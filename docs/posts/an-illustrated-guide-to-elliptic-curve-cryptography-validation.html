<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://research.nccgroup.com/2021/11/18/an-illustrated-guide-to-elliptic-curve-cryptography-validation/">Original</a>
    <h1>An Illustrated Guide to Elliptic Curve Cryptography Validation</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>Elliptic Curve Cryptography (ECC) has become the <em>de facto</em> standard for protecting modern communications. ECC is widely used to perform asymmetric cryptography operations, such as to establish shared secrets or for digital signatures. However, insufficient validation of public keys and parameters is still a frequent cause of confusion, leading to serious vulnerabilities, such as leakage of secret keys, signature malleability or interoperability issues.</p>



<p>The purpose of this blog post is to provide an illustrated description of the typical failures related to elliptic curve validation and how to avoid them in a clear and accessible way. Even though a number of standards<a href="#sec"><sup>1</sup></a><sup>,</sup><a href="#nist"><sup>2</sup></a> mandate these checks, implementations frequently fail to perform them.</p>



<p>While this blog post describes some of the necessary concepts behind elliptic curve arithmetic and cryptographic protocols, it does not cover elliptic curve cryptography in detail, which has already been done extensively. The following blog posts are good resources on the topic: <a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/">A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography</a> by Nick Sullivan and <a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">Elliptic Curve Cryptography: a gentle introduction</a> by Andrea Corbellini.</p>



<p>In elliptic curve cryptography, public keys are frequently sent between parties, for example to establish shared secrets using <a href="https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman">Elliptic curve Diffie–Hellman (ECDH)</a>. The goal of public key validation is to ensure that keys are legitimate (by providing assurance that there is an existing, associated private key) and to circumvent attacks leading to the leakage of some information about the private key of a legitimate user.</p>



<p>Issues related to public key validation seem to routinely occur in two general areas. First, transmitting public keys using digital communication requires to convert them to bytes. However, converting these bytes back to an elliptic curve point is a common source of issues, notably due to <a href="https://en.wikipedia.org/wiki/Canonicalization">canonicalization</a>. Second, once public keys have been decoded, some mathematical subtleties of the elliptic curve operations may also lead to different types of attacks. We will discuss these subtleties in the remainder of this blog post.</p>



<h2 id="tl-dr">TL;DR</h2>



<p>In general<sup><a href="#general">3</a></sup>, vulnerabilities may arise when applications fail to check that:</p>



<ol><li>The point coordinates are lower than the field modulus.</li><li>The coordinates correspond to a valid curve point.</li><li>The point is not the point at infinity.</li><li>The point is in the correct subgroup.</li></ol>



<h2 id="an-illustrated-guide-to-validating-ecc-curve-points">An Illustrated Guide to Validating ECC Curve Points</h2>



<p>Elliptic curves are curves given by an equation of the form <img src="https://s0.wp.com/latex.php?latex=y%5E2+%3D+x%5E3+%2B+ax+%2B+b&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="y^2 = x^3 + ax + b" data-lazy-src="https://s0.wp.com/latex.php?latex=y%5E2+%3D+x%5E3+%2B+ax+%2B+b&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> (called <em>short Weierstrass</em> form). Elliptic curve cryptography deals with the group of points on that elliptic curve, namely, a set of <img src="https://s0.wp.com/latex.php?latex=%28x%2C+y%29&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="(x, y)" data-lazy-src="https://s0.wp.com/latex.php?latex=%28x%2C+y%29&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> values satisfying the curve equation.</p>



<p>These values, called coordinates (more specifically, <em>affine coordinates</em>), are defined over a field. For use in Cryptography, we work with coordinates defined over a <em>finite field</em>. For the purpose of this blog post, we will concentrate our efforts on the field of integers modulo <img src="https://s0.wp.com/latex.php?latex=p&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="p" data-lazy-src="https://s0.wp.com/latex.php?latex=p&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>, with <img src="https://s0.wp.com/latex.php?latex=p&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="p" data-lazy-src="https://s0.wp.com/latex.php?latex=p&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> a prime number (and <img src="https://s0.wp.com/latex.php?latex=p+%3E+3&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="p &gt; 3" data-lazy-src="https://s0.wp.com/latex.php?latex=p+%3E+3&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>), which we call the <em>field modulus</em>. Elements of this field can take any value between <img src="https://s0.wp.com/latex.php?latex=0&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="0" data-lazy-src="https://s0.wp.com/latex.php?latex=0&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> and <img src="https://s0.wp.com/latex.php?latex=p+-+1&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="p - 1" data-lazy-src="https://s0.wp.com/latex.php?latex=p+-+1&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> . In the following figure, the white squares depict valid field elements while grey squares represent the elements that are larger than the field modulus.</p>



<div><figure><img data-attachment-id="13183" data-permalink="https://research.nccgroup.com/2021/11/18/an-illustrated-guide-to-elliptic-curve-cryptography-validation/0-1/" data-orig-file="https://i2.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/0-1.png?fit=410%2C29&amp;ssl=1" data-orig-size="410,29" data-comments-opened="0" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="0-1" data-image-description="" data-image-caption="" data-medium-file="https://i2.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/0-1.png?fit=300%2C21&amp;ssl=1" data-large-file="https://i2.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/0-1.png?fit=410%2C29&amp;ssl=1" loading="lazy" width="410" height="29" src="https://i2.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/0-1.png?resize=410%2C29&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i2.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/0-1.png?w=410&amp;ssl=1 410w, https://i2.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/0-1.png?resize=300%2C21&amp;ssl=1 300w, https://i2.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/0-1.png?resize=400%2C29&amp;ssl=1 400w" data-lazy-sizes="(max-width: 410px) 100vw, 410px" data-lazy-src="https://i2.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/0-1.png?resize=410%2C29&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>



<p>Mathematically, a value larger than the field modulus is equivalent to its reduced form (that is, in the <img src="https://s0.wp.com/latex.php?latex=0&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="0" data-lazy-src="https://s0.wp.com/latex.php?latex=0&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> to <img src="https://s0.wp.com/latex.php?latex=p-1&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="p-1" data-lazy-src="https://s0.wp.com/latex.php?latex=p-1&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> range, see <a href="https://en.wikipedia.org/wiki/Modular_arithmetic#Congruence_classes">congruence classes</a>), but in practice these ambiguities may lead to complex issues<sup><a href="#zcash">4</a></sup>.</p>



<p>    In ECC, a public key is simply a point on the curve. Since curve points are generally first encoded to byte arrays before being transmitted, the first step when receiving an encoded curve point is to decode it. This is what we identified earlier as the first area of confusion and potential source of vulnerabilities. Specifically, what happens when the integer representation of the coordinates we decoded are larger than the field modulus?</p>



<p>This is the first common source of issues and the reason for our first validation rules:</p>



<blockquote><p><em>Check that the point coordinates are lower than the field modulus.</em></p></blockquote>



<p><strong>What can go wrong?</strong> If the recipient does not enforce that coordinates are lower than the field modulus, some elliptic curve point operations may be incorrectly computed. Additionally, different implementations may have diverging interpretations of the validity of a point, possibly leading to interoperability issues, which can be a critical issue in consensus-driven deployments.</p>



<p>In the figure below, this means that the point coordinates should be rejected if they are <em>not</em> in the white area in the bi-dimensional plane.</p>



<div><figure><img data-attachment-id="13184" data-permalink="https://research.nccgroup.com/2021/11/18/an-illustrated-guide-to-elliptic-curve-cryptography-validation/1-1-2/" data-orig-file="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/1-1.png?fit=392%2C392&amp;ssl=1" data-orig-size="392,392" data-comments-opened="0" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="1-1" data-image-description="" data-image-caption="" data-medium-file="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/1-1.png?fit=300%2C300&amp;ssl=1" data-large-file="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/1-1.png?fit=392%2C392&amp;ssl=1" loading="lazy" width="392" height="392" src="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/1-1.png?resize=392%2C392&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/1-1.png?w=392&amp;ssl=1 392w, https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/1-1.png?resize=300%2C300&amp;ssl=1 300w, https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/1-1.png?resize=150%2C150&amp;ssl=1 150w, https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/1-1.png?resize=200%2C200&amp;ssl=1 200w" data-lazy-sizes="(max-width: 392px) 100vw, 392px" data-lazy-src="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/1-1.png?resize=392%2C392&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>



<p>    Since both coordinates are elements of this finite field, it might seem that an elliptic curve point could theoretically take any value in the white area above. However, not all pairs of <img src="https://s0.wp.com/latex.php?latex=%28x%2C+y%29&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="(x, y)" data-lazy-src="https://s0.wp.com/latex.php?latex=%28x%2C+y%29&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> values in this plane are valid curve points; remember that they need to satisfy the curve equation <img src="https://s0.wp.com/latex.php?latex=y%5E2+%3D+x%5E3+%2B+ax+%2B+b&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="y^2 = x^3 + ax + b" data-lazy-src="https://s0.wp.com/latex.php?latex=y%5E2+%3D+x%5E3+%2B+ax+%2B+b&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> in order to be <em>on the curve</em>. We represent the valid curve point in blue in the figure below<sup><a href="#arbitrary">5</a></sup>. The number of points on the curve is referred to as the <em>curve order</em>.</p>



<div><figure><img data-attachment-id="13185" data-permalink="https://research.nccgroup.com/2021/11/18/an-illustrated-guide-to-elliptic-curve-cryptography-validation/2-1-2/" data-orig-file="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/2-1.png?fit=392%2C392&amp;ssl=1" data-orig-size="392,392" data-comments-opened="0" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="2-1" data-image-description="" data-image-caption="" data-medium-file="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/2-1.png?fit=300%2C300&amp;ssl=1" data-large-file="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/2-1.png?fit=392%2C392&amp;ssl=1" loading="lazy" width="392" height="392" src="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/2-1.png?resize=392%2C392&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/2-1.png?w=392&amp;ssl=1 392w, https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/2-1.png?resize=300%2C300&amp;ssl=1 300w, https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/2-1.png?resize=150%2C150&amp;ssl=1 150w, https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/2-1.png?resize=200%2C200&amp;ssl=1 200w" data-lazy-sizes="(max-width: 392px) 100vw, 392px" data-lazy-src="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/2-1.png?resize=392%2C392&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>



<p>This is another common source of issues and where our second validation rule arises:</p>



<blockquote><p><em>Check that the point coordinates correspond to a valid curve point (i.e. that the coordinates satisfy the curve equation).</em></p></blockquote>



<p><strong>What can go wrong?</strong> If the recipient of a public key fails to verify that the point is on the curve, an attacker may be able to perform a so-called <em>invalid curve attack</em><sup><a href="#invalid">6</a></sup>. Some point operations being independent of the value of <img src="https://s0.wp.com/latex.php?latex=b&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="b" data-lazy-src="https://s0.wp.com/latex.php?latex=b&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> in the elliptic curve equation, a malicious peer may carefully select a different curve (by varying the value of <img src="https://s0.wp.com/latex.php?latex=b&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="b" data-lazy-src="https://s0.wp.com/latex.php?latex=b&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>) in which the security is reduced (namely, the discrete logarithm problem is easier than on the original curve). By then sending a point on that new curve (and provided the legitimate peer fails to verify that the point coordinates satisfy the curve equation), the attacker may eventually recover the legitimate peer’s secret.</p>



<p>    In practice, curve points are rarely sent as pairs of coordinates, which we call <em>uncompressed</em>. Indeed, the <img src="https://s0.wp.com/latex.php?latex=y&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="y" data-lazy-src="https://s0.wp.com/latex.php?latex=y&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>-coordinate can be recovered by solving the curve equation for a given <img src="https://s0.wp.com/latex.php?latex=x&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="x" data-lazy-src="https://s0.wp.com/latex.php?latex=x&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>, which is why <em>point compression</em> was developed. Point compression reduces the amount of data to be transmitted by (almost) half, at the cost of a few more operations necessary to solve the curve equation. However, solving the equation for a given <img src="https://s0.wp.com/latex.php?latex=x&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="x" data-lazy-src="https://s0.wp.com/latex.php?latex=x&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> may have different outcomes. It can either result in: </p>







<p>Hence, when compressing a point, an additional byte of data is used to distinguish the correct <img src="https://s0.wp.com/latex.php?latex=y&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="y" data-lazy-src="https://s0.wp.com/latex.php?latex=y&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>-coordinate. Specifically, point encoding (following Section 2.3.3 of <a href="https://www.secg.org/sec1-v2.pdf">SEC 1</a>, works by prepending a byte to the coordinate(s) specifying which encoding rule is used, as follows:</p>



<ul><li>Compressed point: <code>0x02 || x</code> if y is even and <code>0x03 || x</code> if y is odd;</li><li>Uncompressed point: <code>0x04 || x || y</code>.<sup><a href="#hybrid">7</a></sup></li></ul>



<p>Any other value for the first byte should result in the curve point being ignored. Point compression has a significant benefit in that it ensures that the point is on the curve, since in case there is no solution, implementation should reject the point.</p>



<p>    Now, the careful reader may have realized that the set of points in the figure above is incomplete. In order for this set to form a group (in the <a href="https://en.wikipedia.org/wiki/Group_(mathematics)">mathematical sense</a>), and be useful in cryptography, it needs to be supplemented with an additional element, the <em>point at infinity</em>. This point, also called neutral element or additive identity, is the element <img src="https://s0.wp.com/latex.php?latex=%5Cmathcal%7BO%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="\mathcal{O}" data-lazy-src="https://s0.wp.com/latex.php?latex=%5Cmathcal%7BO%7D&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> such that for any point <img src="https://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="P" data-lazy-src="https://s0.wp.com/latex.php?latex=P&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> on our elliptic curve, <img src="https://s0.wp.com/latex.php?latex=P+%2B+%5Cmathcal%7BO%7D+%3D+%5Cmathcal%7BO%7D+%2B+P+%3D+P&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="P + \mathcal{O} = \mathcal{O} + P = P" data-lazy-src="https://s0.wp.com/latex.php?latex=P+%2B+%5Cmathcal%7BO%7D+%3D+%5Cmathcal%7BO%7D+%2B+P+%3D+P&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>. The figure below shows the previous set of points on our arbitrary curve with the addition of the point at infinity, which we (artificially) positioned slightly outside our plane, in the bottom left corner.</p>



<div><figure><img data-attachment-id="13186" data-permalink="https://research.nccgroup.com/2021/11/18/an-illustrated-guide-to-elliptic-curve-cryptography-validation/3-1-2/" data-orig-file="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/3-1.png?fit=392%2C392&amp;ssl=1" data-orig-size="392,392" data-comments-opened="0" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="3-1" data-image-description="" data-image-caption="" data-medium-file="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/3-1.png?fit=300%2C300&amp;ssl=1" data-large-file="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/3-1.png?fit=392%2C392&amp;ssl=1" loading="lazy" width="392" height="392" src="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/3-1.png?resize=392%2C392&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/3-1.png?w=392&amp;ssl=1 392w, https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/3-1.png?resize=300%2C300&amp;ssl=1 300w, https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/3-1.png?resize=150%2C150&amp;ssl=1 150w, https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/3-1.png?resize=200%2C200&amp;ssl=1 200w" data-lazy-sizes="(max-width: 392px) 100vw, 392px" data-lazy-src="https://i1.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/3-1.png?resize=392%2C392&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>



<p>Since the point at infinity is not on the curve, it does not have well-defined <img src="https://s0.wp.com/latex.php?latex=x&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="x" data-lazy-src="https://s0.wp.com/latex.php?latex=x&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> and <img src="https://s0.wp.com/latex.php?latex=y&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="y" data-lazy-src="https://s0.wp.com/latex.php?latex=y&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> coordinates like other curve points. As such, its representation had to be constructed artificially<sup><a href="#structure">8</a></sup>. Standards (such as <a href="https://www.secg.org/sec1-v2.pdf">SEC 1: Elliptic Curve Cryptography</a>) define the encoding of the point at infinity to be a single octet of value zero. Confusingly, implementations sometimes also use other encodings for the point at infinity, such as a number of zero bytes equal to the size of the coordinates.</p>



<p> Implementations sometimes fail to properly distinguish the point at infinity, and this is where our third validation rule comes from:</p>



<blockquote><p><em>Check that the point is not the point at infinity.</em></p></blockquote>



<p><strong>What can go wrong?</strong> Since multiplying the point at infinity by any scalar results in the point at infinity, an adversary may force the result of a key agreement to be zero if the legitimate recipient fails to check that the point received is not the point at infinity. This goes against the principle of <em>contributory behavior</em>, where some protocols require that both parties contribute to the outcome of an operation such as a key exchange. Failure to enforce this check may have additional negative consequences in other protocols.</p>



<p>    Recall that the <em>curve order</em>, say <img src="https://s0.wp.com/latex.php?latex=N&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="N" data-lazy-src="https://s0.wp.com/latex.php?latex=N&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>, corresponds to the number of points on the curve. To make matters more complicated, the group of points on an elliptic curve may be further divided into multiple <em>subgroups</em>. <a href="https://en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory)">Lagrange’s theorem</a> tells us that any subgroup of the group of points on the elliptic curve has an order dividing the order of the original group. Namely, the size (i.e. the number of points) of every subgroup divides the total number of points on the curve.</p>



<p>In cryptography, to ensure that the discrete logarithm problem is hard, curves are selected in such a way that they consist of one subgroup with large, prime order, say <img src="https://s0.wp.com/latex.php?latex=n&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="n" data-lazy-src="https://s0.wp.com/latex.php?latex=n&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>, in which all computations are performed. Some curves (such as the NIST curves<sup><a href="#nistp" data-type="internal" data-id="#nistp">9</a></sup>, or the curve secp256k1<sup><a href="#secp256k1">10</a></sup> used in bitcoin) were carefully designed such that <img src="https://s0.wp.com/latex.php?latex=n+%3D+N&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="n = N" data-lazy-src="https://s0.wp.com/latex.php?latex=n+%3D+N&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>, namely the prime order group in which we perform operations is the full group of points on the elliptic curve. In contrast, the popular Curve25519 has curve order <img src="https://s0.wp.com/latex.php?latex=N+%3D+8n&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="N = 8n" data-lazy-src="https://s0.wp.com/latex.php?latex=N+%3D+8n&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>, which means that points on this curve can belong to the large prime-order subgroup of size <img src="https://s0.wp.com/latex.php?latex=n&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="n" data-lazy-src="https://s0.wp.com/latex.php?latex=n&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>, or to a subgroup with a much smaller order, of size 2, 4 or 8, for example<sup><a href="#taming">11</a></sup>. The value <img src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="h" data-lazy-src="https://s0.wp.com/latex.php?latex=h&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> such that <img src="https://s0.wp.com/latex.php?latex=h+%3D+N%2Fn&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="h = N/n" data-lazy-src="https://s0.wp.com/latex.php?latex=h+%3D+N%2Fn&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> is called the <em>cofactor</em>, it can be thought of as the ratio between the total number of points on the curve and the size of the prime-order subgroup in which cryptographic operations are performed.</p>



<p>To illustrate this notion, consider the figure below in which we have further subdivided our fictitious set of elliptic curve points into two groups. When performing operations on elliptic curve points, we want to stick with operations on points in the larger, prime-order subgroup, identified by the blue points below.</p>



<div><figure><img data-attachment-id="13187" data-permalink="https://research.nccgroup.com/2021/11/18/an-illustrated-guide-to-elliptic-curve-cryptography-validation/4-1-3/" data-orig-file="https://i0.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/4-1.png?fit=392%2C392&amp;ssl=1" data-orig-size="392,392" data-comments-opened="0" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="4-1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/4-1.png?fit=300%2C300&amp;ssl=1" data-large-file="https://i0.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/4-1.png?fit=392%2C392&amp;ssl=1" loading="lazy" width="392" height="392" src="https://i0.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/4-1.png?resize=392%2C392&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/4-1.png?w=392&amp;ssl=1 392w, https://i0.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/4-1.png?resize=300%2C300&amp;ssl=1 300w, https://i0.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/4-1.png?resize=150%2C150&amp;ssl=1 150w, https://i0.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/4-1.png?resize=200%2C200&amp;ssl=1 200w" data-lazy-sizes="(max-width: 392px) 100vw, 392px" data-lazy-src="https://i0.wp.com/research.nccgroup.com/wp-content/uploads/2021/11/4-1.png?resize=392%2C392&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>



<p>And this is where our last validation rule comes from:</p>



<blockquote><p><em>Check that the point is in the correct subgroup.</em></p></blockquote>



<p>This can be achieved by checking that <img src="https://s0.wp.com/latex.php?latex=nP+%3D+%5Cmathcal%7BO%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="nP = \mathcal{O}" data-lazy-src="https://s0.wp.com/latex.php?latex=nP+%3D+%5Cmathcal%7BO%7D&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>. Indeed, a consequence of Lagrange’s theorem is that any group element multiplied by the order of that group is equal to the neutral element. If <img src="https://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="P" data-lazy-src="https://s0.wp.com/latex.php?latex=P&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> were in the small subgroup, multiplying it by <img src="https://s0.wp.com/latex.php?latex=n&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="n" data-lazy-src="https://s0.wp.com/latex.php?latex=n&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/> would not equal <img src="https://s0.wp.com/latex.php?latex=%5Cmathcal%7BO%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="\mathcal{O}" data-lazy-src="https://s0.wp.com/latex.php?latex=%5Cmathcal%7BO%7D&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>. This highlights another possible method for checking that the point belongs to the correct subgroup; one could also check that <img src="https://s0.wp.com/latex.php?latex=hP+%5Cneq+%5Cmathcal%7BO%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="hP \neq \mathcal{O}" data-lazy-src="https://s0.wp.com/latex.php?latex=hP+%5Cneq+%5Cmathcal%7BO%7D&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>. Contrary to the previous validation rules, this check is considerably more expensive since it requires a point multiplication, and as such is sometimes (detrimentally) skipped for efficiency purposes.</p>



<p><strong>What can go wrong?</strong> A malicious party sending a point in the orange subgroup, for example as part of an ECDH key agreement protocol, would result in the honest party performing operations limited to that small subgroup. Thus, if the recipient of a public key failed to check that the point was in the correct subgroup, the attacker could perform a so-called <em>small subgroup attack</em> (also known as subgroup confinement attacks) and learn information about the legitimate party’s private key<sup><a href="#small">12</a></sup>.</p>



<h2 id="does-that-apply-to-all-curves">Does that apply to all curves?</h2>



<p>While the presentation above is fairly generic and applies <em>in a general sense</em> to all curves, some curves and associated constructions were created to prevent some of these issues <em>by design</em>.</p>



<h3 id="nist-curves-e-g-p-256-and-the-bitcoin-curve-secp256k1">NIST curves (e.g. P-256) and the Bitcoin curve (secp256k1)</h3>



<p>These curves have a cofactor value of 1 (namely, <img src="https://s0.wp.com/latex.php?latex=h+%3D+1&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="h = 1" data-lazy-src="https://s0.wp.com/latex.php?latex=h+%3D+1&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>). As such, there is only one large subgroup of prime order and all curve points belong to that group. Hence, once the first 3 steps in our validation procedure have been performed, the last step is superfluous.</p>



<h3 id="curve25519">Curve25519</h3>



<p>Curve25519, proposed by Daniel J. Bernstein and specified in <a href="https://datatracker.ietf.org/doc/html/rfc7748">RFC 7748</a>, is a popular curve which is notably used in TLS 1.3 for key agreement.</p>



<p>Although Curve25519 has a cofactor of 8, some functions using this curve were designed to prevent cofactor-related issues. For example, the X25519 function used to perform key agreement using Curve25519 mandates specific checks and performs key agreement using only <img src="https://s0.wp.com/latex.php?latex=x&amp;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" alt="x" data-lazy-src="https://s0.wp.com/latex.php?latex=x&amp;is-pending-load=1#038;bg=ffffff&amp;fg=000000&amp;s=0&amp;c=20201002" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>-coordinates, such that invalid curve attacks are avoided. Additionally, the governing RFC states in <a href="https://datatracker.ietf.org/doc/html/rfc7748#section-5">Section 5</a> that</p>



<blockquote><p>Implementations MUST accept non-canonical values and process them as if they had been reduced modulo the field prime. The non-canonical values are 2^255 – 19 through 2^255 – 1 for X25519.</p></blockquote>



<p>This seems to address most issues discussed in this post. However, there has been some debate<sup><a href="#debate">13</a></sup> over the claimed optional nature of these checks.</p>



<p>With the popularity of Curve25519 and the desire for cryptographers to design more exotic protocols with it, the cofactor value of 8 resurfaced as a potential source of problems. <a href="https://ristretto.group/">Ristretto</a> was designed as a solution to the cofactor pitfalls. Ristretto is an abstraction layer, on top of Curve25519, which essentially restricts curve points to a prime-order subgroup.</p>



<h3 id="double-odd-elliptic-curves">Double-Odd Elliptic Curves</h3>



<p>Finally, a strong contender in the <em>secure-by-design</em> curve category is the <a href="https://doubleodd.group/">Double-Odd</a> family of elliptic curves, recently proposed by Thomas Pornin. These curves specify a strict and economical encoding, preventing issues with canonicalization and, even though their cofactor is not trivial, a prime order group is defined on them, similar in spirit to Ristretto’s approach, preventing subgroup confinement attacks.</p>



<h2 id="conclusion">Conclusion</h2>



<p>With the ubiquitous use of elliptic curve cryptography, failure to validate elliptic curve points can be a critical issue which is sadly still commonly uncovered during cryptography reviews. While standards and academic publications provide ample directions to correctly validate curve points, implementations still frequently fail to follow these steps. For example, a vulnerability nicknamed <a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2020-0601">Curveball</a> was reported in January 2020, which allowed attacker to perform spoofing attacks in Microsoft Windows by crafting public points. Recently, we also uncovered a critical vulnerability in a number of open-source ECDSA libraries, in which the verification function failed to check that the signature was non-zero, allowing attackers to forge signatures on arbitrary messages, see the technical advisory <a href="https://research.nccgroup.com/2021/11/08/technical-advisory-arbitrary-signature-forgery-in-stark-bank-ecdsa-libraries/">Arbitrary Signature Forgery in Stark Bank ECDSA Libraries</a>.</p>



<p>This illustrated guide will hopefully serve as an accessible reference on why and how point validation should be performed.</p>



<h2 id="thank-you">Thank you</h2>



<p>The author would like to thank Eric Schorn and Giacomo Pope for their detailed review and helpful feedback.</p>



<hr/>



<h2 id="references">References</h2>



<ol><li id="sec"><a href="https://www.secg.org/sec1-v2.pdf">Standards for efficient cryptography, SEC 1: Elliptic Curve Cryptography</a>, Section <em>3.2.2.1 Elliptic Curve Public Key Validation Primitive</em>.</li><li id="nist"><a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf">NIST Special Publication 800-56A</a>, Section <em>5.6.2.3.2 FFC Partial Public-Key Validation Routine</em> and <em>5.6.2.3.3 ECC Full Public-Key Validation Routine</em>.</li><li id="general">That is, unless using an elliptic curve that was designed specifically to address these potential issues, we will come back to that at the end of this blog post.</li><li id="zcash">Specifically, implementations may handle values that are larger than the field modulus in different ways. They may reject non-reduced values (i.e., non-canonical encodings), accept non-reduced values and reduce them modulo the prime order, or accept non-reduced values and discard the most significant bit(s). An interesting example happened with the cryptocurrency Zcash, where different implementations had distinct interpretations regarding the validity of curve points. Some details can be found in a <a href="https://hdevalence.ca/blog/2020-10-04-its-25519am">blog post</a> by Henry de Valence, as well as in a public report following a <a href="https://research.nccgroup.com/wp-content/uploads/2020/09/NCC_Group_Zcash_ZCHX006_Report_2020-09-03_v2.0.pdf">cryptography review</a> performed by NCC Group.</li><li id="arbitrary">Note that this figure does not represent an actual elliptic curve; it is just an arbitrary diagram designed for illustrative purposes.</li><li id="invalid">Ingrid Biehl, Bernd Meyer and Volker Müller. “Differential Fault Attacks on Elliptic Curve Cryptosystems”. In: <em>Advances in Cryptology – CRYPTO 2000, 20th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 2000, Proceedings.</em> 2000, pp. 131–146.</li><li id="hybrid">Note that there is a hybrid form starting in <code>0x06</code> defined in <a href="https://standards.globalspec.com/std/1955141/ANSI%20X9.62">ANSI X9.62</a>, but this format is very rarely used in practice.</li><li id="structure">Note that some curves and alternate point representations (for instance, when working in projective coordinates) may allow the point at infinity to have a well-defined representation.</li><li id="nistp">Standardized in <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">FIPS PUB 186-4: Digital Signature Standard (DSS)</a>.</li><li id="secp256k1">Standardized in <a href="http://www.secg.org/sec2-v2.pdf">SEC 2: Recommended Elliptic Curve Domain Parameters</a>.</li><li id="taming">The paper <a href="https://eprint.iacr.org/2020/1244.pdf">Taming the many EdDSAs</a> provides some very interesting discussions around ambiguities in the Ed25519 signature verification equations (which is based on Curve25519). These ambiguities led to different interpretations of the validity of signatures, which resulted in implementations returning different validity results for some signatures, which could be critical in consensus-driven applications.</li><li id="small">Chae Hoon Lim and Pil Joong Lee. “A Key Recovery Attack on Discrete Log-based Schemes Using a Prime Order Subgroup”. In: <em>Advances in Cryptology – CRYPTO ’97, 17th Annual International Cryptology Conference, Santa Barbara, California, USA, August 17-21, 1997, Proceedings.</em> 1997, pp. 249–263.</li><li id="debate">See <a href="https://moderncrypto.org/mail-archive/curves/2017/000896.html">https://moderncrypto.org/mail-archive/curves/2017/000896.html</a>.</li></ol>








	</div></div>
  </body>
</html>
