<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://i686.me/blog/csplit/">Original</a>
    <h1>Decompiling Xbox games using PDB debug info</h1>
    
    <div id="readability-page-1" class="page"><div>
    
    
    <p>
        26 January, 2026

        
        
        

        
    </p>
    
    
    
<p>In the world of matching decompilation, projects use a tool which consumes an
input binary and lifts objects for comparison and linkage.</p>
<p>Doing this lets them employ a divide and conquer strategy where a game is
reverse engineered, object by object, until the game is buildable, and matches
on a byte or instruction level using fully original code. In the dark ages,
every project started with a disassembly of its target binary. The boundaries
between different object files (&#34;splits&#34;) were determined manually through
heuristics and processes of elimination.</p>
<p>Fast forward some years and the decompilation landscape has developed
considerably. Many different open-source toolkits called splitters exist which
let you establish a decompilation workflow for all sorts of targets. Code is
processed by control flow generation algorithms that lift relocations. You
never deal with disassemblies because the tools write object files for you.</p>
<p><img src="https://i686.me/blog/csplit/dtk.png" alt="decomp toolkit"/></p>

<p>Currently most decomps target 6th and 7th generation PowerPC console games
using decomp-toolkit.</p>
<p>But what if we want to decompile an original Xbox game? Specifically, I&#39;m
working on the PAL debug build of Halo 1, since it has debug symbols in the
form of a Program Database (PDB) file.</p>
<p>The vast majority of x86 reverse engineering projects load a DLL which hooks
functions in the base executable. Nobody has managed instruction level
matching using this, which is something I wanted. And only the debug Xbox
kernels even support loading DLLs (in the form of &#34;debugger extensions.&#34;)</p>
<p>Instead I started looking at splitting tools for x86, of which there were
two solutions: either scripts to postprocess disassemblies or plugins for IDA
Pro and Ghidra that work based on exporting the tools&#39; symbol databases.</p>
<h2 id="section-contributions">Section contributions</h2>
<p>I couldn&#39;t find a tool that actually read the PDBs for splitting. The best
the existing tools could do was use the PDB like a map file to be consumed by
another reverse engineering tool to provide symbolisation.</p>
<p>Using the PDB this way meant that I&#39;d miss out on a lot of information.
The VC++ linker logs the individual sections of input COFF objects being
linked into the output executable to the PDB in the form of
<a rel="external" href="https://github.com/microsoft/pdb-rs/blob/main/pdb/src/dbi/section_contrib.rs#L14-L32">section contributions</a>.</p>
<p>These structures contain:</p>
<ul>
<li>the address of the section in the binary,</li>
<li>the original size and flags (including alignment) of the section,</li>
<li>the specific object the section came from,</li>
<li>and a checksum for the section&#39;s data itself.</li>
</ul>
<p>This is very useful in the context of splitting objects because it&#39;s a record
of how all object files were laid out verbatim!</p>
<p>And they still exist even in stripped PDBs. In my case, I have a stripped PDB,
so I don&#39;t have type info or private symbols for the target. But we can still
automatically enumerate every logical piece of data and code. Compared to
other tools we are no longer guessing the sizes and locations of data symbols
based on auto analysis.</p>

<p>So I wrote my own splitter that uses the section contributions data to create
objects.</p>
<p>My specific target uses Visual C++ 7 beta 2 on the old VC++ 2.00 debug info
format which no-one implements support for, so to read the file I had to modify
the Rust pdb crate. Though, the official Microsoft crate can read these now,
but where&#39;s the fun in that?</p>
<p>Some information we don&#39;t have is names for private symbols or COMDAT data (the
rules for handling duplicate definitions of symbols.) In my case I just ignored
COMDAT except where it is plainly obvious that it was used like for string and
floating point constant deduplication. For nameless section contributions,
having their flags was useful when creating temp names because it lets you
prefix symbols based on their contents, e.g. <code>code_00401234</code>.</p>
<h2 id="control-flow-generation">Control flow generation</h2>
<p>Every decompilation needs to identify all pointers referenced in their binaries.
We have a complete list of all absolute relocations in the binary thanks to the
<code>.reloc</code> section, but nothing about relative relocations for jmp or call.</p>
<p>To lift these relative relocations, you can either make a script to export from
a tool like IDA or you can find them yourself using control flow generation. I
opted for the latter because I wanted to keep the tool self contained.</p>
<h3 id="safeseh">SafeSEH</h3>
<p>Structured Exception Handlers (SEH) are a Microsoft vendor-specific C language
extension that lets you write exception handlers inside functions using <code>__try</code>
and <code>__catch</code> statements.</p>
<p>When entering a <code>__try</code> statement, the compiler generates a structure
containing pointers to the <code>__catch</code> or <code>__finally</code> handlers, which are blocks
in the function. There&#39;s never a direct jump to these handlers, and without
special treatment this is opaque to control flow generation. Hence it failed to
find any catch/finally blocks. I ended up fixing about 130 handlers manually.</p>

<p>Booting into the game the first time it linked immediately booted me back to
the dashboard.</p>
<p>After investigating this I found that the Xbox runtime library was failing to
assign the console&#39;s active cache partition to a drive letter. szCacheDrive
was being formatted to <code>&#34;\Device\Harddisk0\Partitin%d\&#34;</code>, so something must
have broken inside of string formatting.</p>
<p><img src="https://i686.me/blog/csplit/xapi_mount.png" alt="xapi function"/></p>
<h2 id="negative-relocations">Negative relocations</h2>
<p>This turns out to be a failure in the symbolisation of relocation targets
concerning a compiler optimisation. Tracing the error to the internal
libcmt function for applying format strings, <code>_output</code>:</p>
<pre><code>  34:   80 fb 20                cmp    bl,0x20
  37:   7c 12                   jl     4b &lt;__output+0x4b&gt;
  39:   80 fb 78                cmp    bl,0x78
  3c:   7f 0d                   jg     4b &lt;__output+0x4b&gt;
  3e:   0f be c3                movsx  eax,bl
  41:   0f be 80 e0 ff ff ff    movsx  eax,BYTE PTR [eax-0x20]
                        44: dir32       ___lookuptable
</code></pre>
<p><code>___lookuptable</code> is valid for some values above 0x20 (the first valid ASCII
character.) A loop checks if the current character is in bounds, then
dereferences <code>___lookuptable</code> by that character minus 0x20.</p>
<p>Visual C++ optimises away the subtraction by applying a negative offset to the
relocation. In this case the relocation points to 0x20 bytes before
<code>___lookuptable</code>.</p>
<pre><code>RELOCATIONS #18
                                                Symbol    Symbol
 Offset    Type              Applied To         Index     Name
 --------  ----------------  -----------------  --------  ------
 00000044  DIR32                      FFFFFFE0         9  ___lookuptable
 0000004F  DIR32                      00000000         9  ___lookuptable
 00000067  DIR32                      00000000        76  $L9491
 000001EE  DIR32                      00000000        6E  __pctype
 ...
</code></pre>
<p>This means that if you match relocation targets to symbols based on the last
symbol before the target address, you are liable to generate bad relocations
and probably crash the game.</p>
<pre><code>movsx   eax, byte ptr ds:stru_6B5C08.HandlerFunc[eax] ; bad
</code></pre>
<p>Maybe some kind of heuristic could help here. But what I found good enough was
to manually fix it, and after patching a few of these in libcmt and d3d8 the
game made it through init.</p>

<p><img src="https://i686.me/blog/csplit/ida.png" alt="ida debug"/></p>
<p>Unfortunately there are still some bad pointers. The game can&#39;t load into
another map from the menu successfully, and if you idle long enough, the
content streaming thread in the game crashes inside of a kernel export.</p>
<p>I haven&#39;t found the root cause for the crash. The idea is that in the
future we&#39;ll get to all of these just by finding them naturally through the
decompilation process.</p>
<p>There is also the possibility of matching linking so that bad relocations
simply disappear. Hopefully there isn&#39;t undefined behaviour involved with
determining the linker order.</p>
<p><img src="https://i686.me/blog/csplit/pregame.png" alt="pregame menu"/></p>

<p>You can visit the repo for Halo on <a rel="external" href="https://github.com/punpckhdq/halo">GitHub</a>
and the progress tracker at <a rel="external" href="https://decomp.dev/punpckhdq/halo">decomp.dev</a>.</p>
<p>There is a (pretty bad) C object writer tool that the repository is currently
working off of available <a rel="external" href="https://github.com/punpckhdq/csplit">here</a>. In the
future, I&#39;m going to rewrite this to include the CFG step. I swear.</p>

</div></div>
  </body>
</html>
