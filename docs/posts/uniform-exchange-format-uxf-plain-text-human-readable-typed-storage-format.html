<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/mark-summerfield/uxf">Original</a>
    <h1>Uniform eXchange Format (UXF) – plain text human readable typed storage format</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Uniform eXchange Format (UXF) is a plain text human readable optionally
typed storage format that supports custom types.</p>
<p dir="auto">UXF is designed to make life easier for software developers and data
designers. It directly competes with csv, ini, json, toml, and yaml formats.
A key advantage of UXF is its support for custom (i.e., user-defined) types.
This can result in more compact, more readable, and easier to parse data.
And in some contexts it may prove to be a convenient alternative to sqlite
or xml.</p>
<ul dir="auto">
<li><a href="#datatypes">Datatypes</a>
<ul dir="auto">
<li><a href="#table-of-built-in-types">Table of Built-in Types</a></li>
<li><a href="#terminology">Terminology</a></li>
<li><a href="#minimal-empty-uxf">Minimal empty UXF</a></li>
<li><a href="#built-in-types">Built-in Types</a></li>
<li><a href="#custom-types">Custom Types</a></li>
<li><a href="#formatting">Formatting</a></li>
</ul>
</li>
<li><a href="#examples">Examples</a>
<ul dir="auto">
<li><a href="#json">JSON</a></li>
<li><a href="#csv">CSV</a></li>
<li><a href="#toml">TOML</a></li>
<li><a href="#database">Database</a></li>
</ul>
</li>
<li><a href="#libraries">Libraries</a> [<a href="https://github.com/mark-summerfield/uxf/blob/main/py/README.md">Python</a>] [<a href="https://github.com/mark-summerfield/uxf/blob/main/rs/README.md">Rust</a>]
<ul dir="auto">
<li><a href="#implementation-notes">Implementation Notes</a></li>
</ul>
</li>
<li><a href="#imports">Imports</a></li>
<li><a href="#bnf">BNF</a></li>
<li><a href="#supplementary">Supplementary</a>
<ul dir="auto">
<li><a href="#vim-support">Vim Support</a></li>
<li><a href="#uxf-logo">UXF Logo</a></li>
</ul>
</li>
</ul>
<h2 dir="auto"><a id="user-content-datatypes" aria-hidden="true" href="#datatypes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Datatypes</h2>
<p dir="auto">UXF supports the following eleven built-in datatypes.</p>
<table>
<thead>
<tr>
<th><strong>Type</strong><a name="user-content-table-of-built-in-types"></a></th>
<th><strong>Example(s)</strong></th>
<th><strong>Notes</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>null</code></td>
<td><code>?</code></td>
<td><code>?</code> is the UXF <em>null</em> type&#39;s literal representation.</td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>no</code> <code>yes</code></td>
<td>Use <code>no</code> for false and <code>yes</code> for true.</td>
</tr>
<tr>
<td><code>bytes</code></td>
<td><code>(:20AC 65 66 48:)</code></td>
<td>There must be an even number of case-insensitive hex digits; whitespace (spaces, newlines, etc.) optional.</td>
</tr>
<tr>
<td><code>date</code></td>
<td><code>2022-04-01</code></td>
<td>Basic ISO8601 YYYY-MM-DD format.</td>
</tr>
<tr>
<td><code>datetime</code></td>
<td><code>2022-04-01T16:11:51</code></td>
<td>ISO8601 YYYY-MM-DDTHH[:MM[:SS]] format; 1-sec resolution no timezone support (see also <a href="#custom-types">Custom Types</a>).</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>-192</code> <code>+234</code> <code>7891409</code></td>
<td>Standard integers with optional sign.</td>
</tr>
<tr>
<td><code>real</code></td>
<td><code>0.15</code> <code>0.7e-9</code> <code>2245.389</code></td>
<td>Standard and scientific notation.</td>
</tr>
<tr>
<td><code>str</code></td>
<td><code>&lt;Some text which may include newlines&gt;</code></td>
<td>For &amp;, &lt;, &gt;, use &amp;amp;, &amp;lt;, &amp;gt; respectively.</td>
</tr>
<tr>
<td><code>list</code></td>
<td><code>[value1 value2 ... valueN]</code></td>
<td>A list of values of any type.</td>
</tr>
<tr>
<td><code>list</code></td>
<td><code>[vtype value1 value2 ... valueN]</code></td>
<td>A list of values of type <em>vtype</em>.</td>
</tr>
<tr>
<td><code>map</code></td>
<td><code>{key1 value1 key2 value2 ... keyN valueN}</code></td>
<td>A map with keys of any valid key type and values of any type.</td>
</tr>
<tr>
<td><code>map</code></td>
<td><code>{ktype key1 value1 key2 value2 ... keyN valueN}</code></td>
<td>A map with keys of type <em>ktype</em> and values of any type.</td>
</tr>
<tr>
<td><code>map</code></td>
<td><code>{ktype vtype key1 value1 key2 value2 ... keyN valueN}</code></td>
<td>A map with keys of type <em>ktype</em> and values of type <em>vtype</em>.</td>
</tr>
<tr>
<td><code>table</code></td>
<td><code>(ttype &lt;value0_0&gt; ... &lt;value0_N&gt; ... &lt;valueM_0&gt; ... &lt;valueM_N&gt;)</code></td>
<td>A table of values. Each value&#39;s type must be of the corresponding type specified in the <em>ttype</em>, or any value type where no type has been specified.</td>
</tr>
</tbody>
</table>
<p dir="auto">Note that it is also possible to represent <a href="#custom-types">Custom Types</a>.</p>
<h3 dir="auto"><a id="user-content-terminology" aria-hidden="true" href="#terminology"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Terminology</h3>
<ul dir="auto">
<li>A <code>map</code> <em>key-value</em> is collectively called an <em>item</em>.</li>
<li>A “single” valued type (<code>bool</code>, <code>bytes</code>, <code>date</code>, <code>datetime</code>, <code>int</code>,
<code>str</code>), is called a <em>scalar</em>.</li>
<li>A “multi-” valued type (<code>list</code>, <code>map</code>, <code>table</code>) is called a <em>collection</em>.</li>
<li>A <code>list</code>, <code>map</code>, or <code>table</code> which contains only scalar values is called a
scalar <code>list</code>, scalar <code>map</code>, or scalar <code>table</code>, respectively.</li>
<li>A <em><code>ttype</code></em> is the name of a user-defined table type.</li>
</ul>
<h3 dir="auto"><a id="user-content-minimal-empty-uxf" aria-hidden="true" href="#minimal-empty-uxf"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Minimal empty UXF</h3>

<p dir="auto">Every UXF file consists of a single header line (starting <code>uxf 1</code>,
optionally followed by custom text). This may be followed by an optional
file-level comment, then any <em>ttype</em> (table type) imports, then any <em>ttype</em>
definitions. After this comes the data in the form of a single <code>list</code>,
<code>map</code>, or <code>table</code> in which all the values are stored. The data must be
present even if it is merely an empty list (as here), an empty map (e.g.,
<code>{}</code>), or an empty table. Since <code>list</code>s, <code>map</code>s, and <code>table</code>s can be
nested inside each other, the UXF format is extremely flexible.</p>
<h3 dir="auto"><a id="user-content-built-in-types" aria-hidden="true" href="#built-in-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Built-in Types</h3>
<p dir="auto">Map keys (i.e., <em>ktype</em>) may only be of types <code>bytes</code>, <code>date</code>, <code>datetime</code>,
<code>int</code>, and <code>str</code> and may not be null (<code>?</code>).</p>
<p dir="auto">List, map, and table values may be of <em>any</em> type (including nested <code>map</code>s,
<code>list</code>s, and <code>table</code>s), unless constrained to a specific type. If
constrained to a specific <em>vtype</em>, the <em>vtype</em> may be any built-in type (as
listed above, except <code>null</code>), or any user-defined <em>ttype</em>, and the
corresponding value or values must be any valid value for the specified
type, or <code>?</code> (null).</p>
<p dir="auto">Lists and tables preserve the order in which values appear. So the first
value is at index/row 0, the second at index/row 1, etc. Maps are
key-ordered. In particular when two keys are of different types they are
ordered <code>bytes</code> <code>&lt;</code> <code>date</code> <code>&lt;</code> <code>datetime</code> <code>&lt;</code> <code>int</code> <code>&lt;</code> <code>str</code>, and when two
keys have the same types they are ordered using <code>&lt;</code> except for <code>str</code>s
which use case-insensitive <code>&lt;</code>.</p>
<p dir="auto">A <code>table</code> starts with a <em>ttype</em>. Next comes the table&#39;s values. The number
of values in any given row is equal to the number of field names in the
<em>ttype</em>.</p>
<p dir="auto">Lists, maps, tables, and <em>ttype</em> definitions may begin with a comment. And
lists, maps, and tables may optionally by typed as indicated above. (See
also the examples below and the BNF near the end).</p>
<p dir="auto">Strings may not include <code>&amp;</code>, <code>&lt;</code> or <code>&gt;</code>, so if they are needed, they must be
replaced by the XML/HTML escapes <code>&amp;amp;</code>, <code>&amp;lt;</code>, and <code>&amp;gt;</code> respectively.
Strings respect any whitespace they contain, including newlines.</p>
<p dir="auto">Where whitespace is allowed (or required) it may consist of one or more
spaces, tabs, or newlines in any combination.</p>
<p dir="auto">If you don&#39;t want to be committed to a particular UXF type, just use a <code>str</code>
and do whatever conversion you want, or use a <a href="#custom-types">Custom Type</a>.</p>
<h3 dir="auto"><a id="user-content-custom-types" aria-hidden="true" href="#custom-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Custom Types</h3>
<p dir="auto">There are two common approaches to handling custom types in UXF. Both
allow for UXFs to remain round-trip readable and writeable even by UXF
processors that aren&#39;t aware of the use of custom types as such.</p>
<p dir="auto">Here, we&#39;ll look at both approaches for three different custom types, a
point and some constants which we&#39;ll treat as enumerations.</p>
<div data-snippet-clipboard-copy-content="uxf 1
[
  {&lt;Point&gt; [1.4 9.8]} {&lt;Point&gt; [-0.7 3.0]} {&lt;Point&gt; [2.1 -6.3]}
  &lt;TrafficLightGreen&gt; &lt;TrafficLightAmber&gt; &lt;TrafficLightRed&gt;
]"><pre><code>uxf 1
[
  {&lt;Point&gt; [1.4 9.8]} {&lt;Point&gt; [-0.7 3.0]} {&lt;Point&gt; [2.1 -6.3]}
  &lt;TrafficLightGreen&gt; &lt;TrafficLightAmber&gt; &lt;TrafficLightRed&gt;
]
</code></pre></div>
<p dir="auto">This first approach shows three points, each represented by a <code>map</code> with a
<code>str</code> indicating the custom type (“Point”), and using <code>list</code>s of two
<code>real</code>s for the <em>x</em> and <em>y</em> coordinates. The example also shows traffic
light constants each represented by a <code>str</code>.</p>
<div data-snippet-clipboard-copy-content="uxf 1
[
  {&lt;Point&gt; [1.4 9.8 -0.7 3.0 2.1 -6.3]}
  &lt;TrafficLightGreen&gt; &lt;TrafficLightAmber&gt; &lt;TrafficLightRed&gt;
]"><pre><code>uxf 1
[
  {&lt;Point&gt; [1.4 9.8 -0.7 3.0 2.1 -6.3]}
  &lt;TrafficLightGreen&gt; &lt;TrafficLightAmber&gt; &lt;TrafficLightRed&gt;
]
</code></pre></div>
<p dir="auto">Since we have multiple points we&#39;ve changed to a single <code>map</code> with a <code>list</code>
of point values. This is more compact but assumes that the reading
application knows that points come in pairs.</p>
<p dir="auto">A UXF processor has no knowledge of these representations of points or
constants (or constants used as enumerations), but will handle both
seamlessly since they are both represented in terms of built-in UXF types.
Nonetheless, an application that reads such UXF data can recognize and
convert to and from these representations to and from the actual types.</p>
<div data-snippet-clipboard-copy-content="uxf 1
=Point x:real y:real
=TrafficLightGreen
=TrafficLightAmber
=TrafficLightRed
[
  (Point 1.4 9.8 -0.7 3.0 2.1 -6.3)
  (TrafficLightGreen) (TrafficLightAmber) (TrafficLightRed)
]"><pre><code>uxf 1
=Point x:real y:real
=TrafficLightGreen
=TrafficLightAmber
=TrafficLightRed
[
  (Point 1.4 9.8 -0.7 3.0 2.1 -6.3)
  (TrafficLightGreen) (TrafficLightAmber) (TrafficLightRed)
]
</code></pre></div>
<p dir="auto">This second approach uses four <em>ttypes</em> (custom table types). For the Point
we specify it as having two real fields (so the processor now knows that
Points have two <code>real</code> values). And for the enumeration we used three
separate fieldless tables, i.e., three constants.</p>
<p dir="auto">Using tables has the advantage that we can represent any number of values of
a particular <em>ttype</em> in a single table (including just one, or even none),
thus cutting down on repetitive text. Here, the Point table has three Points
(rows). And some UXF processor libraries will be able to return table values
as custom types. (For example, the <a href="https://github.com/mark-summerfield/uxf/blob/main/py/README.md">Python UXF library</a> would
return these as custom class instances—as “editable tuples”.)</p>
<p dir="auto">If many applications need to use the same <em>ttypes</em>, it <em>may</em> make sense to
create some shared <em>ttype</em> definitions. See <a href="#imports">Imports</a> for how to
do this.</p>
<h3 dir="auto"><a id="user-content-formatting" aria-hidden="true" href="#formatting"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Formatting</h3>
<p dir="auto">A UXF file&#39;s header must always occupy its own line (i.e., end with a
newline). The rest of the file could in theory be a single line no matter
how long. In practice and for human readability it is normal to limit the
width of lines, for example, to 76, 80, or the UXF default of 96 characters.</p>
<p dir="auto">A UXF processor is expected to provide formatting options for pretty
printing UXF files with user defined indentation, wrap width, and real
number formatting.</p>
<p dir="auto">UXF <code>bytes</code> and <code>str</code>s can be of any length, but nonetheless they can be
width-limited without changing their semantics.</p>
<h4 dir="auto"><a id="user-content-bytes" aria-hidden="true" href="#bytes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Bytes</h4>
<p dir="auto">Any <code>bytes</code> value may be written with any amount of whitespace including
newlines—with all the whitespace ignored. For example:</p>
<div data-snippet-clipboard-copy-content="(:AB DE 01 57:) ≣ (:ABDE0157:)"><pre><code>(:AB DE 01 57:) ≣ (:ABDE0157:)
</code></pre></div>
<p dir="auto">This makes it is easy to convert a <code>bytes</code> that is too long into chunks,
e.g.,</p>
<div data-snippet-clipboard-copy-content="(:20 AC 40 41 ... lots more ... FF FE:)"><pre><code>(:20 AC 40 41 ... lots more ... FF FE:)
</code></pre></div>
<p dir="auto">to, say:</p>
<div data-snippet-clipboard-copy-content="(:20 AC 40 41
... some more ...
... some more ...
FF FE:)"><pre><code>(:20 AC 40 41
... some more ...
... some more ...
FF FE:)
</code></pre></div>
<h4 dir="auto"><a id="user-content-strings" aria-hidden="true" href="#strings"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Strings</h4>
<p dir="auto">Because UXF strings respect any whitespace they contain they cannot be split
into chunks like <code>bytes</code>. However, UXF supports a string concatenation
operator such that:</p>
<div data-snippet-clipboard-copy-content="&lt;This is one string&gt; ≣ &lt;This &gt; &amp; &lt;is one &gt; &amp; &lt;string&gt;"><pre><code>&lt;This is one string&gt; ≣ &lt;This &gt; &amp; &lt;is one &gt; &amp; &lt;string&gt;
</code></pre></div>
<p dir="auto">Which means, of course, that given a long string that might not contain
newlines or whose lines are too long, we can easily split it into chunks,
e.g.,</p>
<div data-snippet-clipboard-copy-content="&lt;Imagine this is a really long string...&gt;"><pre><code>&lt;Imagine this is a really long string...&gt;
</code></pre></div>
<p dir="auto">to, say:</p>
<div data-snippet-clipboard-copy-content="&lt;Imagine &gt; &amp;
&lt;this is a &gt; &amp;
&lt;really long &gt; &amp;
&lt;string...&gt;"><pre><code>&lt;Imagine &gt; &amp;
&lt;this is a &gt; &amp;
&lt;really long &gt; &amp;
&lt;string...&gt;
</code></pre></div>
<p dir="auto">Comments work the same way, but note that the comment marker must only
precede the <em>first</em> fragment.</p>
<div data-snippet-clipboard-copy-content="#&lt;This is a comment in one or more strings.&gt; ≣ #&lt;This is a &gt; &amp; &lt;comment in &gt; &amp; &lt;one or more&gt; &amp; &lt; strings.&gt;"><pre><code>#&lt;This is a comment in one or more strings.&gt; ≣ #&lt;This is a &gt; &amp; &lt;comment in &gt; &amp; &lt;one or more&gt; &amp; &lt; strings.&gt;
</code></pre></div>
<h2 dir="auto"><a id="user-content-examples" aria-hidden="true" href="#examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Examples</h2>
<h3 dir="auto"><a id="user-content-minimal-uxfs" aria-hidden="true" href="#minimal-uxfs"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Minimal UXFs</h3>

<p dir="auto">We saw earlier an example of a minimal UXF file with an empty list; here we
have one with an empty map.</p>
<div data-snippet-clipboard-copy-content="uxf 1
=Pair first second
(Pair)"><pre><code>uxf 1
=Pair first second
(Pair)
</code></pre></div>
<p dir="auto">Here is a UXF with a <em>ttype</em> specifying a Pair that has two fields each of
which can hold <em>any</em> UXF value (including nested collections). In this case
the data is a single <em>empty</em> Pair table.</p>
<div data-snippet-clipboard-copy-content="uxf 1
=Pair first second
(Pair (Pair 1 2) (Pair 3 (Pair 4 5)))"><pre><code>uxf 1
=Pair first second
(Pair (Pair 1 2) (Pair 3 (Pair 4 5)))
</code></pre></div>
<p dir="auto">And here is a UXF with a single Pair table that contains two nested Pair
tables, the second of which itself contains a nested pair.</p>
<h2 dir="auto"><a id="user-content-json" aria-hidden="true" href="#json"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>JSON</h2>
<p dir="auto">JSON is a very widely used format, but unlike UXF it lacks user-defined
types. Here&#39;s an example of GeoJSON data from Wikipedia:</p>
<div data-snippet-clipboard-copy-content="{
&#34;type&#34;: &#34;FeatureCollection&#34;,
&#34;features&#34;: [
    {
    &#34;type&#34;: &#34;Feature&#34;,
    &#34;geometry&#34;: {
        &#34;type&#34;: &#34;Point&#34;,
        &#34;coordinates&#34;: [102.0, 0.5]
    },
    &#34;properties&#34;: {
        &#34;prop0&#34;: &#34;value0&#34;
    }
    },
    {
    &#34;type&#34;: &#34;Feature&#34;,
    &#34;geometry&#34;: {
        &#34;type&#34;: &#34;LineString&#34;,
        &#34;coordinates&#34;: [
        [102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0]
        ]
    },
    &#34;properties&#34;: {
        &#34;prop0&#34;: &#34;value0&#34;,
        &#34;prop1&#34;: 0.0
    }
    },
    {
    &#34;type&#34;: &#34;Feature&#34;,
    &#34;geometry&#34;: {
        &#34;type&#34;: &#34;Polygon&#34;,
        &#34;coordinates&#34;: [
        [
            [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
            [100.0, 1.0], [100.0, 0.0]
        ]
        ]
    },
    &#34;properties&#34;: {
        &#34;prop0&#34;: &#34;value0&#34;,
        &#34;prop1&#34;: { &#34;this&#34;: &#34;that&#34; }
    }
    }
]
}"><pre><code>{
&#34;type&#34;: &#34;FeatureCollection&#34;,
&#34;features&#34;: [
    {
    &#34;type&#34;: &#34;Feature&#34;,
    &#34;geometry&#34;: {
        &#34;type&#34;: &#34;Point&#34;,
        &#34;coordinates&#34;: [102.0, 0.5]
    },
    &#34;properties&#34;: {
        &#34;prop0&#34;: &#34;value0&#34;
    }
    },
    {
    &#34;type&#34;: &#34;Feature&#34;,
    &#34;geometry&#34;: {
        &#34;type&#34;: &#34;LineString&#34;,
        &#34;coordinates&#34;: [
        [102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0]
        ]
    },
    &#34;properties&#34;: {
        &#34;prop0&#34;: &#34;value0&#34;,
        &#34;prop1&#34;: 0.0
    }
    },
    {
    &#34;type&#34;: &#34;Feature&#34;,
    &#34;geometry&#34;: {
        &#34;type&#34;: &#34;Polygon&#34;,
        &#34;coordinates&#34;: [
        [
            [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
            [100.0, 1.0], [100.0, 0.0]
        ]
        ]
    },
    &#34;properties&#34;: {
        &#34;prop0&#34;: &#34;value0&#34;,
        &#34;prop1&#34;: { &#34;this&#34;: &#34;that&#34; }
    }
    }
]
}
</code></pre></div>
<p dir="auto">It would be easy to “translate” this directly into UXF:</p>
<div data-snippet-clipboard-copy-content="uxf 1
{
&lt;type&gt;: &lt;FeatureCollection&gt;,
&lt;features&gt;: [
    {
    &lt;type&gt;: &lt;Feature&gt;,
    &lt;geometry&gt;: {
        &lt;type&gt;: &lt;Point&gt;,
        &lt;coordinates&gt;: [102.0, 0.5]
    },
    &lt;properties&gt;: {
        &lt;prop0&gt;: &lt;value0&gt;
    }
    ..."><pre><code>uxf 1
{
&lt;type&gt;: &lt;FeatureCollection&gt;,
&lt;features&gt;: [
    {
    &lt;type&gt;: &lt;Feature&gt;,
    &lt;geometry&gt;: {
        &lt;type&gt;: &lt;Point&gt;,
        &lt;coordinates&gt;: [102.0, 0.5]
    },
    &lt;properties&gt;: {
        &lt;prop0&gt;: &lt;value0&gt;
    }
    ...
</code></pre></div>
<p dir="auto">Naturally this works, but doesn&#39;t take advantage of any of UXF&#39;s benefits.</p>
<p dir="auto">Here&#39;s a more realistic possible UXF alternative:</p>
<div data-snippet-clipboard-copy-content="uxf 1
=Feature geometry properties:map
=LineString x:real y:real
=Point x:real y:real
=Polygon x:real y:real
(Feature
    (Point 102.0 0.5) {&lt;prop0&gt; &lt;value0&gt;}
    (LineString 102.0 0.0 103.0 1.0 104.0 0.0 105.0 1.0)
                {&lt;prop0&gt; &lt;value0&gt; &lt;prop1&gt; 0.0}
    (Polygon 100.0 0.0 101.0 0.0 101.0 1.0 100.0 1.0 100.0 0.0)
                {&lt;prop0&gt; &lt;value0&gt; &lt;prop1&gt; {&lt;this&gt; &lt;that&gt;}}
)"><pre><code>uxf 1
=Feature geometry properties:map
=LineString x:real y:real
=Point x:real y:real
=Polygon x:real y:real
(Feature
    (Point 102.0 0.5) {&lt;prop0&gt; &lt;value0&gt;}
    (LineString 102.0 0.0 103.0 1.0 104.0 0.0 105.0 1.0)
                {&lt;prop0&gt; &lt;value0&gt; &lt;prop1&gt; 0.0}
    (Polygon 100.0 0.0 101.0 0.0 101.0 1.0 100.0 1.0 100.0 0.0)
                {&lt;prop0&gt; &lt;value0&gt; &lt;prop1&gt; {&lt;this&gt; &lt;that&gt;}}
)
</code></pre></div>
<p dir="auto">We don&#39;t need a FeatureCollection because UXF tables can accept zero or more
values, so a Feature table is sufficient.</p>
<p dir="auto">Here&#39;s a last JSON alternative, this time avoiding the duplication of
<code>x:real</code> and <code>y:real</code>:</p>
<div data-snippet-clipboard-copy-content="uxf 1
=Feature geometry properties:map
=LineString points:Point
=Point x:real y:real
=Polygon points:Point
(Feature
(Point 102.0 0.5) {&lt;prop0&gt; &lt;value0&gt;}
(LineString (Point 102.0 0.0 103.0 1.0 104.0 0.0 105.0 1.0))
            {&lt;prop0&gt; &lt;value0&gt; &lt;prop1&gt; 0.0}
(Polygon (Point 100.0 0.0 101.0 0.0 101.0 1.0 100.0 1.0 100.0 0.0))
         {&lt;prop0&gt; &lt;value0&gt; &lt;prop1&gt; {&lt;this&gt; &lt;that&gt;}}
)"><pre><code>uxf 1
=Feature geometry properties:map
=LineString points:Point
=Point x:real y:real
=Polygon points:Point
(Feature
(Point 102.0 0.5) {&lt;prop0&gt; &lt;value0&gt;}
(LineString (Point 102.0 0.0 103.0 1.0 104.0 0.0 105.0 1.0))
            {&lt;prop0&gt; &lt;value0&gt; &lt;prop1&gt; 0.0}
(Polygon (Point 100.0 0.0 101.0 0.0 101.0 1.0 100.0 1.0 100.0 0.0))
         {&lt;prop0&gt; &lt;value0&gt; &lt;prop1&gt; {&lt;this&gt; &lt;that&gt;}}
)
</code></pre></div>
<p dir="auto">This seems like the clearest solution.</p>
<h3 dir="auto"><a id="user-content-csv" aria-hidden="true" href="#csv"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>CSV</h3>
<p dir="auto">Although widely used, the CSV format is not standardized and has a number of
problems. UXF is a standardized alternative that can distinguish fieldnames
from data rows, can handle multiline text (including text with commas and
quotes) without formality, and can store one—or more—tables in a single UXF
file.</p>
<p dir="auto">Here&#39;s a simple CSV file:</p>
<div data-snippet-clipboard-copy-content="Date,Price,Quantity,ID,Description
&#34;2022-09-21&#34;,3.99,2,&#34;CH1-A2&#34;,&#34;Chisels (pair), 1in &amp; 1¼in&#34;
&#34;2022-10-02&#34;,4.49,1,&#34;HV2-K9&#34;,&#34;Hammer, 2lb&#34;
&#34;2022-10-02&#34;,5.89,1,&#34;SX4-D1&#34;,&#34;Eversure Sealant, 13-floz&#34;"><pre><code>Date,Price,Quantity,ID,Description
&#34;2022-09-21&#34;,3.99,2,&#34;CH1-A2&#34;,&#34;Chisels (pair), 1in &amp; 1¼in&#34;
&#34;2022-10-02&#34;,4.49,1,&#34;HV2-K9&#34;,&#34;Hammer, 2lb&#34;
&#34;2022-10-02&#34;,5.89,1,&#34;SX4-D1&#34;,&#34;Eversure Sealant, 13-floz&#34;
</code></pre></div>
<p dir="auto">Like with JSON we could simply “translate” this directly into UXF as a list
of lists. But doing so would leave us with the same problem as <code>.csv</code> files:
is the first row data values or column titles? (For software this isn&#39;t
always obvious, for example, if all the values are strings.) Even so, this
is still an improvement, since unlike the <code>.csv</code> representation, every value
would have a concrete type (all <code>str</code>s for the first row, and <code>date</code>,
<code>real</code>, <code>int</code>, <code>str</code>, <code>str</code>, for the subsequent rows).</p>
<p dir="auto">The most <em>appropriate</em> UXF equivalent is to use a UXF <code>table</code>:</p>
<div data-snippet-clipboard-copy-content="uxf 1
=PriceList Date Price Quantity ID Description
(PriceList
  2022-09-21 3.99 2 &lt;CH1-A2&gt; &lt;Chisels (pair), 1in &amp;amp; 1¼in&gt; 
  2022-10-02 4.49 1 &lt;HV2-K9&gt; &lt;Hammer, 2lb&gt; 
  2022-10-02 5.89 1 &lt;SX4-D1&gt; &lt;Eversure Sealant, 13-floz&gt; 
)"><pre><code>uxf 1
=PriceList Date Price Quantity ID Description
(PriceList
  2022-09-21 3.99 2 &lt;CH1-A2&gt; &lt;Chisels (pair), 1in &amp;amp; 1¼in&gt; 
  2022-10-02 4.49 1 &lt;HV2-K9&gt; &lt;Hammer, 2lb&gt; 
  2022-10-02 5.89 1 &lt;SX4-D1&gt; &lt;Eversure Sealant, 13-floz&gt; 
)
</code></pre></div>
<p dir="auto">When one or more tables are used each one&#39;s <em>ttype</em> (table type) must be
defined at the start of the <code>.uxf</code> file. A <em>ttype</em> definition begins with an
<code>=</code> sign followed by the <em>ttype</em> (i.e., the table name), followed by zero or
more fields. A field consists of a name optionally followed by a <code>:</code> and
then a type (here only names are given).</p>
<p dir="auto">Both table and field names are user chosen and consist of 1-60 letters,
digits, or underscores, starting with a letter or underscore. No table or
field name may be the same as any built-in type name, so no table or field
can be called <code>bool</code>, <code>bytes</code>, <code>date</code>, <code>datetime</code>, <code>int</code>, <code>list</code>, <code>map</code>,
<code>null</code>, <code>real</code>, <code>str</code>, or <code>table</code>. (But <code>Date</code>, <code>DateTime</code>, and <code>Real</code> or
<code>real_</code> are fine, since names are case-sensitive and none of the built-in
types contains an underscore or uses uppercase letters.) If whitespace is
wanted one convention is to use underscores in their place.</p>
<p dir="auto">Once we have defined a <em>ttype</em> we can use it.</p>
<p dir="auto">Here, we&#39;ve created a single table whose <em>ttype</em> is “PriceList”. There&#39;s no
need to group rows into lines as we&#39;ve done here (although doing so is
common and easier for human readability), since the UXF processor knows how
many values go into each row based on the number of field names. In this
example, the UXF processor will treat every five values as a single record
(row) since the <em>ttype</em> has five fields.</p>
<p dir="auto">This is already an improvement on <code>.csv</code>—we know the table&#39;s name and field
names, and could easily store two or more tables (as we&#39;ll see later).
Although the UXF processor will correctly determine the field types, what if
we want to constrain each field&#39;s value to a particular type?</p>
<div data-snippet-clipboard-copy-content="uxf 1 Price List
=PriceList Date:date Price:real Quantity:int ID:str Description:str
(PriceList
  2022-09-21 3.99 2 &lt;CH1-A2&gt; &lt;Chisels (pair), 1in &amp;amp; 1¼in&gt; 
  2022-10-02 4.49 1 &lt;HV2-K9&gt; &lt;Hammer, 2lb&gt; 
  2022-10-02 5.89 1 &lt;SX4-D1&gt; &lt;Eversure Sealant, 13-floz&gt; 
)"><pre><code>uxf 1 Price List
=PriceList Date:date Price:real Quantity:int ID:str Description:str
(PriceList
  2022-09-21 3.99 2 &lt;CH1-A2&gt; &lt;Chisels (pair), 1in &amp;amp; 1¼in&gt; 
  2022-10-02 4.49 1 &lt;HV2-K9&gt; &lt;Hammer, 2lb&gt; 
  2022-10-02 5.89 1 &lt;SX4-D1&gt; &lt;Eversure Sealant, 13-floz&gt; 
)
</code></pre></div>
<p dir="auto">Here we&#39;ve added a custom file description in the header, and we&#39;ve also
added field types to the <em>ttype</em> definition. When types are specified, the
UXF processor is expected to be able to check that each value is of the
correct type. Omit the type altogether (as in the earliler examples) to
indicate <em>any</em> valid table type.</p>
<h2 dir="auto"><a id="user-content-toml" aria-hidden="true" href="#toml"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>TOML</h2>
<p dir="auto">Here is a TOML example from the TOML website and Wikipedia:</p>
<div data-snippet-clipboard-copy-content="# This is a TOML document.

title = &#34;TOML Example&#34;

[owner]
name = &#34;Tom Preston-Werner&#34;
dob = 1979-05-27T07:32:00-08:00 # First class dates

[database]
server = &#34;192.168.1.1&#34;
ports = [ 8000, 8001, 8002 ]
connection_max = 5000
enabled = true

[servers]

    # Indentation (tabs and/or spaces) is allowed but not required
    [servers.alpha]
    ip = &#34;10.0.0.1&#34;
    dc = &#34;eqdc10&#34;

    [servers.beta]
    ip = &#34;10.0.0.2&#34;
    dc = &#34;eqdc10&#34;

[clients]
data = [ [&#34;gamma&#34;, &#34;delta&#34;], [1, 2] ]

# Line breaks are OK when inside arrays
hosts = [
&#34;alpha&#34;,
&#34;omega&#34;
]"><pre><code># This is a TOML document.

title = &#34;TOML Example&#34;

[owner]
name = &#34;Tom Preston-Werner&#34;
dob = 1979-05-27T07:32:00-08:00 # First class dates

[database]
server = &#34;192.168.1.1&#34;
ports = [ 8000, 8001, 8002 ]
connection_max = 5000
enabled = true

[servers]

    # Indentation (tabs and/or spaces) is allowed but not required
    [servers.alpha]
    ip = &#34;10.0.0.1&#34;
    dc = &#34;eqdc10&#34;

    [servers.beta]
    ip = &#34;10.0.0.2&#34;
    dc = &#34;eqdc10&#34;

[clients]
data = [ [&#34;gamma&#34;, &#34;delta&#34;], [1, 2] ]

# Line breaks are OK when inside arrays
hosts = [
&#34;alpha&#34;,
&#34;omega&#34;
]
</code></pre></div>
<p dir="auto">And here&#39;s a possible UXF alternative:</p>
<div data-snippet-clipboard-copy-content="uxf 1
#&lt;UXF version of TOML Example&gt;
=Clients a b
=Database server:str ports:list connection_max:int enabled:bool
=DateTime when:datetime tz:str
=Owner name:str dob:DateTime
=Server name:str ip:str dc:str
=Hosts name:str
[
  (Owner &lt;Tom Preston-Werner&gt; (DateTime 1979-05-27T07:32:00 &lt;-08:00&gt;))
  (Database &lt;192.168.1.1&gt; [8000 8001 8002] 5000 yes)
  (Server &lt;alpha&gt; &lt;10.0.0.1&gt; &lt;eqdc10&gt;
          &lt;beta&gt; &lt;10.0.0.2&gt; &lt;eqdc10&gt;)
  (Clients &lt;gamma&gt; &lt;delta&gt; 1 2)
  (Hosts
    &lt;alpha&gt;
    &lt;omega&gt;)
]"><pre><code>uxf 1
#&lt;UXF version of TOML Example&gt;
=Clients a b
=Database server:str ports:list connection_max:int enabled:bool
=DateTime when:datetime tz:str
=Owner name:str dob:DateTime
=Server name:str ip:str dc:str
=Hosts name:str
[
  (Owner &lt;Tom Preston-Werner&gt; (DateTime 1979-05-27T07:32:00 &lt;-08:00&gt;))
  (Database &lt;192.168.1.1&gt; [8000 8001 8002] 5000 yes)
  (Server &lt;alpha&gt; &lt;10.0.0.1&gt; &lt;eqdc10&gt;
          &lt;beta&gt; &lt;10.0.0.2&gt; &lt;eqdc10&gt;)
  (Clients &lt;gamma&gt; &lt;delta&gt; 1 2)
  (Hosts
    &lt;alpha&gt;
    &lt;omega&gt;)
]
</code></pre></div>
<p dir="auto">The main differences from <code>.toml</code> are that UXF quotes strings using
<code>&lt;&gt;</code>s, and uses <code>yes</code> and <code>no</code> for <code>bool</code>s. UXF doesn&#39;t require the
use of indentation, but UXF processors default to using it for pretty
printing.</p>
<p dir="auto">Unlike TOML, UXF doesn&#39;t natively support timezones, so we&#39;ve created a
DateTime <em>ttype</em> which has a when datetime and a timezone offset. For
Clients the data will come in pairs because we&#39;ve specified two fields.
Although written compactly, we could have newlines wherever whitespace is
required—or optional.</p>
<p dir="auto">There are many similar formats, including <code>.conf</code>, <code>.ini</code>, and
<code>.yaml</code>, all of which can easily be advantageously translated into UXF.</p>
<h3 dir="auto"><a id="user-content-database" aria-hidden="true" href="#database"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Database</h3>
<p dir="auto">Database files aren&#39;t normally human readable and usually require
specialized tools to read and modify their contents. Yet many databases are
relatively small (both in size and number of tables), and would be more
convenient to work with if human readable. For these, UXF format provides a
viable alternative.</p>
<p dir="auto">A UXF equivalent to a database of tables can easily be created using a
<code>list</code> of <code>table</code>s:</p>
<div data-snippet-clipboard-copy-content="uxf 1 MyApp Data
=Customers CID Company Address Contact Email
=Invoices INUM CID Raised_Date Due_Date Paid Description
=Items IID INUM Delivery_Date Unit_Price Quantity Description
[#&lt;There is a 1:M relationship between the Invoices and Items tables&gt;
  (Customers
    50 &lt;Best People&gt; &lt;123 Somewhere&gt; &lt;John Doe&gt; &lt;j@doe.com&gt; 
    19 &lt;Supersuppliers&gt; ? &lt;Jane Doe&gt; &lt;jane@super.com&gt; 
  )
  (Invoices
    152 50 2022-01-17 2022-02-17 no &lt;COD&gt; 
    153 19 2022-01-19 2022-02-19 yes &lt;&gt; 
  )
  (Items
    1839 152 2022-01-16 29.99 2 &lt;Bales of hay&gt; 
    1840 152 2022-01-16 5.98 3 &lt;Straps&gt; 
    1620 153 2022-01-19 11.5 1 &lt;Washers (1-in)&gt; 
  )
]"><pre><code>uxf 1 MyApp Data
=Customers CID Company Address Contact Email
=Invoices INUM CID Raised_Date Due_Date Paid Description
=Items IID INUM Delivery_Date Unit_Price Quantity Description
[#&lt;There is a 1:M relationship between the Invoices and Items tables&gt;
  (Customers
    50 &lt;Best People&gt; &lt;123 Somewhere&gt; &lt;John Doe&gt; &lt;j@doe.com&gt; 
    19 &lt;Supersuppliers&gt; ? &lt;Jane Doe&gt; &lt;jane@super.com&gt; 
  )
  (Invoices
    152 50 2022-01-17 2022-02-17 no &lt;COD&gt; 
    153 19 2022-01-19 2022-02-19 yes &lt;&gt; 
  )
  (Items
    1839 152 2022-01-16 29.99 2 &lt;Bales of hay&gt; 
    1840 152 2022-01-16 5.98 3 &lt;Straps&gt; 
    1620 153 2022-01-19 11.5 1 &lt;Washers (1-in)&gt; 
  )
]
</code></pre></div>
<p dir="auto">Here we have a <code>list</code> of <code>table</code>s representing three database tables.
The <code>list</code> begins with a comment.</p>
<p dir="auto">Notice that the second customer has a null (<code>?</code>) address and the second
invoice has an empty description.</p>
<div data-snippet-clipboard-copy-content="uxf 1 MyApp Data
#&lt;It is also possible to have one overall comment at the beginning,
after the uxf header and before any ttype definitions or the data.&gt;
=Customers CID:int Company:str Address:str Contact:str Email:str
=Invoices INUM:int CID:int Raised_Date:date Due_Date:date Paid:bool Description:str
=Items IID:int INUM:int Delivery_Date:date Unit_Price:real Quantity:int Description:str
[#&lt;There is a 1:M relationship between the Invoices and Items tables&gt;
  (Customers
    50 &lt;Best People&gt; &lt;123 Somewhere&gt; &lt;John Doe&gt; &lt;j@doe.com&gt; 
    19 &lt;Supersuppliers&gt; ? &lt;Jane Doe&gt; &lt;jane@super.com&gt; 
  )
  (Invoices
    152 50 2022-01-17 2022-02-17 no &lt;COD&gt; 
    153 19 2022-01-19 2022-02-19 yes &lt;&gt; 
  )
  (Items
    1839 152 2022-01-16 29.99 2 &lt;Bales of hay&gt; 
    1840 152 2022-01-16 5.98 3 &lt;Straps&gt; 
    1620 153 2022-01-19 11.5 1 &lt;Washers (1-in)&gt; 
  )
]"><pre><code>uxf 1 MyApp Data
#&lt;It is also possible to have one overall comment at the beginning,
after the uxf header and before any ttype definitions or the data.&gt;
=Customers CID:int Company:str Address:str Contact:str Email:str
=Invoices INUM:int CID:int Raised_Date:date Due_Date:date Paid:bool Description:str
=Items IID:int INUM:int Delivery_Date:date Unit_Price:real Quantity:int Description:str
[#&lt;There is a 1:M relationship between the Invoices and Items tables&gt;
  (Customers
    50 &lt;Best People&gt; &lt;123 Somewhere&gt; &lt;John Doe&gt; &lt;j@doe.com&gt; 
    19 &lt;Supersuppliers&gt; ? &lt;Jane Doe&gt; &lt;jane@super.com&gt; 
  )
  (Invoices
    152 50 2022-01-17 2022-02-17 no &lt;COD&gt; 
    153 19 2022-01-19 2022-02-19 yes &lt;&gt; 
  )
  (Items
    1839 152 2022-01-16 29.99 2 &lt;Bales of hay&gt; 
    1840 152 2022-01-16 5.98 3 &lt;Straps&gt; 
    1620 153 2022-01-19 11.5 1 &lt;Washers (1-in)&gt; 
  )
]
</code></pre></div>
<p dir="auto">Here, we&#39;ve added types to each table&#39;s <em>ttype</em>.</p>
<p dir="auto">It is conventional in a database to have IDs and foreign keys. But these can
often be avoided by using hierarchical data. For example:</p>
<div data-snippet-clipboard-copy-content="uxf 1 MyApp Data
#&lt;There is a 1:M relationship between the Invoices and Items tables&gt;
=Database customers:Customers invoices:Invoices
=Customers CID:int Company:str Address:str Contact:str Email:str
=Invoices INUM:int CID:int Raised_Date:date Due_Date:date Paid:bool
Description:str Items:Items
=Items IID:int Delivery_Date:date Unit_Price:real Quantity:int Description:str
(Database
    (Customers
    50 &lt;Best People&gt; &lt;123 Somewhere&gt; &lt;John Doe&gt; &lt;j@doe.com&gt; 
    19 &lt;Supersuppliers&gt; ? &lt;Jane Doe&gt; &lt;jane@super.com&gt; 
    )
    (Invoices
    152 50 2022-01-17 2022-02-17 no &lt;COD&gt; (Items
        1839 2022-01-16 29.99 2 &lt;Bales of hay&gt; 
        1840 2022-01-16 5.98 3 &lt;Straps&gt; 
        )
    153 19 2022-01-19 2022-02-19 yes &lt;&gt; (Items
        1620 2022-01-19 11.5 1 &lt;Washers (1-in)&gt; 
        )
    )
)"><pre><code>uxf 1 MyApp Data
#&lt;There is a 1:M relationship between the Invoices and Items tables&gt;
=Database customers:Customers invoices:Invoices
=Customers CID:int Company:str Address:str Contact:str Email:str
=Invoices INUM:int CID:int Raised_Date:date Due_Date:date Paid:bool
Description:str Items:Items
=Items IID:int Delivery_Date:date Unit_Price:real Quantity:int Description:str
(Database
    (Customers
    50 &lt;Best People&gt; &lt;123 Somewhere&gt; &lt;John Doe&gt; &lt;j@doe.com&gt; 
    19 &lt;Supersuppliers&gt; ? &lt;Jane Doe&gt; &lt;jane@super.com&gt; 
    )
    (Invoices
    152 50 2022-01-17 2022-02-17 no &lt;COD&gt; (Items
        1839 2022-01-16 29.99 2 &lt;Bales of hay&gt; 
        1840 2022-01-16 5.98 3 &lt;Straps&gt; 
        )
    153 19 2022-01-19 2022-02-19 yes &lt;&gt; (Items
        1620 2022-01-19 11.5 1 &lt;Washers (1-in)&gt; 
        )
    )
)
</code></pre></div>
<p dir="auto">Notice that Items no longer need an INUM to identify the Invoice they belong
to because they are nested inside their Invoice. However, the relational
approach has been retained for Customers since more than one Invoice could
be for the same Customer.</p>
<p dir="auto">In addition, rather than using a simple <code>list</code> of tables, we&#39;ve created a
“Database” <em>ttype</em> and specified it as containing two tables.</p>
<p dir="auto">What if we wanted to add some extra configuration data to the database? One
solution would be to add a third field to the “Database” <em>ttype</em> (e.g.,
<code>=Database customers:Customers invoices:Invoices config:map</code>). Or we could
go further and specify a “Config” <em>ttype</em> and specify the third field as
<code>config:Config</code>.</p>
<h3 dir="auto"><a id="user-content-additional-examples" aria-hidden="true" href="#additional-examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Additional Examples</h3>
<p dir="auto">See the <code>testdata</code> folder for more examples of <code>.uxf</code> files (some with other
suffixes). See also the <code>t</code> and <code>eg</code> folders in each language-specific
library (e.g., <code>py/t</code> and <code>py/eg</code>) for additional examples.</p>
<h2 dir="auto"><a id="user-content-libraries" aria-hidden="true" href="#libraries"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Libraries</h2>
<p dir="auto"><em>Implementations in additional languages are planned.</em></p>
<table>
<thead>
<tr>
<th><strong>Library</strong></th>
<th><strong>Language</strong></th>
<th><strong>Notes</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>uxf</td>
<td>Python 3</td>
<td>See the <a href="https://github.com/mark-summerfield/uxf/blob/main/py/README.md">Python UXF library</a>.</td>
</tr>
<tr>
<td>uxf</td>
<td>Rust</td>
<td>See the <a href="https://github.com/mark-summerfield/uxf/blob/main/rs/README.md">Rust UXF library</a>.</td>
</tr>
</tbody>
</table>
<h3 dir="auto"><a id="user-content-implementation-notes" aria-hidden="true" href="#implementation-notes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Implementation Notes</h3>
<p dir="auto">If you create a UXF library please let us know so that we can add a link
here (providing your library passes the regression tests!).</p>
<p dir="auto">Implmenting a UXF pretty printer whould be doable by a CS major as a final
year project. Implementing a UXF parser—without support for imports, string
concatenation, or aliases—should be doable by a CS major as a <em>big</em> final
year project.</p>
<h2 dir="auto"><a id="user-content-imports" aria-hidden="true" href="#imports"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Imports</h2>
<p dir="auto">UXF files are normally completely self-contained. However, in some cases it
may be desirable to share a set of <em>ttype</em> definitions amongst many UXF
files.</p>
<p dir="auto">The <em>disadvantages</em> of doing this are: first, that the relevant UXF files
become dependent on one or more external dependencies; second, it is
possible to have import conflicts (i.e., two <em>ttypes</em> with the same name but
different definitions; and third, if URL imports are used, load times will
be affected by network availability and latency. (However, the first and
third disadvantages don&#39;t apply if all the dependencies are provided by the
UXF processor itself, i.e., are system imports.)</p>
<p dir="auto">The <em>advantage</em> of importing <em>ttype</em> definitions is that for UXF&#39;s that have
lots of <em>ttypes</em>, only the import(s) and the data need be in the file,
without having to repeat all the <em>ttype</em> definitions.</p>
<p dir="auto">Imports go at the start of the file <em>after</em> the header and <em>after</em> any
file-level comment, and <em>before</em> any <em>ttype</em> definitions. Each import must
be on its own line and may not span lines, nor have comments.</p>
<p dir="auto">If a filename import has no path or a relative path, the import attempt will
be made relative to the importing <code>.uxf</code> file, and failing that, relative to
the current folder, and failing those, relative to each path in the
<code>UXF_PATH</code> environment variable (if it exists and is nonempty).</p>
<p dir="auto">Any <em>ttype</em> definition that follows an import will redefine any imported
defintion of the same name.</p>
<table>
<thead>
<tr>
<th><strong>Import</strong></th>
<th><strong>Notes</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>! complex</code></td>
<td>System import of <em>ttype</em> <code>Complex</code></td>
</tr>
<tr>
<td><code>! fraction</code></td>
<td>System import of <em>ttype</em> <code>Fraction</code></td>
</tr>
<tr>
<td><code>! numeric</code></td>
<td>System import of <em>ttypes</em> <code>Complex</code> and <code>Fraction</code></td>
</tr>
<tr>
<td><code>! mydefs.uxi</code></td>
<td>Import the <em>ttypes</em> from <code>mydefs.uxi</code> in the importing <code>.uxf</code> file&#39;s folder, or from the current folder, or from a folder in the <code>UXF_PATH</code></td>
</tr>
<tr>
<td><code>! /path/to/shared.uxf</code></td>
<td>Import the <em>ttypes</em> from the given file</td>
</tr>
<tr>
<td><code>! http://www.qtrac.eu/ttype-eg.uxf</code></td>
<td>Import from the given URL</td>
</tr>
</tbody>
</table>
<p dir="auto">Imports with no suffix (e.g., <code>complex</code>, <code>fraction</code>, <code>numeric</code>), are
provided by the UXF processor itself.</p>
<p dir="auto">The imported file must be a valid UXF file. It need not have a <code>.uxf</code> suffix
(e.g., you might prefer <code>.uxt</code> or <code>.uxi</code>), but must have <em>a</em> suffix (to
distinguish it from a system import), and must have a <code>.gz</code> suffix if gzip
compressed. Any custom string, comments, or data the imported file may
contain are ignored: only the <em>ttype</em> definitions are used.</p>
<div data-snippet-clipboard-copy-content="uxf 1
!complex
!fraction
[(Complex 5.1 7.2 8e-2 -9.1e6 0.1 -11.2) &lt;a string&gt; (Fraction 22 7 355 113)]"><pre><code>uxf 1
!complex
!fraction
[(Complex 5.1 7.2 8e-2 -9.1e6 0.1 -11.2) &lt;a string&gt; (Fraction 22 7 355 113)]
</code></pre></div>
<p dir="auto">Here we&#39;ve used the official system <code>complex</code>&#39;s <code>Complex</code> and
<code>fraction</code>&#39;s <code>Fraction</code> <em>ttypes</em> without having to specify them
explicitly. The data represented is a list consisting of three Complex
numbers each holding two <code>real</code>s each, a <code>str</code>, and two Fractions holding
two <code>int</code>s each.</p>
<div data-snippet-clipboard-copy-content="uxf 1
!numeric
[(Complex 5.1 7.2 8e-2 -9.1e6 0.1 -11.2) &lt;a string&gt; (Fraction 22 7 355 113)]"><pre><code>uxf 1
!numeric
[(Complex 5.1 7.2 8e-2 -9.1e6 0.1 -11.2) &lt;a string&gt; (Fraction 22 7 355 113)]
</code></pre></div>
<p dir="auto">This is the same as the previous example, but using the system convenience
<code>numeric</code> import to pull in both the <code>Complex</code> and <code>Fraction</code> <em>ttypes</em>.</p>
<p dir="auto">If you choose to use imports we recommed that UXF files intended for import
<em>either</em> contain a single <em>ttype</em> definition <em>or</em> two or more imports.</p>
<p dir="auto">We recommend avoiding imports and using stand-alone UXF files wherever
possible. Some UXF processors can do UXF to UXF conversions that will
replace imports with (actually used) <em>ttype</em> definitions. (For example, the
<a href="https://github.com/mark-summerfield/uxf/blob/main/py/README.md">Python UXF library</a>&#39;s <code>uxf.py</code> module can do this.)</p>
<h2 dir="auto"><a id="user-content-bnf" aria-hidden="true" href="#bnf"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>BNF</h2>
<p dir="auto">A UXF file consists of a mandatory header followed by an optional file-level
comment, optional imports, optional <em>ttype</em> definitions, and then a single
mandatory <code>list</code>, <code>map</code>, or <code>table</code> (which may be empty).</p>
<div data-snippet-clipboard-copy-content="UXF          ::= &#39;uxf&#39; RWS VERSION CUSTOM? &#39;\n&#39; CONTENT
VERSION      ::= /\d{1,3}/
CUSTOM       ::= RWS [^\n]+ # user-defined data e.g. filetype and version
CONTENT      ::= COMMENT? IMPORT* TTYPEDEF* (MAP | LIST | TABLE)
IMPORT       ::= &#39;!&#39; /\s*/ IMPORT_FILE &#39;\n&#39; # See below for IMPORT_FILE
TTYPEDEF     ::= &#39;=&#39; COMMENT? OWS IDENFIFIER (RWS FIELD)* # IDENFIFIER is the ttype (i.e., the table name)
FIELD        ::= IDENFIFIER (OWS &#39;:&#39; OWS VALUETYPE)? # IDENFIFIER is the field name (see note below)
MAP          ::= &#39;{&#39; COMMENT? MAPTYPES? OWS (KEY RWS VALUE)? (RWS KEY RWS VALUE)* OWS &#39;}&#39;
MAPTYPES     ::= OWS KEYTYPE (RWS VALUETYPE)?
KEYTYPE      ::=  &#39;bytes&#39; | &#39;date&#39; | &#39;datetime&#39; | &#39;int&#39; | &#39;str&#39;
VALUETYPE    ::= KEYTYPE | &#39;bool&#39; | &#39;real&#39; | &#39;list&#39; | &#39;map&#39; | &#39;table&#39; | IDENFIFIER # IDENFIFIER is table name
LIST         ::= &#39;[&#39; COMMENT? LISTTYPE? OWS VALUE? (RWS VALUE)* OWS &#39;]&#39;
LISTTYPE     ::= OWS VALUETYPE
TABLE        ::= &#39;(&#39; COMMENT? OWS IDENFIFIER (RWS VALUE)* &#39;)&#39; # IDENFIFIER is the ttype (i.e., the table name)
COMMENT      ::= OWS &#39;#&#39; STR
KEY          ::= BYTES | DATE | DATETIME | INT | STR
VALUE        ::= KEY | NULL | BOOL | REAL | LIST | MAP | TABLE
NULL         ::= &#39;?&#39;
BOOL         ::= &#39;no&#39; | &#39;yes&#39;
INT          ::= /[-+]?\d+/
REAL         ::= # standard or scientific notation
DATE         ::= /\d\d\d\d-\d\d-\d\d/ # basic ISO8601 YYYY-MM-DD format
DATETIME     ::= /\d\d\d\d-\d\d-\d\dT\d\d(:\d\d(:\d\d)?)?/ # see note below
STR          ::= STR_FRAGMENT (OWS &#39;&amp;&#39; OWS STR_FRAGMENT)*
STR_FRAGMENT ::= /[&lt;][^&lt;&gt;]*?[&gt;]/ # newlines allowed, and &amp;amp; &amp;lt; &amp;gt; supported i.e., XML
BYTES        ::= &#39;(:&#39; (OWS [A-Fa-f0-9]{2})* OWS &#39;:)&#39;
IDENFIFIER   ::= /[_\p{L}]\w{0,31}/ # Must start with a letter or underscore; may not be a built-in typename or constant
OWS          ::= /[\s\n]*/
RWS          ::= /[\s\n]+/ # in some cases RWS is actually optional"><pre><code>UXF          ::= &#39;uxf&#39; RWS VERSION CUSTOM? &#39;\n&#39; CONTENT
VERSION      ::= /\d{1,3}/
CUSTOM       ::= RWS [^\n]+ # user-defined data e.g. filetype and version
CONTENT      ::= COMMENT? IMPORT* TTYPEDEF* (MAP | LIST | TABLE)
IMPORT       ::= &#39;!&#39; /\s*/ IMPORT_FILE &#39;\n&#39; # See below for IMPORT_FILE
TTYPEDEF     ::= &#39;=&#39; COMMENT? OWS IDENFIFIER (RWS FIELD)* # IDENFIFIER is the ttype (i.e., the table name)
FIELD        ::= IDENFIFIER (OWS &#39;:&#39; OWS VALUETYPE)? # IDENFIFIER is the field name (see note below)
MAP          ::= &#39;{&#39; COMMENT? MAPTYPES? OWS (KEY RWS VALUE)? (RWS KEY RWS VALUE)* OWS &#39;}&#39;
MAPTYPES     ::= OWS KEYTYPE (RWS VALUETYPE)?
KEYTYPE      ::=  &#39;bytes&#39; | &#39;date&#39; | &#39;datetime&#39; | &#39;int&#39; | &#39;str&#39;
VALUETYPE    ::= KEYTYPE | &#39;bool&#39; | &#39;real&#39; | &#39;list&#39; | &#39;map&#39; | &#39;table&#39; | IDENFIFIER # IDENFIFIER is table name
LIST         ::= &#39;[&#39; COMMENT? LISTTYPE? OWS VALUE? (RWS VALUE)* OWS &#39;]&#39;
LISTTYPE     ::= OWS VALUETYPE
TABLE        ::= &#39;(&#39; COMMENT? OWS IDENFIFIER (RWS VALUE)* &#39;)&#39; # IDENFIFIER is the ttype (i.e., the table name)
COMMENT      ::= OWS &#39;#&#39; STR
KEY          ::= BYTES | DATE | DATETIME | INT | STR
VALUE        ::= KEY | NULL | BOOL | REAL | LIST | MAP | TABLE
NULL         ::= &#39;?&#39;
BOOL         ::= &#39;no&#39; | &#39;yes&#39;
INT          ::= /[-+]?\d+/
REAL         ::= # standard or scientific notation
DATE         ::= /\d\d\d\d-\d\d-\d\d/ # basic ISO8601 YYYY-MM-DD format
DATETIME     ::= /\d\d\d\d-\d\d-\d\dT\d\d(:\d\d(:\d\d)?)?/ # see note below
STR          ::= STR_FRAGMENT (OWS &#39;&amp;&#39; OWS STR_FRAGMENT)*
STR_FRAGMENT ::= /[&lt;][^&lt;&gt;]*?[&gt;]/ # newlines allowed, and &amp;amp; &amp;lt; &amp;gt; supported i.e., XML
BYTES        ::= &#39;(:&#39; (OWS [A-Fa-f0-9]{2})* OWS &#39;:)&#39;
IDENFIFIER   ::= /[_\p{L}]\w{0,31}/ # Must start with a letter or underscore; may not be a built-in typename or constant
OWS          ::= /[\s\n]*/
RWS          ::= /[\s\n]+/ # in some cases RWS is actually optional
</code></pre></div>
<p dir="auto">Note that a UXF file <em>must</em> contain a single list, map, or table, even if
it is empty.</p>
<p dir="auto">An <code>IMPORT_FILE</code> may be a filename which does <em>not</em>  have a file suffix, in
which case it is assumed to be a “system” UXF provided by the UXF processor
itself. (Currently there are just three system UXFs: <code>complex</code>, <code>fraction</code>,
and <code>numeric</code>.) Or it may be a filename with an absolute or relative path.
In the latter case the import is searched for in the importing <code>.uxf</code> file&#39;s
folder, or the current folder, or a folder in the <code>UXF_PATH</code> until it is
found—or not). Or it may be a URL referring to an external UXF file. (See
<a href="#imports">Imports</a>.)</p>
<p dir="auto">To indicate any type valid for the context, simply omit the type name.</p>
<p dir="auto">As the BNF shows, <code>list</code>, <code>map</code>, and <code>table</code> values may be of <em>any</em> type
including nested <code>list</code>s, <code>map</code>s, and <code>table</code>s.</p>
<p dir="auto">For a <code>table</code>, after the optional comment, there must be an identifier which
is the table&#39;s <em>ttype</em>. This is followed by the table&#39;s values. There&#39;s no
need to distinguish between one row and the next (although it is common to
start new rows on new lines) since the number of fields indicate how many
values each row has. It is possible to create tables that have no fields;
these might be used for representing constants (or enumerations or states).</p>
<p dir="auto">Note that for any given table each field name must be unique.</p>
<p dir="auto">If a list value, map key, or table value&#39;s type is specified, then the UXF
processor is expected to be able to check for (and if requested and
possible, correct) any mistyped values. UXF writers are expected output
collections—<code>list</code> values and  <code>table</code> records (and values within
records) in order. Similarly <code>map</code> items should be output in key-order: when
two keys are of different types they should be ordered <code>bytes</code> <code>&lt;</code> <code>date</code>
<code>&lt;</code> <code>datetime</code> <code>&lt;</code> <code>int</code> <code>&lt;</code> <code>str</code>, and when two keys have the same types
they should be ordered using <code>&lt;</code> except for <code>str</code>s which should use
case-insensitive <code>&lt;</code>.</p>
<p dir="auto">For <code>datetime</code>&#39;s, only 1-second resolution is supported and no timezones.
If microsecond resolution or timezones are required, consider using custom
<em>ttypes</em>, e.g.,</p>
<div data-snippet-clipboard-copy-content="=Timestamp when:datetime microseconds:real
=DateTime when:datetime tz:str"><pre><code>=Timestamp when:datetime microseconds:real
=DateTime when:datetime tz:str
</code></pre></div>
<p dir="auto">Alternatively, if all the <code>datetime</code>s in a UXF have the <em>same</em> timezone,
one approach would be to to just set it once, and then use plain
<code>datetime</code>s throughout e.g.,</p>
<div data-snippet-clipboard-copy-content="=Timezone tz:str
[(Timezone &lt;+01:00&gt;) ... 1990-01-15T13:05 ...]"><pre><code>=Timezone tz:str
[(Timezone &lt;+01:00&gt;) ... 1990-01-15T13:05 ...]
</code></pre></div>
<p dir="auto">Note that a UXF reader (writer) <em>must</em> be able to read (write) a plain text
<code>.uxf</code> file containing UTF-8 encoded text, and <em>ought</em> to be able to read
and write gzipped plain text <code>.uxf.gz</code> files.</p>
<p dir="auto">Note also that UXF readers and writers should <em>not</em> care about the actual
file extension (apart from the <code>.gz</code> needed for gzipped files), since users
are free to use their own. For example, <code>data.myapp</code> and <code>data.myapp.gz</code>.</p>
<h2 dir="auto"><a id="user-content-supplementary" aria-hidden="true" href="#supplementary"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Supplementary</h2>
<h3 dir="auto"><a id="user-content-vim-support" aria-hidden="true" href="#vim-support"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Vim Support</h3>
<p dir="auto">If you use the vim editor, simple color syntax highlighting is available.
Copy <code>uxf.vim</code> into your <code>$VIM/syntax/</code> folder and add these lines (or
similar) to your <code>.vimrc</code> or <code>.gvimrc</code> file:</p>
<div data-snippet-clipboard-copy-content="au BufRead,BufNewFile,BufEnter * if getline(1) =~ &#39;^uxf &#39; | setlocal ft=uxf | endif
au BufRead,BufNewFile,BufEnter *.uxf set ft=uxf|set expandtab|set tabstop=2|set softtabstop=2|set shiftwidth=2"><pre><code>au BufRead,BufNewFile,BufEnter * if getline(1) =~ &#39;^uxf &#39; | setlocal ft=uxf | endif
au BufRead,BufNewFile,BufEnter *.uxf set ft=uxf|set expandtab|set tabstop=2|set softtabstop=2|set shiftwidth=2
</code></pre></div>
<h3 dir="auto"><a id="user-content-uxf-logo" aria-hidden="true" href="#uxf-logo"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>UXF Logo</h3>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/mark-summerfield/uxf/blob/main/uxf.svg"><img src="https://github.com/mark-summerfield/uxf/raw/main/uxf.svg" alt="uxf logo"/></a></p>
<hr/>
</article>
          </div></div>
  </body>
</html>
