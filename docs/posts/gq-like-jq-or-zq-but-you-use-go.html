<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/hherman1/gq">Original</a>
    <h1>Show HN: gq â€“ like jq or zq, but you use Go</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text"><p dir="auto"><a href="https://pkg.go.dev/mod/github.com/hherman1/gq/gq" rel="nofollow"><img src="https://camo.githubusercontent.com/5f0f955a6ca9f7fc55a95e46b02f9b055704bf15eba43a3e0478eb582fdae776/68747470733a2f2f676f646f632e6f72672f6769746875622e636f6d2f686865726d616e312f67713f7374617475732e737667" alt="GoDoc" data-canonical-src="https://godoc.org/github.com/hherman1/gq?status.svg"/></a></p>

<p dir="auto">jq but using go instead.</p>
<h2 dir="auto"><a id="user-content-install" aria-hidden="true" href="#install"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Install</h2>
<div data-snippet-clipboard-copy-content="go install github.com/hherman1/gq@latest"><pre><code>go install github.com/hherman1/gq@latest
</code></pre></div>
<p dir="auto">Or download the binaries <a href="https://github.com/hherman1/gq/releases/latest">here</a></p>

<p dir="auto">Pipe some input into <code>gq</code> and pass in a block of go code as the argument. The variable <code>j</code> is set to the passed in JSON and printed at the end of the function, so manipulate it (e.g below) in order to change the output. The <code>gq</code> library is inlined in the program, and described in detail in the API reference above.</p>

<p dir="auto">Accesses</p>
<div data-snippet-clipboard-copy-content="$ echo &#39;{&#34;weird&#34;: [&#34;nested&#34;, {&#34;complex&#34;: &#34;structure&#34;}]}&#39; | gq &#39;j.G(&#34;weird&#34;).I(1).G(&#34;complex&#34;)&#39;
&#34;structure&#34;"><pre><code>$ echo &#39;{&#34;weird&#34;: [&#34;nested&#34;, {&#34;complex&#34;: &#34;structure&#34;}]}&#39; | gq &#39;j.G(&#34;weird&#34;).I(1).G(&#34;complex&#34;)&#39;
&#34;structure&#34;
</code></pre></div>
<p dir="auto">Filters</p>
<div data-snippet-clipboard-copy-content="$ echo &#39;[&#34;list&#34;, &#34;of&#34;, &#34;mostly&#34;, &#34;uninterseting&#34;, &#34;good/strings&#34;, &#34;good/welp&#34;]&#39; | gq &#39;j.Filter(func(n *Node) bool { return strings.Contains(n.String(), &#34;good/&#34;) })&#39;
[
	&#34;good/strings&#34;,
	&#34;good/welp&#34;
]"><pre><code>$ echo &#39;[&#34;list&#34;, &#34;of&#34;, &#34;mostly&#34;, &#34;uninterseting&#34;, &#34;good/strings&#34;, &#34;good/welp&#34;]&#39; | gq &#39;j.Filter(func(n *Node) bool { return strings.Contains(n.String(), &#34;good/&#34;) })&#39;
[
	&#34;good/strings&#34;,
	&#34;good/welp&#34;
]
</code></pre></div>
<p dir="auto">Maps</p>
<div data-snippet-clipboard-copy-content="$ echo &#39;[1, 2, 3, 4]&#39; | gq &#39;j.Map(func(n *Node) *Node {n.val = n.Int() + 50 / 2; return n})&#39;
[
	26,
	27,
	28,
	29
]"><pre><code>$ echo &#39;[1, 2, 3, 4]&#39; | gq &#39;j.Map(func(n *Node) *Node {n.val = n.Int() + 50 / 2; return n})&#39;
[
	26,
	27,
	28,
	29
]
</code></pre></div>

<p dir="auto"><code>jq</code> is hard to use. There are alternatives like <code>fq</code> and <code>zq</code>, but they still make you learn a new programming language. Im tired of learning new programming languages.</p>
<p dir="auto"><code>gq</code> is not optimized for speed, flexibility or beauty. <code>gq</code> is optimized for minimal learning/quick usage. <code>gq</code> understands that you don&#39;t use it constantly, you use it once a month and then forget about it. So when you come back to it, <code>gq</code> will be easy to relearn. Just use the builtin library just like you would any other go project and you&#39;re done. No unfamiliar syntax or operations, or surprising limits. Thats it.</p>

<p dir="auto">Speaking of surprising limits, <code>gq</code> runs your code in the <code>yaegi</code> go interpreter. This means that it runs quickly for small inputs/programs (the alternative was <code>go run</code>, which is... not quite as quick). However, it also means its not the fastest <code>*q</code> out there, and further it means that you might run into quirks with <code>yaegi</code> interpretation limitations. Seems to work pretty well so far though.</p>

<p dir="auto">Yea, well, I built it last night, so, yea it kinda sucks. But please file issues! Or submit PRs! Maybe this will turn into something useful? At least maybe it will inspire some conversation.</p>
<p dir="auto">I think it needs a lot of refinement still, in short.</p>
</article>
          </div></div>
  </body>
</html>
