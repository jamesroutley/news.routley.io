<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoFinalizerCostsNotes">Original</a>
    <h1>Notes on the Cost of Go Finalizers</h1>
    
    <div id="readability-page-1" class="page"><div><h2>Some notes on the cost of Go finalizers (in Go 1.20)</h2>

	<p><small>May 20, 2023</small></p>
</div><div><p>I recently read Daniel Lemire&#39;s <a href="https://lemire.me/blog/2023/05/19/the-absurd-cost-of-finalizers-in-go/">The absurd cost of finalizers in
Go</a>
(<a href="https://lobste.rs/s/vhivpd/absurd_cost_finalizers_go">via</a>),
which reports on a remarkably high cost of using a finalizer to
insure that C memory is freed. Lemire&#39;s numbers aren&#39;t atypical;
in my own testing in a different environment I found a rough factor
of ten difference between directly calling C <code>malloc()</code> and <code>free()</code>
and using a finalizer to call <code>free()</code>.</p>

<p>The first reason for this increased overhead in Lemire&#39;s test case
is perhaps somewhat surprising, which is that <strong>using a finalizer
forces heap allocation</strong>, while Lemire&#39;s non-finalizer version does
not. Suppose that you have:</p>

<blockquote><pre>func Allocate() *C.char {
  return C.allocate()
}

func Free(c *C.char) {
  C.free_allocated(c)
}

// in a _test.go file
func BenchmarkAllocate(b *testing.B) {
  for j := 0; j &lt; b.N; j++ {
    p := Allocate()
    Free(p)
  }
}
</pre>
</blockquote>

<p>Go 1.20 is smart enough to allocate &#39;<code>p</code>&#39; on the Go stack, so while
the C code is calling <code>malloc()</code> and <code>free()</code>, Go is not doing
anything with its own memory system. The moment you call
<a href="https://pkg.go.dev/runtime#SetFinalizer"><code>runtime.SetFinalizer()</code></a>
this changes; Go considers the object you&#39;re trying to finalize
to escape, so it allocates it in the heap. Probably this often
won&#39;t matter in real situations, because what you&#39;re finalizing
is already going to be heap allocated.</p>

<p>(In Lemire&#39;s test code, you can see this if you use &#39;<code>go test
-benchmem -bench=Benchmark -run -</code>&#39;; some of the benchmarks
will allocate nothing per invocation, and others will allocate
one thing.)</p>

<p>Lemire tested with garbage collection (GC) turned off in the Go
runtime and got similar results, so theorized that SetFinalizer()
was the expensive portion. I constructed a synthetic test function
that only set a finalizer without making any cgo calls, and this
does seem to be the case. With Go&#39;s GC on in its normal state, over
50% of the runtime of benchmarking this function is in SetFinalizer(),
mostly in an internal runtime function called <code>runtime.addspecial()</code>.
There are some other surprises, though. In total, GC activity seems
to be about 27% of the runtime, with about half of that being
directly triggered by allocations and half happening in the background.
Much of the GC time seems to be spent processing and running
finalizers, even though the test&#39;s finalizer does nothing (21% of
the total time). A surprisingly high percentage of the time is spent
locking and unlocking things, with the Go profiler attributing 10%
to &#39;<code>runtime.lock2()</code>&#39; and 10% to &#39;<code>runtime.unlock2()</code>&#39;.</p>

<p>What I take from this is that SetFinalizer() is probably not
considered something that you should use heavily, and as a result
it hasn&#39;t been heavily optimized. You can get a sense of this from
the extensive documentation around its limitations and issues in
the <a href="https://pkg.go.dev/runtime#SetFinalizer"><code>runtime.SetFinalizer()</code> documentation</a>; using it correctly is
tricky, and correctly using anything with a finalizer attached is
also tricky (see the discussion of the example with file descriptors).</p>

<p>PS: One of the effects of putting finalizers on objects is that the
objects will take longer to be garbage collected (an unused object with
a finalizer takes two GC cycles to collect, instead of one). This may
affect how you structure objects and where you attach finalizers; you
probably don&#39;t want to put a finalizer on a big object or on an object
that will be directly embedded in one (<a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoInteriorPointerGC">since Go doesn&#39;t free sub-objects
by themselves</a>).</p>

<h3>Sidebar: My finalizer-only test code</h3>

<p>In case people want to run their own tests:</p>

<blockquote><pre>// Used by Lemire&#39;s other benchmarks
type Cstr struct {
  cpointer *C.char
}

// No C malloc, no finalizer code
func EmptyFinalizer() *Cstr {
  answer := &amp;Cstr{}
  runtime.SetFinalizer(answer, func(c *Cstr) {})
  return answer
}

// in _test file
func BenchmarkEmptyFinalizer(b *testing.B) {
  for j := 0; j &lt; b.N; j++ {
    EmptyFinalizer()
  }
}
</pre>
</blockquote>

<p>I deliberately structured this to be as close to Lemire&#39;s other
benchmark test functions as possible, hence its use of the Cstr
type.</p>
</div></div>
  </body>
</html>
