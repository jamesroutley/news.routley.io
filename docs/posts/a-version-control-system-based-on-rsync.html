<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jamsync.dev/about">Original</a>
    <h1>Show HN: A version control system based on rsync</h1>
    
    <div id="readability-page-1" class="page"><div>
<section>


<p>
Jamsync is an open-source version control system that enables software engineers to develop and deploy faster. We&#39;re currently under development but feel free to preview the system on this site. The AGPL-licensed source and client binaries are available to download <a href="https://jamsync.dev/download">here</a>.
</p>
<h2>Algorithm</h2>
<p>
The idea behind Jamsync is the same as <a href="https://github.com/WayneD/rsync">rsync</a>. In fact, Jamsync uses <a href="https://github.com/jbreiding/rsync-go">jbreiding/rsync-go</a> for now under the hood.
If you havent read the <a href="https://www.andrew.cmu.edu/course/15-749/READINGS/required/cas/tridgell96.pdf">rsync algorithm</a> paper,
it&#39;s highly recommended -- it&#39;s very approachable for anyone with a computer science background and has some great information.
</p>
<h3>Rsync</h3>
<p>
Essentially, rsync allows a file on two separate computers, a sender and receiver, to be synced efficiently over a network.
It does this by chopping a file into blocks and reusing existing blocks on the receiver to regenerate a file.
A <a href="https://en.wikipedia.org/wiki/Rolling_hash#:~:text=A%20rolling%20hash%20(also%20known,that%20moves%20through%20the%20input.">rolling hash</a> is used to scan over the file on the sender and
operations are sent to the receiver to either reuse a block (if the rolling hash matches) or to use new data.
</p>
<p>
More detailed steps are below:
</p><ol>
<li>Sender and receiver establish a connection</li>
<li>Receiver hashes their existing blocks of a file with a rolling and strong hash and sends the hashes to the sender</li>
<li>Sender receives hashes and uses the rolling hash to scan over the file
<ol>
<li>If the rolling hash matches a block on the receiver, the strong hash is used to verify the integrity and an operation is sent to reuse the block</li>
<li>If a block does not match a block on the receiver, an operation containing the data is sent to the receiver</li>
</ol>
</li>
<li>Receiver receives operations in a stream to regenerate the file by either reusing existing blocks or writing new data</li>
</ol>

<h3>How Jamsync uses Rsync</h3>
<p>
The main idea behind Jamsync is that we can store the operations sent by the sender to track changes to a file. This means we treat
rsync operations like a delta chain that we can use later to regenerate the file. The storage of deltas and their usage to regenerate a file
is similar to the Mercurial concept of a <a href="https://www.mercurial-scm.org/wiki/Revlog">Revlog</a>. However, the advantage of using rsync blocks is that we can
efficiently store changes to, and regenerate, arbitrarily large files since these blocks can be streamed and regenerated independently.
</p>

<h3>Changes and Conflicts</h3>
<p>
A chain of changes, formed by the process above, can be used to regerate every file in a project. Branches off of the main chain can be used to prevent
conflicts from occuring when editing the same part of a file; however, whenever a branch is merged in, every other branch is automatically rebased on top.
This means that every branch will always be up-to-date. If conflicts occur during the rebase, a branch will be marked as &#34;stale&#34; and will need manual merging.
</p>
<h3>Limitations</h3>
<p>
The goal is to be able to handle over 10M files and over 1TB-sized files in a single repository. We&#39;re not there yet in the current implementation (probably ~10K files with 1GB-sized files) but should be there in the next couple months.
</p>
<h3>Implementation</h3>
<p>
Jamsync is being written from scratch in <a href="https://go.dev/">Go</a> and uses <a href="https://github.com/mattn/go-sqlite3">mattn/go-sqlite3</a> to store projects and change information. <a href="https://grpc.io/">gRPC</a> and <a href="https://developers.google.com/protocol-buffers">Protocol buffers</a>
are used for service definitions and data serialization.
</p>
<h2>Current state</h2>
<p>
This site is a preview version of the system. The features <a href="https://jamsync.dev/">here</a> will be available over the next few months.
</p>
<h3>Developers</h3>
<p>
Jamsync is being developed by <a href="https://www.linkedin.com/in/zdgeier/">Zachary Geier</a>. Please send me an email if you have any thoughts at <a href="https://jamsync.dev/cdn-cgi/l/email-protection#7c061d1f143c161d110f05121f5218190a"><span data-cfemail="bcc6dddfd4fcd6ddd1cfc5d2df92d8d9ca">[emailÂ protected]</span></a>.
</p>
</section>
</div></div>
  </body>
</html>
