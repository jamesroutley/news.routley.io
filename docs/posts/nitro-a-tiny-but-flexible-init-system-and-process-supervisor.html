<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://git.vuxu.org/nitro/about/">Original</a>
    <h1>Nitro: A tiny but flexible init system and process supervisor</h1>
    
    <div id="readability-page-1" class="page"><div><div id="summary">   
<div>

<h2>Overview</h2>
<p>Nitro is a tiny process supervisor that also can be used as pid 1 on Linux.</p>
<p>There are four main applications it is designed for:</p>
<ul>
<li>As init for a Linux machine for embedded, desktop or server purposes</li>
<li>As init for a Linux initramfs</li>
<li>As init for a Linux container (Docker/Podman/LXC/Kubernetes)</li>
<li>As unprivileged supervision daemon on POSIX systems</li>
</ul>
<p>Nitro is configured by a directory of scripts, defaulting to
<code>/etc/nitro</code> (or the first command line argument).</p>
<h2>Requirements</h2>
<ul>
<li>Kernel support for Unix sockets</li>
<li><code>tmpfs</code> or writable <code>/run</code> on another fs</li>
</ul>
<h2>Benefits over other systems</h2>
<ul>
<li>All state is kept in RAM, works without tricks on read-only root file systems.</li>
<li>Efficient event-driven, polling free operation.</li>
<li>Zero memory allocations during runtime.</li>
<li>No unbounded file descriptor usage during runtime.</li>
<li>One single self-contained binary, plus one optional binary to
control the system.</li>
<li>No configuration compilation steps needed, services are simple
directories containing scripts.</li>
<li>Supports reliable restarting of services.</li>
<li>Reliable logging mechanisms per service or as default.</li>
<li>Support for logging chains spread over several services.</li>
<li>Works independently of properly set system clock.</li>
<li>Can be run on FreeBSD from /etc/ttys (sets up file descriptors 0, 1, 2).</li>
<li>Tiny static binary when using musl libc.</li>
</ul>
<h2>Services</h2>
<p>Every directory inside <code>/etc/nitro</code> (or your custom service directory)
can contain several files:</p>
<ul>
<li><code>setup</code>, an optional executable file that is run before the service starts.
It must exit with status 0 to continue.</li>
<li><code>run</code>, an optional executable file that runs the service;
it must not exit as long as the service is considered running.
If there is no <code>run</code> script, the service is considered a “one shot”,
and stays “up” until it’s explicitly taken “down”.</li>
<li><code>finish</code>, an optional executable file that is run after the <code>run</code>
process finished.  It is passed two arguments, the exit status
of the <code>run</code> process (or -1 if it was killed by a signal)
and the signal that killed it (or 0, if it exited regularly).</li>
<li><code>log</code>, a symlink to another service directory.
The standard output of <code>run</code> is connected to the standard input of the
service under <code>log</code> by a pipe.  You can chain these for reliable and
supervised log processing.</li>
<li><code>down</code>, an optional file that causes nitro to not bring up this
service by default.</li>
<li>Service directories ending with ‘@’ are ignored; they can be used
for parameterized services.</li>
<li>Service names must be shorter than 64 chars, and not contain <code>/</code>,
<code>,</code> or newlines.</li>
</ul>
<p>You may find runit’s <code>chpst</code> useful when writing <code>run</code> scripts.</p>
<h2>Special services</h2>
<ul>
<li><code>LOG</code>: this service is used as a logging service for all services
that don’t have a <code>log</code> symlink.</li>
<li><code>SYS</code>: <code>SYS/setup</code> is run before other services are brought up.
You can already use <code>nitroctl</code> in <code>SYS/setup</code> to bring up services
in a certain order.
<code>SYS/finish</code> is run before all remaining services are killed and the
system is brought down.
After all processes are terminated, <code>SYS/final</code> is run.
The program <code>SYS/fatal</code>, if it exists, is run instead of exiting
when an unrecoverable, fatal error happens.
The program <code>SYS/reincarnate</code>, if it exists, is executed into
instead of a shutdown.  This can be used to implement an initramfs,
for example.</li>
</ul>
<h2>Parametrized services</h2>
<p>Service directories ending in <code>@</code> are ignored, however you can refer
to parametrized services by symlinks (either in the service directory
or as a <code>log</code> symlink), or start them manually using <code>nitroctl</code>.</p>
<p>The part after the <code>@</code>, the parameter, is passed to the scripts as
first argument.</p>
<p>For example, given you have a script <code>agetty@/run</code> and a symlink
<code>agetty@tty1</code> -&gt; <code>agetty@</code>, nitro will spawn <code>agetty@/run tty1</code>.  Upon
running <code>nitroctl up agetty@tty2</code>, nitro will spawn <code>agetty@/run tty2</code>, even if it does not exist in the service directory.</p>
<h2>Modes of operation</h2>
<p>The lifecycle of a machine/container/session using nitro consists of
three phases.</p>
<p>First, the system is brought up.  If there is a special service
g<code>SYS</code>, its <code>setup</code> script is run first.  After it finishes, all
services not marked <code>down</code> are brought up.</p>
<p>When a service exits, it’s being restarted, potentially waiting for
two seconds if the last restart happened too quickly.</p>
<p>By using <code>nitroctl Reboot</code> or <code>nitroctl Shutdown</code>, the system can be
brought down.  If it exists, <code>SYS/finish</code> will be run.  After this,
nitro will send a SIGTERM signal to all running services and waits for
up to 7 seconds for the service to exit.  Otherwise, a SIGKILL is
sent.  After all processes are terminated, <code>SYS/final</code> is run.</p>
<p>Finally, nitro reboots or shuts down the system; or just exits when it
was used as a container init or unprivileged supervisor.  (When a
reboot was requested, it re-execs itself.  This requires being called
with absolute path for the binary and the service directory.)</p>
<h2>Controlling nitro with nitroctl</h2>
<p>You can remote control a running nitro instance using the tool
<code>nitroctl</code>.</p>
<p>Usage: <code>nitroctl [COMMAND] [SERVICE]</code></p>
<p>Where COMMAND is one of:</p>
<ul>
<li>list: show a list of services and their state, pid, uptime and last
exit status.</li>
<li>up: start SERVICE</li>
<li>down: stop SERVICE (sending SIGTERM or the first letter of <code>./down-signal</code>)</li>
<li>start: start SERVICE, waiting for success</li>
<li>restart: restart SERVICE, waiting for success</li>
<li>stop: stop SERVICE, waiting for success</li>
<li>p: send signal SIGSTOP to SERVICE</li>
<li>c: send signal SIGCONT to SERVICE</li>
<li>h: send signal SIGHUP to SERVICE</li>
<li>a: send signal SIGALRM to SERVICE</li>
<li>i: send signal SIGINT to SERVICE</li>
<li>q: send signal SIGQUIT to SERVICE</li>
<li>1: send signal SIGUSR1 to SERVICE</li>
<li>2: send signal SIGUSR2 to SERVICE</li>
<li>t: send signal SIGTERM to SERVICE</li>
<li>k: send signal SIGKILL to SERVICE</li>
<li>pidof: print the PID of the SERVICE, or return 1 if it’s not up</li>
<li>rescan: re-read <code>/etc/nitro</code>, start added daemons, stop removed daemons</li>
<li>Shutdown: shutdown (poweroff) the system</li>
<li>Reboot: reboot the system</li>
</ul>
<h2>Controlling nitro by signals</h2>
<p>rescan can also be triggered by sending <code>SIGHUP</code> to nitro.</p>
<p>reboot can also be triggered by sending <code>SIGINT</code> to nitro.</p>
<p>shutdown can also be triggered by sending <code>SIGTERM</code> to nitro, unless
nitro is used as Linux pid 1.</p>
<h2>Nitro as <code>init</code> for Linux</h2>
<p>Nitro is self-contained and can be booted directly as pid 1.
It will mount <code>/dev</code> and <code>/run</code> when required, everything else
should be done with <code>SYS/setup</code>.</p>
<p>When receiving Ctrl-Alt-Delete, nitro triggers an orderly reboot.</p>
<h2>Nitro as init for a Docker container</h2>
<p>Nitro is compiled statically, so you can copy it into your container easily:</p>
<pre><code>COPY ./nitro /bin/
COPY ./nitroctl /bin/
CMD [&#34;/bin/nitro&#34;]
</code></pre>
<p>Note that <code>/run</code> must exist in the container if you want to use the
default control socket name.</p>
<p>You can put the control socket onto a bind mount and remote control
<code>nitro</code> using <code>nitroctl</code> from the outside by pointing <code>NITRO_SOCK</code> to
the appropriate target.</p>
<h2>Nitro on FreeBSD</h2>
<p>You can add this line to <code>/etc/ttys</code> to run <code>nitro</code> supervised by
FreeBSD <code>init</code>:</p>
<pre><code>/etc/nitro &#34;/usr/local/sbin/nitro&#34; &#34;&#34; on
</code></pre>
<h2>Authors</h2>
<p>Leah Neukirchen <a href="mailto:leah@vuxu.org">leah@vuxu.org</a></p>
<h2>Thanks</h2>
<p>I’m standing on the shoulder of giants; this software would not have
been possible without detailed study of prior systems such as
daemontools, freedt, runit, perp, and s6.</p>
<h2>Copying</h2>
<p>nitro is licensed under the 0BSD license, see LICENSE for details.</p>
</div>
</div></div></div>
  </body>
</html>
