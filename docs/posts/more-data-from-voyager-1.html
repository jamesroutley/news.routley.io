<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://destevez.net/2021/12/more-data-from-voyager-1/">Original</a>
    <h1>More Data from Voyager 1</h1>
    
    <div id="readability-page-1" class="page"><article id="post-10399">

	<!-- .entry-header -->

	<div>
		
<p>Back in September, I showed how to <a href="https://destevez.net/2021/09/decoding-voyager-1/" data-type="post" data-id="10150">decode the telemetry signal from Voyager 1</a> using a recording made with the <a href="https://en.wikipedia.org/wiki/Green_Bank_Telescope">Green Bank Telescope</a> in 2015 by the <a href="https://en.wikipedia.org/wiki/Breakthrough_Listen">Breakthrough Listen</a> project. The recording was only 22.57 seconds long, so it didn’t even contain a complete telemetry frame. To study the contents of the telemetry, more data would be needed. Often we can learn things about the structure of the telemetry frames by comparing several consecutive frames. Fields whose contents don’t change, counters, and other features become apparent.</p>



<p>Some time after writing that post, <a href="http://www.stevecroft.co.uk/" data-type="URL" data-id="http://www.stevecroft.co.uk/">Steve Croft</a>, from <a href="https://seti.berkeley.edu/">BSRC</a>, pointed me to another set of recordings of Voyager 1 from 16 July 2020 (MJD 59046.8). They were also made by Breakthrough Listen with the Green Bank Telescope, but they are longer. This post is an analysis of this set of recordings.</p>



<h4>Recorded data</h4>



<p>The recordings follow the usual observing cadence of Breakthrough Listen, described in Section 2.1 in <a href="https://arxiv.org/abs/1906.07391">this paper</a>. Six scans of 5 minutes each are done. The primary target (in this case Voyager 1) is observed in three of the scans, called ON scans. In the three other scans, called OFF scans, other targets or the empty sky are observed. The ON and OFF scans alternate, starting with an ON scan. The goal of this schedule is to discard as local interference signals that are present both in an ON and OFF scan.</p>



<p>I think that these recordings have not been published yet in the <a href="http://seti.berkeley.edu/opendata">Breakthrough Listen open data archive</a>. I guess they will be published at some point when the data is curated.</p>



<p>The files I used are from compute node BLC23, which processed the data in a 187.5 MHz window around the frequency 8345.21484375 MHz. A total of 24 compute nodes were used in this observation to cover the span between 7501.5 and 11251.5 MHz approximately (a few of the 187.5 MHz windows were duplicated into two nodes).</p>



<p>The files are in GUPPI format, which I described in my <a href="https://destevez.net/2021/09/decoding-voyager-1/" data-type="post" data-id="10150">previous post</a>. The header of the first file in the dataset is as follows:</p>



<pre><code> BACKEND = &#39;GUPPI   &#39;
 DAQCTRL = &#39;start   &#39;
 TELESCOP= &#39;GBT     &#39;
 OBSERVER= &#39;Steve Croft&#39;
 PROJID  = &#39;AGBT20A_999_53&#39;
 FRONTEND= &#39;Rcvr8_10&#39;
 NRCVR   =                    2
 FD_POLN = &#39;CIRC    &#39;
 BMAJ    =  0.02198635849376383
 BMIN    =  0.02198635849376383
 SRC_NAME= &#39;VOYAGER-1&#39;
 TRK_MODE= &#39;UNKNOWN &#39;
 RA_STR  = &#39;17:12:40.4400&#39;
 RA      =             258.1685
 DEC_STR = &#39;+12:24:14.7600&#39;
 DEC     =              12.4041
 LST     =                45322
 AZ      =              92.7495
 ZA      =              66.3982
 DAQPULSE= &#39;Thu Jul 16 18:13:55 2020&#39;
 DAQSTATE= &#39;record  &#39;
 NBITS   =                    8
 OFFSET0 =                  0.0
 OFFSET1 =                  0.0
 OFFSET2 =                  0.0
 OFFSET3 =                  0.0
 BANKNAM = &#39;BLP23   &#39;
 TFOLD   =                    0
 DS_FREQ =                    1
 DS_TIME =                    1
 FFTLEN  =                  512
 CHAN_BW =           -2.9296875
 BANDNUM =                    2
 NBIN    =                    0
 OBSNCHAN=                   64
 SCALE0  =                  1.0
 SCALE1  =                  1.0
 DATAHOST= &#39;blr2-3-10-3.gb.nrao.edu&#39;
 SCALE3  =                  1.0
 NPOL    =                    4
 POL_TYPE= &#39;AABBCRCI&#39;
 BANKNUM =                    3
 DATAPORT=                60000
 ONLY_I  =                    0
 CAL_DCYC=                  0.5
 DIRECTIO=                    1
 BLOCSIZE=            134217728
 ACC_LEN =                    1
 CAL_MODE= &#39;OFF     &#39;
 OVERLAP =                    0
 OBS_MODE= &#39;RAW     &#39;
 CAL_FREQ=                  0.0
 DATADIR = &#39;/datax/dibas&#39;
 OBSFREQ =        8345.21484375
 PFB_OVER=                   12
 SCANLEN =                300.0
 PARFILE = &#39;/opt/dibas/etc/config/example.par&#39;
 OBSBW   =               -187.5
 SCALE2  =                  1.0
 BINDHOST= &#39;eth4    &#39;
 PKTFMT  = &#39;1SFA    &#39;
 TBIN    = 3.41333333333333E-07
 BASE_BW =               1450.0
 CHAN_DM =                  0.0
 SCAN    =                   11
 STT_SMJD=                80036
 STT_IMJD=                59046
 STTVALID=                    1
 DISKSTAT= &#39;waiting &#39;
 NETSTAT = &#39;receiving&#39;
 PKTIDX  =                    0
 DROPAVG =          1.27322e-06
 DROPTOT =             0.719169
 DROPBLK =                    0
 PKTSTOP =             27459584
 NETBUFST= &#39;1/24    &#39;
 STT_OFFS=                    0
 SCANREM =                  0.0
 PKTSIZE =                 8192
 NPKT    =                16383
 NDROP   =                    0
 END</code></pre>



<p>Each 5 minute scan is divided in time into 14 GUPPI files. There are no gaps in the data between these 14 files, so an IQ file that is continuous in time can be obtained by concatenating the IQ samples extracted from these 14 files.</p>



<p>To extract the IQ data in the polyphase filterbank channel that contains the Voyager 1 signal, I have used <a href="https://github.com/UCBerkeleySETI/blimpy">blimpy</a> and the following Python script:</p>



<figure><div>

</div></figure>



<p>This can be run as</p>



<pre>for file in *.raw; do ~/extract_voyager.py $file ~/vgr1_$file; done</pre>



<p>The scans can be concatenated by using <code>cat</code> on the resulting files to obtain a single IQ file per scan. The resulting files are signed 8-bit IQ, since the data in the GUPPI files uses 8-bit sampling. The frequency axis in the files is inverted, so when reading the files, the complex conjugate of the data needs to be computed (or alternatively, I and Q can be swapped).</p>



<h4>Waterfall analysis</h4>



<p>To assess the quality of the recordings we compute a waterfall (time-frequency representation) using <a href="https://www.gnuradio.org/">GNU Radio</a>. This is done using the <a href="https://github.com/daniestevez/jupyter_notebooks/blob/master/Voyager1/voyager1_spectrum.grc"><code>voyager1_spectrum.grc</code> flowgraph</a>.</p>






<p>This flowgraph uses an FFT size of \(2^{20}\) points, which gives a frequency resolution of 2.79 Hz. The PSDs are integrated 30 times, so the resulting time resolution is 10.74 seconds. The waterfall data is written to a file, which is then plotted with <a href="https://github.com/daniestevez/jupyter_notebooks/blob/master/Voyager1/Voyager-1%20spectrum.ipynb">this Jupyter notebook</a>.</p>



<p>The following figures correspond to the first scan in the dataset, which has the filename <code>blc23_guppi_59046_80036_DIAG_VOYAGER-1_0011.raw</code>. Note that scans are numbered starting by 11.</p>



<p>The first figure is the spectrum of the polyphase filterbank channel that we have extracted. The residual carrier of Voyager 1, as well as the data subcarrier can be seen well above the noise (note that the scale is in linear units of power). </p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/voyager_spec.png"><img width="609" height="333" src="https://destevez.net/wp-content/uploads/2021/11/voyager_spec.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/voyager_spec.png 609w, https://destevez.net/wp-content/uploads/2021/11/voyager_spec-300x164.png 300w" sizes="(max-width: 609px) 100vw, 609px"/></a></figure>



<p>The next figure shows the waterfall of the carrier. The Doppler drift of the signal is apparent.</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/voyager_carrier.png"><img width="612" height="333" src="https://destevez.net/wp-content/uploads/2021/11/voyager_carrier.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/voyager_carrier.png 612w, https://destevez.net/wp-content/uploads/2021/11/voyager_carrier-300x163.png 300w" sizes="(max-width: 612px) 100vw, 612px"/></a></figure>



<p>A measurement of the signal power of the residual carrier and the noise is done in order to estimate the C/N0 of the carrier. The measurement is done independently for each spectrum (time slice) in the waterfall. The bin where the carrier has maximum power is selected as centre and a few bins about this centre are used to measure the signal power (plus the noise in those bins). The noise power per bin is measured by averaging some 200 bins of noise to each side of the carrier (leaving some small guard band so as not to measure any power leaked from the carrier). The appropriate noise power is subtracted from the measurement of the signal power to obtain the signal power alone.</p>



<p>In the plot we see that there are large variations in the power of the carrier, of up to 1.5 dB. The SNR of the carrier will be measured later in a different way, confirming these variations.</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/voyager_snr.png"><img width="624" height="333" src="https://destevez.net/wp-content/uploads/2021/11/voyager_snr.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/voyager_snr.png 624w, https://destevez.net/wp-content/uploads/2021/11/voyager_snr-300x160.png 300w" sizes="(max-width: 624px) 100vw, 624px"/></a></figure>



<p>Finally, the next figure shows the waterfall of one of the sidebands. As we remarked in the previous post, the spectral lines are due to some long runs of zeros in the data, which is sent unscrambled. When these zeros pass through the convolutional encoder, an alternating 0101 sequence is produced due to the inverter in one of the branches of the encoder.</p>



<p>The power of each of the two sidebands is also measured in order to estimate the Eb/N0 that is present in the data modulation. </p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/voyager_r_sideband.png"><img width="612" height="333" src="https://destevez.net/wp-content/uploads/2021/11/voyager_r_sideband.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/voyager_r_sideband.png 612w, https://destevez.net/wp-content/uploads/2021/11/voyager_r_sideband-300x163.png 300w" sizes="(max-width: 612px) 100vw, 612px"/></a></figure>



<p>As expected, the three ON scans show the Voyager 1 signal, while the three OFF scans show only noise. The estimates of the C/N0 of the carrier and the Eb/N0 of the data subcarrier (adding up the power of both sidebands) are shown in the table below.</p>



<figure><table><tbody><tr><td>Scan</td><td>Carrier C/N0 (dB)</td><td>Data Eb/N0 (dB)</td></tr><tr><td>11</td><td>23.74</td><td>6.33</td></tr><tr><td>13</td><td>20.49</td><td>3.13</td></tr><tr><td>15</td><td>23.21</td><td>5.90</td></tr></tbody></table><figcaption>SNR estimates of each ON scan</figcaption></figure>



<p>It is noteworthy that the middle ON scan has much worse SNR, approximately 3 dB less than the other scans. The figure below shows the signal and noise power measurement. The gain normalization is the same in all the recordings, so we see that the reduction of SNR is mainly due to an increase in the noise, which is around 3 dB stronger than in scan 11, and shows a large variation during the 5 minutes that the scan lasts. I do not know why the noise in this scan has increased so much.</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/voyager_snr_13.png"><img width="608" height="333" src="https://destevez.net/wp-content/uploads/2021/11/voyager_snr_13.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/voyager_snr_13.png 608w, https://destevez.net/wp-content/uploads/2021/11/voyager_snr_13-300x164.png 300w" sizes="(max-width: 608px) 100vw, 608px"/></a><figcaption>Signal and noise power measurement for scan 13</figcaption></figure>



<p>The last ON scan shows a behaviour that is similar to the first scan, although the SNR is some 0.5 dB worse. Again, there are large variations in the estimate of signal power.</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/voyager_snr_15.png"><img width="617" height="333" src="https://destevez.net/wp-content/uploads/2021/11/voyager_snr_15.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/voyager_snr_15.png 617w, https://destevez.net/wp-content/uploads/2021/11/voyager_snr_15-300x162.png 300w" sizes="(max-width: 617px) 100vw, 617px"/></a><figcaption>Signal and noise power measurement for scan 15</figcaption></figure>



<p>The SNR of the middle ON scan (number 13) is in fact too low to decode the telemetry signal, so we will only use the first and last ON scans (numbers 11 and 15).</p>



<h4>GNU Radio decoder</h4>



<p>The GNU Radio decoder flowgraph is based on the flowgraph that I used in the <a href="https://destevez.net/2021/09/decoding-voyager-1/">previous post</a>. It can be seen in the figure below (click on the figure to view it in full size). The flowgraph can be downloaded <a href="https://github.com/daniestevez/jupyter_notebooks/blob/master/Voyager1/voyager1_decoder.grc">here</a>.</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/voyager1_decoder.png"><img width="644" height="607" src="https://destevez.net/wp-content/uploads/2021/11/voyager1_decoder-644x607.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/voyager1_decoder-644x607.png 644w, https://destevez.net/wp-content/uploads/2021/11/voyager1_decoder-300x283.png 300w, https://destevez.net/wp-content/uploads/2021/11/voyager1_decoder-768x724.png 768w, https://destevez.net/wp-content/uploads/2021/11/voyager1_decoder-1536x1449.png 1536w, https://destevez.net/wp-content/uploads/2021/11/voyager1_decoder-1568x1479.png 1568w, https://destevez.net/wp-content/uploads/2021/11/voyager1_decoder.png 1616w" sizes="(max-width: 644px) 100vw, 644px"/></a><figcaption>GNU Radio Voyager 1 decoder flowgraph</figcaption></figure>



<p>In comparison to the recording from 2015, which was easy to decode, these recordings are more difficult to decode, since the SNR is closer to the decoding threshold. The figure below, which is taken from the <a href="https://public.ccsds.org/Pubs/130x1g3.pdf">CCSDS TM Synchronization and Channel Coding Green Book</a>, shows the BER of the rate 1/2 convolutional code used by Voyager 1. Frames are 7680 bits long, so for a FER of 1% we need a BER of \(10^{-6}\). This is achieved at 4.8 dB Eb/N0. We see that we have somewhat more than 1 dB of margin, so in principle things look good.</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/convolutional_code_ber.png"><img width="644" height="381" src="https://destevez.net/wp-content/uploads/2021/11/convolutional_code_ber-644x381.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/convolutional_code_ber-644x381.png 644w, https://destevez.net/wp-content/uploads/2021/11/convolutional_code_ber-300x178.png 300w, https://destevez.net/wp-content/uploads/2021/11/convolutional_code_ber-768x455.png 768w, https://destevez.net/wp-content/uploads/2021/11/convolutional_code_ber.png 1083w" sizes="(max-width: 644px) 100vw, 644px"/></a><figcaption>BER of the rate 1/2 convolutional code, taken from the <a href="https://public.ccsds.org/Pubs/130x1g3.pdf">CCSDS Green Book</a></figcaption></figure>



<p>However, in practice the decoder doesn’t work so well. First, there’s always going to be some implementation losses in the decoder. Also, as we will see below, the large variations in signal power (of around 1 dB) that we have noticed above will give problems, causing burst errors in the Viterbi decoder output.</p>



<p>To try to understand the performance of the decoder better and see if it could be improved, I have tried to monitor the SNR of the data subcarrier in different points of the decoding chain. The GNU Radio flowgraph outputs to a File Sink in several intermediate steps. The signal is then analyzed in a Jupyter notebook to estimate its Eb/N0. These points are described in the sections below.</p>



<h4>PLL output</h4>



<p>The first intermediate step where the SNR is measured is the output of the PLL. Assuming an ideal carrier phase recovery, the two sidebands of the data subcarrier should add coherently, yielding the Eb/N0 that has been estimated above by adding the power of the two sidebands. However, the PLL does not track the carrier signal perfectly, so some power will be lost in the coherent combination of the data sidebands.</p>



<p>The calculations and plots are done in <a href="https://github.com/daniestevez/jupyter_notebooks/blob/master/Voyager1/Data%20sideband.ipynb">this Jupyter notebook</a>. The figure below shows the data subcarrier at the output of the PLL. The FFT frequency resolution is 1.28 Hz. This makes visible not only the two tones due to the 010101 sequences in the symbols, but also their odd harmonics. These are caused by the square pulse shape filter.</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/voyager1_subcarrier.png"><img width="606" height="333" src="https://destevez.net/wp-content/uploads/2021/11/voyager1_subcarrier.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/voyager1_subcarrier.png 606w, https://destevez.net/wp-content/uploads/2021/11/voyager1_subcarrier-300x165.png 300w" sizes="(max-width: 606px) 100vw, 606px"/></a></figure>



<p>In fact, the power decay of these harmonics matches that of a square wave, which is \(20 \log_{10} k\), so that the 3rd harmonic of a square wave is 9.54 dB below the fundamental, the 5th is 13.98 dB down, the 7th is 19.08 dB down, and the 11th is 20.83 dB down. We need to take into account that the PSD shows (S+N)/N rather than S/N. Assuming an (S+N)/N of the fundamental of 13 dB (which is more or less what we see in the plot), the (S+N)/N of the square wave odd harmonics would be 4.92, 2.45, 1.42 and 0.91 dB, which agrees with what we see here.</p>



<p>The area marked in dark blue in the plot is used to measure the signal plus noise power, and the area marked in light blue is used to measure the noise power. This gives the following Eb/N0 estimates for the data subcarrier after the PLL. The estimates done in the waterfall are shown for comparison.</p>



<figure><table><tbody><tr><td>Scan</td><td>PLL output Eb/N0 (dB)</td><td>Waterfall Eb/N0 (dB)</td><td>Loss (dB)</td></tr><tr><td>11</td><td>5.97</td><td>6.33</td><td>0.36</td></tr><tr><td>15</td><td>5.32</td><td>5.90</td><td>0.58</td></tr></tbody></table><figcaption>Eb/N0 estimates at PLL output</figcaption></figure>



<p>The cause of losses in the PLL are the phase errors in the carrier phase recovery. To put things in perspective, it is good to see what constant phase error would give the losses we observe. Since the loss in dB units is \(20 \log_{10}(cos \theta)\), where \(\theta\) is the phase error in radians, we see that a loss of 0.36 dB corresponds to a phase error of 16.4 degrees, and a loss of 0.58 dB corresponds to a phase error of 20.7 degrees.</p>



<p>The variance for the PLL phase error is approximately \(\sigma^2 = 1/\rho\), where \(\rho\) denotes the loop SNR, which can be computed as \(\rho = C/(N_0B_L)\), with \(B_L\) the loop bandwidth. More precisely, the PLL phase error distribution is a <a href="https://en.wikipedia.org/wiki/Von_Mises_distribution">Tikhonov distribution</a> with parameter \(\kappa = \rho\). For large \(\rho\), the Tikhonov distribution can be approximated by a normal distribution with variance \(1/\rho\). For more details about the PLL error, see for instance <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.167.6375&amp;rep=rep1&amp;type=pdf">this paper</a>. The corresponding carrier C/N0’s, loop bandwidths and phase error standard deviations are shown in this table.</p>



<figure><table><tbody><tr><td>Scan</td><td>Carrier C/N0 (dB)</td><td>Loop bandwidth (Hz)</td><td>Phase error \(\sigma\) (deg)</td></tr><tr><td>11</td><td>23.74</td><td>2.5</td><td>6.26</td></tr><tr><td>15</td><td>23.21</td><td>5</td><td>8.85</td></tr></tbody></table><figcaption>PLL phase error due to AWGN</figcaption></figure>



<p>Note that a loop bandwidth of 5 Hz was used in scan 15 because the loop bandwidth of 2.5 Hz didn’t lock the loop properly.</p>



<p>These phase errors due to AWGN are significantly smaller than the phase errors of 16.4 and 20.7 degrees that we have mentioned above.</p>



<p>We can be more precise and compute the average power loss using the phase error Tikhonov distribution\[f(\theta) = \frac{\exp(\rho \cos \theta)}{2\pi I_0(\rho)}.\]Assuming that the subcarrier has power one at the input of the PLL, the average power of the subcarrier at the PLL output is\[\int_{-\pi}^\pi \cos^2(\theta) f(\theta)\, d\theta.\]This integral can be evaluated numerically for the values of \(\rho\) corresponding to each of the scans we are studying. We obtain losses of 0.05 dB and 0.10 dB for scans 11 and 15 respectively. These are much smaller than the losses we are observing.</p>



<p>Another source of error in PLLs is the steady state error due to higher order dynamics that are not modelled by the loop filter. For a loop filter of order 2, such as the one used by the PLL blocks in GNU Radio, the steady state error is\[\widetilde{\varphi}_{ss} \approx \frac{1}{2B_L^2}\varphi”.\]The exact value depends on the of the placement of the loop poles, but it is proportional to \(\varphi”/B_L^2\).</p>



<p>In our case, the Doppler drift rate is approximately 110 Hz over 300 seconds. This gives 2.3 rad/s². With a loop bandwidth of 2.5 Hz, we get a steady state error of 10.5 degrees, and with a loop bandwidth of 5 Hz we get a steady state error of 2.6 degrees. In the case of scan 11 this might account for the losses we see, since, roughly speaking, 11 degrees of steady state error plus 6 degrees of error due to noise would give the 17 degrees of error that correspond to the 0.36 dB loss we are seeing. In the case of scan 15 this doesn’t account for the losses, since we only have 3 degrees of steady state error plus 9 degrees of error due to noise, but we need a total of 21 degrees of error to explain the 0.58 dB loss.</p>



<p>It might be a good idea to remove the Doppler drift (which is almost a constant) to reduce the stress on the PLL and check if this reduces the PLL losses.</p>



<p>Something else that can be measured at the output of the PLL is the subcarrier frequency. By using the two strongest spectral lines, we can measure a frequency of 22497.3 Hz. This is an error of -117.9 ppm with respect to the nominal 22.5 kHz subcarrier. According to <a href="https://ssd.jpl.nasa.gov/horizons/app.html">NASA HORIZONS</a>, the range-rate at the time when the recording was made was 31.599 km/s. This would give a Doppler of -105.4 ppm, which agrees with the observed value. However, we need to take into account that the FFT resolution is not good enough to measure this accurately, as one FFT bin corresponds to 56.9 ppm of 22.5 kHz.</p>



<h4>Costas loop output</h4>



<p>The data subcarrier is processed with the Symbol Sync GNU Radio block to perform pulse shape filtering and symbol clock recovery. The maximum likelihood time error detector is used. This forces us to use a pulse shape with continuous derivate, since the maximum likelihood TED needs the derivative filter. Thus, instead of using a square pulse shape we use a root-raised cosine pulse shape. The excess bandwidth is set to 1.0, since that seems to work best regarding output SNR. The loop bandwidth is set to a low value. After symbol synchronization, a Costas loop is used to recover the residual subcarrier phase and frequency. It uses a low loop bandwidth.</p>



<p>At the output of the Costas loop we should have the optimally sampled and filtered symbols in the I component, and noise in the Q component. The figure below shows the symbols obtained from scan 11. The first 5000 symbols have been thrown away, since the loops haven’t locked yet.</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/voyager1_symbols.png"><img width="608" height="333" src="https://destevez.net/wp-content/uploads/2021/11/voyager1_symbols.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/voyager1_symbols.png 608w, https://destevez.net/wp-content/uploads/2021/11/voyager1_symbols-300x164.png 300w" sizes="(max-width: 608px) 100vw, 608px"/></a></figure>



<p>To estimate the SNR of the signal at this point we use the \(M_2M_4\) estimator described in the paper “<a href="https://www.researchgate.net/publication/3160255_A_Comparison_of_SNR_estimation_techniques_for_the_AWGN_channel">A Comparison of SNR estimation techniques for the AWGN channel</a>“. For a complex signal, this estimator is\[\frac{\sqrt{2M_2^2-M_4}}{M_2 – \sqrt{2M_2^2-M_4}},\]where \(M_2\) and \(M_4\) denote the second and fourth order moments respectively:\[M_2 = E[|x_n|^2],\quad M_4 = E[|x_n|^4].\]</p>



<p>In the table below we compare the results of this SNR estimator with the SNR estimates done before symbol synchronization.</p>



<figure><table><tbody><tr><td>Scan</td><td>Costas output Eb/N0 (dB)</td><td>PLL output Eb/N0 (dB)</td><td>Loss (dB)</td></tr><tr><td>11</td><td>5.40</td><td>5.97</td><td>0.57</td></tr><tr><td>15</td><td>4.77</td><td>5.32</td><td>0.55</td></tr></tbody></table><figcaption>Eb/N0 estimates at Costas loop output</figcaption></figure>



<p>Again, we have noticeable losses in this step of the decoder chain. Some of the losses can be explained by the mismatch between the transmit pulse shape filter (which is is a square shape) and the receiver filter (for which we are using an RRC filter). Here there is an opportunity for improvement by trying to use a square pulse shape in the receiver. Loop jitter can also explain some of the losses, but however the loop bandwidths are already set quite narrow to minimize jitter.</p>



<h4>BCJR decoder</h4>



<p>Usually, we would send the soft symbols to a Viterbi decoder, since Voyager 1 uses the typical CCSDS \(k=7, r=1/2\) convolutional code. However, the SNR is not good enough for error-free decode. When trying to study the contents of the frames to do reverse engineering, it can be rather hard to do so when there are bit errors, because some of the patterns we spot may be caused by bit errors rather than by the actual contents of the frames. It is much more helpful to have some soft output FEC decoder, since that gives us a level of confidence in the decoded data that we can use as a guide when interpreting the output.</p>



<p>Instead of using a <a href="https://en.wikipedia.org/wiki/Viterbi_algorithm#Soft_output_Viterbi_algorithm">soft output Viterbi algorithm</a>, I have decided to use the <a href="https://en.wikipedia.org/wiki/BCJR_algorithm">BCJR algorithm</a>. The whole output from each scan is processed at once by the BCJR decoder. The implementation of the decoder follows Algorithm 4.2 in the book “<a href="https://www.cambridge.org/core/books/iterative-error-correction/7964EAB1B743D56D2E9B58CCA4CE71EB">Iterative Error Correction</a>” by Sarah Johnson. As in this book, the implementation I have done favours readability rather than efficiency. The BCJR decoder and the related plots are implemented in <a href="https://github.com/daniestevez/jupyter_notebooks/blob/master/Voyager1/BCJR.ipynb">this Jupyter notebook</a>.</p>



<p>To try to achieve the best performance with the BCJR decoder, we attempt to give it the best possible estimate on the noise variance \(\sigma^2\). To do so, we run the decoder with an initial estimate. We run hard decision on the BCJR output and encode the result with the convolutional code. We use this to wipe-off the data in our symbols. There are some symbol errors still, but most of the symbols are correct. Then we can measure the mean and variance of the wiped-off symbols, and use that to supply the BCJR decoder an improved estimate of \(\sigma^2\). We repeat this process a few times to improve the results.</p>



<p>The figure below shows the soft output of the BCJR decoder, which is the log-likelihood ratio for the bits. At the beginning the output is around zero because the loops haven’t locked yet. Then we see that most of the time the decoder is able to correct all the errors, but there are several times when the log-likelihood ratio drops close to zero. As we will see later, these seem to correspond to drops in the CN0 of the carrier.</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/bcjr_L_11.png"><img width="626" height="333" src="https://destevez.net/wp-content/uploads/2021/11/bcjr_L_11.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/bcjr_L_11.png 626w, https://destevez.net/wp-content/uploads/2021/11/bcjr_L_11-300x160.png 300w" sizes="(max-width: 626px) 100vw, 626px"/></a></figure>



<p>The next figure shows the wiped-off symbols, using the re-encoded hard decision on the output from the BCJR decoder. We see that most of the symbols have been wiped off correctly. This is used to estimate the amplitude and noise variance of the signal.</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/bcjr_wipe_11.png"><img width="608" height="333" src="https://destevez.net/wp-content/uploads/2021/11/bcjr_wipe_11.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/bcjr_wipe_11.png 608w, https://destevez.net/wp-content/uploads/2021/11/bcjr_wipe_11-300x164.png 300w" sizes="(max-width: 608px) 100vw, 608px"/></a></figure>



<p>We can use the amplitude and noise variance of this wiped-off signal to estimate the Eb/N0. If we denote by \(y_n\) the wiped-off symbols, an estimate of the SNR is given by \(E[y_n]/(2E[|y_n|^2])\). Alternatively, we can use equation (31) in the paper “<a href="https://www.researchgate.net/publication/3160255_A_Comparison_of_SNR_estimation_techniques_for_the_AWGN_channel">A Comparison of SNR estimation techniques for the AWGN channel</a>“, which is known as the SNV TxDA estimate for a real signal. This gives a very similar result.</p>



<p>The table below compares the results of this estimate with the \(M_2M_4\) estimate obtained at the output of the Costas loop. We see that the results are slightly lower. Perhaps the reason is due to the occasional symbol errors after wipe-off, or just to the different estimators used</p>



<figure><table><tbody><tr><td>Scan</td><td>Wipe-off Eb/N0 (dB)</td><td>Costas output Eb/N0 (dB)</td><td>Difference (dB)</td></tr><tr><td>11</td><td>5.26</td><td>5.40</td><td>0.14</td></tr><tr><td>15</td><td>4.61</td><td>4.77</td><td>0.16</td></tr></tbody></table><figcaption>Eb/N0 estimates using wipe-off</figcaption></figure>



<p>To assess the performance of the BCJR decoder at this SNR, we can build a simulated signal on AWGN and run it through the decoder. These are the results of decoding a simulated signal at the same SNR as scan 11. We see that the decoder works very well, and there should be no errors at its output. This matches the fact that a convolutionally encoded signal can be decoded without problems at an Eb/N0 of 5 dB.</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/bcjr_simulated.png"><img width="614" height="333" src="https://destevez.net/wp-content/uploads/2021/11/bcjr_simulated.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/bcjr_simulated.png 614w, https://destevez.net/wp-content/uploads/2021/11/bcjr_simulated-300x163.png 300w" sizes="(max-width: 614px) 100vw, 614px"/></a></figure>



<p>Therefore, we see that the problem with our recordings is that the SNR is not stationary. There are some sudden SNR drops that cause errors in the BCJR decoder (or in the Viterbi decoder).</p>



<h4>Carrier SNR</h4>



<p>These SNR drops might be caused by several factors. The most obvious cause are drops in the SNR of the phase-modulated signal. There are other possible explanations, such as instability in the phase/clock of the signal, which would cause larger errors in the loops.</p>



<p>To try to understand the cause of these drops, we perform an SNR estimate on the residual carrier. We have already such an estimate using the waterfall, but the time resolution was not high enough to see the drops clearly.</p>



<p>To perform the SNR estimate, we take the output of the PLL and run it through a low pass filter with a noise bandwidth of 10 kHz. The output of this filter is integrated coherently down to a 10 Hz rate. Additionally, the complex magnitude squared of the filter output is taken and integrated down to a 10 Hz rate. These two outputs are processed in <a href="https://github.com/daniestevez/jupyter_notebooks/blob/master/Voyager1/Residual%20carrier.ipynb">a Jupyter notebook</a>.</p>



<p>The next figure shows the 10 Hz coherent integrations of the PLL output corresponding to scan 11. As expected, the residual carrier appears in the I component, while the Q component contains noise and leakage from the carrier due to phase noise. In fact we see that the noise variance in the Q component is much larger than in the I component, so the extra noise variance must be due to phase noise (see above for some notes on the PLL phase jitter).</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/narrow_11.png"><img width="620" height="333" src="https://destevez.net/wp-content/uploads/2021/11/narrow_11.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/narrow_11.png 620w, https://destevez.net/wp-content/uploads/2021/11/narrow_11-300x161.png 300w" sizes="(max-width: 620px) 100vw, 620px"/></a></figure>



<p>We also see some sudden drops in the amplitude of the I component. There is an AGC in the flowgraph, but since the AGC acts on the full 83.7 kHz bandwidth, the noise power dominates the AGC input, so the changes in amplitude we see here correspond to changes in SNR (which actually are caused by changes in the signal power).</p>



<p>The plot below shows an estimate of the CN0 of the residual carrier with a resolution of one second. This has been obtained by averaging the 10 Hz measurements in groups of 10 and then noting that the coherent integrations measure signal power plus noise in 10 Hz, while the power at the filter output measures signal power plus noise in 10 kHz.</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/carrier_cn0_11.png"><img width="615" height="333" src="https://destevez.net/wp-content/uploads/2021/11/carrier_cn0_11.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/carrier_cn0_11.png 615w, https://destevez.net/wp-content/uploads/2021/11/carrier_cn0_11-300x162.png 300w" sizes="(max-width: 615px) 100vw, 615px"/></a></figure>



<p>The changes in the CN0 show the same behaviour as in the plot with lower temporal resolution obtained from the waterfall. The CN0 has large variations of up to 2.5 dB. It seems that the drops in the log-likelihood ratio of the BCJR are somewhat related to these drops in CN0, but the match is not completely perfect.</p>



<p>The two figures below show the corresponding plots for scan 15.</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/narrow_15.png"><img width="620" height="333" src="https://destevez.net/wp-content/uploads/2021/11/narrow_15.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/narrow_15.png 620w, https://destevez.net/wp-content/uploads/2021/11/narrow_15-300x161.png 300w" sizes="(max-width: 620px) 100vw, 620px"/></a></figure>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/carrier_cn0_15.png"><img width="615" height="333" src="https://destevez.net/wp-content/uploads/2021/11/carrier_cn0_15.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/carrier_cn0_15.png 615w, https://destevez.net/wp-content/uploads/2021/11/carrier_cn0_15-300x162.png 300w" sizes="(max-width: 615px) 100vw, 615px"/></a></figure>



<h4>Telemetry frames</h4>



<p>We can take the log-likelihood ratios produced by the BCJR decoder and detect the ASM, which is <code>0x03915ED3</code>, in order to correct the for the possible 180º phase ambiguity in the Costas loop and to align with the telemetry frames. Then we can do a raster plot of the log-likelihoods of the bits in each of the frames.</p>



<p>The raster plot is done by sections of 128 bits. In the raster plots each of the frames is shown as a row, while each column corresponds to the bit position in the frame. The red colours correspond to ones (positive log-likelihood ratios), and the blue colours corresponds to zeros (negative log-likelihood rations). Lighter colours correspond to log-likelyhood ratios with smaller magnitude, which mean that the BCJR decoder is not so sure about the correct output. The first plot is shown below.</p>



<figure><a href="https://destevez.net/wp-content/uploads/2021/11/voyager1_frame0.png"><img width="592" height="361" src="https://destevez.net/wp-content/uploads/2021/11/voyager1_frame0.png" alt="" srcset="https://destevez.net/wp-content/uploads/2021/11/voyager1_frame0.png 592w, https://destevez.net/wp-content/uploads/2021/11/voyager1_frame0-300x183.png 300w" sizes="(max-width: 592px) 100vw, 592px"/></a><figcaption>First 128 bits from 12 frames from Voyager 1</figcaption></figure>



<p>First we can see the 32 bit ASM. Then we see an interesting pattern around bit 40 that changes every other frame. Around frame 50 we see a counter which is at least 6 bits wide. After the first 64 bits we have almost a repetition of the same data. The same 32 bit ASM appears on position 64, we have the changing pattern around bit 105, and also the counter around bit 115. We note that some of the bits with a lighter colour have decoding errors, but the log-likelihood information from the BCJR decoder helps us spot and discard these.</p>



<p>The Voyager 1 frames are 7680 bits long, so there are a total of 60 plots of segments of 128 bits. All these are shown in <a href="https://github.com/daniestevez/jupyter_notebooks/blob/master/Voyager1/Voyager%201%20frames.ipynb">this Jupyter notebook</a>. Other than finding a few binary counters and observing the general structure of the frames, I haven’t been able to figure out the meaning of any of this data.</p>



<h4>Data and results</h4>



<p>Most of the data used in this post (excepting large files), as well as the code used for the calculations and figures can be found in <a href="https://github.com/daniestevez/jupyter_notebooks/tree/master/Voyager1">this repository</a>.</p>
	</div><!-- .entry-content -->

	<!-- .entry-footer -->

				
</article></div>
  </body>
</html>
