<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mo8it.com/blog/quadlet/">Original</a>
    <h1>Quadlet: Running Podman containers under systemd</h1>
    
    <div id="readability-page-1" class="page"><article>
        

        <p>Quadlet lets you run your Podman containers as systemd services.
This is especially useful for running containers in the background and automatically starting them after a server reboot.</p>
<p>Running Podman containers under systemd isn&#39;t new.
Indeed, this was supported by Podman for a long time with the command <a href="https://docs.podman.io/en/latest/markdown/podman-generate-systemd.1.html"><code>podman generate systemd</code></a>.
But this command now shows a deprecation warning to migrate to Quadlet.</p>
<p>For some months, I was too lazy to do that migration on my home server.
Why even touch a working system?
But now that I finally found time for it, I really appreciate Quadlet!
I think that Podman finally has a Docker Compose alternative which is even more flexible and powerful!</p>
<p>In this blog post, I will explain how to use Quadlet with <strong>rootless</strong> Podman and migrate from the old method with <code>podman generate systemd</code>.</p>
<span id="continue-reading"></span><div>
    <div>
        <p>Note</p>
        <p>If you wonder why systemd: Something has to start containers when there is no daemon (since Podman is daemonless).</p>
<p>If you are part of the vocal minority hating against systemd, then please leave instead of trolling.</p>

    </div>
</div>

    <p>Landscape mode recommended on mobile devices</p>

    
        
    

<h2 id="the-deprecated-method"><a href="#the-deprecated-method">The deprecated method</a></h2>
<p>Let&#39;s see how the old method worked before comparing it to Quadlet.
You can skip to the Quadlet section though.</p>
<p>First, you had to create a container.
In an older post about <a href="https://mo8it.com/blog/containerized-postgresql-with-rootless-podman/">Containerized PostgreSQL with rootless Podman</a>, I created a container with a command similar to the following:</p>
<pre data-lang="fish"><code data-lang="fish"><span>podman </span><span>create </span><span>\
</span><span>  </span><span>--name </span><span>test-db </span><span>\
</span><span>  </span><span>-p </span><span>5432:5432 </span><span>\
</span><span>  </span><span>-v </span><span>~</span><span>/volumes/test-db:/var/lib/postgresql/data:Z </span><span>\
</span><span>  </span><span>-e </span><span>POSTGRES_PASSWORD=CHANGE_ME </span><span>\
</span><span>  </span><span>--label </span><span>&#34;io.containers.autoupdate=registry&#34; </span><span>\
</span><span>  docker.io/library/postgres:16
</span></code></pre>
<p>The command details are explained in the older post.
The only option that isn&#39;t explained there is <code>--label &#34;io.containers.autoupdate=registry&#34;</code>.
This option enables updating the container image using <code>podman auto-update</code> which will be explained later in this post.</p>
<p>After creating the container, you can run the following command:</p>
<pre data-lang="fish"><code data-lang="fish"><span>podman </span><span>generate systemd test-db </span><span>-fn --new
</span></code></pre>
<p>It creates the systemd service file <code>container-test-db.service</code> in your current path.
The options of the command aren&#39;t relevant for now, but they are also explained in the older post.</p>
<p>To use this generated service file, you had to place it in the directory <code>~/.config/systemd/user</code>.
To enable and start it, you had to run the following command:</p>
<pre data-lang="fish"><code data-lang="fish"><span>systemctl </span><span>--user </span><span>enable </span><span>--now </span><span>container-test-db
</span></code></pre>
<h2 id="the-problem"><a href="#the-problem">The problem</a></h2>
<p>The problem with the old method is that it required you to run commands to…</p>
<ol>
<li>create a container</li>
<li>generate a service file</li>
<li>move the service file if not already in the mentioned directory</li>
<li>enable the service</li>
</ol>
<p>Especially the command for creating the container is often lengthy.
This means that you had to create a shell script with these commands if you wanted to be able to rerun them later.</p>
<p>To reduce duplication, I created the following fish function to be called in my fish scripts that create the containers:</p>
<pre data-lang="fish"><code data-lang="fish"><span>function </span><span>podman-default-create
</span><span>    </span><span>set </span><span>-l </span><span>container_name $argv[</span><span>1</span><span>]
</span><span>
</span><span>    </span><span>podman </span><span>create </span><span>\
</span><span>        </span><span>--name </span><span>$container_name </span><span>\
</span><span>        </span><span>--replace </span><span>\
</span><span>        $argv[</span><span>2</span><span>..</span><span>]</span><span>; </span><span>or return </span><span>1
</span><span>
</span><span>    </span><span>podman </span><span>generate systemd </span><span>--no-header --new --name </span><span>$container_name </span><span>&gt;~</span><span>/.config/systemd/user/container-$container_name.service</span><span>; </span><span>or return </span><span>1
</span><span>
</span><span>    </span><span>systemctl </span><span>--user </span><span>enable </span><span>--now </span><span>container-$container_name
</span><span>end
</span></code></pre>
<p>You don&#39;t have to understand the details of the function above.
What I want to demonstrate with it is that the old method was too hacky and involved the usage of redundant commands.</p>
<p>There must be an easier way, you might think.
Especially if you experienced the convenience that Docker Compose provides.
But this is not the only problem.
The old method is very inflexible!</p>
<p>If you want to cutomize the service file and use all systemd features, you need to <em>manually</em> edit it <em>after each generation</em>!</p>
<h2 id="quadlet"><a href="#quadlet">Quadlet</a></h2>
<p>Let&#39;s take a look at the new method with Quadlet.</p>
<p>First, you create the directory <code>~/.config/containers/systemd</code>.
Then, you place a <code>.container</code> file inside it.
For example, here is the <code>test-db.container</code> file:</p>
<pre data-lang="ini"><code data-lang="ini"><span>[Container]
</span><span>Image</span><span>=</span><span>docker</span><span>.</span><span>io</span><span>/</span><span>library</span><span>/</span><span>postgres</span><span>:</span><span>16
</span><span>AutoUpdate</span><span>=</span><span>registry
</span><span>PublishPort</span><span>=</span><span>5432</span><span>:</span><span>5432
</span><span>Volume</span><span>=</span><span>%h</span><span>/</span><span>volumes</span><span>/</span><span>test</span><span>-</span><span>db</span><span>:/</span><span>var</span><span>/</span><span>lib</span><span>/</span><span>postgresql</span><span>/</span><span>data</span><span>:</span><span>Z
</span><span>Environment</span><span>=</span><span>POSTGRES_PASSWORD</span><span>=</span><span>CHANGE_ME
</span><span>
</span><span>[Service]
</span><span>Restart</span><span>=</span><span>always
</span><span>
</span><span>[Install]
</span><span>WantedBy</span><span>=</span><span>default</span><span>.</span><span>target
</span></code></pre>
<p>It is a normal systemd service file but with the special section <code>[Container]</code>.
This section has <a href="https://docs.podman.io/en/latest/markdown/podman-systemd.unit.5.html#container-units-container">many documented options</a>.
Almost all these options map to command line options that can be used to create a container with Podman (<code>podman create</code>).
The ones that we are interested in for the example are the following:</p>
<ul>
<li><code>Image</code> specifies the image (with tag) to use</li>
<li><code>AutoUpdate=registry</code> maps to <code>--label &#34;io.containers.autoupdate=registry&#34;</code> (explained later in this post)</li>
<li><code>PublishPort</code> maps to <code>-p</code></li>
<li><code>Volume</code> maps to <code>-v</code></li>
<li><code>Environment</code> maps to <code>-e</code></li>
</ul>
<p>It is important to use the <a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#Specifiers">systemd specifier</a> <code>%h</code> instead of <code>~</code> for the user home directory.</p>
<p>In the <code>[Service]</code> section, we use the <a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.service.html#Restart="><code>Restart</code></a> option and set it to <code>always</code> to always restart the container (unless stopped manually).</p>
<p>To automatically start the container on boot, we set the <a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#WantedBy="><code>WantedBy</code></a> option in the <code>[Install]</code> section to <code>default.target</code>.</p>
<div>
    <div>
        <p>Note</p>
        <p>I thought that setting <code>WantedBy</code> to <code>multi-user.target</code> would work because it is the default target on servers.
But it doesn&#39;t work in the case of rootless containers.</p>
<p><code>multi-user.target</code> is not defined in the user mode in systemd.
You can verify this by running the command <code>systemctl --user status multi-user.target</code>.
It is only defined in the system mode (<code>systemctl status multi-user.target</code> without <code>--user</code>).</p>

    </div>
</div>
<p>Since we use user services for systemd, we have to enable the <em>linger</em> for our user to start the containers without the user being logged in:</p>
<pre data-lang="fish"><code data-lang="fish"><span>loginctl </span><span>enable-linger
</span></code></pre>
<div>
    <div>
        <p>⚠️ Warning ⚠️</p>
        <p>Enabling the linger is required for the container to be automatically started after a server reboot!</p>

    </div>
</div>
<p>For systemd to discover the new service file, run <code>systemctl --user daemon-reload</code>.
Now, you can start the container with <code>systemctl --user start test-db</code>.</p>
<p>You can check the status of the container service by running <code>systemctl --user status test-db</code>.
You can also verify that the Podman container is running by running <code>podman ps</code>.
You should find the container <code>systemd-test-db</code>.</p>
<p>The container has the name of the service file (<code>test-db.container</code> without the <code>.container</code> extension) prefixed by <code>systemd-</code> to avoid collisions with containers not managed by systemd.
But you can manually set the name of the container using the <code>ContainerName</code> option in the <code>[Container]</code> section.</p>
<h2 id="is-it-any-better"><a href="#is-it-any-better">Is it any better?</a></h2>
<p>My first impression was: &#34;Well, now I have to map all the <code>podman create</code> options to their equivalents in the <code>[Container]</code> section. Where is the benefit?&#34;.</p>
<p>But after migrating all containers, I found the following benefits:</p>
<ul>
<li>You have only one file (the container service file) instead of a script that generates a service file.</li>
<li>You can use all options possible in systemd. All options that you know about in the <code>[Unit]</code> and <code>[Service]</code> sections are supported. For example, you can specify a command to run before starting the container by setting the <code>StartExecPre</code> option. No more manual editing of generated files anymore!</li>
<li>Rather subjective: Writing configuration files is easier than writing and debugging shell scripts.</li>
<li>It is easier to handle dependencies as we will see in the next section.</li>
</ul>
<h2 id="dependencies"><a href="#dependencies">Dependencies</a></h2>
<p>Let&#39;s assume that we have an app container that depends on the database container that we created.</p>
<p>You want the database container to be automatically started when the app container is started.
You also want to make sure that the app container is started <strong>after</strong> the database container.
Otherwise, the app container might fail to start.</p>
<p>How can we express this dependency?</p>
<p>Let&#39;s use <a href="https://codeberg.org/mo8it/oxitraffic/">OxiTraffic</a> as an example (shameless plug 😅).</p>
<p>Here is the container service file <code>oxitraffic.container</code> that should be placed in <code>~/.config/containers/systemd</code>:</p>
<pre data-lang="ini"><code data-lang="ini"><span>[Container]
</span><span>Image</span><span>=</span><span>docker</span><span>.</span><span>io</span><span>/</span><span>mo8it</span><span>/</span><span>oxitraffic</span><span>:</span><span>0</span><span>.</span><span>9</span><span>.</span><span>2
</span><span>AutoUpdate</span><span>=</span><span>registry
</span><span>Volume</span><span>=</span><span>%h</span><span>/</span><span>volumes</span><span>/</span><span>oxitraffic</span><span>/</span><span>config</span><span>.</span><span>toml</span><span>:/</span><span>volumes</span><span>/</span><span>config</span><span>.</span><span>toml</span><span>:</span><span>Z</span><span>,</span><span>ro
</span><span>Volume</span><span>=</span><span>%h</span><span>/</span><span>volumes</span><span>/</span><span>oxitraffic</span><span>/</span><span>logs</span><span>:/</span><span>var</span><span>/</span><span>log</span><span>/</span><span>oxitraffic</span><span>:</span><span>Z
</span><span>
</span><span>[Unit]
</span><span>Requires</span><span>=</span><span>test</span><span>-</span><span>db</span><span>.</span><span>service
</span><span>After</span><span>=</span><span>test</span><span>-</span><span>db</span><span>.</span><span>service
</span><span>
</span><span>[Service]
</span><span>Restart</span><span>=</span><span>always
</span><span>
</span><span>[Install]
</span><span>WantedBy</span><span>=</span><span>default</span><span>.</span><span>target
</span></code></pre>
<p>The new section is <code>[Unit]</code>.
We set the <a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#Requires="><code>Requires</code></a> option to <code>test-db.service</code> to only start the app when the database is started.
We also set the <a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#Before="><code>After</code></a> option to make sure that both containers aren&#39;t started in parallel.</p>
<p>Note that we use <code>test-db.service</code> when referencing this container service and not <code>test-db.container</code>.</p>
<ul>
<li><code>test-db.container</code> is the file name.</li>
<li><code>test-db.service</code> is the service name.</li>
<li><code>systemd-test-db</code> is the default container name.</li>
</ul>
<p>For the app to communicate with the database, a network should be added to both containers with the <code>Network</code> option in the <code>[Container]</code> section, but networking is out of the scope of this post.</p>
<h2 id="too-many-files"><a href="#too-many-files">Too many files?</a></h2>
<p>In our example, we created two files, one for the app container and one for the database container.
Does this mean that multi-container apps are more complex with Quadlet because you can&#39;t just put them in one file like with Docker Compose?</p>
<p>It depends on how you define complexity in this context.
Does splitting content over multiple files always result in a higher complexity?</p>
<p>For me, it is more complex to have everything in the same file.
I had to maintain Docker Compose files with hundreds of lines and dozens of containers…
That wasn&#39;t fun!
Having each container in its own file has less mental overhead for me because I just have to think about this single container when I am in its file.
Of course, you need to specify its dependencies on other containers, but you don&#39;t need to think about the details of these other containers.</p>
<p><a href="https://github.com/mailcow/mailcow-dockerized/blob/cb0b0235f01a8e4102ece9540fe0aa3bb2b60d72/docker-compose.yml">The Docker Compose file of Mailcow</a> is a <strong>terrifying</strong> example of huge Docker Compose files.</p>
<div>
    <div>
        <p>Note</p>
        <p>Docker Compose supports splitting to multiple files.</p>

    </div>
</div>
<p>So we need multiple files.
But we should still group related ones together!
Quadlet supports placing unit files inside directories in the <code>~/.config/containers/systemd</code> directory.
For our example, you would create an <code>oxitraffic</code> directory and place both files inside it.</p>
<h2 id="updating-images"><a href="#updating-images">Updating images</a></h2>
<p>Now, we have containers running in the background and automatically started after a server reboot.
Wouldn&#39;t it be nice to have an easy method to update the images of these containers without running <code>podman pull</code> for every container and then restarting the updated ones?</p>
<p>For example, if a new image is uploaded for PostgreSQL 16 (with the image tag <code>16</code> that we used), then the image should be updated and the container should be restarted.</p>
<p>With Docker, you would need something like <a href="https://containrrr.dev/watchtower/">Watchtower</a>.
But Podman provides a tool out of the box!</p>
<p>If you set <code>AutoUpdate=registry</code>, you can just run <code>podman auto-update</code> and Podman will check if the registry has a newer image which is compatible with the used tag.
In that case, the image will be pulled and the container will be restarted.
It is that easy 😍</p>
<p>Of course, this could be dangerous if you use a tag like <code>latest</code> for OxiTraffic instead of a concrete version like <code>0.9.2</code>.
Because the next version pushed to the <code>latest</code> tag might include a breaking change!
It is even more dramatic if you use the <code>latest</code> tag for the PostgreSQL image because manual migrations are always required when upgrading PostgreSQL to a new major version.</p>
<p>Therefore, always use a tag that can&#39;t lead to a breaking change!
Trust me, this is not only a problem with Podman updates.
I learned this the hard way when trying to deploy Docker containers a while ago that used the <code>latest</code> tag.</p>
<p>Personally, I run <code>podman auto-update</code> manually on the server every couple of days to see what has been updated and make sure that the containers are still healthy afterwards.</p>
<h2 id="what-about-podman-compose"><a href="#what-about-podman-compose">What about podman-compose?</a></h2>
<p>There is the Python script <a href="https://github.com/containers/podman-compose"><code>podman-compose</code></a> which runs Compose files with Podman.
But I don&#39;t consider it a long-term alternative to Docker Compose for multiple reasons:</p>
<ul>
<li><code>podman-compose</code> is just a translation layer between the Compose spec and Podman with systemd. Why yet another layer of abstraction that sacrifices flexibility? It doesn&#39;t let you use all features of systemd.</li>
<li>I consider Python scripts a prototype because of Python&#39;s interpreted nature. Official Podman projects are written in a compiled language like Rust or Go.</li>
<li>It is not actively maintained. The last commit was 5 months ago.</li>
</ul>
<p>Quadlet aligns much better with the rootless, daemonless design of Podman.</p>
<p>If you are stuck with Compose files and would like to try out Quadlet, check out <a href="https://github.com/containers/podlet">podlet</a> that can help you during the migration.</p>
<h2 id="further-resources"><a href="#further-resources">Further resources</a></h2>
<p>Take this post as an introduction.
I highly recommend reading the man page <a href="https://docs.podman.io/en/latest/markdown/podman-systemd.unit.5.html"><code>podman-systemd.unit</code></a> to get a deeper understanding of Quadlet.
You don&#39;t need to read the documentation of every supported option though.</p>
<p>Quadlet doesn&#39;t only work with containers.
It can also manage pods, networks and volumes (see man page).</p>
<p>If you are new to writing systemd unit files (like me), I also recommend checking out the man pages <a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html"><code>systemd.unit</code></a> and <a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.service.html"><code>systemd.service</code></a>.</p>
<p><a href="https://github.com/containers/podlet">podlet</a> is a wonderful Rust tool that can help you during the migration.
It can create Quadlet files out of Podman commands or even (Docker) Compose files.</p>
<p>Check out the <a href="https://blog.while-true-do.io/podman-quadlets/">similar blog post on blog.while-true-do</a> for another perspective and a second example.
It is my favorite blog related to Linux 🥰</p>
<p>Finally, if you want to see my migration as an example, then you can compare <a href="https://git.mo8it.com/mo8it/main_server/src/commit/334ff80a365a55cec8c57d47047fdf6dbe6de71d/containers">before</a> and <a href="https://git.mo8it.com/mo8it/main_server/src/commit/14a949bb4f5b08d0666a7161ecfc8942cfa605b9/containers">after</a>.</p>

    </article></div>
  </body>
</html>
