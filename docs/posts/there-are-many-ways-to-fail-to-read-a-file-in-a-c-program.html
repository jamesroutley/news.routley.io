<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://colinpaice.blog/2022/08/06/there-are-many-ways-to-fail-to-read-a-file-in-a-c-program/">Original</a>
    <h1>There are many ways to fail to read a file in a C program</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>The 10 minute task to read a file from disk using a C program took a week.</p>



<p>There are several options you can specify on the C <a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-fopen-open-file">fopen() </a>function and it was hard to find the one that worked.  I basically tried all combinations.   Once I got it working, I tried on other files, and these failed, so my little task turned into a big piece of research.</p>



<p>Depending on the <a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-fopen-open-file">fopen</a> options and the use of <a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-fgets-read-string-from-stream">fgets</a> or <a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-fread-read-items">fread</a> I got different data when getting from a dataset with two records in it!</p>



<ul><li>AAAA   – what I wanted.</li><li>AAAAx’15’ – with a hex 15 on the end.</li><li>AA </li><li>AAAAx’15’BBBBx’15’- both the records, with each record terminated in a line-end x’15’.</li><li>AAAABBBB – both records with no line ends.</li><li>x’00140000′ x’00080000’AAAAx’000080000’BBBB.   <ul><li>This has a Block Descriptor Word (x’00140000′) saying the length of the block is x14.  </li><li>There is a Record Descriptor Word (RDW) (X’00080000′) of length x’0008′ including the 4 bytes for the RDW.  </li><li>There is the data for the first record AAAA,</li><li>A second RDW</li><li>The second data </li><li>The size of this record is 4 for the BWD, 4 for the first RDW, 4 for the AAAA, 4 for the second RDW, and 4 for the data = 20 bytes = x14.</li></ul></li><li>Nothing!</li></ul>



<h2>Sections in this blog post</h2>



<ul><li><a href="#data">There are different sorts of data</a></li><li><a href="#getting">Different ways of getting the data</a></li><li><a href="#fopen">Introduction to fopen()</a></li><li><a href="#filename">The file name</a></li><li><a href="http://options">The options</a></li><li><a href="#much">How much data is read at a time?</a></li><li><a href="#reading">Reading the data</a></li><li><a href="#fread">You can use the fread() function</a></li><li><a href="#fgets">You can use the fgets function</a></li><li><a href="#dataset">Results from reading data sets and files</a></li><li><a href="#toread">To read a dataset</a></li><li><a href="#ebcdic">Read a normal(EBCDIC) OMVS file</a></li><li><a href="#ascii">Read an ASCII file in OMVS</a></li><li><a href="#binary">To read a binary file</a></li><li><a href="#binarynormal">Read a binary normal(EBCDIC) OMVS file</a></li><li><a href="#binaryascii">Read a binary ASCII file in OMVS</a></li><li><a href="#shell">Reading data sets from a shell script</a></li><li><a href="#big">How big a buffer do I need?</a></li><li><a href="#howbig">How can I tell the size of the buffer I need?</a></li></ul>



<h3 id="data">There are different sorts of data</h3>



<ul><li>z/OS uses data sets which have records.  Records can be blocked (for better disk utilisation) It is more efficient to write one block containing 40 * 80 bytes records than write 40 blocks each of 80 bytes.   You can treat the data as one big block (of size 3200 bytes) – or as 40 blocks of 80  (or 2 blocks of 1600 …) .  With good blocking you can get 10 times the amount of data onto a disk.  (If you imagine each record on disk needs a 650 byte header you will see why blocking is good).</li><li>You can have “text” files, which contain printable characters.   They often use the new line character (x’15’) to indicate end of line.</li><li>You can have binary files which should be treated as a blob.  In these characters line x’15’ do not represent new line.  For example it might just be part of a sequence x’1314<strong>15</strong>16′.</li><li>Unix (and so OMVS) uses byte-addressable storage.<ul><li>“Normal files” have data in EBCDIC</li><li>You can use <a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=pages-enhanced-ascii">enhanced ASCII</a>. Where you can have files with data in ASCII (or other code page).  The file metadata contains the type of data (binary or text) and the code page of the text data.</li><li>With environment <a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=ascii-setting-up-enhanced">_BPXK_AUTOCVT</a> you can have automatic conversion which converts a text file in ASCII to EBCDIC when it is read.</li></ul></li></ul>



<p>From this you can see that you need to use the correct way of accessing the data(records or byte addressable), and of using the data(text or binary).</p>



<h3 id="getting">Different ways of getting the data</h3>



<p>You can use </p>



<ul><li>the fread function which reads the data, according to the file open options (binary|text, blocked)</li><li>the fgets function which returns text data (often terminated by a line end character).g</li></ul>



<h3>Introduction to fopen()</h3>



<p>The <a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-fopen-open-file">fopen()</a> function takes a file name and  information on how the file should be opened  and returns a handle. The handle can be used in an <a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-fread-read-items">fread()</a> function or to provide information about the file.  The C runtime reference gives the syntax of fopen(),  and there is a lot of information in the C Programming guide:</p>



<ul><li><a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=output-introduction-c-c-input">Introduction to C and C++ input and output</a></li><li><a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=output-types-c-c-input">Types of C and C++ input and output</a></li><li><a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=output-opening-files">Opening files</a></li></ul>



<p>There is a lot of good information – but it didn’t help me open a file and read the contents.</p>



<h4 id="filename">The file name</h4>



<p>The name can be, for example:</p>



<ul><li>“DD:SYSIN” – a reference to a data set via JCL</li><li>“//’USER.PROCLIB(MYPROC)&#39;” – a direct reference to a dataset</li><li>“/etc/profile” – an OMVS file.</li></ul>



<p>If you are using the Unix shell you need to use “//’datasetname&#39;” with both sets of quotes.</p>



<h4 id="options">The options</h4>



<p>This options string has one or more parameters. </p>



<p>The first parameter defines the operation, read, write, read+write etc.  Any other parameters are in the format keyword=format. </p>



<p>The read operation can be</p>



<ul><li>“rb” to read a binary file.  In a binary file, the data is treated as a blob.</li><li>“rt” to read a text file.  A text file can have auto conversion see <a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=options-filetag-cc-only">FILETAG</a> C run time option.</li><li>“r” </li></ul>



<p>The type can be</p>



<ul><li>type=record – read a record of data from the  disk, and give the record to the application</li><li>type=blocked.  It is more efficient in disk storage terms, to build up a record of 10 * 80 byte records into one 800 byte record (or even 3200 byte records).     When a blocked record is read, the read request returns the first N bytes, then the next n bytes. When the end of the block is reached it will get retrieve the next block from disk.  </li><li>not specified, which implies byte access, rather than record access, and use of fgets function.</li></ul>



<h4>An example fopen</h4>



<p>FILE * f2 fopen(“//’COLIN.VB&#39;”,”rt type=blocked”) ;</p>



<h3 id="much">How much data is read at a time?</h3>



<p>Depending on the type of data, and the open options a read request may return data</p>



<ul><li>up to the end of the record</li><li>up to and including the new-line character</li><li>up to the size of the buffer you give it.</li></ul>



<p>If you do not give it a big enough buffer you may have to issue several reads to get whole logical record.</p>



<p>The system may also “compress” data, for example remove trailing blanks from the end of a line.  If you were expecting an 80 byte record – you might only get 20 bytes – so you may need to check this, and fill in the missing blanks if needed.</p>



<h3 id="reading">Reading the data</h3>



<h4 id="fread">You can use the fread() function</h4>



<p>The <a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-fread-read-items">fread()</a> parameters are:</p>



<ul><li>the address of a buffer to hold the data</li><li>the unit of the buffer block size</li><li>the number of buffer blocks</li><li>the file handle.</li></ul>



<p>It returns the number of completed buffer blocks used.</p>



<p>It is usually used</p>



<blockquote>
<p>#define lBuffer 1024</p>



<p>char buffer[lBuffer];</p>
</blockquote>



<p>This says the unit of the buffer is 1 character, and there are 1024 of them.</p>



<p>If the record returned was 80 bytes long, then len would be 80.</p>



<p>If it was written as</p>



<blockquote>
<p>size_t len = fread(buffer, <strong>lBuffer, 1</strong> ,fHandle );</p>
</blockquote>



<p>This says the unit of buffer is 1024 – and there is one of them.   The returned “length” is 0, as there were no full 1024 size buffers used.</p>



<h4 id="fgets">You can use the fgets function.</h4>



<p>The <a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-fgets-read-string-from-stream">fgets()</a> parameters are:</p>



<ul><li>the address of a buffer to hold the data</li><li>the size of the buffer</li><li>the file handle.</li></ul>



<p>This returns a null terminated string in the buffer.  You can use strlen(buffer) to get the length of it.  Any empty string would have length 0.</p>



<h3 id="dataset">Results from reading data sets and files</h3>



<p>I did many tests with different options, and configurations, and the results are displayed below.</p>







<ul><li>Run.<ul><li>job.  The program was run in JCL using BPXBATSL or via PGM=…</li><li>unix shell – the program was run in OMVS shell.</li></ul></li><li>BPXAUTO.  This is used in OMVS shell. The environment variable _BPXK_AUTOCVT can have<ul><li>“ON” – do automatic conversion from ASCII to EBCDIC where application</li><li>“OFF” do not do automatic conversion from ASCII to EBCDIC</li></ul></li><li>open.   The options used. <ul><li>r read</li><li>rb read binary</li><li>rt read test</li></ul><ul><li>“t=r” is shorthand for type=record</li></ul></li><li>read.  The C function used to read the data. <ul><li>fread – this is the common read function.  It can read text files and binary files</li><li>fgets – this is used to get text from a file.  The records usually have the new-line character a the end of the daya</li><li>aread is a C program which uses fread – but the program is compiled with the ASCII option.</li></ul></li><li>data<ul><li>E is the EBCDIC data I was expecting.  For example reading from a FB dataset member gave me an 80 byte record with the data in it.</li><li>E15 is EBCDIC data, but trailing blanks have been removed.   The last character is an EBDCIC line end (x15).</li><li>A0A.  The data is returned in ASCII, and has a trailing line end character (x0A).   You can convert this data from ASCII to EBCDIC using the C run time function __a2e_l(buffer,len) .</li><li>Abuffer – data up to the size of the buffer ( or size -1 for fgets) the data in ASCII.</li><li>Ebuffer – data up to the size of the buffer ( or size -1 for fgets) the data in EBCDIC.  This data may have newlines within the buffer</li></ul></li></ul>



<h3 id="toread">To read a dataset</h3>



<p>This worked with a data set and inline data within a JOB.</p>







<figure><table><tbody><tr><td>Run</td><td>BPXAUTO</td><td>open</td><td>read</td><td>data</td></tr><tr><td>Job</td><td>NA</td><td>rb,t=r</td><td>fread</td><td>E</td></tr><tr><td></td><td></td><td>r|rt</td><td>fread</td><td>Ebuffer</td></tr><tr><td></td><td></td><td>r</td><td>fgets</td><td>E15</td></tr><tr><td></td><td></td><td>rt</td><td>fgets</td><td>E15</td></tr><tr><td>Unix shell</td><td>Any</td><td>rb,t=r</td><td>fread</td><td>E</td></tr><tr><td></td><td></td><td>r|rt</td><td>fread</td><td>Ebuffer</td></tr><tr><td></td><td></td><td>r</td><td>fgets</td><td>E15</td></tr><tr><td></td><td></td><td>rt</td><td>fgets</td><td>E15</td></tr></tbody></table></figure>



<h3 id="ebcdic">Read a normal(EBCDIC) OMVS file </h3>



<figure><table><tbody><tr><td>Run</td><td>BPXAUTO</td><td>open</td><td>read</td><td>data</td></tr><tr><td>Job</td><td>OFF</td><td>rb,t=r</td><td>fread</td><td>E</td></tr><tr><td></td><td>off</td><td>rt</td><td>fgets</td><td>E15</td></tr><tr><td></td><td>off</td><td>*</td><td>fread</td><td>Ebuffer</td></tr><tr><td>Unix shell</td><td>off</td><td>r</td><td>fgets</td><td>E15</td></tr><tr><td></td><td>off</td><td>rt</td><td>fgets</td><td>E15</td></tr><tr><td></td><td>off</td><td>rb</td><td>fgets</td><td>E15</td></tr><tr><td></td><td>off</td><td>*</td><td>fread</td><td>E15</td></tr><tr><td></td><td>on</td><td>rb,t=r</td><td>fread</td><td>E</td></tr><tr><td></td><td>on</td><td>rb</td><td>fgets</td><td>E15</td></tr></tbody></table></figure>



<h4 id="ascii">Read an ASCII file in OMVS</h4>



<figure><table><tbody><tr><td>Run</td><td>BPXAUTO</td><td>open</td><td>read</td><td>data</td></tr><tr><td>Job</td><td>off</td><td>r</td><td>agets</td><td>A0A</td></tr><tr><td></td><td>off</td><td>rb</td><td>agets</td><td>A0A</td></tr><tr><td></td><td>off</td><td>rt</td><td>agets</td><td>A0A</td></tr><tr><td>Unix shell</td><td>on</td><td>r</td><td>fgets</td><td>E15</td></tr><tr><td></td><td>on</td><td>rb</td><td>fgets</td><td>E15</td></tr><tr><td></td><td>on</td><td>rt</td><td>fgets</td><td>E15</td></tr><tr><td></td><td>on</td><td>*</td><td>fread</td><td>buffer</td></tr><tr><td></td><td>off</td><td>r</td><td>agets</td><td>A0A</td></tr><tr><td></td><td>off</td><td>rb</td><td>agets</td><td>A0A</td></tr><tr><td></td><td>off</td><td>rt</td><td>agets</td><td>A0A</td></tr><tr><td></td><td>off</td><td>*</td><td>fread</td><td>Abuffer</td></tr></tbody></table></figure>



<h3 id="binary">To read a binary file</h3>



<p>To read a data set </p>



<figure><table><tbody><tr><td>Run</td><td>BPXAUTO</td><td>open</td><td>read</td><td>data</td></tr><tr><td>Job</td><td>off</td><td>rb</td><td>fread</td><td>E</td></tr><tr><td>Unix shell</td><td>on</td><td>rb</td><td>fread</td><td>E</td></tr></tbody></table></figure>







<h3 id="binarynormal">Read a binary normal(EBCDIC) OMVS file </h3>



<figure><table><tbody><tr><td>Run</td><td>BPXAUTO</td><td>open</td><td>read</td><td>data</td></tr><tr><td>Job</td><td>off</td><td>rb</td><td>fread</td><td>E</td></tr><tr><td>Unix shell</td><td>on</td><td>rb</td><td>fread</td><td>E</td></tr><tr><td></td><td>off</td><td>rb</td><td>fread</td><td>E</td></tr></tbody></table></figure>



<h3 id="binaryascii">Read a binary ASCII file in OMVS</h3>



<p>If use list the attributes of a binary file, for example “ls -T ecrsa.p12” it gives</p>



<blockquote>
<p>b binary T=off ecrsa1024.p12</p>
</blockquote>



<p>Which shows it is a binary file</p>



<figure><table><tbody><tr><td>Run</td><td>BPXAUTO</td><td>open</td><td>read</td><td>data</td></tr><tr><td>Job</td><td>off</td><td>rb,t=r</td><td>fread</td><td>E</td></tr><tr><td>Unix shell</td><td>on</td><td>rb,=r</td><td>fread</td><td>E</td></tr><tr><td></td><td>off</td><td>rb,t=r</td><td>fread</td><td>E</td></tr></tbody></table></figure>



<h3 id="shell">Reading data sets from a shell script</h3>



<p>If you try to use fopen(“DD:xxxx”…) from a shell script you will get</p>



<blockquote>
<p>FOPEN: EDC5129I No such file or directory. (errno2=0x05620062)</p>
</blockquote>



<p>If you use fopen(“//’COLIN.VB&#39;”…)  and specify a fully qualified dataset name if will work.</p>



<p>fopen(“//VB”..) will put the RACF userid in front off they name.   For example  attempt to open “//’COLIN.VB.&#39;” </p>



<h2 id="big">How big a buffer do I need?</h2>



<p>The the buffer is not large enough to get all of the data in the record, the buffer will be filled up to the size of the data. For example using fgets and a 20 byte buffer, 19 characters were returned.  The 20th character was a null.  The “new-line” character was present only when the end of the record was got.</p>



<h3 id="howbig">How can I tell the size of the buffer I need?</h3>



<p>There is data available which helps – but does not give the whole picture.</p>



<p>With the C <a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-fldata-retrieve-file-information">fldata() — Retrieve file information</a> function you can get information from the file handle such as </p>



<ul><li>the name of the dataset (as provided at open time)</li><li>record format – fixed, variable</li><li>dataset organisation (dsorg) – Paritioned, Temporary, HFS</li><li>open mode – text, binary, record</li><li>device type – disk, printer, hfs, terminal</li><li>blksize </li><li>maximum record length</li></ul>



<p>With <a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-fstat-fstat64-get-status-information-about-file">fstat(), fstat64() — Get status information from a file handle </a> and <a href="https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-lstat-lstat64-get-status-file-symbolic-link">lstat(), lstat64() — Get status of file name or symbolic link</a> you can get information about an OMVS file name (or file handle). This has the information available in the OMVS “ls” command.  For example</p>



<ul><li>file serial number</li><li>owner userid</li><li>group userid</li><li>size of the file</li><li>time last access</li><li>time last modified</li><li>time last file status changed</li><li>file tag<ul><li>ccsid, value or 0x000 for untagged, or 0xffff for binary</li><li>pure text flag.</li></ul></li></ul>







<h4>Example output</h4>



<p>For data sets and files (along the top of the table)</p>



<ul><li>VB a sequential data set Variable Blocked</li><li>FB a member of user.proclib which is Fixed Block</li><li>SYSIN inline data in a job</li><li>Loadlib a library containing load modules (binary file)</li><li>OMVS file for example zos.c</li><li>ASCII for example z.py which has been tagged as ASCII</li></ul>



<p>Other values</p>



<ul><li>V variable format data</li><li>F fixed format data</li><li>Blk it has blocked records</li><li>B “Indicates whether it was allocated with blocked records”.  I do  not know the difference between Blk and V</li><li>U Undefined format</li><li>PS It is a Physical Sequential</li><li>PO It is partitioned – it as members</li><li>PDSE it is a PDSE</li><li>HFS it is a file from OMVS </li></ul>



<figure><table><tbody><tr><td></td><td></td><td>VB</td><td>FB</td><td>SYSIN</td><td>loadib</td><td>OMVS file</td><td>ASCII </td></tr><tr><td>fldata</td><td>recfm</td><td>V Blk B</td><td>F Blk B</td><td>F Blk B</td><td>U</td><td>U</td><td>U</td></tr><tr><td></td><td>dsorg</td><td>PS</td><td>PO PDSMem</td><td>PS</td><td>PO PDSMem PDSE</td><td>HFS</td><td>HFS</td></tr><tr><td></td><td>device</td><td>disk</td><td>disk</td><td>other</td><td>disk</td><td>HFS</td><td>HFS</td></tr><tr><td></td><td>blocksize</td><td>6144</td><td>610</td><td>80</td><td>6400</td><td>0</td><td>0</td></tr><tr><td></td><td>maxreclen</td><td>1024</td><td>80</td><td>80</td><td>6400</td><td>1024</td><td>1024</td></tr><tr><td>stat</td><td>ccsid</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>819</td></tr><tr><td></td><td>file size</td><td>0</td><td>0</td><td>0</td><td>0</td><td>4780</td><td>824</td></tr></tbody></table></figure>



<p>To read a record, you should use the maxreclen  size.   This may not be the size of the data record but it is the best guess.</p>




	</div><div>
			<div>
				<p><img alt="" src="https://2.gravatar.com/avatar/8c634342e734b142995169c8742e60eb?s=80&amp;d=identicon&amp;r=G" height="80" width="80"/>		</p><!-- .author-avatar -->
		
		<p>
			<h2>Published by <span>Colin Paice</span></h2>
		</p><!-- .author-heading -->

		<p>
			I retired from IBM where I worked on MQ on z/OS, and did customer stuff.
I retired, and keep my hand in with MQ, by playing with it!			<a href="https://colinpaice.blog/author/colinpaicemq/" rel="author">
				View all posts by Colin Paice			</a>
		</p><!-- .author-bio -->
	</div><!-- .entry-auhtor -->
		<p><strong>Published</strong>
			<time datetime="2022-08-06T09:15:06+00:00">August 6, 2022</time><time datetime="2022-08-12T17:15:03+00:00">August 12, 2022</time>		</p><!-- .site-posted-on -->
	</div></div>
  </body>
</html>
