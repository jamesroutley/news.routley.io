<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://liveblocks.io/blog/how-to-animate-multiplayer-cursors">Original</a>
    <h1>How to Animate Multiplayer Cursors</h1>
    
    <div id="readability-page-1" class="page"><div><p>Multiplayer cursors are becoming an increasingly common sight across all sorts
of collaborative tools, but have you ever wondered how they’re animated?
Animating real-time cursors is more complex than it first may seem, thanks to
network and connection limitations. Here’s a quick overview of a few different
methods, with some React snippets to get you started. Let’s dive in!</p><h2>Why do we need animations?</h2><p>In an ideal world, animations wouldn’t be needed, and every single cursor
movement would be reflected immediately across browsers.</p><figure><figcaption>An interactive demo displaying a perfectly animated cursor.</figcaption><div><div><div><div></div></div></div></div></figure><p>However, updates can’t be transmitted instantly, and realistically, we wouldn’t
want them to be. Even if updates were sent every millisecond (1ms), blinking
your eye still takes longer than 100ms—would it really be efficient to send 100
updates in such a short space of time?</p><h2>Throttling</h2><p>Every real-time service will use some kind of throttling to ensure that your
code, and their systems, aren’t overloaded, and this is where our animation
problem lies. Try adjusting the throttle rate with the range slider below.</p><figure><figcaption>An interactive demo allowing you to change the update frequency of cursors.</figcaption><div><div><div><div></div></div></div><div><p><label for="ping-exists-slider">Update every <!-- -->120<!-- -->ms</label><span data-orientation="horizontal" aria-disabled="false" id="ping-exists-slider"><span data-orientation="horizontal"></span><span></span></span></p></div></div></figure><p>Lowering the throttle rate prevents updates being sent as regularly, and as you
can see, this results in the cursor animation only being completely smooth at
the lowest rates.</p><h2>In the real world</h2><p>Of course in the real world, the cursor won’t update <em>exactly</em> on the throttle
rate (for example, 120ms) there&#39;ll be some slight variation between each update
caused by varying processing times on clients and server, as well as changing
network latency. The actual time between updates will be slightly different.</p><figure><figcaption>An diagram explaining that update time isn&#39;t just throttling.</figcaption><div><div><div><p>Throttle rate (120ms)</p><p>Variation (5-15ms)</p></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></figure><p>I’m going to call the actual time between updates the <em>update rate</em>, a value
that includes throttling, and other normal variations. If you’d like to see a
realistic update rate, try interacting with the demo below—it connects to
Liveblocks and manually measures the rate on each update.</p><figure><figcaption>A demo that displays your current update frequency and ping for Liveblocks when interacted with.</figcaption><div><div><div><div><p>You</p></div><div><div><p><span>Move cursor</span><span>Touch and drag</span></p></div></div></div></div></div></figure><p>This demo uses Liveblocks’ default throttle rate, but you can specify a custom
rate within
<a href="https://donnywinston.com/docs/api-reference/liveblocks-client#createClientThrottle">createClient</a>.</p><h2>Animation methods</h2><p>Now we’ve seen the problem, let’s fix it. There are three different ways we can
tackle this: CSS transitions, spring animations, and spline animations.</p><p>In the React code examples below, we’ll be animating cursors by passing <code>x</code> and
<code>y</code> props to the component, these numbers corresponding to the pixel distance
from the top-left corner of the container.</p><pre></pre><h2>CSS Transitions</h2><p>The easiest approach to animate cursor locations is to use a CSS transition on
the cursor component which can be added with just a single CSS property,
<code>transition</code>.</p><figure><figcaption>An interactive demo displaying a cursor animated with CSS transitions.</figcaption><div><div><div><div></div></div></div><div><p><label for="transitions-slider">Update every <!-- -->120<!-- -->ms</label><span data-orientation="horizontal" aria-disabled="false" id="transitions-slider"><span data-orientation="horizontal"></span><span></span></span></p></div></div></figure><p>When you increase the update time, you’ll probably notice the most prominent
flaw with CSS transitions—the route to the next point is always a straight line.
CSS transitions only consider the cursor’s next coordinates, not the path taken
to get there, nor the momentum of the cursor.</p><p>If you move the slider in the diagram below, you can see the shape of the
original cursor’s movement alongside the path created by the transition. Each
&#34;x&#34; represents a new update that’s been received.</p><figure><figcaption>An interactive diagram showing the path taken by a CSS transition animated cursor, alongside the original cursor&#39;s path.</figcaption><div><div><div><div></div><svg width="1020" height="415" viewBox="0 0 1020 415" fill="none" xmlns="http://www.w3.org/2000/svg"></svg></div></div><div><p><label for="range-cursor-path-demo-transition">Cursor movement</label><span data-orientation="horizontal" aria-disabled="false"><span data-orientation="horizontal"></span><span></span></span></p><div><div><p><label for="check-updates-cursor-path-demo-transition">Show updates</label></p></div><div><p><label for="check-paths-cursor-path-demo-transition">Show paths</label></p></div></div></div></div></figure><p>As you can see, each time an update is received, the transition starts pathing a
straight line directly towards the next update; certainly less than ideal.</p><h3>Timing functions</h3><p>When it comes to CSS timing functions, interestingly, and perhaps
counterintuitively, <code>linear</code> transitions result in smoother cursors than
<code>easing</code> transitions. Try enabling <code>ease-in-out</code>, then going back to <code>linear</code>:</p><figure><figcaption>An interactive demo displaying a cursor animated with CSS transitions.</figcaption><div><div><div><div></div></div></div><div><p><label for="transitions-slider">Update every <!-- -->120<!-- -->ms</label><span data-orientation="horizontal" aria-disabled="false" id="transitions-slider"><span data-orientation="horizontal"></span><span></span></span></p></div><div><div></div><p><label for="check-paths-transitions">Ease-in-out</label></p></div></div></figure><p>But how does that make sense? Transitions such as <code>ease-in-out</code> slow down
towards the start and end of each transition, but with cursors we don’t want
that—we want a similar speed maintained between updates. If the cursor slows
down on each update, before speeding up again, it won’t look as smooth. Using
<code>linear</code> ensures that a similar speed is maintained, and the shift to the next
set of coordinates is smoother.</p><h3>Should I use CSS transitions?</h3><p>I’d only recommend using CSS transitions if you’re after a lightweight solution
that doesn’t use any third-party packages. Here’s an example of a React
component that uses CSS transitions:</p><pre></pre><h2>Springs</h2><p>Rather than using straight-line CSS transitions, we can look to spring physics
to mimic more organic motion. Spring animations allow us to control aspects of
cursor movement such as stiffness and damping ratio, lending the appearance of a
real item moving with its own impetus and mass, resulting in a much more natural
movement.</p><figure><figcaption>An interactive demo displaying a cursor animated with springs.</figcaption><div><div><div><div></div></div></div><div><p><label for="springs-slider">Update every <!-- -->120<!-- -->ms</label><span data-orientation="horizontal" aria-disabled="false" id="springs-slider"><span data-orientation="horizontal"></span><span></span></span></p></div></div></figure><p>Spring animations tend to be far smoother than CSS transitions, as they take
into account not just the next coordinates, but also the current momentum of the
element.</p><figure><figcaption>An interactive diagram showing the path taken by a spring animated cursor, alongside the original cursor&#39;s path.</figcaption><div><div><div><div></div><svg width="1020" height="415" viewBox="0 0 1020 415" fill="none" xmlns="http://www.w3.org/2000/svg"></svg></div></div><div><p><label for="range-cursor-path-demo-spring">Cursor movement</label><span data-orientation="horizontal" aria-disabled="false"><span data-orientation="horizontal"></span><span></span></span></p><div><div><p><label for="check-updates-cursor-path-demo-spring">Show updates</label></p></div><div><p><label for="check-paths-cursor-path-demo-spring">Show paths</label></p></div></div></div></div></figure><p>After each update, the cursor’s direction is smoothly changed before it paths a
straight-line to the next coordinates.</p><h3>Should I use spring animations?</h3><p>If you’re after smooth cursors with a quick response, and strict pathing
accuracy isn’t important, spring animations are the way to go. Here’s an example
of a spring-animated React cursor built with
<a href="https://www.framer.com/motion/" target="_blank" rel="noopener noreferrer">Framer Motion</a>.</p><pre></pre><h3>Spring animations in use</h3><p>A good example of an app using spring-animated cursors is our open-source
project <a href="https://pixelart.liveblocks.app" target="_blank" rel="noopener noreferrer">Pixel Art Together</a>, which uses
Svelte’s built-in spring library.</p><figure><figcaption>Video displaying live cursors and collaboration in Pixel Art Together.</figcaption><video loop="" controls="" playsinline=""><source src="/images/blog/video-pixel-art-together-drawing.mp4" type="video/mp4"/></video></figure><h2>Splines</h2><p>Spline interpolation is a method of constructing new points from a set of known
points, and plotting a smooth curve between. It’s often used to plot curves in
charts between discrete points of data.</p><figure><figcaption>An graph with points connected by a spline curve.</figcaption></figure><p>We can make use of spline interpolation to animate smooth paths for cursors,
relying on it using multiple different points to create a more accurate path.
There is a downside to this accuracy however—the function waits to receive
multiple points before rendering, so the cursor is slightly delayed.</p><figure><figcaption>An interactive demo displaying a cursor animated with splines.</figcaption><div><div><div><div></div></div></div><div><p><label for="splines-slider">Update every <!-- -->120<!-- -->ms</label><span data-orientation="horizontal" aria-disabled="false" id="splines-slider"><span data-orientation="horizontal"></span><span></span></span></p></div></div></figure><p>Spline animations take into account both the previous coordinates, and the next
coordinates, to create an accurate path that passes directly through every
point, unlike the other animation types.</p><figure><figcaption>An interactive diagram showing the path taken by a spline animated cursor, alongside the original cursor&#39;s path.</figcaption><div><div><div><div></div><svg width="1020" height="415" viewBox="0 0 1020 415" fill="none" xmlns="http://www.w3.org/2000/svg"></svg></div></div><div><p><label for="range-cursor-path-demo-spline">Cursor movement</label><span data-orientation="horizontal" aria-disabled="false"><span data-orientation="horizontal"></span><span></span></span></p><div><div><p><label for="check-updates-cursor-path-demo-spline">Show updates</label></p></div><div><p><label for="check-paths-cursor-path-demo-spline">Show paths</label></p></div></div></div></div></figure><p>As you can tell, the path created isn’t 100% accurate—splines still struggle
with abrupt changes of direction—but it is much closer than any other method.</p><h3>Should I use spline animations?</h3><p>I’d recommend using spline-animated cursors where accuracy is preferred and a
little delay is acceptable. The easiest way to do this in React is with the
<a href="https://github.com/steveruizok/perfect-cursors" target="_blank" rel="noopener noreferrer">perfect‑cursors</a> library, built
by the creator of
<a href="https://donnywinston.com/blog/tldraw-became-viral-by-converting-its-product-to-multiplayer-using-liveblocks">tldraw</a>.</p><pre></pre><h3>Spline animations in use</h3><p>A great example of spline cursors in the wild is <a href="https://tldraw.com" target="_blank" rel="noopener noreferrer">tldraw</a>,
which uses <code>perfect‑cursors</code>.</p><figure><figcaption>Video displaying live cursors and collaboration in tldraw.</figcaption><video loop="" controls="" playsinline=""><source src="/images/blog/video-tldraw-spline-cursors.mp4" type="video/mp4"/></video></figure><h2>Comparison</h2><p>Now that we’ve taken a look the different animation methods, let’s see how they
perform side-by-side.</p><figure><figcaption>An interactive demo displaying all animated cursors at once.</figcaption><div><div><div><div></div></div></div><div><p><label for="all-slider">Update every <!-- -->120<!-- -->ms</label><span data-orientation="horizontal" aria-disabled="false" id="all-slider"><span data-orientation="horizontal"></span><span></span></span></p></div></div></figure><p>When we compare we can really start to notice the delay caused by spline
animations, and also, somewhat surprisingly, we can see just how similar CSS
transitions and spring animations are, despite springs feeling much more fluid.</p><figure><figcaption>An interactive diagram showing the paths taken by all different animated cursors, alongside the original cursor&#39;s path.</figcaption><div><div><div><div></div><svg width="1020" height="415" viewBox="0 0 1020 415" fill="none" xmlns="http://www.w3.org/2000/svg"></svg></div></div><div><p><label for="range-cursor-path-demo-all">Cursor movement</label><span data-orientation="horizontal" aria-disabled="false"><span data-orientation="horizontal"></span><span></span></span></p><div><div><p><label for="check-updates-cursor-path-demo-all">Show updates</label></p></div><div><p><label for="check-paths-cursor-path-demo-all">Show paths</label></p></div></div></div></div></figure><p>CSS transitions make for a quick-and-easy lightweight solution, whereas spring
and spline animations result in a smoother experience. Springs work smoothly,
but if you’re after accuracy, and responsiveness isn’t important, take a look
into splines!</p><h2>Looking to add real-time cursors?</h2><p>This article covers the front end of live cursors, but what about the back end?
Implementing this is a much more difficult task, but it doesn’t have to be—you
can let Liveblocks handle your collaborative back end for you. We&#39;ll do all the
heavy lifting, so you can work on building your app.</p><p>Cursor positions, along with any other multiplayer data, can be sent across
clients with
<a href="https://donnywinston.com/docs/api-reference/liveblocks-client#Room.updatePresence"><code>updatePresence()</code></a>,
part of the <a href="https://donnywinston.com/docs/api-reference/liveblocks-client"><code>@liveblocks/client</code></a>
package.</p><pre></pre><p>Changes to other users’ presence can then be detected on clients using
<a href="https://liveblocks.io/docs/api-reference/liveblocks-client#Room.subscribe.others" target="_blank" rel="noopener noreferrer"><code>subscribe(&#34;others&#34;)</code></a>.</p><pre></pre><p>We also have <a href="https://donnywinston.com/docs/api-reference/liveblocks-react"><code>@liveblocks/react</code></a>, a
special React package that simplifies rendering multiplayer components even
further. You can add
<a href="https://donnywinston.com/docs/api-reference/liveblocks-react#useOthers"><code>useOthers()</code></a> which replaces
the subscription above:</p><pre></pre><h3>Find your framework</h3><p>We have working examples of live cursors built in a number of different
frameworks to get you started, have a try:
<a href="https://github.com/liveblocks/liveblocks/tree/main/examples/nextjs-live-cursors" target="_blank" rel="noopener noreferrer">Next.js</a>,
<a href="https://github.com/liveblocks/liveblocks/tree/main/examples/vuejs-live-cursors" target="_blank" rel="noopener noreferrer">Vue</a>,
<a href="https://github.com/liveblocks/liveblocks/tree/main/examples/sveltekit-live-cursors" target="_blank" rel="noopener noreferrer">Svelte</a>,
<a href="https://github.com/liveblocks/liveblocks/tree/main/examples/solidjs-live-cursors" target="_blank" rel="noopener noreferrer">Solid</a>,
<a href="https://github.com/liveblocks/liveblocks/tree/main/examples/javascript-live-cursors" target="_blank" rel="noopener noreferrer">JavaScript</a>.</p><h3>There’s more to life than cursors</h3><p>Wait, really? This article is about live cursors, but these tips also apply to
other animated components in multiplayer environments, for example sticky notes
on a
<a href="https://donnywinston.com/docs/tutorials/collaborative-online-whiteboard">collaborative whiteboard</a>. We
have plenty of other fun <a href="https://donnywinston.com/examples">examples</a> too!</p></div></div>
  </body>
</html>
