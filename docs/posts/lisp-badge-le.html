<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.technoblogy.com/show?3Z2Y">Original</a>
    <h1>Lisp Badge LE</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<h2>Lisp Badge LE</h2>
<p>27th September 2023</p>
<p>This is a self-contained low-power computer with its own display and keyboard that you can program in uLisp, a version of the high-level language Lisp for microcontrollers:</p>
<p><img src="https://stace.dev/pictures/kvm/lispbadgepulse.jpg" alt="LispBadgePulse.jpg" width="560" height="370"/></p>
<p><em>The Lisp Badge LE, a low-power computer programmed in Lisp</em></p>
<p>It&#39;s based on an AVR128DB48 which provides 128K bytes of flash memory, and 16K bytes of RAM. There&#39;s an integrated 45-key keyboard optimised for Lisp, using reverse-mounted buttons giving room for large key legends on the PCB.</p>
<p>It has a low-power monochrome display, readable in daylight without a backlight, so it&#39;s ideal for programming in the garden or on the beach! This gives 10 lines of 41 characters, or graphics with a resolution of 250x122 pixels, supported by several graphics commands.</p>
<p>You can use it to run programs that interface to components such as LEDs and push-buttons via the I/O pins, read the analogue inputs, and operate external devices via the I2C and SPI interfaces.</p>
<h3>Introduction</h3>
<p>A few years ago I designed the <a href="https://stace.dev/show?2AEE">Lisp Badge</a>, a self-contained computer with its own display and keyboard, based on an ATmega1284, that you could program in Lisp. Since then I&#39;ve been thinking about how I could improve it, and made a list of features I&#39;d like to add.</p>
<p>On the one hand I wanted it to have a better keyboard, and be low power, powered from a button cell, with an eInk display that you could see in daylight. On the other hand I wanted it to have a colour TFT graphics display, and use a fast 32-bit ARM processor, with support for floating-point arithmetic.</p>
<p>I soon realised that these requirements are incompatible in a single design, and so set about designing two different Lisp Badges to meet the two sets of requirements. This Lisp Badge LE (low energy) is the first of those designs, and has the following new features:</p>
<h4>Processor and memory</h4>
<p>It’s based on an AVR128DB48 (or AVR128DA48) running at 24MHz, and provides 2800 Lisp objects, about the same as the original Lisp Badge. You can save the entire workspace to flash.</p>
<h4>Current consumption</h4>
<p>The Lisp Badge LE draws only 6mA from its CR2032 button cell, and so should have a life of about 40 hours. There’s a physical on/off switch too for long periods of inactivity.</p>
<h4>Lisp language</h4>
<p>The Lisp Badge LE runs the AVR version of uLisp which provides 16-bit integer arithmetic, arbitrary length symbols and strings, lists, multi-dimensional arrays, Arduino interface functions, debugging features, and built-in documentation.</p>
<h4>Display</h4>
<p>The display is a low-power monochrome graphics display <sup id="cite_ref1"><a href="#cite_note1">[1]</a></sup> which I explored in an earlier article; see <a href="https://stace.dev/show?3YB0">Monochrome Low-Power Display Library</a>. It has a resolution of 250x122 pixels, and a text resolution of 10 lines of 41 characters per line. It supports reading back from the display, which makes it possible to support a full range of graphics functions, including plotting points, drawing lines, drawing outline and filled rectangles circles or triangles, and plotting characters and text at normal size or enlarged by any integer scale factor.</p>
<h4>Keyboard</h4>
<p>The keyboard takes advantage of push buttons that mount on the reverse of the board, with the button caps protruding through holes in the PCB. This makes it much easier to use than on the original Lisp Badge because it&#39;s easier to press the keys, and there&#39;s space for larger key legends. The push buttons are available from Adafruit <sup id="cite_ref2"><a href="#cite_note2">[2]</a></sup>. or The Pi Hut in the UK <sup id="cite_ref3"><a href="#cite_note3">[3]</a></sup>.</p>
<p>It uses the same 45-key layout as the original Lisp badge, with upper and lower-case characters, digits, and the symbols required by uLisp. However, it now provides an addition <strong>META</strong> modifier key in addition to <strong>SHIFT</strong>, allowing you to enter characters that don&#39;t have a dedicated key on the keyboard.</p>
<h4>Peripherals</h4>
<p>There’s a large piezo speaker that supports playing notes, and a reverse-mounting LED that shines through a hole on the front of the board.</p>
<p>Here&#39;s the full specification:</p>
<div>
<h3>Lisp Badge – Specification</h3>
<p><strong>Size:</strong> 107mm x 61mm (4.2&#34; x 2.4&#34;).</p>
<p><strong>Display</strong>: 41 characters x 10 lines, or 250 x 122 pixels.</p>
<p><strong>Keyboard:</strong> Integrated 45-key keyboard providing upper and lower-case characters, digits, and the symbols required by uLisp.</p>
<p>The <strong>META</strong> key pressed in conjunction with another key gives access to the following characters not available from the main keyboard:</p>
<table>
<thead>
<tr>
<td><strong>META +</strong></td>
<td>A</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>P</td>
<td>Q</td>
<td>T</td>
<td>U</td>
<td>V</td>
<td>&lt;</td>
<td>&gt;</td>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Character</strong></td>
<td>&amp;</td>
<td>:</td>
<td>$</td>
<td>!</td>
<td>%</td>
<td>?</td>
<td>@</td>
<td>^</td>
<td>|</td>
<td>{</td>
<td>}</td>
</tr>
</tbody>
</table>
<p><strong>Memory available</strong>: 2800 Lisp cells (11200 bytes).</p>
<p><strong>Flash</strong>: 16384 bytes of flash are reserved for use to save the Lisp workspace using <strong>save-image</strong>.</p>
<p><strong>Processor:</strong> AVR128DB48</p>
<p><strong>Clock speed:</strong> 24 MHz.</p>
<p><strong>Current consumption:</strong> Approx. 6 mA. A CR2032 cell has a typical capacity of 225 mAh, so this should give a life of about 40 hours.</p>
<p><strong>Types supported</strong>: list, symbol, integer, character, string, stream, and array.</p>
<p>An integer is a sequence of digits, optionally prefixed with &#34;+&#34; or &#34;-&#34;. Integers can be between -32768 and 32767. You can enter numbers in hexadecimal, octal, or binary with the notations #x2A, #o52, or #b101010, all of which represent 42.</p>
<p>User-defined symbol names can have arbitrary names. Any sequence that isn&#39;t an integer can be used as a symbol; so, for example, 12a is a valid symbol.</p>
<p>There is one namespace for functions and variables; in other words, you cannot use the same name for a function and a variable.</p>
<p>Includes a mark and sweep garbage collector. Garbage collection takes 5 msec.</p>
<h4><strong>Language</strong></h4>
<p>uLisp, a subset of Common Lisp, with the following 196 Lisp functions and special forms:</p>
<p><strong>* + - / /= 1+ 1- &lt; &lt;= = &gt; &gt;= ? abs analogread analogreadresolution analogreference analogwrite and append apply apropos apropos-list aref array-dimensions arrayp ash assoc atom bit boundp break caaar caadr caar cadar caddr cadr car case cdaar cdadr cdar cddar cdddr cddr cdr char char-code characterp check-key closure cls code-char concatenate cond cons consp dacreference decf defcode defun defvar delay digitalread digitalwrite documentation dolist dotimes draw-char draw-circle draw-line draw-pixel draw-rect </strong><strong>draw-triangle </strong><strong>edit eq equal error eval evenp fill-circle fill-rect fill-screen </strong><strong>fill-triangle</strong><strong> first for-millis format funcall gc get-pixel globals glyph-pixel if ignore-errors incf integerp keyboard keywordp lambda length let let* list list-library listp load-image locals logand logbitp logior lognot logxor loop make-array makunbound mapc mapcan mapcar max member millis min minusp mod not note nothing nth null numberp oddp or pinmode plot plot3d plusp pop pprint pprintall prin1 prin1-to-string princ princ-to-string print progn push quote random read read-byte read-from-string read-line register require rest restart-i2c return reverse room save-image search second set set-cursor setf setq sleep sort streamp string string&lt; string= string&gt; stringp subseq symbolp t terpri third time trace truncate unless untrace unwind-protect when with-i2c with-output-to-string with-sd-card with-serial with-spi write-byte write-line write-string zerop</strong></p>
<p>It also provides 37 keywords such as <strong>:input</strong>, <strong>:output</strong>, and <strong>:led-builtin</strong>, as a convenient way of entering Arduino constants.</p>
<p>For a full definition see <a href="http://www.ulisp.com/show?3L" target="_blank">uLisp Language Reference</a>.</p>
<h4>Graphics extensions</h4>
<p>The Lisp Badge LE includes a graphics library to allow you to do plotting on the display; for details see <a href="http://www.ulisp.com/show?31GT" target="_blank">Graphics extensions</a>. These work using a coordinate system with the origin at top left:</p>
<p><img src="https://stace.dev/pictures/kvm/graphicsdisplaycoords5.gif" alt="GraphicsDisplayCoords5.gif" width="265" height="135"/></p><p>
The following example shows a plot of the fractal Dragon Curve; for the program see <a href="http://www.ulisp.com/show?4JLZ" target="_blank">Dragon curve</a>:
</p><p><img src="https://stace.dev/pictures/kvm/lispbadgeledragon.jpg" alt="LispBadgeLEDragon.jpg" width="560" height="370"/></p>
<p><em>A fractal Dragon Curve drawn in Lisp on the Lisp Badge LE using the graphics extensions.</em></p>
<h4>Assembler</h4>
<p>The Lisp Badge LE also includes an AVR assembler which allows you to generate and run machine-code functions, written in AVR mnemonics, using an assembler written in Lisp. For details see <a href="http://www.ulisp.com/show?3IUO">AVR assembler overview</a>.</p>
<p>The language includes several extensions specifically for the Lisp Badge, including <strong>plot</strong> and <strong>plot3d</strong>, for plotting graphs and 3d functions, and <strong>keyboard</strong> and <strong>check-key</strong> for reading the keyboard in real time. For details see <a href="http://www.ulisp.com/show?4JJ6" target="_blank">Lisp Badge LE extensions</a>.</p>
<h4><strong>Interfaces</strong></h4>
<p>These interfaces are brought to headers at the edge of the Lisp Badge LE board. The numbers in brackets refer to Arduino pin numbers:</p>
<ul>
<li>Eight analogue input pins using <strong>analogread</strong>: PD0 to PD7 (22 to 29).</li>
<li>VCC, GND, and UPDI.</li>
<li>Two analogue outputs using <strong>analogwrite</strong>: MOSI0 (4) and MISO0 (5).</li>
<li>Digital input and output using <strong>pinmode</strong>, <strong>digitalread</strong>, and <strong>digitalwrite</strong>: TX0 (0), RX0 (1), SCL0 (2), SDA0 (3), MOSI0 (4), MISO0 (5), SCK0 (6), and PD0 to PD7 (22 to 29)</li>
<li>I2C interface using <strong>with-i2c</strong> and <strong>restart-i2c</strong>: SCL0 (2) and SDA0 (3), plus VCC and GND.</li>
<li>SPI interface using <strong>with-spi</strong>: MOSI0 (4), MISO0 (5), and SCK0 (6), plus VCC and GND.</li>
<li>Serial interface (FTDI) using <strong>with-serial</strong>: TX0 (0) and RX0 (1), plus DTR, VCC, and GND.</li>
</ul>
<p>Analogue output PB4 (12) is connected to a piezo speaker, which can use <strong>analogwrite</strong> or<strong> note.</strong></p>
<p>The <strong>SHIFT</strong> (33) and <strong>META</strong> (11) keys can be used as digital inputs, read with <strong>digitalread</strong> and referenced as <strong>:shift-key</strong> and <strong>:meta-key</strong>.</p>
<p>PA7 (7) is connected to an LED on the front panel, referenced as <strong>:led-builtin</strong>. You can turn it on and off with <strong>digitalwrite</strong>, or vary its brightness with <strong>analogwrite</strong>.</p>
</div>
<h3>Entering programs</h3>
<p>You can enter commands and programs by typing them at the keyboard, and pressing ENTER. A keyboard buffer is provided that buffers a full screen of text, and you can use the DEL key to delete characters and correct typing mistakes. The line editor includes parenthesis matching which automatically highlights matching brackets in inverse video as you type in a program. This makes it much easier to enter a program correctly, and is especially helpful in telling you how many closing brackets to type at the end of defining a function.</p>
<p>For example, the following program pulsates the built-in LED slowly on and off:</p>
<pre>(defun pulse (&amp;optional (up t))
  (dotimes (x 256)
    (analogwrite :led-builtin (if up x (- 255 x)))
    (delay 8))
  (pulse (not up)))</pre>
<p>It&#39;s shown nicely formatted here for clarity, but you can type it in as one continuous line, only pressing ENTER at the end. To run the program type:</p>
<pre>(pulse)</pre>
<h4>Connecting to a computer</h4>
<p>You can connect the Lisp Badge to a computer by plugging a 3.3V FTDI USB-to-serial converter onto the FTDI connector on the top right of the Lisp Badge, and then connecting this to the computer using a USB cable. You can then use the Serial Monitor in the Arduino IDE to enter and edit programs as described in <a href="http://www.ulisp.com/show?19XT">Using uLisp</a>.</p>
<p>I used the 3.3V FTDI Basic Breakout from Sparkfun <sup id="cite_ref4"><a href="#cite_note4">[4]</a></sup>. When using it with the Lisp Badge it powers the Lisp Badge, and so the battery should be left switched off.</p>
<h3>The circuit</h3>
<p>Here&#39;s the main part of the circuit:</p>
<p><img src="https://stace.dev/pictures/kvm/lispbadgele.gif" alt="LispBadgeLE.gif" width="720" height="401"/></p>
<p><em>Circuit of the Lisp Badge, based on an AVR128DB48 microcontroller.</em></p>
<p>The keyboard arranges the keys in a matrix of four rows and 11 columns:</p>
<p><img src="https://stace.dev/pictures/kvm/lispbadgekybd.gif" alt="LispBadgeKybd.gif" width="720" height="206"/></p>
<p><em>The circuit of the Lisp Badge keyboard matrix.</em></p>
<h4>► Parts list</h4>

<h3>Construction</h3>
<p>I created a PCB in Eagle, and ordered a set of boards from <a href="https://www.pcbway.com/" target="_blank">PCBWay</a>. I chose white PCBs to contrast with the black buttons. The board is the same width as the original Lisp Badge, but slightly taller to accomodate the larger display.</p>
<p>After a bit of experimentation I chose a board thickness of 1.2mm. With the standard 1.6mm thick PCB material the reverse-mounted buttons didn&#39;t protrude far enough through the holes, and 0.8mm made the boards too bendy, but 1.2mm was ideal.</p>
<p>The components, apart from the display, are mounted on the back of the board:</p>
<p><img src="https://stace.dev/pictures/kvm/lispbadgeleback.jpg" alt="LispBadgeLEBack.jpg" width="560" height="370"/></p>
<p><em>The reverse side of the Lisp Badge printed circuit board.</em></p>
<p>The push buttons are mounted at a 15° angle, which makes it possible to pack them closer together. I&#39;ve taken advantage of the fact that the terminals on each side of the push buttons are connected together to link the rows and columns of the key matrix across the board, and simplify the PCB track layout. A consequence of this is that if one push button is omitted, or has a faulty connection, all the other buttons to its left or below it across the keyboard may not work. Understanding this should help you track down any faulty soldering.</p>
<p>The PCB uses 0805 resistors and capacitors. The LED is a reverse-mounting 1206 LED <sup id="cite_ref5"><a href="#cite_note5">[5]</a></sup> to make the front of the board flush.</p>
<p>The board will accommodate either a 16 x 16mm SMD piezo speaker <sup id="cite_ref6"><a href="#cite_note6">[6]</a></sup>, or a 11 x 9mm SMD piezo speaker <sup id="cite_ref7"><a href="#cite_note7">[7]</a></sup>.</p>
<p>The battery holder is an SMD 20mm coin cell holder available from Sparkfun <sup id="cite_ref8"><a href="#cite_note8">[8]</a></sup>, or from Proto-PIC in the UK <sup id="cite_ref9"><a href="#cite_note9">[9]</a></sup>. Note that on many button cells the negative terminal is concave, and doesn&#39;t make good contact with the pad on the PCB. I therefore recommend melting some solder on the circular PCB contact to provide extra thickness before mounting the battery holder.</p>
<p>The display is held in place with a double-sided self-adhesive foam pad, and then soldered to the board with the seven header pins. There are also four mounting holes if you prefer to use screw mounting. I recommend leaving the display uninstalled until you have tested the rest of the board, because it&#39;s likely to be sensitive to overheating.</p>
<p>I used a Youyue 858D+ hot air gun at 275°C to solder the small SMD components and push buttons, and then used a conventional soldering iron for the display, battery holder, switch, piezo speaker, and connectors.</p>
<p>The PCB has space for a 5 x 3.2mm 32.768kHz crystal and its capacitors which you could use with the RTC peripheral to provide accurate timekeeping. However, I didn&#39;t fit it on the prototype as the internal clock is already pretty accurate.</p>
<h3>The program</h3>
<p>The Lisp Badge program is based on the code for the AVR version of uLisp Version 4.4 (see <a href="http://www.ulisp.com/show?1AA0" target="_blank">Download uLisp</a>), with the addition of routines to handle the display and keyboard, and the plot extensions.</p>
<h4>Display</h4>
<p>The display routine is based on the routine I developed for the display in my project <a href="https://stace.dev/show?3YB0">Monochrome Low-Power Display Library</a>. The display driver is the ST7302 <sup id="cite_ref10"><a href="#cite_note10">[10]</a></sup>, and it shares some similarities with the ST7735 used for colour TFT displays. Here&#39;s the display layout:</p>
<p><img src="https://stace.dev/pictures/kvm/graphicdisplaylayout6.gif" alt="GraphicDisplayLayout3.gif" width="436" height="198"/></p>
<p>The display is divided into 11 lines, each of which is 12 pixels high, and 125 columns, each of which is 2 pixels wide. Note that because 122 isn&#39;t an exact multiple of 12, only part of the last line actually appears on the display.</p>
<p>Unlike on the colour TFT displays each pixel isn&#39;t individually addressable; in fact, the minimum update is to write three bytes to the display, which defines the state of a block of 2x12 pixels corresponding to one column and one row. Fortunately the display supports reading back the display memory, so it&#39;s not necessary to maintain a copy of the display in RAM to do things like line drawing; instead, to set a single pixel we can read the 2x12 block, change one pixel, and write it back.</p>
<h4>Reading from the display</h4>
<p>The routine <strong>ReadBlock()</strong> reads a 12x2 pixel block from the display memory specified by the column, from 0 to 124, and the line, from 0 to 10:</p>
<pre>uint32_t ReadBlock (uint8_t column, uint8_t line) {
  uint32_t pix = 0;
  PORT_TOGGLE(1&lt;&lt;cs);
  Command2(CASET, 25+line, 25+line);
  Command2(RASET, column, column);
  Command(RAMRD);
  PORT_INPUT(1&lt;&lt;mosi);                     // mosi input
  for (uint8_t i=0; i&lt;25; i++) {
    PORT_TOGGLE(1&lt;&lt;sck);
    pix = pix&lt;&lt;1 | (PORT_IN&gt;&gt;mosi &amp; 1);
    PORT_TOGGLE(1&lt;&lt;sck);
  }
  PORT_OUTPUT(1&lt;&lt;mosi);                    // mosi output
  PORT_TOGGLE(1&lt;&lt;cs);
  return pix;
}</pre>
<p>When reading from display memory you have to do a dummy read, which is why the main loop is executed 25 times rather than 24 times.</p>
<p>The companion routine <strong>PlotBlock()</strong> writes back a 12x2 pixel block to the display memory:</p>
<pre>void PlotBlock (uint32_t block, uint8_t column, uint8_t line) {
  PORT_TOGGLE(1&lt;&lt;cs);
  Command2(CASET, 25+line, 25+line);
  Command2(RASET, column, column);
  Command(RAMWR); Data(block&gt;&gt;16); Data(block&gt;&gt;8); Data(block);
  PORT_TOGGLE(1&lt;&lt;cs);
}</pre>
<h4>Scrolling</h4>
<p>The display doesn&#39;t provide hardware scrolling in the vertical direction, so scrolling is done in software by calling <strong>ScrollDisplay()</strong>, which uses the <strong>ReadBlock()</strong> and <strong>PlotBlock()</strong> routines:</p>
<pre>void ScrollDisplay () {
  uint32_t block, block2;
  for (uint8_t x = 0; x &lt; Columns*3; x++) {
    block = ReadBlock(x, 0);
    for (uint8_t y = 1; y &lt; Lines; y++) {
      block2 = ReadBlock(x, y);
      if (block2 != block) {                   // Optimisation if already the same
        PlotBlock(block2, x, y-1);
        block = block2;
      }
    }
  }
  ClearLine(LastLine);
}</pre>
<p>The routine optimises the scrolling by only writing blocks when necessary if they have been changed by the scrolling.</p>
<h4>Keyboard</h4>
<p>The keyboard uses the AVR128DB48&#39;s Timer/Counter TCB3 to generate an interrupt at about 250Hz. Each call of the interrupt service routine takes the next column low in the keyboard matrix, and it then tests to see if any of the four row inputs has been pulled low by the pressing of a push button. If so, the button&#39;s position is looked up in the key table <strong>Keymap[]</strong> to translate it to the ASCII code of the key. This also takes into account the state of the SHIFT and META keys, which are connected to dedicated inputs.</p>
<p>A keyboard buffer buffers a full screen of text, so you can use the DEL key to delete characters and correct typing mistakes. The line editor includes parenthesis matching which automatically highlights matching brackets in inverse video as you type in a program.</p>
<h3>Installing a bootloader</h3>
<p>To program the Lisp Badge I recommend using Spence Konde&#39;s <a href="https://github.com/SpenceKonde/DxCore" target="_blank">DxCore on GitHub</a>.</p>
<p>The first step is to install a bootloader using a UPDI programmer. Because the display is only tolerant of 3.3V you should power the Lisp Badge from 3.3V while programming, or do the programming before connecting the display to the board.</p>
<p>The recommended option is to use a USB to Serial board, such as the SparkFun FTDI Basic board <sup id="cite_ref11"><a href="#cite_note11">[11]</a></sup>, connected with a 4.7kΩ resistor as follows:</p>
<p><img src="https://stace.dev/pictures/kvm/serialupdiprogrammer3v.gif" alt="SerialUPDIProgrammer3V.gif" width="395" height="147"/></p>
<p>Choose the <strong>AVR DB-series (Optiboot) </strong>option under the <strong>DxCore</strong> heading on the <strong>Board</strong> option on the <strong>Tools</strong> menu. Check that the subsequent options are set as follows (leave other options at their defaults):</p>
<p><strong>Chip: &#34;AVR128DB48&#34;</strong></p>
<p>Set the <strong>Programmer</strong> option as appropriate for the UPDI programmer you are using. Then choose <strong>Burn Bootloader</strong>.</p>
<h3>Uploading the Lisp Badge code</h3>
<p>The next step is to install the Lisp Badge code via the serial connection, using the bootloader you have just installed. Plug a 3.3V FTDI USB-to-serial converter into the FTDI connector on the PCB. I used the same SparkFun FTDI Basic Breakout <sup id="cite_ref12"><a href="#cite_note12">[12]</a></sup>.</p>
<p>Leave the <strong>DxCore</strong> options set as described above, and choose the USB port from the <strong>Port</strong> submenu. Then choose <strong>Upload</strong> from the <strong>Sketch</strong> menu to upload uLisp.</p>
<p>Note that this stage will fail if you didn&#39;t set the <strong>Bootloader Serial Port</strong> correctly in the previous step, and you&#39;ll need to go back and repeat that step with the correct setting.</p>
<p>You should then be able to choose <strong>Serial Monitor</strong> from the <strong>Tools</strong> menu in the Arduino IDE, and type Lisp commands at the uLisp prompt.</p>
<h3>Resources</h3>
<p>Get the latest Lisp Badge LE source from GitHub, together with the Eagle files for the PCB so you can make yourself a board, at: <a href="https://github.com/technoblogy/lisp-badge-le" target="_blank">Lisp Badge LE</a>.</p>
<p>Or order a board from PCBWay here: <a href="https://www.pcbway.com/project/shareproject/W157031ASS72_Lisp_Badge_7_7f9492ee.html" target="_blank">Lisp Badge LE</a>.</p><hr/>
<ol>
<li id="cite_note1"><a href="#cite_ref1">^</a> <a href="https://www.aliexpress.com/item/1005005692052464.html" target="_blank">2.13&#34; 122*250 E-paper ink screen TFT Module</a> on AliExpress.</li>
<li id="cite_note2"><a href="#cite_ref2">^</a> <a href="https://www.adafruit.com/product/5410" target="_blank">Reverse Mount Tactile Switch Buttons</a> on Adafruit.</li>
<li id="cite_note3"><a href="#cite_ref3">^</a> <a href="https://thepihut.com/products/reverse-mount-tactile-switch-buttons-6mm-square-10-pack" target="_blank">Reverse Mount Tactile Switch Buttons</a> on The Pi Hut.</li>
<li id="cite_note4"><a href="#cite_ref4">^</a> <a href="https://www.sparkfun.com/products/9873" target="_blank">FTDI Basic Breakout 3.3V</a> on Sparkfun.</li>
<li id="cite_note5"><a href="#cite_ref5">^</a> <a href="https://uk.farnell.com/kingbright/kptl-3216qbc-d-01/led-smd-1206-optic-blue-reverse/dp/2217907" target="_blank">Kingbright KPTL-3216QBC</a> on Farnell.com.</li>
<li id="cite_note6"><a href="#cite_ref6">^</a> <a href="https://uk.rs-online.com/web/p/piezo-buzzers/1722259" target="_blank">Square Wave External Piezo Buzzer</a> on RS Online.</li>
<li id="cite_note7"><a href="#cite_ref7">^</a> <a href="https://uk.rs-online.com/web/p/piezo-buzzers/7541971" target="_blank">KMTG1102-A1 Piezo Buzzer</a> on RS Online.</li>
<li id="cite_note8"><a href="#cite_ref8">^</a> <a href="https://www.sparkfun.com/products/11892" target="_blank">Coin Cell Battery Holder - 20mm (SMD)</a> on SparkFun.</li>
<li id="cite_note9"><a href="#cite_ref9">^</a> <a href="https://proto-pic.co.uk/product/sparkfun-prt-11892-coin-cell-battery-holder-20mm-smd/" target="_blank">Coin Cell Battery Holder - 20mm (SMD)</a> on Proto-PIC.</li>
<li id="cite_note10"><a href="#cite_ref10">^</a> <a href="https://github.com/zhcong/ST7302-for-arduino/raw/main/doc/ST7302_V0.0.pdf" target="_blank">ST7302 Datasheet</a> download from GitHub.</li>
<li id="cite_note11"><a href="#cite_ref11">^</a> <a href="https://www.sparkfun.com/products/9873" target="_blank">SparkFun FTDI Basic Breakout - 3.3V</a> on SparkFun.</li>
<li id="cite_note12"><a href="#cite_ref12">^</a> <a href="https://www.sparkfun.com/products/9873" target="_blank">SparkFun FTDI Basic Breakout - 3.3V</a> on SparkFun.</li>
</ol>

<hr/>


<p><a href="http://disqus.com">blog comments powered by </a></p></div></div>
  </body>
</html>
