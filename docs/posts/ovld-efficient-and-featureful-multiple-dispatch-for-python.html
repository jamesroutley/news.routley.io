<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/breuleux/ovld">Original</a>
    <h1>Ovld ‚Äì Efficient and featureful multiple dispatch for Python</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Fast multiple dispatch in Python, with many extra features.</p>
<p dir="auto"><a href="https://ovld.readthedocs.io/en/latest/" rel="nofollow">üìã Documentation</a></p>
<p dir="auto">With ovld, you can write a version of the same function for every type signature using annotations instead of writing an awkward sequence of <code>isinstance</code> statements. Unlike Python&#39;s <code>singledispatch</code>, it works for multiple arguments.</p>
<ul dir="auto">
<li>‚ö°Ô∏è <strong><a href="https://ovld.readthedocs.io/en/latest/compare/#results" rel="nofollow">Fast</a>:</strong> ovld is the fastest multiple dispatch library around, by some margin.</li>
<li>üöÄ <a href="https://ovld.readthedocs.io/en/latest/usage/#variants" rel="nofollow"><strong>Variants</strong></a>, <a href="https://ovld.readthedocs.io/en/latest/usage/#mixins" rel="nofollow"><strong>mixins</strong></a> and <a href="https://ovld.readthedocs.io/en/latest/medley" rel="nofollow"><strong>medleys</strong></a> of functions and methods.</li>
<li>ü¶Ñ <strong><a href="https://ovld.readthedocs.io/en/latest/dependent/" rel="nofollow">Dependent types</a>:</strong> Overloaded functions can depend on more than argument types: they can depend on actual values.</li>
<li>üîë <strong><a href="https://ovld.readthedocs.io/en/latest/usage/#keyword-arguments" rel="nofollow">Extensive</a>:</strong> Dispatch on functions, methods, positional arguments and even keyword arguments (with some restrictions).</li>
<li>‚öôÔ∏è <strong><a href="https://ovld.readthedocs.io/en/latest/codegen/" rel="nofollow">Codegen</a>:</strong> (Experimental) For advanced use cases, you can generate custom code for overloads.</li>
</ul>
<p dir="auto">Install with <code>pip install ovld</code></p>

<p dir="auto">Define one version of your function for each type signature you want to support. <code>ovld</code> supports all basic types, plus literals and value-dependent types such as <code>Regexp</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from ovld import ovld
from ovld.dependent import Regexp
from typing import Literal

@ovld
def f(x: str):
    return f&#34;The string {x!r}&#34;

@ovld
def f(x: int):
    return f&#34;The number {x}&#34;

@ovld
def f(x: int, y: int):
    return &#34;Two numbers!&#34;

@ovld
def f(x: Literal[0]):
    return &#34;zero&#34;

@ovld
def f(x: Regexp[r&#34;^X&#34;]):
    return &#34;A string that starts with X&#34;

assert f(&#34;hello&#34;) == &#34;The string &#39;hello&#39;&#34;
assert f(3) == &#34;The number 3&#34;
assert f(1, 2) == &#34;Two numbers!&#34;
assert f(0) == &#34;zero&#34;
assert f(&#34;XSECRET&#34;) == &#34;A string that starts with X&#34;"><pre><span>from</span> <span>ovld</span> <span>import</span> <span>ovld</span>
<span>from</span> <span>ovld</span>.<span>dependent</span> <span>import</span> <span>Regexp</span>
<span>from</span> <span>typing</span> <span>import</span> <span>Literal</span>

<span>@<span>ovld</span></span>
<span>def</span> <span>f</span>(<span>x</span>: <span>str</span>):
    <span>return</span> <span>f&#34;The string <span><span>{</span><span>x</span>!r<span>}</span></span>&#34;</span>

<span>@<span>ovld</span></span>
<span>def</span> <span>f</span>(<span>x</span>: <span>int</span>):
    <span>return</span> <span>f&#34;The number <span><span>{</span><span>x</span><span>}</span></span>&#34;</span>

<span>@<span>ovld</span></span>
<span>def</span> <span>f</span>(<span>x</span>: <span>int</span>, <span>y</span>: <span>int</span>):
    <span>return</span> <span>&#34;Two numbers!&#34;</span>

<span>@<span>ovld</span></span>
<span>def</span> <span>f</span>(<span>x</span>: <span>Literal</span>[<span>0</span>]):
    <span>return</span> <span>&#34;zero&#34;</span>

<span>@<span>ovld</span></span>
<span>def</span> <span>f</span>(<span>x</span>: <span>Regexp</span>[<span>r&#34;^X&#34;</span>]):
    <span>return</span> <span>&#34;A string that starts with X&#34;</span>

<span>assert</span> <span>f</span>(<span>&#34;hello&#34;</span>) <span>==</span> <span>&#34;The string &#39;hello&#39;&#34;</span>
<span>assert</span> <span>f</span>(<span>3</span>) <span>==</span> <span>&#34;The number 3&#34;</span>
<span>assert</span> <span>f</span>(<span>1</span>, <span>2</span>) <span>==</span> <span>&#34;Two numbers!&#34;</span>
<span>assert</span> <span>f</span>(<span>0</span>) <span>==</span> <span>&#34;zero&#34;</span>
<span>assert</span> <span>f</span>(<span>&#34;XSECRET&#34;</span>) <span>==</span> <span>&#34;A string that starts with X&#34;</span></pre></div>

<p dir="auto"><code>ovld</code> shines particularly with recursive definitions, for example tree maps or serialization. Here we define a function that recursively adds lists of lists and integers:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from ovld import ovld, recurse

@ovld
def add(x: list, y: list):
    return [recurse(a, b) for a, b in zip(x, y)]

@ovld
def add(x: list, y: int):
    return [recurse(a, y) for a in x]

@ovld
def add(x: int, y: list):
    return [recurse(x, a) for a in x]

@ovld
def add(x: int, y: int):
    return x + y

assert add([1, 2], [3, 4]) == [4, 6]
assert add([1, 2, [3]], 7) == [8, 9, [10]]"><pre><span>from</span> <span>ovld</span> <span>import</span> <span>ovld</span>, <span>recurse</span>

<span>@<span>ovld</span></span>
<span>def</span> <span>add</span>(<span>x</span>: <span>list</span>, <span>y</span>: <span>list</span>):
    <span>return</span> [<span>recurse</span>(<span>a</span>, <span>b</span>) <span>for</span> <span>a</span>, <span>b</span> <span>in</span> <span>zip</span>(<span>x</span>, <span>y</span>)]

<span>@<span>ovld</span></span>
<span>def</span> <span>add</span>(<span>x</span>: <span>list</span>, <span>y</span>: <span>int</span>):
    <span>return</span> [<span>recurse</span>(<span>a</span>, <span>y</span>) <span>for</span> <span>a</span> <span>in</span> <span>x</span>]

<span>@<span>ovld</span></span>
<span>def</span> <span>add</span>(<span>x</span>: <span>int</span>, <span>y</span>: <span>list</span>):
    <span>return</span> [<span>recurse</span>(<span>x</span>, <span>a</span>) <span>for</span> <span>a</span> <span>in</span> <span>x</span>]

<span>@<span>ovld</span></span>
<span>def</span> <span>add</span>(<span>x</span>: <span>int</span>, <span>y</span>: <span>int</span>):
    <span>return</span> <span>x</span> <span>+</span> <span>y</span>

<span>assert</span> <span>add</span>([<span>1</span>, <span>2</span>], [<span>3</span>, <span>4</span>]) <span>==</span> [<span>4</span>, <span>6</span>]
<span>assert</span> <span>add</span>([<span>1</span>, <span>2</span>, [<span>3</span>]], <span>7</span>) <span>==</span> [<span>8</span>, <span>9</span>, [<span>10</span>]]</pre></div>
<p dir="auto">The <code>recurse</code> function is special: it will recursively call the current ovld object. You may ask: how is it different from simply calling <code>add</code>? The difference is that if you create a <em>variant</em> of <code>add</code>, <code>recurse</code> will automatically call the variant.</p>
<p dir="auto">For example:</p>

<p dir="auto">A <em>variant</em> of an <code>ovld</code> is a copy of the <code>ovld</code>, with some methods added or changed. For example, let&#39;s take the definition of <code>add</code> above and make a variant that multiplies numbers instead:</p>
<div dir="auto" data-snippet-clipboard-copy-content="@add.variant
def mul(x: int, y: int):
    return x * y

assert mul([1, 2], [3, 4]) == [3, 8]"><pre><span>@<span>add</span>.<span>variant</span></span>
<span>def</span> <span>mul</span>(<span>x</span>: <span>int</span>, <span>y</span>: <span>int</span>):
    <span>return</span> <span>x</span> <span>*</span> <span>y</span>

<span>assert</span> <span>mul</span>([<span>1</span>, <span>2</span>], [<span>3</span>, <span>4</span>]) <span>==</span> [<span>3</span>, <span>8</span>]</pre></div>
<p dir="auto">Simple! This means you can define one <code>ovld</code> that recursively walks generic data structures, and then specialize it in various ways.</p>

<p dir="auto">You can define a numeric priority for each method (the default priority is 0):</p>
<div dir="auto" data-snippet-clipboard-copy-content="from ovld import call_next

@ovld(priority=1000)
def f(x: int):
    return call_next(x + 1)

@ovld
def f(x: int):
    return x * x

assert f(10) == 121"><pre><span>from</span> <span>ovld</span> <span>import</span> <span>call_next</span>

<span>@<span>ovld</span>(<span>priority</span><span>=</span><span>1000</span>)</span>
<span>def</span> <span>f</span>(<span>x</span>: <span>int</span>):
    <span>return</span> <span>call_next</span>(<span>x</span> <span>+</span> <span>1</span>)

<span>@<span>ovld</span></span>
<span>def</span> <span>f</span>(<span>x</span>: <span>int</span>):
    <span>return</span> <span>x</span> <span>*</span> <span>x</span>

<span>assert</span> <span>f</span>(<span>10</span>) <span>==</span> <span>121</span></pre></div>
<p dir="auto">Both definitions above have the same type signature, but since the first has higher priority, that is the one that will be called.</p>
<p dir="auto">However, that does not mean there is no way to call the second one. Indeed, when the first function calls the special function <code>call_next(x + 1)</code>, it will call the next function in line, in order of priority and specificity.</p>
<p dir="auto">The pattern you see above is how you may wrap each call with some generic behavior. For instance, if you did something like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="@f.variant(priority=1000)
def f2(x: object)
    print(f&#34;f({x!r})&#34;)
    return call_next(x)"><pre><span>@<span>f</span>.<span>variant</span>(<span>priority</span><span>=</span><span>1000</span>)</span>
<span>def</span> <span>f2</span>(<span>x</span>: <span>object</span>)
    <span>print</span>(<span>f</span><span>&#34;f({x!r})&#34;</span>)
    <span>return</span> <span>call_next</span>(<span>x</span>)</pre></div>
<p dir="auto">The above is effectively a clone of <code>f</code> that traces every call. Useful for debugging.</p>

<p dir="auto">A dependent type is a type that depends on a value. <code>ovld</code> supports this, either through <code>Literal[value]</code> or <code>Dependent[bound, check]</code>. For example, this definition of factorial:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from typing import Literal
from ovld import ovld, recurse, Dependent

@ovld
def fact(n: Literal[0]):
    return 1

@ovld
def fact(n: Dependent[int, lambda n: n &gt; 0]):
    return n * recurse(n - 1)

assert fact(5) == 120
fact(-1)   # Error!"><pre><span>from</span> <span>typing</span> <span>import</span> <span>Literal</span>
<span>from</span> <span>ovld</span> <span>import</span> <span>ovld</span>, <span>recurse</span>, <span>Dependent</span>

<span>@<span>ovld</span></span>
<span>def</span> <span>fact</span>(<span>n</span>: <span>Literal</span>[<span>0</span>]):
    <span>return</span> <span>1</span>

<span>@<span>ovld</span></span>
<span>def</span> <span>fact</span>(<span>n</span>: <span>Dependent</span>[<span>int</span>, <span>lambda</span> <span>n</span>: <span>n</span> <span>&gt;</span> <span>0</span>]):
    <span>return</span> <span>n</span> <span>*</span> <span>recurse</span>(<span>n</span> <span>-</span> <span>1</span>)

<span>assert</span> <span>fact</span>(<span>5</span>) <span>==</span> <span>120</span>
<span>fact</span>(<span>-</span><span>1</span>)   <span># Error!</span></pre></div>
<p dir="auto">The first argument to <code>Dependent</code> must be a type bound. The bound must match before the logic is called, which also ensures we don&#39;t get a performance hit for unrelated types. For type checking purposes, <code>Dependent[T, A]</code> is equivalent to <code>Annotated[T, A]</code>.</p>

<p dir="auto">Define your own types with the <code>@dependent_check</code> decorator:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import torch
from ovld import ovld, dependent_check

@dependent_check
def Shape(tensor: torch.Tensor, *shape):
    return (
        len(tensor.shape) == len(shape)
        and all(s2 is Any or s1 == s2 for s1, s2 in zip(tensor.shape, shape))
    )

@dependent_check
def Dtype(tensor: torch.Tensor, dtype):
    return tensor.dtype == dtype

@ovld
def f(tensor: Shape[3, Any]):
    # Matches 3xN tensors
    ...

@ovld
def f(tensor: Shape[2, 2] &amp; Dtype[torch.float32]):
    # Only matches 2x2 tensors that also have the float32 dtype
    ..."><pre><span>import</span> <span>torch</span>
<span>from</span> <span>ovld</span> <span>import</span> <span>ovld</span>, <span>dependent_check</span>

<span>@<span>dependent_check</span></span>
<span>def</span> <span>Shape</span>(<span>tensor</span>: <span>torch</span>.<span>Tensor</span>, <span>*</span><span>shape</span>):
    <span>return</span> (
        <span>len</span>(<span>tensor</span>.<span>shape</span>) <span>==</span> <span>len</span>(<span>shape</span>)
        <span>and</span> <span>all</span>(<span>s2</span> <span>is</span> <span>Any</span> <span>or</span> <span>s1</span> <span>==</span> <span>s2</span> <span>for</span> <span>s1</span>, <span>s2</span> <span>in</span> <span>zip</span>(<span>tensor</span>.<span>shape</span>, <span>shape</span>))
    )

<span>@<span>dependent_check</span></span>
<span>def</span> <span>Dtype</span>(<span>tensor</span>: <span>torch</span>.<span>Tensor</span>, <span>dtype</span>):
    <span>return</span> <span>tensor</span>.<span>dtype</span> <span>==</span> <span>dtype</span>

<span>@<span>ovld</span></span>
<span>def</span> <span>f</span>(<span>tensor</span>: <span>Shape</span>[<span>3</span>, <span>Any</span>]):
    <span># Matches 3xN tensors</span>
    ...

<span>@<span>ovld</span></span>
<span>def</span> <span>f</span>(<span>tensor</span>: <span>Shape</span>[<span>2</span>, <span>2</span>] <span>&amp;</span> <span>Dtype</span>[<span>torch</span>.<span>float32</span>]):
    <span># Only matches 2x2 tensors that also have the float32 dtype</span>
    ...</pre></div>
<p dir="auto">The first parameter is the value to check. The type annotation (e.g. <code>value: torch.Tensor</code> above) is interpreted by <code>ovld</code> to be the bound for this type, so <code>Shape</code> will only be called on parameters of type <code>torch.Tensor</code>.</p>

<p dir="auto">Either inherit from <code>OvldBase</code> or use the <code>OvldMC</code> metaclass to use multiple dispatch on methods.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from ovld import OvldBase, OvldMC

# class Cat(OvldBase):  &lt;= Also an option
class Cat(metaclass=OvldMC):
    def interact(self, x: Mouse):
        return &#34;catch&#34;

    def interact(self, x: Food):
        return &#34;devour&#34;

    def interact(self, x: PricelessVase):
        return &#34;destroy&#34;"><pre><span>from</span> <span>ovld</span> <span>import</span> <span>OvldBase</span>, <span>OvldMC</span>

<span># class Cat(OvldBase):  &lt;= Also an option</span>
<span>class</span> <span>Cat</span>(<span>metaclass</span><span>=</span><span>OvldMC</span>):
    <span>def</span> <span>interact</span>(<span>self</span>, <span>x</span>: <span>Mouse</span>):
        <span>return</span> <span>&#34;catch&#34;</span>

    <span>def</span> <span>interact</span>(<span>self</span>, <span>x</span>: <span>Food</span>):
        <span>return</span> <span>&#34;devour&#34;</span>

    <span>def</span> <span>interact</span>(<span>self</span>, <span>x</span>: <span>PricelessVase</span>):
        <span>return</span> <span>&#34;destroy&#34;</span></pre></div>

<p dir="auto">Subclasses inherit overloaded methods. They may define additional overloads for these methods which will only be valid for the subclass, but they need to use the <code>@extend_super</code> decorator (this is required for clarity):</p>
<div dir="auto" data-snippet-clipboard-copy-content="from ovld import OvldMC, extend_super

class One(metaclass=OvldMC):
    def f(self, x: int):
        return &#34;an integer&#34;

class Two(One):
    @extend_super
    def f(self, x: str):
        return &#34;a string&#34;

assert Two().f(1) == &#34;an integer&#34;
assert Two().f(&#34;s&#34;) == &#34;a string&#34;"><pre><span>from</span> <span>ovld</span> <span>import</span> <span>OvldMC</span>, <span>extend_super</span>

<span>class</span> <span>One</span>(<span>metaclass</span><span>=</span><span>OvldMC</span>):
    <span>def</span> <span>f</span>(<span>self</span>, <span>x</span>: <span>int</span>):
        <span>return</span> <span>&#34;an integer&#34;</span>

<span>class</span> <span>Two</span>(<span>One</span>):
    <span>@<span>extend_super</span></span>
    <span>def</span> <span>f</span>(<span>self</span>, <span>x</span>: <span>str</span>):
        <span>return</span> <span>&#34;a string&#34;</span>

<span>assert</span> <span>Two</span>().<span>f</span>(<span>1</span>) <span>==</span> <span>&#34;an integer&#34;</span>
<span>assert</span> <span>Two</span>().<span>f</span>(<span>&#34;s&#34;</span>) <span>==</span> <span>&#34;a string&#34;</span></pre></div>

<p dir="auto">Inheriting from <a href="https://ovld.readthedocs.io/en/latest/medley/" rel="nofollow"><code>ovld.Medley</code></a> lets you combine functionality in a new way. Classes created that way are free-form medleys that you can (almost) arbitrarily combine together.</p>
<p dir="auto">All medleys are dataclasses and you must define their data fields as you would for a normal dataclass (using <code>dataclass.field</code> if needed).</p>
<div dir="auto" data-snippet-clipboard-copy-content="from ovld import Medley

class Punctuator(Medley):
    punctuation: str = &#34;.&#34;

    def __call__(self, x: str):
        return f&#34;{x}{self.punctuation}&#34;

class Multiplier(Medley):
    factor: int = 3

    def __call__(self, x: int):
        return x * self.factor

# You can add the classes together to merge their methods and fields using ovld
PuMu = Punctuator + Multiplier
f = PuMu(punctuation=&#34;!&#34;, factor=3)

# You can also combine existing instances!
f2 = Punctuator(&#34;!&#34;) + Multiplier(3)

assert f(&#34;hello&#34;) == f2(&#34;hello&#34;) == &#34;hello!&#34;
assert f(10) == f2(10) == 30

# You can also meld medleys inplace, but only if all new fields have defaults
class Total(Medley):
    pass

Total.extend(Punctuator, Multiplier)
f3 = Total(punctuation=&#34;!&#34;, factor=3)"><pre><span>from</span> <span>ovld</span> <span>import</span> <span>Medley</span>

<span>class</span> <span>Punctuator</span>(<span>Medley</span>):
    <span>punctuation</span>: <span>str</span> <span>=</span> <span>&#34;.&#34;</span>

    <span>def</span> <span>__call__</span>(<span>self</span>, <span>x</span>: <span>str</span>):
        <span>return</span> <span>f&#34;<span><span>{</span><span>x</span><span>}</span></span><span><span>{</span><span>self</span>.<span>punctuation</span><span>}</span></span>&#34;</span>

<span>class</span> <span>Multiplier</span>(<span>Medley</span>):
    <span>factor</span>: <span>int</span> <span>=</span> <span>3</span>

    <span>def</span> <span>__call__</span>(<span>self</span>, <span>x</span>: <span>int</span>):
        <span>return</span> <span>x</span> <span>*</span> <span>self</span>.<span>factor</span>

<span># You can add the classes together to merge their methods and fields using ovld</span>
<span>PuMu</span> <span>=</span> <span>Punctuator</span> <span>+</span> <span>Multiplier</span>
<span>f</span> <span>=</span> <span>PuMu</span>(<span>punctuation</span><span>=</span><span>&#34;!&#34;</span>, <span>factor</span><span>=</span><span>3</span>)

<span># You can also combine existing instances!</span>
<span>f2</span> <span>=</span> <span>Punctuator</span>(<span>&#34;!&#34;</span>) <span>+</span> <span>Multiplier</span>(<span>3</span>)

<span>assert</span> <span>f</span>(<span>&#34;hello&#34;</span>) <span>==</span> <span>f2</span>(<span>&#34;hello&#34;</span>) <span>==</span> <span>&#34;hello!&#34;</span>
<span>assert</span> <span>f</span>(<span>10</span>) <span>==</span> <span>f2</span>(<span>10</span>) <span>==</span> <span>30</span>

<span># You can also meld medleys inplace, but only if all new fields have defaults</span>
<span>class</span> <span>Total</span>(<span>Medley</span>):
    <span>pass</span>

<span>Total</span>.<span>extend</span>(<span>Punctuator</span>, <span>Multiplier</span>)
<span>f3</span> <span>=</span> <span>Total</span>(<span>punctuation</span><span>=</span><span>&#34;!&#34;</span>, <span>factor</span><span>=</span><span>3</span>)</pre></div>

<p dir="auto">(Experimental) For advanced use cases, you can generate custom code for type checkers or overloads. <a href="https://ovld.readthedocs.io/en/latest/codegen/" rel="nofollow">See here</a>.</p>

<p dir="auto"><code>ovld</code> is pretty fast: the overhead is comparable to <code>isinstance</code> or <code>match</code>, and only 2-3x slower when dispatching on <code>Literal</code> types. Compared to other multiple dispatch libraries, it has 1.5x to 100x less overhead.</p>
<p dir="auto">Time relative to the fastest implementation (1.00) (lower is better).</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Benchmark</th>
<th>custom</th>
<th><a href="https://github.com/breuleux/ovld">ovld</a></th>
<th><a href="https://github.com/beartype/plum">plum</a></th>
<th><a href="https://github.com/coady/multimethod">multim</a></th>
<th><a href="https://github.com/mrocklin/multipledispatch/">multid</a></th>
<th><a href="https://github.com/erezsh/runtype">runtype</a></th>
<th><a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow">sd</a></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/breuleux/ovld/tree/master/benchmarks/test_trivial.py">trivial</a></td>
<td>1.56</td>
<td>1.00</td>
<td>3.38</td>
<td>4.92</td>
<td>2.00</td>
<td>2.38</td>
<td>2.15</td>
</tr>
<tr>
<td><a href="https://github.com/breuleux/ovld/tree/master/benchmarks/test_multer.py">multer</a></td>
<td>1.22</td>
<td>1.00</td>
<td>11.06</td>
<td>4.67</td>
<td>9.22</td>
<td>2.24</td>
<td>3.92</td>
</tr>
<tr>
<td><a href="https://github.com/breuleux/ovld/tree/master/benchmarks/test_add.py">add</a></td>
<td>1.27</td>
<td>1.00</td>
<td>3.61</td>
<td>4.93</td>
<td>2.24</td>
<td>2.62</td>
<td>x</td>
</tr>
<tr>
<td><a href="https://github.com/breuleux/ovld/tree/master/benchmarks/test_ast.py">ast</a></td>
<td>1.01</td>
<td>1.00</td>
<td>22.98</td>
<td>2.72</td>
<td>1.52</td>
<td>1.70</td>
<td>1.57</td>
</tr>
<tr>
<td><a href="https://github.com/breuleux/ovld/tree/master/benchmarks/test_calc.py">calc</a></td>
<td>1.00</td>
<td>1.28</td>
<td>57.86</td>
<td>29.79</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td><a href="https://github.com/breuleux/ovld/tree/master/benchmarks/test_regexp.py">regexp</a></td>
<td>1.00</td>
<td>2.28</td>
<td>22.71</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td><a href="https://github.com/breuleux/ovld/tree/master/benchmarks/test_fib.py">fib</a></td>
<td>1.00</td>
<td>3.39</td>
<td>403.38</td>
<td>114.69</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td><a href="https://github.com/breuleux/ovld/tree/master/benchmarks/test_tweaknum.py">tweaknum</a></td>
<td>1.00</td>
<td>1.86</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
</article></div></div>
  </body>
</html>
