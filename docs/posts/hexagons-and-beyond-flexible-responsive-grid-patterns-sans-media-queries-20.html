<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://css-tricks.com/hexagons-and-beyond-flexible-responsive-grid-patterns-sans-media-queries/">Original</a>
    <h1>Hexagons and Beyond: Flexible, Responsive Grid Patterns, Sans Media Queries (20</h1>
    
    <div id="readability-page-1" class="page"><div>

          
          
<p>A little while back, Chris shared <a href="https://css-tricks.com/building-a-hexagonal-grid-using-css-grid/">this nice hexagonal grid</a>. And true to its name, it’s using —wait for it — CSS Grid to form that layout. It’s a neat trick! Combining grid columns, grid gaps, and creative clipping churns out the final result.</p>



<p>A similar thing could be accomplished with flexbox, too. But I’m here to resurrect our old friend <code>float</code> to create the same sort of complex and responsive layout — but with less complexity and without a single media query.</p>



<p>I know, it’s hard to believe. So let’s start with a working demo:</p>







<p>This is a fully responsive hexagon grid made without media queries, JavaScript, or a ton of hacky CSS. Resize the demo screen and see the magic. In addition to being responsive, the grid also scales. For example, we can chuck more hexagons in there by adding more divs, and control both the sizing and spacing using CSS variables.</p>



<p>Cool, right? And this is only one example among many grids we will build in the same manner.</p>


<h3 id="h-making-a-grid-of-hexagons"><a href="#aa-making-a-grid-of-hexagons" aria-hidden="true" id="aa-making-a-grid-of-hexagons"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Making a grid of hexagons</h3>


<p>First, we create our hexagon shape. This task is fairly easy using <code>clip-path</code>. We will consider a variable <code>S</code> that will define the dimension of our element. Bennett Feely’s <a href="https://bennettfeely.com/clippy/" rel="noopener">Clippy</a> is a great online generator for clip paths.</p>



<figure><img loading="lazy" data-recalc-dims="1" fetchpriority="high" decoding="async" width="714" height="518" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/hex-clip-path.png?resize=714%2C518&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/hex-clip-path.png?w=714&amp;ssl=1 714w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/hex-clip-path.png?resize=300%2C218&amp;ssl=1 300w" sizes="(min-width: 735px) 864px, 96vw"/><figcaption>Creating a hexagonal shape using <code>clip-path</code></figcaption></figure>



<p>Each hexagon is an <code>inline-block</code> element. The markup can go something like this:</p>



<pre rel="HTML" data-line=""><code markup="tt">&lt;div class=&#34;main&#34;&gt;
  &lt;div class=&#34;container&#34;&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;!--etc. --&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>



<p>…and the CSS:</p>



<pre rel="CSS" data-line=""><code markup="tt">.main {
  display: flex; /* we will talk about this later ... */
  --s: 100px;  /* size  */
  --m: 4px;   /* margin */
}

.container {
  font-size: 0; /* disable white space between inline block element */
}

.container div {
  width: var(--s);
  margin: var(--m);
  height: calc(var(--s) * 1.1547);
  display: inline-block;
  font-size: initial; /* we reset the font-size if we want to add some content */
  clip-path: polygon(0% 25%, 0% 75%, 50% 100%, 100% 75%, 100% 25%, 50% 0%);
}</code></pre>



<p>Nothing complex so far. We have a main element that holds a container which, in turn, holds the hexagons. Since we are dealing with <code>inline-block</code>, we need to fight the common white space issue (using the <code>font-size</code> trick) and we consider some margin (defined with the variable <code>M</code>) to control the space.</p>



<figure><img loading="lazy" data-recalc-dims="1" decoding="async" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_489C47DEB5ED3D99F49CAA77D7A68EFC4ED23B49384A4DBBBBDE77C56A5997D3_1622153193505_hexagon-font-size.gif?resize=761%2C322&amp;ssl=1" alt="" width="761" height="322"/><figcaption>Toggling the font-size of the first demo to illustrate the white space issue</figcaption></figure>



<p>Here’s the result so far:</p>



<figure><img loading="lazy" data-recalc-dims="1" decoding="async" width="1214" height="386" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/CefrNYpk.png?resize=1214%2C386&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/CefrNYpk.png?w=1214&amp;ssl=1 1214w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/CefrNYpk.png?resize=300%2C95&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/CefrNYpk.png?resize=1024%2C326&amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/CefrNYpk.png?resize=768%2C244&amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/CefrNYpk.png?resize=1000%2C318&amp;ssl=1 1000w" sizes="(min-width: 735px) 864px, 96vw"/></figure>



<p id="figure-1">Every other row needs some negative offset so the rows overlap rather than stack directly on top of each other. That offset will be equal to <code>25%</code> of the element height (see <a href="#figure-1">Figure 1</a>). We apply that offset to <code>margin-bottom</code> to get the following:</p>



<pre rel="CSS" data-line="8,9"><code markup="tt">.container div {
  width: var(--s);
  margin: var(--m);
  height: calc(var(--s) * 1.1547);
  display: inline-block;
  font-size: initial;
  clip-path: polygon(0% 25%, 0% 75%, 50% 100%, 100% 75%, 100% 25%, 50% 0%);
  margin-bottom: calc(var(--m) - var(--s) * 0.2886); /* some negative margin to create overlap */
}</code></pre>



<p>…and the result becomes:</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="1212" height="332" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619908434242_image.png?resize=1212%2C332&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619908434242_image.png?w=1212&amp;ssl=1 1212w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619908434242_image.png?resize=300%2C82&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619908434242_image.png?resize=1024%2C281&amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619908434242_image.png?resize=768%2C210&amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619908434242_image.png?resize=1000%2C274&amp;ssl=1 1000w" sizes="auto, (min-width: 735px) 864px, 96vw"/></figure>



<p>Now the real trick is how we can shift the second row to get a perfect hexagon grid. We’ve already scrunched things to the point where the rows overlap each other vertically, but what we need is to push every other row toward the right so the hexagons stagger rather than overlap. Here’s where <code>float</code> and <code>shape-outside</code> come into play.</p>



<p>Did you wonder why we have a <code>.main</code> element wrapping our container and having <code>display: flex</code> ? That div is also a part of the trick. In a <a href="https://css-tricks.com/float-an-element-to-the-bottom-corner/">previous article</a>, I used <code>float</code> and I needed that flexbox container in order to be able to use <code>height: 100%</code>. I will be doing the same thing here.</p>



<pre rel="CSS" data-line=""><code markup="tt">.container::before {
  content: &#34;&#34;;
  width: calc(var(--s)/2 + var(--m));
  float: left;
  height: 100%;
}</code></pre>



<p>I am using the <code>container::before</code> pseudo-element to create a float element that take up all the height at the left of the grid, and that has a width equal to half a hexagon (plus its margin). We get the following result: </p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="1062" height="423" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/PTuQEwm8.png?resize=1062%2C423&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/PTuQEwm8.png?w=1062&amp;ssl=1 1062w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/PTuQEwm8.png?resize=300%2C119&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/PTuQEwm8.png?resize=1024%2C408&amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/PTuQEwm8.png?resize=768%2C306&amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/PTuQEwm8.png?resize=1000%2C398&amp;ssl=1 1000w" sizes="auto, (min-width: 735px) 864px, 96vw"/><figcaption>The yellow area is our<code>.container::before</code> pseudo-element.</figcaption></figure>



<p>Now, we can reach for <code>shape-outside</code>. Let’s take a quick refresher on what it does. Robin <a href="https://css-tricks.com/almanac/properties/s/shape-outside/">defines it nicely</a> in the CSS-Tricks Almanac. MDN describes it nicely as well:</p>



<blockquote><p>The <code>shape-outside</code> CSS property defines a shape—which may be non-rectangular—around which adjacent <strong>inline content</strong> should wrap. By default, inline content wraps around its margin box; <code>shape-outside</code> provides a way to customize this wrapping, making it possible to wrap text around complex objects rather than simple boxes.</p><cite><em>Emphasis mine</em></cite></blockquote>



<p>Notice “inline content” in the definition. This explains exactly why the hexagons need to be <code>inline-block</code> elements. But to understand what kind of shape we need, let’s zoom into the pattern.</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="764" height="612" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619910028475_image.png?resize=764%2C612&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619910028475_image.png?w=764&amp;ssl=1 764w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619910028475_image.png?resize=300%2C240&amp;ssl=1 300w" sizes="auto, (min-width: 735px) 864px, 96vw"/></figure>



<p>What’s cool about <code>shape-outside</code> is that it actually works with gradients. But what kind of gradient fits our situation?</p>



<p>If, for example, we have 10 rows of hexagons, we only need to shift means every <em>even</em> row. Seen differently, we need to shift every second row so we need a kind of repetition — perfect for a repeating gradient!</p>



<p>We’ll create a gradient with two colors: </p>



<ul><li>A transparent one to create the “free space” while allowing the first row to stay in place (illustrated by the blue arrow above).</li><li>An opaque color to shift the second row to the right so the hexagons aren’t directly stacked on top of one another (illustrated by the green arrow).</li></ul>



<p>Our <code>shape-outside</code> value will look like this:</p>



<pre rel="CSS" data-line=""><code markup="tt">shape-outside: repeating-linear-gradient(#0000 0 A, #000 0 B); /* #0000 = transparent */</code></pre>



<p>Now, let’s find the value of <code>A</code> and <code>B</code>. <code>B</code> will simply be equal to the height of two rows since our logic need to repeat each two rows.</p>



<p>The height of two rows is equal to the height of two hexagons (including their margins), minus twice the overlap (<code>2*Height + 4*M - 2*Height*25% = 1.5*Height + 4*M</code> ). Or, expressed in CSS with <code>calc()</code>:</p>



<pre rel="CSS" data-line=""><code markup="tt">calc(1.732 * var(--s) + 4 * var(--m))</code></pre>



<p>That’s a lot! So, let’s hold all of this in a CSS custom property, <code>F</code>.</p>



<p>The value of <code>A</code> (defined by the blue arrow in the previous figure) needs to be at least equal to the size of one hexagon, but it can also be bigger. In order to push the second row over to the right, we need few pixel of opaque color so <code>A</code> can simply be equal to <code>B - Xpx</code>, where <code>X</code> is a small value. </p>



<p>We end up with something like this:</p>



<pre rel="CSS" data-line=""><code markup="tt">shape-outside: repeating-linear-gradient(#0000 0 calc(var(--f) - 3px),#000 0 var(--f));</code></pre>



<p>And the following result: </p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="676" height="528" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619910864415_image.png?resize=676%2C528&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619910864415_image.png?w=676&amp;ssl=1 676w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619910864415_image.png?resize=300%2C234&amp;ssl=1 300w" sizes="auto, (min-width: 735px) 864px, 96vw"/><figcaption><code>shape-outside</code> is applied to the floated element, creating a floated area with a predating linear gradient.</figcaption></figure>



<p>See that? Our repeating linear gradient’s shape is pushing every other row to the right by one half the width of a hexagon to offset the pattern.</p>



<p>Let’s put that all together:</p>



<pre rel="CSS" data-line=""><code markup="tt">.main {
  display:flex;
  --s: 100px;  /* size  */
  --m: 4px;    /* margin */
  --f: calc(var(--s) * 1.732 + 4 * var(--m) - 1px); 
}

.container {
  font-size: 0; /* disable white space between inline block element */
}

.container div {
  width: var(--s);
  margin: var(--m);
  height: calc(var(--s) * 1.1547);
  display: inline-block;
  font-size:initial;
  clip-path: polygon(0% 25%, 0% 75%, 50% 100%, 100% 75%, 100% 25%, 50% 0%);
  margin-bottom: calc(var(--m) - var(--s) * 0.2885);
}

.container::before {
  content: &#34;&#34;;
  width: calc(var(--s) / 2 + var(--m));
  float: left;
  height: 120%; 
  shape-outside: repeating-linear-gradient(#0000 0 calc(var(--f) - 3px), #000 0 var(--f));
}</code></pre>



<p>That’s it! With no more than 15 CSS declarations, we have a responsive grid that fit nicely into all the screen sizes and we can easily adjust things by simply controling two variables.</p>



<p>You may have noticed that I am adding <code>-1px</code> to the variable <code>F</code>. Since we are dealing with calculation that involve decimals, the rounding may give us bad results. To avoid this we add or remove few pixels. I am also using <code>120%</code> instead of <code>100%</code> for the height of the floated element for similar reasons. There is no particular logic with theses values; we simply adjust them to make sure to cover most of the cases without any misaligning our shapes.</p>


<h3 id="h-want-more-shapes"><a href="#aa-want-more-shapes" aria-hidden="true" id="aa-want-more-shapes"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Want more shapes?</h3>


<p>We can do more than hexagons with this approach! Let’s create a “rhombus” grid instead. Again, we start with our <code>clip-path</code> to create the shape:</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="526" height="460" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/rhombus-clip-path.png?resize=526%2C460&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/rhombus-clip-path.png?w=526&amp;ssl=1 526w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/rhombus-clip-path.png?resize=300%2C262&amp;ssl=1 300w" sizes="auto, (min-width: 735px) 864px, 96vw"/><figcaption>Rhombus shape using clip-path</figcaption></figure>



<p>The code is basically the same. What’s changing are the calculations and values. Find below a table that will illustrate the changes.</p>



<figure><table><thead><tr><th></th><th><strong>Hexagon grid</strong></th><th><strong>Rhombus grid</strong></th></tr></thead><tbody><tr><td><code>height</code></td><td><code>calc(var(--s)*1.1547)</code></td><td><code>var(--s)</code></td></tr><tr><td><code>clip-path</code></td><td><code>polygon(0% 25%, 0% 75%, 50% 100%, 100% 75%, 100% 25%, 50% 0%)</code></td><td><code>polygon(50% 0, 100% 50%, 50% 100%, 0 50%)</code></td></tr><tr><td><code>margin-bottom</code></td><td><code>calc(var(--m) - var(--s)*0.2885)</code></td><td><code>calc(var(--m) - var(--s)*0.5)</code></td></tr><tr><td><code>--f</code></td><td><code>calc(var(--s)*1.7324 + 4*var(--m))</code></td><td><code>calc(var(--s) + 4*var(--m))</code></td></tr></tbody></table></figure>



<p>And we’re done! A mere four changes to our code gets us a completely new grid but with a different shape.</p>






<h3 id="h-just-how-flexible-is-this"><a href="#aa-just-how-flexible-is-this" aria-hidden="true" id="aa-just-how-flexible-is-this"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Just how flexible is this?</h3>


<p>We saw how we were able to make the hexagon and rhombus grids using the exact same code structure, but different variables. Let me blow your mind with another idea: What about making that calculation a variable so that we can easily switch between different grids without changing the code? We can certainly do that!</p>



<p>We’ll use an octagonal shape because it’s more of a generic shape from that we can use to create other shapes (a hexagon, a rhombus, a rectangle, etc.) simply by changing a few values.</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="638" height="494" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/octagon-clip-path.png?resize=638%2C494&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/octagon-clip-path.png?w=638&amp;ssl=1 638w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/octagon-clip-path.png?resize=300%2C232&amp;ssl=1 300w" sizes="auto, (min-width: 735px) 864px, 96vw"/><figcaption>The points on this octagon shape are defined in the <code>clip-path</code> property.</figcaption></figure>



<p>Our octagon is defined with four variables:</p>



<ul><li><code>S</code>: the width.</li><li><code>R</code>: the ratio that will help us defines the height based on the width.</li><li><code>hc</code> and <code>vc</code> : both of these will control our <code>clip-path</code> values and the shape we want to get. <code>hc</code> will be based on the width while <code>vc</code> on the height</li></ul>



<p>I know it looks hefty, but the <code>clip-path</code> is defined using eight points (like shown in the figure). Adding some CSS variables, we get this:</p>



<pre rel="CSS" data-line=""><code markup="tt">clip-path: polygon(
   var(--hc) 0, calc(100% - var(--hc)) 0, /* 2 points at the top */
   100% var(--vc),100% calc(100% - var(--vc)), /* 2 points at the right */
   calc(100% - var(--hc)) 100%, var(--hc) 100%, /* 2 points at the bottom */
   0 calc(100% - var(--vc)),0 var(--vc) /* 2 points at the left */
);</code></pre>



<p>This is what we’re aiming for:</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="1148" height="316" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619961411571_image.png?resize=1148%2C316&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619961411571_image.png?w=1148&amp;ssl=1 1148w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619961411571_image.png?resize=300%2C83&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619961411571_image.png?resize=1024%2C282&amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619961411571_image.png?resize=768%2C211&amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619961411571_image.png?resize=1000%2C275&amp;ssl=1 1000w" sizes="auto, (min-width: 735px) 864px, 96vw"/></figure>



<p>Let’s zoom in to identify the different values:</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="694" height="482" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619963939847_image.png?resize=694%2C482&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619963939847_image.png?w=694&amp;ssl=1 694w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619963939847_image.png?resize=300%2C208&amp;ssl=1 300w" sizes="auto, (min-width: 735px) 864px, 96vw"/></figure>



<p>The overlap between each row (illustrated by the red arrow) can be expressed using the <code>vc</code> variable which gives us a <code>margin-bottom</code> equal to <code>M - vc</code> (where <code>M</code> is our margin).</p>



<p>In addition to the margin we applied between our element, we also need an additional horizontal margin (illustrated by the yellow arrow) equal to <code>S - 2*hc</code>. Let’s define another variable for the horizontal margin (<code>MH</code>) that is equal to <code>M + (S - 2*hc)/2</code>. </p>



<p>The height of two rows is equal to twice the size of a shape (plus the margin), minus twice the overlap, or <code>2*(S + 2*M) - 2*vc</code>.</p>



<p>Let’s update our table of values to see how we’re calculating things between the different grids:</p>



<figure><table><thead><tr><th></th><th><strong>Hexagon grid</strong></th><th><strong>Rhombus grid</strong></th><th><strong>Octagon grid</strong></th></tr></thead><tbody><tr><td><code>height</code></td><td><code>calc(var(--s)*1.1547)</code></td><td><code>var(--s)</code></td><td><code>calc(var(--s)*var(--r)))</code></td></tr><tr><td><code>clip-path</code></td><td><code>polygon(0% 25%, 0% 75%, 50% 100%, 100% 75%, 100% 25%, 50% 0%)</code></td><td><code>polygon(50% 0, 100% 50%, 50% 100%, 0 50%)</code></td><td><code>polygon(var(--hc) 0, calc(100% - var(--hc)) 0,100% var(--vc),100% calc(100% - var(--vc)), calc(100% - var(--hc)) 100%,var(--hc) 100%,0 calc(100% - var(--vc)),0 var(--vc))</code></td></tr><tr><td><code>--mh</code></td><td>–</td><td>–</td><td><code>calc(var(--m) + (var(--s) - 2*var(--hc))/2)</code></td></tr><tr><td><code>margin</code></td><td><code>var(--m)</code></td><td><code>var(--m)</code></td><td><code>var(--m) var(--mh)</code></td></tr><tr><td><code>margin-bottom</code></td><td><code>calc(var(--m) - var(--s)*0.2885)</code></td><td><code>calc(var(--m) - var(--s)*0.5)</code></td><td><code>calc(var(--m) - var(--vc))</code></td></tr><tr><td><code>--f</code></td><td><code>calc(var(--s)*1.7324 + 4*var(--m))</code></td><td><code>calc(var(--s) + 4*var(--m))</code></td><td><code>calc(2*var(--s) + 4*var(--m) - 2*var(--vc))</code></td></tr></tbody></table></figure>



<p>Alright, let’s update our CSS with those adjustments:</p>



<pre rel="CSS" data-line=""><code markup="tt">.main {
  display: flex;
  --s: 100px;  /* size  */
  --r: 1; /* ratio */

  /* clip-path parameter */
  --hc: 20px; 
  --vc: 30px;

  --m: 4px; /* vertical margin */
  --mh: calc(var(--m) + (var(--s) - 2*var(--hc))/2); /* horizontal margin */
  --f: calc(2*var(--s) + 4*var(--m) - 2*var(--vc) - 2px);
}

.container {
  font-size: 0; /* disable white space between inline block element */
}

.container div {
  width: var(--s);
  margin: var(--m) var(--mh);
  height: calc(var(--s)*var(--r));
  display: inline-block;
  font-size: initial;
  clip-path: polygon( ... );
  margin-bottom: calc(var(--m) - var(--vc));
}

.container::before {
  content: &#34;&#34;;
  width: calc(var(--s)/2 + var(--mh));
  float: left;
  height: 120%; 
  shape-outside: repeating-linear-gradient(#0000 0 calc(var(--f) - 3px),#000 0 var(--f));
}</code></pre>



<p>As we can see, the code structure is the same. We simply added more variable to control the shape and extend the <code>margin</code> property.</p>



<p>And below a working example. Adjust the different variables to control the shape while having a fully responsive grid:</p>







<p>An interactive demo, you say? You bet!</p>







<p>To make things easier, I am expressing the <code>vc</code> and <code>hc</code> as percetange of the width and height so we can easily scale our elements without breaking the <code>clip-path</code> </p>



<p>From the above we can easily get the initial hexagonal grid:</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619967785492_image.png?resize=978%2C406&amp;ssl=1" alt="" width="978" height="406" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619967785492_image.png?w=1036&amp;ssl=1 1036w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619967785492_image.png?resize=300%2C125&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619967785492_image.png?resize=1024%2C425&amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619967785492_image.png?resize=768%2C319&amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619967785492_image.png?resize=1000%2C415&amp;ssl=1 1000w" sizes="auto, (min-width: 735px) 864px, 96vw"/></figure>



<p>The rhombus grid:</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619967852929_image.png?resize=994%2C293&amp;ssl=1" alt="" width="994" height="293" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619967852929_image.png?w=1062&amp;ssl=1 1062w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619967852929_image.png?resize=300%2C89&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619967852929_image.png?resize=1024%2C303&amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619967852929_image.png?resize=768%2C227&amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619967852929_image.png?resize=1000%2C296&amp;ssl=1 1000w" sizes="auto, (min-width: 735px) 864px, 96vw"/></figure>



<p>And yet another hexagon grid:</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="1054" height="336" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/vm8u1y_Y.png?resize=1054%2C336&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/vm8u1y_Y.png?w=1054&amp;ssl=1 1054w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/vm8u1y_Y.png?resize=300%2C96&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/vm8u1y_Y.png?resize=1024%2C326&amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/vm8u1y_Y.png?resize=768%2C245&amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/vm8u1y_Y.png?resize=1000%2C319&amp;ssl=1 1000w" sizes="auto, (min-width: 735px) 864px, 96vw"/></figure>



<p>A masonry-like grid:</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="878" height="264" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619968042870_image.png?resize=878%2C264&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619968042870_image.png?w=878&amp;ssl=1 878w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619968042870_image.png?resize=300%2C90&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619968042870_image.png?resize=768%2C231&amp;ssl=1 768w" sizes="auto, (min-width: 735px) 864px, 96vw"/></figure>



<p>And a checkerboard while we are at it:</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="880" height="274" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619968097777_image.png?resize=880%2C274&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619968097777_image.png?w=880&amp;ssl=1 880w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619968097777_image.png?resize=300%2C93&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1619968097777_image.png?resize=768%2C239&amp;ssl=1 768w" sizes="auto, (min-width: 735px) 864px, 96vw"/></figure>



<p>A lot of possibilities to create a responsive grid with any kind of shape! All we have to do is adjust few variables.</p>


<h3 id="h-fixing-the-alignment"><a href="#aa-fixing-the-alignment" aria-hidden="true" id="aa-fixing-the-alignment"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fixing the alignment</h3>


<p>Let’s try to control the alignment of our shapes. Since we are dealing with <code>inline-block</code> elements, we’re dealing with default left alignment and some empty space at the end, depending on viewport width.</p>



<p>Notice that we alternate between two kind of grids based on the screen width:</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="768" height="528" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1620174099369_image.png?resize=768%2C528&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1620174099369_image.png?w=768&amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1620174099369_image.png?resize=300%2C206&amp;ssl=1 300w" sizes="auto, (min-width: 735px) 864px, 96vw"/><figcaption>Grid #1: A different number of items per row (<code>N</code>, <code>N-1</code>,<code>N</code>, <code>N-1</code>, etc.)</figcaption></figure>



<p>It would be good to always have one of the grid all the time (either #1 or #2) and center everything so that the free space is equally divided on both sides. </p>



<p>In order to get the first grid in the figure above, the container width needs to be a multiplier of the size of one shape, plus its margin, or <code>N*(S + 2*MH)</code>, where <code>N</code> is an integer value.</p>



<p>This may sound impossible with CSS, but it’s indeed possible. I made it using CSS grid:</p>



<pre rel="CSS" data-line=""><code markup="tt">.main {
  display: grid;
  grid-template-columns: repeat(auto-fit, calc(var(--s) + 2*var(--mh)));
  justify-content: center;
}

.container {
  grid-column: 1/-1;
}</code></pre>



<p><code>.main</code> is now a grid container. Using <code>grid-template-columns</code>, I define the column width (as previously explained) and use the <code>auto-fit</code> value to get as many columns as possible into the available space. Then, the <code>.container</code> spans all of the grid columns using <code>1/-1</code> — which means that the width of our container will be a mutiplier of one column size.</p>



<p>All it takes to center things is <code>justify-content: center</code>. </p>



<p>Yes, CSS is magic!</p>







<p>Resize the demo and notice that not only do we have the first grid from the figure, but everything is perfectly centered as well.</p>



<p>But wait, we removed <code>display: flex</code> and swapped in <code>display: grid</code>… so how is the percentage-based height of the float still working? I had said that using a flex container was the key for that, no?</p>



<p>Well, turns out CSS grid sports that feature too. From <a href="https://www.w3.org/TR/css-grid-1/#algo-overview" rel="noopener">the specification</a>:</p>



<blockquote><p>Once the size of each <a href="https://www.w3.org/TR/css-grid-1/#grid-area" rel="noopener">grid area</a> is thus established, the <a href="https://www.w3.org/TR/css-grid-1/#grid-item" rel="noopener">grid items</a> are laid out into their respective containing blocks. The grid area’s width and height are considered <a href="https://www.w3.org/TR/css-sizing-3/#definite" rel="noopener">definite</a> for this purpose.</p></blockquote>



<p>A grid item has a <code>stretch</code> alignment by default, so its height is definite, meaning using a percentage as a height inside it is perfectly valid. </p>



<p>Let’s say we instead want the second grid in the figure — we simply add an extra column with a width equal to half the width of the other columns:</p>



<pre rel="CSS" data-line=""><code markup="tt">.main {
  display: grid;
  grid-template-columns: repeat(auto-fit,calc(var(--s) + 2*var(--mh))) calc(var(--s)/2 + var(--mh));
  justify-content :center;
}</code></pre>







<p>Now, in addition to a fully responsive grid that is flexible enough to take custom shapes, everything is perfectly centred!</p>


<h3 id="h-fighting-the-overflow"><a href="#aa-fighting-the-overflow" aria-hidden="true" id="aa-fighting-the-overflow"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fighting the overflow</h3>


<p>The use of negative <code>margin-bottom</code> on the last items and the float element pushing our items will create some unwanted overflow that may affect the content placed after our grid.</p>







<p>If you resize the demo, you will notice an overflow equal to the negative offset and sometimes it’s bigger. The fix is to add some <code>padding-bottom</code> to our container. I will make the padding equal to the height of one shape:</p>







<p>I have to admit that there isn’t a perfect solution to fight that overflow and to control the space below our grid. That space depends on a lot of factors and we may have to use a different padding value for each case. The safest solution is to consider a big value that covers most of the cases.</p>


<h3 id="h-wait-one-more-a-pyramidal-grid"><a href="#aa-wait-one-more-a-pyramidal-grid" aria-hidden="true" id="aa-wait-one-more-a-pyramidal-grid"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wait, one more: a pyramidal grid</h3>


<p>Let’s take everything we’ve learned and build another amazing grid. This time, we’ll transform the grid we just made into a pyramidal one.</p>



<p>Consider that, unlike the grid we’ve made so far, the number of elements is important especially for the responsive part. It’s required to know the number of elements and more precesily the number of rows.</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="1024" height="229" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/different-pyramid.png?resize=1024%2C229&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/different-pyramid.png?resize=1024%2C229&amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/different-pyramid.png?resize=300%2C67&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/different-pyramid.png?resize=768%2C172&amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/different-pyramid.png?resize=1000%2C224&amp;ssl=1 1000w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/different-pyramid.png?w=1214&amp;ssl=1 1214w" sizes="auto, (min-width: 735px) 864px, 96vw"/><figcaption>Different pyramidal grid based on the number of items</figcaption></figure>



<p>It doesn’t mean we need a bunch of hardcoded values; rather we use an extra variable to adjust things based on the number of rows.</p>



<p>The logic is based on the number of rows because different numbers of elements may give us the same number of rows. For example, there are five rows when we have between 11 and 15 elements, even if the last row is not fully occupied. Having between 16 and 21 elements gives us six rows, and so on. The number of rows is our new variable.</p>



<p>Before digging into the geometry and the math here is a working demo:</p>







<p>Notice that most of the code is the same as what we’ve done in the previous examples. So let’s focus on the new properties that we’ve added:</p>



<pre rel="CSS" data-line="2"><code markup="tt">.main {
  --nr: 5;  /* number of rows */
}

.container {
  max-width: calc(var(--nr)*(var(--s) + 2*var(--mh)));
  margin: 0 auto;
}

.container::before ,
.container i {
  content: &#34;&#34;;
  width: calc(50% - var(--mh) - var(--s)/2);
  float: left;
  height: calc(var(--f)*(var(--nr) - 1)/2);
  shape-outside: linear-gradient(to bottom right, #000 50%, #0000 0);
}

.container i {
  float:right;
  shape-outside: linear-gradient(to bottom left, #000 50%, #0000 0);
}</code></pre>



<p><code>NR</code> is our variable for the number of rows. The width of the container needs to be equal to the last row of the pyramid to make sure it hold all the elements. If you check the previous figure, you’ll see that the number of the items contained in the last row is simply equal to the number of rows, which means the formula is: <code>NR* (S + 2*MH)</code>.</p>



<p>You may have also noticed that we also added an <code>&lt;i&gt;</code> element in there. We did that because we need two floating elements where we will apply <code>shape-outside</code>.</p>



<p>To understand why we need two floating elements let’s see what is done behind the scenes:</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="1042" height="618" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/behind-the-scenes.png?resize=1042%2C618&amp;ssl=1" alt="A pyramid grid of octagon shapes. The octagons alternate between green and red. There are 5 rows of octagons." srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/behind-the-scenes.png?w=1042&amp;ssl=1 1042w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/behind-the-scenes.png?resize=300%2C178&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/behind-the-scenes.png?resize=1024%2C607&amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/behind-the-scenes.png?resize=768%2C455&amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/behind-the-scenes.png?resize=1000%2C593&amp;ssl=1 1000w" sizes="auto, (min-width: 735px) 864px, 96vw"/><figcaption>Pyramidal grid</figcaption></figure>



<p>The blue elements are our floating elements. Each one is having a width equal to half the container size, minus half a shape size, plus margin. The height is equal to four rows in our case, and to <code>NR - 1</code> in a more generic case. Earlier, we defined the height of two rows, <code>F</code>, so the height of one row is <code>F/2</code>. That’s how we landed at <code>height: calc(var(--f)*(var(--nr) - 1)/2</code>.</p>



<p>Now that we have the size of our elements, we need to apply a gradient to our <code>shape-outside</code>.</p>



<p>The purple coloration in the figure above is the restricted area for our elements (it need to be an opaque color). The remaining area is the free space where the elements can flow (it need to be a transparent color). This can be done using a diagonal gradient:</p>



<pre rel="CSS" data-line=""><code markup="tt">shape-outside: linear-gradient(to bottom right, #000 50%, #0000 0); </code></pre>



<p>We simply change <code>right</code> with <code>left</code> for the other floated element. You have probably noticed that this is not responsive. In fact, go ahead and adjust the viewport width of the demo and see just how unresponsive this is.</p>



<p>We have a couple of options to get responsive:</p>



<ol><li>We can fall back to the first grid when the container width is smaller than the viewport width. It’s a bit tricky to code, but it allows us to preserve the same size for our elements.</li><li>We can reduce the size of our elements in order to keep the pyramidal grid. This is easier to code using the percentage-based value trick, but that could result in super tiny elements on smaller screen sizes.</li></ol>



<p>Let’s go with the first solution. We like a good challenge, right?</p>



<p>To get the pyramidal grid, we needed two floated element. The initial grid needed just one floated element. Luckily, our structure allows us to have <strong>three</strong> floated elements without needing to add more elements to the markup, thanks to pseudo-elements. We will use <code>container::before</code>, <code>i::before</code>, <code>i::after</code>:</p>



<pre rel="CSS" data-line=""><code markup="tt">/* Same as before... */

/* The initial grid */
.container::before {
  content: &#34;&#34;;
  width: calc(var(--s)/2 + var(--mh));
  float: left;
  height: 120%; 
  shape-outside: repeating-linear-gradient(#0000 0 calc(var(--f) - 3px),#000 0 var(--f));
}

/* The pyramidal grid */
.container i::before ,
.container i::after {
  content: &#34;&#34;;
  width: calc(50% - var(--mh) - var(--s)/2);
  float: left;
  height: calc(var(--f)*(var(--nr) - 1)/2);
  shape-outside: linear-gradient(to bottom right,#000 50%,#0000 0);
}

.container i::after {
  float:right;
  shape-outside: linear-gradient(to bottom left,#000 50%,#0000 0);
}</code></pre>



<p>Now we need a trick that lets us use either the first floated element or the other two, but not all of them at the same time. This condition should be based on the width of our container:</p>



<ul><li>If the container width is bigger than the width of the last row, we can have our pyramid and use the floated elements inside of <code>&lt;i&gt;</code>.</li><li>If the container width is smaller than the width of the last row, we switch to the other grid and use the first floated element.</li></ul>



<p>We can use <code>clamp()</code> for this! <a href="https://css-tricks.com/complete-guide-to-css-functions/#clamp">It’s sort of like a conditional function</a> that sets a minimum and maximum range and, within that range, we provide it an “ideal” value to use between those points. This way, we can “switch” between grids using our formulas as clamped values, and still avoid using media queries.</p>



<p>Our code will look like this:</p>



<pre rel="CSS" data-line=""><code markup="tt">.main {
  /* the other variables won&#39;t change*/
  --lw: calc(var(--nr)*(var(--s) + 2*var(--mh))); /* width of last row */
}

.container {
  max-width: var(--lw);
}

/* The initial grid */
.container::before {
  width: clamp(0px, (var(--lw) - 100%)*1000, calc(var(--s)/2 + var(--mh)));
}

/* The pyramidal grid */
.container i::before,
.container i::after {
  width: clamp(0px, (100% - var(--lw) + 1px)*1000, calc(50% - var(--mh) - var(--s)/2));
}</code></pre>



<p>On larger screens, the width of the container (<code>LW</code>) is now equal to its <code>max-width</code>, so <code>100% == LW</code>. That means that the width of <code>.container::before</code> is equal to <code>0px</code> (and results in this floated element becoming disabled).</p>



<p>For the other floating elements, we clamp the width:</p>



<pre rel="CSS" data-line=""><code markup="tt">width: clamp(0px, (100% - var(--lw) + 1px)*1000, calc(50% - var(--mh) - var(--s)/2));</code></pre>



<p>…where the middle value (<code>(100% - LW + 1px)*1000</code>) is equal to <code>(0 + 1px)*1000 = 1000px</code> (an intentionally large, but arbitrary value). It gets clamped to <code>calc(50% - var(--mh) - var(--s)/2)</code>. In other words, these floated elements are enabled with the correct width (the one we defined previously)</p>



<p><em>Voilà!</em> we have a pyramidal shape on large screen.</p>



<p>Now, when the container width get smaller, <code>LW</code> is going to be greater than <code>100%</code>. So, <code>(LW - 100%)</code> will be positive. Multiplied by a big value, it’s clamped to <code>calc(var(--s)/2 + var(--mh))</code>, which enables the first floated element. For the other float elements, <code>(100% - LW + 1px)</code> resolves to a negative value and is clamped to <code>0px</code>, which disables the float elements.</p>



<p>Resize the below demo and see how we switch between both grids</p>







<p>Let’s try adding more elements:</p>







<p>See that? Things are scaling perfectly. Let’s toss more elements at it just for kicks:</p>







<p>Still great. Notice that the last row isn’t even full. Just shows that this approach covers a bunch of cases. We can also combine this with the CSS grid alignment trick we used earlier:</p>







<p>Do you think “float” is such a bad thing now?</p>



<p>Want invert the pyramid?</p>



<figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="1180" height="296" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1620991346257_image.png?resize=1180%2C296&amp;ssl=1" alt="" srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1620991346257_image.png?w=1180&amp;ssl=1 1180w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1620991346257_image.png?resize=300%2C75&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1620991346257_image.png?resize=1024%2C257&amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1620991346257_image.png?resize=768%2C193&amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/05/s_07A03AC602CD604A1A84FE537FD07A78FDA8B04BD4AF14DED8BF2087D58EB481_1620991346257_image.png?resize=1000%2C251&amp;ssl=1 1000w" sizes="auto, (min-width: 735px) 864px, 96vw"/></figure>



<p>Like illustrated with the above figure, two changes to the previous code can invert our pyramid: </p>



<ul><li>I change the direction of the gradient from <code>to bottom left|right</code> to <code>to top left|right</code>, </li><li>I add a <code>margin-top</code> equal to the height of one row.</li></ul>







<p>And, hey, we can swap between both pyramid easily:</p>







<p>Isn’t this beautiful? We have a responsive pyramidal grid with custom shapes that we can easily invert and that fallback to another responsive grid on small screen while everything is perfectly centred. All this without a single media query or JavaScript, but instead using the often overlooked <code>float</code> property.</p>



<p>You will probably notice some missalignment in some particular cases. Yes, it’s again some rounding issue related to the calculation we are doing and the fact that we are trying to make this generic with the interactive demos. To rectify this, we simply adjust few values manually (epsecially the percentage of the gradient) until we get back a perfect alignment.</p>


<h3 id="h-that-s-a-float-wrap"><a href="#aa-thats-a-float-wrap" aria-hidden="true" id="aa-thats-a-float-wrap"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>That’s a <s>float</s> wrap!</h3>


<p>There we have it: combining <code>float</code> with <code>shape-outside</code> can help us make complex, flexible and responsive layouts — long live <code>float</code>!</p>



<p>The article ends here but this is only the beginning. I provided you with the layout and now you can easily put any content inside the divs, apply a background, shadows, animations, etc.</p>





          
        </div></div>
  </body>
</html>
