<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tweag.io/blog/2023-03-09-announcing-topiary/">Original</a>
    <h1>Topiary: A code formatting engine leveraging Tree-sitter</h1>
    
    <div id="readability-page-1" class="page"><div><div><p><a href="https://github.com/tweag/topiary">Topiary</a> aims to be a universal formatter engine within the
<a href="https://tree-sitter.github.io/tree-sitter">Tree-sitter</a> ecosystem. Named after the art of clipping or trimming
trees into fantastic shapes, it is designed for formatter authors and
formatter users:</p>
<ul>
<li>
<p>Authors can create a formatter for a language without having to write
their own formatting engine, or even their own parser.</p>
</li>
<li>
<p>Users benefit from uniform, comparable code style, across multiple
languages, with the convenience of a single formatter
tool.</p>
</li>
</ul>
<p>The core of Topiary is written in Rust, with declarative formatting
rules for bundled languages written in the <a href="https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries">Tree-sitter query
language</a>. In this first release, we have
concentrated on formatting OCaml code, capitalising on the OCaml
expertise within the Topiary Team and our colleague, Nicolas Jeannerod.</p>
<p>All development and releases happen over in the <a href="https://github.com/tweag/topiary">Topiary GitHub
repository</a>.</p>
<p><span>
      <a href="https://www.tweag.io/static/f7431681a62101b5e1a6408368317862/12c06/topiary-logo.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Topiary logo" title="Topiary logo" src="https://www.tweag.io/static/f7431681a62101b5e1a6408368317862/fcda8/topiary-logo.png" srcset="/static/f7431681a62101b5e1a6408368317862/12f09/topiary-logo.png 148w,
/static/f7431681a62101b5e1a6408368317862/e4a3f/topiary-logo.png 295w,
/static/f7431681a62101b5e1a6408368317862/fcda8/topiary-logo.png 590w,
/static/f7431681a62101b5e1a6408368317862/efc66/topiary-logo.png 885w,
/static/f7431681a62101b5e1a6408368317862/c83ae/topiary-logo.png 1180w,
/static/f7431681a62101b5e1a6408368317862/12c06/topiary-logo.png 2418w" sizes="(max-width: 590px) 100vw, 590px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<h2 id="motivation"><a href="#motivation" aria-label="motivation permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Motivation</h2>
<p>Coding style has historically been a matter of personal choice. This is
inherently subjective, leading to bikeshedding over formatting choices,
rather than meaningful discussion during review. Prescribed style
guides, linters and ultimately automatic formatters — popularised by
<a href="https://pkg.go.dev/cmd/gofmt"><code>gofmt</code></a>, whose developers had <a href="https://go.dev/talks/2015/gofmt-en.slide#1">the insight</a> to
impose “good enough” uniform formatting on a codebase — have helped
solve these issues.</p>
<p>This motivated research into developing a formatter for our <a href="https://nickel-lang.org">Nickel
language</a>. However, its internal parser did not provide a syntax
tree that retained enough context to allow the original program to be
reconstructed after parsing. After creating a <a href="https://github.com/nickel-lang/tree-sitter-nickel">Tree-sitter grammar for
Nickel</a>, for syntax highlighting,
we concluded that it would be possible to
leverage Tree-sitter for formatting as well.</p>
<p>But why stop at Nickel? Topiary generalises this approach for <em>any</em>
language that doesn’t employ semantic whitespace — for which,
specialised formatters, such as our Haskell formatter <a href="https://github.com/tweag/ormolu">Ormolu</a>, are
required — by expressing formatting style rules in the <a href="https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries">Tree-sitter
query language</a>. It thus aspires to be a “universal
formatter engine” for such languages; enabling the fast development of
formatters, provided a <a href="https://tree-sitter.github.io/tree-sitter/#available-parsers">Tree-sitter grammar</a> is
available.</p>
<h2 id="design-principles"><a href="#design-principles" aria-label="design principles permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Principles</h2>
<p>To that end, Topiary has been created with the following goals in mind:</p>
<ul>
<li>Use <a href="https://tree-sitter.github.io/tree-sitter">Tree-sitter</a> for parsing, to avoid writing yet another engine for
a formatter.</li>
<li>Expect idempotency. That is, formatting of already-formatted code
shouldn’t change anything.</li>
<li>For bundled formatting styles to meet the following constraints:
<ul>
<li>Compatible with attested formatting styles used for that language in
the wild.</li>
<li>Faithful to the author’s intent: if code has been written such that
it spans multiple lines, that decision is preserved.</li>
<li>Minimise changes between commits such that diffs focus mainly on the
code that’s changed, rather than superficial artefacts.</li>
<li>Be well-tested and robust, such that they can be trusted on large
projects.</li>
</ul>
</li>
<li>For end users, the formatter should run efficiently and integrate with
other developer tools, such as editors and language servers.</li>
</ul>
<h2 id="how-it-works"><a href="#how-it-works" aria-label="how it works permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How it Works</h2>
<p>As long as a <a href="https://tree-sitter.github.io/tree-sitter/#available-parsers">Tree-sitter grammar</a> is defined for a
language, Tree-sitter can parse it and build a concrete syntax tree.
Tree-sitter also allows us to run queries against this tree. We can make
use of these to target interesting subtrees (e.g., an <code>if</code> block or a
loop), to which we can apply formatting rules. These cohere into a
declarative definition of how that language should be formatted.</p>
<p>For example:</p>
<div data-language="scheme"><pre><code><span>(</span>
  <span>[</span>
    <span>(</span><span>infix_operator</span><span>)</span>
    <span>&#34;if&#34;</span>
    <span>&#34;:&#34;</span>
  <span>]</span> @append_space
  .
  <span>(</span><span>_</span><span>)</span>
<span>)</span></code></pre></div>
<p>This will match any node that the grammar has identified as an
<code>infix_operator</code>, or the anonymous nodes containing <code>if</code> or <code>:</code> tokens,
immediately followed by any named node (represented by the <code>(_)</code>
wildcard pattern). The query matches on subtrees of the same shape,
where the annotated node within it will be “captured” with the name
<code>@append_space</code>; one of <a href="https://github.com/tweag/topiary#supported-capture-instructions">many formatting rules</a> we
have defined. Our formatter runs through all matches and captures, and
when we process any capture called <code>@append_space</code>, we append a space
after the annotated node.</p>
<p>Before rendering the output, Topiary does some post-processing, such as
squashing consecutive spaces and newlines, trimming extraneous
whitespace, and ordering indentation and newline instructions
consistently. This means that you can, for example, prepend and append
spaces to <code>if</code> and <code>true</code>, and Topiary will still output <code>if true</code> with
just one space between the words.</p>
<p>To make this more concrete, consider the expression <code>1+2</code>. This has the
following syntax tree, if it’s interpreted as OCaml, where the match
described by the above query is highlighted in red:</p>
<p><img src="https://www.tweag.io/a6ec7baabfa5bd77e15069bcea71a7da/match.svg" alt="Syntax tree, with the match highlighted"/></p>
<p>The <code>@append_space</code> capture instructs Topiary to append a space after
the <code>infix_operator</code>, rendering <code>1+ 2</code>. Repeating this process for every
syntactic structure we care about — making judicious generalisations
wherever possible — leads us to an overall formatting style for a
language.</p>
<p>As a formatter author, defining a style for a language is just a matter
of building up these queries. End users can then apply them to their
codebase with Topiary, to render their code in this style.</p>

<p>Topiary is not the first tool to use Tree-sitter beyond its original
scope, nor is it the first tool that attempts to be a formatter for
multiple languages (e.g., <a href="https://prettier.io">Prettier</a>). This section contains some tools
that we drew inspiration from, or used during the development of
Topiary.</p>
<h3 id="tree-sitter-specific"><a href="#tree-sitter-specific" aria-label="tree sitter specific permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tree-sitter Specific</h3>
<ul>
<li><a href="https://tree-sitter.github.io/tree-sitter/playground">Syntax Tree Playground</a>: An interactive,
online playground for experimenting with Tree-sitter and its query
language.</li>
<li><a href="https://github.com/nvim-treesitter/playground">Neovim Treesitter Playground</a>: A Tree-sitter
playground plugin for Neovim.</li>
<li><a href="https://difftastic.wilfred.me.uk">Difftastic</a>: A tool that utilises Tree-sitter to perform syntactic
diffing.</li>
</ul>
<h3 id="meta-formatters"><a href="#meta-formatters" aria-label="meta formatters permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Meta-Formatters</h3>
<ul>
<li><a href="https://github.com/numtide/treefmt">treefmt</a>: A general formatter orchestrator, which unifies formatters
under a common interface.</li>
<li><a href="https://melpa.org/#/format-all">format-all</a>: A formatter orchestrator for Emacs.</li>
<li><a href="https://github.com/jose-elias-alvarez/null-ls.nvim">null-ls.nvim</a>: An LSP framework for Neovim that facilitates formatter
orchestration.</li>
</ul>
<h2 id="getting-started"><a href="#getting-started" aria-label="getting started permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Getting Started</h2>
<p>We’re really excited about Topiary and the potential it has in this
space.</p>
<p>This first release concentrates on formatting support for OCaml, as well
as simple languages, such as JSON and TOML. Experimental formatting
support is also available for <a href="https://nickel-lang.org">Nickel</a>, Bash, Rust, and Tree-sitter’s
own query language; these are under active development or serve a
pedagogical end for formatter authors.</p>
<p>We would highly encourage you to try Topiary and invite you to check out
the <a href="https://github.com/tweag/topiary">Topiary GitHub repository</a> to see for yourself.
Information on installing and using Topiary can be found in this
<a href="https://github.com/tweag/topiary">repository</a>, where we would also welcome contributions,
feature requests, and bug reports.</p>
<!-- Links --></div></div><div><p>About the authors</p><div><p><span>Erin van der Veen</span><span>Erin is a software engineer with experience in creating web-based functional
programs, maintaining a functional programming language and designing and
implementing tools enhancing developer productivity. His personal goal is to
get as many people as possible working with functional programming languages.
</span></p><p><span>Nicolas Bacquey</span><span>Nicolas is a Software Engineer who works on design, implementation and
maintenance of micro-services. Before joining Tweag, he worked in academia,
where he studied automata of many sorts (be they cellular, graph-, or tree-).
He has a PhD and a MSc in computer science, from Université de Caen Normandie
</span></p><p><span>Christopher Harrison</span><span>Chris is a recovering mathematician and software engineer at Tweag. He
has spent his career working for academia, from both the
business and the research sides of the industry. He particularly
enjoys writing well-tested, maintainable code that serves a pragmatic
end, with a side-helping of DevOps to keep services ticking with
minimal fuss.
</span></p><p><span>Tor Hovland</span><span>Tor is a Rust developer at Tweag who lives in Trondheim, Norway with his wife
and two sons.
</span></p></div></div></div>
  </body>
</html>
