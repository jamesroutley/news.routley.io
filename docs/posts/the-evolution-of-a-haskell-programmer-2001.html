<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pages.cpsc.ucalgary.ca/~robin/class/449/Evolution.htm">Original</a>
    <h1>The Evolution of a Haskell Programmer (2001)</h1>
    
    <div id="readability-page-1" class="page">


<p>Fritz Ruehr, Willamette University</p>



<!---------------------------------------->
<a name="freshman"></a>
Â 
<h3>Freshman Haskell programmer</h3>


<code><pre>fac n = if n == 0 
           then 1
           else n * fac (n-1)
</pre></code>

<!---------------------------------------->

<a name="sophomore"></a>
Â 
<h3>Sophomore Haskell programmer, at MIT</h3>

<p>
	(studied Scheme as a freshman)
</p>

<code><pre>fac = (\(n) -&gt;
        (if ((==) n 0)
            then 1
            else ((*) n (fac ((-) n 1)))))
</pre></code>

<!---------------------------------------->

<a name="junior"></a>
Â 
<h3>Junior Haskell programmer</h3>

<p>
	(beginning Peano player)
</p>

<code><pre>fac  0    =  1
fac (n+1) = (n+1) * fac n
</pre></code>

<!---------------------------------------->

<a name="junior-no-nk"></a>
Â 
<h3>Another junior Haskell programmer</h3>

<div><p>
	(read that n+k patterns are “a disgusting part of Haskell” <a href="https://willamette.edu/~fruehr/haskell/evolution.html#references">[1]</a></p></div>

<code><pre>fac 0 = 1
fac n = n * fac (n-1)
</pre></code>

<!---------------------------------------->

<a name="senior-right"></a>
Â 
<h3>Senior Haskell programmer</h3>

<div><p>
	(voted for Â  </p><strike>Nixon</strike> Â  
	<strike>Buchanan</strike><p> Â  Bush — “leans right”)
</p></div>

<code><pre>fac n = foldr (*) 1 [1..n]
</pre></code>

<!---------------------------------------->

<a name="senior-left"></a>
Â 
<h3>Another senior Haskell programmer</h3>

<div><p>
	(voted for Â  </p><strike>McGovern</strike> Â  
	<strike>Biafra</strike><p> Â  Nader — “leans left”)
</p></div>

<code><pre>fac n = foldl (*) 1 [1..n]
</pre></code>

<!---------------------------------------->

<a name="senior-left-right"></a>
Â 
<h3>Yet another senior Haskell programmer</h3>

<p>
	(leaned so far right he came back left again!)
</p>

<code><pre>-- using foldr to simulate foldl

fac n = foldr (\x g n -&gt; g (x*n)) id [1..n] 1
</pre></code>

<!---------------------------------------->

<a name="memoizing"></a>
Â 
<h3>Memoizing Haskell programmer</h3>

<p>
	(takes Ginkgo Biloba daily)
</p>

<code><pre>facs = scanl (*) 1 [1..]

fac n = facs !! n
</pre></code>

<!---------------------------------------->

<a name="pointsfree"></a>
Â 
<h3><strike>Pointless</strike> <i><small>(ahem)</small> 
“Points-free”</i> Haskell programmer</h3>

<p>
	(studied at Oxford)
</p>

<code><pre>fac = foldr (*) 1 . enumFromTo 1
</pre></code>

<!---------------------------------------->

<a name="iterative"></a>
Â 
<h3>Iterative Haskell programmer</h3>

<p>
	(former Pascal programmer)
</p>

<code><pre>fac n = result (for init next done)
        where init = (0,1)
              next   (i,m) = (i+1, m * (i+1))
              done   (i,_) = i==n
              result (_,m) = m

for i n d = until d n i
</pre></code>

<!---------------------------------------->

<a name="oneliner"></a>
Â 
<h3>Iterative one-liner Haskell programmer</h3>

<p>
	(former APL and C programmer)
</p>

<code><pre>fac n = snd (until ((&gt;n) . fst) (\(i,m) -&gt; (i+1, i*m)) (1,1))
</pre></code>

<!---------------------------------------->

<a name="accumulating"></a>
Â 
<h3>Accumulating Haskell programmer</h3>

<p>
	(building up to a quick climax)
</p>

<code><pre>facAcc a 0 = a
facAcc a n = facAcc (n*a) (n-1)

fac = facAcc 1
</pre></code>

<!---------------------------------------->

<a name="continuation"></a>
Â 
<h3>Continuation-passing Haskell programmer</h3>

<p>
	(raised RABBITS in early years, then moved to New Jersey)
</p>

<code><pre>facCps k 0 = k 1
facCps k n = facCps (k . (n *)) (n-1)

fac = facCps id
</pre></code>

<!---------------------------------------->

<a name="boyscout"></a>
Â 
<h3>Boy Scout Haskell programmer</h3>

<div><p>
	(likes tying knots; always “reverent,” he
	</p></div>

<code><pre>y f = f (y f)

fac = y (\f n -&gt; if (n==0) then 1 else n * f (n-1))
</pre></code>

<!---------------------------------------->

<a name="combinatory"></a>
Â 
<h3>Combinatory Haskell programmer</h3>

<div><p>
	(eschews variables, if not obfuscation;
	</p></div>

<code><pre>s f g x = f x (g x)

k x y   = x

b f g x = f (g x)

c f g x = f x g

y f     = f (y f)

cond p f g x = if p x then f x else g x

fac  = y (b (cond ((==) 0) (k 1)) (b (s (*)) (c b pred)))
</pre></code>

<!---------------------------------------->

<a name="listencoding"></a>
Â 
<h3>List-encoding Haskell programmer</h3>

<p>
	(prefers to count in unary)
</p>

<code><pre>arb = ()    -- &#34;undefined&#34; is also a good RHS, as is &#34;arb&#34; :)

listenc n = replicate n arb
listprj f = length . f . listenc

listprod xs ys = [ i (x,y) | x&lt;-xs, y&lt;-ys ]
                 where i _ = arb

facl []         = listenc  1
facl n@(_:pred) = listprod n (facl pred)

fac = listprj facl
</pre></code>

<!---------------------------------------->

<a name="interpretive"></a>
Â 
<h3>Interpretive Haskell programmer</h3>

<p>
	(never “met a language” he didn&#39;t like)
</p>

<code><pre>-- a dynamically-typed term language

data Term = Occ Var
          | Use Prim
          | Lit Integer
          | App Term Term
          | Abs Var  Term
          | Rec Var  Term

type Var  = String
type Prim = String


-- a domain of values, including functions

data Value = Num  Integer
           | Bool Bool
           | Fun (Value -&gt; Value)

instance Show Value where
  show (Num  n) = show n
  show (Bool b) = show b
  show (Fun  _) = &#34;<function>&#34;

prjFun (Fun f) = f
prjFun  _      = error &#34;bad function value&#34;

prjNum (Num n) = n
prjNum  _      = error &#34;bad numeric value&#34;

prjBool (Bool b) = b
prjBool  _       = error &#34;bad boolean value&#34;

binOp inj f = Fun (\i -&gt; (Fun (\j -&gt; inj (f (prjNum i) (prjNum j)))))


-- environments mapping variables to values

type Env = [(Var, Value)]

getval x env =  case lookup x env of
                  Just v  -&gt; v
                  Nothing -&gt; error (&#34;no value for &#34; ++ x)


-- an environment-based evaluation function

eval env (Occ x) = getval x env
eval env (Use c) = getval c prims
eval env (Lit k) = Num k
eval env (App m n) = prjFun (eval env m) (eval env n)
eval env (Abs x m) = Fun  (\v -&gt; eval ((x,v) : env) m)
eval env (Rec x m) = f where f = eval ((x,f) : env) m


-- a (fixed) &#34;environment&#34; of language primitives

times = binOp Num  (*)
minus = binOp Num  (-)
equal = binOp Bool (==)
cond  = Fun (\b -&gt; Fun (\x -&gt; Fun (\y -&gt; if (prjBool b) then x else y)))

prims = [ (&#34;*&#34;, times), (&#34;-&#34;, minus), (&#34;==&#34;, equal), (&#34;if&#34;, cond) ]


-- a term representing factorial and a &#34;wrapper&#34; for evaluation

facTerm = Rec &#34;f&#34; (Abs &#34;n&#34; 
              (App (App (App (Use &#34;if&#34;)
                   (App (App (Use &#34;==&#34;) (Occ &#34;n&#34;)) (Lit 0))) (Lit 1))
                   (App (App (Use &#34;*&#34;)  (Occ &#34;n&#34;))
                        (App (Occ &#34;f&#34;)  
                             (App (App (Use &#34;-&#34;) (Occ &#34;n&#34;)) (Lit 1))))))

fac n = prjNum (eval [] (App facTerm (Lit n)))
</function></pre></code>

<!---------------------------------------->

<a name="fundep"></a>
Â 
<h3>Static Haskell programmer</h3>

<div><p>
	(he does it with class, he’s got that fundep Jones!
	</p></div>

<code><pre>-- static Peano constructors and numerals

data Zero
data Succ n

type One   = Succ Zero
type Two   = Succ One
type Three = Succ Two
type Four  = Succ Three


-- dynamic representatives for static Peanos

zero  = undefined :: Zero
one   = undefined :: One
two   = undefined :: Two
three = undefined :: Three
four  = undefined :: Four


-- addition, a la Prolog

class Add a b c | a b -&gt; c where
  add :: a -&gt; b -&gt; c
  
instance              Add  Zero    b  b
instance Add a b c =&gt; Add (Succ a) b (Succ c)


-- multiplication, a la Prolog

class Mul a b c | a b -&gt; c where
  mul :: a -&gt; b -&gt; c

instance                           Mul  Zero    b Zero
instance (Mul a b c, Add b c d) =&gt; Mul (Succ a) b d


-- factorial, a la Prolog

class Fac a b | a -&gt; b where
  fac :: a -&gt; b

instance                                Fac  Zero    One
instance (Fac n k, Mul (Succ n) k m) =&gt; Fac (Succ n) m

-- try, for &#34;instance&#34; (sorry):
-- 
--     :t fac four
</pre></code>

<!---------------------------------------->

<a name="peano"></a>
Â 
<h3>Beginning graduate Haskell programmer</h3>

<div><p>
	(graduate education tends to liberate one from petty concerns
	</p></div>

<code><pre>-- the natural numbers, a la Peano

data Nat = Zero | Succ Nat


-- iteration and some applications

iter z s  Zero    = z
iter z s (Succ n) = s (iter z s n)

plus n = iter n     Succ
mult n = iter Zero (plus n)


-- primitive recursion

primrec z s  Zero    = z
primrec z s (Succ n) = s n (primrec z s n)


-- two versions of factorial

fac  = snd . iter (one, one) (\(a,b) -&gt; (Succ a, mult a b))
fac&#39; = primrec one (mult . Succ)


-- for convenience and testing (try e.g. &#34;fac five&#34;)

int = iter 0 (1+)

instance Show Nat where
  show = show . int

(zero : one : two : three : four : five : _) = iterate Succ Zero
</pre></code>

<!---------------------------------------->

<a name="origami"></a>
Â 
<h3>Origamist Haskell programmer</h3>

<p>
	(always starts out with the “basic Bird fold”)
</p>

<code><pre>-- (curried, list) fold and an application

fold c n []     = n
fold c n (x:xs) = c x (fold c n xs)

prod = fold (*) 1


-- (curried, boolean-based, list) unfold and an application

unfold p f g x = 
  if p x 
     then [] 
     else f x : unfold p f g (g x)

downfrom = unfold (==0) id pred


-- hylomorphisms, as-is or &#34;unfolded&#34; (ouch! sorry ...)

refold  c n p f g   = fold c n . unfold p f g

refold&#39; c n p f g x = 
  if p x 
     then n 
     else c (f x) (refold&#39; c n p f g (g x))
                         

-- several versions of factorial, all (extensionally) equivalent

fac   = prod . downfrom
fac&#39;  = refold  (*) 1 (==0) id pred
fac&#39;&#39; = refold&#39; (*) 1 (==0) id pred
</pre></code>

<!---------------------------------------->

<a name="cartesian"></a>
Â 
<h3>Cartesianally-inclined Haskell programmer</h3>

<div><p>
	(prefers Greek food, avoids the spicy Indian stuff;
	</p></div>

<code><pre>-- (product-based, list) catamorphisms and an application

cata (n,c) []     = n
cata (n,c) (x:xs) = c (x, cata (n,c) xs)

mult = uncurry (*)
prod = cata (1, mult)


-- (co-product-based, list) anamorphisms and an application

ana f = either (const []) (cons . pair (id, ana f)) . f

cons = uncurry (:)

downfrom = ana uncount

uncount 0 = Left  ()
uncount n = Right (n, n-1)


-- two variations on list hylomorphisms

hylo  f  g    = cata g . ana f

hylo&#39; f (n,c) = either (const n) (c . pair (id, hylo&#39; f (c,n))) . f

pair (f,g) (x,y) = (f x, g y)


-- several versions of factorial, all (extensionally) equivalent

fac   = prod . downfrom
fac&#39;  = hylo  uncount (1, mult)
fac&#39;&#39; = hylo&#39; uncount (1, mult)
</pre></code>

<!---------------------------------------->

<a name="categorical"></a>
Â 
<h3>Ph.D. Haskell programmer</h3>

<p>
	(ate so many bananas that his eyes bugged out, now he needs new lenses!)
</p>

<code><pre>-- explicit type recursion based on functors

newtype Mu f = Mu (f (Mu f))  deriving Show

in      x  = Mu x
out (Mu x) = x


-- cata- and ana-morphisms, now for *arbitrary* (regular) base functors

cata phi = phi . fmap (cata phi) . out
ana  psi = in  . fmap (ana  psi) . psi


-- base functor and data type for natural numbers,
-- using a curried elimination operator

data N b = Zero | Succ b  deriving Show

instance Functor N where
  fmap f = nelim Zero (Succ . f)

nelim z s  Zero    = z
nelim z s (Succ n) = s n

type Nat = Mu N


-- conversion to internal numbers, conveniences and applications

int = cata (nelim 0 (1+))

instance Show Nat where
  show = show . int

zero = in   Zero
suck = in . Succ       -- pardon my &#34;French&#34; (Prelude conflict)

plus n = cata (nelim n     suck   )
mult n = cata (nelim zero (plus n))


-- base functor and data type for lists

data L a b = Nil | Cons a b  deriving Show

instance Functor (L a) where
  fmap f = lelim Nil (\a b -&gt; Cons a (f b))

lelim n c  Nil       = n
lelim n c (Cons a b) = c a b

type List a = Mu (L a)


-- conversion to internal lists, conveniences and applications

list = cata (lelim [] (:))

instance Show a =&gt; Show (List a) where
  show = show . list

prod = cata (lelim (suck zero) mult)

upto = ana (nelim Nil (diag (Cons . suck)) . out)

diag f x = f x x

fac = prod . upto
</pre></code>

<!---------------------------------------->

<a name="comonadic"></a>
Â 
<h3>Post-doc Haskell programmer</h3>

<p>
	(from Uustalu, Vene and Pardo’s “Recursion Schemes from Comonads” <a href="https://willamette.edu/~fruehr/haskell/evolution.html#references">[4]</a>)
</p>

<code><pre>-- explicit type recursion with functors and catamorphisms

newtype Mu f = In (f (Mu f))

unIn (In x) = x

cata phi = phi . fmap (cata phi) . unIn


-- base functor and data type for natural numbers,
-- using locally-defined &#34;eliminators&#34;

data N c = Z | S c

instance Functor N where
  fmap g  Z    = Z
  fmap g (S x) = S (g x)

type Nat = Mu N

zero   = In  Z
suck n = In (S n)

add m = cata phi where
  phi  Z    = m
  phi (S f) = suck f

mult m = cata phi where
  phi  Z    = zero
  phi (S f) = add m f


-- explicit products and their functorial action

data Prod e c = Pair c e

outl (Pair x y) = x
outr (Pair x y) = y

fork f g x = Pair (f x) (g x)

instance Functor (Prod e) where
  fmap g = fork (g . outl) outr


-- comonads, the categorical &#34;opposite&#34; of monads

class Functor n =&gt; Comonad n where
  extr :: n a -&gt; a
  dupl :: n a -&gt; n (n a)

instance Comonad (Prod e) where
  extr = outl
  dupl = fork id outr


-- generalized catamorphisms, zygomorphisms and paramorphisms

gcata :: (Functor f, Comonad n) =&gt;
           (forall a. f (n a) -&gt; n (f a))
             -&gt; (f (n c) -&gt; c) -&gt; Mu f -&gt; c

gcata dist phi = extr . cata (fmap phi . dist . fmap dupl)

zygo chi = gcata (fork (fmap outl) (chi . fmap outr))

para :: Functor f =&gt; (f (Prod (Mu f) c) -&gt; c) -&gt; Mu f -&gt; c
para = zygo In


-- factorial, the *hard* way!

fac = para phi where
  phi  Z             = suck zero
  phi (S (Pair f n)) = mult f (suck n)
  

-- for convenience and testing

int = cata phi where
  phi  Z    = 0
  phi (S f) = 1 + f

instance Show (Mu N) where
  show = show . int
</pre></code>

<!---------------------------------------->

<a name="tenured"></a>
Â 
<h3>Tenured professor</h3>

<p>
	(teaching Haskell to freshmen)
</p>

<code><pre>fac n = product [1..n]
</pre></code>

<hr/>
<a name="backstory"></a>
Â 
<h2>Background</h2>

On 19 June 2001, at the 
<a href="http://www.cse.ogi.edu/~magnus/SeminarSeries/">
	OGI PacSoft Tuesday Morning Seminar Series
</a>,
<a href="http://www.cse.ogi.edu/~diatchki/">Iavor Diatchki</a>
presented the paper 
“Recursion Schemes from Comonads” by 
Uustalu, Vene and Pardo <a href="https://willamette.edu/~fruehr/haskell/evolution.html#references">[4]</a>. 
I attended Iavor’s excellent presentation 
and remarked that I found the end of the paper
rather anti-climactic: after much categorical effort and the definition
of several generalized recursion combinators, the main examples were
the factorial and Fibonacci functions. (Of course, I offered no better
examples myself, so this was rather unfair carping.)
<p>
Some time later, I came across Iavor’s &#34;jokes&#34; page, including a 
funny bit called
“<a href="http://www.cse.ogi.edu/~diatchki/jokes/programmer.html">The Evolution of a Programmer</a>” 
in which the traditional imperative &#34;Hello, world&#34; program is
developed through several variations,
from simple beginnings to a ridiculously complex extreme.
A moment’s thought turned up the factorial function as the best
functional counterpart of &#34;Hello, world&#34;. 
Suddenly the Muse struck and I knew I must write out these examples,
culminating (well, almost) in the heavily generalized categorical
version of factorial provided by Uustalu, Vene and Pardo.

</p><p>
I suppose this is what you’d have to call “small-audience” humour.

</p><p>
<b>PS:</b>
I’ve put all the code into a 
<a href="https://willamette.edu/~fruehr/haskell/evolution.hs">better-formatted text file</a>
for those who might like to experiment with the different variations 
(you could also just cut and paste a section from your browser).

</p><p>
<b>PPS:</b>
As noted above, Iavor is not the original author of
“The Evolution of a Programmer.”
A quick web search suggests that there are thousands of copies
floating around and it appears (unattributed) in humor newsgroups as
far back as 1995. But I suspect some version of it goes back much
further than that. Of course, if anyone does know who wrote the original, 
please let me know so that I may credit them here.
</p><hr/>
<a name="pedagogy"></a>
Â 
<h2>But seriously, folks, ...</h2>

On a more serious note, I think that the basic idea of the joke
(successive variations on a theme, building in complexity)
can serve a good pedagogical purpose as well as a humorous one.
To that end, and for those who may not be familiar
with all of the ideas represented above, I offer the following
comments on the variations:
<p>
The <a href="https://willamette.edu/~fruehr/haskell/evolution.html#freshman">first version</a>
(straight recursion with conditionals)
is probably familiar to programmers of all stripes;
fans of LISP and Scheme will find the 
<a href="https://willamette.edu/~fruehr/haskell/evolution.html#freshman">sophomore version</a> especially readable,
except for the funny spelling of 
“lambda” and the absence of “define”
(or “defun”).
The use of <a href="https://willamette.edu/~fruehr/haskell/evolution.html#junior">patterns</a> 
may seem only a slight shift in perspective, 
but in addition to mirroring mathematical notation,
patterns encourage the view of data types as 
initial algebras (or as inductively defined).
</p><p>
The use of more “structural” recursion combinators (such as 
<a href="https://willamette.edu/~fruehr/haskell/evolution.html#senior-right">foldr</a> and <a href="https://willamette.edu/~fruehr/haskell/evolution.html#senior-left">foldl</a>) is 
square in the spirit of functional programming: these higher-order functions
abstract away from the common details of different instances of
recursive definitions, recovering the specifics through function arguments. 
The “<a href="https://willamette.edu/~fruehr/haskell/evolution.html#points-free">points-free</a>” style 
(defining functions without explicit reference to their formal parameters)
can be compelling, but it can also be over-done;
here the intent is to foreshadow similar usage in some of the
later, more stridently algebraic variations.
</p><p>
The <a href="https://willamette.edu/~fruehr/haskell/evolution.html#accumulating">accumulating-parameter</a> version illustrates
a traditional technique for speeding up functional code. It is the
second fastest implementation here, at least as measured in terms of
number of reductions reported by Hugs,
with the <a href="https://willamette.edu/~fruehr/haskell/evolution.html#iterative">iterative</a> versions coming in third. 
Although the latter run somewhat against the spirit of functional 
programming, they do give the flavor of the functional simulation
of state as used in denotational semantics or, for that matter,
in monads. (Monads are woefully un-represented here; I would
be grateful if someone could contribute a few (progressive)
examples in the spirit of the development above.) The 
<a href="https://willamette.edu/~fruehr/haskell/evolution.html#continuation">continuation-passing</a> version 
recalls a denotational account of control 
(the references are to Steele’s RABBIT compiler for Scheme 
and the SML/NJ compiler).
</p><p>
The <a href="https://willamette.edu/~fruehr/haskell/evolution.html#boyscout">fixed-point version</a>
demonstrates that we can isolate recursion in a general Y combinator.
The <a href="https://willamette.edu/~fruehr/haskell/evolution.html#combinatory">combinatory</a> version provides an
extreme take on the points-free style inspired by Combinatory Logic,
isolating dependence on variable names to the definitions of a few combinators.
Of course we could go further, defining the Naturals and Booleans
in combinatory terms, but note that the predecessor function will be
a bit hard to accomodate (this is one good justification for algebraic
types). Also note that we cannot define the Y combinator in terms of the 
others without running into typing problems (due essentially to issues of
self-application). Interestingly, this is the fastest of all of the
implementations, perhaps reflecting the underlying graph reduction 
mechanisms used in the implementation.
</p><p>
The <a href="https://willamette.edu/~fruehr/haskell/evolution.html#listencoding">list-encoded</a> version exploits the simple
observation that we can count in unary by using lists of arbitrary
elements, so that the length of a list encodes a natural number.
In some sense this idea foreshadows later versions based on recursive
type definitions for Peano’s naturals, since lists of units are
isomorphic to naturals. The only interesting thing here is that
multiplication (numeric product) is seen to arise naturally out of 
combination (Cartesian product) by way of cardinality.
Typing issues make it hard to express this correspondence as directly 
as we’d like:
the following definition of listprod would break the definition
of the facl function due to an occurs-check/infinite type:
</p><blockquote>
<code>listprod xs ys = [ (x,y) | x&lt;-xs, y&lt;-ys ]</code>
</blockquote>
Of course we could also simplify as follows, but only at the expense
of obscuring the relationship between the two kinds of products:
<blockquote>
<code>listprod xs ys = [ arb | x&lt;-xs, y&lt;-ys ]</code>
</blockquote>
<p>
The <a href="https://willamette.edu/~fruehr/haskell/evolution.html#interpretive">interpretive</a> version implements a small 
object language rich enough to express factorial, and then implements
an interpreter for it based on a simple environment model. Exercises
along these lines run all through the latter half of the Friedman,
Wand and Haynes text (<a href="https://willamette.edu/~fruehr/haskell/evolution.html#references">[6]</a>), albeit expressed
there in Scheme. We used to get
flack from students at <a href="http://www.cs.oberlin.edu/">Oberlin</a> 
when we made them implement twelve interpreters in a single 
week-long lab, successively exposing more of the implementation by
moving the real work from the meta-language to the interpreter. This
implementation leaves a whole lot on the shoulders of the meta-language,
corresponding to about Tuesday or Wednesday in their week. Industrious 
readers are invited to implement a compiler for a Squiggol-like language
of polytypic folds and unfolds, targeting (and simulating) a suitable
categorical abstract machine (see <a href="https://willamette.edu/~fruehr/haskell/evolution.html#references">[9]</a>), 
and then to implement factorial in that setting 
(but don&#39;t blame me if it makes you late for lunch ...).
</p><p>
The <a href="https://willamette.edu/~fruehr/haskell/evolution.html#fundep">statically-computed</a> version uses 
type classes and <i>functional dependencies</i> to facilitate computation 
at compile time 
(the latter are recent extensions to the Haskell 98 standard by Mark Jones,
and are available in Hugs and GHC). 
The same kinds of techniques can also be used to encode behaviors more often
associated with dependent types and polytypic programming, and are thus a 
topic of much recent interest in the Haskell community. 
The code shown here is based on an account by
Thomas Hallgren (see <a href="https://willamette.edu/~fruehr/haskell/evolution.html#references">[7]</a>), extended to include
factorial. Prolog fans will find the definitions particularly easy to read, 
if a bit backwards.
</p><p>
The first of the “<a href="https://willamette.edu/~fruehr/haskell/evolution.html#peano">graduate</a>”
versions gets more serious about
recursion, defining natural numbers as a recursive
algebraic datatype and highlighting the difference between
iteration and primitive recursion.  
The “<a href="https://willamette.edu/~fruehr/haskell/evolution.html#origami">origamist</a>”
and “<a href="https://willamette.edu/~fruehr/haskell/evolution.html#cartesian">cartesian</a>”
variations take a small step backwards in this regard,
as they return to the use of internal integer and list types.
They serve, however, to introduce anamorphic and hylomorphic notions 
in a more familiar context.
</p><p>
The “<a href="https://willamette.edu/~fruehr/haskell/evolution.html#categorical">Ph.D</a>” example 
employs the categorical style
of BMF/Squiggol in a serious way (we could actually
go a bit further, by using co-products more directly, and thus
eliminate some of the overt dependence on the “internal 
sums” of the data type definition mechanism). 
</p><p>
By the time we arrive at the “pièce de résistance”,
the <a href="https://willamette.edu/~fruehr/haskell/evolution.html#comonadic">comonadic</a> version of Uustalu, Vene and Pardo, 
we have covered most of the underlying ideas and can (hopefully)
concentrate better on their specific contributions. 
The <a href="https://willamette.edu/~fruehr/haskell/evolution.html#tenured">final</a> version, 
using the Prelude-defined product function and ellipsis 
notation, is how I think the function is most clearly expressed,
presuming some knowledge of the language and Prelude definitions. 
(This definition also dates back at least to David Turner’s KRC* language <a href="https://willamette.edu/~fruehr/haskell/evolution.html#references">[5]</a>.)
</p><p>
It is comforting to know that the Prelude ultimately uses
a recursion combinator (foldl&#39;, the strict version of foldl)
to define product.
I guess we can all hope to see the day when the Prelude
will define gcatamorphic, zygomorphic and paramorphic combinators
for us, so that factorial can be defined both conveniently <em>and</em>
with greater dignity :) .

</p><hr/>

* <small><i>KRC may or may not be a trademark of Research Software, Ltd.,
</i>Miranda ™ <i>is!</i></small>

<hr/>
<a name="revisions"></a>
Â 
<h2>Revision history</h2>

<ul>
	<li><i>Sometime in the 2010’s</i>: 
	corrected the attribution for the <i>Church of the LFP</i>
	creed, which is due to Calvin Ostrum (and added a link
	to an illuminated version; see above). Also added a link to a
	Serbo-Croatian version of this page, although I was later told that this
	kindly-provided service is some sort of click-bait scheme.
	I don’t know what to make of all that: if the translation
	itself is somehow horribly wrong, I suppose I could cut the link
	back out. But perhaps the whole incident merely suggests
	that I am deteriorating into a clueless old fart who can‘t
	make sense of all these new-fangled Internet scams, which is
	probably becoming more true all the time. (Extra points to anyone
	who combines Dynamic Logic with Denotational Semantics and Fuzzy Logic
	to develop a system in which to explore the notion of propositions
	“becoming true” slowly, over time. I can also see potential
	applications to sorities paradoxes involving greying hair ... .)
	</li><li><i>20 August 01</i>: 
	added the <a href="https://willamette.edu/~fruehr/haskell/evolution.html#interpretive">interpretive</a> version,
	based on an environment model of a small object language 
	(no, not in <i>that </i> sense of object ...).
	I’m thinking about re-arranging the order of the
	examples, so that longer ones that are not part of
	the main line of development don&#39;t intrude so much.
	I also advertised the page on 
	<a href="http://haskell.org/mailman/listinfo/haskell-cafe">the Haskell Café</a>
	mailing list and requested that a link be added to the 
	<a href="http://www.haskell.org/humor">Haskell humor page.</a>
	Finally, I have an interesting new example in the works that
	may actually have some original research value; more on this soon.
	</li><li><i>14 August 01 (afternoon)</i>: 
	added the <a href="https://willamette.edu/~fruehr/haskell/evolution.html#combinatory">combinatory</a> version,
	now the fastest of the bunch, as measured in number of
	reductions reported by Hugs.
	</li><li><i>14 August 01 (morning)</i>: 
	adjusted the <a href="https://willamette.edu/~fruehr/haskell/evolution.html#sophomore">sophomore/Scheme</a> version 
	to use an explicit &#34;lambda&#34; (though we spell it differently
	in Haskell land) and added the <a href="https://willamette.edu/~fruehr/haskell/evolution.html#boyscout">fixed-point</a>
	version.
	</li><li><i>10 August 01</i>: 
	added the <a href="https://willamette.edu/~fruehr/haskell/evolution.html#listencoding">list-encoding</a> and 
	<a href="https://willamette.edu/~fruehr/haskell/evolution.html#fundep">static computation</a> versions
	(the latter uses type classes and functional dependencies to
	compute factorial during type-checking; it is an
	extended version of code from Thomas Hallgren’s “Fun with
	Functional Dependencies” <a href="https://willamette.edu/~fruehr/haskell/evolution.html#references">[7]</a>).
	</li><li><i>1 August 01</i>: 
	added <a href="https://willamette.edu/~fruehr/haskell/evolution.html#accumulating">accumulating-parameter</a> and 
	<a href="https://willamette.edu/~fruehr/haskell/evolution.html#continuation">continuation-passing</a> versions
	(the latter is a revised
	transliteration from Friedman, Wand and Haynes’ “Essentials
	of Programming Languages” <a href="https://willamette.edu/~fruehr/haskell/evolution.html#references">[5]</a>).
	</li><li><i>11 July 01</i>: 
	date of the original posting.
</li></ul>
<hr/>

<a name="references"></a>
Â 
<h2>References</h2>

<ol>

	<li><i>Highlights from nhc - a Space-efficient Haskell Compiler,</i> Niklas Röjemo.
		In the <b>FPCA ‘95 proceedings</b>. ACM Press, 1995 (see also
		<a href="http://citeseer.nj.nec.com/nbib/5076458">CiteSeer</a>
		or 
		<a href="ftp://ftp.cs.chalmers.se/pub/users/rojemo/fpca95.ps.gz">Chalmers ftp archive</a>)
		</li><li><i>n+k patterns,</i> Lennart Augustsson. Message to the haskell mailing list,
		Mon, 17 May 93 (see
		<a href="http://www.mail-archive.com/haskell@haskell.org/msg01261.html">
		the mailing list archive</a>)
		</li><li><i>Sorting Morphisms,</i>Lex Augusteijn. In <b>Advanced Functional Programming</b>, 
		(LNCS 1608). Springer-Verlag, 1999 (see also 
		<a href="http://citeseer.nj.nec.com/augusteijn99sorting.html">CiteSeer</a>).
		</li><li><i>Recursion Schemes from Comonads,</i> T. Uustalu, V. Vene and A. Pardo. 
		<b>Nordic Journal of Computing</b>, to appear (see also
		<a href="http://www.cs.ioc.ee/~tarmo/papers/">
		Tarmo Uustalu’s papers page</a>).
		</li><li><i>Recursion Equations as a Programming Language,</i> D. A. Turner. 
		In <b>Functional Programming and its Applications</b>. Cambridge University Press, 1982.
		</li><li><i>Essentials of Programming Languages,</i> D. Friedman, M. Wand and C. Haynes. 
		MIT PRess and McGraw-Hill, 1994.
		</li><li><i>Fun with Functional Dependencies,</i> Thomas Hallgren. 
		<b>Joint Winter Meeting of the Departments of Science and Computer Engineering</b>,
		Chalmers University of Technology and Göteborg University, Varberg, Sweden, 2001 
		(available at
		<a href="http://www.cs.chalmers.se/~hallgren/Papers/wm01.html">
		the author’s web archive</a>).
		</li><li><i>The Church of the Least Fixed-Point,</i> <s>authour unknown</s> by Calvin Ostrum, Feburary 1983. 
		A bit of lambda calculus humor which circulated in the
		mid-1980’s (at least that’s when I saw it), probably from the 
		comp.lang.functional newsgroup or somesuch. 
		(Thanks to Ron, and perhaps another few kind souls, for bringing the
		correct attribution to my attention. I apparently created the 
		following 	
		<a href="http://www.willamette.edu/~fruehr/haskell/ChurchLFP.jpg">
		“illuminated manuscript” version of the 
		<i>Church of the LFP</i> creed
		</a> somewhere along the way.)
<!--
		Please <a href="mailto://fruehr@willamette.edu">write me</a> 
		if you know the author or any other citation information).
-->
		</li><li><i>Categorical Combinators, Sequential Algorithms and Functional Programming,</i>
		Pierre-Louis Curien. Springer Verlag (2nd edition), 1993.
		</li></ol>

<hr/>



</div>
  </body>
</html>
