<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.willmunn.xyz/devops/helm/kubernetes/2026/01/17/building-robust-helm-charts.html">Original</a>
    <h1>Building Robust Helm Charts</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    

<p>In my current work, there is often the need to deploy a similar application
stack in various configurations, to several environments. Each configuration may
vary in terms of scale, uptime requirements and feature flagging. Due to a lot
of flux in infrastructure set up, each environment is also not equivalent. On
top of this, there are obviously financial requirements to run all of this as
cheaply as possible. Kubernetes and helm templating are valuable tools in this
situation, they allow us to create a configuration blueprint with the details
abstracted in <code>values.yaml</code> files.</p>

<h2 id="use-helms-built-in-linter">Use helm’s built in linter</h2>

<p>Let’s start with the basics, helm provides a <code>helm lint</code> command which performs
checks</p>

<ul>
  <li>YAML syntax</li>
  <li>Template rendering</li>
  <li>Missing or misnamed required files</li>
  <li>Best practice violations</li>
</ul>

<p>You can run this with your different values.yaml files to ensure that all your
configurations are compliant.</p>

<p>It’s also a good idea to use the <code>helm template</code> command to actually check that
helm is able to render your templates.</p>

<h2 id="parallels-with-front-end-templating">Parallels with front end templating</h2>

<p>I like to compare helm templating with html templating tools like JSX. This
allows front end developers to create reusable components usable throughout
pages of a web application, A button component for example can have many states,
primary, secondary, loading, disabled, light or dark mode.
<img src="https://www.willmunn.xyz/assets/images/button-states.png" alt="Button States"/></p>

<p>Each state may also look different depending on the size/type of device your are
browsing the site with. Each of these states represents differences in many
parameters (font size, colour, gradient, opacity, border, padding, margin,
width, height, etc). These complexities are abstracted away giving the consuming
code the list of states to chose from, so that they can write code like this.</p>

<div><div><pre><code><span>&lt;</span><span>button</span> <span>type</span><span>=</span><span>&#34;primary&#34;</span><span>&gt;</span>Click Me!<span>&lt;/</span><span>button</span><span>&gt;</span>
</code></pre></div></div>

<p>Under the hood of course many aspects of the CSS or HTML code will be impacted
by the change of state so you often end up with different parts of the markup
having conditionals on the same check.</p>

<div><div><pre><code><span>const</span> <span>Button</span> <span>=</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>return</span> <span>(</span>
        <span>&lt;</span><span>button</span> <span>className</span><span>=</span><span>&#34;btn btn-primary {classesForState(props.state)}&#34;</span><span>&gt;</span>
            <span>{</span><span>props</span><span>.</span><span>state</span> <span>==</span> <span>&#34;</span><span>loading</span><span>&#34;</span> <span>&amp;&amp;</span> <span>&lt;</span><span>span</span><span>&gt;&lt;</span><span>svg</span> <span>src</span><span>=</span><span>&#34;loading.svg&#34;</span> <span>/&gt;&lt;/</span><span>span</span><span>&gt;</span><span>}</span>
            <span>{</span><span>props</span><span>.</span><span>children</span><span>}</span>
            <span>&lt;</span><span>span</span><span>&gt;</span>
        <span>&lt;/</span><span>button</span><span>&gt;</span>
    );
}
</code></pre></div></div>

<p>Just in this contrived example you already have 2 different things being
controlled by the state property with 2 separate checks, the CSS classes and the
presence of the loading icon.</p>

<p>This is quite similar to the situation you end up templating in YAML with helm.
Consider an application that has optional persistent storage. You could quite
easily imagine a boolean property in your <code>values.yaml</code> file called
<code>persistent</code>. Under the hood this has many implications likely affecting
different files.</p>

<ul>
  <li>Conditional creation of a PersistentVolume resource</li>
  <li>Conditional creation of a PersistentVolumeClaim resource</li>
  <li>Conditional storage requests/limits in your Pod</li>
  <li>Adding a <code>volumes</code> block to your Pod</li>
  <li>Adding a <code>volumesMount</code> block to your Pod</li>
</ul>

<p>That’s 5 separate <code>if</code> blocks that need to be in your templates.</p>

<p>Forgetting one of these blocks could cause your application to function
incorrectly and in this case, even cause unexpected data loss. Rather than find
these problems out post deployment we can use the output of helm template with
specific values to ensure that the right manifests are generated before going
anywhere near a kubernetes cluster.</p>

<h2 id="helm-unit-test">Helm unit test</h2>

<p>After talking about this problem with a colleague, they told me that his team
use <a href="https://github.com/helm-unittest/helm-unittest">helm unit test</a> for this.
This is a simple helm plugin that allows us to assert on the output of helm
templates using yaml tests.</p>

<p>A test for the case described above could look like this. Assuming you have your
chart templates arranged as one file per resource:</p>

<div><div><pre><code>test-chart
├── Chart.yaml
├── templates
│   ├── _helpers.tpl
│   ├── persistent-volume-claim.yaml
│   └── pod.yaml
└── values.yaml
</code></pre></div></div>

<p>You could add a test for the persistent volume and a similar one for the
persistent volume claim</p>

<div><div><pre><code><span>suite</span><span>:</span> <span>persistent volume suite</span>
<span>templates</span><span>:</span>
  <span>-</span> <span>persistent-volume.yaml</span>
<span>tests</span><span>:</span>
  <span>-</span> <span>it</span><span>:</span> <span>doesn&#39;t include when persistence is disabled</span>
    <span>set</span><span>:</span>
      <span>persistent</span><span>:</span> <span>false</span>
    <span>asserts</span><span>:</span>
      <span>-</span> <span>hasDocuments</span><span>:</span>
          <span>count</span><span>:</span> <span>0</span>
  <span>-</span> <span>it</span><span>:</span> <span>includes when persistence is enabled</span>
    <span>set</span><span>:</span>
      <span>persistent</span><span>:</span> <span>true</span>
    <span>asserts</span><span>:</span>
      <span>-</span> <span>containsDocument</span><span>:</span>
          <span>kind</span><span>:</span> <span>PersistentVolume</span>
          <span>apiVersion</span><span>:</span> <span>v1</span>
</code></pre></div></div>

<p>Then you could add another test for the pod</p>

<div><div><pre><code><span>suite</span><span>:</span> <span>pod suite</span>
<span>templates</span><span>:</span>
  <span>-</span> <span>pod.yaml</span>
<span>tests</span><span>:</span>
  <span>-</span> <span>it</span><span>:</span>
      <span>Sets storages limits and no volumes are added when persistence is disabled</span>
    <span>set</span><span>:</span>
      <span>persistent</span><span>:</span> <span>false</span>
    <span>asserts</span><span>:</span>
      <span>-</span> <span>notExists</span><span>:</span>
          <span>path</span><span>:</span> <span>spec.volumes</span>
      <span>-</span> <span>notExists</span><span>:</span>
          <span>path</span><span>:</span> <span>spec.containers[0].volumeMounts</span>
      <span>-</span> <span>equal</span><span>:</span>
          <span>path</span><span>:</span> <span>spec.containers[0].resources.requests.ephemeral-storage</span>
          <span>value</span><span>:</span> <span>500Mi</span>
      <span>-</span> <span>equal</span><span>:</span>
          <span>path</span><span>:</span> <span>spec.containers[0].resources.limits.ephemeral-storage</span>
          <span>value</span><span>:</span> <span>1Gi</span>
  <span>-</span> <span>it</span><span>:</span> <span>Volume is added when persistence is enabled</span>
    <span>set</span><span>:</span>
      <span>persistent</span><span>:</span> <span>true</span>
    <span>asserts</span><span>:</span>
      <span>-</span> <span>lengthEqual</span><span>:</span>
          <span>paths</span><span>:</span>
            <span>-</span> <span>spec.volumes</span>
            <span>-</span> <span>spec.containers[0].volumeMounts</span>
          <span>count</span><span>:</span> <span>1</span>
      <span>-</span> <span>exists</span><span>:</span>
          <span>path</span><span>:</span> <span>spec.volumes</span>
      <span>-</span> <span>exists</span><span>:</span>
          <span>path</span><span>:</span> <span>spec.containers[0].volumeMounts</span>
      <span>-</span> <span>notExists</span><span>:</span>
          <span>path</span><span>:</span> <span>spec.containers[0].resources.requests.ephemeral-storage</span>
      <span>-</span> <span>notExists</span><span>:</span>
          <span>path</span><span>:</span> <span>spec.containers[0].resources.limits.ephemeral-storage</span>
</code></pre></div></div>

<p>Your chart directory should now look like this</p>

<div><div><pre><code>test-chart
├── Chart.yaml
├── templates
│   ├── _helpers.tpl
│   ├── persistent-volume-claim.yaml
│   └── pod.yaml
├── tests
│   ├── persistent_volume_claim_test.yaml
│   ├── persistent_volume_test.yaml
│   └── pod_test.yaml
└── values.yaml
</code></pre></div></div>

<p>You can run these tests with a single docker command which should be simple to
integrate into your CI configuration</p>

<div><div><pre><code>docker run <span>-t</span> <span>--rm</span> <span>-v</span> <span>$(</span><span>pwd</span><span>)</span>:/apps helmunittest/helm-unittest:3.19.0-1.0.3 test-chart
</code></pre></div></div>

<p>Now you have confidence that the templated output for persistent and non
persistent configurations is as you expect. If someone removes one of your
template conditionals, they will be warned by failing tests.</p>

<h2 id="native-helm-test">Native helm test</h2>

<p>Unit tests are all well and good, but they don’t really confirm that your chart
works correctly or even that your templated output contains valid kubernetes
manifests. This is where helm’s native test feature comes in. It allows you to
run checks on your chart after it’s been deployed to a cluster. If your chart is
for a custom built application, this could be your integration test suite, but
if it’s a deployment of some vendor application with custom configuration, this
is also a great way to check that your configuration works as expected. I find
this especially useful for things like proxy servers.</p>

<p>As a simple example, let’s say you’re deploying a proxy to handle TLS
redirection, in nginx, that would be something like</p>

<div><div><pre><code>server {
    listen 80 default_server;
    server_name _;
    return 301 https://$host$request_uri;
}
</code></pre></div></div>

<p>You could use something like <a href="https://hurl.dev/">hurl</a> to check that http
requests are indeed redirecting to their https alternatives. You can put a hurl
script in a config map.</p>

<div><div><pre><code><span># templates/tests/proxy-tests-config-map.yaml</span>
<span>apiVersion</span><span>:</span> <span>v1</span>
<span>kind</span><span>:</span> <span>ConfigMap</span>
<span>metadata</span><span>:</span>
  <span>name</span><span>:</span> <span>&#34;</span><span>proxy-test-requests&#34;</span>
  <span>annotations</span><span>:</span>
    <span>&#34;</span><span>helm.sh/hook&#34;</span><span>:</span> <span>&#34;</span><span>pre-install,pre-upgrade&#34;</span>
    <span>&#34;</span><span>helm.sh/hook-weight&#34;</span><span>:</span> <span>&#34;</span><span>0&#34;</span>
    <span>&#34;</span><span>helm.sh/hook-delete-policy&#34;</span><span>:</span> <span>before-hook-creation</span>
<span>data</span><span>:</span>
  <span>tests.hurl</span><span>:</span> <span>|</span>
    <span># Test https redirection</span>
    <span>GET http://my-proxy.my-namespace.svc/path</span>
    <span>HTTP 301</span>
    <span>[Asserts]</span>
    <span>header &#34;Location&#34; == &#34;https://my-proxy.my-namespace.svc/path&#34;</span>
</code></pre></div></div>

<p>And then add a pod to run it</p>

<div><div><pre><code><span># templates/tests/proxy-tests-pod.yaml</span>
<span>apiVersion</span><span>:</span> <span>v1</span>
<span>kind</span><span>:</span> <span>Pod</span>
<span>metadata</span><span>:</span>
  <span>name</span><span>:</span> <span>proxy-tests</span>
  <span>annotations</span><span>:</span>
    <span>&#34;</span><span>helm.sh/hook&#34;</span><span>:</span> <span>&#34;</span><span>test&#34;</span>
    <span>&#34;</span><span>helm.sh/hook-weight&#34;</span><span>:</span> <span>&#34;</span><span>1&#34;</span>
    <span>&#34;</span><span>helm.sh/hook-delete-policy&#34;</span><span>:</span> <span>&#34;</span><span>before-hook-creation&#34;</span>
<span>spec</span><span>:</span>
  <span>containers</span><span>:</span>
    <span>-</span> <span>name</span><span>:</span> <span>hurl</span>
      <span>image</span><span>:</span> <span>ghcr.io/orange-opensource/hurl:7.1.0</span>
      <span>command</span><span>:</span> <span>[</span><span>&#34;</span><span>hurl&#34;</span><span>]</span>
      <span>args</span><span>:</span> <span>[</span><span>&#34;</span><span>--test&#34;</span><span>,</span> <span>&#34;</span><span>/tests/tests.hurl&#34;</span><span>,</span> <span>&#34;</span><span>--verbose&#34;</span><span>]</span>
      <span>volumeMounts</span><span>:</span>
        <span>-</span> <span>name</span><span>:</span> <span>&#34;</span><span>proxy-test-requests&#34;</span>
          <span>readOnly</span><span>:</span> <span>true</span>
          <span>mountPath</span><span>:</span> <span>/tests</span>
  <span>volumes</span><span>:</span>
    <span>-</span> <span>name</span><span>:</span> <span>&#34;</span><span>proxy-test-requests&#34;</span>
      <span>configMap</span><span>:</span>
        <span>name</span><span>:</span> <span>&#34;</span><span>proxy-test-requests&#34;</span>
  <span>restartPolicy</span><span>:</span> <span>Never</span>
</code></pre></div></div>

<p>You can also use this to perform other checks, the advantage is that you can run
these checks in the same kubernetes namespace that you deployed to giving you
real world network conditions for example.</p>

<p>You can run these right after your deploying your chart in your CI system.</p>

<div><div><pre><code>  helm <span>test </span>hs-solr-migration-proxy <span>\</span>
    <span>--logs</span>
</code></pre></div></div>

<p>The <code>--logs</code> argument will output the test pod’s logs in the output of
<code>helm test</code> so you can examine failures easily and without necessarily accessing
the cluster yourself.</p>

<h2 id="generating-documentation">Generating documentation</h2>

<p>It’s also important to have human friendly documentation for your charts so that
consumers understand the various options available set in their values.yaml
files, what the defaults are and what each option does. The
<a href="https://github.com/norwoodj/helm-docs">helm-docs</a> tool, parses your chart
values and metadata to generate documentation in a README.md file. Without any
additional effort it will create a table of all the options and their default
values. You can add a description column by adding a comment above the parameter
in your values.yaml file.</p>

<div><div><pre><code><span># -- Saves application data to a persistent volume surviving application restarts</span>
<span>persistent</span><span>:</span> <span>true</span>
</code></pre></div></div>

<p>helm-docs also supply a <a href="https://pre-commit.com/">pre-commit</a> configuration
which you can use to automatically regenerate the documentation when the chart
changes which helps keep it in sync.</p>

<h2 id="full-pipeline">Full pipeline</h2>

<p>To summarise, if we combine all the things we’ve discussed in this post, your
workflow for creating a robust helm chart might look like this.</p>

<ol>
  <li>Make chart changes annotating your values file with comments to be consumed
by helm-docs</li>
  <li>Check your chart validates with <code>helm lint</code> and <code>helm tempate</code></li>
  <li>Add unit tests using
<a href="https://github.com/helm-unittest/helm-unittest">helm unit test</a></li>
  <li>Add integration tests using
<a href="https://helm.sh/docs/topics/chart_tests/">helm’s native tests</a></li>
  <li>Generate documentation using
<a href="https://github.com/norwoodj/helm-docs">helm-docs</a></li>
  <li>Run linting, unit tests in CI before publishing</li>
  <li>Run integration tests immediately after your deployment.</li>
</ol>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
