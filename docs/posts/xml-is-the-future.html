<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bitecode.dev/p/hype-cycles">Original</a>
    <h1>XML is the future</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><p><em><span>My first hype exposure was &#34;use the </span><a href="https://en.wikipedia.org/wiki/XML" rel="">Extensible Markup Language</a><span> for everything&#34;. Learning from it allowed me to live through the front end stack explosion, the micro-service overdose and many, many more silly trends.</span></em></p><p><em>It turns out Grandma was right. Eat vegetables, exercise, sleep well.</em></p><p><em>And use the right tool for the right job.</em></p><p><em>Well, she didn&#39;t say that last one.</em></p><p><em>But she could have.</em></p><p><span>When I started programming, XML was going to replace everything. HTML with </span><a href="https://en.wikipedia.org/wiki/XHTML" rel="">XHTML</a><span>, validation with </span><a href="https://en.wikipedia.org/wiki/Document_type_definition" rel="">DTD</a><span>, transformation and presentation with </span><a href="https://en.wikipedia.org/wiki/XSLT" rel="">XSLT</a><span>, communication with </span><a href="https://en.wikipedia.org/wiki/SOAP" rel="">SOAP</a><span>.</span></p><p>I missed the train on the OOP hype, that was the generation before me, but I read so many articles warning me about it, that I applied the reasoning to XML: let&#39;s wait and see if this is actually as good as they say before investing everything in it.</p><p>Turns out, XML was not the future. It was mostly technical debt.</p><p>It was mostly useful for things like documents, and I believe the most successful use of it are still MS Office and LibreOffice file formats. They are just zips of XML.</p><p>I was lucky to learn this lesson very early in my career: there is no silver bullet, any single tool, no matter how good it is, must be evaluated from the engineering point of view of pros and cons. Everything has a cost, and implies compromises. It&#39;s a matter of ROI. Which is hard to evaluate without experience.</p><p>Bottom line, time is once again the great equalizer, there is no substitute to observe how a complex system evolves, no matter your model of the world.</p><p><span>But above all, I learned that </span><strong>geeks think they are rational beings, while they are completely influenced by buzz, marketing, and their emotions</strong><span>. Even more so than the average person, because they believe they are less susceptible to it than normies, so they have a blind spot.</span></p><p>XML was just the beginning of many, many waves of hype.</p><p><span>When MongoDB came around (</span><a href="https://youtu.be/b2F-DItXtZs" rel="">it&#39;s web scale!</a><span>), suddenly you had to use </span><a href="https://en.wikipedia.org/wiki/NoSQL" rel="">NoSQL</a><span> for everything. Didn&#39;t matter that there was absolutely no relation between 2 NoSQL systems. It&#39;s like labeling a country as &#34;doesn&#39;t speak English&#34;. Didn&#39;t matter </span><a href="https://en.wikipedia.org/wiki/MongoDB" rel="">MongoDB</a><span> was a terrible product at the time that was destroying your data (they did fix that, it&#39;s now a good DB to have in your toolbox). Didn&#39;t matter that most people using it didn&#39;t need free replication because their data could fit in a </span><a href="https://docs.python.org/3/library/sqlite3.html" rel="">SQlite</a><span> file.</span></p><p>So we watched beginners put their data with no schema, no consistency, and broken validation in a big bag of blobs. The projects fail in mass.</p><p><span>Then the </span><a href="https://nodejs.org/en" rel="">node</a><span> era arrived. </span><a href="https://en.wikipedia.org/wiki/Isomorphic_JavaScript" rel="">Isomorphic JavaScript</a><span> was all the rage, you </span><em>had</em><span> to use the same language in the frontend and the backend, and make everything </span><a href="https://docs.python.org/3/library/asyncio.html" rel="">async</a><span>. But JS sucked, so most JS projects were created... to avoid writing </span><a href="https://en.wikipedia.org/wiki/ECMAScript#5th_Edition" rel="">ES5</a><span>. I mean, no import, no namespace, terrible scoping, </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="">schizophreniac </a><code>this</code><span>, </span><a href="https://en.wikipedia.org/wiki/Prototype-based_programming" rel="">prototype based inheritance</a><span>, weak types, come on! So we got </span><a href="https://coffeescript.org/" rel="">coffeescript</a><span>, then </span><a href="https://babeljs.io/" rel="">babel</a><span>, </span><a href="https://webpack.js.org/" rel="">webpack</a><span>, </span><a href="https://www.typescriptlang.org/" rel="">typescript</a><span>, </span><a href="https://legacy.reactjs.org/docs/jsx-in-depth.html" rel="">react + JSX,</a><span> etc.</span></p><p><span>We were told to stay on top of the most modern ecosystem, and by that I mean dealing with compatibility being broken every two months. That’s the price of cutting edge tree-shaking transpilation. That, and a </span><a href="https://www.theregister.com/2016/03/23/npm_left_pad_chaos/" rel="">left-pad</a><span> way of life you couldn’t debug because the map files were generated wrong.</span></p><p><span>At this point, everything needed to be a </span><a href="https://en.wikipedia.org/wiki/Single-page_application" rel="">Single Page Application</a><span> with client-side routing, </span><a href="https://immutable-js.com/" rel="">immutable data structures</a><span> and some kind of store. That is, if you could chose between flux, redux, alt, reflux, flummox, fluxible, fluxxor, marty.js, fynx, MacFly, DeLorean.js, fluxify, fluxury, exim, fluxtore, Redx, fluxx… No, </span><a href="https://github.com/kriasoft/react-starter-kit/issues/22" rel="">I’m not making that up.</a></p><p><span>But because you still had to pass a lot of data through the wire, and since everything had to be on the client, </span><a href="https://graphql.org/" rel="">GraphQL</a><span> was born. Of course, all that stuff had terrible accessibility, </span><a href="https://en.wikipedia.org/wiki/Search_engine_optimization" rel="">SEO</a><span> and first-rendering time issues, leading to the rise of </span><a href="https://vuejs.org/guide/scaling-up/ssr.html" rel="">Server-Side Rendering</a><span>, aka CGI with extra steps. This couldn’t stop there, so the community added hydration on top. </span></p><p>This turned out to be an immense addition in complexity, and created tons and tons of disposable code base, leading to, you get it, failed projects and waste of money.</p><p><span>Because, of course, most of those tasks could have been done with </span><a href="https://rubyonrails.org/" rel="">Ruby-On-Rail</a><span>, </span><a href="https://symfony.com/" rel="">Symfony</a><span> or </span><a href="https://www.djangoproject.com/" rel="">Django</a><span> and a pinch of </span><a href="https://jquery.com/" rel="">jQuery</a><span>. At least, they would have been finished with those boring techs. Instead, dead projects began to accumulate, and for one Figma shinning, you had a trail of hidden bodies behind corporate walls nobody dared to talk about. </span></p><p>It was taboo to speak about this madness. You were the one not getting it.</p><p><span>You would think people drowning while trying to produce a basic </span><a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="">CRUD</a><span> app would have been a red flag.</span></p><p>Instead, it inspired teams everywhere in the world to make things harder on themselves.</p><p><span>First, the &#34;everything should be a </span><a href="https://en.wikipedia.org/wiki/Microservices" rel="">micro-service</a><span>&#34; crowd started to take over. Every single small website had a </span><a href="https://www.docker.com/resources/what-container/" rel="">docker</a><span> container for the restish API, plus one for the front end, and one for the database. Indirection layers on top of indirection layers. To communicate between all that, why not a little message queue? </span><a href="https://zeromq.org/" rel="">ZeroMQ</a><span>, </span><a href="https://www.rabbitmq.com/" rel="">RabbitMQ</a><span>... And a good exchange format, like </span><a href="https://grpc.io/" rel="">grpc</a><span> with </span><a href="https://github.com/protocolbuffers/protobuf" rel="">protobuff</a><span>.</span></p><p><span>Believe it or not, it became very hard to make your todo-list app work with all those, so a solution was found: adding orchestration. </span><a href="https://docs.docker.com/engine/swarm/" rel="">Docker swarm</a><span>, and now </span><a href="https://kubernetes.io/" rel="">kubernetes</a><span>.</span></p><p>At this stage, so much time and money were obliterated the cloud felt like a savior: they will do all that for you, for a fee. You just had to learn their entire way of doing things, debug their black box, be locked in their ecosystem, and carefully optimize and configure - using state-of-the-art templated YAML files and hostile UIs - your entire project, so that you could only spend 10 times more on hosting, and not 10000 times by mistake.</p><p>Easy.</p><p><span>Second, big data arrived. You had to store every single click of your users. A/B test everything as well, so that you consistently annoy 10% of your customers and make support unbearable. Now the data you had was gigantic! And if it was not, you had to believe it, and you needed some kind of </span><a href="https://en.wikipedia.org/wiki/Amazon_DynamoDB" rel="">Dynamo</a><span> data lake. Or maybe a time series db. Or a graph one. You needed something, that&#39;s for sure.</span></p><p>Third, all of that stuff was now very slow. It was not because of the terrible technical decisions leading to use Google level industrial architectures for your 100 request/seconds website, no. It was because you used a slow language. So let&#39;s rewrite everything in Go. Or Rust.</p><p>The compilation step is not going to have any impact on the feedback loop anyway, since the CI pipeline already takes 73 minutes.</p><p>That was the last straw, so out of tiredness, devs went back to simple ways...</p><p><span>Just kidding, they went in flocks to </span><a href="https://en.wikipedia.org/wiki/AWS_Lambda" rel="">serverless lambda</a><span> and SaaS services you call </span><a href="https://de.wikipedia.org/wiki/Edge_Computing" rel="">from the edge</a><span>, cause not owning your stack is the future!</span></p><p>Meanwhile, while the blog posts about burn out were increasing tenfold, somewhere at the top, leaders heard the call of money.</p><p>You can&#39;t grow without making everything social.</p><p>Gamify, gamify, gamify.</p><p>Block chain will change the universe.</p><p><span>You need an </span><a href="https://en.wikipedia.org/wiki/Accelerated_Mobile_Pages" rel="">AMP website</a><span>.</span></p><p>Your stuff is not competitive without Machine Learning.</p><p>If you lived through all those, you know what remains about it: almost nothing.</p><p>A few &#34;share&#34; buttons and &#34;login with&#34; workflows. Some points and badges. Graphs.</p><p>Things either died, or filled the niche they were good at, as they should.</p><p>Some were replaced by the future of today.</p><p><span>I like the new hype: </span><a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it" rel="">YAGNI</a><span> is popular again.</span></p><p><span>Projects like </span><a href="https://vuejs.org/" rel="">Vue</a><span>, </span><a href="https://htmx.org/" rel="">HTMX</a><span> and </span><a href="https://unpoly.com/" rel="">unpoly</a><span>, </span><a href="https://alpinejs.dev/" rel="">alpine.js</a><span> or just vanilla are getting traction.</span></p><p>There is talk of coming back to using Postgres for most things.</p><p><a href="https://world.hey.com/dhh/we-have-left-the-cloud-251760fb" rel="">37signals is on the spotlight once more, because they left the cloud.</a></p><p>It will, of course, be overdone. Because minimalism being hyped is still... hype.</p><p>You do need the cloud, containers, nosql, go, rust and js build systems. Modern software requirements, customers’ expectations and incredible new features are not to be ignored.</p><p>Just not for everything.</p><p>Nothing is ever needed for everything.</p></div></div></div></article></div></div></div>
  </body>
</html>
