<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pinetreelabs.github.io/archimedes/blog/2025/introduction.html">Original</a>
    <h1>Archimedes – A Python toolkit for hardware engineering</h1>
    
    <div id="readability-page-1" class="page"><article role="main" id="furo-main-content">
          <section id="introducing-archimedes">

<img alt="Introducing Archimedes" src="https://pinetreelabs.github.io/archimedes/_images/rocket_intro.png"/>
<p><strong><em>A Python toolkit for hardware engineering</em></strong></p>
<p>By Jared Callaham • 6 Oct 2025</p>
<hr/>
<p>A great engineer (controls being no exception) has to be part hacker, part master craftsman.</p>
<p>You have to be a hacker because things rarely “just work” in the real world without a little… creativity.
But you can’t <em>only</em> be a hacker; developing complex systems in aerospace, automotive, robotics, and similar industries demands a disciplined, systematic approach.
You need tools that let you iterate fast and maintain a methodical workflow where changes are version-controlled, algorithms are tested systematically, and deployment is repeatable.</p>
<p>Modern deep learning frameworks solved this years ago — you can develop in PyTorch or JAX and deploy anywhere.
But those tools were built for neural net models, GPUs, and cloud deployments, not dynamics models, MCUs, and HIL testing.</p>
<p>That’s where Archimedes comes in; what PyTorch did for ML deployment, Archimedes aims to do for control systems.
The goal is to build an open-source “PyTorch for hardware” that gives you the productivity of Python with the deployability of C.</p>
<p>In short, <strong>Archimedes is a Python framework that lets you develop and analyze algorithms in NumPy and automatically generate optimized C code for embedded systems</strong>.
For instance, you can write a physics model in Python, calibrate it with data, use the model to design and simulate control logic, validate with simple hardware-in-the-loop (HIL) testing, and deploy with confidence:</p>
<img alt="../../_images/dev_workflow.png" src="https://pinetreelabs.github.io/archimedes/_images/dev_workflow.png"/>
<img alt="../../_images/dev_workflow_dark.png" src="https://pinetreelabs.github.io/archimedes/_images/dev_workflow_dark.png"/>
<p>This is <em>one</em> workflow you might use with Archimedes (specifically, the one from the <a href="https://pinetreelabs.github.io/archimedes/tutorials/deployment/deployment00.html"><span>hardware deployment tutorial</span></a>), but it’s designed to be flexible, so you’re free to build up whatever workflow suits your style and application best.</p>
<section id="the-linchpin-python-c-code-generation">
<h2>The Linchpin: Python → C Code Generation<a href="#the-linchpin-python-c-code-generation" title="Link to this heading">¶</a></h2>
<p>Archimedes started with the question, <strong>“What would you need to actually do practical control systems development in Python?”</strong></p>
<p>As a high-level language, it’s hard to beat Python on design principles like progressive disclosure, flexibility, and scalability.
The numerical ecosystem (NumPy, SciPy, Matplotlib, Pandas, PyTorch, etc.) is also excellent.
The problem is that <strong>none of it can deploy to typical embedded systems.</strong></p>
<p>If you need to deploy to hardware today, you have a few basic options:</p>
<ol>
<li><p>Work in a high-level language like Python or Julia and manually translate algorithms to C code</p></li>
<li><p>Work entirely in a low-level language like C/C++ or Rust</p></li>
<li><p>Adopt an expensive vendor-locked ecosystem that supports automatic code generation</p></li>
</ol>
<p>(<strong>Side note</strong>: While running Python itself on a microcontroller is growing in popularity for educational and hobby applications, there’s no real future for pure Python in real-time mission-critical deployments.)</p>
<p>However, if you could do seamless C code generation from standard NumPy code, you could layer on simulation and optimization tools, building blocks for physics modeling, testing frameworks, and other features of comprehensive controls engineering toolchains.
But without the code generation, there will always be a gulf between the software and the hardware deployment.</p>
<p>Just to drive the point home, here’s a side-by-side of manual vs automatic coding for a common piece of sensor fusion algorithms:</p>
<details>
<div>
<p>Below are two implementations of a Kalman filter, an algorithm that combines noisy sensor measurements with a prediction model to estimate system state.
This is what’s behind GPS navigation, spacecraft guidance, and sensor fusion in millions of devices.</p>
<p>On the left is hand-written C code, and on the right is a NumPy version that can be used to generate an equivalent function.</p>
<p>Here we’ll show an implementation for the common case of a single sensor, which avoids having to use a library for matrix inversion in C (though Archimedes does support operations like Cholesky factorization).</p>
<div>
<div>
<div>
<div>
<div>
<p><strong>Handwritten C</strong></p>
<div><div><pre><span></span><span>#include</span><span> </span><span>&lt;stdint.h&gt;</span>
<span>#define N_STATES        4</span>

<span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>float</span><span> </span><span>H</span><span>[</span><span>N_STATES</span><span>];</span><span>  </span><span>// Measurement matrix (1 x n)</span>
<span>    </span><span>float</span><span> </span><span>R</span><span>;</span><span>            </span><span>// Measurement noise covariance (scalar)</span>
<span>}</span><span> </span><span>kf_params_t</span><span>;</span>

<span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>float</span><span> </span><span>x</span><span>[</span><span>N_STATES</span><span>];</span><span>            </span><span>// State estimate</span>
<span>    </span><span>float</span><span> </span><span>P</span><span>[</span><span>N_STATES</span><span>][</span><span>N_STATES</span><span>];</span><span> </span><span>// Estimate covariance</span>
<span>}</span><span> </span><span>kf_state_t</span><span>;</span>

<span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>float</span><span> </span><span>K</span><span>[</span><span>N_STATES</span><span>];</span><span>              </span><span>// Kalman gain (n x 1)</span>
<span>    </span><span>float</span><span> </span><span>M</span><span>[</span><span>N_STATES</span><span>][</span><span>N_STATES</span><span>];</span><span>    </span><span>// I - K * H temporary</span>
<span>    </span><span>float</span><span> </span><span>MP</span><span>[</span><span>N_STATES</span><span>][</span><span>N_STATES</span><span>];</span><span>   </span><span>// M * P temporary</span>
<span>    </span><span>float</span><span> </span><span>MPMT</span><span>[</span><span>N_STATES</span><span>][</span><span>N_STATES</span><span>];</span><span> </span><span>// M * P * M^T temporary</span>
<span>    </span><span>float</span><span> </span><span>KRKT</span><span>[</span><span>N_STATES</span><span>][</span><span>N_STATES</span><span>];</span><span> </span><span>// K * R * K^T temporary</span>
<span>}</span><span> </span><span>kf_work_t</span><span>;</span>

<span>/**</span>
<span> * Kalman filter update step (scalar measurement case)</span>
<span> *</span>
<span> * Mathematical formulation:</span>
<span> *   y = z - H·x                      (innovation)</span>
<span> *   S = H·P·H^T + R                  (innovation covariance)</span>
<span> *   K = P·H^T·S^(-1)                 (Kalman gain)</span>
<span> *   x&#39; = x + K·y                     (state update)</span>
<span> *   P&#39; = (I-KH)·P·(I-KH)^T + K·R·K^T (Joseph form covariance)</span>
<span> *</span>
<span> * @param z: Latest measurement</span>
<span> * @param kf_state: Pointer to Kalman filter state struct</span>
<span> * @param kf_params: Pointer to Kalman filter parameters struct</span>
<span> * @param kf_work: Pointer to Kalman filter work struct (for temporaries)</span>
<span> * @return: 0 on success, -1 on error</span>
<span> */</span>
<span>int</span><span> </span><span>kalman_update</span><span>(</span><span>float</span><span> </span><span>z</span><span>,</span><span> </span><span>kf_state_t</span><span> </span><span>*</span><span>kf_state</span><span>,</span>
<span>                  </span><span>const</span><span> </span><span>kf_params_t</span><span> </span><span>*</span><span>kf_params</span><span>,</span>
<span>                  </span><span>kf_work_t</span><span> </span><span>*</span><span>kf_work</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>#ifdef DEBUG</span>
<span>    </span><span>if</span><span> </span><span>(</span><span>!</span><span>kf_state</span><span> </span><span>||</span><span> </span><span>!</span><span>kf_params</span><span> </span><span>||</span><span> </span><span>!</span><span>kf_work</span><span>)</span>
<span>        </span><span>return</span><span> </span><span>-1</span><span>;</span>
<span>    </span><span>#endif</span>
<span>    </span><span>size_t</span><span> </span><span>i</span><span>,</span><span> </span><span>j</span><span>,</span><span> </span><span>k</span><span>;</span>

<span>    </span><span>// Innovation: y = z - H * x</span>
<span>    </span><span>float</span><span> </span><span>y</span><span> </span><span>=</span><span> </span><span>z</span><span>;</span>
<span>    </span><span>for</span><span> </span><span>(</span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span>
<span>        </span><span>y</span><span> </span><span>-=</span><span> </span><span>kf_params</span><span>-&gt;</span><span>H</span><span>[</span><span>i</span><span>]</span><span> </span><span>*</span><span> </span><span>kf_state</span><span>-&gt;</span><span>x</span><span>[</span><span>i</span><span>];</span>

<span>    </span><span>// Innovation covariance: S = H * P * H^T + R</span>
<span>    </span><span>float</span><span> </span><span>S</span><span> </span><span>=</span><span> </span><span>kf_params</span><span>-&gt;</span><span>R</span><span>;</span>

<span>    </span><span>// Compute P * H^T (mv_mult)</span>
<span>    </span><span>// Using K as temporary storage here</span>
<span>    </span><span>for</span><span> </span><span>(</span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>kf_work</span><span>-&gt;</span><span>K</span><span>[</span><span>i</span><span>]</span><span> </span><span>=</span><span> </span><span>0.0f</span><span>;</span>
<span>        </span><span>for</span><span> </span><span>(</span><span>j</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>j</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>j</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>            </span><span>kf_work</span><span>-&gt;</span><span>K</span><span>[</span><span>i</span><span>]</span><span> </span><span>+=</span><span> </span><span>kf_state</span><span>-&gt;</span><span>P</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span><span> </span><span>*</span><span> </span><span>kf_params</span><span>-&gt;</span><span>H</span><span>[</span><span>j</span><span>];</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>    </span><span>for</span><span> </span><span>(</span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span>
<span>        </span><span>S</span><span> </span><span>+=</span><span> </span><span>kf_params</span><span>-&gt;</span><span>H</span><span>[</span><span>i</span><span>]</span><span> </span><span>*</span><span> </span><span>kf_work</span><span>-&gt;</span><span>K</span><span>[</span><span>i</span><span>];</span>

<span>    </span><span>// Kalman gain: K = P * H^T / S</span>
<span>    </span><span>for</span><span> </span><span>(</span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span>
<span>        </span><span>kf_work</span><span>-&gt;</span><span>K</span><span>[</span><span>i</span><span>]</span><span> </span><span>/=</span><span> </span><span>S</span><span>;</span>

<span>    </span><span>// Update state with feedback from new measurement: x = x + K * y</span>
<span>    </span><span>for</span><span> </span><span>(</span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span>
<span>        </span><span>kf_state</span><span>-&gt;</span><span>x</span><span>[</span><span>i</span><span>]</span><span> </span><span>+=</span><span> </span><span>kf_work</span><span>-&gt;</span><span>K</span><span>[</span><span>i</span><span>]</span><span> </span><span>*</span><span> </span><span>y</span><span>;</span>

<span>    </span><span>// Joseph form update: P = (I - K * H) * P * (I - K * H)^T + K * R * K^T</span>
<span>    </span><span>// First compute M = I - K * H</span>
<span>    </span><span>for</span><span> </span><span>(</span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>for</span><span> </span><span>(</span><span>j</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>j</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>j</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>            </span><span>if</span><span> </span><span>(</span><span>i</span><span> </span><span>==</span><span> </span><span>j</span><span>)</span>
<span>                </span><span>kf_work</span><span>-&gt;</span><span>M</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span><span> </span><span>=</span><span> </span><span>1.0f</span><span> </span><span>-</span><span> </span><span>kf_work</span><span>-&gt;</span><span>K</span><span>[</span><span>i</span><span>]</span><span> </span><span>*</span><span> </span><span>kf_params</span><span>-&gt;</span><span>H</span><span>[</span><span>j</span><span>];</span>
<span>            </span><span>else</span>
<span>                </span><span>kf_work</span><span>-&gt;</span><span>M</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span><span> </span><span>=</span><span> </span><span>-</span><span>kf_work</span><span>-&gt;</span><span>K</span><span>[</span><span>i</span><span>]</span><span> </span><span>*</span><span> </span><span>kf_params</span><span>-&gt;</span><span>H</span><span>[</span><span>j</span><span>];</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>// Compute M * P</span>
<span>    </span><span>for</span><span> </span><span>(</span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>for</span><span> </span><span>(</span><span>j</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>j</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>j</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>            </span><span>kf_work</span><span>-&gt;</span><span>MP</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span><span> </span><span>=</span><span> </span><span>0.0f</span><span>;</span>
<span>            </span><span>for</span><span> </span><span>(</span><span>k</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>k</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>k</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>                </span><span>kf_work</span><span>-&gt;</span><span>MP</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span><span> </span><span>+=</span><span> </span><span>kf_work</span><span>-&gt;</span><span>M</span><span>[</span><span>i</span><span>][</span><span>k</span><span>]</span><span> </span><span>*</span><span> </span><span>kf_state</span><span>-&gt;</span><span>P</span><span>[</span><span>k</span><span>][</span><span>j</span><span>];</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>// Compute (M * P) * M^T</span>
<span>    </span><span>for</span><span> </span><span>(</span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>for</span><span> </span><span>(</span><span>j</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>j</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>j</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>            </span><span>kf_work</span><span>-&gt;</span><span>MPMT</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span><span> </span><span>=</span><span> </span><span>0.0f</span><span>;</span>
<span>            </span><span>for</span><span> </span><span>(</span><span>k</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>k</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>k</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>                </span><span>kf_work</span><span>-&gt;</span><span>MPMT</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span><span> </span><span>+=</span><span> </span><span>kf_work</span><span>-&gt;</span><span>MP</span><span>[</span><span>i</span><span>][</span><span>k</span><span>]</span><span> </span><span>*</span><span> </span><span>kf_work</span><span>-&gt;</span><span>M</span><span>[</span><span>j</span><span>][</span><span>k</span><span>];</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>// Compute K * R * K^T</span>
<span>    </span><span>for</span><span> </span><span>(</span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>for</span><span> </span><span>(</span><span>j</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>j</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>j</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>            </span><span>kf_work</span><span>-&gt;</span><span>KRKT</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span><span> </span><span>=</span><span> </span><span>kf_work</span><span>-&gt;</span><span>K</span><span>[</span><span>i</span><span>]</span><span> </span><span>*</span><span> </span><span>kf_params</span><span>-&gt;</span><span>R</span><span> </span><span>*</span><span> </span><span>kf_work</span><span>-&gt;</span><span>K</span><span>[</span><span>j</span><span>];</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>// Final covariance update: P = MPMT + KRKT</span>
<span>    </span><span>for</span><span> </span><span>(</span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>for</span><span> </span><span>(</span><span>j</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>j</span><span> </span><span>&lt;</span><span> </span><span>N_STATES</span><span>;</span><span> </span><span>j</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>            </span><span>kf_state</span><span>-&gt;</span><span>P</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span><span> </span><span>=</span><span> </span><span>kf_work</span><span>-&gt;</span><span>MPMT</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span><span> </span><span>+</span><span> </span><span>kf_work</span><span>-&gt;</span><span>KRKT</span><span>[</span><span>i</span><span>][</span><span>j</span><span>];</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<p><strong>Archimedes Codegen</strong></p>
<div><div><pre><span></span><span>@arc</span><span>.</span><span>compile</span>
<span>def</span><span> </span><span>kalman_update</span><span>(</span><span>x</span><span>,</span> <span>P</span><span>,</span> <span>z</span><span>,</span> <span>H</span><span>,</span> <span>R</span><span>):</span>
<span>    </span><span>&#34;&#34;&#34;Update state estimate with new measurement&#34;&#34;&#34;</span>
    <span>I</span> <span>=</span> <span>np</span><span>.</span><span>eye</span><span>(</span><span>len</span><span>(</span><span>x</span><span>))</span>
    <span>R</span> <span>=</span> <span>np</span><span>.</span><span>atleast_2d</span><span>(</span><span>R</span><span>)</span>  <span># Ensure R is 2D for matrix operations</span>

    <span>y</span> <span>=</span> <span>np</span><span>.</span><span>atleast_1d</span><span>(</span><span>z</span> <span>-</span> <span>H</span> <span>@</span> <span>x</span><span>)</span>  <span># Innovation</span>
    <span>S</span> <span>=</span> <span>H</span> <span>@</span> <span>P</span> <span>@</span> <span>H</span><span>.</span><span>T</span> <span>+</span> <span>R</span>  <span># Innovation covariance  </span>
    <span>K</span> <span>=</span> <span>P</span> <span>@</span> <span>H</span><span>.</span><span>T</span> <span>/</span> <span>S</span>  <span># Kalman gain (scalar S)</span>

    <span># Update state with feedback from new measurement</span>
    <span>x_new</span> <span>=</span> <span>x</span> <span>+</span> <span>K</span> <span>*</span> <span>y</span>

    <span># Joseph form covariance update</span>
    <span>P_new</span> <span>=</span> <span>(</span><span>I</span> <span>-</span> <span>K</span> <span>@</span> <span>H</span><span>)</span> <span>@</span> <span>P</span> <span>@</span> <span>(</span><span>I</span> <span>-</span> <span>K</span> <span>@</span> <span>H</span><span>)</span><span>.</span><span>T</span> <span>+</span> <span>K</span> <span>@</span> <span>R</span> <span>@</span> <span>K</span><span>.</span><span>T</span>
    
    <span>return</span> <span>x_new</span><span>,</span> <span>P_new</span>

<span># Generate optimized C code:</span>
<span>return_names</span> <span>=</span> <span>(</span><span>&#34;x_new&#34;</span><span>,</span> <span>&#34;P_new&#34;</span><span>)</span>
<span>args</span> <span>=</span> <span>(</span><span>x</span><span>,</span> <span>P</span><span>,</span> <span>z</span><span>,</span> <span>H</span><span>,</span> <span>R</span><span>)</span>
<span>arc</span><span>.</span><span>codegen</span><span>(</span><span>kalman_update</span><span>,</span> <span>args</span><span>,</span> <span>return_names</span><span>=</span><span>return_names</span><span>)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
<p>Neither of these implementations is optimized, but it gives a sense of what it looks like to work in either environment.
Of course, for production hand-written code, you’d likely also use optimized linear algebra libraries like CMSIS-DSP and numerical strategies like Cholesky factorization or a square-root form for stability.
But the extra numerical features are only a few extra lines in NumPy, while the hand-written C version becomes more and more complex.</p>
</div>
</details><p>This capability, and most of the other core functionality in Archimedes, is made possible by building on <a href="https://web.casadi.org/">CasADi</a>, a sophisticated open-source library for nonlinear optimization and algorithmic differentiation.
This lets Archimedes translate your NumPy code into C++ <em>computational graphs</em> that support code generation, derivative calculation, and more.</p>
</section>
<section id="beyond-codegen">
<h2>Beyond Codegen<a href="#beyond-codegen" title="Link to this heading">¶</a></h2>
<p>If you’re already working in C/C++/Rust, or if you don’t actually need to deploy to hardware for your application, the codegen may not speak to you.
But while Python → C code generation is what makes Archimedes practical for deployment, there’s much more you can do.</p>
<!--
Archimedes has a primarily _functional_ style, meaning that much of the core functionality is exposed through function _decorators_ that transform the function you wrote into a modified function according to the purpose of the decorator.

This design was heavily influenced by JAX and PyTorch, but don't worry if you haven't used these frameworks before.
-->
<section id="compilation">
<h3>Compilation<a href="#compilation" title="Link to this heading">¶</a></h3>
<p>Archimedes can “compile” a Python function into a C++ <em>computational graph</em>, meaning that when you call the compiled function, the entire numerical code gets executed in C++ rather than interpreted Python.
For complicated functions this can achieve dramatic speedups over pure Python (5-10x even on simple benchmarks).</p>
<div><div><pre><span></span><span>import</span><span> </span><span>numpy</span><span> </span><span>as</span><span> </span><span>np</span>
<span>import</span><span> </span><span>archimedes</span><span> </span><span>as</span><span> </span><span>arc</span>

<span>@arc</span><span>.</span><span>compile</span>
<span>def</span><span> </span><span>rotate</span><span>(</span><span>x</span><span>,</span> <span>theta</span><span>):</span>
    <span>R</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span>
        <span>[</span><span>np</span><span>.</span><span>cos</span><span>(</span><span>theta</span><span>),</span> <span>-</span><span>np</span><span>.</span><span>sin</span><span>(</span><span>theta</span><span>)],</span>
        <span>[</span><span>np</span><span>.</span><span>sin</span><span>(</span><span>theta</span><span>),</span> <span>np</span><span>.</span><span>cos</span><span>(</span><span>theta</span><span>)],</span>
    <span>],</span> <span>like</span><span>=</span><span>x</span><span>)</span>
    <span>return</span> <span>R</span> <span>@</span> <span>x</span>

<span>rotate</span><span>(</span><span>np</span><span>.</span><span>array</span><span>([</span><span>1.0</span><span>,</span> <span>0.0</span><span>]),</span> <span>0.1</span><span>)</span>
</pre></div>
</div>
<p>You can embed complex functionality like <a href="https://pinetreelabs.github.io/archimedes/generated/api/archimedes.odeint.html#archimedes.odeint" title="archimedes.odeint"><span>ODE solves</span></a>, <a href="https://pinetreelabs.github.io/archimedes/generated/api/archimedes.minimize.html#archimedes.minimize" title="archimedes.minimize"><span>constrained nonlinear optimization</span></a>, and more directly in these computational graphs.</p>
<p>When you first call your function, Archimedes feeds it <em>symbolic arrays</em> (using <a href="https://web.casadi.org/">CasADi’s</a> symbolic types under the hood) that match the shape and type of your numerical inputs.
As your code executes, it builds up a C++ representation of the calculation.
Then, instead of operating on the numerical arrays, your code operates on these symbolic replacements, using NumPy’s <em>array dispatch</em> mechanism to redirect to CasADi whenever you call NumPy functions.
By the end of this “tracing” step, CasADi has a full view of what the function does and can reproduce it in efficient C++.
Then, any time you call that function again, the C++ equivalent is what actually gets executed.</p>
<p>This approach is not “Just-In-Time” (JIT) compilation in the sense used by Julia/JAX/Numba, where the Python code is literally compiled down to highly optimized platform-specific machine code.
We’ll show some benchmarking in a separate post, but generally what you can expect is that these JIT-compiled frameworks will be somewhat faster than pre-compiled CasADi (and hence, Archimedes).
However, by avoiding the overhead and “unrolling” of true JIT compilation, we get a massive reduction in compilation time for the kind of complex functions typical of advanced controls applications.</p>
<p>For more on how this works (and when it doesn’t), see the <a href="https://pinetreelabs.github.io/archimedes/under-the-hood.html"><span>Under the Hood</span></a> documentation page.</p>
</section>
<section id="simulation-optimization-root-finding">
<h3>Simulation, Optimization, &amp; Root-finding<a href="#simulation-optimization-root-finding" title="Link to this heading">¶</a></h3>
<p>Archimedes provides a SciPy-like interface to the powerful and robust <a href="https://computing.llnl.gov/projects/sundials/cvodes">CVODES</a> solver from SUNDIALS, which is a highly efficient and time-tested implementation of a stiff/non-stiff implicit solver that even supports gradient-based sensitivity analysis:</p>
<div><div><pre><span></span><span>def</span><span> </span><span>simulate</span><span>(</span><span>x0</span><span>):</span>
    <span>xs</span> <span>=</span> <span>arc</span><span>.</span><span>odeint</span><span>(</span><span>dynamics</span><span>,</span> <span>(</span><span>t0</span><span>,</span> <span>tf</span><span>),</span> <span>x0</span><span>,</span> <span>t_eval</span><span>=</span><span>ts</span><span>)</span>
    <span>return</span> <span>xs</span><span>[:,</span> <span>-</span><span>1</span><span>]</span>

<span>arc</span><span>.</span><span>jac</span><span>(</span><span>simulate</span><span>)(</span><span>x0</span><span>)</span>  <span># dxf/dx0</span>
</pre></div>
</div>
<p>We also have a SciPy-like optimization interface that can solve constrained nonlinear problems with IPOPT:</p>
<div><div><pre><span></span><span># Rosenbrock problem</span>
<span>def</span><span> </span><span>f</span><span>(</span><span>x</span><span>):</span>
    <span>return</span> <span>100</span> <span>*</span> <span>(</span><span>x</span><span>[</span><span>1</span><span>]</span> <span>-</span> <span>x</span><span>[</span><span>0</span><span>]</span> <span>**</span> <span>2</span><span>)</span> <span>**</span> <span>2</span> <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>x</span><span>[</span><span>0</span><span>])</span> <span>**</span> <span>2</span>

<span>result</span> <span>=</span> <span>arc</span><span>.</span><span>minimize</span><span>(</span><span>f</span><span>,</span> <span>x0</span><span>=</span><span>[</span><span>-</span><span>1.0</span><span>,</span> <span>1.0</span><span>])</span>
</pre></div>
</div>
<p>and a root-finding interface for iteratively solving nonlinear algebraic systems using Newton iterations and similar methods:</p>
<div><div><pre><span></span><span>def</span><span> </span><span>f</span><span>(</span><span>x</span><span>):</span>
    <span>return</span> <span>np</span><span>.</span><span>array</span><span>([</span>
        <span>x</span><span>[</span><span>0</span><span>]</span> <span>+</span> <span>0.5</span> <span>*</span> <span>(</span><span>x</span><span>[</span><span>0</span><span>]</span> <span>-</span> <span>x</span><span>[</span><span>1</span><span>])</span><span>**</span><span>3</span> <span>-</span> <span>1.0</span><span>,</span>
        <span>0.5</span> <span>*</span> <span>(</span><span>x</span><span>[</span><span>1</span><span>]</span> <span>-</span> <span>x</span><span>[</span><span>0</span><span>])</span><span>**</span><span>3</span> <span>+</span> <span>x</span><span>[</span><span>1</span><span>]</span>
    <span>],</span> <span>like</span><span>=</span><span>x</span><span>)</span>

<span>x</span> <span>=</span> <span>arc</span><span>.</span><span>root</span><span>(</span><span>f</span><span>,</span> <span>x0</span><span>=</span><span>np</span><span>.</span><span>array</span><span>([</span><span>0.0</span><span>,</span> <span>0.0</span><span>]))</span>
</pre></div>
</div>
<p>These solves can also be embedded in compiled computational graphs for accelerated simulation and optimization.</p>
</section>
<section id="automatic-differentiation">
<h3>Automatic Differentiation<a href="#automatic-differentiation" title="Link to this heading">¶</a></h3>
<p>Compilation into a CasADi computational graph unlocks two critical capabilities: execution speed and automatic differentiation.
This means that you can easily and accurately calculate derivatives of your functions:</p>
<div><div><pre><span></span><span>def</span><span> </span><span>lotka_volterra</span><span>(</span><span>t</span><span>,</span> <span>x</span><span>):</span>
    <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>,</span> <span>d</span> <span>=</span> <span>1.5</span><span>,</span> <span>1.0</span><span>,</span> <span>1.0</span><span>,</span> <span>3.0</span>
    <span>return</span> <span>np</span><span>.</span><span>hstack</span><span>([</span>
        <span>a</span> <span>*</span> <span>x</span><span>[</span><span>0</span><span>]</span> <span>-</span> <span>b</span> <span>*</span> <span>x</span><span>[</span><span>0</span><span>]</span> <span>*</span> <span>x</span><span>[</span><span>1</span><span>],</span>
        <span>c</span> <span>*</span> <span>x</span><span>[</span><span>0</span><span>]</span> <span>*</span> <span>x</span><span>[</span><span>1</span><span>]</span> <span>-</span> <span>d</span> <span>*</span> <span>x</span><span>[</span><span>1</span><span>],</span>
    <span>])</span>

<span># Linearize the system</span>
<span>J</span> <span>=</span> <span>arc</span><span>.</span><span>jac</span><span>(</span><span>dynamics</span><span>,</span> <span>argnums</span><span>=</span><span>1</span><span>)</span>
<span>print</span><span>(</span><span>J</span><span>(</span><span>0.0</span><span>,</span> <span>[</span><span>1.0</span><span>,</span> <span>1.0</span><span>]))</span>
</pre></div>
</div>
<p>Besides linearizing models for stability analysis and controller design, this is a feature you may not directly use very often.
But gradients and Jacobians are used pervasively in numerical methods:</p>
<ul>
<li><p><strong>Optimization</strong> solvers use gradients of the objective, Jacobians of the constraints, and sometimes even Hessian information</p></li>
<li><p><strong>Simulation</strong> algorithms use Jacobians of the dynamics model for implicit solvers, especially for “stiff” ODE/DAE problems</p></li>
<li><p><strong>Root-finding</strong> solvers like Newton’s method use Jacobians at every iteration to find an improved guess at the solution point</p></li>
</ul>
<p>So when you do parameter estimation, trajectory optimization, trim point identification, or even just call <code><span>odeint</span></code>, you don’t <em>think</em> about “autodiff”, but it’s happening behind the scenes to solve your problem.</p>
<p>Traditional scientific computing packages like SciPy and MATLAB usually fall back to slow and inaccurate finite differencing unless you provide manually implemented gradients, Jacobians, etc. - but for anything but the simplest problems this is prohibitively complicated to calculate and implement.</p>
<p>Newer frameworks like Julia, JAX, and PyTorch rely much more heavily on autodiff, but none of these are tailored towards hardware and controls engineering applications.
My personal experience has been that CasADi (the autodiff framework used under the hood by Archimedes) has far and away the best autodiff system for the kinds of large, sparse problems that commonly arise in engineering (like parameter estimation, trajectory optimization, model-predictive control, etc.).</p>
<p>All that is to say, the derivatives are there if you need them.</p>
</section>
<section id="structured-data-types">
<h3>Structured Data Types<a href="#structured-data-types" title="Link to this heading">¶</a></h3>
<p>Most numerical codes are naturally written to operate on flat vectors.
This makes sense for the implementation of an optimization algorithm or ODE solver, but physical systems are usually more naturally conceived of as hierarchical.
For instance, a satellite has position, velocity, attitude, angular velocity, battery state, thermal state, etc.
To work with typical numerical codes, you have to either keep track of what entries in your array are which physical state or manually flatten/unflatten every time you call a routine that expects a flat vector.</p>
<p>That might be fine the <em>first</em> time, but what if you want to try a higher-fidelity battery model that has twice as many dynamic states?
It quickly becomes a nightmare to maintain these kinds of codes, and the result is that you waste cycles on keeping all of this straight, and you lose the practical capability to explore multi-fidelity modeling.</p>
<p>This also comes up frequently in deep learning: models are naturally organized as hierarchical modules with trainable parameters.
This is the root of the <code><span>nn.Module</span></code> in PyTorch and the “PyTree” concept in JAX.
Modern ML frameworks (specifically JAX and PyTorch) have developed a nice set of solutions around working with this kind of hierarchically structured data.</p>
<p>But this hierarchical data and logic might even be <em>more</em> common in engineering.
Physical systems are naturally organized into subsystems and components that have well-defined interfaces, and each of these might have its own dynamic state and configurable parameters.
Hierarchical data structures can mirror this physical system decomposition.</p>
<p>Archimedes takes inspiration from these frameworks and supports “tree operations” (functions applied to hierarchical data) and a <a href="https://pinetreelabs.github.io/archimedes/generated/api/archimedes.struct.html#archimedes.struct" title="archimedes.struct"><span><code><span>@struct</span></code></span></a> decorator to create tree-compatible data classes:</p>
<div><div><pre><span></span><span>@arc</span><span>.</span><span>struct</span>
<span>class</span><span> </span><span>PointMass</span><span>:</span>
    <span>pos</span><span>:</span> <span>np</span><span>.</span><span>ndarray</span>
    <span>vel</span><span>:</span> <span>np</span><span>.</span><span>ndarray</span>

<span>state</span> <span>=</span> <span>PointMass</span><span>(</span><span>np</span><span>.</span><span>zeros</span><span>(</span><span>3</span><span>),</span> <span>np</span><span>.</span><span>ones</span><span>(</span><span>3</span><span>))</span>  <span># state.pos, state.vel</span>
<span>flat_state</span><span>,</span> <span>unravel</span> <span>=</span> <span>arc</span><span>.</span><span>tree</span><span>.</span><span>ravel</span><span>(</span><span>state</span><span>)</span>  <span># flat_state is a vector</span>
<span>state</span> <span>=</span> <span>unravel</span><span>(</span><span>flat_state</span><span>)</span>  <span># Back to a PointMass instance</span>
</pre></div>
</div>
<p>These <code><span>@struct</span></code>-decorated classes can be nested inside one another, flattened to/from a 1D vector, and used to auto-generate nested <code><span>struct</span></code> types in deployable C code.
If a <code><span>PointMass</span></code> is used as an argument to a codegen function, it will become:</p>
<div><div><pre><span></span><span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>float</span><span> </span><span>pos</span><span>[</span><span>3</span><span>];</span>
<span>    </span><span>float</span><span> </span><span>vel</span><span>[</span><span>3</span><span>];</span>
<span>}</span><span> </span><span>point_mass_t</span><span>;</span>
</pre></div>
</div>
<p>This gives you a predictable and intuitive way to switch back and forth between Python and auto-generated C.</p>
<p>For much more on structured data types, see <a href="https://pinetreelabs.github.io/archimedes/trees.html"><span>Structured Data Types</span></a>, <a href="https://pinetreelabs.github.io/archimedes/tutorials/hierarchical/hierarchical00.html"><span>Hierarchical Systems Modeling</span></a>, and the <a href="https://pinetreelabs.github.io/archimedes/tutorials/codegen/codegen00.html"><span>C Code Generation</span></a> tutorial series.</p>
</section>
</section>
<section id="why-another-framework">
<h2>Why Another Framework?<a href="#why-another-framework" title="Link to this heading">¶</a></h2>
<p>There are lots of modeling and simulation tools out there, from rock-solid commercial tools building on 30-year legacies to innovative modern frameworks experimenting with new languages, JIT-compilation, and physics-informed ML.</p>
<p>I created Archimedes because none of these really solved the problems I was having in my own work.
Codebases that started out being logical and well-organized invariably ended up growing into a gnarled, difficult-to-maintain mass in order to support increasingly complex models and analyses.
Then when it’s time to move towards testing and production, you’re back to square one to translate to C code.</p>
<p>Granted, these complaints might just indicate that I’m not a great software developer - but I’m <em>not</em> a software developer.
That’s the point.
I wanted a framework that would let me write code that looked as clean as a deep learning repository in PyTorch, but would also be high-performance for simulation and optimization, <em>and</em> had a path to hardware deployment.
After seeing it perform in my own work, I’m convinced this approach - NumPy-based development with automatic C deployment - could help how control systems engineers develop and deploy algorithms.</p>
<p><strong>One last comment</strong>: from personal experience, it takes a little time (but maybe less than you think) to grok the functional programming and hierarchical data types that are core to Archimedes.
(I’ve spent a lot of time in JAX, which heavily influenced the design of this library.)
It’s different than what you might be used to, and there are also some <a href="https://pinetreelabs.github.io/archimedes/gotchas.html"><span>quirks and gotchas</span></a> related to compilation and control flow.</p>
<p>But these concepts do actually map quite neatly to our mental/mathematical models for dynamical systems and control algorithms.
Once it clicks, you’ll be able to write clean, modular, maintainable workflows that cut down your iteration time and make it faster to design, debug, deploy, and debug, and debug, and redesign, and debug, and…</p>
</section>
<section id="get-started">
<h2>Get Started<a href="#get-started" title="Link to this heading">¶</a></h2>
<p>If you want to give Archimedes a try, it’s easy to get started.
The <a href="https://pinetreelabs.github.io/archimedes/quickstart.html"><span>Quickstart</span></a> page will walk you through the setup, and <a href="https://pinetreelabs.github.io/archimedes/getting-started.html"><span>Getting Started</span></a> will teach you the basic concepts.</p>
<p>Then there are tutorials and deep dives on:</p>
<ul>
<li><p><a href="https://pinetreelabs.github.io/archimedes/trees.html"><span>Structured Data Types</span></a></p></li>
<li><p><a href="https://pinetreelabs.github.io/archimedes/control-flow.html"><span>Control Flow</span></a></p></li>
<li><p><a href="https://pinetreelabs.github.io/archimedes/tutorials/hierarchical/hierarchical00.html"><span>Hierarchical Systems Modeling</span></a></p></li>
<li><p><a href="https://pinetreelabs.github.io/archimedes/tutorials/sysid/parameter-estimation.html"><span>Parameter Estimation</span></a></p></li>
<li><p><a href="https://pinetreelabs.github.io/archimedes/tutorials/codegen/codegen00.html"><span>C Code Generation</span></a></p></li>
</ul>
<p>The <a href="https://pinetreelabs.github.io/archimedes/tutorials/deployment/deployment00.html"><span>Hardware Deployment</span></a> tutorial is a bit more advanced, but shows an end-to-end example of the kinds of workflows you can build in Archimedes.</p>
<p>Upcoming tutorial and example content includes 6dof flight vehicle dynamics, rotor aerodynamics, system identification, low-cost HIL testing workflows, and deep dives on C code generation.</p>
<p>To see where the project is headed and some more detail on the vision, also check out the <a href="https://pinetreelabs.github.io/archimedes/roadmap.html"><span>roadmap</span></a>.</p>
<section id="on-ramp-projects">
<h3>On-ramp Projects<a href="#on-ramp-projects" title="Link to this heading">¶</a></h3>
<p>Once you learn the basics, I bet in an hour or two you could:</p>
<ul>
<li><p>Deploy a PI temperature controller to an Arduino</p></li>
<li><p>Write an integrator for the IMU strapdown equations</p></li>
<li><p>Run parameter estimation on some step response data you have lying around</p></li>
<li><p>Design an <a href="https://underactuated.csail.mit.edu/pend.html#energy_shaping">energy-shaping controller</a> for a pendulum</p></li>
<li><p>Benchmark some old hand-written C code against the auto-generated equivalent (and share the results)</p></li>
</ul>
<p>If you have a cool first project that you’re willing to share, feel free to post about it on the <a href="https://github.com/pinetreelabs/archimedes/discussions">Discussions</a> page - if it’s interesting it could become its own tutorial or blog post.</p>
</section>
<section id="public-beta-status">
<h3>“Public Beta” Status<a href="#public-beta-status" title="Link to this heading">¶</a></h3>
<p>This post marks the release of Archimedes in “public beta” (v0.X.X).
This means that the core functionality is there and has already been tested in practical applications.
The API is also well-tested and stable; while it is likely to evolve in time, it will change with semantic versioning conventions, meaning smooth upgrade paths and deprecation notices.
The library will remain in beta for 6-12 months to allow for community feedback and API maturation across ongoing real-world applications.</p>
<p>For symbolic/numeric reliability in particular, Archimedes gets a big leg up by using CasADi as its backend, which has an excellent track record and is widely and actively used and tested in a variety of applications.</p>
<p>All that is to say, between now and the “v1.0” release you can expect things to be largely stable, but this additional time builds in a cushion to work out any kinks.</p>
<p>Ongoing development priorities are outlined in detail in the <a href="https://pinetreelabs.github.io/archimedes/roadmap.html"><span>roadmap</span></a>, but key focus areas include:</p>
<ul>
<li><p><strong>Hybrid Simulations</strong>: Support for DAEs, zero-crossing events, multirate control logic</p></li>
<li><p><strong>Hardware Deployment</strong>: Improved support for HIL testing, static analysis, and profiling/telemetry</p></li>
<li><p><strong>Physics Modeling</strong>: Built-in functionality like reference frames, kinematic trees, polynomial/spline primitives, and templates for domain-specific components.</p></li>
<li><p><strong>Algorithm Development</strong>: State machines, trajectory optimization, MPC, sensor fusion, uncertainty quantification, etc.</p></li>
</ul>
</section>
<section id="stay-updated">
<h3>Stay Updated<a href="#stay-updated" title="Link to this heading">¶</a></h3>
<p>For updates on Archimedes, including release announcements, new features, blog posts, application examples, and case studies, subscribe to the free newsletter:</p>

<p>You can expect infrequent posts (maybe monthly) with a strong technical focus - no ads, spam, or paywalls.</p>
</section>
<section id="supporting-archimedes">
<h3>Supporting Archimedes<a href="#supporting-archimedes" title="Link to this heading">¶</a></h3>
<p>This post might read a bit like ad copy, but Archimedes is a free, open-source project.
The codebase, ongoing status, and discussions all live on the <a href="https://github.com/pinetreelabs/archimedes">GitHub repository</a>.</p>
<p>If you want to support it, the best thing you can do right now is try it out and give feedback.
What worked well? What didn’t work? What did you like? What was confusing? What was confusing at first but you liked once you got used to it? What would you like to try with Archimedes? What would you like to try but there’s a functionality gap?</p>
<p>The <a href="https://github.com/pinetreelabs/archimedes/discussions">Discussions</a> page is a great place to share general feedback, and bug reports or feature requests are welcome on the <a href="https://github.com/pinetreelabs/archimedes/issues">Issues</a> tab.</p>
<p>Besides feedback, other easy ways to support the project include:</p>
<ul>
<li><p><strong>⭐ Star the Repository</strong>: This shows support and interest and helps others discover the project</p></li>
<li><p><strong>📢 Spread the Word</strong>: Think anyone you know might be interested?</p></li>
<li><p><strong>🐛 Report Issues</strong>: Detailed bug reports, documentation gaps, and feature requests are invaluable</p></li>
<li><p><strong>🗞️ Stay in the Loop</strong>: <a href="https://jaredcallaham.substack.com/embed">Subscribe</a> to the newsletter for updates and announcements</p></li>
</ul>
<p>Thanks for checking out the project!</p>
<hr/>
<div>
<p>About the Author</p>
<p><strong>Jared Callaham</strong> is the creator of Archimedes and principal at Pine Tree Labs.
He is a consulting engineer on modeling, simulation, optimization, and control systems with a particular focus on applications in aerospace engineering.</p>
<p><em>Have questions or feedback? <a href="https://github.com/jcallaham/archimedes/discussions">Open a discussion on GitHub</a></em></p>
</div>
</section>
</section>
</section>

        </article></div>
  </body>
</html>
