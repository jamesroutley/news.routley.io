<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.yossarian.net/2021/11/29/LLVM-internals-part-4-attributes-and-attribute-groups">Original</a>
    <h1>LLVM internals, part 4: attributes and attribute groups</h1>
    
    <div id="readability-page-1" class="page">


<h2><em>Programming, philosophy, pedaling.</em></h2>

<ul>
    <li><a href="https://blog.yossarian.net/">Home</a></li>
    <li><a href="https://blog.yossarian.net/tags">Tags</a></li>
    <li><a href="https://blog.yossarian.net/series">Series</a></li>
    <li><a href="https://blog.yossarian.net/favorites">Favorites</a></li>
    <li><a href="https://blog.yossarian.net/archive">Archive</a></li>
    
      <li><a href="https://yossarian.net">Main Site</a></li>
    
</ul>

<hr/>



<h2>
  <p>
    <span><em>Nov 29, 2021</em></span>

       

    
      <span>
        Tags:
        
        
          <a href="https://blog.yossarian.net/tags#llvm">llvm</a>,
        
          <a href="https://blog.yossarian.net/tags#rust">rust</a>
        
      </span>
    

       

    
      <span>
        Series: <a href="https://blog.yossarian.net/series#llvm-internals">llvm-internals</a>
      </span>
    
  </p>
</h2>

<hr/>

<h2 id="preword">Preword</h2>

<p>This is the last post I plan to do on parsing LLVM’s bitcode, at least for a while.
I’ll keep working on the various libraries that I’ve started under the
<a href="https://github.com/woodruffw/mollusc"><em>mollusc</em></a> umbrella, but they won’t be accompanied
by regular posts anymore — I’d like to refocus on writing smaller, less dense
(read: lower-pressure) posts for a while.</p>

<p>Also, as a sort of update: all four of the patchsets<sup id="fnref:patchsets" role="doc-noteref"><a href="#fn:patchsets" rel="footnote">1</a></sup> that I mentioned in the
<a href="https://blog.yossarian.net/2021/09/14/LLVM-internals-part-3-from-bitcode-to-IR">previous post</a>
have been fully merged into LLVM, including a couple of documentation and bitcode parsing
bugfixes. Many thanks to the LLVM maintainers for reviewing and approving my changes!</p>

<hr/>



<p>LLVM has no less<sup id="fnref:maybemore" role="doc-noteref"><a href="#fn:maybemore" rel="footnote">2</a></sup> than three different ways to represent <em>some</em> of the metadata that gets
stored in its intermediate representation of a program: <em>metadata</em>, <em>attributes</em>, and <em>intrinsics</em>.
All three are represented differently in the bitcode format and this post will focus only
on <em>attributes</em>, but it’s important to understand the semantic difference between the three.</p>

<p>Using
<a href="https://llvm.org/devmtg/2016-11/Slides/Finkel-IntrinsicsMetadataAttributes.pdf">this excellent 2016 LLVM developers’ meeting presentation</a>
as a reference:</p>

<ul>
  <li>
    <p><em>Intrinsics</em> are internal functions whose semantics are well-defined by and well-known to LLVM.
Common examples of these include the
<a href="https://llvm.org/docs/LangRef.html#llvm-memcpy-intrinsic"><code>@llvm.memcpy.*</code> family</a> for semantics
similar to the <a href="https://man7.org/linux/man-pages/man3/memcpy.3.html"><code>memcpy(3)</code></a> <code>libc</code> routine,
as well as various mathematics intrinsics corresponding roughly to <code>libm</code> routines (such as
<a href="https://llvm.org/docs/LangRef.html#llvm-ceil-intrinsic"><code>@llvm.ceil</code></a> for
<a href="https://linux.die.net/man/3/ceil"><code>ceil(3)</code></a>).</p>

    <p>Generation of these intrinsics by language frontends
(such as <code>clang</code>) is vital to LLVM’s ability to perform a wide variety of memory and arithmetic
optimizations<sup id="fnref:optwhy" role="doc-noteref"><a href="#fn:optwhy" rel="footnote">3</a></sup>, and <code>clang</code> will not hesitate to produce them even for unoptimized runs:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre><span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span> <span>{</span>
  <span>char</span> <span>x</span><span>[</span><span>1024</span><span>];</span>
  <span>char</span> <span>y</span><span>[</span><span>1024</span><span>];</span>

  <span>if</span> <span>(</span><span>rand</span><span>())</span> <span>{</span>
      <span>memcpy</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>1024</span><span>);</span>
  <span>}</span> <span>else</span> <span>{</span>
      <span>memcpy</span><span>(</span><span>y</span><span>,</span> <span>x</span><span>,</span> <span>1024</span><span>);</span>
  <span>}</span>

  <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>yields:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td><pre><span>define</span> <span>dso_local</span> <span>i32</span> <span>@main</span><span>()</span> <span>#0</span> <span>!dbg</span> <span>!9</span> <span>{</span>
  <span>%1</span> <span>=</span> <span>alloca</span> <span>i32</span><span>,</span> <span>align</span> <span>4</span>
  <span>%2</span> <span>=</span> <span>alloca</span> <span>[</span><span>1024</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>16</span>
  <span>%3</span> <span>=</span> <span>alloca</span> <span>[</span><span>1024</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>16</span>
  <span>store</span> <span>i32</span> <span>0</span><span>,</span> <span>i32</span><span>*</span> <span>%1</span><span>,</span> <span>align</span> <span>4</span>
  <span>call</span> <span>void</span> <span>@llvm.dbg.declare</span><span>(</span><span>metadata</span> <span>[</span><span>1024</span> <span>x</span> <span>i8</span><span>]*</span> <span>%2</span><span>,</span> <span>metadata</span> <span>!14</span><span>,</span> <span>metadata</span> <span>!DIExpression</span><span>()),</span> <span>!dbg</span> <span>!19</span>
  <span>call</span> <span>void</span> <span>@llvm.dbg.declare</span><span>(</span><span>metadata</span> <span>[</span><span>1024</span> <span>x</span> <span>i8</span><span>]*</span> <span>%3</span><span>,</span> <span>metadata</span> <span>!20</span><span>,</span> <span>metadata</span> <span>!DIExpression</span><span>()),</span> <span>!dbg</span> <span>!21</span>
  <span>%4</span> <span>=</span> <span>call</span> <span>i32</span> <span>@rand</span><span>()</span> <span>#4</span><span>,</span> <span>!dbg</span> <span>!22</span>
  <span>%5</span> <span>=</span> <span>icmp</span> <span>ne</span> <span>i32</span> <span>%4</span><span>,</span> <span>0</span><span>,</span> <span>!dbg</span> <span>!22</span>
  <span>br</span> <span>i1</span> <span>%5</span><span>,</span> <span>label</span> <span>%6</span><span>,</span> <span>label</span> <span>%9</span><span>,</span> <span>!dbg</span> <span>!24</span>

<span>6</span><span>:</span>                                                <span>; preds = %0</span>
  <span>%7</span> <span>=</span> <span>getelementptr</span> <span>inbounds</span> <span>[</span><span>1024</span> <span>x</span> <span>i8</span><span>],</span> <span>[</span><span>1024</span> <span>x</span> <span>i8</span><span>]*</span> <span>%2</span><span>,</span> <span>i64</span> <span>0</span><span>,</span> <span>i64</span> <span>0</span><span>,</span> <span>!dbg</span> <span>!25</span>
  <span>%8</span> <span>=</span> <span>getelementptr</span> <span>inbounds</span> <span>[</span><span>1024</span> <span>x</span> <span>i8</span><span>],</span> <span>[</span><span>1024</span> <span>x</span> <span>i8</span><span>]*</span> <span>%3</span><span>,</span> <span>i64</span> <span>0</span><span>,</span> <span>i64</span> <span>0</span><span>,</span> <span>!dbg</span> <span>!25</span>
  <span>call</span> <span>void</span> <span>@llvm.memcpy.p0i8.p0i8.i64</span><span>(</span><span>i8</span><span>*</span> <span>align</span> <span>16</span> <span>%7</span><span>,</span> <span>i8</span><span>*</span> <span>align</span> <span>16</span> <span>%8</span><span>,</span> <span>i64</span> <span>1024</span><span>,</span> <span>i1</span> <span>false</span><span>),</span> <span>!dbg</span> <span>!25</span>
  <span>br</span> <span>label</span> <span>%12</span><span>,</span> <span>!dbg</span> <span>!27</span>

<span>9</span><span>:</span>                                                <span>; preds = %0</span>
  <span>%10</span> <span>=</span> <span>getelementptr</span> <span>inbounds</span> <span>[</span><span>1024</span> <span>x</span> <span>i8</span><span>],</span> <span>[</span><span>1024</span> <span>x</span> <span>i8</span><span>]*</span> <span>%3</span><span>,</span> <span>i64</span> <span>0</span><span>,</span> <span>i64</span> <span>0</span><span>,</span> <span>!dbg</span> <span>!28</span>
  <span>%11</span> <span>=</span> <span>getelementptr</span> <span>inbounds</span> <span>[</span><span>1024</span> <span>x</span> <span>i8</span><span>],</span> <span>[</span><span>1024</span> <span>x</span> <span>i8</span><span>]*</span> <span>%2</span><span>,</span> <span>i64</span> <span>0</span><span>,</span> <span>i64</span> <span>0</span><span>,</span> <span>!dbg</span> <span>!28</span>
  <span>call</span> <span>void</span> <span>@llvm.memcpy.p0i8.p0i8.i64</span><span>(</span><span>i8</span><span>*</span> <span>align</span> <span>16</span> <span>%10</span><span>,</span> <span>i8</span><span>*</span> <span>align</span> <span>16</span> <span>%11</span><span>,</span> <span>i64</span> <span>1024</span><span>,</span> <span>i1</span> <span>false</span><span>),</span> <span>!dbg</span> <span>!28</span>
  <span>br</span> <span>label</span> <span>%12</span>

<span>12</span><span>:</span>                                               <span>; preds = %9, %6</span>
  <span>%13</span> <span>=</span> <span>load</span> <span>i32</span><span>,</span> <span>i32</span><span>*</span> <span>%1</span><span>,</span> <span>align</span> <span>4</span><span>,</span> <span>!dbg</span> <span>!30</span>
  <span>ret</span> <span>i32</span> <span>%13</span><span>,</span> <span>!dbg</span> <span>!30</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>(<em>View it on <a href="https://godbolt.org/z/Y41G7qjhn">Godbolt</a>.</em>)</p>

    <p>Consequently, LLVM’s intrinsics are <strong>correctness-bearing</strong> in IR programs: it is not safe, in
the general case, to remove calls to intrinsic functions without providing an adequate substitute
function<sup id="fnref:someintrinsics" role="doc-noteref"><a href="#fn:someintrinsics" rel="footnote">4</a></sup>.</p>
  </li>
  <li>
    <p><em>Attributes</em> are <strong>markers</strong> that define special <strong>properties</strong> on a small subset of program
features: functions (and their callsites), individual parameters, and return values.</p>

    <p>In the textual representation of LLVM’s IR, attributes are associated with program features with
one of two syntaxes. For parameters and return values, attributes are shown inline at their definition sites.
Using a <code>memcpy</code> intrinsic variant as an example:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>declare</span> <span>void</span> <span>@llvm.memcpy.p0i8.p0i8.i64</span><span>(</span><span>i8</span><span>*</span> <span>noalias</span> <span>nocapture</span> <span>writeonly</span><span>,</span> <span>i8</span><span>*</span> <span>noalias</span> <span>nocapture</span> <span>readonly</span><span>,</span> <span>i64</span><span>,</span> <span>i1</span> <span>immarg</span><span>)</span> <span>#3</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>Here, we have the following parameter attributes:</p>

    <ul>
      <li>Our two <code>i8*</code> parameters are <code>noalias</code> and <code>nocapture</code>, meaning that (1) memory accesses through
each pointer are <em>exclusive</em>, and (2) that neither pointer is “captured” within the function, e.g.
by storing its value to a global or other memory location that outlives the function call.</li>
      <li>Our first <code>i8*</code> is <code>writeonly</code> and our second is <code>readonly</code>, which enforce precisely what they
say on the tin: that the function may only write or read through these respective pointers.</li>
      <li>Finally, our <code>i1</code> parameter is marked as <code>immarg</code>, meaning that its parameter must be an immediate
value (along with some other constraints) — anything that would have to be further loaded
or executed to produce a value is invalid.</li>
    </ul>

    <p>Similarly for a definition of <code>malloc</code>:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>declare</span> <span>dso_local</span> <span>noalias</span> <span>align</span> <span>16</span> <span>i8</span><span>*</span> <span>@malloc</span><span>(</span><span>i64</span><span>)</span> <span>#2</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>Here our single parameter has no attributes of its own, but our return value has two: <code>noalias</code>
and <code>align 16</code>.</p>

    <p>Our second syntax is also visible in the snippets above: the <code>#N</code> anchor ties each
function (or function callsite) to a <em>list of attributes</em> that apply to the <strong>entire function
or callsite</strong>.</p>

    <p>For example, the <code>memcpy</code> intrinsic is associated with <code>#3</code>, which is:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>attributes</span> <span>#3</span> <span>=</span> <span>{</span> <span>argmemonly</span> <span>nofree</span> <span>nounwind</span> <span>willreturn</span> <span>}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>(We’re getting into the weeds now, but a whirlwind tour: <code>argmemonly</code> asserts that the function
only modifies memory through any pointer arguments it’s given; <code>nofree</code> asserts that the function
does not call a <code>free</code>-type function on its pointer argument(s); <code>nounwind</code> asserts that the
function never raises an exception; <code>willreturn</code> asserts that the function either contains UB <em>or</em>
returns back to its callsite in some call stack.)</p>

    <p>Each of these, again, has important effects on the program’s correctness, so <em>naively</em>
removing them<sup id="fnref:codegen" role="doc-noteref"><a href="#fn:codegen" rel="footnote">5</a></sup> <strong>is not safe.</strong> They also appear on many callsites, e.g.:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>%5</span> <span>=</span> <span>call</span> <span>i32</span> <span>@rand</span><span>()</span> <span>#4</span><span>,</span> <span>!dbg</span> <span>!24</span>

<span>; ... snip ...</span>

<span>attributes</span> <span>#4</span> <span>=</span> <span>{</span> <span>nounwind</span> <span>}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p><em>Metadata</em> is a lot of things. Among them:</p>

    <ul>
      <li>
        <p>Source-level debugging information that LLVM is responsible for lowering into a format
like DWARF or <a href="https://llvm.org/devmtg/2016-11/Slides/Kleckner-CodeViewInLLVM.pdf">CodeView</a>.</p>

        <p>Virtually everything that ends up in one of these binary debugging formats corresponds
to one or more metadata entries (indicated textually as <code>!N</code>) on LLVM instructions, functions,
&amp;c. For example, here’s how LLVM relates an IR-level <code>%struct</code> back to its
original C-level layout with metadata entries:</p>

        <div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td><pre><span>typedef</span> <span>struct</span> <span>{</span>
    <span>int</span> <span>x</span><span>;</span>
    <span>char</span> <span>y</span><span>;</span>
    <span>struct</span> <span>bar</span> <span>{</span>
        <span>long</span> <span>z0</span><span>;</span>
    <span>}</span> <span>z</span><span>;</span>
<span>}</span> <span>foo</span><span>;</span>

<span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>foo</span> <span>x</span><span>;</span>
    <span>foo</span> <span>y</span><span>;</span>

    <span>/* ... snip ... */</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div>        </div>

        <p>Here, the <code>x</code> and <code>y</code> declarations get <code>@llvm.dbg.declare</code> intrinsics with
associated metadata entries (comments added):</p>

        <div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>%1</span> <span>=</span> <span>alloca</span> <span>i32</span><span>,</span> <span>align</span> <span>4</span>
<span>%2</span> <span>=</span> <span>alloca</span> <span>%struct.foo</span><span>,</span> <span>align</span> <span>8</span> <span>; &#39;foo x&#39;</span>
<span>%3</span> <span>=</span> <span>alloca</span> <span>%struct.foo</span><span>,</span> <span>align</span> <span>8</span> <span>; &#39;foo y&#39;</span>
<span>store</span> <span>i32</span> <span>0</span><span>,</span> <span>i32</span><span>*</span> <span>%1</span><span>,</span> <span>align</span> <span>4</span>
<span>call</span> <span>void</span> <span>@llvm.dbg.declare</span><span>(</span><span>metadata</span> <span>%struct.foo</span><span>*</span> <span>%2</span><span>,</span> <span>metadata</span> <span>!12</span><span>,</span> <span>metadata</span> <span>!DIExpression</span><span>()),</span> <span>!dbg</span> <span>!24</span>
<span>call</span> <span>void</span> <span>@llvm.dbg.declare</span><span>(</span><span>metadata</span> <span>%struct.foo</span><span>*</span> <span>%3</span><span>,</span> <span>metadata</span> <span>!25</span><span>,</span> <span>metadata</span> <span>!DIExpression</span><span>()),</span> <span>!dbg</span> <span>!26</span>
</pre></td></tr></tbody></table></code></pre></div>        </div>

        <p>Following <code>metadata !12</code>, we can see that it accurately describes both <code>x</code> and its type, by way
of subsequent metadata entries:</p>

        <div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre><span>!12</span> <span>=</span> <span>!DILocalVariable</span><span>(</span><span>name:</span> <span>&#34;x&#34;</span><span>,</span> <span>scope:</span> <span>!7</span><span>,</span> <span>file:</span> <span>!8</span><span>,</span> <span>line:</span> <span>13</span><span>,</span> <span>type:</span> <span>!13</span><span>)</span>
<span>!13</span> <span>=</span> <span>!DIDerivedType</span><span>(</span><span>tag:</span> <span>DW_TAG_typedef</span><span>,</span> <span>name:</span> <span>&#34;foo&#34;</span><span>,</span> <span>file:</span> <span>!8</span><span>,</span> <span>line:</span> <span>10</span><span>,</span> <span>baseType:</span> <span>!14</span><span>)</span>
<span>!14</span> <span>=</span> <span>distinct</span> <span>!DICompositeType</span><span>(</span><span>tag:</span> <span>DW_TAG_structure_type</span><span>,</span> <span>file:</span> <span>!8</span><span>,</span> <span>line:</span> <span>4</span><span>,</span> <span>size:</span> <span>128</span><span>,</span> <span>elements:</span> <span>!15</span><span>)</span>
<span>!15</span> <span>=</span> <span>!{</span><span>!16</span><span>,</span> <span>!17</span><span>,</span> <span>!19</span><span>}</span>
<span>!16</span> <span>=</span> <span>!DIDerivedType</span><span>(</span><span>tag:</span> <span>DW_TAG_member</span><span>,</span> <span>name:</span> <span>&#34;x&#34;</span><span>,</span> <span>scope:</span> <span>!14</span><span>,</span> <span>file:</span> <span>!8</span><span>,</span> <span>line:</span> <span>5</span><span>,</span> <span>baseType:</span> <span>!11</span><span>,</span> <span>size:</span> <span>32</span><span>)</span>
<span>!17</span> <span>=</span> <span>!DIDerivedType</span><span>(</span><span>tag:</span> <span>DW_TAG_member</span><span>,</span> <span>name:</span> <span>&#34;y&#34;</span><span>,</span> <span>scope:</span> <span>!14</span><span>,</span> <span>file:</span> <span>!8</span><span>,</span> <span>line:</span> <span>6</span><span>,</span> <span>baseType:</span> <span>!18</span><span>,</span> <span>size:</span> <span>8</span><span>,</span> <span>offset:</span> <span>32</span><span>)</span>
<span>!18</span> <span>=</span> <span>!DIBasicType</span><span>(</span><span>name:</span> <span>&#34;char&#34;</span><span>,</span> <span>size:</span> <span>8</span><span>,</span> <span>encoding:</span> <span>DW_ATE_signed_char</span><span>)</span>
<span>!19</span> <span>=</span> <span>!DIDerivedType</span><span>(</span><span>tag:</span> <span>DW_TAG_member</span><span>,</span> <span>name:</span> <span>&#34;z&#34;</span><span>,</span> <span>scope:</span> <span>!14</span><span>,</span> <span>file:</span> <span>!8</span><span>,</span> <span>line:</span> <span>9</span><span>,</span> <span>baseType:</span> <span>!20</span><span>,</span> <span>size:</span> <span>64</span><span>,</span> <span>offset:</span> <span>64</span><span>)</span>
<span>!20</span> <span>=</span> <span>distinct</span> <span>!DICompositeType</span><span>(</span><span>tag:</span> <span>DW_TAG_structure_type</span><span>,</span> <span>name:</span> <span>&#34;bar&#34;</span><span>,</span> <span>file:</span> <span>!8</span><span>,</span> <span>line:</span> <span>7</span><span>,</span> <span>size:</span> <span>64</span><span>,</span> <span>elements:</span> <span>!21</span><span>)</span>
<span>!21</span> <span>=</span> <span>!{</span><span>!22</span><span>}</span>
<span>!22</span> <span>=</span> <span>!DIDerivedType</span><span>(</span><span>tag:</span> <span>DW_TAG_member</span><span>,</span> <span>name:</span> <span>&#34;z0&#34;</span><span>,</span> <span>scope:</span> <span>!20</span><span>,</span> <span>file:</span> <span>!8</span><span>,</span> <span>line:</span> <span>8</span><span>,</span> <span>baseType:</span> <span>!23</span><span>,</span> <span>size:</span> <span>64</span><span>)</span>
<span>!23</span> <span>=</span> <span>!DIBasicType</span><span>(</span><span>name:</span> <span>&#34;long int&#34;</span><span>,</span> <span>size:</span> <span>64</span><span>,</span> <span>encoding:</span> <span>DW_ATE_signed</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div>        </div>

        <p>That’s a lot of metadata!</p>
      </li>
      <li>
        <p><em>Optional</em> optimization assistance whose presence or absence <strong>does not</strong> affect
program correctness. When present this metadata can be used to <em>progressively enhance</em>
some optimizations. For example, the
<a href="https://llvm.org/docs/LangRef.html#range-metadata"><code>!range</code></a> metadatum can be attached to a
<code>load</code>, <code>call</code>, or <code>invoke</code> instruction to indicate that the value produced by the instruction
can only be in one of the associated ranges.</p>

        <p>For example, adapted from the LLVM LangRef:</p>

        <div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>; `%a` can only be {0, 1, 3, 4}</span>
<span>%a</span> <span>=</span> <span>load</span> <span>i8</span><span>,</span> <span>i8</span><span>*</span> <span>%x</span><span>,</span> <span>align</span> <span>1</span><span>,</span> <span>!range</span> <span>!0</span>

<span>; ... snip ...</span>

<span>; valid ranges: [0, 2), [3, 5)</span>
<span>!0</span> <span>=</span> <span>!{</span> <span>i8</span> <span>0</span><span>,</span> <span>i8</span> <span>2</span><span>,</span> <span>i8</span> <span>3</span><span>,</span> <span>i8</span> <span>5</span> <span>}</span>
</pre></td></tr></tbody></table></code></pre></div>        </div>

        <p>Another great example is <a href="https://llvm.org/docs/LangRef.html#callees-metadata"><code>!callees</code></a>,
which helps LLVM perform
<a href="https://llvm.org/devmtg/2015-10/slides/Baev-IndirectCallPromotion.pdf">indirect call promotion</a>
(which, in turn, decreases pressure on the indirect branch predictor at runtime).</p>
      </li>
    </ul>
  </li>
</ul>

<p>So, to wrap things up: a <strong>correct</strong> bitcode parser needs to <strong>accurately</strong> handle intrinsics and
attributes, while metadata can be more or less ignored until a <del>brave</del> masochistic soul feels the
needs it for their own purposes.</p>

<p>Let’s get to it.</p>

<h2 id="parsing-attributes-from-the-bitcode">Parsing attributes from the bitcode</h2>

<p>For reasons that are unclear to me, LLVM describes <em>all</em> attributes as “parameter attributes”
at the bitcode/bitstream level, even when said attributes refer to entire functions or function
return values. Similarly confusingly, LLVM splits said “parameter attributes” into two separate
bitstream level blocks: <code>PARAMATTR_BLOCK</code> and <code>PARAMATTR_GROUP_BLOCK</code><sup id="fnref:confusing" role="doc-noteref"><a href="#fn:confusing" rel="footnote">6</a></sup>.</p>

<p>The former references the latter (by way of indices), so the latter needs to be parsed first.
As such, we’ll start with it.</p>

<h3 id="paramattr_group_block"><code>PARAMATTR_GROUP_BLOCK</code></h3>

<p>Here’s what LLVM’s bitcode docs
<a href="https://llvm.org/docs/BitCodeFormat.html#paramattr-group-block-contents">have to say</a> about this
block:</p>

<blockquote>
  <p>The <code>PARAMATTR_GROUP_BLOCK</code> block (id 10) contains a table of entries describing the attribute
groups present in the module. These entries can be referenced within <code>PARAMATTR_CODE_ENTRY</code>
entries.</p>
</blockquote>

<p>The <code>PARAMATTR_GROUP_BLOCK</code> block can only contain one kind of record: <code>PARAMATTR_GRP_CODE_ENTRY</code>.
Each <code>PARAMATTR_GRP_CODE_ENTRY</code> record looks like this:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>[ENTRY, grpid, paramidx, attr0, attr1, ...]
</pre></td></tr></tbody></table></code></pre></div></div>

<p>…where <code>grpid</code> is a unique numeric identifier for this group of attributes,
and <code>paramidx</code> identifies one of the following:</p>

<ul>
  <li><code>0</code>: This group contains attributes for the return value (i.e., call-site?<sup id="fnref:ithink" role="doc-noteref"><a href="#fn:ithink" rel="footnote">7</a></sup>) of the
function that references it (by <code>grpid</code>).</li>
  <li><code>0xFFFFFFFF</code>: This group contains attributes for the function itself.</li>
  <li><code>[1, 0xFFFFFFFF)</code>: This group contains attributes for the <code>N</code>th function parameter,
starting at 1.</li>
</ul>

<p>We can represent this with a tidy <code>enum</code> and a total mapping from <code>u32</code>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td><pre><span>#[derive(Clone,</span> <span>Copy,</span> <span>Debug)]</span>
<span>pub</span> <span>enum</span> <span>AttributeGroupDisposition</span> <span>{</span>
    <span>Return</span><span>,</span>
    <span>Parameter</span><span>(</span><span>u32</span><span>),</span>
    <span>Function</span><span>,</span>
<span>}</span>

<span>impl</span> <span>From</span><span>&lt;</span><span>u32</span><span>&gt;</span> <span>for</span> <span>AttributeGroupDisposition</span> <span>{</span>
    <span>fn</span> <span>from</span><span>(</span><span>value</span><span>:</span> <span>u32</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>match</span> <span>value</span> <span>{</span>
            <span>u32</span><span>::</span><span>MAX</span> <span>=&gt;</span> <span>Self</span><span>::</span><span>Function</span><span>,</span>
            <span>0</span> <span>=&gt;</span> <span>Self</span><span>::</span><span>Return</span><span>,</span>
            <span>_</span> <span>=&gt;</span> <span>Self</span><span>::</span><span>Parameter</span><span>(</span><span>value</span><span>),</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><em>(<a href="https://docs.rs/llvm-mapper/0.0.2/llvm_mapper/block/attributes/enum.AttributeGroupDisposition.html">Docs link</a>.)</em></p>

<p>Each <code>attrN</code> has, in turn, even more internal structure:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>{ kind, key [, ...], [value [, ...]] }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>…where <code>kind</code> indicates the layout of <code>key</code> and <code>value</code>:</p>

<ul>
  <li><code>0</code>: <code>key</code> is an integer indicating a “well-known” attribute, such as <code>noalias</code> (<code>9</code>).
These are sometimes referred to as “enum attributes” in the LLVM source code.
These attributes have no associated value — all necessary information is
wholly present in the key itself.</li>
  <li><code>1</code>: <code>key</code> is an integer indicating a “well-known” attribute, and <code>value</code> is
<em>also</em> an integer, representing a value associated with the attribute.
For example, <code>dereferenceable(&lt;n&gt;)</code> (<code>41</code>) takes <code>&lt;n&gt;</code> via the <code>value</code> field,
which in turn represents the address space that the <code>dereferenceable</code> attribute
applies to.</li>
  <li>
    <p><code>3</code>: <code>key</code> is a null-terminated string, indicating a <strong>not</strong> well-known “string” attribute.
This string can be free-form and isn’t accompanied by a value. The absence of well-known
string attributes means that there’s no single source of truth for values that are understood
by various parts of LLVM. That being said, passing <code>-fsplit-stack</code> on <code>clang</code> 13 seems to
reliably introduce the <code>&#34;split-stack&#34;</code> string attribute to any function that <strong>isn’t</strong>
marked with <code>__attribute__((no_split_stack))</code>:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>define</span> <span>dso_local</span> <span>i32</span> <span>@main</span><span>()</span> <span>#2</span> <span>!dbg</span> <span>!9</span> <span>{</span>
  <span>; ... snip ...</span>
<span>}</span>

<span>; ... snip ...</span>
<span>attributes</span> <span>#2</span> <span>=</span> <span>{</span> <span>noinline</span> <span>nounwind</span> <span>optnone</span> <span>uwtable</span> <span>&#34;split-stack&#34;</span> <span>}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p><em>(View it on <a href="https://godbolt.org/z/zWTab9e3h">Godbolt</a>.)</em></p>
  </li>
  <li>
    <p><code>4</code>: <code>key</code> is a null-terminated string, and <code>value</code> is <em>also</em> a null-terminated string.
Like with the key-only variant, neither string is well-known and both are free-form.
These are comparatively common, and we can see LLVM translate C-level <code>__attribute__</code>s
to them:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>__attribute__</span><span>((</span><span>__target__</span><span>(</span><span>&#34;sse4.2&#34;</span><span>)))</span> <span>int</span> <span>add1</span><span>(</span><span>int</span> <span>x</span><span>,</span> <span>int</span> <span>y</span><span>);</span>
<span>__attribute__</span><span>((</span><span>__target__</span><span>(</span><span>&#34;sse4.1&#34;</span><span>)))</span> <span>int</span> <span>add2</span><span>(</span><span>int</span> <span>x</span><span>,</span> <span>int</span> <span>y</span><span>);</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>These become (simplified):</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>attributes</span> <span>#0</span> <span>=</span> <span>{</span> <span>&#34;target-features&#34;</span><span>=</span><span>&#34;+cx8,+fxsr,+mmx,+popcnt,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87&#34;</span> <span>}</span>
<span>attributes</span> <span>#2</span> <span>=</span> <span>{</span> <span>&#34;target-features&#34;</span><span>=</span><span>&#34;+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&#34;</span> <span>}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p><em>(View it on <a href="https://godbolt.org/z/5xPd1xavd">Godbolt</a>.)</em></p>

    <p>Observe that <code>#2</code> doesn’t include <code>sse4.2</code> in its <code>target-features</code> value, since we’ve capped it
at <code>sse4.1</code>.</p>
  </li>
</ul>

<p>The astute will notice that <code>kind=2</code> isn’t specified. Why? Beats me<sup id="fnref:mystery" role="doc-noteref"><a href="#fn:mystery" rel="footnote">8</a></sup>!</p>

<p>Once again, we can model this with a relatively tidy <code>enum</code>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>// Each variant&#39;s value is exhaustively enumerated in turn, where possible.</span>
<span>// For example, `EnumAttribute` is not just a `u32` newtype but an exhaustive</span>
<span>// `enum` of all currently known &#34;enum&#34;-kinded LLVM attributes.</span>
<span>pub</span> <span>enum</span> <span>Attribute</span> <span>{</span>
    <span>Enum</span><span>(</span><span>EnumAttribute</span><span>),</span>
    <span>Int</span><span>(</span><span>IntAttribute</span><span>),</span>
    <span>Str</span><span>(</span><span>String</span><span>),</span>
    <span>StrKeyValue</span><span>(</span><span>String</span><span>,</span> <span>String</span><span>),</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><em>(<a href="https://docs.rs/llvm-mapper/0.0.2/llvm_mapper/block/attributes/enum.Attribute.html">Docs link</a>.)</em></p>

<p>…and to tie it all together, our model for each “attribute group” in <code>PARAMATTR_GROUP_BLOCK</code>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>#[derive(Clone,</span> <span>Debug)]</span>
<span>pub</span> <span>struct</span> <span>AttributeGroup</span> <span>{</span>
    <span>disposition</span><span>:</span> <span>AttributeGroupDisposition</span><span>,</span>
    <span>attributes</span><span>:</span> <span>Vec</span><span>&lt;</span><span>Attribute</span><span>&gt;</span><span>,</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><em>(<a href="https://docs.rs/llvm-mapper/0.0.2/llvm_mapper/block/attributes/struct.AttributeGroup.html">Docs link</a>.)</em></p>

<p>And our parsing procedure <code>PARAMATTR_GROUP_BLOCK</code>:</p>

<ol>
  <li>Create an initial mapping of <code>grpid -&gt; AttributeGroup</code></li>
  <li>For each <code>PARAMATTR_GRP_CODE_ENTRY</code> in <code>PARAMATTR_GROUP_BLOCK</code>:
    <ol>
      <li>Extract the <code>grpid</code> and <code>paramidx</code> fields, which are always present and are always
the first two in the record. Convert the <code>paramidx</code> into its corresponding
<code>AttributeGroupDisposition</code>.</li>
      <li>Initialize <code>fieldidx</code> as <code>2</code>, indicating that we’ve already
consumed <code>grpid</code> and <code>paramidx</code>.</li>
      <li>Parse <code>Attribute</code>s from the record using the <code>kind</code> rules above, starting at <code>fieldidx</code> and
increasing <code>fieldidx</code> by the number of record fields consumed at each parse step.
Complete when <code>fieldidx == record.fields().len()</code>.</li>
      <li>Construct a new <code>AttributeGroup</code> whose disposition and attributes are those just parsed.</li>
      <li>Add the new <code>grpid</code> and <code>AttributeGroup</code> to the mapping</li>
    </ol>
  </li>
</ol>

<p>…and here’s what that looks like, in Rust:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td><pre><span>impl</span> <span>IrBlock</span> <span>for</span> <span>AttributeGroups</span> <span>{</span>
    <span>const</span> <span>BLOCK_ID</span><span>:</span> <span>IrBlockId</span> <span>=</span> <span>IrBlockId</span><span>::</span><span>ParamAttrGroup</span><span>;</span>

    <span>fn</span> <span>try_map_inner</span><span>(</span><span>block</span><span>:</span> <span>&amp;</span><span>UnrolledBlock</span><span>,</span> <span>_</span><span>ctx</span><span>:</span> <span>&amp;</span><span>mut</span> <span>MapCtx</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Self</span><span>,</span> <span>BlockMapError</span><span>&gt;</span> <span>{</span>
        <span>let</span> <span>mut</span> <span>groups</span> <span>=</span> <span>HashMap</span><span>::</span><span>new</span><span>();</span>

        <span>for</span> <span>record</span> <span>in</span> <span>block</span><span>.all_records</span><span>()</span> <span>{</span>
            <span>let</span> <span>code</span> <span>=</span> <span>AttributeCode</span><span>::</span><span>try_from</span><span>(</span><span>record</span><span>.code</span><span>())</span><span>.map_err</span><span>(</span><span>AttributeError</span><span>::</span><span>from</span><span>)</span><span>?</span><span>;</span>

            <span>if</span> <span>code</span> <span>!=</span> <span>AttributeCode</span><span>::</span><span>GroupCodeEntry</span> <span>{</span>
                <span>return</span> <span>Err</span><span>(</span><span>AttributeError</span><span>::</span><span>WrongBlock</span><span>(</span><span>code</span><span>)</span><span>.into</span><span>());</span>
            <span>}</span>

            <span>if</span> <span>record</span><span>.fields</span><span>()</span><span>.len</span><span>()</span> <span>&lt;</span> <span>3</span> <span>{</span>
                <span>return</span> <span>Err</span><span>(</span><span>RecordMapError</span><span>::</span><span>BadRecordLayout</span><span>(</span><span>format!</span><span>(</span>
                    <span>&#34;too few fields in {:?}, expected {} &gt;= 3&#34;</span><span>,</span>
                    <span>code</span><span>,</span>
                    <span>record</span><span>.fields</span><span>()</span><span>.len</span><span>()</span>
                <span>))</span>
                <span>.into</span><span>());</span>
            <span>}</span>

            <span>let</span> <span>group_id</span> <span>=</span> <span>record</span><span>.fields</span><span>()[</span><span>0</span><span>]</span> <span>as</span> <span>u32</span><span>;</span>
            <span>let</span> <span>disposition</span><span>:</span> <span>AttributeGroupDisposition</span> <span>=</span> <span>(</span><span>record</span><span>.fields</span><span>()[</span><span>1</span><span>]</span> <span>as</span> <span>u32</span><span>)</span><span>.into</span><span>();</span>

            <span>let</span> <span>mut</span> <span>fieldidx</span> <span>=</span> <span>2</span><span>;</span>
            <span>let</span> <span>mut</span> <span>attributes</span> <span>=</span> <span>vec!</span><span>[];</span>
            <span>while</span> <span>fieldidx</span> <span>&lt;</span> <span>record</span><span>.fields</span><span>()</span><span>.len</span><span>()</span> <span>{</span>
                <span>let</span> <span>(</span><span>count</span><span>,</span> <span>attr</span><span>)</span> <span>=</span> <span>Attribute</span><span>::</span><span>from_record</span><span>(</span><span>fieldidx</span><span>,</span> <span>record</span><span>)</span><span>?</span><span>;</span>
                <span>attributes</span><span>.push</span><span>(</span><span>attr</span><span>);</span>
                <span>fieldidx</span> <span>+=</span> <span>count</span><span>;</span>
            <span>}</span>

            <span>if</span> <span>fieldidx</span> <span>!=</span> <span>record</span><span>.fields</span><span>()</span><span>.len</span><span>()</span> <span>{</span>
                <span>return</span> <span>Err</span><span>(</span><span>RecordMapError</span><span>::</span><span>BadRecordLayout</span><span>(</span><span>format!</span><span>(</span>
                    <span>&#34;under/overconsumed fields in attribute group record ({} fields, {} consumed)&#34;</span><span>,</span>
                    <span>fieldidx</span><span>,</span>
                    <span>record</span><span>.fields</span><span>()</span><span>.len</span><span>(),</span>
                <span>))</span>
                <span>.into</span><span>());</span>
            <span>}</span>

            <span>groups</span><span>.insert</span><span>(</span>
                <span>group_id</span><span>,</span>
                <span>AttributeGroup</span> <span>{</span>
                    <span>disposition</span><span>,</span>
                    <span>attributes</span><span>,</span>
                <span>},</span>
            <span>);</span>
        <span>}</span>

        <span>Ok</span><span>(</span><span>AttributeGroups</span><span>(</span><span>groups</span><span>))</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>That leaves us with the final product of mapping the <code>PARAMATTR_GROUP_BLOCK</code> block: a
mapping of <code>grpid -&gt; AttributeGroup</code>. Let’s see how the <code>PARAMATTR_BLOCK</code> uses this mapping.</p>

<h3 id="paramattr_block"><code>PARAMATTR_BLOCK</code></h3>

<p>The other half of the attributes equation is the <code>PARAMATTR_BLOCK</code> block, which is
<a href="https://llvm.org/docs/BitCodeFormat.html#paramattr-block-contents">documented by LLVM</a> as follows:</p>

<blockquote>
  <p>The <code>PARAMATTR_BLOCK</code> block (id <code>9</code>) contains a table of entries describing the attributes of
function parameters. These entries are referenced by 1-based index in the <code>paramattr</code> field of
module block <code>FUNCTION</code> records, or within the <code>attr</code> field of function block <code>INST_INVOKE</code> and
<code>INST_CALL</code> records.</p>

  <p>Entries within <code>PARAMATTR_BLOCK</code> are constructed to ensure that each is unique (i.e., no two
indices represent equivalent attribute lists).</p>
</blockquote>

<p>There are two valid record codes in the <code>PARAMATTR_BLOCK</code>:</p>

<ul>
  <li>
    <p><code>PARAMATTR_CODE_ENTRY_OLD</code>: This is a legacy record, emitted by LLVM 3.2 and earlier. We don’t
bother handling it, since modern versions of LLVM won’t emit it at all and 3.2 is
<a href="https://lwn.net/Articles/530355/">nearly a decade old at this point</a>. However, for completeness,
it looks like this:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>[ENTRY, paramidx0, attr0, paramidx1, attr1...]
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>Look familiar? That’s because it’s <em>nearly</em> identical to the <code>PARAMATTR_GRP_CODE_ENTRY</code> record format
that we just comprehensively walked through: the only difference is the absence of the “group”
concept. LLVM (presumably) deprecated this format when someone realized that many parameters
and whole functions share entire groups of attributes, allowing for deduplication by referencing
the groups rather than listing all attributes every time.</p>
  </li>
  <li>
    <p><code>PARAMATTR_CODE_ENTRY</code>: This is the referee record mentioned in the <code>PARAMATTR_GROUP_BLOCK</code>
documentation. Each <code>PARAMATTR_CODE_ENTRY</code> looks like this:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>[ENTRY, attrgrp0, attrgrp1, ...]
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>…where <code>attrgrpN</code> is a attribute group index. And the circle is complete: we use our mapping of
the <code>PARAMATTR_GROUP_BLOCK</code> to fetch each list of attributes corresponding to each group index,
and append them all together into one big list of each <code>PARAMATTR_CODE_ENTRY</code>. These lists,
in turn, are referenced by 1-based indices in other blocks and records throughout the bitcode
representation.</p>

    <p>That ends up being nice and simple:</p>

    <div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td><pre><span>impl</span> <span>IrBlock</span> <span>for</span> <span>Attributes</span> <span>{</span>
  <span>const</span> <span>BLOCK_ID</span><span>:</span> <span>IrBlockId</span> <span>=</span> <span>IrBlockId</span><span>::</span><span>ParamAttr</span><span>;</span>

  <span>fn</span> <span>try_map_inner</span><span>(</span><span>block</span><span>:</span> <span>&amp;</span><span>UnrolledBlock</span><span>,</span> <span>ctx</span><span>:</span> <span>&amp;</span><span>mut</span> <span>MapCtx</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Self</span><span>,</span> <span>BlockMapError</span><span>&gt;</span> <span>{</span>
      <span>let</span> <span>mut</span> <span>entries</span> <span>=</span> <span>vec!</span><span>[];</span>

      <span>for</span> <span>record</span> <span>in</span> <span>block</span><span>.all_records</span><span>()</span> <span>{</span>
          <span>let</span> <span>code</span> <span>=</span> <span>AttributeCode</span><span>::</span><span>try_from</span><span>(</span><span>record</span><span>.code</span><span>())</span><span>.map_err</span><span>(</span><span>AttributeError</span><span>::</span><span>from</span><span>)</span><span>?</span><span>;</span>

          <span>match</span> <span>code</span> <span>{</span>
              <span>AttributeCode</span><span>::</span><span>Entry</span> <span>=&gt;</span> <span>{</span>
                  <span>let</span> <span>mut</span> <span>groups</span> <span>=</span> <span>vec!</span><span>[];</span>
                  <span>for</span> <span>group_id</span> <span>in</span> <span>record</span><span>.fields</span><span>()</span> <span>{</span>
                      <span>let</span> <span>group_id</span> <span>=</span> <span>*</span><span>group_id</span> <span>as</span> <span>u32</span><span>;</span>
                      <span>log</span><span>::</span><span>debug!</span><span>(</span><span>&#34;group id: {}&#34;</span><span>,</span> <span>group_id</span><span>);</span>
                      <span>groups</span><span>.push</span><span>(</span>
                          <span>ctx</span><span>.attribute_groups</span><span>()</span><span>?</span>
                              <span>.get</span><span>(</span><span>group_id</span><span>)</span>
                              <span>.ok_or</span><span>(</span><span>AttributeError</span><span>::</span><span>BadAttributeGroup</span><span>(</span><span>group_id</span><span>))</span><span>?</span>
                              <span>.clone</span><span>(),</span>
                      <span>);</span>
                  <span>}</span>
                  <span>entries</span><span>.push</span><span>(</span><span>AttributeEntry</span><span>(</span><span>groups</span><span>));</span>
              <span>}</span>
              <span>AttributeCode</span><span>::</span><span>GroupCodeEntry</span> <span>=&gt;</span> <span>{</span>
                  <span>// This is a valid attribute code, but it isn&#39;t valid in this block.</span>
                  <span>return</span> <span>Err</span><span>(</span><span>AttributeError</span><span>::</span><span>WrongBlock</span><span>(</span><span>code</span><span>)</span><span>.into</span><span>());</span>
              <span>}</span>
              <span>_</span> <span>=&gt;</span> <span>{</span>
                  <span>return</span> <span>Err</span><span>(</span><span>BlockMapError</span><span>::</span><span>Unsupported</span><span>(</span><span>format!</span><span>(</span>
                      <span>&#34;unsupported attribute block code: {:?}&#34;</span><span>,</span>
                      <span>code</span><span>,</span>
                  <span>)))</span>
              <span>}</span>
          <span>}</span>
      <span>}</span>

      <span>Ok</span><span>(</span><span>Attributes</span><span>(</span><span>entries</span><span>))</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<h2 id="takeaways">Takeaways</h2>

<p>Parsing the blocks responsible for LLVM’s attributes was <em>moderately</em> troublesome: nowhere nearly
as annoying as the type table<sup id="fnref:rewrite" role="doc-noteref"><a href="#fn:rewrite" rel="footnote">9</a></sup>, but not as easy as the identification block or the string
table. All told, the current implementation requires
<a href="https://github.com/woodruffw/mollusc/pull/13">slightly under 900 lines of code</a>, much of which
is documentation and <code>enum</code> variants.</p>

<p>The end result of it all can be seen with in the debug logs of the
<a href="https://github.com/woodruffw/mollusc/blob/ece9be0db19d415fdc6e0983c9ce6317d8c957c9/llvm-mapper/examples/unroll-bitstream.rs"><code>unroll-bitstream</code></a>
example provided by the <code>llvm-mapper</code> crate:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>RUST_LOG</span><span>=</span>debug ./target/debug/examples/unroll-bitstream some-input.bc
</pre></td></tr></tbody></table></code></pre></div></div>

<p>…which, amidst a great deal of other output, should yield some messages like this (formatted for readability):</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td><pre>[2021-11-29T06:54:51Z DEBUG llvm_mapper::block::module] attributes:
  Some(Attributes([
    AttributeEntry(
      [
        AttributeGroup {
          disposition: Function,
          attributes: [
            Enum(NoInline),
            Enum(NoUnwind),
            Enum(OptimizeNone),
            Enum(UwTable),
            StrKeyValue(&#34;correctly-rounded-divide-sqrt-fp-math&#34;, &#34;false&#34;),
            StrKeyValue(&#34;disable-tail-calls&#34;, &#34;false&#34;),
            StrKeyValue(&#34;frame-pointer&#34;, &#34;all&#34;),
            StrKeyValue(&#34;less-precise-fpmad&#34;, &#34;false&#34;),
            StrKeyValue(&#34;min-legal-vector-width&#34;, &#34;0&#34;),
            StrKeyValue(&#34;no-infs-fp-math&#34;, &#34;false&#34;),
            StrKeyValue(&#34;no-jump-tables&#34;, &#34;false&#34;),
            StrKeyValue(&#34;no-nans-fp-math&#34;, &#34;false&#34;),
            StrKeyValue(&#34;no-signed-zeros-fp-math&#34;, &#34;false&#34;),
            StrKeyValue(&#34;no-trapping-math&#34;, &#34;false&#34;),
            StrKeyValue(&#34;stack-protector-buffer-size&#34;, &#34;8&#34;),
            StrKeyValue(&#34;target-cpu&#34;, &#34;x86-64&#34;),
            StrKeyValue(&#34;target-features&#34;, &#34;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&#34;),
            StrKeyValue(&#34;unsafe-fp-math&#34;, &#34;false&#34;),
            StrKeyValue(&#34;use-soft-float&#34;, &#34;false&#34;)
          ]
        }
      ]
    )
  ]))
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This information isn’t exposed anywhere in mapped LLVM modules, <em>yet</em>: it’s kept purely as
state within the <a href="https://docs.rs/llvm-mapper/0.0.2/llvm_mapper/map/struct.MapCtx.html"><code>MapCtx</code></a>.
Future mapping work (e.g., for IR-level functions, blocks, instructions, &amp;c) will
access that state to correctly associate themselves with their attributes.</p>

<p>As I’ve said in previous posts: <em>mollusc</em> still has no particular end goal or state
in mind, other than my broad goal of being able to perform <em>some amount</em> of static analysis of
LLVM IR in pure Rust. The <del>beatings</del> development will continue until the <del>masochism</del> curiosity
abates.</p>

<hr/>




<hr/>




  






</div>
  </body>
</html>
