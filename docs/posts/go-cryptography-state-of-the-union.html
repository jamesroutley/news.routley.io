<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://words.filippo.io/2025-state/">Original</a>
    <h1>Go Cryptography State of the Union</h1>
    
    <div id="readability-page-1" class="page"><article>
        <time datetime="2025-11-20">
            20 Nov 2025</time>
        
        <section>
            <!-- buttondown-editor-mode: plaintext -->
<p>This past August, I delivered my traditional <em>Go Cryptography State of the Union</em> talk at <a href="https://www.gophercon.com/">GopherCon US 2025</a> in New York.</p>
<p>It goes into everything that happened at the intersection of Go and cryptography over the last year.</p>
<p>You can watch the video (with manually edited subtitles, for my fellow subtitles enjoyers) or read the transcript below (for my fellow videos not-enjoyers).</p>
<p><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/YnyeAQblUyA?si=lodMeQIkMc8zhRy4" title="YouTube video player" frameborder="0" allow="clipboard-write; encrypted-media; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></p>

<p><em>The annotated transcript below was made with <a href="https://tools.simonwillison.net/annotated-presentations">Simon Willison’s tool</a>. All pictures were taken around Rome, the Italian contryside, and the skies of the Northeastern United States.</em></p>
<h2 id="annotated-transcript">Annotated transcript</h2>
<div id="gcus25slide-01.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/a2094744-c5b9-4301-93d2-61676adee15d.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-01.jpeg">#</a></p><p>Welcome to my annual performance review.</p>
<p>We are going to talk about all of the stuff that we did in the Go cryptography world during the past year.</p>
  </div>
</div>

<div id="gcus25slide-02.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/4ff34dc1-aca8-439e-8fe4-a38237da2855.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-02.jpeg">#</a></p><p>When I say &#34;we,&#34; it doesn&#39;t mean just me, it means me, Roland Shoemaker, Daniel McCarney, Nicola Morino, Damien Neil, and many, many others, both from the Go team and from the Go community that contribute to the cryptography libraries all the time.</p>
<p>I used to do this work at Google, and I now do it as an independent as part of and leading <a href="https://geomys.org">Geomys</a>, but we&#39;ll talk about that later.</p>
  </div>
</div>

<div id="gcus25slide-03.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/f5f10c2b-296f-4375-b71f-2498d5f1a796.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-03.jpeg">#</a></p><p>When we talk about the Go cryptography standard libraries, we talk about all of those packages that you use to build secure applications.</p>
<p>That&#39;s what we make them for. We do it to provide you with encryption and hashes and protocols like TLS and SSH, to <a href="https://golang.org/design/cryptography-principles">help you build secure applications</a>.</p>
  </div>
</div>

<div id="gcus25slide-04.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/d3c5fb80-876c-40e9-85bd-80a23e36e89f.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-04.jpeg">#</a></p><p>The main headlines of the past year:</p>
<p>We shipped post quantum key exchanges, which is something that you will not have to think about and will just be solved for you.</p>
<p>We have solved FIPS 140, which some of you will not care about at all and some of you will be very happy about.</p>
<p>And the thing I&#39;m most proud of: we did all of this while keeping an excellent security track record, year after year.</p>
  </div>
</div>

<div id="gcus25slide-05.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/d722f8d0-f12f-477f-be25-89a7519f1157.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-05.jpeg">#</a></p><p>This is an update to something you&#39;ve seen last year.</p>
<p><a href="https://docs.google.com/spreadsheets/d/1kGwdnqcdfevyhbxVSUbwQTcdrmvrlCZUV4_XMiTn3qQ/view">The Go Security Track Record</a></p>
<p>It&#39;s the list of vulnerabilities in the Go cryptography packages.</p>
<p>We don&#39;t assign a severity—because it&#39;s really hard, instead they&#39;re graded on the &#34;Filippo&#39;s unhappiness score.&#34;</p>
<p>It goes shrug, oof, and ouch.</p>
<p>Time goes from bottom to top, and you can see how as time goes by things have been getting better. People report more things, but they&#39;re generally more often shrugs than oofs and there haven&#39;t been ouches.</p>
  </div>
</div>

<div id="gcus25slide-06.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/f98ececb-4046-471b-ad0a-6ba080c84a33.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-06.jpeg">#</a></p><p>More specifically, we haven&#39;t had any oof since 2023.</p>
<p>We didn&#39;t have any Go-specific oof since 2021.</p>
<p>When I say Go-specific, I mean: well, sometimes the protocol is broken, and as much as we want to also be ahead of that by limiting complexity, you know, sometimes there&#39;s nothing you can do about that.</p>
<p>And <strong>we haven&#39;t had ouches since 2019</strong>. I&#39;m very happy about that.</p>
  </div>
</div>

<div id="gcus25slide-07.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/f679dda9-bc5b-4b2f-9b35-95e97f5bf479.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-07.jpeg">#</a></p><p>But if this sounds a little informal, I&#39;m also happy to report that we had the first security audit by a professional firm.</p>
<p>Trail of Bits looked at all of the nuts and bolts of the Go cryptography standard library: primitives, ciphers, hashes, assembly implementations. They didn&#39;t look at the protocols, which is a lot more code on top of that, but they did look at all of the foundational stuff.</p>
<p>And I&#39;m happy to say that <a href="https://go.dev/blog/tob-crypto-audit">they found <em>nothing</em></a>.</p>
<p><img loading="lazy" src="https://assets.buttondown.email/images/4bd5e6be-7100-41dc-be9c-00161a1a0b78.jpeg" alt="Roland and I showing off I SURVIVED TRAIL OF BITS t-shirts"/></p><p>Two of a kind t-shirts, for me and Roland Shoemaker.</p>
  </div>
</div>

<div id="gcus25slide-08.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/468319e9-3f62-425b-ac8a-a5e32771c3a6.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-08.jpeg">#</a></p><p>It is easy though to maintain a good security track record if you never add anything, so let&#39;s talk about the code we did add instead.</p>
<p>First of all, post-quantum key exchanges.</p>
<p>We talked about post-quantum last year, but as a very quick refresher:</p>
<ul>
<li>Post-quantum cryptography is about the future. We are worried about quantum computers that might exist… 5-50 (it&#39;s a hell of a range) years from now, and that might break all of asymmetrical encryption. (Digital signatures and key exchanges.)</li>
<li>Post-quantum cryptography runs on classical computers. It&#39;s cryptography that we can do now that resists future quantum computers.</li>
<li>Post-quantum cryptography is fast, actually. If you were convinced that for some reason it was slow, that&#39;s a common misconception.</li>
<li>However, post-quantum cryptography is large. Which means that we have to send a lot more bytes on the wire to get the same results.</li>
</ul>
<p>Now, we focused on post-quantum key exchange because the key exchange defends against the most urgent risk, which is that somebody might be recording connections today, keeping them saved on some storage for the next 5-50 years and then use the future quantum computers to decrypt those sessions.</p>
  </div>
</div>

<div id="gcus25slide-09.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/f671c289-0e63-47ca-a4e6-6711cb48fe7a.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-09.jpeg">#</a></p><p>I&#39;m happy to report that we now have ML-KEM, which is the post-quantum key exchange algorithm selected by the NIST competition, an international competition run in the open.</p>
<p>You can use it directly from the <a href="https://pkg.go.dev/crypto/mlkem">crypto/mlkem</a> standard library package starting in Go 1.24, but you&#39;re probably not gonna do that.</p>
  </div>
</div>

<div id="gcus25slide-10.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/8ad85b47-a2eb-4de2-8e5d-0f5c29ab8613.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-10.jpeg">#</a></p><p>Instead, you&#39;re probably going to just use crypto/tls, which by default now uses a hybrid of X25519 and ML-KEM-768 for all connections with other systems that support it.</p>
<p>Why hybrid? Because this is new cryptography. So we are still <em>a little</em> worried that somebody might break it.</p>
<p>There was one that looked very good and had very small ciphertext, and we were all like, “yes, yes, that&#39;s good, that&#39;s good.” And then somebody broke it on a laptop. It was very annoying.</p>
<p>We&#39;re fairly confident in lattices. We think this is the good one. But still, we are taking both the old stuff and the new stuff, hashing them together, and unless you have both a quantum computer to break the old stuff and a mathematician who broke the new stuff, you&#39;re not breaking the connection.</p>
<p>crypto/tls can now negotiate that with Chrome and can negotiate that with other Go 1.24+ applications.</p>
<p>Not only that, we also removed any choice you had in ordering of key exchanges because we think we know better than you and— that didn&#39;t come out right, uh.</p>
<p>… because we assume that you actually want us to make those kind of decisions, so as long as you don&#39;t turn it off, we will default to post-quantum.</p>
<p>You can still turn it off. But as long as you don&#39;t turn it off, we&#39;ll default to the post-quantum stuff to keep your connection safe from the future.</p>
  </div>
</div>

<div id="gcus25slide-11.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/a6fd1a9c-1ca9-4db3-b3aa-72b18cbae064.jpeg"/></p>
</div>

<div id="gcus25slide-12.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/bdc8faee-11fb-4d5d-9127-17ba3ea63885.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-12.jpeg">#</a></p><p>Okay, but you said key exchanges <em>and digital signatures</em> are broken. What about the latter?</p>
<p>Well, key exchanges are urgent because of the record-now-decrypt-later problem, but unless the physicists that are developing quantum computers also develop a time machine, they can&#39;t use the QC to go back in time and use a fake signature today. So if you&#39;re verifying a signature today, I promise you it&#39;s not forged by a quantum computer.</p>
<p>We have a lot more time to figure out post-quantum digital signatures. But if we can, why should we not start now? Well, it&#39;s different. Key exchange, we knew what hit we had to take. You have to do a key exchange, you have to do it when you start the connection, and ML-KEM is the algorithm we have, so we&#39;re gonna use it.</p>
<p>Signatures, we developed a lot of protocols like TLS, SSH, back when it was a lot cheaper to put signatures on the wire. When you connect to a website right now, you get five signatures. We can&#39;t send you five 2KB blobs every time you connect to a website. So we are waiting to give time to protocols to evolve, to redesign things with the new trade-offs in mind of signatures not being cheap.</p>
<p>We are kind of slow rolling intentionally the digital signature side because it&#39;s both not as urgent and not as ready to deploy. We can&#39;t do the same “ta-da, it&#39;s solved for you” show because signatures are much harder to roll out.</p>
  </div>
</div>

<div id="gcus25slide-13.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/ca63bc57-db68-445c-9b6f-ad36017e24db.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-13.jpeg">#</a></p><p>Let&#39;s talk about another thing that I had mentioned last year, which is FIPS 140.</p>
<p>FIPS 140 is a US government regulation for how to do cryptography. It is a list of algorithms, but it&#39;s not just a list of algorithms. It&#39;s also a list of rules that the modules have to follow.</p>
<p>What is a module?</p>
<p>Well, a module used to be a thing you would rack. All the rules are based on the idea that it&#39;s a thing you can rack. Then the auditor can ask “what is the module’s boundary?” And you&#39;re like, “this shiny metal box over here.&#34; And, you know, that works.</p>
<p>When people ask those questions of libraries, though, I do get a little mad every time. Like, what are the data input ports of your library? Ports. Okay.</p>
<p>Anyway, it&#39;s an interesting thing to work with.</p>
  </div>
</div>

<div id="gcus25slide-14.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/11f1a65e-1391-4927-9c0b-3038d952fc9b.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-14.jpeg">#</a></p><p>To comply with FIPS 140 in Go, up to now, you had to use an <u>unsupported</u> GOEXPERIMENT, which would replace all of the Go cryptography standard library, all of the stuff I&#39;m excited about, with the BoringCrypto module, which is a FIPS 140 module developed by the BoringSSL folks. We love the BoringSSL folks, but that means using cgo, and we do not love cgo. It has memory safety issues, it makes cross-compilation difficult, it’s not very fast.</p>
<p>Moreover, the list of algorithms and platforms of BoringCrypto is tailored to the needs of BoringSSL and not to the needs of the Go community, and their development cycle doesn&#39;t match our development cycle: we don&#39;t decide when that module gets validated.</p>
<p>Speaking of memory safety, I lied a little. Trail of Bits did find one vulnerability. They found it in Go+BoringCrypto, which was yet another reason to try to push away from it.</p>
  </div>
</div>

<div id="gcus25slide-15.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/871c48ee-5a50-4c7b-a67d-430aa00442a8.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-15.jpeg">#</a></p><p>Instead, we&#39;ve got now the FIPS 140-3 Go Cryptographic Module.</p>
<p>Not only is it native Go, it&#39;s actually just a different name for the internal Go packages that all the regular Go cryptography package use for the FIPS 140 algorithms. We just moved them into their own little bubble so that when they ask us “what is the module boundary” we can point at those packages.</p>
<p>Then there&#39;s a runtime mode which enables some of the self-tests and slow stuff that you need for compliance. It also tells crypto/tls not to negotiate stuff that&#39;s not FIPS, but aside from that, it doesn&#39;t change any observable behavior.</p>
<p>We managed to keep everything working exactly the same: you don&#39;t import a different package, you don&#39;t do anything different, your applications just keep working the same way. We&#39;re very happy about that.</p>
<p>Finally, you can at compile time select a GOFIPS140 frozen module, which is just a zip file of the source of the module as it was back when we submitted it for validation, which is a compliance requirement sometimes.</p>
<p>By the way, that means we have to be forward compatible with future versions of Go, even for internal packages, which was a little spicy.</p>
<p>You can read more in <a href="https://go.dev/doc/security/fips140">the upstream FIPS 140-3 docs</a>.</p>
  </div>
</div>

<div id="gcus25slide-16.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/09841e7b-98cc-4999-a035-0a378f92d8cc.jpeg"/></p>
</div>

<div id="gcus25slide-17.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/5c72c810-d813-45aa-93bf-7945ac75c641.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-17.jpeg">#</a></p><p>But that&#39;s not enough.</p>
<p>Even if you use a FIFS 140 algorithm from a FIPS 140 module that was tested for the algorithm it&#39;s still not enough because it has to run on a platform that was tested as part of the validation.</p>
<p>So we tested on a lot of platforms.</p>
<p>Some of them were paid for by various Fortune 100s that had an interest in them getting tested, but some of them had no sponsors.</p>
<p>We really wanted to solve this problem for everyone, once and for all, so Geomys just paid for all the FreeBSD, macOS, even Windows testing so that we could say “run it on whatever and it&#39;s probably going to be compliant.” (Don&#39;t quote me on that.)</p>
  </div>
</div>

<div id="gcus25slide-18.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/dbeb62fc-9905-4065-9750-56216679de00.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-18.jpeg">#</a></p><p>How did we test on that many machines? Well, you know, we have this sophisticated data center…</p>
<p>Um, no. No, no.</p>
<p>I got a bunch of stuff shipped to my place.</p>
<p>That&#39;s my NAS now. It&#39;s an Ampere Altra Q64-22, sixty-four arm64 cores, and yep, it&#39;s my NAS.</p>
  </div>
</div>

<div id="gcus25slide-19.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/c3876169-67a8-42fa-80d3-db5fc70d06c5.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-19.jpeg">#</a></p><p>Then I tested it on, you know, this sophisticated arm64 macOS testing platform.</p>
  </div>
</div>

<div id="gcus25slide-20.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/a9476420-943e-4646-9496-95a4cd9fa88f.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-20.jpeg">#</a></p><p>And then on the Windows one, which is my girlfriend&#39;s laptop.</p>
  </div>
</div>

<div id="gcus25slide-21.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/7a5a3129-c11e-4b38-8fb7-343d3b630e9f.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-21.jpeg">#</a></p><p>And then the arm one, which was my router.</p>
<p>Apparently I own an EdgeRouter now? It&#39;s sitting in the data center which is totally not my kitchen.</p>
  </div>
</div>

<div id="gcus25slide-22.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/02926300-11b9-4b3f-9fab-24db8ea918b7.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-22.jpeg">#</a></p><p>It was all a very serious and regimented thing, and all of it is actually recorded, in recorded sessions with the accredited laboratories, so all this is now on file with the US government.</p>
  </div>
</div>

<div id="gcus25slide-23.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/8107ac02-ed1c-40a3-a352-7eafa451f2a3.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-23.jpeg">#</a></p><p>You might or might not be surprised to hear that the easiest way to meet the FIPS 140 requirements is not to exceed them.</p>
<p>That&#39;s annoying and a problem of FIPS 140 in general: if you do what everybody else does, which is just clearing the bar, nobody will ask questions, so there’s a strong temptation to lower security in FIPS 140 mode.</p>
<p>We just refused to accept that. Instead, we figured out complex stratagems.</p>
  </div>
</div>

<div id="gcus25slide-24.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/dc633b91-8702-40c2-ade3-503bf0587835.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-24.jpeg">#</a></p><p>For example, for randomness, the safest thing to do is to just take randomness from the kernel every time you need it. The kernel knows if a virtual machine was just cloned and we don&#39;t, so we risk generating the same random bytes twice.</p>
<p>But NIST will not allow that. You need to follow a bunch of standards for how the randomness is generated, and the kernel doesn’t.</p>
<p>So what we do is we do everything that NIST asks and then every time you ask for randomness, we squirrel off, go to the kernel, get a little piece of extra entropy, stir it into the pot before giving back the result, and give back the result.</p>
<p>It&#39;s still NIST compliant because it&#39;s as strong as both the NIST and the kernel solution, but it took some significant effort to <em>show</em> it is compliant.</p>
  </div>
</div>

<div id="gcus25slide-25.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/fb1bbd22-5578-4cd4-b211-e3c0f65f5915.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-25.jpeg">#</a></p><p>We did the same for ECDSA.</p>
<p>ECDSA is a digital signature mechanism. We&#39;ve talked about it a few other times. It&#39;s just a way to take a message and a private key and generate a signature, here <em>(s, r)</em>.</p>
<p>To make a signature, you also need a random number, and that number must be used only once with the same private key. You cannot reuse it. That number is k here.</p>
<p>Why can you not reuse it? Because if you reuse it, then you can do this fun algebra thing and then <em>pop</em> the private key falls out by just smashing two signatures together. Bad, really, really bad.</p>
  </div>
</div>

<div id="gcus25slide-26.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/a7accf6e-1e5c-4e83-852b-0bae07291308.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-26.jpeg">#</a></p><p>How do we generate this number that must never be the same?</p>
<p>Well, one option is we make it random.</p>
<p>But what if your random number generator breaks and generates twice the same random number? That would leak the private key, and that would be bad.</p>
<p>So the community came up with <a href="https://www.rfc-editor.org/rfc/rfc6979">deterministic ECDSA</a>. Instead of generating the nonce at random, we are going to hash the message and the private key.</p>
<p>This is still actually a little risky though, because if there&#39;s a <a href="https://en.wikipedia.org/wiki/Differential_fault_analysis">fault in the CPU</a>, for example, or a bug, because <a href="https://github.com/MystenLabs/ed25519-unsafe-libs">for example you&#39;re taking the wrong inputs</a>, you might still end up generating the same value but signing a slightly different message.</p>
<p>How do we mitigate both of those? We do both.</p>
<p>We take some randomness and the private key and the message, we hash them all together, and now it&#39;s really, really hard for the number to come out the same. That&#39;s called hedged ECDSA.</p>
<p>The Go crypto library <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.0:src/crypto/ecdsa/ecdsa.go;l=417">has been doing hedged ECDSA from way before it was called hedged and way before I was on the team</a>.</p>
<p>Except… random ECDSA has always been FIPS. Deterministic ECDSA has been FIPS since a couple years ago. Hedged ECDSA is technically not FIPS.</p>
  </div>
</div>

<div id="gcus25slide-27.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/1b7bb197-d2e9-40b7-ad41-5d06b7518ab1.jpeg"/></p>
</div>

<div id="gcus25slide-28.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/22896b4e-83c7-4311-9e6a-b5efa4ce3f99.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-28.jpeg">#</a></p><p>We basically just figured out a way to claim it was fine and the lab eventually said &#34;okay, shut up.&#34; I&#39;m very proud of that one.</p>
<p>If you want to read more about this, check out <a href="https://go.dev/blog/fips140">the announcement blog post</a>.</p>
<p>If you know you need commercial services for FIPS 140, here’s <a href="https://geomys.org/fips140">Geomys FIPS 140 commercial services page</a>. If you don&#39;t know if you need them, you actually probably don&#39;t. It&#39;s fine, the standard library will probably solve this for you now.</p>
  </div>
</div>

<div id="gcus25slide-30.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/8a3d85b8-1eee-431e-b772-15285509c607.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-30.jpeg">#</a></p><p>Okay, but who cares about this FIPS 140 stuff?</p>
<p>&#34;Dude, we&#39;ve been talking about FIPS 140 for 10 minutes and I don&#39;t care about that.&#34;</p>
  </div>
</div>

<div id="gcus25slide-31.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/5e54bc8f-7b28-4ffd-9336-03e814cb2373.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-31.jpeg">#</a></p><p>Well, I care because I spent my last year on it and that apparently made me the top committer for the cycle to the Go repo and that&#39;s mostly FIPS 140 stuff.</p>
<p>I don&#39;t know how to feel about that.</p>
  </div>
</div>

<div id="gcus25slide-32.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/3c04c383-e856-4874-aeab-ff5ac0b0a0bd.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-32.jpeg">#</a></p><p>There have been actually a lot of positive side effects from the FIPS 140 effort. We took care to make sure that everything that we found we would leave in a better state.</p>
  </div>
</div>

<div id="gcus25slide-33.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/0da7630d-7872-4291-ab39-da857bae9415.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-33.jpeg">#</a></p><p>For example, there are new packages that moved from x/crypto into the standard library: crypto/hkdf, crypto/pbkdf, crypto/sha3.</p>
<p>SHA-3 is faster and doesn&#39;t allocate anymore.</p>
<p>HKDF has a new generic API which lets you pass in a function that returns either a concrete type that implements Hash or a function that returns a Hash interface, which otherwise was a little annoying. (You had to make a little closure.) I like it.</p>
  </div>
</div>

<div id="gcus25slide-34.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/0e624dfe-e578-42c8-a06e-e9419a45a31d.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-34.jpeg">#</a></p><p>We restructured crypto/aes and crypto/cipher and in the process merged a contribution from a community member that made AES-CTR, the counter mode, between 2 and 9 times faster. That was a pretty good result.</p>
<p>The assembly interfaces are much more consistent now.</p>
  </div>
</div>

<div id="gcus25slide-35.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/32a58983-b50e-46f6-af33-82fbeae7f628.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-35.jpeg">#</a></p><p>Finally, we finished cleaning up crypto/rsa.</p>
<p>If you remember from last year, we made the crypto/rsa sign and verify operations not use math/big and use constant time code. Now we also made key generation, validation, and pre-computation all not use math/big.</p>
<p>That loading keys that were serialized to JSON a lot faster, and made key generation much faster. But how much faster?</p>
<p>Benchmarking key generation is really hard because it&#39;s a random process: you take a number random number and you check, is it prime? No. Toss. Is it prime? Nope. Toss. Is it prime?</p>
<p>You keep doing this. If you&#39;re lucky, it’s very fast. If you are unlucky, very slow. It’s a geometric distribution and if you want to average it out, you have to run for hours. Instead, I figured out <a href="https://words.filippo.io/rsa-keygen-bench/">a new way by mathematically deriving the average number of pulls you are supposed to do and preparing a synthetic run that gives exactly the expected mean number of checks, so that we get a representative sample to benchmark deterministically</a>. That was a lot of fun.</p>
<p>Moreover, we detect more broken keys, and we did a rare backwards compatibility break to stop supporting keys smaller than 1024 bits.</p>
<p>1024 is already pretty small, you should be using 2048 minimum, but if you&#39;re using less than 1024, it can be broken on the proverbial laptop. It&#39;s kind of silly that a production library lets you do something so insecure, and you can&#39;t tell them apart just by looking at the code. You have to know what the size of the key is.</p>
<p>So we just took that out.</p>
<p>I expected people to yell at me. Nobody yelled at me. Good job community.</p>
  </div>
</div>

<div id="gcus25slide-36.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/7786bdf8-65ae-4726-8d9e-d63061e5deb2.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-36.jpeg">#</a></p><p>Aside from adding stuff, you know that we are very into testing and that testing is how we keep that security track record that we talked about.</p>
<p>I have one bug in particular that is my white whale.</p>
<p>(You might say, &#34;Filippo, well-adjusted people don&#39;t have white whales.&#34; Well, we learned nothing new, have we?)</p>
<p>My white whale is <a href="https://go.dev/issue/20040">this assembly bug</a> that we found at Cloudflare before I joined the Go team. I spent an afternoon figuring out an exploit for it with Sean Devlin in Paris, while the yellow jackets set fire to cop cars outside. That&#39;s a different story.</p>
<p>It&#39;s an assembly bug where the carry—literally the carry like when you do a pen and paper multiplication—was just not accounted for correctly. You can watch my talk <a href="https://www.youtube.com/watch?v=zPj5tTFDql0"><em>Squeezing a Key through a Carry Bit</em></a> if you are curious to learn more about it.</p>
  </div>
</div>

<div id="gcus25slide-37.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/1b7fed7c-e283-48d0-b1da-8612c21672ee.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-37.jpeg">#</a></p><p>The problem with this stuff is that it&#39;s so hard to get code coverage for it because all the code always runs. It&#39;s just that you don&#39;t know if it always runs with that carry at zero, and if the carry was one, it’d do the wrong math.</p>
<p>I think we&#39;ve cracked it, by using mutation testing.</p>
<p>We have a framework that tells the assembler, &#34;hey, anywhere you see an add-with-carry, replace it with a simple add that discards the carry.&#34; Then we run the tests. If the tests still pass, the test did not cover that carry.</p>
<p>If that happens we fail a meta-test and tell whoever&#39;s sending the CL, “hey, no, no, no, you gotta test that.”</p>
<p>Same for checking the case in which the carry is always set. We replace the add-with-carry with a simple add and then insert a +1.</p>
<p>It&#39;s a little tricky. If you want to read more about it, it&#39;s in <a href="https://words.filippo.io/assembly-mutation/">this blog post</a>. I&#39;m very hopeful that will help us with all this assembly stuff.</p>
  </div>
</div>

<div id="gcus25slide-38.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/3de6c66e-34c3-4b03-a10c-643934e4e6d7.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-38.jpeg">#</a></p><p>Next, <a href="https://words.filippo.io/accumulated/">accumulated test vectors</a>.</p>
<p>This is a little trick that I&#39;m very very fond of.</p>
<p>Say you want to test a very large space. For example there are two inputs and they can both be 0 to 200 bytes long, and you want to test all the size combinations.</p>
<p>That would be a lot of test vectors, right?</p>
<p>If I checked in a megabyte of test vectors every time I wanted to do that, people eventually would yell at me.</p>
<p>Instead what we do is run the algorithm with each size combination, and take the result and we put it inside a rolling hash. Then at the end we take the hash result and we check that it comes out right.</p>
<p>We do this with two implementations. If it comes out to the same hash, great. If it comes out not to the same hash, it doesn&#39;t help you figure out what the bug is, but it tells you there&#39;s a bug. I&#39;ll take it.</p>
  </div>
</div>

<div id="gcus25slide-39.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/eaf0ae79-7259-4b07-9999-11f6be39fd28.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-39.jpeg">#</a></p><p>We really like reusing other people&#39;s tests. We&#39;re lazy.</p>
<p>The BoringSSL people have a fantastic suite of tests for TLS called BoGo and Daniel has been doing fantastic work integrating that and making crypto/tls stricter and stricter in the process.</p>
<p>It&#39;s now much more spec compliant on the little things where it goes like, “no, no, no, you&#39;re not allowed to put a zero here” and so on.</p>
<p>Then, the Let&#39;s Encrypt people have a test tool for the ACME protocol called Pebble. (Because it&#39;s a small version of their production system called Boulder! It took me a long time to figure it out and eventually I was like ooooohhh.)</p>
<p>Finally, NIST has this X.509 interoperability test suite, which just doesn&#39;t have a good name. It&#39;s good though.</p>
  </div>
</div>

<div id="gcus25slide-40.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/bd1d65ba-8eed-48a4-9af2-19d0fa47e41c.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-40.jpeg">#</a></p><p>More assembly cleanups.</p>
<p>There used to be places in assembly where—as if assembly was not complicated enough—instructions were just written down as raw machine code.</p>
<p>Sometimes even the comment was wrong! Can you tell the comment changed in that patch? This is a thing Roland and Joel found.</p>
<p>Now there&#39;s a test that will just yell at you if you try to commit a <code>WORD</code> or <code>BYTE</code> instruction.</p>
<p>We also removed all the assembly that was specifically there for speeding up stuff on CPUs that don&#39;t have AVX2. AVX2 came out in 2015 and if you want to go fast, you&#39;re probably not using the CPU generation from back then. We still run on it, just not as fast.</p>
  </div>
</div>

<div id="gcus25slide-42.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/1eec9761-54ca-4d45-9c69-c8f293a20b3e.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-42.jpeg">#</a></p><p>More landings! I’m going to speed through these ones.</p>
<p>This is all stuff that we talked about last year and that we actually landed.</p>
<p>Stuff like <a href="https://pkg.go.dev/crypto/subtle#WithDataIndependentTiming">data independent timing</a> to tell the CPU, &#34;no, no, I actually did mean for you to do that in constant time, goddammit.&#34;</p>
<p>And server-side TLS Encrypted Client Hello, which is a privacy improvement. We had client side, now we have server side.</p>
<p>crypto/rand.Read never fails. We promised that, we did that.</p>
<p>Now, do you know how hard it is to test the failure case of something that never fails? I had to re-implement the seccomp library to tell the kernel to break the getrandom syscall to check what happens when it doesn’t work. There are <a href="https://go-review.googlesource.com/c/go/+/608175">tests all pointing guns at each other</a> to make sure the fallback both works and is never hit unexpectedly.</p>
<p>It&#39;s also much faster now because Jason Donenfeld added the Linux getrandom VDSO.</p>
<p>Sean Liao added rand.Text like we promised.</p>
  </div>
</div>

<div id="gcus25slide-43.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/8d1ab144-726f-4906-88aa-5034cd5bf332.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-43.jpeg">#</a></p><p>Then more stuff like <a href="https://pkg.go.dev/hash#Cloner">hash.Cloner</a>, which I think makes a lot of things a little easier, and more and more and more and more. The <a href="https://go.dev/doc/go1.24">Go 1.24</a> and <a href="https://go.dev/doc/go1.25">Go 1.25</a> release notes are there for you.</p>
  </div>
</div>

<div id="gcus25slide-44.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/3cb23b48-553e-4ea2-bb59-90ba06f05efa.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-44.jpeg">#</a></p><p>x/crypto/ssh is also under our maintenance and some excellent stuff happened there, too.</p>
<p>Better tests, better error messages, better compatibility, and we&#39;re working on <a href="https://go.dev/doc/go1.24">some v2 APIs</a>. If you have opinions, it’s time to come to those issues to talk about them!</p>
  </div>
</div>

<div id="gcus25slide-45.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/78526952-b6d5-4fe2-a69f-8a7c546f303a.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-45.jpeg">#</a></p><p>It’s been an exciting year, and I&#39;m going to give you just two samples of things we&#39;re planning to do for the next year.</p>
  </div>
</div>

<div id="gcus25slide-46.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/59fb818a-4b38-4bd0-a6c8-69a0ee9393a4.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-46.jpeg">#</a></p><p>One is TLS profiles.</p>
<p>Approximately no one wants to specifically configure the fifteen different knobs of a TLS library.</p>
<p>Approximately no one—because I know there are some people who do and they yell at me regularly.</p>
<p>But instead most people just want &#34;hey, make it broadly compatible.&#34; &#34;Hey, make it FIPS compliant.&#34; &#34;Hey, make it modern.&#34;</p>
<p>We&#39;re looking for a way to make it easy to just say what your goal is, and then we do all the configuration for you in a way that makes sense and that evolves with time.</p>
<p>I&#39;m excited about this one.</p>
  </div>
</div>

<div id="gcus25slide-47.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/80d7540d-9cce-49e4-ad47-81435399dfa1.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-47.jpeg">#</a></p><p>And maybe something with passkeys? If you run websites that authenticate users a bunch with password hashes and maybe also with WebAuthN, find me, email us, we want feedback.</p>
<p>We want to figure out what to build here, into the standard library.</p>
  </div>
</div>

<div id="gcus25slide-48.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/ed4069df-2f3e-4415-89bf-87a67d884f1e.jpeg"/></p>
</div>

<div id="gcus25slide-49.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/a557a17f-a730-4804-800d-a3791b582a83.jpeg"/></p><div>
  <p><a href="https://words.filippo.io/2025-state/#gcus25slide-49.jpeg">#</a></p><p>The best FIPS 140 side effect has been that we have a new maintainer.</p>
<p>Daniel McCarney joined us to help with the FIPS effort and then we were working very well together so Geomys decided to just take him on as a permanent maintainer on the Go crypto maintenance team. I’m very excited about that.</p>
  </div>
</div>

<div id="gcus25slide-50.jpeg">
  <p><img loading="lazy" src="https://assets.buttondown.email/images/d0255ebb-9e0b-4e01-9cb5-bfd56f1b7c14.jpeg"/></p>
</div>

<p><img loading="lazy" src="https://assets.buttondown.email/images/05d17f03-28b4-4479-a658-c915f98fdd20.jpeg"/>
</p>

<hr/>
<p>My work is made possible by <a href="https://geomys.org">Geomys</a>, an organization of professional Go maintainers, which is funded by <a href="https://smallstep.com/">Smallstep</a>, <a href="https://www.avalabs.org/">Ava Labs</a>, <a href="https://goteleport.com/">Teleport</a>, <a href="https://tailscale.com/">Tailscale</a>, and <a href="https://sentry.io/">Sentry</a>. Through our retainer contracts they ensure the sustainability and reliability of our open source maintenance work and get a direct line to my expertise and that of the other Geomys maintainers. (Learn more in the <a href="https://words.filippo.io/geomys">Geomys announcement</a>.)
Here are a few words from some of them!</p>
<p>Teleport — For the past five years, attacks and compromises have been shifting from traditional malware and security breaches to identifying and compromising valid user accounts and credentials with social engineering, credential theft, or phishing. <a href="https://goteleport.com/platform/identity/?utm=filippo">Teleport Identity</a> is designed to eliminate weak access patterns through access monitoring, minimize attack surface with access requests, and purge unused permissions via mandatory access reviews.</p>
<p>Ava Labs — We at <a href="https://www.avalabs.org">Ava Labs</a>, maintainer of <a href="https://github.com/ava-labs/avalanchego">AvalancheGo</a> (the most widely used client for interacting with the <a href="https://www.avax.network">Avalanche Network</a>), believe the sustainable maintenance and development of open source cryptographic protocols is critical to the broad adoption of blockchain technology. We are proud to support this necessary and impactful work through our ongoing sponsorship of Filippo and his team.</p>
        </section>
    </article></div>
  </body>
</html>
