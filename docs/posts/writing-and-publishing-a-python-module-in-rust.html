<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.yossarian.net/2020/08/02/Writing-and-publishing-a-python-module-in-rust">Original</a>
    <h1>Writing and publishing a Python module in Rust</h1>
    
    <div id="readability-page-1" class="page">


<h2><em>Programming, philosophy, pedaling.</em></h2>

<ul>
    <li><a href="https://blog.yossarian.net/">Home</a></li>
    <li><a href="https://blog.yossarian.net/tags">Tags</a></li>
    <li><a href="https://blog.yossarian.net/series">Series</a></li>
    <li><a href="https://blog.yossarian.net/favorites">Favorites</a></li>
    <li><a href="https://blog.yossarian.net/archive">Archive</a></li>
    
      <li><a href="https://yossarian.net">Main Site</a></li>
    
</ul>

<hr/>



<h2>
  <p>
    <span><em>Aug 2, 2020</em></span>

       

    
      <span>
        Tags:
        
        
          <a href="https://blog.yossarian.net/tags#devblog">devblog</a>,
        
          <a href="https://blog.yossarian.net/tags#programming">programming</a>,
        
          <a href="https://blog.yossarian.net/tags#python">python</a>,
        
          <a href="https://blog.yossarian.net/tags#rust">rust</a>
        
      </span>
    

       

    
  </p>
</h2>

<p>This post is a quick walkthrough of how I wrote a Python library,
<a href="https://pypi.org/project/procmaps/"><em>procmaps</em></a>, in nothing but Rust. It uses
<a href="https://github.com/PyO3/pyo3">PyO3</a> for the bindings and
<a href="https://github.com/PyO3/maturin">maturin</a> to manage the build (as well as produce
<code>manylinux1</code>-compatible wheels).</p>

<p>The code is, of course, <a href="https://github.com/woodruffw/procmaps.py">available on GitHub</a>, and
can be installed directly with a modern Python (3.5+) via <code>pip</code><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup> <em>without a local Rust install</em>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>$ </span>pip3 <span>install </span>procmaps
</pre></td></tr></tbody></table></code></pre></div></div>

<hr/>

<h2 id="procmaps">Procmaps?</h2>

<p><em>procmaps</em> is an <strong>extremely</strong> small Python library, backed by a similarly small
<a href="https://github.com/woodruffw/procmaps.rs">Rust library</a><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup>.</p>

<p>All it does is parse “maps” files, best known for their presence under
<a href="https://man7.org/linux/man-pages/man5/proc.5.html"><code>procfs</code></a> on Linux<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup>, into
a list of <code>Map</code> objects. Each <code>Map</code>, in turn, contains the basic attributes of the
mapped memory region.</p>

<p>By their Python attributes:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td><pre><span>import</span> <span>os</span>
<span>import</span> <span>procmaps</span>

<span># also: from_path, from_str
# N.B.: named map_ instead of map to avoid shadowing the map function
</span><span>map_</span> <span>=</span> <span>procmaps</span><span>.</span><span>from_pid</span><span>(</span><span>os</span><span>.</span><span>getpid</span><span>())[</span><span>0</span><span>]</span>

<span>map_</span><span>.</span><span>begin_address</span>  <span># the begin address for the mapped region
</span><span>map_</span><span>.</span><span>end_address</span>    <span># the end address for the mapped region
</span><span>map_</span><span>.</span><span>is_readable</span>    <span># is the mapped region readable?
</span><span>map_</span><span>.</span><span>is_writable</span>    <span># is the mapped region writable?
</span><span>map_</span><span>.</span><span>is_executable</span>  <span># is the mapped region executable?
</span><span>map_</span><span>.</span><span>is_shared</span>      <span># is the mapped region shared with other processes?
</span><span>map_</span><span>.</span><span>is_private</span>     <span># is the mapped region private (i.e., copy-on-write)?
</span><span>map_</span><span>.</span><span>offset</span>         <span># the offset into the region&#39;s source that the region originates from
</span><span>map_</span><span>.</span><span>device</span>         <span># a tuple of (major, minor) for the device that the region&#39;s source is on
</span><span>map_</span><span>.</span><span>inode</span>          <span># the inode of the source for the region
</span><span>map_</span><span>.</span><span>pathname</span>       <span># the &#34;pathname&#34; field for the region, or None if an anonymous map
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>Critically: apart from the <code>import</code>s and the <code>os.getpid()</code> call, all of the code above
<strong>calls directly into compiled Rust</strong>.</p>

<h2 id="motivation">Motivation</h2>

<p>The motivations behind <em>procmaps</em> are twofold.</p>

<p>First: I do program analysis and instrumentation research at my day job. Time and time again,
I need to obtain information about the memory layout of a program that I’m instrumenting (or would
like to instrument). This almost always means opening <code>/proc/&lt;pid&gt;/maps</code>, writing an ad-hoc parser,
getting the field(s) I want, and then getting on with my life.</p>

<p>Doing this over and over again has made me realize that it’s an ideal task for a small,
self-contained Rust library:</p>

<ul>
  <li>The “maps” format is line-oriented and practically frozen, with no ambiguities<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" rel="footnote">4</a></sup>. Rust has
<a href="https://github.com/pest-parser/pest">many</a> <a href="https://github.com/kevinmehall/rust-peg">high</a> <a href="https://github.com/geal/nom">quality</a>
PEG and parser combinator libraries that are well suited to the task.</li>
  <li>Writing ad-hoc parsers for it is bad™, especially when those parsers are written in C and/or C++.</li>
  <li>Having a small library with a small API surface would make exposure to other languages (including C and C++) trivial.</li>
</ul>

<p>Second: I started learning Rust about a year ago, and have been looking for new challenges in it.
Interoperating with another language (especially one with radically different memory semantics,
like Python) is an obvious choice.</p>

<h2 id="structure">Structure</h2>

<p>The <em>procmaps</em> module is a plain old Rust crate. Really.</p>

<p>The <em>only</em> differences are in the Cargo.toml:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span>[lib]</span>
<span>crate-type</span> <span>=</span> <span>[&#34;cdylib&#34;]</span>

<span>[package.metadata.maturin]</span>
<span>classifier</span> <span>=</span> <span>[</span>
  <span>&#34;Programming Language :: Rust&#34;</span><span>,</span>
  <span>&#34;Operating System :: POSIX :: Linux&#34;</span><span>,</span>
<span>]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>(Other settings under <code>package.metadata.maturin</code> are available for e.g. managing Python-side dependencies,
but <em>procmaps</em> doesn’t need them. More details are available
<a href="https://github.com/PyO3/maturin#python-metadata">here</a>.)</p>

<p>In terms of code, the crate is structured like a normal Rust library. PyO3 only requires a few
pieces of sugar to promote everything into Python-land:</p>

<h3 id="modules">Modules</h3>

<p>Python modules are created by decorating a Rust function with <code>#[pymodule]</code>.</p>

<p>This function then uses the functions of the <code>PyModule</code> argument that it takes to load the module’s
functions and classes.</p>

<p>For example, here is the Python-visible <code>procmaps</code> module <em>in its entirety</em>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>#[pymodule]</span>
<span>fn</span> <span>procmaps</span><span>(</span><span>_</span><span>py</span><span>:</span> <span>Python</span><span>,</span> <span>m</span><span>:</span> <span>&amp;</span><span>PyModule</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
    <span>m</span><span>.add_class</span><span>::</span><span>&lt;</span><span>Map</span><span>&gt;</span><span>()</span><span>?</span><span>;</span>
    <span>m</span><span>.add_wrapped</span><span>(</span><span>wrap_pyfunction!</span><span>(</span><span>from_pid</span><span>))</span><span>?</span><span>;</span>
    <span>m</span><span>.add_wrapped</span><span>(</span><span>wrap_pyfunction!</span><span>(</span><span>from_path</span><span>))</span><span>?</span><span>;</span>
    <span>m</span><span>.add_wrapped</span><span>(</span><span>wrap_pyfunction!</span><span>(</span><span>from_str</span><span>))</span><span>?</span><span>;</span>

    <span>Ok</span><span>(())</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="functions">Functions</h3>

<p>Module level functions are trivial to create: they’re just normal Rust functions,
marked with <code>#[pyfunction]</code>. They’re loaded into modules via <code>add_wrapped</code> + <code>wrap_pyfunction!</code>,
as seen above. Alternatively, they can be created within a module definition (i.e., nested within
the <code>#[pymodule]</code>) function via the <code>#[pyfn]</code> decorator.</p>

<p>Python-visible functions return a <code>PyResult&lt;T&gt;</code>, where <code>T</code> implements <code>IntoPy&lt;PyObject&gt;</code>.
PyO3 helpfully provides an implementation of this trait for many core types; a full table is
<a href="https://pyo3.rs/master/conversions.html#returning-rust-values-to-python">here</a>.
This includes <code>Option&lt;T&gt;</code>, making it painless to turn Rust-level functions that return
<code>Option</code>s into Python-level functions that can return <code>None</code>.</p>

<p><em>procmaps</em> doesn’t make use of them, but PyO3 also supports variadic arguments and keyword
arguments. Details on those are available <a href="https://pyo3.rs/master/class.html#method-arguments">here</a>.</p>

<p>Here’s a trivial Python-exposed function that does integer division, returning <code>None</code> if
division by zero is requested:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span>#[pyfunction]</span>
<span>fn</span> <span>idiv</span><span>(</span><span>dividend</span><span>:</span> <span>i64</span><span>,</span> <span>divisor</span><span>:</span> <span>i64</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>Option</span><span>&lt;</span><span>i64</span><span>&gt;&gt;</span> <span>{</span>
  <span>if</span> <span>divisor</span> <span>==</span> <span>0</span> <span>{</span>
    <span>Ok</span><span>(</span><span>None</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>Ok</span><span>(</span><span>Some</span><span>(</span><span>dividend</span> <span>/</span> <span>divisor</span><span>))</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="classes">Classes</h3>

<p>Classes are loaded into modules via the <code>add_class</code> function, as seen in the module definition.</p>

<p>Just like modules, they’re managed almost entirely behind a single decorator, this time on a
Rust struct. Here is the entirety of the <code>procmaps.Map</code> class definition:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>#[pyclass]</span>
<span>struct</span> <span>Map</span> <span>{</span>
    <span>inner</span><span>:</span> <span>rsprocmaps</span><span>::</span><span>Map</span><span>,</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><em>procmaps</em> doesn’t need them, but trivial getters and setters can be added to the members of a
class with <code>#[pyo3(get, set)]</code>. For example, the following creates a <code>Point</code> class:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>#[pyclass]</span>
<span>struct</span> <span>Point</span> <span>{</span>
  <span>#[pyo3(get,</span> <span>set)]</span>
  <span>x</span><span>:</span> <span>i64</span><span>,</span>
  <span>#[pyo3(get,</span> <span>set)]</span>
  <span>y</span><span>:</span> <span>i64</span><span>,</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>…for which the following would be possible in Python:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span># get_unit_point not shown above
</span><span>from</span> <span>pointlib</span> <span>import</span> <span>get_unit_point</span>

<span>p</span> <span>=</span> <span>get_unit_point</span><span>()</span>
<span>print</span><span>(</span><span>p</span><span>.</span><span>x</span><span>,</span> <span>p</span><span>.</span><span>y</span><span>)</span>

<span>p</span><span>.</span><span>x</span> <span>=</span> <span>100</span>
<span>p</span><span>.</span><span>y</span> <span>=</span> <span>-</span><span>p</span><span>.</span><span>x</span>
<span>print</span><span>(</span><span>p</span><span>.</span><span>x</span><span>,</span> <span>p</span><span>.</span><span>y</span><span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Using <code>#[pyclass]</code> on <code>Foo</code> auto-implements <code>IntoPy&lt;PyObject&gt; for Foo</code>, making it
easy to return your custom classes from any function (as above) or member method
(as below).</p>

<h3 id="member-methods">Member methods</h3>

<p>Just as Python-visible classes are defined via <code>#[pyclass]</code> on Rust <code>struct</code>s,
Python-visible member methods are declared via <code>#[pymethods]</code> attribute on Rust <code>impl</code>s for
those structures.</p>

<p>Member methods return <code>PyResult&lt;T&gt;</code>, just like functions do:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>#[pymethods]</span>
<span>impl</span> <span>Point</span> <span>{</span>
  <span>fn</span> <span>invert</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>Point</span><span>&gt;</span> <span>{</span>
    <span>Ok</span><span>(</span><span>Point</span> <span>{</span> <span>x</span><span>:</span> <span>self</span><span>.y</span><span>,</span> <span>y</span><span>:</span> <span>self</span><span>.x</span><span>})</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>…allows for the following:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span># get_unit_point not shown above
</span><span>from</span> <span>pointlib</span> <span>import</span> <span>get_unit_point</span>

<span>p</span> <span>=</span> <span>get_unit_point</span><span>()</span>
<span>p_inv</span> <span>=</span> <span>p</span><span>.</span><span>invert</span><span>()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>By default, PyO3 forbids the creation of Rust-defined classes within Python code. To allow their
creation, just add a function with the <code>#[new]</code> attribute to the <code>#[pymethods]</code> <code>impl</code> block.
This creates a <code>__new__</code> Python method rather than <code>__init__</code>; PyO3 doesn’t support the latter<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" rel="footnote">5</a></sup>.</p>

<p>For example, here’s a constructor for the contrived <code>Point</code> class above:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>#[pymethods]</span>
<span>impl</span> <span>Point</span> <span>{</span>
  <span>#[new]</span>
  <span>fn</span> <span>new</span><span>(</span><span>x</span><span>:</span> <span>i64</span><span>,</span> <span>y</span><span>:</span> <span>i64</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
    <span>Point</span> <span>{</span> <span>x</span><span>,</span> <span>y</span> <span>}</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>…which allows for:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>from</span> <span>pointlib</span> <span>import</span> <span>Point</span>

<span>p</span> <span>=</span> <span>Point</span><span>(</span><span>100</span><span>,</span> <span>0</span><span>)</span>
<span>p_inv</span> <span>=</span> <span>p</span><span>.</span><span>invert</span><span>()</span>
<span>assert</span> <span>p</span><span>.</span><span>y</span> <span>==</span> <span>100</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="exceptions-and-error-propagation">Exceptions and error propagation</h3>

<p>As mentioned above, (most) Python-visible functions and methods return <code>PyResult&lt;T&gt;</code>.</p>

<p>The <code>Err</code> half of <code>PyResult</code> is <code>PyErr</code>, and these values get propagated as Python exceptions.
The <code>pyo3::exceptions</code> module contains structures that parallel the standard Python exceptions,
each of which provides a <code>py_err(String)</code> function to produce an appropriate <code>PyErr</code>.</p>

<p>Creating a brand new Python-level exception takes a single line with the <code>create_exception!</code> macro.
Here’s how <em>procmaps</em> creates a <code>procmaps.ParseError</code> exception that inherits from the standard
Python <code>Exception</code> class:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>use</span> <span>pyo3</span><span>::</span><span>exceptions</span><span>::</span><span>Exception</span><span>;</span>

<span>// N.B.: The first argument is the module name,</span>
<span>// i.e. the function declared with #[pymodule].</span>
<span>create_exception!</span><span>(</span><span>procmaps</span><span>,</span> <span>ParseError</span><span>,</span> <span>Exception</span><span>);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Similarly, marshalling Rust <code>Error</code> types into <code>PyErr</code>s is as simple as
<code>impl std::convert::From&lt;ErrorType&gt; for PyErr</code>.</p>

<p>Here’s how <em>procmaps</em> turns some of its errors into standard Python <code>IOError</code>s
and others into the custom <code>procmaps.ParseError</code> exception:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre><span>// N.B.: The newtype here is only necessary because Error comes from an</span>
<span>// external crate (rsprocmaps).</span>
<span>struct</span> <span>ProcmapsError</span><span>(</span><span>Error</span><span>);</span>
<span>impl</span> <span>std</span><span>::</span><span>convert</span><span>::</span><span>From</span><span>&lt;</span><span>ProcmapsError</span><span>&gt;</span> <span>for</span> <span>PyErr</span> <span>{</span>
    <span>fn</span> <span>from</span><span>(</span><span>err</span><span>:</span> <span>ProcmapsError</span><span>)</span> <span>-&gt;</span> <span>PyErr</span> <span>{</span>
        <span>match</span> <span>err</span><span>.0</span> <span>{</span>
            <span>Error</span><span>::</span><span>Io</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>IOError</span><span>::</span><span>py_err</span><span>(</span><span>e</span><span>.to_string</span><span>()),</span>
            <span>Error</span><span>::</span><span>ParseError</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>ParseError</span><span>::</span><span>py_err</span><span>(</span><span>e</span><span>.to_string</span><span>()),</span>
            <span>Error</span><span>::</span><span>WidthError</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>ParseError</span><span>::</span><span>py_err</span><span>(</span><span>e</span><span>.to_string</span><span>()),</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="compilation-and-distribution">Compilation and distribution</h2>

<p>With everything above, <code>cargo build</code> <em>just works</em> — it produces a Python-loadable
shared object.</p>

<p>Unfortunately, it does it using the <code>cdylib</code> naming convention, meaning that <code>cargo build</code> for
<em>procmaps</em> produces <code>libprocmaps.so</code>, rather than one of the naming conventions that Python knows
how to look for when searching <code>$PYTHONPATH</code><sup id="fnref:6" role="doc-noteref"><a href="#fn:6" rel="footnote">6</a></sup>.</p>

<p>This is where <a href="https://github.com/PyO3/maturin">maturin</a> comes in: once installed, a single
<code>maturin build</code> in the crate root puts an appropriately named <code>pip</code>-compatible
<a href="https://www.python.org/dev/peps/pep-0427/">wheel</a> in <code>target/wheels</code>.</p>

<p>It gets even better: <code>maturin develop</code> will install the compiled module directly into the current
virtual environment, making local development as simple as:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>$ </span>python3 <span>-m</span> venv <span>env</span>
<span>$ </span><span>source env</span>/bin/activate
<span>(</span><span>env</span><span>)</span> <span>$ </span>pip3 <span>install </span>maturin
<span>(</span><span>env</span><span>)</span> <span>$ </span>maturin develop
<span>$ </span>python3
<span>&gt;</span> import procmaps
</pre></td></tr></tbody></table></code></pre></div></div>

<p><em>procmaps</em> has a <a href="https://github.com/woodruffw/procmaps.py/blob/master/Makefile">handy Makefile</a>
that wraps all of that; running the compiled module locally is a single <code>make develop</code> away.</p>

<p>Distribution is slightly more involved: <code>maturin develop</code> builds wheels that are compatible with the
local machine, but further restrictions on symbol versions and linkages are required to ensure
that a binary wheel runs on a large variety of Linux versions and distributions<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" rel="footnote">7</a></sup>.</p>

<p>Compliance with these constraints is normally enforced in one of two ways:</p>

<ol>
  <li>Packages are compiled into binary wheels, and then audited (and potentially repaired) via the
PyPA’s <a href="https://github.com/pypa/auditwheel">auditwheel</a> before release.</li>
  <li>Packages are compiled into binary wheels within a wholly controlled runtime environment,
such as the PyPa’s <a href="https://github.com/pypa/manylinux">manylinux</a> Docker containers.</li>
</ol>

<p>Distribution with <code>maturin</code> takes the latter approach: the <code>maturin</code> developers have derived a
Rust build container from the PyPa’s standard <code>manylinux</code> container, making <em>fully compatible</em>
builds (again, from the crate root) as simple as:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span># optional: do `build --release` for release-optimized builds</span>
<span>$ </span>docker run <span>--rm</span> <span>-v</span> <span>$(</span><span>pwd</span><span>)</span>:/io konstin2/maturin build
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This command, like a normal <code>maturin build</code>, drops the compiled wheel(s) into <code>target/wheels</code>.
Because it runs inside of the standard <code>manylinux</code> container, it can and does automatically build
wheels for a wide variety of Python versions (Python 3.5 through 3.8, as of writing).</p>

<p>From here, distribution to PyPI is as simple as <code>twine upload target/wheels/*</code> <em>or</em>
<code>maturin publish</code>. <em>procmaps</em> currently uses the former, as releases are
<a href="https://github.com/woodruffw/procmaps.py/blob/master/.github/workflows/release.yml">handled via GitHub Actions</a>
using the PyPA’s excellent
<a href="https://github.com/pypa/gh-action-pypi-publish"><code>gh-action-pypi-publish</code></a> action.</p>

<p>Voilá: a Python module, written completely in Rust, that can be installed on the vast majority of
Linux distributions with absolutely no dependencies on Rust itself. Even the non-<code>maturin</code>
metadata in <code>Cargo.toml</code> is propagated correctly!</p>

<p><img src="https://blog.yossarian.net/assets/procmaps_pypi.png" alt="procmaps on PyPI"/></p>

<h2 id="wrapup">Wrapup</h2>

<p>I only ran into one small hiccup while working on <em>procmaps</em> — I tried to add a
<code>Map.__contains__</code> method to allow for inclusion checks with the <code>in</code> protocol, e.g.:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>fn</span> <span>__</span><span>contains__</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>addr</span><span>:</span> <span>u64</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>bool</span><span>&gt;</span> <span>{</span>
    <span>Ok</span><span>(</span><span>addr</span> <span>&gt;=</span> <span>self</span><span>.inner.address_range.begin</span> <span>&amp;&amp;</span> <span>addr</span> <span>&lt;</span> <span>self</span><span>.inner.address_range.end</span><span>)</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>…but this didn’t work, for whatever reason, despite working when called manually:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span>4194304</span> <span>in</span> <span>map_</span>
<span>Traceback</span> <span>(</span><span>most</span> <span>recent</span> <span>call</span> <span>last</span><span>):</span>
  <span>File</span> <span>&#34;&lt;stdin&gt;&#34;</span><span>,</span> <span>line</span> <span>1</span><span>,</span> <span>in</span> <span>&lt;</span><span>module</span><span>&gt;</span>
<span>TypeError</span><span>:</span> <span>argument</span> <span>of</span> <span>type</span> <span>&#39;Map&#39;</span> <span>is</span> <span>not</span> <span>iterable</span>

<span>&gt;&gt;&gt;</span> <span>map_</span><span>.</span><span>__contains__</span><span>(</span><span>4194304</span><span>)</span>
<span>True</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>There’s probably a reasonable explanation for this in the Python data model that I haven’t figured
out.
<strong>Edit</strong>:
<a href="https://www.reddit.com/r/rust/comments/i2ctke/writing_and_publishing_a_python_module_in_rust/g04vw1y/">a Redditor pointed me to the correct approach</a>.
I’ve cut a new release of <em>procmaps</em> that shows the <code>__contains__</code> protocol in action.</p>

<p>By and large, the process of writing a Python module in Rust was <em>extremely</em> pleasant —
I didn’t have to write a single line of Python (or even Python-specific configuration) until I wanted
to add unit tests. Both pyO3 and maturin are incredibly polished, and the PyPA’s efforts
to provide <code>manylinux</code> build environments made compatible builds a breeze.</p>

<hr/>




<hr/>




  


  





</div>
  </body>
</html>
