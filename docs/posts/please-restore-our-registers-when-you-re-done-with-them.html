<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://randomascii.wordpress.com/2022/11/21/please-restore-our-registers-when-youre-done-with-them/">Original</a>
    <h1>Please restore our registers when you’re done with them</h1>
    
    <div id="readability-page-1" class="page"><div>
						<p>“Hey, you. Yes you, that function over there. When you’re cleaning up please remember to restore all of my registers. Yes, that one too – what do you think this is, Linux?”</p>
<p>That’s the problem I was dealing with in a nutshell. Functions are required by a platform’s ABI (<a href="https://en.wikipedia.org/wiki/Application_binary_interface">Application Binary Interface</a>) to preserve certain registers – restoring them if they were used – but the set of registers that must be restored varies between platforms, and the rules on Linux are different from those on Windows. That may be why I encountered register corruption in Chrome on Windows. But let’s take a step back.</p>

<p>I was<a href="https://randomascii.files.wordpress.com/2022/11/dscn2244.jpg"><img width="184" height="244" title="A crashed phone showing a Windows BSOD" alt="A crashed phone showing a Windows BSOD" src="https://randomascii.files.wordpress.com/2022/11/dscn2244_thumb.jpg?w=184&amp;h=244"/></a> asked to look at a <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1218384">crash bug</a> in Chrome. The crash was strongly correlated with the injection of third-party DLLs into Chrome’s processes (something that we cannot and do not support) so it was highly likely that the crash was caused by those third-party DLLs, but I still wanted to understand what was going on.</p>
<p>Some of my coworkers had investigated the bug previously and added some extra tests, so the crash had been isolated down to this pseudo-code:</p>
<blockquote>
<p><SPAN face="Courier New"><strong>while (StillRunning()) {</strong></SPAN></p>
</blockquote>
<p>The code above represents a long running loop that does a bunch of stuff. At the end of each iteration it calls a function and moves a smart pointer to the function parameters, which should zero out the source pointer. The crash happened when the CHECK statement noticed that the source pointer was, in fact, <em>not</em> zeroed – we intentionally crash then to avoid memory corruption.</p>
<p>The thing that made me want to investigate was the peculiarity of the behavior of the last two lines. How could we zero a pointer on one line of code, and then find it non-zero on the next line? Even if third-party DLLs are the culprit, how could they do that? I’d checked for any modification of the code bytes near the crash and found nothing, so, how? I wanted to understand.</p>
<h2>The truth is in the crash dump</h2>
<p>As usual I downloaded one of the crash dumps and looked at the assembly-language instructions which implemented the C++ source code. Here, in a mixture of pseudo-code and assembly language, is what I found the code had been translated to (see <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1218384#c61">comment#61</a> in the bug for details):</p>
<blockquote>
<p><SPAN face="Courier New"><strong>xorps xmm7, xmm7   ; Zero register xmm7</strong></SPAN></p>
</blockquote>
<p>Apologies for the mixing of metaphors, but the key point is that the compiler decided to zero the XMM7 register (one of the <a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions#Registers">SSE registers</a>) before the loop started. Then, at the end of each loop iteration it would use XMM7 to zero out m_ptr (stored at the address rsp+50h). The compiler expected XMM7 to remain zero. It did not.</p>
<p>I looked at a large set of crash dumps to see if there was any pattern to the values in XMM7. Here are four of the values I found:</p>
<ul>
<li>96 12 54 91 ca c8 18 ef 98 e8 77 c9 6e 5d ce ee</li>
<li>c5 1e 15 13 00 a0 94 5b 37 a5 f3 55 a8 7e 8d 7d</li>
<li>54 39 1f 15 3e bf 13 3e 58 98 fd 6d 64 a3 5a 27</li>
<li>04 df 90 27 02 94 4c ed 73 65 1d 61 af da 33 36</li>
</ul>
<p>If there is a pattern in these numbers then I sure can’t see it. This randomness is another clue that constrains what the problem could be caused by.</p>
<h2>ABIs matter</h2>
<p><a href="https://randomascii.files.wordpress.com/2022/11/img_7322.jpg"><img width="342" height="229" title="Mount St. Helens crater - snow near fire" alt="Mount St. Helens crater - snow near fire" src="https://randomascii.files.wordpress.com/2022/11/img_7322_thumb.jpg?w=342&amp;h=229"/></a>The functions DoLotsOfStuff and ImportantFunction and all of the functions that they call are <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">required by the Windows ABI</a> to preserve XMM7 (this is not the case on Linux). If they use it then they have to restore it. But one of them was not (or the stack location where they preserved the register got trashed, but that seems less likely). In most of the crashes third-party DLLs were present in the Chrome process. These DLLs are presumed to be hooking Chrome or OS functions, and their injected code was presumed to be corrupting XMM7.</p>
<p>I <a href="https://twitter.com/BruceDawson0xB/status/1582461778361217025">tweeted about this</a>, trying to get theories for how this could happen. Amidst the various replies talking about ISRs, DPCs, and drivers I saw a reply from <a href="https://twitter.com/dougallj">someone I’d never talked to before</a> saying, basically, “What about <a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/boringssl/win-x86_64/crypto/cipher_extra/aes128gcmsiv-x86_64.asm?pli=1#3142">this Chromium code</a>?”</p>
<p>I saw this tweet on my home laptop and when I went to look on my work machine the author had already deleted it. My curiosity piqued I reached out to them in a DM. They said that they had thought the code looked suspicious but then realized that the problem was <a href="https://boringssl.googlesource.com/boringssl/+/master/crypto/cipher_extra/e_aesgcmsiv.c?pli=1#30">understood by the developers</a> and that the code wasn’t actually compiled in to Chrome on Windows. Such is the challenge of looking for misuse of XMM7 in Chromium’s source code – there are too many references (over 17,000), and most of them are irrelevant.</p>
<p>They then mentioned that they were switching to binary analysis using IDA Pro and had found a couple of functions that were shipping in chrome.dll but weren’t restoring XMM7 – they sent source-code links to what looked like real bugs. This is a time when binary analysis is actually easier than “use the source,” because the machine code has had all macros and #ifdefs processed and represents what actually ships.</p>
<p>I decided to replicate their work using “dumpbin /disasm” and some simple Python code to scan the output. For every function in Chrome (found by looking for global symbols in the disassembly output) my script checked to see whether XMM7 was used without being saved. Initially I checked to see if it was written relative to rsp prior to its first use, but I found it being written relative to rax and rbp as well, so I eventually loosened my heuristics. My script still gives false positives, and may also give false negatives, but it works well enough to be useful.</p>
<p>Despite my initial assumption that this was a third-party bug, my simple script found several suspicious functions. There were roughly three categories of functions where the first use of XMM7 was not restoring it:</p>
<ol>
<li>Functions such as dav1d_iflipadst_16x8_internal_16bpc_sse4 (<a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/dav1d/libdav1d/src/x86/">from here?</a>) that are internal-use functions by the dav1d library. These functions are all called by wrappers that preserve and restore XMM7, therefore they are fine.</li>
<li>Functions such as __longjmp_internal which <em>by design</em> restores all of the non-volatile registers so that it can return to a previous execution state.</li>
<li>Buggy code that is built in to Chromium</li>
</ol>
<p><a href="https://randomascii.files.wordpress.com/2022/11/dsc08148.jpg"><img width="355" height="238" title="Mauna Loa crater, snow in Hawaii. Okay, I really like volcanoes!" alt="Mauna Loa crater, snow in Hawaii. Okay, I really like volcanoes!" src="https://randomascii.files.wordpress.com/2022/11/dsc08148_thumb.jpg?w=355&amp;h=238"/></a>Using this crude binary-analysis technique I ultimately found the same two buggy functions in chrome.dll that my twitter accomplice had found.</p>
<p>The function <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/libyuv/source/scale_gcc.cc;l=1003?q=ScaleRowUp2_Bilinear_12_SSSE3">ScaleRowUp2_Bilinear_12_SSSE3</a> in WebRTC was putting the constant 0x0008000800080008 into XMM7 without first preserving. This is a bug, and could cause crashes, but I knew that this wasn’t the cause of <em>this</em> crash because the XMM7 values I was seeing were highly random. I reported the issue to the author and they <a href="https://bugs.chromium.org/p/libyuv/issues/detail?id=945">filed a bug</a> and fixed it within 24 hours.</p>
<p><a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/openh264/src/codec/processing/src/x86/downsample_bilinear.asm;l=2226?q=DyadicBilinearQuarterDownsampler_sse">DyadicBilinearQuarterDownsampler_sse</a> in openh264 was also using XMM7 without preserving it. Video codecs often deal with values with high entropy so <em>maybe</em> this could have been producing the random values I was seeing (spoiler alert: it wasn’t) and it was certainly wrong. I <a href="https://github.com/cisco/openh264/issues/3585">filed a bug</a> for this and then decided to fix it. Landing this fix came with a couple of challenges:</p>
<ol>
<li>The bug was in an assembly language file that used multiple macros to ensure cross-platform correctness. Thus I had to figure out (by examining nearby functions) the correct incantations to preserve the registers when needed. It wasn’t too bad, but it’s always weird when I’m writing code in a language that I effectively don’t know at all. Pattern recognition FTW. Anyway, the <a href="https://github.com/cisco/openh264/commit/db956674bbdfbaab5acdd3fdb4117c2fef5527e9">two line fix</a> worked.</li>
<li>Fixing the bug in openh264 does not immediately help Chrome because Chromium uses a pinned copy of third-party libraries, so I needed to “roll” in the latest version of openh264. Sometimes there is an auto-roller that does this regularly, but openh264 lacked this. It had been six months since the last roll of openh264, and in the interim somebody had moved the public header files to a new directory. Since Chromium and another third-party project (<a href="https://webrtc.org/">WebRTC</a>) were both including headers from this renamed directory there was an eight step process (<a href="https://chromium-review.googlesource.com/c/chromium/src/+/3986032">one,</a> <a href="https://webrtc-review.googlesource.com/c/src/+/280942">two</a>, <a href="https://webrtc-review.googlesource.com/c/src/+/280800">three</a>, <a href="https://chromium-review.googlesource.com/c/chromium/src/+/3996007">four</a>, <a href="https://chromium-review.googlesource.com/c/chromium/src/+/3978910">five</a>, <a href="https://webrtc-review.googlesource.com/c/src/+/281561">six</a>, <a href="https://chromium-review.googlesource.com/c/chromium/src/+/4027295">seven</a>, <a href="https://chromium-review.googlesource.com/c/chromium/src/+/4028582">eight</a>) to bring in the new version without breaking anything in WebRTC or Chromium. The basic technique was to do conditional includes in WebRTC, plus waiting for auto-rolls of WebRTC into Chromium and vice-versa.</li>
</ol>
<p>The WebRTC and openh264 issues were genuine bugs, and fixing them will probably prevent future crashes in Chromium, but it made no difference to the issue that I was investigating. The crashes continued. Third-party software continued to be the most likely explanation.</p>
<p><a href="https://randomascii.files.wordpress.com/2022/11/dsc08557.jpg"><img width="358" height="240" title="Roadside chapel in France" alt="Roadside chapel in France" src="https://randomascii.files.wordpress.com/2022/11/dsc08557_thumb.jpg?w=358&amp;h=240"/></a>There had been multiple hints as to what type of third-party software could be the problem. It has to be something that creates highly randomized data. There was an apparent correlation with third-party disk encryption software. One customer I was investigating the crashes with was using a particular third-party disk encryption product, and Microsoft had noticed a <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1218384#c78">correlation with tasks that do filesystem work</a>. Attempts were made to contact the vendor.</p>
<p>I am hopeful that the root cause is being fixed, but also, I would like it if developers working on product that use assembly language could audit their code to make sure they are honoring the Windows ABI. This isn’t the <a href="https://twitter.com/Zalathar/status/1595204081429012480">first instance of this class of bug</a>, and it won’t be the last.</p>
<h2>My motivation</h2>
<p>I decided to write this up because I thought that the journey was interesting, but also because the journey is not over. There could be other registers that are not being properly saved and restored in Chromium. There could be <a href="https://twitter.com/Zalathar/status/1594970774603202561">other projects</a> that are making this mistake, perhaps not aware of the differences between the Linux and Windows ABI. Any software rules that are not tested and enforced are inevitably broken and I am not aware of any consistent testing to detect ABI violations. More bugs of this type seem inevitable.</p>
<h2>Summary</h2>
<p>These crashes started happening around the M91 versions of Chrome. This at first looked like a Chrome bug, but it now seems more likely that it was because the compiler or the Chromium code changed to make it <em>vulnerable</em> to XMM7 register corruption that was already happening in the ecosystem. That is, prior to M91 Chrome wasn’t using XMM7 at all in the <em>RunWorker</em> function (<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1218384#c92">I checked</a>), and starting with M91 the code-gen changed (compiler change?) and the function started relying on XMM7 staying zeroed for hours at a time. So please restore our registers when you’re done with them.</p>
<p>And thanks again to <a href="https://twitter.com/dougallj">Dougall on twitter</a> for poking at this problem and inspiring me to dig deeper.</p>
<p><a href="https://twitter.com/BruceDawson0xB/status/1594944533066027009">Twitter announcement</a></p>
<p><a href="https://news.ycombinator.com/item?id=33705209">Hacker news discussion</a></p>
											</div><div id="entry-author-info">
						<p><img alt="" src="https://1.gravatar.com/avatar/d69d2780728dfc033fcc8123f31ef8fa?s=60&amp;d=identicon&amp;r=G" height="60" width="60"/>						</p><!-- #author-avatar -->
						<div id="author-description">
							<h2>
							About brucedawson							</h2><p>
							I&#39;m a programmer, working for Google, focusing on optimization and reliability. Nothing&#39;s more fun than making code run 10x as fast. Unless it&#39;s eliminating large numbers of bugs.

I also unicycle. And play (ice) hockey. And sled hockey. And juggle. And worry about whether this blog should have been called randomutf-8.

2010s in review tells more: https://twitter.com/BruceDawson0xB/status/1212101533015298048							</p><!-- #author-link	-->
						</div><!-- #author-description -->
					</div></div>
  </body>
</html>
