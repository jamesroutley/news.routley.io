<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/slaily/aiosqlitepool">Original</a>
    <h1>SQLite async connection pool for high-performance</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">

    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/192c9e02e0d9fd2bd40010317d8088d09d446db0ac51a44339a5d72413153c44/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f73746162696c6974792d737461626c652d677265656e2e737667"><img src="https://camo.githubusercontent.com/192c9e02e0d9fd2bd40010317d8088d09d446db0ac51a44339a5d72413153c44/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f73746162696c6974792d737461626c652d677265656e2e737667" alt="Stable version" data-canonical-src="https://img.shields.io/badge/stability-stable-green.svg"/></a>

<a href="https://pypi.org/project/aiosqlitepool" rel="nofollow">
    <img src="https://camo.githubusercontent.com/4a50dcfe4916b7484776adbbc21fb7ab798ab4b092f46e0b09d583f8f65724bf/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f61696f73716c697465706f6f6c3f636f6c6f723d253233333444303538266c6162656c3d707970692532307061636b616765" alt="Package version" data-canonical-src="https://img.shields.io/pypi/v/aiosqlitepool?color=%2334D058&amp;label=pypi%20package"/>
</a>
<a href="https://pypi.org/project/aiosqlitepool" rel="nofollow">
    <img src="https://camo.githubusercontent.com/1e0c0a9f86cd65ef46062a0adca565c3741ae6a47594fd67d838b1b3896994e7/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f61696f73716c697465706f6f6c2e7376673f636f6c6f723d253233333444303538" alt="Supported Python versions" data-canonical-src="https://img.shields.io/pypi/pyversions/aiosqlitepool.svg?color=%2334D058"/>
</a>
<a href="https://github.com/slaily/aiosqlitepool/blob/main/LICENSE">
    <img src="https://camo.githubusercontent.com/6cd0120cc4c5ac11d28b2c60f76033b52db98dac641de3b2644bb054b449d60c/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d79656c6c6f772e737667" alt="Supported Python versions" data-canonical-src="https://img.shields.io/badge/License-MIT-yellow.svg"/>
</a>
</p>
<p dir="auto"><code>aiosqlitepool</code> is a high-performance connection pool for asyncio SQLite applications. By managing a pool of reusable database connections, it eliminates connection overhead and delivers significant performance gains.</p>
<p dir="auto"><strong>Important</strong>: <code>aiosqlitepool</code> is not a SQLite database driver.</p>
<p dir="auto">It&#39;s a performance-boosting layer that works <em>with</em> an asyncio driver like <a href="https://github.com/omnilib/aiosqlite">aiosqlite</a>, not as a replacement for it.</p>
<p dir="auto"><code>aiosqlitepool</code> in three points:</p>
<ul dir="auto">
<li><strong>Eliminates connection overhead</strong>: It avoids repeated database connection setup (syscalls, memory allocation) and teardown (syscalls, deallocation) by reusing long-lived connections.</li>
<li><strong>Faster queries via &#34;hot&#34; cache</strong>: Long-lived connections keep SQLite&#39;s in-memory page cache &#34;hot.&#34; This serves frequently requested data directly from memory, speeding up repetitive queries and reducing I/O operations.</li>
<li><strong>Maximizes concurrent throughput</strong>: Allows your application to process significantly more database queries per second under heavy load.</li>
</ul>

<ul dir="auto">
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Usage</a>
<ul dir="auto">
<li><a href="#basic-usage">Basic usage</a></li>
<li><a href="#using-as-context-manager">Using as Context Manager</a></li>
<li><a href="#high-performance-sqlite-connection-configuration">High-performance SQLite connection configuration</a></li>
<li><a href="#fastapi-integration">FastAPI integration</a></li>
</ul>
</li>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#how-it-works">How it works</a></li>
<li><a href="#do-you-need-a-connection-pool-with-sqlite">Do you need a connection pool with SQLite?</a></li>
<li><a href="#benchmarks">Benchmarks</a>
<ul dir="auto">
<li><a href="#load-test">Load test</a></li>
<li><a href="#connection-overhead">Connection overhead</a></li>
</ul>
</li>
<li><a href="#compatibility">Compatibility</a>
<ul dir="auto">
<li><a href="#officially-supported-drivers">Officially supported drivers</a></li>
<li><a href="#using-other-drivers">Using other drivers</a></li>
</ul>
</li>
<li><a href="#license">License</a></li>
</ul>

<p dir="auto"><code>aiosqlitepool</code> requires the <code>aiosqlite</code> driver to be installed as a peer dependency.</p>
<p dir="auto">Install with your preferred package manager:</p>
<p dir="auto"><strong>pip</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="pip install aiosqlite aiosqlitepool"><pre>pip install aiosqlite aiosqlitepool</pre></div>
<p dir="auto"><strong>uv</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="uv add aiosqlite aiosqlitepool"><pre>uv add aiosqlite aiosqlitepool</pre></div>
<p dir="auto"><strong>Poetry</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="poetry add aiosqlite aiosqlitepool"><pre>poetry add aiosqlite aiosqlitepool</pre></div>


<p dir="auto">You must provide a <code>connection_factory</code> - an async function that creates and returns a database connection:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import asyncio
import aiosqlite

from aiosqlitepool import SQLiteConnectionPool


async def connection_factory():
    return await aiosqlite.connect(&#34;basic.db&#34;)


async def main():
    pool = SQLiteConnectionPool(connection_factory)
    
    async with pool.connection() as conn:
        await conn.execute(&#34;CREATE TABLE IF NOT EXISTS users (name TEXT)&#34;)
        await conn.execute(&#34;INSERT INTO users VALUES (?)&#34;, (&#34;Alice&#34;,))
        # You must handle transaction management yourself
        await conn.commit()
        cursor = await conn.execute(&#34;SELECT name FROM users&#34;)
        row = await cursor.fetchone()
        print(f&#34;Found user: {row[0]}&#34;)
    
    await pool.close()


if __name__ == &#34;__main__&#34;:
    asyncio.run(main())"><pre><span>import</span> <span>asyncio</span>
<span>import</span> <span>aiosqlite</span>

<span>from</span> <span>aiosqlitepool</span> <span>import</span> <span>SQLiteConnectionPool</span>


<span>async</span> <span>def</span> <span>connection_factory</span>():
    <span>return</span> <span>await</span> <span>aiosqlite</span>.<span>connect</span>(<span>&#34;basic.db&#34;</span>)


<span>async</span> <span>def</span> <span>main</span>():
    <span>pool</span> <span>=</span> <span>SQLiteConnectionPool</span>(<span>connection_factory</span>)
    
    <span>async</span> <span>with</span> <span>pool</span>.<span>connection</span>() <span>as</span> <span>conn</span>:
        <span>await</span> <span>conn</span>.<span>execute</span>(<span>&#34;CREATE TABLE IF NOT EXISTS users (name TEXT)&#34;</span>)
        <span>await</span> <span>conn</span>.<span>execute</span>(<span>&#34;INSERT INTO users VALUES (?)&#34;</span>, (<span>&#34;Alice&#34;</span>,))
        <span># You must handle transaction management yourself</span>
        <span>await</span> <span>conn</span>.<span>commit</span>()
        <span>cursor</span> <span>=</span> <span>await</span> <span>conn</span>.<span>execute</span>(<span>&#34;SELECT name FROM users&#34;</span>)
        <span>row</span> <span>=</span> <span>await</span> <span>cursor</span>.<span>fetchone</span>()
        <span>print</span>(<span>f&#34;Found user: <span><span>{</span><span>row</span>[<span>0</span>]<span>}</span></span>&#34;</span>)
    
    <span>await</span> <span>pool</span>.<span>close</span>()


<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span>:
    <span>asyncio</span>.<span>run</span>(<span>main</span>())</pre></div>
<p dir="auto"><strong>Note</strong>: The pool manages connections, not transactions. You&#39;re responsible for calling <code>commit()</code> or <code>rollback()</code> as needed. The pool ensures connections are safely reused but doesn&#39;t interfere with your transaction logic.</p>

<p dir="auto">The pool can be used as an async context manager for automatic cleanup:</p>
<div dir="auto" data-snippet-clipboard-copy-content="async def main():
    async with SQLiteConnectionPool(create_connection) as pool:
        async with pool.connection() as conn:
            # Do database work
            pass
    # Pool is automatically closed"><pre><span>async</span> <span>def</span> <span>main</span>():
    <span>async</span> <span>with</span> <span>SQLiteConnectionPool</span>(<span>create_connection</span>) <span>as</span> <span>pool</span>:
        <span>async</span> <span>with</span> <span>pool</span>.<span>connection</span>() <span>as</span> <span>conn</span>:
            <span># Do database work</span>
            <span>pass</span>
    <span># Pool is automatically closed</span></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">High-performance SQLite connection configuration</h3><a id="user-content-high-performance-sqlite-connection-configuration" aria-label="Permalink: High-performance SQLite connection configuration" href="#high-performance-sqlite-connection-configuration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">For high-performance applications, configure your connection factory with optimized SQLite pragmas.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import aiosqlite

from aiosqlitepool import SQLiteConnectionPool


async def sqlite_connection() -&gt; aiosqlite.Connection:
    # Connect to your database
    conn = await aiosqlite.connect(&#34;your_database.db&#34;)
    # Apply high-performance pragmas
    await conn.execute(&#34;PRAGMA journal_mode = WAL&#34;)
    await conn.execute(&#34;PRAGMA synchronous = NORMAL&#34;)
    await conn.execute(&#34;PRAGMA cache_size = 10000&#34;)
    await conn.execute(&#34;PRAGMA temp_store = MEMORY&#34;)
    await conn.execute(&#34;PRAGMA foreign_keys = ON&#34;)
    await conn.execute(&#34;PRAGMA mmap_size = 268435456&#34;)
    
    return conn


async def main():
    # Initialize the connection pool with your high-performance connection factory
    pool = SQLiteConnectionPool(
        connection_factory=sqlite_connection,
    )
    
    # Use the pool
    async with pool.connection() as conn:
        # Your database operations here
        # cursor = await conn.execute(&#34;SELECT ...&#34;)
        # rows = await cursor.fetchall()
        pass
    
    # Clean up
    await pool.close()"><pre><span>import</span> <span>aiosqlite</span>

<span>from</span> <span>aiosqlitepool</span> <span>import</span> <span>SQLiteConnectionPool</span>


<span>async</span> <span>def</span> <span>sqlite_connection</span>() <span>-&gt;</span> <span>aiosqlite</span>.<span>Connection</span>:
    <span># Connect to your database</span>
    <span>conn</span> <span>=</span> <span>await</span> <span>aiosqlite</span>.<span>connect</span>(<span>&#34;your_database.db&#34;</span>)
    <span># Apply high-performance pragmas</span>
    <span>await</span> <span>conn</span>.<span>execute</span>(<span>&#34;PRAGMA journal_mode = WAL&#34;</span>)
    <span>await</span> <span>conn</span>.<span>execute</span>(<span>&#34;PRAGMA synchronous = NORMAL&#34;</span>)
    <span>await</span> <span>conn</span>.<span>execute</span>(<span>&#34;PRAGMA cache_size = 10000&#34;</span>)
    <span>await</span> <span>conn</span>.<span>execute</span>(<span>&#34;PRAGMA temp_store = MEMORY&#34;</span>)
    <span>await</span> <span>conn</span>.<span>execute</span>(<span>&#34;PRAGMA foreign_keys = ON&#34;</span>)
    <span>await</span> <span>conn</span>.<span>execute</span>(<span>&#34;PRAGMA mmap_size = 268435456&#34;</span>)
    
    <span>return</span> <span>conn</span>


<span>async</span> <span>def</span> <span>main</span>():
    <span># Initialize the connection pool with your high-performance connection factory</span>
    <span>pool</span> <span>=</span> <span>SQLiteConnectionPool</span>(
        <span>connection_factory</span><span>=</span><span>sqlite_connection</span>,
    )
    
    <span># Use the pool</span>
    <span>async</span> <span>with</span> <span>pool</span>.<span>connection</span>() <span>as</span> <span>conn</span>:
        <span># Your database operations here</span>
        <span># cursor = await conn.execute(&#34;SELECT ...&#34;)</span>
        <span># rows = await cursor.fetchall()</span>
        <span>pass</span>
    
    <span># Clean up</span>
    <span>await</span> <span>pool</span>.<span>close</span>()</pre></div>
<p dir="auto"><strong><code>PRAGMA journal_mode = WAL</code></strong> - Writes go to a separate WAL file, reads continue from main database. Multiple readers can work simultaneously with one writer.</p>
<p dir="auto"><strong><code>PRAGMA synchronous = NORMAL</code></strong> - SQLite syncs to disk at critical moments, but not after every write. ~2-3x faster writes than <code>FULL</code> synchronization.</p>
<p dir="auto"><strong><code>PRAGMA cache_size = 10000</code></strong> - Keeps 10,000 database pages (~40MB) in memory. Frequently accessed data served from RAM, not disk</p>
<p dir="auto"><strong><code>PRAGMA temp_store = MEMORY</code></strong> - Stores temporary tables, indexes, and sorting operations in RAM. Eliminates disk I/O for temporary operations</p>
<p dir="auto"><strong><code>PRAGMA foreign_keys = ON</code></strong> - Enforces foreign key constraints automatically. Prevents data corruption, reduces application-level checks</p>
<p dir="auto"><strong><code>PRAGMA mmap_size = 268435456</code></strong> - Maps database file directly into process memory space. Reduces system calls, faster access to large databases</p>

<p dir="auto">This section demonstrates an effective pattern for integrating <code>aiosqlitepool</code> with <a href="https://fastapi.tiangolo.com/" rel="nofollow">FastAPI</a> applications.</p>
<p dir="auto">The pattern addresses three key requirements:</p>
<ol dir="auto">
<li><strong>Lifecycle management</strong>: The pool is created during application startup and gracefully closed on shutdown using FastAPI&#39;s <code>lifespan</code> context manager</li>
<li><strong>Global access</strong>: The pool is stored in the application&#39;s state, making it accessible to all route handlers</li>
<li><strong>Dependency injection</strong>: A reusable dependency function provides clean access to pooled connections with automatic resource management</li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="import asyncio

from typing import AsyncGenerator
from contextlib import asynccontextmanager

import aiosqlite

from aiosqlitepool import SQLiteConnectionPool
from fastapi import (
    Request,
    Depends, 
    FastAPI, 
    HTTPException, 
)


async def sqlite_connection() -&gt; aiosqlite.Connection:
    &#34;&#34;&#34;A factory for creating new connections.&#34;&#34;&#34;
    conn = await aiosqlite.connect(&#34;app.db&#34;)

    return conn


@asynccontextmanager
async def lifespan(app: FastAPI):
    &#34;&#34;&#34;
    Manage the connection pool&#39;s lifecycle.
    The pool is created when the application starts and gracefully closed when it stops.
    &#34;&#34;&#34;
    db_pool = SQLiteConnectionPool(connection_factory=sqlite_connection, pool_size=10)
    app.state.db_pool = db_pool
    yield
    await db_pool.close()


app = FastAPI(lifespan=lifespan)


async def get_db_connection(request: Request) -&gt; AsyncGenerator[Connection]:
    &#34;&#34;&#34;
    A dependency that provides a connection from the pool.
    It accesses the pool from the application state.
    &#34;&#34;&#34;
    db_pool = request.app.state.db_pool

    async with db_pool.connection() as conn:
        yield conn


@app.get(&#34;/users/{user_id}&#34;)
async def get_user(
    user_id: int, db_conn: Connection = Depends(get_db_connection)
) -&gt; dict[str, any]:
    cursor = await db_conn.execute(&#34;SELECT * FROM users WHERE id = ?&#34;, (user_id,))
    user = await cursor.fetchone()

    if not user:
        raise HTTPException(status_code=404, detail=&#34;User not found&#34;)
    
    return dict(user)"><pre><span>import</span> <span>asyncio</span>

<span>from</span> <span>typing</span> <span>import</span> <span>AsyncGenerator</span>
<span>from</span> <span>contextlib</span> <span>import</span> <span>asynccontextmanager</span>

<span>import</span> <span>aiosqlite</span>

<span>from</span> <span>aiosqlitepool</span> <span>import</span> <span>SQLiteConnectionPool</span>
<span>from</span> <span>fastapi</span> <span>import</span> (
    <span>Request</span>,
    <span>Depends</span>, 
    <span>FastAPI</span>, 
    <span>HTTPException</span>, 
)


<span>async</span> <span>def</span> <span>sqlite_connection</span>() <span>-&gt;</span> <span>aiosqlite</span>.<span>Connection</span>:
    <span>&#34;&#34;&#34;A factory for creating new connections.&#34;&#34;&#34;</span>
    <span>conn</span> <span>=</span> <span>await</span> <span>aiosqlite</span>.<span>connect</span>(<span>&#34;app.db&#34;</span>)

    <span>return</span> <span>conn</span>


<span>@<span>asynccontextmanager</span></span>
<span>async</span> <span>def</span> <span>lifespan</span>(<span>app</span>: <span>FastAPI</span>):
    <span>&#34;&#34;&#34;</span>
<span>    Manage the connection pool&#39;s lifecycle.</span>
<span>    The pool is created when the application starts and gracefully closed when it stops.</span>
<span>    &#34;&#34;&#34;</span>
    <span>db_pool</span> <span>=</span> <span>SQLiteConnectionPool</span>(<span>connection_factory</span><span>=</span><span>sqlite_connection</span>, <span>pool_size</span><span>=</span><span>10</span>)
    <span>app</span>.<span>state</span>.<span>db_pool</span> <span>=</span> <span>db_pool</span>
    <span>yield</span>
    <span>await</span> <span>db_pool</span>.<span>close</span>()


<span>app</span> <span>=</span> <span>FastAPI</span>(<span>lifespan</span><span>=</span><span>lifespan</span>)


<span>async</span> <span>def</span> <span>get_db_connection</span>(<span>request</span>: <span>Request</span>) <span>-&gt;</span> <span>AsyncGenerator</span>[<span>Connection</span>]:
    <span>&#34;&#34;&#34;</span>
<span>    A dependency that provides a connection from the pool.</span>
<span>    It accesses the pool from the application state.</span>
<span>    &#34;&#34;&#34;</span>
    <span>db_pool</span> <span>=</span> <span>request</span>.<span>app</span>.<span>state</span>.<span>db_pool</span>

    <span>async</span> <span>with</span> <span>db_pool</span>.<span>connection</span>() <span>as</span> <span>conn</span>:
        <span>yield</span> <span>conn</span>


<span>@<span>app</span>.<span>get</span>(<span>&#34;/users/{user_id}&#34;</span>)</span>
<span>async</span> <span>def</span> <span>get_user</span>(
    <span>user_id</span>: <span>int</span>, <span>db_conn</span>: <span>Connection</span> <span>=</span> <span>Depends</span>(<span>get_db_connection</span>)
) <span>-&gt;</span> <span>dict</span>[<span>str</span>, <span>any</span>]:
    <span>cursor</span> <span>=</span> <span>await</span> <span>db_conn</span>.<span>execute</span>(<span>&#34;SELECT * FROM users WHERE id = ?&#34;</span>, (<span>user_id</span>,))
    <span>user</span> <span>=</span> <span>await</span> <span>cursor</span>.<span>fetchone</span>()

    <span>if</span> <span>not</span> <span>user</span>:
        <span>raise</span> <span>HTTPException</span>(<span>status_code</span><span>=</span><span>404</span>, <span>detail</span><span>=</span><span>&#34;User not found&#34;</span>)
    
    <span>return</span> <span>dict</span>(<span>user</span>)</pre></div>

<p dir="auto"><code>SQLiteConnectionPool</code> accepts these parameters:</p>
<p dir="auto"><strong>Required parameters</strong></p>
<ul dir="auto">
<li><strong><code>connection_factory</code></strong> - An async function that creates and returns a new database connection. This function will be called whenever the pool needs to create a new connection.</li>
</ul>
<p dir="auto"><strong>Optional parameters</strong></p>
<ul dir="auto">
<li>
<p dir="auto"><strong><code>pool_size</code></strong> (int) - Maximum number of connections to maintain in the pool (default: <code>5</code>)</p>
</li>
<li>
<p dir="auto"><strong><code>acquisition_timeout</code></strong> (int) - Maximum seconds to wait for an available connection (default: <code>30</code>)</p>
</li>
<li>
<p dir="auto"><strong><code>idle_timeout</code></strong> (int) - Maximum seconds a connection can remain idle before replacement (default: <code>86400</code> - 24 hours)</p>
</li>
</ul>
<p dir="auto"><strong>Recommended configurations</strong></p>
<p dir="auto">Most web applications work well with these settings:</p>
<div dir="auto" data-snippet-clipboard-copy-content="pool = SQLiteConnectionPool(
    connection_factory,
    pool_size=10,
    acquisition_timeout=30
)"><pre><span>pool</span> <span>=</span> <span>SQLiteConnectionPool</span>(
    <span>connection_factory</span>,
    <span>pool_size</span><span>=</span><span>10</span>,
    <span>acquisition_timeout</span><span>=</span><span>30</span>
)</pre></div>
<p dir="auto">For read-heavy workloads like analytics or reporting:</p>
<div dir="auto" data-snippet-clipboard-copy-content="pool = SQLiteConnectionPool(
    connection_factory,
    pool_size=20,
    acquisition_timeout=15
)"><pre><span>pool</span> <span>=</span> <span>SQLiteConnectionPool</span>(
    <span>connection_factory</span>,
    <span>pool_size</span><span>=</span><span>20</span>,
    <span>acquisition_timeout</span><span>=</span><span>15</span>
)</pre></div>
<p dir="auto">For write-heavy workloads:</p>
<div dir="auto" data-snippet-clipboard-copy-content="pool = SQLiteConnectionPool(
    connection_factory,
    pool_size=5,
    acquisition_timeout=60
)"><pre><span>pool</span> <span>=</span> <span>SQLiteConnectionPool</span>(
    <span>connection_factory</span>,
    <span>pool_size</span><span>=</span><span>5</span>,
    <span>acquisition_timeout</span><span>=</span><span>60</span>
)</pre></div>

<p dir="auto">The pool automatically:</p>
<ul dir="auto">
<li>Creates connections on-demand up to the pool size limit</li>
<li>Reuses idle connections to avoid creation overhead</li>
<li>Performs health checks to detect broken connections</li>
<li>Rolls back any uncommitted transactions when connections are returned</li>
<li>Replaces connections that have been idle too long</li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">Do you need a connection pool with SQLite?</h2><a id="user-content-do-you-need-a-connection-pool-with-sqlite" aria-label="Permalink: Do you need a connection pool with SQLite?" href="#do-you-need-a-connection-pool-with-sqlite"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">For server-based databases like PostgreSQL or MySQL, the answer is always yes. Connecting over a network is slow and expensive. A connection pool is a critical pattern to minimize latency and manage server resources.</p>
<p dir="auto">But SQLite is different. It&#39;s an embedded, in-process database. There&#39;s no network, no sockets, just a file on disk. The overhead of creating a connection is measured in microseconds, not even milliseconds.</p>
<p dir="auto">So, is a connection pool just needless complexity?</p>
<p dir="auto">The primary challenge with SQLite in a concurrent environment (like an <code>asyncio</code> web application) is not connection time, but <strong>write contention</strong>. SQLite uses a database-level lock for writes. When multiple asynchronous tasks try to write to the database simultaneously through their own separate connections, they will collide. This contention leads to a cascade of <code>SQLITE_BUSY</code> or <code>SQLITE_LOCKED</code> errors.</p>
<p dir="auto">Most applications will not encounter these issues, only a small percentage under heavy load!</p>
<p dir="auto">Here&#39;s a quick checklist. Use <code>aiosqlitepool</code> if:</p>
<ul dir="auto">
<li><strong>Your service handles steady web traffic</strong>: Your application serves more than <strong>5-10 requests per second</strong> from the database.</li>
<li><strong>Your workers process high-throughput jobs</strong>: Your background workers run more than <strong>~30 queries per second</strong>.</li>
<li><strong>Your application requires predictable low latency</strong>: Your service operates under a tight performance budget (e.g., p99 latency &lt; 50ms).</li>
<li><strong>You aim for a minimal footprint</strong>: You design your applications to be resource-efficient, knowing that reducing CPU and I/O load contributes to leaner, more sustainable infrastructure.</li>
</ul>
<p dir="auto">You don&#39;t need <code>aiosqlitepool</code> if your application is:</p>
<ul dir="auto">
<li>A <strong>short-lived script</strong> that runs a few queries and exits.</li>
<li>A <strong>very low-traffic service</strong> with fewer than a few requests per minute.</li>
</ul>

<p dir="auto">All benchmarks performed on a realistic database with:</p>
<ul dir="auto">
<li>1.2M users</li>
<li>120K posts</li>
<li>6M comments</li>
<li>12M likes</li>
</ul>

<p dir="auto"><em>1,000 concurrent requests across 100 workers</em></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Metric</th>
<th>Without Pool</th>
<th>With Pool</th>
<th>Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Queries/sec</strong></td>
<td>3,325</td>
<td>5,731</td>
<td><strong>+72%</strong></td>
</tr>
<tr>
<td><strong>Average latency</strong></td>
<td>28.98ms</td>
<td>17.13ms</td>
<td><strong>-41%</strong></td>
</tr>
<tr>
<td><strong>Median latency</strong></td>
<td>28.10ms</td>
<td>13.57ms</td>
<td><strong>-52%</strong></td>
</tr>
<tr>
<td><strong>P90 latency</strong></td>
<td>37.39ms</td>
<td>18.25ms</td>
<td><strong>-51%</strong></td>
</tr>
<tr>
<td><strong>P99 latency</strong></td>
<td>42.17ms</td>
<td>58.76ms</td>
<td>Variable*</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto"><em>*P99 latency shows pool contention under extreme load (100 workers, pool size 100) where 1% of requests must wait for connection availability</em></p>
<p dir="auto"><strong>Key takeaway</strong>: In realistic concurrent scenarios, connection pooling delivers 1.7x throughput improvement and 2x faster response times for 99% of requests.</p>

<p dir="auto"><em>10,000 simple SELECT operations across 5 workers</em></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Approach</th>
<th>Avg Latency</th>
<th>Median Latency</th>
<th>Total Time</th>
<th>Operations/sec</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Open/close per query</strong></td>
<td>1,019μs</td>
<td>1,006μs</td>
<td>2.04s</td>
<td>4,902</td>
</tr>
<tr>
<td><strong>Persistent connections</strong></td>
<td>396μs</td>
<td>389μs</td>
<td>0.79s</td>
<td>12,658</td>
</tr>
<tr>
<td><strong>Improvement</strong></td>
<td><strong>-61%</strong></td>
<td><strong>-61%</strong></td>
<td><strong>-61%</strong></td>
<td><strong>+158%</strong></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto"><strong>Pure connection overhead</strong>: Each connection create/destroy cycle costs <strong>623 microseconds</strong> (1,019 - 396 = 623μs) of pure overhead per database operation.</p>

<p dir="auto"><code>aiosqlitepool</code> is designed to be a flexible pooling layer that works with different asyncio SQLite drivers.</p>
<p dir="auto">To be compatible, a connection object from a driver must have implemented the following three <code>async</code> methods:</p>
<div dir="auto" data-snippet-clipboard-copy-content="class Connection:
    async def execute(self, *args, **kwargs):
        ...

    async def rollback(self) -&gt; None:
        ...

    async def close(self) -&gt; None:
        ..."><pre><span>class</span> <span>Connection</span>:
    <span>async</span> <span>def</span> <span>execute</span>(<span>self</span>, <span>*</span><span>args</span>, <span>**</span><span>kwargs</span>):
        ...

    <span>async</span> <span>def</span> <span>rollback</span>(<span>self</span>) <span>-&gt;</span> <span>None</span>:
        ...

    <span>async</span> <span>def</span> <span>close</span>(<span>self</span>) <span>-&gt;</span> <span>None</span>:
        ...</pre></div>
<p dir="auto"><strong>Note on <code>commit</code></strong>: The <code>commit</code> method is intentionally not part of the protocol. Transaction management is considered the responsibility of the application developer, not the pool. <code>aiosqlitepool</code> never commits on your behalf.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Officially supported drivers</h3><a id="user-content-officially-supported-drivers" aria-label="Permalink: Officially supported drivers" href="#officially-supported-drivers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The following libraries are tested and confirmed to work out-of-the-box with <code>aiosqlitepool</code>:</p>
<ul dir="auto">
<li><strong><a href="https://github.com/omnilib/aiosqlite">aiosqlite</a></strong></li>
</ul>

<p dir="auto">If you are using another asyncio SQLite library that follows the protocol, it should work seamlessly. Just pass your driver&#39;s connection function to the <code>connection_factory</code>.</p>
<p dir="auto">If you encounter an issue with a specific driver, please let us know by <a href="https://github.com/slaily/aiosqlitepool/issues">opening a GitHub issue</a>.</p>

<p dir="auto">aiosqlitepool is available under the MIT License.</p>
</article></div></div>
  </body>
</html>
