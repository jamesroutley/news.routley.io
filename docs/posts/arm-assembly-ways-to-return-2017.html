<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://quantum5.ca/2017/10/19/arm-ways-to-return/">Original</a>
    <h1>ARM Assembly: ∞ Ways to Return (2017)</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>ARM is unusual among the processors by having the program counter available as a “general purpose” register. Most other processors have the program counter hidden, and its value will only be disclosed as the return address when calling a function. If you want to modify it, a jumping instruction is used.</p>

<p>For example, on the x86, the program counter is called the instruction pointer, and is stored in <code>eip</code>, which is not an accessible register. After a function call, <code>eip</code> is pushed onto the stack, at which point it could be examined. Return is done through the <code>ret</code> instruction which pops the return address off the stack, and jumps there.</p>

<p>Another example: on the MIPS, the program counter is stored into register <code>31</code> after executing a <code>JALR</code> instruction, which is used for function calling. The value in there can be examined, and a return is a register jump <code>JR</code> to that register.</p>

<p>ARM’s unusual design allows many, many ways of returning from functions. But first, we must understand how function calls work on the ARM.</p>

<!--more-->

<p>On ARM, the program counter is register 15, or <code>r15</code>, also called <code>pc</code>. The instruction to call a function is <code>bl</code> (for immediate offsets) or <code>blx</code> (for addresses in registers). These instructions stores the return address in <code>r14</code>, called the link register, or <code>lr</code>. To return, we must put this value back into <code>pc</code>.</p>

<h2 id="method-1">Method 1</h2>

<p>When writing non-leaf functions, i.e. functions that calls other functions, the value of <code>lr</code> must be preserved, since calling another function will overwrite it. The most common way is to store it on the stack. On the ARM, there are convenient instructions <code>push</code> and <code>pop</code> which pushes and pops multiple values onto the stack. We typically use this to preserve the registers we modify. For example, if we want to preserve <code>r3</code>, <code>r4</code>, and <code>lr</code>, we can write <code>push {r3, r4, lr}</code>.</p>

<p>A normal function will look like:</p>

<pre><code>push        {r3, r4, lr}  ; Save registers.
; Function body.
pop         {r3, r4, pc}  ; Restore registers and return.
</code></pre>

<p>This is our first way of returning: using <code>push</code> to restore all the registers, except putting what was <code>lr</code> when we are doing <code>push</code> into <code>pc</code>. This will overwrite <code>pc</code> with the return address, achieving the return. Note that we could instead use <code>r14</code> instead of <code>lr</code> and <code>r15</code> instead of <code>pc</code>, but this is less clear on the intent.</p>

<h2 id="method-2">Method 2</h2>

<p>We can use an unconditional jump to register to return, which is useful in leaf functions where <code>lr</code> is never stored on the stack. This is simply:</p>

<pre><code>bx          lr
</code></pre>

<p>This jumps to the address in <code>lr</code>, setting <code>pc</code> to <code>lr</code>, and completing the return.</p>

<h2 id="method-3">Method 3</h2>

<p>Similar in rationale to method 2, but as stated in the beginning, ARM lets you manipulate the program counter as you would any other register. So… we have:</p>

<pre><code>mov         pc, lr
</code></pre>

<p>This copies <code>lr</code> into <code>pc</code>, also completing the return.</p>

<h2 id="method-4">Method 4</h2>

<p>To really get the point across, we can also use bitwise instructions to return. For example:</p>

<pre><code>orr         r15, r14, r14
</code></pre>

<p>This performs a bitwise OR of <code>r14</code> (<code>lr</code>) with itself, which results in the value of <code>lr</code>, and stores this in <code>r15</code> (<code>pc</code>). This also copies <code>lr</code> into <code>pc</code>, completing the return.</p>

<h2 id="method-n">Method <code>n</code></h2>

<p>Of course, there are many other ways of copying the value in one register into another, and to list that would be fairly silly. But as long as <code>lr</code> at the beginning of the function call is placed into <code>pc</code>, a return is completed.</p>

<p><strong>But please, use the most sensible ways to return.</strong> This means you should prefer the first two, depending on whether the function is a leaf. As a distant third, use method 3 (<code>mov pc, lr</code>).</p>

  </div></div>
  </body>
</html>
