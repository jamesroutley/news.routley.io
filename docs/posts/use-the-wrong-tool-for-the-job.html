<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/hillelwayne/archive/use-the-wrong-tool-for-the-job/">Original</a>
    <h1>Use the wrong tool for the job</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                    
                        <p>I’ve recently been real fascinated by the topic of <em>complexity</em> and what keeps us from keeping software simple. The wider net likes to blame “lazy programmers” and “evil managers” for this, as if any software could, with sufficient time, be made as simple as “hello world”. I’ve instead been looking at how various factors create complexity “pressure”. Code that needs to satisfy a physical constraint is more likely to be complex than code that doesn’t, etc.</p>
<p>One complexity pressure is “impedance”: when the problem you are solving isn’t well suited for the means you have to solve it. For example, if you need to write really fast software, then Python will be too slow. You can get around this by using foreign function interface, as scientific libraries do, or running multiple processes, as webdevs do, but these are solutions you might not need if you were using a faster language in the first place. In a sense impedance is complexity that comes from using “the wrong tool for the job.”</p>
<p>Saying that python is the “wrong tool” for data science is a little inflammatory. It might have impedance flaws, but it also has a lot going for it— rapid prototyping, a huge community, a large ecosystem, etc. Surely those matter more than the added complexity of slowness! </p>
<p>More broadly, “use the right tool for the job” directly contradicts the best practice of <a href="https://mcfunley.com/choose-boring-technology" target="_blank">choose boring technology</a>:</p>
<blockquote>
<p>Adding technology to your company comes with a cost. As an abstract statement this is obvious: if we’re already using Ruby, adding Python to the mix doesn’t feel sensible because the resulting complexity would outweigh Python’s marginal utility. But somehow when we’re talking about Python and Scala or MySQL and Redis <a href="https://martinfowler.com/bliki/PolyglotPersistence.html" target="_blank">people lose their minds</a>, discard all constraints, and start raving about using the best tool for the job.</p>
</blockquote>
<p>In the majority of cases, the benefits of using the same language for ten different problems outweighs the benefits of using the perfect language for every problem. </p>
<h3>Is Impedance Manageable?</h3>
<p>One advantage of boring technology: you can manage a <em>lot</em> more complexity in tech you’ve mastered than in tech you haven’t. Complexity (sometimes) happens when the amount of the system we have to think about is larger than the amount we can fit in our heads. But you can <a href="https://en.wikipedia.org/wiki/Chunking_(psychology)" target="_blank">chunk information</a> in familiar tech and so raise the amount you can “fit in your head”.</p>
<p>The wrong tool might add complexity through impedance, but you can also manage more complexity due to familiarity, so you’re still coming out ahead by using it.</p>
<p>(Another way that familiar tools help with complexity: the better you are at a tool, the easier it is to find simple and <em>idiomatic</em> solutions. I die a little inside whenever <a href="https://www.hillelwayne.com/consulting/" target="_blank">one of my clients</a> solves a TLA+ problem with double-recursive functions. Nine times out of ten there’s a simpler solution they’re unfamiliar with.) </p>
<h3>Greenspun’s Eleventh Rule</h3>
<p>I’m inclined to think that the benefits of familiar tooling is <em>enormous</em>, such that you’re often better using a wrong-but-familiar tool than a right-but-exotic tool. And there’s a problem with that. What you’re familiar with is highly circumstantial. If a team wants to make a slick web app, but all they know is Fortran, then they have a good argument for writing the app backend in Fortran.</p>
<p>…And then, if they need a yaml parser or a pdf generator or a job queue, then those should be in Fortran too. Over time, all language ecosystems will develop all possible language tooling, even if the tooling is for a purpose the language is completely unsuited to.<sup id="fnref:tooling"><a href="#fn:tooling">1</a></sup> Because no matter how wrong a tool is for the job, proper familiarity can turn it into the right tool.</p>
<p>(Obviously there’s a limit to this, which is why some webtech companies have migrated their Ruby and Python codebases to things like Go or TypeScript.)</p>
<p>This also <em>changes</em> what the right tool for the job is. If you ask me, Python isn’t that good <em>as a language</em> for scientific computing, both due to performance impedance and because of how hard it is to pipeline data. But because it has the large data ecosystem, it’s more appropriate now for that kind of work. Other languages now have more impedance because you’d need to reproduce those libraries.</p>
<h3>Tying it all together</h3>
<p>This is going in a lot of different places. Let’s bring it back together:</p>
<ol>
<li>Impedance is when you have to take on complexity to solve a problem, due to your choice of tools.</li>
<li>The more impedance, the more “wrong” your tool is for the job.</li>
<li>The complexity from impedance usually (<em>usually</em>) is counteracted by the higher complexity ceilings you get with familiar tools, and possibly by the additional simplifications you get from tool mastery.</li>
<li>Impedance isn’t a one-and-done deal: as a system grows, you need to do more things, which adds more impedance (and more places for worse impedance).</li>
<li>The ecosystem growing also reduces the impedance of the “wrong tool”, so it’s more viable in place of the “right tool”.</li>
</ol>
<p>I think impedance is an interesting source of complexity because it’s avoidable, but not one you always <em>should</em> avoid.  You’re often better off writing more complex software if you can stick with a familiar tool. </p>
<hr/>

<p>I wrote about <a href="https://learntla.com/topics/message-queues.html" target="_blank">modeling message queues in TLA+</a>.</p>

                    
                
            </div></div>
  </body>
</html>
