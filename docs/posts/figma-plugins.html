<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://macwright.com/2024/03/29/figma-plugins.html">Original</a>
    <h1>Figma Plugins</h1>
    
    <div id="readability-page-1" class="page"><div><p>At the beginning of 2023, I <a href="https://www.placemark.io/?path=/post/placemark-for-figma">released a Figma plugin called Placemark</a>, which lets you create vector maps in <a href="https://www.figma.com/">Figma</a>, the graphic design tool. Since then I’ve been maintaining that plugin for fun, and introduced another one, <a href="https://www.figma.com/community/plugin/1323092380415927575/placemark-globe">Placemark Globe</a>.</p><p>They’ve been somewhat successful! The Placemark plugin has 11.3k users, according to Figma’s community site, and Placemark Globe has 1.5k users. The feedback loop for plugins is okay - you can see how many likes your plugin has received, and how many “users” there are, but no change-over-time statistics, so I <a href="https://observablehq.com/@tmcw/placemark-figma-plugin-stats">built my own dashboard for the plugins using Observable</a>.</p><p><a href="https://observablehq.com/@tmcw/placemark-figma-plugin-stats"><img alt="Figma plugin statistics on Observable" src="https://macwright.com/images/2024-03-29-figma-plugins-figma-plugin-statistics-on-observable.png"/></a></p><p>But even with that, I don’t really know whether many people are actually using them. Maybe “users” means unique installations - it certainly doesn’t mean active users because the charts I’ve generated go “up only”, and I know that active user numbers are more volatile than that.</p><h3 id="sandboxing">Sandboxing</h3><p>I’m pretty fascinated by Figma plugins because of the challenges of sandboxing. Plugins are, by nature, third-party code that has access to a user’s documents, information, and to some extent, their computer. You want a plugin to be powerful, but safe.</p><p>Figma has a top-tier engineering team, and they <a href="https://www.figma.com/blog/how-we-built-the-figma-plugin-system/">struggled to make this work</a>. They even made a big misstep by first implementing a solution based on Realms that <a href="https://www.figma.com/blog/an-update-on-plugin-security/">was quickly found to be insecure</a>.</p><p>Sandboxing is such an interesting topic because everyone wants it, but there are so few examples of it actually ever working. For example, when I was working on <a href="https://github.com/openstreetmap/iD">iD</a>, the map editor for OpenStreetMap, we always had <a href="https://github.com/openstreetmap/iD/issues/1392">the challenge of creating a plugin architecture</a> to rival <a href="https://josm.openstreetmap.de/">JOSM</a>, the more established rival which is a Java-based desktop app.</p><h3 id="sandboxing-in-observable">Sandboxing in Observable</h3><p><a href="https://observablehq.com/">Observable</a> is a good example of real-world sandboxing in action. <a href="https://en.wikipedia.org/wiki/Mike_Bostock">Mike</a> had figured out basically the whole challenge before I got there: the architecture looks like:</p><ol><li>User code runs in an iframe with <code>sandbox</code> attributes. The top frame communicates with the iframe through <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">postMessage</a>.</li><li>The iframe can communicate back up to the top frame, and user code could maliciously send its own messages (there is no “trusted communication channel”), so any messages from the iframe are limited in their power. Mostly the iframe just tells the top frame the dimensions of its contents.</li><li>Each user has a wildcard subdomain that the iframe contents are hosted on, so that cookies can not conflict.</li></ol><p>This got us surprisingly far - the Observable sandbox generally just worked, from a security perspective, but it suffered from some other problems. For example, if someone wrote an infinite loop in an Observable Notebook, it would spin the iframe process up to 100% CPU and they’d have to engage a “safe mode” version of the application in order to get rid of the infinite loop. Browser vendors have tinkered with this for a bit now, whether iframes are <a href="https://www.chromium.org/developers/design-documents/oop-iframes/">out of process</a>, or shared with the top page, or maybe all iframes from a certain origin have their own process. It’s a complicated topic.</p><h3 id="sandboxing-in-val-town">Sandboxing in Val Town</h3><p>I wrote <a href="https://blog.val.town/blog/first-four-val-town-runtimes/">a long article about Val Town’s journey to sandboxing</a> recently. In short, the product started off on <a href="https://nodejs.org/en">Node.js</a>’s <a href="https://nodejs.org/docs/latest/api/vm.html">vm module</a> and <a href="https://www.npmjs.com/package/vm2">wrappers around it</a>, but quickly realized that there was no future to that approach: all of the attempts of sandboxing within a Node.js process were failing.</p><p>So, we switched to <a href="https://deno.com/">Deno</a>, the project started by <a href="https://en.wikipedia.org/wiki/Ryan_Dahl">Ryan Dahl</a>, the creator of Node.js. Deno has, from the very beginning, had a permissions model that lets you enable or disable a program’s access to resources. So finally you can do something like installing a module and catching it in the act before it tries to read from your <code>/etc/passwd</code> file, and then actually preventing it from doing so.</p><p>Val Town uses <a href="https://github.com/casual-simulation/node-deno-vm">node-deno-vm</a> to start up a separate Deno process, which exposes a WebSocket, receives user code, and runs it with Deno’s permissions model. There’s some overhead but it otherwise works really well.</p><p>Deno is extremely cool and has worked really well so far.</p><h3 id="sandboxing-in-figma">Sandboxing in Figma</h3><p>Figma’s eventual solution to the sandboxing problem was to use <a href="https://bellard.org/quickjs/">QuickJS</a>, which is a JavaScript engine that’s small and can be compiled to WASM. In effect, you can run a JavaScript engine in JavaScript with QuickJS.</p><p>So basically the <a href="https://www.figma.com/plugin-docs/how-plugins-run/">plugin architecture</a> runs part of your plugin in an iframe, where you display a UI, and part of it within QuickJS, where that code is able to actually read and write from your Figma document.</p><p>Now having written two Figma plugins, I can say that this <em>works</em>. The biggest issues that I’ve run into are debuggability and performance.</p><p><img alt="Figma crashing" src="https://macwright.com/images/2024-03-29-figma-plugins-figma-crashing.png"/></p><p>JavaScript’s debugging story is just extremely good. Most of the time when something goes wrong in your code, you get a nice error message that specifies where it happened, and you can use the debugging tools to get more information. I <a href="https://macwright.com/2015/03/10/javascript-diagnosis">wrote about this back in 2015</a>.</p><p>When QuickJS encounters an issue in Figma, you get truly impenetrable errors. I’ve spent a lot of time just guessing what’s going wrong with my plugins, because all I have to go on is something like the stacktrace above.</p><p>It’s harder to quantify, but the performance of Figma plugins is also not great. They’ve recently launched <a href="https://www.figma.com/plugin-docs/migrating-to-dynamic-loading/">dynamic loading</a>, which should improve some performance at the edges, but my plugins still run slower than they feel like they should. Though, of course, I’m making geospatial plugins, and it’s easy to forget that geospatial data has its somewhat unique requirements on systems. Geospatial tools churn through a lot more data than most drawing tools.</p><h3 id="plugin-architectures">Plugin architectures</h3><p>I should reiterate how amazing it is that Figma has a plugin architecture that allows many people to author plugins. It is <em>extremely rare</em> for this to exist on a website. If I tried to name another website with somewhat freeform community plugins that ran on the frontend, I couldn’t.</p><p>I really wish it was easier to build this kind of thing! For all the talk about the web lacking a payments mechanism, we should pay more attention to the fact that the web lacks an extensibility mechanism: we basically have iframes as the only security primitive that enables plugin architectures, and they leave a lot to be desired. WebAssembly is the future (and has been the future for many years), but the story for distribution and debugging of WebAssembly code is still barely written.</p><p>Of course, sandboxing in general is a hard issue. There are some success stories - scripting video games in Lua is certainly one of them. The web would be much different and hopefully much better if normal websites were customizable and extensible.</p><p>Now that I’ve gotten my rant about sandboxing out of the way, what about the rest of the Figma plugin authoring flow?</p><p>It’s pretty good! Publishing new versions of Figma plugins is really seamless, just a few clicks, and it’s instantly on the community site. The success is very evident in <a href="https://www.figma.com/community">the Figma Community site</a> that has lots of content. There are lots of other <a href="https://www.figma.com/community/search?resource_type=plugins&amp;sort_by=relevancy&amp;query=maps&amp;editor_type=figma&amp;price=all&amp;creators=all">plugins that target mapping</a>, of various levels of quality.</p><h3 id="the-placemark-plugin">The Placemark Plugin</h3><p><em>Note: this post is about a bunch of different topics, as you can probably tell by now, which are tangentially related. I could edit them into something more cohesive, but I am writing for the fun of it and maybe reading this is fun too.</em></p><p><img alt="Screenshot of the Figma Plugin page" src="https://macwright.com/images/2024-03-29-figma-plugins-screenshot-of-the-figma-plugin-page.png"/></p><p>The <a href="https://www.figma.com/community/plugin/1189962635826293304/placemark">Placemark Figma Plugin</a> is by far the more advanced project. It pulls map data straight from <a href="https://overpass-turbo.eu/">Overpass Turbo</a>, which is an API for <a href="https://www.openstreetmap.org/">OpenStreetMap</a> data. This is pretty intentional, relative to the options:</p><ul><li>Loading maps from a raster tile source would both produce static, raster maps that can’t be further styled, and would also introduce another layer of intellectual property: the styles of a provider like Mapbox or Maptiler are generally copyrighted.</li><li>Loading tiles from a vector tile source might be a good idea in the long run, but vector tiles are generally optimized for performance and lightness, not completeness. With my plugin currently, you can really get the whole OpenStreetMap data model if you want to, down to adding trees to the map.</li></ul><p>So, loading from OpenStreetMap gives the plugin some extra power and simplicity, and it’s pretty clear that the only attribution required is the <a href="https://www.openstreetmap.org/copyright">OpenStreetMap standard attribution</a>, which the plugin adds by default (silence, trolls!)</p><p>It’s open source, so you can <a href="https://github.com/placemark/figma-plugin">see how it does all of this</a>. Basically, it implements a tiny static map rendering engine, with label placement, styling, some understanding of OpenStreetMap’s tagging scheme, and more. It uses <a href="https://en.wikipedia.org/wiki/D3.js">d3’s</a> implementation of the Mercator <a href="https://macwright.com/2012/01/27/projections-understanding">map projection</a>, which doesn’t make much of a difference at the local scale.</p><p>The plugin has two big weaknesses: water and zoom levels.</p><p><img alt="Water, as rendered by the plugin" src="https://macwright.com/images/2024-03-29-figma-plugins-water-as-rendered-by-the-plugin.png"/></p><p>It’s pretty bad at rendering bodies of water. This is a really hard problem in the world of maps: let’s say that you’re rendering a map that shows some coastal town and the ocean is to the right. How do you know that the ocean is to the right? Have you downloaded the entire, enormous, ocean polygon? That’d dramatically slow down your rendering process. There are ways to do this efficiently which are pretty surprising and cool:</p><blockquote><p>The direction the ways are drawn is very important! They must be drawn so that the land is on the left side and water on the right side of the way (when viewing in the direction of the way arrows). If you regard this as tracing around an area of land, e.g., an island, then the coastline way should be running counterclockwise. <a href="https://wiki.openstreetmap.org/wiki/Tag:natural%3Dcoastline">- from the OpenStreetMap wiki</a></p></blockquote><p>However, I haven’t found the time to implement coastlines intelligently. It’s open source, so if you feel inspired, I am ready to merge the PR.</p><p>The other problem is simply zoom levels: to render a zoomed-out map, I’ll need to craft different Overpass Turbo queries so that the amount of data downloaded is more reasonable, and I haven’t done so yet.</p><h3 id="the-placemark-globe-plugin">The Placemark Globe Plugin</h3><p><img alt="Screenshot of the Figma Placemark Globe Plugin page" src="https://macwright.com/images/2024-03-29-figma-plugins-screenshot-of-the-figma-placemark-globe-plugin-page.png"/></p><p>The <a href="https://www.figma.com/community/plugin/1323092380415927575/placemark-globe">Placemark Globe</a> plugin is way simpler: it just renders a globe. It doesn’t even render labels yet.</p><p>I think that the impetus for creating this was, the usual that “this doesn’t exist yet”, but also that things that are technically simple can still be useful. Someday I’ll find something that’s both simple, useful, and profitable!</p><p>This plugin uses <a href="https://d3js.org/">d3</a> more heavily - really, it wouldn’t be possible without all the hard work from d3. The plugin component of it is translating SVG into Figma’s document model and styling system, which is just a bit different than SVG. And making all of that convenient. There are certainly many other ways of generating a vector globe and pulling it into Figma - this is just an easy one.</p><p>Because this shows borders, it uses the <a href="https://github.com/visionscarto/world-atlas">Visionscarto World Atlas</a> project for data, a modified version of <a href="https://www.naturalearthdata.com/">Natural Earth</a> which shows some contentious borders in a more globally-accepted sense. There is a lot written about international borders in cartography that I won’t try to summarize here.</p><h3 id="plugin-architecture">Plugin architecture</h3><p>I used <a href="https://github.com/yuanqing/create-figma-plugin">create-figma-plugin</a> for the Globe plugin initially. I think it has some good patterns. There’s also some <a href="https://github.com/figma/plugin-resources">great resources for plugin development</a> elsewhere.</p><p>Basically, I think I’ve decided that React is overkill for Figma plugins. Nearly any framework is overkill if you just have a few UI elements. Just write some HTML and JavaScript and don’t overthink it. I do wish that there was a standalone CSS framework for these, so that I can get that Figma aesthetic, and dark mode support, right off the bat.</p><hr/><p>Maintaining these Figma plugins has been pretty fun. It lets me scratch the itch of tinkering with new technology and it helps me keep a little presence in the world of maps, which I still like.</p></div></div>
  </body>
</html>
