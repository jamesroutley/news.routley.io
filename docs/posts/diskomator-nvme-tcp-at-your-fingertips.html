<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/poettering/diskomator">Original</a>
    <h1>Diskomator ‚Äì NVMe-TCP at your fingertips</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><em>ü¶† NVMe-TCP at your fingertips ü¶†</em></p>
<p dir="auto">Diskomator is an OS-in-an-EFI-binary whose only job is to expose all
local disks as NVMe-TCP network block devices, as they appear.</p>
<p dir="auto">When built, it results in a single UEFI binary, that embeds a full OS
root file system so that it does not need any further disk access
while it runs. The EFI binary can be invoked directly from the UEFI
firmware, for example by placing it an EFI System Partition (ESP). The
OS root file system contains:</p>
<ol dir="auto">
<li>
<p dir="auto">A Fedora Linux OS tree</p>
</li>
<li>
<p dir="auto">A current version of systemd (v255-rc2),
including
<a href="https://www.freedesktop.org/software/systemd/man/latest/systemd-storagetm.html" rel="nofollow">systemd-storagetm</a>
and
<a href="https://www.freedesktop.org/software/systemd/man/latest/systemd-networkd.html" rel="nofollow">systemd-networkd</a>.</p>
</li>
<li>
<p dir="auto">An SSH server (just to make things easy to debug)</p>
</li>
<li>
<p dir="auto">The Plymouth boot splash tool to make things pretty at boot and during runtime.</p>
</li>
</ol>
<p dir="auto">The image is built via <a href="https://github.com/systemd/mkosi"><code>mkosi</code></a>.</p>
<p dir="auto">All this then does is boot up into a minimal mode where
<code>systemd-storagetm</code> and <code>systemd-networkd</code> are running. The former
exposes all local block devices via NVMe-TCP, the latter configures
all local network devices.</p>
<p dir="auto">The resulting EFI binary is relatively large (~300M), because it
embeds all kinds of network drivers and graphics devices, plus their
firmware. To keep things simply this stays close to upstream Fedora,
without any attempts to minimize footprint.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-why-even" aria-hidden="true" tabindex="-1" href="#why-even"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Why Even?</h2>
<p dir="auto">My personal usecase for this goes something like this: I build
immutable OS images for physical systems regularly and try them out. I
could always write them to an USB stick on my development machine and
then unplug it, and plug it into my testing machine. But that&#39;s
cumbersome. My way out: just have a way how the test machine&#39;s disk
can be written to directly from my development machine. And that&#39;s
what Diskomator is.</p>
<p dir="auto">Other usecases:</p>
<ul dir="auto">
<li>Debugging</li>
<li>Remote installation of OSes</li>
<li>Turn your 2000 USD laptop into a very expensive USB stick</li>
<li>It&#39;s a fantastic show-case for UKIs, <code>mkosi</code>, Linux and <code>systemd</code> I think</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-caveats" aria-hidden="true" tabindex="-1" href="#caveats"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Caveats</h2>
<ul dir="auto">
<li>
<p dir="auto"><g-emoji alias="warning">‚ö†Ô∏è</g-emoji> This currently does not enable NVME authentication nor
encryption. If you boot from this your disk will be readable and
writable to anyone with access to your local network!</p>
</li>
<li>
<p dir="auto"><g-emoji alias="warning">‚ö†Ô∏è</g-emoji> The <code>root</code> user is accessible via SSH with the password <em>test</em>,
again to anyone with access to your local network!</p>
</li>
<li>
<p dir="auto"><g-emoji alias="warning">‚ö†Ô∏è</g-emoji> A debug shell is always available on Alt-F9.</p>
</li>
<li>
<p dir="auto">This requires an EFI system, with a bit of RAM. After all the OS
is entirely kept in memory.</p>
</li>
<li>
<p dir="auto">The resulting EFI binary is not SecureBoot signed, you thus have to
disable SecureBoot if you want to use this. (You can easily add that
though, if you have a suitable key pair. <code>mkosi</code> will help with
that, see documentation.)</p>
</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-building" aria-hidden="true" tabindex="-1" href="#building"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Building</h2>
<p dir="auto">You&#39;ll need:</p>
<ol dir="auto">
<li>
<p dir="auto">A build tree of a current systemd development version, to get the
newest version of <code>systemd-repart</code>. Once distributions started to
regularly ship v255, this manual step will go away. On a Fedora
system you&#39;d do it like this:</p>
<div data-snippet-clipboard-copy-content="sudo dnf builddep systemd
git clone https://github.com/systemd/systemd.git
cd systemd
meson build
ninja -C build"><pre><code>sudo dnf builddep systemd
git clone https://github.com/systemd/systemd.git
cd systemd
meson build
ninja -C build
</code></pre></div>
<p dir="auto">And with that you should have a version of systemd built in the
<code>build</code> sub-directory. No need to install this, BTW, just keep it
around, we can use the build tree directly in step 4.</p>
</li>
<li>
<p dir="auto">v19 of <a href="https://github.com/systemd/mkosi"><code>mkosi</code></a> or newer. If
your distribution doesn&#39;t have that yet, you can trivially check it
out too:</p>
<div data-snippet-clipboard-copy-content="sudo dnf builddep mkosi
git clone https://github.com/systemd/mkosi.git"><pre><code>sudo dnf builddep mkosi
git clone https://github.com/systemd/mkosi.git
</code></pre></div>
</li>
<li>
<p dir="auto">A checkout of <code>diskomator</code>:</p>
<div data-snippet-clipboard-copy-content="git clone https://github.com/poettering/diskomator.git
cd diskomator
git submodule update --init"><pre><code>git clone https://github.com/poettering/diskomator.git
cd diskomator
git submodule update --init
</code></pre></div>
</li>
<li>
<p dir="auto">Now edit <code>mkosi.conf</code> in the diskomator directory locally on your
system, and adjust the (by default commented) <code>ExtraSearchPaths=</code>
line to point to the build tree from step 1.</p>
</li>
<li>
<p dir="auto">You are now ready to build the image. In the <code>diskomator</code> git
checkout run:</p>
<div data-snippet-clipboard-copy-content="sudo ../mkosi/bin/mkosi -T -i -f build"><pre><code>sudo ../mkosi/bin/mkosi -T -i -f build
</code></pre></div>
<p dir="auto">(The <code>-T -i -f</code> you can theoretically drop BTW, I only specify them
here since it improves rebuild times in case you hack on this.)</p>
<p dir="auto">Adjust the <code>mkosi</code> path to match where you placed the checkout tree
from step 3.</p>
<p dir="auto">Once this completes you&#39;ll have two things in the <code>mkosi.output/</code>
subdirectory: <code>diskomator.efi</code> and <code>diskomator.raw</code>. The former is
the EFI binary that we care about. The latter is a GPT disk image
with an ESP with that very EFI binary in it (and no other
partitions). The latter you can directly <code>dd</code> to an USB stick if
you like, to boot another system from.</p>
<p dir="auto">You can even let <code>mkosi</code> do the <code>dd</code>&#39;ing for you. Which is actually
a good idea, since it will make sure the image is adapted to your
chosen target device&#39;s sector and disk size üî•üî•üî•:</p>
<div data-snippet-clipboard-copy-content="sudo ../mkosi/bin/mkosi burn /dev/disk/by-id/usb-SanDisk_Ultra_Fit_4C530000190505109123-0\:0"><pre><code>sudo ../mkosi/bin/mkosi burn /dev/disk/by-id/usb-SanDisk_Ultra_Fit_4C530000190505109123-0\:0
</code></pre></div>
<p dir="auto">Replace the last argument in that command line by the path to the
device node you want to write this to. As you can see I have a
SanDisk USB stick I am testing this with.</p>
</li>
</ol>
<p dir="auto">And that&#39;s really all.</p>
<p dir="auto">Once systemd v255 and mkosi v19 entered the various distributions step
1, 2 and 4 will become unnecessary (and the git submodule thing from
step 3). Once that happened you only have to do 3 and 5.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-future" aria-hidden="true" tabindex="-1" href="#future"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Future</h2>
<p dir="auto">I&#39;d like to live to see a future where people build appliances like
this for various purposes, not just this specific NVMe one. For
example, a nice thing to have would be an appliance whose only job is
to make all local displays available via Miracast. I hope this
repository is inspiration enough for an interested soul, to get this
off the ground.</p>
<p dir="auto">Ideally, distributions would build images like this on their
own. Specifically, I&#39;d be delighted if Fedora (for example) would
build an image like this and SecureBoot sign it, within their own
build infrastructure and make that an offering to their users.</p>
<p dir="auto">In the meantime it might be nice to build diskomator on the usually
available Open Source build infrastructure somewhere, so that people
can just download a <code>.raw</code> or <code>.efi</code> file, instead of the cumbersome
build steps listed above. Anyone interested in setting this up?</p>
<p dir="auto">Anyway, I hope this piqued your interest, now run and do with all this
whatever you want!</p>
</article>
          </div></div>
  </body>
</html>
