<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wiomoc.de/misc/posts/hacking_coroutines_into_c.html">Original</a>
    <h1>Hacking Coroutines into C</h1>
    
    <div id="readability-page-1" class="page"><article>


    



<span>12.7.2025</span>
<p>A while ago, I was part of a team developing embedded software. The software was deeply rooted in state machines - dozens of them—spread across multiple functions. While this architecture is common in embedded development, especially for systems without an operating system, I started to question: <strong>Is this really the clearest way to express control flow?</strong></p>
<p>The state machines in our code worked fine, but understanding and maintaining them was often a headache. They lacked a <em>linear flow</em>, requiring mental juggling of flags, states, and transitions scattered across polling functions.</p>
<p>I kept thinking: <em>Wouldn&#39;t this be easier if we could just write the logic like a sequential program—waiting for events and resuming where we left off?</em></p>
<p>Of course, the project didn’t allow us to use an RTOS. So, the conventional approach of using threads or blocking system calls to manage concurrency was off the table. Yet, I knew there had to be a middle ground.</p>
<p>Around that time, I had been using <strong>coroutines</strong> in languages like Python, JavaScript, Dart, and Rust. They allow you to pause and resume execution without relying on threads—offering a kind of <em>cooperative multitasking</em>.</p>
<p>It hit me: this coroutine pattern could be the perfect fit for our problem—providing concurrency without requiring an OS.</p>
<p>Before diving into a coroutine-based solution, let’s take a step back and look at a small toy example that illustrates the problem.</p>
<p>We want to implement an LED blinker with a user-controllable period, denoted as $p$. Initially, the LED blinks with a fixed period of 2 seconds. However, the user should be able to change this period at any time by pressing and holding a button. When the button is released, the LED should restart its blinking cycle with a new period equal to twice the duration the button was held ($p/2$).</p>
<p>To model this behavior, we can use two simple state machines, as shown in the following figure:
<img src="https://wiomoc.de/misc/assets/state_machine.svg" alt="Statemachine"/></p>
<p>The first state machine, <code>led_blinker</code>, consists of two states: <code>LED_ON</code> and <code>LED_OFF</code>. The system transitions from <code>LED_ON</code> to <code>LED_OFF</code> after a delay of $p/2$, and similarly from <code>LED_OFF</code> back to <code>LED_ON</code> after another $p/2$. Additionally, if a <code>resetLed</code> event is received from the second state machine, the <code>led_blinker</code> transitions immediately to the <code>LED_OFF</code> state, regardless of its current state. This state machine starts in the <code>LED_OFF</code> state.</p>
<p>The second state machine, <code>button_record</code>, also has two states: <code>WAIT_BUTTON_PRESSED</code> and <code>WAIT_BUTTON_UNPRESSED</code>. In the initial state, it waits for the user to press the button. Once the button is pressed, it records the current time $t_s$ and transitions to the <code>WAIT_BUTTON_UNPRESSED</code> state. In this state, it waits for the user to release the button. When the button is released, it captures the current time $t_e$, calculates the new half-period as $p/2 = t_e - t_s$, emits a <code>resetLed</code> event, and returns to the <code>WAIT_BUTTON_PRESSED</code> state.</p>
<p>Implementing polling based for arduino, would look some like this:</p>
<pre><code><span>#<span>define</span> BUTTON_PIN 2</span>

<span><span>enum</span> <span>led_blink_state</span> {</span>
  STATE_LED_OFF = <span>0</span>,
  STATE_LED_ON
};

<span>uint64_t</span> led_blink_duration_ms = <span>1000</span>;
<span>uint64_t</span> led_blink_toggle_time = <span>0</span>;
<span>uint8_t</span> reset_led_requested = <span>0</span>;

<span><span>enum</span> <span>button_record_state</span> {</span>
  STATE_WAIT_BUTTON_PRESSED = <span>0</span>,
  STATE_WAIT_BUTTON_UNPRESSED
};

<span>void</span> <span>setup</span><span>()</span> {
  led_blink_state = STATE_LED_OFF;
  button_record_state = STATE_WAIT_BUTTON_PRESSED;
  led_blink_toggle_time = millis() + led_blink_duration_ms;

  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
}

<span>void</span> <span>poll_led_blink</span><span>()</span> {
  <span>static</span> <span><span>enum</span> <span>led_blink_state</span> =</span> STATE_LED_OFF;
  <span>if</span> (led_blink_state == STATE_LED_OFF) {
    digitalWrite(LED_BUILTIN, LOW);
  } <span>else</span> <span>if</span> (led_blink_state == STATE_LED_ON) {
    digitalWrite(LED_BUILTIN, HIGH);
  }

  
  <span>if</span> (reset_led_requested) {
      reset_led_requested = <span>0</span>;
      led_blink_state = STATE_LED_OFF;
      led_blink_toggle_time = millis() + led_blink_duration_ms;
  } <span>else</span> <span>if</span> (millis() &gt;= led_blink_toggle_time) {
    <span>if</span> (led_blink_state == STATE_LED_OFF) {
      led_blink_state = STATE_LED_ON;
    } <span>else</span> <span>if</span> (led_blink_state == STATE_LED_ON) {
      led_blink_state = STATE_LED_OFF;
    }
    led_blink_toggle_time = millis() + led_blink_duration_ms;
  }
}

<span>void</span> <span>poll_button_record</span><span>()</span> {
  <span>static</span> <span><span>enum</span> <span>button_record_state</span> =</span> STATE_WAIT_BUTTON_PRESSED;
  <span>static</span> <span>int</span> button_pressed_start_time = <span>0</span>;
  <span>if</span> (button_record_state == STATE_WAIT_BUTTON_PRESSED) {
    <span>if</span> (digitalRead(BUTTON_PIN) == LOW) {
      button_record_state = STATE_WAIT_BUTTON_UNPRESSED;
      button_pressed_start_time = millis();
    }

  } <span>else</span> <span>if</span> (button_record_state == STATE_WAIT_BUTTON_UNPRESSED) {
    <span>if</span> (digitalRead(BUTTON_PIN) == HIGH) {
      button_record_state = STATE_WAIT_BUTTON_PRESSED;
      <span>int</span> button_pressed_end_time = millis();
      led_blink_duration_ms = button_pressed_end_time - button_pressed_start_time;
      reset_led_requested = <span>1</span>;
    }
  }
}

<span>void</span> <span>loop</span><span>()</span> {
  poll_led_blink();
  poll_button_record();
}
</code></pre>
<p>This implementation is almost a one-to-one translation of the state machines into C code. Mapping the diagram to code is relatively straightforward. However, once you look solely at the code, it becomes difficult to follow the actual behavior. That’s because there&#39;s no linear control flow in either the <code>poll_led_blink</code> or <code>poll_button_record</code> functions. Instead, they’re repeatedly called in a loop, checking the current state and reacting accordingly—which fragments the logic and makes it harder to reason about.</p>
<p>Wouldn’t it be simpler if each state machine function could just pause—waiting for something to happen, like a button press or release, a timer to expire, or a <code>resetLed</code> event—and then resume execution from that point onward? This kind of structure would allow us to write code that follows a clear, sequential flow. Implementing such behavior becomes quite straightforward when using FreeRTOS, by mapping each state machine to a separate task that can block while waiting for events.</p>
<pre><code><span>#<span>include</span> <span>&lt;Arduino_FreeRTOS.h&gt;</span></span>

<span>#<span>define</span> BUTTON_PIN 2</span>

TickType_t led_blink_duration_ticks = pdMS_TO_TICKS(<span>1000</span>);

TaskHandle_t led_blink_task_handle;
<span>#<span>define</span> NOTIFYBIT_RESET_LED 0x80</span>

<span>void</span> <span>led_blink</span><span>()</span> {
  <span>while</span> (<span>true</span>) {
    digitalWrite(LED_BUILTIN, LOW);
    
    <span>if</span> (xTaskNotifyWait(<span>0</span>, NOTIFYBIT_RESET_LED, <span>NULL</span>, led_blink_duration_ticks) == pdTRUE) {
      
      <span>continue</span>;
    }
    digitalWrite(LED_BUILTIN, HIGH);
    
    xTaskNotifyWait(<span>0</span>, NOTIFYBIT_RESET_LED, <span>NULL</span>, led_blink_duration_ticks);
  }
}

<span>void</span> <span>wait_pin</span><span>(<span>int</span> pin, <span>int</span> level)</span> {
  <span>while</span> (digitalRead(pin) == level)
    ;
}

<span>void</span> <span>button_record</span><span>()</span> {
  <span>while</span> (<span>true</span>) {
    wait_pin(BUTTON_PIN, HIGH);
    TickType_t start_time_ticks = xTaskGetTickCount();
    
    wait_pin(BUTTON_PIN, LOW);
    TickType_t end_time_ticks = xTaskGetTickCount();
    led_blink_duration_ticks = end_time_ticks - start_time_ticks;
    xTaskNotify(led_blink_task_handle, NOTIFYBIT_RESET_LED, eSetBits);  
  }
}

<span>void</span> <span>setup</span><span>()</span> {
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);

  xTaskCreate(led_blink, <span>&#34;led_blink&#34;</span>, <span>512</span>, <span>NULL</span>, <span>1</span>, &amp;led_blink_task_handle);
  xTaskCreate(button_record, <span>&#34;button_record&#34;</span>, <span>512</span>, <span>NULL</span>, <span>1</span>, <span>NULL</span>);
}

<span>void</span> <span>loop</span><span>()</span> {}
</code></pre>
<p>In my view, this approach is much easier to read and understand. It also eliminates the need to define a discrete state machine design upfront—you can simply express the logic directly as sequential code.</p>
<p>However, there&#39;s an important trade-off: this solution requires an operating system. Specifically, it relies on (preemptive) scheduling to switch between tasks, which means your project must include an OS like FreeRTOS.</p>
<p>So finally the implementation on my hacky macro-based coroutines, the rough structure of the task implementation is very similar to the freeRTOS based approach. Let&#39;s start with the implementation of the <code>button_recorder</code> first:</p>
<pre><code>CORO(button_recorder_fn,
     CORO_NO_ARGS,
     CORO_LOCALS(<span>uint64_t</span> button_pressed_start_time;),
     CORO_CALLS(
        CORO_CALL(wait_pin_low, wait_pin),
        CORO_CALL(wait_pin_high, wait_pin)), {
       <span>coro_res_t</span> res;
       <span>while</span> (<span>true</span>) {
         CALL(res, wait_pin_low, wait_pin, BUTTON_PIN, LOW);
         LOCAL(button_pressed_start_time) = millis();

         CALL(res, wait_pin_high, wait_pin, BUTTON_PIN, HIGH);
         <span>uint64_t</span> button_pressed_end_time = millis();
         led_blink_duration_ms = button_pressed_end_time - LOCAL(button_pressed_start_time);
         coro_cond_var_notify(&amp;reset_led_signal);
       }
       <span>return</span> CORO_RES_DONE;
     })
</code></pre>
<p>At first glance, this might look like just a wall of macros. But what&#39;s really happening here is that the macros are effectively <em>transpiling</em> the coroutine into an explicit state machine at compile time. To understand this, we need to take a brief detour into how normal function calls work and what we&#39;re doing differently here.</p>
<p>In a typical C function, the call stack is used to manage control flow and store local variables. Every function call pushes a <em>stack frame</em> onto the call stack, which contains the return address, parameters, and local variables. Once the function returns, the frame is popped off, and execution continues where it left off.</p>
<p>However, in our coroutine system, we can&#39;t rely on this built-in stack mechanism because we&#39;re pausing execution at arbitrary points and resuming later—potentially from a different part of the program loop. Instead, we manage our own <em>manual</em> control flow. All local variables that need to persist across <code>await</code>-style calls must be stored <em>outside</em> the standard stack—in a structure tied to the coroutine&#39;s context. That&#39;s what the <code>CORO_LOCALS</code> macro sets up.</p>
<p>Similarly, since there&#39;s no stack to implicitly remember where we left off (like a return address), we use an explicit state variable to represent the coroutine’s current execution point. Each possible <code>CALL</code> to a sub-coroutine defines a state, declared via <code>CORO_CALLS</code>, and each of those sub-coroutines has its own context as well. This is very much like manually implementing what the C compiler normally handles for you when it compiles regular function calls.</p>
<p>This pattern is reminiscent of a classic C trick known as <strong>Duff&#39;s Device</strong>—a technique that uses a <code>switch</code> statement combined with loop unrolling to implement a form of coroutine or co-operative multitasking. We’re using a similar mechanism here: a <code>switch</code>-based jump table that resumes execution at the exact point it was paused last time.
To make this clearer, here’s what the <code>button_recorder</code> coroutine looks like after macro expansion:</p>
<pre><code><span><span>enum</span> <span>button_recorder_fn_fct_state</span> {</span>
  button_recorder_fn_state_initial = <span>0</span>,
  coro_state_wait_pin_low,
  coro_state_wait_pin_high
};
<span><span>struct</span> <span>button_recorder_fn_fct_ctx</span> {</span>
  <span><span>enum</span> <span>button_recorder_fn_fct_state</span> <span>state</span>;</span>
  <span>uint64_t</span> button_pressed_start_time;
  <span><span>union</span> {</span>
    <span>uint8_t</span> _placeholder_;
    <span><span>struct</span> <span>wait_pin_fct_ctx</span> <span>wait_pin_low</span>;</span>
    <span><span>struct</span> <span>wait_pin_fct_ctx</span> <span>wait_pin_high</span>;</span>
  } calls;
};

<span>coro_res_t</span> <span>button_recorder_fn_fct</span><span>(<span>struct</span> button_task_fn_fct_ctx *ctx)</span> {
  <span>switch</span> (ctx-&gt;state) {
  <span>case</span> button_recorder_fn_state_initial: {
    <span>coro_res_t</span> res;
    <span>while</span> (<span>1</span>) {
      
      ctx-&gt;state = coro_state_wait_pin_low;
      ctx-&gt;calls.wait_pin_low.state = (<span>enum</span> wait_pin_fct_state)<span>0</span>;
      <span>case</span> coro_state_wait_pin_low:
      res = wait_pin_fct(&amp;ctx-&gt;calls.wait_pin_low, <span>2</span>, LOW);
      <span>if</span> (res &amp; CORO_RES_PENDING)
        <span>return</span> res;
      
      (ctx-&gt;button_pressed_start_time) = millis();
      
      
      ctx-&gt;state = coro_state_wait_pin_high;
      ctx-&gt;calls.wait_pin_high.state = (<span>enum</span> wait_pin_fct_state)<span>0</span>;
      <span>case</span> coro_state_wait_pin_high:
      res = wait_pin_fct(&amp;ctx-&gt;calls.wait_pin_high, <span>2</span>, HIGH);
      <span>if</span> (res &amp; CORO_RES_PENDING)
          <span>return</span> res;
      
      <span>uint64_t</span> button_pressed_end_time = millis();
      led_blink_duration_ms =
          button_pressed_end_time - (ctx-&gt;button_pressed_start_time);
      coro_cond_var_notify(&amp;reset_led_signal);
    }
    <span>return</span> CORO_RES_DONE;
  }
  }
}
</code></pre>
<p>In this form, it&#39;s clear how the macro system rewrites the coroutine into a state machine. Each <code>CALL</code> effectively becomes a case label in a <code>switch</code>, and <code>ctx-&gt;state</code> tracks which part of the function should run next time it&#39;s resumed. All local state and subroutine call contexts are persistently stored in a heap-allocated (or static) struct rather than on the call stack.</p>
<p>A similar idea is presented in the following <a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">blog article</a> from Simon Tatham, which describes this pickpocket trick quite appropriately:</p>
<blockquote>
<p>Of course, this trick violates every coding standard in the book. Try doing this in your company&#39;s code and you will probably be subject to a stern telling off if not disciplinary action! You have embedded unmatched braces in macros, used <code>case</code> within sub-blocks, [...] It&#39;s a wonder you haven&#39;t been fired on the spot for such irresponsible coding practice. You should be ashamed of yourself.</p>
</blockquote>
<p>Let’s now examine the coroutine <code>wait_ms</code>, which delays execution for a specified number of milliseconds:</p>
<pre><code>CORO(wait_ms, 
     CORO_ARGS(<span>uint64_t</span> delay), 
     CORO_LOCALS(<span>uint64_t</span> end_time;),
     CORO_CALLS(CORO_CALL(wait_ms_yield, coro_yield)), {
       <span>coro_res_t</span> res;
       LOCAL(end_time) = millis() + delay;
       <span>while</span> (LOCAL(end_time) &gt;= millis()) {
         CALL(res, wait_ms_yield, coro_yield);
       }
       <span>return</span> CORO_RES_DONE;
     })
</code></pre>
<p>This coroutine waits until the current time surpasses a computed end time. During that time, it repeatedly yields via another coroutine called <code>coro_yield</code>, which typically represents a single iteration of cooperative scheduling—allowing other coroutines or main loop logic to run.</p>
<p>Let’s see what this expands to after the macros have been processed:</p>
<pre><code><span><span>enum</span> <span>wait_ms_fct_state</span> {</span> wait_ms_state_initial = <span>0</span>, coro_state_wait_ms_yield };
<span><span>struct</span> <span>wait_ms_fct_ctx</span> {</span>
  <span><span>enum</span> <span>wait_ms_fct_state</span> <span>state</span>;</span>
  <span>uint64_t</span> end_time;
  <span><span>union</span> {</span>
    <span>uint8_t</span> _placeholder_;
    <span><span>struct</span> <span>coro_yield_fct_ctx</span> <span>wait_ms_yield</span>;</span>
  } calls;
};
<span>coro_res_t</span> <span>wait_ms_fct</span><span>(<span>struct</span> wait_ms_fct_ctx *ctx, <span>uint64_t</span> delay)</span> {
  <span>switch</span> (ctx-&gt;state) {
  <span>case</span> wait_ms_state_initial: {
    <span>coro_res_t</span> res;
    (ctx-&gt;end_time) = millis() + delay;
    <span>while</span> ((ctx-&gt;end_time) &gt;= millis()) {
      
      ctx-&gt;state = coro_state_wait_ms_yield;
      ctx-&gt;calls.wait_ms_yield.state = (<span>enum</span> coro_yield_fct_state)<span>0</span>;
      <span>case</span> coro_state_wait_ms_yield:
      res = coro_yield_fct(&amp;ctx-&gt;calls.wait_ms_yield);
      <span>if</span> (res &amp; CORO_RES_PENDING)
        <span>return</span> res;
      
    }
    <span>return</span> CORO_RES_DONE;
  }
  }
}
</code></pre>
<p>What’s happening here is nearly identical in structure to the previous coroutine. The key idea is that the coroutine &#34;remembers&#34; where it was last suspended using the state enum, and all variables that need to persist across multiple invocations (such as <code>end_time</code>) live in the coroutine context.</p>
<p>The <code>while</code> loop is partially unrolled using this manual state machine, and the call to <code>coro_yield</code> is transformed into its own resumable block. This allows the <code>wait_ms</code> coroutine to sleep without blocking other coroutines—achieving a non-blocking delay in a completely single-threaded environment.</p>
<p>This is where the technique becomes really powerful. Even though we’re not using an operating system or real threads, we can simulate cooperative multitasking simply through clever code structure and macro expansion. By chaining coroutines together—each with their own saved state and local context—we can build complex behavior while keeping the control flow readable and sequential.</p>
<p>In essence, we’re trading stack frames and preemptive scheduling for persistent state and manual switching. The result is a system that feels intuitive to write, even though its implementation is deeply unconventional and, some might say, sacrilegious by conventional C standards.</p>
<p>We’ve seen how individual coroutine functions like <code>wait_ms</code> or <code>button_recorder_fn</code> are compiled down into state machines using macros. Now let’s look at how these coroutines actually <em>run</em>. That is, how they are scheduled, paused, resumed, and eventually completed. Here&#39;s the code that defines the core coroutine runtime system:</p>
<pre><code><span><span>enum</span> <span>coro_task_state</span> {</span>
  coro_task_state_not_started = <span>0</span>,
  coro_task_state_running = <span>1</span>,
  coro_task_state_waiting_for_execution = <span>2</span>,
  coro_task_state_parked = <span>3</span>,
  coro_task_state_finished = <span>4</span>,
  coro_task_state_failed = <span>5</span>,
};

<span><span>struct</span> <span>coro_task</span>;</span>

<span><span>struct</span> <span>coro_task</span> *<span>current_task</span> =</span> <span>NULL</span>;

<span><span>struct</span> <span>coro_executor</span> {</span>
  <span><span>struct</span> <span>coro_task</span> *<span>task_queue_head</span>;</span>
  <span><span>struct</span> <span>coro_task</span> *<span>task_queue_tail</span>;</span>
};

<span>typedef</span> <span>coro_res_t</span> <span>(*coro_task_root_fct)</span><span>(<span>void</span> *ctx)</span>;

<span><span>struct</span> <span>coro_task</span> {</span>
  <span><span>enum</span> <span>coro_task_state</span> <span>state</span>;</span>

  <span><span>struct</span> <span>coro_executor</span> *<span>executor</span>;</span>
  <span><span>struct</span> <span>coro_task</span> *<span>next</span>;</span>
  coro_task_root_fct root_fct;
  <span>uint8_t</span> canceled;
  <span>void</span> *context;
};

<span>void</span> <span>coro_executor_enqueue_task</span><span>(<span>struct</span> coro_executor *executor,
                                <span>struct</span> coro_task *task)</span> {

  assert(task-&gt;state == coro_task_state_waiting_for_execution);
  assert(task-&gt;executor == executor);

  <span><span>struct</span> <span>coro_task</span> **<span>task_queue_tail</span> =</span> &amp;executor-&gt;task_queue_tail;
  <span>if</span> (*task_queue_tail)  
    (*task_queue_tail)-&gt;next = task;
  <span>else</span>  
    executor-&gt;task_queue_head = task;
  *task_queue_tail = task;
}

<span>void</span> <span>coro_executor_start_task</span><span>(<span>struct</span> coro_executor *executor,
                              <span>struct</span> coro_task *task)</span> {

  assert(task-&gt;state == coro_task_state_not_started);
  assert(task-&gt;executor == <span>NULL</span>);
  task-&gt;state = coro_task_state_waiting_for_execution;
  task-&gt;executor = executor;

  coro_executor_enqueue_task(executor, task);
}

<span>void</span> <span>coro_executor_process</span><span>(<span>struct</span> coro_executor *executor)</span> {
  <span><span>struct</span> <span>coro_task</span> **<span>task_queue_head</span> =</span> &amp;executor-&gt;task_queue_head;

  <span>while</span> (*task_queue_head != <span>NULL</span>) {
    <span><span>struct</span> <span>coro_task</span> *<span>task</span> =</span> *task_queue_head;
    <span>if</span> (task-&gt;state == coro_task_state_waiting_for_execution) {
      task-&gt;state = coro_task_state_running;

      current_task = task;
      <span>coro_res_t</span> res = task-&gt;root_fct(task-&gt;context);
      <span>if</span> (res == CORO_RES_DONE) {
        task-&gt;state = coro_task_state_finished;
      } <span>else</span> <span>if</span> (res == CORO_RES_CANCELED) {
        task-&gt;state = coro_task_state_failed;
      } <span>else</span> <span>if</span> (res == CORO_RES_PENDING) {
        task-&gt;state = coro_task_state_parked;
      } <span>else</span> <span>if</span> (res == CORO_RES_PENDING_NON_PARKING) {
        task-&gt;state = coro_task_state_waiting_for_execution;
        coro_executor_enqueue_task(executor, task);
      } <span>else</span> {
        assert(<span>0</span>);
      }
    }
    *task_queue_head = task-&gt;next;
    task-&gt;next = <span>NULL</span>;
  }
  executor-&gt;task_queue_tail = <span>NULL</span>;
  current_task = <span>NULL</span>;
}


<span><span>enum</span> <span>coro_yield_fct_state</span> {</span>
  yield_state_init = <span>0</span>,
  yield_state_after_yield = <span>1</span>,
};
<span><span>struct</span> <span>coro_yield_fct_ctx</span> {</span>
  <span><span>enum</span> <span>coro_yield_fct_state</span> <span>state</span>;</span>
};
<span>coro_res_t</span> <span>coro_yield_fct</span><span>(<span>struct</span> coro_yield_fct_ctx *ctx)</span> {
  <span>if</span> (current_task-&gt;canceled)
    <span>return</span> CORO_RES_CANCELED;
  <span>if</span> (ctx-&gt;state == yield_state_init) {
    ctx-&gt;state = yield_state_after_yield;
    <span>return</span> CORO_RES_PENDING_NON_PARKING;
  } <span>else</span> {
    <span>return</span> CORO_RES_DONE;
  }
}
</code></pre>
<p>The coro_executor is a minimal scheduler. It maintains a queue of coroutine tasks ready to run.</p>
<p>When <code>coro_executor_process</code> is called, it:</p>
<ol>
<li>Picks the first queued task.</li>
<li>Calls its coroutine function.</li>
<li>Checks the return value to determine what to do next:<ul>
<li><code>CORO_RES_DONE</code>: The coroutine is finished.</li>
<li><code>CORO_RES_CANCELED</code>: The coroutine was canceled mid-way - we take a look at that behavior later.</li>
<li><code>CORO_RES_PENDING</code>: The coroutine is waiting and blocking until un-parked - more about parking later.</li>
<li><code>CORO_RES_PENDING_NON_PARKING</code>: The coroutine yielded voluntarily and should be resumed as soon as possible (e.g., in the next loop).</li>
<li>If a task yields with CORO_RES_PENDING_NON_PARKING, it’s immediately re-enqueued.</li>
</ul>
</li>
</ol>
<p>Let’s now turn to the <code>led_task</code>, which is slightly more involved than the previous coroutines. This task’s goal is to blink an LED on and off with a duration controlled by the user—but with a twist: it should react immediately to a <code>resetLed</code> event, which may be sent at any time via a condition variable. That means during each LED on/off phase, the task must wait for two things in parallel:</p>
<ol>
<li><p>A timeout (<code>wait_ms</code>) to elapse.</p>
</li>
<li><p>A signal (<code>coro_cond_var_wait</code>) indicating that the blinking period has changed.</p>
</li>
</ol>
<p>Crucially, we don’t care <em>which</em> of these completes first—but once one completes, we want to cancel the other. For example, if the <code>resetLed</code> event is received, we no longer care about the timer finishing, and vice versa. That’s where the <code>ANY_CALL</code> macro and coroutine cancelation come into play.</p>
<p>Here’s what the coroutine looks like:</p>
<pre><code>CORO(led_task_fn,
     CORO_NO_ARGS,
     CORO_NO_LOCALS,
     CORO_CALLS(
        CORO_ANY_CALL(wait_a, wait_ms, coro_cond_var_wait), 
        CORO_ANY_CALL(wait_b, wait_ms, coro_cond_var_wait)), {
       <span>coro_res_t</span> res_wait_ms;
       <span>coro_res_t</span> res_reset_led;
       <span>while</span> (<span>true</span>) {
         digitalWrite(LED_BUILTIN, LOW);
         ANY_CALL(res_wait_ms, res_reset_led, wait_a, 
            wait_ms, (led_blink_duration_ms),
            coro_cond_var_wait, (&amp;reset_led_signal)
         );
         <span>if</span> (res_reset_led == CORO_RES_DONE) <span>continue</span>;
         digitalWrite(LED_BUILTIN, HIGH);
         ANY_CALL(res_wait_ms, res_reset_led, wait_b, 
            wait_ms, (led_blink_duration_ms), 
            coro_cond_var_wait, (&amp;reset_led_signal)
         );
         <span>if</span> (res_reset_led == CORO_RES_DONE) <span>continue</span>;
       }
       <span>return</span> CORO_RES_DONE;
     })
</code></pre>
<p>The same code but expanded:</p>
<pre><code><span><span>enum</span> <span>led_task_fn_fct_state</span> {</span>
  led_task_fn_state_initial = <span>0</span>,
  coro_state_wait_a,
  coro_state_wait_b
};
<span><span>struct</span> <span>led_task_fn_fct_ctx</span> {</span>
  <span><span>enum</span> <span>led_task_fn_fct_state</span> <span>state</span>;</span>
  <span><span>union</span> {</span>
    <span>uint8_t</span> _placeholder_;
    <span><span>struct</span> {</span>
      <span><span>struct</span> <span>wait_ms_fct_ctx</span> <span>a</span>;</span>
      <span><span>struct</span> <span>coro_cond_var_wait_fct_ctx</span> <span>b</span>;</span>
    } wait_a;
    <span><span>struct</span> {</span>
      <span><span>struct</span> <span>wait_ms_fct_ctx</span> <span>a</span>;</span>
      <span><span>struct</span> <span>coro_cond_var_wait_fct_ctx</span> <span>b</span>;</span>
    } wait_b;
  } calls;
};
<span>coro_res_t</span> <span>led_task_fn_fct</span><span>(<span>struct</span> led_task_fn_fct_ctx *ctx)</span> {
  <span>switch</span> (ctx-&gt;state) {
  <span>case</span> led_task_fn_state_initial: {
    <span>coro_res_t</span> res_wait_ms;
    <span>coro_res_t</span> res_reset_led;
    <span>while</span> (<span>1</span>) {
      digitalWrite(LED_BUILTIN, LOW);
      
      
      
      
      ctx-&gt;state = coro_state_wait_a;
      ctx-&gt;calls.wait_a.a.state = (<span>enum</span> wait_ms_fct_state)<span>0</span>;
      ctx-&gt;calls.wait_a.b.state = (<span>enum</span> coro_cond_var_wait_fct_state)<span>0</span>;
      <span>case</span> coro_state_wait_a:
      res_wait_ms = wait_ms_fct(&amp;ctx-&gt;calls.wait_a.a, led_blink_duration_ms);
      res_reset_led = coro_cond_var_wait_fct(&amp;ctx-&gt;calls.wait_a.b, &amp;reset_led_signal);
      <span>if</span> (res_wait_ms &amp; CORO_RES_DONE &amp;&amp; !(res_reset_led &amp; CORO_RES_DONE)) {
        current_task-&gt;canceled++;
        res_reset_led =
            coro_cond_var_wait_fct(&amp;ctx-&gt;calls.wait_a.b, &amp;reset_led_signal);
        current_task-&gt;canceled--;
      } <span>else</span> <span>if</span> (res_reset_led &amp; CORO_RES_DONE &amp;&amp; !(res_wait_ms &amp; CORO_RES_DONE)) {
        current_task-&gt;canceled++;
        res_wait_ms = wait_ms_fct(&amp;ctx-&gt;calls.wait_a.a, led_blink_duration_ms);
        current_task-&gt;canceled--;
      }
      <span>if</span> ((res_wait_ms | res_reset_led) &amp; CORO_RES_PENDING)
        <span>return</span> (res_wait_ms | res_reset_led);

      <span>if</span> (res_reset_led == CORO_RES_DONE)
        <span>continue</span>;
      
      digitalWrite(LED_BUILTIN, HIGH);
      
      
      
      
      
    }
    <span>return</span> CORO_RES_DONE;
  }
  }
}
</code></pre>
<p>The <code>ANY_CALL</code> macro launches two sub-coroutines in parallel and waits for <strong>either</strong> to complete. When one finishes, the macro manually increments the <code>canceled</code> flag of the <code>current_task</code> before running the still-pending coroutine again. This triggers coroutine-level cancelation.</p>
<p>Cancelation in this system is cooperative and opt-in. Each coroutine can check whether it&#39;s been canceled by inspecting the <code>current_task-&gt;canceled</code> flag. If set, the coroutine is expected to exit early (typically returning <code>CORO_RES_CANCELED</code>). This design allows you to safely &#34;abort&#34; a pending coroutine without requiring real preemption or risking inconsistent state.</p>
<p>One practical and critical use of this coroutine cancelation system appears in the implementation of condition variables, specifically within the <code>coro_cond_var_wait</code> coroutine.</p>
<p>A <code>coro_cond_var</code> maintains a linked list of waiters, where each waiter is a <code>coro_cond_var_waiter</code> struct embedded directly within the coroutine’s local context. This is an efficient way to avoid heap allocations, but it introduces a major caveat: if the coroutine is canceled or finishes before it’s signaled, and it does not clean up after itself, the list would contain a dangling pointer — a reference to a context that no longer exists. That’s undefined behavior waiting to happen.</p>
<p>To prevent this, <code>coro_cond_var_wait</code> takes special care to remove its waiter from the list if the coroutine is canceled before being signaled.</p>
<p>Here&#39;s how this works:</p>
<pre><code><span>void</span> <span>coro_unpark_task</span><span>(<span>struct</span> coro_task *task)</span> {
  assert(task-&gt;state != coro_task_state_not_started);
  assert(task-&gt;executor != <span>NULL</span>);

  <span>if</span> (task-&gt;state == coro_task_state_parked) {
    task-&gt;state = coro_task_state_waiting_for_execution;

    coro_executor_enqueue_task(task-&gt;executor, task);
  }
}

<span><span>enum</span> <span>coro_cond_var_waiter_state</span> {</span>
  coro_cond_var_waiter_idle = <span>0</span>,
  coro_cond_var_waiter_waiting = <span>1</span>,
  coro_cond_var_waiter_signaled = <span>2</span>,
};

<span><span>struct</span> <span>coro_cond_var_waiter</span> {</span>
  <span><span>enum</span> <span>coro_cond_var_waiter_state</span> <span>state</span>;</span>
  <span><span>struct</span> <span>coro_cond_var_waiter</span> *<span>next</span>;</span>
  <span><span>struct</span> <span>coro_task</span> *<span>parked_task</span>;</span>
};

<span><span>struct</span> <span>coro_cond_var</span> {</span>
  <span><span>struct</span> <span>coro_cond_var_waiter</span> *<span>waiter_head</span>;</span>
};

<span>void</span> <span>coro_cond_var_notify</span><span>(<span>struct</span> coro_cond_var *cond_var)</span> {
  <span><span>struct</span> <span>coro_cond_var_waiter</span> **<span>waiter_head</span> =</span> &amp;cond_var-&gt;waiter_head;
  <span>while</span> (*waiter_head != <span>NULL</span>) {
    <span>if</span> ((*waiter_head)-&gt;state == coro_cond_var_waiter_waiting) {
      (*waiter_head)-&gt;state = coro_cond_var_waiter_signaled;
      coro_unpark_task((*waiter_head)-&gt;parked_task);
    }
    *waiter_head = (*waiter_head)-&gt;next;
  }
}

<span>static</span> <span>void</span> <span>coro_cond_var_add_waiter</span><span>(<span>struct</span> coro_cond_var *cond_var,
                                     <span>struct</span> coro_cond_var_waiter *waiter)</span> {
  <span><span>struct</span> <span>coro_cond_var_waiter</span> **<span>waiter_head</span> =</span> &amp;cond_var-&gt;waiter_head;
  waiter-&gt;next = *waiter_head;
  *waiter_head = waiter;
}

<span>static</span> <span>void</span> <span>coro_cond_var_remove_waiter</span><span>(<span>struct</span> coro_cond_var *cond_var,
                                        <span>struct</span> coro_cond_var_waiter *waiter)</span> {

  <span>for</span> (<span>struct</span> coro_cond_var_waiter **waiter_head = &amp;cond_var-&gt;waiter_head;
       *waiter_head != <span>NULL</span>; waiter_head = &amp;(*waiter_head)-&gt;next) {
    <span>if</span> (*waiter_head == waiter) {
      *waiter_head = (*waiter_head)-&gt;next;
      <span>break</span>;
    }
  }
}

CORO(coro_cond_var_wait, CORO_ARGS(<span>struct</span> coro_cond_var *cond_var),
     CORO_LOCALS(<span>struct</span> coro_cond_var_waiter waiter;),
     CORO_CALLS(CORO_CALL(coro_cond_var_wait_park, coro_park)), {
       <span>coro_res_t</span> res;

       coro_cond_var_add_waiter(cond_var, &amp;LOCAL(waiter));

       <span>do</span> {
         LOCAL(waiter).state = coro_cond_var_waiter_waiting;
         LOCAL(waiter).parked_task = current_task;
         CALL(res, coro_cond_var_wait_park, coro_park);
         <span>if</span> (res == CORO_RES_CANCELED &amp;&amp; ctx-&gt;waiter.state != coro_cond_var_waiter_signaled) {
           coro_cond_var_remove_waiter(cond_var, &amp;LOCAL(waiter));
           <span>return</span> CORO_RES_CANCELED;
         }
       } <span>while</span> (ctx-&gt;waiter.state != coro_cond_var_waiter_signaled);
       <span>return</span> CORO_RES_DONE;
     })
</code></pre>
<p>This mechanism highlights a broader theme in this coroutine system: <strong>every coroutine is responsible for cleaning up its own mess</strong>—especially in the face of cancelation. Since we&#39;re embedding waiter objects directly into coroutine stack frames (which may be on the heap or static memory), it’s essential to de-register those objects before the stack goes away.</p>
<p>Now we can sew everything together. The snippet below shows how the system is started and run in an Arduino-like environment:</p>
<pre><code>DECLARE_TASK(led_task, led_task_fn);
DECLARE_TASK(button_task, button_task_fn);
DECLARE_EXECUTOR(exe);

<span>void</span> <span>setup</span><span>()</span> {
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);

  coro_executor_start_task(&amp;exe, &amp;led_task);
  coro_executor_start_task(&amp;exe, &amp;button_task);
}

<span>void</span> <span>loop</span><span>()</span> {
  coro_executor_process(&amp;exe);
}
</code></pre>
<p>Each co-routine task is declared and initialized ahead of time. When <code>setup</code> runs, the tasks are registered with the executor and marked as ready. In the <code>loop</code> function—which is repeatedly called by the Arduino runtime—the executor resumes each co-routine that is ready to make progress.
If you are interested in the missing parts of the implementation - you&#39;ll find the full source code <a href="https://gist.github.com/wiomoc/8f9882eea79f17c419f04539173ea66d">here</a>.</p>
<h3 id="final-words">Final words</h3>
<p>This whole setup is an unholy alliance of C macros, state machines, and sheer willpower. It&#39;s clever, it&#39;s educational, and yes—it&#39;s kind of fun. But let’s be honest: this is not how sane people should write software in 2025.</p>
<p>If you&#39;re thinking, <em>“Wow, that’s a lot of boilerplate just to blink an LED asynchronously,”</em> you&#39;re absolutely right. What you&#39;ve built here is essentially a poor man&#39;s async runtime. A very educational, very brave, very macro-ridden poor man&#39;s async runtime.</p>
<p>So to be a little bit salty:</p>
<p>Rust gives you everything we&#39;ve scratched and clawed together here, but natively. Async/await is stackless and zero-cost, with real compiler guarantees, memory safety, cancelation semantics, and futures that compose cleanly—no unhygienic macro hell, no manual cancelation logic duct-taped together.</p>
<p>What we’ve done in C is a fascinating look under the hood. But if you&#39;re doing serious work, or you want to ship something that won’t wake you up at 3AM with a mysterious hard crash—save yourself the pain.</p>
<h3 id="update">Update</h3>
<p>After I had actually already completed the post, by chance I recently came across an alternative approach: Adam Dunkels beat me to it with his brilliant <a href="https://dunkels.com/adam/pt/index.html">Protothreads</a>, and his approach is arguably more elegant.</p>
<p>Instead of generating explicit state enums like we did, Protothreads cleverly use the <code>__LINE__</code> macro to represent state—yes, the actual line number in the source file becomes the state machine’s program counter. It&#39;s an audacious hack that makes our elaborate macro gymnastics look almost… wholesome.
You can find a full macro expansion example <a href="https://dunkels.com/adam/pt/expansion.html">here</a></p>


       <span>Embedded</span>

</article></div>
  </body>
</html>
