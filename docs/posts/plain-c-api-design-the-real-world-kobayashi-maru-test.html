<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nibblestew.blogspot.com/2023/02/plain-c-api-design-real-world-kobayashi.html">Original</a>
    <h1>Plain C API design, the real world Kobayashi Maru test</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-4614730407363573730" itemprop="description articleBody">
<p>Designing APIs is hard. Designing good APIs that future people will not instantly classify as &#34;total crap&#34; is even harder. There are typically many competing requirements such as:</p><ul><li>API stability</li><li>ABI stability (if you are into that sort of thing, some are not)</li><li>Maximize the amount of functionality supported</li><li>Minimize the number of functions exposed</li><li>Make the API as easy as possible to use</li><li>Make the API as difficult as possible to use incorrectly (preferably it should be impossible)</li><li>Make the API as easy as possible to use from scripting languages</li></ul><p>Recently I have been trying to create a proper API for PDF generation so let&#39;s use that as an example.</p><p>The API that <a href="https://www.cairographics.org">Cairo</a> exposes is on the whole pretty good. It has a fair bit of functions, but only one main &#34;painter&#34;, the <a href="https://www.cairographics.org/manual/cairo-cairo-t.html">Cairo context</a>. Cairo is a general drawing library with many backends, but the drawing commands map very closely to the ones in PDF. This is probably because Cairo&#39;s drawing model is patterned after PostScript, which is almost the same as PDF. Having only one context type means that the users do not have to manually keep track of life times between different object types, which is the source of many C bugs.</p><p>This approach works nicely with Cairo but not so well if you want to expose the full functionality of PDF directly, specifically <i>patterns</i>. In PDF you can specify a &#34;pattern object&#34;. The basic use case for it is if you need to draw a repeating shape, like a brick wall, by specifying how to draw a single tile and then telling the PDF interpreter to &#34;fill in&#34; the area you specify with this pattern. (Cairo also has pattern support which behaves mostly the same but is ideologically slightly different. We&#39;ll ignore those for the rest of this text.)</p><p>When defining a pattern you can use <i>almost</i> but <i>not exactly</i> the same drawing commands as when doing regular painting on page surfaces. There are also at least two different pattern types with slightly varying semantics. Since we want to expose PDF functionality directly, we need to have one function for each command, like <span>pdf_draw_cmd_l(ctx, x, y)</span> to draw a line. The question then becomes how does one expose all this as types and functions.</p><p>The simplest thing objectwise would be to keep everything in a single god object and have functions like <span>pdf_draw_page_cmd_l</span>, <span>pdf_draw_pattern1_cmd_l</span> and <span>pdf_draw_pattern2_cmd_l</span>. This is a terrible API because everything is smooshed together and you need to remember to finish patterns before using them. Don&#39;t do this.</p><p>Another approach is to make each concept their own separate type. Then you can have functions like <span>pdf_page_cmd_l(page, x, y)</span>, <span>pdf_pattern_cmd_l(pattern, x, y)</span> and so on. This also makes it easy to prevent using commands that are not supported. If, say, a command called <span>bob</span> is not supported on patterns, then all you have to do is to not implement the corresponding function <span>pdf_pattern_cmd_bob</span>.</p><p>The big downside is that there are a <i>lot</i> of drawing commands in PDF and in this approach almost all of them need to be defined three times, once for each context type. Their implementations are identical, so they all need to call a fourth function or the code needs to be triplicated.</p><p>One approach is to abstract this have a <span>PaintContext</span> class that internally knows whether it is used for page or pattern painting. This reduces the number of functions back to one. <span>pdf_ctx_cmd_l(ctx, x, y)</span>. The main downside is that now it is possible to accidentally call a function that requires a page drawing context with a pattern drawing context and the type system will not stop you.</p><p>A second problem is that you can call the aforementioned <span>bob</span> command with a pattern context. The library needs to detect that and return an error code if it happens. What this means is that a bunch of functions that previously <i>could not fail</i>, can now return error codes. For consistency you might want to change all paint commands to return error codes instead, but then &gt;90% of them never return anything except success.</p><p>The &#34;object oriented&#34; way of doing this would be to have a common base class for the painting functionality and then inherit that. In this approach functions that can take any context would have names like <span>pdf_ctx_cmd_l(ctx, x, y)</span> wheres functions that don&#39;t get specializations like <span>pdf_page_cmd_bob</span>. Since C does not have any OO functionality this would need to be reimplemented from scratch, probably using some Gobject-style preprocessor macro hackery like <span>pdf_ctx_cmd_l(PDF_CTX(page), x, y)</span><span> or alternatively</span><span> pdf_ctx_cmd_l(pdf_page_get_ctx(page), x, y)</span>. This works, but means a lot of typing for end users and macros are type unsafe even by C standards. If you use the wrong type, woe is you. Macros make providing wrappers harder because they require you to always compile some glue code rather than using something simple like Python&#39;s <a href="https://docs.python.org/3/library/ctypes.html">ctypes</a>.</p><p>I have not managed to come up with a way. Do let me know if you do.</p>

</div></div>
  </body>
</html>
