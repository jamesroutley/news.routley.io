<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://forums.swift.org/t/implementing-parts-of-the-swift-compiler-in-swift/59524">Original</a>
    <h1>Implementing parts of the Swift compiler in Swift</h1>
    
    <div id="readability-page-1" class="page"><div id="main-outlet" role="main">
        

  


      <div id="post_1" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          


          <p><span>
              <time itemprop="datePublished" datetime="2022-08-08T18:41:42Z">
                August 8, 2022,  6:41pm
              </time>
              <meta itemprop="dateModified" content="2022-08-08T18:41:42Z"/>
          <span itemprop="position">#1</span>
          </span>
        </p></div>
        <div itemprop="articleBody">
          <p>Hi all,</p>
<p>In the past few years, some components of the Swift compiler have started being implemented in Swift, including:</p>
<ul>
<li>The new <a href="https://github.com/apple/swift-driver">Swift Driver</a>, which coordinates Swift compilations.</li>
<li>Parsing of <a href="https://github.com/apple/swift-experimental-string-processing/">regular expression literals</a>.</li>
<li>Some new <a href="https://github.com/apple/swift/tree/main/SwiftCompilerSources/Sources/Optimizer">SIL optimization</a> passes.</li>
</ul>
<p>All of these components are <strong>optional</strong> for one reason or another. The new Swift Driver is optional because we are still maintaining the existing <a href="https://github.com/apple/swift/tree/main/lib/Driver">C++ Driver implementation</a>, which can be used for building a compiler with a host that doesn‚Äôt support Swift. Regular expression literals and the new SIL optimization passes are optional because we can build a compiler without them, then use that compiler to build a new compiler with them. All of this means that it is still possible to build a (mostly) working Swift compiler on a host where there is no existing Swift compiler, using the host C++ compiler.</p>
<p>I propose that we start requiring an existing Swift compiler to build the Swift compiler. This opens the door to non-optional (mandatory) parts of the compiler to be implemented in Swift.</p>
<h2>
<a name="requirements-for-mandatory-swift-code-in-the-compiler-1" href="#requirements-for-mandatory-swift-code-in-the-compiler-1"></a>Requirements for mandatory Swift code in the compiler</h2>
<p>For a mandatory part of the compiler to be implemented in Swift, it must:</p>
<ul>
<li>Build with <a href="https://cmake.org">CMake</a>, which will be used when building the compiler.</li>
<li>Be part of a SwiftPM package, to allow a package-based workflow for most development.</li>
<li>Build with the current <code>main</code> compiler, release branch, and all Swift releases shipped in the last 12 months. For example, at the time of this writing, <code>main</code> will become Swift 5.8, and the release branch is Swift 5.7. A mandatory part of the compiler implemented in Swift would have to build with Swift 5.5, 5.6, 5.7, and 5.8. This gives ample time for anyone who wants to work with the Swift compiler to update their host tools (possibly building newer versions) without having to go through a multi-stage bring-up.</li>
<li>Deploy back to the Swift 5.1 runtime. This would allow Swift Concurrency to be used in the code base (via the back-deployment libraries), as well as opaque result types. However, it would be a significant bump in requirements for using the compiler on macOS: currently, the compiler can run on macOS 10.9 or newer. This would move that requirement to macOS 10.15. Other platforms are unaffected because they don&#39;t ship Swift as part of the OS.</li>
<li>Support cross-compiled builds to other host architectures. For example, this means that the code base must be free of <code>#if os(...)</code> checks (and similar) that conflate the host and target environments. Once we accept that Swift code can be a mandatory part of the compiler, bringing up a new host environment means cross-compiling all of the compiler‚Äôs code.</li>
</ul>
<h2>
<a name="use-cases-for-mandatory-swift-code-in-the-compiler-2" href="#use-cases-for-mandatory-swift-code-in-the-compiler-2"></a>Use cases for mandatory Swift code in the compiler</h2>
<p>The first few candidates for mandatory Swift code in the compiler are:</p>
<ul>
<li>The new Swift Driver implementation. The new driver is a standalone replacement for the C++ driver. We can stop building the C++ driver executable, and instead make the new Swift Driver mandatory. As follow-up work, <a href="https://github.com/apple/swift/blob/main/lib/Driver/FrontendUtil.cpp#L43"><code>getSingleFrontendInvocationFromDriverArguments</code></a> can be reimplemented by using the Swift Driver library, allowing the C++ driver to be removed entirely.</li>
<li>Regular expression literals, which could be enabled all of the time instead of conditionally. This is mostly a simplification to ensure that the language dialect doesn‚Äôt depend on how the compiler was built.</li>
<li>Various uses of <a href="https://github.com/apple/swift/blob/main/utils/gyb.py">gyb</a> and <a href="https://llvm.org/docs/TableGen/">tablegen</a> for code generation could be replaced with Swift code in the build process.</li>
</ul>
<p>Under this proposal, the <a href="https://github.com/apple/swift/tree/main/SwiftCompilerSources/Sources/Optimizer">new SIL optimization passes</a> are not good candidates for becoming mandatory Swift code. These passes, and indeed the use of SIL instructions from Swift, are being used as testbeds for <a href="https://github.com/apple/swift/blob/main/docs/CppInteroperability/CppInteroperabilityStatus.md">Swift/C++ Interoperability</a>, so this code cannot become mandatory until Swift/C++ interoperability has been stabilized in a release that is older than the 12-month cutoff.</p>
<h2>
<a name="concrete-build-process-3" href="#concrete-build-process-3"></a>Concrete Build Process</h2>
<p>Here‚Äôs a proposed build process for the Swift compiler with Swift code in it:</p>
<ol>
<li>Build C++ bits with the host C++ compiler</li>
<li>Build <em>mandatory</em> Swift bits with the host Swift compiler</li>
<li>Link a ‚Äúminimal stage 1&#34; Swift compiler</li>
<li>Build <em>optional</em> Swift bits with the minimal stage 1 compiler. Note that these bits may not be fully optimized because the stage 1 compiler may lack some optimizer passes.</li>
<li>Link a ‚Äúfull stage 2‚Äù Swift compiler</li>
<li>Rebuild <em>optional</em> Swift bits with the stage 2 compiler.</li>
<li>Link a ‚Äúfinal stage 3‚Äù Swift compiler</li>
</ol>
<p>The above does create a productivity risk: The optional bits get built twice, and this happens any time the stage 1 compiler changes. In practice, this risks slowing down developers who must wait for additional build steps to get a fully optimized result. Any developer working on the optimizer will need at least the stage 2 compiler; developers interested in compiler performance will need to work with the stage 3 compiler. A workaround would be to have a separate build mode that builds the optional bits with the host compiler; that would provide faster build turnaround for those cases where the host compiler can be fully up-to-date.</p>
<p>Also note: It is possible to do the above with dependency-based build systems (such as Make or Ninja), but it‚Äôs tricky to get right. Note that a naive version would have the optional bits depend on both the stage 1 and stage 2 compilers.</p>
<p>There are two cross-compiling scenarios to consider:</p>
<ul>
<li>Initial platform bringup: For a new platform, someone will have to cross-build a stage 1 compiler one time and make it available. That is sufficient for everyone involved to do native builds from there on.</li>
<li>Platforms that are unable to build the compiler natively. This includes targets like Raspberry Pi that are capable of <em>running</em> a Swift compiler but not necessarily <em>building</em> it. These will require a different build process, as the stage 1 compiler above would be for the target platform, not the host.</li>
</ul>
<h2>
<a name="continuous-integration-4" href="#continuous-integration-4"></a>Continuous Integration</h2>
<p>To ensure that the compiler build succeeds with older compilers, we will need to bring up additional CI to build the <code>main</code> compiler with all of the supported host compiler versions, e.g., Swift 5.5, 5.6, and 5.7. As new versions of Swift are released, we can drop the CI jobs for older versions when adding the new one. For example, once a new version is released (say, 5.8), the oldest compiler can be removed (e.g., 5.5).</p>
<p>Personally, I&#39;m excited to open the door to having more Swift code in the compiler, but I want to make sure we&#39;re doing so in a way that doesn&#39;t make it unduly complicated to develop the Swift compiler or port to other host architectures. Thoughts?</p>
<p>Doug</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>
          <meta itemprop="keywords" content=""/>

        

         

            
      </div>
      <div id="post_2" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            <a itemprop="url" href="https://forums.swift.org/u/etcwilde"><span itemprop="name">etcwilde</span></a>
            (Evan Wilde)
          </span></p>


          <p><span>
              <time itemprop="datePublished" datetime="2022-08-08T20:18:43Z">
                August 8, 2022,  8:18pm
              </time>
              <meta itemprop="dateModified" content="2022-08-08T20:18:43Z"/>
          <span itemprop="position">#2</span>
          </span>
        </p></div>
        <div itemprop="articleBody">
          
<p>Which side is responsible for testing? Do we need to teach <code>lit</code> to work with <code>XCTest</code>, or SwiftPM to work with <code>lit</code>?</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_3" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <p>will there be performance test cases for portions of compiler that are migrated?</p>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_4" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          
<p>The latter, I think, because we&#39;ll want to be able to initiate testing via SwiftPM and make use of its integration in Xcode/VS Code. With the Swift Driver, we did a bit of both---all of its new tests are written in XCTest, but we have a way to swap in that driver to run the lit tests.</p>

<p>We evaluate the performance of any new component, regardless of implementation language. However, I don&#39;t think that belongs in this proposal--it&#39;s part of the normal development flow already.</p>
<p>Doug</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_5" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <p>I think it sounds like a great direction but:</p>
<p>I‚Äôve never done a xcompile bring up, but my only concern would be that the bar for someone who want to bring swift to a new platform will be even higher - it seems it would require great documentation and concrete examples to not make it completely inaccessible to most.</p>
<p>There are already other bits like ie. Libdispatch that causes friction even for the major ‚Äúother‚Äù platform (Linux) due to Mach dependencies afaict. eg. Like lack of support for the new concurrent executor (there is a big PR that got stuck last year that maybe has it), but I digress.</p>
<p>It‚Äôs likely still worth it as surely the people working on the compiler deserves better tools - good for  future progress surely and very reasonable.</p>
<p>One simpler concrete question - would this impact how one would eg. Support a new version of Ubuntu or would that require to set up xcompile? Given the ‚Äúwe build everything from source‚Äù Linux mentality (in the Linux world) it‚Äôs unclear to me whether an older built swift tool chain would run on a newer distribution (assuming that‚Äôs not always the case given that we build for multiple versions and distribute them separately at <a href="http://swift.org">swift.org</a>).</p>
<p>Perhaps obvious how that would work for most, but I just wanted to clarify, thanks.</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_6" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            <a itemprop="url" href="https://forums.swift.org/u/stevapple"><span itemprop="name">stevapple</span></a>
            (YR Chen)
          </span></p>


          <p><span>
              <time itemprop="datePublished" datetime="2022-08-09T05:36:38Z">
                August 9, 2022,  5:36am
              </time>
              <meta itemprop="dateModified" content="2022-08-09T05:36:38Z"/>
          <span itemprop="position">#6</span>
          </span>
        </p></div>
        <div itemprop="articleBody">
          <p>I‚Äôm not sure how this will affect Windows, where we have Swift toolchain but is not capable of bootstrapping at the moment.</p>
<p>Introducing mandatory Swift code certainly raises the bar of bringing Swift onto new platforms, unless we have a pure C++ ‚Äústage 0‚Äù compiler that can be used for compiling stage 1 pieces, so no cross-compilation will be required.</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_7" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          
<p>It raises the bar for a new host platform, yes.</p>

<p>That&#39;s a separate issue, unless the compiler were to depend on Dispatch itself.</p>

<p>I don&#39;t know what you&#39;re referring to, but I suspect it belongs in a different thread.</p>

<p>Amongst different Linux versions cross-compiling should be quite simple. Compilers are mostly self-contained, and we could statically link executables to make them more portable. Indeed, we might even want to do this anyway to make it easier to get Swift compilers on Linux.</p>

<p>It&#39;ll take some work, but we&#39;ve been talking through the steps, and it&#39;s manageable.</p>

<p>This proposal specifically plans to not have a &#34;pure C++&#34; Swift compiler any more.</p>
<p>To be clear, cross-compiling compilers is a normal thing done throughout the industry. We want to make sure we do it well, but it&#39;s not something to fear.</p>
<p>Doug</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_8" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <p>I love it, but there may be a performance challenge down the line.</p>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_9" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <p>I&#39;m sure there is awareness of this but I&#39;d be wary of a few points that you suggest that would make it inordinately difficult to do platform bootstrap not just on conventional systems but on more esoteric platforms.</p>
<p>Specifically, the dependency graph needs to be considered. Since Swift concurrency features depend on Dispatch, this means that bringup critically requires Dispatch when it hasn&#39;t before. Dispatch either requires some degree of tight kernel coupling to implement, or at the very least, requires a new Dispatch backend to be written using portable primitives (that would not be very performant, but at least wouldn&#39;t be a strong blocker to getting the basics of a Swift toolchain bootstrapped).</p>

<p>I&#39;d strongly advise against that, because primarily SPM depends on Dispatch and Foundation, which have the same problems as mentioned above.</p>
<p>Overall, I don&#39;t disagree with the overall goal here, so this post is just a reminder that we can make the process of bootstrap extremely difficult if we aren&#39;t mindful enough of what we are suggesting be mandated.</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_10" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          
<p>That&#39;s not currently the case, there&#39;s already an implementation of single-threaded cooperative concurrency that we already use when targeting WebAssembly, where Dispatch is not available.</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_11" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            <a itemprop="url" href="https://forums.swift.org/u/3405691582"><span itemprop="name">3405691582</span></a>
            (3405691582)
          </span></p>


          <p><span>
              <time itemprop="datePublished" datetime="2022-08-09T14:48:46Z">
                August 9, 2022,  2:48pm
              </time>
              <meta itemprop="dateModified" content="2022-08-09T14:48:46Z"/>
          <span itemprop="position">#11</span>
          </span>
        </p></div>
        <p>Oh, neat! Maybe I&#39;ve missed that since last I looked. The points about SPM though stand, I believe.</p>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_12" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            <a itemprop="url" href="https://forums.swift.org/u/Karl"><span itemprop="name">Karl</span></a>
            (üëëü¶Ü)
          </span></p>


          <p><span>
              <time itemprop="datePublished" datetime="2022-08-09T15:06:16Z">
                August 9, 2022,  3:06pm
              </time>
              <meta itemprop="dateModified" content="2022-08-09T15:06:16Z"/>
          <span itemprop="position">#12</span>
          </span>
        </p></div>
        <div itemprop="articleBody">
          <p>+1 - I mentioned in the previous thread that I didn&#39;t think the heroic efforts to enable bootstrapping were worth the cost. Swift&#39;s availability is better than it has ever been - I&#39;m not sure that getting access to a machine which can build a port of compiler, even if it is written in Swift, is actually a real barrier to supporting more platforms.</p>
<p>I would also like to recommend that the project start adopting <code>swift-format</code> for the large amount of new Swift code. One thing that I find a bit annoying about the standard library is that it isn&#39;t automatically formatted. DocC support would also be great, and its improved organisational capabilities could really help make the compiler more approachable.</p>
<p>Finally, I mention WebAssembly every time this comes up. Apparently it is a very simple bitcode and there are portable interpreters for just about <a href="https://github.com/wasm3/wasm3" rel="noopener nofollow ugc">every platform under the sun</a>, and some allow compiling the files to native code ahead-of-time for better performance. Perhaps, on platforms where an existing &#34;full&#34; compiler is not available, something like that would make a reasonable &#34;stage 1&#34;/minimal compiler. I think we&#39;re talking about a real fallback scenario here; where you can&#39;t even access an x86/arm linux box to have a build machine with a native compiler for your initial bootstrap. It&#39;s important to support that case, but I wonder again whether this much complexity will actually amount to a tangible gain over something which could be simpler and have broader benefits for Swift&#39;s cross-platform story.</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_13" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <blockquote>
<p>I&#39;d strongly advise against that, because primarily SPM depends on Dispatch and Foundation, which have the same problems as mentioned above.</p>
</blockquote>
<p>Maybe you missed the bullet point prior to that, where he says mandatory Swift packages in the compiler must build with CMake too. The idea is that you use SPM to build those compiler packages on one of the platforms that already has a working Swift toolchain, not that you use SPM running on a new platform to compile parts of the compiler for that new platform. Frankly, even when cross-compiling from an existing Swift platform to a new platform, I found SPM to be better at it than CMake, though that may be partially because I can&#39;t stand the CMake build language.</p>
<blockquote>
<p>Under this proposal, the <a href="https://github.com/apple/swift/tree/main/SwiftCompilerSources/Sources/Optimizer" rel="noopener nofollow ugc">new SIL optimization passes </a> are not good candidates for becoming mandatory Swift code. These passes, and indeed the use of SIL instructions from Swift, are being used as testbeds for <a href="https://github.com/apple/swift/blob/main/docs/CppInteroperability/CppInteroperabilityStatus.md" rel="noopener nofollow ugc">Swift/C++ Interoperability </a>, so this code cannot become mandatory until Swift/C++ interoperability has been stabilized in a release that is older than the 12-month cutoff.</p>
</blockquote>
<p><a href="https://kracekumar.com/u/douglas_gregor">@Douglas_Gregor</a>, I was surprised by this: will the mandatory Swift code only use C interop to call the existing LLVM/Swift functions from that C++ codebase? I&#39;ve certainly run into <a href="https://github.com/apple/swift/issues/60272" rel="noopener nofollow ugc">an issue with that experimental C++ interop</a>, so avoiding it for now makes sense.</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_14" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            <a itemprop="url" href="https://forums.swift.org/u/stevapple"><span itemprop="name">stevapple</span></a>
            (YR Chen)
          </span></p>


          <p><span>
              <time itemprop="datePublished" datetime="2022-08-09T15:25:15Z">
                August 9, 2022,  3:25pm
              </time>
              <meta itemprop="dateModified" content="2022-08-09T15:25:15Z"/>
          <span itemprop="position">#14</span>
          </span>
        </p></div>
        <div itemprop="articleBody">
          
<p>Totally makes sense! Using WebAssembly or Docker should provide a nice start for initial support, and I hope we can have a detailed guide on this topic.</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_15" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            <a itemprop="url" href="https://forums.swift.org/u/3405691582"><span itemprop="name">3405691582</span></a>
            (3405691582)
          </span></p>


          <p><span>
              <time itemprop="datePublished" datetime="2022-08-09T16:02:08Z">
                August 9, 2022,  4:02pm
              </time>
              <meta itemprop="dateModified" content="2022-08-09T16:02:08Z"/>
          <span itemprop="position">#15</span>
          </span>
        </p></div>
        <div itemprop="articleBody">
          
<p>I&#39;m not sure what that would look like, e.g., if we build a SPM package with CMake, then why use SPM? Maybe we need a more detailed proposal...</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_16" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            <a itemprop="url" href="https://forums.swift.org/u/tbkka"><span itemprop="name">tbkka</span></a>
            (Tim Kientzle)
          </span></p>


          <p><span>
              <time itemprop="datePublished" datetime="2022-08-09T16:28:20Z">
                August 9, 2022,  4:28pm
              </time>
              <meta itemprop="dateModified" content="2022-08-09T16:28:20Z"/>
          <span itemprop="position">#16</span>
          </span>
        </p></div>
        <div itemprop="articleBody">
          
<p>Porting a compiler to a new platform is not something lots of people should be doing.  It is an occasional task, generally done by people who are expert with both the compiler and the target platform and its SDK.  Almost all compiler development should continue to be local development.</p>
<p>In particular, a new version of an existing platform should not require cross-compiling the compiler.  A new version of Ubuntu (for instance) should be able to run binaries (including compilers) for the old version.  That means that people working on Swift for Ubuntu should never need to cross-build any part of Swift, since it already runs on Ubuntu.</p>
<p>Tim</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_17" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <blockquote>
<p>if we build a SPM package with CMake, then why use SPM?</p>
</blockquote>
<p>I think the idea is that the CMake support maintains the current build process, while the new SPM build support for building Swift portions of the compiler is another option for those who are building on a host that has a full Swift toolchain. People may find it more convenient if they then want to use those compiler packages as libraries in external Swift projects and so on.</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_18" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            <a itemprop="url" href="https://forums.swift.org/u/audulus"><span itemprop="name">audulus</span></a>
            (Taylor Holliday)
          </span></p>


          <p><span>
              <time itemprop="datePublished" datetime="2022-08-09T18:01:20Z">
                August 9, 2022,  6:01pm
              </time>
              <meta itemprop="dateModified" content="2022-08-09T18:01:20Z"/>
          <span itemprop="position">#18</span>
          </span>
        </p></div>
        <div itemprop="articleBody">
          
<p>When I tried to do something with the swift compiler, CMake utterly turned me off, FWIW. I was shocked that Swift didn&#39;t just use Xcode. Generating Xcode project files with CMake didn&#39;t work either at the time.</p>
<p>I&#39;d do everything possible to get rid of CMake. What a revolting kluge it is.</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_19" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            <a itemprop="url" href="https://forums.swift.org/u/3405691582"><span itemprop="name">3405691582</span></a>
            (3405691582)
          </span></p>


          <p><span>
              <time itemprop="datePublished" datetime="2022-08-09T18:04:43Z">
                August 9, 2022,  6:04pm
              </time>
              <meta itemprop="dateModified" content="2022-08-09T18:09:52Z"/>
          <span itemprop="position">#19</span>
          </span>
        </p></div>
        <div itemprop="articleBody">
          
<p>Right, and this is the problem I want to highlight: to get that &#34;full Swift toolchain&#34; to properly bootstrap would require bringing up Dispatch and Foundation (and llbuild! and swift-crypto! and...). That is a lot of work relative to just bringing up Swift as it stands today.</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>
      <div id="post_20" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <blockquote>
<p>I&#39;d do everything possible to get rid of CMake. What a revolting kluge it is.</p>
</blockquote>
<p>I agree, but it appears to be the de facto standard for cross-platform C++ projects, so the Swift toolchain uses it heavily. It is not realistic to migrate off of CMake any time soon, but we can certainly start going in that direction now.</p>
        </div>

        <meta itemprop="headline" content="Implementing Parts of the Swift Compiler in Swift"/>

        

         

      </div>

    





    </div></div>
  </body>
</html>
