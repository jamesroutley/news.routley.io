<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://arthi-chaud.github.io/posts/packed/">Original</a>
    <h1>Packed Data Support in Haskell</h1>
    
    <div id="readability-page-1" class="page"><div><p>This blog post aims to be a short and accessible summary of a paper that will be published at ECOOP 2025, titled <em>Type-safe and portable support for packed data</em>.</p><h2 id="introduction-packed-data"><span>Introduction: Packed Data</span><a href="#introduction-packed-data"><i></i></a></h2><p>When programs want to persist data or send it over the network, they need to <strong>serialise</strong> it (e.g. to JSON or XML). On the other hand, when a program receives data from the network or reads it from a file, data needs to be <strong>deserialised</strong>.</p><pre><code>flowchart LR
        Server([&#34;Server&#34;])
        Server --&gt; SD[&#34;Serialise&#34;]
        SD -- Network --- RD[&#34;Deserialise&#34;]
        RD --&gt; Client([&#34;Client&#34;])
</code></pre><p>These de/serialisation steps are necessary because <strong>we cannot use the in-memory representation/layout of the data in a file or when sending it over the network</strong>, mainly because of the pointers it may contain.</p><p>Consequently, <strong>de/serialising data has a cost</strong>: it takes time, and the serialised version of the data is usually bigger than its in-memory representation. In the context of systems that interact through the network, it leads to <strong>larger payloads</strong> to send, and thus <strong>slower transfer times</strong>.</p><p>Now, <strong>what if we didn’t have to serialise the data before sending it to a client</strong>, and <strong>what if the client could use the data from the network as-is</strong>, without any marshalling steps? We could save some time, on both the server and client side.</p><p>Introducing the <strong>‘packed’ data format</strong>, a binary format that allows using data as it is, without the need for a deserialisation step. A notable perk of this format is that <strong>traversals on packed trees is proven to be faster than on ‘unpacked’ trees</strong>: as the fields of data structures are inlines, there are no pointer jumps, thus making the most of the L1 cache.</p><p>To better understand how it looks like, here is a representation of a tree in memory that uses pointers. <code>N</code> represents nodes, and <code>L</code> represents leaves. Numbers are the tree’s data, and dots and arrows are pointers.</p><p><a href="https://arthi-chaud.github.io/assets/img/packed/unpacked-tree.png"><img src="https://arthi-chaud.github.io/assets/img/packed/unpacked-tree.png" alt="Pointer-based layout" width="300" loading="lazy"/></a> <em>Pointer-based tree layout in memory</em></p><p>Here is what a packed tree looks like in memory.</p><p><a href="https://arthi-chaud.github.io/assets/img/packed/packed-tree.png"><img src="https://arthi-chaud.github.io/assets/img/packed/packed-tree.png" alt="Pointer-based layout" width="300" loading="lazy"/></a> <em>Packed tree layout in memory</em></p><p>A few projects use or leverage this ‘packed’ approach. For example, Cap’n Proto<sup id="fnref:1"><a href="#fn:1" rel="footnote" role="doc-noteref">1</a></sup> is a popular library that allows packing data (i.e. build a binary buffer containing the data), using that buffer as-is (e.g. traverse it and ‘unpack’ fields of a structure). However, no languages support packed data natively. Haskell does support compact normal forms (CNF), but the <code>Compact</code> data type does not allow using (e.g. deconstructing) packed values. We should note the existence of <a href="https://iu-parfunc.github.io/gibbon/">Gibbon</a>, a research compiler that accepts functional programs and generates programs that use packed data natively.</p><p>Unfortunately <strong>the use of packed data is limited to research projects</strong>, probably because it’s kinda hard to support it.</p><p>In this post, I will introduce <strong>the <code>packed-data</code> Haskell library</strong>. It <strong>allows packing and unpacking data, as well as traversing packed data as-is</strong> (with a custom <code>case</code> function), with no marshalling step or compiler mods, thanks to the power of types. As far as we are aware, this is on of the first effort to bring support for packed data using only the host language’s type-system, meta-programming (Template Haskell) <strong>with no compiler modifications</strong>.</p><h2 id="the-library-its-features-and-its-api"><span>The library, its features and its API</span><a href="#the-library-its-features-and-its-api"><i></i></a></h2><p>Using Template Haskell, <code>packed-data</code> generates all the necessary code so that one can, for <em>any</em> type<sup id="fnref:unboxed"><a href="#fn:unboxed" rel="footnote" role="doc-noteref">2</a></sup> :</p><ul><li><em>pack</em> data (i.e. serialise the data into a binary format)</li><li><em>unpack</em> data (i.e. deserialise the data from that binary format)</li><li><em>traverse</em> the data, thanks to a generated <code>case</code> function that allows pattern matching on a data type’s constructor.</li></ul><p>Let’s consider the example of a binary tree:</p><div><p><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>data</span> <span>Tree</span> <span>a</span> <span>=</span> <span>Leaf</span> <span>a</span> <span>|</span> <span>Node</span> <span>(</span><span>Tree</span> <span>a</span><span>)</span> <span>(</span><span>Tree</span> <span>a</span><span>)</span>
</pre></td></tr></tbody></table></code></p></div><p>We can use the following Template Haskell entrypoint (from <a href="https://hackage-content.haskell.org/package/packed-data-0.1.0.3/docs/Data-Packed.html#g:5"><code>Data.Packed</code></a>):</p><p>which generates instances of the following classes (defined in <a href="https://hackage-content.haskell.org/package/packed-data-0.1.0.3/docs/Data-Packed.html#g:1"><code>Data.Packed</code></a> as well)</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>class</span> <span>Packable</span> <span>a</span> <span>where</span>
  <span>write</span> <span>::</span> <span>a</span> <span>-&gt;</span> <span>NeedsBuilder</span> <span>a</span> <span>r</span> <span>t</span>

<span>class</span> <span>Unpackable</span> <span>a</span> <span>where</span>
  <span>read</span> <span>::</span> <span>PackedReader</span> <span>&#39;</span><span>[</span><span>a</span><span>]</span> <span>r</span> <span>a</span>
</pre></td></tr></tbody></table></code></p></div><p>along with the function</p><div><p><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>caseTree</span> <span>::</span> <span>(</span><span>PackedReader</span> <span>&#39;</span><span>[</span><span>a</span><span>]</span> <span>r</span> <span>b</span><span>)</span> <span>-&gt;</span>
            <span>(</span><span>PackedReader</span> <span>&#39;</span><span>[</span><span>Tree</span> <span>a</span><span>,</span> <span>Tree</span> <span>a</span><span>]</span> <span>r</span> <span>b</span><span>)</span> <span>-&gt;</span>
            <span>(</span><span>PackedReader</span> <span>&#39;</span><span>[</span><span>Tree</span> <span>a</span><span>]</span> <span>r</span> <span>b</span><span>)</span>
</pre></td></tr></tbody></table></code></p></div><p>Ooh, all these types are scary. Don’t worry, we’ll look into them right now.</p><h3 id="needsbuilder"><span>NeedsBuilder</span><a href="#needsbuilder"><i></i></a></h3><p>To <em>build</em> packed data, we use an intermediary buffer, through its phantom type parameters, can restrict what data it takes as input.</p><p>We didn’t come up with that idea, it is heavily inspired by the examples from the <em>Linear Haskell</em> paper<sup id="fnref:1:1"><a href="#fn:1" rel="footnote" role="doc-noteref">1</a></sup>. The paper’s authors define the <code>Needs</code> type, with two phantom type parameters, <code>p</code> and <code>t</code>, where</p><ul><li><code>p</code> tells the types of the data the buffer needs before it can be considered as <em>ready</em> or <em>full</em></li><li><code>t</code> gives the types of all the data packed in the buffer, once it’s ready (i.e. when <code>p</code> is an empty list)</li></ul><div><p><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>import</span> <span>Data.ByteString.Builder</span> <span>(</span><span>Builder</span><span>)</span>

<span>newtype</span> <span>Needs</span> <span>(</span><span>p</span> <span>::</span> <span>[</span><span>Type</span><span>])</span> <span>(</span><span>t</span> <span>::</span> <span>[</span><span>Type</span><span>])</span> <span>=</span> <span>Needs</span> <span>Builder</span>
</pre></td></tr></tbody></table></code></p></div><p>For example, <code>Needs &#39;[Int] &#39;[Tree Int]</code> is an incomplete buffer that needs an <code>Int</code> before we can reify it into a proper packed <code>(Tree Int)</code>. On the other hand, <code>Needs &#39;[] &#39;[Char, Char]</code> is ready to be reified, and the produced buffer will contain two <code>Char</code>s.</p><p>We expand on that paper’s idea to make the building of the buffers monadic. For example, with Template Haskell, we generate the following code (or something similar) to <code>write</code> a <code>Tree</code> into a <code>Needs</code></p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span>instance</span> <span>Packable</span> <span>Tree</span> <span>where</span>
  <span>write</span> <span>(</span><span>Leaf</span> <span>n</span><span>)</span> <span>=</span> <span>do</span> 
    <span>writeTag</span> <span>0</span>
    <span>write</span> <span>n</span> <span>-- The library provides an instance of Packable Int</span>
  <span>write</span> <span>(</span><span>Node</span> <span>t1</span> <span>t2</span><span>)</span> <span>=</span> <span>do</span>
    <span>writeTag</span> <span>1</span>
    <span>write</span> <span>t1</span> <span>-- We call the function recursively</span>
    <span>write</span> <span>t2</span>
</pre></td></tr></tbody></table></code></p></div><p>The <code>Needs</code> type is just a wrapper around a <code>Data.ByteString.Builder</code>. The buffer is not created when we use the <code>write</code> function<sup id="fnref:bs-builder"><a href="#fn:bs-builder" rel="footnote" role="doc-noteref">3</a></sup>. It’s what <code>finish</code> is for:</p><div><p><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>finish</span> <span>::</span> <span>Needs</span> <span>&#39;</span><span>[]</span> <span>t</span> <span>-&gt;</span> <span>Packed</span> <span>t</span>
</pre></td></tr></tbody></table></code></p></div><p>Notice how the first type parameter of the input <code>Needs</code> is empty. It ensures that the buffer is <em>full</em> and <em>ready</em>.</p><p>The library also provides a shorthand <code>pack</code> function:</p><div><p><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>pack</span> <span>::</span> <span>(</span><span>Packable</span> <span>a</span><span>)</span> <span>=&gt;</span> <span>Packed</span> <span>&#39;</span><span>[</span><span>a</span><span>]</span>
<span>pack</span>  <span>=</span> <span>finish</span> <span>.</span> <span>withEmptyNeeds</span> <span>.</span> <span>write</span>
</pre></td></tr></tbody></table></code></p></div><h3 id="packedreader"><span>PackedReader</span><a href="#packedreader"><i></i></a></h3><p><code>PackedReader</code> represents reading operations on packed data. It is a monad. More specifically, it’s an indexed one. This means that the ‘state’ of the computation is reflected in its type.</p><p>For example, <code>PackedReader &#39;[Int] &#39;[Int, Int] Char</code> reads a single <code>Int</code> in a buffer where the <em>rest</em> of the buffer contains two other <code>Int</code>. This means that we could use that reader with a <code>Packed &#39;[Int, Int, Int]</code>, but not a <code>Packed &#39;[Char, Int, Int]</code>. The operation produces a <code>Char</code>.</p><p>Why does this monad exist? Under the hood, the <code>PackedReader</code> <a href="https://hackage-content.haskell.org/package/packed-data-0.1.0.3/docs/src/Data.Packed.Reader.html#runPackedReader">passes around a <code>Ptr</code></a> and reads data using <code>peek</code>, in the IO monad. <code>PackedReader</code> abstract away pointer manipulations while also ensuring type-correct reading operations on packed buffers.</p><details> <summary>What it would look like without `PackedReader`</summary> Here is what a traversal on a packed `Tree` (defined in the next subsection) would look like without the `PackedReader` abstraction. ```haskell getRightMostNodePacked :: Packed (Tree1 Int &#39;: r) -&gt; IO Int getRightMostNodePacked packed = fst &lt;$&gt; go (unsafeForeignPtrToPtr fptr) where (BS fptr _) = fromPacked packed go :: Ptr Word8 -&gt; IO (Int, Ptr Word8) go ptr = do tag &lt;- peek ptr :: IO Word8 case tag of 0 -&gt; do !n &lt;- peek (plusPtr ptr 1) return (n, plusPtr ptr 9) 1 -&gt; do (!_, !r) &lt;- go (plusPtr ptr 1) (!right, !r1) &lt;- go r return (right, r1) _ -&gt; undefined ``` Pretty ugly, innit? </details><h3 id="the-case-function"><span>The <code>case</code> function</span><a href="#the-case-function"><i></i></a></h3><p>For each call to <code>mkPacked</code>, a <code>case</code> function for the given type.</p><p>For instance, for the <code>Tree</code> ADT, it generates the <code>caseTree</code> function. It takes as many <code>PackedReader</code>s as parameter as there are constructors in <code>Tree</code>. Each <code>PackedReader</code> has a type that matches each constructor’s type:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td><pre><span>data</span> <span>Tree</span> <span>a</span> <span>=</span> <span>Leaf</span> <span>a</span> <span>|</span> <span>Node</span> <span>(</span><span>Tree</span> <span>a</span><span>)</span> <span>(</span><span>Tree</span> <span>a</span><span>)</span>

<span>caseTree</span> <span>::</span> 
  <span>-- The first PackedReader will only read an &#39;a&#39;, </span>
  <span>-- as the first constructor has an &#39;a&#39; </span>
  <span>(</span><span>PackedReader</span> <span>&#39;</span><span>[</span><span>a</span><span>]</span> <span>r</span> <span>b</span><span>)</span> <span>-&gt;</span> 
  <span>-- The second reads two trees</span>
  <span>(</span><span>PackedReader</span> <span>&#39;</span><span>[</span><span>Tree</span> <span>a</span><span>,</span> <span>Tree</span> <span>a</span><span>]</span> <span>r</span> <span>b</span><span>)</span> <span>-&gt;</span> 
  <span>-- The resulting PackedReader reads a &#39;Tree&#39;</span>
  <span>(</span><span>PackedReader</span> <span>&#39;</span><span>[</span><span>Tree</span> <span>a</span><span>]</span> <span>r</span> <span>b</span><span>)</span>
</pre></td></tr></tbody></table></code></p></div><p>We can use the generated <code>caseTree</code> function to define the instance of <code>Unpackable</code> for <code>Tree</code>:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre><span>-- This function is generated by `mkPacked`</span>
<span>instance</span> <span>(</span><span>Unpackable</span> <span>a</span><span>)</span> <span>=&gt;</span> <span>Unpackable</span> <span>(</span><span>Tree</span> <span>a</span><span>)</span> <span>where</span>
  <span>read</span> <span>=</span> <span>caseTree</span> 
    <span>(</span><span>do</span> 
      <span>n</span> <span>&lt;-</span> <span>read</span> <span>-- &#39;n&#39; has type Int</span>
      <span>return</span> <span>n</span>
    <span>)</span>
    <span>(</span><span>do</span> 
      <span>left</span> <span>&lt;-</span> <span>read</span> <span>-- &#39;left&#39; is a &#39;Tree a&#39; </span>
      <span>right</span> <span>&lt;-</span> <span>read</span> <span>-- &#39;right&#39; is also a &#39;Tree a&#39;</span>
      <span>return</span> <span>$</span> <span>Node</span> <span>left</span> <span>right</span>
    <span>)</span>
</pre></td></tr></tbody></table></code></p></div><p>The second lambda can feel a bit weird at first. You can think of a <code>PackedReader</code> as an operation that moves a cursor within a buffer. Here <code>read</code> unpacks the value at the current cursor’s position, and shifts it to the next packed value.</p><h3 id="indirections"><span>Indirections</span><a href="#indirections"><i></i></a></h3><p>One common challenge with packed data is to access a field in a packed data structure. Since all fields are inlined, we cannot predict the position of a given field in the buffer, as the preceding fields may not have a fixed size (in the case of a recursive data structure, like a tree).</p><p>Thus, there are two ways to access a field:</p><ul><li>Traversing the preceding ones. This can lead to dramatic performance issues if these preceding fields are big.</li><li>Prefix each field with an indirection: a number that gives the size of the field it precedes. They allow us to skip over a field though a simple pointer shift. In<code>packed-data</code>, we call them <code>FieldSize</code>.</li></ul><p>When building packed data, the library automatically inserts these indirections and modifies the signature of the <code>case</code> function so that its <code>PackedReader</code> know that there are <code>FieldSize</code> interspersed in the buffer.</p><p>To skip over a value preceded with a <code>FieldSize</code>, we provide the <code>skipwithFieldSize</code> function, which has type <code>PackedReader &#39;[FieldSize, a] r ()</code>.</p><h3 id="examples"><span>Examples</span><a href="#examples"><i></i></a></h3><p>Here’s what getting the right-most value in a packed tree would look like:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>getRightMostNodePacked</span> <span>::</span> <span>PackedReader</span> <span>&#39;</span><span>[</span><span>Tree1</span> <span>Int</span><span>]</span> <span>r</span> <span>Int</span>
<span>getRightMostNodePacked</span> <span>=</span>
    <span>caseTree1</span>
        <span>read</span>
        <span>skip</span> <span>R</span><span>.&gt;&gt;</span> <span>getRightMostNodePacked</span>
</pre></td></tr></tbody></table></code></p></div><p>Summing the values in the packed tree is similar:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td><pre><span>sumPacked</span> <span>::</span> <span>PackedReader</span> <span>&#39;</span><span>[</span><span>Tree1</span> <span>Int</span><span>]</span> <span>r</span> <span>Int</span>
<span>sumPacked</span> <span>=</span>
    <span>caseTree1</span>
        <span>read</span>
        <span>(</span> <span>R</span><span>.</span><span>do</span>
            <span>!</span><span>left</span> <span>&lt;-</span> <span>sumPacked</span>
            <span>!</span><span>right</span> <span>&lt;-</span> <span>sumPacked</span>
            <span>let</span> <span>!</span><span>res</span> <span>=</span> <span>left</span> <span>+</span> <span>right</span>
            <span>R</span><span>.</span><span>return</span> <span>res</span>
        <span>)</span>
</pre></td></tr></tbody></table></code></p></div><p>You can find more examples of tree traversals in the <a href="https://github.com/Arthi-chaud/packed-data">package’s repository</a>.</p><h2 id="benchmarks"><span>Benchmarks</span><a href="#benchmarks"><i></i></a></h2><p>How fast is all that stuff? To answer that question, we ran <strong>benchmarks on simple tree traversals</strong>: summing the values in a tree, getting the right-most value in a tree, evaluating an AST for an arithmetic expression, and incrementing the leaves values in a tree.</p><p>We compared the execution time of these operations with C, ‘Unpacked’/native Haskell and Gibbon, on trees of sizes between 1 and 20 (for example, a tree of size 5 has 2^5 = 32 leaves, dispatched symmetrically). We noticed the following:</p><ul><li>For summing the values, we notice a small speed-up (20%) compared to ‘unpacked’ Haskell.</li><li>On the other hand, getting the right-most value in the tree is 5 times slower than native Haskell.</li><li>Evaluating the AST is surprisingly faster (2.5x) compared to both Haskell and C.</li><li>Finally, incrementing the values of a packed tree is as fast as incrementing a native, unpacked tree in Haskell. We think this is due to the fact that the <code>ByteString.Builder</code> does only one big memory allocation, while the native operation does one for each node.</li></ul><details> <summary>The complete benchmark results table </summary><p> <a href="https://arthi-chaud.github.io/assets/img/packed/benchmark-table.png"> </a><a href="https://arthi-chaud.github.io/assets/img/packed/benchmark-table.png"><img src="https://arthi-chaud.github.io/assets/img/packed/benchmark-table.png" alt="Benchmark results" width="300" loading="lazy" loading="lazy"/></a> </p></details><blockquote><p>We should note that these benchmark results vary depending on the architecture of the machine’s CPU. ARM CPUs do not enjoy such speed-ups compared to Intel CPUs.</p></blockquote><p>(You can run these benchmarks on your machine, the source code is available on <a href="https://github.com/Arthi-chaud/packed-data">GitHub</a>)</p><h3 id="interpretation-of-the-results"><span>Interpretation of the results</span><a href="#interpretation-of-the-results"><i></i></a></h3><p>Well, we <strong>did get some speed-ups</strong>, but <strong>it’s not consistent across our benchmark cases</strong>.</p><p>Using a packed layout should always provide faster traversals, as we avoid jumping using pointers, and make the most of the L1 cache.</p><p>We suspect that the monadic approach of the <code>PackedReader</code> leads to some computation overhead due to the intensive use of IO operations (like <code>peek</code>).</p><p>For fun, we implemented a non-monadic version of a traversal to get the right-most value in a packed tree. This version does not use <code>PackedReader</code> and uses <code>peek</code> without any abstraction. (The code is available <a href="https://github.com/Arthi-chaud/packed-data/blob/33072fdaccd3f25cd416276780f2a2b2778e29d3/benchmark/tree/Traversals.hs#L70">here</a>). It did speed up the traversal (30% faster than the <code>PackedReader</code>), but is still slower (4x) than native Haskell.</p><p>This confirms that <strong>there is a computing overhead caused by our monadic abstraction</strong> of pointer manipulation.</p><h2 id="future-work-and-conclusion"><span>Future work and conclusion</span><a href="#future-work-and-conclusion"><i></i></a></h2><p>OK, so using only a library, with no compiler modifications, we somewhat managed to leverage the speed-ups allowed by packed data. However, because of its shallow embedding (i.e. it’s <em>just</em> a library), we suffer from computing overhead, which can hardly be bypassed without changing the compiler.</p><p>A solution would be to rewrite the library so that <code>PackedReader</code> generates an AST, which would be used to generate C code. Then, using Template Haskell, we could inject an FFI call into the Haskell code, in place of the <code>PackedReader</code> execution. This would allow us to avoid the computing overhead caused by our monadic approach.</p><p>I only rely on types to ensure the correctness of reading operations on packed data. I am actually curious to see if this library-based approach would work on other strongly-typed languages like Rust, Scala or maybe even TypeScript.</p><p>I talked about servers and clients in the introduction. For web services, it’s common to use JSON. It would be interesting to see if it is possible to use a JSON bytestring as-is on the client-side, without the need for a deserialisation step, using a strongly-types interface like in <code>packed-data</code>.</p> </div></div>
  </body>
</html>
