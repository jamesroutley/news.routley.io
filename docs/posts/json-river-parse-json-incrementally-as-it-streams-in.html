<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/rictic/jsonriver">Original</a>
    <h1>JSON River â€“ Parse JSON incrementally as it streams in</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Parse JSON incrementally as it streams in, e.g. from a network request or a language model. Gives you a sequence of increasingly complete values.</p>
<p dir="auto">jsonriver is small, fast, has no dependencies, and uses only standard features of JavaScript so it works in any JS environment.</p>
<p dir="auto">Usage:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Richer example at examples/fetch.js
import {parse} from &#39;jsonriver&#39;;

const response = await fetch(`https://jsonplaceholder.typicode.com/posts`);
const postsStream = parse(response.body.pipeThrough(new TextDecoderStream()));
for await (const posts of postsStream) {
  console.log(posts);
}"><pre><span>// Richer example at examples/fetch.js</span>
<span>import</span> <span>{</span><span>parse</span><span>}</span> <span>from</span> <span>&#39;jsonriver&#39;</span><span>;</span>

<span>const</span> <span>response</span> <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span>`https://jsonplaceholder.typicode.com/posts`</span><span>)</span><span>;</span>
<span>const</span> <span>postsStream</span> <span>=</span> <span>parse</span><span>(</span><span>response</span><span>.</span><span>body</span><span>.</span><span>pipeThrough</span><span>(</span><span>new</span> <span>TextDecoderStream</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
<span>for</span> <span>await</span> <span>(</span><span>const</span> <span>posts</span> <span>of</span> <span>postsStream</span><span>)</span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>posts</span><span>)</span><span>;</span>
<span>}</span></pre></div>

<p dir="auto">What does it mean that we give you a sequence of increasingly complete values? Consider this JSON:</p>
<div dir="auto" data-snippet-clipboard-copy-content="{&#34;name&#34;: &#34;Alex&#34;, &#34;keys&#34;: [1, 20, 300]}"><pre>{<span>&#34;name&#34;</span>: <span><span>&#34;</span>Alex<span>&#34;</span></span>, <span>&#34;keys&#34;</span>: [<span>1</span>, <span>20</span>, <span>300</span>]}</pre></div>
<p dir="auto">If you gave this to jsonriver one byte at a time it would yield this sequence of values:</p>
<div dir="auto" data-snippet-clipboard-copy-content="{}
{&#34;name&#34;: &#34;&#34;}
{&#34;name&#34;: &#34;A&#34;}
{&#34;name&#34;: &#34;Al&#34;}
{&#34;name&#34;: &#34;Ale&#34;}
{&#34;name&#34;: &#34;Alex&#34;}
{&#34;name&#34;: &#34;Alex&#34;, &#34;keys&#34;: []}
{&#34;name&#34;: &#34;Alex&#34;, &#34;keys&#34;: [1]}
{&#34;name&#34;: &#34;Alex&#34;, &#34;keys&#34;: [1, 20]}
{&#34;name&#34;: &#34;Alex&#34;, &#34;keys&#34;: [1, 20, 300]}"><pre>{}
{<span>&#34;name&#34;</span>: <span><span>&#34;</span><span>&#34;</span></span>}
{<span>&#34;name&#34;</span>: <span><span>&#34;</span>A<span>&#34;</span></span>}
{<span>&#34;name&#34;</span>: <span><span>&#34;</span>Al<span>&#34;</span></span>}
{<span>&#34;name&#34;</span>: <span><span>&#34;</span>Ale<span>&#34;</span></span>}
{<span>&#34;name&#34;</span>: <span><span>&#34;</span>Alex<span>&#34;</span></span>}
{<span>&#34;name&#34;</span>: <span><span>&#34;</span>Alex<span>&#34;</span></span>, <span>&#34;keys&#34;</span>: []}
{<span>&#34;name&#34;</span>: <span><span>&#34;</span>Alex<span>&#34;</span></span>, <span>&#34;keys&#34;</span>: [<span>1</span>]}
{<span>&#34;name&#34;</span>: <span><span>&#34;</span>Alex<span>&#34;</span></span>, <span>&#34;keys&#34;</span>: [<span>1</span>, <span>20</span>]}
{<span>&#34;name&#34;</span>: <span><span>&#34;</span>Alex<span>&#34;</span></span>, <span>&#34;keys&#34;</span>: [<span>1</span>, <span>20</span>, <span>300</span>]}</pre></div>

<p dir="auto">The final value yielded by <code>parse</code> will be the same as if you had called <code>JSON.parse</code> on the entire string. This is tested against the JSONTestSuite, matching JSON.parse&#39;s behavior on tests of correct, incorrect, and ambiguous cases.</p>

<ol dir="auto">
<li>Subsequent versions of a value will have the same type. i.e. we will never
yield a value as a string and then later replace it with an array.</li>
<li>true, false, null, and numbers are atomic, we don&#39;t yield them until
we have the entire value.</li>
<li>Strings may be replaced with a longer string, with more characters (in
the JavaScript sense) appended.</li>
<li>Arrays are only modified by either appending new elements, or
replacing/mutating the element currently at the end.</li>
<li>Objects are only modified by either adding new properties, or
replacing/mutating the most recently added property.</li>
<li>As a consequence of 1 and 5, we only add a property to an object once we
have the entire key and enough of the value to know that value&#39;s type.</li>
</ol>

<p dir="auto">The built-in JSON.parse is faster (~5x in simple benchmarking) if you don&#39;t need streaming.</p>
<p dir="auto"><a href="https://www.npmjs.com/package/stream-json" rel="nofollow">stream-json</a>, is larger, more complex, and slower (~10-20x slower in simple benchmarking), but it&#39;s much more featureful, and if you only need a subset of the data it can likely be much faster.</p>

<p dir="auto">Install dependencies with:</p>

<p dir="auto">Run the test suite with:</p>

<p dir="auto">Run the linter with:</p>

<p dir="auto">And auto-fix most lint issues with:</p>

</article></div></div>
  </body>
</html>
