<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danielquinn.org/blog/developing-with-docker/">Original</a>
    <h1>Developing with Docker</h1>
    
    <div id="readability-page-1" class="page"><div>
    <blockquote>
  <p><strong>Update</strong>: there&#39;s now a <a rel="nofollow" href="https://gitlab.com/danielquinn/developing-with-docker-demo">companion repo</a> to serve as a demonstration of the below.</p>
</blockquote>

<p>You&#39;d think that this topic would have been done to death, but given that <em>every</em> job I&#39;ve started in the past 10+ years has used Docker differently (if at all) to varying degrees of success, I feel like we need some sense of consensus around how to Do This Right™.  And, as someone with an ego the size of a small moon, I&#39;m here to decide what&#39;s right... on my own blog anyway.</p>

<p>The argument here is that the use of Docker and various tooling shouldn&#39;t be unique to any particular project, that this sort of thing should be so standard it&#39;s both common and boring to even think about.  My experience tells me that we&#39;re not there yet though, so this is just me making the case for what I think constitutes a good setup.</p>

<h2>Thesis</h2>

<p>The main argument I want to make is that if you&#39;re using Docker, <em>you don&#39;t write software anymore</em>, but rather you <em>build immutable images</em>.  Images that are developed locally, tested in CI, and deployed to production, but importantly, the image at each of these stages <em>is exactly the same</em>: reproducible at every turn.  There&#39;s little value in developing and testing one thing if what you roll out to production is something else entirely.  Say it with me:</p>

<blockquote>
  <p><strong>Test what you develop.  Deploy what you test.</strong></p>
</blockquote>

<p>There are a lot of advantages to this model, strongest of which is probably simplicity.  It greatly reduces the number of tricks &amp; hacks you need to make your various environments work, thereby reducing surprises (and extra code!) at all stages.  It does however require a shift in how you might be used to building things.  That&#39;s ok though.  We&#39;ll get through this together ;-)</p>

<h2>The 12 Factor Model</h2>

<p>Maybe you&#39;ve heard about it and maybe you haven&#39;t, but <a rel="nofollow" href="https://12factor.net/">the 12-factor app</a> is a design pattern that&#39;s uniquely suited to Docker-based systems.  The gist is that your application code and behaviour shouldn&#39;t change based on its environment.  At it&#39;s simplest, stuff like this:</p>

<div>
<pre><span></span><code><span>if</span> <span>ENVIRONMENT</span> <span>==</span> <span>&#34;prod&#34;</span><span>:</span>
      <span>do_something_only_production_does</span><span>()</span>
</code></pre>
</div>

<p>...shouldn&#39;t happen.  How exactly do you test that?  How do you even demo it locally?  You&#39;re introducing unpredictable behaviour into your application that can only be revealed in production.</p>

<p>Often external services like ElasticSearch or Kafka are a culprit here.  We think to ourselves: <em>&#34;This is development.  We don&#39;t need an industrial grade service to handle the little stuff I&#39;m doing on my laptop.&#34;</em> ...and so we stub out these services with dummy functions or bypass them altogether with hacks like the above.</p>

<p>The problem of course is that in doing so you&#39;ve cemented a blind spot into your application.  Your software behaves differently in one environment than it does in another, so when it breaks in production, you have no reliable way to debug it, let alone catch it before it reaches production in the first place.</p>

<p>The work-around for this is to reproduce your production environment locally as best you can — a feat that wasn&#39;t really possible pre-Docker.  Maybe you could stand up a database with your application, but a queue, Kafka, or a built-in-house-by-another-team-API-server?  Without containers, that&#39;s a fool&#39;s errand.</p>

<p>But we <em>have</em> containers, so let&#39;s use them!  When you&#39;re developing locally, you can use <a rel="nofollow" href="https://docs.docker.com/compose/">Docker Compose</a> to spin up everything you use in production.  Sure, you won&#39;t have 64 instances of the webserver and 128 workers, but one of everything relevant is likely enough, and if you ever want to track down some of the ugly race conditions and async issues, you can always increment the replicas for a single service to 2 or 3.</p>

<p>So what does that look like?  Well here&#39;s a sample <code>compose.yaml</code> file for a common pattern you see in Djangoland:</p>

<div>
<pre><span></span><code><span>name</span><span>:</span><span> </span><span>myproject</span>

<span>## Note that we&#39;re hard-coding credentials here with some very insecure values.</span>
<span>## That&#39;s ok, because these values are set to something sensible in production.</span>
<span>## What&#39;s important is that (a) the way your application behaves is consistent</span>
<span>## (looks for credentials and uses them to do something), and (b) the values are</span>
<span>## all known, so standing this baby up requires no special knowledge (more on</span>
<span>## this in the next section).</span>

<span>x-base</span><span>:</span><span> </span><span>&amp;base</span>
<span>  </span><span>build</span><span>:</span>
<span>    </span><span>context</span><span>:</span><span> </span><span>.</span>
<span>  </span><span>environment</span><span>:</span>
<span>    </span><span>DEBUG</span><span>:</span><span> </span><span>&#39;True&#39;</span>
<span>    </span><span>ALLOWED_HOSTS</span><span>:</span><span> </span><span>&#39;*&#39;</span>
<span>    </span><span>SECRET_KEY</span><span>:</span><span> </span><span>secret</span>
<span>    </span><span>DB_URL</span><span>:</span><span> </span><span>postgres://postgres:postgres@database/postgres</span>
<span>    </span><span>CACHE_URL</span><span>:</span><span> </span><span>redis://redis:6379/0</span>
<span>    </span><span>QUEUE_URL</span><span>:</span><span> </span><span>redis://redis:6379/1</span>
<span>    </span><span>ELASTICSEARCH_URL</span><span>:</span><span> </span><span>http://elasticsearch:9200</span>
<span>    </span><span>ELASTICSEARCH_USER</span><span>:</span><span> </span><span>elastic</span>
<span>    </span><span>ELASTICSEARCH_PASS</span><span>:</span><span> </span><span>elastic</span>
<span>    </span><span>BULK_UPLOAD_BUCKET</span><span>:</span><span> </span><span>mybucket</span>
<span>    </span><span>BOTO3_ENDPOINT</span><span>:</span><span> </span><span>http://localstack:4566/</span>
<span>    </span><span>AWS_ACCESS_KEY_ID</span><span>:</span><span> </span><span>XXX</span>
<span>    </span><span>AWS_SECRET_ACCESS_KEY</span><span>:</span><span> </span><span>XXX</span>
<span>  </span><span>working_dir</span><span>:</span><span> </span><span>/app/src</span>
<span>  </span><span>volumes</span><span>:</span>
<span>    </span><span>-</span><span> </span><span>.:/app</span>
<span>  </span><span>restart</span><span>:</span><span> </span><span>on-failure</span>
<span>  </span><span>depends_on</span><span>:</span>
<span>    </span><span>-</span><span> </span><span>redis</span>
<span>    </span><span>-</span><span> </span><span>database</span>
<span>    </span><span>-</span><span> </span><span>the_other_database</span>
<span>    </span><span>-</span><span> </span><span>elasticsearch</span>
<span>    </span><span>-</span><span> </span><span>localstack</span>

<span>services</span><span>:</span>

<span>  </span><span># The database.  Our project is using PostgreSQL 16 in production, so</span>
<span>  </span><span># that&#39;s what we use here.</span>
<span>  </span><span>database</span><span>:</span>
<span>    </span><span>image</span><span>:</span><span> </span><span>postgres:16-alpine</span>
<span>    </span><span>restart</span><span>:</span><span> </span><span>always</span>
<span>    </span><span>environment</span><span>:</span>
<span>      </span><span>POSTGRES_PASSWORD</span><span>:</span><span> </span><span>postgres</span>

<span>  </span><span># There&#39;s another database running an older version that we pinky-swear</span>
<span>  </span><span># we&#39;re going to update soon, but For Right Now™ it&#39;s doing its own thing</span>
<span>  </span><span># with behaviour that differs from our primary db.</span>
<span>  </span><span>the_other_database</span><span>:</span>
<span>    </span><span>image</span><span>:</span><span> </span><span>postgres:11-alpine</span>
<span>    </span><span>restart</span><span>:</span><span> </span><span>always</span>
<span>    </span><span>environment</span><span>:</span>
<span>      </span><span>POSTGRES_PASSWORD</span><span>:</span><span> </span><span>postgres</span>

<span>  </span><span># We cache things, but we also might use this to queue stuff.</span>
<span>  </span><span>redis</span><span>:</span>
<span>    </span><span>image</span><span>:</span><span> </span><span>library/redis:7.4-alpine</span>

<span>  </span><span># Apparently this project needs some industrial strength search magic.</span>
<span>  </span><span>elasticsearch</span><span>:</span>
<span>    </span><span>image</span><span>:</span><span> </span><span>elasticsearch:8.15.1</span>
<span>    </span><span>environment</span><span>:</span>
<span>      </span><span>-</span><span> </span><span>discovery.type=single-node</span>
<span>      </span><span>-</span><span> </span><span>&#34;ES_JAVA_OPTS=-Xms256m</span><span> </span><span>-Xmx1g&#34;</span>
<span>      </span><span>-</span><span> </span><span>xpack.security.enabled=false</span>
<span>      </span><span>-</span><span> </span><span>ELASTIC_PASSWORD=elastic</span>

<span>  </span><span># Production is on AWS, so this is how we simulate S3</span>
<span>  </span><span>localstack</span><span>:</span>
<span>    </span><span>image</span><span>:</span><span> </span><span>localstack/localstack:1.2</span>
<span>    </span><span>environment</span><span>:</span>
<span>      </span><span>SERVICES</span><span>:</span><span> </span><span>s3:5002</span>
<span>      </span><span>LOCALSTACK_HOSTNAME</span><span>:</span><span> </span><span>127.0.0.1</span>
<span>      </span><span>BULK_UPLOAD_BUCKET</span><span>:</span><span> </span><span>mybucket</span>
<span>    </span><span>stop_grace_period</span><span>:</span><span> </span><span>1s</span>

<span>  </span><span># Our webserver</span>
<span>  </span><span>web</span><span>:</span>
<span>    </span><span>&lt;&lt;</span><span>:</span><span> </span><span>*base</span>
<span>    </span><span>ports</span><span>:</span>
<span>      </span><span>-</span><span> </span><span>&#39;${PORT:-8000}:8000&#39;</span>
<span>    </span><span>command</span><span>:</span><span> </span><span>/app/src/manage.py runserver &#39;0.0.0.0:8000&#39;</span>

<span>  </span><span># No point in having a queue if you don&#39;t have workers for it.  Note that we</span>
<span>  </span><span># can set ${WORKERS} in our environment to spin up multiple workers, but it</span>
<span>  </span><span># defaults to 1.  This is handy when you want to test out how async stuff</span>
<span>  </span><span># might handle a large workload.</span>
<span>  </span><span>worker</span><span>:</span>
<span>    </span><span>&lt;&lt;</span><span>:</span><span> </span><span>*common</span>
<span>    </span><span>deploy</span><span>:</span>
<span>      </span><span>replicas</span><span>:</span><span> </span><span>${WORKERS:-1}</span>
<span>    </span><span>depends_on</span><span>:</span>
<span>      </span><span>-</span><span> </span><span>redis</span>
<span>      </span><span>-</span><span> </span><span>database</span>
<span>    </span><span>command</span><span>:</span><span> </span><span>/app/src/manage.py rqworker default</span>
</code></pre>
</div>

<p>It looks daunting, but what you see here is a declaratively-defined, canonical way for you to stand up A Very Complicated Project with everything you need to make your application work <em>just as it does in production</em> (whether using all of these tools together is a good idea or not is a whole other conversation).  Critically, now you can do this on anyone&#39;s laptop, and <em>even in CI</em> (we&#39;ll get to that).</p>

<p>The big win here is that you don&#39;t have to be thinking things like <em>&#34;In production, my app will do this, but in development that feature&#39;s not enabled, so this other thing will happen&#34;</em>.  No: if your app uses ElasticSearch, then your local development experience can now account for all the quirks of interacting with that system.  More importantly, your <em>tests</em> can be written to interact with them too.</p>

<p>It&#39;s important to remember though that this isn&#39;t religion.  Big services like Oracle or Kafka for example can be beasts to stand up locally and may only have very tangential relevance to your project.  In such cases it may make more sense to take on the risk of stubbing-out the service for development and tests, but these really should be the exception.</p>

<h3>Developer Tooling</h3>

<p>This is where I tend to run into the most pushback on this pattern but it&#39;s also the part that can greatly reduce headaches.  Are you ready?  Your immutable image includes everything you need for development: linters, tests, and debugging modules.  I will sometimes even include a few useful system tools like <code>netcat</code> or <code>ping</code>, as well as a fancy prompt.</p>

<p><em>None</em> of these things are necessary for production.  They are at best, image bloat, adding anywhere from 100 to 200 MB of useless code to your image that&#39;s never used in the wild.  Why then, would we want to include it?</p>

<p>Part of it goes back to the develop → test → deploy paradigm.  If these tools exist in one stage, they must exist in all of them unless you&#39;re willing to deploy something you didn&#39;t test.  Mostly though, this pattern saves you a pile of pain around getting everyone developing on your project with as few problems as possible.</p>

<p>One of the first questions I always ask on a new job is <em>&#34;How do you run the tests?&#34;</em>.  This is because everyone does it differently and many companies bake assumptions into the process that depend on things like your OS or Python version, etc.  As a Python developer, I see instruction manuals like this all too often:</p>

<ol>
<li>Install homebrew</li>
<li><code>brew install &lt;some system dependencies&gt;</code></li>
<li>Install Pyenv</li>
<li>Switch your Python version to 3.10</li>
<li>Setup a virtualenv and <code>pip install -r dev-requirements.txt</code></li>
<li>Run our special script that assumes you&#39;re running everything on a Mac.  It&#39;ll set some environment variables, create some folders and make a bunch of assumptions about the location of various files and their permissions on your system.</li>
</ol>

<p>If you&#39;re on Windows or Linux of course, you&#39;re typically met with a shrug, but even if you <em>are</em> on a Mac, this is a rather demanding ask: make a bunch of changes to your entire system with homebrew (good luck if you&#39;ve got multiple projects with different version requirements) and more importantly <em>you&#39;re not testing the image</em>.  You&#39;re deploying a Debian image with dependencies of various versions that are the result of <code>apt install &lt;package name&gt;</code>.  These system dependencies (and the system&#39;s behaviour when interacting with our Python dependencies) are unique to the environment and by developing outside of that controlled environment, you&#39;re inviting surprises.</p>

<blockquote>
  <p>Here&#39;s a fun example of this that I ran into on a recent job.  The company was mostly comprised of Mac-based developers, but there was a small group of Linux nerds as well of which I was a part.  The project we were working on required an antiquated version of a system-level XML parsing library, so in order to even build the project&#39;s Python dependencies, you needed to have version 1.x of this library installed on your system.  This was fine for the Macs, since there was apparently no way to upgrade this library anyway, but for some of the Linux machines (like my beloved Arch) we had to pin the version of this library to the old value, lest our package manager upgrade it and break our project.</p>
  
  <p>It doesn&#39;t stop there though.  We <em>also</em> had to install a bunch of spy/management-ware on our machines which (as you might have guessed by now) complained at you if you were running an old version of any package.  So every time I had to rebuild the Python dependencies, I had to downgrade this XML library, install the dependencies, then re-upgrade it so I could actually use my computer without it barking at me about updates.  Good times.</p>
</blockquote>

<p>It&#39;s just so needlessly complicated.  Imagine if those complicated instructions were as simple as:</p>

<ol>
<li><code>docker compose up</code></li>
</ol>

<p>The Python version is guaranteed to the be same as production.  The OS and system dependencies are also guaranteed to be the same.  We don&#39;t care what OS you&#39;re running, or what version of Python you might have locally, and we&#39;re not asking you to change any of your system to make this project go.  You just say: &#34;start the project in its own environment&#34;.</p>

<p>It&#39;s liberating how simple this is.  It&#39;s even more exciting when you consider that you can now run unit tests for multiple languages (your NodeJS-based front-end will have its own set of special behaviour constrained to its container) <em>and</em> you can run integration tests between the various services -- no demands or expectations made on the host computer whatsoever.</p>

<p>The same goes for the linters.  What version of <code>ruff</code> did you install on your laptop?  How &#39;bout <code>mypy</code>?  Is this up to date with the project requirements?  What if running the linters was as easy as:</p>

<div>
<pre><span></span><code>$<span> </span>docker<span> </span>compose<span> </span><span>exec</span><span> </span>web<span> </span>/scripts/run-linters
</code></pre>
</div>

<p>How much less hassle would you and every new developer on your project have?  How many hours of senior developers debugging junior setups could be reclaimed?  This alone is a goal worth working toward: a one-line way to ensure Shit Just Works™.</p>

<h3>The CI</h3>

<p>The nice thing about building an accurate, consistent, and reproducible environment for local development is that you can reuse that environment in the CI.  I&#39;ve seen this far too many times: the dev team has put in all the effort to dockerise their project and may even use Docker both in development and production, but for some reason they run the tests in whatever broken Ubuntu container their favourite CI provider offers.  The whole CI process looks something like this:</p>

<ol>
<li>Check out the code into an Ubuntu container</li>
<li>Build a virtualenv</li>
<li>Use <code>apt</code> to install one or two things</li>
<li>Install the Python dependencies into the virtualenv with something like <code>pip</code> or <code>uv</code></li>
<li>Stand up a Docker container of Postgres (What version?  Probably &#34;latest&#34;.)</li>
<li>Run the tests</li>
<li>Build the Debian or Alpine-based Docker image</li>
<li>Push it to the repo for deployment</li>
</ol>

<p><strong>This is madness</strong>.  You just tested all of your code in an entirely different Linux distro using different versions of system dependencies and ran your tests against only <em>one</em> of your external dependencies (the database), and there&#39;s no guarantee that it was even the right version.  <em>Then</em> you throw all that out and build an entirely separate Docker image with different... <em>everything</em> and you deploy that.</p>

<p>To top this all off, <em>it&#39;s extra work</em>!  Someone had to sit down and write those instructions above, accounting for the differences between development and production and trying to make a best-effort middle road between the two.  Someone has to keep an eye on CI environment versions, and worry about keeping dependencies in sync between the Docker container and what&#39;s installed in CI.</p>

<p>Why do this to yourself when you&#39;ve already gone through the effort of building a working Compose environment.  Just use that!  You can build your image, then test that your image behaves as it should, and then push that image out for deployment.</p>

<p>Here&#39;s what that looks like with GitLab&#39;s CI system:</p>

<div>
<pre><span></span><code><span>## We use &#34;Docker in Docker&#34;, since GitLab CI drops you into a Dockerised</span>
<span>## environment to begin with</span>
<span>services</span><span>:</span>
<span>  </span><span>-</span><span> </span><span>docker:dind</span>

<span>stages</span><span>:</span>
<span>  </span><span>-</span><span> </span><span>build_and_test</span>

<span>build_and_test</span><span>:</span>
<span>  </span><span>services</span><span>:</span>
<span>    </span><span>-</span><span> </span><span>docker:dind</span>
<span>  </span><span>variables</span><span>:</span>
<span>    </span><span>DOCKER_HOST</span><span>:</span><span> </span><span>tcp://docker:2375</span>
<span>    </span><span>DOCKER_DRIVER</span><span>:</span><span> </span><span>overlay2</span>
<span>  </span><span>stage</span><span>:</span><span> </span><span>build_and_test</span>
<span>  </span><span>image</span><span>:</span><span> </span><span>docker</span>

<span>  </span><span># We log into the Docker repo to pull down the latest image that was</span>
<span>  </span><span># successfully built.  That way when we build our image here, we can</span>
<span>  </span><span># take advantage of layer caching which reduces our build time to</span>
<span>  </span><span># seconds.</span>
<span>  </span><span>before_script</span><span>:</span>
<span>    </span><span>-</span><span> </span><span>docker login --username $CI_REGISTRY_USER --password $CI_REGISTRY_PASSWORD $CI_REGISTRY</span>
<span>    </span><span>-</span><span> </span><span>docker pull $CI_REGISTRY_IMAGE:latest || true</span>
<span>    </span><span>-</span><span> </span><span>docker build --cache-from $CI_REGISTRY_IMAGE:latest --build-arg BUILDKIT_INLINE_CACHE=1 --tag $CI_REGISTRY_IMAGE:latest .</span>

<span>  </span><span># This is a simple project, so we&#39;re running the linters followed by the</span>
<span>  </span><span># tests in the same job.  We could split this up, but I&#39;m trying to keep</span>
<span>  </span><span># it easy to follow.</span>
<span>  </span><span>script</span><span>:</span>
<span>    </span><span>-</span><span> </span><span>docker compose run web sh -c &#34;/scripts/run-linters&#34;</span>
<span>    </span><span>-</span><span> </span><span>docker compose run web sh -c &#34;/scripts/run-tests&#34;</span>
<span>    </span><span>-</span><span> </span><span>docker push $CI_REGISTRY_IMAGE:latest</span>
</code></pre>
</div>

<p>Note that we&#39;re running exactly the same stuff here as we did in development.  That&#39;s by design.  It should be easy and obvious to a developer just what&#39;s running in CI and how they might reproduce a problem locally, but more than anything else, they should be able to know:</p>

<blockquote>
  <p><em>&#34;If the tests pass locally, they&#39;ll pass in CI&#34;</em></p>
</blockquote>

<p>There&#39;s something deeply satisfying about knowing this with a high degree of confidence.  It&#39;s also a lot cheaper for a company that pays a SaSS CI provider.</p>

<h2>Why You Should Care</h2>

<p>The big advantage to this model is simplicity.</p>

<ul>
<li>No special documentation for getting your development environment working.</li>
<li>No special documentation for running the tests or linting.</li>
<li>No weird hacks to run the tests in CI.</li>
<li>It works everywhere, on any system, without hassle.</li>
<li>It doesn&#39;t depend on (and therefore potentially interfere with) the host system.</li>
</ul>

<p>This is a massive net reduction in code and documentation as well as in confusion and headaches for the entire development team.  How does the project work?  The same way, regardless of where it&#39;s being used.  You reduce the chances that you&#39;ll miss something in production or CI because development is as close to production as is technically possible and that saves you a mountain of pain as well.</p>

<p>Mostly though, it&#39;ll make <em>me</em> happy.  Just once I&#39;d like to sit down at a project that doesn&#39;t require me to globally install a bunch of tools and libraries, or open some network ports, or use homebrew, or Pyenv, or any other virtualisation-before-we-had-containers nonsense.  I Have A Dream my friends, and that dream is that one day I&#39;ll sit down at a new project and the instructions will be this simple:</p>

<div>
<pre><span></span><code>To stand up the project:

    $ docker compose up

To run the tests:

    $ docker compose exec web /scripts/run-tests

Or just use our alias:

    $ make tests
</code></pre>
</div>

<p>Until that day comes though, I&#39;m going to keep pointing people to this blog post.</p>

    
  </div></div>
  </body>
</html>
