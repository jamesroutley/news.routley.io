<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://davidgomes.com/async-queue-interview-ai/">Original</a>
    <h1>Async Queue – One of my favorite programming interview questions</h1>
    
    <div id="readability-page-1" class="page"><section>
        <p>For the past 7+ years, I&#39;ve been conducting a programming interview that has been a true personal favorite of mine. It was passed down to me from good friends (Jeremy Kaplan and Carl Sverre, and it was the latter whom I believe invented it). This interview has probably been given by us between 500-1000 times across different companies, and upon googling for &#34;async queue interview&#34;, I see tons of results. So, it&#39;s probably fine for me to blog about it.</p><p>My main goal with this blog post is to discuss <em>why</em> I like the interview so much, and I will also get into how AI does at this interview <em>today </em>(obviously knowning that AI advancing so quickly that this will probably be obsolete soon).</p><h2 id="the-beginning-of-the-interview">The beginning of the interview</h2><p>The story goes as follows, or so I remember... We are working on a client, like a web app for instance. And our client talks to a server. But that server is faulty!! If it has to handle multiple requests at once, it starts to break down. So, we decide to make our server&#39;s life easier by trying to ensure, from the client, that it doesn&#39;t ever have to handle more than one request at once (at least from the same client, so we can assume this is a single-server per-client type of architecture).</p><p>Then, the main thing is that our client is single-threaded. This interview can be given in JavaScript (where candidates can sort of assume single-threadedness), or any other language (even just pseudo-code) is fine, but single-threadedness is an important part of how the interview is given.</p><p>So as it stands, our client is currently calling the following <code>send</code> function all over the codebase:</p><pre><code>declare function send&lt;P&gt;(
    payload: P,
    callback: () =&gt; void
): void;</code></pre><p>This <code>send</code> function is a blackbox for us in the context of this exercise. We won&#39;t see its implementation nor should we care too much about it. All it does is send some <code>payload</code> to the server, and then call some <code>callback</code> once the server has finished processing this payload (whether the processing was successful or not).</p><p>So, we&#39;d like to implement a new function that we can start using all over the codebase called <code>sendOnce</code>:</p><pre><code>declare function sendOnce&lt;P&gt;(
    payload: P,
    callback: () =&gt; void
): void;</code></pre><p>This function should, somehow, guarantee that no more than a single request is being handled by the server (for the same client) at any given point in time.</p><p>Here&#39;s a naive, faulty implementation:</p><pre><code>let requestQueue: Array&lt;{ payload: unknown, callback: () =&gt; void }&gt; = [];

function sendOnce&lt;P&gt;(payload: P, callback: () =&gt; void) {
    function processNextRequest() {
        if (requestQueue.length !== 0) {
            const { payload, callback } = requestQueue.shift() as { payload: unknown, callback: () =&gt; void };

            send(payload, () =&gt; {
                callback();
                processNextRequest();
            });
        }
    }

    if (requestQueue.length === 0) {
        send(payload, () =&gt; {
            callback();
            processNextRequest();
        })
    } else {
        requestQueue.push({ payload, callback });
    }
}</code></pre><p>The bug in this implementation is that if <code>sendOnce</code> is called consecutively and the previous request hasn&#39;t finished yet, then we violate the &#34;one request at a time&#34; requirement. A proper implementation needs a <code>requestQueue</code> as well as a <code>isProcessing</code> flag:</p><pre><code>let isProcessing = false;
let requestQueue = [];

function sendOnce(payload, callback) {
    requestQueue.push({ payload, callback });

    if (!isProcessing) {
      processNextRequest();
    }
}

function processNextRequest() {
    if (requestQueue.length === 0) {
      isProcessing = false;
      return;
    }
  
    isProcessing = true;
  
    const { payload, callback } = requestQueue.shift();
  
    send(payload, () =&gt; {
        callback();
        processNextRequest();
    });
}</code></pre><p>Now that we have the proper implementation, we can start to see why this interview is so interesting:</p><ul><li>Can candidates reason around tricky flag logic and write bug-free code? Can they read code and debug it in their head?</li><li>Can candidates come up with the callback wrapping logic that is required to make this work?</li><li>Will candidates get stuck on the single-threaded nature of JavaScript and try to write code that works in a multi-threaded environment? (i.e., multiple threads trying to read the <code>requestQueue</code> array)<ul><li>This happens a lot since the single-threaded nature of JavaScript is not that well understood especially by less-experienced engineers. A lot of candidates start to write while loops iterating on the queue which will block the thread.</li></ul></li></ul><p><strong>What I&#39;ve described so far is really just the start of the interview.</strong> Let&#39;s get into what comes next!</p><h2 id="getting-into-the-meatier-parts-of-the-interview">Getting into the &#34;meatier&#34; parts of the interview</h2><p>After the candidate has successfully implemented <code>sendOnce</code>, we can start to make the interview more interesting. The first thing we&#39;d typically ask candidates to do is to add a third parameter to it so that it now has the following signature:</p><pre><code>declare function sendOnce&lt;P&gt;(
    payload: P,
    callback: () =&gt; void,
    minDelayMs: number
): void;</code></pre><p>The new argument should be used to let clients send requests to the server with a certain minimum delay (i.e., we don&#39;t want the server to begin processing our request for at least <code>minDelay</code> milliseconds after we fire <code>sendOnce</code>).</p><p>If you have any experience with JavaScript, the solution is fairly straightforward. We can simply wrap the entire <code>sendOnce</code> function in a <code>setTimeout</code>.</p><pre><code>function sendOnce(payload, callback, minDelayMs = 0) {
    setTimeout(() =&gt; {
        requestQueue.push({ payload, callback });
    
        if (!isProcessing) {
            processNextRequest();
        }
    }, minDelayMs);
}</code></pre><p>For candidates without JavaScript experience or doing this interview in pseudo-code, you have to tell them that there&#39;s another function available to them now with the following signature:</p><pre><code>declare function setTimeout(callback: () =&gt; void, delayMs: number): number;</code></pre><p>For more experienced candidates, you can include the <code>minDelayMs</code> requirement <strong>from the very beginning of the interview.</strong> This makes the problem more challenging since the candidate will be thinking about the queue at the same time as they&#39;re thinking about the minimum delay. Strong engineers, however, can break out the two problems and solve them at the same time. And if someone is struggling, you can always break it apart <em>for </em>them. Simply tell the candidate to ignore the <code>minDelayMs</code> for a bit, and then re-introduce this requirement <em>later</em>.</p><p>For this part of the interview, what I particularly like about it is that you&#39;re testing the candidate&#39;s ability to handle new requirements, and again you&#39;re testing how they can work in a single-threaded environment (a lot of people resort to some type of blocking <code>sleep</code> style function call to solve the delay part of this problem).</p><h2 id="what-comes-after-this">What comes after this?</h2><p>After <code>sendOnce</code> is implemented, it&#39;s time to make the interview a lot more interesting. This is where you can start to distinguish less skilled software engineers from more skilled software engineers. You can do this by adding a bunch of new requirements to the problem:</p><ul><li>Implement <code>sendMany</code> which is a <code>sendOnce</code> that should happen every X seconds</li><li>Implement a cancelation mechanism for <code>sendOnce</code> calls<ul><li>(let API design up to the candidate)</li></ul></li><li>Implement a way for requests to be retried, if failed</li><li>Write tests!</li><li>Implement a full blown <code>AsyncQueue</code> class with more methods that allow the clients to define some type of priority for different requests<ul><li>(let API design up to the candidate)</li></ul></li></ul><p>These questions are really helpful to test a whole bunch of different skills. Can they evolve their code with new requirements in such a way where the code stays elegant? How do they approach writing tests? What types of edge cases are they covering in their tests?</p><h2 id="can-ai-crack-this-interview">Can AI crack this interview?</h2><p>Absolutely, yes (with proper prompting, and some caveats). I gave the <a href="https://replit.com/?ref=davidgomes.com" rel="noreferrer">Replit Agent</a> a try on this interview earlier today with Claude Sonnet 4.0 and it was able to do a very good job with <code>sendOnce</code> (even with the minimum delay argument).</p><figure><img src="https://davidgomes.com/content/images/2025/07/CleanShot-2025-07-06-at-14.10.27.png" alt="" loading="lazy" width="1717" height="1324" srcset="https://davidgomes.com/content/images/size/w600/2025/07/CleanShot-2025-07-06-at-14.10.27.png 600w, https://davidgomes.com/content/images/size/w1000/2025/07/CleanShot-2025-07-06-at-14.10.27.png 1000w, https://davidgomes.com/content/images/size/w1600/2025/07/CleanShot-2025-07-06-at-14.10.27.png 1600w, https://davidgomes.com/content/images/2025/07/CleanShot-2025-07-06-at-14.10.27.png 1717w" sizes="(min-width: 720px) 720px"/><figcaption><span>Replit Agent starting the interview</span></figcaption></figure><figure><img src="https://davidgomes.com/content/images/2025/07/CleanShot-2025-07-06-at-16.22.25.png" alt="" loading="lazy" width="1717" height="1327" srcset="https://davidgomes.com/content/images/size/w600/2025/07/CleanShot-2025-07-06-at-16.22.25.png 600w, https://davidgomes.com/content/images/size/w1000/2025/07/CleanShot-2025-07-06-at-16.22.25.png 1000w, https://davidgomes.com/content/images/size/w1600/2025/07/CleanShot-2025-07-06-at-16.22.25.png 1600w, https://davidgomes.com/content/images/2025/07/CleanShot-2025-07-06-at-16.22.25.png 1717w" sizes="(min-width: 720px) 720px"/><figcaption><span>Replit Agent receiving new requirements</span></figcaption></figure><p>However, the code was fairly convoluted and I had to prompt it a few more times to simplify it a bit more. For the more advanced requirements, it starts to write buggier code.</p><p>So, when giving this interview, should we let candidates use AI? Yes. (And I&#39;d even recommend giving this interview with the Replit UI + Replit Agent)</p><p>The number of engineers who are not leveraging LLMs to write code is shrinking by the day. And with the exception of some fairly niche situations where LLMs are still somewhat useless (like low-level systems engineering), they are incredibly helpful. <strong>And that only makes me like this interview even more!</strong></p><p>Because I explicitly tell candidates upfront that they can use AI to speed up their work, the exercise becomes more interesting. The very best candidates will use AI for auto-completion and other things, but quickly, and correctly, review all the code it generates. This is a good way to test how &#34;AI-native&#34; the candidate is. The more AI-native, the more quickly they should be able to handle each new set of requirements. And that is exactly what I&#39;m looking for these days – engineers who can empower themselves and become faster with these new tools.</p><p>And especially for the section of the interview where candidates have to write tests, AI can be a very powerful assistant, but the prompts have to be well-structured and carefully written. Furthermore, all the AI-generated code must be properly reviewed.</p><p>I&#39;d love to hear more about how others are adopting AI in their technical interviews.</p><p>Feel free to <a href="https://x.com/davidrfgomes/?ref=davidgomes.com">follow me on Twitter/X</a> if you want!</p>
    </section></div>
  </body>
</html>
