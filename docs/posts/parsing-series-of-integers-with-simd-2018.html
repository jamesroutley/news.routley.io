<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://0x80.pl/articles/simd-parsing-int-sequences.html">Original</a>
    <h1>Parsing series of integers with SIMD (2018)</h1>
    
    <div id="readability-page-1" class="page"><div id="parsing-series-of-integers-with-simd">

<table>
<colgroup><col/>
<col/>
</colgroup><tbody>

<tr><th>Added on:</th><td>2018-04-19</td>
</tr>
<tr><th>Updated on:</th><td>2020-07-05 (fixed a typo <a href="#conversion-2digit">in conversion 2-digit numbers</a>, thank to <strong>Alexander Vingardt</strong>),
2020-03-30 (added method <a href="#detecting-digits">decimal_digits_mask_version2</a> by <strong>Carl Witty</strong>),
2020-03-29 (fixed a typo, thanks to <strong>Carl Witty</strong>),
2018-04-30 (info about <a href="#sse-range-checking">overflows</a>),
2018-04-25 (added speed-up <a href="#core-i7-results">comparison table</a>)</td>
</tr>
</tbody>
</table>
<div id="introduction">

<p>While conversion from a string into an integer value is feasible with SIMD
instructions, this application is unpractical. For typical cases, when a single
value is parsed, scalar procedures — like the standard <tt>atoi</tt> or
<tt>strtol</tt> — are faster than any fancy SSE code.</p>
<p>However, SIMD procedures can be really fast and convert <strong>in parallel</strong> several
numbers. There is only one &#34;but&#34;: the input data has to be regular and valid,
i.e. the input string must contain only ASCII digits. Recently, I updated
article about <a href="#internal-links">SSE parsing</a> with the benchmark results.  The
speed-ups are really impressive, for example the SSSE3 parser is 7 to 9 times
faster than a naive, scalar code.</p>
<p>The obvious question is how these powerful SIMD procedures can be used to
convert real data? By <em>real</em> I mean possibly broken inputs that contain series
of numbers of different length separated with characters from a predefined set.</p>
<p>In this text I try to answer that question; major contributions of this
article are:</p>
<ul>
<li>Methods to efficiently <strong>parse and validate</strong> such strings using SSE
instructions. There is a special variant that handles only unsigned
numbers and also a fully featured variant for signed numbers.</li>
<li>Boosting the SSE procedure with AVX2 or AVX512 instructions when
possible.</li>
<li>A way to combine some of SIMD techniques with scalar conversions.</li>
</ul>
<p>The article starts with unsigned conversion, because it is easier than a signed
one. The signed conversion shares the core idea, it just adds some extra steps.</p>
<p>The text is accompanied with BSD-licensed software, that includes fully
functional implementations alongside the programs which validate and benchmark
the procedures.</p>
<div id="contents">
<p>Contents</p>
<ul>
<li><a href="#introduction" id="id17">1   Introduction</a></li>
<li><a href="#parser-specification" id="id18">2   Parser specification</a></li>
<li><a href="#sse-conversion-capabilities-update" id="id19">3   SSE conversion capabilities <img src="https://blog.plover.com/update.png" alt="update"/></a><ul>
<li><a href="#range-checking-new" id="id20">3.1   Range checking <img src="https://blog.plover.com/new.png" alt="new"/></a></li>
<li><a href="#sample-implementation" id="id21">3.2   Sample implementation</a></li>
</ul>
</li>
<li><a href="#parsing-and-conversions-of-unsigned-numbers" id="id22">4   Parsing and conversions of unsigned numbers</a><ul>
<li><a href="#algorithm-overview" id="id23">4.1   Algorithm overview</a></li>
<li><a href="#normalizing-input" id="id24">4.2   Normalizing input</a></li>
<li><a href="#precalculating-data" id="id25">4.3   Precalculating data</a><ul>
<li><a href="#example" id="id26">4.3.1   Example</a></li>
</ul>
</li>
<li><a href="#sse-algorithm-outline" id="id27">4.4   SSE algorithm outline</a></li>
<li><a href="#detecting-invalid-inputs" id="id28">4.5   Detecting invalid inputs</a><ul>
<li><a href="#detecting-digits-update" id="id29">4.5.1   Detecting digits <img src="https://blog.plover.com/update.png" alt="update"/></a></li>
<li><a href="#detecting-characters-from-set" id="id30">4.5.2   Detecting characters from set</a><ul>
<li><a href="#sse-avx2" id="id31">4.5.2.1   SSE &amp; AVX2</a></li>
<li><a href="#sse4-2" id="id32">4.5.2.2   SSE4.2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#caveats" id="id33">4.6   Caveats</a></li>
</ul>
</li>
<li><a href="#parsing-and-conversion-of-signed-numbers" id="id34">5   Parsing and conversion of signed numbers</a><ul>
<li><a href="#algorithm" id="id35">5.1   Algorithm</a></li>
<li><a href="#implementation-note" id="id36">5.2   Implementation note</a></li>
<li><a href="#id3" id="id37">5.3   Detecting invalid inputs</a><ul>
<li><a href="#avx512vbmi" id="id38">5.3.1   AVX512VBMI</a></li>
</ul>
</li>
<li><a href="#id4" id="id39">5.4   SSE algorithm outline</a></li>
</ul>
</li>
<li><a href="#processing-larger-inputs" id="id40">6   Processing larger inputs</a></li>
<li><a href="#id5" id="id41">7   Scalar hybrid</a><ul>
<li><a href="#id6" id="id42">7.1   Example</a></li>
</ul>
</li>
<li><a href="#appendix-a-conversion-of-three-digit-numbers" id="id43">8   Appendix A — conversion of three-digit numbers</a></li>
<li><a href="#appendix-b-conversion-of-two-four-digit-numbers" id="id44">9   Appendix B — conversion of two four-digit numbers</a></li>
<li><a href="#reference-scalar-procedures" id="id45">10   Reference scalar procedures</a></li>
<li><a href="#experiments" id="id46">11   Experiments</a><ul>
<li><a href="#id8" id="id47">11.1   SSE conversion — execution statistics</a><ul>
<li><a href="#overview" id="id48">11.1.1   Overview</a></li>
<li><a href="#sse-routines-calls" id="id49">11.1.2   SSE routines calls</a></li>
</ul>
</li>
<li><a href="#sse-conversion-runtime-analysis" id="id50">11.2   SSE conversion — runtime analysis</a><ul>
<li><a href="#input-size-4-096-bytes" id="id51">11.2.1   Input size 4,096 bytes</a></li>
<li><a href="#input-size-65-536-bytes" id="id52">11.2.2   Input size 65,536 bytes</a></li>
</ul>
</li>
<li><a href="#performance-comparison" id="id53">11.3   Performance comparison</a><ul>
<li><a href="#tested-procedures" id="id54">11.3.1   Tested procedures</a></li>
<li><a href="#tests-setup" id="id55">11.3.2   Tests setup</a></li>
<li><a href="#id12" id="id56">11.3.3   Core i7 results</a><ul>
<li><a href="#input-size-4096-bytes" id="id57">11.3.3.1   Input size 4096 bytes</a></li>
<li><a href="#input-size-65536-bytes" id="id58">11.3.3.2   Input size 65536 bytes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#conclusions" id="id59">12   Conclusions</a></li>
<li><a href="#acknowledgements" id="id60">13   Acknowledgements</a></li>
<li><a href="#see-also" id="id61">14   See also</a></li>
<li><a href="#source-code" id="id62">15   Source code</a></li>
</ul>
</div>
</div>
<div id="parser-specification">

<p>The input is defined as follows:</p>
<ul>
<li>It is a string of arbitrary length; but it should be large, say a few
kilobytes or megabytes.</li>
<li>The input contains integer numbers. A number is an optional sign character
&#39;+&#39; or &#39;-&#39; followed by a non-empty sequence of digits &#39;0&#39;..&#39;9&#39;.</li>
<li>Numbers are separated with characters from a user-defiend set;
for instance, it might be the comma and blank characters (space, new
line, etc.).</li>
<li>All characters other than digits, separators and signs are considered
invalid.</li>
<li>Parser must be able to check validity of the input, i.e. lack of invalid
characters and the proper input format (numbers are separated with at
least one character, sign characters are present only at the beginning
of a number).</li>
</ul>
<p>For the input string &#34;123; -52,     +432424  -999; 1234568, +879&#34;, and three
separators &#39;,&#39;, &#39;;&#39; and &#39; &#39;, an algorithm is expected to extract six integers:
[123, -52, 432424, -999, 1234568, 879]. The order of converted numbers must be
exactly the same as in the input string.</p>
<p>A simplified parser is also tested. This parser simply considers all
non-digit and non-sign characters as delimiters.</p>
</div>
<div id="sse-conversion-capabilities-update">

<p>SSE instructions work on 16-byte vectors. When the input numbers have <strong>the same
count of digits</strong> and the digits of each number are placed — depending of the
digits count — on bytes, words, double words or quad words of an SSE vector,
then an SSE procedure converts them <strong>in parallel</strong>. Below are required layouts
of vectors; the most significant digit is at index 0 of each subword.</p>
<ul>
<li><p>16 one-digit unsigned numbers <tt>a .. p</tt>:</p>
<pre>[ a0 | b0 | c0 | d0 | e0 | f0 | g0 | h0 | i0 | j0 | k0 | l0 | m0 | n0 | o0 | p0 ]
</pre>
</li>
<li><p>8 two-digit unsigned numbers <tt>a .. h</tt>:</p>
<pre>[ a0 | a1 | b0 | b1 | c0 | c1 | d0 | d1 | e0 | e1 | f0 | f1 | g0 | g1 | h0 | h1 ]
| input 0 | input 1 | input 2 | input 3 | input 4 | input 5 | input 6 | input 7 |
</pre>
</li>
<li><p>4 four-digit unsigned numbers <tt>a .. d</tt>:</p>
<pre>[ a0 | a1 | a2 | a3 | b0 | b1 | b2 | b3 | c0 | c1 | c2 | c3 | d0 | d1 | d2 | d3 ]
|      input 0      |      input 1      |      input 2      |      input 3      |
</pre>
</li>
<li><p>and 2 eight-digit unsigned numbers <tt>a</tt> and <tt>b</tt>:</p>
<pre>[ a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 | b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7 ]
|                input 0                |                input 1                |
</pre>
</li>
</ul>
<p>The conversion is done gradually. We start with an input vector filled with
ASCII digits &#39;0&#39;..&#39;9&#39;; each byte of a vector contains single character. For
string &#34;1234567890123456&#34; we have:</p>
<pre>in = [&#39;1&#39;|&#39;2&#39;|&#39;3&#39;|&#39;4&#39;|&#39;5&#39;|&#39;6&#39;|&#39;7&#39;|&#39;8&#39;|&#39;9&#39;|&#39;0&#39;|&#39;1&#39;|&#39;2&#39;|&#39;3&#39;|&#39;4&#39;|&#39;5&#39;|&#39;6&#39;]
</pre>
<p>A single subtract <tt>_mm_subs_epu8</tt> (<tt>psubusb</tt>) converts from ASCII into
numbers 0..9:</p>
<pre>t0 = [ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 | 1 | 2 | 3 | 4 | 5 | 6 ]
</pre>
<p>At this point we converted 16 one-digit numbers. Now, by merging adjacent numbers
from <tt>t0</tt>, we may obtain two-digit numbers. SSSE3 introduced the instruction
<tt>_mm_maddubs_epi16</tt> (<tt>pmaddubsw</tt>) which multiplies vectors of bytes and adds
intermediate 16-bit values producing a vector of 16-bit values. Thus, when we
multiply <tt>t0</tt> by a vector filled with weights (1, 10) we get eight two-digit
numbers, each saved on a 16-bit field:</p>
<pre>t1 = [   12  |  34   |  56   |  78   |  90   |  12   |  34   |  56   ]
</pre>
<p>Similarly, these numbers can be merged into four-digit numbers. SSE has the
instruction <tt>_mm_madd_epi16</tt> (<tt>pmaddwd</tt>) which performs similar operation as
<tt>_mm_maddubs_epi16</tt>, but works on 16-bit values and yields vector of 32-bit
numbers. The other vector is filled with weights (1, 100) and we get four
four-digit numbers, each saved on a 32-bit field:</p>
<pre>t2 = [     1234      |     5678      |     9012      |     3456      ]
</pre>
<p>Four-digit numbers fits into 16-bit values, we might convert the above result
into a 16-bit vector using <tt>_mm_packus_epi32</tt> (<tt>packusdw</tt>) and again apply
the <tt>_mm_madd_epi16</tt> instruction, this time with weights (1, 10000). Then we
get two eight-digit numbers:</p>
<pre>t3 = [           12345678            |           90123456            ]
</pre>
<p>To summarize: conversion from a 16-digit string into two unsigned eight-digit
numbers requires only one subtract, three multiply-add instructions and one
pack operation.</p>
<p>If we need narrower numbers we simply stop the above procedure at an earlier
step; for example, for four-digit numbers the result is <tt>t2</tt>. Since the
intermediate vectors have different element size (8-, 16-, 32-bit) a cast to
other vector type might be needed. Widening can be done with the instructions
<tt>pmovsx</tt> (intrinsics <tt>_mm_cvtepi16_epi32</tt>, <tt>_mm_cvtepi8_epi32</tt>, etc.);
narrowing with the mentioned pack instruction which is also available in
different variants.</p>
<p>The same conversion using a naive scalar procedure would require 16 subtracts,
14 multiplications and 14 additions. More advanced <a href="#internal-links">SWAR procedures</a> would require fewer multiplications, but still not as few
as the SIMD procedure.</p>
<div id="range-checking-new">
<h2><a href="#id20">3.1   Range checking <img src="https://blog.plover.com/new.png" alt="new"/></a></h2>
<p>The maximum possible value from SSE conversion procedure is <span> ± 99999999</span>.  This value is smaller than the maximum that can hold a 32-bit number
(<span>2<sup>31</sup> − 1 = 2147483647</span>) and also absolute value of the minimum
(<span>2<sup>31</sup> = 2147483648</span>).  It means that if an output collection uses at
least 32-bit numbers, then SSE procedures <strong>never cause overflow</strong> (signed nor
unsigned).</p>
<p>Obviously, for 16-bit outputs, overflow is possible. For such case an extra
step would be required, but I do not discuss it in this text.</p>
</div>
<div id="sample-implementation">
<h2><a href="#id21">3.2   Sample implementation</a></h2>
<p>Below is a sample SSE implementation which shows all described steps.</p>
<pre><span>// 1. convert from ASCII &#39;0&#39; .. &#39;9&#39; to numbers 0 .. 9
</span><span>const</span> <span>__m128i</span> <span>ascii0</span> <span>=</span> <span>_mm_set1_epi8</span><span>(</span><span>&#39;0&#39;</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>t0</span> <span>=</span> <span>_mm_subs_epu8</span><span>(</span><span>input</span><span>,</span> <span>ascii0</span><span>);</span>

<span>// 2. convert to 2-digit numbers
</span><span>const</span> <span>__m128i</span> <span>mul_1_10</span> <span>=</span> <span>_mm_setr_epi8</span><span>(</span><span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>t1</span> <span>=</span> <span>_mm_maddubs_epi16</span><span>(</span><span>t0</span><span>,</span> <span>mul_1_10</span><span>);</span>

<span>// 3. convert to 4-digit numbers
</span><span>const</span> <span>__m128i</span> <span>mul_1_100</span>   <span>=</span> <span>_mm_setr_epi16</span><span>(</span><span>100</span><span>,</span> <span>1</span><span>,</span> <span>100</span><span>,</span> <span>1</span><span>,</span> <span>100</span><span>,</span> <span>1</span><span>,</span> <span>100</span><span>,</span> <span>1</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>t2</span> <span>=</span> <span>_mm_madd_epi16</span><span>(</span><span>t1</span><span>,</span> <span>mul_1_100</span><span>);</span>

<span>// 4a. convert form 32-bit into 16-bit element vector
</span><span>const</span> <span>__m128i</span> <span>t3</span> <span>=</span> <span>_mm_packus_epi32</span><span>(</span><span>t2</span><span>,</span> <span>t2</span><span>);</span>

<span>// 4. convert to 8-digit numbers
</span><span>const</span> <span>__m128i</span> <span>mul_1_10000</span> <span>=</span> <span>_mm_setr_epi16</span><span>(</span><span>10000</span><span>,</span> <span>1</span><span>,</span> <span>10000</span><span>,</span> <span>1</span><span>,</span> <span>10000</span><span>,</span> <span>1</span><span>,</span> <span>10000</span><span>,</span> <span>1</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>t4</span> <span>=</span> <span>_mm_madd_epi16</span><span>(</span><span>t3</span><span>,</span> <span>mul_1_10000</span><span>);</span>
</pre>
</div>
</div>
<div id="parsing-and-conversions-of-unsigned-numbers">

<div id="tresc">
<ul>
<li><a href="#algorithm-overview" id="id63">4.1   Algorithm overview</a></li>
<li><a href="#normalizing-input" id="id64">4.2   Normalizing input</a></li>
<li><a href="#precalculating-data" id="id65">4.3   Precalculating data</a><ul>
<li><a href="#example" id="id66">4.3.1   Example</a></li>
</ul>
</li>
<li><a href="#sse-algorithm-outline" id="id67">4.4   SSE algorithm outline</a></li>
<li><a href="#detecting-invalid-inputs" id="id68">4.5   Detecting invalid inputs</a><ul>
<li><a href="#detecting-digits-update" id="id69">4.5.1   Detecting digits <img src="https://blog.plover.com/update.png" alt="update"/></a></li>
<li><a href="#detecting-characters-from-set" id="id70">4.5.2   Detecting characters from set</a><ul>
<li><a href="#sse-avx2" id="id71">4.5.2.1   SSE &amp; AVX2</a></li>
<li><a href="#sse4-2" id="id72">4.5.2.2   SSE4.2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#caveats" id="id73">4.6   Caveats</a></li>
</ul>
</div>
<div id="algorithm-overview">
<h2><a href="#id23">4.1   Algorithm overview</a></h2>
<p>The conversion algorithm works in a loop, in each iteration exactly one input
vector is loaded from memory and processed.</p>
<ul>
<li>The vector is validated.</li>
<li>Depending on the layout of the digits, the input is <strong>normalized</strong> to the
format required by the SIMD procedures. At this step we choose: how many
numbers from the input are converted and which SIMD procedure is suitable
for conversion.</li>
<li>After conversion, the input pointer is advanced and the loop continues.</li>
</ul>
</div>
<div id="normalizing-input">
<h2><a href="#id24">4.2   Normalizing input</a></h2>
<p>Since SIMD procedures impose specific layout of digits within a vector, an
arbitrary input has to be properly aligned. In order to do this, we need to
identify <strong>spans of digits</strong> in the input and move each span onto certain
subarrays of a vector. Let&#39;s assume at this point that the input contains either
digits or separators (denoted with <tt>_</tt>).</p>
<p>For instance, the vector with one-digit numbers <tt>1___2_3__4__5_6_</tt> must be
transformed into <tt>123456__________</tt>. Then an SSE procedure will convert in
parallel all the numbers into the array [1, 2, 3, 4, 5, 6]. Likewise, the vector
with two-digit numbers <tt>_12__34___56_78_</tt> must be transformed into
<tt>12345678________</tt> and then the result will be [12, 34, 56, 78].</p>
<p>Let&#39;s consider a more complicated case, when a string has numbers with
different count of digits. There are a few ways to convert the input
<tt>_1_2_34_567_89__</tt>:</p>
<ul>
<li>If we choose conversion of one-digit numbers, then just the two first spans
can be converted — because we need to keep the order of numbers from the input.
After normalization the input into <tt>12______________</tt> just two values [1,
2] will be produced. The input&#39;s tail <tt>_34_567_89__</tt> remain untouched.</li>
<li>If we choose conversion of two-digit numbers, then the three first spans
can be converted. Shorter numbers are completed with zeros, then normalized
input is <tt>010234__________</tt>. The result is [1, 2, 34]; this time
a bit shorter input&#39;s tail <tt>_567_89__</tt> remain untouched.</li>
<li>Finally, if we choose conversion of four-digit numbers, then the four first
spans can be converted. Again, shorter numbers are completed with zeros,
and normalized input is <tt>0001000200340567</tt>. The result is [1, 2, 34, 567],
but still the chunk&#39;s tail, i.e. <tt>_89__</tt>, is unprocessed.</li>
</ul>
<p>We can see that in order to convert given span combination we need to know:</p>
<ol>
<li>How to shuffle bytes in the input vector?</li>
<li>Which SIMD procedure can be used then?</li>
<li>How many numbers converted by the SIMD procedure must be stored?</li>
</ol>
<p>Obtaining this information seems to be quite complicated, especially when
we look at the last example.  Fortunately, all parameters can
be <strong>precalculated</strong>.  A span combination can be saved as a bit-pattern,
where ones represent digits. For example, from vector <tt>_1_2_34_567_89__</tt>
we get the <strong>span pattern</strong> <tt>0b0101011011101100 = 0x56ec</tt>.
A span pattern is used to fetch a record from the precalculated array.
The record contains following fields:</p>
<ul>
<li><strong>shuffle_digits</strong> — an array of 16 bytes, which is the argument for
the instruction <tt>_mm_shuffle_epi8</tt> (<tt>pshufb</tt>); the instruction
moves bytes at certain positions;</li>
<li><strong>conversion_routine</strong> — an enumeration that selects an SSE conversion
procedure; for instance, it tells that shuffled input is an array
of two-digit numbers;</li>
<li><strong>element_count</strong> — the number of elements from the SSE conversion
procedure that must be stored in the output collection.</li>
</ul>
<p>The solution with a precalculated array is suitable only for SSE, as span
patterns have 16 bits. In cases of AVX2 and AVX512, where vectors are wider,
such a table would be simply too large, respectively <span>2<sup>32</sup></span> or
<span>2<sup>64</sup></span> entries. Additionally, the AVX2 version of <tt>pshufb</tt> instruction
works on lanes, i.e. 128-bit halves of a vector, thus it is impossible to
shuffle all inputs.</p>
<p>But AVX2 and AVX512 instructions still might be used in some parts of
algorithms, especially in input validation.</p>
</div>
<div id="precalculating-data">
<h2><a href="#id25">4.3   Precalculating data</a></h2>
<p>To build the whole precalculated table all 65536 span patterns have to be
processed. Processing a pattern consists following steps:</p>
<ol>
<li><strong>Determine digit spans</strong>. For pattern <tt>_ddd__d__ddd_dd_</tt> we have four spans
[(1,3), (6,6), (9,11), (14,15)]. But for pattern <tt>____dddd___ddddd</tt> there
is only one span [(4,7)]. The span at the vector&#39;s end might be continued in
the next chunk, and we don&#39;t know how to convert it. However, we may assume
that a span which starts at the vector&#39;s beginning is a new number and thus
it is included into the span&#39;s list.</li>
<li><strong>Find the best conversion scheme for the spans</strong>. We systematically check
which SSE conversion is possible, i.e. one-/two-/four-/eight-digit and how
many spans each conversion can process — the procedure which processes the
most items is selected. The output from this step are values for the following
record fields:<ul>
<li><tt>element_size</tt> — 1, 2, 4, 8 or 0 if SSE conversion is not possible;</li>
<li><tt>element_count</tt> — the numbers of converted spans;</li>
<li><tt>total_skip</tt> — how many <strong>input bytes</strong> are processed; for pattern
<tt>____dddd________</tt> we know that the whole input is processed
(<tt>total_skip=16</tt>); for pattern <tt>____d____ddddd_d</tt> we process only the
first span at index 5, but we know that four non-digit characters after
the span can be also skipped, thus <tt>total_skip</tt> is 9.</li>
</ul>
</li>
<li><strong>Construct the shuffle pattern</strong>. Having the element size and spans positions
the vector <tt>shuffle_digits</tt> is built.  The characters from a span are mapped
on the appropriate subarrays in the vector.  Also zero completion is done in
this step, as the instruction <tt>pshufb</tt> either copy given byte from the input
vector or put zero if the index has got the most significant bit set.</li>
</ol>
<div id="example">
<h3><a href="#id26">4.3.1   Example</a></h3>
<p>Let&#39;s consider span pattern <tt>_ddd__d__ddd_dd_</tt>. It can be converted using
four-digit conversion, so the layout of normalized vector should be:</p>
<pre>[ a0 | a1 | a2 | a3 | b0 | b1 | b2 | b3 | c0 | c1 | c2 | c3 | d0 | d1 | d2 | d3 ]
</pre>
<p>There are four numbers <tt>a</tt>, <tt>b</tt>, <tt>c</tt> and <tt>d</tt> in the vector; note
that the bytes at 0th index hold the most significant digits.</p>
<p>The first number in pattern has three digits at indices 1, 2 and 3. It means
that <tt>a1 = 1</tt>, <tt>a2 = 2</tt> and <tt>a3 = 3</tt>; value of <tt>a0</tt> should be zeroed,
so <tt>a0 = 0x80</tt>.</p>
<p>The second number has just one digit at index 6. Thus <tt>b3 = 6</tt> and, since
the rest digits have to be zero, <tt>b0 = b1 = b2 = 0x80</tt>.</p>
<p>The third number has three digits at indices 9, 10, 11. Thus <tt>c1 = 9</tt>,
<tt>c2 = 10</tt>, <tt>c3 = 11</tt>, and <tt>c0 = 0x80</tt>.</p>
<p>The last, forth number, has got two digits at indices 14 and 15. Thus
<tt>d2 = 14</tt>, <tt>d3 = 15</tt> and the rest have to be zero, so <tt>d0 = d1 = 0x80</tt>.</p>
<p>The final content of the <tt>shuffle_digits</tt> vector is:</p>
<pre>[ 80 |  1 |  2 |  3 | 80 | 80 | 80 |  6 | 80 |  9 | 10 | 11 | 80 | 80 | 14 | 15 ]
</pre>
</div>
</div>
<div id="sse-algorithm-outline">
<h2><a href="#id27">4.4   SSE algorithm outline</a></h2>
<p>Below are major steps of the algorithm&#39;s loop, with snippets from the actual
implementation.</p>
<ol>
<li>Load 16 characters into the input vector.</li>
</ol>
<pre><span>const</span> <span>__m128i</span> <span>input</span> <span>=</span> <span>_mm_loadu_si128</span><span>((</span><span>const</span> <span>__m128i</span><span>*</span><span>)</span><span>data</span><span>);</span>
</pre>
<ol start="2">
<li>Check for invalid characters (will be discussed <a href="#unsinged-invalid-inputs">later</a>).</li>
</ol>
<ol start="3">
<li>Build the span pattern:</li>
</ol>
<pre><span>// t0 = input[i] in [&#39;0&#39;..&#39;9] ? 0xff : 0x00
</span><span>const</span> <span>__m128i</span>  <span>t0</span> <span>=</span> <span>decimal_digits_mask</span><span>(</span><span>input</span><span>);</span>
<span>const</span> <span>uint16_t</span> <span>span_mask</span> <span>=</span> <span>_mm_movemask_epi8</span><span>(</span><span>t0</span><span>);</span>
</pre>
<ol start="5">
<li>Fetch the block info with the precalculate parameters.</li>
</ol>
<pre><span>const</span> <span>BlockInfo</span><span>&amp;</span> <span>bi</span> <span>=</span> <span>blocks</span><span>[</span><span>span_mask</span><span>];</span>
</pre>
<ol start="6">
<li>From the block info get the shuffle pattern for <tt>_mm_shuffle_epi8</tt>.</li>
</ol>
<pre><span>const</span> <span>__m128i</span> <span>shuffle_digits</span> <span>=</span> <span>_mm_loadu_si128</span><span>((</span><span>const</span> <span>__m128i</span><span>*</span><span>)</span><span>b</span><span>.</span><span>shuffle_digits</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>shuffled</span> <span>=</span> <span>_mm_shuffle_epi8</span><span>(</span><span>input</span><span>,</span> <span>shuffle_digits</span><span>);</span>
</pre>
<ol start="7">
<li>The <tt>shuffled</tt> vector is then issued to the proper conversion routine. The block
info structure keeps the conversion kind (<tt>conversion_routine</tt>) and also the number
of items to get from the SSE result (<tt>element_count</tt>). It is not always
possible to use any SSE conversion procedure, thus a scalar code is needed
to handle odd cases.</li>
</ol>
<pre><span>if</span> <span>(</span><span>b</span><span>.</span><span>conversion_routine</span> <span>==</span> <span>Conversion</span><span>::</span><span>SSE1Digit</span><span>)</span> <span>{</span>

    <span>convert_1digit</span><span>(</span><span>shuffled</span><span>,</span> <span>b</span><span>.</span><span>element_count</span><span>,</span> <span>output</span><span>);</span>

<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>b</span><span>.</span><span>conversion_routine</span> <span>==</span> <span>Conversion</span><span>::</span><span>SSE2Digits</span><span>)</span> <span>{</span>

    <span>convert_2digits</span><span>(</span><span>shuffled</span><span>,</span> <span>b</span><span>.</span><span>element_count</span><span>,</span> <span>output</span><span>);</span>

<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>b</span><span>.</span><span>conversion_routine</span> <span>==</span> <span>Conversion</span><span>::</span><span>SSE4Digits</span><span>)</span> <span>{</span>

    <span>convert_4digits</span><span>(</span><span>shuffled</span><span>,</span> <span>b</span><span>.</span><span>element_count</span><span>,</span> <span>output</span><span>);</span>

<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>b</span><span>.</span><span>conversion_routine</span> <span>==</span> <span>Conversion</span><span>::</span><span>SSE8Digits</span><span>)</span> <span>{</span>

    <span>convert_8digits</span><span>(</span><span>shuffled</span><span>,</span> <span>b</span><span>.</span><span>element_count</span><span>,</span> <span>output</span><span>);</span>

<span>}</span> <span>else</span> <span>{</span>

    <span>// case unsupported, a scalar code is called here
</span><span>}</span>
</pre>
<ol start="8">
<li>Advance the input pointer. The block info structure keeps how many bytes
were actually covered.</li>
</ol>
<pre><span>data</span> <span>+=</span> <span>b</span><span>.</span><span>total_skip</span><span>;</span>
</pre>
</div>
<div id="detecting-invalid-inputs">
<h2><a href="#id28">4.5   Detecting invalid inputs</a></h2>
<p>In case of unsigned inputs we need to classify input characters into three
categories:</p>
<ul>
<li>digits, i.e. chars &#39;0&#39; .. &#39;9&#39;;</li>
<li>user-defined set of separators;</li>
<li>invalid numbers.</li>
</ul>
<p>In practise we need two masks: one with positions of digits, another with
positions of separators. If the or&#39;ed mask has some zero elements, it means
that there are invalid characters. Below is a schema:</p>
<pre><span>const</span> <span>__m128i</span> <span>bytemask_digit</span> <span>=</span> <span>decimal_digits_mask</span><span>(</span><span>input</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>bytemask_sep</span>   <span>=</span> <span>matcher</span><span>.</span><span>get_mask</span><span>(</span><span>input</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>bytemask_valid</span> <span>=</span> <span>_mm_or_si128</span><span>(</span><span>bytemask_digit</span><span>,</span> <span>bytemask_sep</span><span>);</span>

<span>const</span> <span>uint16_t</span> <span>valid_mask</span> <span>=</span> <span>_mm_movemask_epi8</span><span>(</span><span>bytemask_valid</span><span>);</span>

<span>if</span> <span>(</span><span>valid_mask</span> <span>!=</span> <span>0xffff</span><span>)</span> <span>{</span>
    <span>throw</span> <span>std</span><span>::</span><span>logic_error</span><span>(</span><span>&#34;wrong input&#34;</span><span>);</span>
<span>}</span>
</pre>
<div id="detecting-digits-update">
<h3><a href="#id29">4.5.1   Detecting digits <img src="https://blog.plover.com/update.png" alt="update"/></a></h3>
<p>The easiest algorithm implements expression <tt>c &gt;= &#39;0&#39; and c &lt;= &#39;9&#39;</tt>:</p>
<pre><span>__m128i</span> <span>decimal_digits_mask</span><span>(</span><span>const</span> <span>__m128i</span> <span>input</span><span>)</span> <span>{</span>
    <span>const</span> <span>__m128i</span> <span>ascii0</span> <span>=</span> <span>_mm_set1_epi8</span><span>(</span><span>&#39;0&#39;</span><span>);</span>
    <span>const</span> <span>__m128i</span> <span>after_ascii9</span> <span>=</span> <span>_mm_set1_epi8</span><span>(</span><span>&#39;9&#39;</span> <span>+</span> <span>1</span><span>);</span>

    <span>const</span> <span>__m128i</span> <span>t0</span> <span>=</span> <span>_mm_cmplt_epi8</span><span>(</span><span>input</span><span>,</span> <span>ascii0</span><span>);</span> <span>// t1 = (x &lt; &#39;0&#39;)
</span>    <span>const</span> <span>__m128i</span> <span>t1</span> <span>=</span> <span>_mm_cmplt_epi8</span><span>(</span><span>input</span><span>,</span> <span>after_ascii9</span><span>);</span> <span>// t0 = (x &lt;= &#39;9&#39;)
</span>
    <span>return</span> <span>_mm_andnot_si128</span><span>(</span><span>t0</span><span>,</span> <span>t1</span><span>);</span> <span>// x &lt;= &#39;9&#39; and x &gt;= &#39;0&#39;
</span><span>}</span>
</pre>
<p>Following C-expression requires only one subtraction and one comparison:</p>
<pre><span>bool</span> <span>is_digit</span><span>(</span><span>char</span> <span>c</span><span>)</span> <span>{</span>

    <span>const</span> <span>uint8_t</span> <span>x</span> <span>=</span> <span>c</span><span>;</span>
    <span>return</span> <span>(</span><span>x</span> <span>-</span> <span>&#39;0&#39;</span><span>)</span> <span>&lt;=</span> <span>9</span><span>;</span>
<span>}</span>
</pre>
<p>However, it requires unsigned comparison, which is not available in both SSE
and AVX2. Only AVX512BW defines such instruction <tt>_mm512_cmple_epu8_mask</tt>
(<tt>vcmpgtub</tt>).</p>
<pre><span>uint64_t</span> <span>decimal_digits_mask</span><span>(</span><span>const</span> <span>__m128i</span> <span>input</span><span>)</span> <span>{</span>

    <span>const</span> <span>__m512i</span> <span>ascii0</span> <span>=</span> <span>_mm512_set1_epi8</span><span>(</span><span>&#39;0&#39;</span><span>);</span>
    <span>const</span> <span>__m512i</span> <span>ascii9</span> <span>=</span> <span>_mm512_set1_epi8</span><span>(</span><span>&#39;9&#39;</span><span>);</span>

    <span>const</span> <span>__m512i</span> <span>t0</span> <span>=</span> <span>_mm512_sub_epi8</span><span>(</span><span>input</span><span>,</span> <span>ascii0</span><span>);</span>

    <span>return</span> <span>__mm256_cmple_epu8_mask</span><span>(</span><span>t0</span><span>,</span> <span>ascii9</span><span>);</span>
<span>}</span>
</pre>
<p>Fortunatelly, it&#39;s possible to use similar trick for signed bytes,
we need just different constants. First, we subtract from the
input byte value <tt><span>(ord(&#39;0&#39;)</span> + 128) &amp; 0xff = 176 &amp; 0xff = 80</tt>.
This moves codes of &#39;0&#39;..&#39;9&#39; to range -128..-119. Then it&#39;s
sufficient to compare subtracted value with -118.</p>
<pre><span>__m128i</span> <span>decimal_digits_mask_version2</span><span>(</span><span>const</span> <span>__m128i</span> <span>input</span><span>)</span> <span>{</span>

    <span>const</span> <span>__m512i</span> <span>t0</span> <span>=</span> <span>_mm_sub_epi8</span><span>(</span><span>input</span><span>,</span> <span>_mm_set1_epi8</span><span>(</span><span>80</span><span>));</span>

    <span>return</span> <span>_mm_cmplt_epi8</span><span>(</span><span>t0</span><span>,</span> <span>_mm_set1_epi8</span><span>(</span><span>-</span><span>118</span><span>));</span>
<span>}</span>
</pre>
</div>
<div id="detecting-characters-from-set">
<h3><a href="#id30">4.5.2   Detecting characters from set</a></h3>
<div id="sse-avx2">
<h4><a href="#id31">4.5.2.1   SSE &amp; AVX2</a></h4>
<p>The most generic SSE implementation works in time proportional to the size
of a separators set. Each character from the set is broadcasted into
a vector and then compared with the input vector. The resulting byte mask is
ored with the previous result.</p>
<pre><span>__m128i</span> <span>get_mask</span><span>(</span><span>const</span> <span>__m128i</span><span>&amp;</span> <span>input</span><span>,</span> <span>const</span> <span>__m128i</span><span>&amp;</span> <span>initial</span><span>)</span> <span>const</span> <span>{</span>
    <span>__m128i</span> <span>result</span> <span>=</span> <span>initial</span><span>;</span>
    <span>for</span> <span>(</span><span>size_t</span> <span>i</span><span>=</span><span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span> <span>+</span> <span>1</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>

        <span>const</span> <span>__m128i</span> <span>mask</span> <span>=</span> <span>_mm_cmpeq_epi8</span><span>(</span><span>letters</span><span>[</span><span>i</span><span>],</span> <span>input</span><span>);</span>
        <span>result</span> <span>=</span> <span>_mm_or_si128</span><span>(</span><span>result</span><span>,</span> <span>mask</span><span>);</span>
    <span>}</span>

    <span>return</span> <span>result</span><span>;</span>
<span>}</span>
</pre>
<p>If the separators set is known at compilation time, then a compiler may
unroll the loop.</p>
</div>
<div id="sse4-2">
<h4><a href="#id32">4.5.2.2   SSE4.2</a></h4>
<p>The SNTI instruction <tt>pcmpestrm</tt> (<tt>_mm_cmpestrm</tt>) from SSE4.2 can also be used
in same cases. The instruction gets two arguments. One is an input vector.
Another one is interpreted either as a set of individual characters (up to 16) or
characters ranges (up to 8). The result is a mask for the input characters matching
the set (or ranges).  In the example below the set variant was used.</p>
<pre><span>__m128i</span> <span>get_mask</span><span>(</span><span>const</span> <span>__m128i</span><span>&amp;</span> <span>input</span><span>,</span> <span>const</span> <span>__m128i</span><span>&amp;</span> <span>initial</span><span>)</span> <span>{</span>

    <span>const</span> <span>uint8_t</span> <span>mode</span> <span>=</span> <span>_SIDD_UBYTE_OPS</span>
                       <span>|</span> <span>_SIDD_CMP_EQUAL_ANY</span>
                       <span>|</span> <span>_SIDD_UNIT_MASK</span><span>;</span>

    <span>return</span> <span>_mm_or_si128</span><span>(</span><span>initial</span><span>,</span> <span>_mm_cmpestrm</span><span>(</span><span>set</span><span>,</span> <span>set_size</span><span>,</span> <span>input</span><span>,</span> <span>16</span><span>,</span> <span>mode</span><span>));</span>
<span>}</span>
</pre>
</div>
</div>
</div>
<div id="caveats">
<h2><a href="#id33">4.6   Caveats</a></h2>
<ol>
<li>It is unlikely, and sometimes impossible, to process all digits from the
input vector. In a single iteration one to 16 bytes are converted. The table
below shows details — an important conclusion is that almost 95% of
patterns process at least half of an input vector.</li>
</ol>
<table>
<colgroup>
<col width="35%"/>
<col width="20%"/>
<col width="16%"/>
<col width="29%"/>
</colgroup>
<thead>
<tr><th>bytes processed</th>
<th>patterns</th>
<th>%</th>
<th>cumulative %</th>
</tr>
</thead>
<tbody>
<tr><td>0</td>
<td>17</td>
<td>0.03%</td>
<td>0.03%</td>
</tr>
<tr><td>2</td>
<td>32</td>
<td>0.05%</td>
<td>0.07%</td>
</tr>
<tr><td>3</td>
<td>48</td>
<td>0.07%</td>
<td>0.15%</td>
</tr>
<tr><td>4</td>
<td>176</td>
<td>0.27%</td>
<td>0.42%</td>
</tr>
<tr><td>5</td>
<td>360</td>
<td>0.55%</td>
<td>0.97%</td>
</tr>
<tr><td>6</td>
<td>542</td>
<td>0.83%</td>
<td>1.79%</td>
</tr>
<tr><td>7</td>
<td>693</td>
<td>1.06%</td>
<td>2.85%</td>
</tr>
<tr><td>8</td>
<td>1084</td>
<td>1.65%</td>
<td>4.50%</td>
</tr>
<tr><td>9</td>
<td>1620</td>
<td>2.47%</td>
<td>6.98%</td>
</tr>
<tr><td>10</td>
<td>2274</td>
<td>3.47%</td>
<td>10.45%</td>
</tr>
<tr><td>11</td>
<td>3057</td>
<td>4.66%</td>
<td>15.11%</td>
</tr>
<tr><td>12</td>
<td>4526</td>
<td>6.91%</td>
<td>22.02%</td>
</tr>
<tr><td>13</td>
<td>6193</td>
<td>9.45%</td>
<td>31.47%</td>
</tr>
<tr><td>14</td>
<td>8952</td>
<td>13.66%</td>
<td>45.13%</td>
</tr>
<tr><td>15</td>
<td>12890</td>
<td>19.67%</td>
<td>64.79%</td>
</tr>
<tr><td>16</td>
<td>23072</td>
<td>35.21%</td>
<td>100.00%</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>However, the input validation is always done for the whole vector,
all 16 bytes. This problem might be overcome, see <a href="#processing-larger-inputs">Processing larger
inputs</a>.</li>
<li>SSE units are underutilized. The longest one-digit number sequence
is &#34;1;2;3;4;5;6;7;8;&#34;. It contains eight numbers, while the SSE procedure
is able to process 16 numbers. Likewise, the longest two-digit number
sequence is &#34;12;34;56;78;98;;&#34;. It has five numbers, but the SSE procedure
is able to convert eight numbers. Similarly, the longest four-digit numbers
sequence is &#34;1234;5678;9123;;&#34; — it has three four-digit numbers, the SSE
procedure is able to convert four numbers.</li>
</ol>
<table>
<colgroup>
<col width="19%"/>
<col width="21%"/>
<col width="9%"/>
<col width="12%"/>
<col width="12%"/>
<col width="12%"/>
<col width="17%"/>
</colgroup>
<thead>
<tr><th colspan="2">SSE procedure</th>
<th colspan="2">usage in parser</th>
<th colspan="2">converted numbers</th>
<th rowspan="2">average
utilization</th>
</tr>
<tr><th>input size</th>
<th>converted nums</th>
<th>#</th>
<th>%</th>
<th>avg</th>
<th>max</th>
</tr>
</thead>
<tbody>
<tr><td>N/A</td>
<td>---</td>
<td>264</td>
<td>0.40%</td>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr><td>1-digit</td>
<td>16</td>
<td>5799</td>
<td>8.85%</td>
<td>3.52</td>
<td>8</td>
<td>22%</td>
</tr>
<tr><td>2-digit</td>
<td>8</td>
<td>21241</td>
<td>32.41%</td>
<td>3.99</td>
<td>7</td>
<td>49%</td>
</tr>
<tr><td>4-digit</td>
<td>4</td>
<td>30924</td>
<td>47.18%</td>
<td>3.48</td>
<td>4</td>
<td>87%</td>
</tr>
<tr><td>8-digit</td>
<td>2</td>
<td>7308</td>
<td>11.15%</td>
<td>1.97</td>
<td>2</td>
<td>98%</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="parsing-and-conversion-of-signed-numbers">

<div id="id2">
<ul>
<li><a href="#algorithm" id="id74">5.1   Algorithm</a></li>
<li><a href="#implementation-note" id="id75">5.2   Implementation note</a></li>
<li><a href="#id3" id="id76">5.3   Detecting invalid inputs</a><ul>
<li><a href="#avx512vbmi" id="id77">5.3.1   AVX512VBMI</a></li>
</ul>
</li>
<li><a href="#id4" id="id78">5.4   SSE algorithm outline</a></li>
</ul>
</div>
<div id="algorithm">
<h2><a href="#id35">5.1   Algorithm</a></h2>
<p>Similarly to the unsigned conversion, the signed conversion also requires <strong>a
span pattern</strong>. But in this case also the sign characters &#39;+&#39; and &#39;-&#39; are
included in the pattern. For this sample string:</p>
<pre>input     = &#34;_+123_-45_78_-9_&#34;
</pre>
<p>the span pattern is:</p>
<pre>span_mask = _dddd_ddd_dd_dd_
</pre>
<p>The conversion unfortunately requires two shuffles:</p>
<ol>
<li>Shuffle spans onto proper vector elements — this is exactly the same
as in unsigned conversion.</li>
<li>Populate the first span characters, i.e. <strong>possibly sign character</strong>,
on the proper vector elements.</li>
</ol>
<p>For input:</p>
<pre>input =

[ &#39;_&#39; | &#39;-&#39; | &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;_&#39; | &#39;+&#39; | &#39;4&#39; | &#39;5&#39; | &#39;_&#39; | &#39;-&#39; | &#39;6&#39; | &#39;_&#39; | &#39;7&#39; | &#39;8&#39; | &#39;_&#39; ]
</pre>
<p>The conversion processes four four-digit numbers. After shuffling the
digit spans we have:</p>
<pre>shuffled =

[ &#39;-&#39;   &#39;1&#39;   &#39;2&#39;   &#39;3&#39; | 0x00  &#39;+&#39;   &#39;4&#39;   &#39;5&#39; | 0x00  0x00  &#39;-&#39;   &#39;6&#39; | 0x00  0x00  &#39;7&#39;   &#39;8&#39; ]
</pre>
<p>and the vector of sign characters is:</p>
<pre>shuffled_signs =

[ &#39;-&#39;   &#39;-&#39;   &#39;-&#39;   &#39;-&#39; | &#39;+&#39;   &#39;+&#39;   &#39;+&#39;   &#39;+&#39; | &#39;-&#39;   &#39;-&#39;   &#39;-&#39;   &#39;-&#39; | &#39;7&#39;   &#39;7&#39;   &#39;7&#39;   &#39;7&#39; ]
</pre>
<p>The <tt>shuffled_signs</tt> vector does not necessarily contain only &#39;+&#39; or &#39;-&#39;,
it might contain also digits, but this is not an error.</p>
<p>Then the conversion works as follows:</p>
<ul>
<li><p>From the <tt>shuffled</tt> vector the sign characters are removed and
ASCII characters are converted into values:</p>
<pre>[  0     1     2     3  |  0     0     4     5  |  0     0     0     6  |  0     0     7     8  ]
</pre>
</li>
<li><p>Thus we end up with a vector of unsigned numbers, and such an input
can be converted by the already defined SSE procedures:</p>
<pre>[          123          |           45          |           6           |           78          ]
</pre>
</li>
<li><p>Finally, negate appropriate elements; we use a well known equation <tt>(~x + 1)</tt>,
which is expressed in the SSE code as <tt>(x xor <span>(-1)</span> - <span>(-1))</span></tt>. The value <tt><span>-1</span></tt>
is obtained from comparing <tt>shuffled_signs</tt> with the &#39;-&#39;:</p>
<pre>negated_mask = (shuffled_signs == packed_byte(&#39;-&#39;))

[ ff    ff    ff    ff  | 00    00    00    00  | ff    ff    ff    ff  | 00    00    00    00  ]
</pre>
<p>or as vector of <tt>int32_t</tt>:</p>
<pre>[          -1           |           0           |          -1           |           0           ]
</pre>
</li>
</ul>
</div>
<div id="implementation-note">
<h2><a href="#id36">5.2   Implementation note</a></h2>
<p>Masking of the sign characters in <tt>shuffled</tt> vector is done at no cost, as
the instruction <tt>_mm_subs_epu8</tt> (<tt>psubusb</tt>) is used to convert from ASCII to
numeric values:</p>
<pre><span>const</span> <span>__m128i</span> <span>ascii0</span> <span>=</span> <span>_mm_set1_epi8</span><span>(</span><span>&#39;0&#39;</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>t0</span> <span>=</span> <span>_mm_subs_epu8</span><span>(</span><span>input</span><span>,</span> <span>ascii0</span><span>);</span>
</pre>
<p>The instruction performs <strong>subtract with saturation</strong>, i.e. calculates <tt>max(0,
<span>a-b)</span></tt>. Since the ASCII codes of &#39;-&#39; and &#39;+&#39; are respectively 43 and 45 and the
ASCII code of &#39;0&#39; is 48, then the result of such expression is zero for both
sign characters.</p>
</div>
<div id="id3">
<h2><a href="#id37">5.3   Detecting invalid inputs</a></h2>
<p>The characters &#39;+&#39; and &#39;-&#39; can be present only at the beginning of a digit
span, i.e. we want to reject inputs like &#34;++12&#34; or &#34;1234-,&#34;.</p>
<p>To properly validate the input we need four masks for:</p>
<ol>
<li>separators,</li>
<li>digits,</li>
<li>the character &#39;-&#39;,</li>
<li>the character &#39;+&#39;.</li>
</ol>
<p>The first phase is similar to the unsigned conversion, i.e. all masks are or&#39;ed
together, then zero elements point at invalid characters.</p>
<p>The second phase checks if sign characters are placed properly.  For each span
combination we need to precalculate the mask of valid sign positions. Then,
after or&#39;ing the masks for the &#39;+&#39; and &#39;-&#39; we simply verify if they are placed
on valid positions.</p>
<p>In practise the precalculated data has a bit-mask for invalid sign positions,
thanks to that validation require just a simple and. The snippet below shows
the schema of the second step.</p>
<pre><span>const</span> <span>__m128i</span> <span>ascii_minus</span> <span>=</span> <span>_mm_set1_epi8</span><span>(</span><span>&#39;-&#39;</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>ascii_plus</span>  <span>=</span> <span>_mm_set1_epi8</span><span>(</span><span>&#39;+&#39;</span><span>);</span>

<span>// ...
</span>
<span>const</span> <span>__m128i</span> <span>bytemask_plus</span>  <span>=</span> <span>_mm_cmpeq_epi8</span><span>(</span><span>input</span><span>,</span> <span>ascii_plus</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>bytemask_minus</span> <span>=</span> <span>_mm_cmpeq_epi8</span><span>(</span><span>input</span><span>,</span> <span>ascii_minus</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>bytemask_sign</span>  <span>=</span> <span>_mm_or_si128</span><span>(</span><span>bytemask_plus</span><span>,</span> <span>bytemask_minus</span><span>);</span>

<span>// ...
</span>
<span>const</span> <span>uint16_t</span> <span>sign_mask</span> <span>=</span> <span>_mm_movemask_epi8</span><span>(</span><span>bytemask_sign</span><span>);</span>
<span>const</span> <span>uint16_t</span> <span>span_mask</span> <span>=</span> <span>_mm_movemask_epi8</span><span>(</span><span>bytemask_span</span><span>);</span>
<span>const</span> <span>BlockInfo</span><span>&amp;</span> <span>bi</span> <span>=</span> <span>blocks</span><span>[</span><span>span_mask</span><span>];</span>
<span>if</span> <span>(</span><span>sign_mask</span> <span>&amp;</span> <span>bi</span><span>.</span><span>invalid_sign_mask</span><span>)</span> <span>{</span>
    <span>throw</span> <span>std</span><span>::</span><span>runtime_error</span><span>(</span><span>&#34;&#39;+&#39; or &#39;-&#39; at invalid position&#34;</span><span>);</span>
<span>}</span>
</pre>
<div id="avx512vbmi">
<h3><a href="#id38">5.3.1   AVX512VBMI</a></h3>
<p>AVX512VBMI defines the powerful instruction <tt>_mm512_permutex2var_epi8</tt> (<tt>vperm2b</tt>)
which does a lookup in a 128-byte table using as the indices the seven lowest bits of
each byte of a ZMM register. Invocation of the intrinsics function is weird:</p>
<pre><span>const</span> <span>__m512i</span> <span>lookup_lo</span> <span>=</span> <span>...</span> <span>// elements 0..63
</span><span>const</span> <span>__m512i</span> <span>lookup_hi</span> <span>=</span> <span>...</span> <span>// and 64..127 of the lookup
</span><span>const</span> <span>__m512i</span> <span>transformed</span> <span>=</span> <span>_mm512_permutex2var_epi8</span><span>(</span><span>lookup_lo</span><span>,</span> <span>input</span><span>,</span> <span>lookup_hi</span><span>);</span>
</pre>
<p>If the set of valid character fits in the standard ASCII character set, i.e.
just seven lowest bits are set, then the validation step might quickly reject
extended ASCII (7th bit set) and then translate the input using single
invocation of <tt>_mm512_permutex2var_epi8</tt>. When full 8-bit input
is allowed, then the instruction has to be called twice with two halves
of a 256-byte lookup.</p>
<p>An invocation (or two) of this instruction allows to classify <strong>at once</strong>
all 64 input bytes into required categories:</p>
<ul>
<li>separators — it doesn&#39;t matter how many separator chars are used;</li>
<li>digits;</li>
<li>and sign characters.</li>
</ul>
<p>Category is encoded as a bit at certain position, in sample implementation
following schema is used:</p>
<ul>
<li><tt>separator = 0x01</tt>,</li>
<li><tt>digit = 0x80</tt>,</li>
<li><tt>sign = 0x80 | 0x40</tt>.</li>
</ul>
<p>If the transformed vector contains zero byte, it means there are invalid characters.</p>
<p>The span pattern is obtained from the most significant bits by the instruction
<tt>_mm512_movepi8_mask</tt> (<tt>vpmovb2m</tt>); it works exactly the same way as
<tt>pmovmaskb</tt> from SSE.  The sign pattern is obtained by the instruction
<tt>_mm512_test_epi8_mask</tt> (<tt>vptestmb</tt>), by testing bit 7th (mask <tt>0x40</tt>).</p>
<p>Below is a snippet from the implementation:</p>
<pre><span>const</span> <span>__m512i</span> <span>classes</span> <span>=</span> <span>_mm512_permutex2var_epi8</span><span>(</span><span>class_lo</span><span>,</span> <span>input</span><span>,</span> <span>class_hi</span><span>);</span>

<span>if</span> <span>(</span><span>_mm512_test_epi8_mask</span><span>(</span><span>classes</span><span>,</span> <span>classes</span><span>)</span> <span>!=</span> <span>uint64_t</span><span>(</span><span>-</span><span>1</span><span>))</span> <span>{</span>
    <span>throw</span> <span>std</span><span>::</span><span>logic_error</span><span>(</span><span>&#34;invalid character&#34;</span><span>);</span>
<span>}</span>

<span>uint64_t</span> <span>span_mask64</span> <span>=</span> <span>_mm512_movepi8_mask</span><span>(</span><span>classes</span><span>);</span>
<span>uint64_t</span> <span>sign_mask64</span> <span>=</span> <span>_mm512_test_epi8_mask</span><span>(</span><span>classes</span><span>,</span> <span>_mm512_set1_epi8</span><span>(</span><span>int8_t</span><span>(</span><span>0x40</span><span>)));</span>
</pre>
</div>
</div>
<div id="id4">
<h2><a href="#id39">5.4   SSE algorithm outline</a></h2>
<p>Below are major steps of the algorithm&#39;s loop, with snippets from the actual
implementation.</p>
<ol>
<li>Load 16 characters into the input vector.</li>
</ol>
<pre><span>const</span> <span>__m128i</span> <span>input</span> <span>=</span> <span>_mm_loadu_si128</span><span>((</span><span>const</span> <span>__m128i</span><span>*</span><span>)</span><span>data</span><span>);</span>
</pre>
<ol start="2">
<li>Check for invalid characters (as described <a href="#unsinged-invalid-inputs">above</a>).</li>
<li>Build the span pattern and fetch the conversion parameters.</li>
</ol>
<pre><span>const</span> <span>__m128i</span> <span>ascii_minus</span>    <span>=</span> <span>_mm_set1_epi8</span><span>(</span><span>&#39;-&#39;</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>ascii_plus</span>     <span>=</span> <span>_mm_set1_epi8</span><span>(</span><span>&#39;+&#39;</span><span>);</span>

<span>// ...
</span><span>const</span> <span>__m128i</span> <span>bytemask_plus</span>  <span>=</span> <span>_mm_cmpeq_epi8</span><span>(</span><span>input</span><span>,</span> <span>ascii_plus</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>bytemask_minus</span> <span>=</span> <span>_mm_cmpeq_epi8</span><span>(</span><span>input</span><span>,</span> <span>ascii_minus</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>bytemask_sign</span>  <span>=</span> <span>_mm_or_si128</span><span>(</span><span>bytemask_plus</span><span>,</span> <span>bytemask_minus</span><span>);</span>

<span>const</span> <span>__m128i</span> <span>bytemask_digit</span> <span>=</span> <span>decimal_digits_mask</span><span>(</span><span>input</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>bytemask_span</span>  <span>=</span> <span>_mm_or_si128</span><span>(</span><span>bytemask_digit</span><span>,</span> <span>bytemask_sign</span><span>);</span>

<span>const</span> <span>uint16_t</span> <span>span_mask</span> <span>=</span> <span>_mm_movemask_epi8</span><span>(</span><span>bytemask_span</span><span>);</span>
<span>const</span> <span>BlockInfo</span><span>&amp;</span> <span>bi</span> <span>=</span> <span>block_info</span><span>[</span><span>span_mask</span><span>];</span>
</pre>
<ol start="4">
<li>Validate if the sign characters are properly placed.</li>
</ol>
<pre><span>const</span> <span>uint16_t</span> <span>sign_mask</span> <span>=</span> <span>_mm_movemask_epi8</span><span>(</span><span>bytemask_sign</span><span>);</span>
<span>if</span> <span>(</span><span>sign_mask</span> <span>&amp;</span> <span>bi</span><span>.</span><span>invalid_sign_mask</span><span>)</span> <span>{</span>
    <span>throw</span> <span>std</span><span>::</span><span>runtime_error</span><span>(</span><span>&#34;&#39;+&#39; or &#39;-&#39; at invalid position&#34;</span><span>);</span>
<span>}</span>
</pre>
<ol start="5">
<li>If <tt>sign_mask</tt> is zero, choose faster unsigned conversion path.</li>
<li>Otherwise prepare data for signed conversion.</li>
</ol>
<pre><span>const</span> <span>__m128i</span> <span>ascii_minus</span> <span>=</span> <span>_mm_set1_epi8</span><span>(</span><span>&#39;-&#39;</span><span>);</span>

<span>const</span> <span>__m128i</span> <span>shuffle_digits</span> <span>=</span> <span>_mm_loadu_si128</span><span>((</span><span>const</span> <span>__m128i</span><span>*</span><span>)</span><span>bi</span><span>.</span><span>shuffle_digits</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>shuffle_signs</span>  <span>=</span> <span>_mm_loadu_si128</span><span>((</span><span>const</span> <span>__m128i</span><span>*</span><span>)</span><span>bi</span><span>.</span><span>shuffle_signs</span><span>);</span>

<span>const</span> <span>__m128i</span> <span>shuffled</span>       <span>=</span> <span>_mm_shuffle_epi8</span><span>(</span><span>input</span><span>,</span> <span>shuffle_digits</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>shuffled_signs</span> <span>=</span> <span>_mm_shuffle_epi8</span><span>(</span><span>input</span><span>,</span> <span>shuffle_signs</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>negate_mask</span>    <span>=</span> <span>_mm_cmpeq_epi8</span><span>(</span><span>shuffled_signs</span><span>,</span> <span>ascii_minus</span><span>);</span>
</pre>
<ol start="7">
<li>And finally invoke proper conversion routine.</li>
</ol>
<pre><span>if</span> <span>(</span><span>bi</span><span>.</span><span>conversion_routine</span> <span>==</span> <span>Conversion</span><span>::</span><span>SSE1Digit</span><span>)</span> <span>{</span>

    <span>convert_1digit</span><span>(</span><span>shuffled</span><span>,</span> <span>bi</span><span>.</span><span>element_count</span><span>,</span> <span>output</span><span>);</span>

<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>bi</span><span>.</span><span>conversion_routine</span> <span>==</span> <span>Conversion</span><span>::</span><span>SSE2Digits</span><span>)</span> <span>{</span>

    <span>convert_2digits_signed</span><span>(</span><span>shuffled</span><span>,</span> <span>negate_mask</span><span>,</span> <span>bi</span><span>.</span><span>element_count</span><span>,</span> <span>output</span><span>);</span>

<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>bi</span><span>.</span><span>conversion_routine</span> <span>==</span> <span>Conversion</span><span>::</span><span>SSE4Digits</span><span>)</span> <span>{</span>

    <span>convert_4digits_signed</span><span>(</span><span>shuffled</span><span>,</span> <span>negate_mask</span><span>,</span> <span>bi</span><span>.</span><span>element_count</span><span>,</span> <span>output</span><span>);</span>

<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>bi</span><span>.</span><span>conversion_routine</span> <span>==</span> <span>Conversion</span><span>::</span><span>SSE8Digits</span><span>)</span> <span>{</span>

    <span>convert_8digits_signed</span><span>(</span><span>shuffled</span><span>,</span> <span>negate_mask</span><span>,</span> <span>bi</span><span>.</span><span>element_count</span><span>,</span> <span>output</span><span>);</span>

<span>}</span> <span>else</span> <span>{</span>

    <span>// scalar conversion
</span><span>}</span>
</pre>
</div>
</div>
<div id="processing-larger-inputs">

<p>As it was stated in <a href="#caveats">Caveats</a> section, a single step of algorithm validates the
whole input vector but rarely converts all bytes from the input.  Although
detecting digits and sign characters might be considered cheap, we saw that
validating against an arbitrary set of separators might be really time
consuming.</p>
<p>The idea is to separate the validation from the conversion. In case of the
unsigned conversion only the <tt>span_mask</tt> is needed; in case of the
signed conversion we need also <tt>sign_mask</tt>.</p>
<p>In each iteration we process four 16-byte chunks. The result from this step are
64-bit masks. Then, we load 16 bytes into the input vector and use the lower
16-bit part of already calculated mask to get block info for the loaded code.</p>
<p>For unsigned conversion the main loop looks like this:</p>
<pre><span>while</span> <span>(</span><span>data</span> <span>&lt;</span> <span>end</span><span>)</span> <span>{</span>

    <span>const</span> <span>__m128i</span> <span>input</span> <span>=</span> <span>_mm_loadu_si128</span><span>((</span><span>const</span> <span>__m128i</span><span>*</span><span>)</span><span>data</span><span>);</span>

    <span>// validate input and calculate span_mask
</span>    <span>const</span> <span>uint16_t</span> <span>span_mask</span> <span>=</span> <span>get_span_mask</span><span>(</span><span>input</span><span>);</span>
    <span>// obtain block info
</span>    <span>const</span> <span>BlockInfo</span><span>&amp;</span> <span>bi</span> <span>=</span> <span>block_info</span><span>[</span><span>span_mask</span><span>];</span>
    <span>// convert
</span>    <span>convert</span><span>(</span><span>input</span><span>,</span> <span>bi</span><span>);</span>

    <span>// advance pointer
</span>    <span>data</span> <span>+=</span> <span>bi</span><span>.</span><span>total_processed</span><span>;</span>
<span>}</span>
</pre>
<p>And after applying the proposed change:</p>
<pre><span>while</span> <span>(</span><span>data</span> <span>&lt;</span> <span>end</span><span>)</span> <span>{</span>

    <span>const</span> <span>__m128i</span> <span>input0</span> <span>=</span> <span>_mm_loadu_si128</span><span>((</span><span>const</span> <span>__m128i</span><span>*</span><span>)(</span><span>data</span> <span>+</span> <span>0</span><span>*</span><span>16</span><span>));</span>
    <span>const</span> <span>__m128i</span> <span>input1</span> <span>=</span> <span>_mm_loadu_si128</span><span>((</span><span>const</span> <span>__m128i</span><span>*</span><span>)(</span><span>data</span> <span>+</span> <span>1</span><span>*</span><span>16</span><span>));</span>
    <span>const</span> <span>__m128i</span> <span>input2</span> <span>=</span> <span>_mm_loadu_si128</span><span>((</span><span>const</span> <span>__m128i</span><span>*</span><span>)(</span><span>data</span> <span>+</span> <span>2</span><span>*</span><span>16</span><span>));</span>
    <span>const</span> <span>__m128i</span> <span>input3</span> <span>=</span> <span>_mm_loadu_si128</span><span>((</span><span>const</span> <span>__m128i</span><span>*</span><span>)(</span><span>data</span> <span>+</span> <span>3</span><span>*</span><span>16</span><span>));</span>

    <span>// validate input and calculate 4 x span_mask
</span>    <span>const</span> <span>uint16_t</span> <span>span_mask0</span> <span>=</span> <span>get_span_mask</span><span>(</span><span>input0</span><span>);</span>
    <span>const</span> <span>uint16_t</span> <span>span_mask1</span> <span>=</span> <span>get_span_mask</span><span>(</span><span>input1</span><span>);</span>
    <span>const</span> <span>uint16_t</span> <span>span_mask2</span> <span>=</span> <span>get_span_mask</span><span>(</span><span>input2</span><span>);</span>
    <span>const</span> <span>uint16_t</span> <span>span_mask3</span> <span>=</span> <span>get_span_mask</span><span>(</span><span>input3</span><span>);</span>

    <span>const</span> <span>uint64_t</span> <span>span_mask64</span> <span>=</span> <span>(</span><span>uint64_t</span><span>(</span><span>span_mask0</span><span>)</span> <span>&lt;&lt;</span> <span>(</span><span>0</span><span>*</span><span>16</span><span>))</span>
                               <span>|</span> <span>(</span><span>uint64_t</span><span>(</span><span>span_mask1</span><span>)</span> <span>&lt;&lt;</span> <span>(</span><span>1</span><span>*</span><span>16</span><span>))</span>
                               <span>|</span> <span>(</span><span>uint64_t</span><span>(</span><span>span_mask2</span><span>)</span> <span>&lt;&lt;</span> <span>(</span><span>2</span><span>*</span><span>16</span><span>))</span>
                               <span>|</span> <span>(</span><span>uint64_t</span><span>(</span><span>span_mask3</span><span>)</span> <span>&lt;&lt;</span> <span>(</span><span>3</span><span>*</span><span>16</span><span>));</span>

    <span>char</span><span>*</span> <span>ptr</span> <span>=</span> <span>data</span> <span>+</span> <span>3</span><span>*</span><span>16</span><span>;</span>
    <span>while</span> <span>(</span><span>data</span> <span>&lt;</span> <span>ptr</span><span>)</span> <span>{</span>
        <span>const</span> <span>uint16_t</span> <span>span_mask</span> <span>=</span> <span>span_mask64</span> <span>&amp;</span> <span>0xffff</span><span>;</span>
        <span>// obtain block info
</span>        <span>const</span> <span>BlockInfo</span><span>&amp;</span> <span>bi</span> <span>=</span> <span>block_info</span><span>[</span><span>span_mask</span><span>];</span>

        <span>// read input
</span>        <span>const</span> <span>__m128i</span> <span>input</span> <span>=</span> <span>load</span> <span>16</span><span>-</span><span>byte</span> <span>from</span> <span>data</span>

        <span>// convert
</span>        <span>convert</span><span>(</span><span>input</span><span>,</span> <span>bi</span><span>);</span>

        <span>// advance pointer
</span>        <span>data</span> <span>+=</span> <span>bi</span><span>.</span><span>total_processed</span><span>;</span>

        <span>// shift the mas accordingly
</span>        <span>span_mask64</span> <span>&gt;&gt;=</span> <span>bi</span><span>.</span><span>total_processed</span><span>;</span>
    <span>}</span>
<span>}</span>
</pre>
<p>The problem of this solution is multiple reading the input bytes. Moreover, the
looping schema is more complicated; especially in practice, where also scalar
fallback have to be considered (it is not shown here).</p>
</div>
<div id="id5">

<p>The idea of separation the validation step from the actual conversion might
also be applied for scalar parser. The validation, i.e. building a <tt>span_mask</tt>
is done by SIMD code. Then, each byte of the <tt>span_mask</tt> is processed
by a precompiled code for each of 256 cases.</p>
<p>There are two major advantages:</p>
<p>1. Scalar conversions are called with compile-time constants, thanks to
that a compiler can perform as many optimizations as possible.</p>
<p>2. Digits spans that cross byte boundary can be processed seamlessly. When a
span ends at the byte&#39;s end, a conversion routine converts all characters from
the input&#39;s chunk and marks that the conversion is not completed.</p>
<p>When the next pattern is processed, the mark is checked: if the first
bit of the current pattern is zero, it means that the previously converted
number is ready and can be saved. If the first bit is one, it means that the
first span is continuation and thus conversion must be carried on from
the saved point.</p>
<div id="id6">
<h2><a href="#id42">7.1   Example</a></h2>
<p>Let&#39;s convert following input 24-byte input (the space separates 8-byte chunks):</p>
<pre>_12_3_45 6_7890_1 ___99___
</pre>
<p>The first chunk of input is <tt>_12_3_45</tt>, i.e. the <tt>span_pattern = 0b01101011
= 0x6b</tt>. The digit spans are [(1,2), (4,4), (6,7)], following code handles them:</p>
<pre><span>*</span><span>output</span><span>++</span> <span>=</span> <span>convert</span><span>&lt;</span><span>2</span><span>&gt;</span><span>(</span><span>data</span> <span>+</span> <span>1</span><span>);</span>
<span>*</span><span>output</span><span>++</span> <span>=</span> <span>convert</span><span>&lt;</span><span>1</span><span>&gt;</span><span>(</span><span>data</span> <span>+</span> <span>4</span><span>);</span>
<span>val</span>       <span>=</span> <span>convert</span><span>&lt;</span><span>2</span><span>&gt;</span><span>(</span><span>data</span> <span>+</span> <span>6</span><span>);</span>
<span>has_val</span>   <span>=</span> <span>true</span><span>;</span>
</pre>
<p>The template <tt>convert</tt> is parametrized by the number of digits to convert and
gets a pointer to the first character. The important fact is such code doesn&#39;t need
to validate pointers, sizes etc. All is known in the compile-time.</p>
<p>The next input&#39;s chunk is <tt>6_7890_1</tt>, the digit spans are [(0,0), (2,5), (7,7)].
A variant of template <tt>convert</tt> that accepts two parameters simple starts
conversion from the saved state (<tt>val</tt>).</p>
<pre><span>if</span> <span>(</span><span>has_val</span><span>)</span> <span>{</span>
    <span>*</span><span>output</span><span>++</span> <span>=</span> <span>continue</span><span>&lt;</span><span>1</span><span>&gt;</span><span>(</span><span>data</span> <span>+</span> <span>0</span><span>,</span> <span>val</span><span>);</span>
<span>}</span> <span>else</span> <span>{</span>
    <span>*</span><span>output</span><span>++</span> <span>=</span> <span>convert</span><span>&lt;</span><span>1</span><span>&gt;</span><span>(</span><span>data</span> <span>+</span> <span>0</span><span>);</span>
<span>}</span>

<span>*</span><span>output</span><span>++</span> <span>=</span> <span>convert</span><span>&lt;</span><span>4</span><span>&gt;</span><span>(</span><span>data</span> <span>+</span> <span>2</span><span>);</span>
<span>val</span>       <span>=</span> <span>convert</span><span>&lt;</span><span>1</span><span>&gt;</span><span>(</span><span>data</span> <span>+</span> <span>7</span><span>);</span>
<span>has_val</span>   <span>=</span> <span>true</span><span>;</span>
</pre>
<p>The last, third chunk, is <tt>___99___</tt>, and there is just one digit span [(3,4)]:</p>
<pre><span>if</span> <span>(</span><span>has_val</span><span>)</span> <span>{</span>
    <span>*</span><span>output</span><span>++</span> <span>=</span> <span>val</span><span>;</span>
    <span>has_val</span> <span>=</span> <span>false</span><span>;</span>
<span>}</span>

<span>*</span><span>output</span><span>++</span> <span>=</span> <span>convert</span><span>&lt;</span><span>2</span><span>&gt;</span><span>(</span><span>data</span> <span>+</span> <span>3</span><span>);</span>
<span>has_val</span>   <span>=</span> <span>false</span><span>;</span>
</pre>
</div>
</div>
<div id="appendix-a-conversion-of-three-digit-numbers">

<p>When the input vector contains an array of three-digit numbers, like
&#34;123;456;789;123;&#34;, we still use four-digit conversion routine. But we might
utilize the fact that the most significant digit is always zero.</p>
<p>We use <tt>_mm_maddubs_epi16</tt>, but with weights 1, 10, 100, 0: two lower digits
are converted and the most significant digit is properly scaled. Then simple
horizontal add <tt>_mm_hadd_epi16</tt> adds the intermediate results.</p>
<pre><span>// t0 = [   0 |   5 |   7 |   9 |   0 |   1 |   2 |   3 |   0 |   9 |   2 |   5 |   0 |   3 |   2 |   7 ]
</span><span>const</span> <span>__m128i</span> <span>ascii0</span>  <span>=</span> <span>_mm_set1_epi8</span><span>(</span><span>&#39;0&#39;</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>t0</span> <span>=</span> <span>_mm_subs_epu8</span><span>(</span><span>input</span><span>,</span> <span>ascii0</span><span>);</span>

<span>// t1 = [    500    |     79    |    100    |    23     |    900    |    25     |    300    |    27     ]
</span><span>const</span> <span>__m128i</span> <span>mul_all</span> <span>=</span> <span>_mm_setr_epi8</span><span>(</span><span>0</span><span>,</span> <span>100</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>100</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>100</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>100</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>t1</span> <span>=</span> <span>_mm_maddubs_epi16</span><span>(</span><span>t0</span><span>,</span> <span>mul_all</span><span>);</span>

<span>// t2 = [    579    |    123    |    925    |   327     |    579    |    123    |    925    |   327     ]
</span><span>const</span> <span>__m128i</span> <span>t2</span> <span>=</span> <span>_mm_hadd_epi16</span><span>(</span><span>t1</span><span>,</span> <span>t1</span><span>);</span>
</pre>
</div>
<div id="appendix-b-conversion-of-two-four-digit-numbers">

<p>Where two four-digits are going to be converted, a faster approach can be used.
Instead of storing each digit on separate bytes, digits are stored on 16-bit
values. Then a single <tt>_mm_madd_epi16</tt> is used to multiply all digits by
weights 1, 10, 100, 1000. Then the result&#39;s halves are added with <tt>_mm_hadd_epi32</tt>
(<tt>phaddd</tt>).</p>
<pre><span>// input = &#34;12345678&#34;
</span>
<span>// t0 = [   0 |   1 |   0 |   2 |   0 |   3 |   0 |   4 |   0 |   5 |   0 |   6 |   0 |   7 |   0 |   8 ]
</span><span>const</span> <span>__m128i</span> <span>ascii0</span>  <span>=</span> <span>_mm_set1_epi8</span><span>(</span><span>&#39;0&#39;</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>t0</span> <span>=</span> <span>_mm_subs_epu8</span><span>(</span><span>input</span><span>,</span> <span>ascii0</span><span>);</span>

<span>// t0 = [         1 |         2 |         3 |         4 |         5 |         6 |         7 |         8 ]
//    * [      1000 |       100 |        10 |         1 |      1000 |       100 |        10 |         1 ]
</span>
<span>// t1 = [         1200          |           34          |          5600         |          78           ]
</span><span>const</span> <span>__m128i</span> <span>mul_all</span> <span>=</span> <span>_mm_setr_epi16</span><span>(</span><span>1000</span><span>,</span> <span>100</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>1000</span><span>,</span> <span>100</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>);</span>
<span>const</span> <span>__m128i</span> <span>t1</span> <span>=</span> <span>_mm_madd_epi16</span><span>(</span><span>t0</span><span>,</span> <span>mul_all</span><span>);</span>

<span>// t2 = [         1234          |         5678          |         1234          |          5678         ]
</span><span>const</span> <span>__m128i</span> <span>t2</span> <span>=</span> <span>_mm_hadd_epi32</span><span>(</span><span>t1</span><span>,</span> <span>t1</span><span>);</span>
</pre>
</div>
<div id="reference-scalar-procedures">

<p>There are two reference scalar implementations:</p>
<ul>
<li>a fully specialized, handcrafted parser;</li>
<li>parser based on two standard functions: <tt>strspn</tt> and <tt>strtol</tt>.</li>
</ul>
<p>The handcrafted source:</p>
<pre><span>template</span> <span>&lt;</span><span>typename</span> <span>INSERTER</span><span>&gt;</span>
<span>void</span> <span>parse_signed</span><span>(</span><span>const</span> <span>char</span><span>*</span> <span>data</span><span>,</span> <span>size_t</span> <span>size</span><span>,</span> <span>const</span> <span>char</span><span>*</span> <span>separators</span><span>,</span> <span>INSERTER</span> <span>output</span><span>)</span> <span>{</span>

    <span>enum</span> <span>State</span> <span>{</span>
        <span>Separator</span><span>,</span>
        <span>Plus</span><span>,</span>
        <span>Minus</span><span>,</span>
        <span>Digit</span>
    <span>};</span>

    <span>State</span> <span>state</span> <span>=</span> <span>Separator</span><span>;</span>
    <span>State</span> <span>prev</span> <span>=</span> <span>Separator</span><span>;</span>
    <span>bool</span> <span>negative</span> <span>=</span> <span>false</span><span>;</span>
    <span>int32_t</span> <span>number</span> <span>=</span> <span>0</span><span>;</span>

    <span>for</span> <span>(</span><span>size_t</span> <span>i</span><span>=</span><span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>size</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
        <span>const</span> <span>char</span> <span>c</span> <span>=</span> <span>data</span><span>[</span><span>i</span><span>];</span>
        <span>if</span> <span>(</span><span>c</span> <span>==</span> <span>&#39;+&#39;</span><span>)</span> <span>{</span>
            <span>state</span> <span>=</span> <span>Plus</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>c</span> <span>==</span> <span>&#39;-&#39;</span><span>)</span> <span>{</span>
            <span>state</span> <span>=</span> <span>Minus</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>c</span> <span>&gt;=</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> <span>c</span> <span>&lt;=</span> <span>&#39;9&#39;</span><span>)</span> <span>{</span>
            <span>state</span> <span>=</span> <span>Digit</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>contains</span><span>(</span><span>separators</span><span>,</span> <span>c</span><span>))</span> <span>{</span>
            <span>state</span> <span>=</span> <span>Separator</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>throw</span> <span>std</span><span>::</span><span>runtime_error</span><span>(</span><span>&#34;Wrong character (scalar)&#34;</span><span>);</span>
        <span>}</span>

        <span>switch</span> <span>(</span><span>state</span><span>)</span> <span>{</span>
            <span>case</span> <span>Plus</span><span>:</span>
                <span>if</span> <span>(</span><span>prev</span> <span>!=</span> <span>Separator</span><span>)</span> <span>{</span>
                    <span>throw</span> <span>std</span><span>::</span><span>runtime_error</span><span>(</span><span>&#34;Invalid syntax (&#39;+&#39; follows a non-separator character)&#34;</span><span>);</span>
                <span>}</span>
                <span>number</span> <span>=</span> <span>0</span><span>;</span>
                <span>negative</span> <span>=</span> <span>false</span><span>;</span>
                <span>break</span><span>;</span>

            <span>case</span> <span>Minus</span><span>:</span>
                <span>if</span> <span>(</span><span>prev</span> <span>!=</span> <span>Separator</span><span>)</span> <span>{</span>
                    <span>throw</span> <span>std</span><span>::</span><span>runtime_error</span><span>(</span><span>&#34;Invalid syntax (&#39;-&#39; follows a non-separator character)&#34;</span><span>);</span>
                <span>}</span>
                <span>number</span> <span>=</span> <span>0</span><span>;</span>
                <span>negative</span> <span>=</span> <span>true</span><span>;</span>
                <span>break</span><span>;</span>

            <span>case</span> <span>Digit</span><span>:</span>
                <span>if</span> <span>(</span><span>prev</span> <span>==</span> <span>Separator</span><span>)</span> <span>{</span>
                    <span>number</span> <span>=</span> <span>c</span> <span>-</span> <span>&#39;0&#39;</span><span>;</span>
                    <span>negative</span> <span>=</span> <span>false</span><span>;</span>
                <span>}</span> <span>else</span> <span>{</span>
                    <span>number</span> <span>=</span> <span>10</span><span>*</span><span>number</span> <span>+</span> <span>c</span> <span>-</span> <span>&#39;0&#39;</span><span>;</span>
                <span>}</span>
                <span>break</span><span>;</span>

            <span>case</span> <span>Separator</span><span>:</span>
                <span>if</span> <span>(</span><span>prev</span> <span>==</span> <span>Digit</span><span>)</span> <span>{</span>
                    <span>if</span> <span>(</span><span>negative</span><span>)</span> <span>{</span>
                        <span>*</span><span>output</span> <span>=</span> <span>-</span><span>number</span><span>;</span>
                    <span>}</span> <span>else</span> <span>{</span>
                        <span>*</span><span>output</span> <span>=</span> <span>number</span><span>;</span>
                    <span>}</span>
                <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>prev</span> <span>!=</span> <span>Separator</span><span>)</span> <span>{</span>
                    <span>throw</span> <span>std</span><span>::</span><span>runtime_error</span><span>(</span><span>&#34;Invalid syntax (&#39;-&#39; or &#39;+&#39; not followed by any digit)&#34;</span><span>);</span>
                <span>}</span>
                <span>break</span><span>;</span>
        <span>}</span> <span>// switch
</span>
        <span>prev</span> <span>=</span> <span>state</span><span>;</span>
    <span>}</span> <span>// for
</span>
    <span>if</span> <span>(</span><span>state</span> <span>==</span> <span>Separator</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>prev</span> <span>==</span> <span>Digit</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>negative</span><span>)</span> <span>{</span>
                <span>*</span><span>output</span> <span>=</span> <span>-</span><span>number</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>*</span><span>output</span> <span>=</span> <span>number</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>prev</span> <span>!=</span> <span>Separator</span><span>)</span> <span>{</span>
            <span>throw</span> <span>std</span><span>::</span><span>runtime_error</span><span>(</span><span>&#34;Invalid syntax (&#39;-&#39; or &#39;+&#39; not followed by any digit)&#34;</span><span>);</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</pre>
<p>And implementation based on standard functions:</p>
<pre><span>template</span> <span>&lt;</span><span>typename</span> <span>INSERTER</span><span>&gt;</span>
<span>void</span> <span>parse_signed</span><span>(</span><span>const</span> <span>char</span><span>*</span> <span>data</span><span>,</span> <span>size_t</span> <span>size</span><span>,</span> <span>const</span> <span>char</span><span>*</span> <span>separators</span><span>,</span> <span>INSERTER</span> <span>output</span><span>)</span> <span>{</span>

    <span>char</span><span>*</span> <span>ptr</span> <span>=</span> <span>const_cast</span><span>&lt;</span><span>char</span><span>*&gt;</span><span>(</span><span>data</span><span>);</span>
    <span>char</span><span>*</span> <span>end</span> <span>=</span> <span>ptr</span> <span>+</span> <span>size</span><span>;</span>

    <span>char</span><span>*</span> <span>endptr</span><span>;</span>
    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>ptr</span> <span>+=</span> <span>strspn</span><span>(</span><span>ptr</span><span>,</span> <span>separators</span><span>);</span>
        <span>if</span> <span>(</span><span>ptr</span> <span>==</span> <span>end</span><span>)</span> <span>{</span>
            <span>break</span><span>;</span>
        <span>}</span>

        <span>errno</span> <span>=</span> <span>0</span><span>;</span>
        <span>const</span> <span>long</span> <span>val</span> <span>=</span> <span>std</span><span>::</span><span>strtol</span><span>(</span><span>ptr</span><span>,</span> <span>&amp;</span><span>endptr</span><span>,</span> <span>10</span><span>);</span>

        <span>// the following check comes from &#34;man 3 strtol&#34;
</span>        <span>if</span> <span>((</span><span>errno</span> <span>==</span> <span>ERANGE</span> <span>&amp;&amp;</span> <span>(</span><span>val</span> <span>==</span> <span>LONG_MAX</span> <span>||</span> <span>val</span> <span>==</span> <span>LONG_MIN</span><span>))</span> <span>||</span> <span>(</span><span>errno</span> <span>!=</span> <span>0</span> <span>&amp;&amp;</span> <span>val</span> <span>==</span> <span>0</span><span>))</span> <span>{</span>
            <span>throw</span> <span>std</span><span>::</span><span>logic_error</span><span>(</span><span>&#34;invalid input&#34;</span><span>);</span>
        <span>}</span>

        <span>if</span> <span>(</span><span>endptr</span> <span>==</span> <span>ptr</span><span>)</span> <span>{</span>
            <span>throw</span> <span>std</span><span>::</span><span>logic_error</span><span>(</span><span>&#34;no digits&#34;</span><span>);</span>
        <span>}</span>

        <span>ptr</span> <span>=</span> <span>endptr</span><span>;</span>
        <span>*</span><span>output</span><span>++</span> <span>=</span> <span>val</span><span>;</span>
    <span>}</span>
<span>}</span>
</pre>
</div>
<div id="experiments">

<p>This part presents evaluation of algorithms in terms of running time
(performance tests) and also some statistical measurements that might
help in understanding run-time properties.</p>
<div id="id7">
<ul>
<li><a href="#id8" id="id79">11.1   SSE conversion — execution statistics</a><ul>
<li><a href="#overview" id="id80">11.1.1   Overview</a></li>
<li><a href="#sse-routines-calls" id="id81">11.1.2   SSE routines calls</a></li>
</ul>
</li>
<li><a href="#sse-conversion-runtime-analysis" id="id82">11.2   SSE conversion — runtime analysis</a><ul>
<li><a href="#input-size-4-096-bytes" id="id83">11.2.1   Input size 4,096 bytes</a></li>
<li><a href="#input-size-65-536-bytes" id="id84">11.2.2   Input size 65,536 bytes</a></li>
</ul>
</li>
<li><a href="#performance-comparison" id="id85">11.3   Performance comparison</a><ul>
<li><a href="#tested-procedures" id="id86">11.3.1   Tested procedures</a></li>
<li><a href="#tests-setup" id="id87">11.3.2   Tests setup</a></li>
<li><a href="#id12" id="id88">11.3.3   Core i7 results</a><ul>
<li><a href="#input-size-4096-bytes" id="id89">11.3.3.1   Input size 4096 bytes</a></li>
<li><a href="#input-size-65536-bytes" id="id90">11.3.3.2   Input size 65536 bytes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>Following parameters of the input data are being changed:</p>
<ul>
<li>Input size in bytes.</li>
<li>Distribution of number of digits:<ul>
<li>fixed size from 1 to 8 digits [only in overall performance tests];</li>
<li>uniform distribution over range 1 to k, where k = 1..8;</li>
<li>Gaussian distribution with mu = 1..8 (sigma = 1.0).</li>
</ul>
</li>
<li>Distribution of count of separators between numbers:<ul>
<li>exactly one separator character,</li>
<li>uniform distribution of 1 to 6 separators.</li>
</ul>
</li>
<li>Uniform distribution of the set: no-sign-char, &#39;+&#39; and &#39;-&#39;.</li>
</ul>
<div id="id8">
<h2><a href="#id47">11.1   SSE conversion — execution statistics</a></h2>
<p><a href="#caveats">Caveats</a> shows statistics of 1) average processed bytes and 2) SSE
utilization. This section presents real numbers gathered during
conversion of 1000000 bytes containing 1-8 digit signed numbers.</p>
<!-- ./bin/statistics - -size=1000000 - -num=1,1,1,1,1,1,1,1 - -sign=1,1,1 -->
<div id="overview">
<h3><a href="#id48">11.1.1   Overview</a></h3>
<table>
<colgroup>
<col width="69%"/>
<col width="16%"/>
<col width="16%"/>
</colgroup>
<tbody>
<tr><td>loops</td>
<td>90&#39;790</td>
<td> </td>
</tr>
<tr><td>... different span patterns</td>
<td>1&#39;315</td>
<td> </td>
</tr>
<tr><td>total numbers converted</td>
<td>162&#39;228</td>
<td>100.00%</td>
</tr>
<tr><td>conversion handled by scalar fallbacks</td>
<td>13&#39;601</td>
<td>8.38%</td>
</tr>
<tr><td>conversions done by SSE procedures</td>
<td>148&#39;627</td>
<td>91.62%</td>
</tr>
<tr><td>... unsigned SSE parser</td>
<td>6&#39;222</td>
<td rowspan="2">N/A</td>
</tr>
<tr><td>... signed SSE parser</td>
<td>142&#39;405</td>
</tr>
</tbody>
</table>
<p>As we see, most conversions were done by the SSE code; moreover, most
conversions went through the signed parser, which is slower than unsigned
counterpart.</p>
<p>Another important number, which may give a hint about possible cache misses
to the <tt>block_info</tt> structure, is the count of different span patterns.
It is 1315 (~2% of the whole table size, 65536), but only 120 of them were
processed in 75% iterations. The <a href="#sse-conversion-span-pattern-usage">next section</a>
shows this parameter in details.</p>
</div>
<div id="sse-routines-calls">
<h3><a href="#id49">11.1.2   SSE routines calls</a></h3>
<p>Below are detailed statistics for SSE routines:</p>
<ul>
<li>calls — how many times the procedure was called;</li>
<li>converted — how many numbers were parsed;</li>
<li>conv/call — average utilization.</li>
</ul>
<p>Conversions 1-/2-/4-/8-digits are described in section <a href="#sse-conversion-capabilites">SSE conversion
capabilities</a>, the 3-digit procedure in
<a href="#appendix-a-conversion-of-three-digit-numbers">Appendix A — conversion of three-digit numbers</a>.</p>
<table>
<colgroup>
<col width="24%"/>
<col width="13%"/>
<col width="13%"/>
<col width="13%"/>
<col width="13%"/>
<col width="13%"/>
<col width="13%"/>
</colgroup>
<thead>
<tr><th rowspan="2">procedure</th>
<th colspan="3">unsigned path</th>
<th colspan="3">signed path</th>
</tr>
<tr><th>calls</th>
<th>converted</th>
<th>conv/call</th>
<th>calls</th>
<th>converted</th>
<th>conv/call</th>
</tr>
</thead>
<tbody>
<tr><td>1-digit conversion</td>
<td>325</td>
<td>410</td>
<td>1.26</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr><td>2-digit conversion</td>
<td>21</td>
<td>48</td>
<td>2.29</td>
<td>1949</td>
<td>3521</td>
<td>1.81</td>
</tr>
<tr><td>3-digit conversion</td>
<td>21</td>
<td>43</td>
<td>2.05</td>
<td>1409</td>
<td>2246</td>
<td>1.59</td>
</tr>
<tr><td>4-digit conversion</td>
<td>239</td>
<td>581</td>
<td>2.43</td>
<td>10569</td>
<td>26255</td>
<td>2.48</td>
</tr>
<tr><td>8-digit conversion</td>
<td>2887</td>
<td>5140</td>
<td>1.78</td>
<td>59769</td>
<td>110383</td>
<td>1.85</td>
</tr>
</tbody>
</table>
<p>The table below shows how many bytes from the input vector were processed
in single iteration. It is pretty close to average numbers showed in <a href="#caveats">Caveats</a>.</p>
<table>
<colgroup>
<col width="35%"/>
<col width="20%"/>
<col width="16%"/>
<col width="29%"/>
</colgroup>
<thead>
<tr><th>bytes processed</th>
<th>patterns</th>
<th>%</th>
<th>cumulative %</th>
</tr>
</thead>
<tbody>
<tr><td>0</td>
<td>0</td>
<td>0.00%</td>
<td>0.00%</td>
</tr>
<tr><td>1</td>
<td>0</td>
<td>0.00%</td>
<td>0.00%</td>
</tr>
<tr><td>2</td>
<td>197</td>
<td>0.26%</td>
<td>0.26%</td>
</tr>
<tr><td>3</td>
<td>583</td>
<td>0.76%</td>
<td>1.01%</td>
</tr>
<tr><td>4</td>
<td>773</td>
<td>1.00%</td>
<td>2.01%</td>
</tr>
<tr><td>5</td>
<td>1137</td>
<td>1.47%</td>
<td>3.48%</td>
</tr>
<tr><td>6</td>
<td>1841</td>
<td>2.39%</td>
<td>5.87%</td>
</tr>
<tr><td>7</td>
<td>2544</td>
<td>3.30%</td>
<td>9.17%</td>
</tr>
<tr><td>8</td>
<td>5305</td>
<td>6.87%</td>
<td>16.04%</td>
</tr>
<tr><td>9</td>
<td>9135</td>
<td>11.83%</td>
<td>27.87%</td>
</tr>
<tr><td>10</td>
<td>7163</td>
<td>9.28%</td>
<td>37.15%</td>
</tr>
<tr><td>11</td>
<td>8834</td>
<td>11.44%</td>
<td>48.60%</td>
</tr>
<tr><td>12</td>
<td>10102</td>
<td>13.09%</td>
<td>61.68%</td>
</tr>
<tr><td>13</td>
<td>9342</td>
<td>12.10%</td>
<td>73.79%</td>
</tr>
<tr><td>14</td>
<td>8221</td>
<td>10.65%</td>
<td>84.44%</td>
</tr>
<tr><td>15</td>
<td>6743</td>
<td>8.74%</td>
<td>93.17%</td>
</tr>
<tr><td>16</td>
<td>5269</td>
<td>6.83%</td>
<td>100.00%</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="sse-conversion-runtime-analysis">
<h2><a href="#id50">11.2   SSE conversion — runtime analysis</a></h2>
<p>The lookup table is quite large: in the sample implementation single record
occupies 38 bytes, it gives almost 2,5 MiB. This section presents analysis of
<tt>span_pattern</tt> usage during conversion of various inputs. Following parameters
are collated:</p>
<ol>
<li>The number of <strong>different span patterns</strong> that appear during conversion.
This is explained in details below.</li>
<li>The number of <strong>CPU clocks per input byte</strong> (on Skylake); the results were
directly get from <a href="#performance-comparison">Performance comparison</a>.</li>
<li>Both <strong>cache miss</strong> and <strong>branch miss</strong> ratios (the same Skylake); these
results were obtained by running separate <tt><span>bin/benchmark-hwevents</span></tt> tool.
The ratios should give a hint about real-workload penalties.</li>
</ol>
<p>During a conversion a histogram is build. The histogram contains <tt>span_pattern</tt>
and the number of its occurrences; the histogram is sorted by the frequency.
Having such a sorted histogram it is easy to estimate how many <strong>distinct
patterns</strong> appear in most iterations.</p>
<p>Let&#39;s analyse sample, made up, histogram:</p>
<table>
<colgroup>
<col width="10%"/>
<col width="34%"/>
<col width="27%"/>
<col width="29%"/>
</colgroup>
<thead>
<tr><th>#</th>
<th>span pattern</th>
<th>frequency</th>
<th>cumulative</th>
</tr>
</thead>
<tbody>
<tr><td>1</td>
<td>0xaaaa</td>
<td>1</td>
<td>1</td>
</tr>
<tr><td>2</td>
<td>0xbbbb</td>
<td>1</td>
<td>2</td>
</tr>
<tr><td>3</td>
<td>0x4444</td>
<td>1</td>
<td>3</td>
</tr>
<tr><td>4</td>
<td>0xdddd</td>
<td>1</td>
<td>4</td>
</tr>
<tr><td>5</td>
<td>0xeeee</td>
<td>2</td>
<td>6</td>
</tr>
<tr><td>6</td>
<td>0xffff</td>
<td>2</td>
<td>8</td>
</tr>
<tr><td>7</td>
<td>0x1111</td>
<td>3</td>
<td>11</td>
</tr>
<tr><td>8</td>
<td>0x3333</td>
<td>5</td>
<td>16</td>
</tr>
<tr><td>9</td>
<td>0x5555</td>
<td>10</td>
<td>26</td>
</tr>
<tr><td>10</td>
<td>0x7777</td>
<td>17</td>
<td>43</td>
</tr>
</tbody>
</table>
<p>There are <strong>10</strong> different patterns that were used in <strong>43</strong> loops. We can read
from the table that in 1/4 of iterations (11 of 43) were used even seven
patterns. Most of processing uses just three patterns. It means that only a
small portion of the large lookup is actually touched.</p>
<p>The tables in following sections have got data processed in this way. Each column
contains number of distinct patterns that take part in given percentage of the
iterations (25%, 50%, 75%, 95% and all, 100%).</p>
<p>The results for various input sizes are available in the <a href="https://github.com/WojciechMula/parsing-int-series/tree/master/experiments/runtime-comparison/">repository</a>, below
are shown only 4kB and 64kB inputs.</p>
<div id="input-size-4-096-bytes">
<h3><a href="#id51">11.2.1   Input size 4,096 bytes</a></h3>
<table>
<colgroup>
<col width="31%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="4%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="10%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
</colgroup>
<thead>
<tr><th>parameters</th>
<th colspan="5">distinct span masks count</th>
<th colspan="2">cycles per byte</th>
<th colspan="3">branches</th>
<th colspan="3">cache references</th>
</tr>
<tr><th> </th>
<th>&lt; 25%</th>
<th>&lt; 50%</th>
<th>&lt; 75%</th>
<th>&lt; 95%</th>
<th>100%</th>
<th>min</th>
<th>avg</th>
<th>taken</th>
<th>mispredicted</th>
<th>ratio</th>
<th>count</th>
<th>missed</th>
<th>ratio</th>
</tr>
</thead>
<tbody>
<tr><td colspan="14">Fixed length</td>
</tr>
<tr><td>1 digit, single separator character</td>
<td>32</td>
<td>44</td>
<td>50</td>
<td>52</td>
<td>53</td>
<td>3.095</td>
<td>3.165</td>
<td>26085</td>
<td>633</td>
<td>2.43%</td>
<td>1531</td>
<td>415</td>
<td>27.11%</td>
</tr>
<tr><td>2 digits, single separator character</td>
<td>12</td>
<td>16</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>3.305</td>
<td>3.400</td>
<td>25270</td>
<td>485</td>
<td>1.92%</td>
<td>1333</td>
<td>114</td>
<td>8.55%</td>
</tr>
<tr><td>3 digits, single separator character</td>
<td>5</td>
<td>7</td>
<td>8</td>
<td>8</td>
<td>9</td>
<td>2.533</td>
<td>2.584</td>
<td>21809</td>
<td>247</td>
<td>1.13%</td>
<td>954</td>
<td>63</td>
<td>6.60%</td>
</tr>
<tr><td>4 digits, single separator character</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>6</td>
<td>7</td>
<td>3.193</td>
<td>3.231</td>
<td>24145</td>
<td>336</td>
<td>1.39%</td>
<td>926</td>
<td>49</td>
<td>5.29%</td>
</tr>
<tr><td>5 digits, single separator character</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>2.648</td>
<td>2.680</td>
<td>20788</td>
<td>241</td>
<td>1.16%</td>
<td>1067</td>
<td>24</td>
<td>2.25%</td>
</tr>
<tr><td>6 digits, single separator character</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>2.312</td>
<td>2.347</td>
<td>18289</td>
<td>233</td>
<td>1.27%</td>
<td>915</td>
<td>19</td>
<td>2.08%</td>
</tr>
<tr><td>7 digits, single separator character</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4.121</td>
<td>4.167</td>
<td>25682</td>
<td>313</td>
<td>1.22%</td>
<td>780</td>
<td>6</td>
<td>0.77%</td>
</tr>
<tr><td>8 digits, single separator character</td>
<td>1</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>5.495</td>
<td>5.592</td>
<td>44188</td>
<td>837</td>
<td>1.89%</td>
<td>836</td>
<td>25</td>
<td>2.99%</td>
</tr>
<tr><td colspan="14">Uniform distribution</td>
</tr>
<tr><td>1 .. 1 digit, single separator character</td>
<td>42</td>
<td>54</td>
<td>60</td>
<td>62</td>
<td>63</td>
<td>3.162</td>
<td>3.288</td>
<td>25992</td>
<td>619</td>
<td>2.38%</td>
<td>1618</td>
<td>334</td>
<td>20.64%</td>
</tr>
<tr><td>1 .. 2 digits, single separator character</td>
<td>71</td>
<td>102</td>
<td>118</td>
<td>126</td>
<td>128</td>
<td>3.201</td>
<td>3.268</td>
<td>26561</td>
<td>465</td>
<td>1.75%</td>
<td>2118</td>
<td>655</td>
<td>30.93%</td>
</tr>
<tr><td>1 .. 3 digits, single separator character</td>
<td>72</td>
<td>112</td>
<td>134</td>
<td>146</td>
<td>148</td>
<td>2.891</td>
<td>2.941</td>
<td>24393</td>
<td>514</td>
<td>2.11%</td>
<td>2522</td>
<td>663</td>
<td>26.29%</td>
</tr>
<tr><td>1 .. 4 digits, single separator character</td>
<td>87</td>
<td>135</td>
<td>159</td>
<td>170</td>
<td>172</td>
<td>3.398</td>
<td>3.463</td>
<td>25831</td>
<td>906</td>
<td>3.51%</td>
<td>2480</td>
<td>667</td>
<td>26.90%</td>
</tr>
<tr><td>1 .. 5 digits, single separator character</td>
<td>92</td>
<td>136</td>
<td>163</td>
<td>177</td>
<td>179</td>
<td>3.495</td>
<td>3.553</td>
<td>25865</td>
<td>806</td>
<td>3.12%</td>
<td>2509</td>
<td>548</td>
<td>21.84%</td>
</tr>
<tr><td>1 .. 6 digits, single separator character</td>
<td>90</td>
<td>144</td>
<td>168</td>
<td>178</td>
<td>180</td>
<td>3.494</td>
<td>3.557</td>
<td>24943</td>
<td>639</td>
<td>2.56%</td>
<td>2591</td>
<td>627</td>
<td>24.20%</td>
</tr>
<tr><td>1 .. 7 digits, single separator character</td>
<td>86</td>
<td>125</td>
<td>143</td>
<td>151</td>
<td>153</td>
<td>3.259</td>
<td>3.324</td>
<td>23730</td>
<td>579</td>
<td>2.44%</td>
<td>2137</td>
<td>476</td>
<td>22.27%</td>
</tr>
<tr><td>1 .. 8 digits, single separator character</td>
<td>95</td>
<td>135</td>
<td>157</td>
<td>166</td>
<td>167</td>
<td>3.828</td>
<td>3.894</td>
<td>28964</td>
<td>859</td>
<td>2.97%</td>
<td>2074</td>
<td>318</td>
<td>15.33%</td>
</tr>
<tr><td colspan="14">Gaussian distribution</td>
</tr>
<tr><td>max at 1 digit, single separator character</td>
<td>76</td>
<td>133</td>
<td>161</td>
<td>174</td>
<td>176</td>
<td>3.218</td>
<td>3.264</td>
<td>25990</td>
<td>485</td>
<td>1.87%</td>
<td>2658</td>
<td>799</td>
<td>30.06%</td>
</tr>
<tr><td>max at 2 digit, single separator character</td>
<td>77</td>
<td>129</td>
<td>157</td>
<td>170</td>
<td>173</td>
<td>3.122</td>
<td>3.189</td>
<td>24951</td>
<td>686</td>
<td>2.75%</td>
<td>2803</td>
<td>455</td>
<td>16.23%</td>
</tr>
<tr><td>max at 3 digit, single separator character</td>
<td>76</td>
<td>103</td>
<td>115</td>
<td>120</td>
<td>122</td>
<td>3.192</td>
<td>3.246</td>
<td>24812</td>
<td>799</td>
<td>3.22%</td>
<td>3038</td>
<td>256</td>
<td>8.43%</td>
</tr>
<tr><td>max at 4 digit, single separator character</td>
<td>43</td>
<td>57</td>
<td>63</td>
<td>65</td>
<td>66</td>
<td>3.134</td>
<td>3.215</td>
<td>23754</td>
<td>414</td>
<td>1.74%</td>
<td>1650</td>
<td>106</td>
<td>6.42%</td>
</tr>
<tr><td>max at 5 digit, single separator character</td>
<td>32</td>
<td>38</td>
<td>41</td>
<td>43</td>
<td>44</td>
<td>2.822</td>
<td>2.875</td>
<td>21380</td>
<td>346</td>
<td>1.62%</td>
<td>1320</td>
<td>93</td>
<td>7.05%</td>
</tr>
<tr><td>max at 6 digit, single separator character</td>
<td>25</td>
<td>30</td>
<td>33</td>
<td>34</td>
<td>35</td>
<td>2.887</td>
<td>2.935</td>
<td>21765</td>
<td>496</td>
<td>2.28%</td>
<td>1223</td>
<td>79</td>
<td>6.46%</td>
</tr>
<tr><td>max at 7 digit, single separator character</td>
<td>20</td>
<td>22</td>
<td>24</td>
<td>24</td>
<td>25</td>
<td>3.921</td>
<td>3.983</td>
<td>29234</td>
<td>794</td>
<td>2.72%</td>
<td>1096</td>
<td>40</td>
<td>3.65%</td>
</tr>
<tr><td>max at 8 digit, single separator character</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>4.825</td>
<td>4.887</td>
<td>37274</td>
<td>1015</td>
<td>2.72%</td>
<td>944</td>
<td>44</td>
<td>4.66%</td>
</tr>
<tr><td colspan="14">Fixed length</td>
</tr>
<tr><td>1 digit, 1 .. 6 separator characters</td>
<td>65</td>
<td>131</td>
<td>197</td>
<td>223</td>
<td>227</td>
<td>3.331</td>
<td>3.404</td>
<td>18979</td>
<td>677</td>
<td>3.57%</td>
<td>3111</td>
<td>1581</td>
<td>50.82%</td>
</tr>
<tr><td>2 digits, 1 .. 6 separator characters</td>
<td>67</td>
<td>135</td>
<td>175</td>
<td>195</td>
<td>198</td>
<td>3.473</td>
<td>3.529</td>
<td>20588</td>
<td>799</td>
<td>3.88%</td>
<td>2858</td>
<td>1287</td>
<td>45.03%</td>
</tr>
<tr><td>3 digits, 1 .. 6 separator characters</td>
<td>68</td>
<td>119</td>
<td>147</td>
<td>157</td>
<td>158</td>
<td>2.747</td>
<td>2.806</td>
<td>18629</td>
<td>481</td>
<td>2.58%</td>
<td>2728</td>
<td>1150</td>
<td>42.16%</td>
</tr>
<tr><td>4 digits, 1 .. 6 separator characters</td>
<td>69</td>
<td>101</td>
<td>118</td>
<td>124</td>
<td>125</td>
<td>2.641</td>
<td>2.695</td>
<td>18672</td>
<td>488</td>
<td>2.61%</td>
<td>1919</td>
<td>613</td>
<td>31.94%</td>
</tr>
<tr><td>5 digits, 1 .. 6 separator characters</td>
<td>53</td>
<td>71</td>
<td>78</td>
<td>81</td>
<td>82</td>
<td>2.748</td>
<td>2.824</td>
<td>19009</td>
<td>530</td>
<td>2.79%</td>
<td>1638</td>
<td>372</td>
<td>22.71%</td>
</tr>
<tr><td>6 digits, 1 .. 6 separator characters</td>
<td>43</td>
<td>50</td>
<td>53</td>
<td>55</td>
<td>56</td>
<td>2.958</td>
<td>3.002</td>
<td>19989</td>
<td>450</td>
<td>2.25%</td>
<td>1304</td>
<td>208</td>
<td>15.95%</td>
</tr>
<tr><td>7 digits, 1 .. 6 separator characters</td>
<td>12</td>
<td>14</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>3.316</td>
<td>3.341</td>
<td>20881</td>
<td>300</td>
<td>1.44%</td>
<td>1058</td>
<td>52</td>
<td>4.91%</td>
</tr>
<tr><td>8 digits, 1 .. 6 separator characters</td>
<td>33</td>
<td>46</td>
<td>54</td>
<td>57</td>
<td>58</td>
<td>4.302</td>
<td>4.346</td>
<td>34811</td>
<td>728</td>
<td>2.09%</td>
<td>1377</td>
<td>206</td>
<td>14.96%</td>
</tr>
<tr><td colspan="14">Uniform distribution</td>
</tr>
<tr><td>1 .. 1 digit, 1 .. 6 separator characters</td>
<td>66</td>
<td>132</td>
<td>198</td>
<td>232</td>
<td>237</td>
<td>3.197</td>
<td>3.268</td>
<td>19319</td>
<td>685</td>
<td>3.55%</td>
<td>2972</td>
<td>1273</td>
<td>42.83%</td>
</tr>
<tr><td>1 .. 2 digits, 1 .. 6 separator characters</td>
<td>66</td>
<td>132</td>
<td>198</td>
<td>238</td>
<td>243</td>
<td>3.025</td>
<td>3.081</td>
<td>19752</td>
<td>842</td>
<td>4.26%</td>
<td>3186</td>
<td>1247</td>
<td>39.14%</td>
</tr>
<tr><td>1 .. 3 digits, 1 .. 6 separator characters</td>
<td>67</td>
<td>135</td>
<td>203</td>
<td>233</td>
<td>238</td>
<td>3.070</td>
<td>3.150</td>
<td>19453</td>
<td>743</td>
<td>3.82%</td>
<td>3357</td>
<td>1216</td>
<td>36.22%</td>
</tr>
<tr><td>1 .. 4 digits, 1 .. 6 separator characters</td>
<td>70</td>
<td>140</td>
<td>210</td>
<td>250</td>
<td>256</td>
<td>3.390</td>
<td>3.477</td>
<td>19640</td>
<td>897</td>
<td>4.57%</td>
<td>3586</td>
<td>1226</td>
<td>34.19%</td>
</tr>
<tr><td>1 .. 5 digits, 1 .. 6 separator characters</td>
<td>71</td>
<td>142</td>
<td>213</td>
<td>242</td>
<td>247</td>
<td>3.338</td>
<td>3.401</td>
<td>19580</td>
<td>823</td>
<td>4.20%</td>
<td>3170</td>
<td>940</td>
<td>29.65%</td>
</tr>
<tr><td>1 .. 6 digits, 1 .. 6 separator characters</td>
<td>71</td>
<td>143</td>
<td>207</td>
<td>233</td>
<td>237</td>
<td>3.288</td>
<td>3.375</td>
<td>19457</td>
<td>785</td>
<td>4.03%</td>
<td>2916</td>
<td>807</td>
<td>27.67%</td>
</tr>
<tr><td>1 .. 7 digits, 1 .. 6 separator characters</td>
<td>74</td>
<td>148</td>
<td>208</td>
<td>228</td>
<td>230</td>
<td>3.304</td>
<td>3.375</td>
<td>19268</td>
<td>761</td>
<td>3.95%</td>
<td>2985</td>
<td>904</td>
<td>30.28%</td>
</tr>
<tr><td>1 .. 8 digits, 1 .. 6 separator characters</td>
<td>79</td>
<td>159</td>
<td>209</td>
<td>227</td>
<td>230</td>
<td>3.692</td>
<td>3.766</td>
<td>23045</td>
<td>881</td>
<td>3.82%</td>
<td>2946</td>
<td>727</td>
<td>24.68%</td>
</tr>
<tr><td colspan="14">Gaussian distribution</td>
</tr>
<tr><td>max at 1 digit, 1 .. 6 separator characters</td>
<td>66</td>
<td>133</td>
<td>200</td>
<td>244</td>
<td>249</td>
<td>3.154</td>
<td>3.216</td>
<td>19347</td>
<td>900</td>
<td>4.65%</td>
<td>3515</td>
<td>1060</td>
<td>30.16%</td>
</tr>
<tr><td>max at 2 digit, 1 .. 6 separator characters</td>
<td>67</td>
<td>135</td>
<td>203</td>
<td>241</td>
<td>246</td>
<td>3.155</td>
<td>3.229</td>
<td>19299</td>
<td>786</td>
<td>4.07%</td>
<td>3340</td>
<td>892</td>
<td>26.71%</td>
</tr>
<tr><td>max at 3 digit, 1 .. 6 separator characters</td>
<td>69</td>
<td>139</td>
<td>205</td>
<td>229</td>
<td>233</td>
<td>3.202</td>
<td>3.278</td>
<td>19382</td>
<td>804</td>
<td>4.15%</td>
<td>3188</td>
<td>661</td>
<td>20.73%</td>
</tr>
<tr><td>max at 4 digit, 1 .. 6 separator characters</td>
<td>70</td>
<td>141</td>
<td>180</td>
<td>198</td>
<td>201</td>
<td>2.914</td>
<td>2.978</td>
<td>18669</td>
<td>611</td>
<td>3.27%</td>
<td>2775</td>
<td>692</td>
<td>24.94%</td>
</tr>
<tr><td>max at 5 digit, 1 .. 6 separator characters</td>
<td>74</td>
<td>131</td>
<td>156</td>
<td>164</td>
<td>166</td>
<td>3.147</td>
<td>3.217</td>
<td>19276</td>
<td>586</td>
<td>3.04%</td>
<td>2291</td>
<td>552</td>
<td>24.09%</td>
</tr>
<tr><td>max at 6 digit, 1 .. 6 separator characters</td>
<td>70</td>
<td>93</td>
<td>101</td>
<td>105</td>
<td>106</td>
<td>3.196</td>
<td>3.257</td>
<td>20806</td>
<td>493</td>
<td>2.37%</td>
<td>1719</td>
<td>237</td>
<td>13.79%</td>
</tr>
<tr><td>max at 7 digit, 1 .. 6 separator characters</td>
<td>64</td>
<td>80</td>
<td>87</td>
<td>91</td>
<td>92</td>
<td>3.597</td>
<td>3.646</td>
<td>24974</td>
<td>622</td>
<td>2.49%</td>
<td>1599</td>
<td>251</td>
<td>15.70%</td>
</tr>
<tr><td>max at 8 digit, 1 .. 6 separator characters</td>
<td>56</td>
<td>74</td>
<td>82</td>
<td>87</td>
<td>88</td>
<td>3.994</td>
<td>4.055</td>
<td>29874</td>
<td>848</td>
<td>2.84%</td>
<td>1587</td>
<td>231</td>
<td>14.56%</td>
</tr>
</tbody>
</table>
</div>
<div id="input-size-65-536-bytes">
<h3><a href="#id52">11.2.2   Input size 65,536 bytes</a></h3>
<table>
<colgroup>
<col width="31%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="4%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="10%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
</colgroup>
<thead>
<tr><th>parameters</th>
<th colspan="5">distinct span masks count</th>
<th colspan="2">cycles per byte</th>
<th colspan="3">branches</th>
<th colspan="3">cache references</th>
</tr>
<tr><th> </th>
<th>&lt; 25%</th>
<th>&lt; 50%</th>
<th>&lt; 75%</th>
<th>&lt; 95%</th>
<th>100%</th>
<th>min</th>
<th>avg</th>
<th>taken</th>
<th>mispredicted</th>
<th>ratio</th>
<th>count</th>
<th>missed</th>
<th>ratio</th>
</tr>
</thead>
<tbody>
<tr><td colspan="14">Fixed length</td>
</tr>
<tr><td>1 digit, single separator character</td>
<td>61</td>
<td>74</td>
<td>81</td>
<td>84</td>
<td>85</td>
<td>3.619</td>
<td>3.655</td>
<td>393175</td>
<td>6529</td>
<td>1.66%</td>
<td>13469</td>
<td>974</td>
<td>7.23%</td>
</tr>
<tr><td>2 digits, single separator character</td>
<td>13</td>
<td>17</td>
<td>20</td>
<td>21</td>
<td>22</td>
<td>3.727</td>
<td>3.754</td>
<td>374164</td>
<td>3451</td>
<td>0.92%</td>
<td>11212</td>
<td>286</td>
<td>2.55%</td>
</tr>
<tr><td>3 digits, single separator character</td>
<td>4</td>
<td>6</td>
<td>8</td>
<td>8</td>
<td>9</td>
<td>2.839</td>
<td>2.852</td>
<td>328065</td>
<td>829</td>
<td>0.25%</td>
<td>7539</td>
<td>101</td>
<td>1.34%</td>
</tr>
<tr><td>4 digits, single separator character</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>6</td>
<td>7</td>
<td>3.495</td>
<td>3.507</td>
<td>361605</td>
<td>2429</td>
<td>0.67%</td>
<td>7148</td>
<td>89</td>
<td>1.25%</td>
</tr>
<tr><td>5 digits, single separator character</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>2.921</td>
<td>2.935</td>
<td>313419</td>
<td>849</td>
<td>0.27%</td>
<td>7335</td>
<td>119</td>
<td>1.62%</td>
</tr>
<tr><td>6 digits, single separator character</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>2.545</td>
<td>2.555</td>
<td>272684</td>
<td>741</td>
<td>0.27%</td>
<td>8704</td>
<td>58</td>
<td>0.67%</td>
</tr>
<tr><td>7 digits, single separator character</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4.407</td>
<td>4.417</td>
<td>386099</td>
<td>2206</td>
<td>0.57%</td>
<td>5224</td>
<td>27</td>
<td>0.52%</td>
</tr>
<tr><td>8 digits, single separator character</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>7.094</td>
<td>7.135</td>
<td>666950</td>
<td>13453</td>
<td>2.02%</td>
<td>5192</td>
<td>75</td>
<td>1.44%</td>
</tr>
<tr><td colspan="14">Uniform distribution</td>
</tr>
<tr><td>1 .. 1 digit, single separator character</td>
<td>59</td>
<td>72</td>
<td>80</td>
<td>82</td>
<td>83</td>
<td>3.627</td>
<td>3.693</td>
<td>393231</td>
<td>6582</td>
<td>1.67%</td>
<td>14582</td>
<td>973</td>
<td>6.67%</td>
</tr>
<tr><td>1 .. 2 digits, single separator character</td>
<td>236</td>
<td>280</td>
<td>299</td>
<td>308</td>
<td>310</td>
<td>3.908</td>
<td>3.935</td>
<td>397134</td>
<td>5214</td>
<td>1.31%</td>
<td>19011</td>
<td>2176</td>
<td>11.45%</td>
</tr>
<tr><td>1 .. 3 digits, single separator character</td>
<td>355</td>
<td>420</td>
<td>450</td>
<td>466</td>
<td>469</td>
<td>3.565</td>
<td>3.590</td>
<td>361819</td>
<td>4669</td>
<td>1.29%</td>
<td>21347</td>
<td>1858</td>
<td>8.70%</td>
</tr>
<tr><td>1 .. 4 digits, single separator character</td>
<td>416</td>
<td>493</td>
<td>523</td>
<td>537</td>
<td>540</td>
<td>5.329</td>
<td>5.387</td>
<td>391117</td>
<td>12854</td>
<td>3.29%</td>
<td>24169</td>
<td>1621</td>
<td>6.71%</td>
</tr>
<tr><td>1 .. 5 digits, single separator character</td>
<td>444</td>
<td>510</td>
<td>543</td>
<td>556</td>
<td>558</td>
<td>5.270</td>
<td>5.328</td>
<td>390345</td>
<td>11393</td>
<td>2.92%</td>
<td>19020</td>
<td>1568</td>
<td>8.24%</td>
</tr>
<tr><td>1 .. 6 digits, single separator character</td>
<td>423</td>
<td>492</td>
<td>525</td>
<td>535</td>
<td>537</td>
<td>4.589</td>
<td>4.633</td>
<td>372174</td>
<td>7872</td>
<td>2.12%</td>
<td>19917</td>
<td>1282</td>
<td>6.44%</td>
</tr>
<tr><td>1 .. 7 digits, single separator character</td>
<td>392</td>
<td>462</td>
<td>481</td>
<td>491</td>
<td>493</td>
<td>4.174</td>
<td>4.218</td>
<td>355907</td>
<td>6263</td>
<td>1.76%</td>
<td>15979</td>
<td>949</td>
<td>5.94%</td>
</tr>
<tr><td>1 .. 8 digits, single separator character</td>
<td>519</td>
<td>598</td>
<td>620</td>
<td>630</td>
<td>631</td>
<td>5.217</td>
<td>5.273</td>
<td>423108</td>
<td>11289</td>
<td>2.67%</td>
<td>16635</td>
<td>695</td>
<td>4.18%</td>
</tr>
<tr><td colspan="14">Gaussian distribution</td>
</tr>
<tr><td>max at 1 digit, single separator character</td>
<td>481</td>
<td>587</td>
<td>630</td>
<td>645</td>
<td>648</td>
<td>4.150</td>
<td>4.189</td>
<td>395482</td>
<td>6382</td>
<td>1.61%</td>
<td>25467</td>
<td>1620</td>
<td>6.36%</td>
</tr>
<tr><td>max at 2 digit, single separator character</td>
<td>454</td>
<td>534</td>
<td>570</td>
<td>586</td>
<td>589</td>
<td>4.104</td>
<td>4.143</td>
<td>371930</td>
<td>6882</td>
<td>1.85%</td>
<td>25775</td>
<td>739</td>
<td>2.87%</td>
</tr>
<tr><td>max at 3 digit, single separator character</td>
<td>300</td>
<td>330</td>
<td>344</td>
<td>350</td>
<td>352</td>
<td>4.990</td>
<td>5.050</td>
<td>375961</td>
<td>11571</td>
<td>3.08%</td>
<td>15877</td>
<td>351</td>
<td>2.21%</td>
</tr>
<tr><td>max at 4 digit, single separator character</td>
<td>132</td>
<td>147</td>
<td>153</td>
<td>155</td>
<td>156</td>
<td>3.760</td>
<td>3.814</td>
<td>356129</td>
<td>4522</td>
<td>1.27%</td>
<td>10634</td>
<td>220</td>
<td>2.07%</td>
</tr>
<tr><td>max at 5 digit, single separator character</td>
<td>84</td>
<td>90</td>
<td>93</td>
<td>95</td>
<td>96</td>
<td>3.031</td>
<td>3.045</td>
<td>318232</td>
<td>1548</td>
<td>0.49%</td>
<td>8123</td>
<td>177</td>
<td>2.18%</td>
</tr>
<tr><td>max at 6 digit, single separator character</td>
<td>54</td>
<td>59</td>
<td>62</td>
<td>64</td>
<td>65</td>
<td>3.479</td>
<td>3.499</td>
<td>328097</td>
<td>6041</td>
<td>1.84%</td>
<td>8491</td>
<td>366</td>
<td>4.31%</td>
</tr>
<tr><td>max at 7 digit, single separator character</td>
<td>36</td>
<td>39</td>
<td>41</td>
<td>41</td>
<td>42</td>
<td>5.520</td>
<td>5.560</td>
<td>444157</td>
<td>11932</td>
<td>2.69%</td>
<td>5814</td>
<td>124</td>
<td>2.13%</td>
</tr>
<tr><td>max at 8 digit, single separator character</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>6.897</td>
<td>6.946</td>
<td>562307</td>
<td>15610</td>
<td>2.78%</td>
<td>5449</td>
<td>120</td>
<td>2.20%</td>
</tr>
<tr><td colspan="14">Fixed length</td>
</tr>
<tr><td>1 digit, 1 .. 6 separator characters</td>
<td>1052</td>
<td>1626</td>
<td>1870</td>
<td>1950</td>
<td>1958</td>
<td>4.371</td>
<td>4.408</td>
<td>280108</td>
<td>7580</td>
<td>2.71%</td>
<td>34860</td>
<td>8289</td>
<td>23.78%</td>
</tr>
<tr><td>2 digits, 1 .. 6 separator characters</td>
<td>693</td>
<td>909</td>
<td>995</td>
<td>1026</td>
<td>1029</td>
<td>5.044</td>
<td>5.108</td>
<td>308039</td>
<td>12071</td>
<td>3.92%</td>
<td>26297</td>
<td>4481</td>
<td>17.04%</td>
</tr>
<tr><td>3 digits, 1 .. 6 separator characters</td>
<td>354</td>
<td>438</td>
<td>480</td>
<td>494</td>
<td>496</td>
<td>3.334</td>
<td>3.358</td>
<td>273155</td>
<td>3865</td>
<td>1.41%</td>
<td>17568</td>
<td>2647</td>
<td>15.07%</td>
</tr>
<tr><td>4 digits, 1 .. 6 separator characters</td>
<td>177</td>
<td>224</td>
<td>246</td>
<td>252</td>
<td>254</td>
<td>3.311</td>
<td>3.335</td>
<td>277306</td>
<td>4944</td>
<td>1.78%</td>
<td>10967</td>
<td>1361</td>
<td>12.41%</td>
</tr>
<tr><td>5 digits, 1 .. 6 separator characters</td>
<td>100</td>
<td>126</td>
<td>134</td>
<td>137</td>
<td>138</td>
<td>3.648</td>
<td>3.677</td>
<td>284172</td>
<td>7099</td>
<td>2.50%</td>
<td>7727</td>
<td>742</td>
<td>9.60%</td>
</tr>
<tr><td>6 digits, 1 .. 6 separator characters</td>
<td>69</td>
<td>77</td>
<td>80</td>
<td>82</td>
<td>83</td>
<td>3.675</td>
<td>3.703</td>
<td>297939</td>
<td>5210</td>
<td>1.75%</td>
<td>6470</td>
<td>402</td>
<td>6.21%</td>
</tr>
<tr><td>7 digits, 1 .. 6 separator characters</td>
<td>46</td>
<td>49</td>
<td>51</td>
<td>53</td>
<td>54</td>
<td>3.662</td>
<td>3.673</td>
<td>315611</td>
<td>2311</td>
<td>0.73%</td>
<td>6077</td>
<td>308</td>
<td>5.07%</td>
</tr>
<tr><td>8 digits, 1 .. 6 separator characters</td>
<td>30</td>
<td>45</td>
<td>54</td>
<td>58</td>
<td>59</td>
<td>5.735</td>
<td>5.782</td>
<td>532039</td>
<td>10908</td>
<td>2.05%</td>
<td>6292</td>
<td>438</td>
<td>6.96%</td>
</tr>
<tr><td colspan="14">Uniform distribution</td>
</tr>
<tr><td>1 .. 1 digit, 1 .. 6 separator characters</td>
<td>1053</td>
<td>1643</td>
<td>1896</td>
<td>1973</td>
<td>1981</td>
<td>4.364</td>
<td>4.396</td>
<td>279251</td>
<td>7676</td>
<td>2.75%</td>
<td>34478</td>
<td>6144</td>
<td>17.82%</td>
</tr>
<tr><td>1 .. 2 digits, 1 .. 6 separator characters</td>
<td>1066</td>
<td>1792</td>
<td>2104</td>
<td>2212</td>
<td>2221</td>
<td>5.090</td>
<td>5.154</td>
<td>288339</td>
<td>12133</td>
<td>4.21%</td>
<td>39995</td>
<td>5781</td>
<td>14.45%</td>
</tr>
<tr><td>1 .. 3 digits, 1 .. 6 separator characters</td>
<td>1084</td>
<td>1802</td>
<td>2120</td>
<td>2226</td>
<td>2236</td>
<td>4.974</td>
<td>5.031</td>
<td>286026</td>
<td>10029</td>
<td>3.51%</td>
<td>44877</td>
<td>5187</td>
<td>11.56%</td>
</tr>
<tr><td>1 .. 4 digits, 1 .. 6 separator characters</td>
<td>1120</td>
<td>1808</td>
<td>2084</td>
<td>2173</td>
<td>2182</td>
<td>5.332</td>
<td>5.395</td>
<td>287345</td>
<td>11700</td>
<td>4.07%</td>
<td>42918</td>
<td>3871</td>
<td>9.02%</td>
</tr>
<tr><td>1 .. 5 digits, 1 .. 6 separator characters</td>
<td>1141</td>
<td>1713</td>
<td>1959</td>
<td>2031</td>
<td>2039</td>
<td>5.078</td>
<td>5.153</td>
<td>287785</td>
<td>10589</td>
<td>3.68%</td>
<td>40253</td>
<td>2950</td>
<td>7.33%</td>
</tr>
<tr><td>1 .. 6 digits, 1 .. 6 separator characters</td>
<td>1142</td>
<td>1617</td>
<td>1803</td>
<td>1856</td>
<td>1860</td>
<td>4.888</td>
<td>4.960</td>
<td>286913</td>
<td>10124</td>
<td>3.53%</td>
<td>35625</td>
<td>2229</td>
<td>6.26%</td>
</tr>
<tr><td>1 .. 7 digits, 1 .. 6 separator characters</td>
<td>1091</td>
<td>1503</td>
<td>1646</td>
<td>1678</td>
<td>1681</td>
<td>4.970</td>
<td>5.033</td>
<td>287420</td>
<td>11059</td>
<td>3.85%</td>
<td>30932</td>
<td>3218</td>
<td>10.40%</td>
</tr>
<tr><td>1 .. 8 digits, 1 .. 6 separator characters</td>
<td>1109</td>
<td>1476</td>
<td>1598</td>
<td>1619</td>
<td>1622</td>
<td>5.650</td>
<td>5.711</td>
<td>339596</td>
<td>14223</td>
<td>4.19%</td>
<td>28870</td>
<td>2243</td>
<td>7.77%</td>
</tr>
<tr><td colspan="14">Gaussian distribution</td>
</tr>
<tr><td>max at 1 digit, 1 .. 6 separator characters</td>
<td>1070</td>
<td>1975</td>
<td>2405</td>
<td>2551</td>
<td>2565</td>
<td>5.389</td>
<td>5.456</td>
<td>285670</td>
<td>12734</td>
<td>4.46%</td>
<td>46840</td>
<td>6140</td>
<td>13.11%</td>
</tr>
<tr><td>max at 2 digit, 1 .. 6 separator characters</td>
<td>1094</td>
<td>1862</td>
<td>2174</td>
<td>2283</td>
<td>2293</td>
<td>5.125</td>
<td>5.177</td>
<td>288202</td>
<td>10818</td>
<td>3.75%</td>
<td>43779</td>
<td>3228</td>
<td>7.37%</td>
</tr>
<tr><td>max at 3 digit, 1 .. 6 separator characters</td>
<td>1021</td>
<td>1440</td>
<td>1610</td>
<td>1666</td>
<td>1672</td>
<td>4.927</td>
<td>4.986</td>
<td>284545</td>
<td>10542</td>
<td>3.70%</td>
<td>34647</td>
<td>1690</td>
<td>4.88%</td>
</tr>
<tr><td>max at 4 digit, 1 .. 6 separator characters</td>
<td>715</td>
<td>905</td>
<td>985</td>
<td>1010</td>
<td>1013</td>
<td>4.072</td>
<td>4.129</td>
<td>280545</td>
<td>8310</td>
<td>2.96%</td>
<td>20920</td>
<td>931</td>
<td>4.45%</td>
</tr>
<tr><td>max at 5 digit, 1 .. 6 separator characters</td>
<td>445</td>
<td>534</td>
<td>567</td>
<td>575</td>
<td>577</td>
<td>4.127</td>
<td>4.167</td>
<td>286377</td>
<td>8569</td>
<td>2.99%</td>
<td>14319</td>
<td>651</td>
<td>4.55%</td>
</tr>
<tr><td>max at 6 digit, 1 .. 6 separator characters</td>
<td>296</td>
<td>336</td>
<td>346</td>
<td>351</td>
<td>352</td>
<td>4.025</td>
<td>4.054</td>
<td>312734</td>
<td>6394</td>
<td>2.04%</td>
<td>11762</td>
<td>402</td>
<td>3.42%</td>
</tr>
<tr><td>max at 7 digit, 1 .. 6 separator characters</td>
<td>185</td>
<td>207</td>
<td>214</td>
<td>219</td>
<td>220</td>
<td>4.481</td>
<td>4.520</td>
<td>376654</td>
<td>8042</td>
<td>2.14%</td>
<td>7924</td>
<td>452</td>
<td>5.70%</td>
</tr>
<tr><td>max at 8 digit, 1 .. 6 separator characters</td>
<td>110</td>
<td>133</td>
<td>141</td>
<td>146</td>
<td>148</td>
<td>5.532</td>
<td>5.576</td>
<td>448317</td>
<td>12621</td>
<td>2.82%</td>
<td>7779</td>
<td>821</td>
<td>10.55%</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="performance-comparison">
<h2><a href="#id53">11.3   Performance comparison</a></h2>
<div id="tested-procedures">
<h3><a href="#id54">11.3.1   Tested procedures</a></h3>
<p>Following procedures are tested:</p>
<ul>
<li><tt>scalar</tt> — the hand-coded validating <a href="#reference-implementation">scalar parser</a>;</li>
<li><tt>scalar (std)</tt> — also the <a href="#reference-implementation">hand-coded parser</a>,
but use only standard functions <tt>strtol</tt> and <tt>strspn</tt>;</li>
<li><tt>scalar hybrid</tt> — the implementation of <a href="#scalar-hybrid">Scalar hybrid</a>;</li>
<li><tt>SSE</tt> — the implementation of the base SSE algorithm;</li>
<li><tt>SSE (block)</tt> — the implementation of variant described in <a href="#processing-larger-inputs">Processing
larger inputs</a></li>
<li><tt>SSE (simplified)</tt> — the SSE variant with relaxed delimiters definition.</li>
</ul>
</div>
<div id="tests-setup">
<h3><a href="#id55">11.3.2   Tests setup</a></h3>
<p>There are two tests approaches:</p>
<ul>
<li><p><strong>Overall</strong>, where rather huge input data is parsed (a few megabytes) and
the wall clock is used to measure the time of the whole procedure. Procedures
are repeated several times (10, 100, 1000 or more), the <strong>minimum running
time</strong> is noted.</p>
<p>To run these tests type <tt>make <span>report-overall.rst</span></tt>; the tests suite uses executable
<tt>bin/benchmark</tt>.</p>
<p>The results from various computers are available in the <a href="https://github.com/WojciechMula/parsing-int-series/tree/master/experiments/overalltests/results/">repository</a>.</p>
<blockquote>
</blockquote>
</li>
<li><p><strong>Microbenchmarks</strong>, where small inputs are parsed and exact number of CPU
cycles is obtained. Procedures are also repeated many times (1000) and then
<strong>minumum</strong> and <strong>average</strong> cycles to process a single input byte are calculated.</p>
<p>To run these tests type <tt>make microbenchmarks.rst</tt>; the tests suite uses
executable <tt><span>bin/benchmark-cpuclocks</span></tt>.</p>
<p>The all results from various computers are available in the <a href="https://github.com/WojciechMula/parsing-int-series/tree/master/experiments/microbenchmarks/results/">repository</a>,
below are only the measurements from the Skylake computer.</p>
<blockquote>
</blockquote>
</li>
</ul>
</div>
<div id="id12">
<h3><a href="#id56">11.3.3   Core i7 results</a></h3>
<p>Compiler: GCC 7.3.0</p>
<p>CPU: Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz</p>
<hr/>
<p>The table below compares speedup to the reference procedure for various
input sizes and data distributions. Detailed measurements for each size and
different distribution parameters are presented in the subsequent sections.</p>
<table>
<colgroup>
<col width="8%"/>
<col width="17%"/>
<col width="7%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
<col width="5%"/>
</colgroup>
<thead>
<tr><th colspan="3"> </th>
<th colspan="15">speedup over scalar procedure</th>
</tr>
<tr><th colspan="3"> </th>
<th colspan="3">scalar (std)</th>
<th colspan="3">scalar (hybrid)</th>
<th colspan="3">SSE</th>
<th colspan="3">SSE (block)</th>
<th colspan="3">SSE (simplified)</th>
</tr>
<tr><th>size [B]</th>
<th>distribution</th>
<th>samples</th>
<th>min</th>
<th>avg</th>
<th>max</th>
<th>min</th>
<th>avg</th>
<th>max</th>
<th>min</th>
<th>avg</th>
<th>max</th>
<th>min</th>
<th>avg</th>
<th>max</th>
<th>min</th>
<th>avg</th>
<th>max</th>
</tr>
</thead>
<tbody>
<tr><td>1024</td>
<td>Gaussian distribution</td>
<td>16</td>
<td>0.45</td>
<td>0.87</td>
<td>1.29</td>
<td>1.65</td>
<td>2.36</td>
<td>3.26</td>
<td>1.53</td>
<td>3.21</td>
<td>5.44</td>
<td>1.66</td>
<td>3.16</td>
<td>4.97</td>
<td>1.58</td>
<td>3.37</td>
<td>5.78</td>
</tr>
<tr><td>1024</td>
<td>Fixed length</td>
<td>16</td>
<td>0.42</td>
<td>0.87</td>
<td>1.29</td>
<td>1.63</td>
<td>2.41</td>
<td>3.53</td>
<td>1.28</td>
<td>3.32</td>
<td>5.23</td>
<td>1.47</td>
<td>3.30</td>
<td>5.05</td>
<td>1.30</td>
<td>3.54</td>
<td>5.79</td>
</tr>
<tr><td>1024</td>
<td>Uniform distribution</td>
<td>16</td>
<td>0.40</td>
<td>0.86</td>
<td>1.32</td>
<td>1.64</td>
<td>2.41</td>
<td>3.36</td>
<td>2.04</td>
<td>3.70</td>
<td>5.54</td>
<td>2.22</td>
<td>3.53</td>
<td>4.97</td>
<td>2.13</td>
<td>3.88</td>
<td>5.79</td>
</tr>
<tr><td>4096</td>
<td>Gaussian distribution</td>
<td>16</td>
<td>0.39</td>
<td>0.69</td>
<td>1.24</td>
<td>1.69</td>
<td>3.01</td>
<td>4.67</td>
<td>1.91</td>
<td>4.56</td>
<td>7.21</td>
<td>2.13</td>
<td>4.88</td>
<td>7.84</td>
<td>2.01</td>
<td>4.77</td>
<td>7.68</td>
</tr>
<tr><td>4096</td>
<td>Fixed length</td>
<td>16</td>
<td>0.36</td>
<td>0.69</td>
<td>1.39</td>
<td>1.94</td>
<td>2.87</td>
<td>4.32</td>
<td>1.60</td>
<td>4.44</td>
<td>6.86</td>
<td>1.71</td>
<td>4.66</td>
<td>8.34</td>
<td>1.62</td>
<td>4.70</td>
<td>7.83</td>
</tr>
<tr><td>4096</td>
<td>Uniform distribution</td>
<td>16</td>
<td>0.43</td>
<td>0.78</td>
<td>1.38</td>
<td>2.07</td>
<td>3.24</td>
<td>4.55</td>
<td>3.19</td>
<td>5.33</td>
<td>7.40</td>
<td>3.36</td>
<td>5.61</td>
<td>7.87</td>
<td>3.27</td>
<td>5.61</td>
<td>7.79</td>
</tr>
<tr><td>65536</td>
<td>Gaussian distribution</td>
<td>16</td>
<td>0.45</td>
<td>0.77</td>
<td>1.30</td>
<td>1.40</td>
<td>1.74</td>
<td>2.13</td>
<td>1.73</td>
<td>4.46</td>
<td>5.88</td>
<td>1.76</td>
<td>4.57</td>
<td>6.00</td>
<td>1.77</td>
<td>4.60</td>
<td>6.25</td>
</tr>
<tr><td>65536</td>
<td>Fixed length</td>
<td>16</td>
<td>0.40</td>
<td>0.75</td>
<td>1.36</td>
<td>1.55</td>
<td>1.87</td>
<td>2.37</td>
<td>1.46</td>
<td>4.68</td>
<td>6.72</td>
<td>1.48</td>
<td>5.00</td>
<td>7.31</td>
<td>1.50</td>
<td>4.95</td>
<td>7.53</td>
</tr>
<tr><td>65536</td>
<td>Uniform distribution</td>
<td>16</td>
<td>0.55</td>
<td>0.86</td>
<td>1.36</td>
<td>1.38</td>
<td>1.75</td>
<td>2.34</td>
<td>3.32</td>
<td>4.98</td>
<td>6.39</td>
<td>3.29</td>
<td>5.01</td>
<td>6.52</td>
<td>3.43</td>
<td>5.20</td>
<td>6.89</td>
</tr>
<tr><td>102400</td>
<td>Gaussian distribution</td>
<td>16</td>
<td>0.46</td>
<td>0.77</td>
<td>1.26</td>
<td>1.38</td>
<td>1.71</td>
<td>2.03</td>
<td>1.78</td>
<td>4.28</td>
<td>5.66</td>
<td>1.81</td>
<td>4.44</td>
<td>5.81</td>
<td>1.82</td>
<td>4.42</td>
<td>6.00</td>
</tr>
<tr><td>102400</td>
<td>Fixed length</td>
<td>16</td>
<td>0.40</td>
<td>0.75</td>
<td>1.36</td>
<td>1.53</td>
<td>1.84</td>
<td>2.31</td>
<td>1.29</td>
<td>4.59</td>
<td>6.49</td>
<td>1.46</td>
<td>4.91</td>
<td>6.99</td>
<td>1.31</td>
<td>4.85</td>
<td>7.16</td>
</tr>
<tr><td>102400</td>
<td>Uniform distribution</td>
<td>16</td>
<td>0.54</td>
<td>0.86</td>
<td>1.38</td>
<td>1.35</td>
<td>1.71</td>
<td>2.32</td>
<td>3.22</td>
<td>4.78</td>
<td>6.38</td>
<td>3.21</td>
<td>4.83</td>
<td>6.43</td>
<td>3.31</td>
<td>4.97</td>
<td>6.85</td>
</tr>
</tbody>
</table>
<div id="input-size-4096-bytes">
<h4><a href="#id57">11.3.3.1   Input size 4096 bytes</a></h4>
<p><strong>Gaussian distribution (max at 8 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>8.782</td>
<td>9.103</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.874</td>
<td>23.586</td>
<td>0.38</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>5.005</td>
<td>5.148</td>
<td>1.75</td>
</tr>
<tr><td>SSE</td>
<td>4.898</td>
<td>4.974</td>
<td>1.79</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.603</td>
<td>4.651</td>
<td>1.91</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.687</td>
<td>4.730</td>
<td>1.87</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 8 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>12.729</td>
<td>13.130</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>17.501</td>
<td>18.150</td>
<td>0.73</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.067</td>
<td>4.273</td>
<td>3.13</td>
</tr>
<tr><td>SSE</td>
<td>4.002</td>
<td>4.069</td>
<td>3.18</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.903</td>
<td>3.945</td>
<td>3.26</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.914</td>
<td>3.970</td>
<td>3.25</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 7 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>8.836</td>
<td>9.191</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>23.365</td>
<td>24.139</td>
<td>0.38</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>5.104</td>
<td>5.250</td>
<td>1.73</td>
</tr>
<tr><td>SSE</td>
<td>4.129</td>
<td>4.195</td>
<td>2.14</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.476</td>
<td>3.518</td>
<td>2.54</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.975</td>
<td>4.039</td>
<td>2.22</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 7 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>13.646</td>
<td>14.115</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.029</td>
<td>18.596</td>
<td>0.76</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.042</td>
<td>4.274</td>
<td>3.38</td>
</tr>
<tr><td>SSE</td>
<td>3.591</td>
<td>3.644</td>
<td>3.80</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.294</td>
<td>3.334</td>
<td>4.14</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.431</td>
<td>3.481</td>
<td>3.98</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 6 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>9.434</td>
<td>9.852</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>24.766</td>
<td>25.547</td>
<td>0.38</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>5.571</td>
<td>5.728</td>
<td>1.69</td>
</tr>
<tr><td>SSE</td>
<td>2.833</td>
<td>2.882</td>
<td>3.33</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.977</td>
<td>3.024</td>
<td>3.17</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.738</td>
<td>2.786</td>
<td>3.45</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 6 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>14.200</td>
<td>14.750</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>17.992</td>
<td>18.563</td>
<td>0.79</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.091</td>
<td>4.330</td>
<td>3.47</td>
</tr>
<tr><td>SSE</td>
<td>3.207</td>
<td>3.266</td>
<td>4.43</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.885</td>
<td>2.932</td>
<td>4.92</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.058</td>
<td>3.113</td>
<td>4.64</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 5 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>10.384</td>
<td>10.864</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>25.763</td>
<td>26.495</td>
<td>0.40</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.102</td>
<td>6.273</td>
<td>1.70</td>
</tr>
<tr><td>SSE</td>
<td>2.786</td>
<td>2.827</td>
<td>3.73</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.710</td>
<td>2.744</td>
<td>3.83</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.699</td>
<td>2.752</td>
<td>3.85</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 5 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>15.168</td>
<td>15.622</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.088</td>
<td>18.872</td>
<td>0.84</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.244</td>
<td>4.442</td>
<td>3.57</td>
</tr>
<tr><td>SSE</td>
<td>3.023</td>
<td>3.096</td>
<td>5.02</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.864</td>
<td>2.934</td>
<td>5.30</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.908</td>
<td>2.984</td>
<td>5.22</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 1 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>18.091</td>
<td>18.877</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>34.484</td>
<td>35.258</td>
<td>0.52</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>7.037</td>
<td>7.275</td>
<td>2.57</td>
</tr>
<tr><td>SSE</td>
<td>3.160</td>
<td>3.213</td>
<td>5.72</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.282</td>
<td>3.352</td>
<td>5.51</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.120</td>
<td>3.194</td>
<td>5.80</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 1 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>21.390</td>
<td>22.112</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.566</td>
<td>19.088</td>
<td>1.15</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>5.160</td>
<td>5.286</td>
<td>4.15</td>
</tr>
<tr><td>SSE</td>
<td>3.067</td>
<td>3.126</td>
<td>6.97</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.904</td>
<td>2.963</td>
<td>7.37</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.961</td>
<td>3.022</td>
<td>7.22</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 4 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>11.966</td>
<td>12.550</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>26.982</td>
<td>27.705</td>
<td>0.44</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>5.896</td>
<td>6.082</td>
<td>2.03</td>
</tr>
<tr><td>SSE</td>
<td>3.234</td>
<td>3.284</td>
<td>3.70</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.026</td>
<td>3.074</td>
<td>3.95</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.117</td>
<td>3.183</td>
<td>3.84</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 4 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>16.371</td>
<td>16.967</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>17.832</td>
<td>18.445</td>
<td>0.92</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.173</td>
<td>4.395</td>
<td>3.92</td>
</tr>
<tr><td>SSE</td>
<td>2.909</td>
<td>3.001</td>
<td>5.63</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.760</td>
<td>2.813</td>
<td>5.93</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.848</td>
<td>2.908</td>
<td>5.75</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 3 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>13.280</td>
<td>13.948</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>29.238</td>
<td>30.157</td>
<td>0.45</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.225</td>
<td>6.450</td>
<td>2.13</td>
</tr>
<tr><td>SSE</td>
<td>3.225</td>
<td>3.309</td>
<td>4.12</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.963</td>
<td>3.012</td>
<td>4.48</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.238</td>
<td>3.286</td>
<td>4.10</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 3 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>18.193</td>
<td>18.831</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.642</td>
<td>19.287</td>
<td>0.98</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.119</td>
<td>4.246</td>
<td>4.42</td>
</tr>
<tr><td>SSE</td>
<td>3.126</td>
<td>3.190</td>
<td>5.82</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.016</td>
<td>3.090</td>
<td>6.03</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.000</td>
<td>3.048</td>
<td>6.06</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 2 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>15.942</td>
<td>16.733</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>32.551</td>
<td>33.334</td>
<td>0.49</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.372</td>
<td>6.605</td>
<td>2.50</td>
</tr>
<tr><td>SSE</td>
<td>3.130</td>
<td>3.190</td>
<td>5.09</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.041</td>
<td>3.121</td>
<td>5.24</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.020</td>
<td>3.082</td>
<td>5.28</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 2 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>20.088</td>
<td>20.800</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.382</td>
<td>19.013</td>
<td>1.09</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.574</td>
<td>4.835</td>
<td>4.39</td>
</tr>
<tr><td>SSE</td>
<td>3.184</td>
<td>3.264</td>
<td>6.31</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.018</td>
<td>3.069</td>
<td>6.66</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.988</td>
<td>3.042</td>
<td>6.72</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 1 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>18.677</td>
<td>19.206</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>34.479</td>
<td>35.207</td>
<td>0.54</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>7.953</td>
<td>8.184</td>
<td>2.35</td>
</tr>
<tr><td>SSE</td>
<td>3.014</td>
<td>3.099</td>
<td>6.20</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.117</td>
<td>3.172</td>
<td>5.99</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.977</td>
<td>3.062</td>
<td>6.27</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 1 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>21.981</td>
<td>22.621</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>16.860</td>
<td>17.391</td>
<td>1.30</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>5.285</td>
<td>5.481</td>
<td>4.16</td>
</tr>
<tr><td>SSE</td>
<td>3.029</td>
<td>3.085</td>
<td>7.26</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.942</td>
<td>3.000</td>
<td>7.47</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.099</td>
<td>3.179</td>
<td>7.09</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 2 digits) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>17.695</td>
<td>18.444</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>34.917</td>
<td>35.633</td>
<td>0.51</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>7.245</td>
<td>7.401</td>
<td>2.44</td>
</tr>
<tr><td>SSE</td>
<td>3.324</td>
<td>3.387</td>
<td>5.32</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.323</td>
<td>3.398</td>
<td>5.33</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.236</td>
<td>3.321</td>
<td>5.47</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 2 digits) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>21.164</td>
<td>21.860</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.567</td>
<td>19.126</td>
<td>1.14</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.937</td>
<td>5.156</td>
<td>4.29</td>
</tr>
<tr><td>SSE</td>
<td>2.940</td>
<td>2.995</td>
<td>7.20</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.924</td>
<td>2.975</td>
<td>7.24</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.785</td>
<td>2.826</td>
<td>7.60</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 3 digits) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>16.385</td>
<td>17.254</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>33.359</td>
<td>34.075</td>
<td>0.49</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.877</td>
<td>7.145</td>
<td>2.38</td>
</tr>
<tr><td>SSE</td>
<td>2.892</td>
<td>2.947</td>
<td>5.67</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.088</td>
<td>3.158</td>
<td>5.31</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.752</td>
<td>2.844</td>
<td>5.95</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 3 digits) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>20.530</td>
<td>21.221</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.995</td>
<td>19.580</td>
<td>1.08</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.647</td>
<td>4.811</td>
<td>4.42</td>
</tr>
<tr><td>SSE</td>
<td>3.037</td>
<td>3.089</td>
<td>6.76</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.941</td>
<td>2.992</td>
<td>6.98</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.914</td>
<td>2.972</td>
<td>7.05</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 4 digits) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>14.926</td>
<td>15.613</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>31.275</td>
<td>32.210</td>
<td>0.48</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.445</td>
<td>6.677</td>
<td>2.32</td>
</tr>
<tr><td>SSE</td>
<td>3.393</td>
<td>3.458</td>
<td>4.40</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.126</td>
<td>3.184</td>
<td>4.77</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.293</td>
<td>3.344</td>
<td>4.53</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 4 digits) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>19.047</td>
<td>19.920</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>19.500</td>
<td>20.130</td>
<td>0.98</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.539</td>
<td>4.723</td>
<td>4.20</td>
</tr>
<tr><td>SSE</td>
<td>3.325</td>
<td>3.383</td>
<td>5.73</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.132</td>
<td>3.193</td>
<td>6.08</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.182</td>
<td>3.235</td>
<td>5.99</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 5 digits) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>13.748</td>
<td>14.405</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>30.105</td>
<td>30.941</td>
<td>0.46</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.144</td>
<td>6.413</td>
<td>2.24</td>
</tr>
<tr><td>SSE</td>
<td>3.475</td>
<td>3.533</td>
<td>3.96</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.171</td>
<td>3.238</td>
<td>4.34</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.293</td>
<td>3.356</td>
<td>4.17</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 5 digits) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>18.297</td>
<td>19.010</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>19.209</td>
<td>19.845</td>
<td>0.95</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.477</td>
<td>4.652</td>
<td>4.09</td>
</tr>
<tr><td>SSE</td>
<td>3.293</td>
<td>3.352</td>
<td>5.56</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.135</td>
<td>3.188</td>
<td>5.84</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.182</td>
<td>3.230</td>
<td>5.75</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 6 digits) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>12.912</td>
<td>13.548</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>29.511</td>
<td>30.337</td>
<td>0.44</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>5.958</td>
<td>6.253</td>
<td>2.17</td>
</tr>
<tr><td>SSE</td>
<td>3.430</td>
<td>3.487</td>
<td>3.76</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.201</td>
<td>3.265</td>
<td>4.03</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.283</td>
<td>3.337</td>
<td>3.93</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 6 digits) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>17.288</td>
<td>17.956</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>19.250</td>
<td>19.841</td>
<td>0.90</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.356</td>
<td>4.481</td>
<td>3.97</td>
</tr>
<tr><td>SSE</td>
<td>3.205</td>
<td>3.276</td>
<td>5.39</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.990</td>
<td>3.046</td>
<td>5.78</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.116</td>
<td>3.172</td>
<td>5.55</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 7 digits) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>11.974</td>
<td>12.552</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>27.884</td>
<td>28.562</td>
<td>0.43</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.214</td>
<td>6.385</td>
<td>1.93</td>
</tr>
<tr><td>SSE</td>
<td>3.253</td>
<td>3.309</td>
<td>3.68</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.057</td>
<td>3.100</td>
<td>3.92</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.119</td>
<td>3.167</td>
<td>3.84</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 7 digits) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>16.583</td>
<td>17.366</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.947</td>
<td>19.528</td>
<td>0.88</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.265</td>
<td>4.401</td>
<td>3.89</td>
</tr>
<tr><td>SSE</td>
<td>3.248</td>
<td>3.311</td>
<td>5.11</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.989</td>
<td>3.048</td>
<td>5.55</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.165</td>
<td>3.215</td>
<td>5.24</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 8 digits) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>11.637</td>
<td>12.165</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>27.107</td>
<td>27.851</td>
<td>0.43</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>6.079</td>
<td>6.231</td>
<td>1.91</td>
</tr>
<tr><td>SSE</td>
<td>3.821</td>
<td>3.870</td>
<td>3.05</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.492</td>
<td>3.550</td>
<td>3.33</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.688</td>
<td>3.745</td>
<td>3.16</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 8 digits) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>15.739</td>
<td>16.589</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>18.875</td>
<td>19.563</td>
<td>0.83</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>4.335</td>
<td>4.463</td>
<td>3.63</td>
</tr>
<tr><td>SSE</td>
<td>3.611</td>
<td>3.667</td>
<td>4.36</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.337</td>
<td>3.400</td>
<td>4.72</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.490</td>
<td>3.538</td>
<td>4.51</td>
</tr>
</tbody>
</table>
</div>
<div id="input-size-65536-bytes">
<h4><a href="#id58">11.3.3.2   Input size 65536 bytes</a></h4>
<p><strong>Gaussian distribution (max at 8 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>11.852</td>
<td>11.971</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>26.589</td>
<td>26.792</td>
<td>0.45</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>8.336</td>
<td>8.411</td>
<td>1.42</td>
</tr>
<tr><td>SSE</td>
<td>6.911</td>
<td>6.956</td>
<td>1.71</td>
</tr>
<tr><td>SSE (block)</td>
<td>6.921</td>
<td>6.990</td>
<td>1.71</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>6.757</td>
<td>6.802</td>
<td>1.75</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 8 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>17.008</td>
<td>17.110</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>21.492</td>
<td>21.653</td>
<td>0.79</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>8.722</td>
<td>8.800</td>
<td>1.95</td>
</tr>
<tr><td>SSE</td>
<td>5.650</td>
<td>5.692</td>
<td>3.01</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.679</td>
<td>5.733</td>
<td>2.99</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.426</td>
<td>5.470</td>
<td>3.13</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 7 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>12.818</td>
<td>12.929</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>27.335</td>
<td>27.609</td>
<td>0.47</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>9.246</td>
<td>9.315</td>
<td>1.39</td>
</tr>
<tr><td>SSE</td>
<td>5.513</td>
<td>5.542</td>
<td>2.33</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.259</td>
<td>5.296</td>
<td>2.44</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.364</td>
<td>5.405</td>
<td>2.39</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 7 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>17.978</td>
<td>18.119</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>21.924</td>
<td>22.109</td>
<td>0.82</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>9.205</td>
<td>9.286</td>
<td>1.95</td>
</tr>
<tr><td>SSE</td>
<td>4.537</td>
<td>4.591</td>
<td>3.96</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.351</td>
<td>4.388</td>
<td>4.13</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.352</td>
<td>4.407</td>
<td>4.13</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 6 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>13.772</td>
<td>13.862</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>28.295</td>
<td>28.596</td>
<td>0.49</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>10.005</td>
<td>10.079</td>
<td>1.38</td>
</tr>
<tr><td>SSE</td>
<td>3.456</td>
<td>3.479</td>
<td>3.98</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.358</td>
<td>3.385</td>
<td>4.10</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.379</td>
<td>3.402</td>
<td>4.08</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 6 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>19.374</td>
<td>19.538</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.288</td>
<td>22.489</td>
<td>0.87</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>9.660</td>
<td>9.730</td>
<td>2.01</td>
</tr>
<tr><td>SSE</td>
<td>3.949</td>
<td>3.983</td>
<td>4.91</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.726</td>
<td>3.751</td>
<td>5.20</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.870</td>
<td>3.918</td>
<td>5.01</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 5 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>14.989</td>
<td>15.092</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>29.851</td>
<td>30.089</td>
<td>0.50</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>10.750</td>
<td>10.842</td>
<td>1.39</td>
</tr>
<tr><td>SSE</td>
<td>2.933</td>
<td>2.945</td>
<td>5.11</td>
</tr>
<tr><td>SSE (block)</td>
<td>2.807</td>
<td>2.822</td>
<td>5.34</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>2.866</td>
<td>2.878</td>
<td>5.23</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 5 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>20.729</td>
<td>20.888</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.536</td>
<td>22.718</td>
<td>0.92</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>10.225</td>
<td>10.311</td>
<td>2.03</td>
</tr>
<tr><td>SSE</td>
<td>4.032</td>
<td>4.086</td>
<td>5.14</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.762</td>
<td>3.805</td>
<td>5.51</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.985</td>
<td>4.043</td>
<td>5.20</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 1 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>24.489</td>
<td>24.804</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>38.285</td>
<td>38.540</td>
<td>0.64</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>16.088</td>
<td>16.198</td>
<td>1.52</td>
</tr>
<tr><td>SSE</td>
<td>4.159</td>
<td>4.200</td>
<td>5.89</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.107</td>
<td>4.142</td>
<td>5.96</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.213</td>
<td>4.250</td>
<td>5.81</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 1 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>28.265</td>
<td>28.549</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.648</td>
<td>22.767</td>
<td>1.25</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.524</td>
<td>13.622</td>
<td>2.09</td>
</tr>
<tr><td>SSE</td>
<td>5.201</td>
<td>5.271</td>
<td>5.43</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.452</td>
<td>5.513</td>
<td>5.18</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.057</td>
<td>5.128</td>
<td>5.59</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 4 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>16.687</td>
<td>16.790</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>31.153</td>
<td>31.398</td>
<td>0.54</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>11.835</td>
<td>11.913</td>
<td>1.41</td>
</tr>
<tr><td>SSE</td>
<td>3.590</td>
<td>3.614</td>
<td>4.65</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.466</td>
<td>3.489</td>
<td>4.81</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.496</td>
<td>3.525</td>
<td>4.77</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 4 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>22.284</td>
<td>22.529</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.476</td>
<td>22.653</td>
<td>0.99</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>10.916</td>
<td>11.005</td>
<td>2.04</td>
</tr>
<tr><td>SSE</td>
<td>4.032</td>
<td>4.081</td>
<td>5.53</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.859</td>
<td>3.898</td>
<td>5.77</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.953</td>
<td>3.991</td>
<td>5.64</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 3 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>19.121</td>
<td>19.291</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>32.927</td>
<td>33.175</td>
<td>0.58</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.629</td>
<td>13.718</td>
<td>1.40</td>
</tr>
<tr><td>SSE</td>
<td>4.848</td>
<td>4.901</td>
<td>3.94</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.780</td>
<td>4.825</td>
<td>4.00</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.760</td>
<td>4.812</td>
<td>4.02</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 3 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>24.281</td>
<td>24.611</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.530</td>
<td>22.703</td>
<td>1.08</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>11.920</td>
<td>12.185</td>
<td>2.04</td>
</tr>
<tr><td>SSE</td>
<td>4.756</td>
<td>4.823</td>
<td>5.11</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.781</td>
<td>4.835</td>
<td>5.08</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.607</td>
<td>4.664</td>
<td>5.27</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 2 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>22.188</td>
<td>22.377</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>36.158</td>
<td>36.461</td>
<td>0.61</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>15.232</td>
<td>15.326</td>
<td>1.46</td>
</tr>
<tr><td>SSE</td>
<td>4.058</td>
<td>4.108</td>
<td>5.47</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.952</td>
<td>3.990</td>
<td>5.61</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.061</td>
<td>4.110</td>
<td>5.46</td>
</tr>
</tbody>
</table>
<p><strong>Gaussian distribution (max at 2 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>26.633</td>
<td>26.932</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.723</td>
<td>22.869</td>
<td>1.17</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.162</td>
<td>13.267</td>
<td>2.02</td>
</tr>
<tr><td>SSE</td>
<td>5.097</td>
<td>5.174</td>
<td>5.23</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.160</td>
<td>5.224</td>
<td>5.16</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.941</td>
<td>5.008</td>
<td>5.39</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 1 digit) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>22.963</td>
<td>23.203</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>37.465</td>
<td>37.718</td>
<td>0.61</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.951</td>
<td>14.058</td>
<td>1.65</td>
</tr>
<tr><td>SSE</td>
<td>3.389</td>
<td>3.447</td>
<td>6.78</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.593</td>
<td>3.643</td>
<td>6.39</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.324</td>
<td>3.394</td>
<td>6.91</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 1 digit) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>27.116</td>
<td>27.518</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>20.621</td>
<td>20.742</td>
<td>1.31</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>11.908</td>
<td>12.006</td>
<td>2.28</td>
</tr>
<tr><td>SSE</td>
<td>4.128</td>
<td>4.167</td>
<td>6.57</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.179</td>
<td>4.214</td>
<td>6.49</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.105</td>
<td>4.136</td>
<td>6.61</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 2 digits) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>23.675</td>
<td>24.277</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>37.914</td>
<td>38.203</td>
<td>0.62</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>15.327</td>
<td>15.432</td>
<td>1.54</td>
</tr>
<tr><td>SSE</td>
<td>3.896</td>
<td>3.933</td>
<td>6.08</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.870</td>
<td>3.901</td>
<td>6.12</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.913</td>
<td>3.952</td>
<td>6.05</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 2 digits) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>27.811</td>
<td>28.100</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.433</td>
<td>22.537</td>
<td>1.24</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.003</td>
<td>13.113</td>
<td>2.14</td>
</tr>
<tr><td>SSE</td>
<td>4.947</td>
<td>5.018</td>
<td>5.62</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.201</td>
<td>5.265</td>
<td>5.35</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.807</td>
<td>4.872</td>
<td>5.79</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 3 digits) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>22.512</td>
<td>22.742</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>36.660</td>
<td>36.946</td>
<td>0.61</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>15.263</td>
<td>15.362</td>
<td>1.47</td>
</tr>
<tr><td>SSE</td>
<td>3.474</td>
<td>3.507</td>
<td>6.48</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.456</td>
<td>3.480</td>
<td>6.51</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>3.528</td>
<td>3.561</td>
<td>6.38</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 3 digits) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>26.841</td>
<td>27.155</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>22.874</td>
<td>23.042</td>
<td>1.17</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.184</td>
<td>13.284</td>
<td>2.04</td>
</tr>
<tr><td>SSE</td>
<td>4.815</td>
<td>4.876</td>
<td>5.57</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.952</td>
<td>5.022</td>
<td>5.42</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.699</td>
<td>4.753</td>
<td>5.71</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 4 digits) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>21.123</td>
<td>21.329</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>35.205</td>
<td>35.486</td>
<td>0.60</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>14.756</td>
<td>14.856</td>
<td>1.43</td>
</tr>
<tr><td>SSE</td>
<td>5.217</td>
<td>5.283</td>
<td>4.05</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.053</td>
<td>5.106</td>
<td>4.18</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.163</td>
<td>5.227</td>
<td>4.09</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 4 digits) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>25.877</td>
<td>26.129</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>23.132</td>
<td>23.285</td>
<td>1.12</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>12.984</td>
<td>13.084</td>
<td>1.99</td>
</tr>
<tr><td>SSE</td>
<td>5.211</td>
<td>5.291</td>
<td>4.97</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.283</td>
<td>5.356</td>
<td>4.90</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.048</td>
<td>5.116</td>
<td>5.13</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 5 digits) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>19.780</td>
<td>19.978</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>34.247</td>
<td>34.511</td>
<td>0.58</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>14.274</td>
<td>14.371</td>
<td>1.39</td>
</tr>
<tr><td>SSE</td>
<td>5.099</td>
<td>5.160</td>
<td>3.88</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.920</td>
<td>4.975</td>
<td>4.02</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.053</td>
<td>5.099</td>
<td>3.91</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 5 digits) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>24.749</td>
<td>25.022</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>23.269</td>
<td>23.468</td>
<td>1.06</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>12.627</td>
<td>12.718</td>
<td>1.96</td>
</tr>
<tr><td>SSE</td>
<td>5.046</td>
<td>5.111</td>
<td>4.90</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.999</td>
<td>5.126</td>
<td>4.95</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.903</td>
<td>4.954</td>
<td>5.05</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 6 digits) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>18.656</td>
<td>18.857</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>33.362</td>
<td>33.565</td>
<td>0.56</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.643</td>
<td>13.742</td>
<td>1.37</td>
</tr>
<tr><td>SSE</td>
<td>4.433</td>
<td>4.479</td>
<td>4.21</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.282</td>
<td>4.319</td>
<td>4.36</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.356</td>
<td>4.399</td>
<td>4.28</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 6 digits) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>23.975</td>
<td>24.304</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>23.495</td>
<td>23.653</td>
<td>1.02</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>12.269</td>
<td>12.358</td>
<td>1.95</td>
</tr>
<tr><td>SSE</td>
<td>4.883</td>
<td>4.947</td>
<td>4.91</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.715</td>
<td>4.770</td>
<td>5.08</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.778</td>
<td>4.825</td>
<td>5.02</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 7 digits) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>17.632</td>
<td>17.799</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>32.227</td>
<td>32.509</td>
<td>0.55</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>13.079</td>
<td>13.177</td>
<td>1.35</td>
</tr>
<tr><td>SSE</td>
<td>4.114</td>
<td>4.158</td>
<td>4.29</td>
</tr>
<tr><td>SSE (block)</td>
<td>3.976</td>
<td>4.028</td>
<td>4.43</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.032</td>
<td>4.069</td>
<td>4.37</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 7 digits) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>22.878</td>
<td>23.116</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>23.259</td>
<td>23.512</td>
<td>0.98</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>12.010</td>
<td>12.113</td>
<td>1.90</td>
</tr>
<tr><td>SSE</td>
<td>4.926</td>
<td>4.986</td>
<td>4.64</td>
</tr>
<tr><td>SSE (block)</td>
<td>4.670</td>
<td>4.735</td>
<td>4.90</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>4.836</td>
<td>4.892</td>
<td>4.73</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 8 digits) — single separator character</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>16.753</td>
<td>16.923</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>31.309</td>
<td>31.604</td>
<td>0.54</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>12.522</td>
<td>12.615</td>
<td>1.34</td>
</tr>
<tr><td>SSE</td>
<td>5.181</td>
<td>5.232</td>
<td>3.23</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.263</td>
<td>5.313</td>
<td>3.18</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.089</td>
<td>5.133</td>
<td>3.29</td>
</tr>
</tbody>
</table>
<p><strong>Uniform distribution (1 .. 8 digits) — 1 .. 6 separator characters</strong></p>
<table>
<colgroup>
<col width="33%"/>
<col width="24%"/>
<col width="24%"/>
<col width="19%"/>
</colgroup>
<thead>
<tr><th> </th>
<th colspan="2">cycles per one input byte</th>
<th>speed-up</th>
</tr>
<tr><th>procedure</th>
<th>min</th>
<th>avg</th>
<th>(min)</th>
</tr>
</thead>
<tbody>
<tr><td>scalar</td>
<td>22.070</td>
<td>22.400</td>
<td>1.00</td>
</tr>
<tr><td>scalar (std)</td>
<td>23.084</td>
<td>23.272</td>
<td>0.96</td>
</tr>
<tr><td>scalar (hybrid)</td>
<td>11.689</td>
<td>11.777</td>
<td>1.89</td>
</tr>
<tr><td>SSE</td>
<td>5.666</td>
<td>5.729</td>
<td>3.90</td>
</tr>
<tr><td>SSE (block)</td>
<td>5.833</td>
<td>5.886</td>
<td>3.78</td>
</tr>
<tr><td>SSE (simplified)</td>
<td>5.493</td>
<td>5.553</td>
<td>4.02</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="conclusions">

<ul>
<li><p>The vectorized algorithm can be faster from 2 to 5 times than the scalar base.</p>
</li>
<li><p>Although SSE speed-up depends on the count of digits in numbers, negative
impact is visible when the numbers are separated by more than one character.
This is caused by greater number of distinct <a href="https://blog.plover.com/lang/sse_conversion_span_pattern_usage">span patterns</a>: for &#34;Gaussian distribution — max at
1 digit, single separator character&#34; the number of distinct patterns is
approximately <strong>1000</strong>; for the same distribution, but variable number of
separator, this value raises almost 28 times, to <strong>28000</strong>.</p>
<p>It means touching more memory locations within the lookup table and, as a
result, more cache misses. Also amount of branch mispredictions is greater
due to processing greater variety of patterns.</p>
</li>
<li><p><strong>Scalar hybrid</strong> performs surprisingly well, it can be even 2 times faster than
the baseline. However, its compile time is terribly long.</p>
</li>
</ul>
</div>
<div id="acknowledgements">

<p><strong>Nathan Kurz</strong> and <strong>Daniel Lemire</strong> gave incredibly valuable feedback and
comments on text and experiments. Thank you!</p>
</div>
<div id="see-also">

<p>External links:</p>
<ul>
<li>Daniel Lemire <a href="https://lemire.me/blog/2017/01/20/how-quickly-can-you-remove-spaces-from-a-string/">How quickly can you remove spaces from a string?</a></li>
</ul>
<p id="internal-links">Internal links:</p>
<ul>
<li><a href="http://0x80.pl/notesen/2014-10-15-parsing-decimal-numbers-part-2-sse.html">Parsing decimal numbers — part 1: SWAR</a></li>
<li><a href="http://0x80.pl/notesen/2014-10-12-parsing-decimal-numbers-part-1-swar.html">Parsing decimal numbers — part 2: SSE</a></li>
<li><a href="https://blog.plover.com/lang/swar-digits-validate.html">SWAR check if all chars are digits</a></li>
</ul>
</div>
<div id="source-code">

<p>Source code is available on <a href="https://github.com/WojciechMula/parsing-int-series">github</a>.</p>
</div>
</div></div>
  </body>
</html>
