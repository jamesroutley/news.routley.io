<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bvisness.me/advent-of-dreams/">Original</a>
    <h1>I did Advent of Code on a Playstation</h1>
    
    <div id="readability-page-1" class="page"><div>
            

            
    <article>
        <header>
            
<p><time datetime="2022-12-31T00:00:00Z" itemprop="datePublished">December 31, 2022</time>
</p>

        </header>
        
<p>I did a very stupid challenge this December - I did Advent of Code in Dreams.</p>




<p><a href="https://indreams.me/">Dreams</a> is a PlayStation game creation platform by Media Molecule, the studio most famous for the LittleBigPlanet games. Users can create and share everything from games to animations to interactive art. It‚Äôs truly amazing what these tools can do - I mean, just look at <a href="https://youtu.be/2HBBh8O1xpk">this</a> <a href="https://twitter.com/LeorProject/status/1604128725414600711">stuff</a>.</p>
      

<p>Unfortunately I am no artist. But I am a programmer, and Dreams has a robust ‚Äúlogic‚Äù system designed for game scripting. When I bought Dreams a couple years ago, I discovered that this logic system is a capable visual scripting engine with a very thoughtful design, and I was quickly able to produce some fun results, culminating in my magnum opus: a toy LISP interpreter.</p>

<div>
    
<p>
    
    
    <iframe src="https://www.youtube-nocookie.com/embed/MiCbA3JuaWk?enablejsapi=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</p>

</div>

<p>This proved to me that Dreams was capable of just about anything. And as the leader of the <a href="https://handmade.network/">Handmade Network</a>, I‚Äôve heard a lot of discussion over the years about ‚Äúvisual programming‚Äù.[1] So this year, I decided to give visual programming a serious try. And what better way to experiment with a new programming system than <a href="https://adventofcode.com/">Advent of Code</a>?</p>








<p>I completed 15 of the 25 days of Advent of Code. By ‚Äúcompleted‚Äù I mean ‚Äúgot the example working‚Äù, because I didn‚Äôt have any way to copy-paste my actual puzzle input into Dreams. Also, Dreams doesn‚Äôt have lists.</p>

<p>In the end, Day 16 was too much - an optimization problem that requires recursion, Dijkstra‚Äôs algorithm, and N! runs to determine the optimal path. I spent three days trying to solve it and eventually had to admit defeat.</p>

<p>You can see videos of each solution on the calendar below. I‚Äôve highlighted my favorite results!</p>




<div>
    <div>
        
        

        <div>
            <p>Sunday</p>
            <p>Monday</p>
            <p>Tuesday</p>
            <p>Wednesday</p>
            <p>Thursday</p>
            <p>Friday</p>
            <p>Saturday</p>
        </div>
        
        <div>
            <div>
                
<div data-day="1">
    <div>

                    <h2>Day 1: Calorie Counting</h2>
                    
                    <div>
                        <p>As expected, I spent a lot of time on Day 1 getting my bearings. Rather than figure out double iteration on my first day, I manually walked from elf to elf to compute the final answer.</p>

<p>I hadn&#39;t yet learned about some newer features in Dreams, like scope (which was added sometime in the last couple years.) Those features would make subsequent days considerably easier.</p>

                    </div>
                
    </div>
    
</div>


                
<div data-day="2">
    <div>

                    <h2>Day 2: Rock Paper Scissors</h2>
                    
                    <p>I put in a tiny amount of visual polish, and I think it paid off. This one is still quite simple, and some changes I made to iteration were an improvement, but I still ran into a lot of issues. (More on that later.)</p>
                
    </div>
    <div>

                    
<p>
    
    
        
    
    <iframe src="https://www.youtube-nocookie.com/embed/07GstsK8Aos?start=6890&amp;enablejsapi=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</p>

                
    </div>
</div>


                
<div data-day="3">
    <div>

                    <h2>Day 3: Rucksack Reorganization</h2>
                    
                    <div>
                        <p>This stream went for a grueling five full hours. I spent about half the time just fixing bugs in my iterator and weird suppressed-behavior / bad-cycle bugs in the larger program. I also spent at least an hour just inputting the example data, which was unusually large. It took me a staggering 4 hours and 45 minutes to get the right answer on this one.</p>

<p>I ended up abandoning the internal timer on the iterator on this day. This was the right decision.</p>

<p>I didn&#39;t have the energy to make this one pretty. Not sure how I would have anyway.</p>

                    </div>
                
    </div>
    
</div>

            </div>
        </div>
        
        <div>
            <div>
                
<div data-day="4">
    <div>

                    <h2>Day 4: Camp Cleanup</h2>
                    
                    <div>
                        <p>I opened this stream saying that ‚Äúmy goal is to solve this problem in less than five hours‚Äù. Luckily, this one took me literally just a half hour. In fact, it went so fast that I decided to do part 2 as well - which only took another half hour. The iterator worked fine, which was a huge blessing.</p>

<p>This is a fun one to watch if you want to see a speedrun of the process. No other day would be so easy.</p>

                    </div>
                
    </div>
    
</div>


                
<div data-day="5">
    <div>

                    <h2>Day 5: Supply Stacks</h2>
                    
                    <div>
                        <p>I love this problem. It exemplifies everything that is great about Dreams, as well as all the issues I had throughout the challenge. The result is a literal simulation of the problem; the program is also so fragile that it breaks if you breathe on it. All the highs and lows are in one place.</p>

<p>If I could revisit this one, I would probably save a full hour due to better handling of iteration and of large cycles in the graph. I talk about cycle issues later on.</p>

<p>(Skip back a bit in the video if you want to see some shenanigans.)</p>

                    </div>
                
    </div>
    
</div>


                
<div data-day="6">
    <div>

                    <h2>Day 6: Tuning Trouble</h2>
                    
                    <p>I don&#39;t even remember this one tbh. It went really fast. I guess it all worked fine right away?</p>
                
    </div>
    
</div>


                
<div data-day="7">
    <div>

                    <h2>Day 7: No Space Left On Device</h2>
                    
                    <div>
                        <p>This was the first problem that required me to &#34;allocate memory&#34;, that is, spawn objects in the world to store data and run logic of their own. This thankfully went pretty well, in part thanks to my experience two years ago with the LISP thing.</p>

<p>I took what I think are some justified shortcuts in this program - it seems that the input always follows a depth-first traversal of the file data, so I hardcoded a depth-first traversal in my implementation.</p>

                    </div>
                
    </div>
    
</div>


                
<div data-day="8">
    <div>

                    <h2>Day 8: Treetop Tree House</h2>
                    
                    <div>
                        <p>This is one of my favorite simulation problems from this year. When the problem described trees occluding other trees, I couldn&#39;t help but think &#34;RAYCASTS!!&#34; (or, Laser Scopes, as Dreams calls them). Iteration was working pretty reliably at this point; although this problem took three hours to solve, most of that time was spent learning how to properly use Laser Scopes.</p>

<p>It is just absolutely delightful to me that I can push a little guy around using a Follower and he actually does a run animation. That would never work in any other engine but it saves me so much effort here.</p>

                    </div>
                
    </div>
    
</div>


                
<div data-day="9">
    <div>

                    <h2>Day 9: Rope Bridge</h2>
                    
                    <div>
                        <p>This one turned out great as well. If you imagine a rope between the two elves, you can imagine the back elf being tugged around only when the front elf is at least two tiles away.</p>

<p>Amusing fact: I originally had the elves face in the direction they were walking, but disabled it because the code was attached to the elves, and when they turned around, the code would turn around. How many other programmers have ever had their code run away from them?</p>

                    </div>
                
    </div>
    
</div>


                
<div data-day="10">
    <div>

                    <h2>Day 10: Cathode-Ray Tube</h2>
                    
                    <div>
                        <p>I spent SO LONG entering the example data for this one. It is just cruel to give a Dreams programmer sample input that is 146 lines long.</p>

<p>Worse yet, I realized later than the <em>actual</em> input was only 140 lines. So, I spent another half hour entering the <em>actual</em> input, and managed to produce my <a href="https://twitter.com/its_bvisness/status/1601822981587697664">first and only</a> legitimate Advent of Code answer from Dreams.</p>

<p>At least this one was pretty!</p>

                    </div>
                
    </div>
    
</div>

            </div>
        </div>
        
        <div>
            <div>
                
<div data-day="11">
    <div>

                    <h2>Day 11: Monkey in the Middle</h2>
                    
                    <div>
                        <p>This problem was really incredibly difficult. I spent at least an hour just figuring out how to make monkeys toss objects to each other, and at least an hour debugging sync issues again. Some days are just like that.</p>

<p>I ran out of time at the end of the stream, so I wasn&#39;t quite able to make it as pretty as I would like. Despite that, and despite all the grueling bugs, I think this is one of the most technically impressive simulation problems I completed.</p>

                    </div>
                
    </div>
    
</div>


                
<div data-day="12">
    <div>

                    <h2>Day 12: Hill Climbing Algorithm</h2>
                    
                    <div>
                        <p>This is, without a doubt, the most technically challenging problem I completed. It took two days and six hours total, and required both recursion and wireless communication between adjacent tiles. It recursively flood-fills the scene by spawning elves to go to each unvisited tile - whoever gets there fastest took the shortest path.</p>

<p>(The elves ascend to heaven because otherwise Dreams yells about having too many entities.)</p>

                    </div>
                
    </div>
    
</div>


                
<div data-day="13">
    <div>

                    <h2>Day 13: Distress Signal</h2>
                    
                    <p>This problem was a welcome reprieve. I&#39;m proud of the solution here; I came up with a way to transform the obvious recursive solution into an iterative one, dramatically reducing the complexity of my Dreams logic. More info in <a href="https://twitter.com/its_bvisness/status/1603851835047088153?s=20">this follow-up tweet</a>.</p>
                
    </div>
    
</div>


                
<div data-day="14">
    <div>

                    <h2>Day 14: Regolith Reservoir</h2>
                    
                    <div>
                        <p>I am so happy with this one. It directly simulates the problem, has great visuals I found on the Dreamiverse, and I even verified that it works with other inputs too (skip to 3:23:39 for an example). Cellular automata turn out to be really fun in Dreams!</p>

<p>There were a couple weird issues, like trigger zones not detecting anything on the first frame they&#39;re active. Iteration was still difficult. But the end result is just wonderful.</p>

                    </div>
                
    </div>
    
</div>


                
<div data-day="15">
    <div>

                    <h2>Day 15: Beacon Exclusion Zone</h2>
                    
                    <div>
                        <p>This one looked cool at the end but was quite a grind. Taxicab / Manhattan distance stuff was fun to work with, though. I didn&#39;t really bother to actually produce a legit answer for real, but I did get the simulation stuff working.</p>

<p>This would be the final problem I completed; Day 16 was ludicrously difficult, and I had to admit defeat.</p>

                    </div>
                
    </div>
    
</div>

            </div>
        </div>
    </div>
</div>




<div>
    <div>
        <div>

    <p>Before we go further, let me introduce you to programming in Dreams.</p>

<p>Dreams code is made up of nodes and wires, superficially similar to some other visual programming systems. However, it is very tightly designed and elegantly integrated into the game world. In this example, a Trigger Zone widget is wired to the Glow property of the lights on this Christmas tree, causing it to light up whenever the player walks into the zone.</p>


        </div>
        
    </div>
</div>



<div>
    <div>
        <p>Widgets can be snapped onto a Microchip to make logic more organized. Microchips can have explicit input/output ports, allowing Microchips to serve as reusable units of code, sort of like functions or macros. Being on a Microchip does not affect the widgets‚Äô behavior (outside of inheriting a couple properties like power).</p>
        
    </div>
</div>



<div>
    <div>
        <p>Widgets have their own state, just like any other object in the world. For example, Timers can be turned on and off, Selectors remember which port is active, and Signal Generators just do their own thing.</p>
        
    </div>
</div>



<div>
    <div>
        <div>

    <p>The only data type is decimal numbers. All wires are just decimal numbers. ‚ÄúBoolean‚Äù signals are typically communicated with the number 0 or the number 1.</p>

<p>For convenience, there are several types of ‚Äúfat wires‚Äù that are just common bundles of other wires. (These are basically structs.) All the nodes in Dreams interact with fat wires in pleasant ways, such as the Calculator node working component-wise (allowing for both vector and scalar arithmetic). Each fat wire type can decay to a single number if necessary.</p>

<p>There is no explicit execution flow like you might see in Unreal Blueprints.[2] It‚Äôs usually best to think about Dreams logic as independent actors sending signals to each other. In practice, this is often literally true, since logic is usually attached to physical objects in the game world.</p>


        </div>
        
    </div>
</div>








<p>One piece of logic is a perfect microcosm of everything I learned from this challenge: the Iterator.</p>

<p>Every problem required me to iterate through a list in some way. Every problem had some number of lines of input, which I would loop through. My logic for this started off simple and messy, then became complicated and messy, then finally became simple and clean. Let‚Äôs go through those steps:</p>



<div>
    <div>
        <div>

    <h2>Day 1: Simple and messy</h2>

<p>My intuition for any list or sequence in Dreams was to use a Selector. It has up to 10 output ports, and can step from one state to the next. Sounds like what I need! By using the selector to power other nodes, I can use this to step through a list of values. This structure worked well and I used it every day, but the challenge is automatically stepping to the next item.</p>

<p>I originally structured my logic like so: do stuff with the current values, and then send a wire back around to ‚ÄúMove to Next Output‚Äù to continue. The problem, though, is that Next Output is never powered off - and when the signal is always high, we don‚Äôt keep stepping.</p>

<p>I fixed this on Day 1 by wedging a timer onto Next Output. The logic for resetting this was annoying and fragile, but I got by.</p>

<p>I also had issues where I would step to the next port <em>before</em> the current port had finished processing. Dreams doesn‚Äôt have a clear notion of execution order, so when you have cycles in the graph, execution doesn‚Äôt always start where you want it to start. In this case, I wasn‚Äôt reliably processing the first item in the list.</p>

<p>I hacked my way through Day 1, but after sleeping on it, I had some good ideas that would help me in Day 2.</p>


        </div>
        
    </div>
</div>



<div>
    <div>
        <div>

    <h2>Day 2: Complex and messy</h2>

<p>My core insight for Day 2 was to have two distinct phases when iterating: <em>using</em> a value, and <em>stepping</em> to the next value. In a system with unclear execution order, it‚Äôs dangerous to process an item and step to the next item on the same frame. It‚Äôs not <em>exactly</em> a race condition, but it feels like one.</p>

<p>My idea was to have a clock ticking high, low, high, low on some interval - when it‚Äôs high, use the current value, when it‚Äôs low, step to the next. I implemented this with a Signal Generator like so.</p>

<p>This worked for Day 2‚Äôs relatively simple problem. I would not be so lucky on Day 3.</p>


        </div>
        
    </div>
</div>



<div>
    <div>
        <div>

    <h2>Day 3: More complex, more messy</h2>

<p>Day 3 introduced a new wrinkle: nested iterators.</p>

<p>Suddenly my clock-based scheme started to break down. The outer iterator needed to step only when the inner one finished. Furthermore, I needed to reset the inner one when the outer one stepped. To accommodate this, I pulled the Signal Generator out of the iterator and replaced it with a Next input. When high, step, when low, use. I also made the iterator aware of the total number of items so it could output a Done signal; this was necessary for the inner iterator to tell the outer iterator to step.</p>

<p>This added a lot of complexity, and it took two solid hours of debugging to get the inner iterator to reset correctly. Functionally, though, this was an improvement. The iterator was now more ‚Äúpure‚Äù, a state machine with no internal timers, whose behavior depended entirely on the signals fed into it.</p>


        </div>
        
    </div>
</div>



<div>
    <div>
        <div>

    <h2>Day 5: Execution order interlude</h2>

<p>My iterator would serve me reasonably well for the next several days. The one big exception was when Day 5‚Äôs solution was plagued by heisenbugs, and were eventually ‚Äúfixed‚Äù by‚Ä¶removing a single wire.</p>

<p>Basically, I had put myself in cycle hell. As mentioned, Dreams doesn‚Äôt have a clear execution order, especially when you have cycles in your graph. As my program got more complicated, and my cycles got larger, my logic became more likely to start execution ‚Äúin the middle‚Äù, yielding seemingly impossible results. At one point, I replaced one wire with a hardcoded value slider of the same value - and all my problems fixed themselves. This led to a rant (see video).</p>

<p>My fix for this was to use Wireless Transmitters to send the Next signal to my iterator. Wireless Transmitters do not cause cycles in the graph, and according to someone in my Twitch chat, always incur a one-frame delay. This is good for me; it allows me to suggest an execution order. I would use this technique every day going forward, and it did reduce the number of cycle-based heisenbugs.</p>


        </div>
        <div>

    
<p>
    
    
        
    
    <iframe src="https://www.youtube-nocookie.com/embed/-Q7v_M2aOS4?start=7725&amp;enablejsapi=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</p>


        </div>
    </div>
</div>


<h2>Day 10: Simple and clean</h2>

<p>I struggled through several more days with my iterator, and kept running into problems. Resetting in particular was a huge headache - I discovered that my logic would break if I fired Reset while Next was high. The internal ‚Äúmemory cell‚Äù that was storing the current iteration value also occasionally heisenbugged, storing nonsensical values. These issues regularly lost me at least an hour a day, and I was getting pretty demoralized.</p>

<p>The Iterator was also so complex that I could hardly understand it. At one point, Eric Wastl (the creator of Advent of Code) remarked in my chat that I needed a <a href="https://en.wikipedia.org/wiki/Logic_analyzer">logic analyzer</a>, like you would use with real electronics.</p>

<p>Sometime between Day 9 and Day 10, though, I had a horrifying realization: I had basically just reinvented the built-in Counter widget.</p>

<p>My iterator had a Total, a Next, and a Reset. The Counter has a Target Value, a Next, and a Reset. My Iterator output Done when the count reached the Total. The Counter outputs Done when the count reaches the Target Value. The only thing the Counter didn‚Äôt have was the Use/Next split.</p>

<p>On Day 10, I started with a Counter and added a tiny amount of wrapper logic. In minutes, I had perfectly recreated my old Iterator with none of the bugs:</p>

<div>
    
<p>
    
    
        
    
    <iframe src="https://www.youtube-nocookie.com/embed/mJE1MYBw4eY?start=623&amp;enablejsapi=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</p>

</div>

<p>I made zero modifications to this iterator for the rest of the challenge. It was perfect. And I was so annoyed with myself.</p>

<h2>How did this happen?</h2>

<p>I had drifted toward the Counter design so slowly that I didn‚Äôt realize it. I started with a selector and no explicit counter, then transitioned to a clock, then added the inner counter, and then removed the clock. The Counter, though, didn‚Äôt have the Use/Next split, which is why I didn‚Äôt think to use it earlier.</p>

<p>In the end, there were two good ideas that I had to discover:</p>

<ul>
<li>Separate Use and Next into two mutually exclusive states to avoid same-frame bugs.</li>
<li>Drive the logic manually instead of using an internal clock. Timers belong at the highest level of your logic, never hidden inside other widgets.</li>
</ul>

<p>Both of these ideas apply broadly to programming in Dreams, so let‚Äôs break them down.</p>



<h2>Lesson 1: Make logic mutually exclusive</h2>

<p>Tons of bugs boiled down to two nodes being active at the same time, when they shouldn‚Äôt have been. Early on, I tried to fix this ad-hoc with lots of AND gates powering specific nodes. Later on, though, I realized that grouping logic into Microchips not only helped me organize my logic, but actually fixed bugs too.</p>



<div>
    <div>
        <div>

    <p>Putting logic in Microchips allows you to power entire chunks of your program on and off. Instead of running logic and then randomly suppressing some results, you can simply <em>not run the logic</em>. I think this actually fixes a lot of heisenbugs by ensuring that all the wires are zero on the first frame each widget is active. The more I used power in this way, the more I liked my logic and the fewer bugs I encountered. I developed a mantra: ‚Äúdon‚Äôt use an AND gate, use power instead‚Äù.</p>

<p>This way of thinking is probably old news to those more experienced with Dreams, and here‚Äôs why: the Timeline node, which is used for all animation, sound, and fancy sequencing in Dreams, literally just powers nodes on and off. Someone on Mastodon <a href="https://mastodon.nz/@flashmedallion/109539143131376443">remarked to me</a> that ‚Äútimelines = scripts‚Äù, and it blew my mind.[3]</p>


        </div>
        
    </div>
</div>






<p>In the end, what matters is making major chunks of logic mutually exclusive. Whether you use Timelines or power things manually, you will benefit from isolating them in this way. Your logic will be easier to follow and you will avoid heisenbugs. It takes practice, but Dreams is well-designed, so well-structured logic actually does feel better. You‚Äôll know it when you see it.</p>

<h2>Lesson 2: Use timers, but keep them out of core logic</h2>

<p>One of the most influential programming talks I‚Äôve seen is Gary Bernhardt‚Äôs <a href="https://www.destroyallsoftware.com/talks/boundaries">Boundaries</a>, in which he advocates for programs to be structured with a ‚Äúfunctional core‚Äù and ‚Äúimperative shell‚Äù. Keep your program‚Äôs core logic pure and functional, free of side effects, and push the messy (but necessary) imperative logic to the outside. Keep the core code free of side effects so it‚Äôs trustworthy and predictable, and your leaf code can be as messy as it wants to be.</p>

<p>In retrospect, that advice applies to Dreams just as much as any other programming environment. A Dreams project needs core logic and gameplay systems, but also needs delays and animations and time for physics objects to settle.</p>

<p>At first, I wrote my logic without timers. But this led to same-frame execution issues, and it was difficult to visualize my logic in the world. Then I put timers all over the place, but every time I put a timer inside some ‚Äúreusable‚Äù logic, it would later blow up on me. My iterator is the perfect example; first it did all the work at once (and was buggy), then I gave it an internal clock (which was buggy), and eventually it was a pure state machine (that worked reliably).</p>

<p>‚ÄúPurity‚Äù in Dreams logic isn‚Äôt exactly the same as ‚Äúpure functions‚Äù in programming; I don‚Äôt know if functional programmers would consider any state machine to be ‚Äúpure‚Äù. But Dreams is, at its heart, a bunch of state machines talking to each other[4]. If you want something to be reusable, keep side effects out of it.</p>






<div>
    <picture>
        <source srcset="https://bvisness.me/advent-of-dreams/calendar.jpg?fmt=image%2Fjpeg&amp;orig=3&amp;scale=1 1x, https://bvisness.me/advent-of-dreams/calendar.jpg?fmt=image%2Fjpeg&amp;orig=3&amp;scale=2 2x, https://bvisness.me/advent-of-dreams/calendar.jpg?fmt=image%2Fjpeg&amp;orig=3&amp;scale=3 3x" type="image/jpeg"/><img src="https://bvisness.me/advent-of-dreams/calendar.jpg"/>
    </picture>
</div>



<p>I‚Äôm really glad I did this challenge. My overall impressions of Dreams are still very positive. I‚Äôm genuinely delighted by how easy it is to kit-bash beautiful scenes together. I‚Äôm amazed by the quality and variety of material on the Dreamiverse. And I still think the logic system is brilliant.</p>

<p>But obviously I struggled to do things that would be simple in a ‚Äúreal‚Äù programming environment. I put together a <a href="https://docs.google.com/spreadsheets/d/1OxQt5dfEQDIFmq0UrSU165OSiUTbr-DVdft1_naV9ms/edit?usp=sharing">spreadsheet</a> tracking my times in Dreams vs. my times in JavaScript[5], and I was generally about 15x faster in JS. Even if you account for the time spent just thinking about the problem, and the time spent fixing bugs instead of ‚Äúreally programming‚Äù, this is still a staggering difference.</p>



<p>So let&#39;s break down what I liked, what I disliked, and what I think Dreams is good at.</p>

<p><b>What I like:</b> Programming in Dreams is very <em>tangible</em>. And not because the code sprawls across my screen, but because it‚Äôs associated with the data it manipulates in a very real way. It‚Äôs <em>embodied</em>. There is really no boundary between the code and the world, and this allows for some wonderful workflows. For example, there is no boundary between programming and debugging - if something is acting weird, you can simply pause time, open the logic, and probe widgets and wires to see what state they‚Äôre in. Tweak the logic on the fly and resume again. It‚Äôs blissfully iterative and doesn‚Äôt require you to learn any additional tools, e.g. a time-travel debugger or a <a href="https://whitebox.systems/">Whitebox</a>. This is exactly how scripting should be.</p>

<p>Plus, every feature of Dreams is just so tightly designed. It‚Äôs one of the most thoughtful systems I‚Äôve ever used. The logic system can be simple because the rest of the engine is so carefully designed. It‚Äôs an incredibly coherent experience.</p>

<p><b>What I dislike:</b> Like I said, I&#39;m horribly unproductive compared to traditional programming, and it&#39;s hard to imagine ever closing a 15x productivity gap. The logic system is great for orchestrating high-level game behaviors but bad for building systems. Advanced Dreams programming feels like working with electronics - instead of high-level programming constructs, I&#39;ve got a bunch of wires, transistors, and an oscilloscope. (I mean, units of logic are literally called Microchips.) This is not the level of abstraction I like to work at.</p>

<p>On the other hand, I was able to go from a working implementation to a great visualization in <em>minutes</em>. The connection between Dreams logic and Dreams objects is so seamless that it‚Äôs trivial to visualize your program in pleasant ways. This part of Dreams works extremely well.</p>

<p>So in an ideal world, I think I would like to write my own nodes. Instead of making my state machines with faux electronics, I‚Äôd like to actually write them in a more powerful language. Then I could tie them together with Dreams‚Äôs lovely scripting system and game engine. I legitimately think that this could be an <em>incredibly</em> powerful way to program.</p>

<p><b>What is Dreams good at?</b> Simulation. All the best programs were the ones that could take advantage of the 3D, physical world the code lives in. The ones that work more abstractly with data, e.g. navigating a filesystem or solving optimization problems, are hard to represent in Dreams at all. It&#39;s possible that things would be different if the system somehow supported lists, and recursion, and more advanced forms of data, but Dreams is fundamentally built for simulation, not number-crunching.</p>

<p><b>Do I recommend Dreams?</b> Absolutely yes! It&#39;s just so much fun. I did this challenge because I wanted to find the boundaries of Dreams&#39;s logic system. I think I found those boundaries. I certainly won&#39;t boot up my PlayStation next time I need to solve a dynamic programming problem. But I have come away really inspired about <em>scripting</em>, and concurrent programming, and the things you can achieve with a tightly-integrated system. This is where Dreams shines, and I cannot recommend it enough.</p>


<div>
    <picture>
        <source srcset="https://bvisness.me/advent-of-dreams/imp.png?fmt=image%2Fpng&amp;orig=2&amp;scale=1 1x, https://bvisness.me/advent-of-dreams/imp.png?fmt=image%2Fpng&amp;orig=2&amp;scale=2 2x" type="image/png"/><source srcset="https://bvisness.me/advent-of-dreams/imp.png?fmt=image%2Fwebp&amp;orig=2&amp;scale=1 1x, https://bvisness.me/advent-of-dreams/imp.png?fmt=image%2Fwebp&amp;orig=2&amp;scale=2 2x" type="image/webp"/><img src="https://bvisness.me/advent-of-dreams/imp.png"/>
    </picture>
</div>



<p>Obviously a huge thanks to Media Molecule for dedicating the last 15 years to this weird, wonderful system. It‚Äôs a miracle that Dreams exists at all, and it‚Äôs all because of the LittleBigPlanet series, the studio‚Äôs technical prowess, and their incredible dedication to user-created content.</p>

<p>Thanks to various members of the Dreams community for hanging out in my stream, and a particular thanks to <a href="https://tapgiles.com/">TAPgiles</a> for his Dreams documentation and tutorials.</p>

<p>Thanks to the Handmade community for the years of discussion about visual programming, in particular <a href="https://gist.github.com/d7samurai">d7</a> for his imagination and relentless dissatisfaction with the status quo.</p>

<p>And thank you for reading! üôÇ</p>





    </article>

        </div></div>
  </body>
</html>
