<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.orioledb.com/blog/orioledb-beta7-benchmarks">Original</a>
    <h1>OrioleDB beta7: Benchmarks</h1>
    
    <div id="readability-page-1" class="page"><div id="__blog-post-container"><p>OrioleDB is a <strong>storage extension for PostgreSQL</strong> which uses PostgreSQL&#39;s pluggable storage system. Designed as a drop-in replacement for PostgreSQL&#39;s existing Heap storage, OrioleDB aims to overcome scalability bottlenecks and fully utilize modern hardware capabilities. By integrating seamlessly with PostgreSQL, it offers improved performance, efficiency, and scalability without sacrificing the robustness and reliability that PostgreSQL is known for.</p>
<p>Today we’re releasing OrioleDB version <a href="https://github.com/orioledb/orioledb/releases/tag/beta7" target="_blank" rel="noopener noreferrer">beta7</a>. This marks a significant step in delivering a high-performance, next-generation storage engine for Postgres users. OrioleDB is designed to extract the full potential of modern hardware, offering superior performance, efficiency, and scalability.</p>
<h2 id="orioledb-design-choices">OrioleDB design choices<a href="#orioledb-design-choices" aria-label="Direct link to OrioleDB design choices" title="Direct link to OrioleDB design choices">​</a></h2>
<p>OrioleDB is built from the ground up to leverage modern hardware, reduce maintenance needs, and enhance distributed capabilities. The key technical decisions forming the foundation of OrioleDB are:</p>
<ol>
<li><strong>Elimination of Buffer Mapping and Lock-less Page Reading</strong>: In OrioleDB, in-memory pages are directly linked to storage pages, eliminating the need for buffer mapping and its associated bottlenecks. Additionally, in-memory page reading is performed without atomic operations, enabling lock-less access. Together, these design choices significantly elevate vertical scalability for PostgreSQL.</li>
<li><strong>MVCC Based on the UNDO Log Concept</strong>: OrioleDB employs a Multi-Version Concurrency Control (MVCC) mechanism based on an undo log. Old versions of tuples are evicted into undo logs—forming undo chains—rather than causing bloat in the main storage system. Page-level undo records allow the system to promptly reclaim space occupied by deleted tuples. Combined with page merging, these mechanisms eliminate bloat in most cases. As a result, dedicated vacuuming of tables is unnecessary, removing a common cause of system performance degradation and database outages.</li>
<li><strong>Copy-on-Write Checkpoints and Row-Level WAL</strong>: OrioleDB utilizes copy-on-write checkpoints to provide structurally consistent snapshots of data at all times. This approach is friendly to modern SSDs and enables row-level Write-Ahead Logging (WAL). Row-level WAL is easy to parallelize (already implemented), compact, and suitable for active-active multi-master configurations (planned).</li>
</ol>
<h2 id="benchmarking-orioledb-vs-postgresql-heap">Benchmarking OrioleDB vs PostgreSQL Heap<a href="#benchmarking-orioledb-vs-postgresql-heap" aria-label="Direct link to Benchmarking OrioleDB vs PostgreSQL Heap" title="Direct link to Benchmarking OrioleDB vs PostgreSQL Heap">​</a></h2>
<p>To illustrate the performance characteristics of OrioleDB we used <a href="https://github.com/pingcap/go-tpc" target="_blank" rel="noopener noreferrer">TPC-C benchmarking</a>, a complex test simulating real database workloads that is considered a modern standard in database applications.</p>
<!-- -->
<h3 id="tpc-c-warehouses">TPC-C Warehouses<a href="#tpc-c-warehouses" aria-label="Direct link to TPC-C Warehouses" title="Direct link to TPC-C Warehouses">​</a></h3>
<p>TPC-C measures data volume in “<em>warehouses</em>”: 1 warehouse takes about 100 MB. We ran the benchmarks at various sizes to measure the performance of OrioleDB compared to default Postgres heap tables.</p>
<h3 id="benchmark-100-warehouses">Benchmark: 100 warehouses<a href="#benchmark-100-warehouses" aria-label="Direct link to Benchmark: 100 warehouses" title="Direct link to Benchmark: 100 warehouses">​</a></h3>
<p>100 warehouses mainly highlights the WAL-insertion bottleneck. OrioleDB tested 2.3x faster then heap:</p>
<p><img decoding="async" loading="lazy" alt="Benchmarked on a 64-core virtual machine c7g.metal with 20Gb of RAM allocated as shared buffers." src="https://www.orioledb.com/assets/images/tpc-c-100-4b41df19ef2026f623bedcef18f1fdf4.png" width="1596" height="982"/></p>
<p>Benchmarked on a 64-core virtual machine c7g.metal with 20Gb of RAM allocated as shared buffers.</p>
<h3 id="benchmark-500-warehouses">Benchmark: 500 warehouses<a href="#benchmark-500-warehouses" aria-label="Direct link to Benchmark: 500 warehouses" title="Direct link to Benchmark: 500 warehouses">​</a></h3>
<p>500 warehouses highlights the shared memory cache bottleneck. OrioleDB tested 5.5x faster than heap:</p>
<p><img decoding="async" loading="lazy" alt="Benchmarked on a 64-core virtual machine c7g.metal with 20Gb of RAM allocated as shared buffers." src="https://www.orioledb.com/assets/images/tpc-c-500-32fe5f831f20b52b28133eafc4125a81.png" width="1600" height="974"/></p>
<p>Benchmarked on a 64-core virtual machine c7g.metal with 20Gb of RAM allocated as shared buffers.</p>
<h3 id="benchmark-1000-warehouses">Benchmark: 1000 warehouses<a href="#benchmark-1000-warehouses" aria-label="Direct link to Benchmark: 1000 warehouses" title="Direct link to Benchmark: 1000 warehouses">​</a></h3>
<p>OrioleDB implements index-organized tables providing better data locality when compared with Postgres’s default heap-organized tables. In cases where data do not fit in the OS’s memory cache this optimization improves throughput by reducing disk IO. This is visible in the results of TPC-C with 1000 warehouses, which did not fit in OS cache memory on the target hardware.</p>
<p>Larger than OS memory cases would require a lot of IO and typically it’s good to use local SSD with low latency and high throughput for big clusters like this (100GB with often updates of all data). So we did in the test.</p>
<p>OrioleDB tested 2.7x faster than heap:</p>
<p><img decoding="async" loading="lazy" alt="Benchmarked on a 64-core virtual machine c7gd.metal with 20Gb of RAM allocated as shared buffers." src="https://www.orioledb.com/assets/images/tpc-c-1000-9ba6f43c8fb46cef35f2ea3d7088074c.png" width="1588" height="970"/></p>
<p>Benchmarked on a 64-core virtual machine c7gd.metal with 20Gb of RAM allocated as shared buffers.</p>
<h3 id="other-optimizations">Other optimizations<a href="#other-optimizations" aria-label="Direct link to Other optimizations" title="Direct link to Other optimizations">​</a></h3>
<p>There are additional OrioleDB improvement, not covered by these benchmarks, but still important:</p>
<ul>
<li>Builtin compression reducing storage footprint up to 5x in typical cases,</li>
<li><a href="https://www.orioledb.com/blog/no-more-vacuum-in-postgresql" target="_blank" rel="noopener noreferrer">UNDO log</a>, which avoids bloat and eliminates the need for VACUUM,</li>
<li>Removal of the <a href="https://about.gitlab.com/blog/2021/09/29/why-we-spent-the-last-month-eliminating-postgresql-subtransactions/" target="_blank" rel="noopener noreferrer">sub-transaction hazard</a>.</li>
</ul>
<h2 id="try-it-yourself">Try it yourself<a href="#try-it-yourself" aria-label="Direct link to Try it yourself" title="Direct link to Try it yourself">​</a></h2>
<ul>
<li>
<p><strong>Install OrioleDB</strong></p>
<p>You can install OrioleDB by <a href="https://github.com/orioledb/orioledb#installation" target="_blank" rel="noopener noreferrer">following the instructions on GitHub</a> for building from source or using Docker.</p>
<p>Alternatively, you can run OrioleDB on Supabase. OrioleDB was released in Public Alpha on the Supabase platform for testing purposes and is not suitable for production use cases yet. Read the <a href="https://supabase.com/blog/orioledb-launch" target="_blank" rel="noopener noreferrer">blog post</a> for more details.</p>
</li>
<li>
<p><strong>Use OrioleDB for Your Tables</strong></p>
<p>To utilize OrioleDB for your tables, add <code>USING orioledb</code> to your table&#39;s Data Definition Language (DDL) statement:</p>
<div><div><pre tabindex="0"><code><span><span>CREATE</span><span> </span><span>TABLE</span><span> my_table </span><span>(</span><span></span><br/></span><span><span>    id </span><span>SERIAL</span><span> </span><span>PRIMARY</span><span> </span><span>KEY</span><span>,</span><span></span><br/></span><span><span>    </span><span>data</span><span> </span><span>TEXT</span><span></span><br/></span><span><span></span><span>)</span><span> </span><span>USING</span><span> orioledb</span><span>;</span><br/></span></code></pre></div></div>
<p>For more detailed instructions, refer to the <a href="https://www.orioledb.com/docs/usage/getting-started" target="_blank" rel="noopener noreferrer">OrioleDB Getting Started Guide</a>.</p>
<p>Alternatively, you can set the <code>default_table_access_method</code> configuration parameter to <code>orioledb</code> in PostgreSQL. This will make OrioleDB the default storage engine for all new tables:</p>
<div><div><pre tabindex="0"><code><span><span>SET</span><span> default_table_access_method </span><span>=</span><span> </span><span>&#39;orioledb&#39;</span><span>;</span><br/></span></code></pre></div></div>
<p>For more information, see the PostgreSQL documentation on <a href="https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-DEFAULT-TABLE-ACCESS-METHOD" target="_blank" rel="noopener noreferrer">default_table_access_method</a>.</p>
</li>
<li>
<p><strong>Perform Testing</strong></p>
<p>Feel free to test OrioleDB using your own workload or by employing well-known benchmarking tools like <a href="https://github.com/pingcap/go-tpc" target="_blank" rel="noopener noreferrer">go-tpc</a>, <a href="https://www.hammerdb.com/" target="_blank" rel="noopener noreferrer">HammerDB</a>, or others. These tools can help you assess the performance and scalability of OrioleDB under various scenarios.</p>
</li>
</ul>
<h2 id="our-vision-for-orioledb">Our Vision for OrioleDB<a href="#our-vision-for-orioledb" aria-label="Direct link to Our Vision for OrioleDB" title="Direct link to Our Vision for OrioleDB">​</a></h2>
<p>We&#39;re not just building a better storage engine; we&#39;re envisioning the future of PostgreSQL in the cloud era.</p>
<h3 id="the-go-to-postgresql-storage-engine">The Go-To PostgreSQL Storage Engine<a href="#the-go-to-postgresql-storage-engine" aria-label="Direct link to The Go-To PostgreSQL Storage Engine" title="Direct link to The Go-To PostgreSQL Storage Engine">​</a></h3>
<p>We envision OrioleDB becoming the default choice for PostgreSQL, replacing Heap. There&#39;s precedent for such a shift in the database world. MySQL&#39;s adoption of InnoDB and MongoDB&#39;s switch to WiredTiger over MMAPv1 are prime examples of storage engines transforming their respective ecosystems.</p>
<h3 id="decoupled-storage-and-compute">Decoupled Storage and Compute<a href="#decoupled-storage-and-compute" aria-label="Direct link to Decoupled Storage and Compute" title="Direct link to Decoupled Storage and Compute">​</a></h3>
<p>We are implementing OrioleDB bottomless storage with an S3 integration. This decoupled architecture allows for virtually unlimited storage capacity while enabling scalable compute resources. It paves the way for more flexible and resilient database deployments.</p>
<h3 id="open-source-serverless-postgresql">Open-Source Serverless PostgreSQL<a href="#open-source-serverless-postgresql" aria-label="Direct link to Open-Source Serverless PostgreSQL" title="Direct link to Open-Source Serverless PostgreSQL">​</a></h3>
<p>We&#39;re committed to keeping OrioleDB fully open-source and PostgreSQL-licensed. Our goal is to provide a storage engine that is fast, serverless, self-hostable, and pure Postgres, in contrast &#34;PostgreSQL-compatible&#34; databases like Amazon Aurora. A modern storage engine without vendor lock-in.</p>
<h3 id="hybrid-workloads-with-columnar-indexes">Hybrid Workloads with Columnar Indexes<a href="#hybrid-workloads-with-columnar-indexes" aria-label="Direct link to Hybrid Workloads with Columnar Indexes" title="Direct link to Hybrid Workloads with Columnar Indexes">​</a></h3>
<p>We plan to introduce a <code>columnar</code> index type, enabling efficient handling of analytical workloads alongside transactional operations. This hybrid approach means you no longer need separate systems for OLTP (online transactional processing) and OLAP (online analytical processing) workloads.</p>
<h3 id="multi-master-replication">Multi-Master Replication<a href="#multi-master-replication" aria-label="Direct link to Multi-Master Replication" title="Direct link to Multi-Master Replication">​</a></h3>
<p>Our roadmap includes support for multi-master configurations, enhancing availability and fault tolerance. This will allow for read and write operations across multiple nodes, improving performance and resilience.</p>
<h2 id="current-limitations">Current Limitations<a href="#current-limitations" aria-label="Direct link to Current Limitations" title="Direct link to Current Limitations">​</a></h2>
<p>While OrioleDB offers significant advantages, it&#39;s important to be aware of its current limitations existing at the moment of beta7 release.</p>
<ul>
<li><strong>Index Support</strong>: Currently, only B-tree indexes are supported, which means features like <code>pg_vector</code>&#39;s HNSW indexes are not yet available. We are actively working on an Index Access Method bridge to support all index types available for heap storage.</li>
<li><strong>Prepared Transactions:</strong> Currently, prepared transactions are not supported for transactions involving OrioleDB tables.</li>
<li><strong>REINDEX CONCURRENTLY:</strong> This command is currently not supported for indexes over OrioleDB tables.</li>
</ul>
<p>The work on the items above will be completed before the project is released in General Availability (GA) in 2025. A full list of limitations can be found <a href="https://www.orioledb.com/docs/usage/getting-started#current-limitations" target="_blank" rel="noopener noreferrer">in the docs</a>.</p>
<h2 id="get-involved">Get Involved<a href="#get-involved" aria-label="Direct link to Get Involved" title="Direct link to Get Involved">​</a></h2>
<p>We&#39;re excited about the possibilities OrioleDB brings to the PostgreSQL ecosystem and invite you to join us on this journey. Please try OrioleDB and share your experience and your expectations for the new functionality in GitHub <a href="https://github.com/orioledb/orioledb/issues" target="_blank" rel="noopener noreferrer">issues</a> and <a href="https://github.com/orioledb/orioledb/discussions" target="_blank" rel="noopener noreferrer">discussions</a>.</p>
<p>If you are a PostgreSQL provider and you want to support OrioleDB on your platform, reach out: we’d love to have more design partners. The OrioleDB team would love to collaborate with other hosting providers.</p></div></div>
  </body>
</html>
