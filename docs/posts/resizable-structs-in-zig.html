<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tristanpemble.com/resizable-structs-in-zig/">Original</a>
    <h1>Resizable Structs in Zig</h1>
    
    <div id="readability-page-1" class="page"><div><p><time datetime="2025-07-26T00:00:00+00:00">July 26, 2025</time></p><p>In this post I will make the case for the concept of a “runtime resizable struct” in Zig. I will then design an API by exploiting Zig’s powerful comptime functionality.</p><p>If you want to skip straight to the implementation, a minimal proof of concept is <a href="https://github.com/tristanpemble/resizable-struct">available as a package on GitHub</a>.</p><h2 id="arrays-and-many-item-pointers"><a aria-label="Anchor link for: arrays-and-many-item-pointers" href="#arrays-and-many-item-pointers">Arrays and many-item pointers</a></h2><p>Zig has support for many kinds of collection types in its standard library. All of them can broadly be broken down to two primitive backing types for contiguous data storage:</p><ul><li><code>[N]T</code> – <a href="https://ziglang.org/documentation/master/#Arrays">arrays</a>, when you <em>always</em> know the length at compile time.</li><li><code>[*]T</code> – <a href="https://ziglang.org/documentation/master/#toc-Pointers">many-item pointers</a>, when you <em>may not</em> know the length at compile time.</li></ul><p>You may be wondering about slices. <a href="https://ziglang.org/documentation/master/#Slices">Slices</a> can be thought of as syntax sugar around a many-item pointer and a length:</p><pre data-lang="zig"><code data-lang="zig"><span>// A desugared slice type
</span><span>const </span><span>PersonSlice </span><span>= struct </span><span>{
</span><span>    </span><span>ptr</span><span>: [</span><span>*</span><span>]</span><span>Person</span><span>,
</span><span>    </span><span>len</span><span>: </span><span>usize</span><span>,
</span><span>};
</span></code></pre><p>Once you allocate the slice, you can’t grow or shrink its memory without reallocating. That’s why we have <a href="https://ziglang.org/documentation/master/#std.ArrayList"><code>std.ArrayList</code></a>, which is just a wrapper around a slice (itself sugar for many-item pointers) that provides helpers to manage reallocating that slice:</p><pre data-lang="zig"><code data-lang="zig"><span>// A naive ArrayList implementation
</span><span>const </span><span>PersonList </span><span>= struct </span><span>{
</span><span>    </span><span>items</span><span>: []</span><span>Person</span><span>,
</span><span>
</span><span>    </span><span>pub fn </span><span>append</span><span>(</span><span>self</span><span>: </span><span>PersonArrayList</span><span>, </span><span>allocator</span><span>: </span><span>Allocator</span><span>, </span><span>person</span><span>: </span><span>Person</span><span>) </span><span>!void </span><span>{
</span><span>        self.items </span><span>= try</span><span> allocator.</span><span>realloc</span><span>(self.items, self.items.len </span><span>+ </span><span>1</span><span>);
</span><span>        self.items[self.items.len] </span><span>=</span><span> person;
</span><span>    }
</span><span>};
</span></code></pre><p>We can build up lots of interesting collection types with these primitives, but at the end of the day, we have <strong>arrays</strong>, <strong>many-item pointers</strong>, and <strong>slices</strong> (which are just many-item pointers!). If the size is fixed at compile time, you’ll probably be working with arrays. If the size may be influenced by runtime values, you’ll probably be working with many-item pointers.</p><h2 id="structs"><a aria-label="Anchor link for: structs" href="#structs">Structs</a></h2><p>Arrays/pointers work well for contiguous storage of the <strong>same</strong> type, but a <a href="https://ziglang.org/documentation/master/#struct">struct</a> can be thought of as contiguous collection of <strong>different</strong> types:</p><pre data-lang="zig"><code data-lang="zig"><span>const </span><span>City </span><span>= struct </span><span>{
</span><span>    </span><span>name</span><span>: []</span><span>const u8</span><span>,
</span><span>    </span><span>population</span><span>: </span><span>u32</span><span>,
</span><span>    </span><span>area</span><span>: </span><span>f32</span><span>,
</span><span>};
</span></code></pre><p>It has a compile time known number of values, they have a compile time known size, and as a result, the size of the struct is known at compile time.</p><h2 id="the-problem"><a aria-label="Anchor link for: the-problem" href="#the-problem">The problem</a></h2><p>Let’s break down the three tools I outlined above for contiguous storage:</p><table><thead><tr><th>Tool</th><th>Elements</th><th>Size</th></tr></thead><tbody><tr><td>Arrays</td><td>Same</td><td>Comptime</td></tr><tr><td>Many-item pointers</td><td>Same</td><td>Runtime</td></tr><tr><td>Structs</td><td>Different</td><td>Comptime</td></tr><tr><td>???</td><td>Different</td><td>Runtime</td></tr></tbody></table><p>At this point, you’ll notice a missing piece – what if we want to access contiguously stored data, with differing types, but the size/length of that data is only known at runtime?</p><h2 id="a-use-case"><a aria-label="Anchor link for: a-use-case" href="#a-use-case">A use-case</a></h2><p>It’s fun to design tools for imaginary problems, but before we continue, is this really something that people need? I believe that it is. <a href="https://github.com/ziglang/zig/blob/8c4482ed78fb651c0288f0cd2bdaf328564c6a49/lib/std/http/Client.zig#L240-L359">Here is a snippet of code</a> in Zig’s standard library where such a thing might be useful.</p><h2 id="the-status-quo"><a aria-label="Anchor link for: the-status-quo" href="#the-status-quo">The status quo</a></h2><p>To do this today, you essentially have to take the following steps:</p><ol><li>Calculate the size of the data you need to store</li><li>Allocate a <code>[]u8</code> to store it in</li><li>Break up that byte slice into pieces for each field using a lot of <code>@ptrCast</code>/<code>@alignCast</code></li><li>Initialize the data in each field, making sure to keep track of all runtime lengths</li></ol><p>Here I have done so using a simplified version of the use-case from the standard library:</p><pre data-lang="zig"><code data-lang="zig"><span>// A known-size data structure
</span><span>const </span><span>Connection </span><span>= struct </span><span>{
</span><span>    </span><span>client</span><span>: </span><span>Client</span><span>,
</span><span>    </span><span>host_len</span><span>: </span><span>usize</span><span>,
</span><span>    </span><span>read_buffer_len</span><span>: </span><span>usize</span><span>,
</span><span>    </span><span>write_buffer_len</span><span>: </span><span>usize</span><span>,
</span><span>};
</span><span>
</span><span>// First, calculate the size of, and then allocate, a byte slice for the data
</span><span>const</span><span> length </span><span>= </span><span>calculateSizeAtRuntime</span><span>(input);
</span><span>const</span><span> bytes </span><span>= try</span><span> gpa.</span><span>alignedAlloc</span><span>(u8, </span><span>@alignOf</span><span>(Connection), length);
</span><span>
</span><span>// Then break up that byte slice into its components
</span><span>const </span><span>conn</span><span>: </span><span>*Connection = </span><span>@ptrCast</span><span>(bytes);
</span><span>
</span><span>const</span><span> host_offset </span><span>= </span><span>@sizeOf</span><span>(Connection);
</span><span>const</span><span> host </span><span>=</span><span> bytes[host_offset</span><span>..</span><span>][0</span><span>..</span><span>input.host_len];
</span><span>
</span><span>const</span><span> read_buffer_offset </span><span>=</span><span> host_offset </span><span>+</span><span> input.host_len;
</span><span>const</span><span> read_buffer </span><span>=</span><span> bytes[read_buffer_offset</span><span>..</span><span>][0</span><span>..</span><span>input.read_buffer_len];
</span><span>
</span><span>const</span><span> write_buffer_offset </span><span>=</span><span> read_buffer_offset </span><span>+</span><span> input.read_buffer_len;
</span><span>const</span><span> write_buffer </span><span>=</span><span> bytes[write_buffer_offset</span><span>..</span><span>][0</span><span>..</span><span>input.write_buffer_len];
</span><span>
</span><span>// Initialize the known-size data, storing runtime sizes
</span><span>conn</span><span>.* =</span><span> .{
</span><span>    .client </span><span>=</span><span> input.client,
</span><span>    .host_len </span><span>=</span><span> input.host_len,
</span><span>    .read_buffer_len </span><span>=</span><span> input.read_buffer_len,
</span><span>    .write_buffer_len </span><span>=</span><span> input.write_buffer_len,
</span><span>};
</span><span>
</span><span>// Initialize the runtime sized data
</span><span>@memcpy</span><span>(host, input.host);
</span></code></pre><p>Doing all of this correctly can be tricky. Even just the first step is more complex than you might think. In our example, the host and buffer fields are both arrays of <code>u8</code>s, but what if the elements have an alignment requirement? If your fields are not ordered correctly, subsequent fields may become unaligned if you don’t pad correctly. If you don’t track all of the lengths, you can accidentally introduce undefined behavior, and as a result, possible security vulnerabilities. Let alone resizing the thing if the lengths change later!</p><p>We can do better!</p><h2 id="variable-length-arrays"><a aria-label="Anchor link for: variable-length-arrays" href="#variable-length-arrays">Variable Length Arrays</a></h2><p>As an aside, some programming languages have a concept of <strong>variable length arrays</strong> (VLA). The idea is to have an array (stack allocated contiguous data) with a length that is known at runtime (it is variable).</p><p>Zig does not, <a href="https://github.com/ziglang/zig/issues/3952#issuecomment-568074491">and will not</a>, have VLAs in the language spec. Instead, you can allocate a slice on the heap. If you want to have the data on the stack, use an array as a bounded backing store, and work with a slice into it:</p><pre data-lang="zig"><code data-lang="zig"><span>// We have an upper limit of 32 values
</span><span>const </span><span>my_buffer</span><span>: [</span><span>32</span><span>]</span><span>u64 = </span><span>undefined</span><span>;
</span><span>const </span><span>my_vla</span><span>: []</span><span>u64 =</span><span> my_buffer[0</span><span>..</span><span>runtime_length];
</span></code></pre><h2 id="dreaming-up-an-api"><a aria-label="Anchor link for: dreaming-up-an-api" href="#dreaming-up-an-api">Dreaming up an API</a></h2><p>Variable length arrays don’t, and won’t, exist in Zig, but what if they did? We might have defined our <code>Connection</code> type something like this:</p><pre data-lang="zig"><code data-lang="zig"><span>const </span><span>Connection </span><span>= struct </span><span>{
</span><span>    </span><span>client</span><span>: </span><span>Client</span><span>,
</span><span>    </span><span>host</span><span>: </span><span>VariableLengthArray</span><span>(u8)
</span><span>    </span><span>read_buffer</span><span>: </span><span>VariableLengthArray</span><span>(u8),
</span><span>    </span><span>write_buffer</span><span>: </span><span>VariableLengthArray</span><span>(u8)
</span><span>};
</span></code></pre><p>Working with it would be a little easier, because we can just initialize the VLAs at runtime:</p><pre data-lang="zig"><code data-lang="zig"><span>const</span><span> conn </span><span>= Connection</span><span>{
</span><span>    .client </span><span>=</span><span> input.client,
</span><span>    .host </span><span>=</span><span> .</span><span>initWithSlice</span><span>(input.host),
</span><span>    .read_buffer </span><span>=</span><span> .</span><span>initWithCapacity</span><span>(input.read_buffer_len),
</span><span>    .write_buffer </span><span>=</span><span> .</span><span>initWithCapacity</span><span>(input.write_buffer_len),
</span><span>};
</span></code></pre><p>The VariableLengthArray type could handle the alignment of our data, and we can just focus on the data itself, accessing the fields directly:</p><pre data-lang="zig"><code data-lang="zig"><span>std.debug.</span><span>print</span><span>(</span><span>&#34;Host: {s}</span><span>\n</span><span>&#34;</span><span>, .{conn.host});
</span><span>const</span><span> reader </span><span>=</span><span> stream.</span><span>reader</span><span>(conn.read_buffer);
</span><span>const</span><span> writer </span><span>=</span><span> stream.</span><span>writer</span><span>(conn.write_buffer);
</span></code></pre><p>And yet, all of this data is stored contiguously in memory, without having to allocate each individual field separately!</p><h2 id="an-implementation"><a aria-label="Anchor link for: an-implementation" href="#an-implementation">An implementation</a></h2><p>We can actually achieve something sort of like this with some good ’ole Zig flavored comptime meta programming.</p><p>We’ll define two structs: a <code>ResizableArray(T)</code>, and a <code>ResizableStruct(Layout)</code> that uses them. The <code>ResizableArray(T)</code> will just be a marker type - such a thing, as far as I know, can’t actually exist in Zig. It’s used by the comptime code in <code>ResizableStruct(Layout)</code> to know which fields have runtime known lengths.</p><p>The <code>ResizableStruct(Layout)</code> will act as a utility type that makes working with pointers to each field easier. We’d use it like this:</p><pre data-lang="zig"><code data-lang="zig"><span>const</span><span> Connection </span><span>= </span><span>ResizableStruct</span><span>(</span><span>struct </span><span>{
</span><span>    </span><span>client</span><span>: </span><span>Client</span><span>,
</span><span>    </span><span>host</span><span>: </span><span>ResizableArray</span><span>(u8)
</span><span>    </span><span>read_buffer</span><span>: </span><span>ResizableArray</span><span>(u8),
</span><span>    </span><span>write_buffer</span><span>: </span><span>ResizableArray</span><span>(u8)
</span><span>});
</span><span>
</span><span>const</span><span> conn </span><span>= try</span><span> Connection.</span><span>init</span><span>(allocator, .{
</span><span>    .host </span><span>=</span><span> input.host_len,
</span><span>    .read_buffer </span><span>=</span><span> input.read_buffer_len,
</span><span>    .write_buffer </span><span>=</span><span> input.write_buffer_len,
</span><span>});
</span><span>defer</span><span> conn.</span><span>deinit</span><span>(allocator);
</span><span>
</span><span>const</span><span> client </span><span>=</span><span> conn.</span><span>get</span><span>(.client);
</span><span>client</span><span>.* =</span><span> input.client;
</span><span>
</span><span>const</span><span> host </span><span>=</span><span> conn.</span><span>get</span><span>(.host);
</span><span>@memcpy</span><span>(host, input.host);
</span><span>
</span><span>const</span><span> reader </span><span>=</span><span> stream.</span><span>reader</span><span>(conn.</span><span>get</span><span>(.read_buffer));
</span><span>const</span><span> writer </span><span>=</span><span> stream.</span><span>writer</span><span>(conn.</span><span>get</span><span>(.write_buffer));
</span><span>
</span><span>// We can resize the arrays later; this invalidates the above pointers.
</span><span>conn.</span><span>resize</span><span>(.{
</span><span>    .host </span><span>= </span><span>123</span><span>,
</span><span>    .read_buffer </span><span>= </span><span>456</span><span>,
</span><span>    .write_buffer </span><span>= </span><span>789</span><span>,
</span><span>});
</span></code></pre><p>The <code>Connection</code> becomes a utility type. It’s kind of like a <code>Slice</code>, or an <code>ArrayList</code>. It can be passed around, stored in arrays, and can be resized at runtime. The only information it needs to store is a pointer to the start of the data, and the lengths of each array. The backing implementation looks like this:</p><pre data-lang="zig"><code data-lang="zig"><span>const </span><span>Connection </span><span>= struct </span><span>{
</span><span>  </span><span>ptr</span><span>: [</span><span>*</span><span>]</span><span>u8</span><span>,
</span><span>  </span><span>lens</span><span>: </span><span>struct </span><span>{
</span><span>    </span><span>host</span><span>: </span><span>usize</span><span>,
</span><span>    </span><span>read_buffer</span><span>: </span><span>usize</span><span>,
</span><span>    </span><span>write_buffer</span><span>: </span><span>usize</span><span>,
</span><span>  }
</span><span>}
</span></code></pre><p>The only cost is four <code>usize</code>s! This works because we are able to use comptime magic to get the size of each field. Let’s take a look at the current implementation of the <code>get</code> method:</p><pre data-lang="zig"><code data-lang="zig"><span>pub fn </span><span>get</span><span>(</span><span>self</span><span>: </span><span>Self</span><span>, </span><span>comptime </span><span>field</span><span>: </span><span>FieldEnum</span><span>(</span><span>Layout</span><span>)) blk: {
</span><span>    </span><span>const</span><span> Field </span><span>= </span><span>@FieldType</span><span>(Layout, </span><span>@tagName</span><span>(field));
</span><span>    </span><span>break</span><span> :blk </span><span>if </span><span>(</span><span>isResizableArray</span><span>(Field)) []Field.Element </span><span>else *</span><span>Field;
</span><span>} {
</span><span>    </span><span>const</span><span> offset </span><span>= </span><span>offsetOf</span><span>(self.lens, </span><span>@tagName</span><span>(field));
</span><span>    </span><span>const</span><span> size </span><span>= </span><span>sizeOf</span><span>(self.lens, </span><span>@tagName</span><span>(field));
</span><span>    </span><span>const</span><span> bytes </span><span>=</span><span> self.ptr[offset</span><span>..</span><span>][0</span><span>..</span><span>size];
</span><span>
</span><span>    </span><span>return </span><span>@ptrCast</span><span>(</span><span>@alignCast</span><span>(bytes));
</span><span>}
</span></code></pre><p>Look familiar? This is the same basic pattern used in the example use-case when we broke up the byte array. The comptime magic comes in by examining <code>ResizableArray</code>. First, we can easily check if a field is resizable with a little helper function:</p><pre data-lang="zig"><code data-lang="zig"><span>pub fn </span><span>ResizableArray</span><span>(</span><span>comptime </span><span>T</span><span>: </span><span>type</span><span>) </span><span>type </span><span>{
</span><span>    </span><span>return struct </span><span>{
</span><span>        </span><span>pub const</span><span> Element </span><span>=</span><span> T;
</span><span>    };
</span><span>}
</span><span>
</span><span>fn </span><span>isResizableArray</span><span>(</span><span>comptime </span><span>T</span><span>: </span><span>type</span><span>) </span><span>bool </span><span>{
</span><span>    </span><span>return </span><span>@typeInfo</span><span>(T) </span><span>==</span><span> .@&#34;struct&#34; </span><span>and
</span><span>        </span><span>@hasDecl</span><span>(T, </span><span>&#34;Element&#34;</span><span>) </span><span>and
</span><span>        T </span><span>== </span><span>ResizableArray</span><span>(T.Element);
</span><span>}
</span></code></pre><p>Once we know <code>FieldType</code> is a <code>ResizableArray(T)</code>, we can then safely access <code>FieldType.Element</code>. With the array element types and the <code>self.lens</code> struct, we now have everything we need to calculate the size, offset and alignment of every field, regardless of their positioning in the struct.</p><p>I have published a minimal implementation of this API as a package <a href="https://github.com/tristanpemble/resizable-struct">on GitHub</a>, and you can use it today. The API docs are on <a href="https://tristanpemble.github.io/resizable-struct/">GitHub pages</a> as well, but they can be boiled down to four methods:</p><ul><li><code>init</code> to allocate the memory</li><li><code>get</code> to get a pointer to a field</li><li><code>resize</code> to resize the arrays</li><li><code>deinit</code> to free the memory</li></ul><h2 id="request-for-feedback"><a aria-label="Anchor link for: request-for-feedback" href="#request-for-feedback">Request for feedback</a></h2><p>I think this, or something like it, would be a valuable addition to Zig’s standard library, but it needs scrutiny. If you have a real world use-case for this type, I would love to hear about it. If you can think of enhancements to the API, feel free to open an issue on GitHub.</p></div></div>
  </body>
</html>
