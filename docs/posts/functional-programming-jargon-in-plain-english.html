<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/hemanth/functional-programming-jargon">Original</a>
    <h1>Functional programming jargon in plain English</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Functional programming (FP) provides many advantages, and its popularity has been increasing as a result. However, each programming paradigm comes with its own unique jargon and FP is no exception. By providing a glossary, we hope to make learning FP easier.</p>
<p dir="auto">Examples are presented in JavaScript (ES2015). <a href="https://github.com/hemanth/functional-programming-jargon/wiki/Why-JavaScript%3F">Why JavaScript?</a></p>
<p dir="auto">Where applicable, this document uses terms defined in the <a href="https://github.com/fantasyland/fantasy-land">Fantasy Land spec</a></p>
<p dir="auto"><strong>Translations</strong></p>
<ul dir="auto">
<li><a href="https://github.com/alexmoreno/jargoes-programacao-funcional">Portuguese</a></li>
<li><a href="https://github.com/idcmardelplata/functional-programming-jargon/tree/master">Spanish</a></li>
<li><a href="https://github.com/shfshanyue/fp-jargon-zh">Chinese</a></li>
<li><a href="https://github.com/wisn/jargon-pemrograman-fungsional">Bahasa Indonesia</a></li>
<li><a href="https://github.com/jmesyou/functional-programming-jargon.py">Python World</a></li>
<li><a href="https://github.com/ikhoon/functional-programming-jargon.scala">Scala World</a></li>
<li><a href="https://github.com/JasonShin/functional-programming-jargon.rs">Rust World</a></li>
<li><a href="https://github.com/sphilee/functional-programming-jargon">Korean</a></li>
<li><a href="https://github.com/Deloryn/functional-programming-jargon">Polish</a></li>
<li><a href="https://github.com/mrtkp9993/functional-programming-jargon">Haskell Turkish</a></li>
<li><a href="https://github.com/epogrebnyak/functional-programming-jargon">Haskell Russian</a></li>
</ul>
<p dir="auto"><strong>Table of Contents</strong></p>

<ul dir="auto">
<li><a href="#arity">Arity</a></li>
<li><a href="#higher-order-functions-hof">Higher-Order Functions (HOF)</a></li>
<li><a href="#closure">Closure</a></li>
<li><a href="#partial-application">Partial Application</a></li>
<li><a href="#currying">Currying</a></li>
<li><a href="#auto-currying">Auto Currying</a></li>
<li><a href="#function-composition">Function Composition</a></li>
<li><a href="#continuation">Continuation</a></li>
<li><a href="#pure-function">Pure Function</a></li>
<li><a href="#side-effects">Side effects</a></li>
<li><a href="#idempotent">Idempotent</a></li>
<li><a href="#point-free-style">Point-Free Style</a></li>
<li><a href="#predicate">Predicate</a></li>
<li><a href="#contracts">Contracts</a></li>
<li><a href="#category">Category</a></li>
<li><a href="#value">Value</a></li>
<li><a href="#constant">Constant</a>
<ul dir="auto">
<li><a href="#constant-function">Constant Function</a></li>
<li><a href="#constant-functor">Constant Functor</a></li>
<li><a href="#constant-monad">Constant Monad</a></li>
</ul>
</li>
<li><a href="#functor">Functor</a></li>
<li><a href="#pointed-functor">Pointed Functor</a></li>
<li><a href="#lift">Lift</a></li>
<li><a href="#referential-transparency">Referential Transparency</a></li>
<li><a href="#equational-reasoning">Equational Reasoning</a></li>
<li><a href="#lambda">Lambda</a></li>
<li><a href="#lambda-calculus">Lambda Calculus</a></li>
<li><a href="#lazy-evaluation">Lazy evaluation</a></li>
<li><a href="#monoid">Monoid</a></li>
<li><a href="#monad">Monad</a></li>
<li><a href="#comonad">Comonad</a></li>
<li><a href="#applicative-functor">Applicative Functor</a></li>
<li><a href="#morphism">Morphism</a>
<ul dir="auto">
<li><a href="#endomorphism">Endomorphism</a></li>
<li><a href="#isomorphism">Isomorphism</a></li>
<li><a href="#homomorphism">Homomorphism</a></li>
<li><a href="#catamorphism">Catamorphism</a></li>
<li><a href="#anamorphism">Anamorphism</a></li>
<li><a href="#hylomorphism">Hylomorphism</a></li>
<li><a href="#paramorphism">Paramorphism</a></li>
<li><a href="#apomorphism">Apomorphism</a></li>
</ul>
</li>
<li><a href="#setoid">Setoid</a></li>
<li><a href="#semigroup">Semigroup</a></li>
<li><a href="#foldable">Foldable</a></li>
<li><a href="#lens">Lens</a></li>
<li><a href="#type-signatures">Type Signatures</a></li>
<li><a href="#algebraic-data-type">Algebraic data type</a>
<ul dir="auto">
<li><a href="#sum-type">Sum type</a></li>
<li><a href="#product-type">Product type</a></li>
</ul>
</li>
<li><a href="#option">Option</a></li>
<li><a href="#function">Function</a></li>
<li><a href="#partial-function">Partial function</a></li>
<li><a href="#functional-programming-libraries-in-javascript">Functional Programming Libraries in JavaScript</a></li>
</ul>

<h2 dir="auto"><a id="user-content-arity" aria-hidden="true" href="#arity"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Arity</h2>
<p dir="auto">The number of arguments a function takes. From words like unary, binary, ternary, etc.</p>
<div data-snippet-clipboard-copy-content="const sum = (a, b) =&gt; a + b
// The arity of sum is 2 (binary)
const inc = a =&gt; a + 1
// The arity of inc is 1 (unary)
const zero = () =&gt; 0
// The arity of zero is 0 (nullary)"><pre><span>const</span> <span>sum</span> <span>=</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>b</span>
<span>// The arity of sum is 2 (binary)</span>
<span>const</span> <span>inc</span> <span>=</span> <span>a</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>1</span>
<span>// The arity of inc is 1 (unary)</span>
<span>const</span> <span>zero</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>0</span>
<span>// The arity of zero is 0 (nullary)</span></pre></div>
<p dir="auto"><strong>Further reading</strong></p>
<ul dir="auto">
<li><a href="https://en.wikipedia.org/wiki/Arity" rel="nofollow">Arity</a> on wikipedia.</li>
</ul>
<h2 dir="auto"><a id="user-content-higher-order-functions-hof" aria-hidden="true" href="#higher-order-functions-hof"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Higher-Order Functions (HOF)</h2>
<p dir="auto">A function which takes a function as an argument and/or returns a function.</p>
<div data-snippet-clipboard-copy-content="const filter = (predicate, xs) =&gt; xs.filter(predicate)"><pre><span>const</span> <span>filter</span> <span>=</span> <span>(</span><span>predicate</span><span>,</span> <span>xs</span><span>)</span> <span>=&gt;</span> <span>xs</span><span>.</span><span>filter</span><span>(</span><span>predicate</span><span>)</span></pre></div>
<div data-snippet-clipboard-copy-content="const is = (type) =&gt; (x) =&gt; Object(x) instanceof type"><pre><span>const</span> <span>is</span> <span>=</span> <span>(</span><span>type</span><span>)</span> <span>=&gt;</span> <span>(</span><span>x</span><span>)</span> <span>=&gt;</span> <span>Object</span><span>(</span><span>x</span><span>)</span> <span>instanceof</span> <span>type</span></pre></div>
<div data-snippet-clipboard-copy-content="filter(is(Number), [0, &#39;1&#39;, 2, null]) // [0, 2]"><pre><span>filter</span><span>(</span><span>is</span><span>(</span><span>Number</span><span>)</span><span>,</span> <span>[</span><span>0</span><span>,</span> <span>&#39;1&#39;</span><span>,</span> <span>2</span><span>,</span> <span>null</span><span>]</span><span>)</span> <span>// [0, 2]</span></pre></div>
<h2 dir="auto"><a id="user-content-closure" aria-hidden="true" href="#closure"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Closure</h2>
<p dir="auto">A closure is a scope which captures local variables of a function for access even after the execution has moved out of the block in which it is defined.
This allows the values in the closure to be accessed by returned functions.</p>
<div data-snippet-clipboard-copy-content="const addTo = x =&gt; y =&gt; x + y
var addToFive = addTo(5)
addToFive(3) // =&gt; 8"><pre><span>const</span> <span>addTo</span> <span>=</span> <span>x</span> <span>=&gt;</span> <span>y</span> <span>=&gt;</span> <span>x</span> <span>+</span> <span>y</span>
<span>var</span> <span>addToFive</span> <span>=</span> <span>addTo</span><span>(</span><span>5</span><span>)</span>
<span>addToFive</span><span>(</span><span>3</span><span>)</span> <span>// =&gt; 8</span></pre></div>
<p dir="auto">In this case the <code>x</code> is retained in <code>addToFive</code>&#39;s closure with the value <code>5</code>. <code>addToFive</code> can then be called with the <code>y</code>
to get back the sum.</p>
<p dir="auto"><strong>Further reading/Sources</strong></p>
<ul dir="auto">
<li><a href="http://stackoverflow.com/questions/220658/what-is-the-difference-between-a-closure-and-a-lambda" rel="nofollow">Lambda Vs Closure</a></li>
<li><a href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work" rel="nofollow">JavaScript Closures highly voted discussion</a></li>
</ul>
<h2 dir="auto"><a id="user-content-partial-application" aria-hidden="true" href="#partial-application"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Partial Application</h2>
<p dir="auto">Partially applying a function means creating a new function by pre-filling some of the arguments to the original function.</p>
<div data-snippet-clipboard-copy-content="// Helper to create partially applied functions
// Takes a function and some arguments
const partial = (f, ...args) =&gt;
  // returns a function that takes the rest of the arguments
  (...moreArgs) =&gt;
    // and calls the original function with all of them
    f(...args, ...moreArgs)

// Something to apply
const add3 = (a, b, c) =&gt; a + b + c

// Partially applying `2` and `3` to `add3` gives you a one-argument function
const fivePlus = partial(add3, 2, 3) // (c) =&gt; 2 + 3 + c

fivePlus(4) // 9"><pre><span>// Helper to create partially applied functions</span>
<span>// Takes a function and some arguments</span>
<span>const</span> <span>partial</span> <span>=</span> <span>(</span><span>f</span><span>,</span> ...<span>args</span><span>)</span> <span>=&gt;</span>
  <span>// returns a function that takes the rest of the arguments</span>
  <span>(</span>...<span>moreArgs</span><span>)</span> <span>=&gt;</span>
    <span>// and calls the original function with all of them</span>
    <span>f</span><span>(</span>...<span>args</span><span>,</span> ...<span>moreArgs</span><span>)</span>

<span>// Something to apply</span>
<span>const</span> <span>add3</span> <span>=</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>b</span> <span>+</span> <span>c</span>

<span>// Partially applying `2` and `3` to `add3` gives you a one-argument function</span>
<span>const</span> <span>fivePlus</span> <span>=</span> <span>partial</span><span>(</span><span>add3</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span> <span>// (c) =&gt; 2 + 3 + c</span>

<span>fivePlus</span><span>(</span><span>4</span><span>)</span> <span>// 9</span></pre></div>
<p dir="auto">You can also use <code>Function.prototype.bind</code> to partially apply a function in JS:</p>
<div data-snippet-clipboard-copy-content="const add1More = add3.bind(null, 2, 3) // (c) =&gt; 2 + 3 + c"><pre><span>const</span> <span>add1More</span> <span>=</span> <span>add3</span><span>.</span><span>bind</span><span>(</span><span>null</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span> <span>// (c) =&gt; 2 + 3 + c</span></pre></div>
<p dir="auto">Partial application helps create simpler functions from more complex ones by baking in data when you have it. <a href="#currying">Curried</a> functions are automatically partially applied.</p>
<h2 dir="auto"><a id="user-content-currying" aria-hidden="true" href="#currying"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Currying</h2>
<p dir="auto">The process of converting a function that takes multiple arguments into a function that takes them one at a time.</p>
<p dir="auto">Each time the function is called it only accepts one argument and returns a function that takes one argument until all arguments are passed.</p>
<div data-snippet-clipboard-copy-content="const sum = (a, b) =&gt; a + b

const curriedSum = (a) =&gt; (b) =&gt; a + b

curriedSum(40)(2) // 42.

const add2 = curriedSum(2) // (b) =&gt; 2 + b

add2(10) // 12
"><pre><span>const</span> <span>sum</span> <span>=</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>b</span>

<span>const</span> <span>curriedSum</span> <span>=</span> <span>(</span><span>a</span><span>)</span> <span>=&gt;</span> <span>(</span><span>b</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>b</span>

<span>curriedSum</span><span>(</span><span>40</span><span>)</span><span>(</span><span>2</span><span>)</span> <span>// 42.</span>

<span>const</span> <span>add2</span> <span>=</span> <span>curriedSum</span><span>(</span><span>2</span><span>)</span> <span>// (b) =&gt; 2 + b</span>

<span>add2</span><span>(</span><span>10</span><span>)</span> <span>// 12</span></pre></div>
<h2 dir="auto"><a id="user-content-auto-currying" aria-hidden="true" href="#auto-currying"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Auto Currying</h2>
<p dir="auto">Transforming a function that takes multiple arguments into one that if given less than its correct number of arguments returns a function that takes the rest. When the function gets the correct number of arguments it is then evaluated.</p>
<p dir="auto">lodash &amp; Ramda have a <code>curry</code> function that works this way.</p>
<div data-snippet-clipboard-copy-content="const add = (x, y) =&gt; x + y

const curriedAdd = _.curry(add)
curriedAdd(1, 2) // 3
curriedAdd(1) // (y) =&gt; 1 + y
curriedAdd(1)(2) // 3"><pre><span>const</span> <span>add</span> <span>=</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>+</span> <span>y</span>

<span>const</span> <span>curriedAdd</span> <span>=</span> <span>_</span><span>.</span><span>curry</span><span>(</span><span>add</span><span>)</span>
<span>curriedAdd</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span> <span>// 3</span>
<span>curriedAdd</span><span>(</span><span>1</span><span>)</span> <span>// (y) =&gt; 1 + y</span>
<span>curriedAdd</span><span>(</span><span>1</span><span>)</span><span>(</span><span>2</span><span>)</span> <span>// 3</span></pre></div>
<p dir="auto"><strong>Further reading</strong></p>
<ul dir="auto">
<li><a href="http://fr.umio.us/favoring-curry/" rel="nofollow">Favoring Curry</a></li>
<li><a href="https://www.youtube.com/watch?v=m3svKOdZijA" rel="nofollow">Hey Underscore, You&#39;re Doing It Wrong!</a></li>
</ul>
<h2 dir="auto"><a id="user-content-function-composition" aria-hidden="true" href="#function-composition"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Function Composition</h2>
<p dir="auto">The act of putting two functions together to form a third function where the output of one function is the input of the other. This is one of the most important ideas of functional programming.</p>
<div data-snippet-clipboard-copy-content="const compose = (f, g) =&gt; (a) =&gt; f(g(a)) // Definition
const floorAndToString = compose((val) =&gt; val.toString(), Math.floor) // Usage
floorAndToString(121.212121) // &#39;121&#39;"><pre><span>const</span> <span>compose</span> <span>=</span> <span>(</span><span>f</span><span>,</span> <span>g</span><span>)</span> <span>=&gt;</span> <span>(</span><span>a</span><span>)</span> <span>=&gt;</span> <span>f</span><span>(</span><span>g</span><span>(</span><span>a</span><span>)</span><span>)</span> <span>// Definition</span>
<span>const</span> <span>floorAndToString</span> <span>=</span> <span>compose</span><span>(</span><span>(</span><span>val</span><span>)</span> <span>=&gt;</span> <span>val</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>,</span> <span>Math</span><span>.</span><span>floor</span><span>)</span> <span>// Usage</span>
<span>floorAndToString</span><span>(</span><span>121.212121</span><span>)</span> <span>// &#39;121&#39;</span></pre></div>
<h2 dir="auto"><a id="user-content-continuation" aria-hidden="true" href="#continuation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Continuation</h2>
<p dir="auto">At any given point in a program, the part of the code that&#39;s yet to be executed is known as a continuation.</p>
<div data-snippet-clipboard-copy-content="const printAsString = (num) =&gt; console.log(`Given ${num}`)

const addOneAndContinue = (num, cc) =&gt; {
  const result = num + 1
  cc(result)
}

addOneAndContinue(2, printAsString) // &#39;Given 3&#39;"><pre><span>const</span> <span>printAsString</span> <span>=</span> <span>(</span><span>num</span><span>)</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>`Given <span><span>${</span><span>num</span><span>}</span></span>`</span><span>)</span>

<span>const</span> <span>addOneAndContinue</span> <span>=</span> <span>(</span><span>num</span><span>,</span> <span>cc</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>result</span> <span>=</span> <span>num</span> <span>+</span> <span>1</span>
  <span>cc</span><span>(</span><span>result</span><span>)</span>
<span>}</span>

<span>addOneAndContinue</span><span>(</span><span>2</span><span>,</span> <span>printAsString</span><span>)</span> <span>// &#39;Given 3&#39;</span></pre></div>
<p dir="auto">Continuations are often seen in asynchronous programming when the program needs to wait to receive data before it can continue. The response is often passed off to the rest of the program, which is the continuation, once it&#39;s been received.</p>
<div data-snippet-clipboard-copy-content="const continueProgramWith = (data) =&gt; {
  // Continues program with data
}

readFileAsync(&#39;path/to/file&#39;, (err, response) =&gt; {
  if (err) {
    // handle error
    return
  }
  continueProgramWith(response)
})"><pre><span>const</span> <span>continueProgramWith</span> <span>=</span> <span>(</span><span>data</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// Continues program with data</span>
<span>}</span>

<span>readFileAsync</span><span>(</span><span>&#39;path/to/file&#39;</span><span>,</span> <span>(</span><span>err</span><span>,</span> <span>response</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>if</span> <span>(</span><span>err</span><span>)</span> <span>{</span>
    <span>// handle error</span>
    <span>return</span>
  <span>}</span>
  <span>continueProgramWith</span><span>(</span><span>response</span><span>)</span>
<span>}</span><span>)</span></pre></div>
<h2 dir="auto"><a id="user-content-pure-function" aria-hidden="true" href="#pure-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Pure Function</h2>
<p dir="auto">A function is pure if the return value is only determined by its input values, and does not produce side effects. The function must always return the same result when given the same input.</p>
<div data-snippet-clipboard-copy-content="const greet = (name) =&gt; `Hi, ${name}`

greet(&#39;Brianne&#39;) // &#39;Hi, Brianne&#39;"><pre><span>const</span> <span>greet</span> <span>=</span> <span>(</span><span>name</span><span>)</span> <span>=&gt;</span> <span>`Hi, <span><span>${</span><span>name</span><span>}</span></span>`</span>

<span>greet</span><span>(</span><span>&#39;Brianne&#39;</span><span>)</span> <span>// &#39;Hi, Brianne&#39;</span></pre></div>
<p dir="auto">As opposed to each of the following:</p>
<div data-snippet-clipboard-copy-content="window.name = &#39;Brianne&#39;

const greet = () =&gt; `Hi, ${window.name}`

greet() // &#34;Hi, Brianne&#34;"><pre><span>window</span><span>.</span><span>name</span> <span>=</span> <span>&#39;Brianne&#39;</span>

<span>const</span> <span>greet</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>`Hi, <span><span>${</span><span>window</span><span>.</span><span>name</span><span>}</span></span>`</span>

<span>greet</span><span>(</span><span>)</span> <span>// &#34;Hi, Brianne&#34;</span></pre></div>
<p dir="auto">The above example&#39;s output is based on data stored outside of the function...</p>
<div data-snippet-clipboard-copy-content="let greeting

const greet = (name) =&gt; {
  greeting = `Hi, ${name}`
}

greet(&#39;Brianne&#39;)
greeting // &#34;Hi, Brianne&#34;"><pre><span>let</span> <span>greeting</span>

<span>const</span> <span>greet</span> <span>=</span> <span>(</span><span>name</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>greeting</span> <span>=</span> <span>`Hi, <span><span>${</span><span>name</span><span>}</span></span>`</span>
<span>}</span>

<span>greet</span><span>(</span><span>&#39;Brianne&#39;</span><span>)</span>
<span>greeting</span> <span>// &#34;Hi, Brianne&#34;</span></pre></div>
<p dir="auto">... and this one modifies state outside of the function.</p>
<h2 dir="auto"><a id="user-content-side-effects" aria-hidden="true" href="#side-effects"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Side effects</h2>
<p dir="auto">A function or expression is said to have a side effect if apart from returning a value, it interacts with (reads from or writes to) external mutable state.</p>
<div data-snippet-clipboard-copy-content="const differentEveryTime = new Date()"><pre><span>const</span> <span>differentEveryTime</span> <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span></pre></div>
<div data-snippet-clipboard-copy-content="console.log(&#39;IO is a side effect!&#39;)"><pre><span>console</span><span>.</span><span>log</span><span>(</span><span>&#39;IO is a side effect!&#39;</span><span>)</span></pre></div>
<h2 dir="auto"><a id="user-content-idempotent" aria-hidden="true" href="#idempotent"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Idempotent</h2>
<p dir="auto">A function is idempotent if reapplying it to its result does not produce a different result.</p>


<h2 dir="auto"><a id="user-content-point-free-style" aria-hidden="true" href="#point-free-style"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Point-Free Style</h2>
<p dir="auto">Writing functions where the definition does not explicitly identify the arguments used. This style usually requires <a href="#currying">currying</a> or other <a href="#higher-order-functions-hof">Higher-Order functions</a>. A.K.A Tacit programming.</p>
<div data-snippet-clipboard-copy-content="// Given
const map = (fn) =&gt; (list) =&gt; list.map(fn)
const add = (a) =&gt; (b) =&gt; a + b

// Then

// Not point-free - `numbers` is an explicit argument
const incrementAll = (numbers) =&gt; map(add(1))(numbers)

// Point-free - The list is an implicit argument
const incrementAll2 = map(add(1))"><pre><span>// Given</span>
<span>const</span> <span>map</span> <span>=</span> <span>(</span><span>fn</span><span>)</span> <span>=&gt;</span> <span>(</span><span>list</span><span>)</span> <span>=&gt;</span> <span>list</span><span>.</span><span>map</span><span>(</span><span>fn</span><span>)</span>
<span>const</span> <span>add</span> <span>=</span> <span>(</span><span>a</span><span>)</span> <span>=&gt;</span> <span>(</span><span>b</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>b</span>

<span>// Then</span>

<span>// Not point-free - `numbers` is an explicit argument</span>
<span>const</span> <span>incrementAll</span> <span>=</span> <span>(</span><span>numbers</span><span>)</span> <span>=&gt;</span> <span>map</span><span>(</span><span>add</span><span>(</span><span>1</span><span>)</span><span>)</span><span>(</span><span>numbers</span><span>)</span>

<span>// Point-free - The list is an implicit argument</span>
<span>const</span> <span>incrementAll2</span> <span>=</span> <span>map</span><span>(</span><span>add</span><span>(</span><span>1</span><span>)</span><span>)</span></pre></div>
<p dir="auto">Point-free function definitions look just like normal assignments without <code>function</code> or <code>=&gt;</code>. It&#39;s worth mentioning that point-free functions are not necessarily better than their counterparts, as they can be more difficult to understand when complex.</p>
<h2 dir="auto"><a id="user-content-predicate" aria-hidden="true" href="#predicate"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Predicate</h2>
<p dir="auto">A predicate is a function that returns true or false for a given value. A common use of a predicate is as the callback for array filter.</p>
<div data-snippet-clipboard-copy-content="const predicate = (a) =&gt; a &gt; 2

;[1, 2, 3, 4].filter(predicate) // [3, 4]"><pre><span>const</span> <span>predicate</span> <span>=</span> <span>(</span><span>a</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>&gt;</span> <span>2</span>

<span>;</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>.</span><span>filter</span><span>(</span><span>predicate</span><span>)</span> <span>// [3, 4]</span></pre></div>
<h2 dir="auto"><a id="user-content-contracts" aria-hidden="true" href="#contracts"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Contracts</h2>
<p dir="auto">A contract specifies the obligations and guarantees of the behavior from a function or expression at runtime. This acts as a set of rules that are expected from the input and output of a function or expression, and errors are generally reported whenever a contract is violated.</p>
<div data-snippet-clipboard-copy-content="// Define our contract : int -&gt; boolean
const contract = (input) =&gt; {
  if (typeof input === &#39;number&#39;) return true
  throw new Error(&#39;Contract violated: expected int -&gt; boolean&#39;)
}

const addOne = (num) =&gt; contract(num) &amp;&amp; num + 1

addOne(2) // 3
addOne(&#39;some string&#39;) // Contract violated: expected int -&gt; boolean"><pre><span>// Define our contract : int -&gt; boolean</span>
<span>const</span> <span>contract</span> <span>=</span> <span>(</span><span>input</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>if</span> <span>(</span><span>typeof</span> <span>input</span> <span>===</span> <span>&#39;number&#39;</span><span>)</span> <span>return</span> <span>true</span>
  <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>&#39;Contract violated: expected int -&gt; boolean&#39;</span><span>)</span>
<span>}</span>

<span>const</span> <span>addOne</span> <span>=</span> <span>(</span><span>num</span><span>)</span> <span>=&gt;</span> <span>contract</span><span>(</span><span>num</span><span>)</span> <span>&amp;&amp;</span> <span>num</span> <span>+</span> <span>1</span>

<span>addOne</span><span>(</span><span>2</span><span>)</span> <span>// 3</span>
<span>addOne</span><span>(</span><span>&#39;some string&#39;</span><span>)</span> <span>// Contract violated: expected int -&gt; boolean</span></pre></div>
<h2 dir="auto"><a id="user-content-category" aria-hidden="true" href="#category"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Category</h2>
<p dir="auto">A category in category theory is a collection of objects and morphisms between them. In programming, typically types
act as the objects and functions as morphisms.</p>
<p dir="auto">To be a valid category 3 rules must be met:</p>
<ol dir="auto">
<li>There must be an identity morphism that maps an object to itself.
Where <code>a</code> is an object in some category,
there must be a function from <code>a -&gt; a</code>.</li>
<li>Morphisms must compose.
Where <code>a</code>, <code>b</code>, and <code>c</code> are objects in some category,
and <code>f</code> is a morphism from <code>a -&gt; b</code>, and <code>g</code> is a morphism from <code>b -&gt; c</code>;
<code>g(f(x))</code> must be equivalent to <code>(g • f)(x)</code>.</li>
<li>Composition must be associative
<code>f • (g • h)</code> is the same as <code>(f • g) • h</code></li>
</ol>
<p dir="auto">Since these rules govern composition at very abstract level, category theory is great at uncovering new ways of composing things.</p>
<p dir="auto">As an example we can define a category Max as a class</p>
<div data-snippet-clipboard-copy-content="
class Max {
  constructor (a) {
    this.a = a
  }
  id () {
    return this
  }
  compose (b) {
    return this.a &gt; b.a ? this : b
  }
  toString () {
    return `Max(${this.a})`
  }
}

new Max(2).compose(new Max(3)).compose(new Max(5)).id().id() // =&gt; Max(5)"><pre><span>class</span> <span>Max</span> <span>{</span>
  <span>constructor</span> <span>(</span><span>a</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>a</span> <span>=</span> <span>a</span>
  <span>}</span>
  <span>id</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span>
  <span>}</span>
  <span>compose</span> <span>(</span><span>b</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>a</span> <span>&gt;</span> <span>b</span><span>.</span><span>a</span> ? <span>this</span> : <span>b</span>
  <span>}</span>
  <span>toString</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>`Max(<span><span>${</span><span>this</span><span>.</span><span>a</span><span>}</span></span>)`</span>
  <span>}</span>
<span>}</span>

<span>new</span> <span>Max</span><span>(</span><span>2</span><span>)</span><span>.</span><span>compose</span><span>(</span><span>new</span> <span>Max</span><span>(</span><span>3</span><span>)</span><span>)</span><span>.</span><span>compose</span><span>(</span><span>new</span> <span>Max</span><span>(</span><span>5</span><span>)</span><span>)</span><span>.</span><span>id</span><span>(</span><span>)</span><span>.</span><span>id</span><span>(</span><span>)</span> <span>// =&gt; Max(5)</span></pre></div>
<p dir="auto"><strong>Further reading</strong></p>
<ul dir="auto">
<li><a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/" rel="nofollow">Category Theory for Programmers</a></li>
</ul>
<h2 dir="auto"><a id="user-content-value" aria-hidden="true" href="#value"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Value</h2>
<p dir="auto">Anything that can be assigned to a variable.</p>
<div data-snippet-clipboard-copy-content="5
Object.freeze({name: &#39;John&#39;, age: 30}) // The `freeze` function enforces immutability.
;(a) =&gt; a
;[1]
undefined"><pre><span>5</span>
<span>Object</span><span>.</span><span>freeze</span><span>(</span><span>{</span><span>name</span>: <span>&#39;John&#39;</span><span>,</span> <span>age</span>: <span>30</span><span>}</span><span>)</span> <span>// The `freeze` function enforces immutability.</span>
<span>;</span><span>(</span><span>a</span><span>)</span> <span>=&gt;</span> <span>a</span>
<span>;</span><span>[</span><span>1</span><span>]</span>
<span>undefined</span></pre></div>
<h2 dir="auto"><a id="user-content-constant" aria-hidden="true" href="#constant"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Constant</h2>
<p dir="auto">A variable that cannot be reassigned once defined.</p>
<div data-snippet-clipboard-copy-content="const five = 5
const john = Object.freeze({name: &#39;John&#39;, age: 30})"><pre><span>const</span> <span>five</span> <span>=</span> <span>5</span>
<span>const</span> <span>john</span> <span>=</span> <span>Object</span><span>.</span><span>freeze</span><span>(</span><span>{</span><span>name</span>: <span>&#39;John&#39;</span><span>,</span> <span>age</span>: <span>30</span><span>}</span><span>)</span></pre></div>
<p dir="auto">Constants are <a href="#referential-transparency">referentially transparent</a>. That is, they can be replaced with the values that they represent without affecting the result.</p>
<p dir="auto">With the above two constants the following expression will always return <code>true</code>.</p>
<div data-snippet-clipboard-copy-content="john.age + five === ({name: &#39;John&#39;, age: 30}).age + (5)"><pre><span>john</span><span>.</span><span>age</span> <span>+</span> <span>five</span> <span>===</span> <span>(</span><span>{</span><span>name</span>: <span>&#39;John&#39;</span><span>,</span> <span>age</span>: <span>30</span><span>}</span><span>)</span><span>.</span><span>age</span> <span>+</span> <span>(</span><span>5</span><span>)</span></pre></div>
<h3 dir="auto"><a id="user-content-constant-function" aria-hidden="true" href="#constant-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Constant Function</h3>
<p dir="auto">A <a href="#currying">curried</a> function that ignores its second argument:</p>
<div data-snippet-clipboard-copy-content="const constant = a =&gt; () =&gt; a

;[1, 2].map(constant(0)) // =&gt; [0, 0]"><pre><span>const</span> <span>constant</span> <span>=</span> <span>a</span> <span>=&gt;</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>a</span>

<span>;</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span><span>.</span><span>map</span><span>(</span><span>constant</span><span>(</span><span>0</span><span>)</span><span>)</span> <span>// =&gt; [0, 0]</span></pre></div>
<h3 dir="auto"><a id="user-content-constant-functor" aria-hidden="true" href="#constant-functor"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Constant Functor</h3>
<p dir="auto">Object whose <code>map</code> doesn&#39;t transform the contents. See <a href="#functor">Functor</a></p>
<div data-snippet-clipboard-copy-content="  Constant(1).map(n =&gt; n + 1) // =&gt; Constant(1)"><pre>  <span>Constant</span><span>(</span><span>1</span><span>)</span><span>.</span><span>map</span><span>(</span><span>n</span> <span>=&gt;</span> <span>n</span> <span>+</span> <span>1</span><span>)</span> <span>// =&gt; Constant(1)</span></pre></div>
<h3 dir="auto"><a id="user-content-constant-monad" aria-hidden="true" href="#constant-monad"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Constant Monad</h3>
<p dir="auto">Object whose <code>chain</code> doesn&#39;t transform the contents. See <a href="#monad">Monad</a></p>
<div data-snippet-clipboard-copy-content="  Constant(1).chain(n =&gt; Constant(n + 1)) // =&gt; Constant(1)"><pre>  <span>Constant</span><span>(</span><span>1</span><span>)</span><span>.</span><span>chain</span><span>(</span><span>n</span> <span>=&gt;</span> <span>Constant</span><span>(</span><span>n</span> <span>+</span> <span>1</span><span>)</span><span>)</span> <span>// =&gt; Constant(1)</span></pre></div>
<h2 dir="auto"><a id="user-content-functor" aria-hidden="true" href="#functor"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Functor</h2>
<p dir="auto">An object that implements a <code>map</code> function that takes a function which is run on the contents of that object. A functor must adhere to two rules:</p>
<p dir="auto"><strong>Preserves identity</strong></p>
<div data-snippet-clipboard-copy-content="object.map(x =&gt; x) ≍ object"><pre><code>object.map(x =&gt; x) ≍ object
</code></pre></div>
<p dir="auto"><strong>Composable</strong></p>
<div data-snippet-clipboard-copy-content="object.map(compose(f, g)) ≍ object.map(g).map(f)"><pre><code>object.map(compose(f, g)) ≍ object.map(g).map(f)
</code></pre></div>
<p dir="auto">(<code>f</code>, <code>g</code> are arbitrary functions)</p>
<p dir="auto">A common functor in JavaScript is <code>Array</code> since it abides to the two functor rules:</p>
<div data-snippet-clipboard-copy-content=";[1, 2, 3].map(x =&gt; x) // = [1, 2, 3]"><pre><span>;</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>.</span><span>map</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span><span>)</span> <span>// = [1, 2, 3]</span></pre></div>
<p dir="auto">and</p>
<div data-snippet-clipboard-copy-content="const f = x =&gt; x + 1
const g = x =&gt; x * 2

;[1, 2, 3].map(x =&gt; f(g(x))) // = [3, 5, 7]
;[1, 2, 3].map(g).map(f) // = [3, 5, 7]"><pre><span>const</span> <span>f</span> <span>=</span> <span>x</span> <span>=&gt;</span> <span>x</span> <span>+</span> <span>1</span>
<span>const</span> <span>g</span> <span>=</span> <span>x</span> <span>=&gt;</span> <span>x</span> <span>*</span> <span>2</span>

<span>;</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>.</span><span>map</span><span>(</span><span>x</span> <span>=&gt;</span> <span>f</span><span>(</span><span>g</span><span>(</span><span>x</span><span>)</span><span>)</span><span>)</span> <span>// = [3, 5, 7]</span>
<span>;</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>.</span><span>map</span><span>(</span><span>g</span><span>)</span><span>.</span><span>map</span><span>(</span><span>f</span><span>)</span> <span>// = [3, 5, 7]</span></pre></div>
<h2 dir="auto"><a id="user-content-pointed-functor" aria-hidden="true" href="#pointed-functor"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Pointed Functor</h2>
<p dir="auto">An object with an <code>of</code> function that puts <em>any</em> single value into it.</p>
<p dir="auto">ES2015 adds <code>Array.of</code> making arrays a pointed functor.</p>

<h2 dir="auto"><a id="user-content-lift" aria-hidden="true" href="#lift"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lift</h2>
<p dir="auto">Lifting is when you take a value and put it into an object like a <a href="#pointed-functor">functor</a>. If you lift a function into an <a href="#applicative-functor">Applicative Functor</a> then you can make it work on values that are also in that functor.</p>
<p dir="auto">Some implementations have a function called <code>lift</code>, or <code>liftA2</code> to make it easier to run functions on functors.</p>
<div data-snippet-clipboard-copy-content="const liftA2 = (f) =&gt; (a, b) =&gt; a.map(f).ap(b) // note it&#39;s `ap` and not `map`.

const mult = a =&gt; b =&gt; a * b

const liftedMult = liftA2(mult) // this function now works on functors like array

liftedMult([1, 2], [3]) // [3, 6]
liftA2(a =&gt; b =&gt; a + b)([1, 2], [3, 4]) // [4, 5, 5, 6]"><pre><span>const</span> <span>liftA2</span> <span>=</span> <span>(</span><span>f</span><span>)</span> <span>=&gt;</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=&gt;</span> <span>a</span><span>.</span><span>map</span><span>(</span><span>f</span><span>)</span><span>.</span><span>ap</span><span>(</span><span>b</span><span>)</span> <span>// note it&#39;s `ap` and not `map`.</span>

<span>const</span> <span>mult</span> <span>=</span> <span>a</span> <span>=&gt;</span> <span>b</span> <span>=&gt;</span> <span>a</span> <span>*</span> <span>b</span>

<span>const</span> <span>liftedMult</span> <span>=</span> <span>liftA2</span><span>(</span><span>mult</span><span>)</span> <span>// this function now works on functors like array</span>

<span>liftedMult</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span><span>,</span> <span>[</span><span>3</span><span>]</span><span>)</span> <span>// [3, 6]</span>
<span>liftA2</span><span>(</span><span>a</span> <span>=&gt;</span> <span>b</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>b</span><span>)</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span><span>,</span> <span>[</span><span>3</span><span>,</span> <span>4</span><span>]</span><span>)</span> <span>// [4, 5, 5, 6]</span></pre></div>
<p dir="auto">Lifting a one-argument function and applying it does the same thing as <code>map</code>.</p>
<div data-snippet-clipboard-copy-content="const increment = (x) =&gt; x + 1

lift(increment)([2]) // [3]
;[2].map(increment) // [3]"><pre><span>const</span> <span>increment</span> <span>=</span> <span>(</span><span>x</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>+</span> <span>1</span>

<span>lift</span><span>(</span><span>increment</span><span>)</span><span>(</span><span>[</span><span>2</span><span>]</span><span>)</span> <span>// [3]</span>
<span>;</span><span>[</span><span>2</span><span>]</span><span>.</span><span>map</span><span>(</span><span>increment</span><span>)</span> <span>// [3]</span></pre></div>
<p dir="auto">Lifting simple values can be simply creating the object.</p>

<h2 dir="auto"><a id="user-content-referential-transparency" aria-hidden="true" href="#referential-transparency"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Referential Transparency</h2>
<p dir="auto">An expression that can be replaced with its value without changing the
behavior of the program is said to be referentially transparent.</p>
<p dir="auto">Given the function greet:</p>
<div data-snippet-clipboard-copy-content="const greet = () =&gt; &#39;Hello World!&#39;"><pre><span>const</span> <span>greet</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>&#39;Hello World!&#39;</span></pre></div>
<p dir="auto">Any invocation of <code>greet()</code> can be replaced with <code>Hello World!</code> hence greet is
referentially transparent. This would be broken if greet depended on external
state like configuration or a database call. See also <a href="#pure-function">Pure Function</a> and
<a href="#equational-reasoning">Equational Reasoning</a>.</p>
<h2 dir="auto"><a id="user-content-equational-reasoning" aria-hidden="true" href="#equational-reasoning"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Equational Reasoning</h2>
<p dir="auto">When an application is composed of expressions and devoid of side effects,
truths about the system can be derived from the parts. You can also be confident
about details of your system without having to go through every function.</p>
<div data-snippet-clipboard-copy-content="const grainToDogs = compose(chickenIntoDogs, grainIntoChicken)
const grainToCats = compose(dogsIntoCats, grainToDogs)"><pre><span>const</span> <span>grainToDogs</span> <span>=</span> <span>compose</span><span>(</span><span>chickenIntoDogs</span><span>,</span> <span>grainIntoChicken</span><span>)</span>
<span>const</span> <span>grainToCats</span> <span>=</span> <span>compose</span><span>(</span><span>dogsIntoCats</span><span>,</span> <span>grainToDogs</span><span>)</span></pre></div>
<p dir="auto">In the example above, if you know that <code>chickenIntoDogs</code> and <code>grainIntoChicken</code>
are pure then you know that the composition is pure. This can be taken further
when more is known about the functions (associative, communtative, idempotent, etc...)</p>
<h2 dir="auto"><a id="user-content-lambda" aria-hidden="true" href="#lambda"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lambda</h2>
<p dir="auto">An anonymous function that can be treated like a value.</p>
<div data-snippet-clipboard-copy-content=";(function (a) {
  return a + 1
})

;(a) =&gt; a + 1"><pre><span>;</span><span>(</span><span>function</span> <span>(</span><span>a</span><span>)</span> <span>{</span>
  <span>return</span> <span>a</span> <span>+</span> <span>1</span>
<span>}</span><span>)</span>

<span>;</span><span>(</span><span>a</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>1</span></pre></div>
<p dir="auto">Lambdas are often passed as arguments to Higher-Order functions.</p>
<div data-snippet-clipboard-copy-content=";[1, 2].map((a) =&gt; a + 1) // [2, 3]"><pre><span>;</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span><span>.</span><span>map</span><span>(</span><span>(</span><span>a</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>1</span><span>)</span> <span>// [2, 3]</span></pre></div>
<p dir="auto">You can assign a lambda to a variable.</p>
<div data-snippet-clipboard-copy-content="const add1 = (a) =&gt; a + 1"><pre><span>const</span> <span>add1</span> <span>=</span> <span>(</span><span>a</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>1</span></pre></div>
<h2 dir="auto"><a id="user-content-lambda-calculus" aria-hidden="true" href="#lambda-calculus"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lambda Calculus</h2>
<p dir="auto">A branch of mathematics that uses functions to create a <a href="https://en.wikipedia.org/wiki/Lambda_calculus" rel="nofollow">universal model of computation</a>.</p>
<h2 dir="auto"><a id="user-content-lazy-evaluation" aria-hidden="true" href="#lazy-evaluation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lazy evaluation</h2>
<p dir="auto">Lazy evaluation is a call-by-need evaluation mechanism that delays the evaluation of an expression until its value is needed. In functional languages, this allows for structures like infinite lists, which would not normally be available in an imperative language where the sequencing of commands is significant.</p>
<div data-snippet-clipboard-copy-content="const rand = function*() {
  while (1 &lt; 2) {
    yield Math.random()
  }
}"><pre><span>const</span> <span>rand</span> <span>=</span> <span>function</span><span>*</span><span>(</span><span>)</span> <span>{</span>
  <span>while</span> <span>(</span><span>1</span> <span>&lt;</span> <span>2</span><span>)</span> <span>{</span>
    <span>yield</span> <span>Math</span><span>.</span><span>random</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span></pre></div>
<div data-snippet-clipboard-copy-content="const randIter = rand()
randIter.next() // Each execution gives a random value, expression is evaluated on need."><pre><span>const</span> <span>randIter</span> <span>=</span> <span>rand</span><span>(</span><span>)</span>
<span>randIter</span><span>.</span><span>next</span><span>(</span><span>)</span> <span>// Each execution gives a random value, expression is evaluated on need.</span></pre></div>
<h2 dir="auto"><a id="user-content-monoid" aria-hidden="true" href="#monoid"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Monoid</h2>
<p dir="auto">An object with a function that &#34;combines&#34; that object with another of the same type (semigroup) which has an &#34;identity&#34; value.</p>
<p dir="auto">One simple monoid is the addition of numbers:</p>

<p dir="auto">In this case number is the object and <code>+</code> is the function.</p>
<p dir="auto">When any value is combined with the &#34;identity&#34; value the result must be the original value. The identity must also be commutative.</p>
<p dir="auto">The identity value for addition is <code>0</code>.</p>
<div data-snippet-clipboard-copy-content="1 + 0 // 1
0 + 1 // 1
1 + 0 === 0 + 1"><pre><span>1</span> <span>+</span> <span>0</span> <span>// 1</span>
<span>0</span> <span>+</span> <span>1</span> <span>// 1</span>
<span>1</span> <span>+</span> <span>0</span> <span>===</span> <span>0</span> <span>+</span> <span>1</span></pre></div>
<p dir="auto">It&#39;s also required that the grouping of operations will not affect the result (associativity):</p>
<div data-snippet-clipboard-copy-content="1 + (2 + 3) === (1 + 2) + 3 // true"><pre><span>1</span> <span>+</span> <span>(</span><span>2</span> <span>+</span> <span>3</span><span>)</span> <span>===</span> <span>(</span><span>1</span> <span>+</span> <span>2</span><span>)</span> <span>+</span> <span>3</span> <span>// true</span></pre></div>
<p dir="auto">Array concatenation also forms a monoid:</p>
<div data-snippet-clipboard-copy-content=";[1, 2].concat([3, 4]) // [1, 2, 3, 4]"><pre><span>;</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span><span>.</span><span>concat</span><span>(</span><span>[</span><span>3</span><span>,</span> <span>4</span><span>]</span><span>)</span> <span>// [1, 2, 3, 4]</span></pre></div>
<p dir="auto">The identity value is empty array <code>[]</code></p>
<div data-snippet-clipboard-copy-content=";[1, 2].concat([]) // [1, 2]"><pre><span>;</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span><span>.</span><span>concat</span><span>(</span><span>[</span><span>]</span><span>)</span> <span>// [1, 2]</span></pre></div>
<p dir="auto">As a counterexample, subtraction does not form a monoid because there is no commutative identity value:</p>

<h2 dir="auto"><a id="user-content-monad" aria-hidden="true" href="#monad"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Monad</h2>
<p dir="auto">A monad is an object with <a href="#pointed-functor"><code>of</code></a> and <code>chain</code> functions. <code>chain</code> is like <a href="#functor"><code>map</code></a> except it un-nests the resulting nested object.</p>
<div data-snippet-clipboard-copy-content="// Implementation
Array.prototype.chain = function (f) {
  return this.reduce((acc, it) =&gt; acc.concat(f(it)), [])
}

// Usage
Array.of(&#39;cat,dog&#39;, &#39;fish,bird&#39;).chain((a) =&gt; a.split(&#39;,&#39;)) // [&#39;cat&#39;, &#39;dog&#39;, &#39;fish&#39;, &#39;bird&#39;]

// Contrast to map
Array.of(&#39;cat,dog&#39;, &#39;fish,bird&#39;).map((a) =&gt; a.split(&#39;,&#39;)) // [[&#39;cat&#39;, &#39;dog&#39;], [&#39;fish&#39;, &#39;bird&#39;]]"><pre><span>// Implementation</span>
<span>Array</span><span>.</span><span>prototype</span><span>.</span><span>chain</span> <span>=</span> <span>function</span> <span>(</span><span>f</span><span>)</span> <span>{</span>
  <span>return</span> <span>this</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>acc</span><span>,</span> <span>it</span><span>)</span> <span>=&gt;</span> <span>acc</span><span>.</span><span>concat</span><span>(</span><span>f</span><span>(</span><span>it</span><span>)</span><span>)</span><span>,</span> <span>[</span><span>]</span><span>)</span>
<span>}</span>

<span>// Usage</span>
<span>Array</span><span>.</span><span>of</span><span>(</span><span>&#39;cat,dog&#39;</span><span>,</span> <span>&#39;fish,bird&#39;</span><span>)</span><span>.</span><span>chain</span><span>(</span><span>(</span><span>a</span><span>)</span> <span>=&gt;</span> <span>a</span><span>.</span><span>split</span><span>(</span><span>&#39;,&#39;</span><span>)</span><span>)</span> <span>// [&#39;cat&#39;, &#39;dog&#39;, &#39;fish&#39;, &#39;bird&#39;]</span>

<span>// Contrast to map</span>
<span>Array</span><span>.</span><span>of</span><span>(</span><span>&#39;cat,dog&#39;</span><span>,</span> <span>&#39;fish,bird&#39;</span><span>)</span><span>.</span><span>map</span><span>(</span><span>(</span><span>a</span><span>)</span> <span>=&gt;</span> <span>a</span><span>.</span><span>split</span><span>(</span><span>&#39;,&#39;</span><span>)</span><span>)</span> <span>// [[&#39;cat&#39;, &#39;dog&#39;], [&#39;fish&#39;, &#39;bird&#39;]]</span></pre></div>
<p dir="auto"><code>of</code> is also known as <code>return</code> in other functional languages.
<code>chain</code> is also known as <code>flatmap</code> and <code>bind</code> in other languages.</p>
<h2 dir="auto"><a id="user-content-comonad" aria-hidden="true" href="#comonad"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Comonad</h2>
<p dir="auto">An object that has <code>extract</code> and <code>extend</code> functions.</p>
<div data-snippet-clipboard-copy-content="const CoIdentity = (v) =&gt; ({
  val: v,
  extract () {
    return this.val
  },
  extend (f) {
    return CoIdentity(f(this))
  }
})"><pre><span>const</span> <span>CoIdentity</span> <span>=</span> <span>(</span><span>v</span><span>)</span> <span>=&gt;</span> <span>(</span><span>{</span>
  <span>val</span>: <span>v</span><span>,</span>
  <span>extract</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>val</span>
  <span>}</span><span>,</span>
  <span>extend</span> <span>(</span><span>f</span><span>)</span> <span>{</span>
    <span>return</span> <span>CoIdentity</span><span>(</span><span>f</span><span>(</span><span>this</span><span>)</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span></pre></div>
<p dir="auto">Extract takes a value out of a functor.</p>
<div data-snippet-clipboard-copy-content="CoIdentity(1).extract() // 1"><pre><span>CoIdentity</span><span>(</span><span>1</span><span>)</span><span>.</span><span>extract</span><span>(</span><span>)</span> <span>// 1</span></pre></div>
<p dir="auto">Extend runs a function on the comonad. The function should return the same type as the comonad.</p>
<div data-snippet-clipboard-copy-content="CoIdentity(1).extend((co) =&gt; co.extract() + 1) // CoIdentity(2)"><pre><span>CoIdentity</span><span>(</span><span>1</span><span>)</span><span>.</span><span>extend</span><span>(</span><span>(</span><span>co</span><span>)</span> <span>=&gt;</span> <span>co</span><span>.</span><span>extract</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>)</span> <span>// CoIdentity(2)</span></pre></div>
<h2 dir="auto"><a id="user-content-applicative-functor" aria-hidden="true" href="#applicative-functor"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Applicative Functor</h2>
<p dir="auto">An applicative functor is an object with an <code>ap</code> function. <code>ap</code> applies a function in the object to a value in another object of the same type.</p>
<div data-snippet-clipboard-copy-content="// Implementation
Array.prototype.ap = function (xs) {
  return this.reduce((acc, f) =&gt; acc.concat(xs.map(f)), [])
}

// Example usage
;[(a) =&gt; a + 1].ap([1]) // [2]"><pre><span>// Implementation</span>
<span>Array</span><span>.</span><span>prototype</span><span>.</span><span>ap</span> <span>=</span> <span>function</span> <span>(</span><span>xs</span><span>)</span> <span>{</span>
  <span>return</span> <span>this</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>acc</span><span>,</span> <span>f</span><span>)</span> <span>=&gt;</span> <span>acc</span><span>.</span><span>concat</span><span>(</span><span>xs</span><span>.</span><span>map</span><span>(</span><span>f</span><span>)</span><span>)</span><span>,</span> <span>[</span><span>]</span><span>)</span>
<span>}</span>

<span>// Example usage</span>
<span>;</span><span>[</span><span>(</span><span>a</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>1</span><span>]</span><span>.</span><span>ap</span><span>(</span><span>[</span><span>1</span><span>]</span><span>)</span> <span>// [2]</span></pre></div>
<p dir="auto">This is useful if you have two objects and you want to apply a binary function to their contents.</p>
<div data-snippet-clipboard-copy-content="// Arrays that you want to combine
const arg1 = [1, 3]
const arg2 = [4, 5]

// combining function - must be curried for this to work
const add = (x) =&gt; (y) =&gt; x + y

const partiallyAppliedAdds = [add].ap(arg1) // [(y) =&gt; 1 + y, (y) =&gt; 3 + y]"><pre><span>// Arrays that you want to combine</span>
<span>const</span> <span>arg1</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>3</span><span>]</span>
<span>const</span> <span>arg2</span> <span>=</span> <span>[</span><span>4</span><span>,</span> <span>5</span><span>]</span>

<span>// combining function - must be curried for this to work</span>
<span>const</span> <span>add</span> <span>=</span> <span>(</span><span>x</span><span>)</span> <span>=&gt;</span> <span>(</span><span>y</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>+</span> <span>y</span>

<span>const</span> <span>partiallyAppliedAdds</span> <span>=</span> <span>[</span><span>add</span><span>]</span><span>.</span><span>ap</span><span>(</span><span>arg1</span><span>)</span> <span>// [(y) =&gt; 1 + y, (y) =&gt; 3 + y]</span></pre></div>
<p dir="auto">This gives you an array of functions that you can call <code>ap</code> on to get the result:</p>
<div data-snippet-clipboard-copy-content="partiallyAppliedAdds.ap(arg2) // [5, 6, 7, 8]"><pre><span>partiallyAppliedAdds</span><span>.</span><span>ap</span><span>(</span><span>arg2</span><span>)</span> <span>// [5, 6, 7, 8]</span></pre></div>
<h2 dir="auto"><a id="user-content-morphism" aria-hidden="true" href="#morphism"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Morphism</h2>
<p dir="auto">A transformation function.</p>
<h3 dir="auto"><a id="user-content-endomorphism" aria-hidden="true" href="#endomorphism"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Endomorphism</h3>
<p dir="auto">A function where the input type is the same as the output.</p>
<div data-snippet-clipboard-copy-content="// uppercase :: String -&gt; String
const uppercase = (str) =&gt; str.toUpperCase()

// decrement :: Number -&gt; Number
const decrement = (x) =&gt; x - 1"><pre><span>// uppercase :: String -&gt; String</span>
<span>const</span> <span>uppercase</span> <span>=</span> <span>(</span><span>str</span><span>)</span> <span>=&gt;</span> <span>str</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span>

<span>// decrement :: Number -&gt; Number</span>
<span>const</span> <span>decrement</span> <span>=</span> <span>(</span><span>x</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>-</span> <span>1</span></pre></div>
<h3 dir="auto"><a id="user-content-isomorphism" aria-hidden="true" href="#isomorphism"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Isomorphism</h3>
<p dir="auto">A pair of transformations between 2 types of objects that is structural in nature and no data is lost.</p>
<p dir="auto">For example, 2D coordinates could be stored as an array <code>[2,3]</code> or object <code>{x: 2, y: 3}</code>.</p>
<div data-snippet-clipboard-copy-content="// Providing functions to convert in both directions makes them isomorphic.
const pairToCoords = (pair) =&gt; ({x: pair[0], y: pair[1]})

const coordsToPair = (coords) =&gt; [coords.x, coords.y]

coordsToPair(pairToCoords([1, 2])) // [1, 2]

pairToCoords(coordsToPair({x: 1, y: 2})) // {x: 1, y: 2}"><pre><span>// Providing functions to convert in both directions makes them isomorphic.</span>
<span>const</span> <span>pairToCoords</span> <span>=</span> <span>(</span><span>pair</span><span>)</span> <span>=&gt;</span> <span>(</span><span>{</span><span>x</span>: <span>pair</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>y</span>: <span>pair</span><span>[</span><span>1</span><span>]</span><span>}</span><span>)</span>

<span>const</span> <span>coordsToPair</span> <span>=</span> <span>(</span><span>coords</span><span>)</span> <span>=&gt;</span> <span>[</span><span>coords</span><span>.</span><span>x</span><span>,</span> <span>coords</span><span>.</span><span>y</span><span>]</span>

<span>coordsToPair</span><span>(</span><span>pairToCoords</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span><span>)</span><span>)</span> <span>// [1, 2]</span>

<span>pairToCoords</span><span>(</span><span>coordsToPair</span><span>(</span><span>{</span><span>x</span>: <span>1</span><span>,</span> <span>y</span>: <span>2</span><span>}</span><span>)</span><span>)</span> <span>// {x: 1, y: 2}</span></pre></div>
<h3 dir="auto"><a id="user-content-homomorphism" aria-hidden="true" href="#homomorphism"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Homomorphism</h3>
<p dir="auto">A homomorphism is just a structure preserving map. In fact, a functor is just a homomorphism between categories as it preserves the original category&#39;s structure under the mapping.</p>
<div data-snippet-clipboard-copy-content="A.of(f).ap(A.of(x)) == A.of(f(x))

Either.of(_.toUpper).ap(Either.of(&#39;oreos&#39;)) == Either.of(_.toUpper(&#39;oreos&#39;))"><pre><span>A</span><span>.</span><span>of</span><span>(</span><span>f</span><span>)</span><span>.</span><span>ap</span><span>(</span><span>A</span><span>.</span><span>of</span><span>(</span><span>x</span><span>)</span><span>)</span> <span>==</span> <span>A</span><span>.</span><span>of</span><span>(</span><span>f</span><span>(</span><span>x</span><span>)</span><span>)</span>

<span>Either</span><span>.</span><span>of</span><span>(</span><span>_</span><span>.</span><span>toUpper</span><span>)</span><span>.</span><span>ap</span><span>(</span><span>Either</span><span>.</span><span>of</span><span>(</span><span>&#39;oreos&#39;</span><span>)</span><span>)</span> <span>==</span> <span>Either</span><span>.</span><span>of</span><span>(</span><span>_</span><span>.</span><span>toUpper</span><span>(</span><span>&#39;oreos&#39;</span><span>)</span><span>)</span></pre></div>
<h3 dir="auto"><a id="user-content-catamorphism" aria-hidden="true" href="#catamorphism"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Catamorphism</h3>
<p dir="auto">A <code>reduceRight</code> function that applies a function against an accumulator and each value of the array (from right-to-left) to reduce it to a single value.</p>
<div data-snippet-clipboard-copy-content="const sum = xs =&gt; xs.reduceRight((acc, x) =&gt; acc + x, 0)

sum([1, 2, 3, 4, 5]) // 15"><pre><span>const</span> <span>sum</span> <span>=</span> <span>xs</span> <span>=&gt;</span> <span>xs</span><span>.</span><span>reduceRight</span><span>(</span><span>(</span><span>acc</span><span>,</span> <span>x</span><span>)</span> <span>=&gt;</span> <span>acc</span> <span>+</span> <span>x</span><span>,</span> <span>0</span><span>)</span>

<span>sum</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span><span>)</span> <span>// 15</span></pre></div>
<h3 dir="auto"><a id="user-content-anamorphism" aria-hidden="true" href="#anamorphism"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Anamorphism</h3>
<p dir="auto">An <code>unfold</code> function. An <code>unfold</code> is the opposite of <code>fold</code> (<code>reduce</code>). It generates a list from a single value.</p>
<div data-snippet-clipboard-copy-content="const unfold = (f, seed) =&gt; {
  function go (f, seed, acc) {
    const res = f(seed)
    return res ? go(f, res[1], acc.concat([res[0]])) : acc
  }
  return go(f, seed, [])
}"><pre><span>const</span> <span>unfold</span> <span>=</span> <span>(</span><span>f</span><span>,</span> <span>seed</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>function</span> <span>go</span> <span>(</span><span>f</span><span>,</span> <span>seed</span><span>,</span> <span>acc</span><span>)</span> <span>{</span>
    <span>const</span> <span>res</span> <span>=</span> <span>f</span><span>(</span><span>seed</span><span>)</span>
    <span>return</span> <span>res</span> ? <span>go</span><span>(</span><span>f</span><span>,</span> <span>res</span><span>[</span><span>1</span><span>]</span><span>,</span> <span>acc</span><span>.</span><span>concat</span><span>(</span><span>[</span><span>res</span><span>[</span><span>0</span><span>]</span><span>]</span><span>)</span><span>)</span> : <span>acc</span>
  <span>}</span>
  <span>return</span> <span>go</span><span>(</span><span>f</span><span>,</span> <span>seed</span><span>,</span> <span>[</span><span>]</span><span>)</span>
<span>}</span></pre></div>
<div data-snippet-clipboard-copy-content="const countDown = n =&gt; unfold((n) =&gt; {
  return n &lt;= 0 ? undefined : [n, n - 1]
}, n)

countDown(5) // [5, 4, 3, 2, 1]"><pre><span>const</span> <span>countDown</span> <span>=</span> <span>n</span> <span>=&gt;</span> <span>unfold</span><span>(</span><span>(</span><span>n</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>n</span> <span>&lt;=</span> <span>0</span> ? <span>undefined</span> : <span>[</span><span>n</span><span>,</span> <span>n</span> <span>-</span> <span>1</span><span>]</span>
<span>}</span><span>,</span> <span>n</span><span>)</span>

<span>countDown</span><span>(</span><span>5</span><span>)</span> <span>// [5, 4, 3, 2, 1]</span></pre></div>
<h3 dir="auto"><a id="user-content-hylomorphism" aria-hidden="true" href="#hylomorphism"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Hylomorphism</h3>
<p dir="auto">The combination of anamorphism and catamorphism.</p>
<h3 dir="auto"><a id="user-content-paramorphism" aria-hidden="true" href="#paramorphism"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Paramorphism</h3>
<p dir="auto">A function just like <code>reduceRight</code>. However, there&#39;s a difference:</p>
<p dir="auto">In paramorphism, your reducer&#39;s arguments are the current value, the reduction of all previous values, and the list of values that formed that reduction.</p>
<div data-snippet-clipboard-copy-content="// Obviously not safe for lists containing `undefined`,
// but good enough to make the point.
const para = (reducer, accumulator, elements) =&gt; {
  if (elements.length === 0) { return accumulator }

  const head = elements[0]
  const tail = elements.slice(1)

  return reducer(head, tail, para(reducer, accumulator, tail))
}

const suffixes = list =&gt; para(
  (x, xs, suffxs) =&gt; [xs, ...suffxs],
  [],
  list
)

suffixes([1, 2, 3, 4, 5]) // [[2, 3, 4, 5], [3, 4, 5], [4, 5], [5], []]"><pre><span>// Obviously not safe for lists containing `undefined`,</span>
<span>// but good enough to make the point.</span>
<span>const</span> <span>para</span> <span>=</span> <span>(</span><span>reducer</span><span>,</span> <span>accumulator</span><span>,</span> <span>elements</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>if</span> <span>(</span><span>elements</span><span>.</span><span>length</span> <span>===</span> <span>0</span><span>)</span> <span>{</span> <span>return</span> <span>accumulator</span> <span>}</span>

  <span>const</span> <span>head</span> <span>=</span> <span>elements</span><span>[</span><span>0</span><span>]</span>
  <span>const</span> <span>tail</span> <span>=</span> <span>elements</span><span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span>

  <span>return</span> <span>reducer</span><span>(</span><span>head</span><span>,</span> <span>tail</span><span>,</span> <span>para</span><span>(</span><span>reducer</span><span>,</span> <span>accumulator</span><span>,</span> <span>tail</span><span>)</span><span>)</span>
<span>}</span>

<span>const</span> <span>suffixes</span> <span>=</span> <span>list</span> <span>=&gt;</span> <span>para</span><span>(</span>
  <span>(</span><span>x</span><span>,</span> <span>xs</span><span>,</span> <span>suffxs</span><span>)</span> <span>=&gt;</span> <span>[</span><span>xs</span><span>,</span> ...<span>suffxs</span><span>]</span><span>,</span>
  <span>[</span><span>]</span><span>,</span>
  <span>list</span>
<span>)</span>

<span>suffixes</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span><span>)</span> <span>// [[2, 3, 4, 5], [3, 4, 5], [4, 5], [5], []]</span></pre></div>
<p dir="auto">The third parameter in the reducer (in the above example, <code>[x, ... xs]</code>) is kind of like having a history of what got you to your current acc value.</p>
<h3 dir="auto"><a id="user-content-apomorphism" aria-hidden="true" href="#apomorphism"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Apomorphism</h3>
<p dir="auto">it&#39;s the opposite of paramorphism, just as anamorphism is the opposite of catamorphism. Whereas with paramorphism, you combine with access to the accumulator and what has been accumulated, apomorphism lets you <code>unfold</code> with the potential to return early.</p>
<h2 dir="auto"><a id="user-content-setoid" aria-hidden="true" href="#setoid"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Setoid</h2>
<p dir="auto">An object that has an <code>equals</code> function which can be used to compare other objects of the same type.</p>
<p dir="auto">Make array a setoid:</p>
<div data-snippet-clipboard-copy-content="Array.prototype.equals = function (arr) {
  const len = this.length
  if (len !== arr.length) {
    return false
  }
  for (let i = 0; i &lt; len; i++) {
    if (this[i] !== arr[i]) {
      return false
    }
  }
  return true
}

;[1, 2].equals([1, 2]) // true
;[1, 2].equals([0]) // false"><pre><span>Array</span><span>.</span><span>prototype</span><span>.</span><span>equals</span> <span>=</span> <span>function</span> <span>(</span><span>arr</span><span>)</span> <span>{</span>
  <span>const</span> <span>len</span> <span>=</span> <span>this</span><span>.</span><span>length</span>
  <span>if</span> <span>(</span><span>len</span> <span>!==</span> <span>arr</span><span>.</span><span>length</span><span>)</span> <span>{</span>
    <span>return</span> <span>false</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>let</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>len</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>[</span><span>i</span><span>]</span> <span>!==</span> <span>arr</span><span>[</span><span>i</span><span>]</span><span>)</span> <span>{</span>
      <span>return</span> <span>false</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span>

<span>;</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span><span>.</span><span>equals</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span><span>)</span> <span>// true</span>
<span>;</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span><span>.</span><span>equals</span><span>(</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>// false</span></pre></div>
<h2 dir="auto"><a id="user-content-semigroup" aria-hidden="true" href="#semigroup"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Semigroup</h2>
<p dir="auto">An object that has a <code>concat</code> function that combines it with another object of the same type.</p>
<div data-snippet-clipboard-copy-content=";[1].concat([2]) // [1, 2]"><pre><span>;</span><span>[</span><span>1</span><span>]</span><span>.</span><span>concat</span><span>(</span><span>[</span><span>2</span><span>]</span><span>)</span> <span>// [1, 2]</span></pre></div>
<h2 dir="auto"><a id="user-content-foldable" aria-hidden="true" href="#foldable"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Foldable</h2>
<p dir="auto">An object that has a <code>reduce</code> function that applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value.</p>
<div data-snippet-clipboard-copy-content="const sum = (list) =&gt; list.reduce((acc, val) =&gt; acc + val, 0)
sum([1, 2, 3]) // 6"><pre><span>const</span> <span>sum</span> <span>=</span> <span>(</span><span>list</span><span>)</span> <span>=&gt;</span> <span>list</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>acc</span><span>,</span> <span>val</span><span>)</span> <span>=&gt;</span> <span>acc</span> <span>+</span> <span>val</span><span>,</span> <span>0</span><span>)</span>
<span>sum</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span> <span>// 6</span></pre></div>
<h2 dir="auto"><a id="user-content-lens" aria-hidden="true" href="#lens"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lens</h2>
<p dir="auto">A lens is a structure (often an object or function) that pairs a getter and a non-mutating setter for some other data
structure.</p>
<div data-snippet-clipboard-copy-content="// Using [Ramda&#39;s lens](http://ramdajs.com/docs/#lens)
const nameLens = R.lens(
  // getter for name property on an object
  (obj) =&gt; obj.name,
  // setter for name property
  (val, obj) =&gt; Object.assign({}, obj, {name: val})
)"><pre><span>// Using [Ramda&#39;s lens](http://ramdajs.com/docs/#lens)</span>
<span>const</span> <span>nameLens</span> <span>=</span> <span>R</span><span>.</span><span>lens</span><span>(</span>
  <span>// getter for name property on an object</span>
  <span>(</span><span>obj</span><span>)</span> <span>=&gt;</span> <span>obj</span><span>.</span><span>name</span><span>,</span>
  <span>// setter for name property</span>
  <span>(</span><span>val</span><span>,</span> <span>obj</span><span>)</span> <span>=&gt;</span> <span>Object</span><span>.</span><span>assign</span><span>(</span><span>{</span><span>}</span><span>,</span> <span>obj</span><span>,</span> <span>{</span><span>name</span>: <span>val</span><span>}</span><span>)</span>
<span>)</span></pre></div>
<p dir="auto">Having the pair of get and set for a given data structure enables a few key features.</p>
<div data-snippet-clipboard-copy-content="const person = {name: &#39;Gertrude Blanch&#39;}

// invoke the getter
R.view(nameLens, person) // &#39;Gertrude Blanch&#39;

// invoke the setter
R.set(nameLens, &#39;Shafi Goldwasser&#39;, person) // {name: &#39;Shafi Goldwasser&#39;}

// run a function on the value in the structure
R.over(nameLens, uppercase, person) // {name: &#39;GERTRUDE BLANCH&#39;}"><pre><span>const</span> <span>person</span> <span>=</span> <span>{</span><span>name</span>: <span>&#39;Gertrude Blanch&#39;</span><span>}</span>

<span>// invoke the getter</span>
<span>R</span><span>.</span><span>view</span><span>(</span><span>nameLens</span><span>,</span> <span>person</span><span>)</span> <span>// &#39;Gertrude Blanch&#39;</span>

<span>// invoke the setter</span>
<span>R</span><span>.</span><span>set</span><span>(</span><span>nameLens</span><span>,</span> <span>&#39;Shafi Goldwasser&#39;</span><span>,</span> <span>person</span><span>)</span> <span>// {name: &#39;Shafi Goldwasser&#39;}</span>

<span>// run a function on the value in the structure</span>
<span>R</span><span>.</span><span>over</span><span>(</span><span>nameLens</span><span>,</span> <span>uppercase</span><span>,</span> <span>person</span><span>)</span> <span>// {name: &#39;GERTRUDE BLANCH&#39;}</span></pre></div>
<p dir="auto">Lenses are also composable. This allows easy immutable updates to deeply nested data.</p>
<div data-snippet-clipboard-copy-content="// This lens focuses on the first item in a non-empty array
const firstLens = R.lens(
  // get first item in array
  xs =&gt; xs[0],
  // non-mutating setter for first item in array
  (val, [__, ...xs]) =&gt; [val, ...xs]
)

const people = [{name: &#39;Gertrude Blanch&#39;}, {name: &#39;Shafi Goldwasser&#39;}]

// Despite what you may assume, lenses compose left-to-right.
R.over(compose(firstLens, nameLens), uppercase, people) // [{&#39;name&#39;: &#39;GERTRUDE BLANCH&#39;}, {&#39;name&#39;: &#39;Shafi Goldwasser&#39;}]"><pre><span>// This lens focuses on the first item in a non-empty array</span>
<span>const</span> <span>firstLens</span> <span>=</span> <span>R</span><span>.</span><span>lens</span><span>(</span>
  <span>// get first item in array</span>
  <span>xs</span> <span>=&gt;</span> <span>xs</span><span>[</span><span>0</span><span>]</span><span>,</span>
  <span>// non-mutating setter for first item in array</span>
  <span>(</span><span>val</span><span>,</span> <span>[</span><span>__</span><span>,</span> ...<span>xs</span><span>]</span><span>)</span> <span>=&gt;</span> <span>[</span><span>val</span><span>,</span> ...<span>xs</span><span>]</span>
<span>)</span>

<span>const</span> <span>people</span> <span>=</span> <span>[</span><span>{</span><span>name</span>: <span>&#39;Gertrude Blanch&#39;</span><span>}</span><span>,</span> <span>{</span><span>name</span>: <span>&#39;Shafi Goldwasser&#39;</span><span>}</span><span>]</span>

<span>// Despite what you may assume, lenses compose left-to-right.</span>
<span>R</span><span>.</span><span>over</span><span>(</span><span>compose</span><span>(</span><span>firstLens</span><span>,</span> <span>nameLens</span><span>)</span><span>,</span> <span>uppercase</span><span>,</span> <span>people</span><span>)</span> <span>// [{&#39;name&#39;: &#39;GERTRUDE BLANCH&#39;}, {&#39;name&#39;: &#39;Shafi Goldwasser&#39;}]</span></pre></div>
<p dir="auto">Other implementations:</p>
<ul dir="auto">
<li><a href="https://github.com/calmm-js/partial.lenses">partial.lenses</a> - Tasty syntax sugar and a lot of powerful features</li>
<li><a href="http://www.kovach.me/nanoscope/" rel="nofollow">nanoscope</a> - Fluent-interface</li>
</ul>
<h2 dir="auto"><a id="user-content-type-signatures" aria-hidden="true" href="#type-signatures"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Type Signatures</h2>
<p dir="auto">Often functions in JavaScript will include comments that indicate the types of their arguments and return values.</p>
<p dir="auto">There&#39;s quite a bit of variance across the community but they often follow the following patterns:</p>
<div data-snippet-clipboard-copy-content="// functionName :: firstArgType -&gt; secondArgType -&gt; returnType

// add :: Number -&gt; Number -&gt; Number
const add = (x) =&gt; (y) =&gt; x + y

// increment :: Number -&gt; Number
const increment = (x) =&gt; x + 1"><pre><span>// functionName :: firstArgType -&gt; secondArgType -&gt; returnType</span>

<span>// add :: Number -&gt; Number -&gt; Number</span>
<span>const</span> <span>add</span> <span>=</span> <span>(</span><span>x</span><span>)</span> <span>=&gt;</span> <span>(</span><span>y</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>+</span> <span>y</span>

<span>// increment :: Number -&gt; Number</span>
<span>const</span> <span>increment</span> <span>=</span> <span>(</span><span>x</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>+</span> <span>1</span></pre></div>
<p dir="auto">If a function accepts another function as an argument it is wrapped in parentheses.</p>
<div data-snippet-clipboard-copy-content="// call :: (a -&gt; b) -&gt; a -&gt; b
const call = (f) =&gt; (x) =&gt; f(x)"><pre><span>// call :: (a -&gt; b) -&gt; a -&gt; b</span>
<span>const</span> <span>call</span> <span>=</span> <span>(</span><span>f</span><span>)</span> <span>=&gt;</span> <span>(</span><span>x</span><span>)</span> <span>=&gt;</span> <span>f</span><span>(</span><span>x</span><span>)</span></pre></div>
<p dir="auto">The letters <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> are used to signify that the argument can be of any type. The following version of <code>map</code> takes a function that transforms a value of some type <code>a</code> into another type <code>b</code>, an array of values of type <code>a</code>, and returns an array of values of type <code>b</code>.</p>
<div data-snippet-clipboard-copy-content="// map :: (a -&gt; b) -&gt; [a] -&gt; [b]
const map = (f) =&gt; (list) =&gt; list.map(f)"><pre><span>// map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span>
<span>const</span> <span>map</span> <span>=</span> <span>(</span><span>f</span><span>)</span> <span>=&gt;</span> <span>(</span><span>list</span><span>)</span> <span>=&gt;</span> <span>list</span><span>.</span><span>map</span><span>(</span><span>f</span><span>)</span></pre></div>
<p dir="auto"><strong>Further reading</strong></p>
<ul dir="auto">
<li><a href="https://github.com/ramda/ramda/wiki/Type-Signatures">Ramda&#39;s type signatures</a></li>
<li><a href="https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch7.html#whats-your-type" rel="nofollow">Mostly Adequate Guide</a></li>
<li><a href="http://stackoverflow.com/a/399392/22425" rel="nofollow">What is Hindley-Milner?</a> on Stack Overflow</li>
</ul>
<h2 dir="auto"><a id="user-content-algebraic-data-type" aria-hidden="true" href="#algebraic-data-type"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Algebraic data type</h2>
<p dir="auto">A composite type made from putting other types together. Two common classes of algebraic types are <a href="#sum-type">sum</a> and <a href="#product-type">product</a>.</p>
<h3 dir="auto"><a id="user-content-sum-type" aria-hidden="true" href="#sum-type"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Sum type</h3>
<p dir="auto">A Sum type is the combination of two types together into another one. It is called sum because the number of possible values in the result type is the sum of the input types.</p>
<p dir="auto">JavaScript doesn&#39;t have types like this but we can use <code>Set</code>s to pretend:</p>
<div data-snippet-clipboard-copy-content="// imagine that rather than sets here we have types that can only have these values
const bools = new Set([true, false])
const halfTrue = new Set([&#39;half-true&#39;])

// The weakLogic type contains the sum of the values from bools and halfTrue
const weakLogicValues = new Set([...bools, ...halfTrue])"><pre><span>// imagine that rather than sets here we have types that can only have these values</span>
<span>const</span> <span>bools</span> <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>[</span><span>true</span><span>,</span> <span>false</span><span>]</span><span>)</span>
<span>const</span> <span>halfTrue</span> <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>[</span><span>&#39;half-true&#39;</span><span>]</span><span>)</span>

<span>// The weakLogic type contains the sum of the values from bools and halfTrue</span>
<span>const</span> <span>weakLogicValues</span> <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>[</span>...<span>bools</span><span>,</span> ...<span>halfTrue</span><span>]</span><span>)</span></pre></div>
<p dir="auto">Sum types are sometimes called union types, discriminated unions, or tagged unions.</p>
<p dir="auto">There&#39;s a <a href="https://github.com/paldepind/union-type">couple</a> <a href="https://github.com/puffnfresh/daggy">libraries</a> in JS which help with defining and using union types.</p>
<p dir="auto">Flow includes <a href="https://flow.org/en/docs/types/unions/" rel="nofollow">union types</a> and TypeScript has <a href="https://www.typescriptlang.org/docs/handbook/enums.html" rel="nofollow">Enums</a> to serve the same role.</p>
<h3 dir="auto"><a id="user-content-product-type" aria-hidden="true" href="#product-type"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Product type</h3>
<p dir="auto">A <strong>product</strong> type combines types together in a way you&#39;re probably more familiar with:</p>
<div data-snippet-clipboard-copy-content="// point :: (Number, Number) -&gt; {x: Number, y: Number}
const point = (x, y) =&gt; ({ x, y })"><pre><span>// point :: (Number, Number) -&gt; {x: Number, y: Number}</span>
<span>const</span> <span>point</span> <span>=</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>=&gt;</span> <span>(</span><span>{</span> x<span>,</span> y <span>}</span><span>)</span></pre></div>
<p dir="auto">It&#39;s called a product because the total possible values of the data structure is the product of the different values. Many languages have a tuple type which is the simplest formulation of a product type.</p>
<p dir="auto">See also <a href="https://en.wikipedia.org/wiki/Set_theory" rel="nofollow">Set theory</a>.</p>
<h2 dir="auto"><a id="user-content-option" aria-hidden="true" href="#option"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Option</h2>
<p dir="auto">Option is a <a href="#sum-type">sum type</a> with two cases often called <code>Some</code> and <code>None</code>.</p>
<p dir="auto">Option is useful for composing functions that might not return a value.</p>
<div data-snippet-clipboard-copy-content="// Naive definition

const Some = (v) =&gt; ({
  val: v,
  map (f) {
    return Some(f(this.val))
  },
  chain (f) {
    return f(this.val)
  }
})

const None = () =&gt; ({
  map (f) {
    return this
  },
  chain (f) {
    return this
  }
})

// maybeProp :: (String, {a}) -&gt; Option a
const maybeProp = (key, obj) =&gt; typeof obj[key] === &#39;undefined&#39; ? None() : Some(obj[key])"><pre><span>// Naive definition</span>

<span>const</span> <span>Some</span> <span>=</span> <span>(</span><span>v</span><span>)</span> <span>=&gt;</span> <span>(</span><span>{</span>
  <span>val</span>: <span>v</span><span>,</span>
  <span>map</span> <span>(</span><span>f</span><span>)</span> <span>{</span>
    <span>return</span> <span>Some</span><span>(</span><span>f</span><span>(</span><span>this</span><span>.</span><span>val</span><span>)</span><span>)</span>
  <span>}</span><span>,</span>
  <span>chain</span> <span>(</span><span>f</span><span>)</span> <span>{</span>
    <span>return</span> <span>f</span><span>(</span><span>this</span><span>.</span><span>val</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>

<span>const</span> <span>None</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>(</span><span>{</span>
  <span>map</span> <span>(</span><span>f</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span>
  <span>}</span><span>,</span>
  <span>chain</span> <span>(</span><span>f</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span>
  <span>}</span>
<span>}</span><span>)</span>

<span>// maybeProp :: (String, {a}) -&gt; Option a</span>
<span>const</span> <span>maybeProp</span> <span>=</span> <span>(</span><span>key</span><span>,</span> <span>obj</span><span>)</span> <span>=&gt;</span> <span>typeof</span> <span>obj</span><span>[</span><span>key</span><span>]</span> <span>===</span> <span>&#39;undefined&#39;</span> ? <span>None</span><span>(</span><span>)</span> : <span>Some</span><span>(</span><span>obj</span><span>[</span><span>key</span><span>]</span><span>)</span></pre></div>
<p dir="auto">Use <code>chain</code> to sequence functions that return <code>Option</code>s</p>
<div data-snippet-clipboard-copy-content="
// getItem :: Cart -&gt; Option CartItem
const getItem = (cart) =&gt; maybeProp(&#39;item&#39;, cart)

// getPrice :: Item -&gt; Option Number
const getPrice = (item) =&gt; maybeProp(&#39;price&#39;, item)

// getNestedPrice :: cart -&gt; Option a
const getNestedPrice = (cart) =&gt; getItem(cart).chain(getPrice)

getNestedPrice({}) // None()
getNestedPrice({item: {foo: 1}}) // None()
getNestedPrice({item: {price: 9.99}}) // Some(9.99)"><pre><span>// getItem :: Cart -&gt; Option CartItem</span>
<span>const</span> <span>getItem</span> <span>=</span> <span>(</span><span>cart</span><span>)</span> <span>=&gt;</span> <span>maybeProp</span><span>(</span><span>&#39;item&#39;</span><span>,</span> <span>cart</span><span>)</span>

<span>// getPrice :: Item -&gt; Option Number</span>
<span>const</span> <span>getPrice</span> <span>=</span> <span>(</span><span>item</span><span>)</span> <span>=&gt;</span> <span>maybeProp</span><span>(</span><span>&#39;price&#39;</span><span>,</span> <span>item</span><span>)</span>

<span>// getNestedPrice :: cart -&gt; Option a</span>
<span>const</span> <span>getNestedPrice</span> <span>=</span> <span>(</span><span>cart</span><span>)</span> <span>=&gt;</span> <span>getItem</span><span>(</span><span>cart</span><span>)</span><span>.</span><span>chain</span><span>(</span><span>getPrice</span><span>)</span>

<span>getNestedPrice</span><span>(</span><span>{</span><span>}</span><span>)</span> <span>// None()</span>
<span>getNestedPrice</span><span>(</span><span>{</span><span>item</span>: <span>{</span><span>foo</span>: <span>1</span><span>}</span><span>}</span><span>)</span> <span>// None()</span>
<span>getNestedPrice</span><span>(</span><span>{</span><span>item</span>: <span>{</span><span>price</span>: <span>9.99</span><span>}</span><span>}</span><span>)</span> <span>// Some(9.99)</span></pre></div>
<p dir="auto"><code>Option</code> is also known as <code>Maybe</code>. <code>Some</code> is sometimes called <code>Just</code>. <code>None</code> is sometimes called <code>Nothing</code>.</p>
<h2 dir="auto"><a id="user-content-function" aria-hidden="true" href="#function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Function</h2>
<p dir="auto">A <strong>function</strong> <code>f :: A =&gt; B</code> is an expression - often called arrow or lambda expression - with <strong>exactly one (immutable)</strong> parameter of type <code>A</code> and <strong>exactly one</strong> return value of type <code>B</code>. That value depends entirely on the argument, making functions context-independant, or <a href="#referential-transparency">referentially transparent</a>. What is implied here is that a function must not produce any hidden <a href="#side-effects">side effects</a> - a function is always <a href="#purity">pure</a>, by definition. These properties make functions pleasant to work with: they are entirely deterministic and therefore predictable. Functions enable working with code as data, abstracting over behaviour:</p>
<div data-snippet-clipboard-copy-content="// times2 :: Number -&gt; Number
const times2 = n =&gt; n * 2

;[1, 2, 3].map(times2) // [2, 4, 6]"><pre><span>// times2 :: Number -&gt; Number</span>
<span>const</span> <span>times2</span> <span>=</span> <span>n</span> <span>=&gt;</span> <span>n</span> <span>*</span> <span>2</span>

<span>;</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>.</span><span>map</span><span>(</span><span>times2</span><span>)</span> <span>// [2, 4, 6]</span></pre></div>
<h2 dir="auto"><a id="user-content-partial-function" aria-hidden="true" href="#partial-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Partial function</h2>
<p dir="auto">A partial function is a <a href="#function">function</a> which is not defined for all arguments - it might return an unexpected result or may never terminate. Partial functions add cognitive overhead, they are harder to reason about and can lead to runtime errors. Some examples:</p>
<div data-snippet-clipboard-copy-content="// example 1: sum of the list
// sum :: [Number] -&gt; Number
const sum = arr =&gt; arr.reduce((a, b) =&gt; a + b)
sum([1, 2, 3]) // 6
sum([]) // TypeError: Reduce of empty array with no initial value

// example 2: get the first item in list
// first :: [A] -&gt; A
const first = a =&gt; a[0]
first([42]) // 42
first([]) // undefined
// or even worse:
first([[42]])[0] // 42
first([])[0] // Uncaught TypeError: Cannot read property &#39;0&#39; of undefined

// example 3: repeat function N times
// times :: Number -&gt; (Number -&gt; Number) -&gt; Number
const times = n =&gt; fn =&gt; n &amp;&amp; (fn(n), times(n - 1)(fn))
times(3)(console.log)
// 3
// 2
// 1
times(-1)(console.log)
// RangeError: Maximum call stack size exceeded"><pre><span>// example 1: sum of the list</span>
<span>// sum :: [Number] -&gt; Number</span>
<span>const</span> <span>sum</span> <span>=</span> <span>arr</span> <span>=&gt;</span> <span>arr</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>b</span><span>)</span>
<span>sum</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span> <span>// 6</span>
<span>sum</span><span>(</span><span>[</span><span>]</span><span>)</span> <span>// TypeError: Reduce of empty array with no initial value</span>

<span>// example 2: get the first item in list</span>
<span>// first :: [A] -&gt; A</span>
<span>const</span> <span>first</span> <span>=</span> <span>a</span> <span>=&gt;</span> <span>a</span><span>[</span><span>0</span><span>]</span>
<span>first</span><span>(</span><span>[</span><span>42</span><span>]</span><span>)</span> <span>// 42</span>
<span>first</span><span>(</span><span>[</span><span>]</span><span>)</span> <span>// undefined</span>
<span>// or even worse:</span>
<span>first</span><span>(</span><span>[</span><span>[</span><span>42</span><span>]</span><span>]</span><span>)</span><span>[</span><span>0</span><span>]</span> <span>// 42</span>
<span>first</span><span>(</span><span>[</span><span>]</span><span>)</span><span>[</span><span>0</span><span>]</span> <span>// Uncaught TypeError: Cannot read property &#39;0&#39; of undefined</span>

<span>// example 3: repeat function N times</span>
<span>// times :: Number -&gt; (Number -&gt; Number) -&gt; Number</span>
<span>const</span> <span>times</span> <span>=</span> <span>n</span> <span>=&gt;</span> <span>fn</span> <span>=&gt;</span> <span>n</span> <span>&amp;&amp;</span> <span>(</span><span>fn</span><span>(</span><span>n</span><span>)</span><span>,</span> <span>times</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span><span>(</span><span>fn</span><span>)</span><span>)</span>
<span>times</span><span>(</span><span>3</span><span>)</span><span>(</span><span>console</span><span>.</span><span>log</span><span>)</span>
<span>// 3</span>
<span>// 2</span>
<span>// 1</span>
<span>times</span><span>(</span><span>-</span><span>1</span><span>)</span><span>(</span><span>console</span><span>.</span><span>log</span><span>)</span>
<span>// RangeError: Maximum call stack size exceeded</span></pre></div>
<h3 dir="auto"><a id="user-content-dealing-with-partial-functions" aria-hidden="true" href="#dealing-with-partial-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Dealing with partial functions</h3>
<p dir="auto">Partial functions are dangerous as they need to be treated with great caution. You might get an unexpected (wrong) result or run into runtime errors. Sometimes a partial function might not return at all. Being aware of and treating all these edge cases accordingly can become very tedious.
Fortunately a partial function can be converted to a regular (or total) one. We can provide default values or use guards to deal with inputs for which the (previously) partial function is undefined. Utilizing the <a href="#Option"><code>Option</code></a> type, we can yield either <code>Some(value)</code> or <code>None</code> where we would otherwise have behaved unexpectedly:</p>
<div data-snippet-clipboard-copy-content="// example 1: sum of the list
// we can provide default value so it will always return result
// sum :: [Number] -&gt; Number
const sum = arr =&gt; arr.reduce((a, b) =&gt; a + b, 0)
sum([1, 2, 3]) // 6
sum([]) // 0

// example 2: get the first item in list
// change result to Option
// first :: [A] -&gt; Option A
const first = a =&gt; a.length ? Some(a[0]) : None()
first([42]).map(a =&gt; console.log(a)) // 42
first([]).map(a =&gt; console.log(a)) // console.log won&#39;t execute at all
// our previous worst case
first([[42]]).map(a =&gt; console.log(a[0])) // 42
first([]).map(a =&gt; console.log(a[0])) // won&#39;t execte, so we won&#39;t have error here
// more of that, you will know by function return type (Option)
// that you should use `.map` method to access the data and you will never forget
// to check your input because such check become built-in into the function

// example 3: repeat function N times
// we should make function always terminate by changing conditions:
// times :: Number -&gt; (Number -&gt; Number) -&gt; Number
const times = n =&gt; fn =&gt; n &gt; 0 &amp;&amp; (fn(n), times(n - 1)(fn))
times(3)(console.log)
// 3
// 2
// 1
times(-1)(console.log)
// won&#39;t execute anything"><pre><span>// example 1: sum of the list</span>
<span>// we can provide default value so it will always return result</span>
<span>// sum :: [Number] -&gt; Number</span>
<span>const</span> <span>sum</span> <span>=</span> <span>arr</span> <span>=&gt;</span> <span>arr</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>+</span> <span>b</span><span>,</span> <span>0</span><span>)</span>
<span>sum</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span> <span>// 6</span>
<span>sum</span><span>(</span><span>[</span><span>]</span><span>)</span> <span>// 0</span>

<span>// example 2: get the first item in list</span>
<span>// change result to Option</span>
<span>// first :: [A] -&gt; Option A</span>
<span>const</span> <span>first</span> <span>=</span> <span>a</span> <span>=&gt;</span> <span>a</span><span>.</span><span>length</span> ? <span>Some</span><span>(</span><span>a</span><span>[</span><span>0</span><span>]</span><span>)</span> : <span>None</span><span>(</span><span>)</span>
<span>first</span><span>(</span><span>[</span><span>42</span><span>]</span><span>)</span><span>.</span><span>map</span><span>(</span><span>a</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>a</span><span>)</span><span>)</span> <span>// 42</span>
<span>first</span><span>(</span><span>[</span><span>]</span><span>)</span><span>.</span><span>map</span><span>(</span><span>a</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>a</span><span>)</span><span>)</span> <span>// console.log won&#39;t execute at all</span>
<span>// our previous worst case</span>
<span>first</span><span>(</span><span>[</span><span>[</span><span>42</span><span>]</span><span>]</span><span>)</span><span>.</span><span>map</span><span>(</span><span>a</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>a</span><span>[</span><span>0</span><span>]</span><span>)</span><span>)</span> <span>// 42</span>
<span>first</span><span>(</span><span>[</span><span>]</span><span>)</span><span>.</span><span>map</span><span>(</span><span>a</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>a</span><span>[</span><span>0</span><span>]</span><span>)</span><span>)</span> <span>// won&#39;t execte, so we won&#39;t have error here</span>
<span>// more of that, you will know by function return type (Option)</span>
<span>// that you should use `.map` method to access the data and you will never forget</span>
<span>// to check your input because such check become built-in into the function</span>

<span>// example 3: repeat function N times</span>
<span>// we should make function always terminate by changing conditions:</span>
<span>// times :: Number -&gt; (Number -&gt; Number) -&gt; Number</span>
<span>const</span> <span>times</span> <span>=</span> <span>n</span> <span>=&gt;</span> <span>fn</span> <span>=&gt;</span> <span>n</span> <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> <span>(</span><span>fn</span><span>(</span><span>n</span><span>)</span><span>,</span> <span>times</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span><span>(</span><span>fn</span><span>)</span><span>)</span>
<span>times</span><span>(</span><span>3</span><span>)</span><span>(</span><span>console</span><span>.</span><span>log</span><span>)</span>
<span>// 3</span>
<span>// 2</span>
<span>// 1</span>
<span>times</span><span>(</span><span>-</span><span>1</span><span>)</span><span>(</span><span>console</span><span>.</span><span>log</span><span>)</span>
<span>// won&#39;t execute anything</span></pre></div>
<p dir="auto">Making your partial functions total ones, these kinds of runtime errors can be prevented. Always returning a value will also make for code that is both easier to maintain as well as to reason about.</p>
<h2 dir="auto"><a id="user-content-functional-programming-libraries-in-javascript" aria-hidden="true" href="#functional-programming-libraries-in-javascript"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Functional Programming Libraries in JavaScript</h2>
<ul dir="auto">
<li><a href="https://github.com/swannodette/mori">mori</a></li>
<li><a href="https://github.com/facebook/immutable-js/">Immutable</a></li>
<li><a href="https://github.com/mweststrate/immer">Immer</a></li>
<li><a href="https://github.com/ramda/ramda">Ramda</a></li>
<li><a href="https://github.com/char0n/ramda-adjunct">ramda-adjunct</a></li>
<li><a href="https://github.com/tommmyy/ramda-extension">ramda-extension</a></li>
<li><a href="http://folktale.origamitower.com/" rel="nofollow">Folktale</a></li>
<li><a href="https://cwmyers.github.io/monet.js/" rel="nofollow">monet.js</a></li>
<li><a href="https://github.com/lodash/lodash">lodash</a></li>
<li><a href="https://github.com/jashkenas/underscore">Underscore.js</a></li>
<li><a href="https://github.com/dtao/lazy.js">Lazy.js</a></li>
<li><a href="https://github.com/sjsyrek/maryamyriameliamurphies.js">maryamyriameliamurphies.js</a></li>
<li><a href="https://github.com/casualjavascript/haskell-in-es6">Haskell in ES6</a></li>
<li><a href="https://github.com/sanctuary-js/sanctuary">Sanctuary</a></li>
<li><a href="https://github.com/evilsoft/crocks">Crocks</a></li>
<li><a href="https://github.com/fluture-js/Fluture">Fluture</a></li>
<li><a href="https://github.com/gcanti/fp-ts">fp-ts</a></li>
</ul>
<hr/>
<p dir="auto"><strong>P.S:</strong> This repo is successful due to the wonderful <a href="https://github.com/hemanth/functional-programming-jargon/graphs/contributors">contributions</a>!</p>
</article>
          </div></div>
  </body>
</html>
