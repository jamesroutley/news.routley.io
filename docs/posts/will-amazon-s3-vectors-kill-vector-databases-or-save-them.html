<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zilliz.com/blog/will-amazon-s3-vectors-kill-vector-databases-or-save-them">Original</a>
    <h1>Will Amazon S3 Vectors Kill Vector Databases–Or Save Them?</h1>
    
    <div id="readability-page-1" class="page"><div><p>Not too long ago, AWS dropped something new: <strong>S3 Vectors</strong>. It’s their first attempt at a vector storage solution, letting you store and query vector embeddings for semantic search right inside Amazon S3.</p>
<p>At a glance, it looks like a lightweight vector database running on top of low-cost object storage—at a price point that is clearly attractive compared to many dedicated vector database solutions.</p>
<p>
  <span>
    <img src="https://assets.zilliz.com/amazon_s3_vectors_83405bbdb1.png" alt="amazon s3 vectors.png" id="amazon-s3-vectors.png"/>
    <span>amazon s3 vectors.png</span>
  </span>
</p>
<p>Naturally, this sparked a lot of hot takes. I’ve seen folks on social media and in engineering circles say this could be the end of purpose-built vector databases—Milvus, Pinecone, Qdrant, and others included. Bold claim, right?</p>
<p>As the engineering architect of Milvus and someone who’s spent way too many late nights thinking about vector search, I have to admit that: <strong>S3 Vectors does bring something interesting to the table, especially around cost and integration within the AWS ecosystem. But instead of “killing” vector databases, I see it fitting into the ecosystem as a complementary piece. In fact, its real future probably lies in working</strong> <em><strong>with</strong></em> <strong>professional vector databases, not replacing them.</strong></p>
<p>In this post, I’ll walk you through why I think that—looking at it from three angles: the tech itself, what it can and can’t do, and what it means for the market.</p>
<p>Vector search is powerful, but it comes with a serious catch: <strong>it’s expensive.</strong> The computational demands are often one to two orders of magnitude higher than what you’d see in a typical NoSQL database. That gap isn’t just theoretical—it shows up in real bills.</p>
<p>I recently spoke with the CTO of a popular AI note-taking app who told me something surprising: they spend <em><strong>twice</strong></em> <em>as much</em> on vector search as they do on OpenAI API calls. Think about that for a second. Running the retrieval layer costs them more than paying for the LLM itself. That flips the usual assumption on its head.</p>
<p>The 2022 ChatGPT boom only made this more obvious. Suddenly, embeddings were everywhere, and vector data became the fastest-growing data type on the public cloud. <a href="https://zilliz.com/learn/Retrieval-Augmented-Generation">Retrieval-Augmented Generation (RAG)</a> was the driver—and with it came three challenges that reshaped what a vector database like <a href="https://milvus.io/">Milvus</a> had to do:</p>
<ul>
<li><p><strong>Massive data explosion</strong>: Workloads jumped from tens of millions to tens of billions of vectors almost overnight. That’s not linear growth—it’s a quantum leap, and it broke the old ways of handling data.</p></li>
<li><p><strong>Latency tolerance shifted</strong>: Since LLMs take time to generate responses anyway, users became more forgiving of slightly slower retrieval. The “sub-10ms recall at all costs” mindset suddenly mattered less.</p></li>
<li><p><strong>Cost sensitivity skyrocketed</strong>: Doubling or tripling data volume wasn’t just a storage problem; it became a financial crisis if you tried to scale using traditional compute-heavy designs.</p></li>
</ul>
<p>In short: vector databases had to evolve fast, not because the technology didn’t work, but because the economics of retrieval were suddenly front and center.</p>
<h2 id="The-Evolution-of-Vector-Storage-From-Memory-to-Disk-and-Now-to-Object-Storage">The Evolution of Vector Storage: From Memory to Disk, and Now to Object Storage</h2><p>The pressure around cost and scale forced one conclusion: vector databases couldn’t stay memory-only forever. They had to evolve—first to disk, and now to object storage like S3. This wasn’t a choice; it was an industry inevitability. And if you’ve been following the space, you’ve probably noticed the same trend I have over the last few years.</p>
<p>I’ve seen vector databases go through three distinct stages:</p>
<ul>
<li><p><strong>Phase I (2018–2022): The Pure Memory Era:</strong> In the early Milvus days, we leaned on memory indexes like HNSW and IVF. The performance and recall were fantastic—but the costs were brutal. Memory doesn’t scale cheaply, and everyone paying those cloud bills knew it.</p></li>
<li><p><strong>Phase II (2022–2024): The Disk Index Revolution:</strong> To break the memory bottleneck, we pioneered a disk-based approach using <a href="https://zilliz.com/learn/DiskANN-and-the-Vamana-Algorithm">DiskANN</a> along with our proprietary <a href="https://zilliz.com/blog/cardinal-most-performant-vector-search-engine">Cardinal</a> index (exclusive to <a href="https://zilliz.com/cloud">Zilliz Cloud</a>, the managed Milvus). With tricks like asynchronous I/O (AIO) and io_uring, we managed to squeeze real performance out of disks. The result? A 3–5x cost reduction. Our capacity-optimized compute units (CUs) quickly became bestsellers in Zilliz Cloud.</p></li>
<li><p><strong>Phase III (2024– ): The Tiered Storage Era:</strong> The next step was obvious: push vector indexes onto cheap object storage. New players like TurboPuffer went all-in on S3, dropping storage costs to ~$0.33/GB/month—a 10x reduction. But the trade-off was just as clear: cold query latency in the 500ms–1s range, and weaker recall precision.</p></li>
</ul>
<p>At <a href="https://zilliz.com/">Zilliz</a>, we’ve been working on tiered storage for a while, but we held back release until we could tame cold query performance. Next month, we’ll be rolling out our upgraded extended-capacity CUs with true hot/cold separation in Zilliz Cloud. That means stable cold query latency under 500ms, paired with ultra-high QPS for hot queries. In other words, the best of both worlds.</p>
<p>With tiered storage already proving itself, it’s no surprise that AWS jumped in with <strong>S3 Vectors</strong>. In fact, the release feels like a natural extension of what was already happening across the industry. Amazon had been expanding S3’s role with features like S3 Tables, evolving it from “just object storage” into a multi-modal cold storage backbone. Vectors are simply the next modality in that evolution—and it probably won’t stop there. Graphs, key-value, and time series data could all follow the same path.</p>
<p>And Amazon brings three undeniable advantages to the table:</p>
<ul>
<li><p><strong>Lower cost</strong>: among the lowest storage pricing in the industry.</p></li>
<li><p><strong>Massive scale</strong>: AWS’s machine pools can absorb almost any query load.</p></li>
<li><p><strong>Microservice-native architecture</strong>: perfectly aligned with vector indexing’s write–build–query workflow.</p></li>
</ul>
<p>Put together, these give S3 Vectors the makings of an ultra-low-cost, highly scalable cold storage solution for vectors.</p>
<p>As soon as S3 Vectors was announced, our team put it through comprehensive tests. The results were eye-opening—not just in terms of how cheap it is, but also where the cracks start to show.</p>
<p>There’s no denying it: S3 Vectors is incredibly cost-effective.</p>
<p>Storage runs at just $0.06/GB, roughly 5 times cheaper than most serverless vector solutions. For a representative workload—say 400 million vectors plus 10 million queries per month—the bill comes out to about $1,217/month. That’s more than a 10x reduction compared to traditional vector databases. For low-QPS, latency-tolerant workloads, it’s almost unbeatable.</p>
<ul>
<li><p><strong>Collection size limits:</strong> Each S3 table maxes out at 50M vectors, and you can only create up to 10,000 tables.</p></li>
<li><p><strong>Cold queries:</strong> Latency comes in at ~500ms for 1M vectors and ~700ms for 10M vectors.</p></li>
<li><p><strong>Hot queries:</strong> Latency stays under 200ms at 200 QPS, but pushing beyond that 200 QPS ceiling is tough.</p></li>
<li><p><strong>Write performance:</strong> Capped at under 2MB/s. That’s orders of magnitude lower than Milvus (which handles GB/s), though to its credit, writes don’t degrade query performance. Translation: it’s not designed for scenarios with large, frequently changing datasets.</p></li>
</ul>
<h3 id="Precision-and-Functionality-Trade-Offs">Precision and Functionality Trade-Offs</h3><p>The precision story is where things get tricky. Recall hovers at 85–90%, and you don’t get knobs to tune it higher. Layer on filters, and recall can drop below 50%. In one test where we deleted 50% of data, TopK queries asked for 20 results but could only return 15.</p>
<p>Functionality is also pared down. TopK queries max out at 30. Metadata per record has strict size limits. And you won’t find features like hybrid search, multi-tenancy, or advanced filtering—all of which are must-haves for many production applications.</p>
<p>After running tests and mapping them against familiar AWS design patterns, we’ve formed a pretty good hypothesis of how S3 Vectors works under the hood. While Amazon hasn’t published full details, the performance characteristics point to five core technologies:</p>
<p><strong>SPFresh Dynamic Indexing:</strong> Instead of rebuilding entire indexes after each write, S3 Vectors seems to update only the affected portions. This design keeps write costs low and availability high, but it comes at a price: recall rates slip by a few percentage points after updates.</p>
<p><strong>Deep Quantization (4-bit PQ):</strong> To cut down on S3’s I/O overhead, embeddings are likely compressed using 4-bit product quantization.</p>
<ul>
<li><p>The upside: storage is cheap, and queries stay fast.</p></li>
<li><p>The downside: recall flatlines around ~85%, and there are no knobs for developers to tune it higher.</p></li>
</ul>
<p><strong>Post-Filter Mechanism:</strong> Filtering looks to be applied after coarse retrieval. That keeps the index unified and simple, but it struggles with complex conditions. In our tests, when we deleted 50% of data, TopK queries requesting 20 results returned only 15—classic signs of a post-filter pipeline. This also suggests Amazon leaned heavily on existing open-source index designs rather than building a custom one from scratch.</p>
<p><strong>Multi-Tier Caching:</strong> Hot queries behave much faster, likely thanks to an SSD/NVMe cache sitting in front of S3. But when a query misses the cache, latency jumps significantly. That pattern fits a multi-tier cache hierarchy built to mask object storage’s inherent slowness.</p>
<p><strong>Large-Scale Distributed Scheduling:</strong> AWS has no shortage of machine pools. S3 Vectors appears to spread the workload across microservices, pipelining the <strong>read → decompress → search</strong> flow. The result is what we observed in tests: a remarkably stable latency distribution, even under heavy load.</p>
<p>After putting S3 Vectors through its paces, it’s clear that it shines in some scenarios and falls short in others. Like most infrastructure tools, it’s not a one-size-fits-all solution—it’s the right tool for the right job.</p>
<ul>
<li><p><strong>Cold data archiving:</strong> Perfect for storing history datasets that are rarely accessed. If you can live with 500ms+ query times, the cost savings are unbeatable.</p></li>
<li><p><strong>Low-QPS RAG queries:</strong> Think of small internal tools or chatbots that run only dozens of queries per day, staying under 100 QPS. For these use cases, latency isn’t a dealbreaker.</p></li>
<li><p><strong>Low-cost prototyping:</strong> Great for proof-of-concept projects where the goal is to test an idea without spending heavily on infrastructure.</p></li>
</ul>
<ul>
<li><p><strong>High-performance search and recommendation:</strong> If your application needs sub-50ms latency, S3 Vectors simply isn’t built for it.</p></li>
<li><p><strong>High-volume writes or frequent updates:</strong> Performance degrades quickly, and recall precision drops noticeably under heavy churn.</p></li>
<li><p><strong>Complex query workloads:</strong> There’s no support for hybrid search, aggregations, or other advanced querying features.</p></li>
<li><p><strong>Multi-tenant production apps:</strong> With a hard cap of 10,000 buckets, it’s not designed for large-scale multi-tenant deployments.</p></li>
</ul>
<p>In other words, S3 Vectors is excellent for cold, cheap, low-QPS scenarios—but it’s not the engine you want to power a recommendation system, a real-time search app, or any high-scale production system.</p>
<p>S3 Vectors doesn’t spell the end of vector databases—it confirms something many of us have been seeing for a while: <strong>the future is tiered storage</strong>. Instead of keeping every vector in expensive memory or fast disk, workloads will naturally spread across hot, warm, and cold tiers based on how often it’s accessed and what kind of latency the application can tolerate.</p>
<p>
  <span>
    <img src="https://assets.zilliz.com/tiered_storage_0c15f13e5d.png" alt="" id=""/>
    <span></span>
  </span>
</p>
<p>Here’s what that looks like in practice:</p>
<ul>
<li><p><strong>Hot Data Layer (&lt;50ms)</strong> – This is where real-time search, recommendations, and targeted ads live. Latency needs to be under 50ms, which means specialized vector databases are still the best option. They’re optimized for both blazing speed and high query throughput.</p></li>
<li><p><strong>Warm Data Layer (50–500ms)</strong> – Many RAG-based applications and multi-tenant shared services fall here. These workloads don’t need ultra-low latency, but they do need predictable performance at lower cost. S3 Vectors and Milvus’s tiered storage instances fit this middle ground.</p></li>
<li><p><strong>Cold Data Layer (&gt;500ms)</strong> – Historical archives and offline analysis don’t require real-time responses, so latency in the hundreds of milliseconds is acceptable. What matters here is cost efficiency at massive scale. This is where solutions like S3 + Spark/Daft or the Milvus vector data lake shine.</p></li>
</ul>
<p>The hot–warm–cold split balances <strong>latency, cost, and scale</strong> in a way that no single storage tier can cover on its own. It’s a pattern we’ve seen before in relational databases, data warehouses, and even CDNs—and vector storage is now following the same trajectory. This three-tier architecture also lines up closely with the roadmap we’ve been building for Milvus and Zilliz Cloud.</p>
<p>AI applications don’t live neatly in separate “online” and “offline” worlds. In reality, data moves constantly between the two. That’s why with the upcoming <strong>Milvus 3.0,</strong> we will introduce a <strong>vector data lake</strong>, designed to support both real-time retrieval and offline processing from the same dataset.</p>
<p>In practice, this means one dataset can power your live RAG and search queries, while also feeding into Spark-based offline analysis—for example, curating training data for LLMs. No duplication, no juggling two different pipelines.</p>
<p>We will also roll out the <strong>StorageV2 format</strong> for the vector data lake, which takes the economics to another level:</p>
<ul>
<li><p>Up to <strong>100x cheaper</strong> for cold data storage.</p></li>
<li><p>Up to <strong>100x faster</strong> than brute-force Spark queries on hot data.</p></li>
</ul>
<p>The result is a unified system that minimizes redundancy, keeps costs under control, and makes working with vector data a lot less painful.</p>
<p>Over the past two years, AI applications have been moving fast—and so have the requirements for the infrastructure behind them. At Zilliz, we’ve pushed Milvus forward in step with those needs, shipping capabilities like <a href="https://milvus.io/blog/get-started-with-hybrid-semantic-full-text-search-with-milvus-2-5.md">BM25 + vector hybrid search</a>, <a href="https://milvus.io/blog/build-multi-tenancy-rag-with-milvus-best-practices-part-one.md">multi-tenant</a> isolation, <a href="https://milvus.io/blog/introduce-milvus-2-6-built-for-scale-designed-to-reduce-costs.md#Hot-Cold-Tiered-Storage-50-Cost-Reduction-Through-Intelligent-Data-Placement">hot–cold tiered storage</a>, and <a href="https://milvus.io/blog/minhash-lsh-in-milvus-the-secret-weapon-for-fighting-duplicates-in-llm-training-data.md">MinHash</a> deduplication, along with a long list of developer-focused improvements.</p>
<p>Our philosophy has been simple: when you combine deep understanding of business use cases with the latest technology, you unlock entirely new infrastructure possibilities. That’s the mindset shaping <strong>Milvus 3.0</strong>, which will bring a new wave of AI-native features designed directly for real-world applications. Among them:</p>
<ul>
<li><p><strong>Keyword weighting in search</strong> – So a query like <em>“red phone”</em> can prioritize <em>red</em> appropriately.</p></li>
<li><p><strong>Geolocation support</strong> – Store and query location-aware vectors to handle prompts like <em>“find nearby coffee shops.”</em></p></li>
<li><p><strong>Multi-vector support for RAG</strong> – Attach multiple embeddings to each text, improving recall and accuracy in complex retrieval tasks.</p></li>
<li><p><strong>Flexible UDF processing</strong> – User-defined functions for richer, customizable data processing.</p></li>
<li><p><strong>Visual analytics tools</strong> – Deeper offline mining and data exploration at scale.</p></li>
</ul>
<p>And that’s just the start. The bigger point is that Milvus is evolving into a system that’s not only efficient and scalable, but <strong>AI-native at its core</strong>—purpose-built for how modern applications actually work.</p>
<p>At Zilliz, we believe that: <strong>a 10x cost reduction opens the door to 100x more application use cases</strong>. That principle has guided every big milestone in Milvus. Since 2022, we’ve introduced disk-based indexes, GPU acceleration, and <a href="https://milvus.io/blog/bring-vector-compression-to-the-extreme-how-milvus-serves-3×-more-queries-with-rabitq.md">RabitQ quantization</a>—all of which have pushed query performance up by orders of magnitude while driving costs down.</p>
<p>Looking ahead, our focus is on squeezing even more efficiency out of the stack:</p>
<ul>
<li><p><strong>Deeper hardware optimization</strong> – Tuning for raw compute power and IOPS performance.</p></li>
<li><p><strong>Smarter compression and quantization</strong> – Making vectors lighter without giving up accuracy.</p></li>
<li><p><strong>Early termination for index queries</strong> – Cutting off wasted computation as soon as we have confident results.</p></li>
<li><p><strong>Refined tiered indexing</strong> – Better cache utilization for faster access to cold data.</p></li>
</ul>
<p>The end goal hasn’t changed: build infrastructure that just works out of the box, scales on demand, and stays both fast and affordable.</p>
<p>A lot of people worry that S3 Vectors will make traditional vector databases obsolete. My take is the opposite: its release is good news for the entire industry. In fact, I see three big benefits.</p>
<ul>
<li><p><strong>It validates demand.</strong> No one can claim vectors are just a fad anymore. If AWS is building a product around it, that’s proof positive that vector storage is a real necessity—not just “indexes wrapped in a database.”</p></li>
<li><p><strong>It educates the market.</strong> With AWS’s reach, more enterprises are now aware of vector databases, which expands the boundaries of what applications can be built.</p></li>
<li><p><strong>It drives innovation.</strong> Competition pushes all of us—Milvus included—to optimize harder, cut costs further, and find differentiated strengths.</p></li>
</ul>
<p>From a positioning standpoint, S3 Vectors looks less like a complete vector database and more like the <strong>cold tier of vector storage</strong>. Its low cost makes it especially attractive for scenarios that were previously priced out: small teams building RAG apps, individual developers experimenting, or organizations indexing massive datasets with only basic retrieval needs. That’s a real unlock for the ecosystem.</p>
<p>Personally, I also want to acknowledge the AWS engineering team. They’ve been steadily improving their platform—from Lambda debugging to cold start performance—and S3 Vectors is another example of thoughtful product innovation. I’m genuinely curious to see what developers will build now that the economics are this favorable.</p>
<p><strong>So no, the vector database market isn’t being disrupted—it’s maturing into a tiered ecosystem where different solutions serve different performance and cost needs.</strong> That’s good for enterprises, good for developers, and good for the overall AI infrastructure stack.</p>
<p>The golden age of vector databases isn’t over—it’s just beginning.</p>
</div></div>
  </body>
</html>
