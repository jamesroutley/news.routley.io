<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://littlemaninmyhead.wordpress.com/2025/08/31/inverting-the-xorshift128-random-number-generator/">Original</a>
    <h1>Inverting the Xorshift128 random number generator</h1>
    
    <div id="readability-page-1" class="page"><article id="post-1672">
	<!-- .entry-header -->

	<div>
		
<p><a href="https://hackerone.com/reports/2913312">CVE-2025-7783</a> is a very recent vulnerability affecting a lot of applications in the Node.js ecosystem including those which use <a href="https://github.com/axios/axios/pull/6970">axios</a> or the deprecated request library. In all honesty, this vulnerability is really an edge case that is extremely unlikely to be exploited: it is dependent upon a number of events that are not normally present. One of those events is the attacker having access to <em>five</em> consecutive outputs of JavaScript <code>Math.random( )</code>, which allows the attacker to predict future outputs of <code>Math.random( )</code> using the <a href="https://www.microsoft.com/en-us/research/project/z3-3/">z3 solver</a> as a <a href="https://github.com/benweissmann/CVE-2025-7783-poc/blob/main/predict.py">predictor</a>.</p>



<p>When I looked into this attack, I couldn’t believe that z3 was the best one can do to “invert” (determine the internal seed) of the <code><code>Math.random( )</code></code> generator. As a former cryptographer, I said to myself surely it is enough to only have 2 or 3 outputs to invert it. So I decided to prove it.</p>



<p>This blog is about my first step in the journey to find an improved algorithm. <code><code>Math.random( )</code></code> uses an algorithm called Xorshift128+ under the hood, but it only outputs 52 of the 64-bits that Xorshift128+ generates. Below I will show a simple and efficient (2<sup>26</sup> operations) way to invert Xorshift128+ if at least two complete 64-bit outputs are given. This can be turned into an algorithm that inverts the full <code><code>Math.random( )</code></code>, but it will require 3 outputs and currently it is somewhat inefficient (2<sup>50</sup> operations). I expect this will be improved later by either me or somebody else, perhaps you.</p>



<p>Ten years ago I wrote a blog called <a href="https://littlemaninmyhead.wordpress.com/2015/09/28/so-you-want-to-learn-to-break-ciphers/">So, You Want to Learn to Break Ciphers</a> which has had about 30,000 views. This blog aligns nicely with that previous one: nothing below is particularly complicated. I expect that a competent computer science graduate could understand it and potentially improve on it. So to the aspiring or amateur cryptographer, I invite you to give it a crack! You can <a href="https://github.com/ScottContini/a_better_xorshift128-inverter">download my source code from GitHub</a> and work to improve it.</p>



<h2>The Xorshift128+ algorithm</h2>



<p>The source code for the Xorshift128+ used in <code><code>Math.random( )</code></code> (v8 engine) can be found <a href="https://github.com/v8/v8/blob/085fed0fb5c3b0136827b5d7c190b4bd1c23a23e/src/base/utils/random-number-generator.h#L102">here</a>. Yep, it is written in C++. The code is transcribed below:</p>



<pre><code>static inline void XorShift128(uint64_t* state0, uint64_t* state1) {
  uint64_t s1 = *state0;
  uint64_t s0 = *state1;
  *state0 = s0;
  s1 ^= s1 &lt;&lt; 23;
  s1 ^= s1 &gt;&gt; 17;
  s1 ^= s0;
  s1 ^= s0 &gt;&gt; 26;
  *state1 = s1;
}</code></pre>



<p>It takes in two 64-bit states, state0 and state1. At the end of the algorithm, the new state0 becomes the old state1 and the new state1 is entirely determined by exclusive-or operations of various bits from the old state0 and state1. Note that the bit shifts essentially select which bits get mixed into each position of the new state1. <code><code>Math.random( )</code></code> performs an <a href="https://github.com/v8/v8/blob/085fed0fb5c3b0136827b5d7c190b4bd1c23a23e/src/base/utils/random-number-generator.h#L97">integer addition of the new state values</a> and converts it to a double, which is the output. This is also where bits are dropped because a 64-bit unsigned int cannot be represented exactly as a double.</p>



<p>In our analysis, we are going to assume that we have the full 64-bit output of the new state0 + state1. We will show at the end how to deal without having that full output.</p>



<p>We’re going to need some notation rather than saying “old state” and “new state” all the time.  Also, in my first write-up of this attack, I came to believe that the whole “state0” and “state1” gets too confusing and intimidating when I bring in other notation, so I decided to rename it.  Going forward, <strong>we will refer to state0 as L (for left) and state1 as R (for right)</strong>.</p>



<p>With that, I will introduce some notation starting with a subscript to indicate which iteration. The initial seed will be at iteration 0, denoted (L<sub>0</sub>, R<sub>0</sub>). The function at iteration i takes (L<sub>i</sub>, R<sub>i</sub>) and maps it to (L<sub>i+1</sub>, R<sub>i+1</sub>), and the output is x<sub>i</sub> = L<sub>i+1</sub> + R<sub>i+1</sub>.</p>



<p>Visually, XorShift128( ) looks like this:</p>



<figure><a href="https://littlemaninmyhead.wordpress.com/wp-content/uploads/2025/08/xorshiftl_r.png"><img data-attachment-id="1696" data-permalink="https://littlemaninmyhead.wordpress.com/2025/08/31/inverting-the-xorshift128-random-number-generator/xorshiftl_r/" data-orig-file="https://littlemaninmyhead.wordpress.com/wp-content/uploads/2025/08/xorshiftl_r.png" data-orig-size="571,531" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="XorShift+L_R" data-image-description="" data-image-caption="" data-medium-file="https://littlemaninmyhead.wordpress.com/wp-content/uploads/2025/08/xorshiftl_r.png?w=300" data-large-file="https://littlemaninmyhead.wordpress.com/wp-content/uploads/2025/08/xorshiftl_r.png?w=571" width="571" height="531" src="https://littlemaninmyhead.wordpress.com/wp-content/uploads/2025/08/xorshiftl_r.png?w=571" alt="" srcset="https://littlemaninmyhead.wordpress.com/wp-content/uploads/2025/08/xorshiftl_r.png 571w, https://littlemaninmyhead.wordpress.com/wp-content/uploads/2025/08/xorshiftl_r.png?w=150 150w, https://littlemaninmyhead.wordpress.com/wp-content/uploads/2025/08/xorshiftl_r.png?w=300 300w" sizes="(max-width: 571px) 100vw, 571px"/></a><figcaption>Visual representation of Xorshift128+ where L is state0 and R is state1</figcaption></figure>



<h2>Beating brute force is easy</h2>



<p>Brute force involves trying all possibilities. There are two 64-bit states, so 128 bits are unknown. Brute force means trying all 2<sup>128</sup> operations.</p>



<p>It is easy to see that in fact we only need to brute force R<sub>1</sub> because x<sub>0</sub> = L<sub>1</sub> + R<sub>1</sub> (this comes directly from the Xorshift128+ first output). In other words, if we know the correct R<sub>1</sub> then we can determine L<sub>1</sub> because we also know x<sub>0</sub>, the observed output. This is just subtraction.</p>



<p>But how can we determine whether our brute force guess is correct for R<sub>1</sub>? We feed the combined “candidate” values (L<sub>1</sub>, R<sub>1</sub>) into the real Xorshift128+ to get a candidate value (L<sub>2</sub>, R<sub>2</sub>) and if the sum of those values matches the observed x<sub>1</sub> then we are fairly confident that our guess is correct. You can observe this by trialing <a href="https://github.com/ScottContini/a_better_xorshift128-inverter/blob/main/a_better_inverter.c">my GitHub implementation</a>: when you feed in two outputs, most of the time there is only one solution. In the cases that there is more than one solution, you will need one more observed output to check the guess.</p>



<p>Hence, it is sufficient to know only one of the 64-bit states if you have two observed outputs. Our search space is now reduced to 2<sup>64</sup> operations. That’s a bit of improvement, but it is still too slow.</p>



<h2>A 2<sup>26</sup> algorithm to determine the internal state given at least 2 observed outputs</h2>



<p>Beating brute force was easy, now we have to be a little bit clever. What we show here is that if you know only the least significant 26 bits of R<sub>1</sub> then you can determine with certainty the remaining bits of L<sub>1</sub> and R<sub>2</sub>. Assuming that, it means that we only need to search all 2<sup>26</sup> possibilities for these least significant bits and then we can determine which one is correct by calculating the remaining unknown bits (with the algorithms to be shown below) and testing it similar to how we described the attack for brute force above.</p>



<p>Before getting into details, it is important to understand searching 2<sup>26</sup> space is very doable. This is what my GitHub implementation does. It is not optimised for speed yet, but still only takes a few seconds on my MacBook Pro. I’ll talk about implementation enhancements later.</p>



<p>Now time to get our hands dirty. To get the 2<sup>26</sup> algorithm, we need two tools. One of them you already know, we just need to write out a bit more:</p>



<p>    x<sub>0</sub> = L<sub>1</sub> + R<sub>1</sub></p>



<p>    x<sub>1</sub> = L<sub>2</sub> + R<sub>2</sub></p>



<p>These are unsigned integer additions which is the same as saying mod 2<sup>64</sup>. Now also remember how Xorshift128+ works: R<sub>1</sub> = L<sub>2</sub> (see visual diagram above).  It is more convenient to write these equations as:</p>



<p>    L<sub>1</sub> = x<sub>0</sub> – R<sub>1</sub></p>



<p>    R<sub>2</sub> = x<sub>1</sub> – R<sub>1</sub></p>



<p>In the above, if we assume we know R<sub>1</sub> then we know the right hand sides of both equations, so it means we can also calculate L<sub>1</sub> and R<sub>2</sub>.</p>



<p>Next, look at the Xorshift128+ code (remembering that we are using L and R in replace of state0 and state1) and think about how bit index j of R<sub>2</sub> is calculated from bit indices in (L<sub>1</sub>, R<sub>1</sub>). We need more notation here, so we will bring in brackets: R<sub>2</sub>[j] will refer to index j of R<sub>2</sub>, meaning the bit <code>(R<sub>2</sub> &gt;&gt; j) &amp; 1</code> in C code. By expanding the shifts in the code, which gets a little bit tricky because the <code>^=</code> terms are compounding state values from one iteration to the next (for example <code>s1 ^= s1 &lt;&lt; 23</code> followed by <code>s1 ^= s1 &gt;&gt; 17</code> results in a certain set of bits being mixed in at an index of <code>&lt;&lt; 6</code>), we end up with (caret symbol denotes XOR):</p>



<p>    <code>R<sub>2</sub>[j] = L<sub>1</sub>[j-23] ^ R<sub>1</sub>[j-6] ^ L<sub>1</sub>[j] ^ L<sub>1</sub>[j+17] ^ R<sub>1</sub>[j] ^ R<sub>1</sub>[j+26]</code></p>



<p>This holds for 23 &lt;= j &lt; 38. For smaller values of j, L<sub>1</sub>[j-23] drops out (i.e. these bits are shifted off the end and hence do not contribute) and similarly for j &lt; 6 we have R<sub>1</sub>[j-6] dropped out.</p>



<p>It is convenient to bring the R<sub>1</sub>[j+26] to the left hand side and the R<sub>2</sub>[j] to the right hand side (simple algebra, xor the values on each side) and we get this equation which we shall call <strong>the inductive equation</strong>:</p>



<p>    <code><code>R<sub>1</sub>[j+26]</code></code> <code>= L<sub>1</sub>[j-23] ^ R<sub>1</sub>[j-6] ^ L<sub>1</sub>[j] ^ L<sub>1</sub>[j+17] ^ R<sub>1</sub>[j] ^ R<sub>2</sub>[j]</code></p>



<p>That’s the hardest part of everything we do, so if you are with me so far, then the rest is a lot easier. The beauty of the above equation is that <strong>the left hand side is computing bit index j+26 of <strong>R<sub>1</sub></strong> using bit indices that are smaller for L<sub>1</sub> and R<sub>1</sub> and R<sub>2</sub></strong>. It tells us that if we know all these lower significant bits, then we can calculate exactly the next most significant bit of R<sub>1</sub>. You should be noticing the 26 on the left hand side and remember that I promised a 2<sup>26</sup> algorithm, so things are starting to come together.</p>



<p>So far it might look like I did a little sleight of hand because the inductive equation is not just involving lower significant bits of R<sub>1</sub> but also lower significant bits of L<sub>1</sub> and R<sub>2</sub>. But this is where the observed outputs come into play. We can derive exactly the least significant bits of these states because the equations above also hold mod 2<sup>(j+26)</sup>:</p>



<p>    L<sub>1</sub> = x<sub>0</sub> – R<sub>1</sub> mod 2<sup>j+26</sup></p>



<p>    R<sub>2</sub> = x<sub>1</sub> – R<sub>1</sub> mod 2<sup>j+26</sup></p>



<p>What it means is that as we calculate each new bit of R<sub>1</sub> using the inductive equation, we also calculate the corresponding least significant bits of L<sub>1</sub> and R<sub>2</sub>.</p>



<p>So in summary, the pseudo code for this attack is as follows:</p>



<pre><code>For each possible guess of the least 26 significant bits of R<sub>1</sub>:
  - Use inductive equation to derive 64-bit candidates L<sub>1</sub>, R<sub>1</sub> and R<sub>2</sub>
  - Compute Xorshift128+(L<sub>1</sub>, R<sub>1</sub>) and let y<sub>1</sub> be output sum from new states
  - If (x<sub>1</sub> == y<sub>1</sub>) then solution found (break)
  - Else our guess is wrong (continue)</code></pre>



<p>We can also bring in x<sub>2</sub> to the testing to increase certainty.</p>



<h2>Speed optimisations</h2>



<p>These do not get the 2<sup>26</sup> any lower, but instead make each iteration faster. One of these I have implemented already, the other I have not done so yet because that will make the code harder to read.</p>



<ul>
<li>The way we described the algorithm above, we update the least significant bits of states L<sub>1</sub> and R<sub>2</sub> in every iteration. We don’t need to update those states yet if they are not used in the next iteration, instead we can delay it until we need it, which means we are doing less work per iteration. This is implemented in my code.</li>



<li>Deriving consecutive bits of R<sub>1</sub> also involves consecutive bits of L<sub>1</sub> and R<sub>2</sub>. That means that rather that computing each bit one at a time, we can do some type of time-memory tradeoff using table lookups (after an initial precomputing tables phase) so long as the bits do not require updating the corresponding bits of L<sub>1</sub> and R<sub>2</sub> every iteration (i.e. the enhancement above). I expect this to make the code at least a few times faster.</li>
</ul>



<h2>Translating the above attack to a full <code>Math.random()</code></h2>



<p>The whole problem with making this work for <code>Math.random( )</code> is that the least significant bits are exactly the ones that are dropped when it is converted to a double. We lose the 12 least significant bits of both x<sub>0</sub> and x<sub>1</sub>.</p>



<p>We can make up for that by brute forcing the 2<sup>24</sup> possibilities for the least significant bits and essentially do the same algorithm above. The main problem is that we’re going to have a lot more false positives, so we definitely need the third output x<sub>2</sub> to weed them out. It’s possible that we need more outputs, but I doubt it. The heuristic reasoning here is that we are losing 24 bits for comparison in the first two iterations but we are gaining 52 bits, which more than makes up for what we lost. So if you believe two outputs is usually enough for inverting Xorshift128+ (this can be observed from my code on GitHub which returns all seed that match two observed outputs), then I think it is also convincing that three outputs should be enough for inverting <code>Math.random( )</code>.</p>



<p>Since we are guessing 24 more bits in addition to the 26 in the original algorithm, we are now searching a space of 2<sup>50</sup>. There should be ways to improve it, especially if we think about how we can use x<sub>2</sub> more intelligently in the algorithm.</p>



<h2>One last remark: on the use of AI to break ciphers</h2>



<p>This is a story for another day, but I actually spent more time than I expected to get this working and one of the reasons why is because I thought I could explain my ideas to ChatGPT and get it to program the idea. I was truly amazed to see ChatGPT understand my reasoning and even come up with its own ideas to help improve the research. But the downfall was in trusting ChatGPT to output the code to prove it. It unfortunately led to one problem after another, which ended up wasting a huge amount of my time. In the end, I decided to start from scratch and not let it write hardly any code, with the exception of <a href="https://github.com/ScottContini/a_better_xorshift128-inverter/blob/main/a_better_inverter.c#L202">one small snippet</a> that it did a lot quicker than I would have done.</p>



<p>But I still have to say I took great value in explaining my ideas and getting feedback from the bot. I strongly recommend researchers to start using tools like this. While at first they may result in productivity sinks, we will eventually get to understand them better and know when to trust them and when to say no to them. Also, these tools will only improve over time. I seriously think there will be a day when such tools are outputting research results better than humans. I’ll comment more on that in my next blog.</p>



<p>My complete conversation with ChatGPT for this research can be found <a href="https://chatgpt.com/share/68b3d90b-7a10-800e-a906-8e02d4086a68">here</a>.</p>
			</div><!-- .entry-content -->

	<!-- .entry-footer -->
</article></div>
  </body>
</html>
