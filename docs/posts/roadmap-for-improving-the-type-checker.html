<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://forums.swift.org/t/roadmap-for-improving-the-type-checker/82952">Original</a>
    <h1>Roadmap for Improving the Type Checker</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
              
<p>In the past, we&#39;ve released various &#34;manifestos&#34; and &#34;roadmaps&#34; to discuss planned improvements to the language. This post is also a roadmap of sorts, but instead, the focus is on the implementation rather than user-visible language changes (however, I will briefly mention a few potential language changes at the very end).</p>
<p>Specifically, I&#39;m going to talk about some work we are doing to improve expression type checking in the Swift compiler. This includes changes that have already shipped in Swift 6.2, changes that are on the <code>main</code> development branch, changes that we plan on working on next, and more tentative longer-term plans.</p>
<p>Before talking about specific improvements, I&#39;m going to start with a rather long explanation of this part of the compiler implementation, which to my knowledge has not been summarized in one place yet.</p>
<h2><a name="p-380928-introduction-2" href="#p-380928-introduction-2"></a>Introduction</h2>
<p>This is all, of course, about the dreaded <code>the compiler is unable to type-check this expression in reasonable time</code> error. This error can appear with both valid and invalid code, and the various workarounds are unsatisfactory, to say the least. Splitting up an expression into smaller pieces, introducing type annotations, or attempting other refactorings will sometimes allow valid code to type check, or in the invalid case, surface an actionable diagnostic. However, this breaks flow and becomes a frustrating process of trial and error &#34;shotgun debugging&#34; even for the most experienced Swift programmers. The compiler doesn&#39;t even <em>tell you</em> if your expression is valid or not!</p>
<h3><a name="p-380928-type-based-overloading-3" href="#p-380928-type-based-overloading-3"></a>Type-based overloading</h3>
<p>Swift supports <em>overloading</em>, where multiple declarations in the same scope can share the same name. Swift allows two forms of overloading: by argument labels, or by type. The former case is ultimately handled by name lookup, because argument labels are specified at the call site. Argument label lookup does not introduce any algorithmic complexity in the type checker, so I won&#39;t discuss it further. Type-based overloading, on the other hand, requires the type checker to reason about the types of expressions before it can decide the correct overload to pick, which is a more difficult problem. So in the rest of this post, when I talk about overloading, I&#39;m specifically referring to overloading based on types---either parameter or result types.</p>
<h3><a name="p-380928-constraint-solving-4" href="#p-380928-constraint-solving-4"></a>Constraint solving</h3>
<p>The Swift compiler implements overload resolution by transforming expression type checking into a <em>constraint solving</em> problem.  The compiler always looks at a single expression at a time (with some exceptions, such as multi-statement closures), and proceeds to type-check each expression in turn.</p>
<p>First, we introduce <em>type variables</em> to represent the unknown type of each sub-expression in the syntax tree. Next, we generate <em>constraints</em> to describe relationships among type variables. Examples of constraints include &#34;type <code>X</code> is a subtype of type <code>Y</code>&#34;, &#34;type <code>X</code> is the result of calling function type <code>Y</code> with arguments <code>Z</code>&#34;, and crucially for overload resolution, what are called <em>disjunction constraints</em>. A disjunction constraint has the form &#34;type <code>X</code> is either <code>Y1</code>, or <code>Y2</code>, or <code>Y3</code>, ... or <code>Yn</code>&#34;, where each <code>Yn</code> is the type of an overloaded declaration with the same name.</p>
<p>Once we have our type variables and constraints, we proceed to <em>solve</em> the constraint system by attempting to assign a concrete type to each type variable, in a manner that is consistent with the set of constraints. A set of such assignments is called a <em>solution</em>. The constraint solving process can produce zero, one, or many solutions. If no solution was found, the expression is erroneous. If one solution was found, we&#39;re done; if multiple solutions were found, we first attempt to <em>rank</em> the solutions in case one of them is clearly &#34;better&#34; than the others. If this ranking fails to produce a winner, we diagnose an ambiguity error.</p>
<h3><a name="p-380928-algorithmic-complexity-5" href="#p-380928-algorithmic-complexity-5"></a>Algorithmic complexity</h3>
<p>The algorithmic complexity in constraint solving arises as a result of these disjunction constraints, because in the worst case, there is no better approach to solving such a constraint system except to attempt each combination of disjunction choices.</p>
<p>This is somewhat like solving a Sudoku. You can write down a number in a blank square, and then check that the result is a valid board. If it is, you try to fill in another square, and so on. On the other hand, if you get stuck, you <em>backtrack</em> by erasing a previously filled in square, and attempt to place a number somewhere else. If you&#39;re lucky and make perfect a guess at each step, you can fill in the whole board without backtracking. At the other extreme, you might end up attempting every possible path to a solution, which can take a long time.</p>
<p>For a more detailed overview of constraint solving in the Swift type checker, see <a href="https://github.com/swiftlang/swift/blob/main/docs/TypeChecker.md">swift/docs/TypeChecker.md at main · swiftlang/swift · GitHub</a>. For an explanation of why overload resolution is inherently hard, and why every known approach has exponential running time in the <em>worst</em> case, see <a href="https://forums.swift.org/t/how-does-compiler-compile-swiftui-code/78483/4">How does compiler compile SwiftUI code? - #4 by Slava_Pestov</a> and <a href="https://learn.microsoft.com/en-us/archive/blogs/ericlippert/lambda-expressions-vs-anonymous-methods-part-five">Lambda Expressions vs. Anonymous Methods, Part Five | Microsoft Learn</a>.</p>
<h3><a name="p-380928-what-does-reasonable-time-mean-6" href="#p-380928-what-does-reasonable-time-mean-6"></a>What does <code>reasonable time</code> mean?</h3>
<p>Since constraint solving with disjunctions takes exponential time in the worst case, it will always be possible to write down a short program that would require an inordinate amount of time to type check, so the type checker must limit the total amount of work that it does, and fail if this limit is reached.</p>
<p>The Swift type checker imposes two such limits:</p>
<ul>
<li>Every time we attempt a disjunction choice, we increment a counter. The counter is reset to zero at the start of each expression, and if the value exceeds one million, we give up.</li>
<li>The constraint solver also allocates various data structures in a per-expression <em>arena</em>, which is then torn down in one shot once type checking this expression ends. If the total size of the arena exceeds 512 megabytes, we give up.</li>
</ul>
<p>In the past, Swift also had a wall-clock time limit, but this is no longer enabled by default, because it is non-deterministic across machines. Counting operations is a better approach, and most &#34;too complex&#34; expressions don&#39;t take longer than 4 seconds on a typical machine in practice.</p>
<h3><a name="p-380928-invalid-expressions-salvage-mode-and-diagnostics-7" href="#p-380928-invalid-expressions-salvage-mode-and-diagnostics-7"></a>Invalid expressions, salvage mode, and diagnostics</h3>
<p>In ordinary type checking, the solver stops and backtracks immediately when a constraint fails, but this does not in itself produce precise error messages.</p>
<p>To get good diagnostics after a failure, we restart the solving process again, this time with an expanded search space. This is called &#34;salvage mode.&#34; In salvage mode, a failure to solve a constraint is handled differently. Instead of simply failing the constraint and stopping the solver, we proceed as if the failed constraint succeeded, but we also record a <em>fix</em>.</p>
<p>For example, if an expression does not type-check because <code>Int</code> does not conform to <code>Sequence</code>, then this conformance constraint will fail on the first attempt. We then restart type checking in salvage mode. When the bogus constraint comes up again, we pretend that <code>Int</code> actually <em>does</em> conform to <code>Sequence</code>, but we record a fix, and continue solving more constraints until we&#39;re done.</p>
<p>Once we finish solving the constraint system in salvage mode, the collected fixes are then analyzed to produce a diagnostic. Finally, if salvage mode fails but no fixes are recorded, we emit the <code>failed to produce diagnostic</code> error.</p>
<p>For more details about the diagnostic architecture, see <a href="https://www.swift.org/blog/new-diagnostic-arch-overview/">New Diagnostic Architecture Overview | Swift.org</a>.</p>

<p>While the worst case behavior is unavoidable, it does not have to be the case that type checking must take exponential time on <em>all</em> expressions, even when complex overload sets are involved. In fact, <em>most</em> expressions do type-check rather quickly, even today. It is also true that for any given single &#34;hard&#34; expression, it is possible to devise a heuristic that will solve it quickly, because in the extreme case, you can hard-code knowledge of that <em>specific</em> problem instance in the constraint solver (of course, we won&#39;t do that).</p>
<p>The main goal then, is to devise sufficiently-general heuristics which can quickly solve most realistic problem instances, without hard-coding too many special cases, so that hopefully, the exponential running time only appears with pathological examples which are unlikely to occur in practice. The primary way to accomplish this is to <strong>attempt disjunction choices in the right order</strong>---this includes both choosing the next disjunction to attempt, and the next choice within a disjunction to attempt. Also, we can <strong>avoid considering disjunction choices that lead to contradictions</strong>. By doing this, we can find the valid solutions more quickly, and spend less time exploring long &#34;dead ends.&#34;</p>
<p>A secondary goal is to <strong>improve the auxiliary data structures and algorithms</strong> used in the constraint solver, so that even if an exhaustive search must be attempted on a given expression, as will sometimes be the case, we burn less CPU time while considering the same search space.</p>
<p>There are also two non-goals worth mentioning:</p>
<ol>
<li>
<p><strong>Removing overloading from the language.</strong> Without disjunction constraints, a constraint system can almost always be solved very quickly. However, this would be such a major change to the language, and break so many existing APIs, that it is not feasible to attempt at this point, even as a new language mode.</p>
</li>
<li>
<p><strong>Removing bidirectional inference.</strong> We can also imagine a language design where expressions are type-checked in a strictly bottom-up fashion, starting from the leaves, like in many other C-family languages. This is another drastic simplification that essentially trivializes the whole problem. However, this would require giving up on language features such as polymorphic literals, leading-dot member syntax, closures with inferred types, and parts of generics. All of these are features that make Swift into the expressive language it is today.</p>
</li>
</ol>

<h2><a name="p-380928-swift-62-10" href="#p-380928-swift-62-10"></a>Swift 6.2</h2>
<p>In Swift 6.2, we spent time profiling the type checker with various larger projects, as well as individual slow expressions, both valid and invalid. This uncovered some bottlenecks, including with the backtracking implementation, various graph algorithms such as computing connected components, and other miscellaneous algorithms.</p>
<p>The first example is an invalid expression where we can see a small improvement. Consider the last line of the below code listing, which appeared in this <a href="https://danielchasehooper.com/posts/why-swift-is-slow/">blog post</a>:</p>
<pre data-code-wrap="swift"><code>let address = &#34;127.0.0.1&#34;
let username = &#34;steve&#34;
let password = &#34;1234&#34;
let channel = 11

let url = &#34;http://&#34; + username 
            + &#34;:&#34; + password 
            + &#34;@&#34; + address 
            + &#34;/api/&#34; + channel 
            + &#34;/picture&#34;
</code></pre>
<p>The expression is invalid as written, because there is no overload of <code>+</code> taking an <code>Int</code> and a <code>String</code>. On my machine, Swift 6.1 spends 10 seconds to produce an <code>unable to type-check</code> error, while in Swift 6.2, we get the same error in 6 seconds. Of course, this is not the desired end state, since we should instead produce a meaningful diagnostic. However, this example specifically illustrates that the type checker is able to do the same amount of work in less time.</p>
<p>For a more realistic example, I measured a project that makes heavy use of overloading and generics, and saw that total type checking time improved from 42 seconds in Swift 6.1, down to 34 seconds in Swift 6.2.</p>
<h2><a name="p-380928-swift-63-11" href="#p-380928-swift-63-11"></a>Swift 6.3</h2>
<h3><a name="p-380928-optimized-disjunction-selection-12" href="#p-380928-optimized-disjunction-selection-12"></a>Optimized disjunction selection</h3>
<p>Recent <code>main</code> development snapshots introduced a large set of changes that <a href="https://forums.swift.org/u/xedin">@xedin</a> has been working on for several years now, to improve disjunction selection, by collecting more information to decide what disjunction should be attempted next. Unlike the targeted optimizations in Swift 6.2 which offered incremental wins without reducing the fundamental complexity of the problem, the disjunction selection changes allow the type checker to quickly solve many expressions that we were formerly unable to type-check. The new algorithm can also drastically speed up expressions that would type check, but were just under the limit and thus slow.</p>
<p>These changes replace some older optimizations that would look at the entire expression before solving begins, to attempt &#34;pre-solving&#34; certain sub-expressions. These hacks were rather brittle in practice, so a small change to an expression could defeat the entire hack.</p>
<p>The optimized disjunction selection algorithm instead runs as part of the constraint solver, making it more robust and predictable. The biggest wins can be seen with expressions that involve math operators and literals. Here is a typical example. The Swift 6.2 compiler was unable to type check the below expression, but the compiler from <code>main</code> type checks this successfully, in 4 milliseconds:</p>
<pre data-code-wrap="swift"><code>func test(n: Int) -&gt; Int {
  return n == 0 ? 0 : (0..&lt;n).reduce(0) { x, y in
    (x &gt; 0 &amp;&amp; y % 2 == 0) ? (((x + y) - (x + y)) / (y - x)) + ((x + y) / (y - x)) : x
  }
}
</code></pre>
<p>The invalid expression from above, where <code>+</code> was applied to <code>String</code> and <code>Int</code>, is still rejected, however with the new algorithm, it only takes the compiler 2 seconds to reach the limit.</p>
<p>Finally, on the same project I mentioned in the Swift 6.2 summary above, the new algorithm yields a further reduction in total type checking time, down to 12 seconds.</p>
<p>(If you find an expression that type checks on a released version of Swift but fails on a <code>main</code> development snapshot, please file a GitHub issue.)</p>
<h3><a name="p-380928-optimized-constraint-solver-arena-usage-13" href="#p-380928-optimized-constraint-solver-arena-usage-13"></a>Optimized constraint solver arena usage</h3>
<p>Recent <code>main</code> development snapshots also introduce an optimization which eliminates a source of exponential <em>space</em> usage in the constraint solver. This optimization is still disabled by default, but we hope to enable it <a href="https://github.com/swiftlang/swift/pull/84993">soon</a>. (You can enable it with the <code>-solver-enable-prepared-overloads</code> frontend flag on a <code>main</code> development snapshot if you&#39;d like to test it now.)</p>
<p>This optimization works as follows. Previously, when attempting a disjunction choice for a generic overload, the solver would generate new type variables and constraints corresponding to the generic parameters and <code>where</code> clause requirements of the generic overload. If the same overload had to be attempted multiple times, in combination with other overload choices, the same type variables and constraints would be generated every time. These type variables and constraints are allocated in the constraint solver&#39;s arena. This space optimization instead allocates these structures once, the first time a disjunction choice is attempted.</p>
<p>For many expressions, this leads to a drastic reduction in constraint solver arena usage. In some instances, it will transform an exponential <em>space</em> problem into a polynomial <em>space</em> problem, even if it still requires exponential <em>time</em>. Furthermore, since less space also means less time, the primary benefit here is again a reduction in total type checking time. In the future, pre-generating these structures will also enable further improvements to the disjunction choice algorithm.</p>
<p>On the invalid expression from earlier, where <code>+</code> was applied to <code>String</code> and <code>Int</code>, the constraint solver arena space optimization further reduces the time to reach the limit, down to 1.7 seconds. (That&#39;s a more than 5x improvement since Swift 6.1.)</p>
<p>Finally, with the same test project I mentioned twice above, this optimization decreases total type checking time from 12 seconds, down to 10 seconds. (That&#39;s a more than 4x improvement since Swift 6.1.)</p>
<h3><a name="p-380928-expanding-our-test-suite-to-cover-more-fast-and-slow-expressions-14" href="#p-380928-expanding-our-test-suite-to-cover-more-fast-and-slow-expressions-14"></a>Expanding our test suite to cover more fast and slow expressions</h3>
<p>To help prevent performance regressions in the future, and to track progress on solving the problem, we have added more test cases to our suite. These have been reduced from user-reported slow expressions in GitHub issues for the Swift project.</p>
<p>Some of the test cases also use our <code>scale-test</code> tool, which repeats a common element of an expression (think adding <code>+ 1 + 1 + 1 ...</code>), measures the performance of each instance, and then attempts to guess if the resulting problem scales in polynomial or exponential time. This helps catch more subtle issues where a given expression might still appear to be &#34;fast&#34;, but becomes slow if you make it just a little bit longer.</p>
<p>These test cases are found in the <a href="https://github.com/swiftlang/swift/tree/main/validation-test/Sema/type_checker_perf">validation-test/Sema/type_checker_perf</a> directory in the Swift repo. The recently added test cases are in <a href="https://github.com/swiftlang/swift/pull/84450">Sema: Collected expression checking performance test cases from GitHub issues by slavapestov · Pull Request #84450 · swiftlang/swift · GitHub</a>, with a few more in <a href="https://github.com/swiftlang/swift/pull/84890">Even more type checker perf tests by slavapestov · Pull Request #84890 · swiftlang/swift · GitHub</a>. We hope to continue expanding the type checker performance test suite over time.</p>

<p><strong>Disclaimer:</strong> all of the below is subject to change as our plans evolve.</p>
<h2><a name="p-380928-optimizing-bindings-16" href="#p-380928-optimizing-bindings-16"></a>Optimizing bindings</h2>
<p>Imagine we&#39;re solving a constraint system, and we&#39;re left with a single unsolved constraint, a conversion from a type variable <code>T0</code> to <code>Optional&lt;Int&gt;</code>. At this point, in order to proceed, we must &#34;guess&#34; the concrete type to bind to <code>T0</code>. While <code>T0</code> might just be <code>Optional&lt;Int&gt;</code>, another valid choice is <code>Int</code>, because <code>Int</code> converts to <code>Optional&lt;Int&gt;</code>. The <em>bindings</em> subsystem in the constraint solver is responsible for tracking the potential bindings for each type variable by considering unsolved conversion constraints, and ultimately, attempting various potential bindings until a solution is found.</p>
<p>The book-keeping for bindings is rather complicated, and must be updated incrementally as constraints are solved and new constraints are introduced. Another complication is that to choose the next binding to attempt, we must consider all type variables and all of their potential bindings, and rank them according to a heuristic.</p>
<p>Today, this ranking process indeed considers all type variables and all bindings, and ultimately picks just one type variable and just one binding to attempt. This must be repeated for each unbound type variable, which of course results in a <em>quadratic time</em> algorithm.</p>
<p>Thus, even in a constraint system without a large number of complex overloads, it is sometimes possible to observe algorithmic complexity due to bindings. Now, most expressions do not involve a large number of type variables---it is far more common to see a large number of disjunction choices instead. But one situation where a large number of type variables are generated is if you write an <strong>array or dictionary literal</strong> with a large number of elements.</p>
<p>We plan on overhauling the data structures for tracking potential bindings, both to eliminate some duplicate bookkeeping (<code>BindingSet</code> and <code>PotentialBindings</code> in the implementation) and to make the <em>choice</em> of the next binding to attempt something that can be done in constant or logarithmic time, instead of the current situation where it is linear in the number of type variables. This will radically speed up the type checking of large array and dictionary literals.</p>
<p>Since solving constraints can introduce new bindings, an important decision problem is whether a binding set is &#34;complete&#34;. Today, this check is very conservative, so we often don&#39;t attempt bindings until we&#39;ve gone far down a path of disjunction choices. More accurate computation of when a binding set is complete would allow bindings to be attempted sooner, which would reduce algorithmic complexity of type-checking many common expressions.</p>
<p>Another improvement to the bindings logic would allow the solver to reach a contradiction by considering contradictory bindings. Today, if a type variable <code>T0</code> is subject to two conversion constraints, for example to <code>Optional&lt;Int&gt;</code> and <code>Optional&lt;String&gt;</code>, we don&#39;t reach a contradiction until we attempt every possible concrete type for <code>T0</code>. But in this case, there is no concrete type that converts to both <code>Optional&lt;Int&gt;</code> and <code>Optional&lt;String&gt;</code>, and so a contradiction could be reached faster, avoiding wasting time exploring dead ends.</p>
<p>These improvements to the binding logic should speed up many expressions, including long collection literals as I mentioned, and also the aforesaid invalid expression where <code>+</code> was applied to <code>String</code> and <code>Int</code>, where we should finally be able to quickly produce an actionable diagnostic.</p>
<h2><a name="p-380928-removing-more-performance-hacks-17" href="#p-380928-removing-more-performance-hacks-17"></a>Removing more performance hacks</h2>
<p>While the new disjunction selection algorithm subsumed many old performance hacks, some hacks remain. Once again, these hacks tend to be applicable in narrow cases only, which introduces performance cliffs when small changes are made to an expression, and they also have &#34;load-bearing&#34; semantic effects which complicate the language model. These will be generalized or subsumed by existing optimizations over time.</p>
<p>It&#39;s worth noting that fixing some of these might be source-breaking in extreme edge cases, but we think this is worth the small inconvenience it may cause. Aside from improving performance, this will make the language semantics easier to reason about, and also improve diagnostics.</p>
<p>To make this more concrete, here are a few random examples of hacks that we hope to eliminate:</p>
<ul>
<li>Subscripting of <code>Array</code> and <code>Dictionary</code> types is handled in a special way, with a narrow optimization that dates back all the way to Swift 1.0 (<code>inferCollectionSubscriptResultType()</code>). It can result in strange overload resolution behavior in some cases, and of course it doesn&#39;t generalize to subscripts on user-defined types.</li>
<li>When simplifying a function call constraint, we look for the case where all overloads have a common return type (<code>simplifyAppliedOverloadsImpl()</code>). This does not handle generic return types at all, and has some strange edge-case behaviors.</li>
<li>There is an optimization that kicks in when a generic overload set has exactly two overloads (<code>tryOptimizeGenericDisjunction()</code>). This is an obvious performance cliff if a third overload is added, even if its not used in the expression.</li>
<li>A set of optimizations attempt to skip some disjunction choices entirely, and &#34;partition&#34; overload sets for math operators into generic, concrete, and SIMD overloads. This is too specific to math operators, and again leads to strange behavior where a concrete overload is chosen even though a generic overload would result in better solutions or diagnostics.</li>
</ul>
<h2><a name="p-380928-optimizing-the-handling-of-partial-solutions-18" href="#p-380928-optimizing-the-handling-of-partial-solutions-18"></a>Optimizing the handling of partial solutions</h2>
<p>One of the steps in our constraint solver algorithm constructs a <em>constraint graph</em>, where the vertices are type variables, and the edges relate each pair of type variables that appear in the same constraint. An important optimization detects a situation where this graph has more than one connected component, in which case each component can be solved independently. The &#34;partial solutions&#34; that we obtain from solving each component are then merged to form a solution for the overall constraint system.</p>
<p>In many situations, this can avoid exponential behavior. However, in other situations where a large number of partial solutions are produced, building the data structures representing these partial solutions, and the merging algorithm itself, can dominate type checking time for a given expression.</p>
<p>By building upon the &#34;trail&#34; data structure for speeding up backtracking that was introduced in Swift 6.2, we hope to reduce the overhead caused by partial solutions in those pathological cases. A specific class of expression where this tends to arise is when you have a large collection literal and each element is itself a complex expression.</p>
<h2><a name="p-380928-improving-salvage-mode-19" href="#p-380928-improving-salvage-mode-19"></a>Improving salvage mode</h2>
<p>While not strictly performance-related, we would also like to eliminate more cases where salvage mode fails to record any fixes, which as I mentioned above, results in the unhelpful <code>failed to produce diagnostic</code> error.</p>
<p>In fact, another odd situation can arise with salvage mode today: there are known examples where normal type checking fails, but salvage mode then <em>succeeds</em>, in which case we accept the expression. This is a performance problem right off the bat, because such an expression must essentially be type checked twice before a solution is found, even though it is valid.</p>
<p>This is also not intended by design, and it involves certain corners of the language which are not well-understood or tested. Fixing these situations will improve performance in pathological cases, while also cleaning up these edge cases in the language, and improving test coverage. Ultimately, if salvage succeeds in this way, we plan to have the solver emit another &#34;fallback diagnostic&#34; instead of silently proceeding.</p>
<p>Finally, if normal type-checking produces multiple valid solutions, we still enter salvage mode today, before we generate an ambiguity diagnostic. This should not be necessary, and addressing this will speed up diagnostics for certain invalid ambiguous expressions. This will also reduce the probability that salvage mode, which must do more work by design, will then fail with an &#34;unable to type-check&#34; error, instead of emitting an actionable diagnostic using information already gleaned from normal type checking.</p>

<p>I&#39;m going to end this post with more tentative ideas, that while not fully fleshed out, have the potential drastically improve type checking performance.</p>
<h2><a name="p-380928-changes-to-operator-lookup-21" href="#p-380928-changes-to-operator-lookup-21"></a>Changes to operator lookup</h2>
<p>So far, I&#39;ve only talked about changes which are (mostly) source-compatible, and this has been our main focus to date. However, while we&#39;ve ruled out drastic solutions such as removing overloading or bidirectional inference entirely, we are considering some more targeted language changes, which would be rolled out with upcoming features or language modes.</p>
<p>Consider the <code>==</code> operator. This operator is heavily-overloaded, but most overloads are implementations of the <code>Equatable</code>  protocol&#39;s <code>==</code> requirement. In principle, we could avoid attempting each one in turn, simplifying the constraint system that we generate for any expression that involves <code>==</code>.</p>
<p>We plan to investigate a scheme where we prune overload sets to hide overloads that witness a protocol requirement, which will simplify overload sets for <code>==</code> as well as many other (but not all) operators.</p>
<p>This will require changing the rules for solution ranking, which today always prefer concrete overloads; however, we will need to prefer the generic <code>Equatable.==</code> overload in many instances as well. For this reason, such a change might be slightly source breaking, at least in pathological cases, but it might be possible to stage in a way that avoids disruption for realistic programs.</p>
<h2><a name="p-380928-changes-to-polymorphic-literals-22" href="#p-380928-changes-to-polymorphic-literals-22"></a>Changes to polymorphic literals</h2>
<p>A common misconception is that polymorphic literals, like integers and strings, themselves introduce overloads, where every concrete type conforming to an <code>ExpressibleBy*</code> protocol adds a disjunction choice to the literal. This isn&#39;t quite right; a literal such as <code>&#34;hello world&#34;</code> will type check if a concrete type is known from the surrounding code, and if that fails, via a default type, which is <code>String</code> in this case. So while this acts as a disjunction of sorts, in this case the disjunction only has two choices, and often the default is not attempted at all.</p>
<p>However, an integer literal such as <code>123</code> actually has two default types, <code>Int</code> and <code>Double</code>, and the resulting disjunction has three choices. It might be worth considering a language change where floating point literals must be spelled with a decimal point. Today, expressions involving mixed integer and double literals can be particularly tricky to type check, for this reason.</p>
<h2><a name="p-380928-improved-constraint-solving-techniques-23" href="#p-380928-improved-constraint-solving-techniques-23"></a>Improved constraint solving techniques</h2>
<p>Once we are further along with various refactorings and cleanups described above, we will be in a position to implement more advanced constraint solving techniques, such as those commonly used in SAT solvers today. &#34;SAT,&#34; or Boolean formula satisfiability, is a related problem to operator overloading. (Like overload resolution, SAT takes exponential time to solve in the worst case, but unlike overload resolution, the &#34;domain&#34; of each type variable is a true or false value. Instead of &#34;constraints&#34;, the problem instance consists of a Boolean formula built up from &#34;and&#34;, &#34;or&#34;, and &#34;not&#34; operations.) Many of the techniques used to speed up SAT solvers can be applied to constraint solving.</p>
<p>A solver that supports <strong>non-chronological backtracking</strong> can jump back over more than one disjunction choice once it detects a contradiction. This avoids the exploration of more dead-ends that necessarily fail, because some constraint further up is already unsatisfiable.</p>
<p>Another technique is <strong>clause learning</strong>. The &#34;naive&#34; approach to constraint solving will discard all state changes when backtracking after a contradiction is discovered. In a solver with clause learning, the algorithm will, roughly speaking, &#34;learn&#34; facts as it goes, recording new constraints that result from backtracking. This ensures that if the same situation arises again, the contradiction can be detected sooner because of the &#34;learned&#34; constraint.</p>
<p>(For those curious to learn more about SAT solvers, here is a blog post I saw the other day with a good summary: <a href="https://vaibhavsagar.com/blog/2025/10/22/satisfying-solutions/">SATisfying Solutions to Difficult Problems! - Vaibhav Sagar</a>. A book with a decent introduction is &#34;The Satisfiability Problem&#34; by Schóning and Torán. An in-depth treatment appears in Knuth Volume 4B. Finally, a recent academic paper titled <a href="https://se.cs.uni-tuebingen.de/publications/benes2025overloading.pdf">The simple essence of overloading</a> by Beneš and Brachthäuser, outlines an interesting approach to overload resolution where the problem is reduced to a <a href="https://en.wikipedia.org/wiki/Binary_decision_diagram">binary decision diagram</a>. Some of the ideas here may apply to Swift type checking as well.)</p>

<p>There are quite a number of interesting improvements that can be made to the Swift type checker, and we look forward to sharing more updates as we make progress in this area.</p>
            </div></div>
  </body>
</html>
