<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://marc.info/?l=openbsd-tech&amp;m=169841790407370&amp;w=2">Original</a>
    <h1>OpenBSD: Removing syscall(2) from libc and kernel</h1>
    
    <div id="readability-page-1" class="page">
<pre><b>[<a href="https://marc.info/?l=openbsd-tech&amp;m=169840739832111&amp;w=2">prev in list</a>] [<a href="https://marc.info/?l=openbsd-tech&amp;m=169842095809570&amp;w=2">next in list</a>] [<SPAN color="#c0c0c0">prev in thread</SPAN>] [<a href="https://marc.info/?l=openbsd-tech&amp;m=169842095809570&amp;w=2">next in thread</a>] </b>
<b><SPAN size="+1">
List:       <a href="https://marc.info/?l=openbsd-tech&amp;r=1&amp;w=2">openbsd-tech</a>
Subject:    <a href="https://marc.info/?t=169841803800006&amp;r=1&amp;w=2">Removing syscall(2) from libc and kernel</a>
From:       <a href="https://marc.info/?a=146809448200002&amp;r=1&amp;w=2">&#34;Theo de Raadt&#34; &lt;deraadt () openbsd ! org&gt;</a>
Date:       <a href="https://marc.info/?l=openbsd-tech&amp;r=1&amp;w=2&amp;b=202310">2023-10-27 14:45:41</a>
Message-ID: <a href="https://marc.info/?i=69276.1698417941%20()%20cvs%20!%20openbsd%20!%20org">69276.1698417941 () cvs ! openbsd ! org</a></SPAN>
[Download RAW <a href="https://marc.info/?l=openbsd-tech&amp;m=169841790407370&amp;q=mbox">message</a> or <a href="https://marc.info/?l=openbsd-tech&amp;m=169841790407370&amp;q=raw">body</a>]</b>

Piece by piece, I&#39;ve been trying to remove the easiest of the
terminal-actions that exploit code uses (ie. getting to execve, or performing
other system calls, etc).

I recognize we can never completely remove all mechanisms they
use. However, I hope I am forcing attack coders into using increasingly
more complicated methods. Same time, it means fewer methods are
available.  Other methods make exploitation more fragile.  This is
pushing success rates into &#34;low-percent statistical&#34; success. If we
teach more software stacks to &#34;fail hard, don&#39;t try to recover&#34;, that is
an improvement in security.

I already made it difficult to call execve() directly in a few ways.
The kernel must be entered via the exact syscall instruction, inside the
libc syscall stub.  Immediately before that syscall instruction, the
SYS_execve instruction is loaded into a register.  On some
architectures, the PLT-reachable stub performs a retguard check, which
can be triggered by a few methods.  Stack pivots are also mostly
prevented because of other checks.  It is not possible to enter via
the SYS_syscall (syscall register = 0) case either.

Attack code can try to do perform other system calls, to create
filesystem damage or network communication.  They could still load other
syscall numbers and jump to a found syscall instruction, if they are
able to cheat the retguard epilogue (It is a bit unfortunate that libc
syscall stubs tend to use the same save register, but at least the
compare offset is chosen random at compile time).  Or, they could know
where all the system calls are from a pre-read libc, which requires them
to be on the machine before performing an online or offline attack (libc
is random relinked, but still readable in the filesystem).  It&#39;s
difficult to discover code-locations online only, because most
architectures also have xonly code now.  Some methods can use PLT
entries (which also vary based upon random relink), but I&#39;ve not seem
much methodology using PLT entry + offset.

Anyways, everyone of these things I mention, and the ones I don&#39;t mention,
tend to be more difficult than the previous methods.  I&#39;m trying to remove
simple methods, and force attackers into more and more complex methods.
I promise that I will circle back and damage the more complex methods in
the future.


So in this next step, I&#39;m going to take away the ability to perform syscall #0
(SYS_syscall), with the first argument being the real system call.

This library interface, and all the pieces below it, will be going away:

    <a href="https://man.openbsd.org/syscall.2" rel="nofollow">https://man.openbsd.org/syscall.2</a>

There&#39;s going to be some fallout which takes time to fix, especially in the
&#34;go&#34; ecosystem.

Snapshots for some architectures now contain kernel diffs which reject
syscall(2).  The symbol still remains libc.

I&#39;m including a piece of this diff.




Index: sys/arch/alpha/alpha/trap.c
===================================================================
RCS file: /cvs/src/sys/arch/alpha/alpha/trap.c,v
diff -u -p -u -r1.108 trap.c
--- sys/arch/alpha/alpha/trap.c	8 Mar 2023 04:43:07 -0000	1.108
+++ sys/arch/alpha/alpha/trap.c	27 Oct 2023 03:26:49 -0000
@@ -497,17 +497,15 @@ dopanic:
  * a3, and v0 from the frame before returning to the user process.
  */
 void
-syscall(code, framep)
-	u_int64_t code;
-	struct trapframe *framep;
+syscall(u_int64_t code, struct trapframe *framep)
 {
-	const struct sysent *callp;
+	const struct sysent *callp = sysent;
 	struct proc *p;
-	int error, indirect = -1;
+	int error;
 	u_int64_t opc;
 	u_long rval<a name="-2"></a><a href="#2">[2]</a>;
 	u_long args<a name="-10"></a><a href="#10">[10]</a>;					/* XXX */
-	u_int hidden, nargs;
+	u_int nargs;
 
 	atomic_add_int(&amp;uvmexp.syscalls, 1);
 	p = curproc;
@@ -515,24 +513,11 @@ syscall(code, framep)
 	framep-&gt;tf_regs[FRAME_SP] = alpha_pal_rdusp();
 	opc = framep-&gt;tf_regs[FRAME_PC] - 4;
 
-	switch(code) {
-	case SYS_syscall:
-		indirect = code;
-		code = framep-&gt;tf_regs[FRAME_A0];
-		hidden = 1;
-		break;
-	default:
-		hidden = 0;
-	}
-
-	error = 0;
-	callp = sysent;
-	if (code &gt;= SYS_MAXSYSCALL)
-		callp += SYS_syscall;
-	else
-		callp += code;
+	if (code &lt;= 0 || code &gt;= SYS_MAXSYSCALL)
+		goto bad;
+	callp += code;
 
-	nargs = callp-&gt;sy_narg + hidden;
+	nargs = callp-&gt;sy_narg;
 	switch (nargs) {
 	default:
 		if (nargs &gt; 10)		/* XXX */
@@ -559,7 +544,7 @@ syscall(code, framep)
 	rval<a name="-0"></a><a href="#0">[0]</a> = 0;
 	rval<a name="-1"></a><a href="#1">[1]</a> = 0;
 
-	error = mi_syscall(p, code, indirect, callp, args + hidden, rval);
+	error = mi_syscall(p, code, callp, args, rval);
 
 	switch (error) {
 	case 0:
Index: sys/arch/amd64/amd64/locore.S
===================================================================
RCS file: /cvs/src/sys/arch/amd64/amd64/locore.S,v
diff -u -p -u -r1.141 locore.S
--- sys/arch/amd64/amd64/locore.S	24 Oct 2023 13:20:09 -0000	1.141
+++ sys/arch/amd64/amd64/locore.S	27 Oct 2023 03:26:49 -0000
@@ -508,6 +508,7 @@ ENTRY(savectx)
 	lfence
 END(savectx)
 
+// XXX this should not behave like a nop
 IDTVEC(syscall32)
 	sysret		/* go away please */
 END(Xsyscall32)
Index: sys/arch/amd64/amd64/trap.c
===================================================================
RCS file: /cvs/src/sys/arch/amd64/amd64/trap.c,v
diff -u -p -u -r1.101 trap.c
--- sys/arch/amd64/amd64/trap.c	5 Jul 2023 12:58:55 -0000	1.101
+++ sys/arch/amd64/amd64/trap.c	27 Oct 2023 03:26:49 -0000
@@ -553,7 +553,7 @@ syscall(struct trapframe *frame)
 	caddr_t params;
 	const struct sysent *callp;
 	struct proc *p;
-	int error, indirect = -1;
+	int error = ENOSYS;
 	size_t argsize, argoff;
 	register_t code, args<a name="-9"></a><a href="#9">[9]</a>, rval<a href="#2">[2]</a>, *argp;
 
@@ -570,26 +570,9 @@ syscall(struct trapframe *frame)
 	argp = &amp;args<a href="#0">[0]</a>;
 	argoff = 0;
 
-	switch (code) {
-	case SYS_syscall:
-		/*
-		 * Code is first argument, followed by actual args.
-		 */
-		indirect = code;
-		code = frame-&gt;tf_rdi;
-		argp = &amp;args<a href="#1">[1]</a>;
-		argoff = 1;
-		break;
-	default:
-		break;
-	}
-
-	callp = sysent;
-	if (code &lt; 0 || code &gt;= SYS_MAXSYSCALL)
-		callp += SYS_syscall;
-	else
-		callp += code;
-
+	if (code &lt;= 0 || code &gt;= SYS_MAXSYSCALL)
+		goto bad;
+	callp = sysent + code;
 	argsize = (callp-&gt;sy_argsize &gt;&gt; 3) + argoff;
 	if (argsize) {
 		switch (MIN(argsize, 6)) {
@@ -620,7 +603,7 @@ syscall(struct trapframe *frame)
 	rval<a href="#0">[0]</a> = 0;
 	rval<a href="#1">[1]</a> = 0;
 
-	error = mi_syscall(p, code, indirect, callp, argp, rval);
+	error = mi_syscall(p, code, callp, argp, rval);
 
 	switch (error) {
 	case 0:
Index: sys/arch/arm/arm/syscall.c
===================================================================
RCS file: /cvs/src/sys/arch/arm/arm/syscall.c,v
diff -u -p -u -r1.26 syscall.c
--- sys/arch/arm/arm/syscall.c	11 Feb 2023 23:07:26 -0000	1.26
+++ sys/arch/arm/arm/syscall.c	27 Oct 2023 03:26:49 -0000
@@ -93,8 +93,8 @@ void
 swi_handler(trapframe_t *frame)
 {
 	struct proc *p = curproc;
-	const struct sysent *callp;
-	int code, error, indirect = -1;
+	const struct sysent *callp = sysent;
+	int code, error;
 	u_int nap = 4, nargs;
 	register_t *ap, *args, copyargs[MAXARGS], rval<a href="#2">[2]</a>;
 
@@ -103,32 +103,19 @@ swi_handler(trapframe_t *frame)
 	/* Before enabling interrupts, save FPU state */
 	vfp_save();
 
-	/* Re-enable interrupts if they were enabled previously */
-	if (__predict_true((frame-&gt;tf_spsr &amp; PSR_I) == 0))
-		enable_interrupts(PSR_I);
+	enable_interrupts(PSR_I);
 
 	p-&gt;p_addr-&gt;u_pcb.pcb_tf = frame;
 
 	/* Skip over speculation-blocking barrier. */
 	frame-&gt;tf_pc += 8;
 
-	code = frame-&gt;tf_r12;
-
 	ap = &amp;frame-&gt;tf_r0;
 
-	switch (code) {	
-	case SYS_syscall:
-		indirect = code;
-		code = *ap++;
-		nap--;
-		break;
-	}
-
-	callp = sysent;
-	if (code &lt; 0 || code &gt;= SYS_MAXSYSCALL)
-		callp += SYS_syscall;
-	else
-		callp += code;
+	code = frame-&gt;tf_r12;
+	if (code &lt;= 0 || code &gt;= SYS_MAXSYSCALL)
+		goto bad;
+	callp += code;
 
 	nargs = callp-&gt;sy_argsize / sizeof(register_t);
 	if (nargs &lt;= nap) {
@@ -145,27 +132,23 @@ swi_handler(trapframe_t *frame)
 	rval<a href="#0">[0]</a> = 0;
 	rval<a href="#1">[1]</a> = frame-&gt;tf_r1;
 
-	error = mi_syscall(p, code, indirect, callp, args, rval);
+	error = mi_syscall(p, code, callp, args, rval);
 
 	switch (error) {
 	case 0:
 		frame-&gt;tf_r0 = rval<a href="#0">[0]</a>;
 		frame-&gt;tf_r1 = rval<a href="#1">[1]</a>;
-
 		frame-&gt;tf_spsr &amp;= ~PSR_C;	/* carry bit */
 		break;
-
 	case ERESTART:
 		/*
 		 * Reconstruct the pc to point at the swi.
 		 */
 		frame-&gt;tf_pc -= 12;
 		break;
-
 	case EJUSTRETURN:
 		/* nothing to do */
 		break;
-
 	default:
 	bad:
 		frame-&gt;tf_r0 = error;
Index: sys/arch/arm64/arm64/syscall.c
===================================================================
RCS file: /cvs/src/sys/arch/arm64/arm64/syscall.c,v
diff -u -p -u -r1.14 syscall.c
--- sys/arch/arm64/arm64/syscall.c	13 Apr 2023 02:19:04 -0000	1.14
+++ sys/arch/arm64/arm64/syscall.c	27 Oct 2023 03:26:49 -0000
@@ -33,7 +33,7 @@ svc_handler(trapframe_t *frame)
 {
 	struct proc *p = curproc;
 	const struct sysent *callp;
-	int code, error, indirect = -1;
+	int code, error = ENOSYS;
 	u_int nap = 8, nargs;
 	register_t *ap, *args, copyargs[MAXARGS], rval<a href="#2">[2]</a>;
 
@@ -50,19 +50,9 @@ svc_handler(trapframe_t *frame)
 
 	ap = &amp;frame-&gt;tf_x<a href="#0">[0]</a>;
 
-	switch (code) {	
-	case SYS_syscall:
-		indirect = code;
-		code = *ap++;
-		nap--;
-		break;
-	}
-
-	callp = sysent;
-	if (code &lt; 0 || code &gt;= SYS_MAXSYSCALL)
-		callp += SYS_syscall;
-	else
-		callp += code;
+	if (code &lt;= 0 || code &gt;= SYS_MAXSYSCALL)
+		goto bad;
+	callp = sysent + code;
 
 	nargs = callp-&gt;sy_argsize / sizeof(register_t);
 	if (nargs &lt;= nap) {
@@ -79,25 +69,22 @@ svc_handler(trapframe_t *frame)
 	rval<a href="#0">[0]</a> = 0;
 	rval<a href="#1">[1]</a> = 0;
 
-	error = mi_syscall(p, code, indirect, callp, args, rval);
+	error = mi_syscall(p, code, callp, args, rval);
 
 	switch (error) {
 	case 0:
 		frame-&gt;tf_x<a href="#0">[0]</a> = rval<a href="#0">[0]</a>;
 		frame-&gt;tf_spsr &amp;= ~PSR_C;	/* carry bit */
 		break;
-
 	case ERESTART:
 		/*
 		 * Reconstruct the pc to point at the svc.
 		 */
 		frame-&gt;tf_elr -= 12;
 		break;
-
 	case EJUSTRETURN:
 		/* nothing to do */
 		break;
-
 	default:
 	bad:
 		frame-&gt;tf_x<a href="#0">[0]</a> = error;
Index: sys/arch/hppa/hppa/trap.c
===================================================================
RCS file: /cvs/src/sys/arch/hppa/hppa/trap.c,v
diff -u -p -u -r1.161 trap.c
--- sys/arch/hppa/hppa/trap.c	11 Feb 2023 23:07:26 -0000	1.161
+++ sys/arch/hppa/hppa/trap.c	27 Oct 2023 03:26:49 -0000
@@ -764,8 +764,8 @@ void
 syscall(struct trapframe *frame)
 {
 	struct proc *p = curproc;
-	const struct sysent *callp;
-	int retq, code, argsize, argoff, error, indirect = -1;
+	const struct sysent *callp = sysent;
+	int code, argsize, argoff, error;
 	register_t args<a name="-8"></a><a href="#8">[8]</a>, rval<a href="#2">[2]</a>;
 #ifdef DIAGNOSTIC
 	int oldcpl = curcpu()-&gt;ci_cpl;
@@ -778,29 +778,16 @@ syscall(struct trapframe *frame)
 
 	p-&gt;p_md.md_regs = frame;
 
-	argoff = 4; retq = 0;
-	switch (code = frame-&gt;tf_t1) {
-	case SYS_syscall:
-		indirect = code;
-		code = frame-&gt;tf_arg0;
-		args<a href="#0">[0]</a> = frame-&gt;tf_arg1;
-		args<a href="#1">[1]</a> = frame-&gt;tf_arg2;
-		args<a href="#2">[2]</a> = frame-&gt;tf_arg3;
-		argoff = 3;
-		break;
-	default:
-		args<a href="#0">[0]</a> = frame-&gt;tf_arg0;
-		args<a href="#1">[1]</a> = frame-&gt;tf_arg1;
-		args<a href="#2">[2]</a> = frame-&gt;tf_arg2;
-		args<a name="-3"></a><a href="#3">[3]</a> = frame-&gt;tf_arg3;
-		break;
-	}
-
-	callp = sysent;
-	if (code &lt; 0 || code &gt;= SYS_MAXSYSCALL)
-		callp += SYS_syscall;
-	else
-		callp += code;
+	argoff = 4;
+	code = frame-&gt;tf_t1;
+	args<a href="#0">[0]</a> = frame-&gt;tf_arg0;
+	args<a href="#1">[1]</a> = frame-&gt;tf_arg1;
+	args<a href="#2">[2]</a> = frame-&gt;tf_arg2;
+	args<a href="#3">[3]</a> = frame-&gt;tf_arg3;
+
+	if (code &lt;= 0 || code &gt;= SYS_MAXSYSCALL)
+		goto bad;
+	callp += code;
 
 	if ((argsize = callp-&gt;sy_argsize)) {
 		register_t *s, *e, t;
@@ -830,7 +817,7 @@ syscall(struct trapframe *frame)
 		 */
 		i = 0;
 		switch (code) {
-		case SYS_lseek:		retq = 0;
+		case SYS_lseek:
 		case SYS_truncate:
 		case SYS_ftruncate:	i = 2;	break;
 		case SYS_preadv:
@@ -851,12 +838,12 @@ syscall(struct trapframe *frame)
 	rval<a href="#0">[0]</a> = 0;
 	rval<a href="#1">[1]</a> = frame-&gt;tf_ret1;
 
-	error = mi_syscall(p, code, indirect, callp, args, rval);
+	error = mi_syscall(p, code, callp, args, rval);
 
 	switch (error) {
 	case 0:
 		frame-&gt;tf_ret0 = rval<a href="#0">[0]</a>;
-		frame-&gt;tf_ret1 = rval[!retq];
+		frame-&gt;tf_ret1 = rval<a href="#1">[1]</a>;
 		frame-&gt;tf_t1 = 0;
 		break;
 	case ERESTART:
@@ -872,7 +859,7 @@ syscall(struct trapframe *frame)
 		break;
 	}
 
-	ast(p);
+	ast(p);		// XXX why?
 
 	mi_syscall_return(p, code, error, rval);
 
Index: sys/arch/i386/i386/trap.c
===================================================================
RCS file: /cvs/src/sys/arch/i386/i386/trap.c,v
diff -u -p -u -r1.162 trap.c
--- sys/arch/i386/i386/trap.c	16 Apr 2023 06:43:49 -0000	1.162
+++ sys/arch/i386/i386/trap.c	27 Oct 2023 03:26:49 -0000
@@ -516,9 +516,9 @@ void
 syscall(struct trapframe *frame)
 {
 	caddr_t params;
-	const struct sysent *callp;
-	struct proc *p;
-	int error, indirect = -1;
+	const struct sysent *callp = sysent;
+	struct proc *p = curproc;
+	int error;
 	register_t code, args<a href="#8">[8]</a>, rval<a href="#2">[2]</a>;
 #ifdef DIAGNOSTIC
 	int ocpl = lapic_tpr;
@@ -540,38 +540,22 @@ syscall(struct trapframe *frame)
 	}
 #endif
 
-	p = curproc;
 	p-&gt;p_md.md_regs = frame;
-	code = frame-&gt;tf_eax;
-
-	params = (caddr_t)frame-&gt;tf_esp + sizeof(int);
 
-	switch (code) {
-	case SYS_syscall:
-		/*
-		 * Code is first argument, followed by actual args.
-		 */
-		indirect = code;
-		copyin(params, &amp;code, sizeof(int));
-		params += sizeof(int);
-		break;
-	default:
-		break;
-	}
+	code = frame-&gt;tf_eax;
+	if (code &lt;= 0 || code &gt;= SYS_MAXSYSCALL)
+		goto bad;
+	callp += code;
 
-	callp = sysent;
-	if (code &lt; 0 || code &gt;= SYS_MAXSYSCALL)
-		callp += SYS_syscall;
-	else
-		callp += code;
 	argsize = callp-&gt;sy_argsize;
+	params = (caddr_t)frame-&gt;tf_esp + sizeof(int);
 	if (argsize &amp;&amp; (error = copyin(params, args, argsize)))
 		goto bad;
 
 	rval<a href="#0">[0]</a> = 0;
 	rval<a href="#1">[1]</a> = frame-&gt;tf_edx;
 
-	error = mi_syscall(p, code, indirect, callp, args, rval);
+	error = mi_syscall(p, code, callp, args, rval);
 
 	switch (error) {
 	case 0:
Index: sys/arch/m88k/m88k/trap.c
===================================================================
RCS file: /cvs/src/sys/arch/m88k/m88k/trap.c,v
diff -u -p -u -r1.128 trap.c
--- sys/arch/m88k/m88k/trap.c	2 Aug 2023 06:14:46 -0000	1.128
+++ sys/arch/m88k/m88k/trap.c	27 Oct 2023 03:26:49 -0000
@@ -1153,9 +1153,9 @@ void
 m88100_syscall(register_t code, struct trapframe *tf)
 {
 	int i, nap;
-	const struct sysent *callp;
+	const struct sysent *callp = sysent;
 	struct proc *p = curproc;
-	int error, indirect = -1;
+	int error;
 	register_t args<a href="#8">[8]</a> __aligned(8);
 	register_t rval<a href="#2">[2]</a> __aligned(8);
 	register_t *ap;
@@ -1172,19 +1172,9 @@ m88100_syscall(register_t code, struct t
 	ap = &amp;tf-&gt;tf_r<a href="#2">[2]</a>;
 	nap = 8; /* r2-r9 */
 
-	switch (code) {
-	case SYS_syscall:
-		indirect = code;
-		code = *ap++;
-		nap--;
-		break;
-	}
-
-	callp = sysent;
-	if (code &lt; 0 || code &gt;= SYS_MAXSYSCALL)
-		callp += SYS_syscall;
-	else
-		callp += code;
+	if (code &lt;= 0 || code &gt;= SYS_MAXSYSCALL)
+		goto bad;
+	callp += code;
 
 	i = callp-&gt;sy_argsize / sizeof(register_t);
 	if (i &gt; sizeof(args) / sizeof(register_t))
@@ -1200,7 +1190,7 @@ m88100_syscall(register_t code, struct t
 	rval<a href="#0">[0]</a> = 0;
 	rval<a href="#1">[1]</a> = tf-&gt;tf_r<a href="#3">[3]</a>;
 
-	error = mi_syscall(p, code, indirect, callp, args, rval);
+	error = mi_syscall(p, code, callp, args, rval);
 
 	/*
 	 * system call will look like:
@@ -1266,7 +1256,7 @@ void
 m88110_syscall(register_t code, struct trapframe *tf)
 {
 	int i, nap;
-	const struct sysent *callp;
+	const struct sysent *callp = sysent;
 	struct proc *p = curproc;
 	int error;
 	register_t args<a href="#8">[8]</a> __aligned(8);
@@ -1285,17 +1275,8 @@ m88110_syscall(register_t code, struct t
 	ap = &amp;tf-&gt;tf_r<a href="#2">[2]</a>;
 	nap = 8;	/* r2-r9 */
 
-	switch (code) {
-	case SYS_syscall:
-		code = *ap++;
-		nap--;
-		break;
-	}
-
-	callp = sysent;
-	if (code &lt; 0 || code &gt;= SYS_MAXSYSCALL)
-		callp += SYS_syscall;
-	else
+	// XXX out of range stays on syscall0, which we assume is enosys
+	if (code &gt;= 0 || code &lt;= SYS_MAXSYSCALL)
 		callp += code;
 
 	i = callp-&gt;sy_argsize / sizeof(register_t);
Index: sys/arch/mips64/mips64/trap.c
===================================================================
RCS file: /cvs/src/sys/arch/mips64/mips64/trap.c,v
diff -u -p -u -r1.167 trap.c
--- sys/arch/mips64/mips64/trap.c	26 Apr 2023 16:53:59 -0000	1.167
+++ sys/arch/mips64/mips64/trap.c	27 Oct 2023 03:26:49 -0000
@@ -396,14 +396,12 @@ fault_common_no_miss:
 	case T_SYSCALL+T_USER:
 	    {
 		struct trapframe *locr0 = p-&gt;p_md.md_regs;
-		const struct sysent *callp;
-		unsigned int code, indirect = -1;
+		const struct sysent *callp = sysent;
+		unsigned int code;
 		register_t tpc;
 		uint32_t branch = 0;
 		int error, numarg;
-		struct args {
-			register_t i<a href="#8">[8]</a>;
-		} args;
+		register_t args<a href="#8">[8]</a>;
 		register_t rval<a href="#2">[2]</a>;
 
 		atomic_inc_int(&amp;uvmexp.syscalls);
@@ -422,51 +420,22 @@ fault_common_no_miss:
 			    trapframe-&gt;pc, 0, branch);
 		} else
 			locr0-&gt;pc += 4;
-		callp = sysent;
 		code = locr0-&gt;v0;
-		switch (code) {
-		case SYS_syscall:
-			/*
-			 * Code is first argument, followed by actual args.
-			 */
-			indirect = code;
-			code = locr0-&gt;a0;
-			if (code &gt;= SYS_MAXSYSCALL)
-				callp += SYS_syscall;
-			else
-				callp += code;
-			numarg = callp-&gt;sy_argsize / sizeof(register_t);
-			args.i<a href="#0">[0]</a> = locr0-&gt;a1;
-			args.i<a href="#1">[1]</a> = locr0-&gt;a2;
-			args.i<a href="#2">[2]</a> = locr0-&gt;a3;
-			if (numarg &gt; 3) {
-				args.i<a href="#3">[3]</a> = locr0-&gt;a4;
-				args.i<a name="-4"></a><a href="#4">[4]</a> = locr0-&gt;a5;
-				args.i<a name="-5"></a><a href="#5">[5]</a> = locr0-&gt;a6;
-				args.i<a name="-6"></a><a href="#6">[6]</a> = locr0-&gt;a7;
-				if (numarg &gt; 7)
-					if ((error = copyin((void *)locr0-&gt;sp,
-					    &amp;args.i<a name="-7"></a><a href="#7">[7]</a>, sizeof(register_t))))
-						goto bad;
-			}
-			break;
-		default:
-			if (code &gt;= SYS_MAXSYSCALL)
-				callp += SYS_syscall;
-			else
-				callp += code;
-
-			numarg = callp-&gt;sy_narg;
-			args.i<a href="#0">[0]</a> = locr0-&gt;a0;
-			args.i<a href="#1">[1]</a> = locr0-&gt;a1;
-			args.i<a href="#2">[2]</a> = locr0-&gt;a2;
-			args.i<a href="#3">[3]</a> = locr0-&gt;a3;
-			if (numarg &gt; 4) {
-				args.i<a href="#4">[4]</a> = locr0-&gt;a4;
-				args.i<a href="#5">[5]</a> = locr0-&gt;a5;
-				args.i<a href="#6">[6]</a> = locr0-&gt;a6;
-				args.i<a href="#7">[7]</a> = locr0-&gt;a7;
-			}
+
+		if (code &lt;= 0 || code &gt;= SYS_MAXSYSCALL)
+			goto bad;
+		callp += code;
+
+		numarg = callp-&gt;sy_narg;
+		args<a href="#0">[0]</a> = locr0-&gt;a0;
+		args<a href="#1">[1]</a> = locr0-&gt;a1;
+		args<a href="#2">[2]</a> = locr0-&gt;a2;
+		args<a href="#3">[3]</a> = locr0-&gt;a3;
+		if (numarg &gt; 4) {
+			args<a href="#4">[4]</a> = locr0-&gt;a4;
+			args<a href="#5">[5]</a> = locr0-&gt;a5;
+			args<a href="#6">[6]</a> = locr0-&gt;a6;
+			args<a href="#7">[7]</a> = locr0-&gt;a7;
 		}
 
 		rval<a href="#0">[0]</a> = 0;
@@ -477,29 +446,24 @@ fault_common_no_miss:
 		    TRAPSIZE : trppos[ci-&gt;ci_cpuid]) - 1].code = code;
 #endif
 
-		error = mi_syscall(p, code, indirect, callp, args.i, rval);
+		error = mi_syscall(p, code, callp, args, rval);
 
 		switch (error) {
 		case 0:
 			locr0-&gt;v0 = rval<a href="#0">[0]</a>;
 			locr0-&gt;a3 = 0;
 			break;
-
 		case ERESTART:
 			locr0-&gt;pc = tpc;
 			break;
-
 		case EJUSTRETURN:
 			break;	/* nothing to do */
-
 		default:
-		bad:
 			locr0-&gt;v0 = error;
 			locr0-&gt;a3 = 1;
 		}
 
 		mi_syscall_return(p, code, error, rval);
-
 		return;
 	    }
 
Index: sys/arch/powerpc/powerpc/trap.c
===================================================================
RCS file: /cvs/src/sys/arch/powerpc/powerpc/trap.c,v
diff -u -p -u -r1.131 trap.c
--- sys/arch/powerpc/powerpc/trap.c	11 Feb 2023 23:07:27 -0000	1.131
+++ sys/arch/powerpc/powerpc/trap.c	27 Oct 2023 03:26:49 -0000
@@ -239,11 +239,11 @@ trap(struct trapframe *frame)
 	struct vm_map *map;
 	vaddr_t va;
 	int access_type;
-	const struct sysent *callp;
+	const struct sysent *callp = sysent;
 	size_t argsize;
 	register_t code, error;
 	register_t *params, rval<a href="#2">[2]</a>, args<a href="#10">[10]</a>;
-	int n, indirect = -1;
+	int n;
 
 	if (frame-&gt;srr1 &amp; PSL_PR) {
 		type |= EXC_USER;
@@ -360,27 +360,13 @@ trap(struct trapframe *frame)
 	case EXC_SC|EXC_USER:
 		uvmexp.syscalls++;
 
-		code = frame-&gt;fixreg<a href="#0">[0]</a>;
 		params = frame-&gt;fixreg + FIRSTARG;
 
-		switch (code) {
-		case SYS_syscall:
-			/*
-			 * code is first argument,
-			 * followed by actual args.
-			 */
-			indirect = code;
-			code = *params++;
-			break;
-		default:
-			break;
-		}
+		code = frame-&gt;fixreg<a href="#0">[0]</a>;
+	        if (code &lt;= 0 || code &gt;= SYS_MAXSYSCALL)
+			goto bad;
+                callp += code;
 
-		callp = sysent;
-		if (code &lt; 0 || code &gt;= SYS_MAXSYSCALL)
-			callp += SYS_syscall;
-		else
-			callp += code;
 		argsize = callp-&gt;sy_argsize;
 		n = NARGREG - (params - (frame-&gt;fixreg + FIRSTARG));
 		if (argsize &gt; n * sizeof(register_t)) {
@@ -395,7 +381,7 @@ trap(struct trapframe *frame)
 		rval<a href="#0">[0]</a> = 0;
 		rval<a href="#1">[1]</a> = frame-&gt;fixreg[FIRSTARG + 1];
 
-		error = mi_syscall(p, code, indirect, callp, params, rval);
+		error = mi_syscall(p, code, callp, params, rval);
 
 		switch (error) {
 		case 0:
Index: sys/arch/powerpc64/powerpc64/syscall.c
===================================================================
RCS file: /cvs/src/sys/arch/powerpc64/powerpc64/syscall.c,v
diff -u -p -u -r1.11 syscall.c
--- sys/arch/powerpc64/powerpc64/syscall.c	11 Feb 2023 23:07:27 -0000	1.11
+++ sys/arch/powerpc64/powerpc64/syscall.c	27 Oct 2023 03:26:49 -0000
@@ -30,27 +30,17 @@ void
 syscall(struct trapframe *frame)
 {
 	struct proc *p = curproc;
-	const struct sysent *callp;
-	int code, error, indirect = -1;
+	const struct sysent *callp = sysent;
+	int code, error;
 	int nap = 8, nargs;
 	register_t *ap, *args, copyargs[MAXARGS], rval<a href="#2">[2]</a>;
 
-	code = frame-&gt;fixreg<a href="#0">[0]</a>;
 	ap = &amp;frame-&gt;fixreg<a href="#3">[3]</a>;
+	code = frame-&gt;fixreg<a href="#0">[0]</a>;
+	if (code &lt;= 0 || code &gt;= SYS_MAXSYSCALL)
+		goto bad;
+	callp += code;
 
-	switch (code) {
-	case SYS_syscall:
-		indirect = code;
-		code = *ap++;
-		nap--;
-		break;
-	}
-
-	callp = sysent;
-	if (code &lt; 0 || code &gt;= SYS_MAXSYSCALL)
-		callp += SYS_syscall;
-	else
-		callp += code;
 	nargs = callp-&gt;sy_argsize / sizeof(register_t);
 	if (nargs &lt;= nap) {
 		args = ap;
@@ -66,7 +56,7 @@ syscall(struct trapframe *frame)
 	rval<a href="#0">[0]</a> = 0;
 	rval<a href="#1">[1]</a> = 0;
 
-	error = mi_syscall(p, code, indirect, callp, args, rval);
+	error = mi_syscall(p, code, callp, args, rval);
 
 	switch (error) {
 	case 0:
@@ -74,15 +64,12 @@ syscall(struct trapframe *frame)
 		frame-&gt;fixreg<a href="#3">[3]</a> = rval<a href="#0">[0]</a>;
 		frame-&gt;cr &amp;= ~0x10000000;
 		break;
-
 	case ERESTART:
 		frame-&gt;srr0 -= 4;
 		break;
-
 	case EJUSTRETURN:
 		/* nothing to do */
 		break;
-
 	default:
 	bad:
 		frame-&gt;fixreg<a href="#0">[0]</a> = error;
Index: sys/arch/riscv64/riscv64/syscall.c
===================================================================
RCS file: /cvs/src/sys/arch/riscv64/riscv64/syscall.c,v
diff -u -p -u -r1.16 syscall.c
--- sys/arch/riscv64/riscv64/syscall.c	13 Apr 2023 02:19:05 -0000	1.16
+++ sys/arch/riscv64/riscv64/syscall.c	27 Oct 2023 03:26:49 -0000
@@ -39,33 +39,20 @@ void
 svc_handler(trapframe_t *frame)
 {
 	struct proc *p = curproc;
-	const struct sysent *callp;
-	int code, error, indirect = -1;
+	const struct sysent *callp = sysent;
+	int code, error;
 	u_int nap = 8, nargs;
 	register_t *ap, *args, copyargs[MAXARGS], rval<a href="#2">[2]</a>;
 
 	uvmexp.syscalls++;
 
-	/* Re-enable interrupts if they were enabled previously */
-	if (__predict_true(frame-&gt;tf_scause &amp; EXCP_INTR))
-		intr_enable();
-
 	ap = &amp;frame-&gt;tf_a<a href="#0">[0]</a>;
 	code = frame-&gt;tf_t<a href="#0">[0]</a>;
 
-	switch (code) {
-	case SYS_syscall:
-		indirect = code;
-		code = *ap++;
-		nap--;
-		break;
-	}
+	if (code &lt;= 0 || code &gt;= SYS_MAXSYSCALL)
+		goto bad;
+	callp += code;
 
-	callp = sysent;
-	if (code &lt; 0 || code &gt;= SYS_MAXSYSCALL)
-		callp += SYS_syscall;
-	else
-		callp += code;
 	nargs = callp-&gt;sy_argsize / sizeof(register_t);
 	if (nargs &lt;= nap) {
 		args = ap;
@@ -81,21 +68,18 @@ svc_handler(trapframe_t *frame)
 	rval<a href="#0">[0]</a> = 0;
 	rval<a href="#1">[1]</a> = 0;
 
-	error = mi_syscall(p, code, indirect, callp, args, rval);
+	error = mi_syscall(p, code, callp, args, rval);
 
 	switch (error) {
 	case 0:
 		frame-&gt;tf_a<a href="#0">[0]</a> = rval<a href="#0">[0]</a>;
 		frame-&gt;tf_t<a href="#0">[0]</a> = 0;		/* syscall succeeded */
 		break;
-
 	case ERESTART:
 		frame-&gt;tf_sepc -= 4;		/* prev instruction */
 		break;
-
 	case EJUSTRETURN:
 		break;
-
 	default:
 	bad:
 		frame-&gt;tf_a<a href="#0">[0]</a> = error;
Index: sys/arch/sh/sh/trap.c
===================================================================
RCS file: /cvs/src/sys/arch/sh/sh/trap.c,v
diff -u -p -u -r1.54 trap.c
--- sys/arch/sh/sh/trap.c	11 Feb 2023 23:07:27 -0000	1.54
+++ sys/arch/sh/sh/trap.c	27 Oct 2023 03:26:49 -0000
@@ -516,44 +516,20 @@ syscall(struct proc *p, struct trapframe
 {
 	caddr_t params;
 	const struct sysent *callp;
-	int error, opc, indirect = -1;
-	int argoff, argsize;
+	int error, opc;
+	int argsize;
 	register_t code, args<a href="#8">[8]</a>, rval<a href="#2">[2]</a>;
 
 	uvmexp.syscalls++;
 
 	opc = tf-&gt;tf_spc;
 	code = tf-&gt;tf_r0;
-
 	params = (caddr_t)tf-&gt;tf_r15;
 
-	switch (code) {
-	case SYS_syscall:
-		/*
-		 * Code is first argument, followed by actual args.
-		 */
-		indirect = code;
-	        code = tf-&gt;tf_r4;
-		argoff = 1;
-		break;
-	default:
-		argoff = 0;
-		break;
-	}
-
-	callp = sysent;
-	if (code &lt; 0 || code &gt;= SYS_MAXSYSCALL)
-		callp += SYS_syscall;
-	else
-		callp += code;
+	if (code &lt;= 0 || code &gt;= SYS_MAXSYSCALL)
+		goto bad;
+	callp = sysent + code;
 	argsize = callp-&gt;sy_argsize;
-#ifdef DIAGNOSTIC
-	if (argsize &gt; sizeof args) {
-		callp += SYS_syscall - code;
-		argsize = callp-&gt;sy_argsize;
-	}
-#endif
-
 	if (argsize) {
 		register_t *ap;
 		int off_t_arg;
@@ -570,19 +546,16 @@ syscall(struct proc *p, struct trapframe
 		}
 
 		ap = args;
-		switch (argoff) {
-		case 0:	*ap++ = tf-&gt;tf_r4; argsize -= sizeof(int);
-		case 1:	*ap++ = tf-&gt;tf_r5; argsize -= sizeof(int);
-		case 2: *ap++ = tf-&gt;tf_r6; argsize -= sizeof(int);
-			/*
-			 * off_t args aren&#39;t split between register
-			 * and stack, but rather r7 is skipped and
-			 * the entire off_t is on the stack.
-			 */
-			if (argoff + off_t_arg == 3)
-				break;
+		*ap++ = tf-&gt;tf_r4; argsize -= sizeof(int);
+		*ap++ = tf-&gt;tf_r5; argsize -= sizeof(int);
+		*ap++ = tf-&gt;tf_r6; argsize -= sizeof(int);
+		/*
+		 * off_t args aren&#39;t split between register
+		 * and stack, but rather r7 is skipped and
+		 * the entire off_t is on the stack.
+		 */
+		if (off_t_arg != 3) {
 			*ap++ = tf-&gt;tf_r7; argsize -= sizeof(int);
-			break;
 		}
 
 		if (argsize &gt; 0) {
@@ -594,7 +567,7 @@ syscall(struct proc *p, struct trapframe
 	rval<a href="#0">[0]</a> = 0;
 	rval<a href="#1">[1]</a> = tf-&gt;tf_r1;
 
-	error = mi_syscall(p, code, indirect, callp, args, rval);
+	error = mi_syscall(p, code, callp, args, rval);
 
 	switch (error) {
 	case 0:
Index: sys/arch/sparc64/sparc64/trap.c
===================================================================
RCS file: /cvs/src/sys/arch/sparc64/sparc64/trap.c,v
diff -u -p -u -r1.115 trap.c
--- sys/arch/sparc64/sparc64/trap.c	11 Feb 2023 23:07:28 -0000	1.115
+++ sys/arch/sparc64/sparc64/trap.c	27 Oct 2023 03:26:49 -0000
@@ -1109,9 +1109,10 @@ syscall(struct trapframe *tf, register_t
 	int64_t *ap;
 	const struct sysent *callp;
 	struct proc *p = curproc;
-	int error, new, indirect = -1;
+	int error = ENOSYS, new;
 	register_t args<a href="#8">[8]</a>;
 	register_t rval<a href="#2">[2]</a>;
+	register_t *argp;
 
 	if ((tf-&gt;tf_out<a href="#6">[6]</a> &amp; 1) == 0)
 		sigexit(p, SIGILL);
@@ -1137,44 +1138,31 @@ syscall(struct trapframe *tf, register_t
 	ap = &amp;tf-&gt;tf_out<a href="#0">[0]</a>;
 	nap = 6;
 
-	switch (code) {
-	case SYS_syscall:
-		indirect = code;
-		code = *ap++;
-		nap--;
-		break;
-	}
-
-	callp = sysent;
-	if (code &lt; 0 || code &gt;= SYS_MAXSYSCALL)
-		callp += SYS_syscall;
-	else {
-		register_t *argp;
-
-		callp += code;
-		i = callp-&gt;sy_narg; /* Why divide? */
-		if (i &gt; nap) {	/* usually false */
-			if (i &gt; 8)
-				panic(&#34;syscall nargs&#34;);
-			/* Read the whole block in */
-			if ((error = copyin((caddr_t)tf-&gt;tf_out<a href="#6">[6]</a>
-			    + BIAS + offsetof(struct frame, fr_argx),
-			    &amp;args[nap], (i - nap) * sizeof(register_t))))
-				goto bad;
-			i = nap;
-		}
-		/*
-		 * It should be faster to do &lt;= 6 longword copies than
-		 * to call bcopy
-		 */
-		for (argp = args; i--;)
-			*argp++ = *ap++;
+	if (code &lt;= 0 || code &gt;= SYS_MAXSYSCALL)
+		goto bad;
+	callp = sysent + code;
+	i = callp-&gt;sy_narg; /* Why divide? */
+	if (i &gt; nap) {	/* usually false */
+		if (i &gt; 8)
+			panic(&#34;syscall nargs&#34;);
+		/* Read the whole block in */
+		if ((error = copyin((caddr_t)tf-&gt;tf_out<a href="#6">[6]</a>
+		    + BIAS + offsetof(struct frame, fr_argx),
+		    &amp;args[nap], (i - nap) * sizeof(register_t))))
+			goto bad;
+		i = nap;
 	}
+	/*
+	 * It should be faster to do &lt;= 6 longword copies than
+	 * to call bcopy
+	 */
+	for (argp = args; i--;)
+		*argp++ = *ap++;
 
 	rval<a href="#0">[0]</a> = 0;
 	rval<a href="#1">[1]</a> = 0;
 
-	error = mi_syscall(p, code, indirect, callp, args, rval);
+	error = mi_syscall(p, code, callp, args, rval);
 
 	switch (error) {
 		vaddr_t dest;
Index: sys/kern/kern_ktrace.c
===================================================================
RCS file: /cvs/src/sys/kern/kern_ktrace.c,v
diff -u -p -u -r1.112 kern_ktrace.c
--- sys/kern/kern_ktrace.c	11 May 2023 09:51:33 -0000	1.112
+++ sys/kern/kern_ktrace.c	27 Oct 2023 03:26:49 -0000
@@ -160,7 +160,7 @@ ktrsyscall(struct proc *p, register_t co
 	u_int nargs = 0;
 	int i;
 
-	if ((code &amp; KTRC_CODE_MASK) == SYS_sysctl) {
+	if (code == SYS_sysctl) {
 		/*
 		 * The sysctl encoding stores the mib[]
 		 * array because it is interesting.
Index: sys/sys/ktrace.h
===================================================================
RCS file: /cvs/src/sys/sys/ktrace.h,v
diff -u -p -u -r1.46 ktrace.h
--- sys/sys/ktrace.h	23 Feb 2023 01:33:20 -0000	1.46
+++ sys/sys/ktrace.h	27 Oct 2023 03:26:49 -0000
@@ -76,8 +76,6 @@ struct ktr_header {
 #define KTR_SYSCALL	1
 struct ktr_syscall {
 	int	ktr_code;		/* syscall number */
-#define KTRC_CODE_MASK			0x0000ffff
-#define KTRC_CODE_SYSCALL		0x20000000
 	int	ktr_argsize;		/* size of arguments */
 	/*
 	 * followed by ktr_argsize/sizeof(register_t) &#34;register_t&#34;s
Index: sys/sys/syscall_mi.h
===================================================================
RCS file: /cvs/src/sys/sys/syscall_mi.h,v
diff -u -p -u -r1.28 syscall_mi.h
--- sys/sys/syscall_mi.h	11 Feb 2023 23:07:23 -0000	1.28
+++ sys/sys/syscall_mi.h	27 Oct 2023 03:26:49 -0000
@@ -51,8 +51,8 @@
  * The MD setup for a system call has been done; here&#39;s the MI part.
  */
 static inline int
-mi_syscall(struct proc *p, register_t code, int indirect,
-    const struct sysent *callp, register_t *argp, register_t retval<a href="#2">[2]</a>)
+mi_syscall(struct proc *p, register_t code, const struct sysent *callp,
+    register_t *argp, register_t retval<a href="#2">[2]</a>)
 {
 	uint64_t tval;
 	int lock = !(callp-&gt;sy_flags &amp; SY_NOLOCK);
@@ -73,15 +73,8 @@ mi_syscall(struct proc *p, register_t co
 #ifdef KTRACE
 	if (KTRPOINT(p, KTR_SYSCALL)) {
 		/* convert to mask, then include with code */
-		switch (indirect) {
-		case SYS_syscall:
-			indirect = KTRC_CODE_SYSCALL;
-			break;
-		default:
-			indirect = 0;
-		}
 		KERNEL_LOCK();
-		ktrsyscall(p, code | indirect, callp-&gt;sy_argsize, argp);
+		ktrsyscall(p, code, callp-&gt;sy_argsize, argp);
 		KERNEL_UNLOCK();
 	}
 #endif

<b>[<a href="https://marc.info/?l=openbsd-tech&amp;m=169840739832111&amp;w=2">prev in list</a>] [<a href="https://marc.info/?l=openbsd-tech&amp;m=169842095809570&amp;w=2">next in list</a>] [<SPAN color="#c0c0c0">prev in thread</SPAN>] [<a href="https://marc.info/?l=openbsd-tech&amp;m=169842095809570&amp;w=2">next in thread</a>] </b>
</pre>
  </div>
  </body>
</html>
