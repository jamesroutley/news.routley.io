<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aarol.dev/posts/go-contentlength/">Original</a>
    <h1>How do HTTP servers figure out Content-Length?</h1>
    
    <div id="readability-page-1" class="page"><div><p><span>Published 06.10.2024</span></p><p>Anyone who has implemented a simple HTTP server can tell you that it is a really simple protocol. Basically, it’s a text file that has some specific rules to make parsing it easier.</p><p>All HTTP requests look something like this: <sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></p><div><pre tabindex="0"><code data-lang="bash"><span><span>GET /path HTTP/1.1<span>\r\n</span>
</span></span><span><span>Host: aarol.dev<span>\r\n</span>
</span></span><span><span>Accept-Language: en,fi-FI<span>\r\n</span>
</span></span><span><span>Accept-Encoding: gzip, deflate<span>\r\n</span>
</span></span><span><span><span>\r\n</span>
</span></span></code></pre></div><p>The first line is the “request line”, and it has the requested method, path and HTTP version.
The following lines are headers, each terminated with “carriage return” and “line feed” characters. There is also an extra CRLF at the end, to mark the end of the header section. After that, there is the message body which can whatever data you want to send.</p><p>Here is a simple Go program to demonstrate this, using a raw TCP socket for the client:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>	<span>// Setup an HTTP server to respond to the path &#34;/test&#34;
</span></span></span><span><span><span></span>	<span>http</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;GET /test&#34;</span><span>,</span> <span>func</span><span>(</span><span>w</span> <span>http</span><span>.</span><span>ResponseWriter</span><span>,</span> <span>r</span> <span>*</span><span>http</span><span>.</span><span>Request</span><span>)</span> <span>{</span>
</span></span><span><span>		<span>w</span><span>.</span><span>Write</span><span>([]</span><span>byte</span><span>(</span><span>&#34;Hello&#34;</span><span>))</span>
</span></span><span><span>		<span>w</span><span>.</span><span>Write</span><span>([]</span><span>byte</span><span>(</span><span>&#34; world!&#34;</span><span>))</span>
</span></span><span><span>	<span>})</span>
</span></span><span><span>	<span>go</span> <span>http</span><span>.</span><span>ListenAndServe</span><span>(</span><span>&#34;localhost:2024&#34;</span><span>,</span> <span>nil</span><span>)</span>
</span></span><span><span>
</span></span><span><span>	<span>// Connect to the server using TCP
</span></span></span><span><span><span></span>	<span>conn</span><span>,</span> <span>err</span> <span>:=</span> <span>net</span><span>.</span><span>Dial</span><span>(</span><span>&#34;tcp&#34;</span><span>,</span> <span>&#34;localhost:2024&#34;</span><span>)</span>
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>		<span>panic</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>// Write the HTTP request (no body, only request line and Host header)
</span></span></span><span><span><span></span>	<span>_</span><span>,</span> <span>err</span> <span>=</span> <span>conn</span><span>.</span><span>Write</span><span>([]</span><span>byte</span><span>(</span><span>&#34;GET /test HTTP/1.1\r\nHost: localhost\r\n\r\n&#34;</span><span>))</span>
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>		<span>panic</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>buf</span> <span>:=</span> <span>make</span><span>([]</span><span>byte</span><span>,</span> <span>1024</span><span>)</span> <span>// 1 kb
</span></span></span><span><span><span></span>	<span>// Read the response
</span></span></span><span><span><span></span>	<span>n</span><span>,</span> <span>err</span> <span>:=</span> <span>conn</span><span>.</span><span>Read</span><span>(</span><span>buf</span><span>)</span>
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>		<span>panic</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>fmt</span><span>.</span><span>Println</span><span>(</span><span>string</span><span>(</span><span>buf</span><span>[:</span><span>n</span><span>]))</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>When I tried this, I got the following response:</p><div><pre tabindex="0"><code data-lang="http"><span><span><span>HTTP</span><span>/</span><span>1.1</span> <span>200</span> <span>OK</span>
</span></span><span><span><span>Date</span><span>:</span> <span>Sun, 06 Oct 2024 14:51:13 GMT</span>
</span></span><span><span><span>Content-Length</span><span>:</span> <span>12</span>
</span></span><span><span><span>Content-Type</span><span>:</span> <span>text/plain; charset=utf-8</span>
</span></span><span><span>
</span></span><span><span><span>Hello</span> <span>world!</span>
</span></span></code></pre></div><p>One interesting thing about this is the header <code>Content-Length</code>, which has a value of 12. That’s exactly the length of <code>&#34;Hello world!&#34;</code> in UTF-8. In the above Go code, writing the response happens in two parts: first we write<code>&#34;Hello&#34;</code>, then we write <code>&#34; world!&#34;</code>. Notice that we didn’t need to call any function to write the headers, but they are still in the response. In Go’s http package, a status of 200 and the headers are automatically written if <code>w.Write()</code> is called before <code>w.WriteHeader()</code>. Any calls to <code>w.WriteHeader()</code> after that are useless and will output a warning.</p><p>Remember that in HTTP, the headers are always written <em>before</em> the body. How is it possible that before writing “Hello” to the connection, the server already knows how long the response will be? What if I wanted to write one “Hello”, and then a thousand exclamation marks after that? Or a million? Does the server need to know how long every response is before sending it? It would mean that every response needs to be kept in memory for the entire duration of the handler.</p><p>I wanted to figure this out, and I didn’t have to look too deep. I found this <a href="https://github.com/golang/go/blob/2f507985dc24d198b763e5568ebe5c04d788894f/src/net/http/server.go#L1630C1-L1663C22">amazing comment</a> in the standard library’s <code>net/http/client.go</code> file. Basically, it says that if the response is small enough to fit into one “chunking buffer”, the length can be calculated very easily, and sent all at once. If the response is bigger than the buffer, it is sent in chunks. What does this mean in practice? I’ve modified the above code to demonstrate it:</p><div><pre tabindex="0"><code data-lang="go"><span><span>
</span></span><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>	<span>http</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;GET /test&#34;</span><span>,</span> <span>func</span><span>(</span><span>w</span> <span>http</span><span>.</span><span>ResponseWriter</span><span>,</span> <span>r</span> <span>*</span><span>http</span><span>.</span><span>Request</span><span>)</span> <span>{</span>
</span></span><span><span>		<span>w</span><span>.</span><span>Write</span><span>([]</span><span>byte</span><span>(</span><span>&#34;Hello&#34;</span><span>))</span>
</span></span><span><span>		<span>w</span><span>.</span><span>Write</span><span>([]</span><span>byte</span><span>(</span><span>strings</span><span>.</span><span>Repeat</span><span>(</span><span>&#34;!&#34;</span><span>,</span> <span>3000</span><span>)))</span>
</span></span><span><span>	<span>})</span>
</span></span><span><span>
</span></span><span><span>	<span>go</span> <span>http</span><span>.</span><span>ListenAndServe</span><span>(</span><span>&#34;localhost:2024&#34;</span><span>,</span> <span>nil</span><span>)</span>
</span></span><span><span>	<span>// removed all error handling for brevity
</span></span></span><span><span><span></span>	<span>conn</span><span>,</span> <span>_</span> <span>:=</span> <span>net</span><span>.</span><span>Dial</span><span>(</span><span>&#34;tcp&#34;</span><span>,</span> <span>&#34;localhost:2024&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>	<span>conn</span><span>.</span><span>Write</span><span>([]</span><span>byte</span><span>(</span><span>&#34;GET /test HTTP/1.1\r\nHost: localhost\r\n\r\n&#34;</span><span>))</span>
</span></span><span><span>
</span></span><span><span>	<span>buf</span> <span>:=</span> <span>make</span><span>([]</span><span>byte</span><span>,</span> <span>1024</span><span>)</span> <span>// 1 kb
</span></span></span><span><span><span></span>	<span>for</span> <span>{</span>
</span></span><span><span>		<span>conn</span><span>.</span><span>SetReadDeadline</span><span>(</span><span>time</span><span>.</span><span>Now</span><span>().</span><span>Add</span><span>(</span><span>1</span> <span>*</span> <span>time</span><span>.</span><span>Second</span><span>))</span>
</span></span><span><span>		<span>n</span><span>,</span> <span>err</span> <span>:=</span> <span>conn</span><span>.</span><span>Read</span><span>(</span><span>buf</span><span>)</span>
</span></span><span><span>		<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>			<span>break</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>
</span></span><span><span>		<span>fmt</span><span>.</span><span>Println</span><span>(</span><span>string</span><span>(</span><span>buf</span><span>[:</span><span>n</span><span>]))</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The handler now returns “Hello!!!!!!!!!!! …” with 3000 exclamation marks. This is bigger than the configured chunk size, so we can see what happens. This is the response:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>HTTP/1.1 200 OK
</span></span><span><span>Date: Sun, 06 Oct 2024 16:43:28 GMT
</span></span><span><span>Content-Type: text/plain; charset=utf-8
</span></span><span><span>Transfer-Encoding: chunked
</span></span><span><span>
</span></span><span><span>800
</span></span><span><span>Hello!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
</span></span><span><span>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
</span></span><span><span>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
</span></span><span><span>3bd
</span></span><span><span>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
</span></span><span><span>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        
</span></span><span><span>0
</span></span></code></pre></div><p>There is no <code>Content-Length</code> header in the response now. Instead, we have a <code>Transfer-Encoding: chunked</code>. Our message is being <em>chunked</em>, sent in multiple parts, so that the server doesn’t need to fit the whole thing into memory at once. Clever!</p><p>The first line of the response data is now a number “800”. Why 800? As it turns out, the number is actually a hexadecimal number, <code>0x800</code> is 2048 in base 10. Similarly, <code>0x3bd</code>, is 957 in base 10. 2048+957=3005, which is the full length of our message! Sending the length of the message before the actual message is a common method to efficiently transfer unknown lengths of data. It is used in the <a href="https://redis.io/docs/latest/develop/reference/protocol-spec">Redis protocol</a> for example.</p><p>Chunked transfer encoding was added in HTTP 1.1.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> This means that it’s very old and basically all HTTP servers &amp; clients support it. Sending chunked responses also allows something called “trailers”, which are headers that are sent <em>after</em> the body. In Go, trailers need to be explicitly declared before sending them:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>http</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;GET /test&#34;</span><span>,</span> <span>func</span><span>(</span><span>w</span> <span>http</span><span>.</span><span>ResponseWriter</span><span>,</span> <span>r</span> <span>*</span><span>http</span><span>.</span><span>Request</span><span>)</span> <span>{</span>
</span></span><span><span>	<span>w</span><span>.</span><span>Header</span><span>().</span><span>Set</span><span>(</span><span>&#34;Trailer&#34;</span><span>,</span> <span>&#34;My-Trailer&#34;</span><span>)</span>
</span></span><span><span>	<span>w</span><span>.</span><span>Write</span><span>([]</span><span>byte</span><span>(</span><span>&#34;Hello&#34;</span><span>))</span>
</span></span><span><span>	<span>w</span><span>.</span><span>Write</span><span>([]</span><span>byte</span><span>(</span><span>strings</span><span>.</span><span>Repeat</span><span>(</span><span>&#34;!&#34;</span><span>,</span> <span>3000</span><span>)))</span>
</span></span><span><span>	<span>w</span><span>.</span><span>Header</span><span>().</span><span>Add</span><span>(</span><span>&#34;My-Trailer&#34;</span><span>,</span> <span>&#34;test&#34;</span><span>)</span>
</span></span><span><span><span>})</span>
</span></span></code></pre></div><p>This is useful for things like digital signatures, which need to be computed from the response body. In Go’s http handlers, adding trailers will also automatically make the response chunked even if it normally wouldn’t be.</p><p>HTTP/2 and HTTP/3 don’t support chunked transfer encoding, as they have their own streaming mechanisms.<sup id="fnref1:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p><p>This is one of the many things that happen in the background when using the <code>net/http</code> package in Go. <code>http.ResponseWriter</code> is a remarkably simple interface, having just 3 methods on it. Behind this API is a lot of magic, including <a href="https://cs.opensource.google/go/go/+/master:src/net/http/sniff.go">Content-Type sniffing</a> and the implicit header writing I mentioned above. It’s great that these things are handled automatically, but in programming I think it’s always important to have an idea of what is happening at the layer below.</p></div></div>
  </body>
</html>
