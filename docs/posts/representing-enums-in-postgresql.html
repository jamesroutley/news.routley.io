<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://making.close.com/posts/native-enums-or-check-constraints-in-postgresql">Original</a>
    <h1>Representing Enums in PostgreSQL</h1>
    
    <div id="readability-page-1" class="page"><div><p>Recently, we had a discussion about whether we should use native enums in PostgreSQL, or rely on regular string columns with <code>CHECK</code> constraints. In the end, we decided that we wanted to go with the latter.</p>
<p>Tag along if you want to learn why.</p>
<h2>Native enums in PostgreSQL</h2>
<p>Native enums in PostgreSQL are full-blown types. You declare a column as an enum the same way you would declare a column of any built-in type:</p>
<div data-language="sql"><pre><code><span>CREATE</span> <span>TYPE</span> mood <span>AS</span> <span>ENUM</span> <span>(</span><span>&#39;sad&#39;</span><span>,</span> <span>&#39;ok&#39;</span><span>,</span> <span>&#39;happy&#39;</span><span>)</span><span>;</span>

<span>CREATE</span> <span>TABLE</span> person <span>(</span>
    name <span>text</span><span>,</span>
    current_mood mood
<span>)</span><span>;</span></code></pre></div>
<p>They come with ordering (from the order in which the values were declared), type safety (you cannot compare two values coming from different enums, even if their string or numerical representations are the same), and space efficiency (they are stored in the tuples as references to the actual enum values that exist in the catalogue tables). Although enums are intended for static sets of values, you can add values to the type and rename existing values. But enums also come with some limitations: for example, you cannot remove an existing value from an enum. To do that, you need to create a new enum in the form you want it to have, and then change all columns to use that new type (well, technically there are alternatives, see below).</p>
<p>Creating a new enum and swapping existing columns to use the new type can be tricky. For the most straightforward cases, you will need something like this:</p>
<div data-language="sql"><pre><code>
<span>ALTER</span> <span>TYPE</span> mood <span>RENAME</span> <span>TO</span> mood_old<span>;</span>


<span>CREATE</span> <span>TYPE</span> mood <span>AS</span> <span>ENUM</span> <span>(</span><span>&#39;sad&#39;</span><span>,</span> <span>&#39;happy&#39;</span><span>)</span><span>;</span>




<span>ALTER</span> <span>TABLE</span> person <span>ALTER</span> <span>COLUMN</span> current_mood
    <span>TYPE</span> mood <span>USING</span> current_mood::<span>text</span>::mood<span>;</span>


<span>DROP</span> <span>TYPE</span> mood_old<span>;</span></code></pre></div>
<p>However, depending on the size of the table, the <code>ALTER TABLE</code> command can have serious performance implications, because it acquires an <code>ACCESS EXLUSIVE</code> lock. This lock is the most restrictive of all locks in PostgreSQL: your transaction is the only transaction that can access that table while it exists. Once it has that lock, it will perform a full table scan to migrate the data and ensure it conforms to the new type. This could make this alternative unfeasible to your application.</p>
<h2>String columns with <code>CHECK</code> constraints</h2>
<p>String columns with <code>CHECK</code> constraints keep the most important property we want with enums: we can enforce data correctness in the database. It also comes with more flexibility: updating a <code>CHECK</code> constraint in the most complex cases is more manageable. And because you use the same method in all cases of updating the constraint, you don&#39;t have to remember multiple options. But it does come with one big downside: it is less space efficient. Because the actual values are stored in the tuples themselves, and not just a reference to the values, it can potentially take a lot of disk space.</p>
<p>To update a <code>CHECK</code> constraint, we do something like this:</p>
<div data-language="sql"><pre><code><span>CREATE</span> <span>TABLE</span> person <span>(</span>
    name <span>text</span><span>,</span>
    current_mood <span>text</span> <span>CHECK</span> <span>(</span>current_mood <span>IN</span> <span>(</span><span>&#39;sad&#39;</span><span>,</span> <span>&#39;ok&#39;</span><span>,</span> <span>&#39;happy&#39;</span><span>)</span><span>)</span>
<span>)</span><span>;</span>



<span>ALTER</span> <span>TABLE</span> person
    <span>DROP</span> <span>CONSTRAINT</span> person_current_mood_check<span>;</span>






<span>ALTER</span> <span>TABLE</span> person
    <span>ADD</span> <span>CONSTRAINT</span> person_current_mood_check
        <span>CHECK</span> <span>(</span>current_mood <span>IN</span> <span>(</span><span>&#39;sad&#39;</span><span>,</span> <span>&#39;happy&#39;</span><span>)</span><span>)</span>
        <span>NOT</span> VALID<span>;</span>


<span>ALTER</span> <span>TABLE</span> person
    VALIDATE <span>CONSTRAINT</span> person_current_mood_check<span>;</span></code></pre></div>
<p>Let&#39;s go through each of these commands in more detail:</p>
<ul>
<li>Drop the previous <code>CHECK</code> constraint. This is a <code>O(1)</code> operation. Nice and quick!</li>
<li>Migrate the data, to make it conform to the new constraint you are going to create. (If you are just dropping a value from the set of possible values, this can also be done before dropping the original constraint.)</li>
<li>Create the constraint in the new form you need, but with <code>NOT VALID</code>. This is also an <code>O(1)</code> operation: the constraint will not be enforced for existing rows, but it will be enforced for rows being created or updated.</li>
<li>Run <code>VALIDATE CONSTRAINT</code> to make sure all rows are good. The validation command acquires a more permissive lock, the <code>SHARE UPDATE EXCLUSIVE</code> lock, which allows concurrent updates to the table: basically, only schema changes and vacuum operations are blocked while validating a <code>CHECK</code> constraint.</li>
</ul>
<h2>Native enums: Alternatives to update without locking</h2>
<p>As I mentioned above, there are alternatives to sidestep the locking of the database when you want to update an enum:</p>
<ul>
<li>You can alter the catalogue tables directly. However, by doing that, you will have to make sure data is consistent yourself instead of relying on the database for that, and there&#39;s always a chance of corrupting the database.</li>
<li>
<p>Removing a value from an enum requires more care:</p>
<ul>
<li>Migrate the data.</li>
<li>Add a constraint (with <code>NOT VALID</code>) requiring that the value that you want to drop from the enum is not used.</li>
<li>Validate the constraint.</li>
<li>Run <code>REINDEX CONCURRENTLY</code> for all indexes that use the enum.</li>
<li>This is required because the enum value you are dropping may still be used internally in the index as a decision node to help the database know where to go when looking for a value. The internal functions that compare enums wouldn&#39;t know what to do when they find the dropped value.</li>
<li>Remove the value from the catalogue tables directly.</li>
<li>Drop the constraint.</li>
</ul>
</li>
</ul>
<p>However, these methods are too involved for most use cases, and they do carry some risk of corrupting the database, since you are directly modifying tables that are supposed to be internal.</p>
<h2>Conclusion</h2>
<p>Because of not having to fully lock down the database for the migration of the <code>CHECK</code> constraint, and the relatively small disadvantages of the update procedure being a little more elaborate even in the simpler cases, and the usage of space being less efficient, we&#39;ve decided to go with <code>CHECK</code> constraints instead of native enums in PostgreSQL.</p></div></div>
  </body>
</html>
