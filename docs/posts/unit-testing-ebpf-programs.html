<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://who.ldelossa.is/posts/unit-testing-ebpf/">Original</a>
    <h1>Unit Testing eBPF Programs</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="unit-testing-ebpf">Unit Testing eBPF</h2><p>Love it or hate it, writing unit tests is all but mandatory for your code.</p><p>They provide a safety net when making changes, and give you that nice, warm
feeling when you see them all pass after a change.</p><p>While working on a Kernel patch I had to investigate writing unit tests for
eBPF programs.</p><p>Turns out, the Kernel developers have thought about this already and infrastructure
exists to accomplish it.</p><p>I’m going to provide a hands on example of unit testing a <code>TC</code> eBPF program.</p><p>In this test we want to confirm that looking up the route for a packet destined
for an external IP address results in selecting the default gateway.</p><p>We will have complete control over the network namespace which the test is ran
in.</p><p>If you have no idea what any of that means, don’t worry, the concepts I will
cover carry over to testing other types of eBPF programs.</p><h2 id="testing-environment">Testing environment</h2><p>In this post I’m assuming you know how to compile your eBPF program utilizing
<code>clang</code>, <code>bpftool</code> and how to generate a <code>vmlinux.h</code> file.</p><p>If you don’t check out my other <a href="https://who.ldelossa.is/posts/bpf-zero-to-hero/">post here</a></p><p>With that said, we do need to level-set on your coding environment and the tools
we need in your coding environment to follow along.</p><p>You must have:</p><ul><li>bpftool - this, in additional to generating the vmlinux.h, will be used to
generate a “skeleton” loader for your compiled eBPF program.</li><li>clang - we need this to compile eBPF programs</li><li>make - used to run my butchered up Makefile</li></ul><p>You must also have <code>CAP_SYS_ADMIN</code> privileges on your machine, if you don’t know
what that means, 99% of the time running as <code>root</code> will fill this requirement.</p><p>I will also assume you’re on Linux, which you may think is obvious statement,
but <a href="https://github.com/microsoft/ebpf-for-windows">it’s a dwindling assumption</a></p><p>Okay, one last assumption, you have <code>libbpf</code> installed correctly and clang/gcc can
locate it and compile your eBPF programs.</p><h2 id="introducing-the-bpf_prog_run-command">Introducing the BPF_PROG_RUN command</h2><p>The core functionality we want to focus on for unit testing eBPF program is a
eBPF command called “BPF_PROG_RUN”.</p><p>This command was renamed from “BPF_PROG_TEST_RUN” and this identifier maybe used
interchangeable.</p><p>A “command” is an enum value which can be passed to the <code>bpf</code> sys-call exposed
by Linux.</p><p>However, <code>libbpf</code> usually wraps the <code>bpf</code> sys-call usage for convenience and
sanity checking.</p><p>Therefore, we’ll focus on using <code>libbpf</code>’s wrapper around the “BPF_PROG_RUN”
command, <code>bpf_test_run_opts</code></p><p>Let’s take a look at it’s forward declaration:
<a href="https://elixir.bootlin.com/linux/v6.2.11/source/tools/lib/bpf/bpf.h#L454">https://elixir.bootlin.com/linux/v6.2.11/source/tools/lib/bpf/bpf.h#L454</a></p><div><pre tabindex="0"><code data-lang="c"><span><span><span>struct</span> bpf_test_run_opts {
</span></span><span><span>	<span>size_t</span> sz; <span>/* size of this struct for forward/backward compatibility */</span>
</span></span><span><span>	<span>const</span> <span>void</span> <span>*</span>data_in; <span>/* optional */</span>
</span></span><span><span>	<span>void</span> <span>*</span>data_out;      <span>/* optional */</span>
</span></span><span><span>	__u32 data_size_in;
</span></span><span><span>	__u32 data_size_out; <span>/* in: max length of data_out
</span></span></span><span><span><span>			      * out: length of data_out
</span></span></span><span><span><span>			      */</span>
</span></span><span><span>	<span>const</span> <span>void</span> <span>*</span>ctx_in; <span>/* optional */</span>
</span></span><span><span>	<span>void</span> <span>*</span>ctx_out;      <span>/* optional */</span>
</span></span><span><span>	__u32 ctx_size_in;
</span></span><span><span>	__u32 ctx_size_out; <span>/* in: max length of ctx_out
</span></span></span><span><span><span>			     * out: length of cxt_out
</span></span></span><span><span><span>			     */</span>
</span></span><span><span>	__u32 retval;        <span>/* out: return code of the BPF program */</span>
</span></span><span><span>	<span>int</span> repeat;
</span></span><span><span>	__u32 duration;      <span>/* out: average per repetition in ns */</span>
</span></span><span><span>	__u32 flags;
</span></span><span><span>	__u32 cpu;
</span></span><span><span>	__u32 batch_size;
</span></span><span><span>};
</span></span><span><span><span>#define bpf_test_run_opts__last_field batch_size
</span></span></span><span><span><span></span>
</span></span><span><span>LIBBPF_API <span>int</span> <span>bpf_prog_test_run_opts</span>(<span>int</span> prog_fd,
</span></span><span><span>				      <span>struct</span> bpf_test_run_opts <span>*</span>opts);
</span></span></code></pre></div><p>If we were to look at the implementation, we’d find that <code>bpf_prog_test_run_opts</code>
simply copies the provided <code>opts</code> to its a structure the Kernel will own, does
some sanity checking on the <code>opts</code> structure, and then calls the <code>bpf</code> sys-call
directly.</p><p>The arguments to the <code>libbpf</code> function takes an eBPF program file descriptor
and a <code>opts</code> structure.</p><p>The eBPF program file descriptor represents an eBPF program which is loaded into
the Kernel, we’ll demonstrate a convenient way of obtaining this file descriptor
later in this post.</p><p>The <code>opts</code> structure provides both mock data and options to the function.
While some fields say ‘optional’ we will learn that it really depends on the
eBPF program type you are testing, whether these fields are optional or not.</p><p>The important fields we’ll utilize in this post are:</p><p><code>sz</code> is always required, and its simply set to <code>sizeof(bpf_test_run_opts)</code>.</p><p><code>data_in, data_size_in</code> allows you to provide mock data to the <code>ctx</code> that is
passed into your eBPF program, in the case of a “TC” program, a mock IPv4 packet.</p><p><code>ctx_in, ctx_size_in</code> allows you to pass in a mock ctx, in the case of a “TC” program,
a mock <code>__sk_buff</code> structure, which is eBPF’s representation of the Kernel’s
socket buffer.</p><h2 id="test-case-and-skeleton-loader">Test Case and Skeleton Loader</h2><p>With the introduction of <code>bpf_test_run_opts</code> out of the way, lets start writing
our eBPF test case.</p><p>We will also use <code>bpftool</code> to generate a skeleton loader, which is a header file
with functions for loading our compiled eBPF program into the Kernel and giving
us a handle to the loaded program.</p><p>This handle can be used to obtain the file descriptor to the loaded eBPF program,
and interact with it during the Kernel’s runtime.</p><p>Our test case’s goal is to ensure that a packet sourced from the host, destined
for an external node, selects the default route, and is forwarded to the correct
interface.</p><p>To test this we will be utilizing the eBPF helper <code>bpf_fib_lookup</code>.</p><p>We don’t need to understand how this helper works in details, suffice it to say
that we provide in the source and destination of a incoming packet, and it
returns to us an interface, if any, that the packet would be forwarded to.</p><p>In our test case, we want to see the aforementioned interface be the default
gateway for the network namespace.</p><p>Our test packet will be sourced from <code>127.0.0.1</code> and its destination will be
<code>8.8.8.8</code>.</p><p>Since we are running a unit test, no data will actually be sent, and no side
effects outside of the host will occur.</p><p>Keep in mind, this test a bit contrived to show off a few features of the testing
infrastructure, and we lean more towards “demonstration” then “practicality”.</p><p>Okay, so lets examine our test eBPF program:</p><p><code>fib_lookup.bpf.c</code></p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&#34;../vmlinux.h&#34;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;bpf/bpf_helpers.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define TC_ACT_OK		0
</span></span></span><span><span><span>#define TC_ACT_SHOT		2
</span></span></span><span><span><span>#define TC_ACT_REDIRECT		7
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define AF_INET		        2	</span><span>/* Internet IP Protocol 	*/</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>struct</span> bpf_fib_lookup fib_params <span>=</span> {<span>0</span>};
</span></span><span><span>
</span></span><span><span><span>int</span> fib_lookup_ret <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span><span>SEC</span>(<span>&#34;tc&#34;</span>)
</span></span><span><span><span>int</span> <span>fib_lookup</span>(<span>struct</span> __sk_buff <span>*</span>skb)
</span></span><span><span>{
</span></span><span><span>        <span>struct</span> iphdr <span>*</span>ip <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span>        <span>bpf_printk</span>(<span>&#34;performing FIB lookup</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>
</span></span><span><span>        <span>bpf_printk</span>(<span>&#34;fib lookup original ret: %d</span><span>\n</span><span>&#34;</span>, fib_lookup_ret);
</span></span><span><span>
</span></span><span><span>	    fib_lookup_ret <span>=</span> <span>bpf_fib_lookup</span>(skb, <span>&amp;</span>fib_params, <span>sizeof</span>(fib_params),
</span></span><span><span>					<span>0</span>);
</span></span><span><span>
</span></span><span><span>        <span>bpf_printk</span>(<span>&#34;fib lookup ret: %d</span><span>\n</span><span>&#34;</span>, fib_lookup_ret);
</span></span><span><span>
</span></span><span><span>	<span>return</span> TC_ACT_OK;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>char</span> _license[] <span>SEC</span>(<span>&#34;license&#34;</span>) <span>=</span> <span>&#34;GPL&#34;</span>;
</span></span></code></pre></div><p>As you can see the test is very simple.</p><p>We import the necessary headers and then we define two global variables, setting
them both to zero.</p><p>By defining these variables as global and setting them to zero, they actually
become available to userspace via our skeleton.</p><p>Let’s use the following Makefile to compile and generate a skeleton for this
eBPF program.</p><p><code>Makefile</code></p><div><pre tabindex="0"><code data-lang="make"><span><span>CFLAGS <span>+=</span> -g3 <span>\
</span></span></span><span><span><span></span>          -Wall
</span></span><span><span>
</span></span><span><span>LIBS <span>=</span> bpf
</span></span><span><span>
</span></span><span><span><span>all</span><span>:</span> fib_lookup.bpf.o fib_lookup.skel.h
</span></span><span><span>
</span></span><span><span><span>fib_lookup.bpf.o</span><span>:</span> fib_lookup.bpf.c
</span></span><span><span>	clang -target bpf -Wall -O2 -g -c $&lt;
</span></span><span><span>
</span></span><span><span><span>fib_lookup.skel.h</span><span>:</span> fib_lookup.bpf.o
</span></span><span><span>	bpftool gen skeleton $&lt; &gt; $@
</span></span><span><span>
</span></span><span><span><span>test</span><span>:</span> test.c
</span></span><span><span>	gcc <span>$(</span>CFLAGS<span>)</span> -l<span>$(</span>LIBS<span>)</span> -o $@ $&lt;
</span></span><span><span>
</span></span><span><span><span>.PHONY</span><span>:</span>
</span></span><span><span><span>clean</span><span>:</span>
</span></span><span><span>	rm -rf fib_lookup.bpf.o
</span></span><span><span>	rm -rf fib_lookup.skel.h
</span></span><span><span>	rm -rf test
</span></span></code></pre></div><p>Ignore the <code>test</code> binary for now, we’ll write our test runner in the next
section.</p><p>If we inspect the file “fib_lookup.skel.h” we come across the interesting
structure.</p><p><code>fib_lookup.skel.h</code></p><div><pre tabindex="0"><code data-lang="c"><span><span><span>struct</span> fib_lookup_bpf {
</span></span><span><span>	<span>struct</span> bpf_object_skeleton <span>*</span>skeleton;
</span></span><span><span>	<span>struct</span> bpf_object <span>*</span>obj;
</span></span><span><span>	<span>struct</span> {
</span></span><span><span>		<span>struct</span> bpf_map <span>*</span>bss;
</span></span><span><span>		<span>struct</span> bpf_map <span>*</span>rodata;
</span></span><span><span>	} maps;
</span></span><span><span>	<span>struct</span> {
</span></span><span><span>		<span>struct</span> bpf_program <span>*</span>fib_lookup;
</span></span><span><span>	} progs;
</span></span><span><span>	<span>struct</span> {
</span></span><span><span>		<span>struct</span> bpf_link <span>*</span>fib_lookup;
</span></span><span><span>	} links;
</span></span><span><span>	<span>struct</span> fib_lookup_bpf__bss {
</span></span><span><span>		<span>struct</span> bpf_fib_lookup fib_params;
</span></span><span><span>		<span>int</span> fib_lookup_ret;
</span></span><span><span>	} <span>*</span>bss;
</span></span><span><span>	<span>struct</span> fib_lookup_bpf__rodata {
</span></span><span><span>	} <span>*</span>rodata;
</span></span><span><span>
</span></span><span><span><span>#ifdef __cplusplus
</span></span></span><span><span><span></span>	<span>static</span> <span>inline</span> <span>struct</span> fib_lookup_bpf <span>*</span><span>open</span>(<span>const</span> <span>struct</span> bpf_object_open_opts <span>*</span>opts <span>=</span> nullptr);
</span></span><span><span>	<span>static</span> <span>inline</span> <span>struct</span> fib_lookup_bpf <span>*</span><span>open_and_load</span>();
</span></span><span><span>	<span>static</span> <span>inline</span> <span>int</span> <span>load</span>(<span>struct</span> fib_lookup_bpf <span>*</span>skel);
</span></span><span><span>	<span>static</span> <span>inline</span> <span>int</span> <span>attach</span>(<span>struct</span> fib_lookup_bpf <span>*</span>skel);
</span></span><span><span>	<span>static</span> <span>inline</span> <span>void</span> <span>detach</span>(<span>struct</span> fib_lookup_bpf <span>*</span>skel);
</span></span><span><span>	<span>static</span> <span>inline</span> <span>void</span> <span>destroy</span>(<span>struct</span> fib_lookup_bpf <span>*</span>skel);
</span></span><span><span>	<span>static</span> <span>inline</span> <span>const</span> <span>void</span> <span>*</span><span>elf_bytes</span>(<span>size_t</span> <span>*</span>sz);
</span></span><span><span><span>#endif </span><span>/* __cplusplus */</span><span>
</span></span></span><span><span><span></span>};
</span></span></code></pre></div><p>This is the handle to our loaded eBPF program which the skeleton loader returns
to us when we call:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>static</span> <span>inline</span> <span>struct</span> fib_lookup_bpf <span>*</span>
</span></span><span><span><span>fib_lookup_bpf__open_and_load</span>(<span>void</span>)
</span></span></code></pre></div><p>In the same file.</p><p>The interesting bit here is:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>struct</span> fib_lookup_bpf__bss {
</span></span><span><span>    <span>struct</span> bpf_fib_lookup fib_params;
</span></span><span><span>    <span>int</span> fib_lookup_ret;
</span></span><span><span>} <span>*</span>bss;
</span></span></code></pre></div><p>Notice, we get access to our global zero initialized variables in the <code>bss</code>
field.</p><p>This allows a userspace program to load the eBPF program, retrieve the handle
to it, and then both “inject” and “read” values from globals before and after
<code>bpf_test_run_opts</code> is called.</p><p>This is exactly what our test runner is going to do.</p><h2 id="writing-the-test-runner">Writing the test runner</h2><p>As eluded to above, we want our test runner to do the following:</p><ul><li>Load our eBPF test program into the Kernel, getting a handle to the
<code>fib_lookup_bpf</code> structure defined in <code>bpf_lookup.skel.h</code></li><li>Inject a mock <code>bpf_fib_lookup</code> parameter structure into the test before
its ran</li><li>utilize <code>libpf</code>’s <code>bpf_test_run_opts</code> function to run our test in userspace</li><li>read the resulting <code>fib_lookup_bpf</code> and <code>fib_lookup_ret</code> to determine if the
default gateway was used.</li></ul><p>We have control of the network namespace the test runs in, so we can hard-code
the interface ID (ifindex) which represents the default gateway, making our
test runner a bit simpler.</p><p>Let’s take a look at the test runner:</p><p><code>test.c</code></p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;bpf/bpf.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;bpf/libbpf.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;bpf/bpf_endian.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&#34;fib_lookup.skel.h&#34;</span><span>
</span></span></span><span><span><span>#include</span> <span>&#34;net/ethernet.h&#34;</span><span>
</span></span></span><span><span><span>#include</span> <span>&#34;linux/ip.h&#34;</span><span>
</span></span></span><span><span><span>#include</span> <span>&#34;netinet/tcp.h&#34;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define TARGET_IFINDEX 2
</span></span></span><span><span><span></span>
</span></span><span><span><span>// in our test, we only care that the packet is the correct size,
</span></span></span><span><span><span>// since our test does not touch any packet data.
</span></span></span><span><span><span></span><span>char</span> v4_pkt[(<span>sizeof</span>(<span>struct</span> ethhdr) <span>+</span> <span>sizeof</span>(<span>struct</span> iphdr) <span>+</span> <span>sizeof</span>(<span>struct</span> tcphdr))];
</span></span><span><span>
</span></span><span><span><span>// create an empty skb as mock data, our tests do not touch any skb fields.
</span></span></span><span><span><span></span><span>struct</span> __sk_buff skb <span>=</span> {<span>0</span>};
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span> (<span>int</span> argc, <span>char</span> <span>*</span>argv[]) {
</span></span><span><span>        <span>struct</span> fib_lookup_bpf <span>*</span>skel;
</span></span><span><span>        <span>int</span> prog_fd, err <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span>        <span>// define our BPF_PROG_RUN options with our mock data.
</span></span></span><span><span><span></span>        <span>struct</span> bpf_test_run_opts opts <span>=</span> {
</span></span><span><span>                <span>// required, or else bpf_prog_test_run_opts will fail
</span></span></span><span><span><span></span>                .sz <span>=</span> <span>sizeof</span>(<span>struct</span> bpf_test_run_opts),
</span></span><span><span>                <span>// data_in will wind up being ctx.data
</span></span></span><span><span><span></span>                .data_in <span>=</span> <span>&amp;</span>v4_pkt,
</span></span><span><span>                .data_size_in <span>=</span> <span>sizeof</span>(v4_pkt),
</span></span><span><span>                <span>// ctx is an skb in this case
</span></span></span><span><span><span></span>                .ctx_in <span>=</span> <span>&amp;</span>skb,
</span></span><span><span>                .ctx_size_in <span>=</span> <span>sizeof</span>(skb)
</span></span><span><span>        };
</span></span><span><span>
</span></span><span><span>        <span>// load our fib lookup test program into the Kernel and return our
</span></span></span><span><span><span></span>        <span>// skeleton handle to it.
</span></span></span><span><span><span></span>        skel <span>=</span> <span>fib_lookup_bpf__open_and_load</span>();
</span></span><span><span>        <span>if</span> (<span>!</span>skel) {
</span></span><span><span>                <span>printf</span>(<span>&#34;[error]: failed to open and load skeleton: %d</span><span>\n</span><span>&#34;</span>, err);
</span></span><span><span>                <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>        }
</span></span><span><span>
</span></span><span><span>        <span>// inject our test parameters into the fib lookup parameter, this primes
</span></span></span><span><span><span></span>        <span>// our test.
</span></span></span><span><span><span></span>        skel<span>-&gt;</span>bss<span>-&gt;</span>fib_lookup_ret <span>=</span> <span>-</span><span>1</span>;
</span></span><span><span>        skel<span>-&gt;</span>bss<span>-&gt;</span>fib_params.family <span>=</span> AF_INET;
</span></span><span><span>        skel<span>-&gt;</span>bss<span>-&gt;</span>fib_params.ipv4_src <span>=</span> <span>0x100007f</span>;
</span></span><span><span>        skel<span>-&gt;</span>bss<span>-&gt;</span>fib_params.ipv4_dst <span>=</span> <span>0x8080808</span>;
</span></span><span><span>        skel<span>-&gt;</span>bss<span>-&gt;</span>fib_params.ifindex <span>=</span> <span>1</span>;
</span></span><span><span>
</span></span><span><span>        <span>// get the prog_fd from the skeleton, and run our test.
</span></span></span><span><span><span></span>        prog_fd <span>=</span> <span>bpf_program__fd</span>(skel<span>-&gt;</span>progs.fib_lookup);
</span></span><span><span>        err <span>=</span> <span>bpf_prog_test_run_opts</span>(prog_fd, <span>&amp;</span>opts);
</span></span><span><span>        <span>if</span> (err <span>!=</span> <span>0</span>) {
</span></span><span><span>                <span>printf</span>(<span>&#34;[error]: bpf test run failed: %d</span><span>\n</span><span>&#34;</span>, err);
</span></span><span><span>                <span>return</span> <span>-</span><span>2</span>;
</span></span><span><span>        }
</span></span><span><span>
</span></span><span><span>        <span>// check global variables for response
</span></span></span><span><span><span></span>        <span>if</span> (skel<span>-&gt;</span>bss<span>-&gt;</span>fib_lookup_ret <span>!=</span> <span>0</span>) {
</span></span><span><span>                <span>printf</span>(<span>&#34;[FAIL]: fib lookup returned: %d&#34;</span>, skel<span>-&gt;</span>bss<span>-&gt;</span>fib_lookup_ret);
</span></span><span><span>                <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>        }
</span></span><span><span>
</span></span><span><span>        <span>if</span> (skel<span>-&gt;</span>bss<span>-&gt;</span>fib_params.ifindex <span>!=</span> TARGET_IFINDEX) {
</span></span><span><span>                <span>printf</span>(<span>&#34;[FAIL]: fib lookup did not choose default gw interface: %d&#34;</span>, skel<span>-&gt;</span>bss<span>-&gt;</span>fib_params.ifindex);
</span></span><span><span>                <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>        }
</span></span><span><span>
</span></span><span><span>        <span>printf</span>(<span>&#34;[PASS]: ifindex %d</span><span>\n</span><span>&#34;</span>, skel<span>-&gt;</span>bss<span>-&gt;</span>fib_params.ifindex);
</span></span><span><span>        <span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>Let’s update our Makefile to build our test runner as well.</p><div><pre tabindex="0"><code data-lang="make"><span><span>CFLAGS <span>+=</span> -g3 <span>\
</span></span></span><span><span><span></span>          -Wall
</span></span><span><span>
</span></span><span><span>LIBS <span>=</span> bpf
</span></span><span><span>
</span></span><span><span><span>all</span><span>:</span> fib_lookup.bpf.o fib_lookup.skel.h test
</span></span><span><span>
</span></span><span><span><span>fib_lookup.bpf.o</span><span>:</span> fib_lookup.bpf.c
</span></span><span><span>	clang -target bpf -Wall -O2 -g -c $&lt;
</span></span><span><span>
</span></span><span><span><span>fib_lookup.skel.h</span><span>:</span> fib_lookup.bpf.o
</span></span><span><span>	bpftool gen skeleton $&lt; &gt; $@
</span></span><span><span>
</span></span><span><span><span>test</span><span>:</span> test.c
</span></span><span><span>	gcc <span>$(</span>CFLAGS<span>)</span> -l<span>$(</span>LIBS<span>)</span> -o $@ $&lt;
</span></span><span><span>
</span></span><span><span><span>.PHONY</span><span>:</span>
</span></span><span><span><span>clean</span><span>:</span>
</span></span><span><span>	rm -rf fib_lookup.bpf.o
</span></span><span><span>	rm -rf fib_lookup.skel.h
</span></span><span><span>	rm -rf test
</span></span></code></pre></div><p>And finally lets provide a script which sets up a network namespace for this
test runner to work inside, and runs the test.</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>#!/bin/bash
</span></span></span><span><span><span></span>NETNS_NAME<span>=</span><span>&#34;netns-1&#34;</span>
</span></span><span><span>n<span>=</span><span>&#39;sudo ip netns&#39;</span>
</span></span><span><span>nexec<span>=</span><span>&#34;sudo ip netns exec </span>$NETNS_NAME<span>&#34;</span>
</span></span><span><span>
</span></span><span><span><span>function</span> setup_netns<span>()</span> <span>{</span>
</span></span><span><span>    <span># add &#39;netns-1&#39; network namespace where we&#39;ll</span>
</span></span><span><span>    <span># run our test.</span>
</span></span><span><span>    $n add $NETNS_NAME
</span></span><span><span>
</span></span><span><span>    <span># setup loopback</span>
</span></span><span><span>    $nexec ip addr add 127.0.0.1 dev lo
</span></span><span><span>
</span></span><span><span>    <span># setup a dummy interface which can route to the default gw, and </span>
</span></span><span><span>    <span># setup a route to the default gw.</span>
</span></span><span><span>    $nexec ip link add name eth0 type dummy
</span></span><span><span>    $nexec ip link set up eth0
</span></span><span><span>    $nexec ip addr add 192.168.1.10/24 dev eth0
</span></span><span><span>    $nexec ip route add default via 192.168.1.11
</span></span><span><span>
</span></span><span><span>    <span># since 192.168.1.11 doesn&#39;t actually exist, create a perm arp-table entry </span>
</span></span><span><span>    <span># for it, allowing fib lookup to succeed.</span>
</span></span><span><span>    $nexec ip neigh add 192.168.1.11 dev eth0 lladdr <span>&#34;0F:0F:0F:0F:0F:0F&#34;</span> nud permanent
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>function</span> teardown_netns<span>()</span> <span>{</span>
</span></span><span><span>    $n del $NETNS_NAME
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>setup_netns
</span></span><span><span>$nexec ./test
</span></span><span><span>teardown_netns
</span></span></code></pre></div><p>Now when we run this script we get the following output:</p><h2 id="summing-it-up">Summing it up</h2><p>Lets summarize the major points in this post.</p><p>A eBPF program can define global variables which can be modified, both before and
after, a userspace test run of the program.</p><p>The <code>BPF_PROG_RUN</code> command can be used run your eBPF program in user space,
which is wrapped by the <code>bpf_prog_test_run_opts()</code> function in <code>libbpf</code>.</p><p>Once the eBPF program is compiled into an object file, you can generate a skeleton
loader with <code>bpftool</code>, this skeleton loader will load your eBPF program into the
Kernel, and also provide your userspace program access to the global variables
mentioned above.</p><p>Finally, you can write a userspace test runner which sets the global variables
of the loaded eBPF program before the test, and reads them after, allowing you
to determine if the eBPF program performed the actions you intended.</p></div></div>
  </body>
</html>
