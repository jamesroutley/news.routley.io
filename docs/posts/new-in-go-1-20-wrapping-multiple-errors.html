<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lukas.zapletalovi.com/posts/2022/wrapping-multiple-errors/">Original</a>
    <h1>New in Go 1.20: wrapping multiple errors</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><div><div><p>Go 1.20, which is expected to be released in February 2023, comes with a small
change that can possibly improve error handling in applications which heavily
use error wrapping. Let’s take a look how it looks, but first, short recap of
what error wrapping is. Feel free to skip to “New in Go 1.20” section down
below for the news.</p><p>Errors in Go are values which implements a very simple interface:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>error</span> <span>interface</span> {
</span></span><span><span>    <span>Error</span>() <span>string</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Error types can be anything, from <code>string</code> itself to <code>int</code>, but very often they
are <code>struct</code> types. This example is from the standard library:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>err</span> <span>struct</span> {
</span></span><span><span>    <span>s</span> <span>string</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> (<span>e</span> <span>*</span><span>err</span>) <span>Error</span>() <span>string</span> {
</span></span><span><span>    <span>return</span> <span>e</span>.<span>s</span>
</span></span><span><span>}
</span></span></code></pre></div><p>To check an error in Go, you simply compare a value (in this case an <code>int</code>
value):</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>err</span> <span>==</span> <span>io</span>.<span>EOF</span> {
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>The second common thing is to check error’s type, that is little bit more code
to write tho:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>nerr</span>, <span>ok</span> <span>:=</span> <span>err</span>.(<span>net</span>.<span>Error</span>) {
</span></span><span><span>    <span>// ... (use nerr which is a net.Error)
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>In the example above, the type assertion tests the <code>err</code> value for type
<code>net.Error</code> creating a new variable <code>nerr</code> which can be used in the if
statement. Errors in Go are simple to understand, simple to use use and
efficient.</p><h2 id="error-wrapping">Error wrapping</h2><p>Now, starting from Go 1.13, wrapping was introduced. Wrapping allows to embed
errors into other errors, just like wrapping exceptions in other languages.
This is very useful: a function that encounters “record not found” error can
add more context information to the message like “unknown user: record not
found”.</p><p>The interesting idea behind error wrapping design in Go is that the contract
does not care about error types, structure or how they are created. What only
matters is the unwrapping procedure and conversion to string because that is
what is needed. It is very simple then: error types with unwrapping support
must implement <code>Unwrap() error</code> method. There is no (named) interface in the
standard library to show you since interfaces are implemented implicitly and
there is no need to have one. Let`s write one just for the purpose of this
post:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>WrappedError</span> <span>interface</span> {
</span></span><span><span>    <span>Unwrap</span>() <span>error</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Let’s take a look how wrapped errors are implemented in the Go standard
library (package <code>fmt</code> actually):</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>wrapError</span> <span>struct</span> {
</span></span><span><span>    <span>msg</span> <span>string</span>
</span></span><span><span>    <span>err</span> <span>error</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> (<span>e</span> <span>*</span><span>wrapError</span>) <span>Error</span>() <span>string</span> {
</span></span><span><span>    <span>return</span> <span>e</span>.<span>msg</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> (<span>e</span> <span>*</span><span>wrapError</span>) <span>Unwrap</span>() <span>error</span> {
</span></span><span><span>    <span>return</span> <span>e</span>.<span>err</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Since errors are types which implement <code>Error() string</code> and there is nothing
wrong saying that errors in Go actually <em>are</em> “strings” in the end, a good
mechanism of creating these strings is needed. This is where function
<code>fmt.Errorf</code> from standard library comes into play:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>var</span> <span>RecordNotFoundErr</span> = <span>errors</span>.<span>New</span>(<span>&#34;not found&#34;</span>)
</span></span><span><span><span>const</span> <span>name</span>, <span>id</span> = <span>&#34;lzap&#34;</span>, <span>13</span>
</span></span><span><span>
</span></span><span><span><span>werr</span> <span>:=</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;unknown user %q (id %d): %w&#34;</span>, <span>name</span>, <span>id</span>, <span>recordNotFoundErr</span>)
</span></span><span><span>
</span></span><span><span><span>fmt</span>.<span>Println</span>(<span>werr</span>.<span>Error</span>())
</span></span></code></pre></div><p>A special format verb <code>%w</code>, which can be only used <em>once</em> per call (more about
this later), is meant for error arguments. Other than that, the function works
similar to <code>fmt.Printf</code> function. The example above prints this:</p><pre><code>unknown user &#34;lzap&#34; (id 13): not found
</code></pre><p>As you can see, wrapped errors are essentially a linked list. To unwrap an
error use <code>errors.Unwrap</code> function which will return <code>nil</code> for the last error
value in the list. To check for error type or value, the whole list needs to be
walked which is not very practical for each error check. Luckily, there are two
helper functions to do that.</p><p>To check for a value in wrapped errors list:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>errors</span>.<span>Is</span>(<span>err</span>, <span>RecordNotFoundErr</span>) {
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>To check for a specific type (a network error from the standard library in this
case):</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>var</span> <span>nerr</span> <span>*</span><span>net</span>.<span>Error</span>
</span></span><span><span><span>if</span> <span>errors</span>.<span>As</span>(<span>err</span>, <span>&amp;</span><span>nerr</span>) {
</span></span><span><span>    <span>// ... (use nerr which is a *net.Error)
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>That summarizes error wrapping in Go 1.13 and later.</p><h2 id="new-in-go-120">New in Go 1.20</h2><p>Let’s take a look what is actually new in Go 1.20 starting with function
<code>errors.Join</code> which wraps list of errors via variadic arguments:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>err1</span> <span>:=</span> <span>errors</span>.<span>New</span>(<span>&#34;err1&#34;</span>)
</span></span><span><span><span>err2</span> <span>:=</span> <span>errors</span>.<span>New</span>(<span>&#34;err2&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>err</span> <span>:=</span> <span>errors</span>.<span>Join</span>(<span>err1</span>, <span>err2</span>)
</span></span><span><span>
</span></span><span><span><span>fmt</span>.<span>Println</span>(<span>err</span>)
</span></span></code></pre></div><p>It is worth mentioning that the function concatenates errors from the list with
newline characters. The above snippet prints:</p><pre><code>err1
err2
</code></pre><p>This could be a problem for many applications or (logging) libraries which
expects errors to be very often just strings without newline characters.
Luckily, another change in Go 1.20 changes behavior of <code>fmt.Errorf</code>: the
function now accepts multiple <code>%w</code> format specifiers:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>err1</span> <span>:=</span> <span>errors</span>.<span>New</span>(<span>&#34;err1&#34;</span>)
</span></span><span><span><span>err2</span> <span>:=</span> <span>errors</span>.<span>New</span>(<span>&#34;err2&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>err</span> <span>:=</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;%w + %w&#34;</span>, <span>err1</span>, <span>err2</span>)
</span></span><span><span>
</span></span><span><span><span>fmt</span>.<span>Println</span>(<span>err</span>)
</span></span></code></pre></div><p>What would previously result as a malformed format string now correctly prints:</p><pre><code>err1 + err2
</code></pre><p>How this is possible when wrapped errors implements <code>Unwrap() error</code>? It turns
out that there is a new mechanism in Go 1.20 standard library: an error type
implementing <code>Unwrap() []error</code> function can wrap multiple errors instead of
just one. Let’s take a look how this is implemented in the library:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>joinError</span> <span>struct</span> {
</span></span><span><span>    <span>errs</span> []<span>error</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> (<span>e</span> <span>*</span><span>joinError</span>) <span>Error</span>() <span>string</span> {
</span></span><span><span>    <span>// concatenate errors with a new line character
</span></span></span><span><span><span></span>}
</span></span><span><span>
</span></span><span><span><span>func</span> (<span>e</span> <span>*</span><span>joinError</span>) <span>Unwrap</span>() []<span>error</span> {
</span></span><span><span>    <span>return</span> <span>e</span>.<span>errs</span>
</span></span><span><span>}
</span></span></code></pre></div><p>A theoretical interface, which does not exists in the standard library, looks
like this:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>MultiWrappedError</span> <span>interface</span> {
</span></span><span><span>    <span>Unwrap</span>() []<span>error</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Since Go does not allow method overloading, each type can either implement
<code>Unwrap() error</code> or <code>Unwrap() []error</code>, but not both. Remember when I mentioned
that wrapped errors are essentially a linked list? Types which implement the
former (the newly introduced) method actually form a linked tree and functions
<code>errors.Is</code> and <code>errors.As</code> work the same, except now they need to traverse
tree instead of list. According to documentation, the implementation performs
pre-order, depth-first traversal.</p><p>That is really all that Go 1.20 brings to the table, it may seem like a small
change, but it allows new ways how to handle errors efficiently and cleanly.
Before I show a real-world example, let me summarize the new features:</p><ul><li>New <code>Unwrap []error</code> function contract allowing traversing through tree of errors.</li><li>New <code>errors.Join</code> function which is a handy function to join two error string values (with a newline).</li><li>Existing functions <code>errors.Is</code> and <code>errors.As</code> updated to work both on list and tree of errors.</li><li>Existing function <code>fmt.Errorf</code> now accepts multiple <code>%w</code> format verbs.</li></ul><h2 id="in-practice">In practice</h2><p>So it’s all great, but how can you leverage this in practice? In a small REST
API microservice, we do all error handling through <code>errors.New</code> and
<code>fmt.Errorf</code> wrapping various errors from DAO package (database), REST clients
(other backend services) and other packages. The return HTTP status code should
be either 2xx, 4xx or 5xx depending on the error status to follow the best REST
API practices. One way to achieve this is to unwrap errors in the main HTTP
handler and find out which kind of error is it.</p><p>However, with the multiple error wrapping, it is now possible to wrap both the
root cause (e.g. database returning “no records found”) and also preferred HTTP
code to return to the user (404 in this case). A working example could look
like this:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> (
</span></span><span><span>	<span>&#34;errors&#34;</span>
</span></span><span><span>	<span>&#34;fmt&#34;</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>// common HTTP status codes
</span></span></span><span><span><span></span><span>var</span> <span>NotFoundHTTPCode</span> = <span>errors</span>.<span>New</span>(<span>&#34;404&#34;</span>)
</span></span><span><span><span>var</span> <span>UnauthorizedHTTPCode</span> = <span>errors</span>.<span>New</span>(<span>&#34;401&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>// database errors
</span></span></span><span><span><span></span><span>var</span> <span>RecordNotFoundErr</span> = <span>errors</span>.<span>New</span>(<span>&#34;DB: record not found&#34;</span>)
</span></span><span><span><span>var</span> <span>AffectedRecordsMismatchErr</span> = <span>errors</span>.<span>New</span>(<span>&#34;DB: affected records mismatch&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>// HTTP client errors
</span></span></span><span><span><span></span><span>var</span> <span>ResourceNotFoundErr</span> = <span>errors</span>.<span>New</span>(<span>&#34;HTTP client: resource not found&#34;</span>)
</span></span><span><span><span>var</span> <span>ResourceUnauthorizedErr</span> = <span>errors</span>.<span>New</span>(<span>&#34;HTTP client: unauthorized&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>// application errors (the new feature)
</span></span></span><span><span><span></span><span>var</span> <span>UserNotFoundErr</span> = <span>fmt</span>.<span>Errorf</span>(<span>&#34;user not found: %w (%w)&#34;</span>,
</span></span><span><span>    <span>RecordNotFoundErr</span>, <span>NotFoundHTTPCode</span>)
</span></span><span><span><span>var</span> <span>OtherResourceUnauthorizedErr</span> = <span>fmt</span>.<span>Errorf</span>(<span>&#34;unauthorized call: %w (%w)&#34;</span>,
</span></span><span><span>    <span>ResourceUnauthorizedErr</span>, <span>UnauthorizedHTTPCode</span>)
</span></span><span><span>
</span></span><span><span><span>func</span> <span>handleError</span>(<span>err</span> <span>error</span>) {
</span></span><span><span>	<span>if</span> <span>errors</span>.<span>Is</span>(<span>err</span>, <span>NotFoundHTTPCode</span>) {
</span></span><span><span>		<span>fmt</span>.<span>Println</span>(<span>&#34;Will return 404&#34;</span>)
</span></span><span><span>	} <span>else</span> <span>if</span> <span>errors</span>.<span>Is</span>(<span>err</span>, <span>UnauthorizedHTTPCode</span>) {
</span></span><span><span>		<span>fmt</span>.<span>Println</span>(<span>&#34;Will return 401&#34;</span>)
</span></span><span><span>	} <span>else</span> {
</span></span><span><span>		<span>fmt</span>.<span>Println</span>(<span>&#34;Will return 500&#34;</span>)
</span></span><span><span>	}
</span></span><span><span>	<span>fmt</span>.<span>Println</span>(<span>err</span>.<span>Error</span>())
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span>() {
</span></span><span><span>	<span>handleError</span>(<span>UserNotFoundErr</span>)
</span></span><span><span>	<span>handleError</span>(<span>OtherResourceUnauthorizedErr</span>)
</span></span><span><span>}
</span></span></code></pre></div><p>This will print:</p><pre><code>Will return 404
user not found: DB: record not found (404)
Will return 401
unauthorized to call other service: HTTP client: unauthorized (401)
</code></pre><p>What may not look obvious from such artificial code snippet is that errors
declarations are typically spread across many packages and it is not easy to
keep track of all possible errors ensuring the required HTTP status codes. In
this approach, all application-level wrapping errors declared in a single place
also have HTTP codes wrapped inside them.</p><p>Note this was previously not possible in Go 1.19 or older because the
<code>fmt.Errorf</code> function would only wrap the first error. The code does compile on
1.19 and does not even generate runtime panic, it won’t work however.</p><p>Obviously, the common HTTP status codes could easily be a new error type (based
on <code>int</code> type) so the actual code could be easily extracted via <code>errors.As</code>,
but I want to keep the example simple.</p><p>Feel free to <a href="https://go.dev/play/p/czyJBZOUltT?v=gotip">play around</a> with the
code on Go Playground. Make sure to use “dev branch” or 1.20+ version of Go.</p><h2 id="existing-applications">Existing applications</h2><p>When implementing the new feature into your application, beware of
<code>errors.Unwrap</code> function. For error types that has <code>Unwrap() []error</code> it
always returns <code>nil</code>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>err1</span> <span>:=</span> <span>errors</span>.<span>New</span>(<span>&#34;err1&#34;</span>)
</span></span><span><span><span>err2</span> <span>:=</span> <span>errors</span>.<span>New</span>(<span>&#34;err2&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>err</span> <span>:=</span> <span>errors</span>.<span>Join</span>(<span>err1</span>, <span>err2</span>)
</span></span><span><span><span>unwrapped</span> <span>:=</span> <span>errors</span>.<span>Unwrap</span>(<span>err</span>)
</span></span><span><span>
</span></span><span><span><span>fmt</span>.<span>Println</span>(<span>unwrapped</span>)
</span></span></code></pre></div><p>This prints <code>nil</code> and it is expected because of the Go 1.X compatibility
promise. Just make sure to review unwrapping code when you introduce multiple
wrapped errors. Luckily, most of error checking in typical Go code is done
using <code>errors.Is</code> and <code>errors.As</code>.</p><p>Error wrapping is not the ultimate solution for all error handling in Go. It
provides a clean approach to handle errors in typical Go applications tho and
it might actually be all you need for simple application.</p><p>Reach out to me on Mastodon or Twitter, share the post if you like it! Cheers.</p></div></div></div></div>
  </body>
</html>
