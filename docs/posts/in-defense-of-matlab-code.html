<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://runmat.org/blog/in-defense-of-matlab-whiteboard-style-code">Original</a>
    <h1>In Defense of Matlab Code</h1>
    
    <div id="readability-page-1" class="page"><article><div><p><em>The issue was never the syntax—it was the runtime. Why readable math still matters in a world aided by LLM-assisted code generation</em></p>
<h2 id="the-enduring-relevance-of-matlab-in-modern-engineering">The enduring relevance of MATLAB in modern engineering</h2>
<p>If you look at the most preferred language list on any Stack Overflow developer survey, you will usually find MATLAB hovering near the bottom. It sits there alongside VBA and COBOL, often dismissed by modern software engineers as a dinosaur. You have probably seen the memes: complaints about license manager errors, the massive install size, or the feeling that it is a language strictly for &#34;old-school academics.”</p>
<p>The world has moved toward open source, containerization, and agile cloud deployments. In that context, a closed ecosystem feels restrictive.</p>
<p>But if you walk into the R&amp;D departments of top aerospace, automotive, or medical device companies, MATLAB is still everywhere. It isn&#39;t there because these engineers don&#39;t know better. It is there because, for a specific type of work—linear algebra, signal processing, and control theory—MATLAB did one thing better than almost anyone else:</p>
<p><strong>It made the code look exactly like the math on the whiteboard.</strong></p>
<p>We need to separate the <strong>language syntax</strong> (which is excellent) from the <strong>runtime and business model</strong> (which are dated).</p>
<h2 id="what-is-whiteboard-style-code">What is &#34;whiteboard-style code&#34;?</h2>
<p><img src="https://web.runmatstatic.com/matlab-runmat-whiteboard-c.png" alt="Engineer copying matrix equations from a whiteboard into MATLAB-style code on a laptop." loading="lazy"/></p>
<p>When I say &#34;whiteboard-style code,&#34; I am referring to a specific level of abstraction.
In engineering, the &#34;truth&#34; is derived on a whiteboard or a notepad. That is where the physics is worked out. You draw matrices, you transpose vectors, and you define relationships ($F = ma$, $V = IR$, $Y = Hx$).
The goal of engineering software is to translate that whiteboard truth into executable logic with as little &#34;translation loss&#34; as possible.
&#34;Whiteboard-style code&#34; means:</p>
<ol>
<li><strong>High Density:</strong> One line of math equals one line of code.</li>
<li><strong>Visual Similarity:</strong> The code visually resembles the equation.</li>
<li><strong>Low Boilerplate:</strong> No memory allocation logic, no type declarations, and minimal imports.
For vectors, matrices, and arrays, MATLAB’s syntax is often the shortest distance between the board and the running code</li>
</ol>
<h2 id="the-translation-test-board-vs-code">The translation test: board vs. code</h2>
<p>Let’s look at a concrete example. Imagine you are sketching a simple linear algebra operation during a lecture or a design review.</p>
<p><strong>In MATLAB:</strong>
The code is almost a direct transcription of the board:</p>
<pre><code><span>X <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>;</span>
</span><span>Y <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>;</span> <span>...</span>
</span><span>     <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>;</span> <span>...</span>
</span><span>     <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span><span>;</span>
</span><span>
</span><span>Z <span>=</span> Y <span>*</span> X<span>&#39;</span><span>;</span>      
</span><span>W <span>=</span> <span>[</span>Z<span>,</span> Z<span>]</span><span>;</span>      
</span></code></pre>
<p><strong>In Python (NumPy):</strong>
Python is an incredible language, and NumPy is a powerhouse. But notice the cognitive load required to handle the shapes explicitly:</p>
<pre><code><span><span>import</span> numpy <span>as</span> np
</span><span>
</span><span>X <span>=</span> np<span>.</span>array<span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span>
</span><span>Y <span>=</span> np<span>.</span>array<span>(</span><span>[</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>,</span>
</span><span>              <span>[</span><span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>]</span><span>,</span>
</span><span>              <span>[</span><span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span><span>]</span><span>)</span>
</span><span>
</span><span>
</span><span>
</span><span>Z <span>=</span> Y @ X<span>.</span>reshape<span>(</span><span>3</span><span>,</span> <span>1</span><span>)</span>
</span><span>
</span><span>
</span><span>W <span>=</span> np<span>.</span>concatenate<span>(</span><span>[</span>Z<span>,</span> Z<span>]</span><span>,</span> axis<span>=</span><span>1</span><span>)</span>
</span></code></pre>
<p>The math is identical. But in the Python version, the engineer is thinking about computer science concepts: <code>imports</code>, <code>methods</code>, <code>tuples</code>, and <code>axes</code>. In the MATLAB version, the engineer is thinking about linear algebra: <em>rows, columns, and multiplication.</em></p>
<h2 id="why-readable-math-is-a-safety-feature">Why readable math is a safety feature</h2>
<p>Why does this subtle difference matter?</p>
<p>In mission-critical fields, <strong>code review is safety review.</strong></p>
<p>Senior engineers and Principal Investigators perform these reviews. These are brilliant people who understand the physics deeply, but they may not be experts in modern software design patterns. They don&#39;t want to parse decorators or understand the nuances of an object-oriented class hierarchy.</p>
<p>When they review code, they are holding their derivation notes in one hand and looking at the screen with the other. They want to verify that step A leads to step B.</p>
<ul>
<li>&#34;Here is the rotation matrix.&#34;</li>
<li>&#34;Here we apply the filter.&#34;</li>
<li>&#34;Here we calculate the error.&#34;</li>
</ul>
<p>MATLAB’s syntax allows them to verify the <em>math</em> without getting bogged down in the <em>implementation</em>. When the code looks like the math, bugs have fewer places to hide. The syntax itself reduces the cognitive load, allowing the reviewer to focus on the physics rather than the programming.</p>
<p><img src="https://web.runmatstatic.com/matlab-code-review-sm.png" alt="MATLAB code review" loading="lazy"/></p>
<h2 id="its-not-just-for-humans-compilers-love-it-too">It&#39;s not just for humans (compilers love it too)</h2>
<p>There is a misconception that &#34;simple syntax&#34; means &#34;slow interpretation.&#34; Actually, high-level array syntax gives runtimes and compilers excellent signals for optimization.</p>
<p>When you write <code>C = A * B</code> in a vectorized language, you are giving the runtime a very high-level instruction: &#34;Perform a matrix multiplication on these two objects.&#34;</p>
<p>Because the language constraints are strict (matrices have defined shapes, types are usually consistent), a modern runtime can:</p>
<ul>
<li>Immediately infer the shapes of the result.</li>
<li>Fuse multiple element-wise operations into a single pass through memory.</li>
<li>Offload the entire chunk of work to a GPU without the user writing a single line of CUDA kernel code.</li>
</ul>
<p>The structure that makes it readable for humans also makes it predictable for machines.</p>
<h2 id="the-honest-truth-why-the-hate-exists">The honest truth: why the hate exists</h2>
<p>If the syntax is so good, why is the sentiment so mixed?</p>
<p>To be fair, the backlash against MATLAB is largely justified. The frustration usually stems from three areas, none of which have to do with the math syntax itself:</p>
<ol>
<li><strong>The &#34;Black Box&#34; Runtime:</strong> The engine is closed source. You cannot see how <code>fft</code> or <code>ode45</code> are implemented under the hood. For high-stakes engineering, not being able to audit your tools is a risk.</li>
<li><strong>Licensing Pain:</strong> Everyone has a story about a simulation crashing because the license server timed out, or not being able to run a script because a colleague &#34;checked out&#34; the toolbox token.</li>
<li><strong>The Cloud Gap:</strong> Modern engineering happens in CI/CD pipelines, Docker containers, and cloud clusters. Integrating a heavy, licensed desktop application into these lightweight, automated workflows is painful.</li>
</ol>
<p>This friction pushed a generation of engineers toward Python, not because they preferred writing <code>np.concatenate</code>, but because they needed tools that played nice with the modern stack.</p>
<h2 id="a-vision-for-a-modern-whiteboard-runtime">A vision for a modern &#34;whiteboard&#34; runtime</h2>
<p>The solution isn&#39;t to abandon the syntax that engineers love. The solution is to build a new, modern engine to run it.</p>
<p>We need a runtime that preserves the dense, array-oriented notation but operates like a modern piece of software infrastructure. It should be:</p>
<ul>
<li><strong>Open and inspectable:</strong> No black boxes.</li>
<li><strong>Hardware agnostic:</strong> It should run on CPUs or GPUs without changing the code.</li>
<li><strong>Portable:</strong> It should run in a Docker container or a web browser.</li>
</ul>
<p>We should keep the language surface that mimics the whiteboard, but swap out the engine for something designed for the era of cloud computing and massive datasets.</p>
<h2 id="keeping-the-math-changing-the-engine">Keeping the math, changing the engine</h2>
<p>This is exactly why we are building <strong>RunMat</strong>.</p>
<p>Our team realized that the problem wasn&#39;t the <code>.m</code> files—it was how they were being executed. RunMat is a new, high-performance runtime designed to execute MATLAB-style syntax. It targets modern hardware (CPUs and GPUs) and integrates seamlessly into cloud and CI workflows, all without the traditional licensing headaches.</p>
<p>It allows teams to keep their &#34;whiteboard code&#34; while gaining the performance and portability of a modern software stack.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Technology trends come and go, but the laws of physics and mathematics don&#39;t change.</p>
<p>Engineers working on the next generation of renewable energy grids, autonomous vehicles, and medical robotics need tools that respect the complexity of their math. They need code that can be written, read, and verified by experts who care more about differential equations than software dependencies.</p>
<p>The future doesn&#39;t need to copy the business models of the past. But it should absolutely keep the best part of the legacy: code that looks like the math on the board.</p><div><section aria-label="Newsletter signup"><div><h3>Enjoyed this post? Join the newsletter</h3><p>Monthly updates on RunMat, Rust internals, and performance tips.</p></div></section></div><div><div data-slot="card"><div data-slot="card-content"><h3>Ready to try RunMat?</h3><p>Get started with the modern MATLAB runtime today.</p></div></div></div></div></article></div>
  </body>
</html>
