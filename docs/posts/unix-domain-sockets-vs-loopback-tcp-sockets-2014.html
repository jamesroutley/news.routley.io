<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nicisdigital.wordpress.com/2014/03/03/unix-domain-sockets-vs-loopback-tcp-sockets/">Original</a>
    <h1>Unix Domain Sockets vs Loopback TCP Sockets (2014)</h1>
    
    <div id="readability-page-1" class="page"><div>
       <p>Two communicating processes on a single machine have a few options. They can use regular TCP sockets, UDP sockets, unix domain sockets, or shared memory. A recent project I was working on used Node.js with two communicating processes on the same machine. I wanted to know how to reduce the CPU utilization of the machine, so I ran a few experiments to compare the efficiency between unix domain sockets and TCP sockets using the loopback interface. This post covers my experiments and test results.</p>
<p>First off, is a disclaimer. This test is not exhaustive. Both client and server are written in Node.js and can only be as efficient as the Node.js runtime.</p>
<p>All code in this post is available at: <a href="http://github.com/nicmcd/uds_vs_tcp">github.com/nicmcd/uds_vs_tcp</a></p>
<h2>Server Application</h2>
<p>I created a simple Node.js server application that could be connected to via TCP socket or Unix domain socket. It simply echos all received messages. Here is the code:</p>
<pre title="">var assert = require(&#39;assert&#39;);
assert(process.argv.length == 4, &#39;node server.js &lt;tcp port&gt; &lt;domain socket path&gt;&#39;);

var net = require(&#39;net&#39;);

var tcpPort = parseInt(process.argv[2]);
assert(!isNaN(tcpPort), &#39;bad TCP port&#39;);
console.log(&#39;TCP port: &#39; + tcpPort);

var udsPath = process.argv[3];
console.log(&#39;UDS path: &#39; + udsPath);

function createServer(name, portPath) {
    var server = net.createServer(function(socket) {
        console.log(name + &#39; server connected&#39;);
        socket.on(&#39;end&#39;, function() {
            console.log(name + &#39; server disconnected&#39;);
        });
        socket.write(&#39;start sending now!&#39;);
        socket.pipe(socket);
    });
    server.listen(portPath, function() {
        console.log(name + &#39; server listening on &#39; + portPath);
    });
}

var tcpServer = createServer(&#39;TCP&#39;, tcpPort);
var udsServer = createServer(&#39;UDS&#39;, udsPath);
</pre>
<h2>Client Application</h2>
<p><span>The client application complements the server application. It connects to the server via TCP or Unix domain sockets. It sends a bunch of randomly generated packets and measures the time it takes to finish. When complete, it prints the time and exits. Here is the code:</span></p>
<pre title="">var assert = require(&#39;assert&#39;);
assert(process.argv.length == 5, &#39;node client.js &lt;port or path&gt; &lt;packet size&gt; &lt;packet count&gt;&#39;);

var net = require(&#39;net&#39;);
var crypto = require(&#39;crypto&#39;);

if (isNaN(parseInt(process.argv[2])) == false)
    var options = {port: parseInt(process.argv[2])};
else
    var options = {path: process.argv[2]};
console.log(&#39;options: &#39; + JSON.stringify(options));

var packetSize = parseInt(process.argv[3]);
assert(!isNaN(packetSize), &#39;bad packet size&#39;);
console.log(&#39;packet size: &#39; + packetSize);

var packetCount = parseInt(process.argv[4]);
assert(!isNaN(packetCount), &#39;bad packet count&#39;);
console.log(&#39;packet count: &#39; + packetCount);

var client = net.connect(options, function() {
    console.log(&#39;client connected&#39;);
});

var printedFirst = false;
var packet = crypto.randomBytes(packetSize).toString(&#39;base64&#39;).substring(0,packetSize);
var currPacketCount = 0;
var startTime;
var endTime;
var delta;
client.on(&#39;data&#39;, function(data) {
    if (printedFirst == false) {
        console.log(&#39;client received: &#39; + data);
        printedFirst = true;
    }
    else {
        currPacketCount += 1;
        if (data.length != packetSize)
            console.log(&#39;weird packet size: &#39; + data.length);
        //console.log(&#39;client received a packet: &#39; + currPacketCount);
    }

    if (currPacketCount &lt; packetCount) {
        if (currPacketCount == 0) {
            startTime = process.hrtime();
        }
        client.write(packet);
    } else {
        client.end();
        endTime = process.hrtime(startTime);
        delta = (endTime[0] * 1e9 + endTime[1]) / 1e6;
        console.log(&#39;millis: &#39; + delta);
    }
});
</pre>
<h2>Running a Single Test</h2>
<p>First start the server application with:</p>
<pre title="">node server.js 5555 /tmp/uds
</pre>
<p>This starts the server using TCP port 5555 and Unix domain socket /tmp/uds.</p>
<p>Now we can run the client application to get some statistics. Let’s first try the TCP socket. Run the client with:</p>
<pre title="">

node client.js 5555 1000 100000

</pre>
<p>This runs the client application using TCP port 5555 and sends 100,000 packets all sized 1000 bytes. This tooks 8006 milliseconds on my machine. We can now try running with the Unix domain socket with:</p>
<pre title="">

node client.js /tmp/uds 1000 100000

</pre>
<p>This runs the client the same as before except it uses the /tmp/uds Unix domain socket instead of the TCP socket. On my machine this took 3570 milliseconds to run. These two runs show that for 1k byte packets, Unix domain sockets are about 2-3x more efficient than TCP sockets.</p>
<h2>Running the Full Test</h2>
<p>As mentioned, running the full test uses the Taskrun Python package (available at <a title="Taskrun Python Package" href="http://github.com/nicmcd/taskrun">github.com/nicmcd/taskrun</a>). The script I quickly hacked together to run the client application and parse the results is as follows:</p>
<pre title="">

import taskrun
import os

POWER = 15
RUNS = 10
PACKETS_PER_RUN = 100000

manager = taskrun.Task.Manager(
    numProcs = 1,
    showCommands = True,
    runTasks = True,
    showProgress = True)

DIR = &#34;sims&#34;
mkdir = manager.task_new(&#39;dir&#39;, &#39;rm -rI &#39; + DIR + &#39;; mkdir &#39; + DIR)

def makeName(stype, size, run):
    return stype + &#39;_size&#39; + str(size) + &#39;_run&#39; + str(run)

def makeCommand(port_or_path, size, name):
    return &#39;node client.js &#39; + port_or_path + &#39; &#39; + str(size) + &#39; &#39; + str(PACKETS_PER_RUN) + \
        &#39; | grep millis | awk \&#39;{printf &#34;%s, &#34;, $2}\&#39; &gt; &#39; + os.path.join(DIR, name)

barrier1 = manager.task_new(&#39;barrier1&#39;, &#39;sleep 0&#39;)
for exp in range(0, POWER):
    size = pow(2, exp)
    for run in range(0, RUNS):
        # Unix domain socket test
        name = makeName(&#39;uds&#39;, size, run)
        task = manager.task_new(name, makeCommand(&#39;/tmp/uds&#39;, size, name))
        task.dependency_is(mkdir)
        barrier1.dependency_is(task)

        # TCP socket test
        name = makeName(&#39;tcp&#39;, size, run)
        task = manager.task_new(name, makeCommand(&#39;5555&#39;, size, name))
        task.dependency_is(mkdir)
        barrier1.dependency_is(task)

# create CSV header
filename = os.path.join(DIR, &#39;uds_vs_tcp.csv&#39;)
header = &#39;NAME, &#39;
for run in range(0, RUNS):
    header += &#39;RUN &#39; + str(run) + &#39;, &#39;
hdr_task = manager.task_new(&#39;CSV header&#39;, &#39;echo \&#39;&#39; + header + &#39;\&#39; &gt; &#39; + filename)
hdr_task.dependency_is(barrier1)

# UDS to CSV
cmd = &#39;&#39;
for exp in range(0,POWER):
    size = pow(2, exp)
    cmd += &#39;echo -n \&#39;UDS Size &#39; + str(size) + &#39;, \&#39; &gt;&gt; &#39; + filename + &#39;; &#39;
    for run in range(0, RUNS):
        name = makeName(&#39;uds&#39;, size, run)
        cmd += &#39;cat &#39; + os.path.join(DIR, name) + &#39; &gt;&gt; &#39; + filename + &#39;; &#39;
    cmd += &#39;echo \&#39;\&#39; &gt;&gt; &#39; + filename + &#39;; &#39;
uds_task = manager.task_new(&#39;UDS to CSV&#39;, cmd)
uds_task.dependency_is(hdr_task)

# TCP to CSV
cmd = &#39;&#39;
for exp in range(0,POWER):
    size = pow(2, exp)
    cmd += &#39;echo -n \&#39;TCP Size &#39; + str(size) + &#39;, \&#39; &gt;&gt; &#39; + filename + &#39;; &#39;
    for run in range(0, RUNS):
        name = makeName(&#39;tcp&#39;, size, run)
        cmd += &#39;cat &#39; + os.path.join(DIR, name) + &#39; &gt;&gt; &#39; + filename + &#39;; &#39;
    cmd += &#39;echo \&#39;\&#39; &gt;&gt; &#39; + filename + &#39;; &#39;
tcp_task = manager.task_new(&#39;TCP to CSV&#39;, cmd)
tcp_task.dependency_is(uds_task)

manager.run_request_is()

</pre>
<p>Admittedly, this isn’t the prettiest code to look at, but it gets the job done. For both Unix domain socket and TCP socket, it runs the client application for all packet sizes that are a power of 2 from 1 to 16384. Each setup is run 10 times. Each test result is written to its own file. After all the tests have been run, the taskrun script creates a CSV file using all the test results. The CSV file can then be imported into a spreadsheet application for analysis.</p>
<h2>Results</h2>
<p>I ran this on an <a href="http://ark.intel.com/products/75789/">Intel E5-2620 v2</a> processor with 16GB of RAM. I imported the CSV into Excel, averaged the 10 results of each setup, then graphed the results. This first graph shows the execution time compared to packet size on a logarithmic graph.</p>
<p><a href="https://nicisdigital.files.wordpress.com/2014/03/exe-time-vs-pkt-size.png"><img data-attachment-id="604" data-permalink="https://nicisdigital.wordpress.com/2014/03/03/unix-domain-sockets-vs-loopback-tcp-sockets/exe-time-vs-pkt-size/" data-orig-file="https://nicisdigital.files.wordpress.com/2014/03/exe-time-vs-pkt-size.png" data-orig-size="966,611" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;}" data-image-title="Execution Time vs. Packet Size" data-image-description="" data-image-caption="" data-medium-file="https://nicisdigital.files.wordpress.com/2014/03/exe-time-vs-pkt-size.png?w=300" data-large-file="https://nicisdigital.files.wordpress.com/2014/03/exe-time-vs-pkt-size.png?w=510" alt="Execution Time vs. Packet Size" src="https://nicisdigital.files.wordpress.com/2014/03/exe-time-vs-pkt-size.png?w=510&amp;h=322" width="510" height="322" srcset="https://nicisdigital.files.wordpress.com/2014/03/exe-time-vs-pkt-size.png?w=510 510w, https://nicisdigital.files.wordpress.com/2014/03/exe-time-vs-pkt-size.png?w=150 150w, https://nicisdigital.files.wordpress.com/2014/03/exe-time-vs-pkt-size.png?w=300 300w, https://nicisdigital.files.wordpress.com/2014/03/exe-time-vs-pkt-size.png?w=768 768w, https://nicisdigital.files.wordpress.com/2014/03/exe-time-vs-pkt-size.png 966w" sizes="(max-width: 510px) 100vw, 510px"/></a></p>
<p>The results shown here are fairly predicable. The Unix domain sockets are always more efficient and the efficiency benefit is in the 2-3x range. After noticing some weird ups and down in the graph, I decided to generate a graph with the execution times normalized to the TCP execution time.</p>
<p><a href="https://nicisdigital.files.wordpress.com/2014/03/rel-exe-time-vs-pkt-size.png"><img data-attachment-id="605" data-permalink="https://nicisdigital.wordpress.com/2014/03/03/unix-domain-sockets-vs-loopback-tcp-sockets/rel-exe-time-vs-pkt-size/" data-orig-file="https://nicisdigital.files.wordpress.com/2014/03/rel-exe-time-vs-pkt-size.png" data-orig-size="964,562" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;}" data-image-title="Relative Execution Time vs Packet Size" data-image-description="" data-image-caption="" data-medium-file="https://nicisdigital.files.wordpress.com/2014/03/rel-exe-time-vs-pkt-size.png?w=300" data-large-file="https://nicisdigital.files.wordpress.com/2014/03/rel-exe-time-vs-pkt-size.png?w=510" alt="Relative Execution Time vs Packet Size" src="https://nicisdigital.files.wordpress.com/2014/03/rel-exe-time-vs-pkt-size.png?w=510&amp;h=297" width="510" height="297" srcset="https://nicisdigital.files.wordpress.com/2014/03/rel-exe-time-vs-pkt-size.png?w=510 510w, https://nicisdigital.files.wordpress.com/2014/03/rel-exe-time-vs-pkt-size.png?w=150 150w, https://nicisdigital.files.wordpress.com/2014/03/rel-exe-time-vs-pkt-size.png?w=300 300w, https://nicisdigital.files.wordpress.com/2014/03/rel-exe-time-vs-pkt-size.png?w=768 768w, https://nicisdigital.files.wordpress.com/2014/03/rel-exe-time-vs-pkt-size.png 964w" sizes="(max-width: 510px) 100vw, 510px"/></a></p>
<p>I’m not exactly sure why the efficiency of Unix domain sockets varies as it does compared to TCP sockets, but it is always better. This is simply because Unix domain sockets don’t traverse the operating system’s network stack. The kernel simply copies the data from the client’s application into the file buffer in the server’s application.</p>

	              </div></div>
  </body>
</html>
