<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://articles.59.ca/doku.php?id=em:20482030">Original</a>
    <h1>2048 Bit RSA and the Year 2030</h1>
    
    <div id="readability-page-1" class="page"><div class="page">
                                                            <!-- wikipage start -->
                    <!-- TOC START -->

<!-- TOC END -->


<p>
In the course of some recent work I developed the impression that 2048 RSA was quite secure. Canada<sup><a href="#fn__1" id="fnt__1">1)</a></sup> (my country of residence) and others
<sup><a href="#fn__2" id="fnt__2">2)</a></sup> are currently strongly suggesting that 2048 bit RSA should be considered potentially insecure after the year 2030 and that the minimum length considered secure should be then be 3072 bits. That is only 7 years from now (2023).
</p>

<h2 id="where_did_the_2030_cutoff_come_from">Where did the 2030 cutoff come from?</h2>
<div>

<p>
I am reasonably certain that the ideas here came from an influential paper released in 2004 by Arjen K. Lenstra<sup><a href="#fn__3" id="fnt__3">3)</a></sup> that showed this year in a table. Here is a simplified version of the table:
</p>
<div><table>
	<thead>
	<tr>
		<th> Modulus Bit Length </th><th> Conservative Year </th><th> Optimistic Year </th>
	</tr>
	</thead>
	<tbody><tr>
		<td> 1024 </td><td> 2006 </td><td> 2006 </td>
	</tr>
	<tr>
		<td> 1280 </td><td> 2014 </td><td> 2017 </td>
	</tr>
	<tr>
		<td> 1536 </td><td> 2020 </td><td> 2025 </td>
	</tr>
	<tr>
		<td> 2048 </td><td> 2030 </td><td> 2040 </td>
	</tr>
	<tr>
		<td> 3072 </td><td> 2046 </td><td> 2065 </td>
	</tr>
	<tr>
		<td> 4096 </td><td> 2060 </td><td> 2085 </td>
	</tr>
	<tr>
		<td> 8192 </td><td> 2100 </td><td> 2142 </td>
	</tr>
</tbody></table></div>

<p>
<em><sub>Common RSA modulus bit-length life spans. Table 4 from: <a href="https://infoscience.epfl.ch/record/164539/files/NPDF-32.pdf" target="_tab" title="https://infoscience.epfl.ch/record/164539/files/NPDF-32.pdf" rel="ugc nofollow noopener">Key Lengths</a></sub></em>
</p>

<p>
So we look at the 2048 bit row, decide we do not feel all that optimistic, and then choose 2030 as the cutoff date. Simple. Straightforward. Definite. Great for long term planning…
</p>

<p>
Lenstra&#39;s prediction was largely based on two observations:
</p>
<ul>
<li><p> That the performance of computing technology was doubling every 18 months.</p>
</li>
<li><p> That the increase of factoring efficiency due to software improvement was doubling every 18 months.</p>
</li>
</ul>

<p>
Combining the two observations means that as of 2004, the capability to attack RSA 2048 was doubling every 9 months. Then 2004 to 2030 is 26 years or 312 months or 35 doublings. That is a capability increase of 2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2 or 2<sup>35</sup> in exponential notation which works out to a predicted capability increase of 34,359,738,368 times as of 2030. So around 34 billion (34×10<sup>9</sup>) times. This figure can be interpreted as how far 2048 bit RSA encryption was out of reach as of 2004. This is what that increase looks like on a plot:
</p>

<p>
<a href="https://articles.59.ca/lib/exe/detail.php?id=em%3A20482030&amp;media=em:9m0430.svg" target="_tab" title="em:9m0430.svg" rel="noopener"><img src="https://articles.59.ca/lib/exe/fetch.php?media=em:9m0430.svg" loading="lazy" alt=""/></a></p>

<p>
This sort of curve and this sort of increase is called “exponential” after exponential notation. It is well known that any physical quantity can not increase in this way past a certain point. There is a common and ancient story that illustrates this principle in a way quite appropriate to this discussion:
</p>

<p>
Someone is to be rewarded. As a reward, they ask that the following process be completed and that they should then be rewarded with the resultant number of wheat/rice grains.
</p>

<p>
Place a single grain on the first square of a chessboard. Place double that number of grains (2) on the next empty square. Then double <em>that</em> number of wheat grains (4) on the next empty square. If you fill all 64 squares of the chessboard, doubling each time, you end up with an amount of wheat some thousands of times more than the entire yearly production of wheat on the entire planet. Obviously this process can never be completed. The exponential nature of the increase precludes that<sup><a href="#fn__4" id="fnt__4">4)</a></sup>. An appropriate quote:
</p>
<blockquote><p>
Exponentials can&#39;t go on forever, because they will gobble up everything.<br/>
</p></blockquote>

<p>
<sub>Carl Sagan, <em>Billions and Billions: Thoughts On Life And Death At the Brink Of The Millennium</em></sub>
</p>

<p>
Having seen that we have a predicted exponential increase of RSA factoring<sup><a href="#fn__5" id="fnt__5">5)</a></sup> capability here, an important task will be to determine if a limit has yet occurred that would prevent that predicted increase.
</p>

</div>

<h2 id="how_did_things_actually_go">How did things actually go?</h2>
<div>

<p>
The best we can do here is to look at the length of the numbers, of the sort relevant to RSA, that have been actually factored. So far, the largest number is 829 bits long<sup><a href="#fn__6" id="fnt__6">6)</a></sup> which was factored in 2020. Late in 2003, a 576 bit number was factored. Here is a plot of those factoring achievements, including the ones between them:
</p>

<p>
<a href="https://articles.59.ca/lib/exe/detail.php?id=em%3A20482030&amp;media=em:factoring.svg" target="_tab" title="em:factoring.svg" rel="noopener"><img src="https://articles.59.ca/lib/exe/fetch.php?media=em:factoring.svg" loading="lazy" alt=""/></a>
</p>

<p>
I ignored the impression that the increase in factoring capability seems to have levelled off after 2009 and added a linear extrapolation based on the record factorizations over the entire predicted interval. The result (1024 bits by 2030) was still quite underwhelming. One would expect a more definite trend if the capability was increasing exponentially. The increasing trend is not enough to make us think that 2048 bit RSA would be under threat by 2030.
</p>

<p>
If the actual factoring demonstrations <em>had</em> shown a more definite upward trend then we could assume that the researchers were simply funded at a lower level than, say, some over funded state run signals intelligence agency and that there was the possibility of a genuine threat. But as it is, this is just inconclusive for our purposes. There are any number of reasons that less time and fewer resources might be allocated to these factoring demonstrations. We have to find another way to approach this question.
</p>

</div>

<h2 id="how_are_the_basic_assumptions_holding_up_so_far">How are the basic assumptions holding up so far?</h2>
<p>
Let&#39;s consider the two basic assumptions that the prediction was based on:
</p>

<h3 id="factoring_algorithm_performance">Factoring Algorithm Performance</h3>
<div>

<p>
The assumption is that the increase of factoring efficiency due to software improvement will double every 18 months. 
</p>

<p>
It isn&#39;t normally possible to predict the rate of software efficiency increase. It is safe to assume that there will be <em>some</em> increase of performance possible for a particular software system, but not how much or when. Software performance improvement, very generally, seems to have three phases:
</p>
<div><table>
	<thead>
	<tr>
		<th>Phase              </th><th> Performance Increase </th><th> Relative Complexity </th>
	</tr>
	</thead>
	<tbody><tr>
		<td>Low hanging fruit  </td><td>Large                 </td><td>Low                  </td>
	</tr>
	<tr>
		<td>High hanging fruit </td><td>Low                   </td><td>High                 </td>
	</tr>
	<tr>
		<td>New algorithm      </td><td>Small to very large   </td><td>—                  </td>
	</tr>
</tbody></table></div>

<p>
So improvement is first easy in the “low hanging fruit” phase and progressively harder in the “high hanging fruit” phase. The cost of this improvement is increased complexity. At some point someone might invent a new algorithm and the cycle can continue. The improvement that comes with a new algorithm can be very large; perhaps even enough to count as exponential if it happens more than once.
</p>

<p>
That is exactly what happened in the case of factoring algorithms in the &#39;80s and &#39;90s<sup><a href="#fn__7" id="fnt__7">7)</a></sup>. The <em>continued fraction factoring algorithm</em> was followed by the <em>quadratic sieve factoring algorithm</em> which was in turn followed by the <em>number field sieve</em> (NFS) algorithm. At the time of Lenstra&#39;s paper it seemed that his <em>elliptic curve method</em> might exceed the capability of the NFS algorithm.
</p>

<p>
For the 19 years from 2004 and 2023 and an assumption of 18 month doubling we end up with a predicted increase of algorithm performance of 6,502 times. It is hard to find definite figures on actual algorithm performance increase in this interval as it is mixed in with hardware performance. The CADO-NFS<sup><a href="#fn__8" id="fnt__8">8)</a></sup> system claims a performance increase of 3.2 from version 1.1 to version 2.3.0 at the 512 bit (RSA-155) level. The researchers responsible for the most recent factoring record<sup><a href="#fn__9" id="fnt__9">9)</a></sup> (829 bits) claimed a performance increase of 3-4 times. Even combining these improvements (I am not sure that is appropriate) we end up with a performance increase of 12 times which is well short of the predicted 6,502 times.
</p>

<p>
The elliptic curve method never ended up exceeding the NFS algorithm for factoring at the scale of RSA 2048. The NFS algorithm was never exceeded by any other invented algorithm. As a result the NFS algorithm is still the best available 27 years after its invention. That seems to be the reason for the severe slowdown in algorithm performance increase.
</p>

<p>
The history of computing shows that there is normally a quick burst of progress related to algorithmic performance when some particular task becomes feasible followed by a long period of very gradual improvement. The popular example of sorting is a good example. The mergesort, quicksort and heapsort algorithms were invented in 1945, 1959 and 1964 respectively. They are still in routine use today for sorting large lists of values. In retrospect it very much seems that the same sort of thing happened with respect to factoring algorithms. The complexity here seems to be high (CADO-NFS has hundreds of thousands of lines of code) so we are probably in the “high hanging fruit” phase. At this point there seems to be no reason to expect the predicted exponential increase in factoring algorithm performance (165,140 times) required to threaten 2048 bit RSA by the year 2030.
</p>

</div>

<h3 id="computing_performance">Computing Performance</h3>
<div>

<p>
The prediction is based in the assumption that the available computing performance will double every 18 months.
</p>

<p>
This assumption is popularly known as “Moore&#39;s Law”<sup><a href="#fn__10" id="fnt__10">10)</a></sup>. It has become fashionable to speculate that Moore&#39;s law is now dead. That is both true and false.
</p>

<p>
It turns out that there are two versions of Moore&#39;s law. The 18 month doubling refers to the increase in available computing performance and is appropriate to our discussion here. The original Moore&#39;s law refers to the number of <a href="https://en.wikipedia.org/wiki/Transistor" target="_tab" title="https://en.wikipedia.org/wiki/Transistor" rel="noopener">transistors</a> available on a substrate of a particular size and is now generally accepted to mean a doubling every 24 months. The 24 month law related to the number of transistors is still alive (but the rate of examples is decreasing rapidly). The 18 month performance law is the one that is dead. That&#39;s the one that the 2030 prediction is based on…
</p>

<p>
If you double the number of transistors on a substrate of a particular size then if the power consumption of those new transistors is half the power consumption of the old transistors then the result will be a substrate that produces the same amount of heat. <a href="https://en.wikipedia.org/wiki/Dennard_scaling" target="_tab" title="https://en.wikipedia.org/wiki/Dennard_scaling" rel="noopener">Dennard scaling</a> explains why this used to be the case. Otherwise, each doubling of transistors would produce more heat in the same area. That heat would quickly become unmanageable. The 18 month performance version of Moore&#39;s law depends on Dennard scaling to be practical. But Dennard scaling no longer works and as a result Moore&#39;s law 18 is dead.
</p>

<p>
This graph shows an example based on Intel processors:
</p>

<p>
<a href="https://articles.59.ca/lib/exe/detail.php?id=em%3A20482030&amp;media=em:dennard.png" target="_tab" title="em:dennard.png" rel="noopener"><img src="https://articles.59.ca/lib/exe/fetch.php?w=640&amp;tok=b6207e&amp;media=em:dennard.png" loading="lazy" alt="" width="640"/></a></p>

<p>
Note the logarithmic scale. The rising, roughly straight line for the number of transistors indicates that some sort of exponential increase is occurring. The qualities we are interested in, clock speed and performance per clock, have levelled off. The power consumption has levelled off because of physical limitations associated with removing heat from a substrate. Because of the end of Dennard scaling, performance is limited by the power efficiency of the transistors and the amount of heat that can be removed from the substrate. We can&#39;t make the transistors smaller in a way that would make them faster because making transistors smaller greatly decreases their power efficiency. That is mostly because of <a href="https://en.wikipedia.org/wiki/Quantum_tunnelling" target="_tab" title="https://en.wikipedia.org/wiki/Quantum_tunnelling" rel="noopener">quantum tunnelling</a> which turned out to be a fundamental physical limit on the performance of the highest performance computing technology we have.
</p>

<p>
There it is. A physical limit that prevents an exponential increase. In retrospect, it can be seen that this limit was already preventing an exponential increase in 2004 when the prediction was made. Unfortunate timing for the one making the prediction but it makes our task here easier. There was no exponential growth of computing performance from 2004 to 2023. It is very unlikely that such growth will reappear in the 7 years before 2030.
</p>

</div>

<h2 id="where_are_we_now">Where Are We Now?</h2>
<div>

<p>
How do things look for breaking 2048 bit RSA right now in 2023?
</p>

<p>
The best available algorithm known, usable with the most powerful computers we know how to build, is NFS. So we would use the NFS algorithm.
</p>

<p>
How much computing power could be brought to bear? As a exorbitant example we could use the Bitcoin mining network. The Bitcoin mining network is a distributed network devoted to breaking a cryptographic function with a brute force search. So it would seem to be a fairly good example to use with respect to breaking RSA which is the same sort of thing.
</p>

<p>
Bitcoin mining is a process that makes money for the entity running the mining system. This financial incentive has created a situation where the mining network has expanded to what might seem a ridiculous extent. The incentive is very sensitive to the cost of electricity. As a result the mining systems are designed to be as power efficient as humanly possible. The end of Dennard scaling is very relevant here. The troublesome heat starts as expensive electricity. Even with this desperate quest for energy efficiency, it is estimated that the Bitcoin mining network consumed 1/200th (0.5%) of all the electricity generated on the entire planet<sup><a href="#fn__11" id="fnt__11">11)</a></sup>in 2021. This makes the network a good upper limit on what might be done in secret. If some over funded national signals intelligence agency built that much processing power we would be able to tell just by checking their power bill. Electricity consumption at the level of an entire country would be impossible to hide.
</p>

<p>
Let&#39;s imagine that we could magically repurpose the processing power of the entire Bitcoin mining network for breaking a single 2048 bit RSA key. This will require us to relate what the network is currently doing to the NFS algorithm. I will use the “apples to apples” relation developed in RFC3766<sup><a href="#fn__12" id="fnt__12">12)</a></sup>. It&#39;s based on the situation in 2004 but there does not seem to be a better one available. The operations that the Bitcoin network performs would seem to take roughly the same amount of processing as the operations used as a reference in RFC3766<sup><a href="#fn__13" id="fnt__13">13)</a></sup>. By RFC3766, breaking 2048 bit RSA would require 9.01×10<sup>30</sup> cryptographic operations. The Bitcoin mining network recently achieved a rate of 1.24×10<sup>28</sup> operations/year<sup><a href="#fn__14" id="fnt__14">14)</a></sup>.
</p>

<p>
So using the power of the largest amount of computing ever dedicated to breaking cryptographic operations in history, it would take  9.01×10<sup>30</sup>/1.24×10<sup>28</sup> years to break one RSA key. That works out to 727 years. If we could magically create enough physical hardware to break a RSA key in a year then we would need to come up with 727/200 or 3.6 times the amount of electricity currently generated on the planet to run that hardware.
</p>

<p>
This only compares the amount of computing power required to break 2048 bit RSA vs the amount of computing power embodied by the Bitcoin mining network. The operations that the Bitcoin network do require very little memory/RAM. The NFS algorithm on the other hand requires a tremendous amount of memory. In 2004, R. D. Silverman pushed back against the idea that 1024 bit RSA was at imminent risk of compromise. As part of that argument he pointed out that the NFS algorithm has a phase (matrix reduction) that requires a large amount of computing power tightly coupled to a large amount of memory. On the basis of that observation he predicted that 1024 bit RSA would not be publicly broken before the 2030s. So far that prediction seems on track. In passing he mentioned that 2048 bit RSA would require 10<sup>18</sup> bytes of memory for the irreducible matrix reduction step<sup><a href="#fn__15" id="fnt__15">15)</a></sup>. That&#39;s a million terabytes, an unimaginable amount of memory to be found in one place, much less tightly coupled to enough processing power to provide any practical benefit. Speaking of memory, the speed of DRAM has lagged to be something like a hundred times slower than processing and sieving is likely very cache unfriendly. So the idea that the processing power of the Bitcoin network could break a single 2048 bit RSA key in a mere 727 years is hopelessly optimistic.
</p>

<p>
It is clear that 2048 bit RSA is vastly out of the scope of current computing technology running the best available algorithm (NFS)…
</p>

</div>

<h2 id="the_future">The future</h2>
<div>

<p>
It appears that a fundamental algorithmic breakthrough would be a prerequisite to threaten the security of RSA 2048. How likely is such a breakthrough?
</p>

<p>
Factoring, prime numbers and the relationship between the two subjects have fascinated humanity for a very long time. The fundamental idea of sieving as a fast method of finding a lot of primes has been around for thousands of years<sup><a href="#fn__16" id="fnt__16">16)</a></sup> (Number Field <em>Sieve</em>, Quadratic <em>Sieve</em>).
</p>

<p>
When creating advanced factoring algorithms there is a vast amount of historical knowledge available. This is very well trodden ground. I think this reduces the chances of surprising insights and reduces the advantage to those working in secret.
</p>

</div>

<h3 id="quantum_computing">Quantum computing</h3>
<div>

<p>
Quantum computing of the sort intended to break RSA involves a breakthrough in both computing and algorithms. Normally some sort of new computing technology is invented and then algorithms are designed to enable that technology to do something useful. The quantum computing threat to RSA is different. We now have the algorithm (Shor&#39;s) but the computer to run it on only exists in our imagination.
</p>

<p>
If someone were to invent such a computer then RSA 2048 would be immediately and trivially breakable. RSA 3072 would also be trivially breakable. The same applies to RSA 4096 and 8192. The threat here is admittedly hypothetical, but this still serves as an example of a situation where routine key length extension is of no real value. By repeatedly increasing the size of keys we are betting that a breakthrough will be exactly strong enough to break the superseded key length and not break the current key length. That seems unlikely.
</p>

<p>
New threats tend to take a different form than old threats…
</p>

</div>

<h2 id="conclusion">Conclusion</h2>
<div>

<p>
The assumptions that the 2030 date for increasing RSA key length were based on turned out to be invalid. A check of current capability confirms this. There seems to be no rational reason to increase RSA key sizes past 2048 starting in the year 2030. We don&#39;t have any reason to increase RSA key sizes at <em>any</em> time based on our current understanding.
</p>
<blockquote><p>
Although this type of estimates is the best that can be done at this point, it should be understood that actual factoring capabilities may follow an entirely different pattern. Any prediction more than a few decades away about security levels is wishful thinking. The figures in the tables should be properly interpreted, namely as today’s best estimates that may have to be revised tomorrow. Anyone using factoring based asymmetric cryptosystems should constantly monitor and stay ahead of the developments in the research community.</p></blockquote>

<p>
The proceeding quoted text is found with the previously shown “Common RSA modulus bit-length life spans” table in the original paper. If you don&#39;t believe me you should still believe Dr. A. K. Lenstra, the one that came up with the double exponential prediction in the first place. We should enact a continuous process of watchful waiting. Any policy changes should be done as a response to changes in the algorithmic and computing performance landscape.
</p>

<p>
This is important because an aspect like a key length is often deeply embedded in the systems protected by the associated cryptography. Rooting out and changing such aspects is normally very expensive in the sorts of systems where cryptographic protection is provided. Where this is not possible at the software level then wholesale equipment replacement is required. The time and resources expended on pointless key length increases can be more profitably used elsewhere. Longer RSA keys require more processing power to process so that pointless keylength increases waste computing resources and power as well.
</p>

</div>

<h2 id="other_systems">Other systems</h2>
<p>
Up to this point this article was made exclusively about RSA to improve readability. Let&#39;s use the ideas developed here to briefly examine some other popular cryptographic systems. I will use the NIST recommendations as the practical example<sup><a href="#fn__17" id="fnt__17">17)</a></sup><sup><a href="#fn__18" id="fnt__18">18)</a></sup>. The period for all of these NIST recommendations is from 2019 to 2030 (11 years). The current keysize recommendation became effective as of 2019 and the next one becomes effective as of 2030.
</p>

<h3 id="discrete_logarithm">Discrete logarithm</h3>
<div>

<p>
Current group size: 2048 bits. Next group size: 3072 bits.
</p>

<p>
This is most often seen as the basis of the <a href="https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange" target="_tab" title="https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange" rel="noopener">Diffie–Hellman key exchange</a> system.
</p>

<p>
The best known algorithm to attack discrete logarithm systems is also a version of NFS. The difficulty vs RSA is slightly harder where the RSA key size is the same as the discrete logarithm group size. So the proceeding discussion about the pointlessness of increasing RSA key sizes directly applies to discrete logarithm systems.
</p>

</div>

<h3 id="elliptic_curve_based">Elliptic curve based</h3>
<div>

<p>
Current key size: 224 bits. Next key size: 256 bits.
</p>

<p>
The rule of thumb for elliptic curves is that 2 extra key bits doubles the difficulty. That&#39;s (256-224)/2=16 difficulty doublings over the 11 year period. So an implicit assumption that the capability available for breaking elliptic curves will double every 11*12/16=8.25 months. That&#39;s a bit faster than the 9 month double exponential assumption that in turn comes from the assumption that available processing power and algorithmic capability are each doubling every 18 months. We know that that is not true for processing power. I have not been able to find any indication of a current or upcoming breakthrough in software methods for breaking elliptic curves, but I am not really qualified to judge that. So I will have to leave this here. In the absence of any evidence of a algorithmic breakthrough then the increase from 224 bits to 256 bits would be unnecessary.
</p>

<p>
Elliptic curve based systems can use much shorter key lengths than other systems. Pointlessly increasing elliptic curve key length would be tragic. If the current assumptions are maintained that would mean we would see a recommendation for more than 256 bit elliptic curve keys for the 2040 decade.
</p>

</div>

<h3 id="symmetric_encryption">Symmetric encryption</h3>
<div>

<p>
Current key size: 112 bits. Next key size: 128 bits.
</p>

<p>
Some examples of symmetric encryption schemes are: <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" target="_tab" title="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" rel="noopener">AES</a>, <a href="https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant" target="_tab" title="https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant" rel="noopener">ChaCha20</a> and <a href="https://en.wikipedia.org/wiki/Camellia_(cipher)" target="_tab" title="https://en.wikipedia.org/wiki/Camellia_(cipher)" rel="noopener">Camellia</a>.
</p>

<p>
One extra key bit doubles the difficulty here. That&#39;s 128-112=16 difficulty doublings over the 11 year period. So an implicit assumption that the capability available for breaking elliptic curves will double every 11*12/16=8.25 months. That&#39;s a bit faster than the 9 month double exponential assumption that in turn comes from the assumption that available processing power and algorithmic capability are each doubling every 18 months. We know that that is not true for processing power.
</p>

<p>
The idea that the algorithmic capability against symmetric encryption might be doubling every 18 months is fairly surprising. A regular increase here is not something that is normally assumed. Perhaps there was some sort of “debt” with respect to key length that we are making up for in this time period. It might be good to apply the Bitcoin thought experiment as previously seen in this article as a sort of sanity check.
</p>

<p>
The number of cryptographic operations required to use brute force to break a 112 bit key in a symmetric system is 2<sup>112</sup>=5.19×10<sup>33</sup> operations. We will make the reasonable assumption that one Bitcoin operation would take roughly the same time as one symmetric encryption operation. Then it would take 5.19×10<sup>33</sup>/1.24×10<sup>28</sup>=418,548 years. Reducing this to a year would require 418,548/200=2092 times the current total planetary electricity production<sup><a href="#fn__19" id="fnt__19">19)</a></sup>.
</p>

<p>
It does not seem reasonable to increase minimum symmetric encryption key size past 112 bits after 2030.
</p>

<p>
<a href="https://articles.59.ca/doku.php?id=em:index" title="em:index" data-wiki-id="em:index">Encrypted Messaging index</a></p>

</div>


                    <!-- wikipage stop -->
                                    </div></div>
  </body>
</html>
