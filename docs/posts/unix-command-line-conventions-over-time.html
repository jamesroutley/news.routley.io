<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.liw.fi/posts/2022/05/07/unix-cli/">Original</a>
    <h1>Unix command line conventions over time</h1>
    
    <div id="readability-page-1" class="page"><article class="page">
    

    

    <div id="pagebody">
      <section>
	<p>This blog post documents my understanding of how the conventions for Unix command line syntax have evolved over time. It’s not properly sourced, and may well be quite wrong. I’ve not been using Unix until 1989, so I wasn’t there for the early years. Maybe someone has written a proper essay on this, with citations. I’m too lazy to dig them up.</p>

<p>In the beginning, in the first year or so of Unix, an ideal was formed for what a Unix program would be like: it would be given some number of filenames as command line arguments, and it would read those. If no filenames were given, it would read the standard input. It would write its output to the standard output. There might be a small number of other, fixed, command line arguments. Options didn’t exist. This allowed programs to be easily combined: one program’s output could be the input of another.</p>
<p>There were, of course, variations. The <code>echo</code> command didn’t read anything. The <code>cp</code>, <code>mv,</code> and <code>rm</code> commands didn’t output anything. However, the “filter” was the ideal.</p>

<p>In the example above, the <code>cat</code> program reads all files with names with a <code>.txt</code> suffix, writes them to its standard output, which is then <em>piped</em> to the <code>wc</code> program, which reads its standard input (it wasn’t given any filenames) to count words. In short, the pipeline above counts words in all text files.</p>
<p>This was quite powerful. It was also very simple.</p>

<p>Fairly quickly, the developers of Unix found that many programs would be more useful if the user could choose between minor variations of function. For example, the <code>sort</code> program could provide the option to order input lines without consideration to upper and lower case of text.</p>
<p>The command line option was added. This seems to have resulted in a bit of a philosophical discussion among the developers. Some were adamant against options, fearing the complexity it would bring, and others really liked them, for the convenience. The side favoring options won.</p>
<p>To make command line parsing easy to implement, options always started with a single dash, and consisted of a single character. Multiple options could be packed after one dash, so that <code>foo -a -b -c</code> could be shortened to <code>foo -abc</code>.</p>
<p>If not immediately, then soon after, an additional twist was added: some options required a value. For example, the <code>sort</code> program could be given the <code>-kN</code> option, where <code>N</code> is an integer specifying which word in a line would be used for sorting. The syntax for values was a little complicated: the value could follow the option letter as part of the same command line argument, or be the next argument. The following two commands thus mean the same thing:</p>

<p>At this point, command line parsing became more than just iterating over the command line arguments. The dominant language for Unix was C, and a lot of programs implemented the command line parsing themselves. This was unfortunate, but at this stage the parsing was still sufficiently simple that most of them did it in sufficiently similar ways that it didn’t cause any serious problems. However, it was now the case that one often needed to check the manual, or experiment, to find out how a specific program was to be used.</p>
<p>Later on, Wikipedia says 1980, the C library function <code>getopt</code> was written. It became part of the Unix C standard library. It implemented the command line parsing described above. It was written in C, which at that time was quite a primitive programming language, and this resulted in a simplistic API. Part of that API is that if the user used an unknown option on the command line, the <code>getopt</code> function would return a question mark (<code>?</code>) as its value. Some programs would respond by writing out a short usage blurb. This led to <code>-?</code> being sometimes used to tell a program to show a help text.</p>

<p>In the late 1970s Unix spread from its birthplace, Bell Labs, to other places, mostly universities. Much experimentation followed. During the 1980s some changes to command line syntax happened. The biggest change here was long options: options whose name wasn’t just a single character. For example, in the new X window system, the <code>-display</code> option would be used to select which display to use for a GUI program.</p>
<p>Note the single dash. This clashed with the “clumping together” of single character option. Does <code>-display</code> mean which display to use, or the options <code>-d -i -s -p -l -a -y</code> clumped together? This depended on the program and how it decided to parse the options.</p>
<p>A further complication to parsing the command line was that single-dash long options that took values couldn’t allow the value to be part of the same command line argument. Thus, <code>-display :0</code> (two words) was correct, but it could not be written as <code>-display:0</code>, because a simple C command line parser would have difficulty figuring out what was the option name and what was the option’s value. Thus, what previously might have been written as a single argument <code>-d:0</code> now became two arguments.</p>
<p>The world did not end, but a little more complexity had landed in the world of Unix command line syntax.</p>

<p>The GNU project was first announced in 1983. It was to be an operating system similar to Unix. One of the changes it made was to command line syntax. GNU introduced another long option syntax, I believe to disambiguate the single-dash long option confusion with clumped single-character options.</p>
<p>Initially, GNU used the plus (<code>+</code>) to indicate a long option, but quickly changed to a double dash (<code>--</code>). This made it unambiguous whether a long option or clumped short options were being used.</p>
<p>I believe it was also GNU that introduced using the equals sign (<code>=</code>) to <em>optionally</em> add a value to a long option. Values to options could be optional: <code>--color</code> could mean the same as <code>--color=auto</code>, but you could also say <code>--color=never</code> if you didn’t like the default value.</p>
<p>GNU further allowed options to occur anywhere on the command line, not just at the beginning. This made things more convenient to the user.</p>
<p>GNU also wrote a C function, <code>getopt_long</code>, to unify command line parsing across the software produced by the project. I believe it supported the single-dash long options from the start. Some GNU programs, such as the C compiler, used those.</p>
<p>Thus, the following was acceptable:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>$ <span>grep</span> -xi *.txt --regexp=foo --regexp bar</span></code></pre></div>
<p>The example above clumps the short options <code>-x</code> and <code>-i</code> into one argument, and provided <code>grep</code> with two regular expression patterns, one with an equals, and one without.</p>
<p>The GNU changes have largely been adopted by other Unix variants. I’m sure those have had their own changes, but I’ve not followed them enough to know.</p>
<p>GNU also added standard options: almost every GNU program supports the options <code>--help</code>, <code>--version</code>, and <code>--mail=ADDR</code>.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<h2 id="double-dash">Double dash</h2>
<p>Around this time, a further convention was added: an argument of two dashes only (<code>--</code>) as a way to say that no further options to the command being invoked would follow. I believe this was another GNU change, but I have no evidence.</p>
<p>This is useful to, say, be able to remove a file with name that starts with a dash:</p>

<p>For <code>rm</code>, it was always possible to provide a fully qualified path, starting from the root directory, or to prefix the filename with a directory—<code>rm ./-f</code>—and so this convention is not necessary for removing files. However, given all GNU programs use the same function for command line parsing, <code>rm</code> gets it for free. Other Unix variants may not have that support, though, so users need to be careful.</p>
<p>The double dash is more useful for other situations, such as when invoking a program that invokes another program. An example is the <code>cargo</code> tool for the Rust language. To build and run a program and tell it to report its version, you would use the following command:</p>

<p>Without the double dash, you would be telling <code>cargo</code> to report its version.</p>

<p>I think at around the late 1980s, subcommands were added to the Unix command line syntax conventions. Subcommands were a response to many Unix programs gaining a large number of “options” that were in fact not optional at all, and were really commands. Thus a program might have “options” <code>--decrypt</code> and <code>--encrypt</code>, and the user was required to use one of them, but not both. This turned out to be a little hard for many people to deal with, and subcommands were a simplification. Instead of using option syntax for commands, just require commands instead.</p>
<p>I believe the oldest program that uses subcommand is the version control system SCCS, from 1972, but I haven’t been able to find out which version added subcommands. Another version control system, CVS, from 1990, seems to have had them the beginning. CVS was built on top of yet another version control system, RCS, which had programs such as <code>ci</code> for “check in”, and <code>co</code> for “check out”. CVS had a single program, with subcommands:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>$ <span>cvs</span> ci ...</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>$ <span>cvs</span> co ...</span></code></pre></div>
<p>Later version control systems, such as Subversion, Arch, and Git, follow the subcommand pattern. Version control systems seem to inherently require the user to do a number of distinct operations, which fits the subcommand style well, and also avoids adding large numbers of individual programs (commands) to the shell, reducing name collisions.</p>
<p>Subcommands add further complications to command line syntax, though, when inevitably combined with options. The main command may have options (often called “global options”), but so can subcommands. When options can occur anywhere on the command line, is <code>--version</code> a global option, or specific to a subcommand? Worse, how does a program parse a command line? If an option is specific to a subcommand, the parsing needs to know which subcommand, if only so it knows whether the options requires a value or not.</p>
<p>To solve this, some programs require global options to be before the subcommand, which is easy to implement. Others allow them anywhere. Everything seems to require per-subcommand options to come after the subcommand.</p>

<p>The early Unix developers who feared complexity were right, but also wrong. It would be intolerable to have to have a separate program for every combination of a program with options. To be fair, I don’t think that’s what they would’ve advocated: instead, I think, they would’ve advocated tools that can be combined, and to simplify things so that fewer tools are needed.</p>
<p>That’s not what happened, alas, and we live in a world with a bit more complexity than is strictly speaking needed. If we were re-designing Unix from scratch, and didn’t need to be backwards compatible, we could introduce a completely new syntax that is systematic, easy to remember, easy to use, and easy to implement. Alas.</p>
<p>None of this explains <code>dd</code>.</p>


      </section>
    </div>

  </article></div>
  </body>
</html>
