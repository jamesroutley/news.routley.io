<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.polarsignals.com/blog/posts/2022/11/29/profiling-without-frame-pointers/">Original</a>
    <h1>DWARF-Based Stack Walking Using eBPF</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>This feature was previously introduced in <a href="https://www.polarsignals.com/blog/posts/2022/11/23/profiling-without-frame-pointers/">the announcement post</a>.</em></p><p>Sampling CPU profilers periodically fetch the stacks of the profiled processes that are running on the CPU at a given time. Walking the stacks of native processes, such as the ones written in C, C++, Rust, etc can be a bit more complicated than one might expect. Most of the complexity is due to the lack of frame pointers, which is quite common.</p><p>We have developed an improved stack walker that works even if frame pointers are omitted in the <a href="https://www.parca.dev/">Parca continuous profiling project</a>&#39;s <a href="https://github.com/parca-dev/parca-agent/">Agent</a>.</p><h2>The stack in x86_64</h2><p>The x86_64 architecture, besides describing its instruction set and several other important characteristics, also defines the rules on how data should be laid out in its Application Binary Interface or ABI for short. The specification shows how the stack should be set up for this architecture.</p><p>When this code is executed, the different <code>call</code> instructions will push the return address to the stack. Once a function returns, the CPU will read the return address and jump to it, continuing where the callsite of the function left.</p><p>With no additional information, it’s not possible to reliably produce a stacktrace. There could be other values, such as function local data, that are stored in the stack that might look like function addresses. This is what frame pointers aim to solve.</p><h2>Can I have a (frame) pointer?</h2><p>For the following pseudocode, assuming no compiler optimisations:</p><pre><pre><p><span>int</span><span> </span><span>top</span><span>(</span><span>void</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>for</span><span>(</span><span>;</span><span>;</span><span>)</span><span> </span><span>{</span><span> </span><span>}</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>int</span><span> </span><span>c1</span><span>(</span><span>void</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>top</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>int</span><span> </span><span>b1</span><span>(</span><span>void</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>c1</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>int</span><span> </span><span>a1</span><span>(</span><span>void</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>b1</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>int</span><span> </span><span>main</span><span>(</span><span>void</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>a1</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span></p></pre></pre><p>To walk the stack with this method, we need to keep a pointer to the previous frame. In the x86 architecture, this typically would be in the frame pointer, <code>$rbp</code>. As functions may call other functions, this register has to be stored on function entry and restored on function exit.</p><p>This is accomplished by the so-called function prologue, on function entry, which might look like this</p><pre><pre><p><span>push $rbp # saves the stack frame pointer</span></p><p><span>mov $rbp, $rsp # sets the current stack pointer to the frame pointer</span></p></pre></pre><p>And the function epilogue on the function returns</p><pre><pre><p><span>pop $rbp # restores the function&#39;s frame pointer</span></p><p><span>ret # pops the saved return address and jumps to it</span></p></pre></pre><p>If we compile and run the C code above with frame pointers, the stack would have all the necessary information to walk the stack. Calling the different functions effectively creates a linked list that we need to traverse.</p><details open=""><summary>Disassembly of the code above compiled with frame pointers</summary><pre><pre><p><span># compiled with `gcc sample.c -o sample_with_frame_pointers -fno-omit-frame-pointer`</span></p><p><span>$ objdump -d ./sample_with_frame_pointers</span></p><p><span>0000000000401106 &lt;top&gt;:</span></p><p><span>  401106:       55                      push   %rbp</span></p><p><span>  401107:       48 89 e5                mov    %rsp,%rbp</span></p><p><span>  40110a:       eb fe                   jmp    40110a &lt;top+0x4&gt;</span></p><p><span>000000000040110c &lt;c1&gt;:</span></p><p><span>  40110c:       55                      push   %rbp</span></p><p><span>  40110d:       48 89 e5                mov    %rsp,%rbp</span></p><p><span>  401110:       e8 f1 ff ff ff          call   401106 &lt;top&gt;</span></p><p><span>  401115:       90                      nop</span></p><p><span>  401116:       5d                      pop    %rbp</span></p><p><span>  401117:       c3                      ret</span></p><p><span>0000000000401118 &lt;b1&gt;:</span></p><p><span>  401118:       55                      push   %rbp</span></p><p><span>  401119:       48 89 e5                mov    %rsp,%rbp</span></p><p><span>  40111c:       e8 eb ff ff ff          call   40110c &lt;c1&gt;</span></p><p><span>  401121:       90                      nop</span></p><p><span>  401122:       5d                      pop    %rbp</span></p><p><span>  401123:       c3                      ret</span></p><p><span>0000000000401124 &lt;a1&gt;:</span></p><p><span>  401124:       55                      push   %rbp</span></p><p><span>  401125:       48 89 e5                mov    %rsp,%rbp</span></p><p><span>  401128:       e8 eb ff ff ff          call   401118 &lt;b1&gt;</span></p><p><span>  40112d:       90                      nop</span></p><p><span>  40112e:       5d                      pop    %rbp</span></p><p><span>  40112f:       c3                      ret</span></p><p><span>0000000000401130 &lt;main&gt;:</span></p><p><span>  401130:       55                      push   %rbp</span></p><p><span>  401131:       48 89 e5                mov    %rsp,%rbp</span></p><p><span>  401134:       e8 eb ff ff ff          call   401124 &lt;a1&gt;</span></p><p><span>  401139:       b8 00 00 00 00          mov    $0x0,%eax</span></p><p><span>  40113e:       5d                      pop    %rbp</span></p><p><span>  40113f:       c3                      ret</span></p></pre></pre></details><p><img src="https://www.polarsignals.com/blog/posts/2022/11/29/profiling-without-frame-pointers/stack_with_fp.png" alt="The contents of the native stack in the example code above when the top function is running. Shows the different return addresses, interleaved with the saved frame pointers. There&#39;s no local variables that have been pushed into the stack." width="100%"/><span>The contents of the native stack in the example code above compiled with frame pointers when the top function is running.</span></p><p>To walk the stack, we would have to follow the generated linked list above, reading the values pushed before each saved <code>$rbp</code>, which will make our stack frames, until <code>$rbp</code> is zero, which indicated that we&#39;ve reached the end of the stack.</p><p>This is nice because it allows us to figure out the stack trace cheaply. It’s also relatively easy for compiler implementers to add, and in general, requires a reasonably small amount of surrounding infrastructure to make it work.</p><p>Despite all the advantages, a lot of the code that we rely on is not compiled with frame pointers. Many of us rely on our Linux distribution applications and libraries, and the overwhelming majority of them choose to omit frame pointers. Even if you compile your code with frame pointers, dynamically or statically linking any library provided by your distribution might prevent you from being able to correctly unwind the stack using frame pointers alone.</p><p>We won’t dive into the reasons why frame pointers are disabled in some environments and the nuances around them, but we believe that benchmarking their overhead has to be done on an application-by-application basis. The often-overlooked costs that come with disabling frame pointers should also be considered.</p><details><summary>The disassemble of this executable compiled without frame pointers</summary><pre><pre><p><span># compiled with `gcc sample.c -o sample_without_frame_pointers -fomit-frame-pointer`</span></p><p><span>$ objdump -d ./sample_without_frame_pointers</span></p><p><span>[...]</span></p><p><span>0000000000401106 &lt;top&gt;:</span></p><p><span>  401106:       eb fe                   jmp    401106 &lt;top&gt;</span></p><p><span>0000000000401108 &lt;c1&gt;:</span></p><p><span>  401108:       e8 f9 ff ff ff          call   401106 &lt;top&gt;</span></p><p><span>  40110d:       90                      nop</span></p><p><span>  40110e:       c3                      ret</span></p><p><span>000000000040110f &lt;b1&gt;:</span></p><p><span>  40110f:       e8 f4 ff ff ff          call   401108 &lt;c1&gt;</span></p><p><span>  401114:       90                      nop</span></p><p><span>  401115:       c3                      ret</span></p><p><span>0000000000401116 &lt;a1&gt;:</span></p><p><span>  401116:       e8 f4 ff ff ff          call   40110f &lt;b1&gt;</span></p><p><span>  40111b:       90                      nop</span></p><p><span>  40111c:       c3                      ret</span></p><p><span>000000000040111d &lt;main&gt;:</span></p><p><span>  40111d:       e8 f4 ff ff ff          call   401116 &lt;a1&gt;</span></p><p><span>  401122:       b8 00 00 00 00          mov    $0x0,%eax</span></p><p><span>  401127:       c3                      ret</span></p><p><span>[...]</span></p></pre></pre></details><details open=""><summary>Diff between the two disassembles</summary><pre><pre><p><span>top:</span></p><p><span></span><span>-</span><span>       push   %rbp</span></p><p><span></span><span>-</span><span>       mov    %rsp,%rbp</span></p><p><span></span><span> </span><span>       jmp    40110a &lt;top+0x4&gt;</span></p><p><span>c1:</span></p><p><span></span><span>-</span><span>       push   %rbp</span></p><p><span></span><span>-</span><span>       mov    %rsp,%rbp</span></p><p><span></span><span> </span><span>       call   401106 &lt;top&gt;</span></p><p><span></span><span> </span><span>       nop</span></p><p><span></span><span>-</span><span>       pop    %rbp</span></p><p><span></span><span> </span><span>       ret</span></p><p><span>b1:</span></p><p><span></span><span>-</span><span>       push   %rbp</span></p><p><span></span><span>-</span><span>       mov    %rsp,%rbp</span></p><p><span></span><span> </span><span>       call   40110c &lt;c1&gt;</span></p><p><span></span><span> </span><span>       nop</span></p><p><span></span><span>-</span><span>       pop    %rbp</span></p><p><span></span><span> </span><span>       ret</span></p><p><span>a1:</span></p><p><span></span><span>-</span><span>       push   %rbp</span></p><p><span></span><span>-</span><span>       mov    %rsp,%rbp</span></p><p><span></span><span> </span><span>       call   401118 &lt;b1&gt;</span></p><p><span></span><span> </span><span>       nop</span></p><p><span></span><span>-</span><span>       pop    %rbp</span></p><p><span></span><span> </span><span>       ret</span></p><p><span>main:</span></p><p><span></span><span>-</span><span>       push   %rbp</span></p><p><span></span><span>-</span><span>       mov    %rsp,%rbp</span></p><p><span></span><span> </span><span>       call   401124 &lt;a1&gt;</span></p><p><span></span><span> </span><span>       mov    $0x0,%eax</span></p><p><span></span><span>-</span><span>       pop    %rbp</span></p><p><span></span><span> </span><span>       ret</span></p></pre></pre></details><p>If when we are profiling we are somewhere in the execution of c1, the stack might look like this:</p><p><img src="https://www.polarsignals.com/blog/posts/2022/11/29/profiling-without-frame-pointers/stack_without_fp.png" alt="The contents of the native stack in the example code above when executing the top function is running. Shows the different return addresses, and nothing else, as there&#39;s no frame pointers nor local variables." width="100%"/><span>The contents of the native stack from the code above when top is running.</span></p><p>We need some other information or hardware support to be able to reliably unwind the stack.</p><h2>Hardware approaches</h2><p>There are some hardware facilities that we could use for stack unwinding, such as Intel’s <a href="https://lwn.net/Articles/680985/">Last Branch Record (LBR)</a>. LBR produces pairs of origin and destination addresses, <code>FROM_IP</code> and <code>TO_IP</code>, that we can use to build stack traces. One drawback they have is that the depth of the records they can produce is limited. Depending on the processor this could be around 32 last taken branches.</p><p>While LBR is versatile and powerful, we decided to not use it for CPU profiling as this feature is not available in every virtualized environment and it’s Intel-specific. These drawbacks extend to other interesting vendor-specific processor features, such as <a href="https://lwn.net/Articles/648154/">Intel Processor Trace (PT</a>).</p><h2>An exceptional encounter</h2><p>Some of you might be thinking, how is it possible that I can compile, let’s say, C++ applications without frame pointers, and exceptions still work just fine? What about Rust, where frame pointers are disabled by default but invoking <code>panic()</code>s shows a full and correct stack trace?</p><p>For C++ exceptions to work no matter how the binaries are compiled, as well as to add some other necessary facilities to make them function, compilers can emit some metadata that indicated how to unwind the stack. This information provides a mapping of program counters to the instructions on how to restore all the registers.</p><p>All this is described in two documents, the <a href="https://dwarfstd.org/doc/DWARF5.pdf">DWARF debugging information format</a> and the <a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf">x86_64 ABI</a>.</p><h3>DWARF’s Call Frame Information (CFI)</h3><p>The main goal of the Call Frame Information is to provide answers on how to restore every register for the previous frame at any part of our code execution. Directly storing a table that contained each program counter and all the registers and their location, such as whether they’ve been pushed to the stack or not, would generate humongous unwind tables.</p><p>For this reason, this format attempts to be compact and only contain the information that is needed. It uses various techniques to this effect such as:</p><ul><li>Variable length compression of numbers with <a href="https://en.wikipedia.org/wiki/LEB128">LEB128</a>.</li><li>Data compression with a state machine. This is important as it allows for a very succinct representation of the data at the expense of increased complexity.</li></ul><p>The unwind tables are encoded in the CFI format in the form of opcodes that we need to evaluate. There are two main &#34;layers&#34; to it. The first one is a state machine encoded in a VM. This helps with repetitive patterns that compress well, and allows for a more compact representation of some data, as in some cases there’s a specialized opcode that consumes 1, 2, or 4 bytes, rather than using 4 bytes all the time. Registers that aren’t pushed into the stack might not appear in the table.</p><p>What I call the second level, is a special opcode that contains another set of opcodes, containing arbitrary expressions, that we need to evaluate. The main difference between these two levels is that while for the first level we just need a stack to remember and restore registers (<code>DW_CFA_remember_state</code> and <code>DW_CFA_restore_state</code>, respectively), for the second level we need to evaluate arbitrary Turing complete expressions. For this reason we need a full-blown VM to evaluate any expression.</p><p>Implementing a VM in BPF is not very practical, so we decided to take a pragmatic approach and start by <a href="https://github.com/parca-dev/parca-agent/pull/1058/commits/b7d873d7ce7cdd19edb52fad1659b8fd34b5fd34">hardcoding the 2 expressions</a> that happen more than 50% of the times in most binaries we&#39;ve evaluated. We have some ideas on how to further improve expression support, but this blog post is getting way too long already :).</p><h3>Walking the stack using DWARF’s CFI</h3><p>To use this approach to walk the stack for a given Program Counter (PC), we need to find its corresponding unwind information. But what do we mean by the unwind information, exactly?</p><p>We need to restore:</p><ul><li>The saved return address.</li><li>The values for the stack pointer (<code>$rsp</code>) and frame pointer (<code>$rbp</code>) registers in the previous frame, which are used to restore the previous frame’s stack pointer.</li></ul><p>The value of the stack pointer for the previous frame, just before our current function got called, in DWARF’s CFI terms, is called the Canonical Frame Address or CFA. As we saw before, in x86_64, the saved return address is always 8 bytes (a word) ahead of the CFA.</p><p>The unwinding algorithm looks something like this:</p><ol><li>Read the initial registers<ol><li>The instruction pointer <code>$rip</code>. Needed to find the row in the unwind table.</li><li>The stack pointer <code>$rsp</code>, and the frame pointer <code>$rbp</code>, which are needed to calculate the the previous frame&#39;s stack pointer value (CFA). We can find the return address and other registers pushed on the stack at an offset from CFA.</li></ol></li><li>While <code>unwind_frame_count &lt;= MAX_STACK_DEPTH</code>:<ol><li>Find the unwind table row for the PC for which <code>i</code> satisfies that <code>$unwind_table[i].PC &lt;= $target_PC &lt;= $unwind_table[i+1].PC</code>.<ol><li>If there&#39;s no entry for it <strong>and</strong> <code>$rbp</code> is zero, we have reached the bottom of the stack.</li></ol></li><li>Add instruction pointer to the stack.</li><li>Calculate the previous frame&#39;s stack pointer. This can be based on the current frame&#39;s <code>$rsp</code> or <code>$rbp</code>, if it&#39;s not an expression or register directly.</li><li>Updates the registers with the calculated values for the previous frame.</li><li>Continue with the next frame. Go to 2.</li></ol></li></ol><p><em>Note: for simplicity, we are omitting some important details that our unwinder implements.</em></p><p>To do this, we need to read the unwind opcodes, evaluate them, and generate the tables. This process can be quite expensive, but it’s how it’s done by the exception handling infrastructure in C++, among others. Because exceptions are supposed to be, erm, exceptional, these code paths should not be exercised often and the overhead won’t be too high.</p><p>This is also the case for debuggers, such as GDB, where users might want to know the stack trace here and there to understand where they are in the execution. These use cases are sometimes categorised under offline unwinding.</p><p>Profilers are a bit different in that they usually sample the stack dozens or hundreds of times a second. The overhead of having to read, parse, and evaluate the unwind information can be quite high. While stack unwinders might do some caching, the whole process is still quite expensive.</p><p>A key observation in our case is that we don’t need to restore every register, we only need these 2 and the saved return address. This insight allows us to produce a representation that works better for our online unwinding use case.</p><h2>Possible implementations</h2><p>The profiler we’ve developed isn’t by far the first one to use this technique. Perf, the venerable Linux profiler has supported DWARF-based stack unwinding for a while. By leveraging <code>PERF_SAMPLE_REGS_USER</code> and <code>PERF_SAMPLE_STACK_USER</code> introduced in the <code>perf_event_open</code> system call in Linux 3.4, it can receive the registers for the profiled processes as well as a copy of the stack for every sample.</p><p>While this approach has been proven to work, and we evaluated implementing our profiler similarly, it has a few drawbacks we wanted to avoid:</p><ul><li><strong>Performance</strong>: the kernel copies the user stack for every sample. It copies the <a href="https://github.com/torvalds/linux/blob/3d7cb6b0/kernel/events/core.c#L6582-L6629">user stack that’s currently in use</a>, but this can be quite a bit of data. Assuming a very conservative <code>1K per stack * 100 samples/second * 30% of the time running on CPU * 10 CPUs</code> = 300KB per second.</li><li><strong>Security</strong>: the implications of having another process having the values of another process’s stack can be complicated. What if some private key or any sort of Personally Identifiable Information (PII) is present there?</li></ul><p>While 300KB/s doesn’t seem like a lot of data, we believe that this number can be significantly higher for busy machines running CPU-intensive applications. We hope that by reducing the impact of the measurements while the profiler is running, fewer resources will be dedicated to the profiler that otherwise applications could use.</p><p>Another idea that popped into our heads was to perhaps copy the stack in a BPF program, but this would still have the disadvantages we wanted to avoid, and we would have to reimplement the functionality that the kernel already has and that it’s proved to work very well!</p><p>This brings us to the approach we eventually took, still leveraging BPF!</p><h3>Why BPF?</h3><p>We are big believers in BPF. There are many reasons for it. Broadly, it allows for the Linux kernel to be programmable with higher safety guarantees and a lower barrier of entry.</p><p>Developing profilers in BPF makes a lot of sense as once the stack walking mechanism is implemented, we can leverage the perf subsystem to get samples on CPU cycles, instructions, L3 cache misses, or any other performance counter that’s available in our machine. It also helps develop other tools, such as allocation tracers, off-CPU profilers, and many many others.</p><p>You might be wondering, why all this talking about stack unwinding in BPF? With the <code>bpf_get_stackid(ctx, &amp;map, BPF_F_USER_STACK)</code> helper we can fetch user stacks! Turns out, this helper walks the stack using frame pointers, and <a href="https://lkml.org/lkml/2012/2/10/129">a fully featured DWARF unwinder is unlikely to ever land in the kernel</a>.</p><h3>A BPF-friendly representation of the unwind table</h3><p>Most offline stack unwinders don’t process most of the DWARF CFI information as they target very few program counters. Profilers, on the other hand, might yield a higher cardinality of program counters. For this reason, and the fact that we only need a subset of the data to walk the stack, as we don’t require to know how to restore every single register, as well as to produce some representation that minimises the work that the BPF unwinder has to do, we decided to take on the unwind table generation cost upfront.</p><p>In userspace, we first parse, evaluate, and generate unwind tables. So far, we only support information stored in the <code>.eh_frame</code> ELF section. The generated table is a couple of arrays built up from this row type:</p><pre><pre><p><span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span><span></span></p><p><span>  u64 pc</span><span>;</span><span></span></p><p><span>  u16 _reserved_do_not_use</span><span>;</span><span></span></p><p><span>  u8 cfa_type</span><span>;</span><span></span></p><p><span>  u8 rbp_type</span><span>;</span><span></span></p><p><span>  s16 cfa_offset</span><span>;</span><span></span></p><p><span>  s16 rbp_offset</span><span>;</span><span></span></p><p><span></span><span>}</span><span> </span><span>stack_unwind_row_t</span><span>;</span></p></pre></pre><p>We use a whole word for the program counter and then have a couple of fields that help us to calculate CFA. For example, it can be at an offset from either the current <code>$rsp</code> or <code>$rbp</code>. We also find out how to restore <code>$rbp</code>.</p><p>Using the algorithm described above, we walk through the frames, by restoring the previous frame&#39;s registers. The table is sorted by program counter, to be able to binary search over the table in the BPF program.</p><p>We are done walking the stack iff we can’t find unwind information for a given PC and the current <code>$rbp</code> is zero. We then aggregate the stacks in a BPF map, in kernel space, to maximise efficiency, and we collect this data twice a minute from userspace, where we generate the profiles and send them to a Parca Server compatible server.</p><h2>The development</h2><p>Early on when we started this project we realised that there were many variables that could affect its success. To the best of our knowledge, there’s no other feature complete, open source, dwarf-based BPF unwinder, so we weren’t sure of how viable it would be. Hence, to maximise our chances of success, we tried to significantly reduce the problem space, while still giving us as much signal as possible.</p><p>At Polar Signals, we create a Request For Comments (RFC) for every large feature or topic we want to discuss or get feedback on. For this work, we started with a document laying out what we wanted to achieve for the first iteration, including goals and even more importantly, the non-goals.</p><p>After some weeks of work, we landed the <a href="https://github.com/parca-dev/parca-agent/pull/948">first version</a>, which focused on correctness. We continued with <a href="https://github.com/parca-dev/parca-agent/pull/978">follow-ups</a> to loosen the minimum kernel requirements (kernel ~4.10), as well as to make the unwind table rows more compact.</p><p>Building this in BPF was an interesting challenge. The kernel has to ensure that any loaded program can’t crash it. It statically analyses code using <a href="https://docs.kernel.org/bpf/verifier.html">the verifier</a>, which will either reject or accept a program. Some of the current rules as of the writing of this post are, no dynamic allocations, termination has to be provable, and many others, so we had to get creative to get the verifier to accept our program. This write-up is getting way too long so this would be a story for another time :)</p><h3>Testing</h3><p>For the unwinder to work, both the unwind table and the unwind algorithm implemented in BPF have to work well. Ensuring that the tables were correct was paramount in the development of this project.</p><p>In this case, we decided early on to use snapshot testing in a very simple form. We have some test binaries as well as the expected unwind table in <a href="https://github.com/parca-dev/testdata">a separate git repository</a>. As part of our testing suite in the Agent, we regenerate the tables and ensure that there aren’t any changes.</p><p>This technique allowed us to quickly iterate on the DWARF unwind information parser, helping us find a myriad of bugs, and saving us a lot of time we would have spent otherwise trying to understand why we failed at walking the stack.</p><h2>Future work</h2><p>There are lots of features and fixes we are working on, and we are excited to be sharing them with you very soon!</p><p>We’ve only released the first version that includes dwarf-based stack unwinding a <a href="https://github.com/parca-dev/parca-agent/releases/tag/v0.10.0">few days ago</a>. But we already have some more changes to ensure that the profiler runs well in memory constrained machines, <a href="https://github.com/parca-dev/parca-agent/issues/1052">improved architecture, enabling better support for JIT’ed code</a>, among others.</p><p>Near term, we are shifting our focus towards reliability, performance, and wider support. The parsing, evaluation, and handling of DWARF’s unwind information is not optimised yet. We also want to ensure that we have detailed performance metrics for our profiler. Finally, we want to do more exhaustive testing for tables produced by Clang and the Rust compiler toolchains.</p><p>The ultimate goal of this project is to enable this profiler by default to all of our users, without incurring a significantly higher resource usage.</p><h2>Give it a try!</h2><p>As mentioned above, this new feature is behind a feature flag, but we are going to enable it by default in the next version once we land some improvements we are working on. You can download the current release <a href="https://github.com/parca-dev/parca-agent/releases/tag/v0.10.0">here</a>.</p><pre><pre><p><span>$ ./parca-agent [...] --experimental-enable-dwarf-unwinding \</span></p><p><span>  --debug-process-names=&#34;(postgres|mysql|redpanda)&#34;</span></p></pre></pre><h2>Working with the community</h2><p>We believe that the pervasive lack of frame pointers is a big issue for the application developers, as well as developers of profilers, debuggers, and compilers.</p><p>Fortunately, this problem space is being actively worked on by many members of the wider engineering community, such as <a href="https://fedoraproject.org/wiki/Changes/fno-omit-frame-pointer">this proposal to enable frame pointers by default in Fedora</a>, or <a href="https://www.youtube.com/watch?v=XiH12D5ZN2A">the .ctf_frame work</a>, an alternative format to dwarf unwinding that’s specifically tailored to the online, asynchronous (meaning that can unwind any program counter, not just from specific parts) use-case that profilers and other tools need.</p><p>Open source and collaborating with other communities are a big part of our company ethos. That&#39;s why we started speaking about this project early on, starting with a <a href="https://youtu.be/Gr1rrSzvqfg">Linux Plumbers talk</a> last September, where we announced this work.</p><p><a href="https://github.com/parca-dev/parca-agent/tree/main/bpf/cpu">Our unwinder</a> is licensed under the GPL license. It&#39;s open for inspection and contributions, and we would love to work with other projects facing similar issues. Don’t hesitate to reach out! Let us know if there’s any feedback or features that you would like to see implemented, either in <a href="https://discord.com/invite/ZgUpYgpzXy">our Discord</a> or in the <a href="https://github.com/parca-dev/parca-agent/discussions/1055">GitHub discussion</a>.</p><h2>Acknowledgements</h2><p>This work wouldn’t have been possible without the work of many individuals. There’s a lot of infrastructure that had to be in place for this project to be possible at all.</p><ul><li>The Delve debugger for Go, which our DWARF unwind information parser is based on.</li><li>Ian Lance Taylor’s <a href="https://www.airs.com/blog/archives/460">blog series on <code>.eh_frame</code></a>.</li><li><a href="https://maskray.me/">MaskRay’s blog</a> is packed with interesting compilers and linkers content.</li><li>The engineers involved in both the DWARF standards and different ABIs. Coming up with something so flexible is not easy. The open and detailed specs are a great resource.</li><li>Compiler engineers are the unsung heroes of this work. Creating unwind tables isn’t easy. Maintaining them in sync across compiler passes is a herculean task.</li><li>Without BPF and its surrounding ecosystem we wouldn’t have a safe way to create programmable system-wide profilers. While sometimes the verifier can be tough, it’s our best ally.</li><li>The <a href="https://dl.acm.org/doi/10.1145/3360572">Reliable and fast DWARF-based stack unwinding paper</a> provides a superb description of all the systems we described in this post, as well as trying some different non-BPF approaches to speed up dwarf-based unwinders, and some of the correctness testing they carried that found several bugs. We owe them not just increasing the quality of unwinding tables that many systems, including ours, depend on, but also helped raises awareness of all these systems and how critical they are.</li></ul><h2>Notes and ramblings</h2><ol><li>While the term &#34;stack walking&#34; is more correct in the context of profilers, and &#34;stack unwinding&#34; is typically used when the runtime is handling exceptions, we use these two terms interchangeably.</li><li>Our table format uses the smallest datatypes we could use, which set some limits on the minimum and maximum value for offsets, among others. You can check them out in <a href="https://github.com/parca-dev/parca-agent/blob/c28f6482924e760faaa844973d690defd74bba4c/docs/native-stack-walking/design.md">this design document</a>, which also includes some of the requirements for this unwinder. We are already working on removing some of the mentioned limitations!</li><li>A very interesting idea from the &#34;Reliable and fast DWARF-based stack unwinding&#34; paper is to synthesise unwind tables from object code when unwind tables are not present or complete for some reason. This is something we might entertain in the future.</li><li>To add some insights into the complexity implications, just in terms of code size, the previous frame pointer-based unwinder could be re-implemented in BPF in less than 50 lines, while this dwarf-based one is more than 500 lines. This excludes all the necessary supporting code in userspace and tests.</li><li>Last but not least don&#39;t take this work as an apologia for frame pointer removal! If we could change something technical and low-level in the computing industry, it would probably be enabling frame pointers by default. This is something that hyperscalers, such as Facebook and Google already do, despite the potential extra compute costs, as they save them headaches and time when every minute of troubleshooting an incident is costing lots of money. That being said, we understand that even if everybody would agree to enable frame pointers, it would take years until all of our users would reap the benefits.</li></ol><p><strong>Side note</strong>: the C++ exception machinery is quite complex and has to do quite a bit of work as described in this write-up. Some interesting things to think about: what would be the cost when the unwind tables are in memory vs when they are not? Could this be a problem with your application? How are these paths exercised?</p></article></div>
  </body>
</html>
