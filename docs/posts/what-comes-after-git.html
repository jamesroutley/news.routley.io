<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matt-rickard.com/what-comes-after-git/">Original</a>
    <h1>What comes after Git</h1>
    
    <div id="readability-page-1" class="page"><div><p>Git was born from the collaboration problems in the Linux kernel. Nearly a decade later, new problems arose when Kubernetes (the operating system of the cloud) brought open-source collaboration to a new level.</p><p>I saw the pain points of git (and GitHub) firsthand working on Kubernetes open-source. Will a new version control system (or something that solves similar problems) spring up?</p><p>Some ideas on what a new version control system would look like.</p><ul><li><strong>Atomicity across projects</strong> –  GitHub is a <em>de facto</em> monorepo and is used as such. Splitting code with dependencies can result in complex syncing and CI pipelines. Submodules aren&#39;t an adequate solution.</li><li><strong>Native package management</strong> – Packages are tightly coupled with code (see <a href="https://matt-rickard.com/githubs-missing-package-manager/">GitHub&#39;s Missing Package Manager</a>). Git&#39;s content-addressable storage tells us that we are using the right set of files for a revision. We should also have the same guarantee when consuming source code through package managers. Better yet, maybe we can build generic primitives toward <a href="https://matt-rickard.com/a-universal-package-manager/">a universal package manager</a>.</li><li><strong>Semantic diff</strong> – Can we figure out how to use version control to have more context-aware merges? Can you believe that we still rely on a <a href="https://matt-rickard.com/diff-the-magic-behind-version-control/">text diffing algorithm</a> from 1976 (and <a href="https://matt-rickard.com/diff3-shortcomings/">its shortcomings</a>)? Git still has trouble with file renaming. <a href="https://twitter.com/mattrickard/status/1413512528714338307">GitHub Copilot, but for merge conflicts</a>? Semantic diff has been tried before, but language-specific implementations will likely never work.</li><li><strong>Merge Queue Data Structure</strong> – Two pull requests simultaneously pass all tests but fail when merged together. While more of a workflow feature rather than a version control one, it&#39;s core enough to the idea of tracking history (i.e., building the commit graph) that a strong case could be made for making it a first-class citizen.</li><li><strong>Fan-out pull requests – </strong>The idea that library owners could write a patch for their software and distribute it to all downstream users. While downstream users wouldn&#39;t be obligated to update, it could take a lot of the work out of N different consumers figuring out how to upgrade. Think dependabot, but with all types of updates (minor, security, and breaking). Most useful inside companies, but an analog might make sense in open source.</li><li><strong><a href="https://matt-rickard.com/the-terrible-ux-of-git/">Terrible UX of Git</a></strong> – overloaded and inconsistent commands, and more. I believe that the underlying problem is the divergence of the workflow from the tool. Either <code>git</code> should be fully decoupled from the pull request and merge workflow or integrated into what&#39;s now become &#34;git flow&#34;.</li><li><strong>Large file storage</strong> – there are extensions like <code>git lfs</code> that provide some support for larger files but aren&#39;t great. It feels like fitting a square peg into a round hole. Most workflows don&#39;t seem to need large asset support – only game development and other niches. But, I imagine if we solved it in an ergonomic way, we&#39;d open up new workflows we never thought to do – like storing binary assets or database snapshots alongside code. Why not version everything if it&#39;s easy and cheap?</li><li><strong>Project Management Hooks, but not Features – </strong>Should issues and bug tracking be built into the version control system? That&#39;s the philosophy behind <a href="https://www2.fossil-scm.org/home/doc/trunk/www/index.wiki">fossil</a>. Project management is so amorphous and fleeting that I don&#39;t believe it should be built into foundational tech. Yet, a new VCS should expose the hooks and APIs that allow the flavor-of-the-moment project management tool to be built on top.</li></ul></div></div>
  </body>
</html>
