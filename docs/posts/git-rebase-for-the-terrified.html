<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.brethorsting.com/blog/2026/01/git-rebase-for-the-terrified/">Original</a>
    <h1>Git Rebase for the Terrified</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p><a href="https://news.ycombinator.com/item?id=46530920">Join the conversation on Hacker News</a>.</p>

<p>As a maintainer of several OneBusAway projects, I regularly ask contributors to rebase their branches before merging. The response is often hesitation or outright fear. I get it. Rebase has a reputation for destroying work, and the warnings you see online don’t help.</p>

<p>Here’s the thing: the worst case scenario for a rebase gone wrong is that you delete your local clone and start over. That’s it. Your remote fork still exists. The main repository still exists. You can always recover. With that fear addressed, let me show you how to rebase.</p>

<h2 id="why-maintainers-ask-for-rebases">Why maintainers ask for rebases</h2>

<p>When you create a branch from main and work on it for a few days, the main branch keeps moving. Other PRs get merged. By the time your PR is ready, your branch’s history diverges from main. A merge commit can combine them, but it creates a messy history with interleaved commits that make it harder to understand what changed and why.</p>

<p>Rebasing replays your commits on top of the current main branch, as if you’d just created your branch today. The result is a clean, linear history that’s easier to review and bisect when tracking down bugs.</p>

<h2 id="the-actual-commands">The actual commands</h2>

<p>First, make sure you have the upstream repository configured as a remote. If you forked a repo and cloned your fork, you probably only have <code>origin</code> pointing to your fork:</p>



<p>If you don’t see the main repository listed, add it:</p>

<div><div><pre><code>git remote add upstream https://github.com/OneBusAway/onebusaway-ios.git
</code></pre></div></div>

<p>Now fetch the latest changes from upstream:</p>



<p>Make sure you’re on your feature branch:</p>

<div><div><pre><code>git checkout your-branch-name
</code></pre></div></div>

<p>Before rebasing, push your current work to your remote fork. This gives you a backup you can recover from if anything goes wrong:</p>

<div><div><pre><code>git push origin your-branch-name
</code></pre></div></div>

<p>Now rebase onto upstream’s main branch:</p>



<p>If there are no conflicts, you’re done with the rebase. If there are conflicts, Git will stop and tell you which files need attention.</p>

<h3 id="understanding-conflict-markers">Understanding conflict markers</h3>

<p>When you open a conflicted file, you’ll see something like this:</p>

<div><div><pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
const timeout = 5000;
=======
const timeout = 10000;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; upstream/main
</code></pre></div></div>

<p>This is confusing until you know what each section means:</p>

<ul>
  <li>Everything between <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> and <code>=======</code> is <strong>your code</strong> from the commit being replayed</li>
  <li>Everything between <code>=======</code> and <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; upstream/main</code> is <strong>the code from main</strong> that conflicts with yours</li>
</ul>

<p>Your job is to decide what the final code should look like. Sometimes you want your version, sometimes theirs, sometimes a combination. Delete the markers and leave only the code you want to keep.</p>

<p>I always use VS Code for this step. Its merge conflict UI is the clearest I’ve found: it shows “Accept Current Change,” “Accept Incoming Change,” “Accept Both Changes,” and “Compare Changes” buttons right above each conflict. You can click through conflicts one at a time without manually hunting for markers.</p>

<h3 id="when-conflicts-get-tricky">When conflicts get tricky</h3>

<p>Some conflicts are straightforward: two people changed the same line differently. Pick one or combine them.</p>

<p>Others are harder. If you’re rebasing multiple commits and the same file conflicts repeatedly, it usually means your changes build on each other in ways that don’t cleanly apply to the new base. A few strategies:</p>

<ol>
  <li>
    <p><strong>Squash first, then rebase.</strong> If you have many small commits, combine them into one or two logical commits before rebasing. Fewer commits means fewer opportunities for conflicts.</p>
  </li>
  <li>
    <p><strong>Abort and try a different approach.</strong> If the conflicts are overwhelming, <code>git rebase --abort</code> and consider whether your branch has diverged too far. Sometimes it’s easier to create a new branch from main and manually re-apply your changes.</p>
  </li>
  <li>
    <p><strong>Use <code>git rerere</code>.</strong> If you find yourself resolving the same conflicts repeatedly, enable rerere (reuse recorded resolution) with <code>git config --global rerere.enabled true</code>. Git will remember how you resolved conflicts and apply the same resolution automatically next time.</p>
  </li>
</ol>

<p>After resolving each file’s conflicts:</p>

<div><div><pre><code>git add path/to/resolved/file
git rebase <span>--continue</span>
</code></pre></div></div>

<p>Repeat until the rebase completes. If things go sideways and you want to abort:</p>



<p>This returns your branch to exactly where it was before you started.</p>

<h2 id="validating-your-changes">Validating your changes</h2>

<p>After rebasing, verify that your changes still work:</p>

<div><div><pre><code>git log <span>--oneline</span> upstream/main..HEAD
</code></pre></div></div>

<p>This shows only your commits that are ahead of main. Make sure they look right. Then build the project and run the tests. Rebasing can sometimes cause subtle issues if upstream changes conflict with your work in ways the merge didn’t catch.</p>

<h2 id="force-pushing">Force pushing</h2>

<p>Here’s where people get nervous. After rebasing, your local branch has diverged from your remote branch. A normal <code>git push</code> will fail. You need to force push:</p>

<div><div><pre><code>git push <span>--force-with-lease</span> origin your-branch-name
</code></pre></div></div>

<p>The <code>--force-with-lease</code> flag is safer than <code>--force</code> because it will fail if someone else has pushed to your branch since you last fetched. This prevents you from accidentally overwriting someone else’s work.</p>

<p>Never force push to main or any shared branch. Only force push to your own feature branches.</p>

<h2 id="when-it-all-goes-wrong">When it all goes wrong</h2>

<p>If you’ve made a mess of things and can’t figure out how to recover, here’s the nuclear option:</p>

<ol>
  <li>Push any work you want to save to your remote fork (even to a temporary branch)</li>
  <li>Delete your local clone</li>
  <li>Clone fresh from your fork</li>
  <li>Add the upstream remote again</li>
  <li>Start the rebase process over</li>
</ol>

<p>This has never failed me. Your commits exist on GitHub until you explicitly delete them. You can always recover.</p>

<h2 id="one-more-thing">One more thing</h2>

<p>Rebasing rewrites commit history. This is fine for feature branches that only you are working on. It’s not fine for branches that others have based work on. If you’re collaborating with someone on a branch, coordinate before rebasing, or just use merge commits instead.</p>

<p>That’s it. Rebase isn’t scary once you understand that you can always recover. The worst case is a few minutes of recloning. The benefit is a clean project history that’s easier to understand and maintain.</p>

</div></div>
  </body>
</html>
