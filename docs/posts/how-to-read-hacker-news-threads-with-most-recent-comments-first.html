<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://til.simonwillison.net/hacker-news/recent-comments">Original</a>
    <h1>How to read Hacker News threads with most recent comments first</h1>
    
    <div id="readability-page-1" class="page"><section>



<p><a href="https://news.ycombinator.com/" rel="nofollow">Hacker News</a> displays comments in a tree. This can be frustrating if you want to keep track of a particular conversation, as you constantly have to seek through the tree to find the latest comment.</p>
<p>I solved this problem in three different ways today. I&#39;ll detail them in increasing orders of complexity (which frustratingly is the reverse order to how I figured them out!)</p>
<h2><a id="user-content-the-easiest-way-algolia-search" aria-hidden="true" href="#the-easiest-way-algolia-search"><span aria-hidden="true"></span></a>The easiest way: Algolia search</h2>
<p>The official Hacker News search uses Algolia, with a constantly updated index.</p>
<p>If you search for <code>story:35111646</code>, filter for comments and then order by date you&#39;ll get the comments for that particular story, most recent at the top. Problem solved!</p>
<p>Here&#39;s the URL - edit the story ID in that URL (or on the page) to view comments for a different story.</p>
<p><a href="https://hn.algolia.com/?dateRange=all&amp;page=0&amp;prefix=false&amp;query=story:35111646&amp;sort=byDate&amp;type=comment" rel="nofollow">https://hn.algolia.com/?dateRange=all&amp;page=0&amp;prefix=false&amp;query=story:35111646&amp;sort=byDate&amp;type=comment</a></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/9599/224572085-d1e57f95-427c-4c62-9a2e-d2e8c4ab8f90.png"><img width="1168" alt="Screenshot of those search results" src="https://user-images.githubusercontent.com/9599/224572085-d1e57f95-427c-4c62-9a2e-d2e8c4ab8f90.png"/></a></p>
<h2><a id="user-content-the-algolia-search_by_date-api" aria-hidden="true" href="#the-algolia-search_by_date-api"><span aria-hidden="true"></span></a>The Algolia search_by_date API</h2>
<p>The Algolia Hacker News API is documented here: <a href="https://hn.algolia.com/api" rel="nofollow">https://hn.algolia.com/api</a></p>
<p>Note that this is a separate system from the official Hacker News API, which is powered by Firebase, doesn&#39;t provide any search or filtering endpoints and is documented at <a href="https://github.com/HackerNews/API">https://github.com/HackerNews/API</a></p>
<p>To retrieve all comments on a specific story ordered by date, most recent first as JSON you can hit this endpoint:</p>
<p><a href="https://hn.algolia.com/api/v1/search_by_date?tags=comment,story_35111646&amp;hitsPerPage=1000" rel="nofollow">https://hn.algolia.com/api/v1/search_by_date?tags=comment,story_35111646&amp;hitsPerPage=1000</a></p>
<p>The <code>tags=</code> parameter does all of the work here - we&#39;re asking it for items of type <code>comment</code> that have been tagged with <code>story_35111646</code>.</p>
<p>This returns 20 results by default. I&#39;ve added <code>&amp;hitsPerPage=1000</code> to get back the maximum of 1,000.</p>
<p>This gives you back JSON, but how can we turn that into something that&#39;s more readable in our browser?</p>
<h2><a id="user-content-loading-that-into-datasette-lite" aria-hidden="true" href="#loading-that-into-datasette-lite"><span aria-hidden="true"></span></a>Loading that into Datasette Lite</h2>
<p>I&#39;m going to use <a href="https://lite.datasette.io/" rel="nofollow">Datasette Lite</a>, my build of Datasette running directly in the browser using Python compiled to WebAssembly. More on <a href="https://simonwillison.net/2022/May/4/datasette-lite/" rel="nofollow">how that works here</a>.</p>
<p>This is possible because the Algolia API returns JSON with a <code>access-control-allow-origin: *</code> CORS header, allowing that data to be loaded by other web applications running on different domains.</p>
<p>If you pass Datasette Lite a <code>?json=</code> parameter with the URL to a JSON file that returns a list of objects, it will use <a href="https://sqlite-utils.datasette.io/" rel="nofollow">sqlite-utils</a> to load that JSON into a SQLite table with a column for each of the keys in those objects.</p>
<p>This URL loads that data:</p>
<p><a href="https://lite.datasette.io/?json=https://hn.algolia.com/api/v1/search_by_date?tags=comment%2Cstory_35111646" rel="nofollow">https://lite.datasette.io/?json=https://hn.algolia.com/api/v1/search_by_date?tags=comment%2Cstory_35111646</a></p>
<p>We can navigate to the <code>search_by_date</code> table to browse and filter the comments.</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/9599/224572148-0088593f-45a0-4456-83c8-5294d391ce87.png"><img width="1168" alt="The search_by_date table in Datasette Lite" src="https://user-images.githubusercontent.com/9599/224572148-0088593f-45a0-4456-83c8-5294d391ce87.png"/></a></p>
<p>Let&#39;s make some improvements to how it&#39;s displayed using a custom SQL query and some Datasette plugins.</p>
<p>Datasette Lite supports some Datasette plugins - you can add <code>?install=name-of-plugin</code> to the URL to install them directly from PyPI.</p>
<p>I&#39;m going to load two plugins:</p>
<ul>
<li>
<a href="https://datasette.io/plugins/datasette-simple-html" rel="nofollow">datasette-simple-html</a> adds SQL functions for escaping and unescaping HTML text and stripping tags</li>
<li>
<a href="https://datasette.io/plugins/datasette-json-html" rel="nofollow">datasette-json-html</a> provides a mechanism for outputting custom links in column results</li>
</ul>
<p>Here&#39;s a URL that loads those two plugins:</p>
<p><a href="https://lite.datasette.io/?install=datasette-simple-html&amp;install=datasette-json-html&amp;json=https://hn.algolia.com/api/v1/search_by_date?tags=comment%2Cstory_35111646%26hitsPerPage=1000" rel="nofollow">https://lite.datasette.io/?install=datasette-simple-html&amp;install=datasette-json-html&amp;json=https://hn.algolia.com/api/v1/search_by_date?tags=comment%2Cstory_35111646%26hitsPerPage=1000</a></p>
<p>Now here&#39;s a custom SQL query that makes the comments a bit nicer to read when they are displayed by Datasette:</p>
<div><pre><span>select</span>
  created_at,
  author,
  html_unescape(
    html_strip_tags(comment_text)
  ) <span>as</span> <span>text</span>,
  parent_id,
  _tags
<span>from</span>
  search_by_date
<span>order by</span>
  created_at <span>desc</span></pre></div>
<p><a href="https://lite.datasette.io/?install=datasette-simple-html&amp;install=datasette-json-html&amp;json=https://hn.algolia.com/api/v1/search_by_date?tags=comment%2Cstory_35111646%26hitsPerPage=100#/data?sql=select%0A++created_at%2C%0A++author%2C%0A++html_unescape%28%0A++++html_strip_tags%28comment_text%29%0A++%29+as+text%2C%0A++parent_id%2C%0A++_tags%0Afrom%0A++search_by_date%0Aorder+by%0A++created_at+desc" rel="nofollow">This link</a> will execute that SQL query against the data in Datasette Lite.</p>
<p>One last trick: it would be neat if we could click through from the results to the comment on Hacker News. Here&#39;s how to add that, using a trick enabled by <code>datasette-json-html</code>:</p>
<div><pre><span>select</span>
  json_object(
    <span><span>&#39;</span>label<span>&#39;</span></span>, objectID,
    <span><span>&#39;</span>href<span>&#39;</span></span>, <span><span>&#39;</span>https://news.ycombinator.com/item?id=<span>&#39;</span></span> <span>||</span> objectID
  ) <span>as</span> link,
  created_at,
  author,
  html_unescape(
    html_strip_tags(comment_text)
  ) <span>as</span> <span>text</span>,
  parent_id,
  _tags
<span>from</span>
  search_by_date
<span>order by</span>
  created_at <span>desc</span></pre></div>
<p><a href="https://lite.datasette.io/?install=datasette-simple-html&amp;install=datasette-json-html&amp;json=https://hn.algolia.com/api/v1/search_by_date?tags=comment%2Cstory_35111646%26hitsPerPage=100#/data?sql=select%0A++json_object%28%0A++++%27label%27%2C+objectID%2C%0A++++%27href%27%2C+%27https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D%27+%7C%7C+objectID%0A++%29+as+link%2C%0A++created_at%2C%0A++author%2C%0A++html_unescape%28%0A++++html_strip_tags%28comment_text%29%0A++%29+as+text%2C%0A++parent_id%2C%0A++_tags%0Afrom%0A++search_by_date%0Aorder+by%0A++created_at+desc" rel="nofollow">See the results of that here</a>.</p>
<p>This adds link to each comment as the first column in the table.</p>
<p>It works by building a JSON string <code>{&#34;label&#34;: &#34;35123521&#34;, &#34;href&#34;: &#34;https://news.ycombinator.com/item?id=35123521&#34;}</code> - the plugin then renders that as a link when the table is displayed, using Datasette&#39;s <a href="https://docs.datasette.io/en/stable/plugin_hooks.html#render-cell-row-value-column-table-database-datasette" rel="nofollow">render_cell()</a> plugin hook.</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/9599/224572235-34986893-eafe-4e4b-9281-4abadee1b4f2.png"><img width="1159" alt="SQL query results with a link in the first column" src="https://user-images.githubusercontent.com/9599/224572235-34986893-eafe-4e4b-9281-4abadee1b4f2.png"/></a></p>
<h2><a id="user-content-the-most-complicated-solution-with-json_tree" aria-hidden="true" href="#the-most-complicated-solution-with-json_tree"><span aria-hidden="true"></span></a>The most complicated solution, with json_tree()</h2>
<p>My first attempt at solving this was by far the most complex.</p>
<p>Before I explored the <code>search_by_date</code> API I spotted that Algolia offers a <code>items</code> API, which returns ALL of the content for a thread in a giant nested JSON object:</p>
<p><a href="https://hn.algolia.com/api/v1/items/35111646" rel="nofollow">https://hn.algolia.com/api/v1/items/35111646</a></p>
<p>Try that now and you&#39;ll see that the top level object has this shape <code>{&#34;id&#34;: ..., &#34;children&#34;: [...]}</code> - with that `&#34;children&#34; array containing a further nested array of objects representing the whole thread.</p>
<p>Datasette Lite&#39;s <code>?json=</code> parameter expects an array of objects. But... if you give it a top-level object which has a key that is itself an array of objects, it will load the objects from that array instead.</p>
<p>Which means passing it the above URL results in a table with a row for each of the top-level comments on that item... plus a <code>children</code> column with the JSON string of each of their descendents.</p>
<p>You can try that here:</p>
<p><a href="https://lite.datasette.io/?json=https://hn.algolia.com/api/v1/items/35111646" rel="nofollow">https://lite.datasette.io/?json=https://hn.algolia.com/api/v1/items/35111646</a></p>
<p>SQLite has a <a href="https://www.sqlite.org/json1.html" rel="nofollow">robust suite of JSON functions</a>, plus the ability to execute recursive CTEs - surely it would be possible to write a query that flattens that nested structure into a table with a row for each comment?</p>
<p>I spent quite a bit of time on this. Eventually I realized that you don&#39;t even need a recursive CTE for this - you can use the <code>json_tree()</code> function provided by SQLite instead.</p>
<p>Here&#39;s the query I came up with:</p>
<div><pre>with items <span>as</span> (<span>select</span> <span>*</span> <span>from</span> [<span>35111646</span>]),
results <span>as</span> (
<span>select</span>
  json_extract(value, <span><span>&#39;</span>$.id<span>&#39;</span></span>) <span>as</span> id,
  json_extract(value, <span><span>&#39;</span>$.created_at<span>&#39;</span></span>) <span>as</span> created_at,
  json_extract(value, <span><span>&#39;</span>$.author<span>&#39;</span></span>) <span>as</span> author,
  html_strip_tags(html_unescape(json_extract(value, <span><span>&#39;</span>$.text<span>&#39;</span></span>))) <span>as</span> <span>text</span>,
  json_extract(value, <span><span>&#39;</span>$.parent_id<span>&#39;</span></span>) <span>as</span> parent_id
<span>from</span>
  items, json_tree(<span>items</span>.<span>children</span>) tree
<span>where</span>
  <span>tree</span>.<span>type</span> <span>=</span> <span><span>&#39;</span>object<span>&#39;</span></span>
<span>union all</span>
<span>select</span> id, created_at, author, html_strip_tags(html_unescape(<span>text</span>)) <span>as</span> <span>text</span>, parent_id
<span>from</span> items
)
<span>select</span>
  json_object(<span><span>&#39;</span>label<span>&#39;</span></span>, id, <span><span>&#39;</span>href<span>&#39;</span></span>, <span><span>&#39;</span>https://news.ycombinator.com/item?id=<span>&#39;</span></span> <span>||</span> id) <span>as</span> link,
  <span>*</span>
<span>from</span> results <span>order by</span> created_at <span>desc</span></pre></div>
<p><a href="https://lite.datasette.io/?install=datasette-simple-html&amp;install=datasette-json-html&amp;json=https://hn.algolia.com/api/v1/items/35111646#/data?sql=with+items+as+%28select+*+from+%5B35111646%5D%29%2C%0Aresults+as+%28%0Aselect%0A++json_extract%28value%2C+%27%24.id%27%29+as+id%2C%0A++json_extract%28value%2C+%27%24.created_at%27%29+as+created_at%2C%0A++json_extract%28value%2C+%27%24.author%27%29+as+author%2C%0A++html_strip_tags%28html_unescape%28json_extract%28value%2C+%27%24.text%27%29%29%29+as+text%2C%0A++json_extract%28value%2C+%27%24.parent_id%27%29+as+parent_id%0Afrom%0A++items%2C+json_tree%28items.children%29+tree%0Awhere%0A++tree.type+%3D+%27object%27%0Aunion+all%0Aselect+id%2C+created_at%2C+author%2C+html_strip_tags%28html_unescape%28text%29%29+as+text%2C+parent_id%0Afrom+items%0A%29%0Aselect%0A++json_object%28%27label%27%2C+id%2C+%27href%27%2C+%27https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D%27+%7C%7C+id%29+as+link%2C%0A++*%0Afrom+results+order+by+created_at+desc" rel="nofollow">Try that out here</a>.</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://user-images.githubusercontent.com/9599/224572313-6416fe2f-5260-4271-9f2b-fe9cb1724006.png"><img width="1159" alt="That SQL query in Datasette Lite, returning a table of recent comments" src="https://user-images.githubusercontent.com/9599/224572313-6416fe2f-5260-4271-9f2b-fe9cb1724006.png"/></a></p>
<p>The key to understanding the above is to understand how <code>json_tree()</code> works. Given a JSON value it returns a huge virtual table representing every node in that tree as a flat list.</p>
<p>Here&#39;s a simple example:</p>
<div><pre><span>select</span> <span>*</span> <span>from</span> json_tree(<span><span>&#39;</span>[</span>
<span>  {</span>
<span>    &#34;id&#34;: 1,</span>
<span>    &#34;name&#34;: &#34;A&#34;,</span>
<span>    &#34;children&#34;: [</span>
<span>      {</span>
<span>        &#34;id&#34;: 2,</span>
<span>        &#34;name&#34;: &#34;B&#34;</span>
<span>      }</span>
<span>    ]</span>
<span>  },</span>
<span>  {</span>
<span>    &#34;id&#34;: 3,</span>
<span>    &#34;name&#34;: &#34;C&#34;</span>
<span>  }</span>
<span>]<span>&#39;</span></span>)</pre></div>
<p><a href="https://latest.datasette.io/_memory?sql=select+*+from+json_tree(%27%5B%0D%0A++%7B%0D%0A++++%22id%22%3A+1%2C%0D%0A++++%22name%22%3A+%22A%22%2C%0D%0A++++%22children%22%3A+%5B%0D%0A++++++%7B%0D%0A++++++++%22id%22%3A+2%2C%0D%0A++++++++%22name%22%3A+%22B%22%0D%0A++++++%7D%0D%0A++++%5D%0D%0A++%7D%2C%0D%0A++%7B%0D%0A++++%22id%22%3A+3%2C%0D%0A++++%22name%22%3A+%22C%22%0D%0A++%7D%0D%0A%5D%27)" rel="nofollow">Try that against Datasette</a>. The output looks like this:</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
<th>type</th>
<th>atom</th>
<th>id</th>
<th>parent</th>
<th>fullkey</th>
<th>path</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>[{&#34;id&#34;:1,&#34;name&#34;:&#34;A&#34;,&#34;children&#34;:[{&#34;id&#34;:2,&#34;name&#34;:&#34;B&#34;}]},{&#34;id&#34;:3,&#34;name&#34;:&#34;C&#34;}]</td>
<td>array</td>
<td></td>
<td>0</td>
<td></td>
<td>$</td>
<td>$</td>
</tr>
<tr>
<td>0</td>
<td>{&#34;id&#34;:1,&#34;name&#34;:&#34;A&#34;,&#34;children&#34;:[{&#34;id&#34;:2,&#34;name&#34;:&#34;B&#34;}]}</td>
<td>object</td>
<td></td>
<td>1</td>
<td>0</td>
<td>$[0]</td>
<td>$</td>
</tr>
<tr>
<td>id</td>
<td>1</td>
<td>integer</td>
<td>1</td>
<td>3</td>
<td>1</td>
<td>$[0].id</td>
<td>$[0]</td>
</tr>
<tr>
<td>name</td>
<td>A</td>
<td>text</td>
<td>A</td>
<td>5</td>
<td>1</td>
<td>$[0].name</td>
<td>$[0]</td>
</tr>
<tr>
<td>children</td>
<td>[{&#34;id&#34;:2,&#34;name&#34;:&#34;B&#34;}]</td>
<td>array</td>
<td></td>
<td>7</td>
<td>1</td>
<td>$[0].children</td>
<td>$[0]</td>
</tr>
<tr>
<td>0</td>
<td>{&#34;id&#34;:2,&#34;name&#34;:&#34;B&#34;}</td>
<td>object</td>
<td></td>
<td>8</td>
<td>7</td>
<td>$[0].children[0]</td>
<td>$[0].children</td>
</tr>
<tr>
<td>id</td>
<td>2</td>
<td>integer</td>
<td>2</td>
<td>10</td>
<td>8</td>
<td>$[0].children[0].id</td>
<td>$[0].children[0]</td>
</tr>
<tr>
<td>name</td>
<td>B</td>
<td>text</td>
<td>B</td>
<td>12</td>
<td>8</td>
<td>$[0].children[0].name</td>
<td>$[0].children[0]</td>
</tr>
<tr>
<td>1</td>
<td>{&#34;id&#34;:3,&#34;name&#34;:&#34;C&#34;}</td>
<td>object</td>
<td></td>
<td>13</td>
<td>0</td>
<td>$[1]</td>
<td>$</td>
</tr>
<tr>
<td>id</td>
<td>3</td>
<td>integer</td>
<td>3</td>
<td>15</td>
<td>13</td>
<td>$[1].id</td>
<td>$[1]</td>
</tr>
<tr>
<td>name</td>
<td>C</td>
<td>text</td>
<td>C</td>
<td>17</td>
<td>13</td>
<td>$[1].name</td>
<td>$[1]</td>
</tr>
</tbody>
</table>
<p>This is pretty useful! The complex nested object has been flattened for us. Most of these rows aren&#39;t relevant... but if we filter for <code>type = &#39;object&#39;</code> we can get hold of just the nested items within that structure that are complete JSON objects.</p>
<p>So that&#39;s what my bigger query does. I call <code>json_tree()</code> on the <code>children</code> column for each of those top level objects, then filter for <code>object</code> within that to get out the nested comments.</p>
<p>Then at the end I do a <code>union all</code> against the top level rows, to ensure they are included in the resulting table.</p>
<p>I was really happy with this query! And then I read a bit more of the Algolia API documentation and realized that it was entirely unneccessary for solving this problem. But I did at least get to learn how to use <code>json_tree()</code>.</p>
<h2><a id="user-content-my-original-solution-hacker-news-to-sqlite" aria-hidden="true" href="#my-original-solution-hacker-news-to-sqlite"><span aria-hidden="true"></span></a>My original solution: hacker-news-to-sqlite</h2>
<p>Prior to today I&#39;ve solved this problem using my <a href="https://datasette.io/tools/hacker-news-to-sqlite" rel="nofollow">hacker-news-to-sqlite</a> CLI tool instead.</p>
<p>This can suck all of the comments for a thread into a SQLite database, so you can sort them chronologically using <a href="https://datasette.io" rel="nofollow">Datasette</a>.</p>
<p>To run that command:</p>
<pre><code>pipx install hacker-news-to-sqlite
hacker-news-to-sqlite trees comments.db 35111646
</code></pre>
<p>Then open it in Datasette (or <a href="https://datasette.io/desktop" rel="nofollow">Datasette Desktop</a>):</p>
<pre><code>datasette comments.db
</code></pre>
<p><code>hacker-news-to-sqlite</code> uses the original Hacker News API, which means it has to fetch each comment in turn and then fetch any child comments as separate requests - so it takes a while to run!</p>
<p>I&#39;m going to stick with the Algolia solution in the future.</p>




  <h3>Related</h3>
  


<p>Created 2023-03-12T13:41:22-07:00, updated 2023-03-12T14:40:11-07:00 · <a href="https://github.com/simonw/til/commits/main/hacker-news/recent-comments.md">History</a> · <a href="https://github.com/simonw/til/blob/main/hacker-news/recent-comments.md">Edit</a></p>

</section></div>
  </body>
</html>
