<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://interjectedfuture.com/three-ways-i-learn-with-ai/">Original</a>
    <h1>Three ways I learn with AI</h1>
    
    <div id="readability-page-1" class="page"><div>

    <article>

        <header>

                <a href="https://interjectedfuture.com/tag/essays/">Essays</a>
            
                <p>&#34;You don’t `learn` from a chatbot. You consume...They’re spewing slop and people are gobbling it up.&#34;

No. You’re holding it wrong. You can definitely learn from LLMs. It has to be with critical thinking.</p>

            <div>
                <p><a href="https://lwn.net/author/wil/">
                                <img src="https://www.gravatar.com/avatar/915aac3dfde2fb502ce415d77643a72d?s=250&amp;d=mm&amp;r=x" alt="Wil Chung"/>
                            </a>
                </p>
                <div>
                    
                    <p><time datetime="2025-09-25">25 Sep 2025</time>
                            <span><span>—</span> 8 min read</span>
                    </p>
                </div>
            </div>

                <figure>
        <img srcset="/content/images/size/w320/2025/09/ChatGPT-Image-Sep-23--2025--08_47_04-AM.jpg 320w,
                    /content/images/size/w600/2025/09/ChatGPT-Image-Sep-23--2025--08_47_04-AM.jpg 600w,
                    /content/images/size/w960/2025/09/ChatGPT-Image-Sep-23--2025--08_47_04-AM.jpg 960w,
                    /content/images/size/w1200/2025/09/ChatGPT-Image-Sep-23--2025--08_47_04-AM.jpg 1200w,
                    /content/images/size/w2000/2025/09/ChatGPT-Image-Sep-23--2025--08_47_04-AM.jpg 2000w" sizes="(max-width: 1200px) 100vw, 1120px" src="https://lwn.net/content/images/size/w1200/2025/09/ChatGPT-Image-Sep-23--2025--08_47_04-AM.jpg" alt="Three ways I learn with AI"/>
    </figure>

        </header>

        <section>
            <blockquote>You don’t “learn” from a chatbot. You consume. There’s a difference. They’re spewing slop and people are gobbling it up (and eroding their intelligence in the process). Misinformation is everywhere. Please don’t rely on a chatbot for anything important. They can’t replace real human connection</blockquote><p>No. You’re holding it wrong. You can definitely learn from LLMs, but with caveats. It has to be with critical thinking where you doubt it every step of the way, on things you can easily verify. </p><p>LLMs definitely have a <em>shape</em> to them. Like a knife, you need to find the part of it–the handle–that has the right affordance for human hand. In the case of an intelligence tool like LLMs, you&#39;re trying to find the affordance for the human mind. As easy as they are to get started with as a chat conversation, most people haven&#39;t figured out how to hold these tools yet. </p><p>Here&#39;s some ways I notice I consistently and heavily use LLM/AI in three different ways to learn:</p><ul><li>As a patient teaching assistant when reading academic papers.</li><li>To get quickly acclimated and acquainted in a new programming language or framework ecosystem.</li><li>As a sounding partner in software architectural design work.</li></ul><h3 id="reading-academic-papers">Reading academic papers</h3><p>Academic papers are dense with jargon, and rightly so. Their main purpose is to communicate with their own peers to move forward the state-of-the-art. But that also mean it can be inscrutable to outsiders, even other academics outside the field. The effort you needed to come up to speed on not just the jargon, but the requisite concepts in order to understand the paper, required a huge activation energy. </p><p>LLMs lower this bar significantly. When I have to read computer science papers, I upload the PDF (or PDF converted to text) and ask it questions of any passages, terms, or concepts I don&#39;t understand. I can ask questions about what concepts mean and what its implications are. When I don&#39;t understand the abstract concept, I can ask it to write out a concrete example. If I still don&#39;t get it? I ask it to explain with metaphors in a domain I know well. I can even ask it to explain it to me like I&#39;m five, and then build it back up to the academic level of understanding from there.</p><figure><a href="https://interjectedfuture.com/ai-assist/accelerated-learning-with-gpt-academic-paper-reader/"><div><p>Accelerated learning with GPT academic paper reader</p><p>These last couple of days, I’ve been trying to deepen my understanding of CRDTs.
There aren’t too many papers on CRDTs, so you can get caught up quickly by
diligently reading the papers. Though I haven’t read them all, I was surprised
by my pace of understanding the papers with</p><p><img src="https://interjectedfuture.com/content/images/icon/favicon-18.ico" alt=""/><span>Interjected Future</span><span>Wil Chung</span></p></div><p><img src="https://interjectedfuture.com/content/images/thumbnail/Accelerated-Learning-with-GPT-Academic-Paper-Reader.jpg" alt="" onerror="this.style.display = &#39;none&#39;"/></p></a></figure><p>Importantly, I can spot-check what it&#39;s saying, either at random or if it smells fishy, based on my current understanding. Here&#39;s some things to do for spot-checking:</p><ul><li>Look at the exact passage in the paper for a claim or fact it&#39;s asserting.</li><li>Cross-reference an assertion with a quick search on the web.</li><li>Cross-reference against existing canonical text I know to be authoritative (such as the documentation to a software library)</li></ul><p>With this Socratic process, I can read about a paper I&#39;m mildly familiar with in a day, whereas otherwise it would have taken me the better part of a week. </p>
<!--kg-card-begin: html-->

<!--kg-card-end: html-->
<h3 id="learning-a-new-language-framework-library-or-ecosystem">Learning a new language, framework, library, or ecosystem</h3><p>Lots of career programmers just stick with a single language, framework, and ecosystem for a long time. They only jump ship when they&#39;re force by work, or if they feel FOMO from &#34;cool kids&#34; touting a new language or framework. But even for programmers who are curious hackers by nature, it takes a lot of effort, a lot of activation energy to get started with another language and ecosystem.</p><p>For one, the only real reason to go to another ecosystem is if it offers something that you can&#39;t get anywhere else. For React, it was the one-way data binding and data flow that eased the reasoning burden (compared to frameworks before). For Haskell, it&#39;s the pure functional approach. For Lean, it&#39;s dependent types. This new capability comes with conceptual ideas that need to be learned. </p><p>The LLM can definitely help you with learning the core concepts, but the source of the high activation energy is all the chrome around the novel core concept. This is basic stuff like syntax, conventions, or build tools. It&#39;s the locations of the forums, documentations, and package management. These are often arbitrary [^1] and by cultural convention, rather than from any reasoned first principle, so you just have to memorize them.</p><p>LLMs are great at this kind of administrivia. For a new language, I can ask the LLM to write me a first draft in the language for a project that I actually care about. It&#39;s much more motivating than some arbitrary project that the tutorial writer decided upon. In addition, the documentation in the ecosystem could be dense or poorly written, so this helps sidestep that hump. </p><p>For example, I wanted to see how the Isabelle proof system worked, so I had the LLMs generate me the code. That was a year and a half ago, so the models weren&#39;t very good at inductive proofs. But I got the hang of the syntax much more easily than if I had to read the docs.</p><figure><a href="https://interjectedfuture.com/lab-notes-031-proving-out-with-isabelle/"><div><p>Lab note #031 Proving out with Isabelle</p><p>In Lab note #029
[https://interjectedfuture.com/lab-notes/lab-notes-029-balancing-nodes-in-a-unicit-tree/]
, I was thinking about a different way to construct a unicit tree. Can we create
both a description of the splits in a tree and a comparator that would make it a
partially ordered set? And with that partially ordered set</p><p><img src="https://interjectedfuture.com/content/images/icon/favicon-19.ico" alt=""/><span>Interjected Future</span><span>Wil Chung</span></p></div><p><img src="https://interjectedfuture.com/content/images/thumbnail/DALL-E-2024-01-15-03.01.14---Hero-image-for-the-article-titled--Proving-out-Mathematics-with-Isabelle--in-an-illustrative-and-impressionistic-style.-The-image-should-convey-the-es.jpg" alt="" onerror="this.style.display = &#39;none&#39;"/></p></a></figure><p>For new frameworks and libraries, once again, asking it to do a first draft is motivating to see how things work, and if it&#39;s a popular ecosystem, I get to see what the conventions are. In most instances, I often have to temper or rewrite the implementation to fit my own standards in my project. However, this is often the quickest way to get something up and running, if the scope of the framework or library is well contained.</p><p>In all these instances, I often don&#39;t have to check the veracity of the generated response by hand, because it&#39;s often code, so there are type checkers, compilers, and build systems to check the output. The value LLMs provide here is to synthesize all the administrivia together to produce a working draft to iterate upon. It&#39;s much easier for all this stuff to stick when it&#39;s in the context of a project you care about.</p><h3 id="software-architecture-and-design">Software architecture and design</h3><p>As someone that works alone, LLMs have been great as <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging?ref=interjectedfuture.com" rel="noreferrer">a rubber duck</a> that talks back. The value here is to generate options I might not have thought of, and to push back on my thinking and designs. But for this to work, you need to adjust the system prompt to allow the LLM to push back on your ideas to combat their sycophantic tendencies.</p><p>As a short list, but not exhaustive list, you should put in the system prompt that:</p><ul><li>Your ideas are often dumb, shallow, and poorly considered. [^2]</li><li>It should ask them pointed questions and help re-direct them toward more insightful lines of thinking. </li><li>Do not be fawning or complimentary.</li><li>It should move them toward more specific, concrete claims backed up by solid evidence.</li><li>It should generate a counter-argument to its assertion, as well as a rebuttal to its counter-argument. [^3]</li></ul><p>With that in place, I first lay out the premise of the software design problem, the constraints of the situation, and ask it to generate options with pros and cons. Then after reviewing the options, I critique those options, throw away bad options, or ask it to elaborate its reasons for choosing specific options. From there, we keep iterating. I find that the latest reasoning models, like GPT-5 and Claude Opus are much better at this than previous models. However, they still have weaknesses. </p><figure><a href="https://interjectedfuture.com/lab-note-070-vibe-coding-is-half-a-skill-issue/"><div><p>Lab note #070 Vibe-coding is half a skill issue</p><p>I’ve been doing an implementation of DBSP, which is a way of doing incremental computation built up from some basic concepts from digital signal processing. While I use LLMs in my daily work to ask it questions, spitball with it, and do some basic stuff, I hardly ever ask it</p><p><img src="https://interjectedfuture.com/content/images/icon/favicon-20.ico" alt=""/><span>Interjected Future</span><span>Wil Chung</span></p></div><p><img src="https://interjectedfuture.com/content/images/thumbnail/ChatGPT-Image-Jun-10--2025--10_15_02-PM.png" alt="" onerror="this.style.display = &#39;none&#39;"/></p></a></figure><p>I find that they tend to revert to the median thinking in software design, which is more in an Object-Orientated tradition in a larger company. This often means a single class for a single concept, when a few functions would do, or an over-complication of relations between subsystems, when a simplification would do. Lots of cover-your-ass chrome, such as health checks and monitoring, when it&#39;s not needed for a core design.</p><p>Unlike the other two types of learning, this task isn&#39;t grounded in easily verifiable facts. What makes the process valuable is the iteration of different scenarios and options, and the articulation of my own tacit knowledge.</p><p>First, this process of iteration over different options and different solution spaces makes me better at doing the software design. Instead of asking LLMs for &#34;the best solution&#34;, I get lots more practice considering options under different scenarios. When the LLM comes up with a great solution, I ask how it got there, and what it knew or considered. I also examine what sort of faulty assumptions I had that lead me away from a good solution.</p><p>Second, the failure modes outlined above are helpful, because it helps me articulate my tacit knowledge of why these are bad solutions. In order to leverage this tacit knowledge as a compounding advantage, I&#39;m starting to record these failures as system eval traces in hopes of doing error analysis and prompt corrections later on. But for now, I&#39;m just writing these corrective guardrails by hand, because asking the LLM to generate them results in subpar generalizations of engineering principles. Either they&#39;re too specific for the problem at hand, or they take commonly known engineering aphorisms and apply them to the shallow design problem, instead of the core reason why I rejected the solution.</p><h3 id="dont-abdicate-your-seat-at-the-table">Don&#39;t abdicate your seat at the table</h3><p>The temptation with LLMs is to absolve yourself from doing critical thinking; to question everything the LLMs says back to you. But to do so is to curb your learning, and to stunt your learning. Despite the hype, I don&#39;t think software engineers will go away completely. I think our numbers will greatly diminish, so to stay as one, you have to get much better. In order to do that, you&#39;ll have to keep on learning. </p><p>The only time you should abdicate your thinking to LLMs is when the task at hand is administrivia: the knowledge that will be outdated in 15 years. If you&#39;ve ever read a COBOL manual on some general software principle, you&#39;ll know what I mean. </p><hr/><p>[^1]: If you&#39;ve been around the block enough, some ecosystems do take these arbitrary conventions from each other. The build tool in C is <code>make</code>. In Ruby, it&#39;s <code>rake</code>. In Lean, it&#39;s <code>lake</code>.</p><p>[^2]: To combat the sycophantic tendencies, I use a variation on <a href="https://maggieappleton.com/ai-enlightenment/?ref=interjectedfuture.com" rel="noreferrer">Maggie Appleton&#39;s prompt</a>.</p><p>[^3]: Got the argument/counter-argument/rebuttal from <a href="https://youtu.be/KxIeJjEGLdo?si=pIFzWGuuy1Jgegpf&amp;t=225&amp;ref=interjectedfuture.com" rel="noreferrer">Prof Sarah Paine</a>.</p>
        </section>

    </article>


</div></div>
  </body>
</html>
