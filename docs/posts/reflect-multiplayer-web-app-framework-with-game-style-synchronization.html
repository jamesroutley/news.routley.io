<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rocicorp.dev/blog/ready-player-two">Original</a>
    <h1>Reflect – Multiplayer web app framework with game-style synchronization</h1>
    
    <div id="readability-page-1" class="page"><div><p><img src="https://andrewkelley.me/blog-content/reflect-beta/sunrise2.jpg" alt="Sunrise over Nā Mokulua in O&#39;ahu Hawaii"/></p>
<p>Hello, and happy morning!</p>
<p><a href="https://reflect.net/">Reflect</a> is a new way to build multiplayer web apps like Figma, Notion, or Google Sheets.</p>
<p>Reflect is an evolution of <a href="https://replicache.dev/">Replicache</a>, our existing client-side sync framework. It uses the same game-inspired sync engine as Replicache, but adds a fully managed server, making it possible to start building high-quality multiplayer apps in minutes.</p>
<p>Today, Reflect is publicly available for the first time. Visit <a href="https://reflect.net/">reflect.net</a> to learn more, or <a href="https://hello.reflect.net/">hello.reflect.net</a> to get started.</p>

<p>Collaborative editing invariably involves conflicts.</p>
<p>This is just a matter of physics – information can only travel so fast. If you want instantaneously responsive UI, this means you can&#39;t wait for the server – changes have to happen locally, on the client. If the application is collaborative, then two users can be editing the same thing at the same time.</p>
<p>These conflicting edits must be synchronized somehow, so that all users see the same thing, and so that conflicts are resolved in a way that feels natural.</p>
<p>The heart of any multiplayer system is its approach to this problem. Like the engine of a car, the choice of sync engine determines just about everything else – the developer experience, the user experience, the performance that is possible, the types of apps that can be built, and more.</p>
<p>In the web ecosystem, <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">CRDTs</a> are a popular way to sync data. CRDTs (Conflict-Free Replicated Data Types) are a type of data structure that always converge to the same value, once all changes have been exchanged between collaborators. <a href="http://yjs.dev/">Yjs</a> and <a href="https://automerge.org/">Automerge</a> are two popular open-source CRDT libraries.</p>
<p>But Reflect is not a CRDT. We call our approach <em>Transactional Conflict Resolution</em>. It&#39;s a twist on <a href="https://en.wikipedia.org/wiki/Client-side_prediction">Server Reconciliation</a> – a technique that has been popular in the video game industry for years.</p>
<p>All the unique benefits and differences of Reflect flow from this one core choice, so it helps to understand it if you want to know what Reflect&#39;s about. Let&#39;s dive in.</p>

<p>Imagine you&#39;re using the Yjs CRDT library and you need to implement a counter. You decide to store the count in a Yjs map entry:</p>
<pre><code><span><span>const</span> map <span>=</span> <span>new</span> <span>Y<span>.</span>Map</span><span>(</span><span>)</span><span>;</span>
</span><span>
</span><span><span>function</span> <span>increment</span><span>(</span><span>)</span> <span>{</span>
</span><span>  <span>const</span> prev <span>=</span> map<span>.</span><span>get</span><span>(</span><span>&#39;count&#39;</span><span>)</span> <span>??</span> <span>0</span><span>;</span>
</span><span>  <span>const</span> next <span>=</span> prev <span>+</span> <span>1</span><span>;</span>
</span><span>  map<span>.</span><span>set</span><span>(</span><span>&#39;count&#39;</span><span>,</span> next<span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>
<figcaption>⚠️ Don&#39;t copy this! Loses increments under concurrency.</figcaption>
<p>You test your app and it seems to work, but in production you begin receiving reports of lost increments. You do some quick research and it leads you to <a href="https://github.com/yjs/yjs#example-using-and-combining-providers">this example from the Yjs docs</a>:</p>
<pre><code><span>
</span><span><span>const</span> yarray <span>=</span> ydoc<span>.</span><span>getArray</span><span>(</span><span>&#39;count&#39;</span><span>)</span><span>;</span>
</span><span>
</span><span>
</span><span>yarray<span>.</span><span>observe</span><span>(</span><span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
</span><span>  
</span><span>  <span>console</span><span>.</span><span>log</span><span>(</span><span>&#39;new sum: &#39;</span> <span>+</span> yarray<span>.</span><span>toArray</span><span>(</span><span>)</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=&gt;</span> a <span>+</span> b<span>)</span><span>)</span><span>;</span>
</span><span><span>}</span><span>)</span><span>;</span>
</span><span>
</span><span>
</span><span>yarray<span>.</span><span>push</span><span>(</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span> 
</span></code></pre>
<figcaption><p>✅ Correct code for implementing a counter from the Yjs docs.</p></figcaption>
<p>This is kind of surprising and awkward, not to mention inefficient. Why doesn&#39;t the obvious way above work?</p>
<p>Yjs is a <em>sequence</em> CRDT. It models a sequence of items. Sequences are great for working with lists, chunks of text, or maps — all tasks Yjs excels at. But a counter is not any of those things, so Yjs struggles to model it well.</p>
<p>Specifically, the merge algorithm for Yjs Map is last-write wins on a per-key basis. So when two collaborators increment concurrently, one or the other of their changes will be lost. LWW is the wrong merge algorithm for a counter, and with Yjs there&#39;s no easy way to provide the correct one.</p>
<p>This is a common problem with CRDTs. Most CRDTs are good for one particular problem, but if that&#39;s not the problem you have, they&#39;re hard to extend.</p>

<p>Now let&#39;s look at how we would implement a counter in Reflect:</p>
<pre><code><span><span>async</span> <span>function</span> <span>increment</span><span>(</span>tx<span>,</span> delta<span>)</span> <span>{</span>
</span><span>  <span>const</span> prev <span>=</span> <span>(</span><span>await</span> tx<span>.</span><span>get</span><span>(</span><span>&#39;count&#39;</span><span>)</span><span>)</span> <span>??</span> <span>0</span><span>;</span>
</span><span>  <span>const</span> next <span>=</span> prev <span>+</span> delta<span>;</span>
</span><span>  <span>await</span> tx<span>.</span><span>put</span><span>(</span><span>&#39;count&#39;</span><span>,</span> next<span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>
<figcaption>Implementing a counter with Reflect.</figcaption>
<p>It&#39;s clear, simple, obvious code. But, importantly, it also works under concurrency. The secret sauce is Transactional Conflict Resolution. Here&#39;s how it works:</p>
<p><img src="https://andrewkelley.me/blog-content/reflect-beta/flow-01.svg"/></p><p>In Reflect, Changes are implemented using special JavaScript functions
called <em>mutators</em>. The increment function above is an example of
a mutator. A copy of each mutator exists on each client and on the
server.</p>
<p><img src="https://andrewkelley.me/blog-content/reflect-beta/flow-02.svg"/></p><p>When a user makes a change, Reflect creates a <em>mutation</em> –
a record of a mutator being called. A mutation contains
<em>only the name of the mutator and its arguments</em> (i.e.,
<code>increment(delta: 1)</code>), not the resulting change.</p>
<p>Reflect immediately applies the mutation locally, by running the mutator
with those arguments. The UI updates and the user sees their
change.</p>
<p><img src="https://andrewkelley.me/blog-content/reflect-beta/flow-03.svg"/></p><p>Mutations are constantly being added at each client, without waiting for
the server. Here, client 2 adds an <code>increment(2)</code> mutation
concurrently with client 1&#39;s <code>increment(1)</code> mutation.</p>
<p><img src="https://andrewkelley.me/blog-content/reflect-beta/flow-04.svg"/></p><p>Mutations are streamed to the server. The server linearizes
the mutations by arrival time, then applies them to create the next
authoritative state.</p>
<p>Notice how when mutation A ran on client 1, the result was
<code>count: 1</code>. But when it ran on the server, the result was
<code>count: 3</code>. The conflict was merged correctly, just by
linearizing execution history. This happens even though the server knows
nothing about what <code>increment</code> does, how it works, or how to
merge it.</p>
<p><img src="https://andrewkelley.me/blog-content/reflect-beta/flow-05.svg"/></p><p>In fast-moving applications, mutations are often added while
awaiting confirmation of earlier ones. Here, client 1 increments one
more time while waiting for confirmation of the first increment.</p>
<p><img src="https://andrewkelley.me/blog-content/reflect-beta/flow-06.svg"/></p><p>Updates to the latest authoritative state are continuously streamed back
to each client.</p>
<p>When a client learns that one of its pending mutation has been applied
to the authoritative state, it removes that mutation from its local
queue. Any remaining pending mutations are <code>rebased</code> atop the
latest authoritative state by again re-running the mutator code.</p>
<p>This entire cycle happens up to 120 times per second, per client.</p>

<p>This is a fair amount of work to implement.</p>
<p>You need a fast datastore that can rewind, fork, and create branches. You need fast storage on the server-side to keep up with the incoming mutations. You need a way to keep the mutators in sync. You need to deal with either clients or servers crashing mid-sync, and recovering.</p>
<p>But the payoff is that it ✨generalizes✨. Linearization of arbitrary functions is a pretty good general-purposes sync strategy. Once you have it in place all kinds of things just work.</p>
<p>For example, any kind of arithmetic just works:</p>
<pre><code><span><span>async</span> <span>function</span> <span>setHighScore</span><span>(</span>tx<span>:</span> WriteTransaction<span>,</span> candidate<span>:</span> <span>number</span><span>)</span> <span>{</span>
</span><span>  <span>const</span> prev <span>=</span> <span>(</span><span>await</span> tx<span>.</span><span>get</span><span>(</span><span>&#39;high-score&#39;</span><span>)</span><span>)</span> <span>??</span> <span>0</span><span>;</span>
</span><span>  <span>const</span> next <span>=</span> Math<span>.</span><span>max</span><span>(</span>prev<span>,</span> candidate<span>)</span><span>;</span>
</span><span>  <span>await</span> tx<span>.</span><span>put</span><span>(</span><span>&#39;high-score&#39;</span><span>,</span> next<span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>
<p>List operations just work:</p>
<pre><code><span><span>async</span> <span>function</span> <span>append</span><span>(</span>tx<span>:</span> WriteTransaction<span>,</span> item<span>:</span> <span>string</span><span>)</span> <span>{</span>
</span><span>  <span>const</span> prev <span>=</span> <span>(</span><span>await</span> tx<span>.</span><span>get</span><span>(</span><span>&#39;shopping&#39;</span><span>)</span><span>)</span> <span>??</span> <span>[</span><span>]</span><span>;</span>
</span><span>  <span>const</span> next <span>=</span> <span>[</span><span>...</span>prev<span>,</span> item<span>]</span><span>;</span>
</span><span>  <span>await</span> tx<span>.</span><span>put</span><span>(</span><span>&#39;shopping&#39;</span><span>,</span> next<span>)</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>async</span> <span>function</span> <span>insertAt</span><span>(</span>
</span><span>  tx<span>:</span> WriteTransaction<span>,</span>
</span><span>  <span>{</span> item<span>,</span> pos <span>}</span><span>:</span> <span>{</span> item<span>:</span> <span>string</span><span>;</span> pos<span>:</span> <span>number</span> <span>}</span><span>,</span>
</span><span><span>)</span> <span>{</span>
</span><span>  <span>const</span> prev <span>=</span> <span>(</span><span>await</span> tx<span>.</span><span>get</span><span>(</span><span>&#39;shopping&#39;</span><span>)</span><span>)</span> <span>??</span> <span>[</span><span>]</span><span>;</span>
</span><span>  
</span><span>  <span>const</span> next <span>=</span> prev<span>.</span><span>toSpliced</span><span>(</span>pos<span>,</span> <span>0</span><span>,</span> item<span>)</span><span>;</span>
</span><span>  <span>await</span> tx<span>.</span><span>put</span><span>(</span><span>&#39;shopping&#39;</span><span>,</span> next<span>)</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span>
</span><span><span>async</span> <span>function</span> <span>remove</span><span>(</span>tx<span>:</span> WriteTransaction<span>,</span> item<span>:</span> <span>string</span><span>)</span> <span>{</span>
</span><span>  <span>const</span> prev <span>=</span> <span>(</span><span>await</span> tx<span>.</span><span>get</span><span>(</span><span>&#39;shopping&#39;</span><span>)</span><span>)</span> <span>??</span> <span>[</span><span>]</span><span>;</span>
</span><span>  <span>const</span> idx <span>=</span> list<span>.</span><span>indexOf</span><span>(</span>item<span>)</span><span>;</span>
</span><span>  <span>if</span> <span>(</span>idx <span>===</span> <span>-</span><span>1</span><span>)</span> <span>return</span><span>;</span>
</span><span>  <span>const</span> next <span>=</span> prev<span>.</span><span>toSpliced</span><span>(</span>idx<span>,</span> <span>1</span><span>)</span><span>;</span>
</span><span>  <span>await</span> tx<span>.</span><span>put</span><span>(</span><span>&#39;shopping&#39;</span><span>,</span> next<span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>
<p>You can even enforce high-level invariants, like ensuring that a child always has a back-pointer to its parent.</p>
<pre><code><span><span>async</span> <span>function</span> <span>addChild</span><span>(</span>
</span><span>  tx<span>:</span> WriteTransaction<span>,</span>
</span><span>  parentID<span>:</span> <span>string</span><span>,</span>
</span><span>  childID<span>:</span> <span>string</span><span>,</span>
</span><span><span>)</span> <span>{</span>
</span><span>  <span>const</span> parent <span>=</span> <span>await</span> tx<span>.</span><span>get</span><span>(</span>parentID<span>)</span><span>;</span>
</span><span>  <span>const</span> child <span>=</span> <span>await</span> tx<span>.</span><span>get</span><span>(</span>childID<span>)</span><span>;</span>
</span><span>  <span>if</span> <span>(</span><span>!</span>parent <span>||</span> <span>!</span>child<span>)</span> <span>return</span><span>;</span>
</span><span>
</span><span>  
</span><span>  <span>const</span> nextParent <span>=</span> <span>{</span> <span>...</span>parent<span>,</span> childIDs<span>:</span> <span>[</span><span>...</span>parent<span>.</span>childIDs<span>,</span> childID<span>]</span> <span>}</span><span>;</span>
</span><span>  <span>const</span> nextChild <span>=</span> <span>{</span> <span>...</span>child<span>,</span> parentID <span>}</span><span>;</span>
</span><span>
</span><span>  <span>await</span> tx<span>.</span><span>put</span><span>(</span>parentID<span>,</span> nextParent<span>)</span><span>;</span>
</span><span>  <span>await</span> tx<span>.</span><span>put</span><span>(</span>childID<span>,</span> nextChild<span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>
<p>All of these examples <em>just work</em>, and merge reasonably without any special sync-aware code.</p>

<p>The benefits of Transactional Conflict Resolution extend further because of the way sync works.</p>
<p><strong>In Reflect, the server is the authority.</strong> It doesn&#39;t matter what clients think or say the result of a change is – their opinion is not even shared with the server or other clients. All that is sent to the server is the mutation name and arguments. The server recomputes the result of a mutation for itself, and all clients see that result.</p>
<p>This means that the server can do whatever it wants to execute a mutation. It doesn&#39;t have to even be the same code as runs on the client. It can consult external services, or even roll dice.</p>
<p>One immediate result of this design is that you get fine-grained authorization for free.</p>
<p>For example, imagine you are implementing a collaborative design program and you want to allow users to share their designs and solicit feedback. Guests should be able to add comments, highlight the drawing, and so on, but not make any changes.</p>
<p>Implementing this would be quite difficult with a CRDT, because there is no place to put the logic that rejects an unauthorized change.</p>
<p>In Reflect, it&#39;s trivial:</p>
<pre><code><span><span>async</span> <span>function</span> <span>updateShape</span><span>(</span>tx<span>:</span> WriteTransaction<span>,</span> shapeUpdate<span>:</span> Update<span>&lt;</span>Shape<span>&gt;</span><span>)</span> <span>{</span>
</span><span>  
</span><span>  
</span><span>  <span>if</span> <span>(</span>tx<span>.</span>environment <span>===</span> <span>&#39;server&#39;</span> <span>&amp;&amp;</span> <span>!</span>tx<span>.</span>user<span>.</span>canEdit<span>)</span> <span>{</span>
</span><span>    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>&#39;unauthorized&#39;</span><span>)</span><span>;</span>
</span><span>  <span>}</span>
</span><span>  
</span><span><span>}</span>
</span></code></pre>
<p>Notice that the mutator actually executes different code on the server. This is fine in Reflect. The server is the authority, and it can make its decision however it wants.</p>

<p>There are even more benefits to this approach. For example, schema validation and migrations just sort of fall out of the design for free. Future blog posts will explore these topics in more detail.</p>
<p>For now, I&#39;ll end this where I started: the choice of sync strategy is the heart of any multiplayer system. It determines just about everything else. And while there are certainly benefits to other approaches, we find that the game industry has a lot to teach on this topic. Transactional Conflict Resolution &#34;fits our brain&#34; in a way other solutions don&#39;t. It&#39;s simple, flexible, and powerful.</p>
<p>If you&#39;re building a multiplayer application, you should <a href="https://hello.reflect.net/">try out Reflect</a> and see if it fits your brain too.</p>
<p>And hey, if you&#39;ve made it this far, you&#39;re our kind of person. We&#39;d love to hear from you. Come find us at <a href="https://discord.reflect.net/">discord.reflect.net</a> or <a href="https://twitter.com/hello_reflect">@hello_reflect</a> and say hi. We&#39;d enjoy hearing about what you&#39;re building.</p></div></div>
  </body>
</html>
