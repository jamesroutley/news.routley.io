<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.dend.ro/mapping-my-walks-osrm-rust/">Original</a>
    <h1>Mapping my walks with OSRM and Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<div>
  
  <p><span>2022-01-15</span></p><p><a href="https://blog.dend.ro/map-matching-osrm/">Last week</a>, we looked at the data from my smartwatch app and how to snap it to the OpenStreetMap roads.
If you haven&#39;t already, consider reading that post before moving on.
This time, we&#39;ll be writing some code in the <a href="https://rust-lang.org/">Rust</a> programming language.
Keep in mind that this isn&#39;t exactly production-grade code, but rather something you would normally write in Python in one afternoon.
I&#39;ll link to the crates I&#39;m using for the benefit of readers less familiar with the Rust ecosystem.</p>
<h2 id="importing-the-data">Importing the data</h2>
<p>If you recall from last time, our data points include a timestamp, the latitude and longitude, and an accuracy radius.
We can define our point type as follows:</p>
<pre><code data-lang="rust"><span>pub struct </span><span>Point {
    </span><span>pub </span><span>time</span><span>: OffsetDateTime,
    </span><span>pub </span><span>geom</span><span>: geo_types::Point&lt;</span><span>f64</span><span>&gt;,
    </span><span>pub </span><span>radius</span><span>: </span><span>f32</span><span>,
}
</span></code></pre>
<p>The <code>OffsetDateTime</code> and <code>Point&lt;T&gt;</code> types are from the <a href="https://crates.io/crates/time"><code>time</code></a> and <a href="https://crates.io/crates/geo-types"><code>geo-types</code></a> crates, respectively.
We&#39;ll also need <a href="https://crates.io/crates/zip"><code>zip</code></a> and <a href="https://crates.io/crates/csv"><code>csv</code></a> in order to parse the exported file.</p>
<p>Let&#39;s see what reading the file looks like:</p>
<pre><code data-lang="rust"><span>pub fn </span><span>read_archive</span><span>(</span><span>path</span><span>: &amp;Path) -&gt; Result&lt;Vec&lt;Point&gt;, Error&gt; {
    </span><span>let</span><span> file = File::open(path)?;
    </span><span>let mut</span><span> archive = ZipArchive::new(file)?;
    </span><span>let mut</span><span> latitudes = Vec::new();
    </span><span>let mut</span><span> record = StringRecord::new();
    {
        </span><span>let</span><span> reader = archive.</span><span>by_name</span><span>(&#34;</span><span>raw_location_latitude.csv</span><span>&#34;)?;
        </span><span>let mut</span><span> reader = Reader::from_reader(reader);
        </span><span>while</span><span> reader.</span><span>read_record</span><span>(&amp;</span><span>mut</span><span> record)? {
            latitudes.</span><span>push</span><span>(</span><span>get_array_first_value</span><span>(&amp;record[</span><span>2</span><span>])?);
        }
    }
    </span><span>let</span><span> n = latitudes.</span><span>len</span><span>();
    </span><span>let mut</span><span> times = Vec::with_capacity(n);
    </span><span>let mut</span><span> longitudes = Vec::with_capacity(n);
    {
        </span><span>let</span><span> reader = archive.</span><span>by_name</span><span>(&#34;</span><span>raw_location_longitude.csv</span><span>&#34;)?;
        </span><span>let mut</span><span> reader = Reader::from_reader(reader);
        </span><span>while</span><span> reader.</span><span>read_record</span><span>(&amp;</span><span>mut</span><span> record)? {
            </span><span>let</span><span> time = OffsetDateTime::parse(&amp;record[</span><span>0</span><span>], &amp;well_known::Rfc3339)?;
            times.</span><span>push</span><span>(time);
            longitudes.</span><span>push</span><span>(</span><span>get_array_first_value</span><span>(&amp;record[</span><span>2</span><span>])?);
        }
    }
    assert_eq!(longitudes.</span><span>len</span><span>(), n);
    </span><span>let mut</span><span> radiuses = Vec::with_capacity(n);
    {
        </span><span>let</span><span> reader = archive.</span><span>by_name</span><span>(&#34;</span><span>raw_location_horizontal-radius.csv</span><span>&#34;)?;
        </span><span>let mut</span><span> reader = Reader::from_reader(reader);
        </span><span>while</span><span> reader.</span><span>read_record</span><span>(&amp;</span><span>mut</span><span> record)? {
            radiuses.</span><span>push</span><span>(</span><span>get_array_first_value</span><span>(&amp;record[</span><span>2</span><span>])?);
        }
    }
    assert_eq!(radiuses.</span><span>len</span><span>(), n);
    </span><span>let</span><span> points = izip!(times, latitudes, longitudes, radiuses)
        .</span><span>map</span><span>(|(</span><span>time</span><span>, </span><span>lat</span><span>, </span><span>lon</span><span>, </span><span>radius</span><span>)| {
            </span><span>let</span><span> geom = geo_types::Point::new(lon, lat);
            Point { time, geom, radius }
        })
        .</span><span>collect</span><span>();
    Ok(points)
}

</span><span>fn </span><span>get_array_first_value</span><span>&lt;T&gt;(</span><span>s</span><span>: &amp;</span><span>str</span><span>) -&gt; Result&lt;T, </span><span>T::</span><span>Err&gt;
</span><span>where
</span><span>    T: FromStr,
    </span><span>T::</span><span>Err: std::fmt::Debug,
{
    </span><span>let</span><span> p = s.</span><span>find</span><span>(|</span><span>c</span><span>| c == &#39;</span><span>]</span><span>&#39; || c == &#39;</span><span>,</span><span>&#39;).</span><span>expect</span><span>(&#34;</span><span>expected array</span><span>&#34;);
    s[</span><span>1</span><span>..p].</span><span>parse</span><span>()
}
</span></code></pre>
<p>The code is somewhat unwieldly because it needs to read three different CSVs from the archive.
The ZIP reader needs to seek into the archive, so we can&#39;t read all of them at once.
If you&#39;re familiar with Rust, that constraint is expressed in the type system by <code>Reader</code> having a mutable reference to <code>ZipArchive</code>.
Instead, we open the files one at a time and scan through each.</p>
<p>We need to remember to read the timestamps and there is one extra complication.
The values are written as JSON-like arrays (e.g. <code>[44.XXX,657.XXX]</code>), but only the first one makes sense.
Instead of reaching for a full-blown JSON parser, we simply look for a bracket or comma and parse the number we find there.</p>
<p>The <code>izip</code> macro comes from <a href="https://crates.io/crates/itertools"><code>itertools</code></a> and lets us iterate over the multiple collections at once.</p>
<p>Note that the implementation keeps all the points in memory (twice, even).
Normally I would dump the points to disk and read them back, but it would make the code harder to follow in a blog post.
In any case, this doesn&#39;t dominate our memory usage.</p>
<h2 id="calling-into-osrm">Calling into OSRM</h2>
<p>As mentioned last time, OSRM has an HTTP server, so we&#39;ll use <a href="https://crates.io/crates/reqwest"><code>reqwest</code></a> to call into it and <a href="https://crates.io/crates/serde"><code>serde</code></a> to deserialize the JSON responses.</p>
<p>First of all, we define some structs that roughly match the OSRM response:</p>
<pre><code data-lang="rust"><span>#[</span><span>derive</span><span>(Deserialize, Debug)]
</span><span>pub struct </span><span>MatchResponse {
    </span><span>pub </span><span>matchings</span><span>: Vec&lt;Matching&gt;,
}

#[</span><span>derive</span><span>(Deserialize, Debug)]
</span><span>pub struct </span><span>Matching {
    </span><span>pub </span><span>geometry</span><span>: String,
}
</span></code></pre>
<p>Then our client:</p>
<pre><code data-lang="rust"><span>pub struct </span><span>OsrmClient {
    </span><span>client</span><span>: Client,
    </span><span>base_url</span><span>: String,
}

</span><span>impl </span><span>OsrmClient {
    </span><span>pub fn </span><span>new</span><span>(</span><span>base_url</span><span>: String) -&gt; </span><span>Self </span><span>{
        </span><span>let</span><span> client = Client::new();
        </span><span>Self </span><span>{ client, base_url }
    }

    </span><span>pub fn </span><span>match_map</span><span>(
        &amp;</span><span>self</span><span>,
        </span><span>profile</span><span>: &amp;</span><span>str</span><span>,
        </span><span>points</span><span>: &amp;[Point],
    ) -&gt; Result&lt;MultiLineString&lt;</span><span>f64</span><span>&gt;, Error&gt; {
        </span><span>let mut</span><span> q = format!(&#34;</span><span>{}</span><span>match/v1/</span><span>{profile}</span><span>/polyline6(</span><span>&#34;, </span><span>self</span><span>.base_url);
        </span><span>let mut</span><span> timestamps = String::new();
        </span><span>let mut</span><span> radiuses = String::from(&#34;</span><span>&amp;radiuses=</span><span>&#34;);
        </span><span>let</span><span> coordinates = LineString::from_iter(points.</span><span>iter</span><span>().</span><span>map</span><span>(|</span><span>p</span><span>| p.geom));
        </span><span>for</span><span> point in points {
            write!(timestamps, &#34;</span><span>{}</span><span>;</span><span>&#34;, point.time.</span><span>unix_timestamp</span><span>())?;
            write!(radiuses, &#34;</span><span>{}</span><span>;</span><span>&#34;, point.radius)?;
        }
        timestamps.</span><span>pop</span><span>();
        radiuses.</span><span>pop</span><span>();
        </span><span>let</span><span> coordinates =
            polyline::encode_coordinates(coordinates, </span><span>6</span><span>).</span><span>map_err</span><span>(|</span><span>e</span><span>| anyhow!(e))?;
        </span><span>let</span><span> pe = percent_encoding::percent_encode(
            coordinates.</span><span>as_bytes</span><span>(),
            percent_encoding::</span><span>NON_ALPHANUMERIC</span><span>,
        );
        write!(
            q,
            &#34;</span><span>{}</span><span>)?geometries=polyline6&amp;tidy=true&amp;steps=false&amp;timestamps=</span><span>&#34;,
            pe
        )?;
        q.</span><span>push_str</span><span>(&amp;timestamps);
        q.</span><span>push_str</span><span>(&amp;radiuses);
        </span><span>let</span><span> res = </span><span>self</span><span>.client.</span><span>get</span><span>(&amp;q).</span><span>send</span><span>()?.json::&lt;MatchResponse&gt;()?;
        </span><span>let</span><span> mls = MultiLineString(
            res.matchings
                .</span><span>into_iter</span><span>()
                .</span><span>map</span><span>(|</span><span>m</span><span>| polyline::decode_polyline(&amp;m.geometry, </span><span>6</span><span>))
                .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
                .</span><span>map_err</span><span>(|</span><span>e</span><span>| anyhow!(e))?,
        );
        Ok(mls)
    }
}
</span></code></pre>
<p>Again, this is quick and dirty code.
We use the <a href="https://developers.google.com/maps/documentation/utilities/polylinealgorithm"><code>polyline</code></a> encoding of the coordinates and the corresponding <a href="https://crates.io/crates/polyline">crate</a> for it.
Because <code>polyline</code> uses an encoding that contains non-alphanumeric characters, we need to encode them using <a href="https://crates.io/crates/polyline"><code>percent-encoding</code></a>.
This crate doesn&#39;t have a standard error type (it uses <code>String</code>s), so we adapt them using <a href="https://crates.io/crates/anyhow"><code>anyhow</code></a>, which is also appears in the rest of the code.</p>
<h2 id="saving-a-flatgeobuf">Saving a FlatGeobuf</h2>
<p>This isn&#39;t really required for our purposes, but I want to keep a copy of the points in a format better suited for using later.
I&#39;d normally use <a href="https://geopackage.org/">GeoPackage</a>, but I want to give <a href="https://flatgeobuf.org/">FlatGeobuf</a> a try.
This is a newer format, with a simpler structure and which should be simpler to write, since a <a href="https://crates.io/crates/flatgeobuf">pure-Rust</a> implementation is available.
Fortunately, <a href="https://gdal.org/">GDAL</a> also has a reader, so it should be compatible with every application I care about at the moment.</p>
<p><code>flatgeobuf</code> has a slightly strange API, but it&#39;s not too bad and I&#39;ve seen worse.
It integrates closely with <a href="https://crates.io/crates/geozero"><code>geozero</code></a>, which is a visitor-based API for zero-copy processing of geospatial data.</p>
<pre><code data-lang="rust"><span>fn </span><span>export_fgb</span><span>(</span><span>name</span><span>: &amp;</span><span>str</span><span>, </span><span>file</span><span>: &amp;Path, </span><span>points</span><span>: &amp;[Point]) -&gt; anyhow::Result&lt;()&gt; {
    </span><span>let mut</span><span> fgb = FgbWriter::create(name, GeometryType::Point, |_, _| {})?;
    fgb.</span><span>set_crs</span><span>(</span><span>4326</span><span>, |</span><span>_fbb</span><span>, </span><span>_crs</span><span>| {});
    fgb.</span><span>add_column</span><span>(&#34;</span><span>time</span><span>&#34;, ColumnType::DateTime, |_, </span><span>col</span><span>| {
        col.nullable = </span><span>false</span><span>;
    });
    fgb.</span><span>add_column</span><span>(&#34;</span><span>radius</span><span>&#34;, ColumnType::Float, |_, </span><span>col</span><span>| {
        col.nullable = </span><span>false</span><span>;
    });
    </span><span>for</span><span> point in points {
        </span><span>let</span><span> time = point.time.</span><span>format</span><span>(&amp;well_known::Rfc3339)?;
        fgb.</span><span>add_feature_geom</span><span>(Geometry::Point(point.geom), |</span><span>feat</span><span>| {
            feat.</span><span>property</span><span>(</span><span>0</span><span>, &#34;</span><span>time</span><span>&#34;, &amp;ColumnValue::DateTime(&amp;time))
                .</span><span>unwrap</span><span>();
            feat.</span><span>property</span><span>(</span><span>1</span><span>, &#34;</span><span>radius</span><span>&#34;, &amp;ColumnValue::Float(point.radius))
                .</span><span>unwrap</span><span>();
        })?;
    }
    </span><span>let</span><span> out_file = File::create(file)?;
    fgb.</span><span>write</span><span>(&amp;</span><span>mut </span><span>BufWriter::new(out_file))?;
    Ok(())
}
</span></code></pre>
<p>We create a writer, configure the <a href="https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/intro-to-coordinate-reference-systems/">CRS</a> and define the two columns.
Afterwards, we can iterate over our points, create features from them, and set the column values.</p>
<h2 id="reprojecting-the-data">Reprojecting the data</h2>
<p>I want to display the resulting tracks on a map, but the (latitude, longitude) coordinates aren&#39;t ideal, since they introduce quite a bit of distorsion:</p>
<p><a href="https://blog.dend.ro/assets/gps-4326.webp" target="_blank"><img src="https://blog.dend.ro/assets/gps-4326.webp"/></a></p>
<p>Instead, we will reproject our points to the <a href="https://en.wikipedia.org/wiki/Web_Mercator_projection">Web Mercator</a> (or, more formally, EPSG:3857) projection.
While it&#39;s not really accurate, it&#39;s good enough at this latitude for my purposes.
Web Mercator has been popularized by Google Maps, and the look of it should be familiar to anyone who&#39;s ever seen an interactive map on the Web.</p>
<p><a href="https://blog.dend.ro/assets/gps-3857.webp" target="_blank"><img src="https://blog.dend.ro/assets/gps-3857.webp"/></a></p>
<p>For this, I&#39;d normally use <code>GDAL</code> or <a href="https://proj.org/"><code>PROJ</code></a>, but GDAL&#39;s approach to threading isn&#39;t the most fortunate.
We could probably use the <a href="https://crates.io/crates/proj"><code>proj</code></a> bindings, but even those bring quite a bit of complexity.</p>
<p>The conversion to Web Mercator should be pretty easy.
You can see a pair of formulas in the link above, but they use different bounds, and it&#39;s not obvious how to do it correctly.
Stack Overflow produces a fair bit of <a href="https://gis.stackexchange.com/questions/208966/converting-lat-long-to-epsg3857-coordinates">confusion</a> and <a href="https://gis.stackexchange.com/questions/142866/converting-latitude-longitude-epsg4326-into-epsg3857/142871#142871">two</a> <a href="https://stackoverflow.com/questions/37523872/converting-coordinates-from-epsg-3857-to-4326/40403522#comment81831709_40403522">answers</a>, but neither of them agrees with <code>PROJ</code>.
After a bit of hit-and miss, I realized that the three implementations are using different values for the Earth radius.
I believe the correct value to use in this case is <code>6_378_137 m</code>.
My final implementation gives the same result (up to the precision limit) as <code>PROJ</code> for a couple of points I&#39;ve tried, so I hope it&#39;s correct.</p>
<pre><code data-lang="rust"><span>pub fn </span><span>epsg_4326_to_3857</span><span>(</span><span>x</span><span>: </span><span>f64</span><span>, </span><span>y</span><span>: </span><span>f64</span><span>) -&gt; (</span><span>f64</span><span>, </span><span>f64</span><span>) {
    </span><span>const </span><span>WGS84_EQUATORIAL_RADIUS</span><span>: </span><span>f64 </span><span>= </span><span>6_378_137.0</span><span>;
    </span><span>const </span><span>MAX_LATITUDE</span><span>: </span><span>f64 </span><span>= </span><span>85.06</span><span>;

    </span><span>let</span><span> x = x.</span><span>to_radians</span><span>();
    </span><span>let</span><span> y = </span><span>if</span><span> y &gt; </span><span>MAX_LATITUDE </span><span>{
        std::f64::consts::</span><span>PI
    </span><span>} </span><span>else if</span><span> y &lt; -</span><span>MAX_LATITUDE </span><span>{
        -std::f64::consts::</span><span>PI
    </span><span>} </span><span>else </span><span>{
        </span><span>let</span><span> y = y.</span><span>to_radians</span><span>() / </span><span>2.0 </span><span>+ std::f64::consts::</span><span>FRAC_PI_4</span><span>;
        y.</span><span>tan</span><span>().</span><span>ln</span><span>()
    };
    (x * </span><span>WGS84_EQUATORIAL_RADIUS</span><span>, y * </span><span>WGS84_EQUATORIAL_RADIUS</span><span>)
}
</span></code></pre>
<p>There is also a helper that reprojects an entire track:</p>
<pre><code data-lang="rust"><span>fn </span><span>reproject_route</span><span>(</span><span>mls</span><span>: &amp;</span><span>mut </span><span>MultiLineString&lt;</span><span>f64</span><span>&gt;) {
    mls.</span><span>iter_mut</span><span>().</span><span>for_each</span><span>(|</span><span>ls</span><span>| {
        ls.</span><span>0.</span><span>iter_mut</span><span>().</span><span>for_each</span><span>(|</span><span>p</span><span>| {
            </span><span>let </span><span>(x, y) = geo::epsg_4326_to_3857(p.x, p.y);
            p.x = x;
            p.y = y;
        });
    });
}
</span></code></pre><h2 id="rasterization">Rasterization</h2>
<p>Next, I want to display the tracks returned by OSRM as images.
Converting from vector data to an image is called rasterization.
I had a couple of options here (it&#39;s less flexible, but GDAL can do it), but I decided to a recently-published crate called <a href="https://crates.io/crates/rasterize"><code>rasterize</code></a>.</p>
<p>First of all, <code>rasterize</code> represents paths as a list of segments, not points, so we need a conversion function for that:</p>
<pre><code data-lang="rust"><span>fn </span><span>mls_to_path</span><span>(</span><span>mls</span><span>: MultiLineString&lt;</span><span>f64</span><span>&gt;) -&gt; rasterize::Path {
    </span><span>let</span><span> subpaths = mls
        .</span><span>into_iter</span><span>()
        .</span><span>filter_map</span><span>(|</span><span>ls</span><span>| {
            SubPath::new(
                ls.</span><span>into_iter</span><span>()
                    .</span><span>map</span><span>(|</span><span>p</span><span>| p.</span><span>x_y</span><span>())
                    .</span><span>tuple_windows</span><span>()
                    .</span><span>map</span><span>(|(</span><span>p1</span><span>, </span><span>p2</span><span>)| Segment::Line(Line::new(p1, p2)))
                    .</span><span>collect</span><span>(),
                </span><span>false</span><span>,
            )
        })
        .</span><span>collect</span><span>();
    rasterize::Path::new(subpaths)
}
</span></code></pre>
<p>We also need to pick a couple of things:</p>
<ul>
<li>the view bounding box in map coordinates</li>
<li>the stroke style and color</li>
<li>a scale factor to apply, so that our output image size doesn&#39;t depend on the EPSG:3857 coordinates</li>
</ul>
<pre><code data-lang="rust"><span>struct </span><span>RasterizeOptions {
    </span><span>rasterizer</span><span>: ActiveEdgeRasterizer,
    </span><span>bbox</span><span>: BBox,
    </span><span>transform</span><span>: Transform,
    </span><span>stroke_color</span><span>: Arc&lt;LinColor&gt;,
    </span><span>stroke_style</span><span>: StrokeStyle,
}
</span></code></pre>
<p>Then we can write a bit of code to rasterize a track and save the result to a file:</p>
<pre><code data-lang="rust"><span>fn </span><span>rasterize_route</span><span>(
    </span><span>options</span><span>: &amp;RasterizeOptions,
    </span><span>output</span><span>: File,
    </span><span>mut </span><span>mls</span><span>: MultiLineString&lt;</span><span>f64</span><span>&gt;,
) -&gt; anyhow::Result&lt;()&gt; {
    </span><span>reproject_mls</span><span>(&amp;</span><span>mut</span><span> mls);
    </span><span>let</span><span> scene = Scene::stroke(
        Arc::new(</span><span>mls_to_path</span><span>(mls)),
        Arc::clone(&amp;options.stroke_color) as Arc&lt;dyn Paint&gt;,
        options.stroke_style,
    );
    </span><span>let</span><span> layer = scene.</span><span>render</span><span>(
        &amp;options.rasterizer,
        options.transform,
        Some(options.bbox),
        None,
    );
    layer.</span><span>write_png</span><span>(output)?;
    Ok(())
}
</span></code></pre>
<p>The result looks like this (if it looks weird for you, it&#39;s because it has a transparent background):</p>
<p><a href="https://blog.dend.ro/assets/gps-track-rasterized.webp" target="_blank"><img src="https://blog.dend.ro/assets/gps-track-rasterized.webp"/></a></p>
<h2 id="accumulating-the-images">Accumulating the images</h2>
<p>At the end, I want to overlay all the tracks in the same image.
We load the files from the previous step using <a href="https://crates.io/crates/png"><code>png</code></a>, then accumulate them into a white layer:</p>
<pre><code data-lang="rust"><span>fn </span><span>accumulate_images</span><span>(</span><span>bbox</span><span>: BBox, </span><span>images</span><span>: &amp;[String]) -&gt; anyhow::Result&lt;()&gt; {
    </span><span>let mut</span><span> layer = Layer::new(bbox, Some(LinColor::new(</span><span>1.0</span><span>, </span><span>1.0</span><span>, </span><span>1.0</span><span>, </span><span>1.0</span><span>)));
    </span><span>let mut</span><span> buf = vec![</span><span>0</span><span>; layer.</span><span>width</span><span>() * layer.</span><span>height</span><span>() * </span><span>4</span><span>];
    </span><span>for</span><span> img in images {
        {
            </span><span>let</span><span> decoder = Decoder::new(File::open(&amp;img)?);
            </span><span>let mut</span><span> reader = decoder.</span><span>read_info</span><span>()?;
            </span><span>let</span><span> info = reader.</span><span>next_frame</span><span>(&amp;</span><span>mut</span><span> buf)?;
            layer
                .</span><span>iter_mut</span><span>()
                .</span><span>zip</span><span>((&amp;buf[..info.</span><span>buffer_size</span><span>()]).</span><span>chunks</span><span>(</span><span>4</span><span>))
                .</span><span>for_each</span><span>(|(</span><span>pa</span><span>, </span><span>p</span><span>)| {
                    </span><span>let</span><span> p = &amp;p[..</span><span>4</span><span>];
                    *pa = pa.</span><span>blend_over</span><span>(&amp;ColorU8::new(p[</span><span>0</span><span>], p[</span><span>1</span><span>], p[</span><span>2</span><span>], p[</span><span>3</span><span>]).</span><span>into</span><span>());
                });
        }
        </span><span>let</span><span> file = File::create(img)?;
        layer.</span><span>write_png</span><span>(file)?;
    }
    Ok(())
}
</span></code></pre>
<p>The bleding operator (<code>blend_over</code>, from <code>rasterize</code>) keeps the existing pixels and only overwrites the transparent ones.</p>
<h2 id="putting-it-together">Putting it together</h2>
<p>Skipping over argument parsing and other initializations, we can finally read the archive and save the FlatGeobuf file:</p>
<pre><code data-lang="rust"><span>let mut</span><span> points = import::read_archive(archive)?;
</span><span>export_fgb</span><span>(&#34;</span><span>location</span><span>&#34;, &amp;archive.</span><span>with_extension</span><span>(&#34;</span><span>fgb</span><span>&#34;), &amp;points)?;
points.</span><span>sort_unstable_by_key</span><span>(|</span><span>p</span><span>| p.time);
</span></code></pre>
<p>We then filter out the bad points and group them by date:</p>
<pre><code data-lang="rust"><span>let</span><span> points = points
    .</span><span>into_iter</span><span>()
    .</span><span>filter</span><span>(|</span><span>p</span><span>| p.radius &lt; </span><span>50.0</span><span>)
    .</span><span>group_by</span><span>(|</span><span>p</span><span>| p.time.</span><span>date</span><span>())
    .</span><span>into_iter</span><span>()
    .</span><span>map</span><span>(|(</span><span>d</span><span>, </span><span>p</span><span>)| (d, p.collect::&lt;Vec&lt;_&gt;&gt;()))
    .collect::&lt;Vec&lt;_&gt;&gt;();
</span></code></pre>
<p>Run them through OSRM:</p>
<pre><code data-lang="rust"><span>let</span><span> osrm_client = osrm::OsrmClient::new(&#34;</span><span>http://127.0.0.1:5000/</span><span>&#34;.</span><span>to_string</span><span>());
</span><span>let</span><span> routes = points
    .</span><span>into_par_iter</span><span>()
    .</span><span>filter_map</span><span>(|(</span><span>date</span><span>, </span><span>points</span><span>)| {
        osrm_client
            .</span><span>match_map</span><span>(&#34;</span><span>foot</span><span>&#34;, &amp;points)
            .</span><span>ok</span><span>()
            .</span><span>map</span><span>(|</span><span>m</span><span>| (date, m))
    })
    .collect::&lt;Vec&lt;_&gt;&gt;();
</span></code></pre>
<p>I&#39;m using <a href="https://crates.io/crates/rayon"><code>rayon</code></a> here in order to do multiple requests to OSRM at once.
It would be very inconsiderate to do this against another server, but I&#39;m running my own instance in Docker.</p>
<p>Rasterize the routes for every date into a corresponding image:</p>
<pre><code data-lang="rust"><span>let mut</span><span> images = routes
    .</span><span>into_par_iter</span><span>()
    .</span><span>map</span><span>(|(</span><span>date</span><span>, </span><span>mls</span><span>)| {
        </span><span>let</span><span> raster_name = format!(&#34;</span><span>{date}</span><span>.png</span><span>&#34;);
        </span><span>let</span><span> file = File::create(&amp;raster_name)?;
        </span><span>rasterize_route</span><span>(&amp;rasterize_options, file, mls)?;
        Ok(raster_name)
    })
    .collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?;
</span></code></pre>
<p>Again, this uses <code>rayon</code> for parallelization.
Since I mentioned the memory usage before, there is one subtle issue here.
Every running thread will rasterize some tracks into a layer, so the memory usage will depend on the available concurrency.
If some computation takes, say, 1 GB RAM, that&#39;s not too bad until you start 32 of them at once.
So remember to pair CPUs with many cores with an appropriate amount of RAM, even if it sits mostly unused.</p>
<p>Then we finally run the accumulation step:</p>
<pre><code data-lang="rust"><span>images.</span><span>sort_unstable</span><span>();
</span><span>accumulate_images</span><span>(bbox, &amp;images)?;
</span></code></pre>
<p>And just one thing left to do:</p>
<pre><code><span>ffmpeg -framerate 15 -pattern_type glob -i &#39;*.png&#39; -c:v libwebp_anim -lossless 1 -quality 100 gps_tracks.webp
</span></code></pre>
<p>You can see the result below:</p>
<p><a href="https://blog.dend.ro/assets/gps-tracks.webp" target="_blank"><img src="https://blog.dend.ro/assets/gps-tracks.webp"/></a></p>
<h2 id="performance">Performance</h2>
<p>I&#39;ve only done rough measurements, but the whole process (except running <code>ffmpeg</code> at the end) takes 4.5 seconds on my system.
Replacing <code>into_par_iter</code> with <code>into_iter</code> brings that up to 10.5 seconds.</p>
<p>Out of the 4.5 s, calling into OSRM takes 1.3 s (6.5 s serially).
The rest of the time is spent in rasterization (which is quite fast), and PNG compression and decompression.</p>
<h2 id="closing-words">Closing words</h2>
<p>If you&#39;ve followed through, thank you for reading.
You can find the code <a href="https://github.com/lnicola/walker">on GitHub</a>.
Props also to the <a href="https://georust.org/">GeoRust</a> community, which owns all the geospatial-related crates I&#39;ve used here.</p>
<p><em>Map data from <a href="https://openstreetmap.org/copyright">OpenStreetMap</a></em></p>

</div>

        </div></div>
  </body>
</html>
