<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nochlin.com/blog/6-techniques-i-use-to-create-a-great-user-experience-for-shell-scripts">Original</a>
    <h1>Techniques I use to create a great user experience for shell scripts</h1>
    
    <div id="readability-page-1" class="page"><article><blockquote><p>&#34;You should go and check out the shell script in the repo because it&#39;s very nice. It has colored output, it&#39;s super safe... it&#39;s really a masterclass in terms of writing shell scripts.&#34;</p></blockquote><p>Thank you Gunnar Morling for the shout-out! üòä</p><p>In January 2024, I along with a few dozen performance-minded geeks got nerd-sniped into participating in Gunnar&#39;s One Billion Row Challenge 1Ô∏è‚É£üêùüèéÔ∏è .</p><p>Gunnar quickly became overwhelmed being the (unpaid) evaluator of a constant stampede of entries. I jumped in to help him automate the evaluation steps with a shell script and received the above testimonial from Gunnar at his Javazone talk (check it out to hear all about the performance techniques used in the challenge: <a href="https://vimeo.com/1006554858">&#34;# 1BRC‚ÄìNerd Sniping the Java Community - Gunnar Morling&#34;</a>).</p><p>Here are 6 techniques I used in the #1BRC shell script to make it robust, safe and fun for Gunnar to use:</p><h2 id="1.-comprehensive-error-handling-and-input-validation"><span>
        <a aria-label="link to this heading" aria-describedby="1. Comprehensive Error Handling and Input Validation" href="#1.-comprehensive-error-handling-and-input-validation">
            <i></i>
        </a>
    </span><span>1. Comprehensive Error Handling and Input Validation</span></h2><p>I believe that clear error messages are crucial for a good user experience. That&#39;s why I implemented thorough error handling and input validation throughout the script. For example:</p><pre><code><span>if</span> <span>[</span> <span>-z</span> <span>&#34;<span>$1</span>&#34;</span> <span>]</span> 
  <span>then</span> 
    <span>echo</span> <span>&#34;Usage: evaluate.sh &lt;fork name&gt; (&lt;fork name 2&gt; ...)&#34;</span> 
    <span>echo</span> <span>&#34; for each fork, there must be a &#39;calculate_average_&lt;fork name&gt;.sh&#39; script and an optional &#39;prepare_&lt;fork name&gt;.sh&#39;.&#34;</span> 
    <span>exit</span> <span>1</span> 
<span>fi</span>
</code></pre>

<p>This approach helps users quickly identify and resolve issues, saving them time and frustration.</p><h2 id="2.-clear-and-colorful-output"><span>
        <a aria-label="link to this heading" aria-describedby="2. Clear and Colorful Output" href="#2.-clear-and-colorful-output">
            <i></i>
        </a>
    </span><span>2. Clear and Colorful Output</span></h2><p>To make the script&#39;s output more readable and user-friendly, I used ANSI color codes to highlight important information, warnings, and errors. For instance:</p><pre><code><span>BOLD_RED</span><span>=</span><span>&#39;\033[1;31m&#39;</span>
<span>RESET</span><span>=</span><span>&#39;\033[0m&#39;</span>
<span>echo</span> <span>-e</span> <span>&#34;<span>${BOLD_RED}</span>ERROR<span>${RESET}</span>: ./calculate_average_<span>$fork</span>.sh does not exist.&#34;</span> <span>&gt;</span><span>&amp;2</span>
</code></pre>

<p>This visual distinction helps users quickly grasp the nature of each message.</p><h2 id="3.-detailed-progress-reporting"><span>
        <a aria-label="link to this heading" aria-describedby="3. Detailed Progress Reporting" href="#3.-detailed-progress-reporting">
            <i></i>
        </a>
    </span><span>3. Detailed Progress Reporting</span></h2><p>I wanted users to understand exactly what the script was doing at each step. To achieve this, I implemented a function that prints each command before executing it:</p><pre><code><span>function</span> <span>print_and_execute</span><span>(</span><span>)</span> <span>{</span>
  <span>echo</span> <span>&#34;+ <span>$@</span>&#34;</span> <span>&gt;</span><span>&amp;2</span> 
  <span>&#34;<span>$@</span>&#34;</span> 
<span>}</span>
</code></pre>

<p>This matches the output format of Bash&#39;s builtin <code>set -x</code> tracing, but gives the script author more granular control of what is printed.</p><p>This level of transparency not only keeps users informed but also aids in debugging if something goes wrong.</p><h2 id="4.-strategic-error-handling-with-&#34;set-e&#34;-and-&#34;set-+e&#34;"><span>
        <a aria-label="link to this heading" aria-describedby="4. Strategic Error Handling with &#34;set -e&#34; and &#34;set +e&#34;" href="#4.-strategic-error-handling-with-&#34;set-e&#34;-and-&#34;set-+e&#34;">
            <i></i>
        </a>
    </span><span>4. Strategic Error Handling with &#34;set -e&#34; and &#34;set +e&#34;</span></h2><p>I wanted to ensure that the script would exit immediately if there was an error in the script itself, but also allow it to continue running if individual forks encountered issues. To achieve this, I used the Bash options &#34;set -e&#34; and &#34;set +e&#34; strategically throughout the script. Here&#39;s how I implemented this technique:</p><pre><code>
<span>set</span> <span>-eo</span> pipefail


<span>for</span> <span>fork</span> <span>in</span> <span>&#34;<span>$@</span>&#34;</span><span>;</span> <span>do</span>
  <span>set</span> +e 

  
  print_and_execute <span>source</span> <span>&#34;./prepare_<span>$fork</span>.sh&#34;</span>

  
  print_and_execute <span>$TIMEOUT</span> ./test.sh <span>$fork</span>

  
<span>done</span>
<span>set</span> <span>-e</span>  
</code></pre>

<p>This approach gives the script author fine-grained control over which errors cause the script to exit and which can be handled in other ways.</p><h2 id="5.-platform-specific-adaptations"><span>
        <a aria-label="link to this heading" aria-describedby="5. Platform-Specific Adaptations" href="#5.-platform-specific-adaptations">
            <i></i>
        </a>
    </span><span>5. Platform-Specific Adaptations</span></h2><p>Knowing that users might run this script on different operating systems, I added logic to detect the OS and adjust the script&#39;s behavior accordingly:</p><pre><code><span>if</span> <span>[</span> <span>&#34;<span><span>$(</span><span>uname</span> <span>-s</span><span>)</span></span>&#34;</span> <span>==</span> <span>&#34;Linux&#34;</span> <span>]</span><span>;</span> <span>then</span> 
  <span>TIMEOUT</span><span>=</span><span>&#34;timeout -v <span>$RUN_TIME_LIMIT</span>&#34;</span> 
<span>else</span> 
  <span>if</span> <span>[</span> <span>-x</span> <span>&#34;<span><span>$(</span><span>command</span> <span>-v</span> gtimeout<span>)</span></span>&#34;</span> <span>]</span><span>;</span> <span>then</span> 
    <span>TIMEOUT</span><span>=</span><span>&#34;gtimeout -v <span>$RUN_TIME_LIMIT</span>&#34;</span>
  <span>else</span> 
    <span>echo</span> <span>-e</span> <span>&#34;<span>${BOLD_YELLOW}</span>WARNING<span>${RESET}</span> gtimeout not available, install with <span><span>`</span>brew <span>install</span> coreutils<span>`</span></span> or benchmark runs may take indefinitely long.&#34;</span> 
  <span>fi</span>
<span>fi</span>
</code></pre>

<p>This ensures a consistent experience across different environments. Many #1BRC participants were developing on MacOS while the evaluation machine ran linux for example.</p><h2 id="6.-timestamped-file-outputs-for-multiple-runs"><span>
        <a aria-label="link to this heading" aria-describedby="6. Timestamped File Outputs for Multiple Runs" href="#6.-timestamped-file-outputs-for-multiple-runs">
            <i></i>
        </a>
    </span><span>6. Timestamped File Outputs for Multiple Runs</span></h2><p>To support multiple benchmark runs without overwriting previous results, I implemented a system of timestamped file outputs. This allows users to run the script multiple times and keep a historical record of all results. Here&#39;s how I did it:</p><pre><code><span>filetimestamp</span><span>=</span><span><span>$(</span><span>date</span> +<span>&#34;%Y%m%d%H%M%S&#34;</span><span>)</span></span>


<span>HYPERFINE_OPTS</span><span>=</span><span>&#34;--warmup 0 --runs <span>$RUNS</span> --export-json <span>$fork</span>-<span>$filetimestamp</span>-timing.json --output ./<span>$fork</span>-<span>$filetimestamp</span>.out&#34;</span>


<span>echo</span> <span>&#34;Raw results saved to file(s):&#34;</span>
<span>for</span> <span>fork</span> <span>in</span> <span>&#34;<span>$@</span>&#34;</span><span>;</span> <span>do</span>
  <span>if</span> <span>[</span> <span>-f</span> <span>&#34;<span>$fork</span>-<span>$filetimestamp</span>-timing.json&#34;</span> <span>]</span><span>;</span> <span>then</span>
      <span>cat</span> <span>$fork</span>-<span>$filetimestamp</span>-timing.json <span>&gt;&gt;</span> <span>$fork</span>-<span>$filetimestamp</span>.out
      <span>rm</span> <span>$fork</span>-<span>$filetimestamp</span>-timing.json
  <span>fi</span>

  <span>if</span> <span>[</span> <span>-f</span> <span>&#34;<span>$fork</span>-<span>$filetimestamp</span>.out&#34;</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>&#34;  <span>$fork</span>-<span>$filetimestamp</span>.out&#34;</span>
  <span>fi</span>
<span>done</span>
</code></pre>

<p>--</p><p>Check out the complete benchmark evaluation script in the #1BRC repo: <a href="https://github.com/gunnarmorling/1brc/blob/main/evaluate.sh">evaluate.sh</a></p><p>By implementing these techniques, I aimed to create a user-friendly, informative, and robust shell script that provides a great experience for users running and analyzing benchmarks. I hope these ideas inspire you to enhance the user experience in your own shell scripts!</p><p>I&#39;d love to hear your thoughts on these shell scripting techniques or any other tips you have for creating great user experiences in scripts. Feel free to join the discussion:</p><ul><li>On Hacker News: <a href="https://news.ycombinator.com/item?id=41512899">Discuss this post on Hacker News</a></li><li>On Twitter: <a href="https://x.com/jasonnochlin/status/1833903787251318798">Share your thoughts on Twitter</a></li></ul></article></div>
  </body>
</html>
