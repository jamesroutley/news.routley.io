<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://healeycodes.com/generating-mazes">Original</a>
    <h1>Generating Mazes</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>I&#39;ve been reading about mazes and how to generate them. The type of mazes I&#39;ll be talking about are 2D grids of connected cells. They&#39;re <em>perfect mazes</em> (i.e. there is exactly one unique path between any two cells aka a uniform spanning tree). I&#39;ll refer to the connections between cells as <em>edges</em>. An edge can be created between a cell and any of its neighbors (up, right, left, down). When two cells don&#39;t share an edge, there is a wall between them. While generating a maze, if a cell isn&#39;t reachable, I&#39;ll render it dark.</p><center><canvas width="170" height="170"></canvas><canvas width="170" height="170"></canvas><p><small>Left: user-facing maze view. Right: debug view.</small></p></center><p>A maze begins as a grid of unconnected cells. All dark. When we start connecting the cells, we create the maze.</p><p>The above visual was created with the following code.</p><pre><div><div><p><span>const</span><span> maze </span><span>=</span><span> </span><span>new</span><span> </span><span>Maze</span><span>(</span><span>2</span><span>,</span><span> </span><span>2</span><span>)</span><span>;</span><span></span></p><p><span></span><span>const</span><span> </span><span>A</span><span> </span><span>=</span><span> maze</span><span>.</span><span>getCell</span><span>(</span><span>0</span><span>,</span><span> </span><span>0</span><span>)</span><span></span></p><p><span></span><span>const</span><span> </span><span>B</span><span> </span><span>=</span><span> maze</span><span>.</span><span>getCell</span><span>(</span><span>1</span><span>,</span><span> </span><span>0</span><span>)</span><span></span></p><p><span></span><span>const</span><span> </span><span>C</span><span> </span><span>=</span><span> maze</span><span>.</span><span>getCell</span><span>(</span><span>1</span><span>,</span><span> </span><span>1</span><span>)</span><span></span></p><p><span></span><span>const</span><span> </span><span>D</span><span> </span><span>=</span><span> maze</span><span>.</span><span>getCell</span><span>(</span><span>0</span><span>,</span><span> </span><span>1</span><span>)</span></p></div></div></pre><p>With our new maze, we can start carving edges between the four cells.</p><pre><div><div><p><span>A</span><span>.</span><span>carveEdge</span><span>(</span><span>B</span><span>)</span><span></span></p><p><span></span><span>B</span><span>.</span><span>carveEdge</span><span>(</span><span>C</span><span>)</span><span></span></p><p><span></span><span>C</span><span>.</span><span>carveEdge</span><span>(</span><span>D</span><span>)</span></p></div></div></pre><p>Finally, we can pick the two points furthest from each other for the start and end positions. In this case, we pick <code>A</code> and <code>D</code>. Later, I&#39;ll explain how to find the two furthest points in any maze.</p><pre><div><div><p><span>maze</span><span>.</span><span>start </span><span>=</span><span> </span><span>A</span><span></span></p><p><span>maze</span><span>.</span><span>end </span><span>=</span><span> </span><span>D</span></p></div></div></pre><h2 id="aldous-broder">Aldous Broder</h2><p>To automate our maze creation process, we can reach for one of the many <a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm">maze generation algorithms</a>. To start, I&#39;ve chosen Aldous Broder because it&#39;s the easiest to code. It uses a random walk-based method to visit every cell, and it&#39;s likely the most frustrating to watch.</p><p>Though inefficient (it revisits cells already part of the maze during generation), it creates an unbiased maze. This means that every possible maze of a given size is equally likely to be generated.</p><center><canvas width="330" height="330"></canvas></center><p>You may be able to reverse engineer the algorithm by simply watching the maze generation. To define it very simply: walk around and connect unconnected cells.</p><pre><div><div><p><span>const</span><span> visited </span><span>=</span><span> </span><span>new</span><span> </span><span>Set</span><span>&lt;</span><span>Cell</span><span>&gt;</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span></span><span>// Choose a random starting cell</span><span></span></p><p><span></span><span>let</span><span> current </span><span>=</span><span> </span><span>randomMember</span><span>(</span><span>maze</span><span>.</span><span>cells</span><span>.</span><span>flat</span><span>(</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>visited</span><span>.</span><span>add</span><span>(</span><span>current</span><span>)</span><span>;</span><span></span></p><p><span></span><span>// While there are unvisited cells</span><span></span></p><p><span></span><span>while</span><span> </span><span>(</span><span>visited</span><span>.</span><span>size </span><span>&lt;</span><span> maze</span><span>.</span><span>width </span><span>*</span><span> maze</span><span>.</span><span>height</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>// From the current cell, choose a random neighbour</span><span></span></p><p><span>    </span><span>const</span><span> next </span><span>=</span><span> </span><span>shuffle</span><span>(</span><span>current</span><span>.</span><span>neighbors</span><span>)</span><span>[</span><span>0</span><span>]</span><span>;</span><span></span></p><p><span>    </span><span>// If the neighbour has not been visited yet</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>!</span><span>visited</span><span>.</span><span>has</span><span>(</span><span>next</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>// Add an edge and mark as visited</span><span></span></p><p><span>        current</span><span>.</span><span>carveEdge</span><span>(</span><span>next</span><span>)</span><span>;</span><span></span></p><p><span>        visited</span><span>.</span><span>add</span><span>(</span><span>next</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>// Move to this neighbour whether or not it was visited</span><span></span></p><p><span>    current </span><span>=</span><span> next</span><span>;</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><h2 id="random-depth-first-search">Random Depth-First Search</h2><p>If we don&#39;t like the inefficiency of Aldous Broder, we can use Random Depth-First Search (DFS) to visit each cell once. By stepping from a cell to a random unvisited neighbor, we can traverse the tree.</p><center><canvas width="330" height="330"></canvas></center><p>You may recall that I described Aldous Broder as unbiased. Unfortunately, Random DFS tends to create long corridors due to the path&#39;s tendency to stick to one direction. Perhaps that&#39;s acceptable for your use case.</p><p>I&#39;ve chosen the recursive version of this algorithm because I personally find it easier to follow.</p><pre><div><div><p><span>const</span><span> visited </span><span>=</span><span> </span><span>new</span><span> </span><span>Set</span><span>&lt;</span><span>Cell</span><span>&gt;</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span></span><span>// Visit a cell and carve a path to the next cell</span><span></span></p><p><span></span><span>async</span><span> </span><span>function</span><span> </span><span>visit</span><span>(</span><span>last</span><span>:</span><span> Cell</span><span>,</span><span> next</span><span>:</span><span> Cell</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>// If the cell has already been visited, skip</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>visited</span><span>.</span><span>has</span><span>(</span><span>next</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>return</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>// Otherwise, mark the cell as visited</span><span></span></p><p><span>    visited</span><span>.</span><span>add</span><span>(</span><span>next</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>// Carve a path between the last cell and the next cell</span><span></span></p><p><span>    last</span><span>.</span><span>carveEdge</span><span>(</span><span>next</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>// Get the neighboring cells of the next cell that haven&#39;t been carved yet</span><span></span></p><p><span>    </span><span>const</span><span> neighbors </span><span>=</span><span> </span><span>shuffle</span><span>(</span><span>next</span><span>.</span><span>uncarvedEdges</span><span>(</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>// Recursively visit each neighbor</span><span></span></p><p><span>    </span><span>for</span><span> </span><span>(</span><span>const</span><span> neighbor </span><span>of</span><span> neighbors</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>await</span><span> </span><span>visit</span><span>(</span><span>next</span><span>,</span><span> neighbor</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>// Start the maze generation by visiting a random neighbor of a random cell</span><span></span></p><p><span></span><span>const</span><span> rndCell </span><span>=</span><span> </span><span>randomMember</span><span>(</span><span>maze</span><span>.</span><span>cells</span><span>.</span><span>flat</span><span>(</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span></span><span>await</span><span> </span><span>visit</span><span>(</span><span>rndCell</span><span>,</span><span> </span><span>shuffle</span><span>(</span><span>rndCell</span><span>.</span><span>neighbors</span><span>)</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span></p></div></div></pre><h2 id="wilsons-algorithm">Wilson&#39;s Algorithm</h2><p>If Aldous Broder is inefficient, and Random DFS has a long-corridor bias, then we can choose something in between. Wilson&#39;s Algorithm is unbiased like Aldous Broder, but it doesn&#39;t revisit connected cells.</p><p>Wilson&#39;s Algorithm performs a <a href="https://en.wikipedia.org/wiki/Loop-erased_random_walk">loop erased random walk</a>. The core loop is this: it starts at an unvisted random cell and randomly walks until it reaches the maze. If, during the walk, a loop is created, then that section of the loop is erased. The initial walk has to reach a random cell.</p><p>It tends to start slowly and ramp up.</p><center><canvas width="330" height="330"></canvas></center><p>A little more code is required for this one.</p><pre><div><div><p><span>const</span><span> unvisited </span><span>=</span><span> </span><span>new</span><span> </span><span>Set</span><span>&lt;</span><span>Cell</span><span>&gt;</span><span>(</span><span>maze</span><span>.</span><span>cells</span><span>.</span><span>flat</span><span>(</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span></span><span>const</span><span> visited </span><span>=</span><span> </span><span>new</span><span> </span><span>Set</span><span>&lt;</span><span>Cell</span><span>&gt;</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span></span><span>// Choose one cell arbitrarily, add it to the maze, and mark it as visited</span><span></span></p><p><span></span><span>const</span><span> startCell </span><span>=</span><span> </span><span>randomMember</span><span>(</span><span>maze</span><span>.</span><span>cells</span><span>.</span><span>flat</span><span>(</span><span>)</span><span>)</span><span></span></p><p><span>visited</span><span>.</span><span>add</span><span>(</span><span>startCell</span><span>)</span><span>;</span><span></span></p><p><span>unvisited</span><span>.</span><span>delete</span><span>(</span><span>startCell</span><span>)</span><span>;</span><span></span></p><p><span></span><span>// Continue until all cells have been visited</span><span></span></p><p><span></span><span>while</span><span> </span><span>(</span><span>unvisited</span><span>.</span><span>size </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>let</span><span> path </span><span>=</span><span> </span><span>[</span><span>]</span><span>;</span><span></span></p><p><span>    </span><span>let</span><span> current </span><span>=</span><span> </span><span>randomMember</span><span>(</span><span>unvisited</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>// Perform a random walk until reaching a cell already in the maze</span><span></span></p><p><span>    </span><span>while</span><span> </span><span>(</span><span>!</span><span>visited</span><span>.</span><span>has</span><span>(</span><span>current</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        path</span><span>.</span><span>push</span><span>(</span><span>current</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>let</span><span> next </span><span>=</span><span> </span><span>randomMember</span><span>(</span><span>current</span><span>.</span><span>uncarvedEdges</span><span>(</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>// If a loop is formed, erase that section of the path</span><span></span></p><p><span>        </span><span>const</span><span> loopIndex </span><span>=</span><span> path</span><span>.</span><span>indexOf</span><span>(</span><span>next</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>loopIndex </span><span>!==</span><span> </span><span>-</span><span>1</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            path </span><span>=</span><span> path</span><span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span><span> loopIndex </span><span>+</span><span> </span><span>1</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span></p><p><span>            path</span><span>.</span><span>push</span><span>(</span><span>next</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        current </span><span>=</span><span> next</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>// Add the path to the maze by carving edges and marking cells as visited</span><span></span></p><p><span>    </span><span>for</span><span> </span><span>(</span><span>let</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> path</span><span>.</span><span>length </span><span>-</span><span> </span><span>1</span><span>;</span><span> i</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>const</span><span> cell </span><span>=</span><span> path</span><span>[</span><span>i</span><span>]</span><span>;</span><span></span></p><p><span>        </span><span>const</span><span> nextCell </span><span>=</span><span> path</span><span>[</span><span>i </span><span>+</span><span> </span><span>1</span><span>]</span><span>;</span><span></span></p><p><span>        cell</span><span>.</span><span>carveEdge</span><span>(</span><span>nextCell</span><span>)</span><span>;</span><span></span></p><p><span>        visited</span><span>.</span><span>add</span><span>(</span><span>cell</span><span>)</span><span>;</span><span></span></p><p><span>        unvisited</span><span>.</span><span>delete</span><span>(</span><span>cell</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>I&#39;ve read in a few places that Wilson&#39;s Algorithm is faster than Aldous Broder at generating mazes; I&#39;ve found this to be true in my brief tests. However, I haven&#39;t found this to be proven with any rigor. I also <a href="https://news.ycombinator.com/item?id=2124503">read</a> that starting with Aldous Broder and then switching to Wilson&#39;s Algorithm (reasoning: Aldous Broder is slow at the end, Wilson&#39;s Algorithm is slow at the start) is faster than either. However, I haven&#39;t seen proof that this combination still results in a uniform spanning tree (where all possible mazes have equal probability).</p><h2 id="finding-the-two-furthest-points">Finding The Two Furthest Points</h2><p>You may have noticed in these visualizations that the start and end positions (<code>S</code> and <code>E</code>) are added once the maze is complete. Usually, start and end positions are placed by the author of a handcrafted maze. They have meaning. For the mazes I’ve been generating, I simply pick the two furthest points.</p><p>The strategy for finding the two furthest points involves running two breadth-first searches while tracking the distance from the root cell in each search.</p><ol start="1"><li>Choose a random starting cell <code>A</code></li><li>BFS with <code>A</code> as root
<ul><li>Mark the furthest point from <code>A</code> as <code>B</code></li></ul></li><li>BFS with <code>B</code> as root
<ul><li>Mark the furthest point from <code>B</code> as <code>C</code></li></ul></li><li>The two furthest points are <code>B</code> and <code>C</code></li></ol><p>The start and end positions are then chosen randomly from these two points.</p><center><canvas width="340" height="340"></canvas><p><small>Finding the start and end cells via tree diameter.</small></p></center><p>I suspect there is a way to figure out the start and end positions while also generating a maze. Perhaps not for all of the algorithms we covered. It <em>feels</em> possible.</p><p>As for resources, I found most of my jumping off points on the Wikipedia page <a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm">Maze generation algorithm</a>. Searching for maze algorithms usually turns up academic resources (with mixed levels of accessibility).</p><p>The code for all the visuals and algorithms can be found in the source of this website, specifically in the <a href="https://github.com/healeycodes/healeycodes.com/tree/main/components/visuals/mazes">mazes directory</a>. The mazes are rendered with <code>&lt;canvas&gt;</code> elements.</p></div></div></div>
  </body>
</html>
