<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://johnwhiles.com/posts/programming-as-theory">Original</a>
    <h1>A software epiphany</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Even though I don&#39;t respect podcasts as an information delivery system, I recently listened to a podcast that felt like having an epiphany.</p>
<p>The podcast in question was <a href="https://futureofcoding.org/episodes/061">episode 61 of Future of Coding</a>. It is essentially a read-through/review of two papers with which I was unfamiliar, but which I believe are actually quite famous and influential.</p>
<p>Why did listening to this feel like an epiphany? Well, I suddenly felt like I understood what the deal is with software. Why is it that when you join a company, the engineer who&#39;s been there for years seems like an incredible genius? Why do some teams that I&#39;ve been on struggle while others manage to get everything right? Why is everyone always so keen to rewrite things?</p>
<p>The two ideas that the podcast expresses are:</p>
<ul>
<li>The concept of what a “Theory” is, according to Gilbert Ryle.</li>
<li>That being a programmer is doing “Building theories” in the Ryle sense of the word.</li>
</ul>
<p>Having these two ideas explained together was really helpful. If I had read Ryle by himself, I would have thought, “interesting and useless”. If I had read Programming as Theory Building without knowing the theory concept, I would just not have understood.</p>
<p>I recommend listening to the podcast and reading the paper. But if you don&#39;t want to do that, I&#39;m going to try and explain the two points.</p>
<p><img src="https://images.ctfassets.net/wc253zohgsra/6FneKfEWuMP1Ke9omenPf2/975978d3070f8b4fa87b74882ef15804/jwhiles_httpss.mj.run55zU4CdGTuk_httpss.mj.run5FGx1NzXTpY_htt_466bc4eb-d727-45fd-8545-3bc6eb2951b6_3.png?w=800&amp;fm=webp" alt="strange" figure=""/></p>
<hr/>
<h2>What is a Theory, According to Gilbert Ryle?</h2>
<p>When Ryle says theory, he doesn&#39;t mean anything like what other people mean when they say theory. Annoying. He should have just come up with a new word.
What he means is the thought object that exists in our minds which allows us to do things.</p>
<p>I, for example, know how to cook pasta. When I cook pasta, that&#39;s a certain expression of this knowledge. When I try and explain to you how to cook pasta, that&#39;s a different expression of it. Neither of those expressions contains everything I know about cooking pasta. And in fact, there are parts of what I know that I can&#39;t really express in any way. This knowledge is what Ryle would call a theory. I have a “Theory of how to cook pasta”. This theory is not something that exists in language or action - it’s a <em>something</em> that we can never fully express. The closest we can get to transferring a theory is to demonstrate the expression of the Theory to someone over and over again until they build their own theory. That theory won&#39;t be the same as ours.</p>
<h2>What Does it Mean that Programming is Theory Building?</h2>
<p>It means that the code base we create is not the true product of our work. The real product is the mental theory of that code base which:</p>
<ul>
<li>Allowed us to create it in the first place.</li>
<li>Allows us to diagnose problems with it and fix them.</li>
<li>Allows us to modify it easily.</li>
</ul>
<p>If I think about times when I&#39;ve worked on a team that works well and gets stuff done, it&#39;s been a team where:</p>
<ul>
<li>Someone has been there for a long time, since the start of whatever code base/feature we work on.</li>
<li>Other team members have joined slowly, and had a chance to work with the people who know more.</li>
<li>The area of focus does not change. We haven&#39;t been reassigned to a random existing project, or asked to fix some other team’s work.</li>
</ul>
<p>The paper also talks about what happens when all the people who have a theory of a given program stop working on it. It <em>dies</em>. Yikes. It’s claimed that we can’t rebuild a theory from code and documentation. </p>
<p>This model explains a few curious phenomena:</p>
<ul>
<li>What “legacy code” actually is - it’s a code base which is no longer maintained by people who have a theory of it.</li>
<li>The solo engineer who can make a better product than a team of equally competent professionals. The solo engineer has spent the time to build a complete theory of their program, the professionals move between projects regularly - and only have theories of what they&#39;ve worked on.</li>
<li>Why getting up to speed with unfamiliar projects is so much harder than just rebuilding the thing. To truly build a theory, you need to mentally rebuild the existing code base anyway.</li>
<li>Why outsourcing, or hiring contractors, always seems to go so badly.</li>
</ul>
<p><img src="https://images.ctfassets.net/wc253zohgsra/2jJwD4Uw8zGYBBK0CnGBw5/8e0ecf35c5cc6ef8f8931a57c3cf821e/jwhiles_a_painting_of_the_moon_attacking_the_earth_in_the_sty_1826cf7c-7415-4be2-b9af-86c1372c06ea_2.png?w=800&amp;fm=webp" alt="Moon" kill="" sun=""/></p>
<hr/>
<h2>What You Can Learn from This</h2>
<p>Retention of software engineers is really important!!!</p>
</div></div>
  </body>
</html>
