<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rubrikinc.github.io/wachy/">Original</a>
    <h1>Show HN: Wachy – A UI for eBPF-based performance debugging</h1>
    
    <div id="readability-page-1" class="page">
  <div>
    <div>
      <div>
        <div>
          <p><img src="https://rubrikinc.github.io/wachy/logo.png" alt="Logo"/></p>
        </div>
        <p>
          Trace arbitrary compiled binaries and functions on Linux, at runtime with 0 modifications.
        </p>
      </div>

      <div>
        <div>
          <div>
            <dl>
              <div>
                <dt>
                  
                  <p>Low overhead dynamic instrumentation</p>
                </dt>
                <dd>
                  Wachy uses the magic of eBPF to dynamically instrument binaries with minimal overhead. This also means
                  there is 0 overhead for untraced functions.
                </dd>
              </div>

              <div>
                <dt>
                  
                  <p>Deep code integration</p>
                </dt>
                <dd>
                  eBPF on its own can be difficult and time-consuming to use. The goal of wachy is to make userspace
                  eBPF tracing 10-100x faster and easier by connecting it back to your source code.
                </dd>
              </div>

              <div>
                <dt>
                  
                  <p>Understand real latencies</p>
                </dt>
                <dd>
                  Stack sampling profilers only provide part of the picture as they usually show the proportion of
                  active CPU cycles.
                  With wachy, you get accurate function latencies including time spent in common blocking calls like
                  waiting on network, IO or mutexes.
                  It can also gather latency histograms.
                </dd>
              </div>

              <div>
                <dt>
                  
                  <p>Powerful runtime filtering</p>
                </dt>
                <dd>
                  Add filters for conditions you want to trace. At runtime with no code changes. eBPF truly is magic.
                </dd>
              </div>
            </dl>
          </div>
        </div>
      </div>

      
    </div>
  </div>

  <section>
    <p>Watch a 3 minute demo of wachy:</p>
    <p>This is the best way to understand wachy. But if you prefer reading,
      look at the <a href="https://github.com/rubrikinc/wachy/blob/master/docs/guide.md">guide</a>.</p>
    <div>
      <p>
        <iframe src="https://www.youtube-nocookie.com/embed/L6VyQP-YDgE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
      </p>
    </div>
  </section>

  <section>
    <div>
      <h2>
        What is it good for?
      </h2>
      

      <div>
        <div>
          <dl>
            <div>
              <div>
                <dt>
                  
                  <p>Frequently executed functions</p>
                </dt>
                <dd>
                  The wachy interface displays average latency of each tracepoint, or the latency histogram of a
                  function.
                  If you have something like an RPC or web server with frequent requests, this works great for
                  understanding latency, down to the level of individual functions.
                </dd>
              </div>

              <div>
                <dt>
                  
                  <p>Interactive debugging with filtering</p>
                </dt>
                <dd>
                  Wachy maintains a stack of functions being traced, which lends itself well to iterative exploration of
                  nested functions.
                  You can also specify custom filters.
                  Want to only see the latency of function B called from function A where A&#39;s first argument is 0? No
                  problem.
                </dd>
              </div>

              <div>
                <dt>
                  
                  <p>Understanding tail latencies</p>
                </dt>
                <dd>
                  Wachy allows specifying runtime filters to understand program behavior under various conditions.
                  For example, where is the time spent inside a function when it takes longer than 100ms to execute?
                </dd>
              </div>

              <div>
                <dt>
                  
                  <p>Debugging in production</p>
                </dt>
                <dd>
                  There&#39;s often some performance issue which only occurs in production.
                  And yeah, sure you follow all the best practices but sometimes the best way to debug it is just to get
                  in there and examine at what&#39;s happening live.
                  eBPF guarantees that any tracing you do is completely safe (I&#39;m looking at you, gdb) with the only
                  side effect being minor tracing overhead.
                  Wachy&#39;s TUI is designed with this use case in mind – there&#39;s no need to forward ports, all you need is
                  an SSH connection to the machine you want to debug on.
                </dd>
              </div>
            </div>

            <div>
              <div>
                <dt>
                  
                  <p>Debugging on arbitrary platforms</p>
                </dt>
                <dd>
                  Necessary eBPF features are only available on Linux 4.6 or later kernels.
                </dd>
              </div>

              <div>
                <dt>
                  
                  <p>Debugging arbitrary languages</p>
                </dt>
                <dd>
                  Wachy relies on eBPF uprobes and debugging symbols, which only work for compiled languages.
                  C++ symbol demangling for displaying human-readable function names is also supported.
                </dd>
              </div>

              <div>
                <dt>
                  
                  <p>Debugging extremely latency-sensitive
                    code</p>
                </dt>
                <dd>
                  While eBPF overhead is fairly low, there is some overhead – in my measurements, about 3μs per traced
                  function call.
                  For functions that take less time than that and are frequently called, this may be unacceptable and
                  wachy&#39;s precision will not be good enough.
                </dd>
              </div>
            </div>
          </dl>
        </div>
      </div>
    </div>
  </section>

  


</div>
  </body>
</html>
