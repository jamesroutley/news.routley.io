<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://essenceia.github.io/projects/alibaba_cloud_fpga/">Original</a>
    <h1>Alibaba cloud FPGA: the $200 Kintex UltraScale&#43;</h1>
    
    <div id="readability-page-1" class="page"><div><div><h2>Introduction<span><a href="#introduction" aria-label="Anchor">#</a></span></h2><p>I was recently in the market for a new FPGA to start building my upcoming projects on.</p><p>Due to the scale of my upcoming projects a Xilinx series 7 UltraScale+ FPGA of the Virtex family would be perfect,
but a Kintex series FPGA will be sufficient for early prototyping.
Due to not wanting to part ways with the eye watering amounts of money that is
required for an Vivado enterprise edition license
my choice was effectively narrowed to the FPGA chips available under the WebPack version of Vivado.</p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/xilinx_doc.png" alt="Xilinx supported boards per vivado edition"/><figcaption>Xilinx supported boards per Vivado edition</figcaption></figure><p>Unsurprisingly Xilinx are well aware of how top of the range the Virtex series are,
and doesn’t offer any Virtex UltraScale+ chips with the webpack license.
That said, they do offer support for two very respectable Kintex UltraScale+ FPGA models, the <code>XCKU3P</code> and the <code>XCKU5P</code>.</p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/fpga_kintex.png" alt="Xiling product guide, overview for the Kintex UltraScale+ series"/><figcaption>Xiling product guide, overview for the Kintex UltraScale+ series</figcaption></figure><p>These two chips are far from being small hobbyist toys, with the smaller <code>XCUK3P</code> already boasting +162K LUTs and
16 GTY transceivers, capable, depending on the physical constraints imposed by the chip packaging of
operating at up to 32.75Gb/s.</p><p>Now that the chip selection has been narrowed down I set out to look for a dev board.</p><p>My requirements for the board where that it featured :</p><ul><li>at least 2 SFP+ or 1 QSFP connector</li><li>a JTAG interface</li><li>a PCIe interface at least x8 wide</li></ul><p>As to where to get the board from, my options where :</p><ol><li>Design the board myself</li><li>Get the AXKU5 or AXKU3 from Alinx</li><li>See what I could unearth on the second hand market</li></ol><p>Although option <code>1</code> could have been very interesting, designing a
dev board with both a high speed PCIe and ethernet interface was not the goal of
today’s project.</p><p>As for option <code>2</code>,
Alinx is newer vendor that is still building up its credibility in the west,
their technical documentation is a bit sparse, but the feedback seems to be positive with no major issues being reported.
Most importantly, Alinx provided very fairly priced development boards
in the 900 to 1050 dollar range ( +150$ for the HPC FMC SFP+ extension board ).
Although these are not cheap by any metric, compared to the competitions
price point, they are the best value.</p><p>Option <code>2</code> was coming up ahead until I stumbled upon this ebay listing :</p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/ebay.png" alt="Ebay listing for a decommissioned Alibaba Cloud accelerator FPGA"/><figcaption>Ebay listing for a decommissioned Alibaba Cloud accelerator FPGA</figcaption></figure><p>For 200$ this board featured a <code>XCKU3P-FFVB676</code>, 2 SPF+ connector and a x8 PCIe interface.
On the flip side it came with no documentation whatsoever, no guaranty it worked, and the
faint promise in the listing that there was a JTAG interface.
A sane person would likely have dismissed this as an interesting internet oddity, a remanence
of what happens when a generation of accelerator cards gets phased out in favor of the next,
or maybe just an expensive paperweight.</p><p>But I like a challenge, and the appeal of unlocking the 200$ Kintex UltraScale+ development board
was too great to ignore.</p><p>As such, I aim for this article to become the documentation paving the way to though this mirage.</p><h2>The debugger challenge<span><a href="#the-debugger-challenge" aria-label="Anchor">#</a></span></h2><p>Xilinx’s UG908 Programming and Debugging User Guide (Appendix D) specifies their blessed JTAG probe ecosystem for FPGA configuration and debug. Rather than dropping $100+ on yet another proprietary dongle that’ll collect dust after the project ends, I’m exploring alternatives.
The obvious tradeoff: abandoning Xilinx’s toolchain means losing ILA integration. However, the ILA fundamentally just captures samples and streams them via JTAG USER registers, there’s nothing preventing us from building our own logic analyzer with equivalent functionality and a custom host interface.</p><p>Enter OpenOCD. While primarily targeting ARM/RISC-V SoCs, it maintains an impressive database of supported probe hardware and provides granular control over JTAG operations. More importantly, it natively supports SVF (Serial Vector Format), a vendor-neutral bitstream format that Vivado can export.</p><p>The documentation landscape is admittedly sparse for anything beyond 7-series FPGAs, and the most recent OpenOCD documentation I could unearth was focused on Zynq ARM core debugging rather than fabric configuration. But the fundamentals remain sound: JTAG is JTAG, SVF is standardized, and the boundary scan architecture hasn’t fundamentally changed.</p><p>The approach should be straightforward: generate SVF from Vivado, feed it through OpenOCD with a commodity JTAG adapter, and validate the configuration. Worst case, we’ll need to patch some adapter-specific quirks or boundary scan chain register addresses.
Time to find out if this theory holds up in practice.</p><h2>The plan<span><a href="#the-plan" aria-label="Anchor">#</a></span></h2><p>So, to resume, the current plan is to buy a second hand hardware accelerator of eBay at a too good to be true price, and try to configure it
with an unofficial probe using open source software without any clear official support.</p><p>As such, we need a plan for approaching this.
The goal of this plan is to outline incremental steps that will build upon themselves with the end goal of being able to use this as a dev board.</p><h3>1 - Confirming the board works<span><a href="#1---confirming-the-board-works" aria-label="Anchor">#</a></span></h3><p>First order of business will be to confirm the board is showing signs of working as intended.</p><p>There is a high probability that the flash wasn’t wiped before this board was sold off, as such the previous bitstream should
still be in the flash.
Given this board was used as an accelerator, we should be able to use that to confirm the board is working by either checking if
the board is presenting itself as a PCIe endpoint or if the SFP’s are sending the ethernet PHY idle sequence.</p><h3>2 - Connecting a debugger to it<span><a href="#2---connecting-a-debugger-to-it" aria-label="Anchor">#</a></span></h3><p>The next step is going to be to try and connect the debugger.
The eBay listing advertised there is a JTAG interface, but the picture is grainy enough that where that JTAG is and what pins are
available is unclear.</p><p>Additionally, we have no indication of what devices are daisy chained together onto the JTAG scan chain.
This is an essential question for flashing over JTAG, so it will need to be figured out.</p><p>At this point, it would also be strategic to try and do some more probing into the FPGA via JTAG.
Xilinx FPGAs
exposes a handful of useful system registers accessible over JTAG. The most well known of these interfaces is the
SYSMON, which allows us, among other things, to get real time temperature and voltage reading from inside the chip.
Although openOCD doesn’t have SYSMON support out of the box it would be worth while to build it, to :</p><ol><li>Familiarise myself with openOCD scripting, this might come in handy when building my ILA replacement down the line</li><li>Having an easy side channel to monitor FPGA operating parameters</li><li>Make a contribution to openOCD as it have support for the interfacing with XADC but not SYSMON</li></ol><h3>3 - Figuring out the Pinout<span><a href="#3---figuring-out-the-pinout" aria-label="Anchor">#</a></span></h3><p>The hardest part will be figuring out the FPGA’s pinout and my clock sources.
The questions that need answering are :</p><ul><li>what external clocks sources do I have, what are there frequencies and which pins are they connected to</li><li>which transceivers are the SFPs connected to</li><li>which transceivers is the PCIe connected to</li></ul><h3>4 - Writing a bitstream<span><a href="#4---writing-a-bitstream" aria-label="Anchor">#</a></span></h3><p>For now I will be focusing on writing a temporary configurations over JTAG to the CCLs and not re-writing the flash.</p><p>That plan is to trying writing either the bitstream directly though openOCD’s <code>virtex2</code> + <code>pld</code> drivers, or by replaying the
SVF generated by Vivado.</p><p>Since I believe a low iteration time is paramount to project velocity and getting big things done, I also want automatize
all of the Vivado flow from taking the rtl to the SVF generation.</p><p>Simple enough ?</p><h2>Liveness test<span><a href="#liveness-test" aria-label="Anchor">#</a></span></h2><p>A few days later my prize arrived via express mail.</p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/fpga.jpg" alt="fpga"/><figcaption>My prized Kintex UltraScale+ FPGA board also known as the decommissioned Alibaba cloud accelerator. Jammed transceiver now safely removed.</figcaption></figure><p>Unexpectedly it even came with a free 25G SFP28 Huawei transceiver rated for a 300m distance and a single 1m long OS2 fiber patch cable.
This was likely not intentional as the transceiver was jammed in the SFP cage, but it was still very generous of them to include the fiber patch cable.</p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/free_stuff.jpg" alt="Additional SFP28-25G-1310nm-300m-SM Huawei transceiver, and 1m long OS2 patch cable"/><figcaption>Free additional SFP28-25G-1310nm-300m-SM Huawei transceiver, and 1m long OS2 patch cable</figcaption></figure><p>The board also came with a travel case and half of a PCIe to USB adapter and a 12V power supply that one could use to power the board as a standalone device. Although this standalone configuration will not be of any use to me, for those looking to develop just networking interfaces without any PCIe interface, this could come in handy.</p><p>Overall the board looked a little worn, but both the transceiver cages and PCIe connectors didn’t look to be damaged.</p><h3>Standalone configuration<span><a href="#standalone-configuration" aria-label="Anchor">#</a></span></h3><p>Before real testing could start I first did a small power-up test using the PCIe to USB adapter that the seller provided.
I was able to do a quick check using the LEDs and the FPGAs dissipated heat that the board seemed to be powering up at a surface level (pun intended).</p><h3>PCIe interface<span><a href="#pcie-interface" aria-label="Anchor">#</a></span></h3><p><span><span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M506.3 417 293 53c-16.33-28-57.54-28-73.98.0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6c32.76.0 53.26-35 36.96-63zM232 168c0-13.25 10.75-24 24-24s24 10.8 24 24v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zm24 248c-17.36.0-31.44-14.08-31.44-31.44s14.07-31.44 31.44-31.44 31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z"></path></svg>
</span></span><span>As a reminder, this next section relies on the flash not having been wiped and still containing the previous user’s design.</span></p><p>Since I didn’t want to directly plug mystery hardware into my prized build server, I decided to use a Raspberry Pi 5 as
my sacrificial test device and got myself an external PCIe adapter.</p><p>It just so happened that the latest Raspberry Pi version, the Pi 5, now features an external PCIe Gen 2.0 x1 interface.
Though our FPGA can handle up to a PCIe Gen 3.0 and the board had a x8 wide interface,
since PCIe standard is backwards compatible and the number of lanes on the interface can be downgraded,
plugging our FPGA with this Raspberry Pi will work.</p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/pi.jpg" alt="FPGA board connected to the Raspberry Pi 5 via the PCIe to PCIe x1 adapter"/><figcaption>FPGA board connected to the Raspberry Pi 5 via the PCIe to PCIe x1 adapter</figcaption></figure><p>After both the Raspberry and the FPGA were booted, I SSHed into my rpi and
started looking for the PCIe enumeration sequence logged from the Linux
PCIe core subsystem.</p><p><code>dmesg</code> log :</p><pre tabindex="0"><code>[    0.388790] pci 0000:00:00.0: [14e4:2712] type 01 class 0x060400
[    0.388817] pci 0000:00:00.0: PME# supported from D0 D3hot
[    0.389752] pci 0000:00:00.0: bridge configuration invalid ([bus 00-00]), reconfiguring
[    0.495733] brcm-pcie 1000110000.pcie: link up, 5.0 GT/s PCIe x1 (!SSC)
[    0.495759] pci 0000:01:00.0: [dabc:1017] type 00 class 0x020000
</code></pre><h4>Background information<span><a href="#background-information" aria-label="Anchor">#</a></span></h4><p>Since most people might not be intimately as familiar with PCIe terminology, allow me to
quickly document what is going on here.</p><p><code>0000:00:00.0</code>: is the identifier of a specific PCIe device connected through the PCIe network
to the kernel, it read as <code>domain</code>:<code>bus</code>:<code>device</code>.<code>function</code>.</p><p><code>[14e4:2712]</code>: is the device’s <code>[vendor id:device id]</code>, these vendor id identifiers are
assigned by the PCI standard body to hardware vendors. Vendors are then free to define there
own vendor id’s.</p><p>The full list of official vendor id’s and released device id can be found : <a href="https://admin.pci-ids.ucw.cz/read/PC/14e4" target="_blank">https://admin.pci-ids.ucw.cz/read/PC/14e4</a> or in
the linux kernel code : <a href="https://github.com/torvalds/linux/blob/7aac71907bdea16e2754a782b9d9155449a9d49d/include/linux/pci_ids.h#L160-L3256" target="_blank">https://github.com/torvalds/linux/blob/7aac71907bdea16e2754a782b9d9155449a9d49d/include/linux/pci_ids.h#L160-L3256</a></p><p><code>type 01</code>: PCIe has two types of devices, bridges allowing the connection of multiple downstream devices to an
upstream device, and endpoints are the leafs.
Bridges are of type <code>01</code> and endpoints of type <code>00</code>.</p><p><code>class 0x60400</code>: is the PCIe device class, it categorizes the kind of function the device performs. It
uses the following format <code>0x[Base Class (8 bits)][Sub Class (8 bits)][Programming Interface (8 bits)]</code>,
( note : the sub class field might be unused ).</p><p>A list of class and sub class identifiers can be found: <a href="https://admin.pci-ids.ucw.cz/read/PD" target="_blank">https://admin.pci-ids.ucw.cz/read/PD</a> or again in the linux codebase : <a href="https://github.com/torvalds/linux/blob/7aac71907bdea16e2754a782b9d9155449a9d49d/include/linux/pci_ids.h#L15-L158" target="_blank">https://github.com/torvalds/linux/blob/7aac71907bdea16e2754a782b9d9155449a9d49d/include/linux/pci_ids.h#L15-L158</a></p><h4>Dmesg log<span><a href="#dmesg-log" aria-label="Anchor">#</a></span></h4><p>The two most interesting lines of the <code>dmesg</code> log are :</p><pre tabindex="0"><code>[    0.388790] pci 0000:00:00.0: [14e4:2712] type 01 class 0x060400
[    0.495759] pci 0000:01:00.0: [dabc:1017] type 00 class 0x020000
</code></pre><p>Firstly the PCIe subsystem logs that at <code>0000:00:00.0</code> it has discovered a Broadcom BCM2712 PCIe Bridge ( vendor id <code>14e4</code>, device id <code>0x2712</code> ).This bridge (type <code>01</code>) class <code>0x0604xx</code> tells us it is a PCI-to-PCI bridge, meaning it is essentially creating additional PCIe lanes downstream for endpoint devices or additional bridges.</p><p>The subsystem then discovers a second device at <code>0000:01:00.0</code>, this is an endpoint (type <code>00</code>), and class <code>0x02000</code> tells us it is an ethernet networking equipment.</p><p>As such, it is not surprising to see an unknown vendor id appear for
an FPGA, this with the class as an ethernet networking device is a strong hint this is our board.</p><h4>Full PCIe device status<span><a href="#full-pcie-device-status" aria-label="Anchor">#</a></span></h4><p>Dmesg logs have already given us a good indication that our FPGA board and its PCIe interface was working but to confirm with certainty that the device with vendor id <code>dabc</code> is our FPGA we now turn to <code>lspci</code>.
<code>lspci -vvv</code> is the most verbose output and gives us a full overview of the detected PCIe devices capabilities and current configurations.</p><p>Broadcom bridge:</p><pre tabindex="0"><code>0000:00:00.0 PCI bridge: Broadcom Inc. and subsidiaries BCM2712 PCIe Bridge (rev 21) (prog-if 00 [Normal decode])
        Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-
        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-
        Latency: 0
        Interrupt: pin A routed to IRQ 38
        Bus: primary=00, secondary=01, subordinate=01, sec-latency=0
        Memory behind bridge: [disabled] [32-bit]
        Prefetchable memory behind bridge: 1800000000-182fffffff [size=768M] [32-bit]
        Secondary status: 66MHz- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &lt;SERR- &lt;PERR-
        BridgeCtl: Parity- SERR- NoISA- VGA- VGA16- MAbort- &gt;Reset- FastB2B-
                PriDiscTmr- SecDiscTmr- DiscTmrStat- DiscTmrSERREn-
        Capabilities: [48] Power Management version 3
                Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold-)
                Status: D0 NoSoftRst+ PME-Enable- DSel=0 DScale=1 PME-
        Capabilities: [ac] Express (v2) Root Port (Slot-), MSI 00
                DevCap: MaxPayload 512 bytes, PhantFunc 0
                        ExtTag- RBE+
                DevCtl: CorrErr- NonFatalErr- FatalErr- UnsupReq-
                        RlxdOrd+ ExtTag- PhantFunc- AuxPwr+ NoSnoop+
                        MaxPayload 512 bytes, MaxReadReq 512 bytes
                DevSta: CorrErr- NonFatalErr- FatalErr- UnsupReq- AuxPwr- TransPend-
                LnkCap: Port #0, Speed 5GT/s, Width x1, ASPM L0s L1, Exit Latency L0s &lt;2us, L1 &lt;4us
                        ClockPM+ Surprise- LLActRep- BwNot+ ASPMOptComp+
                LnkCtl: ASPM Disabled; RCB 64 bytes, Disabled- CommClk-
                        ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
                LnkSta: Speed 5GT/s, Width x1
                        TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt+
                RootCap: CRSVisible+
                RootCtl: ErrCorrectable- ErrNon-Fatal- ErrFatal- PMEIntEna+ CRSVisible+
                RootSta: PME ReqID 0000, PMEStatus- PMEPending-
                DevCap2: Completion Timeout: Range ABCD, TimeoutDis+ NROPrPrP- LTR+
                         10BitTagComp- 10BitTagReq- OBFF Via WAKE#, ExtFmt- EETLPPrefix-
                         EmergencyPowerReduction Not Supported, EmergencyPowerReductionInit-
                         FRS- LN System CLS Not Supported, TPHComp- ExtTPHComp- ARIFwd+
                         AtomicOpsCap: Routing- 32bit- 64bit- 128bitCAS-
                DevCtl2: Completion Timeout: 50us to 50ms, TimeoutDis- LTR- 10BitTagReq- OBFF Disabled, ARIFwd-
                         AtomicOpsCtl: ReqEn- EgressBlck-
                LnkCap2: Supported Link Speeds: 2.5-5GT/s, Crosslink- Retimer- 2Retimers- DRS+
                LnkCtl2: Target Link Speed: 5GT/s, EnterCompliance- SpeedDis-
                         Transmit Margin: Normal Operating Range, EnterModifiedCompliance- ComplianceSOS-
                         Compliance Preset/De-emphasis: -6dB de-emphasis, 0dB preshoot
                LnkSta2: Current De-emphasis Level: -6dB, EqualizationComplete- EqualizationPhase1-
                         EqualizationPhase2- EqualizationPhase3- LinkEqualizationRequest-
                         Retimer- 2Retimers- CrosslinkRes: unsupported, DRS-
                         DownstreamComp: Link Up - Present
        Capabilities: [100 v1] Advanced Error Reporting
                UESta:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
                UEMsk:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
                UESvrt: DLP+ SDES+ TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol-
                CESta:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr-
                CEMsk:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+
                AERCap: First Error Pointer: 00, ECRCGenCap+ ECRCGenEn- ECRCChkCap+ ECRCChkEn-
                        MultHdrRecCap- MultHdrRecEn- TLPPfxPres- HdrLogCap-
                HeaderLog: 00000000 00000000 00000000 00000000
                RootCmd: CERptEn+ NFERptEn+ FERptEn+
                RootSta: CERcvd- MultCERcvd- UERcvd- MultUERcvd-
                         FirstFatal- NonFatalMsg- FatalMsg- IntMsg 0
                ErrorSrc: ERR_COR: 0000 ERR_FATAL/NONFATAL: 0000
        Capabilities: [160 v1] Virtual Channel
                Caps:   LPEVC=0 RefClk=100ns PATEntryBits=1
                Arb:    Fixed- WRR32- WRR64- WRR128-
                Ctrl:   ArbSelect=Fixed
                Status: InProgress-
                VC0:    Caps:   PATOffset=00 MaxTimeSlots=1 RejSnoopTrans-
                        Arb:    Fixed- WRR32- WRR64- WRR128- TWRR128- WRR256-
                        Ctrl:   Enable+ ID=0 ArbSelect=Fixed TC/VC=ff
                        Status: NegoPending- InProgress-
        Capabilities: [180 v1] Vendor Specific Information: ID=0000 Rev=0 Len=028 &lt;?&gt;
        Capabilities: [240 v1] L1 PM Substates
                L1SubCap: PCI-PM_L1.2+ PCI-PM_L1.1+ ASPM_L1.2+ ASPM_L1.1+ L1_PM_Substates+
                          PortCommonModeRestoreTime=8us PortTPowerOnTime=10us
                L1SubCtl1: PCI-PM_L1.2- PCI-PM_L1.1- ASPM_L1.2- ASPM_L1.1-
                           T_CommonMode=1us LTR1.2_Threshold=0ns
                L1SubCtl2: T_PwrOn=10us
        Capabilities: [300 v1] Secondary PCI Express
                LnkCtl3: LnkEquIntrruptEn- PerformEqu-
                LaneErrStat: 0
        Kernel driver in use: pcieport
</code></pre><p>FPGA board:</p><pre tabindex="0"><code>0000:01:00.0 Ethernet controller: Device dabc:1017
        Subsystem: Red Hat, Inc. Device a001
        Control: I/O- Mem- BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-
        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-
        Region 0: Memory at 1820000000 (64-bit, prefetchable) [disabled] [size=2K]
        Region 2: Memory at 1800000000 (64-bit, prefetchable) [disabled] [size=512M]
        Capabilities: [40] Power Management version 3
                Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0-,D1-,D2-,D3hot-,D3cold-)
                Status: D0 NoSoftRst+ PME-Enable- DSel=0 DScale=0 PME-
        Capabilities: [70] Express (v2) Endpoint, MSI 00
                DevCap: MaxPayload 1024 bytes, PhantFunc 0, Latency L0s &lt;64ns, L1 &lt;1us
                        ExtTag+ AttnBtn- AttnInd- PwrInd- RBE+ FLReset- SlotPowerLimit 0W
                DevCtl: CorrErr+ NonFatalErr+ FatalErr+ UnsupReq+
                        RlxdOrd+ ExtTag+ PhantFunc- AuxPwr- NoSnoop+
                        MaxPayload 512 bytes, MaxReadReq 512 bytes
                DevSta: CorrErr- NonFatalErr- FatalErr- UnsupReq- AuxPwr- TransPend-
                LnkCap: Port #0, Speed 8GT/s, Width x8, ASPM not supported
                        ClockPM- Surprise- LLActRep- BwNot- ASPMOptComp+
                LnkCtl: ASPM Disabled; RCB 64 bytes, Disabled- CommClk-
                        ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
                LnkSta: Speed 5GT/s (downgraded), Width x1 (downgraded)
                        TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-
                DevCap2: Completion Timeout: Range BC, TimeoutDis+ NROPrPrP- LTR-
                         10BitTagComp- 10BitTagReq- OBFF Not Supported, ExtFmt- EETLPPrefix-
                         EmergencyPowerReduction Not Supported, EmergencyPowerReductionInit-
                         FRS- TPHComp- ExtTPHComp-
                         AtomicOpsCap: 32bit- 64bit- 128bitCAS-
                DevCtl2: Completion Timeout: 50us to 50ms, TimeoutDis- LTR- 10BitTagReq- OBFF Disabled,
                         AtomicOpsCtl: ReqEn-
                LnkCap2: Supported Link Speeds: 2.5-8GT/s, Crosslink- Retimer- 2Retimers- DRS-
                LnkCtl2: Target Link Speed: 8GT/s, EnterCompliance- SpeedDis-
                         Transmit Margin: Normal Operating Range, EnterModifiedCompliance- ComplianceSOS-
                         Compliance Preset/De-emphasis: -6dB de-emphasis, 0dB preshoot
                LnkSta2: Current De-emphasis Level: -6dB, EqualizationComplete- EqualizationPhase1-
                         EqualizationPhase2- EqualizationPhase3- LinkEqualizationRequest-
                         Retimer- 2Retimers- CrosslinkRes: unsupported
        Capabilities: [100 v1] Advanced Error Reporting
                UESta:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
                UEMsk:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
                UESvrt: DLP+ SDES+ TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol-
                CESta:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr-
                CEMsk:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+
                AERCap: First Error Pointer: 00, ECRCGenCap- ECRCGenEn- ECRCChkCap- ECRCChkEn-
                        MultHdrRecCap- MultHdrRecEn- TLPPfxPres- HdrLogCap-
                HeaderLog: 00000000 00000000 00000000 00000000
        Capabilities: [1c0 v1] Secondary PCI Express
                LnkCtl3: LnkEquIntrruptEn- PerformEqu-
                LaneErrStat: 0
</code></pre><p>For our board, the following lines are particularly interesting:</p><pre tabindex="0"><code>                LnkCap: Port #0, Speed 8GT/s, Width x8, ASPM not supported
                        ClockPM- Surprise- LLActRep- BwNot- ASPMOptComp+
                LnkCtl: ASPM Disabled; RCB 64 bytes, Disabled- CommClk-
                        ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
                LnkSta: Speed 5GT/s (downgraded), Width x1 (downgraded)0x060400
</code></pre><p>The <code>LnkCap</code> tells us about the full capabilities of this PCIe device, here we can see that
the current design supports PCIe Gen 3.0 x8.
The <code>LnkSta</code> tells us the current configuration, here we have been downgraded to PCIe Gen 2.0 at 5GT/s with a width of only x1.</p><p>During startup of when a new PCIe device is plugged, PCIe performs a link speed and width negotiation
where it tries to reach the highest supported stable configuration for the current system.
In our current system, though our FPGA is capable of 8GT/s, as it is located downstream of the
Broadcom bridge with a maximum link capacity of Gen 2.0 ( 5GT/s ), the FPGA has been downgraded to 5GT/s.</p><p>As for the width of x1, that is expected since the Broadcom bridge is also only x1 wide, and our board’s other
7 PCIe lanes are literally hanging over the side.</p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/pcie_air.jpg" alt="7 PCIe lanes left unconnected and hanging over the air"/><figcaption>7 PCIe lanes left unconnected and hanging over the air</figcaption></figure><p>Thus, we can finally confirm that this is our board and that the PCIe interface is working.
We can now proceed to establishing the JTAG connection.</p><h2>JTAG interface<span><a href="#jtag-interface" aria-label="Anchor">#</a></span></h2><p>Xilinx FPGAs can be configured by writing a bitstream to their internal CMOS Configuration Latches (CCL).
CCL is SRAM memory and volatile, thus the configuration is re-done on every power cycle.
For devices in the field this bitstream would be read from an external SPI memory during initialization,
or written from an external device, such as an embedded controller. But for development purposes overwriting the contents of the CCLs over JTAG is acceptable.</p><p>This configuration is done by shifting in the entire FPGA bitstream into the device’s configuration logic over the JTAG bus.</p><h3>FPGA board JTAG interface<span><a href="#fpga-board-jtag-interface" aria-label="Anchor">#</a></span></h3><p>As promised by the original eBay listing the board did come with an accessible JTAG interface, and gloriously enough, this time there
wasn’t even the need for any additional soldering.</p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/pcb_jtag.jpg" alt="View of the JTAG interface on the PCB"/><figcaption>View of the JTAG interface on the PCB</figcaption></figure><p>In addition to a power reference, and ground, conformely to the Xilinx JTAG interface it featured the four mandatory signals comprising the JTAG TAP :</p><ul><li><strong>TCK</strong> Test Clock</li><li><strong>TMS</strong> Test Mode Select</li><li><strong>TDI</strong> Test Data Input</li><li><strong>TDO</strong> Test Data Output</li></ul><p>Of note, the JTAG interface can also come with an independent reset signal.
But since Xilinx JTAG interfaces do not have this independent reset signal, we be using the JTAG FSM reset state
for our reset signal.</p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/board_jtag_intf.svg" alt="very nice documentation of the board JTAG pinout"/><figcaption>6 pin board JTAG interface</figcaption></figure><p>This interface layout doesn’t follow a standard layout so I cannot just plug in one of my debug probes, it requires some re-wiring.</p><h3>Segger JLINK :heart:<span><a href="#segger-jlink-heart" aria-label="Anchor">#</a></span></h3><p>I do not own an AMD approved JTAG programmer.</p><p>Traditionally speaking, the Segger JLink is used for debugging embedded CPUs let them be standalone or in a
Zynq, and not for configuring FPGAs.</p><p>That said, all we need to do is use JTAG to shift in a bitstream to the CCLs, so
technically speaking any programmable device with 4 sufficiently fast GPIOs can be used as a JTAG programmer.
Additionally, the JLink is well supported by OpenOCD, the JLink’s libraries are open source, and I happened to own one.</p><p><span><span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 0C114.6.0.0 114.6.0 256s114.6 256 256 256 256-114.6 256-256S397.4.0 256 0zm0 128c17.67.0 32 14.33 32 32 0 17.67-14.33 32-32 32s-32-14.3-32-32 14.3-32 32-32zm40 256h-80c-13.2.0-24-10.7-24-24s10.75-24 24-24h16v-64h-8c-13.25.0-24-10.75-24-24s10.8-24 24-24h32c13.25.0 24 10.75 24 24v88h16c13.25.0 24 10.75 24 24s-10.7 24-24 24z"></path></svg>
</span></span><span>Note : I could also have used a USB Blaster, which considering it is literally an Altera tool would have made it hilarious.</span></p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/segger_jlink_conn.svg" alt="very nice 20 pin segger JLink pinout interface documentation"/><figcaption>20 pin segger JLink pinout</figcaption></figure><h4>Wiring<span><a href="#wiring" aria-label="Anchor">#</a></span></h4><p>Rewiring :</p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/jtag_wiring.svg" alt="very nice JTAG wiring diagram to connect JLink jtag probe to fpga board"/><figcaption>Wiring diagram to connect JLink JTAG probe to the board.</figcaption></figure><p>JTAG is a parallel protocol where <code>TDI</code> and <code>TMS</code> will be captured according to <code>TCK</code>.
Because of this, good JTAG PCB trace length matching is advised in order to minimize skew.</p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/jtag_timing.png" alt="Timing Waveform for JTAG Signals (From Target Device Perspective)"/><figcaption>Timing Waveform for JTAG Signals (From Target Device Perspective); source : <a href="https://www.intel.com/content/www/us/en/docs/programmable/683719/current/jtag-timing-constraints-and-waveforms.html" target="_blank">https://www.intel.com/content/www/us/en/docs/programmable/683719/current/jtag-timing-constraints-and-waveforms.html</a></figcaption></figure><p>Ideally a custom connector with length matched traces to work as an interface between the JLink’s
probe and a board specific connector would be used.</p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/con.jpg" alt="Far from length matched JTAG connections"/><figcaption>Far from length matched JTAG connections</figcaption></figure><p>Yet, here we are shoving breadboard wires between our debugger and the board.
Since OpenOCD allows us to easily control the debugger clock speed, we can increase the skew tolerance by slowing down the TCK clock signal. As such
there is no immediate need for a custom connector but we will not be able to reach the maximum JTAG speeds.</p><p><span><span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M506.3 417 293 53c-16.33-28-57.54-28-73.98.0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6c32.76.0 53.26-35 36.96-63zM232 168c0-13.25 10.75-24 24-24s24 10.8 24 24v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zm24 248c-17.36.0-31.44-14.08-31.44-31.44s14.07-31.44 31.44-31.44 31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z"></path></svg>
</span></span><span>If no clock speed is specified OpenOCD sets the clock speed at 100MHz.
This is too high in our case.
As such, latter in the article, I will be setting the JTAG clock down to 1MHz for probing and reset, programming will be done at 10MHz.</span></p><h3>OpenOCD<span><a href="#openocd" aria-label="Anchor">#</a></span></h3><p>OpenOCD is a free and open source on-chip debugger software that aims to be compatible with as many
probes, boards and chips as possible.</p><p>Since OpenOCD has support for the standard SVF file format, my plan for my flashing flow will be to use
Vivado to generate the SVF and have OpenOCD flash it.
Now, some of you might be starting to notice that I am diverging quite far from the well lit path of officially
supported tools. Not only am I using a not officially supported debug probe, but I am also using some
obscure open source software with questionable support for interfacing with Xilinx UltraScale+ FPGAs.
You might be wondering, given that the officially supported tools can already prove themselves to be a headache to get working properly,
why am I seemingly making my life even harder?</p><p>The reason is quite simple: when things inevitably start going wrong, as they will,
having an entirely open toolchain, allows me to have more visibility
as to what is going on and the ability to fix it.
I cannot delve into a black box.</p><h4>Building OpenOCD<span><a href="#building-openocd" aria-label="Anchor">#</a></span></h4><p>By default the version of OpenOCD that I got on my server via the official packet manager was outdated and missing features
I will need.</p><p>Also, since saving the ability to modify OpenOCD’s source code could come in handy, I decided to re-build it from source.</p><p>Thus, in the following logs, I will be running OpenOCD version <code>0.12.0+dev-02170-gfcff4b712</code>.</p><p>Note : I have also re-build the JLink libs from source.</p><h3>Determining the scan chain<span><a href="#determining-the-scan-chain" aria-label="Anchor">#</a></span></h3><p>Since I do not have the schematics for the board I do not know how many devices are daisy-chainned on the board JTAG bus.
Also, I want to confirm if the FPGA on the ebay listing is actually the one on the board.
In JTAG, each chained device exposes an accessible <code>IDCODE</code> register used to identify the manufacturer, device type, and revision number.</p><p>When setting up the JTAG server, we typically define the scan chain by specifying the expected <code>IDCODE</code> for each TAP and the corresponding instruction register length, so that instructions can be correctly aligned and routed to the intended device.
Given this is an undocumented board off Ebay, I do not know what the chain looks like.
Fortunately, OpenOCD has an autoprobing functionality, to do a blind interrogation in an <strong>attempt</strong> to discover
the available devices.</p><p>Thus, my first order of business was doing this autoprobing.</p><p>In OpenOCD the autoprobing is done when the configuration does not specify any taps.</p><div><pre tabindex="0"><code data-lang="tcl"><span><span>source <span>[</span>find interface<span>/</span>jlink.cfg<span>]</span>
</span></span><span><span>transport select jtag
</span></span><span><span>
</span></span><span><span><span>set</span> SPEED <span>1</span>
</span></span><span><span>jtag_rclk $SPEED
</span></span><span><span>adapter speed $SPEED
</span></span><span><span>
</span></span><span><span>reset_config none
</span></span></code></pre></div><p>The blind interrogation successfully discovered a single device on the chain with an <code>IDCODE</code> of <code>0x04a63093</code>.</p><pre tabindex="0"><code>gp@workhorse:~/tools/openocd_jlink_test/autoprob$ openocd
Open On-Chip Debugger 0.12.0+dev-02170-gfcff4b712 (2025-09-04-21:02)
Licensed under GNU GPL v2
For bug reports, read
	http://openocd.org/doc/doxygen/bugs.html
none separate
Info : Listening on port 6666 for tcl connections
Info : Listening on port 4444 for telnet connections
Info : J-Link V10 compiled Jan 30 2023 11:28:07
Info : Hardware version: 10.10
Info : VTarget = 1.812 V
Info : clock speed 1 kHz
Warn : There are no enabled taps.  AUTO PROBING MIGHT NOT WORK!!
Info : JTAG tap: auto0.tap tap/device found: 0x04a63093 (mfg: 0x049 (Xilinx), part: 0x4a63, ver: 0x0)
Warn : AUTO auto0.tap - use &#34;jtag newtap auto0 tap -irlen 2 -expected-id 0x04a63093&#34;
Error: IR capture error at bit 2, saw 0x3ffffffffffffff5 not 0x...3
Warn : Bypassing JTAG setup events due to errors
Warn : gdb services need one or more targets defined
</code></pre><p>Comparing against the <code>UltraScale Architecture Configuration User Guide (UG570)</code> we see that this <code>IDCODE</code> matches up
precisely with the expected value for the <code>KU3P</code>.</p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/idcode.png" alt="JTAG and IDCODE for UltraScale Architecture-based FPGAs"/><figcaption>JTAG and IDCODE for UltraScale Architecture-based FPGAs</figcaption></figure><p>By default OpenOCD assumes a JTAG IR length of 2 bits, while our FPGA has an IR length of 6 bits.
This is the cause behind the IR capture error encountered during autoprobing. By updating the script with an IR length of 6 bits we can re-detect the FPGA with no errors.</p><div><pre tabindex="0"><code data-lang="tcl"><span><span>source <span>[</span>find interface<span>/</span>jlink.cfg<span>]</span>
</span></span><span><span>transport select jtag
</span></span><span><span>
</span></span><span><span><span>set</span> SPEED <span>1</span>
</span></span><span><span>jtag_rclk $SPEED
</span></span><span><span>adapter speed $SPEED
</span></span><span><span>
</span></span><span><span>reset_config none
</span></span><span><span>
</span></span><span><span>jtag newtap auto_detect tap <span>-</span>irlen <span>6</span>
</span></span></code></pre></div><p>Output :</p><pre tabindex="0"><code>gp@workhorse:~/tools/openocd_jlink_test/autoprob$ openocd
Open On-Chip Debugger 0.12.0+dev-02170-gfcff4b712 (2025-09-04-21:02)
Licensed under GNU GPL v2
For bug reports, read
	http://openocd.org/doc/doxygen/bugs.html
Info : Listening on port 6666 for tcl connections
Info : Listening on port 4444 for telnet connections
Info : J-Link V10 compiled Jan 30 2023 11:28:07
Info : Hardware version: 10.10
Info : VTarget = 1.812 V
Info : clock speed 1 kHz
Info : JTAG tap: auto_detect.tap tap/device found: 0x04a63093 (mfg: 0x049 (Xilinx), part: 0x4a63, ver: 0x0)
Warn : gdb services need one or more targets defined
</code></pre><p>Based on the probing, this is the JTAG scan chain for our board :</p><figure><img src="https://seinwave.com/projects/alibaba_cloud_fpga/scan_chain.svg" alt="JTAG scan chain for the alibaba cloud FPGA"/><figcaption>JTAG scan chain for the alibaba cloud FPGA</figcaption></figure><h3>System Monitor Registers<span><a href="#system-monitor-registers" aria-label="Anchor">#</a></span></h3><p>Previous generations of Xilinx FPGA had a system called the XADC that, among other features,
allowed you to acquire chip temperature and voltage readings. The newer UltraScale and UltraScale+
family have deprecated this XADC module in favor of the SYSMON (and SYSMON4) which allows you to also
get these temperature readings, just better.</p><p>Unfortunately, openOCD didn’t have support for reading the SYSMON over JTAG out of the box, so I will be adding it.</p><p><span><span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 0C114.6.0.0 114.6.0 256s114.6 256 256 256 256-114.6 256-256S397.4.0 256 0zm0 128c17.67.0 32 14.33 32 32 0 17.67-14.33 32-32 32s-32-14.3-32-32 14.3-32 32-32zm40 256h-80c-13.2.0-24-10.7-24-24s10.75-24 24-24h16v-64h-8c-13.25.0-24-10.75-24-24s10.8-24 24-24h32c13.25.0 24 10.75 24 24v88h16c13.25.0 24 10.75 24 24s-10.7 24-24 24z"></path></svg>
</span></span><span><p>To be more precise, the Kintex UltraScale+ has a SYSMON4 and not a SYSMON.
For full context, there are 3 flavors of SYSMON:</p><ul><li><code>SYSMON1</code> used in the Kintex and Virtex UltraScale series</li><li><code>SYSMON4</code> used in the Kintex, Virtex and in the Zynq programmable logic for the UltraScale+ series</li><li><code>SYSMON</code> used in the Zynq in the processing system of the UltraScale+ series.</li></ul><p>For the purpose of this article, all these instances are similar enough that I will be using the terms SYSMON4 and SYSMON interchangeably.</p></span></p><p>In order for the JTAG to interact with the SYSMON, we first need to write the <code>SYSMON_DRP</code> command to the
JTAG Instruction Register (IR).
Based on the documentation, we see that this command has a value of <code>0x37</code>, which funnily enough,
is the same command code as the XADC, solidifying the SYSMON as the XADC’s descendant.</p><p>The SYSMON offers a lot more additional functionalities than just being used to read voltage and temperature,
but for today’s use case we will not be using any of that. Rather, we will focus only on reading a
subset of the SYSMON status registers.</p><p>These status registers are located at addresses <code>(00h-3Fh, 80h-BFh)</code>,
and contain the measurement results of the analog-to-digital conversions, the flag registers,
and the calibration coefficients. We can select which address we wish to read by writing the
address to the Data Register (DR) over JTAG and the data will be read out of <code>TDO</code>.</p><div><pre tabindex="0"><code data-lang="tcl"><span><span><span># SPDX-License-Identifier: GPL-2.0-or-later
</span></span></span><span><span><span>
</span></span></span><span><span><span># Xilinx SYSMON4 support
</span></span></span><span><span><span>#</span>
</span></span><span><span><span># Based on UG580, used for UltraScale+ Xilinx FPGA
</span></span></span><span><span><span># This code implements access through the JTAG TAP.
</span></span></span><span><span><span>#</span>
</span></span><span><span><span># build a 32 bit DRP command for the SYSMON DRP
</span></span></span><span><span><span></span><span>proc</span> sysmon_cmd <span>{</span>cmd addr data<span>}</span> <span>{</span>
</span></span><span><span>	<span>array</span> set cmds <span>{</span>
</span></span><span><span>		NOP <span>0x00</span>
</span></span><span><span>		READ <span>0x01</span>
</span></span><span><span>		WRITE <span>0x02</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>return</span> <span>[expr</span> <span>{(</span>$cmds<span>(</span>$cmd<span>)</span> <span>&lt;&lt;</span> 26<span>)</span> <span>|</span> <span>(</span>$addr <span>&lt;&lt;</span> 16<span>)</span> <span>|</span> <span>(</span>$data <span>&lt;&lt;</span> 0<span>)}]</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span># Status register addresses
</span></span></span><span><span><span># Some addresses (status registers 0-3) have special function when written to.
</span></span></span><span><span><span></span><span>proc</span> SYSMON <span>{</span>key<span>}</span> <span>{</span>
</span></span><span><span>	<span>array</span> set addrs <span>{</span>
</span></span><span><span>		TEMP <span>0x00</span>
</span></span><span><span>		VCCINT <span>0x01</span>
</span></span><span><span>		VCCAUX <span>0x02</span>
</span></span><span><span>		VPVN <span>0x03</span>
</span></span><span><span>		VREFP <span>0x04</span>
</span></span><span><span>		VREFN <span>0x05</span>
</span></span><span><span>		VCCBRAM <span>0x06</span>
</span></span><span><span>		SUPAOFFS <span>0x08</span>
</span></span><span><span>		ADCAOFFS <span>0x09</span>
</span></span><span><span>		ADCAGAIN <span>0x0a</span>
</span></span><span><span>		VCCPINTLP <span>0x0d</span>
</span></span><span><span>		VCCPINTFP <span>0x0e</span>
</span></span><span><span>		VCCPAUX <span>0x0f</span>
</span></span><span><span>		VAUX0 <span>0x10</span>
</span></span><span><span>		VAUX1 <span>0x11</span>
</span></span><span><span>		VAUX2 <span>0x12</span>
</span></span><span><span>		VAUX3 <span>0x13</span>
</span></span><span><span>		VAUX4 <span>0x14</span>
</span></span><span><span>		VAUX5 <span>0x15</span>
</span></span><span><span>		VAUX6 <span>0x16</span>
</span></span><span><span>		VAUX7 <span>0x17</span>
</span></span><span><span>		VAUX8 <span>0x18</span>
</span></span><span><span>		VAUX9 <span>0x19</span>
</span></span><span><span>		VAUX10 <span>0x1a</span>
</span></span><span><span>		VAUX11 <span>0x1b</span>
</span></span><span><span>		VAUX12 <span>0x1c</span>
</span></span><span><span>		VAUX13 <span>0x1d</span>
</span></span><span><span>		VAUX14 <span>0x1e</span>
</span></span><span><span>		VAUX15 <span>0x1f</span>
</span></span><span><span>		MAXTEMP <span>0x20</span>
</span></span><span><span>		MAXVCC <span>0x21</span>
</span></span><span><span>		MAXVCCAUX <span>0x22</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>return</span> $addrs<span>(</span>$key<span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span># transfer
</span></span></span><span><span><span></span><span>proc</span> sysmon_xfer <span>{</span>tap cmd addr data<span>}</span> <span>{</span>
</span></span><span><span>	<span>set</span> ret <span>[</span>drscan $tap <span>32</span> <span>[</span>sysmon_cmd $cmd $addr $data<span>]]</span>
</span></span><span><span>	runtest <span>10</span>
</span></span><span><span>	<span>return</span> <span>[expr</span> <span>&#34;0x$ret&#34;</span><span>]</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span># sysmon register write
</span></span></span><span><span><span></span><span>proc</span> sysmon_write <span>{</span>tap addr data<span>}</span> <span>{</span>
</span></span><span><span>	sysmon_xfer $tap WRITE $addr $data
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span># sysmon register read, non-pipelined
</span></span></span><span><span><span></span><span>proc</span> sysmon_read <span>{</span>tap addr<span>}</span> <span>{</span>
</span></span><span><span>	sysmon_xfer $tap READ $addr <span>0</span>
</span></span><span><span>	<span>return</span> <span>[</span>sysmon_xfer $tap NOP <span>0</span> <span>0</span><span>]</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span># Select the sysmon DR, SYSMON_DRP has the same binary code value as the XADC
</span></span></span><span><span><span></span><span>proc</span> sysmon_select <span>{</span>tap<span>}</span> <span>{</span>
</span></span><span><span>	<span>set</span> SYSMON_IR <span>0x37</span>
</span></span><span><span>	irscan $tap $SYSMON_IR
</span></span><span><span>	runtest <span>10</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span># convert 16 bit temperature measurement to Celsius
</span></span></span><span><span><span></span><span>proc</span> sysmon_temp_internal <span>{</span>code<span>}</span> <span>{</span>
</span></span><span><span>	<span>return</span> <span>[expr</span> <span>{</span>$code <span>*</span> 509.314<span>/</span><span>(</span>1 <span>&lt;&lt;</span> <span>16</span><span>)</span> <span>-</span> <span>280.23</span><span>}]</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span># convert 16 bit supply voltage measurments to Volt
</span></span></span><span><span><span></span><span>proc</span> sysmon_sup <span>{</span>code<span>}</span> <span>{</span>
</span></span><span><span>	<span>return</span> <span>[expr</span> <span>{</span>$code <span>*</span> 3.<span>/</span><span>(</span>1 <span>&lt;&lt;</span> <span>16</span><span>)}]</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span># measure all internal voltages
</span></span></span><span><span><span></span><span>proc</span> sysmon_report <span>{</span>tap<span>}</span> <span>{</span>
</span></span><span><span>	puts <span>&#34;Sysmon status report :&#34;</span>
</span></span><span><span>	sysmon_select $tap
</span></span><span><span>	<span>foreach</span> ch <span>[</span>list TEMP MAXTEMP<span>]</span> <span>{</span>
</span></span><span><span>		echo <span>&#34;$ch [format %.2f [sysmon_temp_internal [sysmon_read $tap [SYSMON $ch]]]] C&#34;</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>foreach</span> ch <span>[</span>list VCCINT MAXVCC VCCAUX MAXVCCAUX<span>]</span> <span>{</span>
</span></span><span><span>		echo <span>&#34;$ch [format %.3f [sysmon_sup [sysmon_read $tap [SYSMON $ch]]]] V&#34;</span>	
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>I added a report that reads the current chip temperature, internal and external
voltages as well as the maximum values for these recorded since FPGA power cycle, to my flashing script output:</p><pre tabindex="0"><code>gp@workhorse:~/tools/openocd_jlink_test$ openocd
Open On-Chip Debugger 0.12.0+dev-02170-gfcff4b712 (2025-09-04-20:02)
Licensed under GNU GPL v2
For bug reports, read
	http://openocd.org/doc/doxygen/bugs.html
set chipname XCKU3P
Read temperature sysmon 4
Info : J-Link V10 compiled Jan 30 2023 11:28:07
Info : Hardware version: 10.10
Info : VTarget = 1.819 V
Info : clock speed 1 kHz
Info : JTAG tap: XCKU3P.tap tap/device found: 0x04a63093 (mfg: 0x049 (Xilinx), part: 0x4a63, ver: 0x0)
Warn : gdb services need one or more targets defined
--------------------
Sysmon status report :
TEMP 31.12 C
MAXTEMP 34.62 C
VCCINT 0.852 V
MAXVCC 0.855 V
VCCAUX 1.805 V
MAXVCCAUX 1.807 V
</code></pre><h2>Pinout<span><a href="#pinout" aria-label="Anchor">#</a></span></h2><p>To my indescribable joy I happened to stumble onto this gold mine, in which we get the board pinout.
This most likely fell off a truck: <a href="https://blog.csdn.net/qq_37650251/article/details/145716953" target="_blank">https://blog.csdn.net/qq_37650251/article/details/145716953</a></p><p>So far this pinout looks correct.</p><table><thead><tr><th>Pin Index</th><th>Name</th><th>IO Standard</th><th>Location</th><th>Bank</th></tr></thead><tbody><tr><td>0</td><td>diff_100mhz_clk_p</td><td>LVDS</td><td>E18</td><td>BANK67</td></tr><tr><td>1</td><td>diff_100mhz_clk_n</td><td>LVDS</td><td>D18</td><td>BANK67</td></tr><tr><td>2</td><td>sfp_mgt_clk_p</td><td>LVDS</td><td>K7</td><td>BANK227</td></tr><tr><td>3</td><td>sfp_mgt_clk_n</td><td>LVDS</td><td>K6</td><td>BANK227</td></tr><tr><td>4</td><td>sfp_1_txn</td><td>-</td><td>B6</td><td>BANK227</td></tr><tr><td>5</td><td>sfp_1_txp</td><td>-</td><td>B7</td><td>BANK227</td></tr><tr><td>6</td><td>sfp_1_rxn</td><td>-</td><td>A3</td><td>BANK227</td></tr><tr><td>7</td><td>sfp_1_rxp</td><td>-</td><td>A4</td><td>BANK227</td></tr><tr><td>8</td><td>sfp_2_txn</td><td>-</td><td>D6</td><td>BANK227</td></tr><tr><td>9</td><td>sfp_2_txp</td><td>-</td><td>D7</td><td>BANK227</td></tr><tr><td>10</td><td>sfp_2_rxn</td><td>-</td><td>B1</td><td>BANK227</td></tr><tr><td>11</td><td>sfp_2_rxp</td><td>-</td><td>B2</td><td>BANK227</td></tr><tr><td>12</td><td>SFP_1_MOD_DEF_0</td><td>LVCMOS18</td><td>D14</td><td>BANK87</td></tr><tr><td>13</td><td>SFP_1_TX_FAULT</td><td>LVCMOS18</td><td>B14</td><td>BANK87</td></tr><tr><td>14</td><td>SFP_1_LOS</td><td>LVCMOS18</td><td>D13</td><td>BANK87</td></tr><tr><td>15</td><td>SFP_1_LED</td><td>LVCMOS18</td><td>B12</td><td>BANK87</td></tr><tr><td>16</td><td>SFP_2_MOD_DEF_0</td><td>LVCMOS18</td><td>E11</td><td>BANK86</td></tr><tr><td>17</td><td>SFP_2_TX_FAULT</td><td>LVCMOS18</td><td>F9</td><td>BANK86</td></tr><tr><td>18</td><td>SFP_2_LOS</td><td>LVCMOS18</td><td>E10</td><td>BANK86</td></tr><tr><td>19</td><td>SFP_2_LED</td><td>LVCMOS18</td><td>C12</td><td>BANK87</td></tr><tr><td>20</td><td>IIC_SDA_SFP_1</td><td>LVCMOS18</td><td>C14</td><td>BANK87</td></tr><tr><td>21</td><td>IIC_SCL_SFP_1</td><td>LVCMOS18</td><td>C13</td><td>BANK87</td></tr><tr><td>22</td><td>IIC_SDA_SFP_2</td><td>LVCMOS18</td><td>D11</td><td>BANK86</td></tr><tr><td>23</td><td>IIC_SCL_SFP_2</td><td>LVCMOS18</td><td>D10</td><td>BANK86</td></tr><tr><td>24</td><td>IIC_SDA_EEPROM_0</td><td>LVCMOS18</td><td>G10</td><td>BANK86</td></tr><tr><td>25</td><td>IIC_SCL_EEPROM_0</td><td>LVCMOS18</td><td>G9</td><td>BANK86</td></tr><tr><td>26</td><td>IIC_SDA_EEPROM_1</td><td>LVCMOS18</td><td>J15</td><td>BANK87</td></tr><tr><td>27</td><td>IIC_SCL_EEPROM_1</td><td>LVCMOS18</td><td>J14</td><td>BANK87</td></tr><tr><td>28</td><td>GPIO_LED_R</td><td>LVCMOS18</td><td>A13</td><td>BANK87</td></tr><tr><td>29</td><td>GPIO_LED_G</td><td>LVCMOS18</td><td>A12</td><td>BANK87</td></tr><tr><td>30</td><td>GPIO_LED_H</td><td>LVCMOS18</td><td>B9</td><td>BANK86</td></tr><tr><td>31</td><td>GPIO_LED_1</td><td>LVCMOS18</td><td>B11</td><td>BANK86</td></tr><tr><td>32</td><td>GPIO_LED_2</td><td>LVCMOS18</td><td>C11</td><td>BANK86</td></tr><tr><td>33</td><td>GPIO_LED_3</td><td>LVCMOS18</td><td>A10</td><td>BANK86</td></tr><tr><td>34</td><td>GPIO_LED_4</td><td>LVCMOS18</td><td>B10</td><td>BANK86</td></tr><tr><td>35</td><td>pcie_mgt_clkn</td><td>-</td><td>T6</td><td>BANK225</td></tr><tr><td>36</td><td>pcie_mgt_clkp</td><td>-</td><td>T7</td><td>BANK225</td></tr><tr><td>37</td><td>pcie_tx0_n</td><td>-</td><td>R4</td><td>BANK225</td></tr><tr><td>38</td><td>pcie_tx1_n</td><td>-</td><td>U4</td><td>BANK225</td></tr><tr><td>39</td><td>pcie_tx2_n</td><td>-</td><td>W4</td><td>BANK225</td></tr><tr><td>40</td><td>pcie_tx3_n</td><td>-</td><td>AA4</td><td>BANK225</td></tr><tr><td>41</td><td>pcie_tx4_n</td><td>-</td><td>AC4</td><td>BANK224</td></tr><tr><td>42</td><td>pcie_tx5_n</td><td>-</td><td>AD6</td><td>BANK224</td></tr><tr><td>43</td><td>pcie_tx6_n</td><td>-</td><td>AE8</td><td>BANK224</td></tr><tr><td>44</td><td>pcie_tx7_n</td><td>-</td><td>AF6</td><td>BANK224</td></tr><tr><td>45</td><td>pcie_rx0_n</td><td>-</td><td>P1</td><td>BANK225</td></tr><tr><td>46</td><td>pcie_rx1_n</td><td>-</td><td>T1</td><td>BANK225</td></tr><tr><td>47</td><td>pcie_rx2_n</td><td>-</td><td>V1</td><td>BANK225</td></tr><tr><td>48</td><td>pcie_rx3_n</td><td>-</td><td>Y1</td><td>BANK225</td></tr><tr><td>49</td><td>pcie_rx4_n</td><td>-</td><td>AB1</td><td>BANK224</td></tr><tr><td>50</td><td>pcie_rx5_n</td><td>-</td><td>AD1</td><td>BANK224</td></tr><tr><td>51</td><td>pcie_rx6_n</td><td>-</td><td>AE3</td><td>BANK224</td></tr><tr><td>52</td><td>pcie_rx7_n</td><td>-</td><td>AF1</td><td>BANK224</td></tr><tr><td>53</td><td>pcie_tx0_p</td><td>-</td><td>R5</td><td>BANK225</td></tr><tr><td>54</td><td>pcie_tx1_p</td><td>-</td><td>U5</td><td>BANK225</td></tr><tr><td>55</td><td>pcie_tx2_p</td><td>-</td><td>W5</td><td>BANK225</td></tr><tr><td>56</td><td>pcie_tx3_p</td><td>-</td><td>AA5</td><td>BANK225</td></tr><tr><td>57</td><td>pcie_tx4_p</td><td>-</td><td>AC5</td><td>BANK224</td></tr><tr><td>58</td><td>pcie_tx5_p</td><td>-</td><td>AD7</td><td>BANK224</td></tr><tr><td>59</td><td>pcie_tx6_p</td><td>-</td><td>AE9</td><td>BANK224</td></tr><tr><td>60</td><td>pcie_tx7_p</td><td>-</td><td>AF7</td><td>BANK224</td></tr><tr><td>61</td><td>pcie_rx0_p</td><td>-</td><td>P2</td><td>BANK225</td></tr><tr><td>62</td><td>pcie_rx1_p</td><td>-</td><td>T2</td><td>BANK225</td></tr><tr><td>63</td><td>pcie_rx2_p</td><td>-</td><td>V2</td><td>BANK225</td></tr><tr><td>64</td><td>pcie_rx3_p</td><td>-</td><td>Y2</td><td>BANK225</td></tr><tr><td>65</td><td>pcie_rx4_p</td><td>-</td><td>AB2</td><td>BANK224</td></tr><tr><td>66</td><td>pcie_rx5_p</td><td>-</td><td>AD2</td><td>BANK224</td></tr><tr><td>67</td><td>pcie_rx6_p</td><td>-</td><td>AE4</td><td>BANK224</td></tr><tr><td>68</td><td>pcie_rx7_p</td><td>-</td><td>AF2</td><td>BANK224</td></tr><tr><td>69</td><td>pcie_perstn_rst</td><td>LVCMOS18</td><td>A9</td><td>BANK86</td></tr></tbody></table><h3>Global clock<span><a href="#global-clock" aria-label="Anchor">#</a></span></h3><p>On high end FPGAs like the UltraScale+ family, high-speed global clocks are typically driven from external sources
using differential pairs for better signal integrity.</p><p>According to the pinout we have two such differential pairs.</p><p>First I must determine the nature of these external reference clocks to see how I can use them to drive my clocks.</p><p>These differential pairs are provided over the following pins:</p><ul><li>100MHz : {E18, D18}</li><li>156.25MHz : {K7, K6}</li></ul><p>Judging by the naming and the frequencies, the 156.25MHz clock is likely my SFP reference clock,
and the 100MHz can be used as my global clock.</p><p>We can confirm by querying the pin properties.</p><p><strong>K6</strong> properties :</p><div><pre tabindex="0"><code data-lang="tcl"><span><span>Vivado<span>%</span> report_property <span>[</span>get_package_pins K6<span>]</span>
</span></span><span><span>Property                Type    Read-only  Value
</span></span><span><span>BANK                    string  true       <span>227</span>
</span></span><span><span>BUFIO_2_REGION          string  true       TR
</span></span><span><span>CLASS                   string  true       package_pin
</span></span><span><span>DIFF_PAIR_PIN           string  true       K7
</span></span><span><span>IS_BONDED               bool    true       <span>1</span>
</span></span><span><span>IS_DIFFERENTIAL         bool    true       <span>1</span>
</span></span><span><span>IS_GENERAL_PURPOSE      bool    true       <span>0</span>
</span></span><span><span>IS_GLOBAL_CLK           bool    true       <span>0</span>
</span></span><span><span>IS_LOW_CAP              bool    true       <span>0</span>
</span></span><span><span>IS_MASTER               bool    true       <span>0</span>
</span></span><span><span>IS_VREF                 bool    true       <span>0</span>
</span></span><span><span>IS_VRN                  bool    true       <span>0</span>
</span></span><span><span>IS_VRP                  bool    true       <span>0</span>
</span></span><span><span>MAX_DELAY               int     true       <span>38764</span>
</span></span><span><span>MIN_DELAY               int     true       <span>38378</span>
</span></span><span><span>NAME                    string  true       K6
</span></span><span><span>PIN_FUNC                enum    true       MGTREFCLK0N_227
</span></span><span><span>PIN_FUNC_COUNT          int     true       <span>1</span>
</span></span><span><span>PKGPIN_BYTEGROUP_INDEX  int     true       <span>0</span>
</span></span><span><span>PKGPIN_NIBBLE_INDEX     int     true       <span>0</span>
</span></span></code></pre></div><p><strong>E18</strong> properties :</p><div><pre tabindex="0"><code data-lang="tcl"><span><span>Vivado<span>%</span> report_property <span>[</span>get_package_pins E18<span>]</span>
</span></span><span><span>Property                Type    Read-only  Value
</span></span><span><span>BANK                    string  true       <span>67</span>
</span></span><span><span>BUFIO_2_REGION          string  true       TL
</span></span><span><span>CLASS                   string  true       package_pin
</span></span><span><span>DIFF_PAIR_PIN           string  true       D18
</span></span><span><span>IS_BONDED               bool    true       <span>1</span>
</span></span><span><span>IS_DIFFERENTIAL         bool    true       <span>1</span>
</span></span><span><span>IS_GENERAL_PURPOSE      bool    true       <span>1</span>
</span></span><span><span>IS_GLOBAL_CLK           bool    true       <span>1</span>
</span></span><span><span>IS_LOW_CAP              bool    true       <span>0</span>
</span></span><span><span>IS_MASTER               bool    true       <span>1</span>
</span></span><span><span>IS_VREF                 bool    true       <span>0</span>
</span></span><span><span>IS_VRN                  bool    true       <span>0</span>
</span></span><span><span>IS_VRP                  bool    true       <span>0</span>
</span></span><span><span>MAX_DELAY               int     true       <span>87126</span>
</span></span><span><span>MIN_DELAY               int     true       <span>86259</span>
</span></span><span><span>NAME                    string  true       E18
</span></span><span><span>PIN_FUNC                enum    true       IO_L11P_T1U_N8_GC_67
</span></span><span><span>PIN_FUNC_COUNT          int     true       <span>2</span>
</span></span><span><span>PKGPIN_BYTEGROUP_INDEX  int     true       <span>8</span>
</span></span><span><span>PKGPIN_NIBBLE_INDEX     int     true       <span>2</span>
</span></span></code></pre></div><p>This tells us:</p><ul><li>The differential pairings are correct: {K6, K7}, {E18, D18}</li><li>We can easily use the 100MHz as a source to drive our global clocking network</li><li>The 156.25MHz clock is to be used as the reference clock for our GTY transceivers and lands on bank 227 as indicated by the <code>PIN_FUNC</code> property <code>MGTREFCLK0N_227</code></li><li>We cannot directly use the 156.25MHz clock to drive our global clock network</li></ul><p>With all this we have sufficient information to write a constraint file (<code>xdc</code>) for this board.</p><h2>Test design<span><a href="#test-design" aria-label="Anchor">#</a></span></h2><p>Further sections will be using the following design files.</p><p><code>top.v</code>:</p><div><pre tabindex="0"><code data-lang="sv"><span><span><span>module</span> top (
</span></span><span><span>    <span>input</span> <span>wire</span> Clk_100mhz_p_i, 
</span></span><span><span>    <span>input</span> <span>wire</span> Clk_100mhz_n_i,
</span></span><span><span>
</span></span><span><span>    <span>output</span> <span>wire</span> [<span>3</span><span>:</span><span>0</span>] Led_o 
</span></span><span><span>);
</span></span><span><span>    <span>wire</span>        clk_ibuf;
</span></span><span><span>    <span>reg</span>  [<span>28</span><span>:</span><span>0</span>] ctr_q; 
</span></span><span><span>    <span>reg</span>         unused_ctr_q;
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>    IBUFDS #(
</span></span><span><span>        .DIFF_TERM(<span>&#34;TRUE&#34;</span>),
</span></span><span><span>        .IOSTANDARD(<span>&#34;LVDS&#34;</span>)
</span></span><span><span>    ) m_ibufds (
</span></span><span><span>        .I(Clk_100mhz_p_i),
</span></span><span><span>        .IB(Clk_100mhz_n_i),
</span></span><span><span>        .O(clk_ibuf)
</span></span><span><span>    );
</span></span><span><span>
</span></span><span><span>    BUFG m_bufg (
</span></span><span><span>        .I(clk_ibuf),
</span></span><span><span>        .O(clk)
</span></span><span><span>    );
</span></span><span><span>
</span></span><span><span>    <span>always</span> @(<span>posedge</span> clk)
</span></span><span><span>        { unused_ctr_q, ctr_q } <span>&lt;=</span> ctr_q <span>+</span> <span>29</span><span>&#39;b1</span>;    
</span></span><span><span>    
</span></span><span><span>    <span>assign</span> Led_o <span>=</span> ctr_q[<span>28</span><span>:</span><span>25</span>];
</span></span><span><span><span>endmodule</span>
</span></span></code></pre></div><p><code>alibaba_cloud.xdc</code> :</p><div><pre tabindex="0"><code data-lang="tcl"><span><span><span># Global clock signal 
</span></span></span><span><span><span></span>set_property <span>-</span>dict <span>{</span>LOC E18 IOSTANDARD LVDS<span>}</span> <span>[</span>get_ports Clk_100mhz_p_i<span>]</span>
</span></span><span><span>set_property <span>-</span>dict <span>{</span>LOC D18 IOSTANDARD LVDS<span>}</span> <span>[</span>get_ports Clk_100mhz_n_i<span>]</span>
</span></span><span><span>create_clock <span>-</span>period <span>10</span> <span>-</span>name clk_100mhz <span>[</span>get_ports Clk_100mhz_p_i<span>]</span>
</span></span><span><span>
</span></span><span><span><span># LEDS
</span></span></span><span><span><span></span>set_property <span>-</span>dict <span>{</span>LOC B11 IOSTANDARD LVCMOS18<span>}</span> <span>[</span>get_ports <span>{</span> Led_o<span>[</span>0<span>]}]</span>
</span></span><span><span>set_property <span>-</span>dict <span>{</span>LOC C11 IOSTANDARD LVCMOS18<span>}</span> <span>[</span>get_ports <span>{</span> Led_o<span>[</span>1<span>]}]</span>
</span></span><span><span>set_property <span>-</span>dict <span>{</span>LOC A10 IOSTANDARD LVCMOS18<span>}</span> <span>[</span>get_ports <span>{</span> Led_o<span>[</span>2<span>]}]</span>
</span></span><span><span>set_property <span>-</span>dict <span>{</span>LOC B10 IOSTANDARD LVCMOS18<span>}</span> <span>[</span>get_ports <span>{</span> Led_o<span>[</span>3<span>]}]</span>
</span></span></code></pre></div><h2>Writing the bitstream<span><a href="#writing-the-bitstream" aria-label="Anchor">#</a></span></h2><p>My personal belief is that one of the most important contributors to design quality is iteration cost.
The lower your iteration cost, the higher your design quality is going to be.</p><p>As such I will invest the small upfront cost to have the workflow be as streamlined as efficiently feasible.</p><p>Thus, my workflow evolved into doing practically everything over
the command line interfaces and only interacting with the tools, Vivado in this case, through tcl scripts.</p><h3>Vivado flow<span><a href="#vivado-flow" aria-label="Anchor">#</a></span></h3><p>The goal of this flow is to, given a few verilog design and constraint files produce a SVF file. Our steps are :</p><ol><li>creat the Vivado project <code>setup.tcl</code></li><li>run the implementation <code>build.tcl</code></li><li>generate the bitstream and the SVF <code>gen.tcl</code></li></ol><p>I will be using <code>make</code> to kick off and manage the dependencies between the different steps, though I recognise this isn’t a widespread practice for hardware projects. <code>make</code> is a highly flexible, reliable and powerful tool and I believe its ability to tie together any type of workflow makes it a prime tool for this use case.</p><p>We will be invoking Vivado in batch mode, this allows us to provide a tcl script alongside script arguments, the
format is as following :</p><div><pre tabindex="0"><code data-lang="bash"><span><span>vivado -mode batch &lt;path to tcl script&gt; -tclargs &lt;script args&gt;
</span></span></code></pre></div><p>Though this allows us to easily break down our flow into incremental stages, invoking a single script in batch mode has the
drawback of restarting Vivado and needing to re-load the project or the project checkpoint on each invocation.</p><p>As the project size grows so will the project load time, so segmenting the
flow into a large number of independent scripts comes at an increasing cost.</p><p><code>Makefile</code> :</p><div><pre tabindex="0"><code data-lang="makefile"><span><span>SHELL <span>:=</span> /bin/bash
</span></span><span><span>
</span></span><span><span>VIVADO_PRJ_DIR<span>=</span>prj
</span></span><span><span>VIVADO_PRJ_NAME<span>=</span><span>$(</span>VIVADO_PRJ_DIR<span>)</span>
</span></span><span><span>VIVADO_PRJ_PATH<span>=</span><span>$(</span>VIVADO_PRJ_DIR<span>)</span>/<span>$(</span>VIVADO_PRJ_NAME<span>)</span>.xpr
</span></span><span><span>VIVADO_CHECKPOINT_PATH<span>=</span><span>$(</span>VIVADO_PRJ_DIR<span>)</span>/<span>$(</span>VIVADO_PRJ_NAME<span>)</span>_checkpoint.dcp
</span></span><span><span>
</span></span><span><span>VIVADO_CMD<span>=</span>vivado -mode batch -source
</span></span><span><span>
</span></span><span><span>SRC_PATH<span>=</span>src
</span></span><span><span>OUT_DIR<span>=</span>out
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>all</span><span>:</span> setup build gen
</span></span><span><span>
</span></span><span><span><span>$(VIVADO_PRJ_PATH)</span><span>:</span>  
</span></span><span><span>    mkdir -p <span>$(</span>VIVADO_PRJ_DIR<span>)</span>
</span></span><span><span>    <span>$(</span>VIVADO_CMD<span>)</span> setup.tcl -tclargs <span>$(</span>VIVADO_PRJ_DIR<span>)</span> <span>$(</span>VIVADO_PRJ_NAME<span>)</span>
</span></span><span><span>
</span></span><span><span><span>setup</span><span>:</span> <span>$(</span>VIVADO_PRJ_PATH<span>)</span> 
</span></span><span><span>
</span></span><span><span><span>$(VIVADO_CHECKPOINT_PATH)</span><span>:</span> <span>$(</span>VIVADO_PRJ_PATH<span>)</span> <span>$(</span>wildcard <span>$(</span>SRC_PATH<span>)</span>/*.xdc<span>)</span> <span>$(</span>wildcard <span>$(</span>SRC_PATH<span>)</span>/*.v<span>)</span>
</span></span><span><span>    <span>$(</span>VIVADO_CMD<span>)</span> build.tcl -tclargs <span>$(</span>VIVADO_PRJ_PATH<span>)</span> <span>$(</span>SRC_PATH<span>)</span> <span>$(</span>VIVADO_CHECKPOINT_PATH<span>)</span>
</span></span><span><span>
</span></span><span><span><span>build</span><span>:</span> <span>$(</span>VIVADO_CHECKPOINT_PATH<span>)</span>
</span></span><span><span>
</span></span><span><span><span>$(OUT_DIR)/$(VIVADO_PRJ_NAME).svf</span><span>:</span> <span>$(</span>VIVADO_CHECKPOINT_PATH<span>)</span> 
</span></span><span><span>    mkdir -p <span>$(</span>OUT_DIR<span>)</span>
</span></span><span><span>    <span>$(</span>VIVADO_CMD<span>)</span> gen.tcl -tclargs <span>$(</span>VIVADO_CHECKPOINT_PATH<span>)</span> <span>$(</span>OUT_DIR<span>)</span>
</span></span><span><span>
</span></span><span><span><span>gen</span><span>:</span> <span>$(</span>OUT_DIR<span>)</span>/<span>$(</span>VIVADO_PRJ_NAME<span>)</span>.svf
</span></span><span><span>
</span></span><span><span><span>flash</span><span>:</span> <span>$(</span>OUT_DIR<span>)</span>/<span>$(</span>VIVADO_PRJ_NAME<span>)</span>.svf
</span></span><span><span>    openocd	
</span></span><span><span>
</span></span><span><span><span>clean</span><span>:</span> 
</span></span><span><span>    rm -rf <span>$(</span>VIVADO_PRJ_DIR<span>)</span>
</span></span><span><span>    rm -rf <span>$(</span>OUT_DIR<span>)</span>
</span></span><span><span>    rm -f vivado*<span>{</span>log,jou<span>}</span>
</span></span><span><span>    rm -f webtalk*<span>{</span>log,jou<span>}</span>
</span></span><span><span>    rm -f usage_statistics_webtalk*<span>{</span>html,xml<span>}</span>
</span></span></code></pre></div><p><code>setup.tcl</code> :</p><div><pre tabindex="0"><code data-lang="tcl"><span><span><span>set</span> project_dir <span>[</span>lindex $argv <span>0</span><span>]</span>
</span></span><span><span><span>set</span> project_name <span>[</span>lindex $argv <span>1</span><span>]</span>
</span></span><span><span>
</span></span><span><span>puts <span>&#34;Creating project $project_name at path [pwd]/$project_dir&#34;</span>
</span></span><span><span>create_project <span>-</span>part xcku3p-ffvb676-2-e <span>-</span>force $project_name $project_dir
</span></span><span><span>
</span></span><span><span>close_project
</span></span><span><span>exit <span>0</span>
</span></span></code></pre></div><p><code>build.tcl</code> :</p><div><pre tabindex="0"><code data-lang="tcl"><span><span><span>set</span> project_path <span>[</span>lindex $argv <span>0</span><span>]</span>
</span></span><span><span><span>set</span> src_path <span>[</span>lindex $argv <span>1</span><span>]</span>
</span></span><span><span><span>set</span> checkpoint_path <span>[</span>lindex $argv <span>2</span><span>]</span>
</span></span><span><span>puts <span>&#34;Implementation script called with project path $project_path and src path $src_path, generating checkpoint at $checkpoint_path&#34;</span>
</span></span><span><span>
</span></span><span><span>open_project $project_path 
</span></span><span><span>
</span></span><span><span><span>#</span> load src
</span></span><span><span>read_verilog <span>[</span>glob <span>-</span>directory $src_path <span>*</span>.v<span>]</span>
</span></span><span><span>read_xdc <span>[</span>glob <span>-</span>directory $src_path <span>*</span>.xdc<span>]</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span># synth
</span></span></span><span><span><span></span>synth_design <span>-</span>top top
</span></span><span><span>
</span></span><span><span><span># implement
</span></span></span><span><span><span></span>opt_design
</span></span><span><span>place_design
</span></span><span><span>route_design
</span></span><span><span>phys_opt_design
</span></span><span><span>
</span></span><span><span>write_checkpoint $checkpoint_path <span>-</span>force 
</span></span><span><span>close_project
</span></span><span><span>exit <span>0</span>
</span></span></code></pre></div><h4>Generating the SVF file<span><a href="#generating-the-svf-file" aria-label="Anchor">#</a></span></h4><p>The SVF for Serial Vector Format is a human readable, vendor agnostic specification used to specify JTAG bus operations.</p><p>Example SVF file, test program:</p><pre tabindex="0"><code data-lang="svf">! Initialize UUT
STATE RESET;
! End IR scans in DRPAUSE
ENDIR DRPAUSE;
! End DR scans in DRPAUSE
ENDDR DRPAUSE;
! 24 bit IR header
HIR 24 TDI (FFFFFF);
! 3 bit DR header
HDR 3 TDI (7);
! 16 bit IR trailer
TIR 16 TDI (FFFF);
! 2 bit DR trailer
TDR 2 TDI (3);
! 8 bit IR scan, load BIST opcode
SIR 8 TDI (41) TDO (81) MASK (FF);
! 16 bit DR scan, load BIST seed
SDR 16 TDI (ABCD);
! RUNBIST for 95 TCK Clocks
RUNTEST 95 TCK ENDSTATE IRPAUSE;
! 16 bit DR scan, check BIST status
SDR 16 TDI (0000) TDO(1234) MASK(FFFF);
! Enter Test-Logic-Reset
STATE RESET;
! End Test Program
</code></pre><p>Vivado can generate a hardware aware SVF file containing the configuration sequence for an FPGA board, allowing us to write a bitstream.</p><p>Given the SVF file literally contains the bitstream written in clear hexademical, in the file, our first step is to generate
our design’s bitstream.</p><p>Vivado proper isn’t the software that generates the SVF file, this task is done by the hardware manager which
handles all of the configuration.</p><p>We can launch a new instance <code>open_hw_manager</code> and connect to it <code>connect_hw_server</code>.
Since JTAG is a daisy chained bus, and given the SVF file is just a standardised way of specifying
JTAG bus operations, in order to generate a correct JTAG configuration sequence, we must inform the hardware manger
of our scan chain.</p><p>During our earlier probing of the scan chain, we have established that our FPGA is the only device on the chain.
We inform the hardware manager of this by creating a new device configuration ( the term “device” refers to the “board”
here ) and add our fpga to the chain using the <code>create_hw_device -part &lt;device name&gt;</code>.When we have multiple
devices we should register them following the order in which they appear on the chain.</p><p>Finally to generate the SVF file, we must select the device we wish to program with <code>program_hw_device &lt;hw_device&gt;</code>,
then write out the SVF to the file using <code>write_hw_svf &lt;path to svf file&gt;</code>.</p><p><code>gen.tcl</code>:</p><div><pre tabindex="0"><code data-lang="tcl"><span><span><span>set</span> checkpoint_path <span>[</span>lindex $argv <span>0</span><span>]</span>
</span></span><span><span><span>set</span> out_dir <span>[</span>lindex $argv <span>1</span><span>]</span>
</span></span><span><span>puts <span>&#34;SVF generation script called with checkpoint path $checkpoint_path, generating to $out_dir&#34;</span>
</span></span><span><span>
</span></span><span><span>open_checkpoint $checkpoint_path
</span></span><span><span>
</span></span><span><span><span># defines
</span></span></span><span><span><span></span><span>set</span> hw_target <span>&#34;alibaba_board_svf_target&#34;</span>
</span></span><span><span><span>set</span> fpga_device <span>&#34;xcku3p&#34;</span>
</span></span><span><span><span>set</span> bin_path <span>&#34;$out_dir/[current_project]&#34;</span>
</span></span><span><span>
</span></span><span><span>write_bitstream <span>&#34;$bin_path.bit&#34;</span> <span>-</span>force
</span></span><span><span>
</span></span><span><span>open_hw_manager
</span></span><span><span>
</span></span><span><span><span># connect to hw server with default config
</span></span></span><span><span><span></span>connect_hw_server
</span></span><span><span>puts <span>&#34;connected to hw server at [current_hw_server]&#34;</span>
</span></span><span><span>
</span></span><span><span>create_hw_target $hw_target
</span></span><span><span>puts <span>&#34;current hw target [current_hw_target]&#34;</span>
</span></span><span><span>
</span></span><span><span>open_hw_target
</span></span><span><span>
</span></span><span><span><span># single device on scan chain
</span></span></span><span><span><span></span>create_hw_device <span>-</span>part $fpga_device
</span></span><span><span>puts <span>&#34;scan chain : [get_hw_devices]&#34;</span>
</span></span><span><span>
</span></span><span><span>set_property PROGRAM.FILE <span>&#34;$bin_path.bit&#34;</span> <span>[</span>get_hw_device<span>]</span>
</span></span><span><span>
</span></span><span><span><span>#select device to program
</span></span></span><span><span><span></span>program_hw_device <span>[</span>get_hw_device<span>]</span>
</span></span><span><span>
</span></span><span><span><span># generate svf file
</span></span></span><span><span><span></span>write_hw_svf <span>-</span>force <span>&#34;$bin_path.svf&#34;</span>
</span></span><span><span>
</span></span><span><span>close_hw_manager
</span></span><span><span>exit <span>0</span>
</span></span></code></pre></div><h3>Configuring the FPGA using OpenOCD<span><a href="#configuring-the-fpga-using-openocd" aria-label="Anchor">#</a></span></h3><p>Although not widespread openOCD has a very nice <code>svf</code> execution command :</p><blockquote><div><h4>18.1 SVF: Serial Vector Format<span><a href="#181-svf-serial-vector-format" aria-label="Anchor">#</a></span></h4><p>The Serial Vector Format, better known as SVF, is a way to represent JTAG test patterns
in text files. In a debug session using JTAG for its transport protocol, OpenOCD supports
running such test files.</p><pre tabindex="0"><code>[Command]svf filename [-tap tapname] [[-]quiet] [[-]nil] [[-]progress]
[[-]ignore_error]
</code></pre><p>This issues a JTAG reset (Test-Logic-Reset) and then runs the SVF script from
filename.
Arguments can be specified in any order; the optional dash doesn’t affect their se-
mantics.</p><p><strong>Command options</strong>:</p><ul><li><code>-tap</code> tapname ignore IR and DR headers and footers specified by the SVF file
with HIR, TIR, HDR and TDR commands; instead, calculate them automatically
according to the current JTAG chain configuration, targeting tapname;</li><li><code>[-]quiet</code> do not log every command before execution;</li><li><code>[-]nil</code> “dry run”, i.e., do not perform any operations on the real interface;</li><li><code>[-]progress</code> enable progress indication;</li><li><code>[-]ignore</code>_error continue execution despite TDO check errors.</li></ul></div></blockquote><p>We invoke it in our openOCD script using the <code>-progress</code> option for additional logging.</p><p><code>openocd</code> :</p><div><pre tabindex="0"><code data-lang="tcl"><span><span><span>set</span> svf_path <span>&#34;out/project_prj_checkpoint.svf&#34;</span>
</span></span><span><span>
</span></span><span><span>source <span>[</span>find interface<span>/</span>jlink.cfg<span>]</span>
</span></span><span><span>transport select jtag
</span></span><span><span>
</span></span><span><span><span>set</span> SPEED <span>1</span>
</span></span><span><span>jtag_rclk $SPEED
</span></span><span><span>adapter speed $SPEED 
</span></span><span><span>reset_config none
</span></span><span><span>
</span></span><span><span><span># jlink config
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>set</span> CHIPNAME XCKU3P
</span></span><span><span><span>set</span> CHIP $CHIPNAME
</span></span><span><span>puts <span>&#34;set chipname &#34;</span>$CHIP
</span></span><span><span>
</span></span><span><span>source <span>[</span>find ..<span>/</span>openocd<span>/</span>tcl<span>/</span>cpld<span>/</span>xilinx-xcu.cfg<span>]</span>
</span></span><span><span>
</span></span><span><span>source <span>[</span>find ..<span>/</span>openocd<span>/</span>tcl<span>/</span>fpga<span>/</span>xilinx-sysmon.cfg<span>]</span>
</span></span><span><span>
</span></span><span><span>init 
</span></span><span><span>
</span></span><span><span>puts <span>&#34;--------------------&#34;</span>
</span></span><span><span>
</span></span><span><span>sysmon_report $CHIP.tap
</span></span><span><span>
</span></span><span><span>puts <span>&#34;--------------------&#34;</span>
</span></span><span><span>
</span></span><span><span><span># program
</span></span></span><span><span><span></span><span>if</span> <span>{</span><span>!</span><span>[</span>file exists $svf_path<span>]}</span> <span>{</span>
</span></span><span><span>    puts <span>&#34;Svf path not found : $svf_path&#34;</span>
</span></span><span><span>    exit
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>svf $svf_path <span>-</span>progress 
</span></span><span><span> 
</span></span><span><span>exit 
</span></span></code></pre></div><p>Flashing sequence log :</p><pre tabindex="0"><code>gp@workhorse:~/tools/openocd_jlink_test$ openocd
Open On-Chip Debugger 0.12.0+dev-02170-gfcff4b712 (2025-09-04-21:02)
Licensed under GNU GPL v2
For bug reports, read
	http://openocd.org/doc/doxygen/bugs.html
set chipname XCKU3P
Read temperature sysmon 4
Info : J-Link V10 compiled Jan 30 2023 11:28:07
Info : Hardware version: 10.10
Info : VTarget = 1.812 V
Info : clock speed 1 kHz
Info : JTAG tap: XCKU3P.tap tap/device found: 0x04a63093 (mfg: 0x049 (Xilinx), part: 0x4a63, ver: 0x0)
Warn : gdb services need one or more targets defined
--------------------
Sysmon status report :
TEMP 50.46 C
MAXTEMP 52.79 C
VCCINT 0.846 V
MAXVCC 0.860 V
VCCAUX 1.799 V
MAXVCCAUX 1.809 V
--------------------
svf processing file: &#34;out/project_prj_checkpoint.svf&#34;
  0%  TRST OFF;
  0%  ENDIR IDLE;
  0%  ENDDR IDLE;
  0%  STATE RESET;
  0%  STATE IDLE;
  0%  FREQUENCY 1.00E+07 HZ;
adapter speed: 10000 kHz
  0%  HIR 0 ;
  0%  TIR 0 ;
  0%  HDR 0 ;
  0%  TDR 0 ;
  0%  SIR 6 TDI (09) ;
  0%  SDR 32 TDI (00000000) TDO (04a63093) MASK (0fffffff) ;
  0%  STATE RESET;
  0%  STATE IDLE;
  0%  SIR 6 TDI (0b) ;
  0%  SIR 6 TDI (14) ;
  0%  RUNTEST 0.100000 SEC;
  0%  RUNTEST 10000 TCK;
  0%  SIR 6 TDI (14) TDO (11) MASK (31) ;
  0%  SIR 6 TDI (05) ;
 95%  ffffffffffff) ;
 95%  SIR 6 TDI (09) TDO (31) MASK (11) ;
 95%  STATE RESET;
 95%  RUNTEST 5 TCK;
 95%  SIR 6 TDI (05) ;
 95%  SDR 160 TDI (0000000400000004800700140000000466aa9955) ;
 95%  SIR 6 TDI (04) ;
 95%  SDR 32 TDI (00000000) TDO (3f5e0d40) MASK (08000000) ;
 95%  STATE RESET;
 95%  RUNTEST 5 TCK;
Info : Listening on port 6666 for tcl connections
Info : Listening on port 4444 for telnet connections
</code></pre><p>Resulting in a successfully configured our FPGA.</p><h2>Conclusion<span><a href="#conclusion" aria-label="Anchor">#</a></span></h2><p>For <strong>$200</strong> we got a fully working decommissioned Alibaba Cloud accelerator featuring a Kintex UltraScale+
FPGA with an easily accessible debugging/programming interface and enough pinout information to define
our own constraint files.</p><p>We also have a fully automated Vivado workflow to implement our designs and the ability to write the bitstream,
and interface with the FPGA’s internal JTAG accessible registers using an open source programming tool without
the need for an official Xilinx programmer.</p><p>In the end, this project delivered an at least 5x cost savings over commercial boards (compared to the lowest cost $900-1050 Alinx alternatives),
making this perhaps the most cost effective entry point for a Kintex UltraScale+ board.</p><h2>External ressources<span><a href="#external-ressources" aria-label="Anchor">#</a></span></h2><p>Xilinx Vivado Supported Devices : <a href="https://docs.amd.com/r/en-US/ug973-vivado-release-notes-install-license/Supported-Devices" target="_blank">https://docs.amd.com/r/en-US/ug973-vivado-release-notes-install-license/Supported-Devices</a></p><p>Official Xilinx dev board : <a href="https://www.amd.com/en/products/adaptive-socs-and-fpgas/evaluation-boards/ek-u1-kcu116-g.html" target="_blank">https://www.amd.com/en/products/adaptive-socs-and-fpgas/evaluation-boards/ek-u1-kcu116-g.html</a></p><p>Alinx Kintex UltraScale+ dev boards : <a href="https://www.en.alinx.com/Product/FPGA-Development-Boards/Kintex-UltraScale-plus.html" target="_blank">https://www.en.alinx.com/Product/FPGA-Development-Boards/Kintex-UltraScale-plus.html</a></p><p>UltraScale Architecture Configuration User Guide (UG570) : <a href="https://docs.amd.com/r/en-US/ug570-ultrascale-configuration/Device-Resources-and-Configuration-Bitstream-Lengths?section=gyn1703168518425__table_vyh_4hs_szb" target="_blank">https://docs.amd.com/r/en-US/ug570-ultrascale-configuration/Device-Resources-and-Configuration-Bitstream-Lengths?section=gyn1703168518425__table_vyh_4hs_szb</a></p><p>UltraScale Architecture System Monitor User Guide (UG580): <a href="https://docs.amd.com/v/u/en-US/ug580-ultrascale-sysmon" target="_blank">https://docs.amd.com/v/u/en-US/ug580-ultrascale-sysmon</a></p><p>Vivado Design Suite Tcl Command Reference Guide (UG835): <a href="https://docs.amd.com/r/en-US/ug835-vivado-tcl-commands/Tcl-Initialization-Scripts" target="_blank">https://docs.amd.com/r/en-US/ug835-vivado-tcl-commands/Tcl-Initialization-Scripts</a></p><p>PCI vendor/device ID database: <a href="https://admin.pci-ids.ucw.cz/read/PC/14e4" target="_blank">https://admin.pci-ids.ucw.cz/read/PC/14e4</a></p><p>PCI device classes: <a href="https://admin.pci-ids.ucw.cz/read/PD" target="_blank">https://admin.pci-ids.ucw.cz/read/PD</a></p><p>Linux kernel PCI IDs: <a href="https://github.com/torvalds/linux/blob/7aac71907bdea16e2754a782b9d9155449a9d49d/include/linux/pci_ids.h#L160-L3256" target="_blank">https://github.com/torvalds/linux/blob/7aac71907bdea16e2754a782b9d9155449a9d49d/include/linux/pci_ids.h#L160-L3256</a></p><p>Linux kernel PCI classes: <a href="https://github.com/torvalds/linux/blob/7aac71907bdea16e2754a782b9d9155449a9d49d/include/linux/pci_ids.h#L15-L158" target="_blank">https://github.com/torvalds/linux/blob/7aac71907bdea16e2754a782b9d9155449a9d49d/include/linux/pci_ids.h#L15-L158</a></p><p>Truck-kun pinout: <a href="https://blog.csdn.net/qq_37650251/article/details/145716953" target="_blank">https://blog.csdn.net/qq_37650251/article/details/145716953</a></p><p>Ebay listing: <a href="https://www.ebay.com/itm/167626831054?_trksid=p4375194.c101800.m5481" target="_blank">https://www.ebay.com/itm/167626831054?_trksid=p4375194.c101800.m5481</a></p><p>OpenOCD documentation: <a href="https://openocd.org/doc-release/pdf/openocd.pdf" target="_blank">https://openocd.org/doc-release/pdf/openocd.pdf</a></p></div></div></div>
  </body>
</html>
