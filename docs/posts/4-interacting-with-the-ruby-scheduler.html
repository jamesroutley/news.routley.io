<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jacobvosmaer.nl/0004-ruby-scheduler-interaction/">Original</a>
    <h1>4. Interacting with the Ruby scheduler</h1>
    
    <div id="readability-page-1" class="page"><div><p><i><a href="https://blog.jacobvosmaer.nl/">Jacob Vosmaer&#39;s blog</a></i></p>

<p>2019-12-07</p>

<p>I&#39;m trying to wrap my head around how Ruby application code interacts
with the (thread) scheduler in the runtime. My main interest it the
interaction between C extensions and the scheduler.</p>

<p>I&#39;m thinking about / looking at MRI Ruby 2.6. Usual disclaimer: this
is me thinking out loud as I learn. Lots of guessing and speculation.</p>

<p>The elephant in the room is the Global VM Lock (GVL) also known as the
Global Interpreter Lock (GIL). Ruby threads (<code>thread.c</code>) are backed by
Posix threads (<code>thread_pthread.c</code>), unless you&#39;re on win32
(<code>thread_win32.c</code>). I don&#39;t know or work with win32 so I&#39;m going to
ignore that part.</p>

<p>Every time you create a new Ruby thread (<code>Thread.new</code>) you create a
new Posix thread. The OS will schedule those as it sees fit. Most of
the time, though, those threads will just sit around blocked on trying
to acquire the GVL. Only one thread at a time can use the Ruby VM.
Because of this, a multi-threaded Ruby program is seriously limited in
how well it can utilize multiple CPU&#39;s with multi-threading.</p>

<p>One of the main things we want from a scheduler is fairness:
concurrent tasks should all make a fair amount of progress. You don&#39;t
want some task to stall for a long time at the expense of others.</p>

<p>Fairness is especially important in multi threaded application servers
where you handle requests from many unrelated clients (users). As a
user you don&#39;t want someone else&#39;s slow request to make your otherwise
fast request slow.</p>

<p>Cooperative schedulers (e.g. Ruby, Go) cannot guarantee fairness;
because they are cooperative they are at the mercy of the application
code. Even within cooperative schedulers I suspect Ruby is at the
unfair end of the fairness spectrum.</p>

<p>That is a strong claim and I may be wrong. But here is why I think
this is the case.</p>

<ol>
<li>Ruby application code typically relies a lot on C extensions</li>
<li>Ruby C extensions commonly do not release the GVL, except for doing IO or syscalls</li>
</ol>

<p>I can back up neither of these claims with numbers; they are gut
feelings based on my experience with working at GitLab. Take this with
as many grains of salt as necessary.</p>

<p>The first claim rests on two things. One, the high number of gems
(Ruby libraries) in GitLab that have C extensions. Two, the general
philosophy I have picked up from books (which books?) of building
applications in &#34;scripting languages&#34; for their high initial
development velocity, and then replacing the slow parts with C. This
is not the only way to grow applications over time but it is <em>a</em> way,
and I think this philosophy is in line with the idea of building
application in Ruby on Rails.</p>

<p>To be honest I would like to have a better understanding of whether C
extensions really are that prevalent in Ruby and if so why. For now I
make do with this strong impression.</p>

<p>The second claim is also something that ought to be backed up by an
analysis. I might do one one day. For now I have been doing spot
checks on some of the Ruby libraries used in GitLab, and usually see
little or no interaction with the scheduler -- except in libraries that do IO outside the standard library, like kgio, nio4r, raindrops, grpc.</p>

<p>Browsing through the Ruby source code I see the following reasons for
code to interact with the scheduler:</p>

<ol>
<li>&#34;I&#39;m blocked, please let another thread take the GVL&#34; — <code>rb_thread_sleep_*</code></li>
<li>&#34;Now might be a good time to pass the GVL to another thread&#34; — <code>rb_thread_schedule</code></li>
<li>&#34;I&#39;m going to be busy for a while without touching the Ruby VM&#34; — <code>rb_thread_call_without_gvl</code></li>
</ol>

<p>I don&#39;t have a good understanding of reason (2) yet. My hunch is that
this is mainly done to prevent deadlocks.</p>

<p>Reasons (1) and (3) line up well with IO and system calls. In Ruby
itself, you can see <code>rb_thread_call_without_gvl</code> being used for that
in <code>dir.c</code>, <code>file.c</code>, <code>io.c</code> and <code>process.c</code>. You can see sleep-related
calls (<code>rb_thead_sleep.*</code>) in <code>io.c</code> and <code>process.c</code>.</p>

<p>There is an interesting exception to the &#34;IO and syscalls&#34; pattern in
<code>bignum.c</code>. It appears that there we have a function that does
arithmetic, so probably something that burns through a lot of CPU,
running outside the GVL.</p>

<p>Another major exception is in <code>ext/fiddle/function.c</code>. Fiddle is a
library that lets you dynamically define FFI calls into C libraries.
There it appears that such function calls release the GVL by default,
which is good. And contrary to the main pessimistic thrust of this
note. I don&#39;t think it takes away from my claims, though, because in
my impression, a lot of C extensions do not use Fiddle so they don&#39;t
benefit from this &#34;release GVL by default&#34; behavior.</p>

<p>I see some instances of <code>rb_thread_call_without_gvl</code> in the <code>Socket</code>,
<code>Readline</code>, <code>Zlib</code> and <code>OpenSSL</code> parts of the Ruby stdlib. I suspect
that those are all also syscalls or IO. In OpenSSL, for example, the
GVL is released around function calls that generate keys. That usually
involves IO from <code>/dev/random</code> or something related.</p>
<p>Tags:
<a href="https://blog.jacobvosmaer.nl/ruby.html">ruby</a>
</p><details><summary>Edit history</summary><table>
<tbody><tr><td>2023-12-08</td><td></td><td>Remove embedded dates in favor of meta.json</td></tr>
<tr><td>2023-12-08</td><td></td><td>Add dates to header</td></tr>
<tr><td>2023-12-07</td><td></td><td>Add atom.xml</td></tr>
<tr><td>2023-11-28</td><td></td><td>Add some dates</td></tr>
<tr><td>2023-11-28</td><td></td><td>Add tag system</td></tr>
<tr><td>2019-12-08</td><td></td><td>Declare 0004 unfinished</td></tr>
<tr><td>2019-12-07</td><td></td><td>I did see GVL callbacks in gems for IO</td></tr>
<tr><td>2019-12-07</td><td></td><td>Fix formatting</td></tr>
<tr><td>2019-12-07</td><td></td><td>Look at GVL interaction in runtime and stdlib</td></tr>
<tr><td>2019-12-07</td><td></td><td>Add more thoughts, not coherent yet</td></tr>
<tr><td>2019-12-07</td><td></td><td>WIP 0004 ruby scheduler interaction</td></tr>
</tbody></table></details><p><a href="https://blog.jacobvosmaer.nl/">Back</a></p>
</div></div>
  </body>
</html>
