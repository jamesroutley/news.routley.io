<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zkintro.com/articles/programming-zkps-from-zero-to-hero">Original</a>
    <h1>Programming Zero Knowledge Proofs: From Zero to Hero</h1>
    
    <div id="readability-page-1" class="page"><div><div><p><em>A tutorial introduction for the working programmer.</em></p><p>Do you know why zebras have stripes? One theory is that it is a form of camouflage. When zebras are in a herd together, it makes it harder for the lion to distinguish their prey. Lions have to isolate their prey from the flock to be able to go after it. <sup><a href="#user-content-fn-1" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-1">1</a></sup></p><p>Humans like to hide in a crowd too. One specific example of this is when multiple people act as one under a collective name. This was done for the Federalist Papers which led to the ratification of the United States Constitution. Multiple individuals wrote essays under the single Pseudonym &#34;Publius&#34;. <sup><a href="#user-content-fn-2" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-2">2</a></sup> Another example is Bourbaki, a collective pseudonym for a group of French mathematicians in the 1930s. This lead to a complete re-write of large parts of modern mathematics with their focus on rigor and the axiomatic method. <sup><a href="#user-content-fn-3" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-3">3</a></sup></p><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27513%27%20height=%27582%27/%3e"/></span><img alt="Bourbaki Congress" src="https://zkintro.com/static/images/zkintro_bourbaki.png" decoding="async" data-nimg="intrinsic"/></span></p><p><em>Bourbaki congress in 1938</em></p><p>In the digital age, let&#39;s say you are in a group chat and want to send a controversial message. You want to prove that you are one of its members, without revealing which one. How can we do this in the digital realm using cryptography? We can use something called <em>group signatures</em>.</p><p>Traditionally speaking, group signatures are quite mathematically involved and hard to implement. However, with Zero Knowledge Proofs (ZKPs), this math problem becomes a straightforward programming task. By the end of this article, you&#39;ll be able to program group signatures yourself.</p><h2 id="introduction"><a href="#introduction" aria-hidden="true" tabindex="-1"><span></span></a>Introduction</h2><p>This post will show you how to write basic Zero Knowledge Proofs (ZKPs) from scratch.</p><p>When learning a new tech stack, we want to get a hang of the edit-build-run cycle as soon as possible. Only then can we start to learn from our own experience.</p><p>We will start by getting you to setup your environment, write a simple program, perform a so-called trusted setup, and then generate and verify proofs as quickly as possible. After that, we&#39;ll identify some ways to improve our program, implement these improvements and test them. Along the way, we&#39;ll build up a better mental model of the pieces involved in programming ZKPs in practice. At the end of, you&#39;ll be familiar with (one way of) writing ZKPs from scratch.</p><p>We will build up step by step to a simple signature scheme where you can prove that you sent a specific message. You&#39;ll be able to understand what this piece of code is doing and why:</p><div><pre><code><span>template <span><span>SignMessage</span></span> <span>(</span><span>)</span> <span>{</span>
</span><span>  signal input identity_secret<span>;</span>
</span><span>  signal input identity_commitment<span>;</span>
</span><span>  signal input message<span>;</span>
</span><span>  signal output signature<span>;</span>
</span><span>
</span><span>  component identityHasher <span>=</span> <span><span>Poseidon</span></span><span>(</span><span>1</span><span>)</span><span>;</span>
</span><span>  identityHasher<span>.</span><span>inputs</span><span>[</span><span>0</span><span>]</span> <span>&lt;=</span><span>=</span> identity_secret<span>;</span>
</span><span>  identity_commitment <span>===</span> identityHasher<span>.</span><span>out</span><span>;</span>
</span><span>
</span><span>  component signatureHasher <span>=</span> <span><span>Poseidon</span></span><span>(</span><span>2</span><span>)</span><span>;</span>
</span><span>  signatureHasher<span>.</span><span>inputs</span><span>[</span><span>0</span><span>]</span> <span>&lt;=</span><span>=</span> identity_secret<span>;</span>
</span><span>  signatureHasher<span>.</span><span>inputs</span><span>[</span><span>1</span><span>]</span> <span>&lt;=</span><span>=</span> message<span>;</span>
</span><span>  signature <span>&lt;=</span><span>=</span> signatureHasher<span>.</span><span>out</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span>component main <span>{</span><span>public</span> <span>[</span>identity_commitment<span>,</span> message<span>]</span><span>}</span> <span>=</span> <span><span>SignMessage</span></span><span>(</span><span>)</span><span>;</span>
</span></code></pre></div><p>You&#39;ll also have been given all the tools and techniques necessary to modify this to support the group signature scheme mentioned above.</p><h3 id="pre-requisites"><a href="#pre-requisites" aria-hidden="true" tabindex="-1"><span></span></a>Pre-requisites</h3><p>We assume you are a software engineer with working experience in more than one programming language, who has basic familiar with using Unix-style command line interfaces. We also assume you have a passing familiarity with concepts like <em>digital signatures</em>, <em>public-key cryptography</em> and <em>hash functions</em>. Nonetheless, we&#39;ll introduce their relevant properties as they become relevant.</p><p>When it comes to <em>Zero Knowledge Proofs</em>, we assume you&#39;ve read my previous post, <a target="_blank" rel="noopener noreferrer" href="https://zkintro.com/articles/friendly-introduction-to-zero-knowledge"><em>A Friendly Introduction to Zero Knowledge</em></a>. If you haven&#39;t read this article, we&#39;ll quickly recap the most important things here. For better understanding, we recommend reading the above article first. If you have already read it, you can safely skip the below.</p><h3 id="recap-of-zkps"><a href="#recap-of-zkps" aria-hidden="true" tabindex="-1"><span></span></a>Recap of ZKPs</h3><p>Zero Knowledge Proofs (ZKPs) are a fairly new form of cryptography that have seen more practical applications lately. While traditional cryptography allows us to do things like signatures and encryption, ZKPs allows us to prove arbitrary statements in a general-purpose way.</p><p>Outside of proving arbitrary statements, ZKPs give us two key properties: privacy and compression. These are also known as zero knowledge and succinctness, respectively. Privacy means we can prove something without revealing anything else. Compression means the proof of an arbitrary statement stays roughly the same size regardless of how complex the computation we are proving is. ZKPs are also general-purpose. Roughly speaking, this is the difference between a calculator, made for a specific task, and a computer, that can compute anything.</p><p>Two concrete examples of ZKPs:</p><ul><li>We can take a digital identity card and prove that we are over 18 years old<ul><li>Without revealing anything else, like your full name or address</li></ul></li><li>We can prove that all state transitions have been executed correctly<ul><li>Such as in a public blockchain, with the resulting proof being very small</li></ul></li></ul><p>We can program many common types of ZKPs by writing special programs known as circuits. This allows one party, a prover, to create a proof of some statement. Another party, known as a verifier, can then verify this proof. Like a normal program, this program can take input and produce output. For these special programs, we can specify if the input is private or public. If it is private, it means only the prover can see this input. We program circuits by specifying constraints. One example of a constraint is &#34;in a Sudoku puzzle all numbers 1 through 9 must be used exactly once in a row&#34;.</p><p>ZKPs are fairly new but they are already used a lot in public blockchains, for example, to allow private payments with fungible money, or to allow more transactions to be processed faster.</p><p>More and more applications are being discovered and developed every day. There are also a lot of different flavors of ZKPs, all with their own set of trade-offs, and it is a very active area of research. These different flavors are being developed rapidly, and allow for increased efficiency and other affordances.</p><h2 id="overview"><a href="#overview" aria-hidden="true" tabindex="-1"><span></span></a>Overview</h2><p>We are going to use Circom and Groth16. Circom is a domain-specific language (DSL) for writing ZKP circuits. Groth16 is a common and popular proving system. Roughly speaking, a proving system is just one way that you can program ZKPs. Other DSLs and proving systems also exists.</p><p>We&#39;ll start by installing some tools and dependencies. After that, we&#39;ll proceed in the following rough steps:</p><ul><li>Write (write circuit)</li><li>Build (build circuit)</li><li>Setup (trusted setup)</li><li>Prove (generate proof)</li><li>Verify (verify proof)</li></ul><p>After having gone through this flow once, we&#39;ll look at some problems with the current approach. We&#39;ll then make several incremental improvements, building up to the signature scheme above. Along the way, we&#39;ll explain necessary concepts and syntax.</p><p>At the end of each section, we&#39;ll also include some simple exercises that will check your understanding. These exercises are recommended. At the very end of the article we&#39;ll also include a list of problems. Problems are optional and require a lot more effort.</p><h3 id="preparation"><a href="#preparation" aria-hidden="true" tabindex="-1"><span></span></a>Preparation</h3><p>First up, we have to install some tools and dependencies. We have prepared a <a target="_blank" rel="noopener noreferrer" href="https://github.com/oskarth/zkintro-tutorial">git repo</a> that makes it easier for you to get started without getting lost in the weeds with details. If you prefer not to install any software, see the end of this section.</p><p>The pre-requisites we require are:</p><ul><li><code>rust</code> (the programming language)</li><li><code>just</code> (a modern <code>make</code>)</li><li><code>npm</code> (package manager for JavaScript)</li></ul><p>The ZKP tools we will actually use are:</p><ul><li><code>circom</code> (for building our special program, or <em>circuit</em>)</li><li><code>snarkjs</code> (for setup, and generating/verifying proofs)</li><li><code>just</code> tasks (to simplify common operations related to above)</li></ul><p>To install the above as well as make building and running things easier you can clone and use the <a target="_blank" rel="noopener noreferrer" href="https://github.com/oskarth/zkintro-tutorial">git repo</a>. This should work on any Unix-like system like MacOS and Linux. If you use Windows we suggest using a Linux VM, Windows Subsystem for Linux (WSL), or similar for development.</p><div><pre><code><span>
</span><span><span>git</span> clone git@github.com:oskarth/zkintro-tutorial.git
</span><span><span>cd</span> zkintro-tutorial
</span><span>
</span><span>
</span><span><span>less</span> ./scripts/prepare.sh
</span><span>./scripts/prepare.sh
</span></code></pre></div><p>We recommend you skim the contents of <code>./scripts/prepare.sh</code> to see what this will install, or if you prefer to install things manually. Once executed you should see <code>Installation complete</code> and no errors.</p><p>If you get stuck, please see the latest official documentation <a target="_blank" rel="noopener noreferrer" href="https://docs.circom.io/getting-started/installation/">here</a>. Once done, you should have the following versions (or higher) installed:</p><div><pre><code><span><span>&gt;</span> circom --version
</span><span>circom compiler <span>2.1</span>.8
</span><span>
</span><span><span>&gt;</span> snarkjs <span>|</span> <span>head</span> -n <span>1</span>
</span><span>snarkjs@0.7.4
</span></code></pre></div><p>In the repo there is a <code>justfile</code> that defines a set of common commands. These <code>just</code> commands aim to simplify common operations on ZKPs, so you can focus on conceptual understanding of the actual steps involved. This makes the process much less error-prone when you are starting out.</p><p>If at any time you want to see in more detail what commands are being executed, we recommend you look at the <code>justfile</code> and the various scripts in the <code>scripts</code> folder.</p><p>We highly recommend installing the above software for following along the tutorial and building intuition. However, If you do not want to install any software, you can follow along in a limited capacity using an online REPL (Read-Eval-Print Loop) tool such <a target="_blank" rel="noopener noreferrer" href="https://zkrepl.dev">zkrepl.dev</a>. If you do not want to install <code>just</code> and prefer to execute all the commands yourself you can do so with a little extra effort by using the accompanying shell scripts.</p><h2 id="first-iteration"><a href="#first-iteration" aria-hidden="true" tabindex="-1"><span></span></a>First iteration</h2><p>We are now ready to start coding. To build up to the signature scheme mentioned above, we will start with a very simple program, the equivalent of a &#34;Hello World&#34; in other programming languages.</p><p>In practical terms, we will write a special program that will help us prove knowledge of two secret numbers whose product is a public number, <em>without ever revealing the secret numbers themselves</em>. For example, the public number might be &#34;33&#34; and the secret numbers are &#34;11&#34; and &#34;3&#34;. This is an important stepping stone towards digital signatures and will build help intuition for how ZKPs work. If you are familiar with public-key cryptography, you can - very loosely - think of the secret numbers as a &#34;private key&#34; and the public number as a &#34;public key&#34;.</p><p>Since this is a different way of programming involving many new concepts, don&#39;t worry if things don&#39;t make sense at first. You can always keep going, focusing on the code, generating proofs, etc and come back to a specific section later on.</p><h3 id="write-a-special-program"><a href="#write-a-special-program" aria-hidden="true" tabindex="-1"><span></span></a>Write a special program</h3><p>Unlike most other programming, writing these special programs, circuits, look a bit different. What we are interested in is proving a <em>set of constraints</em>. <sup><a href="#user-content-fn-4" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-4">4</a></sup> The simplest set of constraints we can prove consists of a single constraint. <sup><a href="#user-content-fn-5" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-5">5</a></sup> What we will constrain is that two numbers multiplied by each other equal a third one.</p><p>Go to the <code>example1</code> folder in the <code>zkintro-tutorial</code> repository above. There&#39;s a skeleton program in <code>example1.circom</code>. Modify it to look like this:</p><div><pre><code><span>pragma circom <span>2.0</span><span>.0</span><span>;</span>
</span><span>
</span><span>template <span><span>Multiplier2</span></span> <span>(</span><span>)</span> <span>{</span>
</span><span>  signal input a<span>;</span>
</span><span>  signal input b<span>;</span>
</span><span>  signal output c<span>;</span>
</span><span>  c <span>&lt;=</span><span>=</span> a <span>*</span> b<span>;</span>
</span><span><span>}</span>
</span><span>
</span><span>component main <span>=</span> <span><span>Multiplier2</span></span><span>(</span><span>)</span><span>;</span>
</span></code></pre></div><p>This is our special program, or <em>circuit</em>. <sup><a href="#user-content-fn-6" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-6">6</a></sup> Going line by line:</p><ul><li><code>pragma circom 2.0.0;</code>- defines the version of Circom being used</li><li><code>template Multiplier()</code> - templates are the equivalent to objects in most programming languages, a common form of abstraction</li><li><code>signal input a;</code> - our first input, <code>a</code>; inputs are private by default</li><li><code>signal input b;</code> - our second input, <code>b</code>; also private by default</li><li><code>signal output b;</code> - our output, <code>c</code>; outputs are always public</li><li><code>c &lt;== a * b;</code> - this does two things: assigns the signal <code>c</code> a value <em>and</em> constrains <code>c</code> to be equal to the product of <code>a</code> and <code>b</code></li><li><code>component main = Multiplier2()</code> - instantiates our main component</li></ul><p>The most important line is <code>c &lt;== a * b;</code>. This is where we actually declare our constraint. This expression is actually a combination of two: <code>&lt;--</code> (assignment) and <code>===</code> (equality constraint). <sup><a href="#user-content-fn-7" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-7">7</a></sup> A constraint in Circom can only use operations involving constants, addition or multiplication. It enforces that both sides of the equation must be equal. <sup><a href="#user-content-fn-8" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-8">8</a></sup></p><h3 id="on-constraints"><a href="#on-constraints" aria-hidden="true" tabindex="-1"><span></span></a>On constraints</h3><p>How do constraints work? In the context of something like Sudoku, we might say a constraint is &#34;a number between 1 and 9&#34;. In the context of Circom however, this is not a single constraint, but instead something we have to express using a set of simpler equality constraints (<code>===</code>). <sup><a href="#user-content-fn-9" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-9">9</a></sup></p><p>Why is this the case? This has to do with what is mathematically going on under the hood. Fundamentally, most ZKPs use <em>arithmetic circuits</em> which represents computation over <em>polynomials</em>. When dealing with polynomials, you can easily introduce constants, add them together, multiply them and check if they are equal to each other. <sup><a href="#user-content-fn-10" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-10">10</a></sup> Other operations have to be expressed in terms of these fundamental operations. You do not have to understand this in detail in order to write ZKPs, but it can be useful to have some intuitition of what is going on under the hood. <sup><a href="#user-content-fn-11" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-11">11</a></sup></p><p>We can visualize the circuit as follows:</p><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271278%27%20height=%27556%27/%3e"/></span><img alt="example1 circuit" src="https://zkintro.com/static/images/zkintro_example1_circuit.png" decoding="async" data-nimg="intrinsic"/></span></p><h3 id="building-our-circuit"><a href="#building-our-circuit" aria-hidden="true" tabindex="-1"><span></span></a>Building our circuit</h3><p>For your reference, the final file can be found in <code>example1-solution.circom</code>. For more details on the syntax, see the <a target="_blank" rel="noopener noreferrer" href="https://docs.circom.io/circom-language/signals/">official documentation</a>.</p><p>We can compile our circuit by running:</p><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271376%27%20height=%27382%27/%3e"/></span><img alt="example1 build" src="https://zkintro.com/static/images/zkintro_example1_build.png" decoding="async" data-nimg="intrinsic"/></span></p><p>This is a thin wrapper for calling <code>circom</code> to create a <code>example1.r1cs</code> and <code>example1.wasm</code> file. You should see something like:</p><div><pre><code><span>template instances: <span>1</span>
</span><span>non-linear constraints: <span>1</span>
</span><span>linear constraints: <span>0</span>
</span><span>public inputs: <span>0</span>
</span><span>private inputs: <span>2</span>
</span><span>public outputs: <span>1</span>
</span><span>wires: <span>4</span>
</span><span>labels: <span>4</span>
</span><span>Written successfully: example/target/example1.r1cs
</span><span>Written successfully: example/target/example1_js/example1.wasm
</span></code></pre></div><p>In this case, we have the following:</p><ul><li>two private inputs, <code>a</code> and <code>b</code></li><li>one public output, <code>c</code></li><li>one (non-linear) constraint, <code>c &lt;== a * b</code></li></ul><p>We will ignore other parts of the output above for now. <sup><a href="#user-content-fn-12" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-12">12</a></sup> Now we have two files: <code>example1.r1cs</code> and <code>example1.wasm</code>.</p><p><code>r1cs</code> stands for <em>Rank 1 Constraint System</em>. This file contains our circuit in binary form. and corresponds to how we define our constraints mathematically. <sup><a href="#user-content-fn-13" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-13">13</a></sup></p><p>The <code>.wasm</code> file contains WebAssembly, which is what we need to generate our <em>witness</em>. The witness is how we specify the inputs that we want to keep private while still using them to create a proof.</p><p>We are not quite ready to make proofs yet though. First we need to perform a <em>setup</em> to get our prover and verification key.</p><p>Don&#39;t worry if it all doesn&#39;t make sense yet. It is a new way of doing things and it takes a while to get used to.</p><h3 id="trusted-setup"><a href="#trusted-setup" aria-hidden="true" tabindex="-1"><span></span></a>Trusted setup</h3><p>With the artifacts we generated above, we can perform a <em>trusted setup</em>.</p><p>A trusted setup is something we run once as a pre-processing step. This generates what is called a <em>Common Reference String</em> (CRS), which consists of a <em>proving key</em> and a <em>verification key</em>. These keys can then be used every time we want to generate and verify proofs, respectively.</p><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271500%27%20height=%27376%27/%3e"/></span><img alt="Trusted setup" src="https://zkintro.com/static/images/zkintro_example1_setup1.png" decoding="async" data-nimg="intrinsic"/></span></p><p>Why do we need these keys and who should have access to them? The prover key embeds all the information necessary to be able to generate a proof in a zero-knowledge preserving fashion for that specific circuit. Similarly, the verifier key embeds all the information necessary to verify that the proof is indeed correct. These aren&#39;t private keys, but instead information that can and should be publicly distributed. Any party that needs to generate or verify a proof should have access to them. <sup><a href="#user-content-fn-14" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-14">14</a></sup></p><p>Why do we call it a trusted setup? Performing a setup is a process that involves multiple participants and it is sometimes called a <em>ceremony</em>. <sup><a href="#user-content-fn-15" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-15">15</a></sup> All participants cooperate to create a cryptographic &#34;secret&#34;, and this is the basis of how the proving and verification keys are constructed. If this process is manipulated, cryptographically it may be possible to create false proofs or falsely claim invalid proofs as verified. Hence, there&#39;s an assumption of trust that least some participants are honest in the setup process, giving rise to the term &#34;trusted setup&#34;.</p><p>As a starting point, we are going to run the trusted setup ourselves. Run the following:</p><p><code>just trusted_setup example1</code></p><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271260%27%20height=%27318%27/%3e"/></span><img alt="example1 trusted setup" src="https://zkintro.com/static/images/zkintro_example1_setup2.png" decoding="async" data-nimg="intrinsic"/></span></p><p>You&#39;ll be asked to supply some random text or entropy twice. <sup><a href="#user-content-fn-16" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-16">16</a></sup> Once completed you should see &#34;Trusted setup completed.&#34; and the location of the keys. The file ending in <code>.zkey</code> is our proving key. While going into the details of trusted setups is outside of the scope of this article, there are a few things that are useful to be aware of.</p><p>First, what is the problem with the above approach? Since we have just one participant, everyone else who is using the cryptographic key material from that setup is trusting that individual and their computer environment. This wouldn&#39;t work in a production scenarios where&#39;d want to maximize the number of participants to make the setup more trustworthy. If we have 100 people who participate, because of how this cryptographic secret is constructed, it is enough if one single individual is honest. <sup><a href="#user-content-fn-17" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-17">17</a></sup></p><p>It is also worth knowing that different ZKP systems have different properties in terms of security, performance and affordances. While all ZKP systems require some form of setup, not all of them require a trusted setup. Of those that do, some differ in their requirements.</p><p>With Circom we are using the <em>Groth16 proof system</em> which does requires a trusted setup. Specifically, the setup is split into two phases: phase 1 and phase 2. Phase 1 is independent of a circuit and can be used by any ZKP program up to a certain size, whereas phase 2 is <em>circuit-specific</em>. When we ran the above command, we performed both phases.</p><p>You might be wondering, why would you use a trusted setup at all if you can avoid it? A lot of people agree with this view. However, there are still good reasons people use these systems - such as more mature tooling and ecosystem, as well as cheap verification costs. Cheap verification costs is something that is traditionally very important, especially when we are verifying proofs on a public blockchain like Ethereum. Depending on your use case, your choice will likely differ. In a different article we&#39;ll look more into trusted setups and their trade-offs, as well as different proof systems.</p><h3 id="generate-proof"><a href="#generate-proof" aria-hidden="true" tabindex="-1"><span></span></a>Generate proof</h3><p>With the trusted setup completed above, we have a proving key and verification key. We can now generate a proof that we know two secret value whose product is another public number.</p><p>Specifically, let&#39;s prove that we know that 33 can be constructed from multiplying the numbers 3 and 11. Recall that our private input consists of signals <code>a</code> and <code>b</code>. We specify this in the <code>example1/input.json</code> file as follows:</p><p>That is, we specify the input as a JSON map, where the key is the signal name and the value is the value we want to assign it. Notice that the value is a string, even though it is conceptually a number. This is a quirk in Circom and its JS API. Due to the nature of ZKPs, we often deal with very large numbers that require the use of <em>BigInt</em>. The easiest way to specify such a large number in a JSON file is as a string that will then be converted to a BigInt.</p><p>We can create a proof using our compiled circuit (in WASM form), our proving key and the input by running the following:</p><p><code>just generate_proof example1</code></p><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271434%27%20height=%27488%27/%3e"/></span><img alt="example1 generate proof" src="https://zkintro.com/static/images/zkintro_example1_generate_proof.png" decoding="async" data-nimg="intrinsic"/></span></p><p>Under the hood, this command takes the input and generates a <em>witness</em> for our specific circuit. <sup><a href="#user-content-fn-18" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-18">18</a></sup> Normally, by witness, we simply mean the private input we use to generate a proof. In the context of Circom, a witness is the complete assignment of all signals, both private and public, in a form that the prover software can process. This form is an internal representation in a binary format. <sup><a href="#user-content-fn-19" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-19">19</a></sup></p><p>With this generated witness, we can create a proof using <code>snarkjs</code>. Finally, we end up with a proof and some public output.</p><p>The proof looks something like this:</p><div><pre><code><span><span>{</span>
</span><span>  <span>&#34;pi_a&#34;</span><span>:</span> <span>[</span><span>&#34;15932[...]3948&#34;</span><span>,</span> <span>&#34;66284[...]7222&#34;</span><span>,</span> <span>&#34;1&#34;</span><span>]</span><span>,</span>
</span><span>  <span>&#34;pi_b&#34;</span><span>:</span> <span>[</span>
</span><span>    <span>[</span><span>&#34;17667[...]0525&#34;</span><span>,</span> <span>&#34;13094[...]1600&#34;</span><span>]</span><span>,</span>
</span><span>    <span>[</span><span>&#34;12020[...]5738&#34;</span><span>,</span> <span>&#34;10182[...]7650&#34;</span><span>]</span><span>,</span>
</span><span>    <span>[</span><span>&#34;1&#34;</span><span>,</span> <span>&#34;0&#34;</span><span>]</span>
</span><span>  <span>]</span><span>,</span>
</span><span>  <span>&#34;pi_c&#34;</span><span>:</span> <span>[</span><span>&#34;18501[...]3969&#34;</span><span>,</span> <span>&#34;13175[...]3552&#34;</span><span>,</span> <span>&#34;1&#34;</span><span>]</span><span>,</span>
</span><span>  <span>&#34;protocol&#34;</span><span>:</span> <span>&#34;groth16&#34;</span><span>,</span>
</span><span>  <span>&#34;curve&#34;</span><span>:</span> <span>&#34;bn128&#34;</span>
</span><span><span>}</span>
</span></code></pre></div><p>This specifies the proof in the form of some mathematical objects (three elliptic curve elements), <code>pi_a</code>, <code>pi_b</code>, and <code>pi_c</code>. <sup><a href="#user-content-fn-20" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-20">20</a></sup> It also includes some metadata about the protocol (<code>groth16</code>) and the <em>curve</em> (<code>bn128</code>, a mathematical implementation detail we&#39;ll ignore for now) used. This allows the verifier to know what to do with this proof to verify it correctly.</p><p>Notice how short the proof is; regardless of how complex our special program is it&#39;ll only be this size. This showcases the <em>succinctness</em> property of ZKPs we talked about in our <a target="_blank" rel="noopener noreferrer" href="https://zkintro.com/articles/friendly-introduction-to-zero-knowledge#compression"><em>friendly introduction</em></a>.</p><p>The command above also outputs our <em>public output</em>:</p><p>This is a list of all the public outputs corresponding to our witness and circuit. In this case, there&#39;s a single public output that corresponds to<code>c</code>: 33. <sup><a href="#user-content-fn-21" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-21">21</a></sup></p><p>What have we proven? That we know two secret values, <code>a</code> and <code>b</code>, whose product is 33. This showcases the <em>privacy</em> property we talked about in the previous article.</p><p>Note that the proof isn&#39;t useful in isolation, it requires the public output that comes with it.</p><h3 id="verify-proof"><a href="#verify-proof" aria-hidden="true" tabindex="-1"><span></span></a>Verify proof</h3><p>Next up, let&#39;s verify this proof. Run:</p><p><code>just verify_proof example1</code></p><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271488%27%20height=%27470%27/%3e"/></span><img alt="example1 verify proof" src="https://zkintro.com/static/images/zkintro_example1_verify_proof.png" decoding="async" data-nimg="intrinsic"/></span></p><p>This takes the verification key, the public output, and the proof. With this we are able to verify the proof. It should print &#34;Proof verified&#34;. Notice how the verifier is never exposed to any of the private inputs.</p><p>What happens if we change the output? Open <code>example1/target/public.json</code> and change the 33 to 34, then run the command above again.</p><p>You&#39;ll notice that the proof is not verified anymore. This is because our proof does not prove that we have two numbers whose product is 34.</p><p>Congratulations, you&#39;ve now written your first ZKP program, performed a trusted setup, generated a proof and finally verified it!</p><h3 id="exercises"><a href="#exercises" aria-hidden="true" tabindex="-1"><span></span></a>Exercises</h3><ol><li>What are the two key properties of ZKPs and what do they mean?</li><li>What is the role of a prover and what input does she need? What about a verifier?</li><li>Explain what the line <code>c &lt;== a * b;</code> does.</li><li>Why do we need to perform a trusted setup? How do we use its artifacts?</li><li>Code: Finish <code>example1</code> until you generated and verified a proof.</li></ol><h2 id="second-iteration"><a href="#second-iteration" aria-hidden="true" tabindex="-1"><span></span></a>Second iteration</h2><p>With the above circuit, we are proving that we know the product of two (secret) numbers. This is closely related to the problem of <em>prime factorization</em>, which is the basis of a lot of cryptography. <sup><a href="#user-content-fn-22" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-22">22</a></sup> The idea is that if you have a very large number, it is hard to find two prime numbers whose product is that large number. On the flip side, it is very easy to check if the product of two numbers is equal to another number <sup><a href="#user-content-fn-23" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-23">23</a></sup>.</p><p>However, there is a big problem with our circuit. Can you see it?</p><p>We can easily change our input to be &#34;1&#34; and &#34;33&#34;. That is, a number <code>c</code> is always the product of 1 and <code>c</code>. That&#39;s not very impressive at all is it?</p><p>What we want to do is to add another <em>constraint</em>, that neither <code>a</code> or <code>b</code> can be equal to 1. That way, we are forced to do proper integer factorization.</p><p>How can we add this constraint and what changes do we need to make?</p><h3 id="updating-our-circuit"><a href="#updating-our-circuit" aria-hidden="true" tabindex="-1"><span></span></a>Updating our circuit</h3><p>We are going to work with the <code>example2</code> folder for these changes. Unfortunately, we can&#39;t just write <code>a !== 1</code>, because this isn&#39;t a valid constraint. <sup><a href="#user-content-fn-24" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-24">24</a></sup> It isn&#39;t made up of only constants, addition, multiplication and equality checks. How do we express that &#34;something is not&#34;?</p><p>This is not immediately intuitive, and this type of problem is where a lot of the art of writing circuits come into play. Developing this skill takes time and is outside of the scope of this initial tutorial; fortunately there are many good resources for this. <sup><a href="#user-content-fn-25" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-25">25</a></sup></p><p>There are some common idioms though. The basic idea is to use a <code>IsZero()</code> template that checks if an expression is equal to zero or not. It outputs 1 for true, and 0 for false.</p><p>It is often helpful to use a truth table <sup><a href="#user-content-fn-26" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-26">26</a></sup> to show possible values. Here&#39;s the truth table for <code>IsZero()</code>:</p><table><thead><tr><th>in</th><th>out</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>n</td><td>0</td></tr></tbody></table><p>This is such a useful building block that it is included in Circom&#39;s library, <code>circomlib</code>. In <code>circomlib</code> there are also many other useful components. <sup><a href="#user-content-fn-27" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-27">27</a></sup></p><p>We can include this by creating an <code>npm</code> project (JavaScript) and adding it as a dependency. In the <code>example2</code> folder we have already done this for you. To import the relevant module, we add the following line to the top of <code>example2.circom</code>:</p><p><code>include &#34;circomlib/circuits/comparators.circom&#34;;</code></p><p>Using <code>IsZero()</code>, we can check if either a or b is equal to 1. Modify the <code>example2.circom</code> file to contain the following lines:</p><div><pre><code><span>component isZeroCheck <span>=</span> <span><span>IsZero</span></span><span>(</span><span>)</span><span>;</span>
</span><span>isZeroCheck<span>.</span><span>in</span> <span>&lt;=</span><span>=</span> <span>(</span>a <span>-</span> <span>1</span><span>)</span> <span>*</span> <span>(</span>b <span>-</span> <span>1</span><span>)</span><span>;</span>
</span><span>isZeroCheck<span>.</span><span>out</span> <span>===</span> <span>0</span><span>;</span>
</span></code></pre></div><p>In the above code snippet, we create a new component <code>isZeroCheck</code>, instantiating the <code>IsZero()</code> template. If either a or b is equal to 1, <code>isZeroCheck.in</code> will be assigned 0, and <code>isZeroCheck.out</code> will be 1. Since we have a constraint that says <code>isZeroCheck.out === 0</code>, this constraint will fail. This means that we can no longer provide inputs where either a or b is equal to 1.</p><p>I encourage you to convince yourself, either in your head or using pen and paper (perhaps using a truth table?), that this is true. If you are up for a challenge, you can try to figure out how <code>IsZero()</code> is implemented. it is only a few lines of code. You can see the code in <code>circomlib</code>&#39;s <code>comparators.circom</code> file. <sup><a href="#user-content-fn-28" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-28">28</a></sup></p><p>For your reference, the final file can be found in <code>example2-solution.circom</code>. With the changes above, we can install the npm <code>circomlib</code> dependency and build our circuit with:</p><p><code>just build example2</code></p><h3 id="re-running-our-trusted-setup"><a href="#re-running-our-trusted-setup" aria-hidden="true" tabindex="-1"><span></span></a>Re-running our trusted setup</h3><p>With Circom and Groth16, any time we change our circuit we have to re-run our trusted setup. This means you better be sure your circuit is solid before you release it. Especially if you are running a proper ceremony involving many participants.</p><p>More specifically, we only have to run the circuit-specific (phase 2) trusted setup again. This is because phase 1 is generic for <em>any</em> Groth16 circuit written in Circom, up to a certain size. When we performed the trusted setup above, we did both phase 1 and phase 2, but omitted the details of phase 1 for simplicity. Here are some more details on phase 1 to give a more complete picture.</p><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271358%27%20height=%27404%27/%3e"/></span><img alt="Trusted setup (both phases)" src="https://zkintro.com/static/images/zkintro_example2_setup_both.png" decoding="async" data-nimg="intrinsic"/></span></p><p>The result of the phase 1 trusted setup is kept in a <code>.ptau</code> file, where ptau stands for powers of tau. <sup><a href="#user-content-fn-29" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-29">29</a></sup> Mathematically, this file contains powers of some random secrets. This is what allows us to &#34;accommodate&#34; some number of number of constraints. We don&#39;t need to understand how this works mathematically, but there are two key facts that are useful to know: (a) <code>.ptau</code> is circuit-independent (b) the size of it indicates its capacity. The &#34;capacity&#34; of a given ptau is <code>2^n - 1</code> constraints, where <code>n</code> is some number. For example, <code>pot12.ptau</code> indicates that the number of constraints it can accommodate is <code>2^12 - 1</code>, or slighty over 4000 constraints.</p><p>Since we don&#39;t want to re-run our phase 1 again, we just want to run phase 2. This will use the previously generated <code>pot12.ptau</code> (stored in the <code>ptau</code> directory) as input. We can run our phase 2 trusted setup with:</p><div><pre><code><span>just trusted_setup_phase2 example2
</span></code></pre></div><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271380%27%20height=%27294%27/%3e"/></span><img alt="example2 trusted setup" src="https://zkintro.com/static/images/zkintro_example2_setup2.png" decoding="async" data-nimg="intrinsic"/></span></p><h3 id="testing-our-changes"><a href="#testing-our-changes" aria-hidden="true" tabindex="-1"><span></span></a>Testing our changes</h3><p>With this, we can run:</p><div><pre><code><span>just generate_proof example2
</span><span>just verify_proof example2
</span></code></pre></div><p>It still generates and verifies the proof as expected.</p><p>If we change the <code>example2/input.json</code> inputs to say <code>1</code> and <code>33</code> and try to run above we will see an assert error. That is, Circom won&#39;t even let us generate a proof, because the input is breaking our constraints.</p><h3 id="complete-flow-diagram"><a href="#complete-flow-diagram" aria-hidden="true" tabindex="-1"><span></span></a>Complete flow diagram</h3><p>Now that we have gone through the entire flow twice, let&#39;s take a step back and see how all of the pieces fit together.</p><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27986%27%20height=%271120%27/%3e"/></span><img alt="example2 complete flow" src="https://zkintro.com/static/images/zkintro_example2_complete_flow.png" decoding="async" data-nimg="intrinsic"/></span></p><p>Hopefully things are starting to make some sense. With that, let&#39;s kick it up a notch and make our circuit more useful.</p><h3 id="exercises-1"><a href="#exercises-1" aria-hidden="true" tabindex="-1"><span></span></a>Exercises</h3><ol start="6"><li>Why do we have to run phase 2 but not phase 1 of our trusted setup for <code>example2</code>?</li><li>What was the main problem with the previous example and how did we fix it?</li><li>Code: Finish <code>example2</code> until you failed to generate a proof.</li></ol><h2 id="third-iteration"><a href="#third-iteration" aria-hidden="true" tabindex="-1"><span></span></a>Third iteration</h2><p>With the above circuit we have proven that we know the product of two secret values. That on its own is not very useful. Something that is useful in the real world is a <em>digital signature scheme</em>. With it, you can prove to someone else that you wrote a specific message. How would we go about implementing this using ZKPs? To get there, we must first cover some basic concepts.</p><p>Now would be a good time for a short break to get a fresh cup of your favorite beverage.</p><h3 id="digital-signatures"><a href="#digital-signatures" aria-hidden="true" tabindex="-1"><span></span></a>Digital signatures</h3><p>Digital signatures exists already and are everywhere in our digital age. The modern Internet wouldn&#39;t function without them. Usually, these are implemented using <em>public-key cryptography</em>. In public-key cryptography you have a private key and a public key. The private key is for your eyes only, and the public key is shared publicly, representing your identity.</p><p>A digital signature scheme consist of the following parts:</p><ul><li><strong>Key generation</strong>: Generate a private key and a corresponding public key</li><li><strong>Signing</strong>: Create a signature using the private key and the message</li><li><strong>Signature verification</strong>: Verify message was signed by corresponding public key</li></ul><p>While the specifics look different, the program we wrote and the key generation algorithm above share a common element: they both use a <em>one-way function</em>, and more specifically a <em>trapdoor function</em>. A trapdoor is something that is easy to fall into and hard to climb out of (unless you can find a hidden ladder). <sup><a href="#user-content-fn-30" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-30">30</a></sup></p><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27640%27%20height=%27511%27/%3e"/></span><img alt="example3 trapdoor" src="https://zkintro.com/static/images/zkintro_example3_trapdoor.png" decoding="async" data-nimg="intrinsic"/></span></p><p>For public-key cryptography, it is easy to construct the public key from the private key, but very hard to go the other way. The same is true for our previous program. If the two secret numbers are very large prime numbers, it is very hard to turn that product back into the original values. Modern public-key cryptography often uses <em>elliptic curve cryptography</em> under the hood.</p><p>Traditionally, creating cryptographic protocols like these digital signature schemes is a lot of hard work and requires coming up with a specific protocol that involves using some clever math. We don&#39;t want to do that. Instead, we want to write a program using ZKPs that achieves the same result.</p><p>Instead of this: <sup><a href="#user-content-fn-31" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-31">31</a></sup></p><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271298%27%20height=%27622%27/%3e"/></span><img alt="Signature verification" src="https://zkintro.com/static/images/zkintro_example3_sigverify.png" decoding="async" data-nimg="intrinsic"/></span></p><p>We just want to write a program, generate a proof of what we want, and then verify this proof.</p><h3 id="hash-functions-and-commitments"><a href="#hash-functions-and-commitments" aria-hidden="true" tabindex="-1"><span></span></a>Hash functions and commitments</h3><p>Instead of using elliptic curve cryptography, we are going to use two much simpler tools: <em>hash functions</em> and <em>commitments</em>.</p><p>A hash function is also a one-way function. For example, on the command line we can use the SHA-256 hash function like this:</p><div><pre><code><span><span>echo</span> -n <span>&#34;foo&#34;</span> <span>|</span> shasum -a <span>256</span>
</span></code></pre></div><p>To produce the hash of &#34;foo&#34;: <code>0beec7[...]a8a33</code> (abbreviated). <sup><a href="#user-content-fn-32" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-32">32</a></sup></p><p>On its own, a hash function is not a trapdoor function. There&#39;s no special knowledge that allows us to retrieve the original value. It acts more as a meat grinder and less as a trapdoor with a hidden ladder.</p><p>What about commitments? A <em>commitment</em> is simply a way to commit (&#34;to promise&#34;) to a secret value so we can&#39;t change our mind about it later. In our case, we will use a commitment to generate the equivalent of a public key using some secret value. We can do this using a hash function.</p><p>Commitment schemes are a very common cryptographic primitive. <sup><a href="#user-content-fn-33" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-33">33</a></sup> They allow us to:</p><ul><li><strong>commit</strong>: Commit to a specific value while keeping it hidden</li><li><strong>reveal</strong>: Reveal this value so it can be verified to be correct</li></ul><p>This gives us two key properties:</p><ul><li><strong>hiding</strong>: the value stays hidden</li><li><strong>binding</strong>: you can&#39;t change your mind about the value</li></ul><p>One way to think about a commitment is to imagine giving a lock box to a friend. You can&#39;t change the contents of the box after the fact, but your friend can&#39;t look inside it. Only when you give them the key can they open it.</p><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27360%27%20height=%27480%27/%3e"/></span><img alt="example3 lockbox" src="https://zkintro.com/static/images/zkintro_example3_lockbox.png" decoding="async" data-nimg="intrinsic"/></span></p><p>Going back to our digital signature scheme, we have:</p><ul><li><strong>Key generation</strong>: Create some secret string and hash it to create a commitment</li><li><strong>Signing</strong>: Create a signature by hashing the secret together with the message</li><li><strong>Verification</strong>: Verify proof using commitment, message and signature (public output)</li></ul><p>In pseudo-code this is what we want to do in our circuit:</p><div><pre><code><span>commitment <span>=</span> <span>hash</span><span>(</span>some_secret<span>)</span>
</span><span>signature <span>=</span> <span>hash</span><span>(</span>some_secret<span>,</span> message<span>)</span>
</span></code></pre></div><p>At this point you probably have some questions. Let&#39;s address a few likely questions you have in your mind.</p><p>First of all, why does this work and why do we need a ZKP for this? When someone is verifying the proof, they only have access to the commitment, message, and signature. There&#39;s no direct way to verify that the commitment corresponds to the secret, without revealing the secret. In this case, we are just &#34;revealing&#34; the secret when generating our proof, so our secret stays safe.</p><p>Second, why use these hash functions and commitments instead of public key cryptography inside the ZKP? You absolutely could do public key cryptography inside a ZKP, and there are valid reasons to do so. It is a lot more costly to implement in terms of constraints than the above. This makes it a lot slower than the above, simpler scheme. As we&#39;ll see in the next section, the choice of hash function turns out to very important.</p><p>Finally, why use a ZKP at all when we already have public key cryptography? In this simple example, there&#39;s no need for a ZKP. However, it acts as a building block for more interesting applications, such as the group signature example mentioned in the beginning of this article. After all, we want to <em>program cryptography</em>.</p><p>That was a lot! Luckily, we are over the hump now. Let&#39;s get coding. Don&#39;t worry if not all of the above made complete sense to you at first. It takes a while to get used to this type of reasoning.</p><h3 id="back-to-the-code"><a href="#back-to-the-code" aria-hidden="true" tabindex="-1"><span></span></a>Back to the code</h3><p>We are going to work from the <code>example3</code> directory.</p><p>To implement digital signatures, the first thing we need to do is to generate our keys. These correspond to the private and public key in public-key cryptography. Because the keys correspond to an identity (you, the prover), we will call these <code>identity_secret</code> and <code>identity_commitment</code>, respectively. Together they form an identity pair.</p><p>These will be used as input to the circuit, together with the message we are signing. As public output, we&#39;ll have the signature, commitment and message. This will allow someone to verify that the signature is indeed correct.</p><p>Because we need the identity pair as input to the circuit, we generate these separately:</p><p><code>just generate_identity</code></p><p>This produces something like this:</p><div><pre><code><span>identity_secret: <span>43047</span><span>[</span><span>..</span>.<span>]</span><span>2270</span>
</span><span>identity_commitment: <span>21618</span><span>[</span><span>..</span>.<span>]</span>0684
</span></code></pre></div><p>In order to keep the secret secure, we use a big and random number. Unlike what we saw before, we are not using a hash function such as SHA-256 to create the commitment. Instead, we are using what is called a <em>ZK-Friendly hash function</em>. That is a special hash function that is optimzed for being used in ZKPs. This matters a lot in terms of performance when you do a lot hashing. The ZK friendly hash function we are using is called the <em>Poseidon hash function</em>. <sup><a href="#user-content-fn-34" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-34">34</a></sup></p><p>Under the hood, this is using the <code>circomlibjs</code> library to wrap <code>circomlib</code>. This is a JavaScript library that allows us to use Circom circuits. This ensures our <code>identity_commitment</code> is generated in exactly the same way in JavaScript/on the command line as in our circuit. If you want to read the script source code it is available in <code>example3/generate_identity.js</code>.</p><p>Just like we did before with <code>IsZero</code>, we need to include the Poseidon template. We do this with the following include:</p><div><pre><code><span>include &#34;circomlib/circuits/poseidon.circom&#34;;
</span></code></pre></div><p>The Poseidon hash template is used as follows:</p><div><pre><code><span>component hasher <span>=</span> <span><span>Poseidon</span></span><span>(</span><span>2</span><span>)</span><span>;</span>
</span><span>hasher<span>.</span><span>inputs</span><span>[</span><span>0</span><span>]</span> <span>=</span> foo<span>;</span>
</span><span>hasher<span>.</span><span>inputs</span><span>[</span><span>1</span><span>]</span> <span>=</span> bar<span>;</span>
</span><span>quux <span>&lt;=</span><span>=</span> hasher<span>.</span><span>out</span>
</span></code></pre></div><p>We specify that the <code>hasher</code> component expects two arguments, specified in the <code>.inputs[]</code> array. It then assigns the output signal to <code>.out</code>. In this example, it takes <code>foo</code> and <code>bar</code> as inputs, hashes them together and the result is <code>quux</code>. <sup><a href="#user-content-fn-35" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-35">35</a></sup></p><p>Finally, we introduce a new piece of syntax:</p><div><pre><code><span>component main <span>{</span><span>public</span> <span>[</span>identity_commitment<span>,</span> message<span>]</span><span>}</span> <span>=</span> <span><span>SignMessage</span></span><span>(</span><span>)</span><span>;</span>
</span></code></pre></div><p>By default, all inputs to our circuit are private. With this, we explicitly mark <code>identity_commitment</code> and <code>message</code> as public. This means they&#39;ll be part of the public output.</p><p>With this information you should have enough to complete the <code>example3.circom</code> circuit. If you are still stuck, you can refer to <code>example3-solution.circom</code> for the full code.</p><p>Like before, we have to build the circuit and run phase 2 of the trusted setup:</p><div><pre><code><span>just build example3
</span><span>just trusted_setup_phase2 example3
</span></code></pre></div><p>When building the circuit, you might notice how the number of constraints went up quite a lot compared to <code>example2</code>. This is primarily due to the use of two Poseidon hashes. <sup><a href="#user-content-fn-36" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-36">36</a></sup></p><h3 id="testing-our-circuit"><a href="#testing-our-circuit" aria-hidden="true" tabindex="-1"><span></span></a>Testing our circuit</h3><p>For reference, here&#39;s an illustration of our completed circuit:</p><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271496%27%20height=%27480%27/%3e"/></span><img alt="example3 circuit" src="https://zkintro.com/static/images/zkintro_example3_circuit.png" decoding="async" data-nimg="intrinsic"/></span></p><p>We can now generate a proof. We have the following input in <code>example3/input.json</code>:</p><div><pre><code><span><span>{</span>
</span><span>  <span>&#34;identity_secret&#34;</span><span>:</span> <span>&#34;21879[...]1709&#34;</span><span>,</span>
</span><span>  <span>&#34;identity_commitment&#34;</span><span>:</span> <span>&#34;48269[...]7915&#34;</span><span>,</span>
</span><span>  <span>&#34;message&#34;</span><span>:</span> <span>&#34;42&#34;</span>
</span><span><span>}</span>
</span></code></pre></div><p>Feel free to change the identity pair to the one you generated yourself with <code>just generate_identity</code>. After all, you want to keep the identity secret to yourself!</p><p>You might notice how the message is just a number quoted as a string (<code>&#34;42&#34;</code>). Unfortunately, because of how constraints work mathematically (using linear algebra and <em>arithmetic circuits</em>) we can only use numbers and not strings. The only operations that are supported inside of circuits are basic arithmetic ones like addition and multiplication. <sup><a href="#user-content-fn-37" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-37">37</a></sup></p><p>We can now generate and verify a proof:</p><div><pre><code><span>just generate_proof example3
</span><span>just verify_proof example3
</span></code></pre></div><p>As before, the proof stays the same size, even though we are doing a lot more things. The public output found in <code>example3/target/public.json</code> is:</p><div><pre><code><span><span>[</span><span>&#34;48968[...]5499&#34;</span><span>,</span> <span>&#34;48269[...]7915&#34;</span><span>,</span> <span>&#34;42&#34;</span><span>]</span>
</span></code></pre></div><p>This corresponds to the signature, commitment, and message respectively.</p><p>Let&#39;s look at how things can go wrong if we are not careful. <sup><a href="#user-content-fn-38" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-38">38</a></sup></p><p>First, what happens if we change the identity commitment to something random in the <code>input.json</code>? You&#39;ll notice we can&#39;t generate proofs anymore. This is because we are also checking the identity commitment inside the circuit itself. It is critical that this relationship between the identity secret and commitment is maintained.</p><p>Second, what happens if we don&#39;t include the message in the output? We do get a proof and it gets verified. But the message could be <em>anything</em>, so it doesn&#39;t actually prove that the you sent a specific message. Similary, what if we don&#39;t include the identity commitment in the public output? This means that the identity commitment could be anything, so we don&#39;t actually know <em>who</em> signed the message.</p><p>As a though exercise, convince yourself (or try out) what could go wrong if we omit either of these two key constraints:</p><ul><li><code>identity_commitment === identityHasher.out</code></li><li><code>signature &lt;== signatureHasher.out</code></li></ul><p>Congratulations, you now know how to program cryptography! <sup><a href="#user-content-fn-39" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-39">39</a></sup></p><h3 id="exercises-2"><a href="#exercises-2" aria-hidden="true" tabindex="-1"><span></span></a>Exercises</h3><ol start="9"><li>What are the three components of a digital signature scheme?</li><li>What is the purpose of using a &#34;ZK-Friendly hash function&#34; like Poseidon?</li><li>What are commitments? How can we use them for a digital signature scheme?</li><li>Why do we mark the identity commitment and message as public?</li><li>Why do we need the identity commitment and signature constraints?</li><li>Code: Finish <code>example3</code> until you generated and verified a proof.</li></ol><h2 id="next-steps"><a href="#next-steps" aria-hidden="true" tabindex="-1"><span></span></a>Next steps</h2><p>With the above digital signature scheme, and some tricks we saw earlier in the article, you have all the tools at your disposal to implement the <em>group signature scheme</em> mentioned at the start of the article. <sup><a href="#user-content-fn-40" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-40">40</a></sup></p><p>Skeleton code exists in <code>example4</code>. All you need is 5-10 lines of code. The only new syntax is a <code>for</code> loop, which works just as in most other language. <sup><a href="#user-content-fn-41" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-41">41</a></sup>.</p><p>This circuit will allow you to:</p><ul><li>sign a message</li><li>proving that you are one of three people (identity commitments)</li><li>but not reveal which one</li></ul><p>You can think of it as a puzzle. The key insight essentially boils down to a single arithmetic expression. Try to work it out on paper if you can. If you get stuck, you can check the solution as before.</p><p>Finally, if you want some extra challenges, here are some ways to extend it:</p><ol><li>Allow arbitrary many people in the group</li><li>Implement a new circuit <code>reveal</code> that proves you signed a specific message</li><li>Implement a new circuit <code>deny</code> that proves you did not sign a specific message</li></ol><p>Creating a cryptographic protocol like this using classical tools would be a huge task requiring a lot of specialized knowledge. <sup><a href="#user-content-fn-42" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-42">42</a></sup> With ZKPs you can become productive and dangerous in an afternoon, treating these problems as programming tasks. And this is just the tip of the iceberg of what we can do.</p><h3 id="exercises-3"><a href="#exercises-3" aria-hidden="true" tabindex="-1"><span></span></a>Exercises</h3><ol start="15"><li>What do group signatures do over normal signatures? How can they be used?</li></ol><h2 id="problems"><a href="#problems" aria-hidden="true" tabindex="-1"><span></span></a>Problems</h2><p>These problems are optional and require a lot more effort.</p><ol><li>Figure out how <code>IsZero()</code> is implemented.</li><li>Code: Finish the group signature scheme above (see <code>example4</code>).</li><li>Code: Extend the group signature example above: Allow for more people and implement <code>reveal</code> and/or <code>deny</code> circuits.</li><li>How would you design a &#34;ZK Identity&#34; system for proving you are over 18? What are some other properties you might want to prove? At a high level, how would you implement it, and what challenges do you see? Research existing solutions to get a better understanding of how they are implemented.</li><li>For public blockchains like Ethereum, sometimes a <em>Layer 2</em> (L2) is used to allow for faster, cheaper and more transactions. At a high level, how would you design an L2 using ZKPs? Explain some challenges you see with this. Research existing solutions to get a better understanding of how they are implemented.</li></ol><h2 id="conclusion"><a href="#conclusion" aria-hidden="true" tabindex="-1"><span></span></a>Conclusion</h2><p>In this tutorial introduction, we&#39;ve gotten familiar with how to write and modify basic ZKPs from scratch. We setup our programming environment and wrote a basic circuit. We then performed a trusted setup, created and verified proofs. We identified some problems and improved our circuit, making sure to test our changes. After that, we implemented a basic digital signature scheme using hash functions and commitments.</p><p>We also learned enough skills and tools to be able to implement group signatures, something that would be difficult to implement without ZKPs.</p><p>I hope you have developed a better mental model of what is involved in writing ZKPs, and have a better sense of what the edit-run-debug cycle looks like in practice. This will work as a good foundation for any other ZKPs program you may write in the future, regardless of what tech stack you end up using.</p><h2 id="acknowledgements"><a href="#acknowledgements" aria-hidden="true" tabindex="-1"><span></span></a>Acknowledgements</h2><p>Thanks to Hanno Cornelius, Marc Köhlbrugge, Michelle Lai, lenilsonjr, and Chih-Cheng Liang for reading drafts and providing feedback on this.</p><h3 id="images"><a href="#images" aria-hidden="true" tabindex="-1"><span></span></a>Images</h3><ul><li><em>Bourbaki Congress 1938</em> - Unknown, Public domain, via <a target="_blank" rel="noopener noreferrer" href="https://commons.wikimedia.org/wiki/File:Bourbaki_congress1938.png">Wikimedia</a></li><li><em>Hartmann&#39;s Zebras</em> - J. Huber, CC BY-SA 2.0, via <a target="_blank" rel="noopener noreferrer" href="https://commons.wikimedia.org/wiki/File:Hartmann_zebras_hobatereS.jpg">Wikimedia</a></li><li><em>Trapdoor Spider</em> - P.S. Foresman, Public domain, via <a target="_blank" rel="noopener noreferrer" href="https://commons.wikimedia.org/wiki/File:Trapdoor_(PSF).png">Wikimedia</a></li><li><em>Kingsley Lockbox</em> - P.S. Foresman, Public domain, via <a target="_blank" rel="noopener noreferrer" href="https://commons.wikimedia.org/wiki/File:Kingsley_lockbox.jpg">Wikimedia</a></li></ul><h2 id="references"><a href="#references" aria-hidden="true" tabindex="-1"><span></span></a>References</h2></div></div></div>
  </body>
</html>
