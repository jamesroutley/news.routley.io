<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wasmer.io/posts/onyxlang-powered-by-wasmer">Original</a>
    <h1>Onyx, a new programming language powered by WebAssembly</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><strong>Onyx</strong> is a new programming language featuring a modern, expressive syntax, strict type safety, blazingly-fast build times, and out-of-the-box cross platform support thanks to WebAssembly.</p>
<p>Over the past 3 years of development, Onyx has become a complete programming language with features every developer needs: a fast compiler, a <a href="https://onyxlang.io/docs/packages">package manager</a>, a <a href="https://github.com/onyx-lang/onyx-lsp">language server</a>, <a href="https://onyxlang.io/docs/setup">editor support</a>, and cross-platform deployment using Wasmer and WASIX.</p>
<p>Onyx’s syntax is inspired by other imperative programming languages, namely <a href="https://go.dev/">Go</a>, <a href="https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md">Jai</a> and <a href="https://odin-lang.org">Odin</a>. With Onyx however, it is possible to program in a more functional style through some small language features, such as the pipe operator (<code>|&gt;</code>).</p>
<p>Take a look at this program written in Onyx that prints the sum of some numbers!</p>
<pre tabindex="0"><code><span><span>// Include libraries from the standard library </span></span>
<span><span>use</span><span> core {*}</span></span>
<span></span>
<span><span>// All programs start in main.</span></span>
<span><span>main</span><span> :: () {</span></span>
<span><span>    input := </span><span>&#34;111 110 121 120&#34;</span><span>;</span></span>
<span></span>
<span><span>    </span><span>// Chain the output of one function</span></span>
<span><span>    </span><span>// to the input of another!</span></span>
<span><span>    sum := string.split_iter(input, </span><span>&#34; &#34;</span><span>)</span></span>
<span><span>        |&gt; iter.map(x =&gt; </span><span>cast</span><span>(</span><span>i32</span><span>) conv.parse_int(x))</span></span>
<span><span>        |&gt; iter.fold(</span><span>0</span><span>, (a, b) =&gt; a + b);</span></span>
<span></span>
<span><span>    printf(</span><span>&#34;Sum of input: {}</span><span>\n</span><span>&#34;</span><span>, sum);</span></span>
<span><span>}</span></span></code></pre>

<p>Onyx can make everything from HTTP servers to video games. I have used it to make games, web applications, and even a slide deck presenter. I am excited for more users to expand Onyx’s use cases. Take a look at these guides on the Onyx website to get started using Onyx for your next project!</p>
<ul>
<li><a href="https://onyxlang.io/docs/getting_started">Getting started with Onyx</a></li>
<li><a href="https://onyxlang.io/docs/guides/http-server">Creating an HTTP server with Onyx</a></li>
<li><a href="https://onyxlang.io/docs/guides/raylib">Creating a simple game with Raylib in Onyx</a></li>
</ul>

<p>When making a programming language, you need to decide how your programs will actually be executed. Will they be interpreted like Python or JS? Compiled to native code like Rust or C++? Or somewhere in between, like Kotlin or Elixir?</p>
<p>I knew I wanted Onyx to compile to WASM, because of cross-platform support and the simplicity of generating a valid WASM module. Onyx does not rely on libraries like LLVM to generate its code, because WASM is so simple to target.</p>
<p>To give a brief introduction for those unfamiliar, WebAssembly instructions are executed on a stack-based virtual machine. This means all operations are done by pushing and popping operands on a stack. When it’s time to run your code, these stack operations are then translated to native instructions to run directly your CPU.</p>
<p>For example, to add two numbers, say <code>37</code> and <code>42</code>, we would use the following WASM instructions.</p>
<pre tabindex="0"><code><span><span>i32</span><span>.const</span><span> </span><span>37</span></span>
<span><span>i32</span><span>.const</span><span> </span><span>42</span></span>
<span><span>i32</span><span>.add</span></span></code></pre>
<p>The first two instructions push the integers <code>37</code> and <code>42</code> onto the stack. The final instruction pops two integers off of the stack (<code>37</code> and <code>42</code>) and pushes the resulting integer (<code>79</code>) back onto the stack. This method of computation gives us a simple way to make the expression emitter in a compiler.</p>
<p>In a compiler, the source code goes through a series of steps to produce the final executable code.</p>
<pre tabindex="0"><code><span><span>Parsing  -&gt;   Semantic Checking     -&gt;  Code Generation</span></span>
<span><span>(Tokens)    (Abstract Syntax Trees)      (Target code)</span></span></code></pre>
<p>This is a simplified view, but it gives us the right idea. The key is to look at which data structures are used in each phase of the compiler. In the parsing phase, we are looking at individual tokens, things like <code>123</code>, <code>variable_names</code>, and symbols. The parser then generates a tree data-structure that represents our program in a manageable way. After the checker ensures our program makes sense and nothing is wrong, the code generator translates the syntax trees into the target assembly or byte code.</p>
<p>The code generator step is where WASM shines. Because our input to the code generator is (generally) a syntax tree, we simply do a <em>post-order traversal</em> of the tree and we have the instructions in the right order.</p>
<p>Let&#39;s look at this example. The expression <code>3 * 4 + 5</code> would result in a tree with the post-order traversal of <code>3 4 * 5 +</code>. When we convert that into WASM instructions, we get the following code.</p>
<pre tabindex="0"><code><span><span>i32</span><span>.const</span><span> </span><span>3</span></span>
<span><span>i32</span><span>.const</span><span> </span><span>4</span></span>
<span><span>i32</span><span>.mul</span></span>
<span><span>i32</span><span>.const</span><span> </span><span>5</span></span>
<span><span>i32</span><span>.add</span></span></code></pre>
<p>You can double check by hand, but the resulting value is <code>17</code>, or <code>3 * 4 + 5</code>.</p>
<p>Here is some Onyx pseudo-code to show how you could easily implement this.</p>
<pre tabindex="0"><code><span><span>generate_code</span><span> :: (n: &amp;Node) {</span></span>
<span><span>    </span><span>switch</span><span> n {</span></span>
<span><span>        </span><span>case</span><span> binary_op: .Binary_Operation {</span></span>
<span><span>            </span><span>// Emit the expression on the left hand side.</span></span>
<span><span>            generate_code(binary_op.left);</span></span>
<span></span>
<span><span>            </span><span>// Emit the expression on the right hand side.</span></span>
<span><span>            generate_code(binary_op.right);</span></span>
<span></span>
<span><span>            </span><span>// Emit the actual operation.</span></span>
<span><span>            generate_operation_for_binary_op(binary_op.operation);</span></span>
<span><span>        }</span></span>
<span></span>
<span><span>        </span><span>case</span><span> integer: .Integer_Literal {</span></span>
<span><span>            generate_code_for_integer_literal(integer);</span></span>
<span><span>        }</span></span>
<span></span>
<span><span>        </span><span>// ...</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre>
<p>We generate all expressions using a recursive function that first visits the left-hand side, then the right-hand side, then generates the operation&#39;s corresponding instruction.</p>

<p>When creating Onyx, I wanted to push the limits of WebAssembly. WASM is an awesome technology that is a great compilation target, but there are some inherit drawbacks. The major drawback is the impossibility of implementing a graphical interface or a game outside of the browser. This is by design, as WASM is entirely isolated from its host environment. To navigate these limitations I came up with a way for any WebAssembly embedder, like Wasmer, to interact with native system components.</p>
<p>My strategy was to wrap <code>libwasmer.a</code>, the standalone library version of Wasmer, into my own custom WASM loader, to allow imported functions to be linked against native libraries. I added a custom section to the WASM binaries output by Onyx that specifies which native libraries it wants to link against. When linking, I find the libraries on disk, load them, call a function in each dynamic library that returns a list of procedures that can be used when linking. This external linking enables Onyx to use <em>any</em> native C library, from Raylib and OpenGL, to PostgresQL and OpenSSL.</p>

<p>Wasmer has been crucial to Onyx&#39;s development from the very beginning.</p>
<p>In the early stages of the language, the Wasmer CLI was used to test the binaries produced by Onyx and to ensure everything was working properly.</p>
<p>Now, Wasmer is the underlying runtime used in most distributions of Onyx, because it enables fast, cross-platform support, allowing Onyx to be used anywhere.</p>
<p>Thanks to <a href="https://wasmer.io/products/edge">Wasmer Edge</a>, the Onyx website, <a href="https://onyxlang.io/">onyxlang.io</a>, is no longer hosted on my personal VPS.</p>

<p>If Onyx sounds interesting to you, you can learn more at <a href="https://onyxlang.io/">onyxlang.io</a>. You can find installation instructions, getting started guides and example projects to get yourself going.
As of November 2023, Onyx is still very much in a beta state, but the only way for it to get out of beta status is for more people to use and stress test it! I&#39;m always open for feedback and pull requests!</p>
<p>Thanks for taking the time to learn about Onyx. I can&#39;t wait to see what you build with it!</p></div></div>
  </body>
</html>
