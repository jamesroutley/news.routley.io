<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://laurenar.net/posts/lambda_calculus_interpreter/">Original</a>
    <h1>Lambda Calculus Interpreter in Rust</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      
<p>
Building a lambda calculus interpreter gives a great idea of what working in a new language is like. Trying my hand at one as a Rust novice, I learned not only the basics about Rust syntax for pattern matching and enum types, but also how the compiler helps guide the user in managing memory usage. I&#39;ll be sharing my experience of first creating an interpreter on just the heap in Part I, and then in Part II walk through what it was like to experiment with moving some memory usage to the stack.</p>
<div id="outline-container-headline-1">
<h2 id="headline-1">
Part I: Building the interpreter on the heap
</h2>
<div id="outline-text-headline-1">
<div id="outline-container-headline-2">
<h3 id="headline-2">
Exp enum
</h3>
<div id="outline-text-headline-2">
<p>
Every expression in this lambda calculus language is one of three varieties:</p>
<ol>
<li>
<p>\(x\) (variables)</p>
</li>
<li>
<p>\(\lambda x . M\) (function abstraction)</p>
</li>
<li>
<p>\(M N \) (application)</p>
</li>
</ol>
<p>We&#39;ll make an enum type <code>Exp</code> with a variant for each of these.</p>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span></code></pre></td>
<td>
<pre><code data-lang="rust"><span>enum</span> <span>Exp</span><span> </span>{<span>
</span><span>    </span>Var(<span>String</span>),<span>
</span><span>    </span>Lambda(<span>String</span>,<span> </span><span>Box</span>&lt;Exp&gt;),<span>
</span><span>    </span>App(<span>Box</span>&lt;Exp&gt;,<span> </span><span>Box</span>&lt;Exp&gt;),<span>
</span><span></span>}<span>
</span></code></pre></td></tr></tbody></table>
</div>
</div>
</div>
<p>
For this first foray into Rust, I&#39;m depending heavily on use of the heap with <code>Box</code>, which will greatly simplify dealing with recursion in all of the interpreter code. To start with, we need to use the heap to express this recursive <code>Exp</code> type. Without <code>Box</code> (i.e. just <code>App(Exp, Exp)</code>), we will get an error <code>recursive type `Exp` has infinite size</code> since the compiler cannot determine the size of the enum. The compiler helpfully suggests some methods for creating indirection including putting a <code>Box</code> around our inner <code>Exp</code>, and we can proceed designing our methods for beta reduction and substitution.</p>
</div>
</div>
<div id="outline-container-headline-3">
<h3 id="headline-3">
\((\lambda x . x \)) &#34;\(foo\)&#34;
</h3>
<div id="outline-text-headline-3">
<p>
The simplest expression we want to support is \((\lambda x . x\)) &#34;\(foo\)&#34;. This expression exercises all cases of our <code>Exp</code> enum and lets us get started with more than the trivial case (just &#34;\(foo\)&#34;). Specifically, the result of this expression is the application of the identity function \(\lambda x . x\) to the value &#34;\(foo\)&#34;. Expressed as an <code>Exp</code>, this expression looks like:</p>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td>
<td>
<pre><code data-lang="rust">Exp::App(<span>
</span><span>    </span><span>Box</span>::new(Exp::Lambda(<span>&#34;x&#34;</span>.to_string(),<span>
</span><span>                         </span><span>Box</span>::new(Exp::Var(<span>&#34;x&#34;</span>.to_string())))),<span>
</span><span>    </span><span>Box</span>::new(Exp::Var(<span>&#34;foo&#34;</span>.to_string())))<span>
</span></code></pre></td></tr></tbody></table>
</div>
</div>
</div>
<p>
For now, we are using <code>&#34;x&#34;.to_string()</code> to create heap-allocated <code>String</code> objects, though we will explore using references to string literals in Part II. Let&#39;s write our <code>reduce</code> and <code>substitute</code> functions with this test expression in mind.</p>
</div>
</div>
<div id="outline-container-headline-4">
<h3 id="headline-4">
reduce
</h3>
<div id="outline-text-headline-4">
<p><code>reduce</code> is a function that takes an <code>Exp</code> as input and returns an <code>Exp</code> that is the result of evaluating the input. We&#39;ll recursively call <code>reduce</code> on our expression, and we need to pattern-match the type of our expression with each of <code>Var</code>, <code>Lambda</code>, and <code>App</code>. The simplest case here is definitely <code>Var</code>, which reduces to itself.</p>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span>1
</span></code></pre></td>
<td>
<pre><code data-lang="rust"><span> </span>Exp::Var(s)<span> </span>=&gt;<span> </span>Exp::Var(s)<span>
</span></code></pre></td></tr></tbody></table>
</div>
</div>
</div>
<p>
With the second case of <code>Lambda</code>, we must recurse into the lambda&#39;s expression and evaluate it.</p>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span>1
</span></code></pre></td>
<td>
<pre><code data-lang="rust"><span> </span>Exp::Lambda(s,<span> </span>e1)<span> </span>=&gt;<span> </span>Exp::Lambda(s,<span> </span><span>Box</span>::new(reduce(*e1)))<span>
</span></code></pre></td></tr></tbody></table>
</div>
</div>
</div>
<p>
In the case of \(\lambda x . x\), we won&#39;t have any expression to evaluate, and the interesting reduction will come with the application. In this case of our <code>App</code>, we are applying a lambda \(\lambda x . x\) to our expression &#34;\(foo\)&#34;, and will need to make a substitution. In all other cases, we just need to recursively call <code>reduce</code> on both <code>e1</code> and <code>e2</code>. Let&#39;s draft the <code>App</code> pattern match cases.</p>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td>
<td>
<pre><code data-lang="rust">Exp::App(e1,<span> </span>e2)<span> </span>=&gt;<span> </span><span>match</span><span> </span>*e1<span> </span>{<span>
</span><span>    </span>Exp::Lambda(s,<span> </span>e1a)<span> </span>=&gt;<span> </span>reduce(substitute(s,<span> </span>*e1a,<span> </span>*e2)),<span>
</span><span>    </span>other<span> </span>=&gt;<span> </span>reduce(Exp::App(<span>Box</span>::new(reduce(other)),<span> </span><span>Box</span>::new(reduce(*e2))))<span>
</span><span></span>}<span>
</span></code></pre></td></tr></tbody></table>
</div>
</div>
</div>
<p>
We match on <code>*e1</code>, using <code>*</code> to unbox the value inside the first expression. To see this working, we&#39;ll need to turn our attention to implementing <code>substitute</code>. Putting everything together, our <code>reduce</code> function looks like:</p>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span></code></pre></td>
<td>
<pre><code data-lang="rust"><span>fn</span> <span>reduce</span>(e: <span>Exp</span>)<span> </span>-&gt; <span>Exp</span><span> </span>{<span>
</span><span>    </span><span>match</span><span> </span>e<span> </span>{<span>
</span><span>        </span>Exp::Var(s)<span> </span>=&gt;<span> </span>Exp::Var(s),<span>
</span><span>        </span>Exp::App(e1,<span> </span>e2)<span> </span>=&gt;<span> </span><span>match</span><span> </span>*e1<span> </span>{<span>
</span><span>            </span>Exp::Lambda(s,<span> </span>e1a)<span> </span>=&gt;<span> </span>reduce(substitute(s,<span> </span>*e1a,<span> </span>*e2)),<span>
</span><span>            </span>other<span> </span>=&gt;<span> </span>reduce(Exp::App(<span>Box</span>::new(reduce(other)),<span> </span><span>Box</span>::new(reduce(*e2)))),<span>
</span><span>        </span>},<span>
</span><span>        </span>Exp::Lambda(s,<span> </span>e1)<span> </span>=&gt;<span> </span>Exp::Lambda(s,<span> </span><span>Box</span>::new(reduce(*e1))),<span>
</span><span>    </span>}<span>
</span><span></span>}<span>
</span></code></pre></td></tr></tbody></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-5">
<h3 id="headline-5">
substitute
</h3>
<div id="outline-text-headline-5">
<p>Our substitution function says that given some lambda function with argument <code>x</code> and function body <code>e1</code>, and some expression <code>e2</code>, it will return <code>e1</code> with all instances of <code>x</code> in its function body replaced with <code>e2</code>. This is a very general definition of substitution, but it is essentially the same as &#34;plugging in&#34; for variables we learned in algebra. We want to match on the type of the <code>Exp</code> that is the lambda&#39;s function body and break down this expression recursively till we have replaced all instances of the variable <code>x</code>.</p>
<p>
If our function body <code>e1</code> is either itself a <code>Lambda</code> or an <code>App</code>, we need to recurse into each <code>Exp</code> to find any instances of the variable. If the function body is just a <code>Var</code> <strong><em>and</em></strong> the var we see is the same as our argument, we are ready to replace! (Otherwise we should do nothing, e.g. \((\lambda x . y) z \rightarrow y \))</p>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span></code></pre></td>
<td>
<pre><code data-lang="rust"><span>fn</span> <span>substitute</span>(v: <span>String</span>,<span> </span>e1: <span>Exp</span>,<span> </span>e2: <span>Exp</span>)<span> </span>-&gt; <span>Exp</span><span> </span>{<span>
</span><span>    </span><span>match</span><span> </span>e1<span> </span>{<span>
</span><span>        </span>Exp::App(e1a,<span> </span>e1b)<span> </span>=&gt;<span> </span>{<span>
</span><span>            </span><span>let</span><span> </span>v1<span> </span>=<span> </span>v.clone();<span>
</span><span>            </span><span>let</span><span> </span>e2a<span> </span>=<span> </span>e2.clone();<span>
</span><span>
</span><span>            </span>Exp::App(<span>
</span><span>                </span><span>Box</span>::new(substitute(v,<span> </span>*e1a,<span> </span>e2)),<span>
</span><span>                </span><span>Box</span>::new(substitute(v1,<span> </span>*e1b,<span> </span>e2a)),<span>
</span><span>            </span>)<span>
</span><span>        </span>}<span>
</span><span>        </span>Exp::Lambda(s,<span> </span>e)<span> </span>=&gt;<span>
</span><span>            </span><span>if</span><span> </span>s<span> </span>==<span> </span>v<span> </span>{<span>
</span><span>                </span><span>// s is shadowing v, no substitutions needed inside e
</span><span></span><span>                </span>Exp::Lambda(s,<span> </span>e)<span>
</span><span>            </span>}<span> </span><span>else</span><span> </span>{<span>
</span><span>                </span>Exp::Lambda(s,<span> </span><span>Box</span>::new(substitute(v,<span> </span>*e,<span> </span>e2)))<span>
</span><span>            </span>}<span>
</span><span>        </span>Exp::Var(s)<span> </span>=&gt;<span> </span>{<span>
</span><span>            </span><span>if</span><span> </span>s<span> </span>==<span> </span>v<span> </span>{<span>
</span><span>                </span>e2<span> </span><span>// replace!
</span><span></span><span>            </span>}<span> </span><span>else</span><span> </span>{<span>
</span><span>                </span>Exp::Var(s)<span>
</span><span>            </span>}<span>
</span><span>        </span>}<span>
</span><span>    </span>}<span>
</span><span></span>}<span>
</span></code></pre></td></tr></tbody></table>
</div>
</div>
</div>
<p>
Looking at the case where we match <code>App</code>, we will have to make separate calls to <code>substitute</code> on each of the <code>App</code>&#39;s expressions. We can pass in <code>v</code> and <code>e2</code> to our first call to <code>substitute</code> on line 8, which will gain ownership of those variables. We&#39;ll make copies of them, <code>v1</code> and <code>e2a</code>, that we can pass to the second call on line 9.</p>
</div>
</div>
<div id="outline-container-headline-6">
<h3 id="headline-6">
Interpret
</h3>
<div id="outline-text-headline-6">
<p>Let&#39;s try it out!</p>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span></code></pre></td>
<td>
<pre><code data-lang="rust"><span>fn</span> <span>main</span>()<span> </span>{<span>
</span><span>    </span>println!(<span>&#34;{:?}&#34;</span>,<span>
</span><span>             </span>reduce(Exp::App(<span>Box</span>::new(Exp::Lambda(<span>&#34;x&#34;</span>.to_string(),<span>
</span><span>                                                  </span><span>Box</span>::new(Exp::Var(<span>&#34;x&#34;</span>.to_string())))),<span>
</span><span>                             </span><span>Box</span>::new(Exp::Var(<span>&#34;foo&#34;</span>.to_string())))));<span>
</span><span></span>}<span>
</span></code></pre></td></tr></tbody></table>
</div>
</div>
</div>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span>1
</span><span>2
</span></code></pre></td>
<td>
<pre><code data-lang="bash">$&gt; cargo run
Var(<span>&#34;foo&#34;</span>)</code></pre></td></tr></tbody></table>
</div>
</div>
</div>
<p>
We&#39;ve correctly reduced and substituted!</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-7">
<h2 id="headline-7">
Part II: Experiment with the stack
</h2>
<div id="outline-text-headline-7">
<div id="outline-container-headline-8">
<h3 id="headline-8">
Moving strings to the stack &amp; Lifetime
</h3>
<div id="outline-text-headline-8">
<p>Although it&#39;s been convenient to have our whole program reside on the heap, let&#39;s now explore representing strings by utilizing references to the stack. Whereas before we were creating strings using <code>&#34;x&#34;.to_string()</code>, writing <code>&#34;x&#34;</code> alone declares a string literal that is in static memory and immutable. To pass in a string literal to our <code>Exp</code> constructor, we need to specify the lifetime of the <code>Exp</code> values. Lifetimes are a Rust-language concept that ensure memory in scope is valid. To use a reference to a string in one of our enum variants, we must prove at compile time that the string reference is still in scope and has not yet been collected by the garbage collector.</p>
<p>
We&#39;ll use a lifetime parameter to tie the <code>Exp</code> object&#39;s lifetime to that of the string literal by writing <code>Exp&lt;&#39;a&gt;</code>. Here&#39;s our new enum.</p>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span></code></pre></td>
<td>
<pre><code data-lang="rust"><span>enum</span> <span>Exp</span>&lt;<span>&#39;a</span>&gt;<span> </span>{<span>
</span><span>    </span>Var(&amp;<span>&#39;a</span><span> </span><span>str</span>),<span>
</span><span>    </span>App(<span>Box</span>&lt;Exp&lt;<span>&#39;a</span>&gt;&gt;,<span> </span><span>Box</span>&lt;Exp&lt;<span>&#39;a</span>&gt;&gt;),<span>
</span><span>    </span>Lambda(&amp;<span>&#39;a</span><span> </span><span>str</span>,<span> </span><span>Box</span>&lt;Exp&lt;<span>&#39;a</span>&gt;&gt;)<span>
</span><span></span>}<span>
</span></code></pre></td></tr></tbody></table>
</div>
</div>
</div>
<p>
Our previous <code>substitute</code> function took a <code>String</code> as one of its arguments, so we must alter it to accept a string reference. Our new signature becomes:</p>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span>1
</span></code></pre></td>
<td>
<pre><code data-lang="rust"><span> </span><span>fn</span> <span>substitute</span>&lt;<span>&#39;a</span>&gt;(v: <span>&amp;</span><span>&#39;a</span><span> </span><span>str</span>,<span> </span>e1: <span>Exp</span>&lt;<span>&#39;a</span>&gt;,<span> </span>e2: <span>Exp</span>&lt;<span>&#39;a</span>&gt;)<span> </span>-&gt; <span>Exp</span>&lt;<span>&#39;a</span>&gt;<span>
</span></code></pre></td></tr></tbody></table>
</div>
</div>
</div>
<p>
If the function takes a reference as an argument, that function itself needs to be parameterized by the lifetime of that argument. In addition, since our return value is constructed using this reference, it also needs to be parameterized by the lifetime of the reference. In the body of <code>substitute</code>, we can now remove the line <code>let v1 = v.clone();</code> from line 4 in the example from Part I. Since both sub-calls to <code>substitute</code> have the string reference lifetime parameter, they can safely share <code>v</code>.</p>
<p>
Finally, we can remove all calls to <code>&#34;x&#34;.to_string()</code>, and since <code>reduce</code> does not take a string as an argument, no changes are needed. A quick run of valgrind on each implementation reports that the number of allocs has reduced from 17 to 14. This confirms that the 3 strings we were previously allocating are no longer on the heap.</p>
</div>
</div>
<div id="outline-container-headline-9">
<h3 id="headline-9">
Moving Exp to the stack
</h3>
<div id="outline-text-headline-9">
<p>Now that we have strings on the stack, can we go a step further and use references to <code>Exp</code> values? That is, can we implement the same functionality with this definition of <code>Exp</code>:</p>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span></code></pre></td>
<td>
<pre><code data-lang="rust"><span>enum</span> <span>Exp</span>&lt;<span>&#39;a</span>&gt;<span> </span>{<span>
</span><span>    </span>Var(&amp;<span>&#39;a</span><span> </span><span>str</span>),<span>
</span><span>    </span>App(&amp;<span>&#39;a</span><span> </span>Exp&lt;<span>&#39;a</span>&gt;,<span> </span>&amp;<span>&#39;a</span><span> </span>Exp&lt;<span>&#39;a</span>&gt;),<span>
</span><span>    </span>Lambda(&amp;<span>&#39;a</span><span> </span><span>str</span>,<span> </span>&amp;<span>&#39;a</span><span> </span>Exp&lt;<span>&#39;a</span>&gt;)<span>
</span><span></span>}<span>
</span></code></pre></td></tr></tbody></table>
</div>
</div>
</div>
<p>
With this definition, we start running into major problems when trying to make any recursive calls to <code>reduce</code> and <code>substitute</code>. For example, <code>reduce</code> would now take a reference to an <code>Exp</code> with lifetime <code>&#39;a</code>, and return an <code>Exp</code> with the same lifetime:</p>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span>1
</span></code></pre></td>
<td>
<pre><code data-lang="rust"><span> </span><span>fn</span> <span>reduce</span>&lt;<span>&#39;a</span>&gt;(e: <span>&amp;</span><span>&#39;a</span><span> </span>Exp)<span> </span>-&gt; <span>Exp</span>&lt;<span>&#39;a</span>&gt;<span>
</span></code></pre></td></tr></tbody></table>
</div>
</div>
</div>
<p>
Recursive calls to <code>reduce</code> would receive references to <code>Exp</code> values owned by the current function. The recursive calls will create new instances of <code>Exp</code> in their function bodies, and return references to them. The current function will use references to these recursively-created <code>Exp</code> in constructing a new <code>Exp</code> instance in turn. However, these recursively-created <code>Exp</code> will be destroyed when the current function returns because of the lifetime parameter, so the references will no longer be valid and would result in undefined behavior. The Rust compiler confirms this flaw, returning an error: &#34;cannot return value referencing temporary value.&#34; Thus, <code>reduce</code> and <code>substitute</code> do need to return owned values after all, and we&#39;ve reached a dead end with this definition of <code>Exp</code>.</p>
</div>
</div>
<div id="outline-container-headline-10">
<h3 id="headline-10">
Sailing out to C
</h3>
<div id="outline-text-headline-10">
<p>But what if we were feeling particularly stubborn and wanted to bypass this constraint from the Rust compiler in a more flexible language that allows us to dig our own graves, like C? Reimplementing the lambda calculus in C, we will write our two functions:</p>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span>1
</span><span>2
</span></code></pre></td>
<td>
<pre><code data-lang="c">Exp* <span>reduce</span>(Exp* exp);
Exp* <span>substitute</span>(<span>char</span>* s, Exp* e1, Exp* e2);</code></pre></td></tr></tbody></table>
</div>
</div>
</div>
<p>
(full listing <a href="https://github.com/laurenarnett/rust-lambda-calculus/blob/main/c-lambda-calculus/lambda_calculus.c">here</a>)</p>
<p>
Instead of allocating new <code>Exp</code> in each function and returning the pointer to it like the Rust compiler forces us to do, let&#39;s just blindly confidently return the address to the locally constructed <code>Exp</code>. We write, imprudently wielding the manual memory management power C has granted us, <code>return &amp;result;</code>, and successfully compile one of the lowest heap-usage lambda calculus interpreters ever written. Time to run it!</p>
<div>
<div><div>
<table><tbody><tr><td>
<pre><code><span>1
</span><span>2
</span></code></pre></td>
<td>
<pre><code data-lang="text">~&gt; ./lambda_calculus
Segmentation fault (core dumped)</code></pre></td></tr></tbody></table>
</div>
</div>
</div>
<p>
The program reads some garbage memory trying to retrieve one of these locally defined <code>Exp</code>&#39;s, and segfaults. Looks like we should have heeded the warnings of the Rust compiler when it was begging us to never run this code and encounter these disastrous consequences. We&#39;ve now seen first-hand how Rust&#39;s insistence on obeying the lifetime parameter and safe memory management is not an inconvenience, but rather a crucial safeguard.</p>
</div>
</div>
<div id="outline-container-headline-11">
<h3 id="headline-11">
Conclusions
</h3>
<p>Time to wrap up since we&#39;re reaching the end of this blog post&#39;s lifetime. During this project, I found that the ability to catch memory-related errors at compile-time, along with a compiler that nudges you in the right direction with helpful suggestions, greatly enhanced my overall developer experience as a Rust novice. For a relatively simple first project, I learned a ton about Rust&#39;s powerful memory-management features and strict safety guarantees, and am excited to explore more ways the compiler provides guardrails against unsafe memory-management behavior.</p>
</div>
</div>
</div>

    </div></div>
  </body>
</html>
