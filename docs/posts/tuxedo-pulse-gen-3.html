<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tuxedocomputers.com/en/TUXEDO-Pulse-14-Gen3.tuxedo">Original</a>
    <h1>Tuxedo Pulse Gen 3</h1>
    
    <div id="readability-page-1" class="page"><div>
     

<p>Hello! I was trying to explain to someone how <code>git cherry-pick</code> works the other
day, and I found myself getting confused.</p>

<p>What went wrong was: I thought that <code>git cherry-pick</code> was basically applying a
patch, but when I tried to actually do it that way, it didn’t work!</p>

<p>Let’s talk about what I thought <code>cherry-pick</code> did (applying a patch), why
that’s not quite true, and what it actually does instead (a “3-way merge”).</p>

<p>This post is extremely in the weeds and you definitely don’t need to understand
this stuff to use git effectively. But if you (like me) are curious about git’s
internals, let’s talk about it!</p>

<h3 id="cherry-pick-isn-t-applying-a-patch">cherry-pick isn’t applying a patch</h3>

<p>The way I previously understood <code>git cherry-pick COMMIT_ID</code> is:</p>

<ul>
<li>calculate the diff for <code>COMMIT_ID</code>, like <code>git show COMMIT_ID --patch &gt; out.patch</code></li>
<li>Apply the patch to the current branch, like <code>git apply out.patch</code></li>
</ul>

<p>Before we get into this – I want to be clear that this model is mostly
right, and if that’s your mental model that’s fine. But it’s wrong in some
subtle ways and I think that’s kind of interesting, so let’s see how it works.</p>

<p>If I try to do the “calculate the diff and apply the patch” thing in a case
where there’s a merge conflict, here’s what happens:</p>

<pre><code>$ git show 10e96e46 --patch &gt; out.patch
$ git apply out.patch
error: patch failed: content/post/2023-07-28-why-is-dns-still-hard-to-learn-.markdown:17
error: content/post/2023-07-28-why-is-dns-still-hard-to-learn-.markdown: patch does not apply
</code></pre>

<p>This just fails – it doesn’t give me any way to resolve the conflict or figure
out how to solve the problem.</p>

<p>This is quite different from what actually happens when run <code>git cherry-pick</code>,
which is that I get a merge conflict:</p>

<pre><code>$ git cherry-pick 10e96e46
error: could not apply 10e96e46... wip
hint: After resolving the conflicts, mark them with
hint: &#34;git add/rm &lt;pathspec&gt;&#34;, then run
hint: &#34;git cherry-pick --continue&#34;.
</code></pre>

<p>So it seems like the “git is applying a patch” model isn’t quite right. But the
error message literally does say “could not <strong>apply</strong> 10e96e46”, so it’s not quite
<em>wrong</em> either. What’s going on?</p>

<h3 id="so-what-is-cherry-pick-doing">so what is cherry-pick doing?</h3>

<p>I went digging through git’s source code to see how <code>cherry-pick</code> works, and
ended up at <a href="https://github.com/git/git/blob/dadef801b365989099a9929e995589e455c51fed/sequencer.c#L2353-L2358">this line of code</a>:</p>

<pre><code>res = do_recursive_merge(r, base, next, base_label, next_label, &amp;head, &amp;msgbuf, opts);
</code></pre>

<p>So a cherry-pick is a… merge? What? How? What is it even merging? And how does merging even work in the first place?</p>

<p>I realized that I didn’t really know how git’s merge worked, so I googled it
and found out that git does a thing called “3-way merge”. What’s that?</p>

<h3 id="how-git-merges-files-the-3-way-merge">how git merges files: the 3-way merge</h3>

<p>Let’s say I want to merge these 2 files. We’ll call them <code>v1.py</code> and <code>v2.py</code>.</p>

<pre><code>def greet():
    greeting = &#34;hello&#34;
    name = &#34;julia&#34;
    return greeting + &#34; &#34; + name
</code></pre>

<pre><code>def say_hello():
    greeting = &#34;hello&#34;
    name = &#34;aanya&#34;
    return greeting + &#34; &#34; + name
</code></pre>

<p>There are two lines that differ: we have</p>

<ul>
<li><code>def greet()</code> and <code>def say_hello</code></li>
<li><code>name = &#34;aanya&#34;</code> and <code>name = &#34;julia&#34;</code></li>
</ul>

<p>How do we know what to pick? It seems impossible!</p>

<p>But what if I told you that the original function was this (<code>base.py</code>)?</p>

<pre><code>def say_hello():
    greeting = &#34;hello&#34;
    name = &#34;julia&#34;
    return greeting + &#34; &#34; + name
</code></pre>

<p>Suddenly it seems a lot clearer! <code>v1</code> changed the function’s name to <code>greet</code>
and <code>v2</code> set <code>name = &#34;aanya&#34;</code>. So to merge, we should make both those changes:</p>

<pre><code>def greet():
    greeting = &#34;hello&#34;
    name = &#34;aanya&#34;
    return greeting + &#34; &#34; + name
</code></pre>

<p>We can ask git to do this merge with <code>git merge-file</code>, and it gives us exactly
the result we expected: it picks <code>def greet()</code> and <code>name = &#34;aanya&#34;</code>.</p>

<pre><code>$ git merge-file v1.py base.py v2.py -p
def greet():
    greeting = &#34;hello&#34;
    name = &#34;aanya&#34;
    return greeting + &#34; &#34; + name⏎
</code></pre>

<p>This way of merging where you merge 2 files + their original version is called
a <strong>3-way merge</strong>.</p>

<p>If you want to try it out yourself in a browser, I made a little playground at
<a href="https://jvns.ca/3-way-merge/">jvns.ca/3-way-merge/</a>. I made it very quickly so it’s not mobile friendly.</p>

<h3 id="git-merges-changes-not-files">git merges changes, not files</h3>

<p>The way I think about the 3-way merge is – git merges <strong>changes</strong>, not files.
We have an original file and 2 possible changes to it, and git tries to combine
both of those changes in a reasonable way. Sometimes it can’t (for example if
both changes change the same line), and then you get a merge conflict.</p>

<p>Git can also merge more than 2 possible changes: you can have an original file
and 8 possible changes, and it can try to reconcile all of them. That’s called
an octopus merge but I don’t know much more than that, I’ve never done one.</p>

<h3 id="how-git-uses-3-way-merge-to-apply-a-patch">how git uses 3-way merge to apply a patch</h3>

<p>Now let’s get a little weird! When we talk about git “applying a patch” (as you
do in a <code>rebase</code> or <code>revert</code> or <code>cherry-pick</code>), it’s not actually creating a
patch file and applying it. Instead, it’s doing a 3-way merge.</p>

<p>Here’s how applying commit <code>X</code> as a patch to your current commit corresponds to
this <code>v1</code>, <code>v2</code>, and <code>base</code> setup from before:</p>

<ol>
<li>The version of the file <strong>in your current commit</strong> is <code>v1</code>.</li>
<li>The version of the file <strong>before commit X</strong> is <code>base</code></li>
<li>The version of the file <strong>in commit X</strong>. Call that <code>v2</code></li>
<li>Run <code>git merge-file v1 base v2</code> to combine them (technically git does not
actually run <code>git merge-file</code>, it runs a C function that does it)</li>
</ol>

<p>Together, you can think of <code>base</code> and <code>v2</code> as being the “patch”: the diff between
them is the change that you want to apply to <code>v1</code>.</p>

<h3 id="how-cherry-pick-works">how cherry-pick works</h3>

<p>Let’s say we have this commit graph, and we want to cherry-pick <code>Y</code> on to <code>main</code>:</p>

<pre><code>A - B (main)
 \
  \
   X - Y - Z
</code></pre>

<p>How do we turn that into a 3-way merge? Here’s how it translates into our <code>v1</code>, <code>v2</code> and <code>base</code> from earlier:</p>

<ul>
<li><code>B</code> is v1</li>
<li><code>X</code> is the base, <code>Y</code> is v2</li>
</ul>

<p>So together <code>X</code> and <code>Y</code> are the “patch”.</p>

<p>And <code>git rebase</code> is just like <code>git cherry-pick</code>, but repeated a bunch of times.</p>

<h3 id="how-revert-works">how revert works</h3>

<p>Now let’s say we want to run <code>git revert Y</code> on this commit graph</p>

<pre><code>X - Y - Z - A - B
</code></pre>

<ul>
<li><code>B</code> is v1</li>
<li><code>Y</code> is the base, <code>X</code> is v2</li>
</ul>

<p>This is exactly like a cherry-pick, but with <code>X</code> and <code>Y</code> reversed. We have to
flip them because we want to apply a “reverse patch”.</p>

<p>Revert and cherry-pick are so closely related in git that they’re actually
implemented in the same file:
<a href="https://github.com/git/git/blob/dadef801b365989099a9929e995589e455c51fed/builtin/revert.c">revert.c</a>.</p>

<h3 id="this-3-way-patch-is-a-really-cool-trick">this “3-way patch” is a really cool trick</h3>

<p>This trick of using a 3-way merge to apply a commit as a patch seems really
clever and cool and I’m surprised that I’d never heard of it before! I don’t
know of a name for it, but I kind of want to call it a “3-way patch”.</p>

<p>The idea is that with a 3-way patch, you specify the patch as 2 files: the file
before the patch and after (<code>base</code> and <code>v2</code> in our language in this post).</p>

<p>So there are 3 files involved: 1 for the original and 2 for the patch.</p>

<p>The point is that the 3-way patch is a much better way to patch than a normal
patch, because you have a lot more context for merging when you have
both full files.</p>

<p>Here’s more or less what a normal patch for our example looks like:</p>

<pre><code>@@ -1,1 +1,1 @@:
- def greet():
+ def say_hello():
    greeting = &#34;hello&#34;
</code></pre>

<p>and a 3-way patch. This “3-way patch” is not a real file format, it’s just
something I made up.</p>

<pre><code>BEFORE: (the full file)
def greet():
    greeting = &#34;hello&#34;
    name = &#34;julia&#34;
    return greeting + &#34; &#34; + name
AFTER: (the full file)
def say_hello():
    greeting = &#34;hello&#34;
    name = &#34;julia&#34;
    return greeting + &#34; &#34; + name
</code></pre>

<h3 id="building-git-talks-about-this">“Building Git” talks about this</h3>

<p>The book <a href="https://shop.jcoglan.com/building-git/">Building Git</a> by James Coglan
is the only place I could find other than the git source code explaining how
<code>git cherry-pick</code> actually uses 3-way merge under the hood (I thought Pro Git might
talk about it, but it didn’t seem to as far as I could tell).</p>

<p>I actually went to buy it and it turned out that I’d already bought it in 2019
so it was a good reference to have here :)</p>

<h3 id="merging-is-actually-much-more-complicated-than-this">merging is actually much more complicated than this</h3>

<p>There’s more to merging in git than the 3-way merge – there’s something
called a “recursive merge” that I don’t understand, and there are a bunch of
details about how to deal with handling file deletions and moves, and there are
also multiple merge algorithms.</p>

<p>My best idea for where to learn more about this stuff is Building Git, though I
haven’t read the whole thing.</p>

<h3 id="so-what-does-git-apply-do">so what does <code>git apply</code> do?</h3>

<p>I also went looking through git’s source to find out what <code>git apply</code> does, and it
seems to (unsurprisingly) be in <code>apply.c</code>. That code parses a patch file, and
then hunts through the target file to figure out where to apply it. The core logic
seems to be <a href="https://github.com/git/git/blob/dadef801b365989099a9929e995589e455c51fed/apply.c#L2684">around here</a>:
I think the idea is to start at the line number that the patch suggested and
then hunt forwards and backwards from there to try to find it:</p>

<pre><code>	/*
	 * There&#39;s probably some smart way to do this, but I&#39;ll leave
	 * that to the smart and beautiful people. I&#39;m simple and stupid.
	 */
	backwards = current;
	backwards_lno = line;
	forwards = current;
	forwards_lno = line;
	current_lno = line;
  for (i = 0; ; i++) {
     ...
</code></pre>

<p>That all seems pretty intuitive and about what I’d naively expect.</p>

<h3 id="how-git-apply-3way-works">how <code>git apply --3way</code> works</h3>

<p><code>git apply</code> also has a <code>--3way</code> flag that does a 3-way merge. So we actually
could have more or less implemented <code>git cherry-pick</code> with <code>git apply</code> like
this:</p>

<pre><code>$ git show 10e96e46 --patch &gt; out.patch
$ git apply out.patch --3way
Applied patch to &#39;content/post/2023-07-28-why-is-dns-still-hard-to-learn-.markdown&#39; with conflicts.
U content/post/2023-07-28-why-is-dns-still-hard-to-learn-.markdown
</code></pre>

<p><code>--3way</code> doesn’t just use the contents of the patch file  though! The patch file starts with:</p>

<pre><code>index d63ade04..65778fc0 100644
</code></pre>

<p><code>d63ade04</code> and <code>65778fc0</code> are the IDs of the old/new versions of that file in
git’s object database, so git can retrieve them to do a 3-way patch
application. This won’t work if someone emails you a patch and you don’t have
the files for the new/old versions of the file though: if you’re missing the
blobs you’ll get this error:</p>

<pre><code>$ git apply out.patch
error: repository lacks the necessary blob to perform 3-way merge.
</code></pre>

<h3 id="3-way-merge-is-old">3-way merge is old</h3>

<p>A couple of people pointed out that 3-way merge is much older than git, it’s
from the late 70s or something. Here’s a <a href="https://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf">paper from 2007 talking about it</a></p>

<h3 id="that-s-all">that’s all!</h3>

<p>I was pretty surprised to learn that I didn’t actually understand the core way
that git applies patches internally – it was really cool to learn about!</p>

<p>I have <a href="https://jvns.ca/blog/2023/11/01/confusing-git-terminology/">lots of issues</a> with git’s UI but I think this particular thing is not
one of them. The 3-way merge seems like a nice unified way to solve a bunch of
different problems, it’s pretty intuitive for people (the idea of “applying a
patch” is one that a lot of programmers are used to thinking about, and the
fact that it’s implemented as a 3-way merge under the hood is an implementation
detail that nobody actually ever needs to think about).</p>

<p><small>
Also a very quick plug: I’m working on writing a
<a href="https://wizardzines.com">zine</a> about git, if you’re interested in getting an email when it comes out you can
sign up to my <a href="https://wizardzines.com/zine-announcements/">very infrequent announcements mailing list</a>.
</small></p>

</div></div>
  </body>
</html>
