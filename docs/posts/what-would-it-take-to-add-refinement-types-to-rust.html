<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yoric.github.io/post/rust-refinement-types/">Original</a>
    <h1>What would it take to add refinement types to Rust?</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
      <section>
        <article>
          
          
          
          <div>
            
            
            
            
            
            
            
            
            <p>A few years ago, on a whim, I wrote <a href="https://yoric.github.io/post/uom.rs/">YAIOUOM</a>. YAOIOUM was a static analyzer for Rust that checked that the code
was using units of measures correctly, e.g. a distance in meters is not a distance in centimeters, dividing meters
by seconds gave you a value in <code>m / s</code> (aka <code>m * s^-1</code>).</p>
<p>YAIOUOM was an example of a <em>refinement type system</em>, i.e. a type system that does its work after another type
system has already done its work. It was purely static, users could add new units in about
one line of code, and it was actually surprisingly easy to write. It also couldn’t be written within the Rust
type system, in part because I wanted legible error messages, and in part because Rust doesn’t offer a very
good way to specify that <code>(m / s) * s</code> is actually the same type as <code>m</code>.</p>
<p>Sadly, it also worked only on a specific version of Rust Nightly, and the code broke down with every new version
of Rust. It’s a shame, because I believe that there’s lots we could do with refinement types. Simple things such
as units of measure, as above, but also, I suspect, we could achieve much better error messages for complex
type-level programming, such as what Diesel is doing.</p>
<p>It got me to wonder how we could extend Rust in such a way that refinement types could be easily added
to the language.</p>

<p>As I’ve already implemented one refinement type system for Rust, I’ll use it as a benchmark of features that would be needed to let us implement this in Rust.</p>
<p>Let’s assume that we have defined the types <code>Value</code>, <code>Unit</code>, <code>Meter</code>, <code>Second</code> to make the following possible:</p>
<div>
  
  
  
  <div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>Value</span><span>&lt;</span>T, U<span>&gt;</span> <span>where</span> U: <span>Unit</span> { <span>..</span>. }; <span>// a value of type T (e.g. f64) with a unit of type U
</span></span></span><span><span><span></span><span>let</span> a <span>=</span> Value::<span>&lt;</span><span>f64</span>, Meter<span>&gt;</span>::new(<span>9.81</span>); <span>// f64 Meter aka Value&lt;f64, Meter&gt;
</span></span></span><span><span><span></span><span>let</span> b <span>=</span> Value::<span>&lt;</span><span>f64</span>, Second<span>&gt;</span>::new(<span>1.0</span>); <span>// f64 Second aka Value&lt;f64, Second&gt;
</span></span></span></code></pre></div></div>
  
</div><p>Furthermore, we have defined operations <code>std::ops::Add</code> and <code>std::ops::Sub</code> in such a way that we can write</p>
<div>
  
  
  
  <div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> c <span>=</span> b <span>+</span> b; <span>// f64 Second aka Value&lt;f64, Second&gt;
</span></span></span><span><span><span></span><span>let</span> d <span>=</span> b <span>-</span> b; <span>// f64 Second aka Value&lt;f64, Second&gt;
</span></span></span><span><span><span></span>
</span></span><span><span><span>let</span> _ <span>=</span> a <span>-</span> b; <span>// Error: cannot subtract `Value&lt;f64, Second&gt;` from `Value&lt;f64, Meter&gt;`
</span></span></span></code></pre></div></div>
  
</div><p>Multiplication and division are a bit more complicated, because they introduce new units, so let’s further assume
that we have defined <code>std::ops::Mul</code>, <code>std::ops::Div</code> and two <code>Unit</code> combinators <code>Mul&lt;Left, Right&gt;</code> and <code>Div&lt;Left, Right&gt;</code>
in such a way that we can write</p>
<div>
  
  
  
  <div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> g <span>=</span> a <span>/</span> (b <span>*</span> b); <span>// f64 Meter / (Second * Second) aka Value&lt;f64, Div&lt;Meter, Mul&lt;Second, Second&gt;&gt;&gt;&gt;
</span></span></span><span><span><span></span><span>let</span> h <span>=</span> a <span>/</span> b <span>/</span> b;   <span>// f64 Meter / (Second * Second) aka Value&lt;f64, Div&lt;Div&lt;Meter, Second&gt;, Second&gt;&gt;
</span></span></span></code></pre></div></div>
  
</div><p>So far, so good. Unless you want to compare <code>g</code> and <code>h</code>:</p>
<div>
  
  
  
  <div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> diff <span>=</span> g <span>-</span> h; <span>// Error: cannot subtract `Value&lt;f64, Div&lt;Div&lt;Meter, Second&gt;, Second&gt;&gt;` from `Value&lt;f64, Div&lt;Meter, Mul&lt;Second, Second&gt;&gt;&gt;`
</span></span></span></code></pre></div></div>
  
</div><p>which is a shame, because <code>g</code> and <code>h</code> represent the same value and <code>Div&lt;Div&lt;Meter, Second&gt;, Second&gt;&gt;</code> and <code>Div&lt;Meter, Mul&lt;Second, Second&gt;&gt;</code> represent the same unit of measure.</p>
<p>Perhaps we could be smarter about it?</p>
<p>In the above encoding, we have used a definition of <code>-</code> with a type signature</p>
<div>
  
  
  
  <div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span>&lt;</span>V, U<span>&gt;</span> std::ops::Sub <span>for</span> Value<span>&lt;</span>V, U<span>&gt;</span> <span>where</span> V: <span>std</span>::ops::Sub {
</span></span><span><span>    <span>type</span> <span>Output</span> <span>=</span> Value<span>&lt;&lt;</span>V <span>as</span> std::ops::Sub<span>&gt;</span>::Output, U<span>&gt;</span>;
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>}</span></span></code></pre></div></div>
  
</div><p>i.e.</p>
<blockquote>
<p>for any number type <code>V</code> and any unit <code>U</code>, <code>-</code> takes two arguments of type <code>Value&lt;V, U&gt;</code> and produces an argument of type <code>Value&lt;V, U&gt;</code>.</p>
</blockquote>
<p>But what we’d like here would be to express</p>
<blockquote>
<p>for any number type <code>V</code> and any unit types <code>Left</code> and <code>Right</code>, <code>-</code> takes two arguments of type <code>Value&lt;V, Left&gt;</code> and <code>Value&lt;V, Right&gt;</code> and produces an argument of type <code>Value&lt;V, Left&gt;</code> if <code>Left</code> and <code>Right</code> are equivalent.</p>
</blockquote>
<p>In other words, in terms of type-level programming, what we need here is some form of type-level oracle function <code>Equivalent&lt;Left, Right&gt;</code> that is defined if and only if <code>Left</code> and <code>Right</code> are indeed equivalent. Unfortunately, as far as I can tell<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>, in Rust, there is no way to define <code>Equivalent&lt;Left, Right&gt;</code> to combine the following three properties:</p>
<div><ol>
<li><code>Equivalent&lt;Left, Right&gt;</code> is defined iff <code>Left</code> and <code>Right</code> are equivalent;</li>
<li>keep the system extensible in such a way that other crates can create new units;</li>
<li>don’t need the user to manually express equivalences between units.</li>
</ol></div>
<p>So… what if we could expand the Rust type system to help us here?</p>

<p>Our life is complicated because programming with types is complicated. However, if instead of having to implement <code>Equivalent&lt;Left, Right&gt;</code>, we needed to implement <code>equivalent(left: UnitRepr, right: UnitRepr)</code>, where <code>UnitRepr</code> was an algebraic data structure representing our units of measures, our life would be much easier.</p>
<p>If you’re curious, Andrew Kennedy <a href="http://typesatwork.imm.dtu.dk/material/TaW_Paper_TypesAtWork_Kennedy.pdf">formalized the algorithm that does this ~15 years ago</a>, and then implemented it as part of the F# compiler (my own work on YAIOUOM was essentially a port of his work to Rust), so let’s take it for granted that such an algorithm exists and that it’s possible to implement <code>equivalent</code> or something like it.</p>
<p>There are a few places where we could imagine plugging <code>equivalent</code>, or a variant thereof.</p>

<p>
  <h2 id="option-trait-resolution">
    Option: Trait resolution
  </h2>
</p><p>We could somehow plug into <code>rustc_infer::trait</code>, rustc’s implementation of trait resolution, whenever we attempt to resolve <code>Equivalent&lt;Left, Right&gt;</code>.</p>
<p>This would let us write</p>
<div>
  
  
  
  <div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span>&lt;</span>V, Left, Right, C<span>&gt;</span> std::ops::Sub<span>&lt;</span>Value<span>&lt;</span>V, Right<span>&gt;&gt;</span> <span>for</span> Value<span>&lt;</span>V, Left<span>&gt;</span>
</span></span><span><span><span>where</span> V: <span>std</span>::ops::Sub,
</span></span><span><span>      Equivalence: <span>Equivalent</span><span>&lt;</span>Left, Right, Canonical<span>=</span>C<span>&gt;</span>
</span></span><span><span>{
</span></span><span><span>    <span>type</span> <span>Output</span> <span>=</span> Value<span>&lt;&lt;</span>V <span>as</span> std::ops::Sub<span>&gt;</span>::Output, C<span>&gt;</span>;
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>}
</span></span><span><span>
</span></span><span><span><span>let</span> diff <span>=</span> h <span>-</span> g; <span>// Value&lt;f64, C&gt; where C is the canonicalized version of Div&lt;Div&lt;Meter, Second&gt;, Second&gt;
</span></span></span><span><span><span></span>                  <span>// and Div&lt;Meter, Mul&lt;Second, Second&gt;&gt;
</span></span></span></code></pre></div></div>
  
</div><p>As of rustc 1.85, this <em>might</em> look like an additional variant in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_infer/traits/select/enum.SelectionCandidate.html"><code>SelectionCandidate</code></a>.</p>
<p>I am not convinced by this approach, for several reasons:</p>
<div><ol>
<li>trait resolution is already quite complex, I’m afraid that this would make it even more complex, with the added risk of slowing down the compiler/never returning;</li>
<li>it’s not entirely clear to me what should happen in case our plugged-in <code>equivalent</code> returns an error stating that no solution could be found;</li>
<li>it’s not entirely clear to me what should happen in case our plugged-in <code>equivalent</code> can find more than one equivalence – I suspect that this would probably be caused by an error in the implementation of <code>equivalent</code>, so perhaps this question doesn’t need an answer;</li>
<li>somehow, this feels too powerful.</li>
</ol></div>

<p>
  <h2 id="option-typevar-unification">
    Option: TypeVar unification
  </h2>
</p><p>We could somehow plug into <code>rustc_infer::infer</code>, rustc’s implementation of type inference, wherever we attempt to unify a <code>Unit&lt;V, T&gt;</code> and a <code>Unit&lt;V, U&gt;</code>, where either <code>T</code> or <code>U</code> contains a type variable. This would let us keep the definition of subtraction that requires a <code>Unit&lt;V, U&gt;</code> on both sides.</p>
<p>I am also not convinced by this approach, for several reasons:</p>
<div><ol>
<li>type unification is already non-trivial, as the author of a refinement type system, I don’t want to have to reimplement part of unification;</li>
<li>type unification happens all over the place, so there is a strong chance that this would slow down type checking considerably;</li>
<li>somehow, this feels too powerful.</li>
</ol></div>

<p>
  <h2 id="option-trait-resolution-optimistic">
    Option: Trait resolution (optimistic)
  </h2>
</p><p>Instead of this, we could offer a lower-powered solution that takes place in two steps.</p>
<p>Step 1: During trait resolution, we entirely discard the unit information and assume that <code>Left</code>
and <code>Right</code> are equivalent.</p>
<div>
  
  
  
  <div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span>&lt;</span>V, Left, Right, C<span>&gt;</span> std::ops::Sub<span>&lt;</span>Value<span>&lt;</span>V, Right<span>&gt;&gt;</span> <span>for</span> Value<span>&lt;</span>V, Left<span>&gt;</span>
</span></span><span><span><span>where</span> V: <span>std</span>::ops::Sub,
</span></span><span><span>      record!(yaoioum, Equivalent<span>&lt;</span>Left, Right<span>&gt;</span>) <span>// &lt;!-- record for later post-processing
</span></span></span><span><span><span></span>{
</span></span><span><span>    <span>type</span> <span>Output</span> <span>=</span> Value<span>&lt;&lt;</span>V <span>as</span> std::ops::Sub<span>&gt;</span>::Output, Left<span>&gt;</span>;
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>}</span></span></code></pre></div></div>
  
</div><p>In general, this is of course false, as this would let us subtract meters from seconds.</p>
<p>Step 2: At some point before code generation, the compiler calls the plug-in and passes
the list of equivalences that were assumed and lets the plug-in perform late rejection
of types that are not actually equivalent.</p>
<p>Critically, this steps 2 takes place after both trait selection and unification, which
means that type variables are already either resolved or truly generic. Intuitively,
this means that the post-processing step only needs to perform type-checking, rather
than any kind of type inference.</p>
<p>This variant feels faster, much less powerful than plugging an entirely new trait selection mechanism
into <code>rustc_infer</code>, the behavior in case of error is clearer, and the plug-in has access
to better information when displaying error messages. Also, it’s possible that the plug-in
would only need <code>rustdoc::clean::types::Type</code> type information, which are easier to
manipulate (and more stable) than <code>rustc_infer::traits::select::{SelectionCandidate, EvaluationResult}</code>.</p>
<p>My intuition, which would need to be confirmed, is that the post-processor would not always
have access to enough information to decide whether an addition/subtraction is correct, a bit
like the compiler cannot always determine whether <code>1.0</code> is a <code>f32</code> or a <code>f64</code>. Just as is the
case for number literals, I suspect that we could live with that, and reject anything that
cannot be proven correct, as long as error messages are clear enough that a developer can add
the missing annotations.</p>

<p>
  <h3 id="option-typevar-unification-optimistic">
    Option: TypeVar unification (optimistic)
  </h3>
</p><p>Similarly, we could perform optimistic typevar unification, e.g.</p>
<div><ol>
<li>mark <code>Unit</code> unification as something that must be recorded by the compiler;</li>
<li>assume that <code>Unit&lt;T, U&gt;</code> and <code>Unit&lt;T, V&gt;</code> are always unifiable if <code>U</code> or <code>V</code> is a type variable;</li>
<li>perform post-processing to confirm unifications.</li>
</ol></div>
<p>While this shares some of the benefits of optimistic trait resolution, I suspect that this would be
harder to debug both for the author of the plug-in and for its users.</p>

<p>
  <h3 id="option-optimistic-pluggable-keyword">
    Option: Optimistic, pluggable keyword
  </h3>
</p><p>In fact, in YAOIOUM, I implemented a variant on optimistic unification. When you write a method in Rust, you can mark it with an attribute, e.g.:</p>
<div>
  
  
  
  <div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span> Value<span>&lt;</span>T, U<span>&gt;</span> <span>where</span> U: <span>Unit</span> {
</span></span><span><span>    <span>#[allow(unused_attributes)]</span>
</span></span><span><span>    <span>#[yaoioum(method_unify)]</span>
</span></span><span><span>    <span>pub</span> <span>fn</span> <span>unify</span><span>&lt;</span>V: <span>Unit</span><span>&gt;</span>(self) -&gt; <span>Value</span><span>&lt;</span>T, V<span>&gt;</span> {
</span></span><span><span>        Self {
</span></span><span><span>            value: <span>self</span>.value,
</span></span><span><span>            unit: <span>PhantomData</span>,
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>}</span></span></code></pre></div></div>
  
</div><p>when writing a compiler plug-in, you can then walk the tree, looking for all instances of this attribute, and
apply some post-processing to the method. In effect, you are defining something akin to a new keyword.</p>
<p>With this mechanism, the following definition still fails:</p>
<div>
  
  
  
  <div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> diff <span>=</span> h <span>-</span> g; <span>// Error: cannot subtract `Value&lt;f64, Div&lt;Div&lt;Meter, Second&gt;, Second&gt;&gt;` from `Value&lt;f64, Div&lt;Meter, Mul&lt;Second, Second&gt;&gt;&gt;`
</span></span></span></code></pre></div></div>
  
</div><p>But the following two definitions pass type-checking</p>
<div>
  
  
  
  <div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> diff_1 <span>=</span> h.unify() <span>-</span> g; <span>// f64 Meter / (Second * Second) aka Value&lt;f64, Div&lt;Meter, Mul&lt;Second, Second&gt;&gt;&gt;&gt;
</span></span></span><span><span><span></span><span>let</span> diff_2 <span>=</span> h <span>-</span> g.unify(); <span>// f64 Meter / (Second * Second) aka Value&lt;f64, Div&lt;Div&lt;Meter, Second&gt;, Second&gt;&gt;&gt;
</span></span></span></code></pre></div></div>
  
</div><p>Since calls to <code>unify</code> can be detected by the plug-in, they can be accepted or rejected during the compilation phase.</p>
<p>While this variant is even more limited than the previous ones, and clearly less transparent for users, a few dozen
minutes of experimenting with a compiler variant using it showed no really annoying case.</p>

<p>
  <h3 id="what-about-error-messages">
    What about error messages?
  </h3>
</p><p>As mentioned above, I expect that refinement types can have two benefits:</p>
<div><ul>
<li>when they complement type-level programming, they make the type system more poweful;</li>
<li>when they replace type-level programming, it becomes possible to make error messages much clearer.</li>
</ul></div>
<p>In the case of YAOIOUM, an error message looks like</p>
<div>
  
  
  
  <div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> distance <span>=</span> Measure::<span>&lt;</span><span>f64</span>, Km<span>&gt;</span>::new(<span>300_000.</span>);
</span></span><span><span><span>let</span> duration <span>=</span> Measure::<span>&lt;</span><span>f64</span>, S<span>&gt;</span>::new(<span>1.</span>);
</span></span><span><span><span>let</span> _ <span>=</span> distance.unify() <span>-</span> duration;
</span></span><span><span><span>// Error:
</span></span></span><span><span><span>//         ----------------- in this unification
</span></span></span><span><span><span>//    = note: expected unit of measure: `S`
</span></span></span><span><span><span>//               found unit of measure: `Km`
</span></span></span></code></pre></div></div>
  
</div><p>which feels pretty neat.</p>

<p>Let’s look a bit further into the future, at a possible stable implementation. I believe that we’d like:</p>
<div><ul>
<li>as many types as possible defined in regular, userland crates (in this case, <code>Unit</code>, <code>Value</code>, <code>Mul</code>, <code>Div</code>, etc.);</li>
<li>any checks that cannot be implemented within Rust’s regular type system implemented in a post-processing crate, executed during compilation.</li>
</ul></div>
<p>This feels dual to the current design of procedural macros, which I think is a good sign. So, this could look like one of:</p>
<div>
  
  
  
  <div><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> refinement::Type;  <span>// Functionally equivalent to rustdoc::clean::types::Type, but doesn&#39;t need `rustc_private`.
</span></span></span><span><span><span></span><span>use</span> refinement::Error; <span>// Somewhat similar to rustc_errors, to be designed.
</span></span></span><span><span><span></span>
</span></span><span><span><span>// If we go for post-processing trait selection.
</span></span></span><span><span><span>//
</span></span></span><span><span><span>// The directive means that we&#39;re only ever called when `selection` is an instance
</span></span></span><span><span><span>// of `crate::yaoioum::Equivalent&lt;Left, Right&gt;`.
</span></span></span><span><span><span></span><span>#[postprocess::trait(crate::yaoioum::Equivalent)]</span>
</span></span><span><span><span>fn</span> <span>confirm_trait_selection</span>(span: <span>Span</span>, selection: <span>&amp;</span><span>Type</span>) -&gt; Result<span>&lt;</span>(), Error<span>&gt;</span> {
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>}
</span></span><span><span>
</span></span><span><span><span>// If we go for post-processing type variable unification.
</span></span></span><span><span><span>//
</span></span></span><span><span><span>// The directive means that we&#39;re only ever called when both `left` and `right`
</span></span></span><span><span><span>// are instances of `crate::yaoioum::Unit&lt;T, _&gt;`.
</span></span></span><span><span><span></span><span>#[postprocess::unify(crate::yaoioum::Unit)]</span>
</span></span><span><span><span>fn</span> <span>confirm_typevar_unification</span>(span: <span>Span</span>, left: <span>&amp;</span><span>Type</span>, right: <span>&amp;</span><span>Type</span>) -&gt; Result<span>&lt;</span>(), Error<span>&gt;</span> {
</span></span><span><span>    <span>/// ...
</span></span></span><span><span><span></span>}
</span></span><span><span>
</span></span><span><span><span>// If we go for post-processing a pseudo-keyword.
</span></span></span><span><span><span>//
</span></span></span><span><span><span>// The directive means that we&#39;re only ever called upon a call to `Value::unify`, which
</span></span></span><span><span><span>// entails that `args[0]` is an instance of `Value&lt;T, U&gt;` and `args[1]` is an instance of
</span></span></span><span><span><span>// `Value&lt;T, V&gt;`.
</span></span></span><span><span><span></span><span>#[postprocess::keyword(yaoioum(unify))]</span>
</span></span><span><span><span>fn</span> <span>confirm_keyword_unification</span>(span: <span>Span</span>, args: <span>&amp;</span>[<span>&amp;</span>Type]) -&gt; Result<span>&lt;</span>(), Error<span>&gt;</span> {
</span></span><span><span>    <span>/// ...
</span></span></span><span><span><span></span>}</span></span></code></pre></div></div>
  
</div>
<p>From here, the following steps would involve:</p>
<div><ul>
<li>gathering feedback;</li>
<li>writing a rustc driver that supports plug-ins for the three optimistic interfaces mentioned above;</li>
<li>implementing a few refinement types using these plug-ins, including a new version of YAOIOUM and ideally some subset of <a href="https://dl.acm.org/doi/10.1145/3591283">Flux</a> or <a href="https://popl18.sigplan.org/details/PLMW-POPL-2018/6/Liquid-Haskell-Refinement-Types-for-Haskell">Liquid Haskell</a> or SQL.</li>
</ul></div>
<p>I’m a bit busy working on <a href="https://www.pasqal.com">analog quantum programming</a> these days, so I’m not sure when and if I find time to do that. We’ll see :)</p>

          </div></article>
      </section>
      
      
      GITALK ENABLED
      
      
    </div></div>
  </body>
</html>
