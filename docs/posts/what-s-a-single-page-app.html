<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jakelazaroff.com/words/whats-a-single-page-app/">Original</a>
    <h1>What&#39;s a Single-Page App?</h1>
    
    <div id="readability-page-1" class="page"><div data-content="" data-astro-cid-onuac4el=""> <p>The web development community talks a lot about single-page apps, but are we all on a single page?</p>
<p>Heydon Pickering tackled this question in his similarly-named article <a href="https://heydonworks.com/article/what-is-a-single-page-application/" data-astro-cid-bi7aps5f="">What Is A Single-Page Application?</a><a data-tooltip="" href="https://heydonworks.com/article/what-is-a-single-page-application/" data-astro-cid-bi7aps5f=""> <img src="https://heydonworks.com/images/unofficial.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">What Is A Single-page Application?</span> <span data-astro-cid-bi7aps5f="">A quick explainer about single-page applications are what they are good for.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://heydonworks.com/android-icon-192x192.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">heydonworks.com/article/what-is-a-single-page-application/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>
The TL;DR — spoiler alert! — is that it’s a website that uses a ton of JavaScript to improve user experience by showing you a loading spinner.</p>
<p>That’s obviously tongue-in-cheek, but it’s a reaction to the working definition that most people use.
For better or worse, “single-page app” is usually a euphemism for “JavaScript framework app”.</p>
<p>I recently wrote about <a href="https://jakelazaroff.com/words/building-a-single-page-app-with-htmx/" data-astro-cid-bi7aps5f="">building a single-page app with htmx</a><a data-tooltip="" href="https://jakelazaroff.com/words/building-a-single-page-app-with-htmx/" data-astro-cid-bi7aps5f=""> <img src="https://jakelazaroff.com/og/building-a-single-page-app-with-htmx.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Building a Single-Page App with htmx | jakelazaroff.com</span> <span data-astro-cid-bi7aps5f="">People talk about htmx as though it&#39;s saving the web from single-page apps. Well, I guess I missed the memo, because I used htmx to build a single-page app.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://jakelazaroff.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">jakelazaroff.com/words/building-a-single-page-app-with-htmx/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> using service workers to render everything client-side — no loading spinners in sight!
In response, Thomas Broyer objected to the premise that htmx and single-page apps were opposites.
He showed me an article that he wrote called <a href="https://blog.ltgt.net/naming-things-is-hard-spa-edition/" data-astro-cid-bi7aps5f="">Naming things is hard, SPA edition</a><a data-tooltip="" href="https://blog.ltgt.net/naming-things-is-hard-spa-edition/" data-astro-cid-bi7aps5f=""> <img src="https://blog.ltgt.net/image/2023/03/ssr-csr.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Naming things is hard, SPA edition</span> <span data-astro-cid-bi7aps5f="">What is a single-page application (SPA) exactly? How does it relate to client-side rendering (CSR)? (spoiler: SPA doesn&#39;t necessarily imply CSR.)
</span> <span data-astro-cid-bi7aps5f=""> <img src="https://blog.ltgt.net/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">blog.ltgt.net/naming-things-is-hard-spa-edition/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> (which you should also go read!) that breaks down rendering into a spectrum.</p>
<figure><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 608 228"><use href="./ssr-csr.svg#diagram"></use><title><p>Schema of SSR, ESR, SWSR and CSR, with grouping representing SSR-in-the-broader-sense (SSR and ESR) vs. BSR (SWSR and CSR), and which generate HTML (SSR, ESR and SWSR) or manipulate the DOM (CSR)</p></title></svg><figcaption>The rendering spectrum, by Thomas Broyer.</figcaption></figure>
<p>In a bid to cement my burgeoning reputation as a <a href="https://jakelazaroff.com/words/the-website-vs-web-app-dichotomy-doesnt-exist/" data-astro-cid-bi7aps5f="">Quadrant Chart Guy</a><a data-tooltip="" href="https://jakelazaroff.com/words/the-website-vs-web-app-dichotomy-doesnt-exist/" data-astro-cid-bi7aps5f=""> <img src="https://jakelazaroff.com/og/the-website-vs-web-app-dichotomy-doesnt-exist.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">The Website vs. Web App Dichotomy Doesn&#39;t Exist | jakelazaroff.com</span> <span data-astro-cid-bi7aps5f="">A one-dimensional spectrum can&#39;t sufficiently capture the tradeoffs involved in web development.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://jakelazaroff.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">jakelazaroff.com/words/the-website-vs-web-app-dichotomy-doesnt-exist/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>, I feel compelled to add even <em>more</em> nuance to the situation:</p>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 720 672"><use href="./quadrant.svg#chart"></use><title><p>A graph with two axes that intersect in the exact center, labeled SSR/CSR horizontally and SPA/MPA vertically.</p></title></svg>
<p>I’m sorry.
Kinda.</p>
<p>Okay, let’s define the extrema of each axis:</p>
<ul>
<li>Server-side rendering (SSR) is when HTML is produced on a server and sent to the browser.</li>
<li>Client-side rendering (CSR) is when HTML (or some other representation, such as the result of a JSX transform) is produced on the <em>client</em> and applied to the DOM.</li>
<li>A multi-page app (MPA) is when a hyperlink click or form submission results in the browser replacing the current page with an entirely new document.</li>
<li>A single-page app (SPA) is when the browser <em>never</em> replaces the page with a new document, and instead makes all changes through client-side DOM manipulation.</li>
</ul>
<p>If you just came here for an answer to the title, that’s it; I guess you can go home now.
But I think it’s interesting to look at the various tools people use and how they fit in.</p>
<p>Most tools for building websites don’t lock you into just one quadrant.
After all, <em>any</em> tool lets you drop in a plain un-enhanced <code>&lt;a&gt;</code> tag and at the very least get MPA behavior, and most JavaScript usage outside of Google Tag Manager relies on client-side rendering (even if done manually).</p>
<p>So: without casting any aspersions, here’s my ontology of web app architectures organized by rendering and navigation.</p>
<h3 id="traditional-web-frameworks-and-static-site-generators">Traditional Web Frameworks and Static Site Generators</h3>
<p>This is a pretty large tent, encompassing WordPress, Django, Rails (pre-Turbolinks) Jekyll, Hugo, Eleventy and myriad others.
It also includes hand-authored HTML, though I wouldn’t describe that as a “tool” so much as a “way of life”.</p>
<p>Tools in this category are on the bottom left of the chart: server-side rendered multi-page apps.</p>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 720 672"><use href="./quadrant.svg#chart"></use><use href="./quadrant.svg#traditional"></use><title><p>A graph with two axes that intersect in the exact center, labeled SSR/CSR horizontally and SPA/MPA vertically.
A shaded region labeled “Traditional Frameworks &amp; Static Site Generators” covers the quadrant where SSR and SPA intersect.</p></title></svg>
<p>The tradeoffs of this quadrant are well known:</p>
<ul>
<li>The browser takes care of a lot of important accesibility features, such as letting screen readers know when the user navigates to a new page.</li>
<li>Delivering HTML first allows the content to be visible even if CSS or JavaScript fail to load.</li>
<li>Pages can load <em>even faster</em> if HTML is streamed in, rather than delivered all at once.</li>
<li>The full page must be downloaded and replaced on each navigation.</li>
<li>In fact, <em>every</em> interaction requires a network round trip.</li>
</ul>
<p>This experience has remained mostly unchanged for 30 years.
And it’s great!
With only a little bit of HTML and CSS, you can make a <em>pretty good</em> website; the <a href="http://motherfuckingwebsite.com" data-astro-cid-bi7aps5f="">many</a><a data-tooltip="" href="http://motherfuckingwebsite.com" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">Motherfucking Website</span>  <span data-astro-cid-bi7aps5f=""> <img src="http://motherfuckingwebsite.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">motherfuckingwebsite.com</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> <a href="http://bettermotherfuckingwebsite.com" data-astro-cid-bi7aps5f="">Motherfucking</a><a data-tooltip="" href="http://bettermotherfuckingwebsite.com" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">Better Motherfucking Website</span>  <span data-astro-cid-bi7aps5f=""> <img src="http://bettermotherfuckingwebsite.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">bettermotherfuckingwebsite.com</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> <a href="https://evenbettermotherfucking.website" data-astro-cid-bi7aps5f="">Website</a><a data-tooltip="" href="https://evenbettermotherfucking.website" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">Even Better Motherfucking Website</span> <span data-astro-cid-bi7aps5f="">It&#39;s even more fucking perfect than the others motherfucking websites.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://evenbettermotherfucking.website/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">evenbettermotherfucking.website</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> <a href="https://perfectmotherfuckingwebsite.com" data-astro-cid-bi7aps5f="">variations</a><a data-tooltip="" href="https://perfectmotherfuckingwebsite.com" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">Perfect Motherfucking Website</span> <span data-astro-cid-bi7aps5f="">🖕 And it’s really more fucking perfect than the last guy’s.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://perfectmotherfuckingwebsite.com/data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48dGV4dCB5PSIuOWVtIiBmb250LXNpemU9IjkwIj7wn5aVPC90ZXh0Pjwvc3ZnPgo=" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">perfectmotherfuckingwebsite.com</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> show just how far a few tags and properties get you.
The low barrier to entry is one of the main reasons the web flourished.</p>
<p>Three decades on, improvements in HTML and CSS are starting to mitigate some of the downsides.
Preloading resources, for example, allows the browser to preemptively download associated files, which can make navigation almost instantaneous.
And cross-document view transitions — not yet well supported, but hopefully soon! — promise to allow multi-page apps to navigate with fancy animations.</p>
<p>That said: requiring a network request and a whole new page for every interaction is a pretty strong constraint!
As developers’ ambitions grew, they leaned more and more heavily on JavaScript, which led to…</p>
<h3 id="javascript-frameworks">JavaScript Frameworks</h3>
<p>Although JavaScript was invented way back in 1995, I don’t think a schism truly happened until 2010 or so.
That’s when the stereotypical single-page apps began to emerge: rather than using small snippets of JavaScript to add client-side functionality to server-side rendered HTML, people started building apps with a JavaScript <em>framework</em> and rendering them on the client.</p>
<p>Note that I’m not talking about Next.js or similar tools (I’ll get to them in the next section).
I’m talking about Backbone, Angular 1, React with a custom Webpack setup… basically, JavaScript apps before circa 2018, when people would ship an HTML file with an empty <code>&lt;body&gt;</code> except for one lonely <code>&lt;script&gt;</code> tag.</p>
<p>Used thusly, JavaScript frameworks are the diametric opposite of traditional web frameworks: both navigation and rendering happens on the client.
As such, they fit neatly into the top right quadrant: client-side rendered single-page apps.</p>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 720 672"><use href="./quadrant.svg#chart"></use><use href="./quadrant.svg#frameworks"></use><title><p>A graph with two axes that intersect in the exact center, labeled SSR/CSR horizontally and SPA/MPA vertically.
A shaded region labeled “JavaScript Frameworks” covers the quadrant where CSR and SPA intersect.</p></title></svg>
<p>What are the benefits of this quadrant?</p>
<ul>
<li>The initial page load can be much faster once the JavaScript bundle is cached.</li>
<li>Page navigations can be instantaneous, since all the relevant state is already on the client.</li>
<li>Elements can persist across navigations, enabling e.g. uninterrupted media playback and fancy transition animations.</li>
<li>Modifying the UI without first going through the network enables much richer client-side interactions.</li>
</ul>
<p>In practice, I think many of the purported benefits of client-side rendered SPAs turned out to be wishful thinking:</p>
<ul>
<li>When bundles are cached with a hash of the full app code, every deploy busts the cache and forces the user to download the whole bundle again.</li>
<li>Page navigations tend to wait for API responses from a server and database in the same datacenter that would have served the HTML anyway.</li>
<li>Aspirations of being richly interactive are often fantasy; most websites are really just gussied up forms.</li>
</ul>
<p>There are also more general drawbacks:</p>
<ul>
<li>The client needs to download 100% of the UI code.</li>
<li>The initial page load (before the JavScript bundle is cached) will always be slower.</li>
<li>Page navigations are not accessible by default.</li>
<li>It’s way more difficult for apps here to be indexed by search engines.</li>
</ul>
<p>If I sound critical of this category, it’s only because the industry has largely recognized these drawbacks and moved on to other architectures.
While JavaScript frameworks are more popular than ever, they tend to exist as components of larger systems rather than than as app frameworks in and of themselves.</p>
<p>Client-side rendered SPAs still have their uses, though.
When I made <a href="https://jakelazaroff.com/words/a-local-first-case-study/" data-astro-cid-bi7aps5f="">my local-first trip planning app</a><a data-tooltip="" href="https://jakelazaroff.com/words/a-local-first-case-study/" data-astro-cid-bi7aps5f=""> <img src="https://jakelazaroff.com/og/a-local-first-case-study.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">A Local-First Case Study | jakelazaroff.com</span> <span data-astro-cid-bi7aps5f="">How I built a local-first app for planning trips, and what I learned about the current state of the local-first ecosystem along the way.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://jakelazaroff.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">jakelazaroff.com/words/a-local-first-case-study/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>, I built it as a client-side rendered SPA.
There was really no other way to build it — since the client has the canonical copy of the data, there’s not even a server to do any rendering!
As local-first picks up steam, I hope and expect to see this architecture make a resurgence in a way that <em>does</em> capture the upside of the quadrant’s tradeoffs.</p>
<h3 id="javascript-metaframeworks">JavaScript Metaframeworks</h3>
<p>JavaScript frameworks had about half a decade of client-side rendering glory before people realized that delivering entire applications that way was bad for performance.
To address that, developers starting building <em>meta</em>frameworks<sup><a href="#user-content-fn-metaframeworks" id="user-content-fnref-metaframeworks" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">1</a></sup> — Next.js, Remix, SvelteKit, Nuxt and Solid Start, among others — that rendered on the server as well.</p>
<p>In metaframeworks, rendering happens in two different ways:</p>
<ol>
<li>When the user requests a page, the app runs on the <em>server</em>, rendering the appropriate HTML and serving it to the browser. This step is <em>server-side rendered</em>.</li>
<li>Next, the browser requests the JavaScript bundle. That same app then runs in the <em>browser</em>, “hydrating” the already-rendered HTML and taking over any further interactions. This step is <em>client-side rendered</em>.</li>
</ol>
<p>These steps slot neatly into the top left and top right quadrants, respectively:</p>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 720 672"><use href="./quadrant.svg#chart"></use><use href="./quadrant.svg#metaframeworks"></use><title><p>A graph with two axes that intersect in the exact center, labeled SSR/CSR horizontally and SPA/MPA vertically.
A shaded region labeled “JavaScript Metaframeworks” covers the SPA half, covering both SSR and CSR.</p></title></svg>
<p>JavaScript metaframeworks are an attempt to get the “best of both worlds” between server-side rendered multi-page apps and client-side rendered single-page apps.
In particular, they fix the cold cache initial page load and SEO drawbacks of the latter.
With React Server Components, React-based metaframeworks can omit UI code from the JavaScript bundle as well.<sup><a href="#user-content-fn-rsc" id="user-content-fnref-rsc" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">2</a></sup></p>
<p>Depending on whom you ask, this is either good because it really <em>is</em> a “best of both worlds” situation, or bad because your UI is probably useless before it hydrates with the JavaScript (that your users still need to download).
But “probably” in that sentence is doing at least some amount of lifting; many metaframeworks like SvelteKit and Remix embrace progressive enhancement and work without JavaScript by default.</p>
<p>A couple years ago, Nolan Lawson <a href="https://nolanlawson.com/2022/06/27/spas-theory-versus-practice/" data-astro-cid-bi7aps5f="">attempted to bridge the two camps</a><a data-tooltip="" href="https://nolanlawson.com/2022/06/27/spas-theory-versus-practice/" data-astro-cid-bi7aps5f=""> <img src="https://nolanlawson.com/wp-content/uploads/2022/06/vlcsnap-2022-06-25-16h27m34s714-small.png?w=1200" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">SPAs: theory versus practice</span> <span data-astro-cid-bi7aps5f="">I’ve been thinking a lot recently about Single-Page Apps (SPAs) and Multi-Page Apps (MPAs). I’ve been thinking about how MPAs have improved over the years, and where SPAs still have an …</span> <span data-astro-cid-bi7aps5f=""> <img src="https://secure.gravatar.com/blavatar/86a4db4d496aa2fad7e47b11a865e80cfbbbac38285b65ff518b9c98aa47f7d7?s=32" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">nolanlawson.com/2022/06/27/spas-theory-versus-practice/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>:</p>
<blockquote>
<p>At the risk of grossly oversimplifying things, I propose that the core of the debate can be summed up by these truisms:</p>
<ol>
<li>The best SPA is better than the best MPA.</li>
<li>The average SPA is worse than the average MPA.</li>
</ol>
</blockquote>
<p>I think that’s a fair take, but there are a couple other architectures still remaining that make things a little blurrier.</p>
<h3 id="islands-frameworks">Islands Frameworks</h3>
<p>Recently we’ve seen the emergence of a new category: server-side rendered multi-page frameworks that embrace <a href="https://www.patterns.dev/vanilla/islands-architecture" data-astro-cid-bi7aps5f="">islands of interactivity</a><a data-tooltip="" href="https://www.patterns.dev/vanilla/islands-architecture" data-astro-cid-bi7aps5f=""> <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/f_auto/v1633286240/patterns.dev/islandsarchitecture.jpg" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Islands Architecture</span> <span data-astro-cid-bi7aps5f="">The islands architecture encourages small, focused chunks of interactivity within server-rendered web pages</span> <span data-astro-cid-bi7aps5f=""> <img src="https://www.patterns.dev/img/favicon/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">www.patterns.dev/vanilla/islands-architecture</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> for rich client-side behavior.
While the idea itself isn’t new, the current crop of frameworks built around it are — Astro, Deno Fresh and Enhance, among others.</p>
<p>In case you’re unfamiliar: an island of interactivity is a region of an otherwise static HTML page that is controlled by JavaScript.
It’s an acknowledgment that while richly interactive applications do exist, the richly interactive part is often surrounded by a more traditional website.
The classic example is a carousel, but the pattern is broadly useful; the <a href="https://jakelazaroff.com/words/web-components-will-outlive-your-javascript-framework/" data-astro-cid-bi7aps5f="">interactive demos on this very blog</a><a data-tooltip="" href="https://jakelazaroff.com/words/web-components-will-outlive-your-javascript-framework/" data-astro-cid-bi7aps5f=""> <img src="https://jakelazaroff.com/og/web-components-will-outlive-your-javascript-framework.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Web Components Will Outlive Your JavaScript Framework | jakelazaroff.com</span> <span data-astro-cid-bi7aps5f="">If we&#39;re building things that we want to work in five or ten or even 20 years, we need to avoid dependencies and use the web with no layers in between.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://jakelazaroff.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">jakelazaroff.com/words/web-components-will-outlive-your-javascript-framework/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> are built as islands within static HTML.</p>
<p>What that means in practice is that these websites will fit mostly into the bottom left quadrant — except for the namesake islands of interactivity, which fit into the bottom right.</p>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 720 672"><use href="./quadrant.svg#chart"></use><use href="./quadrant.svg#islands"></use><title><p>A graph with two axes that intersect in the exact center, labeled SSR/CSR horizontally and SPA/MPA vertically.
A shaded region labeled “Islands Frameworks” covers the MPA half, covering both SSR and CSR.</p></title></svg>
<p>Similar to JavaScript metaframeworks, islands frameworks also try to get the “best of both worlds” between client-side and server-side rendering — albeit as MPAs rather than SPAs.
The bet is that reducing complexity around the static parts of a page is a better tradeoff than giving developers more control.
As with traditional web frameworks, the gap between them should narrow as support for view transitions gets better.</p>
<h3 id="partial-swapping">Partial Swapping</h3>
<p>This pattern is less all-encompassing than some of the others, but it’s worth mentioning because the past few years have seen it explode in popularity.
By “partial swapping”, I mean making an HTTP request for the server to render an HTML fragment that gets inserted directly into the page.</p>
<p>To wit, websites using partial swapping generally fall on the server-side rendered side of the chart, spanning both the single-page <em>and</em> multi-page quadrants:</p>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 720 672"><use href="./quadrant.svg#chart"></use><use href="./quadrant.svg#htmx"></use><title><p>A graph with two axes that intersect in the exact center, labeled SSR/CSR horizontally and SPA/MPA vertically.
A shaded region labeled “Partial Swapping” covers the SSR half, covering both SPA and MPA.</p></title></svg>
<p>The most famous partial swapping tool is htmx, which people tend to use in conjunction with “traditional” server-side rendered frameworks.
Other libraries like Unpoly and Turbo work similarly.
Some frameworks in other categories, such as Rails (with Turbo) and Deno Fresh, have adopted partial swapping as well.</p>
<p>As I’ve written before, people act as though this pattern is saving the web from SPAs.
Once we widen our view like this, though, we can see that’s a false dichotomy.
In fact, by making it easier for developers to replace finer-grained regions of the page, partial swapping is actually a tool for <em>creating SPAs</em><sup><a href="#user-content-fn-lesshtmx" id="user-content-fnref-lesshtmx" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">3</a></sup> — albeit server-side rendered ones.</p>
<p>It’s not all or nothing!
The htmx documentation outlines <a href="https://htmx.org/essays/hypermedia-friendly-scripting/" data-astro-cid-bi7aps5f="">how this pattern can work in conjunction with client-side scripting approaches such as islands</a><a data-tooltip="" href="https://htmx.org/essays/hypermedia-friendly-scripting/" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">&lt;/&gt; htmx ~ Hypermedia-Friendly Scripting</span>  <span data-astro-cid-bi7aps5f=""> <img src="https://htmx.org/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">htmx.org/essays/hypermedia-friendly-scripting/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>.
I won’t make a chart with three of the four quadrants filled in, but you get the idea: these boundaries are fluid, and good tools don’t lock developers into a specific region.</p>
<p>Partial swapping can also be used as a polyfill for cross-document view transitions.
Frameworks like Astro allow authors to load full pages asynchronously, progressively enhancing MPAs into server-side rendered SPAs.</p>
<h3 id="did-we-learn-anything">Did We Learn Anything?</h3>
<p>None of this is particularly groundbreaking.
But I agree with Thomas that imprecise terminology doesn’t help whatever discourse plays out on the hot-take-fueled Internet argument fora.
Hopefully, this can serve as a reference point when we talk about when and where these architectures are appropriate.</p>

 </div></div>
  </body>
</html>
