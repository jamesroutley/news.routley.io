<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.octomind.dev/blog/why-we-no-longer-use-langchain-for-building-our-ai-agents">Original</a>
    <h1>We no longer use LangChain for building our AI agents</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>At Octomind, we use AI agents with multiple LLMs to automatically create and fix end-to-end tests in Playwright. Until just a few months ago, we did it with the <a href="https://www.langchain.com/">LangChain framework</a>.</p><p>‍</p><p>In this post I’ll share our struggles with LangChain and why replacing its rigid high-level abstractions with modular building blocks simplified our code base and made our team happier and more productive. </p><h2>The backstory</h2><p>We used LangChain in production for over 12 months, starting in early 2023 then removing it in 2024.</p><p>LangChain seemed to be the best choice for us in 2023. It had an impressive list of components and tools, and its popularity soared. It promised to “<em>enable developers to go from an idea to working code in an afternoon.</em>” But problems started to surface as our requirements became more sophisticated, turning LangChain into a source of friction, not productivity.</p><p>‍</p><p>As its inflexibility began to show, we soon found ourselves diving into LangChain internals, to improve lower-level behavior of our system. But because LangChain intentionally abstracts so many details from you, it often wasn’t easy or possible to write the lower-level code we needed to.</p><p>‍</p><h2>The perils of being an early framework</h2><p>AI and LLMs are rapidly changing fields, with new concepts and ideas popping up weekly. So when a framework such as LangChain is created around multiple emerging technologies, designing abstractions that will stand the test of time is incredibly difficult.</p><p>I’m sure that If I had attempted to build a framework such as LangChain when they did, I wouldn’t have done any better. Mistakes are easy to point out in hindsight, and the intent of this post is not to unfairly criticize LangChain’s core developers or their contributors. Everyone is doing the best they can.</p><p>‍</p><p><strong>Crafting well-designed abstractions is hard</strong> - even if the requirements are well-understood. But when you’re modelling components in such a state of flux (e.g. agents), it’s a safer bet to use abstractions for lower level building blocks only.</p><p>‍</p><h2>The problem with LangChain’s abstractions</h2><p>LangChain was helpful at first when our simple requirements aligned with its usage presumptions. But its high-level abstractions soon made our code more difficult to understand and frustrating to maintain. When our team began spending as much time understanding and debugging LangChain as it did building features, it wasn’t a good sign. </p><p>‍</p><p>Issues with LangChain’s approach to abstractions can be demonstrated with this trivial example of translating an English word into Italian.</p><p>Here is a Python example using just the OpenAI package:</p></div><pre contenteditable="false"><code><span>from</span><span> openai </span><span>import</span><span> OpenAI
</span>
<span>client = OpenAI(api_key=</span><span>&#34;&lt;your_api_key&gt;&#34;</span><span>)
</span><span>text = </span><span>&#34;hello!&#34;</span><span>
</span><span>language = </span><span>&#34;Italian&#34;</span><span>
</span>
messages = [
<span>    {</span><span>&#34;role&#34;</span><span>: </span><span>&#34;system&#34;</span><span>, </span><span>&#34;content&#34;</span><span>: </span><span>&#34;You are an expert translator&#34;</span><span>},
</span><span>    {</span><span>&#34;role&#34;</span><span>: </span><span>&#34;user&#34;</span><span>, </span><span>&#34;content&#34;</span><span>: </span><span>f&#34;Translate the following from English into </span><span>{language}</span><span>&#34;</span><span>},
</span><span>    {</span><span>&#34;role&#34;</span><span>: </span><span>&#34;user&#34;</span><span>, </span><span>&#34;content&#34;</span><span>: </span><span>f&#34;</span><span>{text}</span><span>&#34;</span><span>},
</span>]

<span>response = client.chat.completions.create(model=</span><span>&#34;gpt-4o&#34;</span><span>, messages=messages)
</span><span>result = response.choices[</span><span>0</span><span>].message.content</span></code></pre><div><p>This is simple code that is easy to understand, containing a single class and one function call. The rest is standard Python.</p><p>Let’s contrast this with LangChain’s version:</p></div><pre contenteditable="false"><code><span>from</span><span> langchain_openai </span><span>import</span><span> ChatOpenAI
</span><span></span><span>from</span><span> langchain_core.output_parsers </span><span>import</span><span> StrOutputParser
</span><span></span><span>from</span><span> langchain_core.prompts </span><span>import</span><span> ChatPromptTemplate
</span>
<span>os.environ[</span><span>&#34;OPENAI_API_KEY&#34;</span><span>] = </span><span>&#34;&lt;your_api_key&gt;&#34;</span><span>
</span><span>text = </span><span>&#34;hello!&#34;</span><span>
</span><span>language = </span><span>&#34;Italian&#34;</span><span>
</span>

prompt_template = ChatPromptTemplate.from_messages(
<span>    [(</span><span>&#34;system&#34;</span><span>, </span><span>&#34;You are an expert translator&#34;</span><span>),
</span><span>     (</span><span>&#34;user&#34;</span><span>, </span><span>&#34;Translate the following from English into {language}&#34;</span><span>),
</span><span>     (</span><span>&#34;user&#34;</span><span>, </span><span>&#34;{text}&#34;</span><span>)]
</span>)

parser = StrOutputParser()
chain = prompt_template | model | parser
<span>result = chain.invoke({</span><span>&#34;language&#34;</span><span>: language, </span><span>&#34;text&#34;</span><span>: text})</span></code></pre><div><p>The code is roughly doing the same, but that’s where the similarities end. </p><p>We now have three classes and four function calls. But most concerning, is the introduction of three new abstractions:</p><ul role="list"><li>Prompt templates: Providing a prompt to the LLM</li><li>Output parsers: Processing output from the LLM</li><li>Chains: LangChain’s “LCEL syntax” overriding Python’s `|` operator</li></ul><p>‍</p><p>All LangChain has achieved is increased the complexity of the code with no perceivable benefits.</p><p>This code might be fine for early-stage prototypes. But <strong>for production usage, every component must be reasonably understood</strong> so it won’t blow up on you unexpectedly under real-world usage conditions. You have to adhere to the given data structures and design your application around those abstractions.</p><p>Let’s look at another abstraction comparison in Python, this time for fetching JSON from an API.</p><p>Using the built-in http package:</p></div><pre contenteditable="false"><code><span>import</span><span> http.client
</span><span></span><span>import</span><span> json
</span>
<span>conn = http.client.HTTPSConnection(</span><span>&#34;api.example.com&#34;</span><span>)
</span><span>conn.request(</span><span>&#34;GET&#34;</span><span>, </span><span>&#34;/data&#34;</span><span>)
</span>response = conn.getresponse()
data = json.loads(response.read().decode())
conn.close()</code></pre><p>Using the requests package:</p><pre contenteditable="false"><code><span>import</span><span> requests
</span>
<span>response = requests.get(</span><span>&#34;/data&#34;</span><span>)
</span>data = response.json()</code></pre><div><p>The winner is obvious. That’s what a good abstraction feels like.</p><p>Granted, these are trivial examples. But my point is that good abstractions simplify your code and reduce the cognitive load required to understand it.</p><p>LangChain tries to make your life easier by doing more with less code by <strong>hiding details away from you</strong>. But when this comes at the cost of simplicity and flexibility, ‌abstractions lose their value.</p><p>LangChain also has a habit of using <strong>abstractions on top of other abstractions</strong>, so you’re often forced to think in terms of nested abstractions to understand how to use an API correctly. This inevitably leads to comprehending huge stack traces and debugging internal framework code you didn’t write instead of implementing new features.</p><p>‍</p><h2>LangChain’s impact on our development team</h2><p>Our application makes heavy use of AI agents for performing different types of tasks, such as test case discovery, Playwright test  generation, and auto-fixing.</p><p>‍</p><p>When we wanted to move from an architecture with a single sequential agent to something more complex, LangChain was the limiting factor. For example, spawning sub-agents and letting them interact with the original agent. Or multiple specialist agents interacting with each other. <br/></p><p>‍</p><p>In another instance, we needed to dynamically change the availability of tools our agents could access, based on business logic and output from the LLM. But LangChain does ‌not provide a method for externally observing an agent’s state, resulting in us reducing the scope of our implementation to fit into the limited functionality available to LangChain Agents.</p><p>‍</p><blockquote><em>Once we removed it, we no longer had to translate our requirements into LangChain appropriate solutions. We could just code.</em></blockquote><p>‍</p><p>So, if not LangChain, what framework should you be using? Perhaps you don’t need a framework at all.</p><p>‍</p><h2>Do you need a framework for building AI applications?</h2><p>LangChain helped us early on by providing LLM features  so we could focus on building our application. But in hindsight, we would’ve been better off long-term without a framework.</p><p>‍</p><p>LangChain’s long list of components gives the impression that building an LLM-powered application is complicated. But the core components most applications will need are typically:</p><ul role="list"><li>A client for LLM communication</li><li>Functions/Tools for function calling </li><li>A vector database for RAG</li><li>An Observability platform for tracing, evaluation etc.</li></ul><p>The rest are either helpers around those components (e.g. chunking and embeddings for vector databases), or regular application tasks such as managing files and application state through data persistence and caching.</p><p>If you start your AI development journey without a framework, yes, it will take longer to put your own toolbox together and require more upfront learning and research. But this is time well spent and a worthy investment in you and your application’s future, since you are learning fundamentals in the field you are going to operate.</p><p>‍</p><p>In most cases, <strong>your usage of LLMs will be simple and straightforward</strong>. You’ll mostly be writing sequential code, iterating on prompts, and improving the quality and predictability of your output. The majority of tasks can be achieved with simple code and a relatively small collection of external packages.</p><p>Even if using agents, it’s unlikely you’ll be doing much beyond simple agent to agent communication in a predetermined sequential flow with business logic for handling agent state and their responses. You don’t need a framework to implement this.</p><p>‍</p><blockquote><em>While the Agents space is rapidly evolving with exciting possibilities and interesting use cases, we recommend keeping things simple for now while agent usage patterns solidify.</em></blockquote><p>‍</p><h2>Staying fast and lean with building blocks</h2><p>Presuming you’re not shipping rubbish code to production, the speed at which a team can innovate and iterate is the most important metric for success. A lot of development in the AI space is driven by experimentation and prototyping.</p><p>‍</p><p>But frameworks are typically designed for <strong>enforcing structure based on well-established patterns of usage</strong> - something LLM-powered applications don’t yet have. Having to translate new ideas into framework-specific code, limits your speed of iteration.</p><p>‍</p><p>A building blocks approach prefers simple low-level code with carefully selected external packages, keeping your architecture lean so developers can devote their attention to the problem they’re trying to solve.</p><p>‍</p><p>A building block being something simple you feel is comprehensively understood and unlikely to change. For example, a vector database. It’s a known type of <strong>modular component with a baseline set of features so it can easily be swapped</strong> out and replaced. Your codebase needs to be lean and adaptable to maximize your learning speed and the value you get from each iteration cycle.</p><p>‍</p><p>. . . </p><p>‍</p><p>I hope I thoughtfully and fairly described our challenges with LangChain and why moving away from frameworks altogether has been hugely beneficial for our team.</p><p>Our current strategy of using modular building blocks with minimal abstractions allows us to now develop more quickly and with less friction.</p><p>‍</p></div><div><p><img src="https://cdn.prod.website-files.com/647618f73e4f16d380e8eed9/6669a56dabcefef0f84e1ff0_fabib%20-%20closeup.webp" loading="lazy" alt="maximilian link headshot"/></p></div></div></div>
  </body>
</html>
