<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://admccartney.mur.at/programming/idkproc/">Original</a>
    <h1>Not knowing the /proc file system</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
  <div>
    <div>
      <article role="main">
        
<p>I’ve been working quite with files and file systems on Linux recently.
Mostly from the vantage point of either a shell or a python script. I
wanted to practice coding against the Linux API, so I cracked open my
copy of <a href="https://man7.org/tlpi/">the Linux Programming Interface</a> to
see if I could find some useful info. As usual, I found myself on an
enjoyable tangent learning about file system and process fundamentals.</p>
<p>I developed a fairly simple goal for a small project over the weekend:
pick some essential aspect of Linux file systems and learn a bit about
it. Specifically, try to use the Linux API directly or at least
understand what parts of the API are being used by whatever script is
being used to get the job done.</p>
<p>The task I eventually settled on is described as a simple exercise in
the book mentioned above. Write a program that prints a list of all
processes running on the system that are associated with a specific
user. Print the pid and name of the program being run. It’s possible to
glean all of this information from the <code>/proc</code> file system. The file
<code>/proc/$pid/status</code> holds the info about uid and program name.</p>
<p>The general plan:</p>
<ol>
<li>Write a quick script in python to do the job</li>
<li>Run the script using strace to see what system calls are being made</li>
<li>Write a program in c to do the same job but use the API directly</li>
<li>Run the program through strace and compare the footprint</li>
<li>Profile both programs</li>
</ol>
<h2 id="python-script">Python script</h2>
<p>The initial script is very straight forward. Is relies on the <code>os</code>
module and the <code>pathlib.Path</code> class to get the uid, list the pids of all
processes being run. It then opens the <code>/proc/$pid/status</code> file for each process
and reads two lines; the first to get the name of the program being run and the
ninth to get the uid.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>#!/usr/bin/python</span>
</span></span><span><span><span>import</span> os
</span></span><span><span><span>from</span> pathlib <span>import</span> Path
</span></span><span><span>
</span></span><span><span>__doc__ <span>=</span><span>&#34;&#34;&#34;procuall.py: enumerate all processes run by the user who runs the
</span></span></span><span><span><span>script.
</span></span></span><span><span><span>
</span></span></span><span><span><span>usage: python procuall.py
</span></span></span><span><span><span>&#34;&#34;&#34;</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>search_proc</span>():
</span></span><span><span>    <span>&#34;&#34;&#34;for each process under /proc
</span></span></span><span><span><span>       parse the status file and try to match uid
</span></span></span><span><span><span>       if there is a match, the process belongs to the user&#34;&#34;&#34;</span>
</span></span><span><span>    uid <span>=</span> os<span>.</span>getuid()
</span></span><span><span>    all <span>=</span> Path(<span>&#34;/proc&#34;</span>)
</span></span><span><span>    procs <span>=</span> all<span>.</span>glob(<span>&#34;[0-9]*&#34;</span>)
</span></span><span><span>    processes <span>=</span> [p <span>for</span> p <span>in</span> procs]
</span></span><span><span>    info <span>=</span> {}
</span></span><span><span>    <span>for</span> proc <span>in</span> processes:
</span></span><span><span>        status <span>=</span> proc<span>.</span>joinpath(<span>&#34;status&#34;</span>)
</span></span><span><span>        <span>with</span> open(status) <span>as</span> f:
</span></span><span><span>            lines <span>=</span> f<span>.</span>readlines()
</span></span><span><span>            cmd <span>=</span> lines[<span>0</span>]<span>.</span>split(<span>&#34;</span><span>\t</span><span>&#34;</span>)
</span></span><span><span>            name <span>=</span> cmd[<span>1</span>]<span>.</span>strip(<span>&#34;</span><span>\n</span><span>&#34;</span>)
</span></span><span><span>            uidl <span>=</span> lines[<span>8</span>]<span>.</span>split(<span>&#34;</span><span>\t</span><span>&#34;</span>)
</span></span><span><span>            puid <span>=</span> uidl[<span>1</span>]<span>.</span>strip(<span>&#34;</span><span>\n</span><span>&#34;</span>)
</span></span><span><span>            <span>if</span> int(puid) <span>==</span> uid:
</span></span><span><span>                info<span>.</span>update({name: proc<span>.</span>stem})
</span></span><span><span>    <span>return</span> info
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>main</span>():
</span></span><span><span>    <span>&#34;&#34;&#34;Get info about running processes
</span></span></span><span><span><span>    output the command being run and the pid&#34;&#34;&#34;</span>
</span></span><span><span>    info <span>=</span> search_proc()
</span></span><span><span>    <span>for</span> k, v <span>in</span> info<span>.</span>items():
</span></span><span><span>        print(<span>f</span><span>&#34;cmd: </span><span>{</span>k<span>}</span><span>, pid: </span><span>{</span>v<span>}</span><span>&#34;</span>)
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>if</span> __name__ <span>==</span> <span>&#39;__main__&#39;</span>:
</span></span><span><span>    main()
</span></span></code></pre></div><p>I found it quite beneficial to sketch out a working program like this. It didn’t
take more than a couple of minutes to get it working and it made it possible to
think of ways to improve the program for the second iteration.</p>
<h2 id="strace-output">Strace output</h2>
<p>The first thing that I went looking for in the strace output was which
system calls get used to list the contents of a directory. In the python
code the <code>Path.glob(&#34;*&#34;)</code> function is being used to list everything
in the <code>proc</code> directory. The listing happens over the course of three
system calls, lines 912-914 below. Note that these calls are lower level
than anything we would use directly from a C program. The directory is
first opened, then <code>fstatat</code> is called to get the <code>stat</code> structure for
the directory. The call to <code>openat</code> returns the file descriptor for the
directory. This is then passed as the first argument to the 4 following
function calls lines 913-916 below. The hex value is the address of the
directory, this is passed along with the <code>st_size</code> attribute to the
<code>getdents64</code> system call.</p>
<p>One curious part of the system calls generated by the python code is that is
seems to call <code>newfstatat</code> and <code>getents64</code> again with an empty string. I wonder
if this might be some side-effect of the use of the <code>Path.glob</code> function. Which
would imply inclusion of the empty directory?</p>
<p>One moderately thing that occurred to me after writing the initial
python program was that it’s not necessary to read the <code>uid</code> line of the
<code>/proc/$PID/status</code> file. An <code>fstat</code> call using the file descriptor is
enough to glean this info.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># output of strace python procuall.py</span>
</span></span><span><span>...
</span></span><span><span><span>910</span> getuid<span>()</span>                                <span>=</span> <span>1000</span>
</span></span><span><span><span>911</span> newfstatat<span>(</span>AT_FDCWD, <span>&#34;/proc&#34;</span>, <span>{</span>st_mode<span>=</span>S_IFDIR|0555, st_size<span>=</span>0, ...<span>}</span>, 0<span>)</span> <span>=</span> <span>0</span>
</span></span><span><span><span>912</span> openat<span>(</span>AT_FDCWD, <span>&#34;/proc&#34;</span>, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY<span>)</span> <span>=</span> <span>3</span>
</span></span><span><span><span>913</span> newfstatat<span>(</span>3, <span>&#34;&#34;</span>, <span>{</span>st_mode<span>=</span>S_IFDIR|0555, st_size<span>=</span>0, ...<span>}</span>, AT_EMPTY_PATH<span>)</span> <span>=</span> <span>0</span>
</span></span><span><span><span>914</span> getdents64<span>(</span>3, 0x560cbd19e900 /* <span>416</span> entries */, 32768<span>)</span> <span>=</span> <span>11232</span>
</span></span><span><span><span>915</span> getdents64<span>(</span>3, 0x560cbd19e900 /* <span>0</span> entries */, 32768<span>)</span> <span>=</span> <span>0</span>
</span></span><span><span><span>916</span> close<span>(</span>3<span>)</span>                                <span>=</span> <span>0</span>
</span></span><span><span>...
</span></span></code></pre></div><p>It was quite clear from the strace output that the overhead of the interpreter
costs practically the same as running the program itself. Strace generated over
3000 lines of output. The C version used about half the number of system calls.
The really major difference is the absence of the virtual machine.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># output of strace ./procuall adam</span>
</span></span><span><span>...
</span></span><span><span><span>97</span> openat<span>(</span>AT_FDCWD, <span>&#34;/proc&#34;</span>, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY<span>)</span> <span>=</span> <span>3</span>
</span></span><span><span><span>98</span> newfstatat<span>(</span>3, <span>&#34;&#34;</span>, <span>{</span>st_mode<span>=</span>S_IFDIR|0555, st_size<span>=</span>0, ...<span>}</span>, AT_EMPTY_PATH<span>)</span> <span>=</span> <span>0</span>
</span></span><span><span><span>99</span> getdents64<span>(</span>3, 0x7d3db0 /* <span>438</span> entries */, 32768<span>)</span> <span>=</span> <span>12552</span>
</span></span><span><span>...
</span></span></code></pre></div><p>The following is the strace output surrounding the code that generates the data
for the eventual printed line of:</p>
<pre tabindex="0"><code>cmd: nvim, pid: 306559
</code></pre><p>One thing that stands out is the call to <code>ioctl</code> - I have no idea why
this is happening and it also appears to be causing an error. As far as
I understand, the ioctl call signifies that the program is trying to do
a terminal control operation. Dunno.</p>
<pre tabindex="0"><code>3339 openat(AT_FDCWD, &#34;/proc/306559/status&#34;, O_RDONLY|O_CLOEXEC) = 3
3340 newfstatat(3, &#34;&#34;, {st_mode=S_IFREG|0444, st_size=0, ...}, AT_EMPTY_PATH) = 0
3341 ioctl(3, TCGETS, 0x7ffff4b194b0)        = -1 ENOTTY (Inappropriate ioctl for devi»
3342 lseek(3, 0, SEEK_CUR)                   = 0
3343 read(3, &#34;Name:\tnvim\nUmask:\t0022\nState:\tS &#34;..., 8192) = 1466
3344 read(3, &#34;&#34;, 8192)                       = 0
3345 close(3)                                = 0
</code></pre><p>Strace output from the C program for gathering data for the following line.</p>
<pre tabindex="0"><code>Name:   nvim               pid:306559
</code></pre><p>Again, the output looks a bit tidier. One noticeable difference is that
we’re now at a much higher increment of file descriptor. This is because
of the way the program’s loop is running. We’re not closing files after
we’re finishing them, instead we’re just letting this happen implicitly
on program exit. There is also no <code>lseek</code> operation as there way in the
python code. The file pointer is at byte zero on opening the file, so
I don’t really understand why the python version is calling lseek to
reposition it at the beginning of the file.</p>
<pre tabindex="0"><code>1149 openat(AT_FDCWD, &#34;/proc/306559/status&#34;, O_RDONLY) = 341
1150 newfstatat(341, &#34;&#34;, {st_mode=S_IFREG|0444, st_size=0, ...}, AT_EMPTY_PATH) = 0
1151 newfstatat(341, &#34;&#34;, {st_mode=S_IFREG|0444, st_size=0, ...}, AT_EMPTY_PATH) = 0
1152 read(341, &#34;Name:\tnvim\nUmask:\t0022\nState:\tS &#34;..., 1024) = 1024
1153 write(1, &#34;Name:\tnvim               pid:306&#34;..., 60) = 60
</code></pre><h2 id="c-program">C program</h2>
<p>The listing for the C code is included below. I definitely don’t have
as much practice writing C as python. I try to pick up good habits when
I see them. There are some good online resources for this, like <a href="https://nullprogram.com">Chris
Wellons’</a> website.</p>
<p>The only real overhead to speak of in the C version is linking a few
libraries at the top of the program. I’m using a custom function for
reading lines from a file.</p>
<div><pre tabindex="0"><code data-lang="C"><span><span><span>/* Function to read a line from file */</span>
</span></span><span><span><span>char</span><span>*</span> <span>fgetLine</span>(<span>size_t</span> size, FILE<span>*</span> fd)
</span></span><span><span>{
</span></span><span><span>	<span>char</span><span>*</span> input <span>=</span> NULL;
</span></span><span><span>	<span>char</span><span>*</span> buf;
</span></span><span><span>	buf <span>=</span> <span>malloc</span>(size);  <span>/* allocate the min number of bytes */</span>
</span></span><span><span>	<span>if</span> (buf <span>==</span> NULL) {
</span></span><span><span>		<span>fprintf</span>(stderr, <span>&#34;malloc error</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>		<span>exit</span>(<span>1</span>);
</span></span><span><span>	}
</span></span><span><span>    <span>size_t</span> len <span>=</span> <span>0</span>, newlen <span>=</span> <span>0</span>;
</span></span><span><span>	<span>do</span> {
</span></span><span><span>		<span>/* read at most size bytes */</span>
</span></span><span><span>		<span>if</span>(<span>!</span><span>fgets</span>(buf, size, fd))
</span></span><span><span>		{
</span></span><span><span>			<span>/* read null bytes */</span>
</span></span><span><span>			buf[<span>0</span>] <span>=</span> <span>&#39;\0&#39;</span>;
</span></span><span><span>			<span>return</span> buf;
</span></span><span><span>		}
</span></span><span><span>		newlen <span>=</span> <span>strlen</span>(buf); <span>/* check length of string to be copied */</span>
</span></span><span><span>		<span>if</span> (newlen <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> buf[newlen<span>-</span><span>1</span>] <span>==</span> <span>&#39;\n&#39;</span>) {
</span></span><span><span>			buf[<span>--</span>newlen] <span>=</span> <span>&#39;\0&#39;</span>; <span>/* remove the trailing newline if present */</span>
</span></span><span><span>		}
</span></span><span><span>		<span>if</span> (newlen <span>==</span> size<span>-</span><span>1</span>) { <span>/* we&#39;re not finished */</span>
</span></span><span><span>			size <span>*=</span> <span>2</span>;   <span>/* Double the size    */</span>
</span></span><span><span>		} 		
</span></span><span><span>		input <span>=</span> <span>realloc</span>(input, size);
</span></span><span><span>		<span>if</span> (input <span>==</span> NULL) {
</span></span><span><span>			<span>fprintf</span>(stderr, <span>&#34;realloc error</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>			<span>exit</span>(<span>1</span>);
</span></span><span><span>		}
</span></span><span><span>		<span>memcpy</span>(input <span>+</span> len, buf, newlen<span>+</span><span>1</span>); <span>/* begin to write at byte 0, else */</span>
</span></span><span><span>		len <span>+=</span> newlen;
</span></span><span><span>		size <span>+=</span> newlen;
</span></span><span><span>	} <span>while</span> (buf[newlen] <span>&amp;&amp;</span> buf[newlen<span>-</span><span>1</span>]<span>!=</span><span>&#39;\n&#39;</span> <span>&amp;&amp;</span> buf[newlen<span>-</span><span>1</span>]<span>!=</span>EOF);
</span></span><span><span>	<span>return</span> input;
</span></span><span><span>}
</span></span></code></pre></div><p>Other than that I’m making use of a function written by Michael Kerrisk
to translate a name to a uid.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;dirent.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stdarg.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;sys/stat.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>#include</span> <span>&#34;adio.h&#34;</span><span>
</span></span></span><span><span><span>#include</span> <span>&#34;cscratch_common.h&#34;</span><span>
</span></span></span><span><span><span>#include</span> <span>&#34;ugid_info.h&#34;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span>
</span></span><span><span><span>/* procuall.c: all process being run by a user 
</span></span></span><span><span><span> *
</span></span></span><span><span><span> * usage: procuall &lt;username&gt;
</span></span></span><span><span><span> * */</span>
</span></span><span><span>
</span></span><span><span><span>#define MAXLINE 512
</span></span></span><span><span><span>#define LPID 5
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> <span>s_isdigit</span>(<span>const</span> <span>char</span><span>*</span> s) {
</span></span><span><span>    <span>int</span> result <span>=</span> <span>0</span>;
</span></span><span><span>    <span>while</span> (<span>*</span>s <span>!=</span> <span>&#39;\0&#39;</span>) {
</span></span><span><span>        <span>if</span> ((<span>&#39;0&#39;</span> <span>&lt;=</span> <span>*</span>s) <span>&amp;&amp;</span> (<span>&#39;9&#39;</span> <span>&gt;=</span> <span>*</span>s)) {
</span></span><span><span>            result <span>=</span> <span>1</span>;
</span></span><span><span>        }
</span></span><span><span>        s<span>++</span>;
</span></span><span><span>    }
</span></span><span><span>    <span>return</span> result;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>char</span><span>*</span>
</span></span><span><span><span>make_filename</span>(<span>const</span> <span>char</span><span>*</span> pid) {
</span></span><span><span>    <span>char</span><span>*</span> fname;
</span></span><span><span>    <span>if</span> (<span>s_isdigit</span>(pid)) {
</span></span><span><span>        <span>sprintf</span>(fname, <span>&#34;/proc/%s/status&#34;</span>, pid);
</span></span><span><span>        <span>return</span> fname;
</span></span><span><span>    }
</span></span><span><span>    <span>return</span> NULL;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>int</span>
</span></span><span><span><span>main</span> (<span>int</span> argc, <span>char</span><span>*</span> argv[])
</span></span><span><span>{
</span></span><span><span>    <span>char</span><span>*</span> uname <span>=</span> argv[<span>1</span>];
</span></span><span><span>    <span>uid_t</span> uid <span>=</span> <span>uidFromName</span>(uname);
</span></span><span><span>    <span>printf</span>(<span>&#34;user: %s</span><span>\t</span><span>uid: %d</span><span>\n</span><span>&#34;</span>, uname, uid);
</span></span><span><span>
</span></span><span><span>    DIR<span>*</span> dirp;
</span></span><span><span>    <span>char</span><span>*</span> proc <span>=</span> <span>&#34;/proc&#34;</span>;
</span></span><span><span>    dirp <span>=</span> <span>opendir</span>(proc);
</span></span><span><span>    <span>struct</span> dirent<span>*</span> dp;
</span></span><span><span>    <span>char</span><span>*</span> fname;
</span></span><span><span>    <span>int</span> size <span>=</span> <span>0</span>;
</span></span><span><span>    FILE<span>*</span> fp;
</span></span><span><span>    <span>int</span> fd;
</span></span><span><span>    <span>char</span><span>*</span> lone;
</span></span><span><span>
</span></span><span><span>    <span>struct</span> stat sb;
</span></span><span><span>
</span></span><span><span>    <span>if</span> (dirp) {
</span></span><span><span>        errno <span>=</span> <span>0</span>;
</span></span><span><span>        <span>while</span> ((dp <span>=</span> <span>readdir</span>(dirp)) <span>!=</span> NULL) {
</span></span><span><span>            fname <span>=</span> <span>make_filename</span>(dp<span>-&gt;</span>d_name);
</span></span><span><span>            <span>if</span> (fname) {
</span></span><span><span>                fp <span>=</span> <span>fopen</span>(fname, <span>&#34;r&#34;</span>);
</span></span><span><span>                fd <span>=</span> <span>fileno</span>(fp);
</span></span><span><span>                <span>if</span> (<span>fstat</span>(fd, <span>&amp;</span>sb) <span>==</span> <span>-</span><span>1</span>) {
</span></span><span><span>                    <span>return</span> <span>-</span><span>1</span>; <span>/* just cheese it! */</span>
</span></span><span><span>                }
</span></span><span><span>                <span>if</span> (uid <span>==</span> sb.st_uid) {
</span></span><span><span>                    lone <span>=</span> <span>fgetLine</span>(MAXLINE, fp);
</span></span><span><span>                    <span>printf</span>(<span>&#34;%-24s pid:%-30.30s</span><span>\n</span><span>&#34;</span>, lone, dp<span>-&gt;</span>d_name);
</span></span><span><span>                }
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>        <span>closedir</span>(dirp);
</span></span><span><span>    }
</span></span><span><span>    <span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><h2 id="profiling">Profiling</h2>
<p>Okay, so this section started off as a kind of a joke, I ran both
programs using the <code>time</code> command on Linux. They run so quickly, it’s
a bit hard to determine (but not that hard to guess) which one runs
faster. As mentioned above, there is a huge overhead in running a python
interpreter. As much as I love python the language for it’s simple,
readable syntax and just how accessible that makes it as a programming
language, I do wonder from time to if life would be any different if I
wasn’t lugging a python interpreter everywhere.</p>
<p>The initial output was as follows:</p>
<pre tabindex="0"><code>python3 scripts/procuall.py  0.03s user 0.01s system 97% cpu 0.043 total
</code></pre><pre tabindex="0"><code>./procuall adam  0.00s user 0.01s system 93% cpu 0.009 total
</code></pre><p>I then stumbled across a CLI tool called <a href="https://github.com/sharkdp/hyperfine">hyperfine</a>
that is aimed at benchmarking programs. Using this, and tweaking a few flags, it
was easy to generate some useful information about the two programs.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>proc % hyperfine --warmup<span>=</span><span>100</span> --shell<span>=</span>none <span>&#34;python scripts/procuall.py&#34;</span> <span>&#34;./procuall adam
</span></span></span><span><span><span>Benchmark 1: python scripts/procuall.py
</span></span></span><span><span><span>  Time (mean ± σ):      32.2 ms ±   0.3 ms    [User: 24.3 ms, System: 7.6 ms]
</span></span></span><span><span><span>  Range (min … max):    31.5 ms …  33.2 ms    92 runs
</span></span></span><span><span><span>
</span></span></span><span><span><span>Benchmark 2: ./procuall adam
</span></span></span><span><span><span>  Time (mean ± σ):       2.5 ms ±   0.1 ms    [User: 0.3 ms, System: 2.1 ms]
</span></span></span><span><span><span>  Range (min … max):     2.3 ms …   3.5 ms    989 runs
</span></span></span><span><span><span>
</span></span></span><span><span><span>Summary
</span></span></span><span><span><span>  ./procuall adam ran
</span></span></span><span><span><span>   12.97 ± 0.72 times faster than python scripts/procuall.py
</span></span></span></code></pre></div>

        
          
        

        
            <hr/>
            
        

        
          
            
          

          
                  <h4>See also</h4>
                  <ul>
                
                
                    <li><a href="https://miccah.io/programming/idkoptimization/">Not knowing...python code optimization</a></li>
                
              </ul>

          
        
      </article>

      
        
      


      
        
        
      

    </div>
  </div>
</div></div>
  </body>
</html>
