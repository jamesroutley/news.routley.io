<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://huonw.github.io/blog/2021/09/qr-error-correction/">Original</a>
    <h1>QR error correction helps and hinders scanning (2021)</h1>
    
    <div id="readability-page-1" class="page"><article>
      
        
        
      
      
         
      
      <p>Error correction sounds good. It means fewer errors, right? When it comes to QR codes, that’ll mean easier scanning for people, surely? It seems like that’s not the whole story.</p>

<p>I wondered about this, and couldn’t find an answer, so I did some exploration, and found there’s two factors in tension: the error correction on one hand, and the resulting data density on the other:</p>

<ol>
  <li>For fixed data, like a particular URL, it’s <strong>easier</strong> to read a QR code with <strong>lower</strong> error correction, but only when there’s minimal damage to the code (like reflections and dirt).</li>
  <li>Error correction works as advertised when there’s damage: <strong>higher</strong> error correction means <strong>more</strong> codes can be read.</li>
</ol>

<p>The rest of this article explores what this means.</p>

<h2 id="quick-intro-to-quick-response">Quick intro to quick response</h2>

<p>QR (quick response) codes are now extremely widespread in Australia, because they’re used for COVID contact tracing check-ins and placed in every shop window, but they’re somewhat magic. Before diving into the details, Wikipedia says <a href="https://en.wikipedia.org/wiki/QR_code">a whole lot about QR codes</a>; the summary is: a QR code is a pattern of black and white squares that encodes some data (often a URL), that cameras can read.</p>

<p>The article even has diagrams. Here’s one with a whole lot of detail, highlighting a bunch of key concepts going into a QR code, however there’s two that are most important when considering how easy it is to scan a QR code: <strong>version</strong> and <strong>error correction</strong>.</p>

<figure>
  <p><a href="https://commons.wikimedia.org/wiki/File:QR_Code_Structure_Example_3.svg">
      <img src="https://huonw.github.io/blog/2021/09/qr-error-correction/1024px-QR_Code_Structure_Example_3.svg.png" alt="A graphic containing a QR code, with highlighted areas. These areas are labelled as: 1 version information, 2 format information, 3 data and error correction key, 4 required patterns, 4.1 position, 4.2 alignment, 4.3 timing, 5 quiet zone" width="1024" height="574"/>
    </a>
    
  </p>
  <figcaption><p>A diagram of the functional parts of a QR code. <a href="https://commons.wikimedia.org/wiki/File:QR_Code_Structure_Example_3.svg">source</a></p>
</figcaption>
</figure>

<p>What are these two factors?</p>

<ul>
  <li>
    <p><strong>error correction</strong> (EC): a measure of redundancy in the QR code, translating into how much “damage” it can tolerate and still be readable. This is how images and logos can be directly embedded into QR codes, without any special consideration. This is <strong>chosen</strong> when creating the QR code. The number of modules that can be damaged for each level is:</p>

    <table>
      <thead>
        <tr>
          <th>EC</th>
          <th>max damage</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>L (low)</td>
          <td>7%</td>
        </tr>
        <tr>
          <td>M (medium)</td>
          <td>15%</td>
        </tr>
        <tr>
          <td>Q (quartile)</td>
          <td>25%</td>
        </tr>
        <tr>
          <td>H (high)</td>
          <td>30%</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p><strong>version</strong>: the number of little squares (modules) along each side of the big square. This is normally <strong>computed</strong> automatically when creating the QR code (from the data and error correction).</p>

    <table>
      <thead>
        <tr>
          <th>version</th>
          <th>modules</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>1</td>
          <td>21</td>
        </tr>
        <tr>
          <td>2</td>
          <td>25</td>
        </tr>
        <tr>
          <td>…</td>
          <td>…</td>
        </tr>
        <tr>
          <td><em>n</em></td>
          <td>4<em>n</em> + 17</td>
        </tr>
        <tr>
          <td>…</td>
          <td>…</td>
        </tr>
        <tr>
          <td>39</td>
          <td>173</td>
        </tr>
        <tr>
          <td>40</td>
          <td>177</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<figure>
  <p><a href="https://huonw.github.io/blog/2021/09/qr-error-correction/v1-v18-v40.png">
      <img src="https://huonw.github.io/blog/2021/09/qr-error-correction/v1-v18-v40.png" alt="An image showing three QR codes placed horizontally, the left most one consists of only a very large modules, while they&#39;re barely distinguishable in the right most one." width="1110" height="378"/>
    </a>
    
  </p>
  <figcaption><p>Three QR codes, using versions 1, 18 and 40 (from left to right).</p>
</figcaption>
</figure>

<p>Together, the version and error correction dictate how much data a given QR code can store<sup id="fnref:modes" role="doc-noteref"><a href="#fn:modes" rel="footnote">0</a></sup>:</p>

<figure>
  <div>
    
  </div>
  <figcaption><p>The number of bytes a QR code can store, at each version and EC level. (This can be read horizontally too: for a given number of bytes, what version is required?)</p>
</figcaption>
</figure>

<p>(The plots in this article are interactive: hover/tap for more info, tap or double tap the legend to toggle series’ visibility, tap-and-drag to zoom, and hit the ‘home’ icon to reset.)</p>

<p>That plot indicates a QR code using EC level H can store <strong>less than half</strong> the data of one using level L: the closest they get is at version 3 (53 vs. 24 bytes). The other levels have less overhead, but it’s still a cost that’s paid:</p>

<table>
  <thead>
    <tr>
      <th>EC</th>
      <th>max bytes (version 40)</th>
      <th>storage relative to L (mean)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>L</td>
      <td>2953</td>
      <td>100%</td>
    </tr>
    <tr>
      <td>M</td>
      <td>2331</td>
      <td>79%</td>
    </tr>
    <tr>
      <td>Q</td>
      <td>1663</td>
      <td>57%</td>
    </tr>
    <tr>
      <td>H</td>
      <td>1273</td>
      <td>43%</td>
    </tr>
  </tbody>
</table>

<p>That’s some hefty overhead: presumably it is useful for something… I did some experiments.</p>

<h2 id="experiments">Experiments</h2>

<p>I set up a little Rust program that ran <a href="http://zbar.sourceforge.net/">ZBar</a> against an exhaustive set of different QR configurations: all 40 versions and all 4 EC levels. For each of these 160 configurations:</p>

<ol>
  <li>scale the QR code to given size</li>
  <li>place it into a <a href="https://www.flickr.com/photos/_mia/5612839179">background image</a>, to simulate “real world” conditions</li>
  <li>pass the resulting image into ZBar and check if it scans successfully</li>
  <li>repeat at different sizes to find the smallest size at which the QR code scans successfully, or determine that it couldn’t be scanned at any size</li>
</ol>

<figure>
  <p><a href="https://huonw.github.io/blog/2021/09/qr-error-correction/qr-example-7-h-full.png">
      <img src="https://huonw.github.io/blog/2021/09/qr-error-correction/qr-example-7-h-800.jpg" alt="An photo of a shopfront window with some text and reflection of the person. There is a large obviously-CGI QR code overlaid on part of the shopfront." width="800" height="400"/>
    </a>
    
  </p>
  <figcaption><p>An excerpt of an example of the generated image: the code is EC level H and version 7, and has been scaled to 700 pixels on each size. Tap for full size.</p>
</figcaption>
</figure>

<h2 id="error-correction-makes-scanning-more-reliable">Error correction makes scanning more reliable</h2>

<p>Error correction sounds useful for scanning: if the QR code is further away or smaller, then there’s more likely to be blurriness or other “damage”, and so higher error-correction will make it easier to read… right?</p>

<p>A camera generally doesn’t care about the actual distance, as it just “thinks” in the pixels it sees. Thus, it’s the size of the QR code within the overall image that matters. I call this the <em>field of view</em>. Example, for the full sized version of Figure 4:</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>size (px)</th>
      <th>total (px)</th>
      <th>field of view</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>full image</td>
      <td>2592 × 1944</td>
      <td>5.04m</td>
      <td>100%</td>
    </tr>
    <tr>
      <td>QR code</td>
      <td>700 × 700</td>
      <td>0.49m</td>
      <td>9.7%</td>
    </tr>
  </tbody>
</table>

<p>Under the reasonable assumption that the camera is close to <a href="https://en.wikipedia.org/wiki/Rectilinear_lens">rectilinear</a>, this gives a measure of how close the user has to be that scales smoothly with the physical size of the QR code: if the device can read a 10cm QR code from 1m away, it’ll be able to read a 1m code from 10m. Similarly, fields of view can be used to predict distance: given two codes, where the first needs 4% field of view and the second only needs 1%, the second can likely be scanned from about twice as far<sup id="fnref:quadratic" role="doc-noteref"><a href="#fn:quadratic" rel="footnote">1</a></sup>.</p>

<p>Error correction definitely allows scanning a given QR code from further away. At version 40, a level H QR code only requires 1.7% field of view, while a level L one requires 2.4%.</p>

<figure>
  <div>
    
  </div>
  <figcaption><p>The field of view required to scan a QR code of a given version, at each EC level (lower is better).</p>
</figcaption>
</figure>

<p>This seems to all come back to the size of the individual modules (the small squares that make up the overall QR code):</p>

<figure>
  <div>
    
  </div>
  <figcaption><p>The field of view of an individual module required to scan a QR code of a given version, at each EC level (lower is better).</p>
</figcaption>
</figure>

<p>The lines of best fit look pretty flat, and quantitative measures like the parameter confidence intervals agree (except for level L, the 95% confidence intervals on the slope coefficient include 0). In other words: a QR code is scannable if its modules are sufficiently large, and that size threshold doesn’t change much as the version changes.</p>

<p>On the other hand, the size threshold <em>does</em> change with EC level: level L modules need to be 25-35% larger than level H ones, matching the intuition about the benefits of higher error correction.</p>

<p>Cool, hypothesis confirmed: error correction makes scanning more reliable…</p>

<h2 id="error-correction-makes-scanning-less-reliable">Error correction makes scanning less reliable</h2>

<p>Not so fast! When creating a QR code, versions and module sizes usually don’t matter, it’s the data that matters: one will usually choose the data and error correction, and then have the version computed automatically, as the smallest that works.</p>

<p>The overhead of higher error correction matters a lot.</p>

<figure>
  <p><a href="https://huonw.github.io/blog/2021/09/qr-error-correction/v3l-v6h.png">
      <img src="https://huonw.github.io/blog/2021/09/qr-error-correction/v3l-v6h.png" alt="" width="716" height="364"/>
    </a>
    
  </p>
  <figcaption><p>This post’s URL encoded at EC level L (left) and EC level H. At level L, the data fits in a version 3 code, while level H requires version 6, resulting in smaller modules (half the area/field of view).</p>
</figcaption>
</figure>

<p>If we change from looking at the version to the actual data stored, the ordering reverses, and EC level L works best!</p>

<figure>
  <div>
    
  </div>
  <figcaption><p>The field of view required to scan a QR code containing a given amount of data, at each EC level (lower is better).</p>
</figcaption>
</figure>

<p>If one is trying to “send” 1000 bytes via QR code, using level H requires a field of view of 1.4%, while level L only needs half that (approximately), at 0.8%. This means a device can be further away and still read the L code successfully.</p>

<p>This doesn’t seem to match the results in Figures 5 and 6. What’s going on? The level L code uses version 22 with 105<sup>2</sup> ≈ 11k modules, while level H requires version 36 with 161<sup>2</sup> ≈ 26k modules. This ratio (2.35) is much larger than the ratio between the module sizes (~1.3), so, sure, level H allows the individual modules to be smaller, but it requires using so many more that the overall QR code is larger than the level L ones<sup id="fnref:consistency" role="doc-noteref"><a href="#fn:consistency" rel="footnote">2</a></sup>.</p>

<p>This seems to apply consistently across versions, as might be expected from Figure 3: a QR code at level L can store twice as much data as one at level H, for the same version. The data storage overhead of error correction doesn’t seem be worth the apparently dubious benefits.</p>

<p>Nice. <em>This</em> hypothesis—error correction makes scanning less reliable—is correct, right?</p>

<h2 id="error-correction-really-does-make-scanning-more-reliable">Error correction really does make scanning more reliable</h2>

<p>There is more to the story. Those measures had no noise introduced to the QR codes. They’re the easy cases. What happens if we turn up the noise?</p>

<p>I generated 10 different noise patterns, and thresholded them at 8 different levels, and overlaid this noise across each of the QR codes, for a total of 160 × 80 = 12800 configurations. This is meant to simulate reflections and dirt that could make it harder for a device to read the code.</p>

<figure>
  <p><a href="https://huonw.github.io/blog/2021/09/qr-error-correction/qr-example-7-h-noise-together.jpg">
      <img src="https://huonw.github.io/blog/2021/09/qr-error-correction/qr-example-7-h-noise-together.jpg" alt="Three QR codes overlaid; from left to right: 1, the QR code displayed in Figure 4; 2, the same QR code with some white and black regions of damage; 3, the same QR code with larger and more regions of damage." width="800" height="286"/>
    </a>
    
  </p>
  <figcaption><p>Three levels of damage to the example QR code in Figure 4: no damage (<a href="https://huonw.github.io/blog/2021/09/qr-error-correction/qr-example-7-h-full.png">full</a>), some regions of white and black noise (<a href="https://huonw.github.io/blog/2021/09/qr-error-correction/qr-example-7-h-noise-less-full.png">full</a>), even more and larger regions of noise (<a href="https://huonw.github.io/blog/2021/09/qr-error-correction/qr-example-7-h-noise-full.png">full</a>).</p>
</figcaption>
</figure>

<p>Across all of these experiments, <strong>60% more</strong> EC level H QR codes could be scanned successfully than level L ones:</p>

<table>
  <thead>
    <tr>
      <th>EC</th>
      <th>number successfully scanned</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>L</td>
      <td>1257</td>
    </tr>
    <tr>
      <td>M</td>
      <td>1600</td>
    </tr>
    <tr>
      <td>Q</td>
      <td>1839</td>
    </tr>
    <tr>
      <td>H</td>
      <td>2001</td>
    </tr>
  </tbody>
</table>

<p>This is driven by resilience to damage: the QR code at level H is more likely to be able to be read when there’s significant damage. The following plot has a point for each successful scan, against the percentage of pixels damaged.</p>

<figure>
  <div>
    
  </div>
  <figcaption><p>The amount of damage sustained by successfully scanned QR codes. The hover information displays the number of points to the left of the line (number of successful scans up to and including that amount of damage).</p>
</figcaption>
</figure>

<p>Under these experimental conditions, level L codes become much less readable above ~6% damage, level M above ~12%, level Q above ~18% and level H above ~20%. This correlates with the resilience I quoted in the table above.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I’ve learnt that the four different QR error correction levels influence both <strong>data volume</strong> and <strong>ability to scan</strong>. For a given QR version, increasing error correction allows storing less data, but makes scanning easier and more reliable. However, for storing a fixed amount of data, like a particular URL, the version is computed automatically, and the easier scanning can <strong>trade off</strong> against the data volume. This ties back to the size of the individual modules (little squares): there is a minimum certain size before a code is scannable, and so a denser code needs to be larger.</p>

<h2 id="experimental-caveats">Experimental caveats</h2>

<p>The results I’ve talked about here are all empirical, and there’s a bunch of reasons that they’re not perfect:</p>

<ol>
  <li>I tested only one method of reading QR codes, <a href="http://zbar.sourceforge.net/">ZBar</a>, although some quick experiments with my iPhone seem to correlate with the results here.</li>
  <li>I also tested only one background image, so the behaviour may differ greatly with QR codes contained in different surrounds.</li>
  <li>The QR codes are generated to be perfectly rectangular and aligned to the image pixel grid, which is unlikely to happen in the real world.</li>
  <li>The noise generated is random Perlin noise, which isn’t likely to be what occurs in the real world.</li>
  <li>The overlaying of the noise carefully skips damaging the position patterns (the big squares in three corners), because the performance is catastrophically worse if they can be damaged too.</li>
</ol>

<section id="external-links">
  
  
</section>





    </article></div>
  </body>
</html>
