<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lukasz.langa.pl/f37aa97a-9ea3-4aeb-b6a0-9daeea5a7505/">Original</a>
    <h1>A possible future of Python in the browser</h1>
    
    <div id="readability-page-1" class="page"><article>
  
<p>
<svg fill="currentColor" height="20" stroke="none" viewBox="0 0 141 146" width="20" xmlns="http://www.w3.org/2000/svg">
<g>
<path d="M13.3,126.4V37.4c0-2.4,.9-4.5,2.6-6.3c1.7-1.8,3.8-2.6
    6.2-2.6h8.8v-6.7c0-3.1,1.1-5.7,3.2-7.9c2.2-2.2,4.7-3.3,7.8-3.3h4.4c3,0
    5.6,1.1,7.8,3.3c2.2,2.2,3.2,4.8,3.2,7.9v6.7h26.4v-6.7c0-3.1,1.1-5.7
    3.2-7.9c2.2-2.2,4.7-3.3,7.8-3.3h4.4c3,0,5.6,1.1,7.8,3.3c2.2,2.2,3.2
    4.8,3.2,7.9v6.7h8.8c2.4,0,4.4,.9,6.2,2.6c1.7,1.8,2.6,3.8,2.6,6.3v88.9c0
    2.4-.9,4.5-2.6,6.3c-1.7,1.8-3.8,2.6-6.2,2.6H22.1c-2.4,0-4.4-.9-6.2-2.6C14.2,130.8
    13.3,128.8,13.3,126.4z M22.1,126.4h96.8V55.2H22.1V126.4z M39.7,41.9c0,.6,.2,1.2
    .6,1.6c.4,.4,.9,.6,1.6,.6h4.4c.6,0,1.2-.2,1.6-.6c.4-.4
    .6-.9,.6-1.6v-20c0-.6-.2-1.2-.6-1.6c-.4-.4-.9-.6-1.6-.6h-4.4c-.6,0-1.2,.2-1.6
    .6c-.4,.4-.6,1-.6,1.6V41.9z
    M92.5,41.9c0,.6,.2,1.2,.6,1.6c.4,.4,.9,.6
    1.6,.6h4.4c.6,0,1.2-.2,1.6-.6c.4-.4
    .6-.9,.6-1.6v-20c0-.6-.2-1.2-.6-1.6c-.4-.4-.9-.6-1.6-.6h-4.4c-.6
    0-1.2,.2-1.6,.6c-.4,.4-.6,1-.6,1.6V41.9z"></path>
</g>
</svg>
<time datetime="2025-02-24 20:00:00+01:00">Monday, 24 February 2025 20:00</time>
</p>

<p>My Python code was too slow, so I made it faster with Python. For some definition of ‚ÄúPython‚Äù.</p>
<p><img alt="" src="https://lukasz.langa.pl/f37aa97a-9ea3-4aeb-b6a0-9daeea5a7505/assets/IMG_9542_80.jpg"/></p>
<p>I spent last week in the gorgeous Aosta Valley with Antonio Cuni from Anaconda (middle) and Hood Chatham from Cloudflare (left). I was the only one without a Ph.D. degree, but they were both kind enough to act as if they didn‚Äôt notice. We managed to get <a href="https://github.com/spylang/spy">SPy</a> to run in the Web browser, unbreak Pyodide on iOS, as well as make a SPy-accelerated demo with Pyodide. But let‚Äôs start at the beginning.</p>
<h2 id="looking-back">Looking back</h2>
<p>Eleven years ago Gary Bernhardt gave an influential talk at PyCon US called <a href="https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript">The Birth &amp; Death of JavaScript</a>. The Web platform is shaping up to be just as powerful as Gary‚Äôs vision in 2014. WebAssembly exceptions and garbage collection are generally available, <a href="https://v8.dev/blog/jspi">JavaScript Promise Integration</a> is close as well. I feel like we‚Äôre on the verge of true programming language democracy on the Web.</p>
<p>In 2019 I gave <a href="https://www.youtube.com/watch?v=fOdCxum-qLA">a keynote</a> at PyConDE and PyLondinium I called ‚ÄúPython 2020+‚Äù where I shared my ideas about where I think Python as a language should be going. Of course 2020 ended up quite different üòÖ The main premise of the talk was that ‚Äúyou should contribute to Python by inventing a new kind of Python‚Äù. I argued that it‚Äôs not only okay for new Python-like languages to appear, but it‚Äôs in fact necessary to sensibly compete on mobile and on the Web. I gave MicroPython as an example of a ‚ÄúPython-like enough‚Äù variant of the language that lets Python developers succeed in programming microcontrollers. MicroPython is great because despite a large set of documented differences with CPython, Python developers can successfully leverage their existing knowledge in an entirely new environment. Better yet, for some people MicroPython is their first experience writing Python altogether!</p>
<p>I argued something similar is necessary for the Web. At the time, <a href="https://pyodide.org/">Pyodide</a> was the new kid on the block. It‚Äôs a port of CPython running on WebAssembly. It uses Emscripten as its compiler toolchain, which provides a compatibility layer between the browser and POSIX APIs that CPython calls internally. That port includes a number of the most popular scientific libraries, allowing Python users to be immediately productive.</p>
<p>I dismissed Pyodide in my talk as producing a necessarily subpar experience in terms of performance compared to JavaScript. After all, with Pyodide you are running CPython on top of WebAssembly‚Äôs stack-based VM. So a stack-based VM on top of a stack-based VM. You can never match JavaScript‚Äôs performance that way. I wanted a Python compiler for the Web, something that is ‚ÄúPython-like enough‚Äù, but compiles user code directly to run on the WebAssembly VM.</p>
<h2 id="python-2025">Python 2025+</h2>
<p>This January I put a lot of effort evaluating both Pyodide and MicroPython as packaged by PyScript <a href="https://lukasz.langa.pl/62eae3e6-a598-4a1e-8f65-586d16e1bd0f/">in the context of generative art</a>. This is a good benchmark of how useful those runtimes are since effective animation needs to run at the refresh rate of your display, which in my case is 60Hz for the external monitor and 120Hz for my Macbook and iPhone. 120Hz also allows for more convincing audio/video synchronization when you‚Äôre doing realtime audio visualization. But 120Hz means you only get 8.33 milliseconds for calculations between frames. Neither Pyodide nor MicroPython is fast enough for comfort in that kind of use case, so you need to be creative with pre-computing things or moving things to compute on the GPU instead. Or to give up on native rendering in 4K.</p>
<p>In all fairness, it‚Äôs incredible that Pyodide lets you use Numpy in the browser on a ‚Äúreal‚Äù CPython interpreter that works just like you expect. It works surprisingly well. And Pyodide is itself increasingly leveraging the advanced features of the WebAssembly VM, with wasm-gc introduced not long ago and wasm-eh coming very soon. All this promises better performance and even smoother support of regular Python programs with no changes. The Pyodide project upstreams a lot to CPython to ensure it runs well on Emscripten, with the platform official Tier 3 support <a href="https://github.com/python/steering-council/issues/256">restored</a> for Python 3.14.</p>
<p>MicroPython also seems like a good compromise between code size you need to download before running anything and capability. YMMV on how Pythonic it feels for you in practice, I mentioned some surprises in my Genuary article. But for smaller programs it‚Äôs clearly capable and downloads near-instantly.</p>
<p>And yet, I don‚Äôt think I was wrong in 2019. I hit the performance wall during my Genuary journey many times, and I felt like the things I wanted to achieve shouldn‚Äôt be too much to ask. Some had to do with the Python ‚ÜîÔ∏é JavaScript FFI speed, or with the proliferation of network requests to load everything you need, but most problems were clearly ‚ÄúI wish I could crunch those numbers faster‚Äù.</p>
<h2 id="enter-spy">Enter SPy</h2>
<p>Let‚Äôs get one thing out of the way. <a href="https://github.com/spylang/spy">SPy</a> is a research project in its early stages at the moment. You should not attempt to use it yet, unless you plan to contribute to it, and even then you have to come with the right mindset. This software is incomplete both implementation-wise and design-wise. I‚Äôm writing this article mostly to be able to point at it in 2035 and say ‚ÄúI was there‚Äù. And to point at my 2019 talks and say ‚Äúlook, I wasn‚Äôt so wrong after all!‚Äù. </p>
<p>With all this in mind, SPy looks very attractive to me already. It‚Äôs a language designed to be friendly to Python users, but is not attempting to be Python-compatible. It can‚Äôt be, because with SPy, user code can be fully compiled to native binaries or WebAssembly.</p>
<h2 id="roses-are-red-violets-are-blue">Roses are red, violets are <code>@blue</code></h2>
<p>The big idea of it is that you have Python-like source code files that mix code executing at compile-time with code executing at runtime. The former is called blue code and the latter red code. Unlike C macros, blue code is fully interpreted and can do a lot. Unlike C++ templates, blue code looks mostly like your regular Python code.</p>
<p>If you ever thought ‚Äúwouldn‚Äôt it be cool if this module-level computation could be pre-compiled?‚Äù then blue code is just that. You can have ‚Äúcompile-time decorators‚Äù, ‚Äúcompile-time type dispatch‚Äù, ‚Äúcompile-time code generation‚Äù, and so on. This moves us a bit closer to the ‚Äúzero-cost abstractions‚Äù world of Rust.</p>
<p>SPy code can be executed in a fully interpreted mode where even blue code is interpreted on the fly as it would in Python. This is where you can debug things when you‚Äôre still experimenting with a script. Then, with a process called ‚Äúred-shifting‚Äù you pre-compute all that‚Äôs blue. You can view the red-shifted code, seeing what its code generation produced. You can still interpret red-shifted programs to debug them.</p>
<p>Finally, you can compile red-shifted code to C. That allows it to produce a native binary or WebAssembly bytecode. The C code is also a pretty informative read if you want to know how a high-level Python-style construct translates to the resulting native computation. Most importantly, the C code generation is how SPy manages to immediately integrate with existing systems using pre-existing C FFI. This is an explicit goal of the project. That‚Äôs how we were able to make my generative art demo work.</p>
<h2 id="marching-squares">Marching squares</h2>
<p>For the first end-user project in SPy, I decided to convert an existing Genuary entry I made with PyScript that <a href="https://ambv.pyscriptapps.com/genuary-prompt-28-30/latest/">draws an endless abstract topographic map</a>. The map is computed by taking three octaves of Perlin noise, and using the marching squares algorithm on it to draw contours of a few ‚Äúelevation levels‚Äù.</p>
<p>This computation was too much for pure Python in either Pyodide or MicroPython to happen inside the animation loop, so in the original project I pre-computed the map area in a Web worker. That still meant you had to wait several seconds for it to complete, but thanks to the Web worker it all appeared incrementally. And as soon as the pre-computation was done, the rest of the animation can easily hit 120 FPS on my Mac and 60 FPS on my phone. Could be worse.</p>
<p>The <a href="https://ambv.pyscriptapps.com/marching-squares-with-spy/latest/">SPy version of the project</a> ditches the Web worker as the computation is over 100X faster. You‚Äôre literally waiting longer for the background audio file to load. The result looks exactly the same, which was an important metric for us. It‚Äôs still a Pyodide program, only now it‚Äôs importing a wheel built with <code>setuptools</code> and <code>cffi</code> to do all the perlins and march all the squares. All those calls look like normal Python function calls on the Python side.</p>
<p>Look below, your browser is running SPy-powered code right now!</p>

<p>You can clone the PyScript.com project and play with it yourself. By setting <code>USE_SPY</code> to <code>False</code> in <code>main.py</code> you‚Äôre back to the pure Python version. Now pre-computing is counted in seconds! You can see this in action without having to edit anything by <a href="https://ambv.pyscriptapps.com/marching-squares-with-spy/v1/">running v1</a> of the same project.</p>
<p>The code that ends up being <code>perlin-0.0.0-cp312-cp312-pyodide_2024_0_wasm32.whl</code> lives <a href="https://github.com/ambv/spy-examples/blob/main/perlin/perlin.spy">here</a>, you can find the <code>marching_squares</code> function and see how you feel about the code. In my opinion it‚Äôs already serviceable, but in the future it will likely look even more friendly when we get advanced features like for-loops and accessing struct array items by value.</p>
<h2 id="bring-your-own-wings">Bring your own wings</h2>
<p>Again, the SPy project is in early stages, so working on my demo I had to <a href="https://github.com/spylang/spy/pull/123">add bitwise operator support</a> to the SPy compiler, and to include an array implementation in my user script. I made silly mistakes converting my Python for-loops to while-loops. It really felt like I needed to bring my own wings to fly. But I‚Äôm fully aware that this is to be expected at this point. In fact, if I‚Äôm not mistaken, my demo might be actually the first non-trivial demo of the language in existence. Kind of a nice milestone for a workation week in the Alps! </p>
<p>The workflow shows a lot of promise thanks to the ability to run interpreted code and to compile your code to a native Mac or Linux program. That allowed me to iterate on it without involving the Web browser until I knew the numbers produced are alright.</p>
<p>In the end, everything connected just enough to execute in the PyScript environment and I‚Äôm very happy about that. The performance proves this sort of thing has real value.</p>
<h2 id="why-not-cython-then">Why not Cython then?</h2>
<p>Nothing wrong with using Cython today! But remember our dream: at some point it might just be possible to skip CPython in the Web browser entirely. Only your end-user Python-like code remains. Running natively on WebAssembly with speed in the same order of magnitude as Rust.</p>
<p>We‚Äôre not close to this point and if we‚Äôre frank I‚Äôm somewhat concerned this project is currently being bootstrapped by just one person at Anaconda. However, I‚Äôm hopeful that with enough value demonstrated, the company will invest more resources in this moonshot project. The 2019 me would 100% approve.</p>

<p>

  <a href="https://lukasz.langa.pl/programming/">#Programming</a>

  <a href="https://lukasz.langa.pl/python/">#Python</a>

</p>
</article></div>
  </body>
</html>
