<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fil-c.org/pizlix">Original</a>
    <h1>Pizlix: Memory Safe Linux from Scratch</h1>
    
    <div id="readability-page-1" class="page"><div>
        
        <main>


<p><a href="https://fil-c.org/cropped37.png">
   <img src="https://fil-c.org/cropped37.png" alt="Weston desktop and GTK 4 built with Fil-C"/>
</a></p>

<p>Pizlix is <a href="https://www.linuxfromscratch.org/lfs/view/12.2/">LFS (Linux From Scratch) 12.2</a> with some added components, where userland is compiled with Fil-C. This means you get the most memory safe Linux-like OS currently available.</p>

<p>Caveats:</p>

<ul>
<li><p>The kernel is compiled with Yolo-C. So that you can compile the kernel, a copy of GCC is installed in <code>/yolo/bin/gcc</code>.</p></li>
<li><p>The <a href="https://fil-c.org/compiler.html">C/C++ compiler</a> is compiled with Yolo-C++. Some more information about that:</p>

<ul>
<li><p>It&#39;s likely that a production memory safe OS would still let you run unsafe programs in cases where the security/performance trade-off was warranted. The compiler might be a good example of that.</p></li>
<li><p>I haven&#39;t yet ported LLVM to Fil-C++, and so long as I haven&#39;t, the compiler will have to be Yolo-C++.</p></li>
<li><p>The compiler is called <code>/usr/bin/clang-20</code> but there are many symlinks to it (<code>gcc</code>, <code>g++</code>, <code>cc</code>, <code>c++</code>, <code>clang</code>, and <code>clang++</code> all point at <code>clang-20</code>).</p></li>
<li><p>All of the other building-related tools (like <code>ld</code>, <code>make</code>, <code>ninja</code>, etc) are compiled with Fil-C (or Fil-C++).</p></li>
</ul></li>
</ul>

<p>Pizlix is possible because Fil-C is so compatible with C and C++ that many packages in LFS need no changes, and the rest of them mostly just require small changes. That said, it&#39;s not as simple as just replacing LFS&#39;s compiler with the Fil-C compiler because:</p>

<ul>
<li><p>The Fil-C compiler isn&#39;t set up to do the cross-compilation hacks that LFS uses in Chapters 5-7. Therefore, Pizlix uses the Yolo-C toolchain and vanilla versions of the temporary cross-tools in those chapters.</p></li>
<li><p>We need to retain the Yolo GCC for compiling the Linux kernel.</p></li>
</ul>

<p>This document starts with a description of how to install and build Pizlix. <a href="#details">At the end of this document</a>, I explain exactly how Fil-C is injected into LFS.</p>

<h2>Supported Systems</h2>

<p>Pizlix has been tested inside VMware and Hyper-V on X86_64.</p>

<p>I have confirmed that it&#39;s possible to build Pizlix on Ubuntu 24.</p>

<h2>Installing Pizlix</h2>

<p>First, clone the <a href="https://github.com/pizlonator/fil-c/">Fil-C GH repo</a>:</p>

<pre><code>git clone https://github.com/pizlonator/fil-c.git
</code></pre>

<p>Then go into the <a href="https://github.com/pizlonator/fil-c/tree/deluge/pizlix"><code>pizlix</code> directory</a> under <code>fil-c</code>.</p>

<p>Pizlix requires you to set up your machine thusly:</p>

<ul>
<li><p>You must have a <code>/mnt/lfs</code> partition mounted at /dev/sda4. If you have it mounted somewhere else, then make sure you edit the various scripts in this directory (and its subdirectories).</p></li>
<li><p>You must have a swap partition at <code>/dev/sda3</code>. If you have one somewhere else (or don&#39;t have one), then make sure you edit the various scripts in this directory (and its subdirectories).</p></li>
<li><p>You must have an <code>lfs</code> user as described in sections 4.3 and 4.4 of the <a href="https://www.linuxfromscratch.org/lfs/view/12.2/">LFS book</a>.</p></li>
</ul>

<p>Once you have satisfied those requirements, <strong>and you&#39;re happy with the contents of <code>/mnt/lfs</code> being annihilated</strong>, just do:</p>

<pre><code>sudo ./build.sh
</code></pre>

<p>From <code>fil-c/pizlix</code>. Then, edit your grub config to include the <code>menuentry</code> in <code>etc/grub_custom</code> and reboot into Pizlix!</p>

<p>If you run into trouble, see the <a href="#stages">Build Stages</a>.</p>

<h2>Using Pizlix</h2>

<p>Pizlix by default has the following configuration:</p>

<ul>
<li><p><code>sshd</code> is running. It&#39;s a memory safe OpenSSH daemon!</p></li>
<li><p><code>seatd</code> is running.</p></li>
<li><p>There is a <code>root</code> user with password <code>root</code>.</p></li>
<li><p>There is a user called <code>pizlo</code> with password <code>pizlo</code>. This user is a sudoer.</p></li>
<li><p><code>dhcpcd</code> is set to connect you via DHCP on <code>eth0</code>, which is assumed to be ethernet, not wifi.</p></li>
</ul>

<p>Please change the passwords, or better yet, replace the <code>pizlo</code> user with some other user, if your Pizlix install will face the network!</p>

<p>Once you get your internet to work (it will &#34;just work&#34; if <code>eth0</code> is DHCP capable), you&#39;ll need to run:</p>

<pre><code>make-ca -g
</code></pre>

<p>As <code>root</code>. Without this, <code>curl</code> and <code>wget</code> will have problems with HTTPS.</p>

<p>To see what this thing is really capable of, log in as a non-root user (like <code>pizlo</code>) and do:</p>

<pre><code>weston
</code></pre>

<p>And enjoy a totally memory safe GUI!</p>



<h2>Build Stages</h2>

<p>The Pizlix build proceeds in the following stages.</p>

<p>The Pizlix build snapshots after each successful stage so that it&#39;s possible to restart the build at that stage later. This is great for troubleshooting!</p>

<h3>Pre-LC</h3>

<p>This is the bootstrapping phase that uses a Yolo-C GCC to build a Yolo-C toolchain within the <code>/mnt/lfs</code> chroot environment.</p>

<p>If you want to just do this stage of the build and nothing more, do <code>sudo ./build_prelc.sh</code>.</p>

<p>If you want to start the build here, do <code>sudo ./build.sh</code>.</p>

<h3>LC</h3>

<p>This is the phase where the chroot environment is pizlonated with a Fil-C compiler. This builds the Fil-C compiler and slams it into <code>/mnt/lfs</code>.</p>

<p>If you want to just do this stage of the build and nothing more, do <code>sudo ./build_lc.sh</code>.</p>

<p>If you want to start the build here, do <code>sudo ./build_with_recovered_prelc.sh</code>.</p>

<p>The <a href="#details">Injecting Fil-C Into LFS</a> section describes the LC phase, and its relationship to Pre-LC and Post-LC.</p>

<h3>Post-LC</h3>

<p>This is the actual Linux From Scratch build (Chapters 8, 9, 10 of the LFS book) using the Fil-C toolchain. After this completes, the Yolo-C stuff produced in Pre-LC is mostly eliminated, except for what is necessary to run the Fil-C compiler and the GCC used for building the kernel.</p>

<p>If you want to just do this stage of the build and nothing more, do <code>sudo ./build_postlc.sh</code>.</p>

<p>If you want to start the build here, do <code>sudo ./build_with_recovered_lc.sh</code>.</p>

<h3>Post-LC 2</h3>

<p>This builds BLFS (Beyond Linux From Scratch) components that I like to have, such as openssh, emacs, dhcpcd, and cmake.</p>

<p>If you want to just do this stage of the build and nothing more, do <code>sudo ./build_postlc2.sh</code>.</p>

<p>If you want to start the build here, do <code>sudo ./build_with_recovered_postlc.sh</code>.</p>

<h3>Post-LC 3</h3>

<p>This builds the Wayland environment and Weston so that you can have a GUI.</p>

<p>If you want to just do this stage of the build and nothing more, do <code>sudo ./build_postlc3.sh</code>.</p>

<p>If you want to start the build here, do <code>sudo ./build_with_recovered_postlc2.sh</code>.</p>

<h3>Post-LC 4</h3>

<p>This builds GTK 4.</p>

<p>If you want to just do this stage of the build and nothing more, do <code>sudo ./build_postlc4.sh</code>.</p>

<p>If you want to start the build here, do <code>sudo ./build_with_recovered_postlc3.sh</code>.</p>

<h3>Other Tricks</h3>

<p>You can mount the chroot&#39;s virtual filesystems with <code>sudo ./build_mount.sh</code>. You can unmount the chroot&#39;s virtual filesystems with <code>sudo ./build_unmount.sh</code>.</p>

<p>You can hop into the chroot with <code>sudo ./enter_chroot.sh</code>. However, if you&#39;re past Post-LC, then you&#39;ll need to do <code>sudo ./enter_chroot_late.sh</code> instead.</p>

<p>If you want to just rebuild <code>libpizlo.so</code> runtime and slam it into the chroot, do <code>sudo ./rebuild_pas.sh</code>.</p>

<p>If you want to just rebuild the compiler, <code>libpizlo.so</code>, and user glibc, do <code>sudo ./rebuild_lc.sh</code>.</p>



<h2>Injecting Fil-C Into LFS</h2>

<p>My process for building Pizlix started with writing shell scripts to automate the LFS build. This mostly involved copy-pasting the shell commands from the LFS book after manually validating that they worked for me.</p>

<p>Then, I studied the build process to identify the best injection point for Fil-C. That is, where to either compile or binary-drop the Fil-C compiler and have all subsequent build steps use that compiler. After some trial and error, I found that the second glibc build step (<a href="https://www.linuxfromscratch.org/lfs/view/12.2/chapter08/glibc.html">the one at start of Chapter 8</a>) is the perfect point to transition from Yolo-C to Fil-C:</p>

<ul>
<li><p>At this point, we are no longer building temporary cross versions of libraries in tools. We&#39;re building the final versions.</p></li>
<li><p>We have built good-enough versions of libraries and tools to support running <a href="https://fil-c.org/compiler.html">the Fil-C compiler</a>. Note that in preparation for this, I had already adjusted the clang build so that the binary has minimal dependencies and happens to dynamically link to a glibc with the same ABI version as LFS&#39;s glibc (version 2.40). It&#39;s great that glibc ABI is so stable these days that this is possible!</p></li>
</ul>

<p>This is why the build stages have the names that they have:</p>

<ul>
<li><p>Pre-LC: this is the &#34;pre libc&#34; part of the build, i.e. Chapters 5-7.</p></li>
<li><p>LC: this is the part of the build where LFS would have normally build the final (not cross) version of glibc, i.e. <a href="https://www.linuxfromscratch.org/lfs/view/12.2/chapter08/glibc.html">section 8.5</a>.</p></li>
<li><p>Post-LC: this is all of the LFS build that happens after the final glibc step, i.e. everything after section 8.5. However, I also include the <a href="https://www.linuxfromscratch.org/lfs/view/12.2/chapter08/man-pages.html">section 8.3 man-pages</a> and <a href="https://www.linuxfromscratch.org/lfs/view/12.2/chapter08/iana-etc.html">section 8.4 iana-etc</a> as the first steps of Post-LC. It turns out that it&#39;s OK to run these steps after the final glibc build.</p></li>
</ul>

<p>Here&#39;s how the various build stages are modified to support Fil-C.</p>

<h3>Modifying Pre-LC</h3>

<p>In normal LFS, most of the Pre-LC tools are built with <code>--prefix=/usr</code> even though these are not the final versions of the tools. Post-LC overwrites the tools build in this bootstraping phase.</p>

<p>It turns out that I cannot quite do this for Fil-C, because Fil-C does not share ABI with Yolo-C. So, we do not want situations like:</p>

<ol>
<li><p>Pre-LC builds library <code>libfoo.so</code>.</p></li>
<li><p>Pre-LC builds a binary <code>bar</code> that dynamically links <code>libfoo.so</code>.</p></li>
<li><p>Post-LC builds library <code>libfoo.so</code> and overwrites the version from Pre-LC.</p></li>
</ol>

<p>If we did that, then <code>bar</code> would stop functioning, since <code>bar</code> is a Yolo executable and <code>libfoo.so</code> is now a Fil library. The same kind of problem would occur if in step 3, Post-LC built <code>bar</code> with Fil-C - we&#39;d have a Fil binary dynamically linking to a Yolo library. It wouldn&#39;t work!</p>

<p>So, Pre-LC takes the following approach:</p>

<ul>
<li><p>We build everything with <code>--prefix=/yolo</code>.</p></li>
<li><p>We use symlinks to make it seem like everything is in <code>/usr</code>. For example, <code>/usr/bin</code> is a symlink to <code>/yolo/bin</code> and <code>/usr/lib</code> is a symlink to <code>/yolo/lib</code>. Also, <code>/bin</code> is a symlink to <code>/usr/bin</code> and <code>/lib</code> is a symlink to <code>/usr/lib</code>.</p></li>
</ul>

<p>At the end of Pre-LC, all libraries and binaries are actually installed in <code>/yolo</code>, but they function as if they were installed in <code>/usr</code> in the sense that the glibc loader is going to look for libraries in <code>/lib</code> and lots of software (like lots of shell scripts) point at <code>/bin</code> or <code>/usr/bin</code> directly.</p>

<h3>Modifying LC</h3>

<p>The LC phase is where most of the magic happens. LC has multiple substages: Fil-C build, yoloify, yolo glibc build, Fil-C binary drop, user glibc build, and finally libc++ binary drop. Note that the need for two glibcs - yolo and user - is due to the <a href="https://fil-c.org/runtime.html">libc sandwich runtime</a>.</p>

<h4>Fil-C Build</h4>

<p>The first stage of LC is to build Fil-C in a way that is almost identical to <code>./build_all_fast_glibc.sh</code> except that we force the use of the kernel headers from the version of the kernel that Pizlix uses. We will use the clang compiler binary, <code>libpizlo.so</code>, libc++abi, and libc++ libraries as binary drops into Pizlix in later parts of LC.</p>

<p>This also packages up yolo glibc and user glibc so that they can be built inside the Pizlix chroot.</p>

<h4>Yoloify</h4>

<p>Now we break the symlinks from <code>/usr</code> to <code>/yolo</code>. To do this without breaking the bootstrap binaries, we also <code>patchelf</code> all of the binaries so that:</p>

<ul>
<li><p>They know that the ELF interpreter (i.e. ELF dynamic loader) is in <code>/yolo/lib/ld-linux-x86-64.so.2</code>.</p></li>
<li><p>They know that their rpath is in <code>/yolo/lib</code>.</p></li>
</ul>

<p>Also, all scripts that use absolute paths to their interpreter (i.e. <code>#!</code>) is in <code>/yolo/bin</code>.</p>

<h4>Yolo glibc Build</h4>

<p>Now we build <a href="https://github.com/pizlonator/fil-c/tree/deluge/projects/yolo-glibc-2.40">yolo glibc</a> (i.e. the version of glibc 2.40 hacked to be the Yolo libc in the <a href="https://fil-c.org/runtime.html">Fil-C  sandwich runtime</a>) inside the Pizfix chroot. This is a very hacked glibc build:</p>

<ul>
<li><p>We build yolo glibc using GCC, since it&#39;s a Yolo-C component that sits below the Fil-C runtime.</p></li>
<li><p>We disable a bunch of features, since Fil-C only uses this libc for syscalls in the Fil-C runtime. In the future, we could even get rid of the yolo libc altogether!</p></li>
<li><p>We pretend that <code>--prefix=/usr</code>. In some ways, that&#39;s true.</p></li>
<li><p>After glibc is installed, we delete everything it places in <code>/usr</code> except for the <code>libc</code>, <code>libm</code>, and <code>ld-linux-x86-64.so.2</code> shared objects.</p></li>
<li><p>We rename those shared objects so that <code>libc.so.6</code> becomes <code>libyolocimpl.so</code>, <code>libm.so.6</code> becomes <code>libyolomimpl.so</code>, and <code>ld-linux-x86-64.so.2</code> becomes <code>ld-yolo-x86_64.so</code>.</p></li>
</ul>

<p>Now, the yolo glibc is installed in such a way that <code>libpizlo.so</code> and the <a href="https://fil-c.org/compiler.html">Fil-C compiler</a> know how to find it. And, most importantly, it&#39;s installed in such a way that it stays out of the way of the user glibc (which will claim the <code>libc</code> and <code>libm</code> library namespace).</p>

<h4>Fil-C Binary Drop</h4>

<p>This part is very hackish! I haven&#39;t ported <a href="https://github.com/pizlonator/fil-c/tree/deluge/libpas"><code>libpizlo.so</code></a> to build with GCC. So, rather than porting it or having Yolo clang in Pre-LC, this step just binary drops the <code>libpizlo.so</code> we&#39;ve already built into <code>/usr/lib</code>. This also drops the Fil-C headers into <code>/usr/include</code>.</p>

<p>This step also binary drops the <a href="https://fil-c.org/compiler.html">Fil-C compiler</a> - a clang binary that only dynamically links glibc ABI version 6 - into <code>/usr/bin</code> and sets up the symlinks (so <code>gcc</code>, <code>g++</code>, <code>cc</code>, <code>c++</code>, <code>clang</code>, and <code>clang++</code> all point to this compiler).</p>

<h4>User glibc Build</h4>

<p>Now we build <a href="https://github.com/pizlonator/fil-c/tree/deluge/projects/user-glibc-2.40">user glibc</a> (i.e. the version of glibc 2.40 that has been ported to Fil-C) inside the Pizfix chroot. This is almost exactly the build process used in <a href="https://www.linuxfromscratch.org/lfs/view/12.2/chapter08/glibc.html">Section 8.5 of LFS</a>, except we&#39;re using a version of glibc 2.40 that has been ported to Fil-C and we&#39;re compiling with the <a href="https://fil-c.org/compiler.html">Fil-C compiler</a> rather than GCC.</p>

<h4>libc++ Binary Drop</h4>

<p>Ideally, we&#39;d build libc++abi and libc++ within the Pizfix chroot, but for now I&#39;m being lazy so I just binary drop the versions I&#39;ve already built.</p>

<p>This concludes the LC phase! Now it&#39;s possible to proceed with the rest of the LFS build. That build will end up using the Fil-C compiler even if the build scripts explicitly ask for <code>gcc</code> or <code>g++</code>, and they will get a Fil-C version of glibc, and libc++abi/libc++ as their C++ libraries.</p>

<h3>Modifying Post-LC</h3>

<p>Post-LC is almost exactly the LFS chapters 8-10 except for the glibc step (which we already did in the LC phase). The only changes are:</p>

<ul>
<li><p>Some programs required minor modifications to work in Fil-C.</p></li>
<li><p>The Linux kernel needs to be built using two compilers. The &#34;host&#34; compiler is the <a href="https://fil-c.org/compiler.html">Fil-C compiler</a>. So, there are minor changes in the userlevel parts of the Linux kernel and the exact commands used to invoke the build are a bit more verbose.</p></li>
</ul>

<p>Pizlix also includes a Post-LC 2, Post-LC 3, and Post-LC 4 phases that build some parts of <a href="https://www.linuxfromscratch.org/blfs/view/12.2/">BLFS 12.2</a> plus enough to run Weston and GTK 4.</p>
        </main>
    </div></div>
  </body>
</html>
