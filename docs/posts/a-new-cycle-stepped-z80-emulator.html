<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://floooh.github.io/2021/12/17/cycle-stepped-z80.html">Original</a>
    <h1>A new cycle-stepped Z80 emulator</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <article itemscope="" itemtype="https://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <h2 id="table-of-content">Table of Content</h2>

<ul id="markdown-toc">
  <li><a href="#table-of-content" id="markdown-toc-table-of-content">Table of Content</a></li>
  <li><a href="#intro" id="markdown-toc-intro">Intro</a></li>
  <li><a href="#a-code-sample" id="markdown-toc-a-code-sample">A Code Sample</a></li>
  <li><a href="#basic-implementation-ideas" id="markdown-toc-basic-implementation-ideas">Basic Implementation Ideas</a></li>
  <li><a href="#code-generation" id="markdown-toc-code-generation">Code Generation</a></li>
  <li></li>
  <li><a href="#the-opcode-lookup-tables" id="markdown-toc-the-opcode-lookup-tables">The Opcode Lookup Tables</a></li>
  <li><a href="#the-3-tick-function-epilogues" id="markdown-toc-the-3-tick-function-epilogues">The 3 Tick Function Epilogues</a></li>
  <li><a href="#more-on-wait-cycles" id="markdown-toc-more-on-wait-cycles">More on Wait Cycles</a></li>
  <li><a href="#instructions-with-variable-timing" id="markdown-toc-instructions-with-variable-timing">Instructions with Variable Timing</a></li>
  <li><a href="#the-overlapped-clock-cycle-in-more-detail" id="markdown-toc-the-overlapped-clock-cycle-in-more-detail">The ‘Overlapped Clock Cycle’ in more Detail</a></li>
  <li><a href="#ddfd-prefix-handling" id="markdown-toc-ddfd-prefix-handling">DD/FD Prefix Handling</a></li>
  <li><a href="#ed-prefix-handling" id="markdown-toc-ed-prefix-handling">ED Prefix Handling</a></li>
  <li><a href="#cb-prefix-handling" id="markdown-toc-cb-prefix-handling">CB Prefix Handling</a></li>
  <li><a href="#interrupt-detection" id="markdown-toc-interrupt-detection">Interrupt Detection</a></li>
  <li><a href="#nmi-interrupt-behaviour" id="markdown-toc-nmi-interrupt-behaviour">NMI Interrupt Behaviour</a></li>
  <li><a href="#mode-0-interrupt-behaviour" id="markdown-toc-mode-0-interrupt-behaviour">Mode 0 Interrupt Behaviour</a></li>
  <li><a href="#mode-1-interrupt-behaviour" id="markdown-toc-mode-1-interrupt-behaviour">Mode 1 Interrupt Behaviour</a></li>
  <li><a href="#mode-2-interrupt-behaviour" id="markdown-toc-mode-2-interrupt-behaviour">Mode 2 Interrupt Behaviour</a></li>
  <li><a href="#the-ei-di-and-retiretn-instructions" id="markdown-toc-the-ei-di-and-retiretn-instructions">The EI, DI and RETI/RETN instructions</a></li>
  <li><a href="#pin-timing-differences-to-a-real-z80" id="markdown-toc-pin-timing-differences-to-a-real-z80">Pin Timing Differences to a real Z80</a></li>
  <li><a href="#differences-to-the-old-z80-emulator" id="markdown-toc-differences-to-the-old-z80-emulator">Differences to the old Z80 Emulator</a></li>
  <li><a href="#testing" id="markdown-toc-testing">Testing</a></li>
  <li><a href="#amstrad-cpc-accurary-improvements" id="markdown-toc-amstrad-cpc-accurary-improvements">Amstrad CPC Accurary Improvements</a></li>
</ul>

<h2 id="intro">Intro</h2>

<p>I finally got around rewriting the <a href="https://github.com/floooh/chips">Chips Project</a> <a href="https://github.com/floooh/chips/blob/master/chips/z80.h">Z80 emulator</a> to a
‘cycle-stepped’ execution model. The idea has been rolling around in my head
since at least 2019 when I gave the 6502 emulator 
<a href="https://floooh.github.io/2019/12/13/cycle-stepped-6502.html">the cycle-stepped treatment</a>.</p>

<p>‘Cycle-stepped’ means that the CPU emulator state can be stepped forward in
single clock cycles. Previously, the Z80 emulator was ‘instruction stepped’:
Even if the user asked the emulator to only execute one clock cycle, the
emulator would execute one full instruction before it could return
to the caller.  While this doesn’t prevent the creation of cycle-correct
computer system emulators (because the CPU emulator would invoke a ‘tick callback’
multiple times while executing a single instruction), switching the
CPU emulator to a cycle-stepped model allows a more straight-forward
‘whole system’ emulation because the CPU no longer has a special controller
role in a system emulation, instead it’s just an ordinary chip that’s
ticked along with the other chips in the system.</p>

<p>The Z80-based <a href="https://floooh.github.io/tiny8bit/">Tiny Emulators</a> have all been updated
to the new cycle-stepped model, which also means that the CPU step debugger now 
supports cycle-stepping (which is very useful for debugging the other chips in the 
emulated system):</p>

<p><img src="https://floooh.github.io/images/z80_step_debug.jpg"/></p>

<p>…also, if you haven’t seen it yet, check out the <a href="https://floooh.github.io/visualz80remix/">Visual Z80 Remix project</a>,
which I did as preparation for the new Z80 emulator to get the cycle timing right
and better understand what’s going on in some of the more esoteric instructions.</p>

<h2 id="a-code-sample">A Code Sample</h2>

<p>Here’s a simple code example to get an idea how the new emulator works:</p>

<div><div><pre><code><span>#include &lt;stdio.h&gt;
#define CHIPS_IMPL
#include &#34;z80.h&#34;
</span>
<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>// 64 KB memory with test program at address 0x0000</span>
    <span>uint8_t</span> <span>mem</span><span>[(</span><span>1</span><span>&lt;&lt;</span><span>16</span><span>)]</span> <span>=</span> <span>{</span>
        <span>0x3E</span><span>,</span> <span>0x02</span><span>,</span>     <span>// LD A,2</span>
        <span>0x06</span><span>,</span> <span>0x03</span><span>,</span>     <span>// LD B,3</span>
        <span>0x80</span><span>,</span>           <span>// ADD A,B</span>
        <span>0x00</span><span>,</span>           <span>// NOP...</span>
    <span>};</span>

    <span>// initialize Z80 emu and execute some clock cycles </span>
    <span>z80_t</span> <span>cpu</span><span>;</span>
    <span>uint64_t</span> <span>pins</span> <span>=</span> <span>z80_init</span><span>(</span><span>&amp;</span><span>cpu</span><span>);</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>20</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
        
        <span>// tick the CPU</span>
        <span>pins</span> <span>=</span> <span>z80_tick</span><span>(</span><span>&amp;</span><span>cpu</span><span>,</span> <span>pins</span><span>);</span>

        <span>// handle memory read or write access</span>
        <span>if</span> <span>(</span><span>pins</span> <span>&amp;</span> <span>Z80_MREQ</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>pins</span> <span>&amp;</span> <span>Z80_RD</span><span>)</span> <span>{</span>
                <span>Z80_SET_DATA</span><span>(</span><span>pins</span><span>,</span> <span>mem</span><span>[</span><span>Z80_GET_ADDR</span><span>(</span><span>pins</span><span>)]);</span>
            <span>}</span>
            <span>else</span> <span>if</span> <span>(</span><span>pins</span> <span>&amp;</span> <span>Z80_WR</span><span>)</span> <span>{</span>
                <span>mem</span><span>[</span><span>Z80_GET_ADDR</span><span>(</span><span>pins</span><span>)]</span> <span>=</span> <span>Z80_GET_DATA</span><span>(</span><span>pins</span><span>);</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>// register A should now be 5</span>
    <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>Register A: %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>cpu</span><span>.</span><span>a</span><span>);</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Here’s the same code on <a href="https://www.godbolt.org/z/6aTKo4vbM">Compiler Explorer</a>.</p>

<p>The emulator only has two important API functions:</p>

<div><div><pre><code><span>uint64_t</span> <span>z80_init</span><span>(</span><span>z80_t</span><span>*</span> <span>cpu</span><span>)</span>
</code></pre></div></div>

<p>…this initializes a Z80 instance and returns an ‘ignition pin bitmask’ which is passed into the first tick 
function call:</p>

<div><div><pre><code><span>uint64_t</span> <span>z80_tick</span><span>(</span><span>z80_t</span><span>*</span> <span>cpu</span><span>,</span> <span>uint64_t</span> <span>pins</span><span>)</span>
</code></pre></div></div>

<p>…the tick function executes exactly one clock cycle and then returns to the caller 
with a modified pin bitmask. This bitmask is used to communicate with the ‘outside world’
just like the input/output pins on a real CPU.</p>

<p>The caller inspects the returned pin mask (for instance to check if the CPU wants to read
or write memory), modifies the pin mask accordingly, and feeds it back into the next
call of <code>z80_tick()</code>. And that’s it, no more ‘system tick callback’, or
‘trace callback’ for debugger support like in the old Z80 emulator.</p>

<h2 id="basic-implementation-ideas">Basic Implementation Ideas</h2>

<p>Instruction decoding happens in a big switch-case statement like in the
previous emulator, but instead of one case-branch per opcode there’s now one
case branch per instruction clock cycle.</p>

<p>In the new emulator, the decoder switch-case statement looks more like a program which
implements its own ‘meta control flow’.</p>

<p>A simple sequence where each call to the tick function executes the next step would look like this:</p>

<div><div><pre><code><span>void</span> <span>tick</span><span>(</span><span>state_t</span><span>*</span> <span>state</span><span>)</span> <span>{</span>
    <span>switch</span> <span>(</span><span>state</span><span>-&gt;</span><span>step</span><span>++</span><span>)</span> <span>{</span>
        <span>case</span> <span>0</span><span>:</span> <span>...</span> <span>break</span><span>;</span>
        <span>case</span> <span>1</span><span>:</span> <span>...</span> <span>break</span><span>;</span>
        <span>case</span> <span>2</span><span>:</span> <span>...</span> <span>break</span><span>;</span>
        <span>...</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>Calling such a tick function over and over would first step through all the case branches until
there are no more branches left or the step counter overflows.</p>

<p>To implement an unconditional branch the step counter is simply set to the destination step,
so that execution continues there on the next call of the tick function.</p>

<p>For instance here the step counter is reset to zero at the end of the sequence,
implementing an infinite loop:</p>

<div><div><pre><code><span>void</span> <span>tick</span><span>(</span><span>state_t</span><span>*</span> <span>state</span><span>)</span> <span>{</span>
    <span>switch</span> <span>(</span><span>state</span><span>-&gt;</span><span>step</span><span>++</span><span>)</span> <span>{</span>
        <span>case</span> <span>0</span><span>:</span> <span>...</span> <span>break</span><span>;</span>
        <span>case</span> <span>1</span><span>:</span> <span>...</span> <span>break</span><span>;</span>
        <span>case</span> <span>2</span><span>:</span> <span>...</span> <span>break</span><span>;</span>
        <span>case</span> <span>3</span><span>:</span> <span>state</span><span>-&gt;</span><span>step</span> <span>=</span> <span>0</span><span>;</span> <span>break</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>Calling the tick function will now execute the steps 0..3 forever: [0, 1, 2, 3, 0, 1, 2, 3, …].</p>

<p>Of course branches can also jump forward to skip steps:</p>
<div><div><pre><code><span>void</span> <span>tick</span><span>(</span><span>state_t</span><span>*</span> <span>state</span><span>)</span> <span>{</span>
    <span>switch</span> <span>(</span><span>state</span><span>-&gt;</span><span>step</span><span>++</span><span>)</span> <span>{</span>
        <span>case</span> <span>0</span><span>:</span> <span>...</span> <span>break</span><span>;</span>
        <span>case</span> <span>1</span><span>:</span> <span>state</span><span>-&gt;</span><span>step</span> <span>=</span> <span>3</span><span>;</span> <span>break</span><span>;</span>
        <span>case</span> <span>2</span><span>:</span> <span>...</span> <span>break</span><span>;</span>
        <span>case</span> <span>3</span><span>:</span> <span>state</span><span>-&gt;</span><span>step</span> <span>=</span> <span>0</span><span>;</span> <span>break</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>Step 2 will now always be skipped, resulting in [0, 1, 3, 0, 1, 3, …].</p>

<p>…and conditional branches only modify the step counter when a condition is true:</p>
<div><div><pre><code><span>void</span> <span>tick</span><span>(</span><span>state_t</span><span>*</span> <span>state</span><span>)</span> <span>{</span>
    <span>switch</span> <span>(</span><span>state</span><span>-&gt;</span><span>step</span><span>++</span><span>)</span> <span>{</span>
        <span>case</span> <span>0</span><span>:</span> <span>state</span><span>-&gt;</span><span>cond</span> <span>=</span> <span>!</span><span>state</span><span>-&gt;</span><span>cond</span><span>;</span> <span>break</span><span>;</span>
        <span>case</span> <span>1</span><span>:</span> <span>if</span> <span>(</span><span>state</span><span>-&gt;</span><span>cond</span><span>)</span> <span>{</span> <span>state</span><span>-&gt;</span><span>step</span> <span>=</span> <span>3</span><span>;</span> <span>}</span> <span>break</span><span>;</span>
        <span>case</span> <span>2</span><span>:</span>     <span>...</span> <span>break</span><span>;</span>
        <span>case</span> <span>3</span><span>:</span> <span>state</span><span>-&gt;</span><span>step</span> <span>=</span> <span>0</span><span>;</span> <span>break</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Because <code>state-&gt;cond</code> is now toggled in step 0, step 2 will be skipped in every other ‘run’ of the program: [0, 1, 3, 0, 1, 2, 3, 0, 1, 3, …].</p>

<p>Code that needs to be executed on each call of the tick function can be placed in front (prologue) or after (epilogue) the switch-case statement:</p>

<div><div><pre><code><span>void</span> <span>tick</span><span>(</span><span>state_t</span><span>*</span> <span>state</span><span>)</span> <span>{</span>
    <span>prologue</span><span>;</span>
    <span>switch</span> <span>(</span><span>state</span><span>-&gt;</span><span>step</span><span>++</span><span>)</span> <span>{</span>
        <span>case</span> <span>0</span><span>:</span> <span>state</span><span>-&gt;</span><span>cond</span> <span>=</span> <span>!</span><span>state</span><span>-&gt;</span><span>cond</span><span>;</span> <span>break</span><span>;</span>
        <span>case</span> <span>1</span><span>:</span> <span>if</span> <span>(</span><span>state</span><span>-&gt;</span><span>cond</span><span>)</span> <span>{</span> <span>state</span><span>-&gt;</span><span>step</span> <span>=</span> <span>3</span><span>;</span> <span>}</span> <span>break</span><span>;</span>
        <span>case</span> <span>2</span><span>:</span>     <span>...</span> <span>break</span><span>;</span>
        <span>case</span> <span>3</span><span>:</span> <span>state</span><span>-&gt;</span><span>step</span> <span>=</span> <span>0</span><span>;</span> <span>break</span><span>;</span>
    <span>}</span>
    <span>epilogue</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>And finally, in C we can “break into” different epilogue code blocks using the
good old goto statement:</p>
<div><div><pre><code><span>void</span> <span>tick</span><span>(</span><span>state_t</span><span>*</span> <span>state</span><span>)</span> <span>{</span>
    <span>prologue</span><span>;</span>
    <span>switch</span> <span>(</span><span>state</span><span>-&gt;</span><span>step</span><span>++</span><span>)</span> <span>{</span>
        <span>case</span> <span>0</span><span>:</span> <span>state</span><span>-&gt;</span><span>cond</span> <span>=</span> <span>!</span><span>state</span><span>-&gt;</span><span>cond</span><span>;</span> <span>goto</span> <span>ep_1</span><span>;</span>
        <span>case</span> <span>1</span><span>:</span> <span>if</span> <span>(</span><span>state</span><span>-&gt;</span><span>cond</span><span>)</span> <span>{</span> <span>state</span><span>-&gt;</span><span>step</span> <span>=</span> <span>3</span><span>;</span> <span>}</span> <span>goto</span> <span>ep_1</span><span>;</span>
        <span>case</span> <span>2</span><span>:</span>     <span>...;</span> <span>goto</span> <span>ep_2</span><span>;</span>
        <span>case</span> <span>3</span><span>:</span> <span>state</span><span>-&gt;</span><span>step</span> <span>=</span> <span>0</span><span>;</span> <span>goto</span> <span>ep_1</span><span>;</span>
    <span>}</span>
<span>ep_1:</span>
    <span>epilogue_1</span><span>;</span>
<span>ep_2:</span>
    <span>epilogue_2</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>Now the steps 0, 1 and 3 will run <code>epilogue_1</code> and <code>epilogue_2</code> on function
exit, but step 2 will only execute <code>epilogue_2</code>.</p>

<p>With the above core ideas it’s now possible to encode Z80 instructions into
switch-case ‘microcode’:</p>

<p>For example, the <strong>LD HL,nn</strong> instruction loads a 16-bit immediate value into
the register pair HL. Execution of the instruction takes 10 clock cycles, split
into 3 machine cycle groups:</p>

<ul>
  <li>opcode fetch and refresh (4 clock cycles)</li>
  <li>read low byte into L (3 clock cycles)</li>
  <li>read high byte into H (3 clock cycles)</li>
</ul>

<p>…encoded into a switch-case sequence (as simplified pseudocode, abus and dbus means ‘address bus’ and ‘data bus’):</p>

<div><div><pre><code><span>uint64_t</span> <span>tick</span><span>(</span><span>z80_t</span><span>*</span> <span>cpu</span><span>,</span> <span>uint64_t</span> <span>pins</span><span>)</span> <span>{</span>
    <span>switch</span> <span>(</span><span>cpu</span><span>-&gt;</span><span>step</span><span>)</span> <span>{</span>
        <span>// opcode fetch + refresh machine cycle</span>
        <span>case</span> <span>0</span><span>:</span> <span>pins</span> <span>=</span> <span>(</span><span>M1</span><span>|</span><span>MREQ</span><span>|</span><span>RD</span><span>)</span> <span>|</span> <span>set_abus</span><span>(</span><span>cpu</span><span>-&gt;</span><span>PC</span><span>++</span><span>);</span> <span>break</span><span>;</span>
        <span>case</span> <span>1</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>opcode</span> <span>=</span> <span>get_dbus</span><span>(</span><span>pins</span><span>);</span> <span>break</span><span>;</span>
        <span>case</span> <span>2</span><span>:</span> <span>pins</span> <span>=</span> <span>(</span><span>RFSH</span><span>|</span><span>MREQ</span><span>)</span> <span>|</span> <span>set_abus</span><span>(...);</span> <span>break</span><span>;</span>
        <span>case</span> <span>3</span><span>:</span> <span>break</span><span>;</span>

        <span>// first read machine cycle</span>
        <span>case</span> <span>4</span><span>:</span> <span>break</span><span>;</span>
        <span>case</span> <span>5</span><span>:</span> <span>pins</span> <span>=</span> <span>(</span><span>MREQ</span><span>|</span><span>RD</span><span>)</span> <span>|</span> <span>set_abus</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span> <span>break</span><span>;</span>
        <span>case</span> <span>6</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>L</span> <span>=</span> <span>get_dbus</span><span>(</span><span>pins</span><span>);</span> <span>break</span><span>;</span>

        <span>// second read machine cycle</span>
        <span>case</span> <span>7</span><span>:</span> <span>break</span><span>;</span>
        <span>case</span> <span>8</span><span>:</span> <span>pins</span> <span>=</span> <span>(</span><span>MREQ</span><span>|</span><span>RD</span><span>)</span> <span>|</span> <span>set_abus</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span> <span>break</span><span>;</span>
        <span>case</span> <span>9</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>H</span> <span>=</span> <span>get_dbus</span><span>(</span><span>pins</span><span>);</span> <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>0</span><span>;</span> <span>break</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This looks pretty good already, but there’s a chicken-egg-problem: the
opcode fetch machine cycle (the first four steps) doesn’t actually do anything.
Even though it loads an opcode byte, the opcode is ignored and the CPU
will only ever execute <strong>LD HL,nn</strong> instructions. Currently there’s no
way to add additional instructions to the switch statement.</p>

<p>The solution is to split the switch-case decoder into a shared opcode fetch
machine cycle which is the same for all instructions, and then do a branch to
the remaining steps (which I’ll call ‘the instruction payload’ henceforth) somewhere else
in the big switch-case statement.</p>

<p>At the end of the shared opcode fetch machine cycle, a table lookup
is performed with the opcode as index which yields the first step
of the instrucion payload (look at <code>case 3:</code>):</p>

<div><div><pre><code><span>uint64_t</span> <span>tick</span><span>(</span><span>z80_t</span><span>*</span> <span>cpu</span><span>,</span> <span>uint64_t</span> <span>pins</span><span>)</span> <span>{</span>
    <span>switch</span> <span>(</span><span>cpu</span><span>-&gt;</span><span>step</span><span>)</span> <span>{</span>
        <span>// opcode fetch + refresh machine cycle</span>
        <span>case</span> <span>0</span><span>:</span> <span>pins</span> <span>=</span> <span>(</span><span>M1</span><span>|</span><span>MREQ</span><span>|</span><span>RD</span><span>)</span> <span>|</span> <span>set_abus</span><span>(</span><span>cpu</span><span>-&gt;</span><span>PC</span><span>++</span><span>);</span> <span>break</span><span>;</span>
        <span>case</span> <span>1</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>opcode</span> <span>=</span> <span>get_dbus</span><span>(</span><span>pins</span><span>);</span> <span>break</span><span>;</span>
        <span>case</span> <span>2</span><span>:</span> <span>pins</span> <span>=</span> <span>(</span><span>RFSH</span><span>|</span><span>MREQ</span><span>)</span> <span>|</span> <span>set_abus</span><span>(...);</span> <span>break</span><span>;</span>
        <span>case</span> <span>3</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>opstep</span><span>[</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>];</span>

        <span>...</span>

        <span>// somewhere else in the big switch-case:</span>
        <span>// first read machine cycle of LD HL,nn</span>
        <span>case</span> <span>N</span><span>+</span><span>0</span><span>:</span> <span>break</span><span>;</span>
        <span>case</span> <span>N</span><span>+</span><span>1</span><span>:</span> <span>pins</span> <span>=</span> <span>(</span><span>MREQ</span><span>|</span><span>RD</span><span>)</span> <span>|</span> <span>set_abus</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span> <span>break</span><span>;</span>
        <span>case</span> <span>N</span><span>+</span><span>2</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>L</span> <span>=</span> <span>get_dbus</span><span>(</span><span>pins</span><span>);</span> <span>break</span><span>;</span>

        <span>// second read machine cycle of LD HL,nn</span>
        <span>case</span> <span>N</span><span>+</span><span>3</span><span>:</span> <span>break</span><span>;</span>
        <span>case</span> <span>N</span><span>+</span><span>4</span><span>:</span> <span>pins</span> <span>=</span> <span>(</span><span>MREQ</span><span>|</span><span>RD</span><span>)</span> <span>|</span> <span>set_abus</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span> <span>break</span><span>;</span>
        <span>case</span> <span>N</span><span>+</span><span>5</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>H</span> <span>=</span> <span>get_dbus</span><span>(</span><span>pins</span><span>);</span> <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>0</span><span>;</span> <span>break</span><span>;</span>
        
        <span>...</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Note how the last step at <strong>case (N+5)</strong> loops back to step 0 to load the next opcode byte. In
general, that’s how the cycle-stepped emulation loop works, but there’s one
last problem: most instructions in the Z80 instruction set take 4 cycles to
execute, but this doesn’t fit into the above execution pattern.</p>

<p>Since the opcode fetch machine cycle already takes 4 clock cycles, there’s
no clock cycle left to execute the instruction payload.</p>

<p>Let’s take the <strong>ADD A,B</strong> instruction as example, this <em>should</em> look like this:</p>

<div><div><pre><code><span>uint64_t</span> <span>tick</span><span>(</span><span>z80_t</span><span>*</span> <span>cpu</span><span>,</span> <span>uint64_t</span> <span>pins</span><span>)</span> <span>{</span>
    <span>switch</span> <span>(</span><span>cpu</span><span>-&gt;</span><span>step</span><span>)</span> <span>{</span>
        <span>// opcode fetch + refresh machine cycle</span>
        <span>case</span> <span>0</span><span>:</span> <span>pins</span> <span>=</span> <span>(</span><span>M1</span><span>|</span><span>MREQ</span><span>|</span><span>RD</span><span>)</span> <span>|</span> <span>set_abus</span><span>(</span><span>cpu</span><span>-&gt;</span><span>PC</span><span>++</span><span>);</span> <span>break</span><span>;</span>
        <span>case</span> <span>1</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>opcode</span> <span>=</span> <span>get_dbus</span><span>(</span><span>pins</span><span>);</span> <span>break</span><span>;</span>
        <span>case</span> <span>2</span><span>:</span> <span>pins</span> <span>=</span> <span>(</span><span>RFSH</span><span>|</span><span>MREQ</span><span>)</span> <span>|</span> <span>set_abus</span><span>(...);</span> <span>break</span><span>;</span>
        <span>case</span> <span>3</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>opstep</span><span>[</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>];</span>

        <span>...</span>

        <span>// ADD A,B payload:</span>
        <span>case</span> <span>N</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>a</span><span>=</span><span>add8</span><span>(</span><span>cpu</span><span>-&gt;</span><span>a</span><span>,</span><span>cpu</span><span>-&gt;</span><span>b</span><span>);</span> <span>cpu</span><span>-&gt;</span><span>step</span><span>=</span><span>0</span><span>;</span> <span>break</span><span>;</span>
        
        <span>...</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>But this would take 5 clock cycles, not the required 4.</p>

<p>The solution is to use the same trick as a real-world Z80: overlap the
execution of the last instruction with the opcode fetch of the next instruction
by merging the last instruction clock cycle with the first clock cycle of
the next opcode fetch, note how the old <code>case 0:</code> step has been removed and
merged with the ADD A,B payload step:</p>

<div><div><pre><code><span>uint64_t</span> <span>tick</span><span>(</span><span>z80_t</span><span>*</span> <span>cpu</span><span>,</span> <span>uint64_t</span> <span>pins</span><span>)</span> <span>{</span>
    <span>switch</span> <span>(</span><span>cpu</span><span>-&gt;</span><span>step</span><span>)</span> <span>{</span>
        <span>// last 3 clock cyles of opcode fetch + refresh machine cycle</span>
        <span>case</span> <span>0</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>opcode</span> <span>=</span> <span>get_dbus</span><span>(</span><span>pins</span><span>);</span> <span>break</span><span>;</span>
        <span>case</span> <span>1</span><span>:</span> <span>pins</span> <span>=</span> <span>(</span><span>RFSH</span><span>|</span><span>MREQ</span><span>)</span> <span>|</span> <span>set_abus</span><span>(...);</span> <span>break</span><span>;</span>
        <span>case</span> <span>2</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>opstep</span><span>[</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>];</span>

        <span>...</span>
        <span>// ADD A,B payload:</span>
        <span>case</span> <span>N</span><span>:</span> 
            <span>cpu</span><span>-&gt;</span><span>a</span><span>=</span><span>add8</span><span>(</span><span>cpu</span><span>-&gt;</span><span>a</span><span>,</span><span>cpu</span><span>-&gt;</span><span>b</span><span>);</span> 
            <span>pins</span> <span>=</span> <span>(</span><span>M1</span><span>|</span><span>MREQ</span><span>|</span><span>RD</span><span>)</span> <span>|</span> <span>set_abus</span><span>(</span><span>cpu</span><span>-&gt;</span><span>PC</span><span>++</span><span>);</span>
            <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>0</span><span>;</span>
            <span>break</span><span>;</span>
        <span>...</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>…it looks a bit nicer when wrapping the actions of the first opcode fetch cycle into a macro:</p>

<div><div><pre><code><span>#define _fetch() {pins=(M1|MREQ|RD)|set_abus(cpu-&gt;PC++);cpu-&gt;step=0}
</span>
<span>uint64_t</span> <span>tick</span><span>(</span><span>z80_t</span><span>*</span> <span>cpu</span><span>,</span> <span>uint64_t</span> <span>pins</span><span>)</span> <span>{</span>
    <span>switch</span> <span>(</span><span>cpu</span><span>-&gt;</span><span>step</span><span>)</span> <span>{</span>
        <span>// last 3 clock cyles of opcode fetch + refresh machine cycle</span>
        <span>case</span> <span>0</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>opcode</span> <span>=</span> <span>get_dbus</span><span>(</span><span>pins</span><span>);</span> <span>break</span><span>;</span>
        <span>case</span> <span>1</span><span>:</span> <span>pins</span> <span>=</span> <span>(</span><span>RFSH</span><span>|</span><span>MREQ</span><span>)</span> <span>|</span> <span>set_abus</span><span>(...);</span> <span>break</span><span>;</span>
        <span>case</span> <span>2</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>opstep</span><span>[</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>];</span>

        <span>...</span>
        <span>// ADD A,B payload and first clock cycle of next opcode fetch</span>
        <span>case</span> <span>N</span><span>+</span><span>0</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>a</span><span>=</span><span>add8</span><span>(</span><span>cpu</span><span>-&gt;</span><span>a</span><span>,</span><span>cpu</span><span>-&gt;</span><span>b</span><span>);</span> <span>_fetch</span><span>();</span> <span>break</span><span>;</span>
        <span>...</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>With this overlap-trick the timing for 4-cycle instruction is working fine now.
You might be wondering now how the very first instruction starts executing. The
trick is that the <code>z80_init()</code> function doesn’t initialize the
<code>cpu-&gt;step</code> to 0, but instead to the overlapped payload-and-fetch clock
cycle of the NOP instruction. That way the CPU emulation is properly ‘ignited’
at the first call to the <code>z80_tick()</code> function.</p>

<p>The only problem left to figure out now is how to ‘draw the rest of the f*cking owl’.</p>

<h2 id="code-generation">Code Generation</h2>

<p>Like in my previous CPU emulators, I’m using a Python script to generate the
instruction decoder C source code. But this time I tried another idea that was
also rolling around in the back of my head for a long time: instead of
hardwiring the instruction behaviour and timing entirely in the Python script,
describe the instructions in a data file, and process that data file with a
much smaller and more general Python script.</p>

<p>I’m using YAML as file format for this data file. YAML isn’t perfect
because it requires the separately installed PyYAML dependency, but apart from
that it’s quite alright for this use case.</p>

<p>The YAML file contains instruction descriptions like this:</p>

<div><div><pre><code><span>LD $RY,$RZ</span><span>:</span>
  <span>cond</span><span>:</span> <span>(x == 1) and (y != 6) and (z != 6)</span>
  <span>mcycles</span><span>:</span>
    <span>-</span> <span>{</span> <span>type</span><span>:</span> <span>overlapped</span><span>,</span>  <span>action</span><span>:</span> <span>$RY=$RZ</span> <span>}</span>
</code></pre></div></div>
<p>Those 4 lines describe all 49 instructions for loading an 8-bit register into
another. The <code>cond:</code> line is a python expression matching the 2-3-3 opcode
bit pattern described here:</p>

<p><a href="http://www.z80.info/decoding.htm">Decoding Z80 opcodes</a></p>

<p>Identifiers starting with <strong>$</strong> are placeholders which will be replaced with
concrete register names or C code snippets during code generation.</p>

<p>Machine cycles with default timing are implicit and don’t need to be listed (for instance
in this case the opcode fetch machine cycle).</p>

<p>The generated code will look like this (for the <strong>LD A,B</strong> instruction):</p>

<div><div><pre><code>        <span>//  78: LD A,B (M:1 T:4)</span>
        <span>// -- overlapped</span>
        <span>case</span>  <span>399</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>a</span><span>=</span><span>cpu</span><span>-&gt;</span><span>b</span><span>;</span><span>goto</span> <span>fetch_next</span><span>;</span>
</code></pre></div></div>

<p>Another more interesting example is the <strong>LD dd,nn</strong> instruction group, which loads
the 16-bit immediate value <strong>nn</strong> into register pair <strong>dd</strong>.</p>

<p>The YAML description looks like this:</p>

<div><div><pre><code><span># 16-bit load immediate/add</span>
<span>LD $RP,nn</span><span>:</span>
  <span>cond</span><span>:</span> <span>(x == 0) and (z == 1) and (q == 0)</span>
  <span>mcycles</span><span>:</span>
    <span>-</span> <span>{</span> <span>type</span><span>:</span> <span>mread</span><span>,</span>  <span>ab</span><span>:</span> <span>$PC++</span><span>,</span> <span>dst</span><span>:</span> <span>$RPL</span> <span>}</span>
    <span>-</span> <span>{</span> <span>type</span><span>:</span> <span>mread</span><span>,</span>  <span>ab</span><span>:</span> <span>$PC++</span><span>,</span> <span>dst</span><span>:</span> <span>$RPH</span> <span>}</span>
</code></pre></div></div>

<p>Again, the opcode fetch machine cycle has default behaviour and isn’t listed,
and this instruction also doesn’t overlap execution with the next instruction.
What remains are two memory read machine cycles to load the 16-bit value from
memory into the destination register pair.</p>

<p>The stamped out C code for <strong>LD DE,nn</strong> looks like this:</p>

<div><div><pre><code>        <span>//  11: LD DE,nn (M:3 T:10)</span>
        <span>// -- mread</span>
        <span>case</span>   <span>83</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>   <span>84</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>   <span>85</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>e</span><span>=</span><span>_gd</span><span>();</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mread</span>
        <span>case</span>   <span>86</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>   <span>87</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>   <span>88</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>d</span><span>=</span><span>_gd</span><span>();</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- overlapped</span>
        <span>case</span>   <span>89</span><span>:</span> <span>goto</span> <span>fetch_next</span><span>;</span>
</code></pre></div></div>

<p>The macro <code>_mread()</code> sets the CPU pins for a memory read machine cycle (<code>MREQ|RD</code> and address
bus pins).</p>

<p>The macro <code>_gd()</code>  extracts the data bus pins into an <code>uint8_t</code>. The <code>_wait()</code> macro
samples the WAIT pin and will be explained later.</p>

<p>The code generation Python script is now just around 400 lines of code,
compared to about 1000 lines for the old script. However, when counting lines
for all involved files (a C header template file, the Python script, and the
YAML file) the old and new approach is nearly identical (1691 C+YAML+Python for the new
approach, and 1633 lines C+Python for the old approach).</p>

<p>One clear advantage of the new approach is that the same YAML description file can be used
for different code generation scripts (for instance the <a href="https://floooh.github.io/2021/12/06/z80-instruction-timing.html#main-quadrant-1-xx--01">instruction tables</a>
in my last blog post have been generated from the same data with a different
generator script).</p>

<p>It will also be much easier to quickly try out different decoder ideas in the future.</p>

<p>You can take a look at all involved source files for code generation here:</p>

<ul>
  <li><a href="https://github.com/floooh/chips/blob/master/codegen/z80_desc.yml">z80_desc.yml</a></li>
  <li><a href="https://github.com/floooh/chips/blob/master/codegen/z80_gen.py">z80_gen.py</a></li>
  <li><a href="https://github.com/floooh/chips/blob/master/codegen/z80.template.h">z80.template.h</a></li>
</ul>

<p>…and the resulting code-generated header:</p>

<ul>
  <li><a href="https://github.com/floooh/chips/blob/master/chips/z80.h">z80.h</a></li>
</ul>



<p>The shared code for an opcode fetch machine cycle looks like this:</p>

<div><div><pre><code>        <span>// M1/T2: load opcode from data bus</span>
        <span>case</span> <span>0</span><span>:</span> <span>_wait</span><span>();</span> <span>cpu</span><span>-&gt;</span><span>opcode</span> <span>=</span> <span>_gd</span><span>();</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// M1/T3: refresh cycle</span>
        <span>case</span> <span>1</span><span>:</span> <span>pins</span> <span>=</span> <span>_z80_refresh</span><span>(</span><span>cpu</span><span>,</span> <span>pins</span><span>);</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// M1/T4: branch to instruction payload</span>
        <span>case</span> <span>2</span><span>:</span> <span>{</span>
            <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>_z80_optable</span><span>[</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>];</span>
            <span>// preload effective address for (HL) ops</span>
            <span>cpu</span><span>-&gt;</span><span>addr</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>hl</span><span>;</span>
        <span>}</span> <span>goto</span> <span>step_next</span><span>;</span>
</code></pre></div></div>

<p>These are only the last 3 of 4 clock cycles: As explained earlier, the
‘missing’ first clock cycle is overlapped with the last instruction clock cycle
and is part of the specific instruction payload decoder blocks elsewhere in the
big switch-case statement.</p>

<p>In the first step, the WAIT pin is sampled (and if set, execution will be stuck
on this decoder step - more details on wait state behaviour later in the post).
If the WAIT pin isn’t active, the opcode byte is loaded from the data bus.</p>

<p>The <code>_z80_refresh()</code> function sets the pins for a refresh cycle (<code>MREQ|RFSH</code>)
and the address bus pins to a 16-bit value formed from the I and R register
pair. The lower 7 bits in the R register are incremented, while the topmost bit
remains unchanged. The refresh cycle normally has no use in system emulators
apart from the side effect of the R register counting up (unless of course one
would like to implement “DRAM decay”).</p>

<p>The last clock cycle in the opcode fetch machine cycle branches to the
instruction payload by doing a table lookup with the previously loaded opcode
byte as index. Finally, the ‘effective address’ is preloaded with the content of
the HL register (which is only needed for instructions involving
<strong>(HL)</strong>).</p>

<h2 id="the-opcode-lookup-tables">The Opcode Lookup Tables</h2>

<p>Apart from the big switch-case decoder, three lookup tables of 256 entries each
are code-generated which are indexed with the opcode byte. The lookup yields the
decoder switch-case step of the instruction payload.</p>

<p>The three opcode tables are:</p>

<ul>
  <li>The main instruction block for unprefixed instructions.</li>
  <li>A variation of the main instruction block for DD/FD prefixed instructions,
this table is identical with the main table, except for instructions that involve 
<strong>(HL)</strong>: those are modified into <strong>(IX+d)</strong> or <strong>(IY+d)</strong> and need to branch to an 
‘interlude decoder block’ which loads the d-offset and computes the effective address
before continuing with the actual instruction payload.</li>
  <li>And finally a separate opcode lookup table for the <strong>ED</strong> prefixed instructions.</li>
</ul>

<p>One would expect a fourth table for the CB-prefixed instruction block, but
since this instruction block can easily be decoded algorithmically I decided to
handle this as a special case.</p>

<p>Opcode tables are just simple uint16_t arrays:</p>

<div><div><pre><code><span>static</span> <span>const</span> <span>uint16_t</span> <span>_z80_optable</span><span>[</span><span>256</span><span>]</span> <span>=</span> <span>{</span>
      <span>27</span><span>,</span>  <span>// 00: NOP (M:1 T:4 steps:1)</span>
      <span>28</span><span>,</span>  <span>// 01: LD BC,nn (M:3 T:10 steps:7)</span>
      <span>35</span><span>,</span>  <span>// 02: LD (BC),A (M:2 T:7 steps:4)</span>
      <span>39</span><span>,</span>  <span>// 03: INC BC (M:2 T:6 steps:3)</span>
      <span>42</span><span>,</span>  <span>// 04: INC B (M:1 T:4 steps:1)</span>
      <span>43</span><span>,</span>  <span>// 05: DEC B (M:1 T:4 steps:1)</span>
      <span>44</span><span>,</span>  <span>// 06: LD B,n (M:2 T:7 steps:4)</span>
      <span>48</span><span>,</span>  <span>// 07: RLCA (M:1 T:4 steps:1)</span>
      <span>...</span>
     <span>930</span><span>,</span>  <span>// FC: CALL M,nn (M:6 T:17 steps:14)</span>
     <span>944</span><span>,</span>  <span>// FD: FD prefix (M:1 T:4 steps:1)</span>
     <span>945</span><span>,</span>  <span>// FE: CP n (M:2 T:7 steps:4)</span>
     <span>949</span><span>,</span>  <span>// FF: RST 38h (M:4 T:11 steps:8)</span>
 <span>};</span>      
</code></pre></div></div>

<p>The stored step index is the actual decoder step - 1, because the decoder step
is ‘post-incremented’ in the tick function epilogue. For instance the <strong>LD
BC,nn</strong> instruction which has the opcode byte <strong>0x01</strong> has the decoder
step <strong>28</strong> stored in the opcode table, which - post-incremented by one -
points to the instruction payload block at decoder step <strong>29</strong>:</p>

<div><div><pre><code>        <span>//  01: LD BC,nn (M:3 T:10)</span>
        <span>// -- mread</span>
        <span>case</span>   <span>29</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>   <span>30</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>   <span>31</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>c</span><span>=</span><span>_gd</span><span>();</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mread</span>
        <span>case</span>   <span>32</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>   <span>33</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>   <span>34</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>b</span><span>=</span><span>_gd</span><span>();</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- overlapped</span>
        <span>case</span>   <span>35</span><span>:</span> <span>goto</span> <span>fetch_next</span><span>;</span>
</code></pre></div></div>

<h2 id="the-3-tick-function-epilogues">The 3 Tick Function Epilogues</h2>

<p>…about all those <strong>gotos</strong>: the epilogue at the end of the <strong>z80_tick()</strong> function looks like this:</p>

<div><div><pre><code><span>fetch_next:</span> <span>pins</span> <span>=</span> <span>_z80_fetch</span><span>(</span><span>cpu</span><span>,</span> <span>pins</span><span>);</span>
<span>step_next</span><span>:</span>  <span>cpu</span><span>-&gt;</span><span>step</span> <span>+=</span> <span>1</span><span>;</span>
<span>track_int_bits</span><span>:</span> <span>{</span>
        <span>// track NMI 0 =&gt; 1 edge and current INT pin state, this will track the</span>
        <span>// relevant interrupt status up to the last instruction cycle and will</span>
        <span>// be checked in the first M1 cycle (during _fetch)</span>
        <span>const</span> <span>uint64_t</span> <span>rising_nmi</span> <span>=</span> <span>(</span><span>pins</span> <span>^</span> <span>cpu</span><span>-&gt;</span><span>pins</span><span>)</span> <span>&amp;</span> <span>pins</span><span>;</span> <span>// NMI 0 =&gt; 1</span>
        <span>cpu</span><span>-&gt;</span><span>pins</span> <span>=</span> <span>pins</span><span>;</span>
        <span>cpu</span><span>-&gt;</span><span>int_bits</span> <span>=</span> <span>((</span><span>cpu</span><span>-&gt;</span><span>int_bits</span> <span>|</span> <span>rising_nmi</span><span>)</span> <span>&amp;</span> <span>Z80_NMI</span><span>)</span> <span>|</span> <span>(</span><span>pins</span> <span>&amp;</span> <span>Z80_INT</span><span>);</span>
    <span>}</span>
    <span>return</span> <span>pins</span><span>;</span>
</code></pre></div></div>

<p>There are 3 ‘cascaded’ labels which fall through to the next label. Let’s start at the
last label:</p>

<p>The main job of the code block under <strong>track_int_bits:</strong> is to track the NMI and
INT pins for interrupt detection. More on this later in a dedicated section about
interrupt handling. The interrupt pin tracking needs to happen in every clock cycle,
that’s why it is in the last fallthrough position.</p>

<p>Next up is the <strong>step_next:</strong> label. This simply increments the step counter by 1
and needs to happen in each clock cycle, <em>unless</em> the CPU is executing WAIT cycles.</p>

<p>And finally the <strong>fetch_next:</strong> label initiates an opcode fetch for the next instruction.</p>

<p>The reason why those shared epilogue code blocks and gotos exist is ‘manual
code deduplication’. It would just as well be possible to add those code blocks
to each case branch, but that’s a lot of duplicated code. A smart compiler
might be able to do the same deduplication, but depending on this was a bit
beyond my personal “acceptable compiler magic” threshold.</p>

<h2 id="more-on-wait-cycles">More on Wait Cycles</h2>

<p>Machine cycles which access memory or IO ports need to sample the WAIT pin in
specific clock cycles. If the WAIT pin is active, the CPU stops regular
execution until the WAIT pin goes inactive again. This allows
the CPU to wait for slow memory or peripheral devices, but in some computer
systems (like the Amstrad CPC) wait cycles are used to synchronize memory access
between the CPU and video hardware, which is why it is important to get the wait
timing right.</p>

<p>In the emulation, a <strong>_wait()</strong> macro is inserted at the start of case branches
where the WAIT pin needs to be sampled. In regular memory read and write
machine cycles this is the second clock cycle, and in IO read or write machine
cycles the third clock cycle. Wait sampling also needs to happen during
opcode fetch, and in interrupt acknowledge cycles.</p>

<p>Here’s for example a typical memory read machine cycle:</p>

<div><div><pre><code>        <span>case</span> <span>17</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>18</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>19</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>dlatch</span><span>=</span><span>_gd</span><span>();</span> <span>goto</span> <span>step_next</span><span>;</span>
</code></pre></div></div>

<p>The <strong>_wait()</strong> macro simply expands to:</p>

<div><div><pre><code><span>if</span> <span>(</span><span>pins</span> <span>&amp;</span> <span>Z80_WAIT</span><span>)</span> <span>{</span>
    <span>goto</span> <span>track_int_bits</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Jumping to the <code>track_int_bits:</code> epilogue label skips the decoder step increment, so
the next time the <code>z80_tick()</code> function is called, execution continues at
the same case-branch which first checks the WAIT pin state. Only when the WAIT
pin is no longer active, regular execution continues.</p>

<h2 id="instructions-with-variable-timing">Instructions with Variable Timing</h2>

<p>Some conditional branch instructions take less cycles to execute if the branch is
not taken, for instance the conditional relative branch instruction <strong>JR cc,d</strong>.</p>

<p>If the condition is true (branch taken) the instruction takes 12 clock cycles, but
if the branch is not taken only 7 clock cycles.</p>

<p>In the emulation this is implemented by skipping to the overlapped clock cycle at
the end of the instruction payload (look at <strong>case 176</strong>):</p>

<div><div><pre><code>        <span>//  28: JR Z,d (M:3 T:12)</span>
        <span>// -- mread</span>
        <span>case</span>  <span>174</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>  <span>175</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>  <span>176</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>dlatch</span><span>=</span><span>_gd</span><span>();</span><span>if</span><span>(</span><span>!</span><span>(</span><span>_cc_z</span><span>)){</span><span>_skip</span><span>(</span><span>5</span><span>);};</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- generic</span>
        <span>case</span>  <span>177</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>pc</span><span>+=</span><span>(</span><span>int8_t</span><span>)</span><span>cpu</span><span>-&gt;</span><span>dlatch</span><span>;</span><span>cpu</span><span>-&gt;</span><span>wz</span><span>=</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>;</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>  <span>178</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>  <span>179</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>  <span>180</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>  <span>181</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- overlapped</span>
        <span>case</span>  <span>182</span><span>:</span> <span>goto</span> <span>fetch_next</span><span>;</span>
</code></pre></div></div>

<p>The <strong>_skip(5)</strong> macro in step 176 simply expands to:</p>



<h2 id="the-overlapped-clock-cycle-in-more-detail">The ‘Overlapped Clock Cycle’ in more Detail</h2>

<p>The last clock cycle in an instruction decoder block (which is actually the first clock
cycle of the next opcode fetch machine cycle) mainly sets the CPU pins to load the
next opcode byte:</p>

<ul>
  <li>The <code>M1|MREQ|RD</code> pins are set.</li>
  <li>The address bus is loaded with the program counter and the program counter is incremented.</li>
  <li>The decoder step is set to 0xFFFF, which will overflow to 0 when the  step counter is incremented at the end of the tick function so that in the next tick function call execution continues at the first step of the shared opcode fetch decoder block.</li>
</ul>

<p>The other important thing that needs to happen in the overlapped clock cycle is
interrupt detection. On a real Z80, interrupt detection happens in the last
clock cycle of an instruction, but in the emulator it made more sense to move
the interrupt detection code out of the instruction-specific payload block
and into the shared opcode fetch preparation code.</p>

<p>Interrupt handling will be explained in more details later in the blog post.</p>

<h2 id="ddfd-prefix-handling">DD/FD Prefix Handling</h2>

<p>The <strong>DD</strong> and <strong>FD</strong> opcodes execute as regular 4-cycle instructions, but with a slightly
modified overlapped clock cycle: Instead of jumping to the common <code>fetch_next:</code> label
a special opcode fetch is initiated:</p>

<div><div><pre><code>        <span>//  DD: DD prefix (M:1 T:4)</span>
        <span>// -- overlapped</span>
        <span>case</span>  <span>726</span><span>:</span> <span>_fetch_dd</span><span>();</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>...</span>
        <span>//  FD: FD prefix (M:1 T:4)</span>
        <span>// -- overlapped</span>
        <span>case</span>  <span>945</span><span>:</span> <span>_fetch_fd</span><span>();</span><span>goto</span> <span>step_next</span><span>;</span>        
</code></pre></div></div>

<p>The macros _fetch_dd() and _fetch_fd() expand to functions calls:</p>

<div><div><pre><code><span>#define _fetch_dd()     pins=_z80_fetch_dd(cpu,pins);
#define _fetch_fd()     pins=_z80_fetch_fd(cpu,pins);
</span></code></pre></div></div>

<p>…which in turn look like this:</p>

<div><div><pre><code><span>static</span> <span>inline</span> <span>uint64_t</span> <span>_z80_fetch_dd</span><span>(</span><span>z80_t</span><span>*</span> <span>cpu</span><span>,</span> <span>uint64_t</span> <span>pins</span><span>)</span> <span>{</span>
    <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>2</span><span>;</span>   <span>// =&gt; step 3: opcode fetch for DD/FD prefixed instructions</span>
    <span>cpu</span><span>-&gt;</span><span>hlx_idx</span> <span>=</span> <span>1</span><span>;</span>
    <span>cpu</span><span>-&gt;</span><span>prefix_active</span> <span>=</span> <span>true</span><span>;</span>
    <span>return</span> <span>_z80_set_ab_x</span><span>(</span><span>pins</span><span>,</span> <span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>,</span> <span>Z80_M1</span><span>|</span><span>Z80_MREQ</span><span>|</span><span>Z80_RD</span><span>);</span>
<span>}</span>

<span>static</span> <span>inline</span> <span>uint64_t</span> <span>_z80_fetch_fd</span><span>(</span><span>z80_t</span><span>*</span> <span>cpu</span><span>,</span> <span>uint64_t</span> <span>pins</span><span>)</span> <span>{</span>
    <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>2</span><span>;</span>   <span>// =&gt; step 3: opcode fetch for DD/FD prefixed instructions</span>
    <span>cpu</span><span>-&gt;</span><span>hlx_idx</span> <span>=</span> <span>2</span><span>;</span>
    <span>cpu</span><span>-&gt;</span><span>prefix_active</span> <span>=</span> <span>true</span><span>;</span>
    <span>return</span> <span>_z80_set_ab_x</span><span>(</span><span>pins</span><span>,</span> <span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>,</span> <span>Z80_M1</span><span>|</span><span>Z80_MREQ</span><span>|</span><span>Z80_RD</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>The first important difference to the regular _z80_fetch() function is that no
interrupt detection happens (because interrupts are not handled after fetching
prefix bytes).</p>

<p><code>prefix_active</code> can be ignored, this is only used by
the helper function <code>z80_opdone()</code> to test whether an instruction has finished
executing (which is only needed for test code or implementing debuggers).</p>

<p>The returned pinmask is identical with a regular opcode fetch: The pins <code>M1|MREQ|RD</code>
are set to active, and the program counter is put on the address bus and incremented.</p>

<p>The <strong>hlx_idx</strong> index is used for the HL =&gt; IX/IY register-renaming taking
place in DD/FD prefixed instructions through the following somewhat scary
nested union in struct <strong>z80_t</strong>:</p>

<div><div><pre><code>    <span>union</span> <span>{</span>
        <span>struct</span> <span>{</span>
            <span>union</span> <span>{</span> <span>struct</span> <span>{</span> <span>uint8_t</span> <span>l</span><span>;</span> <span>uint8_t</span> <span>h</span><span>;</span> <span>};</span> <span>uint16_t</span> <span>hl</span><span>;</span> <span>};</span>
            <span>union</span> <span>{</span> <span>struct</span> <span>{</span> <span>uint8_t</span> <span>ixl</span><span>;</span> <span>uint8_t</span> <span>ixh</span><span>;</span> <span>};</span> <span>uint16_t</span> <span>ix</span><span>;</span> <span>};</span>
            <span>union</span> <span>{</span> <span>struct</span> <span>{</span> <span>uint8_t</span> <span>iyl</span><span>;</span> <span>uint8_t</span> <span>iyh</span><span>;</span> <span>};</span> <span>uint16_t</span> <span>iy</span><span>;</span> <span>};</span>
        <span>};</span>
        <span>struct</span> <span>{</span> <span>union</span> <span>{</span> <span>struct</span> <span>{</span> <span>uint8_t</span> <span>l</span><span>;</span> <span>uint8_t</span> <span>h</span><span>;</span> <span>};</span> <span>uint16_t</span> <span>hl</span><span>;</span> <span>};</span> <span>}</span> <span>hlx</span><span>[</span><span>3</span><span>];</span>
    <span>};</span>
</code></pre></div></div>

<p>The upper part allows to directly access the 8-bit registers L, H, IXL, IXH, IYL and IYH, or the
16-bit register pairs HL, IX and IY.</p>

<p>The <strong>hlx[3]</strong> array allows to access the same registers through an index:</p>

<div><div><pre><code>    <span>cpu</span><span>-&gt;</span><span>hlx</span><span>[</span><span>0</span><span>].</span><span>l</span> <span>=&gt;</span> <span>L</span>
    <span>cpu</span><span>-&gt;</span><span>hlx</span><span>[</span><span>0</span><span>].</span><span>h</span> <span>=&gt;</span> <span>H</span>
    <span>cpu</span><span>-&gt;</span><span>hlz</span><span>[</span><span>0</span><span>].</span><span>hl</span> <span>=&gt;</span> <span>HL</span>

    <span>cpu</span><span>-&gt;</span><span>hlx</span><span>[</span><span>1</span><span>].</span><span>l</span> <span>=&gt;</span> <span>IXL</span>
    <span>cpu</span><span>-&gt;</span><span>hlx</span><span>[</span><span>1</span><span>].</span><span>h</span> <span>=&gt;</span> <span>IXH</span>
    <span>cpu</span><span>-&gt;</span><span>hlz</span><span>[</span><span>1</span><span>].</span><span>hl</span> <span>=&gt;</span> <span>IX</span>

    <span>cpu</span><span>-&gt;</span><span>hlx</span><span>[</span><span>2</span><span>].</span><span>l</span> <span>=&gt;</span> <span>IYL</span>
    <span>cpu</span><span>-&gt;</span><span>hlx</span><span>[</span><span>2</span><span>].</span><span>h</span> <span>=&gt;</span> <span>IYH</span>
    <span>cpu</span><span>-&gt;</span><span>hlz</span><span>[</span><span>2</span><span>].</span><span>hl</span> <span>=&gt;</span> <span>IY</span>
</code></pre></div></div>

<p>For regular, unprefixed instructions the register renaming index (<strong>hlx_idx</strong>) is set to 0, so that register pair HL is accessed.</p>

<p>For DD-prefixed instruction the index is set to 1, which accesses IX, and for FD-prefixed instructions
the index is set to 2, which accesses IY.</p>

<p>Instructions which ignore the HL/IX/IY register renaming (such as <strong>EX HL,DE</strong>) simply access the
item <strong>cpu-&gt;hl</strong> directly without going through the <strong>cpu-&gt;hlx[cpu-&gt;hlx_idx]</strong> indirection.</p>

<p>The last and most important difference to a regular opcode fetch is that the
decoder step is set to <strong>2</strong> instead of <strong>0xFFFF</strong>. This means that on the next
call to the tick function, execution continues not at the regular shared opcode
fetch decoder block, but at a special decoder block at step <strong>3</strong>:</p>

<div><div><pre><code>        <span>//=== shared fetch machine cycle for DD/FD-prefixed ops</span>
        <span>// M1/T2: load opcode from data bus</span>
        <span>case</span> <span>3</span><span>:</span> <span>_wait</span><span>();</span> <span>cpu</span><span>-&gt;</span><span>opcode</span> <span>=</span> <span>_gd</span><span>();</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// M1/T3: refresh cycle</span>
        <span>case</span> <span>4</span><span>:</span> <span>pins</span> <span>=</span> <span>_z80_refresh</span><span>(</span><span>cpu</span><span>,</span> <span>pins</span><span>);</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// M1/T4: branch to instruction payload</span>
        <span>case</span> <span>5</span><span>:</span> <span>{</span>
            <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>_z80_ddfd_optable</span><span>[</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>];</span>
            <span>cpu</span><span>-&gt;</span><span>addr</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>hlx</span><span>[</span><span>cpu</span><span>-&gt;</span><span>hlx_idx</span><span>].</span><span>hl</span><span>;</span>
        <span>}</span> <span>goto</span> <span>step_next</span><span>;</span>
</code></pre></div></div>

<p>The first difference to a regular opcode fetch is how the ‘effective address’ is preloaded in step 5:</p>

<p>Instead of loading <strong>addr</strong> with HL, the register renaming index <strong>hlx_idx</strong> is
used, which causes either the IX or IY register to be loaded into <strong>addr</strong>, depending
on the previously ‘executed’ prefix-byte instruction (DD or FD):</p>

<div><div><pre><code>    <span>cpu</span><span>-&gt;</span><span>addr</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>hlx</span><span>[</span><span>cpu</span><span>-&gt;</span><span>hlx_idx</span><span>].</span><span>hl</span><span>;</span>
</code></pre></div></div>

<p>The next difference is that the instruction payload step is looked up from
a different table: <strong>_z80_ddfd_optable[]</strong> instead of <strong>_z80_optable[]</strong>. The
<strong>_z80_ddfd_optable[]</strong> is identical to the regular optable, except for instructions
that involve <strong>(HL)</strong> which need to be modified to <strong>(IX+d)</strong> or <strong>(IY+d)</strong>.</p>

<p>Those instructions will ‘inject’ a decoder block after the opcode fetch machine
cycle which loads the <strong>d</strong> offset, adds it to the ‘effective address’, and
then continues to the original instruction decoder block:</p>

<div><div><pre><code>        <span>//=== optional d-loading cycle for (IX+d), (IY+d)</span>
        <span>//--- mread</span>
        <span>case</span> <span>6</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>7</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>8</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>addr</span> <span>+=</span> <span>(</span><span>int8_t</span><span>)</span><span>_gd</span><span>();</span> <span>cpu</span><span>-&gt;</span><span>wz</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>addr</span><span>;</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>//--- filler ticks</span>
        <span>case</span> <span>9</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>10</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>11</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>12</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>13</span><span>:</span> <span>{</span>
            <span>// branch to actual instruction</span>
            <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>_z80_optable</span><span>[</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>];</span>
        <span>}</span> <span>goto</span> <span>step_next</span><span>;</span>
</code></pre></div></div>

<p>All taken together this means that the instruction <strong>LD A,(IX+3)</strong> executes the
following decoder step sequence (starting with the opcode fetch for the DD prefix),
note how the execution jumps between entirely different parts of the decoder
switch-case statement:</p>

<div><div><pre><code>        <span>//=== shared fetch machine cycle for non-DD/FD-prefixed ops</span>
        <span>// M1/T2: load opcode from data bus</span>
        <span>case</span> <span>0</span><span>:</span> <span>_wait</span><span>();</span> <span>cpu</span><span>-&gt;</span><span>opcode</span> <span>=</span> <span>_gd</span><span>();</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// M1/T3: refresh cycle</span>
        <span>case</span> <span>1</span><span>:</span> <span>pins</span> <span>=</span> <span>_z80_refresh</span><span>(</span><span>cpu</span><span>,</span> <span>pins</span><span>);</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// M1/T4: branch to instruction payload</span>
        <span>case</span> <span>2</span><span>:</span> <span>{</span>
            <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>_z80_optable</span><span>[</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>];</span>
            <span>// preload effective address for (HL) ops</span>
            <span>cpu</span><span>-&gt;</span><span>addr</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>hl</span><span>;</span>
        <span>}</span> <span>goto</span> <span>step_next</span><span>;</span>

        <span>//  DD: DD prefix (M:1 T:4)</span>
        <span>// -- overlapped</span>
        <span>case</span>  <span>726</span><span>:</span> <span>_fetch_dd</span><span>();</span><span>goto</span> <span>step_next</span><span>;</span>

        <span>//=== shared fetch machine cycle for DD/FD-prefixed ops</span>
        <span>// M1/T2: load opcode from data bus</span>
        <span>case</span> <span>3</span><span>:</span> <span>_wait</span><span>();</span> <span>cpu</span><span>-&gt;</span><span>opcode</span> <span>=</span> <span>_gd</span><span>();</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// M1/T3: refresh cycle</span>
        <span>case</span> <span>4</span><span>:</span> <span>pins</span> <span>=</span> <span>_z80_refresh</span><span>(</span><span>cpu</span><span>,</span> <span>pins</span><span>);</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// M1/T4: branch to instruction payload</span>
        <span>case</span> <span>5</span><span>:</span> <span>{</span>
            <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>_z80_ddfd_optable</span><span>[</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>];</span>
            <span>cpu</span><span>-&gt;</span><span>addr</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>hlx</span><span>[</span><span>cpu</span><span>-&gt;</span><span>hlx_idx</span><span>].</span><span>hl</span><span>;</span>
        <span>}</span> <span>goto</span> <span>step_next</span><span>;</span>        

        <span>//=== optional d-loading cycle for (IX+d), (IY+d)</span>
        <span>//--- mread</span>
        <span>case</span> <span>6</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>7</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>8</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>addr</span> <span>+=</span> <span>(</span><span>int8_t</span><span>)</span><span>_gd</span><span>();</span> <span>cpu</span><span>-&gt;</span><span>wz</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>addr</span><span>;</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>//--- filler ticks</span>
        <span>case</span> <span>9</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>10</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>11</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>12</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>13</span><span>:</span> <span>{</span>
            <span>// branch to actual instruction</span>
            <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>_z80_optable</span><span>[</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>];</span>
        <span>}</span> <span>goto</span> <span>step_next</span><span>;</span>

        <span>//  7E: LD A,(HL) (M:2 T:7)</span>
        <span>// -- mread</span>
        <span>case</span>  <span>405</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>  <span>406</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>addr</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>  <span>407</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>a</span><span>=</span><span>_gd</span><span>();</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- overlapped</span>
        <span>case</span>  <span>408</span><span>:</span> <span>goto</span> <span>fetch_next</span><span>;</span>        
</code></pre></div></div>

<p>This adds up to 19 decoder steps or clock cycles, and that’s indeed the
duration of the <strong>LD A,(IX+d)</strong> instruction.</p>

<p>There is one special case in the <strong>_z80_ddfd_optable[]</strong> and that is the <strong>LD (HL),n</strong> instruction
which is modified to <strong>LD (IX+d),n</strong> or <strong>LD (IY+d),n</strong>. This is the only instruction which doesn’t
simply insert 8 clock cycles for loading the d-offset and computing the effective address, instead
it overlays the memory read machine cycle for loading the immediate value <strong>n</strong> over those 8 extra
clock cycles.</p>

<p>This is handled with a special d-loading decoder block, which then jumps into the middle of the
original <strong>LD (HL),n</strong> payload.</p>

<p>The special d/n-loading decoder block looks like this:</p>

<div><div><pre><code>        <span>//=== special case d-loading cycle for (IX+d),n where the immediate load</span>
        <span>//    is hidden in the d-cycle load</span>
        <span>//--- mread for d offset</span>
        <span>case</span> <span>14</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>15</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>16</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>addr</span> <span>+=</span> <span>(</span><span>int8_t</span><span>)</span><span>_gd</span><span>();</span> <span>cpu</span><span>-&gt;</span><span>wz</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>addr</span><span>;</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>//--- mread for n</span>
        <span>case</span> <span>17</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>18</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>19</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>dlatch</span><span>=</span><span>_gd</span><span>();</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>//--- filler tick</span>
        <span>case</span> <span>20</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>21</span><span>:</span> <span>{</span>
            <span>// branch to ld (hl),n and skip the original mread cycle for loading &#39;n&#39;</span>
            <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>_z80_optable</span><span>[</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>]</span> <span>+</span> <span>3</span><span>;</span>
        <span>}</span> <span>goto</span> <span>step_next</span><span>;</span>
</code></pre></div></div>

<p>…execution then continues at the memory write machine cycle of <strong>LD (HL),n</strong> which
writes the immediate value <strong>n</strong> back to the memory location defined by the 
‘effective address’:</p>

<div><div><pre><code>        <span>//  36: LD (HL),n (M:3 T:10)</span>
        <span>...</span>
        <span>// -- mwrite</span>
        <span>case</span>  <span>262</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>  <span>263</span><span>:</span> <span>_wait</span><span>();</span><span>_mwrite</span><span>(</span><span>cpu</span><span>-&gt;</span><span>addr</span><span>,</span><span>cpu</span><span>-&gt;</span><span>dlatch</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span>  <span>264</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- overlapped</span>
        <span>case</span>  <span>265</span><span>:</span> <span>goto</span> <span>fetch_next</span><span>;</span>
</code></pre></div></div>

<h2 id="ed-prefix-handling">ED Prefix Handling</h2>

<p>Just as the other prefix instructions, the <strong>ED</strong> instruction executes as regular 
4-clock-cycle instruction but calls into a special opcode fetch function in the overlapped
clock cycle:</p>

<div><div><pre><code>        <span>//  ED: ED prefix (M:1 T:4)</span>
        <span>// -- overlapped</span>
        <span>case</span>  <span>842</span><span>:</span> <span>_fetch_ed</span><span>();</span><span>goto</span> <span>step_next</span><span>;</span>
</code></pre></div></div>

<p>The <strong>_fetch_ed()</strong> macro expands to:</p>

<div><div><pre><code><span>static</span> <span>inline</span> <span>uint64_t</span> <span>_z80_fetch_ed</span><span>(</span><span>z80_t</span><span>*</span> <span>cpu</span><span>,</span> <span>uint64_t</span> <span>pins</span><span>)</span> <span>{</span>
    <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>24</span><span>;</span> <span>// =&gt; step 25: opcode fetch for ED prefixed instructions</span>
    <span>cpu</span><span>-&gt;</span><span>hlx_idx</span> <span>=</span> <span>0</span><span>;</span>
    <span>cpu</span><span>-&gt;</span><span>prefix_active</span> <span>=</span> <span>true</span><span>;</span>
    <span>return</span> <span>_z80_set_ab_x</span><span>(</span><span>pins</span><span>,</span> <span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>,</span> <span>Z80_M1</span><span>|</span><span>Z80_MREQ</span><span>|</span><span>Z80_RD</span><span>);</span>
<span>}</span>
</code></pre></div></div>
<p>This looks very much like the <strong>_z80_fetch_ddfd()</strong> function above. No interrupts
are handled, the decoder step is set to a special opcode fetch machine cycle and
the returned pin mask initiates a standard opcode fetch.</p>

<p>The <strong>hlx_idx</strong> register renaming index is reset to zero. This means that the <strong>ED</strong>
prefix cancels the effect of the <strong>DD</strong> and <strong>FD</strong> prefixes (e.g. HL is <em>never</em> renamed to
IX or IY in ED-prefixed instructions).</p>

<p>The special <strong>ED</strong> opcode fetch machine cycle uses a different opcode lookup table
<strong>_z80_ed_optable[]</strong>, this points to all the ED-prefixed instruction payload steps:</p>

<div><div><pre><code>        <span>//=== special opcode fetch machine cycle for ED-prefixed instructions</span>
        <span>// M1/T2: load opcode from data bus</span>
        <span>case</span> <span>25</span><span>:</span> <span>_wait</span><span>();</span> <span>cpu</span><span>-&gt;</span><span>opcode</span> <span>=</span> <span>_gd</span><span>();</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// M1/T3: refresh cycle</span>
        <span>case</span> <span>26</span><span>:</span> <span>pins</span> <span>=</span> <span>_z80_refresh</span><span>(</span><span>cpu</span><span>,</span> <span>pins</span><span>);</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// M1/T4: branch to instruction payload</span>
        <span>case</span> <span>27</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>_z80_ed_optable</span><span>[</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>];</span> <span>goto</span> <span>step_next</span><span>;</span>
</code></pre></div></div>

<h2 id="cb-prefix-handling">CB Prefix Handling</h2>

<p><strong>CB</strong> prefix handling starts like the other prefixes: with a separate fetch
macro in the overlapped step:</p>

<div><div><pre><code>        <span>//  CB: CB prefix (M:1 T:4)</span>
        <span>// -- overlapped</span>
        <span>case</span>  <span>583</span><span>:</span> <span>_fetch_cb</span><span>();</span><span>goto</span> <span>step_next</span><span>;</span>
</code></pre></div></div>

<p>The macro <strong>_fetch_cb()</strong> wraps this function:</p>

<div><div><pre><code><span>static</span> <span>inline</span> <span>uint64_t</span> <span>_z80_fetch_cb</span><span>(</span><span>z80_t</span><span>*</span> <span>cpu</span><span>,</span> <span>uint64_t</span> <span>pins</span><span>)</span> <span>{</span>
    <span>cpu</span><span>-&gt;</span><span>prefix_active</span> <span>=</span> <span>true</span><span>;</span>
    <span>if</span> <span>(</span><span>cpu</span><span>-&gt;</span><span>hlx_idx</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>// this is a DD+CB / FD+CB instruction, continue</span>
        <span>// execution on the special DDCB/FDCB decoder block which</span>
        <span>// loads the d-offset first and then the opcode in a </span>
        <span>// regular memory read machine cycle</span>
        <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>_z80_special_optable</span><span>[</span><span>_Z80_OPSTATE_SLOT_DDFDCB</span><span>];</span>
    <span>}</span>
    <span>else</span> <span>{</span>
        <span>// this is a regular CB-prefixed instruction, continue</span>
        <span>// execution on a special fetch machine cycle which doesn&#39;t</span>
        <span>// handle DD/FD prefix and then branches either to the</span>
        <span>// special CB or CBHL decoder block</span>
        <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>21</span><span>;</span> <span>// =&gt; step 22: opcode fetch for CB prefixed instructions</span>
        <span>pins</span> <span>=</span> <span>_z80_set_ab_x</span><span>(</span><span>pins</span><span>,</span> <span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>,</span> <span>Z80_M1</span><span>|</span><span>Z80_MREQ</span><span>|</span><span>Z80_RD</span><span>);</span>
    <span>}</span>
    <span>return</span> <span>pins</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>…this however looks quite a bit different than the <strong>DD/FD</strong> or <strong>ED</strong> prefixes!</p>

<p>Long story short: since the CB-prefixed instruction block is very ‘orderly’
(see my previous <a href="https://floooh.github.io/2021/12/06/z80-instruction-timing.html#cb-prefix">blog post for
details</a>)
I decided to decode the entire CB instruction block in a single function and a
handful of special instruction decoder blocks.</p>

<p>For instance all CB-prefixed instructions that don’t involve <strong>(HL)</strong> execute the following
sequence of decoder steps:</p>

<div><div><pre><code>        <span>//=== special opcode fetch machine cycle for CB-prefixed instructions</span>
        <span>case</span> <span>22</span><span>:</span> <span>_wait</span><span>();</span> <span>cpu</span><span>-&gt;</span><span>opcode</span> <span>=</span> <span>_gd</span><span>();</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>23</span><span>:</span> <span>pins</span> <span>=</span> <span>_z80_refresh</span><span>(</span><span>cpu</span><span>,</span> <span>pins</span><span>);</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>24</span><span>:</span> <span>{</span>
            <span>if</span> <span>((</span><span>cpu</span><span>-&gt;</span><span>opcode</span> <span>&amp;</span> <span>7</span><span>)</span> <span>==</span> <span>6</span><span>)</span> <span>{</span>
                <span>// not taken:</span>
                <span>// this is a (HL) instruction</span>
                <span>...</span>
            <span>}</span>
            <span>else</span> <span>{</span>
                <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>_z80_special_optable</span><span>[</span><span>_Z80_OPSTATE_SLOT_CB</span><span>];</span>
            <span>}</span>
        <span>}</span> <span>goto</span> <span>step_next</span><span>;</span>

        <span>...</span>

        <span>// CB 00: cb (M:1 T:4)</span>
        <span>// -- overlapped</span>
        <span>case</span> <span>1437</span><span>:</span> <span>{</span><span>uint8_t</span> <span>z</span><span>=</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>&amp;</span><span>7</span><span>;</span><span>_z80_cb_action</span><span>(</span><span>cpu</span><span>,</span><span>z</span><span>,</span><span>z</span><span>);};</span><span>goto</span> <span>fetch_next</span><span>;</span>
</code></pre></div></div>

<p><strong>_z80_cb_action()</strong> is the magic function which decodes and implements all Z80 instructions
in the CB-prefix instruction block (here’s the <a href="https://github.com/floooh/chips/blob/b46addd0461fa26fb91037ac431f5316748ab060/chips/z80.h#L771-L838">implementation</a>).</p>

<p>CB-prefixed instructions which involve <strong>(HL)</strong> have a more complex payload for reading and
(optionally) writing back the operand:</p>

<div><div><pre><code>        <span>//=== special opcode fetch machine cycle for CB-prefixed instructions</span>
        <span>case</span> <span>22</span><span>:</span> <span>_wait</span><span>();</span> <span>cpu</span><span>-&gt;</span><span>opcode</span> <span>=</span> <span>_gd</span><span>();</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>23</span><span>:</span> <span>pins</span> <span>=</span> <span>_z80_refresh</span><span>(</span><span>cpu</span><span>,</span> <span>pins</span><span>);</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>24</span><span>:</span> <span>{</span>
            <span>if</span> <span>((</span><span>cpu</span><span>-&gt;</span><span>opcode</span> <span>&amp;</span> <span>7</span><span>)</span> <span>==</span> <span>6</span><span>)</span> <span>{</span>
                <span>// this is a (HL) instruction</span>
                <span>cpu</span><span>-&gt;</span><span>addr</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>hl</span><span>;</span>
                <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>_z80_special_optable</span><span>[</span><span>_Z80_OPSTATE_SLOT_CBHL</span><span>];</span>
            <span>}</span>
            <span>else</span> <span>{</span>
                <span>// not taken</span>
                <span>...</span>
            <span>}</span>
        <span>}</span> <span>goto</span> <span>step_next</span><span>;</span>

        <span>...</span>

        <span>// CB 00: cbhl (M:3 T:11)</span>
        <span>// -- mread</span>
        <span>case</span> <span>1438</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1439</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>hl</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1440</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>dlatch</span><span>=</span><span>_gd</span><span>();</span><span>if</span><span>(</span><span>!</span><span>_z80_cb_action</span><span>(</span><span>cpu</span><span>,</span><span>6</span><span>,</span><span>6</span><span>)){</span><span>_skip</span><span>(</span><span>3</span><span>);};</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1441</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mwrite</span>
        <span>case</span> <span>1442</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1443</span><span>:</span> <span>_wait</span><span>();</span><span>_mwrite</span><span>(</span><span>cpu</span><span>-&gt;</span><span>hl</span><span>,</span><span>cpu</span><span>-&gt;</span><span>dlatch</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1444</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- overlapped</span>
        <span>case</span> <span>1445</span><span>:</span> <span>goto</span> <span>fetch_next</span><span>;</span>        
</code></pre></div></div>

<p>The memory write machine cycle which writes back the result is skipped if the <strong>_z80_cb_action()</strong>
function returns true (which happens if this is a bit-testing instruction).</p>

<p>Finally, the weird <strong>DD/FD + CB</strong> <a href="https://floooh.github.io/2021/12/06/z80-instruction-timing.html#dd-cb-and-fd-cb-prefix">double-prefixed instructions</a> are handled through another special decoder block which looks like this:</p>

<div><div><pre><code>        <span>// CB 00: ddfdcb (M:6 T:18)</span>
        <span>// -- generic</span>
        <span>case</span> <span>1446</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- generic</span>
        <span>case</span> <span>1447</span><span>:</span> <span>_z80_ddfdcb_addr</span><span>(</span><span>cpu</span><span>,</span><span>pins</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mread</span>
        <span>case</span> <span>1448</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1449</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1450</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>opcode</span><span>=</span><span>_gd</span><span>();</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1451</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1452</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mread</span>
        <span>case</span> <span>1453</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1454</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>addr</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1455</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>dlatch</span><span>=</span><span>_gd</span><span>();</span><span>if</span><span>(</span><span>!</span><span>_z80_cb_action</span><span>(</span><span>cpu</span><span>,</span><span>6</span><span>,</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>&amp;</span><span>7</span><span>)){</span><span>_skip</span><span>(</span><span>3</span><span>);};</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1456</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mwrite</span>
        <span>case</span> <span>1457</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1458</span><span>:</span> <span>_wait</span><span>();</span><span>_mwrite</span><span>(</span><span>cpu</span><span>-&gt;</span><span>addr</span><span>,</span><span>cpu</span><span>-&gt;</span><span>dlatch</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1459</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- overlapped</span>
        <span>case</span> <span>1460</span><span>:</span> <span>goto</span> <span>fetch_next</span><span>;</span>
</code></pre></div></div>

<p>This needs some explanation:</p>

<p>Instead of a regular opcode fetch machine cycle, execution starts with a memory
read machine cycle (just the last two cycles because the previous step was the
usual overlapped clock cycle of the CB prefix).</p>

<p>This memory read machine cycle loads the d-offset and then computes the
effective address <strong>(IX+d)</strong> or <strong>(IY+d)</strong> in the helper function
<strong>_z80_ddfdcb_addr()</strong>:</p>

<div><div><pre><code><span>// compute the effective memory address for DD+CB/FD+CB instructions</span>
<span>static</span> <span>inline</span> <span>void</span> <span>_z80_ddfdcb_addr</span><span>(</span><span>z80_t</span><span>*</span> <span>cpu</span><span>,</span> <span>uint64_t</span> <span>pins</span><span>)</span> <span>{</span>
    <span>uint8_t</span> <span>d</span> <span>=</span> <span>_z80_get_db</span><span>(</span><span>pins</span><span>);</span>
    <span>cpu</span><span>-&gt;</span><span>addr</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>hlx</span><span>[</span><span>cpu</span><span>-&gt;</span><span>hlx_idx</span><span>].</span><span>hl</span> <span>+</span> <span>(</span><span>int8_t</span><span>)</span><span>d</span><span>;</span>
    <span>cpu</span><span>-&gt;</span><span>wz</span> <span>=</span> <span>cpu</span><span>-&gt;</span><span>addr</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Next in <strong>step 1448</strong>, a regular memory read machine cycle loads the actual opcode
byte into <code>cpu-&gt;opcode</code> (so the opcode byte isn’t loaded with an opcode
fetch machine cycle, but instead with a memory read machine cycle - this is
also why the R register is only incremented twice during a DD/FD+CB
instruction: there are only two ‘proper’ opcode fetch machine cycles for the
DD/FD prefix and the CB prefix).</p>

<p>The next memory read machine cycle loads the operand byte from the effective
address (IX+d or IY+d), and performs the actual payload action of the
instruction in the <strong>_z80_cb_action()</strong> function, which will also write the
result into a register if needed (this is the case for the undocumented
instructions which write the result both into a register and to memory). If the
instruction was a bit-testing instruction, the following memory write machine
cycle is skipped.</p>

<h2 id="interrupt-detection">Interrupt Detection</h2>

<p>On a real Z80, interrupts are detected in the last clock cycle of an instruction
(<a href="https://floooh.github.io/2021/12/06/z80-instruction-timing.html#interrupt-detection-timing">details are explained here</a>).</p>

<p>In the emulation, the tick function epilogue keeps track of the interrupt pins in each clock cycle.
Doing this in each clock cycle is required for NMI detection: NMIs are edge-triggered, meaning
an NMI is triggered if the NMI pin goes active for at least one cycle (on the real hardware:
one <em>half</em>-cycle) <em>anywhere</em> in an instruction. E.g. the NMI pin doesn’t need to be active anymore
in the last clock cycle for an NMI to be triggered.</p>

<div><div><pre><code><span>track_int_bits:</span> <span>{</span>
        <span>// track NMI 0 =&gt; 1 edge and current INT pin state, this will track the</span>
        <span>// relevant interrupt status up to the last instruction cycle and will</span>
        <span>// be checked in the first M1 cycle (during _fetch)</span>
        <span>const</span> <span>uint64_t</span> <span>rising_nmi</span> <span>=</span> <span>(</span><span>pins</span> <span>^</span> <span>cpu</span><span>-&gt;</span><span>pins</span><span>)</span> <span>&amp;</span> <span>pins</span><span>;</span> <span>// NMI 0 =&gt; 1</span>
        <span>cpu</span><span>-&gt;</span><span>pins</span> <span>=</span> <span>pins</span><span>;</span>
        <span>cpu</span><span>-&gt;</span><span>int_bits</span> <span>=</span> <span>((</span><span>cpu</span><span>-&gt;</span><span>int_bits</span> <span>|</span> <span>rising_nmi</span><span>)</span> <span>&amp;</span> <span>Z80_NMI</span><span>)</span> <span>|</span> <span>(</span><span>pins</span> <span>&amp;</span> <span>Z80_INT</span><span>);</span>
    <span>}</span>
</code></pre></div></div>

<p>The <code>cpu-&gt;int_bits</code> state is then checked in the overlapped clock cycle in
the <strong>_z80_fetch()</strong> function. Technically this is one clock cycle too late,
but since the interrupt pin state has been stored in the last
tick function call, interrupt timing is correct nonetheless.</p>

<p>The complete <strong>_z80_fetch()</strong> function looks like this:</p>

<div><div><pre><code><span>// initiate a fetch machine cycle for regular (non-prefixed) instructions, or initiate interrupt handling</span>
<span>static</span> <span>inline</span> <span>uint64_t</span> <span>_z80_fetch</span><span>(</span><span>z80_t</span><span>*</span> <span>cpu</span><span>,</span> <span>uint64_t</span> <span>pins</span><span>)</span> <span>{</span>
    <span>cpu</span><span>-&gt;</span><span>hlx_idx</span> <span>=</span> <span>0</span><span>;</span>
    <span>cpu</span><span>-&gt;</span><span>prefix_active</span> <span>=</span> <span>false</span><span>;</span>
    <span>// shortcut no interrupts requested</span>
    <span>if</span> <span>(</span><span>cpu</span><span>-&gt;</span><span>int_bits</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>0xFFFF</span><span>;</span>
        <span>return</span> <span>_z80_set_ab_x</span><span>(</span><span>pins</span><span>,</span> <span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>,</span> <span>Z80_M1</span><span>|</span><span>Z80_MREQ</span><span>|</span><span>Z80_RD</span><span>);</span>
    <span>}</span>
    <span>else</span> <span>if</span> <span>(</span><span>cpu</span><span>-&gt;</span><span>int_bits</span> <span>&amp;</span> <span>Z80_NMI</span><span>)</span> <span>{</span>
        <span>// non-maskable interrupt starts with a regular M1 machine cycle</span>
        <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>_z80_special_optable</span><span>[</span><span>_Z80_OPSTATE_SLOT_NMI</span><span>];</span>
        <span>cpu</span><span>-&gt;</span><span>int_bits</span> <span>=</span> <span>0</span><span>;</span>
        <span>if</span> <span>(</span><span>pins</span> <span>&amp;</span> <span>Z80_HALT</span><span>)</span> <span>{</span>
            <span>pins</span> <span>&amp;=</span> <span>~</span><span>Z80_HALT</span><span>;</span>
            <span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>;</span>
        <span>}</span>
        <span>// NOTE: PC is *not* incremented!</span>
        <span>return</span> <span>_z80_set_ab_x</span><span>(</span><span>pins</span><span>,</span> <span>cpu</span><span>-&gt;</span><span>pc</span><span>,</span> <span>Z80_M1</span><span>|</span><span>Z80_MREQ</span><span>|</span><span>Z80_RD</span><span>);</span>
    <span>}</span>
    <span>else</span> <span>if</span> <span>(</span><span>cpu</span><span>-&gt;</span><span>int_bits</span> <span>&amp;</span> <span>Z80_INT</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>cpu</span><span>-&gt;</span><span>iff1</span><span>)</span> <span>{</span>
            <span>// maskable interrupts start with a special M1 machine cycle which</span>
            <span>// doesn&#39;t fetch the next opcode, but instead activate the</span>
            <span>// pins M1|IOQR to request a special byte which is handled differently</span>
            <span>// depending on interrupt mode</span>
            <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>_z80_special_optable</span><span>[</span><span>_Z80_OPSTATE_SLOT_INT_IM0</span> <span>+</span> <span>cpu</span><span>-&gt;</span><span>im</span><span>];</span>
            <span>cpu</span><span>-&gt;</span><span>int_bits</span> <span>=</span> <span>0</span><span>;</span>
            <span>if</span> <span>(</span><span>pins</span> <span>&amp;</span> <span>Z80_HALT</span><span>)</span> <span>{</span>
                <span>pins</span> <span>&amp;=</span> <span>~</span><span>Z80_HALT</span><span>;</span>
                <span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>;</span>
            <span>}</span>
            <span>// NOTE: PC is not incremented, and no pins are activated here</span>
            <span>return</span> <span>pins</span><span>;</span>
        <span>}</span>
        <span>else</span> <span>{</span>
            <span>// oops, maskable interrupt requested but disabled</span>
            <span>cpu</span><span>-&gt;</span><span>step</span> <span>=</span> <span>0xFFFF</span><span>;</span>
            <span>return</span> <span>_z80_set_ab_x</span><span>(</span><span>pins</span><span>,</span> <span>cpu</span><span>-&gt;</span><span>pc</span><span>++</span><span>,</span> <span>Z80_M1</span><span>|</span><span>Z80_MREQ</span><span>|</span><span>Z80_RD</span><span>);</span>
        <span>}</span>
    <span>}</span>
    <span>else</span> <span>{</span>
        <span>_Z80_UNREACHABLE</span><span>;</span>
        <span>return</span> <span>pins</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>If <code>cpu-&gt;int_bits == 0</code> then no interrupts need to be handled, and execution continues
with the next opcode fetch.</p>

<p>If an NMI is detected, execution branches to a special decoder block which implements the
extra decoder steps to ‘realize’ a non-maskable interrupt and the returned pin mask
is set to what looks like a regular opcode fetch (<code>M1|MREQ|RD</code> and PC on the address bus),
but <em>without</em> incrementing the PC.</p>

<p>If a maskable interrupt is detected <em>and</em> interrupts are currently enabled,
decoder execution branches to one of three special decoder blocks depending on
the current interrupt mode (IM 0, IM 1 or IM 2). The returned pin mask doesn’t set any
memory or IO request pins.</p>

<p>If any type of interrupt is detected (and accepted), and the CPU is stopped at a HALT
instruction, the CPU will exit the HALT state.</p>

<h2 id="nmi-interrupt-behaviour">NMI Interrupt Behaviour</h2>

<p>The special decoder block for non-maskable interrupts looks like this:</p>

<div><div><pre><code>        <span>//  00: nmi (M:5 T:14)</span>
        <span>case</span> <span>1499</span><span>:</span> <span>_wait</span><span>();</span><span>cpu</span><span>-&gt;</span><span>iff1</span><span>=</span><span>false</span><span>;</span><span>goto</span> <span>step_next</span><span>;</span>        
        <span>case</span> <span>1500</span><span>:</span> <span>pins</span><span>=</span><span>_z80_refresh</span><span>(</span><span>cpu</span><span>,</span><span>pins</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1501</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1502</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mwrite</span>
        <span>case</span> <span>1503</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1504</span><span>:</span> <span>_wait</span><span>();</span><span>_mwrite</span><span>(</span><span>--</span><span>cpu</span><span>-&gt;</span><span>sp</span><span>,</span><span>cpu</span><span>-&gt;</span><span>pch</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1505</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mwrite</span>
        <span>case</span> <span>1506</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1507</span><span>:</span> <span>_wait</span><span>();</span><span>_mwrite</span><span>(</span><span>--</span><span>cpu</span><span>-&gt;</span><span>sp</span><span>,</span><span>cpu</span><span>-&gt;</span><span>pcl</span><span>);</span><span>cpu</span><span>-&gt;</span><span>wz</span><span>=</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>=</span><span>0x0066</span><span>;</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1508</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- overlapped</span>
        <span>case</span> <span>1509</span><span>:</span> <span>goto</span> <span>fetch_next</span><span>;</span>
</code></pre></div></div>

<p>An opcode fetch machine cycle (and an additional clock cycle) is executed but
the resulting opcode on the data bus is ignored. The IFF1 flag (but not IFF2)
is cleared.</p>

<p>Two memory write machine cycles are executed to store the current program counter
on the stack as return address, and once that has happened, both PC and the internal WZ
register are set to the hardwired interrupt service routine address 0x0066.</p>

<p>At the end of the ‘NMI interlude’, a regular opcode fetch happens which causes execution
to continue at the first instruction of the interrupt service routine at address 0x0066.</p>

<h2 id="mode-0-interrupt-behaviour">Mode 0 Interrupt Behaviour</h2>

<p>In interrupt mode 0 the CPU expects an opcode byte to be placed on the data
bus which is then directly executed. The decoder block looks like this:</p>

<div><div><pre><code>        <span>//  00: int_im0 (M:6 T:9)</span>
        <span>// -- generic</span>
        <span>case</span> <span>1461</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>iff1</span><span>=</span><span>cpu</span><span>-&gt;</span><span>iff2</span><span>=</span><span>false</span><span>;</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- generic</span>
        <span>case</span> <span>1462</span><span>:</span> <span>pins</span><span>|=</span><span>(</span><span>Z80_M1</span><span>|</span><span>Z80_IORQ</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- generic</span>
        <span>case</span> <span>1463</span><span>:</span> <span>_wait</span><span>();</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>=</span><span>_z80_get_db</span><span>(</span><span>pins</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- generic</span>
        <span>case</span> <span>1464</span><span>:</span> <span>pins</span><span>=</span><span>_z80_refresh</span><span>(</span><span>cpu</span><span>,</span><span>pins</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- generic</span>
        <span>case</span> <span>1465</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>step</span><span>=</span><span>_z80_optable</span><span>[</span><span>cpu</span><span>-&gt;</span><span>opcode</span><span>];</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- overlapped</span>
        <span>case</span> <span>1466</span><span>:</span> <span>goto</span> <span>fetch_next</span><span>;</span>
</code></pre></div></div>

<p>Instead of an opcode fetch machine cycle, an interrupt acknowledge machine cycle
is executed. First both IFF1 and IFF2 are cleared, then the CPU pins <code>M1|IORQ</code> are
set which causes the interrupt-requesting device to place an opcode
byte on the data bus which is loaded in the next clock cycle.</p>

<p>Next a regular refresh cycle happens and finally the decoder directly branches
to the opcode’s instruction payload.</p>

<p>The final ‘overlapped’ step is never executed, this is just an artefact of
the code generation.</p>

<p>Note how the interrupt handling doesn’t place a return address on the stack. Instead
the instruction that’s placed on the data bus is expected to take care of this
(usually this will be one of the RST instructions, which are one-byte subroutine
calls to one of 8 hardwired locations).</p>

<h2 id="mode-1-interrupt-behaviour">Mode 1 Interrupt Behaviour</h2>

<p>In interrupt mode 1 the CPU simply jumps to address 0x0038. A regular interrupt
acknowledge machine cycle is executed, but the result on the data bus will
be ignored. Two memory write machine cycles push the current program
counter on the stack as return address. Except for the initial interrupt
acknowledge machine cycle, and the destination address (0x0036 instead of
0x0066), interrupt mode 1 behaviour is similar to a non-maskable interrupt.</p>

<div><div><pre><code>        <span>//  00: int_im1 (M:7 T:16)</span>
        <span>case</span> <span>1467</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>iff1</span><span>=</span><span>cpu</span><span>-&gt;</span><span>iff2</span><span>=</span><span>false</span><span>;</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1468</span><span>:</span> <span>pins</span><span>|=</span><span>(</span><span>Z80_M1</span><span>|</span><span>Z80_IORQ</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1469</span><span>:</span> <span>_wait</span><span>();</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1470</span><span>:</span> <span>pins</span><span>=</span><span>_z80_refresh</span><span>(</span><span>cpu</span><span>,</span><span>pins</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1471</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1472</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mwrite</span>
        <span>case</span> <span>1473</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1474</span><span>:</span> <span>_wait</span><span>();</span><span>_mwrite</span><span>(</span><span>--</span><span>cpu</span><span>-&gt;</span><span>sp</span><span>,</span><span>cpu</span><span>-&gt;</span><span>pch</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1475</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mwrite</span>
        <span>case</span> <span>1476</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1477</span><span>:</span> <span>_wait</span><span>();</span><span>_mwrite</span><span>(</span><span>--</span><span>cpu</span><span>-&gt;</span><span>sp</span><span>,</span><span>cpu</span><span>-&gt;</span><span>pcl</span><span>);</span><span>cpu</span><span>-&gt;</span><span>wz</span><span>=</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>=</span><span>0x0038</span><span>;</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1478</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- overlapped</span>
        <span>case</span> <span>1479</span><span>:</span> <span>goto</span> <span>fetch_next</span><span>;</span>
</code></pre></div></div>

<h2 id="mode-2-interrupt-behaviour">Mode 2 Interrupt Behaviour</h2>

<p>In mode 2 interrupts, the interrupt requesting device is expected to put the
low-byte of an ‘interrupt vector’ on the data bus during the regular interrupt
acknowledge machine cycle. This low-byte will be combined with the I register
as high-byte to form the full 16-bit interrupt vector.</p>

<p>Next, two memory write machine cycles are executed to store the current PC
on the stack as return address.</p>

<p>Next, the interrupt vector is placed on the data bus, and two memory read machine
cycles are executed to read the 16-bit interrupt service routine entry address,
which is finally placed into the PC and WZ register.</p>

<p>Finally, the overlapped step initiates a regular opcode fetch which loads
the first opcode of the interrupt service routine.</p>

<div><div><pre><code>        <span>//  00: int_im2 (M:9 T:22)</span>
        <span>case</span> <span>1480</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>iff1</span><span>=</span><span>cpu</span><span>-&gt;</span><span>iff2</span><span>=</span><span>false</span><span>;</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1481</span><span>:</span> <span>pins</span><span>|=</span><span>(</span><span>Z80_M1</span><span>|</span><span>Z80_IORQ</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1482</span><span>:</span> <span>_wait</span><span>();</span><span>cpu</span><span>-&gt;</span><span>dlatch</span><span>=</span><span>_z80_get_db</span><span>(</span><span>pins</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1483</span><span>:</span> <span>pins</span><span>=</span><span>_z80_refresh</span><span>(</span><span>cpu</span><span>,</span><span>pins</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1484</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1485</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mwrite</span>
        <span>case</span> <span>1486</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1487</span><span>:</span> <span>_wait</span><span>();</span><span>_mwrite</span><span>(</span><span>--</span><span>cpu</span><span>-&gt;</span><span>sp</span><span>,</span><span>cpu</span><span>-&gt;</span><span>pch</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1488</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mwrite</span>
        <span>case</span> <span>1489</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1490</span><span>:</span> <span>_wait</span><span>();</span><span>_mwrite</span><span>(</span><span>--</span><span>cpu</span><span>-&gt;</span><span>sp</span><span>,</span><span>cpu</span><span>-&gt;</span><span>pcl</span><span>);</span><span>cpu</span><span>-&gt;</span><span>wzl</span><span>=</span><span>cpu</span><span>-&gt;</span><span>dlatch</span><span>;</span><span>cpu</span><span>-&gt;</span><span>wzh</span><span>=</span><span>cpu</span><span>-&gt;</span><span>i</span><span>;</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1491</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mread</span>
        <span>case</span> <span>1492</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1493</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>wz</span><span>++</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1494</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>dlatch</span><span>=</span><span>_gd</span><span>();</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mread</span>
        <span>case</span> <span>1495</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1496</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>wz</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1497</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>wzh</span><span>=</span><span>_gd</span><span>();</span><span>cpu</span><span>-&gt;</span><span>wzl</span><span>=</span><span>cpu</span><span>-&gt;</span><span>dlatch</span><span>;</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>=</span><span>cpu</span><span>-&gt;</span><span>wz</span><span>;</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- overlapped</span>
        <span>case</span> <span>1498</span><span>:</span> <span>goto</span> <span>fetch_next</span><span>;</span>
</code></pre></div></div>

<h2 id="the-ei-di-and-retiretn-instructions">The EI, DI and RETI/RETN instructions</h2>

<p>On a real Z80, the <strong>EI</strong> instruction disables interrupts from the middle of
the EI instruction’s opcode fetch machine cycle until the middle of the next
opcode fetch machine cycle. This has the effect that any pending maskable
interrupts are delayed until the end of the next instruction, and that maskable
interrupts are never triggered during long sequences of EI instructions.</p>

<p>In the emulator this behaviour is simply achieved by temorarily disabling interrupts
during the overlapped decoder step:</p>

<div><div><pre><code>        <span>//  FB: EI (M:1 T:4)</span>
        <span>// -- overlapped</span>
        <span>case</span>  <span>930</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>iff1</span><span>=</span><span>cpu</span><span>-&gt;</span><span>iff2</span><span>=</span><span>false</span><span>;</span><span>pins</span><span>=</span><span>_z80_fetch</span><span>(</span><span>cpu</span><span>,</span><span>pins</span><span>);</span><span>cpu</span><span>-&gt;</span><span>iff1</span><span>=</span><span>cpu</span><span>-&gt;</span><span>iff2</span><span>=</span><span>true</span><span>;</span><span>goto</span> <span>step_next</span><span>;</span>
</code></pre></div></div>

<p>The <strong>DI</strong> instruction on a real Z80 disables interrupts already in the middle of the
opcode fetch machine cycle, in the emulator this happens in the overlapped cycle:</p>

<div><div><pre><code>        <span>//  F3: DI (M:1 T:4)</span>
        <span>// -- overlapped</span>
        <span>case</span>  <span>877</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>iff1</span><span>=</span><span>cpu</span><span>-&gt;</span><span>iff2</span><span>=</span><span>false</span><span>;</span><span>goto</span> <span>fetch_next</span><span>;</span>
</code></pre></div></div>

<p>The only thing that’s important here is that the IFF1 and IFF2 flags are cleared before interrupt
detection happens in the <strong>_z80_fetch()</strong> function at the destination of <code>goto fetch_next</code></p>

<p>The <strong>RETI/RETN</strong> instruction have identical behaviour on a real Z80: the IFF2 flag is copied
into IFF1 in the middle of the <em>next</em> opcode fetch, this means that at the end of an NMI service
routine, the earliest moment a maskable interrupt will be triggered is at the end of the
instruction following RETN.</p>

<p>On the emulator, the RETI instruction sets a ‘virtual’ RETI output pin which is used by
other Z80-family chip emulators which implement the Z80 daisy chain interrupt protocol to detect
RETI instructions (real chips sniff the data bus for the RETI instruction bytes during
opcode fetch machine cycles instead).</p>

<p>This is what the RETI instruction payload looks like:</p>

<div><div><pre><code>        <span>// ED 4D: RETI (M:3 T:10)</span>
        <span>// -- mread</span>
        <span>case</span> <span>1032</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1033</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>sp</span><span>++</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1034</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>wzl</span><span>=</span><span>_gd</span><span>();</span><span>pins</span><span>|=</span><span>Z80_RETI</span><span>;</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- mread</span>
        <span>case</span> <span>1035</span><span>:</span> <span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1036</span><span>:</span> <span>_wait</span><span>();</span><span>_mread</span><span>(</span><span>cpu</span><span>-&gt;</span><span>sp</span><span>++</span><span>);</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>case</span> <span>1037</span><span>:</span> <span>cpu</span><span>-&gt;</span><span>wzh</span><span>=</span><span>_gd</span><span>();</span><span>cpu</span><span>-&gt;</span><span>pc</span><span>=</span><span>cpu</span><span>-&gt;</span><span>wz</span><span>;</span><span>goto</span> <span>step_next</span><span>;</span>
        <span>// -- overlapped</span>
        <span>case</span> <span>1038</span><span>:</span> <span>pins</span><span>=</span><span>_z80_fetch</span><span>(</span><span>cpu</span><span>,</span><span>pins</span><span>);</span><span>cpu</span><span>-&gt;</span><span>iff1</span><span>=</span><span>cpu</span><span>-&gt;</span><span>iff2</span><span>;</span><span>goto</span> <span>step_next</span><span>;</span>
</code></pre></div></div>

<p>…two memory read machine cycles to load the return address from the stack and
restore the program counter, and in the overlapped cycle the <strong>_z80_fetch()</strong>
function (where interrupt detection happens) is ‘manually invoked’ before the
IFF1 flag is restored.</p>

<p>The RETN instruction looks identical, except that the RETI pin isn’t set.</p>

<p>It’s <strong>important</strong> to note that the timing of the RETI virtual pin is entirely
wrong (it’s about 5 clock cycles late). The pin should actually be set during
the opcode fetch of the RETI’s 4D opcode byte, but this would have required to
add another opcode fetch special case. Since there’s only few actual computer
systems which use the Z80 interrupt daisy chain protocol I decided to accept
this compromise for now.</p>

<p>A proper solution would be to entirely drop the RETI virtual pin, and instead
sniff the data bus for the RETI opcode bytes like real Z80-family chips.</p>

<h2 id="pin-timing-differences-to-a-real-z80">Pin Timing Differences to a real Z80</h2>

<p>In the emulator, the various CPU pin combinations are only active for a single clock
cycle, while on a real Z80 the pins are usually active for multiple clock cycles.</p>

<p>I made this compromise to make the system tick function (which needs to check
for certain pin combinations) more efficient: for instance if the memory read
and write machine cycles would be active over multiple clock cycles, the system
tick function would end up reading and writing memory multiple times.</p>

<p>For memory access this would just mean more work, but for communication with
other chips this could also result in buggy behaviour because IO accesses to
and from the chip which trigger some action in the chip would be triggered
multiple times.</p>

<p>I’m not quite happy yet with the relationship between WAIT states and
memory and IO reads/writes, and I may have made some unintended compromises for the 
Amstrad CPC emulation which might slightly differ from the behaviour in other
computer systems:</p>

<ul>
  <li>
    <p>Memory and IO reads are delayed by WAIT states, e.g. the CPU reads the data
bus value after WAIT goes back to inactive.</p>
  </li>
  <li>
    <p>For IO writes, the <code>IORQ|WR</code> pins are active in the clock cycle before
the WAIT pin is sampled, so that the write is not delayed by the WAIT states.</p>
  </li>
  <li>
    <p>However, for memory writes I had to put the WAIT pin sampling and
<code>MREQ|WR</code> pin activation into the same decoder step. This means that
memory writes are delayed by the WAIT pin. For systems which don’t use memory
mapped IO this shouldn’t be a problem though.</p>
  </li>
</ul>

<p>Long story short: there may be more changes in the relationship between wait
states and read/write accesses in the future. Maybe I will also experiment with
making the CPU pins behave exactly like a real Z80 (e.g. being active for
multiple clock cycles), and put the burden of edge-detection on the system- or
chip-emulations.</p>

<h2 id="differences-to-the-old-z80-emulator">Differences to the old Z80 Emulator</h2>

<p>Apart from the obvious “callback free” execution model there are a few
more subtle differences between the old and new emulation:</p>

<ul>
  <li>
    <p>The old emulator’s tick function worked at ‘machine cycle granularity’,
for instance a memory read machine cycle only caused a single
invocation of the tick callback. This must be considered when
adopting old tick function code to the new emulator. Things that only
executed once per machine cycle now may run for each clock cycle, 
which can slow down execution quite dramatically. I haven’t put
too much thought yet into general performance optimization advice
for the system tick function, just be aware that small changes to
the system tick function now have a much bigger performance impact,
and usually into the wrong direction.</p>
  </li>
  <li>
    <p>The new emulator currently only works on little-endian hosts because
the 8- vs 16-bit register access is implemented with unions (trivial
to fix for big endian CPUs with #ifdefs, but any CPUs which use a
big endian layout are probably too slow for a cycle-stepped emulator
anyway).</p>
  </li>
  <li>
    <p>The old emulation cleared the INT pin at the end of each instruction, which
is not at all how a real Z80 behaves. In the new emulation, the code outside
the CPU emulation needs to take care of clearing the INT pin. How this
happens in concrete emulated systems is very different, a fairly common
approach is to do this during an interrupt acknowledge machine cycle (when
the pin mask <code>M1|IORQ</code> is active).</p>
  </li>
  <li>
    <p>The helper function <strong>z80_opdone()</strong> now returns true <strong>after</strong> the
overlapped clock cycle has been executed (so technically it’s already
one clock cycle into the next instruction). This was necessary because
the result of an instruction may only be available after the overlapped
cycle (which is important for debuggers).</p>
  </li>
  <li>
    <p>In the old emulator, it was enough to set the program counter to a different
value in order to force execution to continue at a random address, in the
new emulator, the function <strong>z80_prefetch()</strong> must be used instead.</p>
  </li>
</ul>

<h2 id="testing">Testing</h2>

<p>The following tests are currently used to verify correct emulator behaviour:</p>

<ul>
  <li>
    <p><a href="https://github.com/floooh/chips-test/blob/master/tests/z80-zex.c"><strong>z80-zexall.c</strong></a>:
This is the standard ZEXALL test which tests behaviour (but not the timing)
of all documented and undocumented instructions including the state of the
undocumented XF and YF flags which ‘leak’ from the internal WZ register (<a href="https://raw.githubusercontent.com/floooh/emu-info/master/z80/memptr_eng.txt">see
here</a>
for information on the WZ register behaviour).</p>
  </li>
  <li>
    <p><a href="https://github.com/floooh/chips-test/blob/master/tests/z80-fuse.c"><strong>z80-fuse.c</strong></a>:
Tests the instruction duration and CPU register state, with one important
caveat: the undocumented XF and YF flags are ignored for the <code>BIT n,(HL)</code>
instructions, because FUSE doesn’t agree here with ZEXALL.</p>
  </li>
  <li>
    <p><a href="https://github.com/floooh/chips-test/blob/master/tests/z80-test.c"><strong>z80-test.c</strong></a>:
This is my own rough instruction tester which I’ve been carrying along through
all the Z80 emulator iterations. It tests the duration and expected results for 
the documented instructions and a handful undocumented instructions, but not 
as thorough as ZEXALL or FUSE.</p>
  </li>
  <li>
    <p><a href="https://github.com/floooh/chips-test/blob/master/tests/z80-timing.c"><strong>z80-timing.c</strong></a>:
This is a variation of the previous test which tests pin timing (whether the expected
CPU pins are active during the right clock cycles)</p>
  </li>
  <li>
    <p><a href="https://github.com/floooh/chips-test/blob/master/tests/z80-int.c"><strong>z80-int.c</strong></a>:
This is similar to the z80-timing.c test, but specializes on interrupt timing.</p>
  </li>
</ul>

<h2 id="amstrad-cpc-accurary-improvements">Amstrad CPC Accurary Improvements</h2>

<p>Implanting the new cycle-stepped emulator into the <a href="https://floooh.github.io/tiny8bit/cpc.html">Amstrad CPC emulation</a>
was a rare case where some improvements were immediately visible. Those improvements
are not a direct result of the cycle-stepping approach, but because more attention
was paid to the correct timing of read and write machine cycles, and more detailed tests.</p>

<p>The CPU vs Gate Array synchronization using WAIT states got a lot simpler though,
the gate array emulation now simply sets the READY/WAIT pin in 3 out of 4 clock 
cycles and the rest happens automatically. In the old emulation (where the
tick callback was only called with machine cycle granularity), the gate array
had to “guess” the correct clock cycle when the CPU would sample the wait pin
and based on this guess, compute the number of wait states to insert.</p>

<p>Here are some of the improvements (mainly in demo scene demos, because those
are usually extremely timing sensitive, much more than classic games):</p>

<p>In the <a href="https://floooh.github.io/tiny8bit/cpc.html?file=cpc/points_barres.dsk&amp;input=run%22-PBARRES%0A">Points Barres demo by Overlanders</a>, a pixel junk scanline above scrolling text has been fixed:</p>

<p><img src="https://floooh.github.io/images/points_barres_1_old.jpg" width="512px"/>
<img src="https://floooh.github.io/images/points_barres_1_new.jpg" width="512px"/></p>

<p>In the <a href="https://floooh.github.io/tiny8bit/cpc.html?file=cpc/phx.dsk&amp;input=run%22phx%0A">PHX demo by Condense</a>
there’s no more pixel junk (below the text overlay) and step artefacts in
background raster effect:</p>

<p><img src="https://floooh.github.io/images/phx_1_old.jpg" width="512px"/>
<img src="https://floooh.github.io/images/phx_1_new.jpg" width="512px"/></p>

<p>In other parts of the PHX demo, a big black bar which was either slowly moving
down or static is gone:</p>

<p><img src="https://floooh.github.io/images/phx_2_old.jpg" width="512px"/>
<img src="https://floooh.github.io/images/phx_2_new.jpg" width="512px"/></p>

<p><img src="https://floooh.github.io/images/phx_4_old.jpg" width="512px"/>
<img src="https://floooh.github.io/images/phx_4_new.jpg" width="512px"/></p>

<p>And in the same demo, a massive pixel junk block under scrolling text
is fixed as well:</p>

<p><img src="https://floooh.github.io/images/phx_3_old.jpg" width="512px"/>
<img src="https://floooh.github.io/images/phx_3_new.jpg" width="512px"/></p>

<p>At start of the <a href="https://floooh.github.io/tiny8bit/cpc.html?file=cpc/stillrising.dsk&amp;input=run%22-RISING%0A">Still Rising demo by Vanity</a>, the black bars that are falling down no longer mess up the
background (that was very hard to capture in a screenshot).</p>

<p>This doesn’t mean that the CPC emulation is perfect though, far from it.
But the remaining problems are most likely in the CRTC and Gate Array
emulation, and not caused by inaccurate CPU behavour.</p>

  </div>

</article>

      </div>
    </div></div>
  </body>
</html>
