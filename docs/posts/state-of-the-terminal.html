<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gpanders.com/blog/state-of-the-terminal/">Original</a>
    <h1>State of the Terminal</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p><em>This is a companion article to <a href="https://vimeo.com/896237832?share=copy">my talk</a> at Neovimconf 2023</em>.</p>
<hr/>
<p>I have been using Vim/Neovim as my full time text editor for close to 10 years.
I’ve spent a lot of time in the terminal and have become very aware of the
many flaws and idiosyncrasies of this bizarre platform. But I also think it
gets a lot of things right! And I’m not alone in this belief: terminal based
tools are still widely popular even in the presence of many alternatives
(the StackOverflow developer survey shows that Neovim is the “most loved”
editor <a href="https://survey.stackoverflow.co/2021/#section-most-loved-dreaded-and-wanted-collaboration-tools">3</a> <a href="https://survey.stackoverflow.co/2022/#section-most-loved-dreaded-and-wanted-integrated-development-environment">years</a> <a href="https://survey.stackoverflow.co/2023/#section-admired-and-desired-integrated-development-environment">in</a> a row).</p>
<p>It’s only been in the last couple of years that I’ve begun to dig deep into
the inner workings of how terminal emulators, and the applications that run
inside of them, really work. I’ve learned that there is a lot of innovation
and creative problem solving happening in this space, even though the
underlying technology is over half a century old<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.</p>
<p>I’ve also found that many people who use terminal based tools (including
shells like Bash and editors like Vim) know very little about terminals
themselves, or some of the modern features and capabilities they can support.</p>
<p>In this article, we’ll discuss some of the problems that terminal based
applications have historically had to deal with (and what the modern solutions
are) as well as some features that modern terminal emulators support that you
may not be aware of.</p>
<p>But first, some (very) brief history.</p>
<h2 id="background--history">
  <a href="#background--history">Background &amp; History</a>
</h2>
<p>Most terminal emulators today can directly trace their roots back to the DEC
VT100. The VT100 was not the first video terminal, nor was it the last, but it
was the most popular (at the time). And as we’ve learned from history many
times since, what becomes popular creates the <em>de facto</em> standard for
everything that comes after.</p>
<figure><img src="https://gpanders.com/img/DEC_VT100_terminal.jpg" alt="DEC VT100" width="75%"/><figcaption>
            <p>DEC VT100
                    <a href="https://commons.wikimedia.org/wiki/File:DEC_VT100_terminal.jpg">Jason Scott, CC BY 2.0 via Wikimedia Commons</a></p>
        </figcaption>
</figure>

<p>Video terminals were an improvement on the teletype machines that preceded
them. They could move the cursor around the screen to create interactive
interfaces. They could use color, and clear and redraw their displays quickly
without feeding out reams of paper.</p>
<p>Different video terminals had their own unique way of doing things using
unique, proprietary escape codes (a sequence of bytes beginning with the
escape <code>0x1b</code> character). This made life difficult for applications because
they had to know which of these sequences to use. Libraries and helper
programs (e.g. <code>termcap</code>) were created to help ameliorate these issues (we
still live with the descendant of these early libraries,
<code>terminfo</code>).</p>
<p>Eventually, formal standards were created, such as ECMA-48 and ANSI X3.64
(from which the term “<a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape codes</a>” derives), which defined a set
of standard escape sequences. The DEC VT100 was the first video terminal to
support these new standards. Its popularity, combined with the new standards,
meant that programs now had a set of known good escape
sequences they could reliably use. Its popularity spawned many clones, which
in turn supported the same sequences for compatibility with applications.</p>
<p>Graphical window systems eventually replaced hardware video terminals, but
users still wanted to use the terminal based programs they were accustomed to
(you know how those <code>vi</code> people are). In 1984, work began on a software
terminal emulator at MIT. This emulator became part of the X project and was
named <a href="https://en.wikipedia.org/wiki/Xterm">Xterm</a>. Xterm implemented its own features which did not exist
on the video terminals it emulated, such as mouse tracking and a configurable
color palette. These features were in turn copied by Xterm clones, until
eventually Xterm itself became the new <em>de facto</em> standard.</p>
<h2 id="terminal-emulator-basics">
  <a href="#terminal-emulator-basics">Terminal Emulator Basics</a>
</h2>
<p>Terminal based applications write two kinds of data to the terminal emulator:
printable text that is displayed to the user, and control codes, which modify
the terminal emulator’s state. Control codes are either single bytes in the C0
character set (bytes <code>0x00</code> through <code>0x1f</code>) or sequences of bytes that begin
with the escape character (<code>0x1b</code>). These sequences are most commonly referred
to as “escape sequences”, and it is these sequences that do the bulk of the
heavy lifting in terminal applications.</p>
<p>Most control codes from the C0 character set are not used today, but
regardless of experience with terminals or terminal applications, most
developers are likely familiar with control codes such as <code>\r</code> (carriage
return), which moves the cursor to the beginning of the current line, and <code>\n</code>
(line feed), which moves the cursor to the next line.</p>
<p>Escape sequences are varied and numerous, but the vast majority used in
practice fall into one of three categories: Control Sequence Introducer (CSI),
Device Control String (DCS), and Operating System Command (OSC).</p>
<p>CSI sequences are those which begin with the prefix <code>ESC [</code> (<code>0x1b 0x5b</code>).
Escape sequences in this category are those which reposition the cursor,
change the cursor style, clear the screen, set foreground and background
colors, and more.</p>
<p>OSC sequences are those which begin with the prefix <code>ESC ]</code> and are typically
used for things that modify or interact with the user’s environment outside of
the terminal emulator itself (hence the name “Operating System Command”).
Examples are reading from or writing to the system clipboard, changing the
title of the terminal emulator’s window, or sending desktop notifications.</p>
<p>Xterm maintains a list of all of the control sequences it supports on its
<a href="https://invisible-island.net/xterm/ctlseqs/ctlseqs.html">website</a>, which, along with <a href="https://vt100.net">vt100.net</a>, forms an
informal pseudo-specification for VT100 emulators. Note that this list may not
contain some control sequences used by other, modern terminal emulators for
features which Xterm does not support (e.g. the Kitty keyboard protocol, which
we’ll discuss later).</p>
<p>Escape sequences are actually quite easy to use, and you can even do it
straight from your shell. Try running the following command from any shell:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>printf</span> <span>&#39;\e[1;32mHello \e[0;4;31mworld!\n\e[0m&#39;</span>
</span></span></code></pre></div><p>This command will print the text “Hello world!”, with “Hello” in
<span>green, bold</span>

text and “world!” in
<span>red, underlined</span>

text.</p>
<p>The escape sequences used here are of the form <code>CSI &lt;parameters&gt; m</code>, which is
so common it has its own name: Select Graphic Rendition (SGR). The SGR escape
sequence sets foreground and background colors for all printed text. The first
escape sequence in the example <code>\e[1;32m</code> enables the <strong>bold</strong> attribute (<code>1</code>)
and sets the foreground color to
<span>green</span>

(<code>32</code>). The second escape sequence <code>\e[0;4;31m</code> first clears any existing
styles (<code>0</code>), then enables the
<span>underline</span>

attribute (<code>4</code>), and finally sets the foreground text color to
<span>red</span>

(<code>31</code>). Finally, the last escape sequence <code>\e[0m</code> resets all styles back to
their defaults.</p>
<p>Another use case for simple CSI sequences is redrawing text on the screen on
an already existing line (e.g. for a progress bar or text that updates itself
over time). Hint: look at <code>\r</code>, <code>CSI A</code>, and <code>CSI K</code>.</p>
<p>Most escape sequences are sent from the application to the terminal emulator,
but occasionally the terminal emulator sends escape sequences to the
application. Usually this is done in response to a query from the application
(for instance, to determine if a certain mode is set).</p>
<h2 id="problems--solutions">
  <a href="#problems--solutions">Problems &amp; Solutions</a>
</h2>
<p>Terminal emulators are descended from old, legacy technologies, which brings
with it its fair share of problems. Many of these problems have been (mostly)
solved, or at least ameliorated, while others are still active areas of
innovation and research.</p>
<h3 id="key-encoding">
  <a href="#key-encoding">Key Encoding</a>
</h3>
<p>Terminal emulators and terminal applications communicate through a stream of
bytes. When a user presses a key the terminal sends the byte representation of
the character associated with that key. The old video terminals only supported
ASCII so this was, generally, fairly straightforward.</p>
<p>Modifier keys like <code>Ctrl</code> and <code>Alt</code> complicate this situation. <code>Alt</code> modified
keys are encoded by prefixing the character with an <code>Esc</code>. But this has a
problem: including an extra <code>Esc</code> byte for the <code>Alt</code> modifier introduces
ambiguity between <code>Alt</code> modified key presses and two separate key presses.
When an application sees <code>Esc C</code>, should it interpret it as <code>Alt-C</code> or did the
user press <code>Esc</code> and then press <code>C</code>? Applications usually solve this by
measuring the amount of time between <code>Esc</code> and the next character. If the time
is less than some defined interval, it is considered an <code>Alt</code> modified key
press (Vim uses the <code>ttimeoutlen</code> option, tmux uses the <code>escape-time</code> option).</p>
<p><code>Ctrl</code> modified keys are an even bigger problem. When <code>Ctrl</code> is used as a
modifier, the shifted<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> version of the key has the 7th bit masked off (for
example, <code>C</code> is <code>0x43</code> and after masking the 7th bit the byte becomes <code>0x03</code>).
This means that not only can the <code>Shift</code> modifier not be used in conjunction
with <code>Ctrl</code>, but that certain <code>Ctrl</code> modified keys are completely
indistinguishable from other control codes.</p>
<p>For instance, when you press the <code>Return</code> key the terminal emulator sends the
byte <code>\r</code> (<code>0x0d</code>) to the application. But if you press <code>Ctrl-M</code> then the
terminal emulator also sends the byte <code>0x0d</code> to the application (<code>M</code> is <code>0x4d</code>
in ASCII, so when the 7th bit is masked out, it becomes <code>0x0d</code>). From the
application’s perspective, there is literally no way to distinguish these two
events.</p>
<p>For a long time this meant that certain modified keys like <code>Ctrl-I</code>, <code>Ctrl-J</code>,
and <code>Ctrl-M</code> could not be used in terminal applications like Vim. There have
been a few attempts to solve this problem: the first came from Xterm in 2006
through the <a href="https://invisible-island.net/xterm/modified-keys.html">modifyOtherKeys</a> option. Paul Evans (author of <code>libvterm</code> and
<code>libtickit</code>) introduced an alternate key encoding using the <code>CSI u</code> escape
sequence in an <a href="http://www.leonerd.org.uk/hacks/fixterms/">essay</a> which is sometimes colloquially referred to
as “fixterms”. The <code>CSI u</code> encoding proposed by Evans was extended by Kovid
Goyal, the author of the kitty terminal emulator, in what has become known as
the <a href="https://sw.kovidgoyal.net/kitty/keyboard-protocol/">kitty keyboard protocol</a>.</p>
<p>What all of these solutions have in common is that key presses are sent to the
terminal application encoded as escape sequences. This eliminates any
ambiguity for modified keys and enables certain modifier combinations (such as
<code>Ctrl + Shift</code>) that are not possible using “legacy” encoding. The <code>CSI u</code>
encoding proposed by Evans and adapted by kitty encodes a modified key press
like <code>Ctrl-M</code> as <code>\e[109;5u</code>. The encoding of unmodified key presses like
<code>Return</code> depend on which “level” of the kitty keyboard protocol is enabled.
Applications can opt-in to different levels to ease adoption (for instance,
Neovim uses only the first level, “Disambiguate escape keys”). See the <a href="https://sw.kovidgoyal.net/kitty/keyboard-protocol/">kitty
documentation</a> for more details.</p>
<p>Sending key presses as escape sequences requires that terminal applications
are able to recognize and parse those sequences, so it is not something that
“just works” out of the box. However, the kitty keyboard protocol has been
widely adopted by both modern terminal emulators and terminal applications.
Terminals which support the kitty keyboard protocol (to some degree) include
Wezterm, Alacritty, kitty, foot, Ghostty, and iTerm2. Applications which
support the kitty keyboard protocol (to some degree) include Vim, Neovim,
Helix, kakoune, and nushell. This means that when using one of these
applications in one of these terminals, all of the key encoding problems
discussed above (as well as some others which were <em>not</em> discussed…) are
solved.</p>
<h3 id="decorations">
  <a href="#decorations">Decorations</a>
</h3>
<p>Xterm has supported 256 user specified colors since <a href="https://invisible-island.net/xterm/xterm.log.html#xterm_111">1999</a>. These
colors could be changed at runtime using an escape sequence (OSC 4), which can
be used to great effect (see <a href="https://www.youtube.com/watch?v=aMcJ1Jvtef0">“8 Bit &amp; ‘8 Bitish’ Graphics-Outside the
Box”</a> by Mark Ferrari for an incredible demonstration, or install
<a href="https://github.com/dankamongmen/notcurses">notcurses</a> and run <code>notcurses-demo j</code> in your terminal).</p>
<p>Within the last decade or so, 24 bit color (sometimes referred to as
“truecolor” or “RGB color”) has become widely supported by terminal emulators
which allows terminal applications to use whatever arbitrary colors they want.
This provides terminal UIs a much greater degree of flexibility and creative
freedom.</p>
<p>Modern terminals also support other kinds of “rich” text markup, such as
strikethrough and various types of underlines. For instance, text editors like
Vim and Neovim can add a
<span>red squiggly line</span>

under misspelled words (as seen in many graphical rich text editors).</p>
<figure><img src="https://gpanders.com/img/terminal_styles.png" alt="A screenshot of a terminal emulator displaying different text markup styles"/><figcaption>
            <p>Examples of markup styles supported by modern terminal emulators</p>
        </figcaption>
</figure>

<p>It is also possible to display images and even videos inline inside of
terminal emulators. There are (at least) three different ways to do this
(<a href="https://github.com/saitoha/libsixel">sixels</a>, the <a href="https://iterm2.com/documentation-images.html">iTerm2 image protocol</a>, and the <a href="https://sw.kovidgoyal.net/kitty/graphics-protocol/">kitty
graphics protocol</a>) and support among terminal emulators
varies. Unfortunately this means that terminal applications are in a bit of an
awkward situation, as they must either implement support for all of the image
protocols, or only support a subset of terminals. For this reason, use of
images in terminal applications is still relatively uncommon.</p>
<p>It is important to note that advances in terminal based UIs are not only due
to the efforts of terminal emulators, but also to the creativity and talent of
terminal application and library authors. For example, see some of the
fantastic work that <a href="https://charm.sh">charm.sh</a> has done creating delightful,
interactive terminal based user interfaces that rival (and in some cases,
surpass!) graphical UIs for similar tools.</p>
<h3 id="capability-determination">
  <a href="#capability-determination">Capability Determination</a>
</h3>
<p>Terminal emulators do not all support the same features. In some cases, the
same feature is implemented in different ways. Terminal applications need some
way to know which features the terminal they’re running in support and how to
properly use those features.</p>
<p>Today this is primarily done using a distributed database of “terminfo” files.
The terminal emulator uses the <code>$TERM</code> environment variable to communicate to
terminal applications which terminfo file to use to lookup which capabilities
the terminal supports.</p>
<p>This has a multitude of problems, however. The terminfo database is part of
the ncurses library, and different operating systems and distributions package
different versions of ncurses. This was a problem for <a href="https://gpanders.com/blog/the-definitive-guide-to-using-tmux-256color-on-macos/">tmux users on
macOS</a> for many years because the version of ncurses packaged with macOS
was so old that it did not even include the <code>tmux-256color</code> terminfo entry at
all!</p>
<p>This is also a problem for newer terminals which have not yet been added to
the ncurses terminfo database. Terminal emulators can (and often do) ship
their own terminfo entries which are used by applications running on the same
system as the terminal emulator itself. But when connecting to a remote system
(e.g. with SSH), the terminfo database on the remote system will not have the
terminfo entry and the user is met with cryptic warnings like <code>WARNING: terminal is not fully functional</code> and applications not functioning properly.</p>
<p>To circumvent this issue, many terminals use <code>xterm-256color</code> as their <code>$TERM</code>
value, essentially claiming to be Xterm even though they are not, piggybacking
on Xterm’s ubiquity. This creates a vicious cycle, as terminal applications
often hardcode special cases for <code>xterm-256color</code>, which incentivizes
terminals to claim to be <code>xterm-256color</code>, which incentivizes applications to
special case <code>xterm-256color</code>, which… and so on. The problem is
exacerbated by common (bad) advice to users facing problems with terminal
applications to simply override <code>$TERM</code> to be <code>xterm-256color</code> (the
<a href="https://invisible-island.net/ncurses/ncurses.faq.html#xterm_generic-id">Xterm FAQ</a> itself warns against this).</p>
<p>Unfortunately there are no easy fixes for these problems, but there is hope.
The vast majority of escape sequences used by applications today are common
across most (if not all) modern terminal emulators. This makes terminfo less
necessary since applications can <em>usually</em> safely assume that a given escape
sequence will “just work”.</p>
<p>In addition, terminal emulators increasingly support applications querying
support for certain capabilities. For instance, applications can query the
terminal for support of the kitty keyboard protocol mentioned above and only
enable it if the terminal responds that it is supported. A nice property of
escape sequence queries is they still work even over remote login connections
like SSH.</p>
<p>Some new TUI libraries, such as <a href="https://git.sr.ht/~rockorager/vaxis">vaxis</a>, are designed specifically to avoid
using terminfo at all and exclusively use queries to determine feature
capabilities. As more applications, libraries, and terminal emulators move in
this direction, terminfo will become increasingly unnecessary.</p>
<h3 id="system-integration">
  <a href="#system-integration">System Integration</a>
</h3>
<p>One of the many advantages of software terminal emulators over hardware video
terminals is that they are one piece of a larger, integrated computing system.
Modern terminal emulators support many escape sequences to interact with their
broader environment. These sequences are generally known as Operating System
Commands (OSCs) and are often referred to by the numeric integer which appears
after the OSC prefix.</p>
<p>Some of the more popular OSC sequences are OSC 2 for setting the title of the
terminal emulator’s window (used frequently by shells and text editors), OSC 8
for creating clickable <a href="https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda">hyperlinks</a>, OSC 9 for sending desktop
notifications, and OSC 52 for interacting with the system clipboard.</p>
<p>You can test these sequences out for yourself. Try running the following in
your shell:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>printf</span> <span>&#39;\e]9;This is a notification!\a&#39;</span>
</span></span></code></pre></div><p>If your terminal emulator supports OSC 9, you will see a desktop notification
appear with the text, “This is a notification!” (some terminals or operating
systems may not display a notificaton for the focused application. In that
case, add a <code>sleep 2</code> before the <code>printf</code> command and quickly change focus to
another window).</p>
<p>Terminals which support OSC 8 can create clickable hyperlinks. For instance,
try running the below command:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>printf</span> <span>&#39;\e]8;;https://www.youtube.com/watch?v=dQw4w9WgXcQ\aClick me for an awesome video!\n\e]8;;\a&#39;</span>
</span></span></code></pre></div><p>You will see the text “Click me for an awesome video!”. If your terminal
emulator supports OSC 8, the text will be clickable (perhaps requiring a
modifier key like <code>Shift</code> or <code>Command</code> to be held) and might be styled with an
underline or some other visual affordance to indicate that the text is a
hyperlink. Clicking on the text will open your web browser to the (perfectly
innocuous) embedded URL.</p>
<p>A long standing issue for terminal based text editors like Vim is clipboard
management in remote sessons. A strength of Vim is that it can be run just as
easily in a remote SSH session as it can locally; however, the remote SSH
session is not able to communicate with the clipboard on your local system, so
it is not possible to copy text inside of Vim on the remote session to your
clipboard.</p>
<p>Vim addresses this by (optionally) linking against X11 and allowing users to
forward their X connection to the remote server, allowing Vim on the remote
server to copy text to the X clipboard on the local system. And while this
does <em>work</em>, it has its own problems (users must use a version of Vim compiled
against X11, with the optional <code>+clipboard</code> feature enabled, and use X11 as
their display server, and remember to forward the X connection to the remote
system).</p>
<p>A better solution is to copy data to the clipboard through the terminal
emulator directly. An application running in the terminal can use the OSC 52
escape sequence to write a Base64 encoded string to the terminal emulator. The
terminal then decodes the string and copies the data into the system
clipboard. The terminal emulator does not know or care whether the application
that sent the sequence is running remotely or not, which means this works on
<em>any</em> system with zero dependencies.</p>
<p>Pasting (reading) from the clipboard has serious security implications,
because any program in the terminal (even ones on remote servers) can request
the clipboard contents of the user’s system. For this reason, most terminal
emulators disable reading from the clipboard by default, or require the user
to explicitly allow it with a prompt.</p>
<p>Neovim recently added builtin support for using OSC 52 and it will be enabled
for users by default (if the terminal emulator supports it) in the forthcoming
0.10 release.</p>
<h2 id="conclusion">
  <a href="#conclusion">Conclusion</a>
</h2>
<p>While it’s true that terminals, as an application platform, are idiosyncratic
and quirky, their portability, ubiquity, and relative ease of use (for
application authors) makes them increasingly popular for many developers, even
in the face of an increasing number of alternatives.</p>
<p>This article is not exhaustive, but it is not meant to be. There are other
challenges that both terminal emulator and terminal application authors face
that are not discussed here, as well as other areas of innovation and creative
exploration. Some examples: <a href="https://mitchellh.com/writing/grapheme-clusters-in-terminals">better grapheme clustering</a>,
<a href="https://gist.github.com/christianparpart/d8a62cc1ab659194337d73e399004036">synchronized output</a> to avoid “flickering” in redraw-heavy UIs, and
<a href="https://twitter.com/mitchellh/status/1724649962397646900">custom shaders</a> to create arbitrary visual effects.</p>
<p>Terminal emulators are not static: they continue to evolve and innovate to
solve users’ problems and improve users’ experience. The underlying technology
is old: downright ancient by the standards of modern tech. But, instead of a
flaw, I consider this a strength: it gives me confidence that while individual
terminal emulators may come and go, the underlying platform will endure.</p>
<h2 id="references--further-reading">
  <a href="#references--further-reading">References &amp; Further Reading</a>
</h2>
<ul>
<li><a href="http://www.linusakesson.net/programming/tty/">The TTY demystified</a></li>
<li><a href="https://jvns.ca/blog/2022/07/20/pseudoterminals/">What happens when you press a key in your terminal?</a></li>
<li><a href="https://computer.rip/2024-02-25-a-history-of-the-tty.html">A history of the tty</a></li>
<li><a href="https://bestasciitable.com">Understanding ASCII (and terminals)</a></li>
<li><a href="https://sw.kovidgoyal.net/kitty/keyboard-protocol/">Comprehensive keyboard handling in terminals</a></li>
<li><a href="http://www.leonerd.org.uk/hacks/fixterms/">Fix Keyboard Input on Terminals - Please</a></li>
<li><a href="https://mitchellh.com/writing/grapheme-clusters-in-terminals">Grapheme Clusters and Terminal Emulators</a></li>
</ul>
<!-- raw HTML omitted -->


  </div></div>
  </body>
</html>
