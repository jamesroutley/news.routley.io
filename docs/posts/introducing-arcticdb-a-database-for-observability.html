<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.polarsignals.com/blog/posts/2022/05/04/introducing-arcticdb/">Original</a>
    <h1>Introducing ArcticDB: A Database for Observability</h1>
    
    <div id="readability-page-1" class="page"><article><p>End of last year we <a href="https://www.polarsignals.com/blog/posts/2021/10/08/introducing-parca-we-got-funded/">announced the Parca Open Source project</a> and today we are excited to introduce <a href="https://github.com/polarsignals/arcticdb">arcticDB</a>, an embedded columnar database written in Go building on top of Apache Parquet and Apache Arrow, powering <a href="https://github.com/parca-dev/parca">Parca</a> going forward.</p><p><img src="https://www.polarsignals.com/blog/posts/2022/05/04/arcticdb_logo.png" alt="arcticDB logo"/><span></span></p><p>This blog post describes why we built it and what drove specific features and requirements, but if you’re just interested in how it works, <a href="https://github.com/polarsignals/arcticdb">check out the project README</a>.</p><h2>Continuous profiling needs a columnar database</h2><p>Continuous profiling is the systematic and always-on profiling of software. We built and open sourced <a href="https://github.com/parca-dev/parca">Parca</a> to make it available to everyone. At Polar Signals our goal is to allow users to always profile their infrastructure with zero instrumentation. Using the <a href="https://www.parca.dev/docs/parca-agent-design">eBPF based Parca Agent</a>, we are enabling the collection of CPU profiling data at very low overhead. However, while we are able to collect the data at low overhead, it produces a huge amount of data to store and query efficiently.</p><p>Profiling data at a high level can be described as stacktraces with a value attached, so continuous profiling is the same, except it adds the time dimension. Take some example data:</p><div><table><thead><tr><th>Stacktrace</th><th>t1</th><th>t2</th><th>t3</th><th>...</th></tr></thead><tbody><tr><td>main;func1;func2</td><td>2</td><td>3</td><td>null</td><td>...</td></tr><tr><td>main;func1;func3</td><td>23</td><td>null</td><td>234</td><td>...</td></tr></tbody></table></div><p>To make querying multi-dimensional data familiar, the data model of Parca, is highly inspired by <a href="https://prometheus.io/docs/concepts/data_model/">Prometheus&#39; data model</a>. For example to select all profiling data of a specific node a label-selector is used to query it:</p><pre><pre><p><span>cpu{node=”123.my-node-pool.polarsignals.com”}</span></p></pre></pre><p>Labels can be anything. Infrastructure labels such as <code>region</code>, <code>datacenter</code>, <code>node</code>, etc. or application specific labels such as <code>version</code> are popular labels used.</p><p>In its first iteration, the Parca storage used a Prometheus-style time-series approach for storing data, which accumulated samples per process-stacktrace combination being profiled to maximize compression using the <a href="https://www.vldb.org/pvldb/vol8/p1816-teller.pdf">Gorilla XOR encoding</a>. In memory the series of process-stacktrace samples were grouped by their process ultimately making up a profile-series. When queried, the label-selector found the profile-series and then used the list of stacktraces within it to construct the result (potentially combined with many other pieces of data). To make the search happen, labels were indexed using an inverted index.</p><p><img src="https://www.polarsignals.com/blog/posts/2022/05/04/parca_timeseries.png" alt="Parca inverted index pointing to profile series"/><span>Parca&#39;s previous storage, using an inverted index pointing to profile-series, which include time-series per stacktrace.</span></p><p>This approach worked well enough for cases where we are just querying to group by process, but we want to go further. We wanted to be able to attach arbitrary labels to stacktraces, like the <a href="https://github.com/google/pprof/blob/83db2b799d1f74c40857232cb5eb4c60379fe6c2/proto/profile.proto#L117">pprof format allows</a>, and be able to filter, and aggregate by those labels. This can be used for attaching labels such as <code>customer=”X”</code> allowing queries to understand how much CPU time is caused by a single customer. It would also allow attaching distributed tracing IDs (or span IDs) to profiling data, or vice versa attach a unique ID to each profile collected and link that ID from a distributed trace. We also want to be able to deal with short-lived environments such as CI environments or serverless, where processes are relatively short-lived. It all boils down to unbound cardinality data, which, as we learned with the Prometheus project, conflicts with the desire to buffer samples per unique series. Prometheus was not made for unbound cardinality and that&#39;s ok, but our goal was now to be abe to handle unbound cardinality, therefore the time-series style approach was no longer going to work for Parca.</p><p>We explored various optimizations to our existing database to allow for these use cases, but ultimately started to investigate alternative layouts of the data since we kept hitting roadblocks. After a few attempts a columnar layout seemed very promising as it more naturally lends itself to high cardinality data, and since all data is by definition stored by their columns, the values we intend to filter or aggregate by are already available in one place in memory or when serialized to persistent storage. These characteristics make it easy to parallelize execution of queries (using <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a>).</p><p>(If all of this sounds familiar, then that might be because you&#39;ve read Honeycomb&#39;s <a href="https://www.honeycomb.io/blog/why-observability-requires-distributed-column-store/">&#34;Why Observability Requires a Distributed Column Store&#34;</a>, which essentially comes to the same conclusion for unbound cardinality data.)</p><p>The way we imagined the data-model to translate was that we would have a column per label, a column for stacktraces, a column for timestamps and a column for values. All data would be globally sorted by all columns so we could use binary searches to find data quickly without having to have an index per column. Early prototypes seemed so promising that we pursued this direction further.</p><p>Taking the profiling data we started with assuming it has the <code>pod=&#34;mypod1&#34;</code> and <code>node=&#34;mynode1&#34;</code> labels:</p><div><table><thead><tr><th>labels.pod</th><th>labels.node</th><th>stacktrace</th><th>timestamp</th><th>value</th></tr></thead><tbody><tr><td>mypod1</td><td>mynode1</td><td>main;func1;func2</td><td>t1</td><td>2</td></tr><tr><td>mypod1</td><td>mynode1</td><td>main;func1;func2</td><td>t4</td><td>3</td></tr><tr><td>mypod1</td><td>mynode1</td><td>main;func1;func3</td><td>t1</td><td>23</td></tr><tr><td>mypod1</td><td>mynode1</td><td>main;func1;func3</td><td>t2</td><td>10</td></tr><tr><td>mypod1</td><td>mynode1</td><td>main;func1;func3</td><td>t3</td><td>12</td></tr><tr><td>mypod1</td><td>mynode1</td><td>main;func1;func3</td><td>t5</td><td>234</td></tr></tbody></table></div><p>And since each column is encoded individually, the desire was to exploit the repetitiveness of the data. Using that strategy, while logically the data is the above table, physically it can be represented much more efficiently:</p><div><table><thead><tr><th>labels.pod</th><th>labels.node</th><th>stacktrace</th><th>timestamp</th><th>value</th></tr></thead><tbody><tr><td>6 x mypod1</td><td>6 x mynode1</td><td>2 x main;func1;func2</td><td>t1</td><td>2</td></tr><tr><td></td><td></td><td>4 x main;func1;func3</td><td>t4</td><td>3</td></tr><tr><td></td><td></td><td></td><td>t1</td><td>23</td></tr><tr><td></td><td></td><td></td><td>t2</td><td>10</td></tr><tr><td></td><td></td><td></td><td>t3</td><td>12</td></tr><tr><td></td><td></td><td></td><td>t5</td><td>234</td></tr></tbody></table></div><p>If a certain order was enforced, then for efficiency, the timestamp and value could also be encoded using the strategies laid out by the Gorilla XOR encoding.</p><h2>Why build something new?</h2><p>At this point you might ask yourself, “sure columnar layout sounds good, but why not use an off the shelf option?” and you’d definitely be right in asking that! There were two primary requirements that led us to build something new.</p><p>First, we needed something embeddable for Go, as we want to provide the Prometheus-like experience of a single statically linked binary that <em>just works</em>. This is definitely the weaker argument as there are other embeddable columnar databases, such as <a href="https://duckdb.org/">DuckDB</a> that while using CGO, could have been embedded. It does however rule out external databases such as <a href="https://clickhouse.com/">ClickHouse</a>.</p><p>The second and more pressing argument was: in order for us to be able to translate the label-based data-model to a table-based layout, we needed the ability to create columns whenever we see a label-name for the first time. This is necessary so we have the ability to exploit the characteristics of columnar layout when searching or aggregating by label-values. If we used a <code>map</code>-type, which many existing columnar databases have, to represent labels we would not be able to exploit the characteristics of the columnar layout, we would essentially be loading the entire map, even when only needing to process a single key.</p><div><table><thead><tr><th>labels (map)</th><th>stacktrace</th><th>timestamp</th><th>value</th></tr></thead><tbody><tr><td>{pod=&#34;mypod1&#34;, node=&#34;mynode1&#34;}</td><td>main;func1;func2</td><td>t1</td><td>2</td></tr><tr><td>{pod=&#34;mypod1&#34;, node=&#34;mynode1&#34;}</td><td>main;func1;func2</td><td>t4</td><td>3</td></tr><tr><td>{pod=&#34;mypod1&#34;, node=&#34;mynode1&#34;}</td><td>main;func1;func3</td><td>t1</td><td>23</td></tr><tr><td>{pod=&#34;mypod1&#34;, node=&#34;mynode1&#34;}</td><td>main;func1;func3</td><td>t2</td><td>10</td></tr><tr><td>{pod=&#34;mypod1&#34;, node=&#34;mynode1&#34;}</td><td>main;func1;func3</td><td>t3</td><td>12</td></tr><tr><td>{pod=&#34;mypod1&#34;, node=&#34;mynode1&#34;}</td><td>main;func1;func3</td><td>t5</td><td>234</td></tr></tbody></table></div><p>The only open source database that we were able to find that supports such a model was <a href="https://github.com/influxdata/influxdb_iox">InfluxDB IOx</a>. We talked to <a href="https://twitter.com/pauldix">Paul Dix</a> and <a href="https://twitter.com/andrewlamb1111">Andrew Lamb</a> of InfluxData, but unfortunately it was not going to be ready for us to use in time. They were very helpful though and shared a lot of their insight and learnings (the <a href="https://www.youtube.com/playlist?list=PLYt2jfZorkDp-PKBS05kf2Yx2NrRyPAAz">InfluxDB IOx tech talks</a> are also fantastic and I can recommend them to anyone interested further in this topic)!</p><p>With all of this combined, we felt we had no other choice but to build something ourselves. We had been following the Apache Parquet and Apache Arrow projects out of interest for some time, and they seemed like the right technologies to build upon (and Paul and Andrew reassured us in this decision when we talked to them, as unsurprisingly InfluxIOx is based on the same technologies). And of course, thanks to building on top of Parquet and Arrow, we could focus on the things that make this database unique rather than reinventing page layouts, execution models, and so on.</p><h2>Built for profiling, but can do so much more!</h2><p>After about 3 months of development we now have a start of what we have started calling <a href="https://github.com/polarsignals/arcticdb">arcticDB</a>. It is already very capable in handling continuous profiling data, so we wanted to start releasing it as part of the Parca project. For now it only accumulates data in-memory and when a certain size is reached it starts over. In the future this data will be persisted to object storage.</p><p>A few things that we think make arcticDB unique:</p><ul><li><strong>Dynamic columns</strong>: As mentioned above, this feature dynamically creates a column whenever a sub-column is seen for the first time. In fact it actually has no effect for the table globally at insertion time, only at read time are all columns returned in their sorted order.</li><li><strong>Immutable and sorted</strong>: The entire database is immutable, data can only ever be written, and never modified. Additionally all data is globally sorted by columns defined in its schema. These two characteristics go hand in hand, we can only maintain global sorting at low cost if data cannot be modified (as it could affect sorting, requiring a re-sort). Sorting allows for efficient searches without an extra index, and immutability is typical for Observability workloads, so it&#39;s not a downside for the applications.</li><li><strong>Consistency trade-offs</strong>: arcticDB has a weak consistency model, it does not have read-after-write consistency as the intended use for it is in systems where the user querying data is distinct from the entity writing data, typically machines, not humans, meaning that the entity writing data is not the same as the entity reading it, so read-after-write consistency is not necessary. That said, writers can still simulate read-after-write consistency by waiting and watching if their transaction successfully advances or not.</li></ul><p>If you want to find out about these mechanisms in more detail refer to the <a href="https://github.com/polarsignals/arcticdb">arcticDB README</a>.</p><h2>Acknowledgements</h2><p>Shout out to Tyler Neely for spending hours with me discussing write isolation mechanisms we could use. This discussion ultimately led to the batch-based write isolation we ended up implementing! Also, shout out to Paul Dix and Andrew Lamb of InfluxData for letting us bounce early ideas and share their experience with InfluxIOx! Also a massive shout out to the folks at Segment (and especially Achille Roussel) for recently opening their <a href="https://github.com/segmentio/parquet-go">Parquet library for Go</a>, which has been a bliss to work with! And last but not least, shout out to Julien Pivotto of the Prometheus team for trialing Parca with arcticDB extensively and reporting high quality bugs (while using it to fix a memory leak in Prometheus!), which after fixing we were comfortable making this announcement and release arcticDB as part of Parca!</p><h2>What’s next?</h2><p>This is only the very beginning of <a href="https://github.com/polarsignals/arcticdb">arcticDB</a>, there are still lots of features that have not been implemented but we wanted to share it early and start to make real use of it in Parca! This blog post also only touches on high level topics regarding arcticDB, there are many parts of it that deserve their own blog posts.</p><p>We would very much appreciate if you could give it a spin by grabbing the <a href="https://github.com/parca-dev/parca/releases/tag/v0.11.0">latest Parca release</a> and try it out!</p><p>If you’re at KubeCon EU 2022, come say hi at our Polar Signals booth at SU8!</p><h2>We are hiring!</h2><p>If arcticDB sounds interesting to you, and you would like to work on and influence the future direction of the database, we just <a href="https://www.polarsignals.com/working-at-polar-signals/">opened a position for a database engineer</a>!</p></article></div>
  </body>
</html>
