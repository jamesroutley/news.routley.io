<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/brendanzab/d41c3ae485d66c07178749eaeeb9e5f7">Original</a>
    <h1>A personal list of Rust grievances</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="file-gistfile1-md">
      
      <div id="file-gistfile1-md-readme">
    <article itemprop="text"><blockquote>
<p dir="auto">September 2022:</p>
<p dir="auto">This has spread to a far wider audience than I had anticipated - probably my fault for using a title that is in hindsight catnip for link aggregators. I wrote this back in 2021 just as a bunch of personal thoughts of my experiences using Rust over the years (not always well thought through), and don&#39;t intend on trying to push them further, outside of personal experiments and projects.</p>
<p dir="auto">Managing a living language is challenging and difficult work, and I am grateful for all the hard work that the Rust community and contributors put in given the difficult constraints they work within. Many of the things I listed below are not new, and there&#39;s been plenty of difficult discussions about many of them over the years, and some are being worked on or postponed, or rejected for various good reasons. For more thoughts, please see <a href="https://gist.github.com/brendanzab/d41c3ae485d66c07178749eaeeb9e5f7?permalink_comment_id=4299063#gistcomment-4299063">my comment below</a>.</p>
</blockquote>

<p dir="auto">I love Rust and I have used it daily for many years as my go-to language, but I
do have my own list of grievances that give me enough itches to contemplate
playing with my own language ideas! <a href="https://twitter.com/ekuber/status/1440723316092768269" rel="nofollow">Esteban Kuber&#39;s tweet</a>
inspired me to compile these into a list, even if I don&#39;t consider myself a ‘hater’!</p>
<p dir="auto">Do note that Rust was a product of it&#39;s time, and was under many constraints in
during its development, and I don&#39;t begrudge the choices that were made. Many of
these things I only really recognise myself in hindsight!</p>
<ul dir="auto">
<li>Many sub-languages to learn, many with different syntaxes and semantics.
For example:
<ul dir="auto">
<li>the expression language
<ul dir="auto">
<li>unsafe runtime language</li>
<li>safe runtime language</li>
<li>compile time language</li>
</ul>
</li>
<li>the type language</li>
<li>the trait language</li>
<li>the macro language</li>
<li>the attribute language</li>
</ul>
</li>
<li>Language is designed in a monolithic fashion, as opposed to elaborating to a
simple, verifiable core language with roots in type theory.</li>
<li>NLL has access to tricks that are not expressible in type system, making it
impossible to factor out code in some cases.</li>
<li>Complicated, mutually recursive modules that make incremental compilation hard.</li>
<li>A large menagerie of traits that could point towards a lack of polymorphism:
<ul dir="auto">
<li>function types: <code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code></li>
<li>conversions: <code>From</code>, <code>TryFrom</code>, <code>Into</code>, <code>TryInto</code>, <code>As</code>, <code>AsRef</code>,  <code>AsMut</code></li>
</ul>
</li>
<li>Traits are hard to extend after the fact, and you can&#39;t break them into
smaller parts in a backwards-compatible way.</li>
<li>Traits bias the <code>Self</code> parameter, which can make some multi-parameter traits
rather odd.</li>
<li>No way of defining abstract types that conform to a given interface. You can
use traits, but these do not support abstract associated types, and require a
<code>Self</code> type. Supporting this kind of feature is now difficult due to the
complexity of traits (Haskell also struggles here).</li>
<li>Trait objects are a bit lackluster
<ul dir="auto">
<li>Complicated rules around object-safety.</li>
<li>Associated types are incompatible with trait objects.</li>
<li>Not allowed to combine trait objects</li>
<li>Could this all have been achieved with better support for existential types?</li>
</ul>
</li>
<li>Marker traits (like <code>Send</code> and <code>Sync</code>) are kind of weird? I don&#39;t fully
understand the complexities behind them, but IIRC have weird properties like
leaking through <code>impl</code> trait. I&#39;ve also heard it&#39;s hard/impossible add more of
them in the future.</li>
<li>Conflation of <code>mut</code> for unique references and for &#39;unfrozen&#39; local variables.</li>
<li>Specialisation breaks parametricity. This is not necessarily a bad thing imo,
but it&#39;s impossible to choose if type parameters are parametric or not.</li>
<li>Silly gripes about syntax:
<ul dir="auto">
<li>Angle-brackets (<code>&lt;</code>, <code>&gt;</code>) for generics is a bit of an eye-sore in complicated types.</li>
<li>Records use <code>:</code> in their literal form, which is overloaded with type ascription.
This is also annoying in cases where you might want to move a field into a let binding.</li>
<li>No space before the colon in type annotations in the default formatting.</li>
<li>Complexity in the grammar around:
<ul dir="auto">
<li>allowing semicolons to be omitted after some expressions, like <code>match</code>,
<code>if</code>/<code>else</code>, and <code>if</code>.</li>
<li>leaving off commas after blocks in match arms</li>
</ul>
</li>
<li>match expressions syntax leads to lots of nested indentation</li>
</ul>
</li>
<li>Async/await splits the ecosystem: having access to effect polymorphism would
have been nice (see the work on typed effect systems, like what Multicore
OCaml is working towards).</li>
<li>Type aliases are transparent (as opposed to abstract) by default, exposing
their definitions publicly.</li>
<li>Type aliases are leaky, and can expose implementation details via definitional
equality. There are some lints to catch this kind of thing, but they often
fail to fire.</li>
<li>Hard to keep track of whether functions are panic-safe or not.</li>
<li>While using allocators like arenas <em>is</em> possible through the use of crates,
Rust&#39;s standard library lacks much in the way of support for this style of
programming, and most libraries are not implemented with support for it, and
the ones that do are often incompatible with each other.</li>
<li>IO, file system, and other effect-based libraries are not capability-safe.</li>
<li>Poor sandboxing/security for procedural macros (see point on capability-based
security). Would be great if procedural macros would be only able to use
safe Rust, with stricter requirements on what capabilities they have access to.</li>
<li>Lack of support for typed, interactive programming through the use of
hole-driven development (As seen in Haskell, Purescript, Idris, Agda, etc).
<code>todo!()</code> gets you some of the way there, but it&#39;s not possible to use it in
places like types and patterns to express partially complete programs. Granted,
this could be less useful in the presence of impurity (due to less precise types).</li>
<li>You can&#39;t run broken Rust programs (translating compile time errors to runtime errors).</li>
<li>It might have been better to call <code>unsafe</code> blocks <code>trusted</code> blocks.</li>
<li>Lack of visibility of the &#39;trusted&#39; parts of code a library/code unit is
taking on. Less in the sense of naming/shaming, and more making it easier to
get visibility and double-check.</li>
<li>No support for using something like separation logic within Rust itself to
verify that unsafe code upholds the invariants that the safe language expects.</li>
<li>Confusion about whether to use <code>kebab-case</code> or <code>snake_case</code> for crate names
I now lean to the former, but it&#39;s impossible to import snake case crates
using kebab case, leading to an ugly mix in my <code>Cargo.toml</code> file.</li>
<li><code>Cargo.toml</code> is capitalised, unlike most other development files.</li>
</ul>
</article>
  </div>

  </div>
</div></div>
  </body>
</html>
