<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/1026694/3413f4b43c862629/">Original</a>
    <h1>How to write Rust in the Linux kernel: part 3</h1>
    
    <div id="readability-page-1" class="page"><div>
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://www.moderndescartes.com/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>

<p>
The interfaces between C and Rust in the kernel have grown over time; any
non-trivial Rust driver will use a number of these. Tasks like allocating memory,
dealing with immovable structures, and interacting with locks are necessary for
handling most devices. There are also many subsystem-specific bindings, but the
focus of this third item in our series on writing Rust in the kernel
will be on an overview of the bindings that all kernel Rust code
can be expected to use.
</p>

<p>
Rust code can call C using the
<a href="https://doc.rust-lang.org/nomicon/ffi.html">
foreign function interface</a> (FFI); given that, one
potential way to integrate Rust into the kernel would have been to let Rust
code call kernel C functions directly. There are a few problems with that
approach, however: <tt>__always_inline</tt> functions, non-idiomatic APIs, etc.
In particular, C and Rust have different approaches to freeing memory and
locking.
</p>

<p>
During the early planning phases, the project
<a href="https://www.moderndescartes.com/Articles/829858/">proposed</a> adopting a rule that there should be a
single, centralized set of Rust bindings for each subsystem,
as explained in
<a href="https://docs.kernel.org/rust/general-information.html#abstractions-vs-bindings">
the kernel documentation</a>. This has
the disadvantage (compared to direct use of Rust&#39;s FFI)
of creating some extra work for a Rust programmer who wishes to
call into a new area of the kernel, but as more bindings are written that need
should go away over time. The advantage of the approach is that there&#39;s a single
set of standardized Rust interfaces to learn, with all of the documentation in
<a href="https://rust.docs.kernel.org">
one
place</a>, which should make building and understanding the bindings less work
overall. The interfaces can also be reviewed by the Rust maintainers in one
place for safety and quality.
</p>

<h4>Allocating memory</h4>

<p>
Like C, Rust puts local variables (including compound structures)
on the stack by default. But most programs will
eventually need the flexibility offered by heap allocation and the limitations
on kernel-stack size mean that even purely local data may require
heap-allocation. In user space, Rust
programs use automatic heap allocations for some types — mainly
<a href="https://doc.rust-lang.org/stable/std/boxed/index.html">
<tt>Box</tt></a>
(a smart pointer into the heap) and
<a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html">
<tt>Vec</tt></a> (a growable, heap-allocated
array). In the kernel, these interfaces would not provide nearly enough control.
Instead, allocations are performed using the interfaces in the
<a href="https://rust.docs.kernel.org/kernel/alloc/index.html">
<tt>kernel::alloc</tt></a> module, which allow for specifying allocation flags
and handling the possibility of failure.
</p>

<p>
The Rust interfaces support three ways to allocate kernel memory: <tt>Kmalloc</tt>,
<tt>Vmalloc</tt>, and <tt>KVmalloc</tt>, corresponding to the
<a href="https://docs.kernel.org/core-api/mm-api.html">
memory-management API functions</a> with similar names.
The first two allocate physically contiguous memory
or virtually contiguous memory, respectively. <tt>KVmalloc</tt> first tries to allocate
physically contiguous memory, and then falls back to virtually contiguous memory. No matter which
allocator is used, the pointers that are exposed to Rust are part of the virtual
address space, as in C.
</p>

<p>
These three different types all implement the
<a href="https://rust.docs.kernel.org/kernel/alloc/trait.Allocator.html">
<tt>Allocator</tt></a> interface, which is similar to
<a href="https://doc.rust-lang.org/std/alloc/trait.Allocator.html">
the unstable user-space trait</a>
of the same name. While the allocators can be used to directly create a
<tt>[u8]</tt> (a sized array of bytes; conceptually similar to how
<tt>malloc()</tt> returns a <tt>void *</tt> instead of a specific type),
the more ergonomic and less
error-prone use is to allocate
<tt>Box</tt> or
<tt>Vec</tt> structures. Since memory allocation is so common, the interfaces provide short
aliases for boxes and vectors made with each allocator, such as <tt>KBox</tt>,
<tt>KVBox</tt>, <tt>VVec</tt>, etc. Reference counted allocations can be made
with
<a href="https://rust.docs.kernel.org/kernel/sync/struct.Arc.html"><tt>Arc</tt></a>.
</p>

<p>
The choice of allocator is far from the only thing that kernel programmers care
about when allocating memory, however. Depending on the context, it may or may
not be acceptable to block, to swap, or to receive memory from
<a href="https://www.moderndescartes.com/Articles/964239/">
a particular zone</a>. When allocating, the flags in
<a href="https://rust.docs.kernel.org/kernel/alloc/flags/index.html">
<tt>kernel::alloc::flags</tt></a> can be used to
<a href="https://www.moderndescartes.com/Articles/920891/">
specify more details</a> about how the necessary memory should be obtained:
</p>

<pre>    let boxed_integer: Result&lt;KBox&lt;u64&gt;, AllocError&gt; = KBox::new(42, GFP_KERNEL);
</pre>

<p>
That example allocates an unsigned 64-bit integer, initialized to 42, with the
usual set of allocation flags (<tt>GFP_KERNEL</tt>).
For a small allocation like this, that likely means the
memory will come from the kernel&#39;s slab allocator, possibly after triggering
memory reclamation or blocking.
This particular allocation
<a href="https://www.moderndescartes.com/Articles/627419/">cannot fail</a>, but a larger one using the same API could,
if there is no suitable memory available,
even after reclamation.
Therefore, the <tt>KBox::new()</tt> function doesn&#39;t return the resulting heap allocation
directly. Instead, it returns a
<a href="https://rust.docs.kernel.org/kernel/error/type.Result.html">
<tt>Result</tt></a> that contains either the
successful heap allocation, or an
<a href="https://rust.docs.kernel.org/kernel/alloc/struct.AllocError.html">
<tt>AllocError</tt></a>.
</p>

<div>
<h4>Reading generic types</h4>
<p>
C doesn&#39;t really have an equivalent of Rust&#39;s
<a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">
generic types</a>; the closest
might be
<a href="https://danielchasehooper.com/posts/typechecked-generic-c-data-structures/">
a macro</a> that can be used to define a structure with different types
substituted in for a field. In this case, the
<tt>Result</tt> that
<tt>KBox::new()</tt> returns has been given two additional types as parameters.
The first is the data associated with a non-error result, and the second is the
data associated with an error result. Matching angle brackets in a Rust type
always play this role of specifying a (possibly optional) type to include as a
field nested somewhere inside the structure.
</p>
</div>

<p>
Boxes, as smart pointers, have a few nice properties compared to raw pointers. A
<tt>KBox</tt> is always initialized — <tt>KBox::new()</tt> takes an initial value,
as shown in the example above. Boxes are also automatically freed when they are
no longer referenced, which is almost always what one wants from a heap
allocation. When that isn&#39;t the case, the
<a href="https://rust.docs.kernel.org/kernel/alloc/kbox/struct.Box.html#method.leak">
<tt>KBox::leak()</tt></a> or
<a href="https://rust.docs.kernel.org/kernel/alloc/kbox/struct.Box.html#method.into_raw">
<tt>KBox::into_raw()</tt></a> methods can be used to override Rust&#39;s lifetime analysis
and let the heap allocation live until the programmer takes care of it with
<a href="https://rust.docs.kernel.org/kernel/alloc/kbox/struct.Box.html#method.from_raw">
<tt>KBox::from_raw()</tt></a>.
</p>

<p>
Of course, there are also times when a programmer would like to allocate space
on the heap, but not actually fill it with anything yet. For example, the Rust
<a href="https://rust.docs.kernel.org/kernel/uaccess/index.html">
user-space memory bindings</a> use it to
<a href="https://rust.docs.kernel.org/src/kernel/uaccess.rs.html#256">
allocate a buffer</a> for user-space data to be copied into without initializing it.
Rust
indicates that a structure may be uninitialized by wrapping it in
<a href="https://rust.docs.kernel.org/core/mem/union.MaybeUninit.html">
<tt>MaybeUninit</tt></a>; allocating a <tt>Box</tt> holding a <tt>MaybeUninit</tt>
works just fine.
</p>

<h4>Self-referential structures</h4>

<p>
The kernel features a number of self-referential structures, such as doubly
linked lists. Sharing these structures with Rust code poses a problem: moving a
value that refers to itself (including indirectly) could cause the invariants
of this kind of structure to be violated. For example, if a doubly linked list
node is moved, <tt>node-&gt;prev-&gt;next</tt> will no longer refer to the right
address. In C, programmers are expected to just not do that.
</p>

<p>
But Rust tries to localize dangerous operations to
areas of the code marked with <tt>unsafe</tt>.
Moving values around is a common thing to do; it would be inconvenient if
it were considered unsafe. To solve this, the Rust developers created an idea called
&#34;pinning&#34;, which is used to mark structures that cannot be safely relocated.
The standard library is designed in such a way that these structures cannot be
moved by accident. The
Rust kernel developers imported the same idea into the kernel Rust APIs; when
referencing a self-referential structure created in C, it must
be wrapped in the
<a href="https://rust.docs.kernel.org/core/pin/struct.Pin.html">
<tt>Pin</tt></a> type on the Rust side. (Some other pointers in the kernel API,
notably <tt>Arc</tt>, include an implicit <tt>Pin</tt>, so the wrapping may not
always be visible). It might not immediately cause
problems if <tt>Pin</tt> were omitted in the Rust bindings for a
self-referential structure, but it would still
be unsound, since it could let ostensibly safe Rust driver code cause memory
corruption.
</p>

<p>
To simplify the process of allocating a large structure with multiple pinned
components, the Rust API includes the
<a href="https://rust.docs.kernel.org/kernel/prelude/macro.pin_init.html">
<tt>pin_init!()</tt></a> and
<a href="https://rust.docs.kernel.org/kernel/macro.try_pin_init.html">
<tt>try_pin_init!()</tt></a> macros. Prior to their inclusion in the kernel,
creating a pinned allocation was a multi-step process using unsafe APIs. The
macro works along with the
<a href="https://rust.docs.kernel.org/pin_init/attr.pin_data.html"><tt>#[pin_data]</tt>
and <tt>#[pin]</tt></a> macros in a structure&#39;s definition to build a custom
initializer.
These
<a href="https://rust.docs.kernel.org/kernel/prelude/trait.PinInit.html">
<tt>PinInit</tt> initializers</a> represent the process of constructing a
pinned structure. They can be written by hand, but the process is tedious, so
the macros are normally used instead.
<a href="https://hackmd.io/@aliceryhl/BJutRcPblx">
Language-level support</a> is the subject of
ongoing debate in the Rust community.
<tt>PinInit</tt> structures can be passed around or reused to build an
initializer for a
larger partially-pinned structure, before finally being given to an allocator to
be turned into a real value of the appropriate type. See below for an example.
</p>

<h4>Locks</h4>

<p>
User-space Rust code typically organizes locks by having structures that wrap
the data covered by the lock. The kernel API makes lock implementations matching
that convention available. For example, a
<a href="https://rust.docs.kernel.org/kernel/sync/lock/mutex/type.Mutex.html">
<tt>Mutex</tt></a> actually contains
the data that it protects, so that it can ensure all accesses to the data are
made with the <tt>Mutex</tt> locked. Since C code doesn&#39;t tend to work like
this, the kernel&#39;s existing locking mechanisms don&#39;t translate directly into Rust.
</p>

<p>
In addition to traditional Rust-style locks, the kernel&#39;s Rust APIs include
special types for dealing with locks separated from the data they protect:
<a href="https://rust.docs.kernel.org/kernel/sync/struct.LockedBy.html">
<tt>LockedBy</tt></a>, and
<a href="https://rust.docs.kernel.org/kernel/sync/struct.GlobalLockedBy.html">
<tt>GlobalLockedBy</tt></a>. These use Rust&#39;s lifetime system
to enforce that a specific
lock is held when the data is accessed.
</p>

<p>
Currently, the Rust bindings in <tt>kernel::sync</tt> support spinlocks,
mutexes, and read-side read-copy-update (RCU) locks. When asked to look over an
early draft of this article, Benno Lossin warned that the
current RCU support is &#34;<q>very barebones</q>&#34;, but that the Rust developers
plan to expand on it over time. The spinlocks and mutexes in these bindings require a
<a href="https://docs.kernel.org/locking/lockdep-design.html">
lockdep class key</a> to create,
so all of the locks used in Rust are automatically
covered by the kernel&#39;s internal locking validator.
Internally, this involves creating some self-referential
state, so both spinlocks and mutexes must be pinned in order to be used.
In all, defining a lock in Rust ends up looking like this example lightly
adapted from some of the
Rust
<a href="https://elixir.bootlin.com/linux/v6.16-rc4/source/samples/rust/rust_configfs.rs">
sample code</a>:
</p>

<pre>    // The `#[pin_data]` macro builds the custom initializer for this type.
    #[pin_data]
    struct Configuration {
        #[pin]
        data: Mutex&lt;(KBox&lt;[u8; PAGE_SIZE]&gt;, usize)&gt;,
    }

    impl Configuration {
        // The value returned can be used to build a larger structure, or it can
        // be allocated on the heap with `KBox::pin_init()`.
        fn new() -&gt; impl PinInit&lt;Self, Error&gt; {
            try_pin_init!(Self {
                // The `new_mutex!()` macro creates a new lockdep class and
                // initializes the mutex with it.
                data &lt;- new_mutex!((KBox::new([0; PAGE_SIZE], flags::GFP_KERNEL)?, 0)),
            })
        }
    }

    // Once created, references to the structure containing the lock can be
    // passed around in the normal way.
    fn show(container: &amp;Configuration, page: &amp;mut [u8; PAGE_SIZE]) -&gt; Result&lt;usize&gt; {
        // Calling the mutex&#39;s `lock()` function returns a smart pointer that
        // allows access only so long as the lock is held.
        let guard = container.data.lock();
        let data = guard.0.as_slice();
        let len = guard.1;
        page[0..len].copy_from_slice(&amp;data[0..len]);
        Ok(len)
        // `guard` is automatically dropped at the end of its containing scope,
        // freeing the lock. Trying to return data from inside the lock past the
        // end of the function without copying it would be a compile-time error.
    }
</pre>

<p>
Using a lock defined in C works much like in <tt>show()</tt> above, except that there
is an additional step to handle the fact that the data may not be directly
contained in the lock structure:
</p>

<pre>    // The C lock will still be released when guard goes out of scope.
    let guard = c_lock.lock();
    // Data that is marked as `LockedBy` in the Rust/C bindings takes a reference
    // to the guard of the matching lock as evidence that the lock has been acquired.
    let data = some_other_structure.access(&amp;guard);
</pre>

<p>
See
<a href="https://rust.docs.kernel.org/kernel/sync/struct.LockedBy.html#examples">the
<tt>LockedBy</tt> examples</a> for a complete demonstration.
The interface is slightly more conceptually complicated than C&#39;s
<a href="https://docs.kernel.org/kernel-hacking/locking.html#c.mutex_lock">
<tt>mutex_lock()</tt> and
<tt>mutex_unlock()</tt></a>, but it does have the nice
property of producing a compiler error instead of a run-time error for many
kinds of mistakes. The mutex in this example cannot be double-locked or
double-freed, nor can the data be accessed without the lock held. It can still be
locked from a non-sleepable context or get involved in a deadlock, however, so
some care is still required — at least until the
<a href="https://rust-for-linux.com/klint">custom tooling to track and enforce
kernel locking rules</a> at compile time is complete.
</p>

<p>
This kind of safer interface
is, of course, the ultimate purpose behind introducing Rust bindings into
the kernel — to make it possible to write drivers where more errors can be
caught at compile time. No machine-checked set of rules can catch everything,
however, so the next (and likely final) article in this series will focus on
things to look for when reviewing Rust patches.
</p></div></div>
  </body>
</html>
