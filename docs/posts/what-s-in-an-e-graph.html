<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bernsteinbear.com/blog/whats-in-an-egraph/?utm_source=rss">Original</a>
    <h1>What&#39;s in an e-graph?</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p><em>This post follows from several conversations with <a href="https://cfbolz.de/">CF
Bolz-Tereick</a>, <a href="https://www.philipzucker.com/">Philip
Zucker</a>, <a href="https://cfallin.org/">Chris Fallin</a>,
and <a href="https://www.mwillsey.com/">Max Willsey</a>.</em></p>

<p>Compilers are all about program representations. They take in a program in one
language, transform some number of ways through some different internal
languages, and output the program in another language<sup id="fnref:languages" role="doc-noteref"><a href="#fn:languages" rel="footnote">1</a></sup>.</p>

<p>Part of the value in the inter-language transformations is optimizing the
program. This can mean making it faster, smaller, or something else. Optimizing
requires making changes to the program. For example, consider the following
piece of code in a made-up IR:</p>

<div><div><pre><code>v0 = ...
v1 = Const 8
v2 = v0 * v1
</code></pre></div></div>

<p>If the compiler wants to optimize the instruction for <code>v2</code>, it has to go
through and logically replace all uses of <code>v2</code> with the replacement
instruction. This is a rewrite.</p>

<p>Many compilers will go through and iterate through every instruction and check
if that instruction <code>op</code> uses the original instruction <code>v2</code>. If it does, it
will swap all of its uses of <code>v2</code> with the replacement instruction.</p>

<div><div><pre><code><span>void</span> <span>very_specific_optimization</span><span>(</span><span>Instr</span><span>*</span> <span>instr</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>instr</span><span>-&gt;</span><span>IsMul</span><span>()</span> <span>&amp;&amp;</span> <span>instr</span><span>-&gt;</span><span>Operand</span><span>(</span><span>1</span><span>)</span><span>-&gt;</span><span>IsConst</span><span>()</span> <span>&amp;&amp;</span>
      <span>instr</span><span>-&gt;</span><span>Operand</span><span>(</span><span>1</span><span>)</span><span>-&gt;</span><span>AsConst</span><span>()</span><span>-&gt;</span><span>Value</span><span>()</span> <span>==</span> <span>8</span><span>)</span> <span>{</span>
    <span>Instr</span><span>*</span> <span>replacement</span> <span>=</span> <span>new</span> <span>LeftShift</span><span>(</span><span>instr</span><span>-&gt;</span><span>Operand</span><span>(</span><span>0</span><span>),</span> <span>new</span> <span>Const</span><span>(</span><span>3</span><span>));</span>
    <span>for</span> <span>(</span><span>auto</span> <span>op</span> <span>:</span> <span>block</span><span>.</span><span>ops</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>op</span><span>-&gt;</span><span>uses</span><span>(</span><span>instr</span><span>))</span> <span>{</span>
        <span>op</span><span>-&gt;</span><span>replace_use</span><span>(</span><span>instr</span><span>,</span> <span>replacement</span><span>);</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This is fine. It’s very traditional. Depending on the size and complexity of
your programs, this can work. It’s how the <a href="https://github.com/facebookincubator/cinder/">Cinder
JIT</a> works for its two IRs. It’s
very far from causing any performance problems in the compiler. But there are
other compilers with other constraints and therefore other approaches to doing
these rewrites.</p>

<p>In this post, I’m going to take you on a bit of a meandering walk. We’ll start
from an alternative to find-and-replace called <em>union-find</em> and then
incrementally add features until we accidentally have built another data
strucutre called an <em>e-graph</em>. Hopefully it removes some of the mystery.</p>

<h2 id="union-find">Union-find</h2>

<p>I love union-find. It enables fast, easy, in-place IR rewrites for compiler
authors. Its API has two main functions: <code>union</code> and <code>find</code>. The minimal
implementation is about 15 lines of code and is embeddable directly in your IR.</p>

<p>Instead of iterating through every operation in the basic block and swapping
pointers, we instead mark our IR node as “pointing to” another node. The below
snippet replaces the entire loop in the previous example:</p>

<div><div><pre><code><span>instr</span><span>-&gt;</span><span>make_equal_to</span><span>(</span><span>new</span> <span>LeftShift</span><span>(</span><span>instr</span><span>-&gt;</span><span>Operand</span><span>(</span><span>0</span><span>),</span> <span>new</span> <span>Const</span><span>(</span><span>3</span><span>)));</span>
</code></pre></div></div>

<p>This notion of a forwarding pointer can be either embedded in the IR node
itself or in an auxiliary table. Each node maintains its source of truth, and
each rewrite takes only one pointer swap (yes, there’s some pointer chasing,
but it’s <em>very little</em> pointer chasing<sup id="fnref:advanced-features" role="doc-noteref"><a href="#fn:advanced-features" rel="footnote">2</a></sup>). It’s a classic
time-space trade-off, though. You have to store ~1 additional pointer of space
for each IR node.</p>

<p>See below an adaptation of CF’s implementation from the toy optimizer
series<sup id="fnref:also-phil" role="doc-noteref"><a href="#fn:also-phil" rel="footnote">3</a></sup>:</p>

<div><div><pre><code><span>from</span> <span>__future__</span> <span>import</span> <span>annotations</span>
<span>from</span> <span>dataclasses</span> <span>import</span> <span>dataclass</span>
<span>from</span> <span>typing</span> <span>import</span> <span>Optional</span>

<span>@</span><span>dataclass</span>
<span>class</span> <span>Expr</span><span>:</span>
    <span>forwarded</span><span>:</span> <span>Optional</span><span>[</span><span>Expr</span><span>]</span> <span>=</span> <span>dataclasses</span><span>.</span><span>field</span><span>(</span>
        <span>default</span><span>=</span><span>None</span><span>,</span>
        <span>init</span><span>=</span><span>False</span><span>,</span>
        <span>compare</span><span>=</span><span>False</span><span>,</span>
        <span>hash</span><span>=</span><span>False</span><span>,</span>
    <span>)</span>

    <span>def</span> <span>find</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>Expr</span><span>:</span>
        <span>&#34;&#34;&#34;Return the representative of the set containing `self`.&#34;&#34;&#34;</span>
        <span>expr</span> <span>=</span> <span>self</span>
        <span>while</span> <span>expr</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
            <span>next</span> <span>=</span> <span>expr</span><span>.</span><span>forwarded</span>
            <span>if</span> <span>next</span> <span>is</span> <span>None</span><span>:</span>
                <span>return</span> <span>expr</span>
            <span>expr</span> <span>=</span> <span>next</span>
        <span>return</span> <span>expr</span>

    <span>def</span> <span>make_equal_to</span><span>(</span><span>self</span><span>,</span> <span>other</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
        <span>&#34;&#34;&#34;Union the set containing `self` with the set containing `other`.&#34;&#34;&#34;</span>
        <span>found</span> <span>=</span> <span>self</span><span>.</span><span>find</span><span>()</span>
        <span>if</span> <span>found</span> <span>is</span> <span>not</span> <span>other</span><span>:</span>
            <span>found</span><span>.</span><span>forwarded</span> <span>=</span> <span>other</span>
</code></pre></div></div>

<p>Union-find can be so fast because it is limited in its expressiveness:</p>

<ul>
  <li>There’s no built-in way to enumerate the elements of a set</li>
  <li>Each set has a single representative element</li>
  <li>We only care about the representative of a set</li>
</ul>

<p>(If you want to read more about it, check out the first half of my other post,
<a href="https://cyberb.space/blog/vectorizing-ml-models/">Vectorizing ML models for fun</a>, the <a href="https://pypy.org/posts/2022/07/toy-optimizer.html">toy
optimizer</a>, <a href="https://pypy.org/posts/2022/10/toy-optimizer-allocation-removal.html">allocation
removal in the toy
optimizer</a>,
and <a href="https://bernsteinbear.com/blog/toy-abstract-interpretation/">abstract interpretation in the toy
optimizer</a>.)</p>

<p>This is really great for some compiler optimizations, like the strength
reduction we did above. Here is the IR snippet again:</p>

<div><div><pre><code>v0 = ...
v1 = Const 8
v2 = v0 * v1
</code></pre></div></div>

<p>A strength reduction pass might rewrite <code>v2</code> as a left shift instead of a
multiplication (<code>v2.make_equal_to(LeftShift(v0, Const(3)))</code>) because left
shifts are often faster than multiplications. That’s great; we got a small
speedup.</p>

<p>But seemingly obvious local rewrites can have less-local consequences. Consider
the expression <code>(a * 2) / 2</code>, which is the example from the <a href="https://egraphs-good.github.io/">e-graphs
good</a> website and paper. If our strength
reduction pass eagerly rewrites <code>a * 2</code> to <code>a &lt;&lt; 1</code>, we’ve lost some
information.</p>

<p>This rewrite stops another hypothetical pass from recognizing that expressions
of the form <code>(a * b) / b</code> are equivalent to <code>a * (b / b)</code> and therefore
equivalent to <code>a</code>. This is because rewrites that use union-find are
destructive; we’ve gotten rid of the multiplication. How might we find it
again?</p>

<h2 id="enumerating-the-equivalence-classes">Enumerating the equivalence classes</h2>

<p>Let’s make this more concrete and conjure a little math IR. We’ll base it on
the <code>Expr</code> base class because it’s rewritable using union-find.</p>

<div><div><pre><code><span>@</span><span>dataclass</span>
<span>class</span> <span>Const</span><span>(</span><span>Expr</span><span>):</span>
    <span>value</span><span>:</span> <span>int</span>

<span>@</span><span>dataclass</span>
<span>class</span> <span>Var</span><span>(</span><span>Expr</span><span>):</span>
    <span>name</span><span>:</span> <span>str</span>

<span>@</span><span>dataclass</span>
<span>class</span> <span>BinaryOp</span><span>(</span><span>Expr</span><span>):</span>
    <span>left</span><span>:</span> <span>Expr</span>
    <span>right</span><span>:</span> <span>Expr</span>

<span>@</span><span>dataclass</span>
<span>class</span> <span>Add</span><span>(</span><span>BinaryOp</span><span>):</span>
    <span>pass</span>

<span>@</span><span>dataclass</span>
<span>class</span> <span>Mul</span><span>(</span><span>BinaryOp</span><span>):</span>
    <span>pass</span>

<span>@</span><span>dataclass</span>
<span>class</span> <span>Div</span><span>(</span><span>BinaryOp</span><span>):</span>
    <span>pass</span>

<span>@</span><span>dataclass</span>
<span>class</span> <span>LeftShift</span><span>(</span><span>BinaryOp</span><span>):</span>
    <span>pass</span>
</code></pre></div></div>

<p>It’s just constants and variables and binary operations but it’ll do for our
demo.</p>

<p>Let’s also write a little optimization pass that can do limited constant
folding, simplification, and strength reduction. We have a function
<code>optimize_one</code> that looks at an individual operation and tries to simplify it
and a function <code>optimize</code> that applies <code>optimize_one</code> to a list of
operations—a basic block, if you will.</p>

<div><div><pre><code><span>def</span> <span>is_const</span><span>(</span><span>op</span><span>:</span> <span>Expr</span><span>,</span> <span>value</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>bool</span><span>:</span>
    <span>return</span> <span>isinstance</span><span>(</span><span>op</span><span>,</span> <span>Const</span><span>)</span> <span>and</span> <span>op</span><span>.</span><span>value</span> <span>==</span> <span>value</span>

<span>def</span> <span>optimize_one</span><span>(</span><span>op</span><span>:</span> <span>Expr</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>op</span><span>,</span> <span>BinaryOp</span><span>):</span>
        <span>left</span> <span>=</span> <span>op</span><span>.</span><span>left</span><span>.</span><span>find</span><span>()</span>
        <span>right</span> <span>=</span> <span>op</span><span>.</span><span>right</span><span>.</span><span>find</span><span>()</span>
        <span>if</span> <span>isinstance</span><span>(</span><span>op</span><span>,</span> <span>Add</span><span>):</span>
            <span>if</span> <span>isinstance</span><span>(</span><span>left</span><span>,</span> <span>Const</span><span>)</span> <span>and</span> <span>isinstance</span><span>(</span><span>right</span><span>,</span> <span>Const</span><span>):</span>
                <span>op</span><span>.</span><span>make_equal_to</span><span>(</span><span>Const</span><span>(</span><span>left</span><span>.</span><span>value</span> <span>+</span> <span>right</span><span>.</span><span>value</span><span>))</span>
            <span>elif</span> <span>is_const</span><span>(</span><span>left</span><span>,</span> <span>0</span><span>):</span>
                <span>op</span><span>.</span><span>make_equal_to</span><span>(</span><span>right</span><span>)</span>
            <span>elif</span> <span>is_const</span><span>(</span><span>right</span><span>,</span> <span>0</span><span>):</span>
                <span>op</span><span>.</span><span>make_equal_to</span><span>(</span><span>left</span><span>)</span>
        <span>elif</span> <span>isinstance</span><span>(</span><span>op</span><span>,</span> <span>Mul</span><span>):</span>
            <span>if</span> <span>is_const</span><span>(</span><span>left</span><span>,</span> <span>1</span><span>):</span>
                <span>op</span><span>.</span><span>make_equal_to</span><span>(</span><span>right</span><span>)</span>
            <span>elif</span> <span>is_const</span><span>(</span><span>right</span><span>,</span> <span>1</span><span>):</span>
                <span>op</span><span>.</span><span>make_equal_to</span><span>(</span><span>left</span><span>)</span>
            <span>elif</span> <span>is_const</span><span>(</span><span>right</span><span>,</span> <span>2</span><span>):</span>
                <span>op</span><span>.</span><span>make_equal_to</span><span>(</span><span>Add</span><span>(</span><span>left</span><span>,</span> <span>left</span><span>))</span>
                <span>op</span><span>.</span><span>make_equal_to</span><span>(</span><span>LeftShift</span><span>(</span><span>left</span><span>,</span> <span>Const</span><span>(</span><span>1</span><span>)))</span>

<span>def</span> <span>optimize</span><span>(</span><span>ops</span><span>:</span> <span>list</span><span>[</span><span>Expr</span><span>]):</span>
    <span>for</span> <span>op</span> <span>in</span> <span>ops</span><span>:</span>
        <span>optimize_one</span><span>(</span><span>op</span><span>.</span><span>find</span><span>())</span>
</code></pre></div></div>

<p>Let’s give it a go and see what it does to our initial smaller IR snippet that
added two constants<sup id="fnref:printing-niceties" role="doc-noteref"><a href="#fn:printing-niceties" rel="footnote">4</a></sup>:</p>

<div><div><pre><code><span>ops</span> <span>=</span> <span>[</span>
    <span>a</span> <span>:</span><span>=</span> <span>Const</span><span>(</span><span>1</span><span>),</span>
    <span>b</span> <span>:</span><span>=</span> <span>Const</span><span>(</span><span>2</span><span>),</span>
    <span>c</span> <span>:</span><span>=</span> <span>Add</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>),</span>
<span>]</span>
<span>print</span><span>(</span><span>&#34;BEFORE:&#34;</span><span>)</span>
<span>for</span> <span>op</span> <span>in</span> <span>ops</span><span>:</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;v</span><span>{</span><span>op</span><span>.</span><span>id</span><span>}</span><span> =&#34;</span><span>,</span> <span>op</span><span>.</span><span>find</span><span>())</span>
<span>optimize</span><span>(</span><span>ops</span><span>)</span>
<span>print</span><span>(</span><span>&#34;AFTER:&#34;</span><span>)</span>
<span>for</span> <span>op</span> <span>in</span> <span>ops</span><span>:</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;v</span><span>{</span><span>op</span><span>.</span><span>id</span><span>}</span><span> =&#34;</span><span>,</span> <span>op</span><span>.</span><span>find</span><span>())</span>
<span># BEFORE:
# v0 = Const&lt;1&gt;
# v1 = Const&lt;2&gt;
# v2 = Add v0 v1
# AFTER:
# v0 = Const&lt;1&gt;
# v1 = Const&lt;2&gt;
# v2 = Const&lt;3&gt;
</span></code></pre></div></div>

<p>Alright, it works. We can fold <code>1+2</code> to <code>3</code>. Hurrah. But the point of this
section of the post is to discover the equivalence classes implicitly
constructed by the union-find structure. Let’s write a function to do that.</p>

<p>To build such a function, we’ll need to iterate over all operations created. I
chose to explicitly keep track of every operation in a list, but you could also
write a function to walk the <code>forwarded</code> chains of all reachable operations.</p>

<div><div><pre><code><span>every_op</span> <span>=</span> <span>[]</span>

<span>@</span><span>dataclass</span>
<span>class</span> <span>Expr</span><span>:</span>
    <span># ...
</span>    <span>def</span> <span>__post_init__</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
        <span>every_op</span><span>.</span><span>append</span><span>(</span><span>self</span><span>)</span>

<span># ...
</span>
<span>def</span> <span>discover_eclasses</span><span>(</span><span>ops</span><span>:</span> <span>list</span><span>[</span><span>Expr</span><span>])</span> <span>-&gt;</span> <span>dict</span><span>[</span><span>Expr</span><span>,</span> <span>set</span><span>[</span><span>Expr</span><span>]]:</span>
    <span>eclasses</span><span>:</span> <span>dict</span><span>[</span><span>Expr</span><span>,</span> <span>set</span><span>[</span><span>Expr</span><span>]]</span> <span>=</span> <span>{}</span>
    <span>for</span> <span>op</span> <span>in</span> <span>ops</span><span>:</span>
        <span>found</span> <span>=</span> <span>op</span><span>.</span><span>find</span><span>()</span>
        <span>if</span> <span>found</span> <span>not</span> <span>in</span> <span>eclasses</span><span>:</span>
            <span># Key by the representative
</span>            <span>eclasses</span><span>[</span><span>found</span><span>]</span> <span>=</span> <span>set</span><span>()</span>
        <span>eclasses</span><span>[</span><span>found</span><span>].</span><span>add</span><span>(</span><span>op</span><span>)</span>
        <span>if</span> <span>op</span> <span>is</span> <span>not</span> <span>found</span><span>:</span>
            <span># Alias the entries so that looking up non-representatives also
</span>            <span># finds equivalent operations
</span>            <span>eclasses</span><span>[</span><span>op</span><span>]</span> <span>=</span> <span>eclasses</span><span>[</span><span>found</span><span>]</span>
    <span>return</span> <span>eclasses</span>

<span># ...
</span><span>print</span><span>(</span><span>&#34;ECLASSES:&#34;</span><span>)</span>
<span>eclasses</span> <span>=</span> <span>discover_eclasses</span><span>(</span><span>every_op</span><span>.</span><span>copy</span><span>())</span>
<span>for</span> <span>op</span> <span>in</span> <span>ops</span><span>:</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;v</span><span>{</span><span>op</span><span>.</span><span>id</span><span>}</span><span> =&#34;</span><span>,</span> <span>eclasses</span><span>[</span><span>op</span><span>])</span>
<span># BEFORE:
# v0 = Const&lt;1&gt;
# v1 = Const&lt;2&gt;
# v2 = Add v0 v1
# AFTER:
# v0 = Const&lt;1&gt;
# v1 = Const&lt;2&gt;
# v2 = Const&lt;3&gt;
# ECLASSES:
# v0 = {Const&lt;1&gt;}
# v1 = {Const&lt;2&gt;}
# v2 = {Const&lt;3&gt;, Add v0 v1}
</span></code></pre></div></div>

<p>Let’s go back to our more complicated IR example from the egg website, this
time expressed in our little IR:</p>

<div><div><pre><code><span>ops</span> <span>=</span> <span>[</span>
    <span>a</span> <span>:</span><span>=</span> <span>Var</span><span>(</span><span>&#34;a&#34;</span><span>),</span>
    <span>b</span> <span>:</span><span>=</span> <span>Const</span><span>(</span><span>2</span><span>),</span>
    <span>c</span> <span>:</span><span>=</span> <span>Mul</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>),</span>
    <span>d</span> <span>:</span><span>=</span> <span>Div</span><span>(</span><span>c</span><span>,</span> <span>b</span><span>),</span>
<span>]</span>
</code></pre></div></div>

<p>If we run our optimizer on it right now, we’ll eagerly rewrite the
multiplication into a left-shift, but then rediscover the multiply in the
equivalence classes (now I’ve added little <code>*</code> to indicate the union-find
representatives of each equivalence class):</p>

<div><div><pre><code>BEFORE:
v0 = Var&lt;a&gt;
v1 = Const&lt;2&gt;
v2 = Mul v0 v1
v3 = Div v2 v1
AFTER:
v0 = Var&lt;a&gt;
v1 = Const&lt;2&gt;
v2 = LeftShift v0 v5
v3 = Div v6 v1
ECLASSES:
v0 = * {Var&lt;a&gt;}
v1 = * {Const&lt;2&gt;}
v2 =   {LeftShift v0 v5, Add v0 v0, Mul v0 v1}
v3 = * {Div v6 v1}
v4 =   {LeftShift v0 v5, Add v0 v0, Mul v0 v1}
v5 = * {Const&lt;1&gt;}
v6 = * {LeftShift v0 v5, Add v0 v0, Mul v0 v1}
</code></pre></div></div>

<p>That solves one problem: at any point, we can enumerate the equivalence classes
stored in the union-find structure. But, like all data structures, the
union-find representation we’ve chosen has a trade-off: fast to rewrite, slow
to enumerate. We’ll accept that for now.</p>

<!-- TODO parallel worlds of graphs -->

<p>This enumeration feature on its own does not comprise one of the APIs of an
e-graph. To graft on e-matching to union-find, we’ll need to do one more step:
a search. Some would call it <code>match</code>.</p>

<h2 id="matching">Matching</h2>

<p>So we can rediscover the multiplication even after reducing it to a left shift.
That’s nice. But how can we do pattern matching on this data representation?</p>

<p>Let’s return to <code>(a * b) / b</code>. This corresponds to the IR-land Python
expression of <code>Div(Mul(a, b), b)</code> for any expressions <code>a</code> and <code>b</code> (and keeping
the <code>b</code>s equal, which is not the default in a Python <code>match</code> pattern).</p>

<p>For a given operation, we can see if there is a <code>Div</code> in its equivalence class
by looping over the entire equivalence class:</p>

<div><div><pre><code><span>def</span> <span>optimize_match</span><span>(</span><span>op</span><span>:</span> <span>Expr</span><span>,</span> <span>eclasses</span><span>:</span> <span>dict</span><span>[</span><span>Expr</span><span>,</span> <span>set</span><span>[</span><span>Expr</span><span>]]):</span>
    <span># Find cases of the form a / b
</span>    <span>for</span> <span>e0</span> <span>in</span> <span>eclasses</span><span>[</span><span>op</span><span>]:</span>
        <span>if</span> <span>isinstance</span><span>(</span><span>e0</span><span>,</span> <span>Div</span><span>):</span>
            <span># ...
</span></code></pre></div></div>

<p>That’s all well and good, but how do we find if it’s a <code>Div</code> of a <code>Mul</code>? We
loop again!</p>

<div><div><pre><code><span>def</span> <span>optimize_match</span><span>(</span><span>op</span><span>:</span> <span>Expr</span><span>,</span> <span>eclasses</span><span>:</span> <span>dict</span><span>[</span><span>Expr</span><span>,</span> <span>set</span><span>[</span><span>Expr</span><span>]]):</span>
    <span># Find cases of the form (a * b) / c
</span>    <span>for</span> <span>e0</span> <span>in</span> <span>eclasses</span><span>[</span><span>op</span><span>]:</span>
        <span>if</span> <span>isinstance</span><span>(</span><span>e0</span><span>,</span> <span>Div</span><span>):</span>
            <span>div_left</span> <span>=</span> <span>e0</span><span>.</span><span>left</span>
            <span>div_right</span> <span>=</span> <span>e0</span><span>.</span><span>right</span>
            <span>for</span> <span>e1</span> <span>in</span> <span>eclasses</span><span>[</span><span>div_left</span><span>]:</span>
                <span>if</span> <span>isinstance</span><span>(</span><span>e1</span><span>,</span> <span>Mul</span><span>):</span>
                    <span># ...
</span></code></pre></div></div>

<p>Note how we don’t need to call <code>.find()</code> on anything because we’ve already
aliased the set in the equivalence classes dictionary for convenience.</p>

<p>And how do we hold the <code>b</code>s equal? Well, we can check if they match:</p>

<div><div><pre><code><span>def</span> <span>optimize_match</span><span>(</span><span>op</span><span>:</span> <span>Expr</span><span>,</span> <span>eclasses</span><span>:</span> <span>dict</span><span>[</span><span>Expr</span><span>,</span> <span>set</span><span>[</span><span>Expr</span><span>]]):</span>
    <span># Find cases of the form (a * b) / b
</span>    <span>for</span> <span>e0</span> <span>in</span> <span>eclasses</span><span>[</span><span>op</span><span>]:</span>
        <span>if</span> <span>isinstance</span><span>(</span><span>e0</span><span>,</span> <span>Div</span><span>):</span>
            <span>div_left</span> <span>=</span> <span>e0</span><span>.</span><span>left</span>
            <span>div_right</span> <span>=</span> <span>e0</span><span>.</span><span>right</span>
            <span>for</span> <span>e1</span> <span>in</span> <span>eclasses</span><span>[</span><span>div_left</span><span>]:</span>
                <span>if</span> <span>isinstance</span><span>(</span><span>e1</span><span>,</span> <span>Mul</span><span>):</span>
                    <span>mul_left</span> <span>=</span> <span>e1</span><span>.</span><span>left</span>
                    <span>mul_right</span> <span>=</span> <span>e1</span><span>.</span><span>right</span>
                    <span>if</span> <span>mul_right</span> <span>==</span> <span>div_right</span><span>:</span>
                        <span># ...
</span></code></pre></div></div>

<p>And then we can rewrite the <code>Div</code> to the <code>Mul</code>’s left child:</p>

<div><div><pre><code><span>def</span> <span>optimize_match</span><span>(</span><span>op</span><span>:</span> <span>Expr</span><span>,</span> <span>eclasses</span><span>:</span> <span>dict</span><span>[</span><span>Expr</span><span>,</span> <span>set</span><span>[</span><span>Expr</span><span>]]):</span>
    <span># Find cases of the form (a * b) / b and rewrite to a
</span>    <span>for</span> <span>e0</span> <span>in</span> <span>eclasses</span><span>[</span><span>op</span><span>]:</span>
        <span>if</span> <span>isinstance</span><span>(</span><span>e0</span><span>,</span> <span>Div</span><span>):</span>
            <span>div_left</span> <span>=</span> <span>e0</span><span>.</span><span>left</span>
            <span>div_right</span> <span>=</span> <span>e0</span><span>.</span><span>right</span>
            <span>for</span> <span>e1</span> <span>in</span> <span>eclasses</span><span>[</span><span>div_left</span><span>]:</span>
                <span>if</span> <span>isinstance</span><span>(</span><span>e1</span><span>,</span> <span>Mul</span><span>):</span>
                    <span>mul_left</span> <span>=</span> <span>e1</span><span>.</span><span>left</span>
                    <span>mul_right</span> <span>=</span> <span>e1</span><span>.</span><span>right</span>
                    <span>if</span> <span>mul_right</span> <span>==</span> <span>div_right</span><span>:</span>
                        <span>op</span><span>.</span><span>make_equal_to</span><span>(</span><span>mul_left</span><span>)</span>
                        <span>return</span>
</code></pre></div></div>

<p>If we run this optimization function for every node in our basic block, we end
up with:</p>

<div><div><pre><code>AFTER:
v0 = Var&lt;a&gt;
v1 = Const&lt;2&gt;
v2 = LeftShift v0 v5
v3 = Var&lt;a&gt;
</code></pre></div></div>

<p>where <code>v3</code> corresponds to our original big expression. Congratulations, you’ve
successfully implemented a time-traveling compiler pass!</p>

<p>Unfortunately, it’s very specific: our match conditions are hard-coded into the
loop structure and the loop structure (how many levels of nesting) is
hard-coded into the function. This is the sort of thing that our programming
giants invented SQL to solve<sup id="fnref:egg-relational" role="doc-noteref"><a href="#fn:egg-relational" rel="footnote">5</a></sup>.</p>

<p>We don’t have time or brainpower to implement a full query
language<sup id="fnref:nerd-snipe" role="doc-noteref"><a href="#fn:nerd-snipe" rel="footnote">6</a></sup> and I ran out of ideas for making a small embedded
matching DSL, so you will have to take my word for it that it’s tractable.</p>

<!-- TODO: a matching DSL

, so in this post will implement a small pattern-matching
DSL that kind of vaguely maybe-if-you-squint looks like something
relational. -->

<p>One thing to note: after every write with <code>make_equal_to</code>, we need to
rediscover the eclasses if we want to read from them again. I think this is
what the egg people call a “rebuild” and part of what made their paper
interesting was finding a way to do this less often or faster.</p>

<p>Another thing we need to do, I think, is iterate until convergence. It’s not
guaranteed that we will always reach the so-called “congruence closure” with
one pass over all of the operations, matching and rewriting. In some cases
(which?), the graph may not even converge at all!</p>

<p>Now what we have is a bunch of parallel worlds for our basic block where each
operation is actually a set of equivalent operations. But which element of the
set should we pick? One approach, the one we were taking before, is to just
pick the representative as the desired final form of each operation. This is a
very union-find style approach. It’s straightforward, it’s fast, and it works
well in a situation where we only ever do strength reduction type rewrites.</p>

<p>But e-graphs popped into the world because people wanted to explore a bigger
state space. It’s possible that the representative of an equivalence class is
locally optimal but not globally optimal. If our optimality function—our cost
function—considers the entire program, we have to find a way to broaden our
search.</p>



<p>The final piece of the e-graph API is an <code>extract</code> function. This function
finds the “lowest cost” or “most optimal” version of the program in the
e-graph.</p>

<p>The simplest extraction function is to iterate through the cartesian product of
all of the equivalence classes for each IR node and find the one that minimizes
the whole-program cost.</p>

<div><div><pre><code><span>import</span> <span>itertools</span>
<span>def</span> <span>extract</span><span>(</span><span>program</span><span>:</span> <span>list</span><span>[</span><span>Expr</span><span>],</span> <span>eclasses</span><span>:</span> <span>dict</span><span>[</span><span>Expr</span><span>,</span> <span>set</span><span>[</span><span>Expr</span><span>]])</span> <span>-&gt;</span> <span>list</span><span>[</span><span>Expr</span><span>]:</span>
    <span>best_cost</span> <span>=</span> <span>float</span><span>(</span><span>&#34;inf&#34;</span><span>)</span>
    <span>best_program</span> <span>=</span> <span>program</span>
    <span>for</span> <span>trial_program</span> <span>in</span> <span>itertools</span><span>.</span><span>product</span><span>(</span><span>*</span><span>[</span><span>eclasses</span><span>[</span><span>op</span><span>]</span> <span>for</span> <span>op</span> <span>in</span> <span>program</span><span>]):</span>
        <span>cost</span> <span>=</span> <span>whole_program_cost</span><span>(</span><span>trial_program</span><span>)</span>
        <span>if</span> <span>cost</span> <span>&lt;</span> <span>best_cost</span><span>:</span>
            <span>best_cost</span> <span>=</span> <span>cost</span>
            <span>best_program</span> <span>=</span> <span>trial_program</span><span>.</span><span>copy</span><span>()</span>
    <span>return</span> <span>best_program</span>
</code></pre></div></div>

<p>Unfortunately, this is slow. As the number of nodes grows, your base grows and
as the number of rewrites grows, your exponent grows. It’s bad news bears.
There are a bunch of different approaches that don’t involve exhaustive search,
but they do not always produce the globally optimal program. It’s an active
area of research.</p>

<p>Another thing to note is that the cost function isn’t normally built-in to
e-graph implementations; usually they allow library users to provide at least
their own cost functions, if not the entirety of <em>extract</em>.</p>

<h2 id="wrapping-up">Wrapping up</h2>

<p>This brings us to a complete e-graph implementation. We started with a simple
union-find, and by incrementally adding <code>match</code> and <code>extract</code>, we ended with a
full e-graph.</p>

<p>A bit of a subtle note here is that unlike our more procedural/functional
pattern matching situation with a manual <code>make_equal_to</code>, many (most?) e-graph
implementations tend to suggest that the library user provides a set of
declarative syntactic rewrite rules.
<a href="https://github.com/egraphs-good/egglog">egglog</a> uses a custom Datalog-like
DSL;
<a href="https://cranelift.dev/">Cranelift</a>
uses a DSL called ISLE; <a href="https://ocaml.org/p/ego/0.0.6/doc/index.html">Ego</a>
uses an embedded DSL.</p>

<div><div><pre><code><span>;; This is a Datalog-like pair of rules from an egglog example</span>
<span>(</span><span>rewrite</span> <span>(</span><span>If</span> <span>T</span> <span>t</span> <span>f</span><span>)</span> <span>t</span><span>)</span>
<span>(</span><span>rewrite</span> <span>(</span><span>If</span> <span>F</span> <span>t</span> <span>f</span><span>)</span> <span>f</span><span>)</span>
</code></pre></div></div>

<p>This requires embedding your compiler’s notion of the program into the
library’s domain, then extracting back out from the library’s domain into your
own IR.</p>

<p>Part of the motivation for this blog post was to provide a kind of e-graph that
can be embedded directly into your compiler project without mapping back and
forth.</p>

<h2 id="further-reading">Further reading</h2>

<p>Cranelift uses a modified form of e-graph called an <a href="https://github.com/bytecodealliance/rfcs/blob/main/accepted/cranelift-egraph.md">aegraph</a>. It’s
different in that the entire e-graph can be topo sorted and equality arrows can
only point to earlier nodes. There are probably some very interesting
trade-offs here but I am not an expert and you should probably read Chris
Fallin’s <a href="https://github.com/bytecodealliance/rfcs/blob/main/accepted/cranelift-egraph.md">excellent post</a>.</p>

<p>In a <a href="https://egraphs.zulipchat.com/#narrow/stream/375765-egg.2Fegglog/topic/incrementally.20.22discovering.22.20e-graphs.20from.20union-find">Zulip thread</a>, Chris writes:</p>

<blockquote>
  <p>aegraphs are really about three key things:</p>

  <ul>
    <li>a persistent immutable data structure that encodes eclasses directly – via the use of “union nodes” that refer to two other nodes. This lets us refer to a “snapshot in time” of an eclass, before we union more things into it, which turns out to be important for acyclicity</li>
    <li>a rewrite strategy that is eager (“bottom-up”): as soon as we create a node, we apply rewrite rules just to that node. That was actually kind of my entrypoint to doing something “different” than egg: I was wondering how to apply rules in a more efficient way than “iterate over all nodes and apply all rules” and, well, doing rewrites just once is about as good as one can do</li>
    <li>acyclicity: in a classical egraph one can get cycles when merging nodes even when no cycles exist in the input. Consider <code>x + 0</code>, and a rule that rewrites that to <code>x</code>. Then we have one eclass that refers to itself – in essence it’s encoding the equivalence in <em>both</em> directions, so it could also be <code>(((x + 0) + 0) + 0)</code> or longer to infinity; that’s what the cycle denotes. To avoid that we have to refer to a <em>snapshot</em> of the eclass as we know it in the args, and never re-intern a value node with new (union’d) arg eclasses. That enables the persistent immutable data structure; and requires the eager rewrite to work.</li>
  </ul>

  <p>(in my <a href="https://cfallin.org/pubs/egraphs2023_aegraphs_slides.pdf">talk about this</a> I have this wonky three-sided figure where each of these concepts mutually reinforces the other…)</p>

  <p>One of the things that surprised me is that the single-pass eager rewrite <em>does</em> actually work – it works if one’s rules are structured in a certain way. The case one wants to avoid is where A rewrites to B, C rewrites to B, and then a better version of A is actually C (but no direct rewrite exists) – that’s where later unification in a full egraph would have grouped A and C together and that equivalence would be visible, but eager rewrites with snapshotted eclasses does not. It turns out the way we write rules in Cranelift at least is “directional” enough that we don’t have this in practice (it would require C to be better than B, even though we have a C-&gt;B rewrite).</p>

  <p>There’s a whole other side to Cranelift’s use of aegraphs having to do with control flow, “elaboration”, the way we do GVN (without partial redundancy) and LICM, keep side effects in the right place, and getting the reconstructed/reserialized sequence of computations correct with respect to dominance (extraction needs to worry about the domtree!).</p>
</blockquote>

<p>PyPy has “union find” in its optimizer but it’s smarter than normal union-find.
It also has smart constructors and some other features that make its optimizer
more e-graph like than union-find like. Perhaps CF will write a blog post about
this some day.</p>

<p>And of course check out egg and egglog, the main e-graph libraries around. And
Metatheory.jl, too.</p>

<p>Please let me know what thoughts you have! This is a very new subject for me.</p>

<p>Thanks to Kartik Agaram, Max Willsey, and Chris Fallin for reviewing drafts of this post.</p>


        </div></div>
  </body>
</html>
