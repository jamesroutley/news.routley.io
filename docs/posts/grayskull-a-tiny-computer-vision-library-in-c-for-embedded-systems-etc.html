<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/zserge/grayskull">Original</a>
    <h1>Grayskull: A tiny computer vision library in C for embedded systems, etc.</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><div dir="auto"><a id="user-content--grayskull" aria-label="Permalink: ðŸ° Grayskull" href="#-grayskull"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Grayskull is a minimalist, dependency-free computer vision library designed for microcontrollers and other resource-constrained devices. It focuses on <strong>grayscale</strong> images and provides modern, practical algorithms that fit in a few kilobytes of code. Single-header design, integer-based operations, pure C99.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Features</h2><a id="user-content-features" aria-label="Permalink: Features" href="#features"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>Image operations: copy, crop, resize (bilinear), downsample</li>
<li>Filtering: blur, Sobel edges, thresholding (global, Otsu, adaptive)</li>
<li>Morphology: erosion, dilation</li>
<li>Geometry: connected components, perspective warp</li>
<li>Features: FAST/ORB keypoints and descriptors (object tracking)</li>
<li>Local binary patterns: LBP cascades to detect faces, vehicles etc</li>
<li>Utilities: PGM read/write</li>
</ul>
<p dir="auto">As usual, no dependencies, no dynamic memory allocation, no C++, no surprises. Just a single header file under 1KLOC.</p>
<p dir="auto">Check out the <a href="http://iafisher.com/zserge/grayskull/blob/main/examples">examples</a> folder for more!</p>
<p dir="auto"><a href="https://zserge.com/grayskull/" rel="nofollow">Online demo</a>: try Grayskull in your browser.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Quickstart</h2><a id="user-content-quickstart" aria-label="Permalink: Quickstart" href="#quickstart"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="#include &#34;grayskull.h&#34;

struct gs_image img = gs_read_pgm(&#34;input.pgm&#34;);
struct gs_image blurred = gs_alloc(img.w, img.h);
struct gs_image binary = gs_alloc(img.w, img.h);

gs_blur(blurred, img, 2);
gs_threshold(binary, blurred, gs_otsu_theshold(blurred));

gs_write_pgm(binary, &#34;output.pgm&#34;);
gs_free(img);
gs_free(blurred);
gs_free(binary);"><pre><span>#include</span> <span>&#34;grayskull.h&#34;</span>

<span>struct</span> <span>gs_image</span> <span>img</span> <span>=</span> <span>gs_read_pgm</span>(<span>&#34;input.pgm&#34;</span>);
<span>struct</span> <span>gs_image</span> <span>blurred</span> <span>=</span> <span>gs_alloc</span>(<span>img</span>.<span>w</span>, <span>img</span>.<span>h</span>);
<span>struct</span> <span>gs_image</span> <span>binary</span> <span>=</span> <span>gs_alloc</span>(<span>img</span>.<span>w</span>, <span>img</span>.<span>h</span>);

<span>gs_blur</span>(<span>blurred</span>, <span>img</span>, <span>2</span>);
<span>gs_threshold</span>(<span>binary</span>, <span>blurred</span>, <span>gs_otsu_theshold</span>(<span>blurred</span>));

<span>gs_write_pgm</span>(<span>binary</span>, <span>&#34;output.pgm&#34;</span>);
<span>gs_free</span>(<span>img</span>);
<span>gs_free</span>(<span>blurred</span>);
<span>gs_free</span>(<span>binary</span>);</pre></div>
<p dir="auto"><em>Note that <code>gs_alloc</code>/<code>gs_free</code> are optional helpers; you can allocate image pixel buffers any way you like.</em></p>
<div dir="auto"><h2 tabindex="-1" dir="auto">API Reference</h2><a id="user-content-api-reference" aria-label="Permalink: API Reference" href="#api-reference"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="struct gs_image { unsigned w, h; uint8_t *data; };
struct gs_rect { unsigned x, y, w, h; }; // ROI
struct gs_point { unsigned x, y; }; // corners

uint8_t gs_get(struct gs_image img, unsigned x, unsigned y);
void gs_set(struct gs_image img, unsigned x, unsigned y, uint8_t value);
void gs_crop(struct gs_image dst, struct gs_image src, struct gs_rect roi);
void gs_copy(struct gs_image dst, struct gs_image src);
void gs_resize(struct gs_image dst, struct gs_image src);
void gs_downsample(struct gs_image dst, struct gs_image src);

// Thresholding
void gs_histogram(struct gs_image img, unsigned hist[256]);
void gs_threshold(struct gs_image img, uint8_t threshold);
uint8_t gs_otsu_threshold(struct gs_image img);
void gs_adaptive_threshold(struct gs_image dst, struct gs_image src, unsigned radius, int c);

// Filters
void gs_blur(struct gs_image dst, struct gs_image src, unsigned radius);
void gs_erode(struct gs_image dst, struct gs_image src);
void gs_dilate(struct gs_image dst, struct gs_image src);
void gs_sobel(struct gs_image dst, struct gs_image src);

// Blobs (connected components) and contours
typedef uint16_t gs_label;
struct gs_blob { gs_label label; unsigned area; struct gs_rect box; struct gs_point centroid; };
struct gs_contour { struct gs_rect box; struct gs_point start; unsigned length; };
unsigned gs_blobs(struct gs_image img, gs_label *labels, struct gs_blob *blobs, unsigned nblobs);
void gs_blob_corners(struct gs_image img, gs_label *labels, struct gs_blob *b, struct gs_point c[4]);
void gs_perspective_correct(struct gs_image dst, struct gs_image src, struct gs_point c[4]);
void gs_trace_contour(struct gs_image img, struct gs_image visited, struct gs_contour *c);

// FAST/ORB
struct gs_keypoint { struct gs_point pt; unsigned response; float angle; uint32_t descriptor[8]; };
struct gs_match { unsigned idx1, idx2; unsigned distance; };
unsigned gs_fast(struct gs_image img, struct gs_image scoremap, struct gs_keypoint *kps, unsigned nkps, unsigned threshold);
float gs_compute_orientation(struct gs_image img, unsigned x, unsigned y, unsigned r);
void gs_brief_descriptor(struct gs_image img, struct gs_keypoint *kp);
unsigned gs_orb_extract(struct gs_image img, struct gs_keypoint *kps, unsigned nkps, unsigned threshold, uint8_t *scoremap_buffer);
unsigned gs_match_orb(const struct gs_keypoint *kps1, unsigned n1, const struct gs_keypoint *kps2, unsigned n2, struct gs_match *matches, unsigned max_matches, float max_distance);

// LBP cascades
struct gs_lbp_cascade { uint16_t window_w, window_h; uint16_t nfeatures, nweaks, nstages; const int8_t *features; /* [nfeatures * 4] */ const uint16_t *weak_feature_idx; const float *weak_left_val, *weak_right_val; const uint16_t *weak_subset_offset, *weak_num_subsets; const int32_t *subsets; const uint16_t *stage_weak_start, *stage_nweaks; const float *stage_threshold; };
void gs_integral(struct gs_image src, unsigned *ii);
unsigned gs_lbp_window(const struct gs_lbp_cascade *c, const unsigned *ii, unsigned iw, unsigned ih, int x, int y, float scale);
unsigned gs_lbp_detect(const struct gs_lbp_cascade *c, const unsigned *ii, unsigned iw, unsigned ih, struct gs_rect *rects, unsigned max_rects, float scale_factor, float min_scale, float max_scale, int step);

// Optional:
struct gs_image gs_alloc(unsigned w, unsigned h);
void gs_free(struct gs_image img);
struct gs_image gs_read_pgm(const char *path);
int gs_write_pgm(struct gs_image img, const char *path);"><pre><span>struct</span> <span>gs_image</span> { <span>unsigned</span> <span>w</span>, <span>h</span>; <span>uint8_t</span> <span>*</span><span>data</span>; };
<span>struct</span> <span>gs_rect</span> { <span>unsigned</span> <span>x</span>, <span>y</span>, <span>w</span>, <span>h</span>; }; <span>// ROI</span>
<span>struct</span> <span>gs_point</span> { <span>unsigned</span> <span>x</span>, <span>y</span>; }; <span>// corners</span>

<span>uint8_t</span> <span>gs_get</span>(<span>struct</span> <span>gs_image</span> <span>img</span>, <span>unsigned</span> <span>x</span>, <span>unsigned</span> <span>y</span>);
<span>void</span> <span>gs_set</span>(<span>struct</span> <span>gs_image</span> <span>img</span>, <span>unsigned</span> <span>x</span>, <span>unsigned</span> <span>y</span>, <span>uint8_t</span> <span>value</span>);
<span>void</span> <span>gs_crop</span>(<span>struct</span> <span>gs_image</span> <span>dst</span>, <span>struct</span> <span>gs_image</span> <span>src</span>, <span>struct</span> <span>gs_rect</span> <span>roi</span>);
<span>void</span> <span>gs_copy</span>(<span>struct</span> <span>gs_image</span> <span>dst</span>, <span>struct</span> <span>gs_image</span> <span>src</span>);
<span>void</span> <span>gs_resize</span>(<span>struct</span> <span>gs_image</span> <span>dst</span>, <span>struct</span> <span>gs_image</span> <span>src</span>);
<span>void</span> <span>gs_downsample</span>(<span>struct</span> <span>gs_image</span> <span>dst</span>, <span>struct</span> <span>gs_image</span> <span>src</span>);

<span>// Thresholding</span>
<span>void</span> <span>gs_histogram</span>(<span>struct</span> <span>gs_image</span> <span>img</span>, <span>unsigned</span> <span>hist</span>[<span>256</span>]);
<span>void</span> <span>gs_threshold</span>(<span>struct</span> <span>gs_image</span> <span>img</span>, <span>uint8_t</span> <span>threshold</span>);
<span>uint8_t</span> <span>gs_otsu_threshold</span>(<span>struct</span> <span>gs_image</span> <span>img</span>);
<span>void</span> <span>gs_adaptive_threshold</span>(<span>struct</span> <span>gs_image</span> <span>dst</span>, <span>struct</span> <span>gs_image</span> <span>src</span>, <span>unsigned</span> <span>radius</span>, <span>int</span> <span>c</span>);

<span>// Filters</span>
<span>void</span> <span>gs_blur</span>(<span>struct</span> <span>gs_image</span> <span>dst</span>, <span>struct</span> <span>gs_image</span> <span>src</span>, <span>unsigned</span> <span>radius</span>);
<span>void</span> <span>gs_erode</span>(<span>struct</span> <span>gs_image</span> <span>dst</span>, <span>struct</span> <span>gs_image</span> <span>src</span>);
<span>void</span> <span>gs_dilate</span>(<span>struct</span> <span>gs_image</span> <span>dst</span>, <span>struct</span> <span>gs_image</span> <span>src</span>);
<span>void</span> <span>gs_sobel</span>(<span>struct</span> <span>gs_image</span> <span>dst</span>, <span>struct</span> <span>gs_image</span> <span>src</span>);

<span>// Blobs (connected components) and contours</span>
<span>typedef</span> <span>uint16_t</span> <span>gs_label</span>;
<span>struct</span> <span>gs_blob</span> { <span>gs_label</span> <span>label</span>; <span>unsigned</span> <span>area</span>; <span>struct</span> <span>gs_rect</span> <span>box</span>; <span>struct</span> <span>gs_point</span> <span>centroid</span>; };
<span>struct</span> <span>gs_contour</span> { <span>struct</span> <span>gs_rect</span> <span>box</span>; <span>struct</span> <span>gs_point</span> <span>start</span>; <span>unsigned</span> <span>length</span>; };
<span>unsigned</span> <span>gs_blobs</span>(<span>struct</span> <span>gs_image</span> <span>img</span>, <span>gs_label</span> <span>*</span><span>labels</span>, <span>struct</span> <span>gs_blob</span> <span>*</span><span>blobs</span>, <span>unsigned</span> <span>nblobs</span>);
<span>void</span> <span>gs_blob_corners</span>(<span>struct</span> <span>gs_image</span> <span>img</span>, <span>gs_label</span> <span>*</span><span>labels</span>, <span>struct</span> <span>gs_blob</span> <span>*</span><span>b</span>, <span>struct</span> <span>gs_point</span> <span>c</span>[<span>4</span>]);
<span>void</span> <span>gs_perspective_correct</span>(<span>struct</span> <span>gs_image</span> <span>dst</span>, <span>struct</span> <span>gs_image</span> <span>src</span>, <span>struct</span> <span>gs_point</span> <span>c</span>[<span>4</span>]);
<span>void</span> <span>gs_trace_contour</span>(<span>struct</span> <span>gs_image</span> <span>img</span>, <span>struct</span> <span>gs_image</span> <span>visited</span>, <span>struct</span> <span>gs_contour</span> <span>*</span><span>c</span>);

<span>// FAST/ORB</span>
<span>struct</span> <span>gs_keypoint</span> { <span>struct</span> <span>gs_point</span> <span>pt</span>; <span>unsigned</span> <span>response</span>; <span>float</span> <span>angle</span>; <span>uint32_t</span> <span>descriptor</span>[<span>8</span>]; };
<span>struct</span> <span>gs_match</span> { <span>unsigned</span> <span>idx1</span>, <span>idx2</span>; <span>unsigned</span> <span>distance</span>; };
<span>unsigned</span> <span>gs_fast</span>(<span>struct</span> <span>gs_image</span> <span>img</span>, <span>struct</span> <span>gs_image</span> <span>scoremap</span>, <span>struct</span> <span>gs_keypoint</span> <span>*</span><span>kps</span>, <span>unsigned</span> <span>nkps</span>, <span>unsigned</span> <span>threshold</span>);
<span>float</span> <span>gs_compute_orientation</span>(<span>struct</span> <span>gs_image</span> <span>img</span>, <span>unsigned</span> <span>x</span>, <span>unsigned</span> <span>y</span>, <span>unsigned</span> <span>r</span>);
<span>void</span> <span>gs_brief_descriptor</span>(<span>struct</span> <span>gs_image</span> <span>img</span>, <span>struct</span> <span>gs_keypoint</span> <span>*</span><span>kp</span>);
<span>unsigned</span> <span>gs_orb_extract</span>(<span>struct</span> <span>gs_image</span> <span>img</span>, <span>struct</span> <span>gs_keypoint</span> <span>*</span><span>kps</span>, <span>unsigned</span> <span>nkps</span>, <span>unsigned</span> <span>threshold</span>, <span>uint8_t</span> <span>*</span><span>scoremap_buffer</span>);
<span>unsigned</span> <span>gs_match_orb</span>(<span>const</span> <span>struct</span> <span>gs_keypoint</span> <span>*</span><span>kps1</span>, <span>unsigned</span> <span>n1</span>, <span>const</span> <span>struct</span> <span>gs_keypoint</span> <span>*</span><span>kps2</span>, <span>unsigned</span> <span>n2</span>, <span>struct</span> <span>gs_match</span> <span>*</span><span>matches</span>, <span>unsigned</span> <span>max_matches</span>, <span>float</span> <span>max_distance</span>);

<span>// LBP cascades</span>
<span>struct</span> <span>gs_lbp_cascade</span> { <span>uint16_t</span> <span>window_w</span>, <span>window_h</span>; <span>uint16_t</span> <span>nfeatures</span>, <span>nweaks</span>, <span>nstages</span>; <span>const</span> <span>int8_t</span> <span>*</span><span>features</span>; <span>/* [nfeatures * 4] */</span> <span>const</span> <span>uint16_t</span> <span>*</span><span>weak_feature_idx</span>; <span>const</span> <span>float</span> <span>*</span><span>weak_left_val</span>, <span>*</span><span>weak_right_val</span>; <span>const</span> <span>uint16_t</span> <span>*</span><span>weak_subset_offset</span>, <span>*</span><span>weak_num_subsets</span>; <span>const</span> <span>int32_t</span> <span>*</span><span>subsets</span>; <span>const</span> <span>uint16_t</span> <span>*</span><span>stage_weak_start</span>, <span>*</span><span>stage_nweaks</span>; <span>const</span> <span>float</span> <span>*</span><span>stage_threshold</span>; };
<span>void</span> <span>gs_integral</span>(<span>struct</span> <span>gs_image</span> <span>src</span>, <span>unsigned</span> <span>*</span><span>ii</span>);
<span>unsigned</span> <span>gs_lbp_window</span>(<span>const</span> <span>struct</span> <span>gs_lbp_cascade</span> <span>*</span><span>c</span>, <span>const</span> <span>unsigned</span> <span>*</span><span>ii</span>, <span>unsigned</span> <span>iw</span>, <span>unsigned</span> <span>ih</span>, <span>int</span> <span>x</span>, <span>int</span> <span>y</span>, <span>float</span> <span>scale</span>);
<span>unsigned</span> <span>gs_lbp_detect</span>(<span>const</span> <span>struct</span> <span>gs_lbp_cascade</span> <span>*</span><span>c</span>, <span>const</span> <span>unsigned</span> <span>*</span><span>ii</span>, <span>unsigned</span> <span>iw</span>, <span>unsigned</span> <span>ih</span>, <span>struct</span> <span>gs_rect</span> <span>*</span><span>rects</span>, <span>unsigned</span> <span>max_rects</span>, <span>float</span> <span>scale_factor</span>, <span>float</span> <span>min_scale</span>, <span>float</span> <span>max_scale</span>, <span>int</span> <span>step</span>);

<span>// Optional:</span>
<span>struct</span> <span>gs_image</span> <span>gs_alloc</span>(<span>unsigned</span> <span>w</span>, <span>unsigned</span> <span>h</span>);
<span>void</span> <span>gs_free</span>(<span>struct</span> <span>gs_image</span> <span>img</span>);
<span>struct</span> <span>gs_image</span> <span>gs_read_pgm</span>(<span>const</span> <span>char</span> <span>*</span><span>path</span>);
<span>int</span> <span>gs_write_pgm</span>(<span>struct</span> <span>gs_image</span> <span>img</span>, <span>const</span> <span>char</span> <span>*</span><span>path</span>);</pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">License</h2><a id="user-content-license" aria-label="Permalink: License" href="#license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This project is licensed under the MIT License. Feel free to use in research, products, and your next embedded vision project!</p>
</article></div></div>
  </body>
</html>
