<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2020/09/reverse-engineering-first-fpga-chip.html">Original</a>
    <h1>Reverse engineering XC2064, the first FPGA  (2020)</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-878418472608863595" itemprop="description articleBody">


<p>A Field-Programmable Gate Array (FPGA) can implement arbitrary digital logic, anything from
a microprocessor to a video generator or crypto miner.
An FPGA
consists of many logic blocks, each typically consisting of a flip flop and a logic function, along with a routing network that connects the logic blocks.
What makes an FPGA special is that it is programmable hardware: you can redefine each logic block and the connections between them.
The result is you can build a complex digital circuit without physically wiring up individual gates and flip flops or going to the expense of
designing a custom integrated circuit.</p>
<p><a href="https://static.righto.com/images/xc2064/tile-detail.jpg"><img alt="Die photo closeup showing the circuitry for one of the 64 tiles in the XC2064 FPGA. The metal layers have been removed, exposing the silicon and polysilicon transistors underneath. Click for a larger image. From siliconpr0n." height="412" src="https://static.righto.com/images/xc2064/tile-detail-w400.jpg" title="Die photo closeup showing the circuitry for one of the 64 tiles in the XC2064 FPGA. The metal layers have been removed, exposing the silicon and polysilicon transistors underneath. Click for a larger image. From siliconpr0n." width="400"/></a></p><p>Die photo closeup showing the circuitry for one of the 64 tiles in the XC2064 FPGA. The metal layers have been removed, exposing the silicon and polysilicon transistors underneath. Click for a larger image. From <a href="https://siliconpr0n.org/map/xilinx/xc2018/dlyr1_mit100x_part/#x=3644&amp;y=2131&amp;z=2">siliconpr0n</a>.</p>
<p>The FPGA was invented by Ross Freeman<span id="fnref:inventor"><a href="#fn:inventor">1</a></span> who co-founded Xilinx<span id="fnref:fabless"><a href="#fn:fabless">2</a></span> in 1984
and introduced the first FPGA, the XC2064.
<span id="fnref:fpga-history"><a href="#fn:fpga-history">3</a></span>
This FPGA is much simpler than modern FPGAs—it contains just 64 logic blocks, compared to thousands or millions in modern FPGAs—but
it led to the current multi-billion-dollar FPGA industry.
Because of its importance, the XC2064 is in the <a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-xilinx-xc2064-fpga">Chip Hall of Fame</a>.
I reverse-engineered Xilinx&#39;s XC2064, and in this blog post I explain its internal circuitry (above) and how a &#34;bitstream&#34; programs it.</p>
<p><a href="https://static.righto.com/images/xc2064/repackaged_top.jpg"><img alt="The Xilinx XC2064 was the first FPGA chip. Photo from siliconpr0n." height="255" src="https://static.righto.com/images/xc2064/repackaged_top-w300.jpg" title="The Xilinx XC2064 was the first FPGA chip. Photo from siliconpr0n." width="300"/></a></p><p>The Xilinx XC2064 was the first FPGA chip. Photo from <a href="https://siliconpr0n.org/archive/doku.php?id=mcmaster:xilinx:xc2064-70">siliconpr0n</a>.</p>
<p>Nowadays, an FPGA is programed in a hardware description language such as Verilog or VHDL, but back then Xilinx provided their own development software,
an MS-DOS application named XACT with a hefty $12,000 price tag.
XACT operated at a lower level than modern tools:
the user defined the function of each logic block, as shown in the screenshot below, and the connections between logic blocks.
XACT routed the connections and generated a bitstream file that could be loaded into the FPGA.
<!--
Although the user interface looks primitive, XACT is a complex program that among other things simulated circuit delays.
--></p>
<p><a href="https://static.righto.com/images/xc2064/xact-screenshot1.jpg"><img alt="Screenshot of XACT. The two lookup tables F and G implement the equations at the bottom of the screen, with Karnaugh map shown above." height="360" src="https://static.righto.com/images/xc2064/xact-screenshot1-w480.jpg" title="Screenshot of XACT. The two lookup tables F and G implement the equations at the bottom of the screen, with Karnaugh map shown above." width="480"/></a></p><p>Screenshot of XACT. The two lookup tables F and G implement the equations at the bottom of the screen, with Karnaugh map shown above.</p>
<p>An FPGA is configured via the bitstream, a sequence of bits with a proprietary format.
If you look at the bitstream for the XC2064 (below), it&#39;s a puzzling mixture of
patterns that repeat irregularly with sequences scattered through the bitstream.
There&#39;s no clear connection between the function definitions in XACT and the data in the bitstream.
However, studying the physical circuitry of the FPGA reveals the structure of the bitstream data and it can be understood.</p>
<p><a href="https://static.righto.com/images/xc2064/xilinx-bitstream-screenshot.png"><img alt="Part of the bitstream generated by XACT." height="204" src="https://static.righto.com/images/xc2064/xilinx-bitstream-screenshot-w533.png" title="Part of the bitstream generated by XACT." width="533"/></a></p><p>Part of the bitstream generated by XACT.</p>
<!--
The key concept is that there is no real encoding of the XC2064 bitstream; it is a raw dump of the physical control bits in the FPGA, where the position of
a bit in the bitstream matches its physical location in the chip.
The layout of the FPGA circuitry is highly optimized so a bit is placed near the circuit it controls, depending on where it fits.
Thus, the secret to understanding the bitstream is not to think of it in terms of high-level fields, but as a representation of the low-level
hardware layout.
-->

<h2>How does an FPGA work?</h2>
<p>The diagram below, from the original FPGA patent, shows the basic structure of an FPGA.
In this simplified FPGA, there are 9 logic blocks (blue) and 12 I/O pins. An interconnection network connects the components together.
By setting switches (diagonal lines) on the interconnect, the logic blocks are connected to each other and to the I/O pins.
Each logic element can be programmed with the desired logic function.
The result is a highly programmable chip that can implement anything that fits in the available circuitry.</p>
<p><a href="https://static.righto.com/images/xc2064/patent-fpga-colorized.jpg"><img alt="The FPGA patent shows logic blocks (LE) linked by an interconnect." height="364" src="https://static.righto.com/images/xc2064/patent-fpga-colorized-w500.jpg" title="The FPGA patent shows logic blocks (LE) linked by an interconnect." width="500"/></a></p><p>The <a href="https://patents.google.com/patent/US4870302A">FPGA patent</a> shows logic blocks (LE) linked by an interconnect.</p>
<h3>CLB: Configurable Logic Block</h3>
<p>While the diagram above shows nine configurable logic blocks (CLBs), the XC2064 has 64 CLBs. The diagram below shows the structure
of each CLB.
Each CLB has four inputs (A, B, C, D) and two outputs (X and Y).
In between is combinatorial logic, which can be programmed with any desired logic function.
The CLB also contains a flip flop, allowing the FPGA to implement
counters, shift registers, state machines and other stateful circuits.
The trapezoids are multiplexers, which can be programmed to pass through any of their inputs.
The multiplexers allow the CLB to be configured for a particular task, selecting
the desired signals for the flip flop controls and the outputs.</p>
<p><a href="https://static.righto.com/images/xc2064/CLB.jpg"><img alt="A Configurable Logic Block in the XC2064, from the datasheet." height="317" src="https://static.righto.com/images/xc2064/CLB-w500.jpg" title="A Configurable Logic Block in the XC2064, from the datasheet." width="500"/></a></p><p>A Configurable Logic Block in the XC2064, from the <a href="http://bitsavers.org/components/xilinx/XC2000FM.PDF">datasheet</a>.</p>
<p>You might wonder how the combinatorial logic implements arbitrary logic functions.
Does it select between a collection of AND gates, OR gates, XOR gates, and so forth?
No, it uses a clever trick called a
lookup table (LUT), in effect holding the truth table for the function.
For instance, a function of three variables is defined by the 8 rows in its truth table.
The LUT consists of 8 bits of memory, along with a multiplexer circuit to select the right value.
By storing values in these 8 bits of memory, any 3-input logic function can be implemented.<span id="fnref:LUT"><a href="#fn:LUT">4</a></span></p>
<h3>The interconnect</h3>
<p>The second key piece of the FPGA is the interconnect, which can be programmed to connect the CLBs in different ways.
The interconnect is fairly complicated, but a rough description is that there are several horizontal and vertical line segments between each CLB.
CLB. Interconnect points allow connections to be made between a horizontal line and a vertical line, allowing arbitrary paths to be created.
More complex connections are done via &#34;switch matrices&#34;. Each switch matrix has 8 pins, which can be wired together in (almost) arbitrary ways.</p>
<p>The diagram below shows the interconnect structure of the XC2064, providing connections to the logic blocks (cyan) and the I/O pins (yellow).
The inset shows a closeup of the routing features. The green boxes are the 8-pin switch matrices, while the small squares are the programmable interconnection
points.</p>
<p><a href="https://static.righto.com/images/xc2064/chip-map-zoom.jpg"><img alt="The XC2064 FPGA has an 8 by 8 grid of CLBs. Each CLB has an alphabetic name from AA to HH." height="544" src="https://static.righto.com/images/xc2064/chip-map-zoom-w600.jpg" title="The XC2064 FPGA has an 8 by 8 grid of CLBs. Each CLB has an alphabetic name from AA to HH." width="600"/></a></p><p>The XC2064 FPGA has an 8 by 8 grid of CLBs. Each CLB has an alphabetic name from AA to HH.</p>
<p>The interconnect can wire, for example, an output of block DC to an input of block DE, as shown below.
The red line indicates the routing path and the small red squares indicate activated routing points.
After leaving block DC, the signal is directed by the first routing point to an 8-pin switch (green) which directs it to two more routing points
and another 8-pin switch.
(The unused vertical and horizontal paths are not shown.)
Note that routing is fairly complex; even this short path used four routing points and two switches.</p>
<p><a href="https://static.righto.com/images/xc2064/routing.jpg"><img alt="Example of a signal routed from an output of block DC to block DE." height="413" src="https://static.righto.com/images/xc2064/routing-w500.jpg" title="Example of a signal routed from an output of block DC to block DE." width="500"/></a></p><p>Example of a signal routed from an output of block DC to block DE.</p>
<p>The screenshot below shows what routing looks like in the XACT program.
The yellow lines indicate routing between the logic blocks.
As more signals are added, the challenge is to route efficiently without the paths colliding.
The XACT software package performs automatic routing, but routes can also be edited manually.</p>
<p><a href="https://static.righto.com/images/xc2064/xact-screenshot.jpg"><img alt="Screenshot of the XACT program.
This MS-DOS program was controlled via the keyboard and mouse." height="360" src="https://static.righto.com/images/xc2064/xact-screenshot-w480.jpg" title="Screenshot of the XACT program.
This MS-DOS program was controlled via the keyboard and mouse." width="480"/></a></p><p>Screenshot of the XACT program.
This MS-DOS program was controlled via the keyboard and mouse.</p>
<h2>The implementation</h2>
<p>The remainder of this post discusses the internal circuitry of the XC2064, reverse-engineered from die photos.<span id="fnref:photos"><a href="#fn:photos">5</a></span>
Be warned that this assumes some familiarity with the XC2064.</p>
<p>The die photo below shows the layout of the XC2064 chip. The main part of the FPGA is the 8×8 grid of tiles;
each tile holds one logic block and the neighboring routing circuitry.
Although FPGA diagrams show the logic blocks (CLBs) as separate entities from the routing that surrounds them, that is <em>not</em> how the FPGA is implemented.
Instead, each logic block and the neighboring routing are implemented as a single entity, a tile.
(Specifically, the tile includes the routing above and to the left of each CLB.)</p>
<p><a href="https://static.righto.com/images/xc2064/chip-layout.jpg"><img alt="Layout of the XC2064 chip. Image from siliconpr0n." height="464" src="https://static.righto.com/images/xc2064/chip-layout-w500.jpg" title="Layout of the XC2064 chip. Image from siliconpr0n." width="500"/></a></p><p>Layout of the XC2064 chip. Image from <a href="https://siliconpr0n.org/map/xilinx/xc2064/mz_mit20x/">siliconpr0n</a>.</p>
<p>Around the edges of the integrated circuit,
I/O blocks
provide communication with the outside world. They are connected to the small green square pads, which
are wired to the chip&#39;s external pins.
The die is divided by buffers (green): two vertical and two horizontal.
These buffers amplify signals that travel long distances across the circuit, reducing delay.
The vertical shift register (pink) and horizontal column select circuit (blue) are used to load the bitstream into the chip, as will be explained below.</p>
<h3>Inside a tile</h3>
<p>The diagram below shows the layout of a single tile in the XC2064; the chip contains 64 of these tiles packed together as shown above.
About 40% of each tile is taken up by the memory cells (green) that hold the configuration bits.
The top third (roughly) of the tile handles the interconnect routing through two switch matrices and numerous individual routing switches. Below that is the logic block.
Key parts of the logic block are multiplexers for the input, the flip flop, and the lookup tables (LUTs).
The tile is connected to neighboring tiles through vertical and horizontal wiring for interconnect, power and ground.
The configuration data bits are fed into the memory cells horizontally, while vertical signals select a particular column of memory cells to load.</p>
<p><a href="https://static.righto.com/images/xc2064/clb-die.jpg"><img alt="One tile of the FPGA, showing important functional units." height="533" src="https://static.righto.com/images/xc2064/clb-die-w600.jpg" title="One tile of the FPGA, showing important functional units." width="600"/></a></p><p>One tile of the FPGA, showing important functional units.</p>
<h3>Transistors</h3>
<p>The FPGA is implemented with CMOS logic, built from NMOS and PMOS transistors.
Transistors have two main roles in the FPGA. First, they can be combined to form logic gates. Second, transistors are used as switches
that signals pass through, for instance to control routing. In this role, the transistor is called a pass transistor.
The diagram below shows the basic structure of an MOS transistor.
Two regions of silicon are doped with impurities to form the source and drain regions. In between, the gate
turns the transistor on or off, controlling current flow between the source and drain.
The gate is made of a special type of silicon called polysilicon, and is separated from the underlying silicon by a thin
insulating oxide layer.
Above this, two layers of metal provide wiring to connect the circuitry.</p>
<p><a href="https://static.righto.com/images/xc2064/mosfet.png"><img alt="Structure of a MOSFET." height="232" src="https://static.righto.com/images/xc2064/mosfet-w450.png" title="Structure of a MOSFET." width="450"/></a></p><p>Structure of a MOSFET.</p>
<p>The die photo closeup below shows what a transistor looks like under a microscope.
The polysilicon gate is the snaking line between the two doped silicon regions.
The circles are vias, connections between the silicon and the metal layer (which has been removed for this photo).</p>
<p><a href="https://static.righto.com/images/xc2064/mosfet-on-die.png"><img alt="A MOSFET as it appears in the FPGA." height="167" src="https://static.righto.com/images/xc2064/mosfet-on-die-w400.png" title="A MOSFET as it appears in the FPGA." width="400"/></a></p><p>A MOSFET as it appears in the FPGA.</p>
<h3>The bitstream and configuration memory</h3>
<p>The configuration information in the XC2064 is stored in configuration memory cells.
Instead of using a block of RAM for storage, the FPGA&#39;s memory is distributed across the chip in a 160×71 grid, ensuring that each bit is next to the circuitry that it controls.
The diagram below shows how the configuration bitstream is loaded into the FPGA.
The bitstream is fed into the shift register that runs down the center of the chip (pink).
Once 71 bits have been loaded into the shift register, the column select circuit (blue) selects a particular column of memory and the bits are loaded
into this column in parallel.
Then, the next 71 bits are loaded into the shift register and the next column to the left becomes the selected column.
This process repeats for all 160 columns of the FPGA, loading the entire bitstream into the chip.
Using a shift register avoids bulky memory addressing circuitry.</p>
<p><a href="https://static.righto.com/images/xc2064/shift-reg.jpg"><img alt="How the bitstream is loaded into the FPGA. The bits shown are conceptual; actual bit storage is much denser. The three columns on the left have been loaded and the fourth column is currently being loaded. Die photo from siliconpr0n." height="563" src="https://static.righto.com/images/xc2064/shift-reg-w600.jpg" title="How the bitstream is loaded into the FPGA. The bits shown are conceptual; actual bit storage is much denser. The three columns on the left have been loaded and the fourth column is currently being loaded. Die photo from siliconpr0n." width="600"/></a></p><p>How the bitstream is loaded into the FPGA. The bits shown are conceptual; actual bit storage is much denser. The three columns on the left have been loaded and the fourth column is currently being loaded. Die photo from <a href="https://siliconpr0n.org/map/xilinx/xc2064/">siliconpr0n</a>.</p>
<p>The important point is that the bitstream is distributed across the chip exactly as it appears in the file: the layout of bits
in the bitstream file matches the physical layout on the chip.
As will be shown below, each bit is stored in the FPGA next to the circuit it controls.
Thus, the bitstream file format is directly determined by the layout of the hardware circuits.
For instance, when there is a gap between FPGA tiles because of the buffer circuitry, the same gap appears in the bitstream.
The content of the bitstream is not designed around software concepts such as fields or data tables or configuration blocks.
Understanding the bitstream depends on thinking of it in hardware terms, not in software terms.<span id="fnref:format"><a href="#fn:format">7</a></span></p>
<p>Each bit of configuration memory is implemented as shown below.<span id="fnref:sram"><a href="#fn:sram">8</a></span>
Each memory cell consists of two inverters connected in a loop.
This circuit has two stable states so it can store a bit: either the top inverter is 1 and the bottom is 0 or vice versa.
To write to the cell, the pass transistor on the left is activated, passing the data signal through.
The signal on the data line simply overpowers the inverters, writing the desired bit.
(You can also read the configuration data out of the FPGA using the same path.)
The Q and inverted <span>Q</span> outputs control the desired function in the FPGA, such as closing a routing connection, providing a bit for a lookup table, or controlling the flip flops. (In most cases, just the Q output is used.)</p>
<p><a href="https://static.righto.com/images/xc2064/sram-schematic.png"><img alt="Schematic diagram of one bit of configuration memory, from the datasheet. Q is the output and Q is the inverted output." height="170" src="https://static.righto.com/images/xc2064/sram-schematic-w500.png" title="Schematic diagram of one bit of configuration memory, from the datasheet. Q is the output and Q is the inverted output." width="500"/></a></p><p>Schematic diagram of one bit of configuration memory, from the datasheet. Q is the output and <span>Q</span> is the inverted output.</p>
<p>The diagram below shows the physical layout of memory cells.
The photo on the left shows eight memory cells, with one cell highlighted.
Each horizontal data line feeds all the memory cells in that row. Each column select line selects all the memory cells in that column for writing.
The middle photo zooms in on the silicon and polysilicon transistors for one memory cell. The metal layers were removed to expose the underlying transistors.
The metal layers wire together the transistors; the circles are connections (vias) between the silicon or polysilicon and the metal.
The schematic shows how the five transistors are connected; the schematic&#39;s physical layout matches the photo.
Two pairs of transistors form two CMOS inverters, while the pass transistor in the lower left provides access to the cell.</p>
<p><a href="https://static.righto.com/images/xc2064/sram-cell-schematic.jpg"><img alt="Eight bits of configuration memory, four above and four below. The red box shows one bit. When a column select line is activated, the row data line is loaded into the corresponding cells. The closeup and schematic show one bit of configuration memory. Die photo from siliconpr0n." height="284" src="https://static.righto.com/images/xc2064/sram-cell-schematic-w800.jpg" title="Eight bits of configuration memory, four above and four below. The red box shows one bit. When a column select line is activated, the row data line is loaded into the corresponding cells. The closeup and schematic show one bit of configuration memory. Die photo from siliconpr0n." width="800"/></a></p><p>Eight bits of configuration memory, four above and four below. The red box shows one bit. When a column select line is activated, the row data line is loaded into the corresponding cells. The closeup and schematic show one bit of configuration memory. Die photo from <a href="https://siliconpr0n.org/map/xilinx/xc2018/dlyr1_mit100x_part">siliconpr0n</a>.</p>
<h3>Lookup table multiplexers</h3>
<p>As explained earlier, the FPGA implements arbitrary logic functions by using a lookup table.
The diagram below shows how a lookup table is implemented in the XC2064.
The eight values on the left are stored in eight memory cells.
Four multiplexers select one of each pair of values, depending on the value of the <code>A</code> input; if <code>A</code> is 0, the top value is selected and if <code>A</code> is 1
the bottom value is selected.
Next, a larger multiplexer selects one of the four values based on <code>B</code> and <code>C</code>. The result is the desired value, in this case <code>A XOR B XOR C</code>.
By putting different values in the lookup table, the logic function can be changed as desired.</p>
<p><a href="https://static.righto.com/images/xc2064/truth-table.png"><img alt="Implementing XOR with a lookup table." height="233" src="https://static.righto.com/images/xc2064/truth-table-w200.png" title="Implementing XOR with a lookup table." width="200"/></a></p><p>Implementing XOR with a lookup table.</p>
<p>Each multiplexer is implemented with pass transistors. Depending on the control signals, one of the pass transistors is activated, passing that input
to the output.
The diagram below shows part of the LUT circuitry, multiplexing two of the bits.
At the right are two of the memory cells. Each bit goes through an inverter to amplify it, and then passes through the multiplexer&#39;s pass
transistors in the middle, selecting one of the bits.</p>
<p><a href="https://static.righto.com/images/xc2064/lut-implementation.jpg"><img alt="A closeup of circuitry in the LUT implementation. Die photo from siliconpr0n." height="278" src="https://static.righto.com/images/xc2064/lut-implementation-w500.jpg" title="A closeup of circuitry in the LUT implementation. Die photo from siliconpr0n." width="500"/></a></p><p>A closeup of circuitry in the LUT implementation. Die photo from <a href="https://siliconpr0n.org/map/xilinx/xc2018/dlyr1_mit100x_part">siliconpr0n</a>.</p>
<h3>Flip flop</h3>
<p>Each CLB contains a flip flop, allowing the FPGA to implement latches, state machines, and other stateful circuits.
The diagram below shows the (slightly unusual) implementation of the flip flop.
It uses a primary/secondary design. When the clock is low, the first multiplexer lets the data into the primary latch.
When the clock goes high, the multiplexer closes the loop for the first latch, holding the value.
(The bit is inverted twice going through the OR gate, NAND gate, and inverter, so it is held constant.)
Meanwhile, the secondary latch&#39;s multiplexer receives the bit from the first latch when the clock goes high (note that the clock is inverted).
This value becomes the flip flop&#39;s output. When the clock goes low, the secondary&#39;s multiplexer closes the loop, latching the bit.
Thus, the flip flop is edge-sensitive, latching the value on the rising edge of the clock.
The set and reset lines force the flip flop high or low.</p>
<p><a href="https://static.righto.com/images/xc2064/flip-flop-die.png"><img alt="Flip flop implementation. The arrows point out the first multiplexer and the two OR-NAND gates. Die photo from siliconpr0n." height="405" src="https://static.righto.com/images/xc2064/flip-flop-die-w600.png" title="Flip flop implementation. The arrows point out the first multiplexer and the two OR-NAND gates. Die photo from siliconpr0n." width="600"/></a></p><p>Flip flop implementation. The arrows point out the first multiplexer and the two OR-NAND gates. Die photo from <a href="https://siliconpr0n.org/map/xilinx/xc2018/dlyr1_mit100x_part">siliconpr0n</a>.</p>
<h3>8-pin switch matrix</h3>
<p>The switch matrix is an important routing element. Each switch has eight &#34;pins&#34; (two on each side) and can connect almost any combination of pins together.
This allows signals to turn, split, or cross over with more flexibility than the individual routing nodes.
The diagram below shows part of the routing network between four CLBs (cyan). The switch matrices (green) can be connected with any combination of the
connections on the right. Note that each pin can connect to 5 of the 7 other pins. For instance, pin 1 can connect to pin 3 but not pin 2 or 4.
This makes the matrix almost a crossbar, with 20 potential connections rather than 28.</p>
<p><a href="https://static.righto.com/images/xc2064/switch-matrices.jpg"><img alt="Based on Xilinx Programmable Gate Array Data Book, fig 7b." height="397" src="https://static.righto.com/images/xc2064/switch-matrices-w600.jpg" title="Based on Xilinx Programmable Gate Array Data Book, fig 7b." width="600"/></a></p>
<p>The switch matrix is implemented by a row of pass transistors controlled by memory cells above and below.
The two sides of the transistor are the two switch matrix pins that can be connected by that transistor.
Thus, each switch matrix has 20 associated control bits;<span id="fnref:pass"><a href="#fn:pass">9</a></span> two matrices per tile yields matrix 40 control bits per tile.
The photo below indicates one of the memory cells, connected to the long squiggly gate of the pass transistor below.
This transistor controls the connection between pin 5 and pin 1. Thus, the bit in the bitstream corresponding to that memory cell controls the
switch connection between pin 5 and pin 1. Likewise, the other memory cells and their associated transistors control other switch connections.
Note that the ordering of these connections follows no particular pattern; consequently, the mapping between bitstream bits and the switch pins
appears random.</p>
<p><a href="https://static.righto.com/images/xc2064/network-switch-labeled.jpg"><img alt="Implementation of an 8-pin switch matrix. The silicon regions are labeled with the corresponding pin numbers.
The metal layers (which connect the pins to the transistors) were removed for this photo.
Based on die photo from siliconpr0n." height="284" src="https://static.righto.com/images/xc2064/network-switch-labeled-w600.jpg" title="Implementation of an 8-pin switch matrix. The silicon regions are labeled with the corresponding pin numbers.
The metal layers (which connect the pins to the transistors) were removed for this photo.
Based on die photo from siliconpr0n." width="600"/></a></p><p>Implementation of an 8-pin switch matrix. The silicon regions are labeled with the corresponding pin numbers.
The metal layers (which connect the pins to the transistors) were removed for this photo.
Based on die photo from <a href="http://siliconpr0n.org">siliconpr0n</a>.</p>
<h3>Input routing</h3>
<p>The inputs to a CLB use a different encoding scheme in the bitstream, which is explained by the hardware implementation.
In the diagram below, the eight circled nodes are potential inputs to CLB box DD.
Only one node (at most) can be configured as an input, since connecting two signals to the same input would short them together.</p>
<p><a href="https://static.righto.com/images/xc2064/input-routing.png"><img alt="Input selection. The eight nodes circled in green are potential inputs to DD; one of them can be selected." height="267" src="https://static.righto.com/images/xc2064/input-routing-w400.png" title="Input selection. The eight nodes circled in green are potential inputs to DD; one of them can be selected." width="400"/></a></p><p>Input selection. The eight nodes circled in green are potential inputs to DD; one of them can be selected.</p>
<p>The desired input is selected using a multiplexer.
A straightforward solution would use an 8-way multiplexer, with 3 control bits selecting one of the 8 signals.
Another straightforward solution would be to use 8 pass transistors, each with its own control signal, with one of them selecting the desired signal.
However, the FPGA uses a hybrid approach that avoids the decoding hardware of the first approach but uses 5 control signals instead of the eight required by the second approach. </p>
<p><a href="https://static.righto.com/images/xc2064/input-routing-schematic.png"><img alt="The FPGA uses multiplexers to select one of eight inputs." height="263" src="https://static.righto.com/images/xc2064/input-routing-schematic-w250.png" title="The FPGA uses multiplexers to select one of eight inputs." width="250"/></a></p><p>The FPGA uses multiplexers to select one of eight inputs.</p>
<p>The schematic above shows the two-stage multiplexer approach used in the FPGA.
In the first stage, one of the control signals is activated.
The second stage picks either the top or bottom signal for the output.<span id="fnref:mux"><a href="#fn:mux">10</a></span>
For instance, suppose control signal <code>B/F</code> is sent to the first stage and &#39;ABCD&#39; to the second stage; input B is the only one that will pass through to the output.
Thus, selecting one of the eight inputs requires 5 bits in the bitstream and uses 5 memory cells.</p>
<h2>Conclusion</h2>
<p>The XC2064 uses a variety of highly-optimized circuits to implement its logic blocks and routing.
This circuitry required a tight layout in order to fit onto the die.
Even so, the XC2064 was a very large chip, larger than microprocessors of the time, so it was difficult to manufacture at first and cost hundreds of dollars.
<!-- trimberger 2015 p321 -->
Compared to modern FPGAs, the XC2064 had an absurdly small number of cells, but even so it sparked a revolutionary new product line.</p>
<p>Two concepts are the key to understanding the XC2064&#39;s bitstream.
First, the FPGA is implemented from 64 tiles, repeated blocks that combine the logic block and routing.
Although FPGAs are described as having logic blocks surrounded by routing, that is not how they are implemented.
The second concept is that there are no abstractions in the bitstream; it is mapped directly onto the two-dimensional layout of the FPGA.
Thus, the bitstream only makes sense if you consider the physical layout of the FPGA.</p>
<p>I&#39;ve determined how most of the XC2064 bitstream is configured (see footnote <span id="fnref:table"><a href="#fn:table">11</a></span>) and I&#39;ve made a
<a href="https://github.com/shirriff/xc2064">program</a>
to generate the CLB information from a bitstream file.
Unfortunately, this is one of those projects where the last 20% takes most of the time, so there&#39;s still work to be done.
One problem is handling I/O pins, which are full of irregularities and their own routing configuration.
Another problem is the tiles around the edges have slightly different configurations.
Combining the individual routing points into an overall netlist also requires some tedious graph calculations.</p>
<p>I announce my latest blog posts on Twitter, so follow me at <a href="https://twitter.com/kenshirriff">kenshirriff</a> for updates. I also have an <a href="https://www.righto.com/feeds/posts/default">RSS feed</a>.
Thanks to John McMaster, Tim Ansell and Philip Freidin for discussions.<span id="fnref:references"><a href="#fn:references">12</a></span></p>
<h2>Notes and references</h2>
<!-- -->



</div></div>
  </body>
</html>
