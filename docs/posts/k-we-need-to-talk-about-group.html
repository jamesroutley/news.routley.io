<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/chrispsn/3450fe6172a7cc441d0819379ed3a32a">Original</a>
    <h1>K: We need to talk about group</h1>
    
    <div id="readability-page-1" class="page"><p>
    We need to talk about group.
  </p><div>
  <div id="file-we-need-to-talk-about-group-md">
      
      <div id="file-we-need-to-talk-about-group-md-readme">
    <article itemprop="text">
<p dir="auto">I&#39;m sorry to tell you, but group is gone.</p>
<p dir="auto">If you check out the latest <code>k.d</code> on <a href="https://shakti.com/" rel="nofollow">shakti.com</a> as at 28 March 2023, you&#39;ll see that &#39;unary&#39; <code>=</code> is now &#39;freq&#39; (frequency).</p>
<p dir="auto">Group had a long life: it&#39;s been around since at least k2, or <a href="https://web.archive.org/web/20191202012157/shakti.com/database-software-history/" rel="nofollow">1996</a>.</p>
<p dir="auto">So why did group go? And what should we use instead?</p>
<p dir="auto">Code examples will be in ngn/k unless otherwise stated.</p>
<h2 dir="auto"><a id="user-content-what-does-group-do" aria-hidden="true" href="#what-does-group-do"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What does group do?</h2>
<p dir="auto">Group tells you where each item occurs in a list. It generates lists of indices. <a href="https://ngn.codeberg.page/k/#eJxdjkEKg0AMRfc5xa8bF6VIpaVFEDyKmZnQFtQpEUuEHr7obKrZJPlJfp5VGTtlz2FJGVFt2EWBh8bpDSOy6owLStxxxY2sqcuD0bHIU/V3MU79Sdg/MUy9Ex2ThQS4GTEERIV8ZCB6dzyLVi13Ly+ti671rLHb9zT6qLL5vipNnQzoW+QbYYHo2RLEOtkwpKUfZhBNvw==" rel="nofollow">Here</a> are some examples in the ngn/k web editor.</p>
<p dir="auto">Here, we group numbers by whether they are even or odd:</p>
<pre><code> x:1 4 2 8 5 7
 =2!x
1 0!(0 4 5;1 2 3)  / indices of elements in input list
 x@=2!x
1 0!(1 5 7;4 2 8)  / index back into original list to group the elements
 +/&#39;x@=2!x         / do something with them, eg...
13 14              / ... subtotals of odd and even elements
</code></pre>
<p dir="auto">You could also take that dict of indices resulting from group and use it to index into <em>another</em> data structure. For example:</p>
<pre><code> player:`alice`bob`carol`alice`bob`carol
 score:1 4 2 8 5 7
 score@=player
`alice`bob`carol!(1 8;4 5;2 7)  / scores of each player
 |/&#39;score@=player               
`alice`bob`carol!8 5 7          / max score of each player
</code></pre>
<p dir="auto">There are differences in the way different k dialects implement group (list vs dict; entry order):</p>
<ul dir="auto">
<li><a href="http://nsl.com/k/k2/k295/kreflite.pdf" rel="nofollow">k2</a> returns indices lists corresponding to the unique values in the input list (in the order in which they appeared)</li>
<li><a href="https://code.kx.com/q/ref/group/" rel="nofollow">k4/q</a> to k6 (including ngn/k) returns the same, but as a dict keyed by those unique values</li>
<li><a href="https://kparc.io/kc/#%3D%22mississippi%22" rel="nofollow">k7</a> and <a href="https://kparc.com/k/#%3D%22mississippi%22" rel="nofollow">k9 2021</a> does the same, but sorted by the keys. In k9 2021 you can get it back to key occurrence order with <code>&lt;</code>.</li>
</ul>
<pre><code> / k2
 = 2 1 2 2 1 1
(0 2 3   / indices of 2
 1 4 5)  / indices of 1

 / k4/q
 group &#34;mississippi&#34;
m| ,0
i| 1 4 7 10
s| 2 3 5 6
p| 8 9

 / k7
2019-09-25 10:44:44 Œ± 4core 512mb wsm32 (c) shakti
 =&#34;mississippi&#34;
i|1 4 7 10
m|,0
p|8 9
s|2 3 5 6

 / k9 2021
w2021.03.27 1gb chrome (c)shakti 2.0
 =&#34;mississippi&#34;
i|1 4 7 10
m|,0      
p|8 9     
s|2 3 5 6

 &lt;=&#34;mississippi&#34;  / sorts dict by values
m|,0      
i|1 4 7 10
s|2 3 5 6 
p|8 9 
</code></pre>
<h2 dir="auto"><a id="user-content-why-change--from-group-to-freq" aria-hidden="true" href="#why-change--from-group-to-freq"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Why change <code>=</code> from group to freq?</h2>
<p dir="auto">Only Arthur knows for sure, but here are some guesses:</p>
<h3 dir="auto"><a id="user-content-1-group-is-too-slow" aria-hidden="true" href="#1-group-is-too-slow"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>1) Group is too slow</h3>
<p dir="auto">We know that one of Arthur&#39;s k design principles is that &#34;the slowest primitive to the fastest primitive have to live within one order of magnitude in speed... you can&#39;t have operations that are powerful but impractical from a CPU point of view&#34;. [1]</p>
<p dir="auto">So you&#39;d expect the slowest operation to take at most 10x the fastest operation.</p>
<p dir="auto">On this test, group is on rocky ground. I won&#39;t use performance numbers from Arthur&#39;s k implementations, but data from other array langs suggest the performance difference is closer to <em>two</em> orders of magnitude, ie 100x:</p>
<ul dir="auto">
<li>In ngn/k&#39;s web REPL, with <code>d:10000?100</code>, I was <a href="https://ngn.codeberg.page/k/#eJxLsTI0AAJ7IMnFFVMC4Slo66cgOLYpAJcNCBM=" rel="nofollow">seeing</a> <code>=d</code> take ~100x more than <code>+/d</code>.</li>
<li>We can also look to Marshall Lochbaum&#39;s <a href="https://mlochbaum.github.io/bencharray/pages/summary.html" rel="nofollow">BQN bencharray</a>. Depending on the data type, BQN&#39;s group takes (roughly!) around 10ns per element, which is ~20-200x more than the fastest operation family (arithmetic without overflow). [2]</li>
</ul>
<p dir="auto">Outside of searching and sorting, not many primitives hit the upper bound of that 20-200x speed difference. For example, again according to bencharray, frequency (<code>#&#39;=</code> in K and <a href="https://mlochbaum.github.io/BQN/doc/replicate.html#inverse" rel="nofollow"><code>/‚Åº</code> in BQN</a>) hits up to 2ns per element for large inputs, so 1/5 of of the time to do a group.</p>
<p dir="auto">It makes sense that group is slow: it does a lot of work!</p>
<h4 dir="auto"><a id="user-content-implementing-group-in-k" aria-hidden="true" href="#implementing-group-in-k"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Implementing group in k</h4>
<p dir="auto">Group is basically a cut-up grade, potentially with some extra work depending on whether we want the dict entries (a) in order of first occurrence, or (b) sorted by the keys.</p>
<p dir="auto">The trick is finding where to cut. We could sort the input and see where the elements change:</p>
<pre><code>{g:(&amp;~x~&#39;:x i)_i:&lt;x  / grade; cut; where; match-each-prior
 x[*&#39;g]!g@:&lt;g}       / grade again (skip this step if you want the result sorted by key); index
</code></pre>
<p dir="auto">(The above is ngn/k&#39;s <a href="https://codeberg.org/ngn/k/src/commit/ba0e0ba340dc0c392c04037ef98ce36ae8078c14/o.c#L24" rel="nofollow">k-string implementation</a> of group.)</p>
<p dir="auto">Or we could find where to cut by sorting a list of bools marking the first occurrence of each element:</p>
<pre><code>/ k9 2021 syntax
{u:a=!#a:x?x         / self-find to mark first occurrences (boolean list)
 x[&amp;u]!(u@)^&lt;a}      / grade; cut; index; where; dict. (no empty case handling)
</code></pre>
<p dir="auto">Compare this to a frequency implementation: data stays nice and flat, with no sorts or cuts required. Just create a histogram, filter it to exclude empty bins, and slap some labels on top.</p>
<pre><code>{a:@[&amp;#x;x?x;+;1]    / no sort or cut;
 !/(x;a)[;&amp;0&lt;a]}     / just self-find, 0&lt;, where, indexing.
</code></pre>
<h3 dir="auto"><a id="user-content-2-groups-generality-is-wasted" aria-hidden="true" href="#2-groups-generality-is-wasted"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>2) Group&#39;s generality is wasted</h3>
<p dir="auto">Notwithstanding the k design principle violation, maybe group is so useful that it&#39;s worth a slot.</p>
<p dir="auto">Thankfully we have data to test this: ngn/k&#39;s test corpus! I classified 400 lines of k code containing the <code>=</code> character [3]:</p>
<pre><code>Category  Description    Freq #&#39;=  Group values x@=f x  Other/dunno  # group uses  # tests  % that use group
========  ============   ========  ===================  ===========  ============  =======  ================
aoc/15    AdventOfCode          2                    0            2             0       21               10%
aoc/16    AdventOfCode          2                    0            0             0       15               13%
aoc/17    AdventOfCode          0                    0            0             0       14                0%
aoc/18    AdventOfCode          0                    0            0             0       11                0%
aoc/19    AdventOfCode          0                    0            2             2       22                9% 
aoc/20    AdventOfCode          2                    0            1             3       25               12%
aoc/21    AdventOfCode          3                    0            0             0        3               13%
aoc/22    AdventOfCode          0                    0            0             0       24                0%
dy        TryAPL                5                    1            5            11      250                4%
e         ProjectEuler          1                    4            0             5      100                5%
g         CodeGolf             10                    3            4            17      263                6%
l         ngn/k libs            0                    0            1             1        4               25%
          TOTAL                23                    8           14            46      724                6%
</code></pre>
<p dir="auto">So:</p>
<ul dir="auto">
<li>roughly 5-10% of problems involve group</li>
<li>of those uses, half are freq (<code>#&#39;=</code>)</li>
<li>the rest are a mix of uses of indexing back into the original list (then doing more work, eg <code>+/&#39;</code>)</li>
<li>at least one of the &#39;other&#39; uses is a <code>#=</code> which is probably better done as <code>#?</code> - suggestive...</li>
</ul>
<p dir="auto">Does having the user do freq as <code>#&#39;=</code> impact speed? Maybe!</p>
<ul dir="auto">
<li>While <code>#&#39;=</code> could be recognised as an idiom and be computed by fast code that does less than a &#39;full&#39; group, the need for idiom recognition is running thin:
<ul dir="auto">
<li><code>*|</code> is better as <code>:/</code> since the latter is a verb that doesn&#39;t ever require brackets, and (especially in Arthur&#39;s latest ks) there&#39;s little to no need for a space before the colon</li>
<li><code>*&lt;</code> and <code>*&gt;</code> (min- and max-index) might qualify, as could <code>#?</code> (unique-count) and <code>*&#39;=</code> (first-of-each-group)</li>
<li>but maybe the interpreter is simpler if those cases are just keywords and idiom recognition is left out.</li>
</ul>
</li>
<li>Having freq as a primitive encourages its use, so &#39;normal&#39; user code will tend to use that function more.</li>
<li>Shorter code is easier to simplify and optimise. Every character counts.</li>
</ul>
<h4 dir="auto"><a id="user-content-undo-to-the-rescue" aria-hidden="true" href="#undo-to-the-rescue"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>&#39;Undo&#39; to the rescue?</h4>
<p dir="auto">Let&#39;s say you&#39;re an implementer and you want a fast way to freq, without losing <code>=</code> or relying on idiom recognition of <code>#&#39;=</code>.</p>
<p dir="auto">k uses <code>noun?</code> as function inverse. So <code>`j?</code> decodes a JSON string into k data.</p>
<p dir="auto">Given where (<code>&amp;:</code>) is run-length-decode, we can get something like freq with <code>(&amp;:)?</code>. Now, there could be duplicate keys...</p>
<pre><code> (&amp;:)?&#34;abbaaacccc&#34;
&#34;abac&#34;!1 2 3 4 
</code></pre>
<p dir="auto">...so we could either:</p>
<ul dir="auto">
<li>sort the input in advance</li>
<li>exchange the domain and range of the dict, group <em>that</em>, then <code>+/&#39;</code>.</li>
</ul>
<p dir="auto">It&#39;s similar to how BQN implements freq <code>/‚Åº</code> as the inverse (<code>‚Åº</code>) of replicate (<code>/</code>) (<a href="https://mlochbaum.github.io/BQN/doc/replicate.html#inverse" rel="nofollow">docs</a>), but it&#39;s even better because k has dicts, so it can validly express cases where elements appear out of sorted order.</p>
<p dir="auto">And run-length-encode could be handy in other situations, such as for <a href="https://justine.lol/sizetricks/#rle" rel="nofollow">simple data compression</a>.</p>
<p dir="auto">Having said all that, the k-string version of freq above was way faster than a run-length-encoding version based on some brief testing I did in ngn/k, so this path might be fruitless.</p>
<h3 dir="auto"><a id="user-content-3-group-sucks-actually" aria-hidden="true" href="#3-group-sucks-actually"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>3) Group sucks, actually</h3>
<p dir="auto">Sometimes group is just not the right tool for the job.</p>
<ul dir="auto">
<li>You might accidentally assume the group&#39;s entries are in a particular order.</li>
<li>You can&#39;t group dict entries.</li>
<li>The result of outdexing a group may not be what you expected.</li>
<li>Group inherently nests data - flatter solutions using other primitives may do the job faster and with less complication.</li>
</ul>
<p dir="auto">Let&#39;s go through examples:</p>
<h4 dir="auto"><a id="user-content-group-entry-order" aria-hidden="true" href="#group-entry-order"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Group entry order</h4>
<p dir="auto">kcc - Kelas&#39;s k tutorial - has a <a href="https://github.com/kparc/kcc#how-to-solve-it">nice quicksort implementation</a> (translated to ngn/k below; try it <a href="https://ngn.codeberg.page/k/#eJxLs6pWiTayU7avsK6w1tHPV69wUFOvs4qpsNEytK+IreVKUyoszUzOLs4vKlECADGZDhY=" rel="nofollow">here</a>):</p>
<pre><code> f:{$[2&gt;#?x;x;,/o&#39;x@&amp;&#39;~:\x&lt;*1?x]}
 f &#34;quicksort&#34;
&#34;cikoqrstu&#34;
</code></pre>
<p dir="auto">A naive person (me) might say, &#34;that not-converge <code>~:\</code> looks wasteful - why can&#39;t we just group the bools that result from <code>x&lt;1?x</code>? In other words, replace <code>x@&amp;&#39;~:\</code> with <code>=x!x</code>?&#34;:</p>
<pre><code> f:{$[2&gt;#?x;x;,/o&#39;=x!x&lt;*1?x]}
 f &#34;quicksort&#34;
&#34;qrsutoick&#34;                     / uh oh
</code></pre>
<p dir="auto">What happened? If we put a print <code>\</code> before the recursive call <code>o&#39;</code>, we see that group&#39;s keys are not always sorted:</p>
<pre><code> f:{$[2&gt;#?x;x;,/o&#39; \ =x!x&lt;*1?x]}
 f &#34;quicksort&#34;

0 1!(&#34;qusort&#34;;&#34;ick&#34;)
0 1!(&#34;qusrt&#34;;,&#34;o&#34;)
1 0!(&#34;qsr&#34;;&#34;ut&#34;)
1 0!(&#34;qr&#34;;,&#34;s&#34;)
1 0!(,&#34;q&#34;;,&#34;r&#34;)
0 1!(,&#34;u&#34;;,&#34;t&#34;)
1 0!(&#34;ic&#34;;,&#34;k&#34;)
(,0)!,&#34;ic&#34;
0 1!(,&#34;i&#34;;,&#34;c&#34;)
</code></pre>
<p dir="auto">Note that implementations that sort group keys, like k9 2021, can avoid this issue:</p>
<pre><code> w2021.03.27 1gb firefox (c)shakti 2.0
 f:{$[2&gt;#?x;x;,/f&#39;|=x!x&lt;*1?x]}
 f&#34;quicksort&#34;
&#34;cikoqrstu&#34;
</code></pre>
<h4 dir="auto"><a id="user-content-grouping-dict-entries" aria-hidden="true" href="#grouping-dict-entries"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Grouping dict entries</h4>
<p dir="auto">We can certainly group a dict:</p>
<pre><code> =`a`b`c`a`b`c!1 4 2 8 5 7
1 4 2 8 5 7!(,`a;,`b;,`c;,`a;,`b;,`c)
</code></pre>
<p dir="auto">But what if we want to group dict entries by group of something else? <code>dict@=groups</code> won&#39;t work, because that does indexing.</p>
<p dir="auto">While k doesn&#39;t let you <em>pick</em> arbitrary dict entries based on order, many of its ops do have a way to act on dict entries. k9 2021, for example:</p>
<pre><code>w2021.03.27 1gb chrome (c)shakti 2.0
 d:`a`b`c`a`b`c!1 4 2 8 5 7
 ^d  / sort by key
a|1
a|8
b|4
b|5
c|2
c|7
 &lt;d  / sort by value
a|1
c|2
b|4
b|5
c|7
a|8
 `a`b#d  / it doesn&#39;t keep all matching entries, but at least it doesn&#39;t just give values
a|1
b|4
</code></pre>
<p dir="auto">Group is therefore unusual because it can&#39;t group a dict&#39;s <em>entries</em>, only its values. (This comes up later.)</p>
<h4 dir="auto"><a id="user-content-missing-entries-and-prototype-issues" aria-hidden="true" href="#missing-entries-and-prototype-issues"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Missing entries and prototype issues</h4>
<p dir="auto">Group returns a dict of key lists. If I index into that dict using a key that isn&#39;t in its domain, I&#39;d expect to receive an empty list.</p>
<p dir="auto">But as at 28 March 2023, that is <em>not</em> what happens!</p>
<pre><code>/ k7
2019-09-25 10:44:44 Œ± 4core 512mb wsm32 (c) shakti
 (=&#34;ab&#34;)&#34;c&#34;
,√ò

/ k9 2021
w2021.03.27 1gb chrome (c)shakti 2.0
 (=&#34;ab&#34;)&#34;c&#34;
,0

/ oK
Welcome to oK v0.1
(inspired by K5; \h for help)
  (=&#34;ab&#34;)&#34;c&#34;
0N

/ ngn/k (28 Mar 2023)
ngn/k, (c) 2019-2023 ngn, GNU AGPLv3. type \ for more info
 (=&#34;ab&#34;)&#34;c&#34;
,0N
</code></pre>
<p dir="auto">In all of these cases, we receive a list of one null (or a null atom in oK). This can be explained as the result of outdexing on a list: such cases return the <strong>prototype</strong> of the values list, which is a value with the same structure as the first element of the values list, but with nulls replacing any atoms.</p>
<p dir="auto"><strong>Why do prototypes matter?</strong> Well, remember Wordle? Let&#39;s write a Wordle guess scorer. The problem is stated <a href="https://codegolf.stackexchange.com/a/250587/82504" rel="nofollow">here</a>.</p>
<p dir="auto">We could:</p>
<ul dir="auto">
<li>find letters that match in value and position (greens)</li>
<li>of the remaining letters, take as many from the guess as there are in the answer (yellows)</li>
<li>assign code 1 for greens, 2 for yellows, 0 for greys.</li>
</ul>
<p dir="auto">A first cut:</p>
<pre><code>f:{[answer;guess]
   green:answer=guess    / green if value and position match
   d:=&#39;(answer;guess)    / indices lists for each letter in each word
   d:d^\:\:&amp;green        / strip green letters from index lists
   yi:#&#39;/(#:&#39;;::)@&#39;d     / yellow if letter in different position
   @[green;yi;:;2]}      / green 1, yellow 2, grey 0
</code></pre>
<p dir="auto">If you <a href="https://ngn.codeberg.page/k/#eJxNkF1rwjAUhu/7Kw4VVgWh2ssUwU4KCnEVhSFTB8WkGqitJNGujO23L+mpdQ25yJPzfqQ+vKXizh0nI9+7tFAVl+HpxpU6OABwkpwXBPGkwQaCjxxEBvc0v3FICwbXUgktygIuqT6erZiRidf/bzlAsSiYOHIFuVBaQVZK4OnxDDnXmktzi8eqlAxd2Oee7MkLZrafD0pLcW2LoNR4yfJi7fkXmlt9LUjP8/s94oWEDKYea/U1z/Oysm94BjORZVzyQnevsQ7TXZMS1iIkYXD4eTTA7PHwYRUMLaphZH7mlLjzmNLEdZwRtOs3czezdbRynTG0y6B2LDATzTYoXiWzudsJLZot3hfUIitD9BpTnAo6+48kWW6s1xNRGi0jFD5QHK8XsS0x6rzmEY0olhh3QrrdYokmExGl7h/CVZvc" rel="nofollow">run this</a>, you&#39;ll find a problem at this line:</p>
<pre><code>yi:#&#39;/(#:&#39;;::)@&#39;d
</code></pre>
<p dir="auto">It&#39;s not truncating the indices lists in the guess dict as expected.</p>
<p dir="auto">The problem is the assumption about how <code>dict #&#39; dict</code> (take-each) behaves:</p>
<ul dir="auto">
<li>I had thought that if letter key were in the guess (RHS) but not in the answer (LHS), it would take zero of that letter&#39;s indices from those remaining in the grouped answer dict.</li>
<li>But if a key is missing from a dict, indexing in returns a value with the structure of the first item in the dict&#39;s values list, but filled with nulls.</li>
<li>In this case, the first item in the dict&#39;s values list is a number atom (since we ran <code>#&#39;</code> over it to get the counts), so the value used by the take-each is <code>0N</code>. And in ngn/k, <code>0N#</code> returns the whole list. [4]</li>
</ul>
<p dir="auto">(In this case k9 2021 wouldn&#39;t have this problem since null is <code>0</code> rather than <code>0N</code>.)</p>
<p dir="auto">Arguably, using <code>dict #&#39; dict</code> is the wrong move here because we don&#39;t get an opportunity to fill the nulls in the left hand side with zero (<code>0^</code>) before doing the take.</p>
<p dir="auto">We hit a similar problem if a letter was in the answer (LHS), but not in the guess (RHS). Take-each will return a list of nulls equal to the number of remaining times that letter appears in the answer. (This is more of an issue with using take-each: unlike drop-each, if you overtake from a list, it will expand the list by repeating the chars (or nulls if the list was empty).)</p>
<p dir="auto">Unlike the case where a letter was in the guess but not in the answer, we can solve this problem by prepending <code>!/,&#39;(&#34; &#34;;!0)</code> to the dict. That way, empty list will get used as the prototype fill for missing letters.</p>
<p dir="auto">We can avoid these outdexing issues by only keeping letters common to the answer and guess (once removing the greens):</p>
<pre><code>f:{[answer;guess]
   green:answer=guess    / green if value and position match
   d:=&#39;(answer;guess)    / indices lists for each letter in each word
   d:d^\:\:&amp;green        / strip green letter indices
   d:(~#:&#39;)_&#39;d           / strip letters with no indices left   &lt;- new step
   d:(^/^\!&#39;d)#/:d       / keep only entries of shared letters  &lt;- new step
   yi:#&#39;/(#:&#39;;::)@&#39;d     / indices of yellow letters in guess
   @[green;yi;:;2]}      / green 1, yellow 2, grey 0
</code></pre>
<p dir="auto">Try this revised solution online <a href="https://ngn.codeberg.page/k/#eJxNkF1rgzAUhu/9FWcWZoWCrZeRQl0RWkixtDDK+jGkiTXMmWLSiYztty8xfizBCx/P855zTNH3MSlERcvg9qBCnC0AuJWUFsjgeYMVBM9wYCl8JfmDQlIQuHPBJOMFfCbymmmZoLkz/h/pGpkVhF2pgJwJKSDlJdDkmkFOpaSl+mpeK14Sk0IuJ3RCz6ZnezwQsmT3dpBebYKNNf4dIcd9dwgMp7NMvYCKyQwKPkxEU9naF+9yenKIO/IQ6e0PSu/Ai7wGWqggZfAURJaUlHSZWq8ZGjneWPUPEHIX7QjD4kqqaZ7zqh9ELd38IW0vjs1SQc0CFPjnn665WXU26Vx/olENU8tKF8heRRjHtmVNob2/qb1f7sKtbc2gvQq1Zb6qaB6Fom28XNm9qNFy/brGGmnNoJcImyq/j3+L481eZw0I43ATGrFDUbRbR3qIaZ+1CnGIzRCzXsSHgxmi6WkQxvYfB2K4sQ==" rel="nofollow">here</a>.</p>
<p dir="auto">It was a lot of work to prepare these dicts for the take-each. It suggests that groups and <code>dict dyad&#39; dict</code> ops are more useful when you know that all the keys are present in both dicts.</p>
<h4 dir="auto"><a id="user-content-other-tools-are-more-appropriate" aria-hidden="true" href="#other-tools-are-more-appropriate"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Other tools are more appropriate</h4>
<p dir="auto">How else could we score a Wordle guess? If we look at the other array language solutions:</p>
<ul dir="auto">
<li><a href="https://codegolf.stackexchange.com/a/250587/82504" rel="nofollow">ovs&#39;s ngn/k solution</a> does use group, but does a simpler <code>@&#39;</code> instead of the <code>#&#39;</code>. It uses find to effectively ignore nulls that result from outdexing.</li>
<li><a href="https://codegolf.stackexchange.com/a/250570/82504" rel="nofollow">Bubbler&#39;s ngn/k solution</a> eschews groups completely. It instead deletes (<code>list_idx</code>) letters if common to both words, and keeps a record of the word prior to each deletion decision: if the word changed, the letter&#39;s yellow, else grey.</li>
<li>Both solutions reorder the words to put greens at the front so that any &#39;excess&#39; values resulting from deletion or indexing are regarded as yellow. They also <strong>sort words based on category, rather than grouping</strong> (prioritising greens). In particular, Bubbler processes <strong>under</strong> sort (permute list, transform list, return list to original order) and the data is kept <strong>flatter</strong>.</li>
<li>Both solutions are also doing a <strong>progressive</strong> search, where a successfully found element in the target is disqualified from being a match for the next searched-for element. BQN has built-in progressive find, and <a href="https://codegolf.stackexchange.com/a/241726/82504" rel="nofollow">ovs&#39;s BQN solution</a> uses it, doing a &#34;find under permute&#34; (which funnily enough uses the equivalent of sorted-keys group). <a href="https://ngn.codeberg.page/k/#eJxFjk1Kw0AUx/dzikeyaEIDSQpukrQ2hkADU1JakKIoVPNBMCSaFM1Q2rUNuhFdFlzqDVz1At5iTuARzDQxzmMW78f7f8gQav3u0YBu31e0fKFPe4E+7n92bx+0/KLlq/i9q5bPNd0+A3syXN0lyNNWx7LAFzpPRL4jGIbYEQqJ6EQqxDU78sjCi67hNkvDzM/z6N6HIEo8qCJQoK3C7ubSOy90AtHF0Ii0QaiRfrFuEm5gmS2SPF4sozRBKBhq3MjG2OUQkkGBypFIoALx4zh9kKDHiJ8gBZrZBNzMmpoTDvWgmQo1Fmp1cfgVsieuNeJaIUOWc+pghpisRic2rq/U1v7Mdccz5vWPMDbHZi38Q7Y9dWxWQmm9RiY2cV2i1wrxfF6XOGTWCGPuFz4xdZs=" rel="nofollow">Here</a>&#39;s a rough k translation.</li>
</ul>
<p dir="auto">Here&#39;s another problem, this time from the APL Farm chatroom: <strong><a href="https://discord.com/channels/821509511977762827/821511464090992640/1017244338025148488" rel="nofollow">Miguel Raz&#39;s &#39;pigdog&#39; challenge</a></strong>.</p>
<blockquote>
<p dir="auto">Given a string comprising ASCII words separated by 1+ whitespace characters, output the Pigdog Latin version of the string. Preserve whitespace and case. For each word:</p>
<ul dir="auto">
<li>if it starts with a vowel, it becomes &#39;pig&#39;+word (eg igloo =&gt; pigigloo)</li>
<li>else, it becomes word+&#39;dog&#39; (eg cup =&gt; cupdog)</li>
</ul>
</blockquote>
<p dir="auto">A non-array-style solution could be to split the words, classify each one based on whether they start with a consonant, vowel or whitespace; then raze them back together:</p>
<pre><code>{x:(&amp;~=&#39;:^x)_x
 c:+/(2*~:;^:)@\:&#34; aeiou&#34;?_*&#39;x           / 0=vowel 1=consonant 2=wspace
 ,/((&#34;pig&#34;,;{x,&#34;dog&#34;};::)c)@&#39;x}
</code></pre>
<p dir="auto">But it might be more array-style to group the words by class and transform each group in one hit (at least, as much as we can when working with strings); then put the words back in the order they started, and raze.</p>
<p dir="auto">This time we know the footguns! We&#39;ll override the groups&#39; prototypes so that outdexing generates an empty list, and we&#39;ll force key order and presence so that everything lines up for the final amend...</p>
<pre><code>{x:(&amp;~=&#39;:^x)_x
 x@:i:=+/(2*~:;^:)@\:&#34; aeiou&#34;?_*&#39;x      / 0=vowel 1=consonant 2=wspace
 (x;i):((,3)!/:,&#39;(();!0)),&#39;(x;i)        / group prototype override
 x:(0 1 2!(&#34;pig&#34;,/:;{x,&#34;dog&#34;}&#39;;::))@&#39;x  / force order, entry presence in x
 ,/@[,/x;0 1 2 3#i;:;x]}                / force order, entry presence in i
</code></pre>
<p dir="auto">...and we will get absolutely smoked by <a href="https://matrix.to/#/!EjsgbQQNuTfHXQoiax:matrix.org/$Q1_g1KnM5U-6XGzhJMavnF_46u44pBcLEwiKylgvE54?via=matrix.org" rel="nofollow">Marshall&#39;s version</a> [5] that shoves a bunch of <code>&#34;pig&#34;</code>s and <code>&#34;dog&#34;</code>s onto the end of the input and permutes it:</p>
<pre><code>{d:~1=&#39;:s:^x             / s‚Äøe‚Üê1‚ä∏¬ª‚ä∏(&gt;‚ãà&lt;)&#39; &#39;=ùï©
 c:^&#34;aeiou&#34;?_x@&amp;d&amp;~s     / c‚Üê¬¨(s/ùï©)‚àä&#34;aeiou&#34;
 x,:,/$`pig`dog c        / ins‚Üê‚•äc‚äè[&#34;pig&#34;,&#34;dog&#34;]
 x@&lt;(+\d),{3}#c+2*!#c}   / ((+`s+e)‚àæ3/c+2√ó‚Üï‚â†c) ‚çã‚ä∏‚äè ùï©‚àæins
</code></pre>
<p dir="auto">Marshall&#39;s is <a href="https://ngn.codeberg.page/k/#eJylU81u00AQvvspJluU2I2LneS2bko4cOiBE73117XXmxWRN9p1WkdVo56qkgrBpeKExIUDEg+AhARSeRM/AY/A7DpRq4pSVVjWej3zzTffrD8HkAyV0GOdR8CVnIzXpo6T0ZOSus1Zv0X3Sm+/dACgHFBB++3A7a7OaLRHvcEOJRAzISfk2f5qqwR7BRD2j+QxG0Gnn8hcyzzOC+j2j/U4TpghcstIeNR1/Z7XCKjfcl0vaoSehzuTAVgSWTkwVrKQxXTMQB4xpURqSVBeCB3oNlwyFpz4AY1OSp+kkpPTVkSp5w2MogAyqRIsVSlTPrC8UFNkZJrlGBU52NH8YLDtB2VkGaG3IiIalbuncOd6kEw4jlETAwqdohQ4FNw8MCb4JM5jMstInTUpWAQdsjXc1Avgpjbrcyhe6C0zDVaYLOBdB0ndQxWYAmKeDkmkHNVgsHsMod6hMJzFkCm2TNpoHbIYq7amMxMO5UQbLG5NY4AYbmdM2CGWyFbXGNyqmn/gE0UcZ81xAngZKz2MRyMgmShZCtkoLszkWsicPEXAq/FIFBoOFYtfa6jefMITLCRkWCNyDhsQ5ymgM83LuuNwepLSWQcdqdGTd76Lrs5+sur8faeaf7v+jou7UV1erHstaPV/f7z6Yj5yQvfI0q3loJk2Z3pRnWDl9VdXBwbqVRfzBc76zKd+8OQAj+jAnEty01PkGuuqz/Okmr/brl1o/bdb/y3rbnsn9fymm7S7q42VxGv0Tk2d67YPdJthnx+9AHO/PlTnVzh+4kH19hK1Ix0YJQjAHvY4H3IVf7Sr+P2u4ndNxf/hKf4oS/F7LcWXjuK3HcVvHLVT0E4YQga4huHK3wZeQPjDkP9j+QNVPJrB" rel="nofollow">shorter and about 6x faster</a>. In fact, even the &#39;listy&#39; non-array-style version is faster than our group version.</p>
<p dir="auto">So just because a bunch of elements should be processed in the same way, doesn&#39;t mean it always makes sense to group them and process them together.</p>
<p dir="auto">None of this is intended to advocate for a particular behaviour of group (well, maybe prototypes need another look). It&#39;s just to suggest that <strong>details matter</strong>. Group may be hard for an inexperienced user to use correctly, and sometimes, another route may be more direct and lead to more robust and potentially faster code.</p>
<h2 dir="auto"><a id="user-content-when-is-group-the-right-tool" aria-hidden="true" href="#when-is-group-the-right-tool"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>When is group the right tool?</h2>
<p dir="auto">In pigdog, we didn&#39;t have to consider the context of each word or which other words fell into the same group.</p>
<p dir="auto">But sometimes we need to process items in a group in totality rather than separately (such as a sum-over). Maybe the order of the items in each group matters too (such as a sum-scan).</p>
<p dir="auto">And maybe those cases come up frequently for Shakti&#39;s clients - such as time series where the current state depends on the order, values and categories of data in a stream.</p>
<p dir="auto">To illustrate this, we naturally turn to <del>traded volumes for each ticker</del> Brainfuck.</p>
<p dir="auto">Problem: Implement a <a href="https://en.wikipedia.org/wiki/Brainfuck#Commands" rel="nofollow">simplified Brainfuck interpreter</a>.</p>
<table>
<thead>
<tr>
<th>Op</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;</code></td>
<td>Increment the data pointer (to point to the next cell to the right).</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Decrement the data pointer (to point to the next cell to the left).</td>
</tr>
<tr>
<td><code>+</code></td>
<td>Increment (increase by one) the byte at the data pointer.</td>
</tr>
<tr>
<td><code>-</code></td>
<td>Decrement (decrease by one) the byte at the data pointer.</td>
</tr>
<tr>
<td><code>.</code></td>
<td>Output the byte at the data pointer.</td>
</tr>
</tbody>
</table>
<p dir="auto">Marshall Lochbaum&#39;s <a href="https://mlochbaum.github.io/BQN/try.html#code=QkYg4oaQIHsKICBT4oaQLcudPeKMnOKfnPCdlakKICAoJy4nPfCdlakpLytgwqjijL4oKOKKkCtgUyI+PCIp4oq44oqUKVMiKy0iCn0KQkYgIj4tLT4rLi08Li4+LSI=" rel="nofollow">BQN code</a>:</p>
<pre><code>BF ‚Üê {
  S‚Üê-Àù=‚åú‚üúùï©
  (&#39;.&#39;=ùï©)/+`¬®‚åæ((‚äê+`S&#34;&gt;&lt;&#34;)‚ä∏‚äî)S&#34;+-&#34;
}
</code></pre>
<p dir="auto">The BQN code does a &#34;sum-scan incs/decs under &#39;group by instruction pointer&#39;&#34;, so the sum values get put back in their original positions automatically.</p>
<ul dir="auto">
<li>We can&#39;t quite do that in k by giving a group result to an amend, because (at least in ngn/k) amend executes elements sequentially (rather than as a group) so that it can handle repeated indices (<a href="https://ngn.codeberg.page/k/#eJxziDY00FY0NLDWMLI2UTDXtK5WiFGosFYw0qqojQUAX0UHAQ==" rel="nofollow">simple example</a>).</li>
<li>We also can&#39;t group a dict&#39;s entries, to keep info about the original keys/positions of the values.</li>
<li>But we <strong>can</strong> add the order info back in by re-keying (<code>i!&#39;</code> in the code below). We can then merge the groups and index in.</li>
</ul>
<p dir="auto">My tweak of <a href="https://matrix.to/#/!TobkTZMOkZJCvcSvwq:matrix.org/$5DiwxQlrD7Pqq8nrP6EycaEVbsGY8m3R8vqsheLomvA?via=matrix.org" rel="nofollow">Marshall&#39;s k and BQN code</a>, try it <a href="https://ngn.codeberg.page/k/#eJx1kUFOwzAQRfc9xeAFXQTHgmVoAuqil6As3HjaWI3syOM0iareHdskgECMvLFm/vvf4+2uuFLBxViKYgWhdFFme2LVhsUbCJAehkbXDZDHjkAT+AZBSS+hs9p4dKCNwjEOogxzUimHRC8Jh4W+W9Mbyzh71xEXxIQgHSaMNjUJhTVFjxa/iIOkyPNNsIu8Z0i0XyXg5GzfwUW2PUKryVMipxhnnFDBYUo+MTvYI+CI9Zwr26/xB8n1xmhzmllH6z4pc6BZcx0fppvARXOYPM6CEFbWXl++n7Cs46/16/1YspzdFkznguJfztCgi4si7/rQsSZ+gbJ+tdrugFWcV1nON3lecRZhj8CfwvkAwAOOGA==" rel="nofollow">here</a>:</p>
<pre><code>BF:{s:-/x=/:
    i:=+\s&#34;&gt;&lt;&#34;     / at which steps is the data pointer index at each address?
    e:i!&#39;s[&#34;+-&#34;]i  / these are the incs/decs while pointer was at this addr; 
                   / group value lists are each keyed by the step of exec
    e:+\&#39;e         / running value for each pointer
    e:{x,y}/e      / byte value at active pointer at each step of exec
    e@&amp;x=&#34;.&#34;}      / print value at active pointer where instruction is dot

BF &#34;&gt;--&gt;+.-&lt;..&gt;-&#34;  / 1 -2 -2
</code></pre>
<p dir="auto">At the second-last step above, we have a dict of byte values indexed by the locations in the original list (thanks to <code>i!&#39;</code>). This lets us get back the original order by just indexing in the last step. But another approach (similar to the Wordle golfs) is to skip the <code>i!&#39;</code> step, and just raze the dict then sort by the grade of the original grouped indices: <code>({x,y}/e)@&lt;,/i</code>. <a href="https://ngn.codeberg.page/k/#eJx1kU1OwzAQRvc5xcgLfpQ6FixDEqouegnKwo2njUUURx6nSVT17tjBUBAw8s7zvXkeb7b5mXIuplLkCfjSeZnuiFUFg1gCpIOx0XUD5LAn0ASuQVDSSeiN7hxa0GoKbSh9l1TKItHzwsOcXljK2au+8nyaEKTFhaO7moTCmsKQFr+Qo6SAdI2fF5BPkMCfJeBozdDDSbYDQqvJ0QJfZN5wRgX7eRkV/MEcACeso126u8WfMDt0ne6OEXcw9gMUtWLs7jyt5ovA+3WxEjrE9rPDmPHWsnb6dH3L52p+C6xvppJl7PJNoLc+9C9qbNCGpZGzg78xXfgPZVySbLbAKs6rNONFllWcBdgD8Ed/3gEKQY/l" rel="nofollow">Try here</a>.</p>
<p dir="auto">All of these approaches are a bit annoying, and they won&#39;t help if group is going away.</p>
<p dir="auto">But there is a solution. q&#39;s <a href="https://code.kx.com/q/ref/update/" rel="nofollow"><code>update ... by</code></a> can do sum-scan-under-group, as <a href="https://matrix.to/#/!cxPCiPlsXnajakSrqd:matrix.org/$ar4xhMNMZbxI2VhXio2DBSw5EiNuePiBXiUD4yw5vno?via=matrix.org" rel="nofollow">Coltim shows</a> (mild edits below):</p>
<pre><code>{select from (update sums op by sums move from t:([]x
                                                  op:(-/)x=/:&#34;+-&#34;
                                                  move:(-/)x=/:&#34;&gt;&lt;&#34;)) where x=&#34;.&#34;}
</code></pre>
<p dir="auto">It looks like KSQL will stick around, so even if group-as-primitive goes, we&#39;ll still have a way to execute Brainfuck.</p>
<h2 dir="auto"><a id="user-content-summary" aria-hidden="true" href="#summary"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Summary</h2>
<p dir="auto">Freq has replaced group. Should we be happy?</p>
<p dir="auto">Look: I think it&#39;s hard to use group for more than simple things like freq or self-group (<code>x@=x</code>). It might be more useful if prototypes worked differently, we could address dict entries, and amend did something like <code>update ... by</code>.</p>
<p dir="auto">If we had run-length-encode <code>(&amp;:)?</code> it <em>might</em> provide the speed benefits of a dedicated freq op without losing group.</p>
<p dir="auto">In group&#39;s absence, we might see more:</p>
<ul dir="auto">
<li>inline DIY implementations of group that preserve only the properties the user needs</li>
<li>inline progressive ops that keep data flat, like <a href="https://gist.github.com/chrispsn/b1020918a83a28ab8b4442d8aff8d1b4#occurrence-count-bqn-">occurrence count</a> and <a href="https://gist.github.com/chrispsn/b1020918a83a28ab8b4442d8aff8d1b4#progressive-find-bqn-">progressive searches</a> (position or existence)</li>
<li>hand-crafted operations for special cases, such as <a href="https://chat.stackexchange.com/transcript/message/58542671#58542671" rel="nofollow">Coltim&#39;s flat partitioned max-scan</a>.</li>
</ul>
<p dir="auto">To sum up: if Arthur&#39;s objective is speed and simplicity, I can understand why he&#39;d remove group from his latest k.</p>
<blockquote>
<p dir="auto">[Arthur] worked on a generalization of the Axis operator. Which is a big deal in APL. And he figured out how you can define like 20 different primitives ... in terms of the axis operator, right? So, you think that he&#39;d be invested in whatever. He&#39;ll drop an idea if it doesn&#39;t work. I mean, it&#39;s interesting how he&#39;s not attached, necessarily, to any particular thing, because later on, you know, when he went and he is doing K, he dropped the idea altogether.</p>
</blockquote>
<p dir="auto">‚Äî <a href="https://www.arraycast.com/episode-27-transcript" rel="nofollow">Joel Kaplan, Ep 27 The Array Cast</a></p>
<p dir="auto">And who knows: maybe Arthur will find another place for group-y ops in native k.</p>
<hr/>
<p dir="auto">If you liked this, <a href="https://twitter.com/kcodetweets" rel="nofollow">follow @kcodetweets on Twitter</a>.</p>
<p dir="auto">[1] Joel Kaplan, <a href="https://www.arraycast.com/episode-27-transcript" rel="nofollow">interviewed</a> on The Array Cast. I&#39;m pretty sure there is a direct quote from Arthur to the same effect on the internet somewhere - please comment if you find it!</p>
<p dir="auto">[2] As at 28 March 2023.</p>
<p dir="auto">[3] Fun fact: leaving aside the obvious &#39;equals&#39;, there was also a surprising number of identity matrices (<code>=n</code>).</p>
<p dir="auto">[4] In ngn/k, <code>0N#</code> takes all values by design so that we can use <code>{(x?y)#x}</code> to return the whole word if the letter is missing.</p>
<p dir="auto">[5] Based on <a href="https://github.com/mlochbaum/BQN/blob/master/md.bqn#L136-L138">this</a> generic BQN string amendment function. <a href="https://ngn.codeberg.page/k/#eJxLs6qOrrDOzEvOKU1JtU5MSbEuyC+O5VJQUICKWalBGSCxCquKaCg3VkcfqBos6GADFdMB6nVQU1YHStRycaVFK2Wk5uTkK1kbKkCggbWGUlJ+pZK1kkJuYp6Ckqa1iYJxLBdXTAwXl29+SmZapcKjtgkK1QqP5q+AGQk0C2Tso/krP8yd2gXEK62Almpo6EMVaD7q2KfxqHPBoRVAlZr6QKWaCo96ux917XjU1a+gAVWlD9IIUgpEIGfXAgDCiVy9" rel="nofollow">Translated to k.</a></p>
<hr/>
<h2 dir="auto"><a id="user-content-appendix-how-each-ngnk-test-case-uses-group" aria-hidden="true" href="#appendix-how-each-ngnk-test-case-uses-group"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Appendix: how each ngn/k test case uses group</h2>
<pre><code>freq
----
aoc/16/01.k
aoc/16/04.k
aoc/20/20.k
aoc/20/24.k
aoc/21/08.k
aoc/21/09.k
aoc/21/21.k
dy/a.k:p146
dy/a.k:p163
dy/a.k:p165
dy/a.k:p183
dy/a.k:p193
e/39.k
g/append-and-erase.k
g/bedevil-your-hangman-opponent.k
g/code-the-huffman.k
g/marquee-sign-letters.k
g/naive-compression.k
g/quadratic-residues-are-so-much-fun.k
g/rotation-invariant-fingerprinting.k
g/score-a-game-of-boggle.k
g/square-chunk-my-matrix.k
g/sort-the-distinct-elements-of-a-list-in-descending-order-by-frequency.k

group-index
-----------
dy/a.k:p216
e/49.k
e/60.k
e/62.k
e/98.k
g/shortest-program-to-split-a-string-at-non-digits-without-regexps.k

group-sums
----------
g/gravitational-force-between-numbers.k
g/most-contributing-rows.k

other / dunno  (i got lazy)
-------------
aoc/15/05.k
aoc/15/06.k
aoc/19/10.k
aoc/19/20.k
aoc/20/11.k
dy/a.k:p18X
dy/a.k:/skipping p135, as =: is a primitive k function
dy/a.k:p153
dy/a.k:p168
dy/a.k:p217  / unique-count (weird as why not #?)
g/classify-a-region-by-its-slope.k
g/golf-a-parentheses-matching-algorithm.k
g/implement-swap-encoding.k
g/split-a-list-at-the-second-occurrence-of-the-first-element.k
l/fmt.k:m
</code></pre>
</article>
  </div>

  </div>
</div></div>
  </body>
</html>
