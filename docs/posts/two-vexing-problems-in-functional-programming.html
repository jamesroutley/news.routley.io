<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matthewbutterick.com/chron/two-vexing-problems-in-functional-progamming.html">Original</a>
    <h1>Two Vexing Problems in Functional Programming</h1>
    
    <div id="readability-page-1" class="page"><div id="doc"><p>Since I started using Lisp languages about 10 years ago, I’ve also become a fan of func­tional program­ming. I’ve taken these habits with me when­ever I return to non-Lisp languages—e.g., Java­Script, Python, Swift. No longer will I write a loop in an imper­a­tive style when I can use <code>map</code> or <code>for­Each</code> or <code>filter</code>.</p><p>As my projects have gotten bigger, however, I’ve discov­ered two recur­ring prob­lems that resist the func­tional-program­ming idiom: what I’ll call the <i>large-object problem</i> and the <i>parent–child problem</i>. (Yes, the first one <a href="https://practicaltypography.com/hyphens-and-dashes.html">takes a hyphen</a>; the second, an en <span>dash.)</span></p><p>Inter­est­ingly, both these prob­lems arise from the mismatch between the func­tional-program­ming model of the world and the under­lying hard­ware reality of the <span>computer.</span></p><h2>Functional programming, briefly</h2><p>The core prin­ciple of <a href="https://beautifulracket.com/appendix/glossary.html#functional-programming">func­tional program­ming</a> is to compose the program from func­tions that are maxi­mally <span>self-contained:</span></p><ul><li><p>On input, all the infor­ma­tion a func­tion needs should be passed in as a list of argu­ments. Func­tions should not rely on <i>state</i>, meaning extra data main­tained outside the func­tion. For example: global <span>vari­ables.</span></p></li><li><p>On output, func­tions should not <i>mutate</i> (aka change) the argu­ments received as input, nor induce other side effects outside the func­tion. Instead, func­tions should return a value that comprises fresh data. For instance, if a func­tion needs to change the third element of a five-element list, it would return a newly constructed list. It would not change the existing list and return <span>nothing.</span></p></li></ul><p>To be clear, there’s nothing inher­ently supe­rior about func­tional program­ming. (Despite the fact that these self-contained func­tions are also known as <i>pure func­tions</i>.) It is not the way computers work at a hard­ware level. Though it is the way math works. Compared to imper­a­tive program­ming, func­tional program­ming is arguably a worse repre­sen­ta­tion of low-level computing (meaning, the part that contends with the mechan­ical char­ac­ter­is­tics of the computer), but a better repre­sen­ta­tion of high-level computing (meaning, the part that models ideas through data struc­tures and <span>algo­rithms).</span></p><p>In prac­tice, func­tional program­ming mani­fests as a styl­istic disci­pline. By making func­tions entirely self-contained as to input and output, it becomes easier to reason about the behavior of each indi­vidual func­tion. And in turn, compo­si­tions of multiple func­tions. As the program grows in complexity, this per-func­tion tidi­ness pays increasing <span>divi­dends.</span></p><h2>The large-object problem</h2><p>Func­tional-program­ming tuto­rials <a href="https://realpython.com/python-functional-programming/">often focus</a> on cute little values like numbers &amp; strings and simple lists thereof. Some­times you see an example of recur­sion using a tree-shaped data struc­ture. Seems fancy, but that’s just what happens when you allow lists to contain other lists. Other­wise, not that <span>different.</span></p><p>For simple scripts that handle simple data, that’s all there is to the func­tional-program­ming story. So it’s usually about here that these tuto­rials clap you on the back and say “best wishes on your journey”. The rest, appar­ently, is just <span>details.</span></p><p>For a while, that is <span>true.</span></p><p>But then you start trying more elab­o­rate projects. I got my first sinking feeling while working on the <a href="https://beautifulracket.com/bf/intro.html"><code>bf</code></a> language tuto­rial for my book <a href="https://beautifulracket.com">Beau­tiful Racket</a>. In <code>bf</code>, every program initial­izes a 30K byte array. All instruc­tions in <code>bf</code> operate on one byte in the <span>array.</span></p><p>Consis­tent with my loyalty to the func­tional-program­ming idiom, I designed my initial <code>bf</code> imple­men­ta­tion so that each instruc­tion would copy the existing bytes into a new array, change the byte of interest, return this new byte array, and abandon the old array (which would even­tu­ally be <span>garbage-collected).</span></p><p>Did this imple­men­ta­tion work? Yes. Did it run fast? No. It was glacial. After noodling with the code for a while, I had my <a href="https://beautifulracket.com/bf/a-functional-expander.html#can-we-make-it-faster">galaxy-brain moment</a>: maybe the inces­sant dupli­ca­tion and dele­tion of 30K data arrays had some­thing to do with it? I refac­tored so that a single byte array was created for each run of a program—<i>oh no, a global vari­able!</i>—and indi­vidual bytes were mutated within that array as needed. Result?  Faster. Mind? Blown. Surprising? No. Avoiding work has always been a great way to speed up a <span>program.</span></p><p>Alan Perlis was adapting an <a href="http://www.literaturepage.com/read/lady-windermeres-fan-50.html">Oscar Wilde epigram</a> when he said that “a Lisp programmer knows the value of every­thing, but the cost of nothing.” This was exactly my mistake. Lured by the glit­tering beauty of func­tional program­ming, I had casu­ally committed to creating and destroying 30K blocks of memory zillions of times per program. The value was that it allowed me to avoid state and muta­tion. But allo­cating and destroying memory isn’t free. So the cost turned out to be far greater than I could really <span>afford.</span></p><p>Indeed, Perlis’s quip gestures toward the ulti­mate tension within all program­ming languages: how to connect the gossamer realm of human ideas to the grubby reality of a computing machine. Arguably the whole point of program­ming languages is to insu­late us from those details, and allow us to express ourselves natu­rally. But the farther we drift from reality of the machine, the less effi­ciently we can use its <span>resources.</span></p><p>(Right—I under­stand that in ther internet age, wasting computing resources has become the primary engine of the US economy. I predict, perhaps naively, that as the rate of improve­ment of processor and storage speeds continue to <a href="https://www.technologyreview.com/2010/10/12/199966/why-cpus-arent-getting-any-faster/">flatten out</a>, there will be an increasing interest in languages that allow more gran­ular control of those <span>resources.)</span></p><p>This is the heart of the large-object problem. Big, complex programs tend to create big, complex data struc­tures to repre­sent a certain slice of reality. Func­tional program­ming, however, suggests we should create and destroy these struc­tures willy-nilly. But memory oper­a­tions are never free. There­fore, this prin­ciple of func­tional program­ming will <b>always</b> become imprac­ti­cally wasteful for suffi­ciently large memory <span>struc­tures.</span></p><p>For instance, my <a href="https://matthewbutterick.com/chron/down-to-the-metal.html">Arche­type app</a> is a GUI editor for fonts (written in Swift). Under the hood, a font is a graph of smaller elements: glyph shapes of course, but also spacing data, layout instruc­tions, and many other fiddly fields. Alto­gether, a font data struc­ture might be multiple megabytes. When I change the width of a certain glyph—a single integer—it wouldn’t make sense to throw away the whole font struc­ture and create a new <span>one.</span></p><p>Thus, my tech­nique within Arche­type has been to prefer func­tional program­ming “in the small” (i.e., when dealing with simple values or small struc­tures) and prefer muta­tion “in the large” (i.e., when dealing with bigger <span>struc­tures).</span></p><p>Another bugaboo of fitting func­tional program­ming into a GUI app is that the GUI itself is a form of mutable global state. In Arche­type, most changes to a font trigger some visible change in the GUI. Like­wise, when the user makes changes in the GUI, it trig­gers an imme­diate update to the under­lying font data. I couldn’t casu­ally throw away a font data struc­ture and regen­erate it even if I wanted to, because there’s a whole appa­ratus on screen that depends on that partic­ular struc­ture remaining alive and <span>avail­able.</span></p><p>Which brings us to the doorstep of the other vexing <span>problem—</span></p><h2>The parent–child problem</h2><p>Program­ming languages include numerous ways of creating custom data struc­tures. Within the language, these may be called <i>structs</i> or <i>objects</i> or some­thing else. But it boils down to the same idea: a collec­tion of items that we can pass around our program as a single <span>item.</span></p><p>The cost of this abstrac­tion, however, is a layer of indi­rec­tion: roughly, the language is allo­cating memory for the struc­ture (and its collec­tion of items) and returning a <i>refer­ence</i> to that struc­ture. This becomes the single item that we can use in the rest of the program. Each refer­ence points to a specific chunk of <span>memory.</span></p><p>But this struc­ture refer­ence behaves differ­ently from other values we handle in the program. As program­mers we tend to inter­nalize these shifts between <i>value seman­tics</i> and <i>refer­ence seman­tics</i> well enough that they become second <span>nature.</span></p><p>Once we have enough of these struc­tures, we often find that we want to make a struc­ture that refers to other struc­tures—the parent–child <span>rela­tion­ship.</span></p><p>(I’m using the term <i>parent–child</i> because it’s a common name for this pattern. But it unhelp­fully implies some gener­a­tive connec­tion between the two. There is none. It is just a way of hier­ar­chi­cally composing two struc­tures with a cross-refer­ence. Like the real world, a parent can refer to any number of chil­dren; unlike the real world, a child can also be referred to by any number of <span>parents.)</span></p><p>For instance, in Arche­type, each font contains an array of glyphs; in turn, each glyph contains an array of contours; in turn, each contour contains an array of points; and so on. This example is multi­lay­ered. But the problem arises even in the simplest case of one struc­ture holding a refer­ence to <span>another.</span></p><p>Let’s suppose in Arche­type that I want to define an oper­a­tion on a glyph in a func­tional-program­ming style. How would I do it? Easy—I write a func­tion that takes a glyph as input, allo­cates a new glyph with the new char­ac­ter­is­tics, and returns that as its result. The old glyph is released from <span>memory.</span></p><p>That’s fine for a glyph standing in isola­tion. But in Arche­type, every glyph is a child of a font. When we invoke this func­tional update on a child glyph, we get a new glyph in return, but the parent font <i>still holds a refer­ence to the old glyph</i>.</p><p>In essence, the parent becomes external state that relies on the child. To complete our func­tional update of the child glyph, we have to also update the refer­ence within the parent to the new glyph. That is, our delightful func­tional oper­a­tion still incurs some imper­a­tive <span>house­keeping.</span></p><p>“I know—let’s rede­fine our child oper­a­tion to take both a parent and child as input, then we can func­tion­ally modify both.” Two prob­lems with <span>this:</span></p><ol><li><p>It entan­gles an oper­a­tion on a child struc­ture with a parent struc­ture. Though it may be worth­while to tolerate this <span>untidi­ness.</span></p><p>(Indeed, the idea of passing parent and child as argu­ments is pretty much how object methods are imple­mented in many languages: nota­tion like <code>parent.foo(child)</code> is rewritten as <code>foo(parent, child)</code>, and within the body of the func­tion, any uses of <code>this</code> are rewritten as <code>parent</code>. Wait, did I just call OOP untidy? Yes. Though I can’t be the only func­tional programmer who strug­gles with OOP the way vege­tar­ians struggle with <span>bacon.)</span></p></li><li><p>The deeper lurking horror is that there may be any number of other things that hold a refer­ence to the old glyph. After a func­tional update, all of them will retain their refer­ence to the outdated glyph. That is, when we say “parent–child problem” there could be any number of parents refering to a certain child. What­ever oper­a­tion we contem­plate on the child, all the parents have to be <span>updated.</span></p></li></ol><p><b>Func­tional program­ming has no solu­tion for this.</b> We end up having to adopt one of three <span>patterns:</span></p><ol><li><p><i>Parent–child links are bidi­rec­tional.</i> That way, when a child is updated, it can trace back to all its parents and update them too. This is awful, because it creates even more entan­gle­ment between struc­tures that were intended to be <span>sepa­rate.</span></p></li><li><p><i>Chil­dren can issue noti­fi­ca­tion events.</i> This like shooting a flare gun into the program, and other struc­tures can take what­ever action is appro­priate. This is possibly better than the first option because chil­dren don’t have to know or care who their parents are. But it still requires intro­ducing a new control mech­a­nism into the program. It also pushes the program farther away from a func­tional orien­ta­tion, because each noti­fi­ca­tion event trig­gers side effects that can become hard to reason <span>about.</span></p><p>I use noti­fi­ca­tion events within Arche­type. It was gnarlier than I supposed. One ends up needing to build a new graph repre­senting the flow of noti­fi­ca­tion events that sort of but not quite matches the data graph, and keep these in sync as the data <span>changes.</span></p></li><li><p>Or we can avoid all this complexity by <i>mutating the existing child struc­ture.</i> The parents retain their existing refer­ences, but when they access the struc­ture on the other end of that refer­ence, they get the updated <span>version.</span></p></li></ol><p>In my expe­ri­ence, option (3) usually ends up being most attrac­tive because it’s simple and contained. Though as that pattern spreads, we end up with less and less func­tional <span>program­ming.</span></p><h2>How could the parent–child problem be solved?</h2><p>My best idea—which I have yet to widely adopt—is to intro­duce a proxy that I’ll call a <i>mutable medi­ator</i>. Each child has a medi­ator. Instead of parents pointing directly at a child, the parents point at the medi­ator, and the medi­ator points at the <span>child.</span></p><p>When a func­tional update on a child struc­ture occurs, the medi­ator is updated with the refer­ence to the new child. But all the parents still point at the same medi­ator. So the next time they refer­ence the child struc­ture (via the medi­ator), they get the new version. In sum, the idea is that if some muta­tion is inevitable, we can at least centralize and simplify <span>it.</span></p><p>Further­more, the medi­ator does not preclude mutable access to the child. Any parent can just reach through the medi­ator to the child and change it. The change will imme­di­ately be visible to every parent also holding a refer­ence to that <span>medi­ator.</span></p><p>Why have I not adopted this? Ideally parents shouldn’t need to care whether a child is accessed directly or through a medi­ator. It should just be an imple­men­ta­tion detail. But this means a medi­ator needs to be able to offer the same calling API as the struc­ture it medi­ates. This is easier said than done, espe­cially if we don’t want to create a whole army of medi­a­tors, one for each type of child, with a lot of boil­er­plate wrapper <span>func­tions.</span></p><p>Here’s my hunch. (Which could be terrible.) Because the mutable medi­ator is essen­tially a pointer to a pointer—aka double pointer—it belongs to the realm of lower-level memory mange­ment. Thus it is prob­ably best handled within the language compiler and exposed as a language feature, or just the default way user-defined data struc­tures are stored and <span>accessed.</span></p><p>“Dude, that’s exactly the differ­ence between how mutable and immutable struc­tures are imple­mented in certain languages.” Maybe so. But AFAIK it’s  never the case that a mutable struc­ture, once created, can also be treated as immutable. Once we choose, we’re stuck with it. The mutable-medi­ator pattern, by contrast, would allow a struc­ture to behave as <i>both</i> mutable and immutable. <span>Duality.</span></p><p>I’m not a Rust user, but roughly I under­stand that its <i>borrow checker</i> lets you “check out” a memory object using either a mutable or immutable refer­ence. If so, then my hunch isn’t completely terrible, because better program­mers have also hatched the idea of main­taining the mutable–immutable duality. No idea, however, whether the Rust borrow checker resolves the parent–child problem. I gather not. Rather, it appears to ensure memory safety (by guar­an­teeing that only one mutable refer­ence can circu­late at a time). <a href="https://nancyfriedman.typepad.com/away_with_words/2010/05/word-of-the-week-cunninghams-law.html">Cunningham’s Law</a> is excep­tion­ally strong for Rust, so I’m sure I’ll have an answer <span>shortly.</span></p><p>And coming full <span>circle—</span></p><h2>How could the large-object problem be solved?</h2><p>I have no idea. As we saw earlier, baked into func­tional program­ming is the notion that for some suffi­ciently small size, memory allo­ca­tion and destruc­tion can be treated as if it were free. In prac­tice, it’s easy to exceed that threshold faster than we <span>expect.</span></p><p>The most produc­tive angle would be to decom­pose large objects into smaller ones that are closer to that basi­cally-free threshold. So instead of a binary blob repre­senting a million <code>foo</code>s, intro­duce a <code>bar</code> struc­ture that holds a million indi­vidual <code>foo</code> struc­tures that can be updated indi­vid­u­ally. Keep subdi­viding until you get to the struc­ture size you <span>like.</span></p><p>Of course, that should sound familiar. We’ve merely trans­muted the large-object problem into the parent–child problem. So solving the parent–child problem is the <span>key.</span></p></div></div>
  </body>
</html>
