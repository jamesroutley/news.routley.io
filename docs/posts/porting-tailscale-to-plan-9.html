<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tailscale.com/blog/plan9-port">Original</a>
    <h1>Porting Tailscale to Plan 9</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>It’s been said that nothing helps land a joke like explaining it, so here we are to explain yesterday’s <a href="https://tailscale.com/blog/tailscale-enterprise-plan-9-support">Tailscale Plan 9 announcement</a>, even at the risk of killing the joke.</p>
<p>But really, if we had to kill a joke by explaining it, there’s no better type of joke to kill than a corporate April Fools’ Day post. They’re admittedly pretty terrible in general. I’m of the opinion that if you’re going to do such a joke, you better put some effort into it; <a href="https://groups.google.com/g/golang-dev/c/ZEntxvHLIt0/m/BdvtIdJNIOMJ">it</a> <a href="https://go-review.googlesource.com/c/go/+/21400">should</a> <a href="https://go-review.googlesource.com/q/quaternions">actually</a> <a href="https://github.com/bradfitz/campher">work</a>. (Otherwise it’s 100% sad instead of whatever percent sad yesterday’s post was.)</p>
<p>And to be super clear today on April 2nd because nobody believes anything on April 1st: Tailscale now actually works on Plan 9. For reals.</p>
<p>We were amused to find everybody in shock that there was <a href="https://github.com/tailscale/tailscale/pull/15491">a PR</a> attached to yesterday’s blog post so let’s dig into that PR a bit, and other work that went on.</p>
<p>First off: I don’t really know Plan 9. I know <em>of</em> Plan 9, and I know people who know Plan 9, but I’m a Plan 9 newbie and I apologize in advance if I offend any Plan 9 people with my ignorance. I tried to check my cluelessness with others to make sure it’s not <em>too</em> stupid, but there are surely some inaccuracies in these posts and bugs and shortcuts and simplifying assumptions in the code.</p>
<p>Anyway.</p>
<p>As the quip goes, “We chose to port Tailscale to Plan 9 not because it was easy, but because we thought it would be easy.” Naively it kinda seems like you’d take Tailscale’s two Go binaries and build them with <code>GOOS=plan9 GOARCH=386 go install ./cmd/tailscale{,d}</code> and call it a day. Sure, I expected some <code>syscall</code> or <code>x/net</code> or <code>x/sys/unix</code> symbols to not exists with <code>GOOS=plan9</code> and some <code>//go:build</code> tag adjustments and some special cases for <code>runtime.GOOS == &#34;plan9&#34;</code> to use different default disk paths like we previously <a href="https://github.com/tailscale/tailscale/commit/a1abd12f351cfb625c5ac9bca243d0bc46dbdbfd">did for AIX</a>, etc. So that’s <a href="https://github.com/tailscale/tailscale/pull/9082">what I tried</a> in August 2023 when a local acquaintance here in Seattle <a href="https://github.com/tailscale/tailscale/issues/5794#issuecomment-1690411613">asked me for Plan 9 support</a> and I finally caved and said okay (after initially rejecting the idea). I tweaked some build tags &amp; paths &amp; compiled it and …. <a href="https://github.com/golang/go/issues/62507">Boom</a>. The binary crashed at runtime in weird ways. Turns out the Go compiler support for Plan 9 had bitrot. Plan 9 wasn’t one of Go’s <a href="https://go.dev/wiki/PortingPolicy">first-class ports</a> and nobody had noticed the regressions. Or maybe Tailscale just pushed Go a bit harder than it had been pushed on Plan 9 before.</p>
<p>In any case, the Tailscale Plan 9 effort stalled out through all of 2024, beyond my time and/or ability to fix.</p>
<p>At the beginning of March 2025, a coworker mentioned April Fools’ Day and I suddenly remembered our Plan 9 port.</p>
<p>I reached out to <a href="https://swtch.com/~rsc/">Russ Cox</a> (a former coworker from the Go team with a lot of Plan 9 history) and told him I thought it’d be fun (&amp; funny) to finish up in time for April 1st. He replied:</p>
<p><em>“Sure I’m in.</em></p>
<p>It’s possible that Russ didn’t know what he was signing himself up for.</p>
<h2 id="sse">SSE</h2>
<p>In 1999, Intel introduced the Pentium III processor with <a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE instructions</a>. Yesterday’s blog post is dated 1999 because that’s kinda where this whole adventure begins.</p>
<p>The “special case” that Russ was referring to above is how the Go compiler <a href="https://github.com/golang/go/issues/62507#issuecomment-1710636507">tried to avoid using SSE anywhere</a> for Plan 9 targets because the Plan 9 kernel doesn’t allow SSE in “note handlers” (think: signal handlers), as it didn’t save/restore them. And because the Go compiler didn’t know which code was being used during a note handler, it conservatively tried to disable SSE everywhere. But that code was regularly breaking and there were too many <code>plan9</code> <a href="https://github.com/golang/go/blob/go1.24.0/src/cmd/compile/internal/ssa/config.go#L369-L379">special</a> <a href="https://github.com/golang/go/blob/go1.24.0/src/cmd/compile/internal/amd64/ggen.go#L67-L88">cases</a> throughout the compiler.</p>
<p>Ideally the Plan 9 kernel would just save/restore the SSE registers/context in note handlers, then Go could remove the Plan 9 special cases and treat it like every other operating system. So Russ did that.</p>
<p>For 386, the Plan 9 fix was <a href="https://github.com/rsc/plan9/commit/3715bf9b86a86ed6a3a857cabfc7dff5d70b409b">sys/src/9: allow floating point in note handlers</a> (and updating the docs in <a href="https://github.com/rsc/plan9/commit/dd95b25897369ff2575b2ad744e18954c4620464">sys/man/2: update notify</a>).</p>
<p>For amd64 (the 9k kernel), we ran into a <a href="https://9fans.topicbox.com/groups/9fans/Taf6b900592afc500/9k-amd64-kernel-and-floating-point">bunch more issues</a>. Russ fixed various things:</p>
<ul>
<li><a href="https://github.com/rsc/plan9/commit/3b001d133aa0e1661f64d2df0a683aa6d10bc955">sys/src/9k: fix bug aliasing parent and child FP state after fork</a></li>
<li><a href="https://github.com/rsc/plan9/commit/c30ca5483b9fb3a438510110580cacaddb88f8e9">sys/src/9k: allow floating point and simd in note handlers</a></li>
<li><a href="https://github.com/rsc/plan9/commit/aa00f938f6b3c6a5b4502c25605666f479a22c16">sys/src/9k: fix noted(NCONT) losing registers</a></li>
<li><a href="https://github.com/rsc/plan9/commit/04c7c708c2640586536bd31e01fbb8f05628bd71">sys/src/libmach: fix default amd64 binary mapping</a></li>
<li><a href="https://github.com/rsc/plan9/commit/aea4b577cd1b7f1402bdd880487cdf436b168b1e">sys/src/cmd/ktrace: fix for new k10 kernel trap routine</a></li>
</ul>
<p>… but by this time we’d both pretty much resigned to just focusing on making the demo work on <code>GOARCH=386</code>.</p>
<p>With the corresponding Go fix to <a href="https://go-review.googlesource.com/c/go/+/655875">stop (incorrectly) special casing Plan 9’s code generation</a>, <code>tailscaled</code> could now start up and run (for longer) without crashing. I could then start working on the bits that I could fix.</p>
<h2 id="ipc">IPC</h2>
<p>Now it was crashing due to out of memory errors instead of stack corruption. It turns out an earlier attempt at porting Tailscale to Plan 9 had a bug resulting in launching an infinite number of goroutines. Fixing that bug in our <code>safesocket</code> IPC package to just boringly using localhost TCP fixed that and now <code>tailscaled</code> would run without crashing. I thought using localhost TCP wasn’t very Plan-9-everything-is-a-file-like but Russ pointed out that some other Plan 9 services do that, so I felt a bit better, at least to unblock forward progress.</p>
<p>Later it’d be nicer to use the <a href="https://pkg.go.dev/9fans.net/go/plan9/srv9p">srv9p package</a> that Russ <a href="https://github.com/9fans/go/commit/3835d560e21f033c0c05c44e7e0f61f7ccfb9e21">ported to Go</a> and make the LocalAPI go over that. Or we should at least make localhost use authentication as we do on other platforms. I ran out of time, unfortunately. For now, don’t use this on shared Plan 9 machines.</p>
<h2 id="dev-environment">Dev Environment</h2>
<p>Up to this point, I was running Plan 9 in a VM that I’d installed from a <a href="http://9legacy.org/download.html">9legacy CD image download</a>. Because I didn’t (and still don’t) know <a href="https://research.swtch.com/acme">the Acme editor</a> too well, I was developing on my normal machines and cross-compiling the Plan 9 binaries, and then running <code>hget http://10.0.0.x:8080/tailscaled &gt; tailscaled</code> and <code>chmod +x tailscaled</code> and <code>./tailscaled</code> on Plan 9 to pull the binaries over HTTP from my LAN. Because I wasn’t even using virtio for my disk or network, this process (just the copy over the LAN!) took multiple minutes per iteration. That’s long enough for me to get distracted and forget what I was working on and context switch to Slack or email or other projects.</p>
<p>Russ, perhaps sensing my pain without me even whining about it, created <a href="https://github.com/rsc/plan9">https://github.com/rsc/plan9</a>. That’s a repo with not only the Plan 9 source code, but also pre-compiled binaries, and a <code>./boot/qemu</code> script that runs a diskless Plan 9 qemu VM that netboots with a <a href="https://en.wikipedia.org/wiki/9P_(protocol)">9P</a> root filesystem over the network to a localhost 9P server that serves out of that git repo. That meant no more copying files around… my laptop’s filesystem and my Plan 9 filesystem were shared, the way Plan 9 is meant to be used. Also, as a bonus, qemu was wired up to use virtio, making it much faster.</p>
<p>I now had a nice dev environment with iteration time in seconds instead of minutes.</p>
<h2 id="tun-mode">TUN mode</h2>
<p>While Tailscale now ran and “worked” on Plan 9, we were only running Tailscale’s “<a href="https://tailscale.com/kb/1112/userspace-networking">userspace networking</a>” mode that doesn’t involve the kernel’s networking stack and instead does all the TCP/UDP/ICMP/etc via <a href="https://github.com/google/gvisor">gVisor</a>’s <a href="https://gvisor.dev/docs/user_guide/networking/">netstack</a>. That’s better than nothing, and where our AIX port is still at, but it’s not ideal— it means the only access from a Plan 9 machine back to your tailnet is via the tailscaled HTTP/SOCKS5 proxy, and you’d have to get all your programs to then use that proxy. But few to zero Plan 9 programs recognize and support an “HTTP_PROXY” or “ALL_PROXY” environment variable to support that. Maybe there’s a Plan 9 <code>/net</code> server that uses SOCKS5, but I didn’t look too hard.</p>
<p>So, how to get the kernel involved in the network path? On most Unix platforms you use <a href="https://en.wikipedia.org/wiki/TUN/TAP">TUN</a> (or <a href="https://www.wintun.net/">wintun</a> on Windows) which give you a virtual network device on which you set addresses and assign routes, handling the incoming and outgoing packets in userspace. The <a href="https://github.com/tailscale/wireguard-go/commit/91a0587fb251a72c28724ee111fe04cf1436ca4c">Plan 9 equivalent is trivial</a>: you open <code>/net/ipifc/clone</code>, read a decimal number back of the new interface you just created, write <code>&#34;bind pkt\n&#34;</code> to the <code>ctl</code> control fd returned by opening <code>clone</code>, and then you have a new interface at e.g. <code>/net/ipifc/2/*</code> where you can then open <code>/net/ipifc/2/data</code> and read and write IP packets. (<code>/net/ipifc/0</code> and and <code>/1</code> are typically localhost and your normal physical LAN).</p>
<p>When I sent this code to <a href="https://github.com/raggi">@raggi</a> for review his reaction was basically, <em>“whoa, cute. no ioctls!”</em> But even more beautiful than no ioctls is that the reads and writes to the data file don’t even need extra framing to prepend the length. You just read and write the IP packets. It’s really the most simple “TUN” implementation we have for any platform.</p>
<h2 id="routing-tables">Routing tables</h2>
<p>I could now get packets in to exactly my interface’s address, but not out to the peers in my tailnet.</p>
<p>Now I’d need to implement Tailscale’s <code>router</code> interfaces.</p>
<p>Manipulating the routing tables on Plan 9 is just about as easy as making the interface. You open <code>/net/iproute</code>, write <code>&#34;tag tail\n&#34;</code> to it to set the “tail” routing protocol tag on all future routes you add on that fd (to make it easy to clean up after ourselves, knowing what we added), and then write little messages like <code>&#34;add 100.64.0.0 /106 100.102.103.104&#34;</code> , giving it our own IP address as the nexthop value. The only surprise was that the CIDR length there (“/106”) is 106 and not the /10 you’d expect from the <a href="https://en.wikipedia.org/wiki/Carrier-grade_NAT">CGNAT range</a>’s 10.64.0.0/10. It turns out (or seems like) Plan 9 internally is IPv6 primarily, and IPv4 is just a special case of that, so writing “100.64.0.0” is just a shorthand way of writing <a href="https://en.wikipedia.org/wiki/IPv6#IPv4-mapped_IPv6_addresses">IPv4-mapped IPv6 addresses</a> like <code>::ffff:100.64.0.0</code>.</p>
<h2 id="the-missing-three-button-mouse">The missing three button mouse</h2>
<p>At this point I took a little trip and forgot to pack my three-button USB mouse.</p>
<p>As mentioned yesterday, Plan 9 basically requires a three-button mouse to use. This makes development on a Mac laptop very difficult to the point of not being fun.</p>
<p>Russ once again took pity on me and <a href="https://9fans.topicbox.com/groups/9fans/T492596e3a67612c6">modified Plan 9 to support holding down modifier keys</a> while clicking to emulate button 2 and button 3.</p>
<h2 id="tailscale-ssh">Tailscale SSH</h2>
<p>In a moment of overconfidence (or boredom waiting for my delayed flight home), I decided to tackle Tailscale SSH support. Tailscale SSH is tailscaled’s built-in SSH server that handles authentication by using your Tailscale identity as known by your WireGuard™ keys associated with all your packets.</p>
<p>Naively, I tried just running the Plan 9 shell (<code>/bin/rc</code>) with <code>os/exec.Command</code> and wiring up stdin/stdout to it.</p>
<p>That “worked” but was kinda terrible— things didn’t echo or navigate correctly. You couldn’t interrupt processes, etc.</p>
<p>Russ explained to me how to do it properly but he probably sensed how overwhelming it seemed so he went off and added a <a href="https://github.com/9fans/go/blob/main/plan9/srv9p/example/netshell/main.go">“netshell” example</a> to the <a href="https://github.com/9fans/go">9fans/go</a> repo. That “netshell” was basically the world’s most insecure telnet server, but it was all I needed to put behind Tailscale SSH instead of running <code>/bin/rc</code> directly.</p>
<p>Now SSH worked. Conveniently, this also meant I could get text output out of Plan 9 more easily: I could <code>ssh glenda@plan9 cat /dev/snarf</code> from my laptop (the VM host) and get the copy/paste buffer from my Plan 9 guest VM. (<code>cat /dev/snarf</code> is like macOS <code>pbpaste</code>)  Of course, that’s primarily because I wasn’t thinking and hadn’t realized I had a shared filesystem and could’ve also just redirected <code>/dev/snarf</code> to a file and read that file from my laptop. Oh well.</p>
<p>But Tailscale SSH also made it easier for me to write Go tests on my laptop and then easily cross-compile and run them “remotely” over SSH.</p>
<h2 id="service-collection">Service collection</h2>
<p>One thing that tailscaled can optionally do (disabled by default), is to look what services you’re running on your machine and report them to the control plane for discoverability, so you know for example that you’re running some dev service and its process name on port 8080.</p>
<p>I was curious how to do that. Basically you just walk over <code>/proc/NNN/fd</code> (similar to Linux) and find process PIDs who have e.g. <code>/net/tcp/clone</code> open. You then look at their “QID” and line it up with <code>/net/tcp/NNN/{status,local}</code> to see if they’re listening and on what port. Overall it’s very similar to other platforms but not as beautiful as I would’ve hoped for. The fact that you have to do <code>tcpN := (qid &gt;&gt; 5) &amp; (1&lt;&lt;12 - 1)</code> to map the FD’s QID (basically its inode number?) to a TCP number and hope the kernel implementation doesn’t change is a little sad. It would be better if we had changed Plan 9 to support that operation explicitly, but we ran out of time. Oh well.</p>
<h2 id="magicdns">MagicDNS</h2>
<p>Next up was making <a href="https://tailscale.com/kb/1081/magicdns">MagicDNS</a> work. Ideally you could just refer to peers as “foo” from Plan 9 (e.g. <code>ip/ping foo</code>) or at least with its <code>foo.tailnet-name.ts.net</code> FQDN.</p>
<p>There’s a bunch of docs in <a href="https://9p.io/magic/man2html/6/ndb">ndb(6)</a> and <a href="https://9p.io/magic/man2html/8/ndb">ndb(8)</a> and <a href="https://9p.io/magic/man2html/2/dial">dial(2)</a> elsewhere about the life of a name lookup on Plan 9 and which layers do what. The Go standard library code was also easy to read to see how it all worked, at least from the client side.</p>
<p>We debated just intercepting all the <code>/net/dns</code> or <code>/net/cs</code> queries and blending in Tailscale names, but in the end <a href="https://9fans.topicbox.com/groups/9fans/T9c9d81b5801a0820">Russ again patched Plan 9</a> to permit specifying alternate DNS servers for specific DNS name suffixes, similar to what <code>systemd-networkd</code> <a href="https://tailscale.com/blog/sisyphean-dns-client-linux">permits on Linux</a>.</p>
<p>For extra fun, I kept randomly hitting a bug where DNS queries got incorrectly negatively cached even after I wrote “refresh” to <code>/net/dns</code>. Russ <a href="https://github.com/rsc/plan9/commit/8cafd26a7c4ba3e34d7eb4c76bc854c1433bf03c">fixed that too</a>.</p>
<h2 id="random-time-crashes">Random time crashes</h2>
<p>Sometimes I noticed <code>tailscaled</code> crashing from an assertion deep in gVisor’s netstack from it observing that its <a href="https://pkg.go.dev/time#hdr-Monotonic_Clocks">monotonic time</a> had gone backwards. Monotonic time should never go backwards; that’s its one job. But it turns out Go’s time implementation on Plan 9 was just using the wall time as its monotonic time, and when ntpd adjusted the clock backwards, gVisor crashed.</p>
<p>Once again Russ jumped in and <a href="https://9fans.topicbox.com/groups/9fans/T59810df4fe34a033/monotonic-time-and-randomness-on-plan-9">added monotonic time to Plan 9’s /dev/bintime</a> and <a href="https://go-review.googlesource.com/c/go/+/656755">patched Go to use it</a>.</p>
<h2 id="time-to-blog">Time to blog</h2>
<p>The final boss was writing a blog post and figuring how to get access to the blog again. (Sorry, long time no see. I’ll try to write more often!)</p>
<p>I thought it’d be fun to date the first blog post as “April 1, 1999” for nostalgic reasons. Also the world seemed happier back then.</p>
<p>I pestered some former Go colleagues who’d worked at Bell Labs for quotes too. I’m thrilled they wanted to play along. I defensively assured them that Plan 9 was not the butt of the joke and the joke was …. ourselves perhaps? (I’m not exactly sure why we did this.)</p>
<h2 id="running-on-the-web">Running on the web</h2>
<p>With a few days remaining, we decided to tackle running Plan 9 on the web. A few weeks prior I had first looked at using <a href="https://www.pcjs.org/">PCjs</a> and met up with its author for coffee &amp; donuts in my neighborhood. Without networking support, though, the demo wasn’t as interesting. Adding <a href="https://en.wikipedia.org/wiki/NE1000">ne2000</a> support might’ve been possible, but there wasn’t a lot of time. Jeff recommended looking at <a href="https://github.com/copy/v86#readme">copy/v86</a>. It runs 32-bit operating systems using WASM and includes <a href="https://github.com/copy/v86/blob/master/docs/networking.md">various forms of networking</a> support. (another reason for us to focus on <code>GOARCH=386</code> and not <code>GOARCH=amd64</code>!)</p>
<p>So far I had been doing development using the <a href="https://github.com/rsc/plan9">qemu-based shared filesystem environment</a> that Russ had prepared. But now we needed a disk image to boot from on the web.</p>
<p>While Russ worked on dusting off &amp; modernizing an old compressed root filesystem kernel he’d worked on 25 years ago, I worked at exploring networking options.</p>
<p>One of the networking options passes Layer 2 ethernet frames over websockets to a relay. I <a href="https://github.com/tailscale/tailscale/commit/2a12e634bfe7fc4f89fa8f37b1bd0ff9866e776b">added wsproxy protocol support</a> to our network simulation environment used for integration tests. That environment fakes everything with the help of gVisor’s <a href="https://gvisor.dev/docs/architecture_guide/networking/">netstack</a>: ARP, DHCP, DNS w/ fake IPs, various flavors of NAT, optionally bridging controlplane &amp; DERP servers to their real connections behind the scenes, etc. That ended up working, but it wasn’t ideal. The VM did DHCP before it brought up <code>rio</code> (the Plan 9 GUI) and DHCP took several round trips over the faked ethernet-over-websockets. If the relay was far away, the GUI would start slowly.</p>
<p>So then I instead implemented a “<a href="https://github.com/MercuryWorkshop/wisp-protocol">WISP</a>” server instead. This made the GUI start up without any network roundtrips at all: the DHCP all happened faked inside the browser.</p>
<p>I was in the middle of productionizing the WISP proxy when I ran out of time and decided to just launch with the <a href="http://copy.sh/v86">copy.sh/v86</a> default network relay settings.</p>
<p>I built Tailscale, added it to <code>/386/bin</code>, prepared a disk image (<code>cd /sys/lib/dist/mini; mk</code> in <a href="https://github.com/rsc/plan9">rsc/plan9</a> after adding <code>tailscale</code> &amp; <code>tailscaled</code> to the image’s <code>proto</code> template file), and then it spit out a 16MB disk image with all of Plan 9 and Tailscale, which itself is a 23MB binary after decompression. That’s why you’ll notice the “gunzip…” step when you boot the image, now included as an example image at <a href="https://copy.sh/v86/?profile=9legacy">https://copy.sh/v86/?profile=9legacy</a></p>
<p>Maybe I’ll finish up the WISP backend later.</p>
<h2 id="future-directions">Future directions</h2>
<p>There are two main forks of Plan 9: a very minimal one (<a href="http://9legacy.org/">9legacy</a>) and a more modified one (<a href="https://9front.org/">9front</a>). So far Tailscale has only been tested on 9legacy. Some of the patches that Russ wrote for 9legacy might still need to be ported to 9front.</p>
<p>We should also verify that 64-bit <code>GOARCH=amd64</code> support works. We’d mostly ignored that during development.</p>
<p>I also didn’t implement exit node support or Go’s <code>net/netns</code> package support. Doing that might require rethinking how Tailscale presents itself on Plan 9, probably <a href="https://9fans.topicbox.com/groups/9fans/T4cecdedbabdedc00/tailscale-on-plan-9">as its own <code>/net</code></a>.</p>
<p>But largely I’ll be relying on the Plan 9 community to take this over if they’d like to.</p>
<h2 id="what-was-the-point">What was the point?</h2>
<p>I’m trying to remember now why we did all this. Mostly it was because <a href="https://github.com/9nut">Skip</a> asked. Partly it was fun &amp; educational, working in an alternate reality and learning new things. And working with a totally busted <code>tailscaled</code> crashing and deadlocking in weird ways always seems to lead to finding existing problems that affect all other platforms or assumptions that aren’t true in general.</p>
<p>And Go’s support for Plan 9 got better:</p>
<ul>
<li><a href="https://go-review.googlesource.com/c/go/+/655877">cmd/compile: use FMA on plan9, and drop UseFMA</a></li>
<li><a href="https://go-review.googlesource.com/c/go/+/655879">runtime: remove nextSampleNoFP from plan9</a></li>
<li><a href="https://go-review.googlesource.com/c/go/+/655875">cmd/compile, runtime: remove plan9 special case avoiding SSE</a></li>
<li><a href="https://go-review.googlesource.com/c/go/+/654055">net: fix parsing of interfaces on plan9 without associated devices</a></li>
<li><a href="https://go-review.googlesource.com/c/go/+/654315">os: guarantee min buffer size for ReadFile reads on /proc-like files</a></li>
<li><a href="https://go-review.googlesource.com/c/go/+/656395">net: unblock UDP Reads upon Close on plan9, add test</a></li>
<li><a href="https://go-review.googlesource.com/c/go/+/656755">runtime: fix plan9 monotonic time, crypto randomness</a></li>
</ul>
<p>In particular, removing the <code>plan9</code> special cases from the Go compiler makes the Go compiler cleaner and easier to hack on, so that’s nice.</p>
<h2 id="final-surprise">Final surprise</h2>
<p>When we launched the blog post on Tuesday, we discovered that the v86 author had launched his own April Fools’ Day joke— everything on v86, including the VGA text output from emulated VMs, was all in fake Dutch or something.</p>
<p>I panicked a little, as it made our demo more confusing (“Plun 9”, “goonzeep…” instead of “gunzip…”, etc), and I’d just run out of time trying to finish hosting our own HTML page with v86 Javascript &amp; WASM embedded, but fortunately the author pointed out that the page took a <code>&amp;nojoke</code> query argument.</p>
<h2 id="thanks">Thanks</h2>
<p>Thanks to everybody who made this possible:</p>
<ul>
<li><a href="https://github.com/9nut">Skip Tavakkolian</a> for the nerdsnipe</li>
<li><a href="https://github.com/jeffpar">Jeff Parsons</a> for talking me through <a href="https://www.pcjs.org/">PCjs</a> and web-based 32-bit emulation</li>
<li><a href="https://github.com/copy/">Fabian</a> for <a href="https://github.com/copy/v86">v86</a>. I have so many new non-April Fools ideas to do with v86 now. Stay tuned.</li>
<li><a href="https://github.com/0intro/">David du Colombier</a> for all the plan9 Go maintenance &amp; reviews over the years and hosting the <a href="https://9p.io/plan9">9p.io</a> docs I relied on constantly</li>
<li><a href="https://en.wikipedia.org/wiki/Rob_Pike">Rob Pike</a> and <a href="https://en.wikipedia.org/wiki/Peter_J._Weinberger">Peter J. Weinberger</a> and <a href="https://bsky.app/profile/catzkorn.dev">Charlotte Brandhorst-Satzkorn</a> for playing along with the quotes</li>
<li><a href="https://swtch.com/~rsc/">Russ Cox</a> for doing all the hard work fixing up stuff in Plan 9 and Go’s Plan 9 support and telling me how to use Plan 9; I stalled out doing this joke for over a year. Russ made this possible.</li>
</ul>
<h2 id="questions">Questions?</h2>
<p>If you miss our <a href="https://ftp.plan9.ts.net/webinar">Plan 9 Google Meet GChat Hangout</a>, we’ll also be answering any questions we see pop up on Hacker News, <a href="https://www.reddit.com/r/Tailscale/comments/1jprsqo/porting_tailscale_to_plan_9/">Reddit</a>, or Bluesky.</p>
<h2 id="in-conclusion">In conclusion</h2>
<p>Maybe I’ll skip April Fools’ Day next year, like I skipped <a href="https://adventofcode.com/">Advent of Code</a> this past year.</p>
<p>And if you actually wanted to pay us dumptruck loads of money for Plan 9 support, please don’t— dumptrucks will dirty the cash. Please wire it instead.</p></div></div></div>
  </body>
</html>
