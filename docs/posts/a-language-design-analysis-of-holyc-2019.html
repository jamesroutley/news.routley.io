<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://harrison.totty.dev/p/a-lang-design-analysis-of-holyc">Original</a>
    <h1>A Language Design Analysis of HolyC (2019)</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
      <header>
        
        <p>Mar 15 2019</p>
        <hr/>
      </header>
  <p>I was recently introduced to the story of <a href="https://en.wikipedia.org/wiki/Terry_A._Davis">Terry A. Davis</a>, a schizophrenic programmer who independently designed the free operating system <a href="https://en.wikipedia.org/wiki/TempleOS">TempleOS</a>. This article will not delve into the story of Terry or TempleOS, but instead the programming language Terry wrote specifically for developing the operating system - a language he dubbed “<em>HolyC</em>”.</p>

<p><em>HolyC</em>, as the name would imply, is a <em>C-like</em> programming language with a number of key differences and improvements. Like <em>C</em>, it’s whitespace independent and compiles to assembly. However, as Terry describes in the OS’s own documentation for the built-in assembly language:</p>

<blockquote>
  <p>TempleOS uses nonstandard opcodes. Asm is kind-of a bonus and I made changes to make the assembler simpler. For opcodes which can have different numbers of args, I separated them out – Like <code>IMUL</code> and <code>IMUL2</code>. The assembler will not report certain invalid forms. Get an Intel datasheet and learn which forms are valid.</p>
</blockquote>

<p>This article won’t cover the assembly layer of TempleOS, but the above is interesting nonetheless.</p>



<p><em>HolyC</em> allows the following numeric types: <code>U0</code>, <code>I8</code>, <code>U8</code>, <code>I16</code>, <code>U16</code>, <code>I32</code>, <code>U32</code>, <code>I64</code>, <code>U64</code>, and <code>F64</code>. As you probably would guess, a <code>U</code> vs <code>I</code> prefix denotes a signed/unsigned integer/float and the numerical value represents the number of bits associated with the type. The two most interesting types are <code>U0</code> and <code>F64</code>.</p>

<p><code>U0</code> is essentially <code>void</code> but with <em>zero</em> size. In regular <em>C</em>, <code>void</code> is actually considered a <a href="https://en.wikipedia.org/wiki/Unit_type">Unit Type</a> and thus when computing <code>sizeof(void)</code> in GCC, you will find that it resolves to <code>1</code>. <code>U0</code> is actually closer to a <a href="https://en.wikipedia.org/wiki/Bottom_type">Bottom Type</a>, like <code>!</code> in Rust.</p>

<p><code>F64</code> is interesting because it is the only <em>float</em> available in <em>HolyC</em>. I can’t find a specified reason in the source code, but I presume it is a combination of “if you’re going to do floating-point operations, wouldn’t you pretty much always want maximum precision by definition?” and maybe the fact that</p>

<blockquote>
  <p>All values are extended to 64-bit when accessed. Intermediate calculations are done with 64-bit values.</p>
</blockquote>

<p>The example given is:</p>

<div><div><pre><code><span>U0</span> <span>Main</span><span>()</span>
<span>{</span>
    <span>I16</span> <span>i1</span><span>;</span>
    <span>I32</span> <span>j1</span><span>;</span>
    <span>j1</span><span>=</span><span>i1</span><span>=</span><span>0x12345678</span><span>;</span>  <span>// i1 is 0x5678 but j1 is 0x12345678</span>
    
    <span>I64</span> <span>i2</span><span>=</span><span>0x8000000000000000</span><span>;</span>
    <span>Print</span><span>(</span><span>&#34;%X</span><span>\n</span><span>&#34;</span><span>,</span> <span>i2</span><span>&gt;&gt;</span><span>1</span><span>);</span>  <span>// Prints 0xC0000000000000000</span>
    
    <span>U64</span> <span>u3</span><span>=</span><span>0x8000000000000000</span><span>;</span>
    <span>Print</span><span>(</span><span>&#34;%X</span><span>\n</span><span>&#34;</span><span>,</span> <span>u3</span><span>&gt;&gt;</span><span>1</span><span>);</span>  <span>// Prints 0x40000000000000000</span>
    
    <span>I32</span> <span>i4</span><span>=</span><span>0x80000000</span><span>;</span>     <span>// This is loaded into a 64-bit register variable.</span>
    <span>Print</span><span>(</span><span>&#34;%X</span><span>\n</span><span>&#34;</span><span>,</span> <span>i4</span><span>&gt;&gt;</span><span>1</span><span>);</span>  <span>// Prints 0x40000000</span>
    
    <span>I32</span> <span>i5</span><span>=-</span><span>0x80000000</span><span>;</span>
    <span>Print</span><span>(</span><span>&#34;%X</span><span>\n</span><span>&#34;</span><span>,</span> <span>i5</span><span>&gt;&gt;</span><span>1</span><span>);</span>  <span>// Prints 0xFFFFFFFFC0000000</span>
<span>}</span>
</code></pre></div></div>



<p>Functions are where you start to see some of the more drastic differences. For starters, functions that are invoked without arguments (or without overriding any default arguments) may be syntactically shortened to just the function name followed by a semicolon.</p>

<div><div><pre><code><span>// The following are equivalent.</span>

<span>x</span> <span>=</span> <span>Foo</span><span>();</span>  <span>// C</span>
<span>y</span> <span>=</span> <span>Foo</span><span>;</span>    <span>// HolyC</span>
</code></pre></div></div>

<p>Speaking of default arguments, in <em>HolyC</em> it’s a-okay to have default args at any point in the function definition like so:</p>

<div><div><pre><code><span>// ----- Function Definition -----</span>
<span>I32</span> <span>Foo</span><span>(</span><span>I32</span> <span>i</span><span>=</span><span>8</span><span>,</span> <span>I32</span> <span>j</span><span>)</span>
<span>{</span>
    <span>return</span> <span>(</span><span>i</span> <span>+</span> <span>j</span><span>);</span>
<span>}</span>

<span>// ----- Invocation -----</span>
<span>I32</span> <span>x</span><span>;</span>
<span>x</span> <span>=</span> <span>Foo</span><span>(,</span><span>6</span><span>);</span>
</code></pre></div></div>

<p>Note the prepended comma in the function invocation arguments. At first this seems pretty useless (why wouldn’t you just re-order your args?) but it <em>does</em> allow you to write functions with some logical order:</p>

<div><div><pre><code><span>// Copies the files in &#34;source&#34; path to the &#34;destination&#34; path</span>
<span>U0</span> <span>CopyTo</span><span>(</span><span>char</span> <span>*</span><span>source</span><span>=</span><span>&#34;T:/Doc/Files&#34;</span><span>,</span> <span>char</span> <span>*</span><span>dest</span><span>)</span>
<span>{</span>
    <span>// ...</span>
<span>}</span>

<span>CopyTo</span><span>(,</span><span>&#34;T:/Doc/Files2&#34;</span><span>);</span>
</code></pre></div></div>

<p>Similarly to Python and other modern languages, functions can have variable argument counts, here specified with <code>(...)</code> in the function definition. The function body may then access its arguments by utilizing the built-in <code>argc</code> and <code>argv</code> variables:</p>

<div><div><pre><code><span>I64</span> <span>Sum</span><span>(...)</span>
<span>{</span>
    <span>I64</span> <span>i</span><span>,</span><span>tot</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>argc</span><span>;</span> <span>i</span><span>++</span><span>)</span>
        <span>tot</span> <span>+=</span> <span>argv</span><span>[</span><span>i</span><span>];</span>
    <span>return</span> <span>tot</span><span>;</span>
<span>}</span>

<span>I64</span> <span>x</span> <span>=</span> <span>Sum</span><span>(</span><span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>);</span> <span>// x = 12</span>
</code></pre></div></div>

<p>Note that <code>for</code> loops don’t require curly braces if they only perform one operation. This is true in both C and HolyC.</p>

<p>Finally, <em>HolyC</em> does <em>not</em> have a required <code>Main()</code> function. Expressions outside of functions are simply evaluated from top to bottom in source. This also allows the programming language to act like a shell, and in-fact <em>is</em> the shell of TempleOS.</p>



<p>Terry explained multiple times how switch statements are the most powerful constructs in <em>HolyC</em>. In the language, switch statements always utilize jump tables in assembly (and thus the documentation mentions to not use them in cases with large/sparse value ranges). The ones in <em>HolyC</em> offer quite a range of convenience improvements over their <em>C</em> counterparts. For starters, <em>HolyC</em> offers experienced programmers an <em>unchecked variant</em> of the switch expression, denoted via <code>switch [foo]</code> instead of <code>switch (foo)</code>. In addition, the language also has implicit case values and even case ranges!</p>

<div><div><pre><code><span>I64</span> <span>i</span><span>;</span>
<span>switch</span> <span>(</span><span>i</span><span>)</span> <span>{</span>
    <span>case:</span> <span>&#34;zero</span><span>\n</span><span>&#34;</span><span>;</span> <span>break</span><span>;</span>         <span>// Implicit case statements start at 0</span>
    <span>case:</span> <span>&#34;one</span><span>\n</span><span>&#34;</span><span>;</span> <span>break</span><span>;</span>          <span>// ... and increment by 1 each time.</span>
    <span>case:</span> <span>&#34;two</span><span>\n</span><span>&#34;</span><span>;</span> <span>break</span><span>;</span>
    <span>case</span> <span>3</span><span>:</span> <span>&#34;three</span><span>\n</span><span>&#34;</span><span>;</span> <span>break</span><span>;</span>      <span>// Explicit cases work as you would expect.</span>
    <span>case</span> <span>4</span><span>...</span><span>8</span><span>:</span> <span>&#34;others</span><span>\n</span><span>&#34;</span><span>;</span> <span>break</span><span>;</span> <span>// Cases 4 through 8 will print &#34;others\n&#34;.</span>
<span>}</span>
</code></pre></div></div>

<p>Note that in the above example I technically skipped explaining another quirk with <em>HolyC</em>, which is that constant (literal) string expressions all by themselves will automatically be sent to <code>Print</code>. This lets you do neat things like:</p>

<div><div><pre><code><span>U0</span> <span>PrintMessage</span><span>(</span><span>char</span> <span>*</span><span>first</span><span>,</span> <span>char</span> <span>*</span><span>last</span><span>)</span>
<span>{</span>
    <span>&#34;Hello person!</span><span>\n</span><span>&#34;</span><span>;</span>
    <span>&#34;Your name is %s %s.</span><span>\n</span><span>&#34;</span><span>,</span> <span>first</span><span>,</span> <span>last</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Back to switch statements, they may actually be nested into what are known as “sub_switch” statements via the <code>start</code> and <code>end</code> keywords. Below is the example code included in TempleOS for this functionality:</p>

<div><div><pre><code><span>U0</span> <span>SubSwitch</span> <span>()</span>
<span>{</span>
    <span>I64</span> <span>i</span><span>;</span>
    <span>for</span> <span>(</span><span>i</span><span>=</span><span>0</span><span>;</span><span>i</span><span>&lt;</span><span>10</span><span>;</span><span>i</span><span>++</span><span>)</span>
        <span>switch</span><span>(</span><span>i</span><span>)</span> <span>{</span>
            <span>case</span> <span>0</span><span>:</span> <span>&#34;Zero &#34;</span><span>;</span>     <span>break</span><span>;</span>
            <span>case</span> <span>2</span><span>:</span> <span>&#34;Two &#34;</span><span>;</span>      <span>break</span><span>;</span>
            <span>case</span> <span>4</span><span>:</span> <span>&#34;Four &#34;</span><span>;</span>     <span>break</span><span>;</span>
            <span>start:</span>
                <span>&#34;[&#34;</span><span>;</span>
                <span>case</span> <span>1</span><span>:</span> <span>&#34;One&#34;</span><span>;</span>   <span>break</span><span>;</span>
                <span>case</span> <span>3</span><span>:</span> <span>&#34;Three&#34;</span><span>;</span> <span>break</span><span>;</span>
                <span>case</span> <span>5</span><span>:</span> <span>&#34;Five&#34;</span><span>;</span>  <span>break</span><span>;</span>
            <span>end:</span>
                <span>&#34;] &#34;</span><span>;</span>
                <span>break</span><span>;</span>
        <span>}</span>
    <span>&#39;\n&#39;</span><span>;</span>
<span>}</span>

<span>SubSwitch</span><span>;</span>
</code></pre></div></div>

<p>The above code will print <code>Zero [One] Two [Three] Four [Five]</code> to the command line.</p>



<p>This is my personal favorite feature. This expression allows you to write code or execute programs whose output is embedded into the rest of your source code at compile time. This let you do things like:</p>

<div><div><pre><code><span>#include #exe { </span><span>/* code to find location of library */</span><span> }
</span></code></pre></div></div>

<p>This is essentially <em>HolyC</em>’s solution to <em>macros</em>.</p>



<ul>
  <li>In <em>HolyC</em>, you can <code>Free()</code> a null pointer (this is also true in C).</li>
  <li>The stack does not grow because <em>HolyC</em> does not utilize virtual memory.</li>
  <li>There is no <code>continue</code> keyword in the language. Instead, Terry urges programmers to use <code>goto</code>’s instead.</li>
  <li>There is no <code>#define</code> capability. Terry’s explanation for this is that he’s just “not a fan”.</li>
  <li>The <code>typedef</code> keyword is replaced with <code>class</code>.</li>
  <li><code>#include</code> does not support <code>&lt;&gt;</code> for importing standard libraries. All <code>#include</code> statements must use <code>&#34;&#34;</code>.</li>
  <li>There is no type checking what-so-ever.</li>
  <li><code>try {}</code>, <code>catch {}</code>, and <code>throw</code> are supported, however <code>throw</code> only returns up to an 8-byte <code>char</code> argument, which may be accessed in a <code>catch {}</code> as <code>Fs-&gt;except_ch</code>.</li>
</ul>

    </article>
  </div></div>
  </body>
</html>
