<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.appsignal.com/2022/02/08/functional-programming-in-elixir-with-witchcraft.html">Original</a>
    <h1>Functional Programming in Elixir with Witchcraft</h1>
    
    <div id="readability-page-1" class="page"><p>While Elixir is a functional programming language, it is different from most of the other popular functional languages like Haskell, Scala, OCaml, and F#.</p><p>Elixir pragmatically handles concurrent systems with high fault tolerance. In other words, Elixir is an FP language because this naturally fits it, and not for its own sake. So, porting idioms blindly from Haskell to Elixir can lead to undesired results.</p><p>At the same time, Elixir users should more frequently visit the whole wonderful universe of functors, monads, and other curiosities. Good libraries have been introduced for operating with algebraic structures.</p><p>In this article, I want to introduce you to a library called Witchcraft and show how you can use it to emulate Haskell-style programming in Elixir.</p><div><h2>String Validation and Processing with Witchcraft</h2><p>We will go through a credit card validation exercise.</p><p>Given a string that should contain a credit card number, we need to make sure that:</p><ul><li>it contains 16 digits</li><li>it has at least two different digits</li><li>the final digit is even</li><li>the sum of the digits is more than 16</li></ul><p>We will do this exercise with <code>Either</code>, one of the predefined data types that the Witchcraft complex offers.</p><div><h3>Set Up Witchcraft</h3><p>First, add the necessary libraries to your <code>mix.exs</code> file and run <code>mix deps.get</code>.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>  </span><span>defp</span><span> </span><span>deps</span><span> </span><span>do</span></span>
<span><span>    [</span></span>
<span><span>      {</span><span>:</span><span>witchcraft</span><span>, </span><span>&#34;~&gt; 1.0&#34;</span><span>},</span></span>
<span><span>      {</span><span>:</span><span>algae</span><span>, </span><span>&#34;~&gt; 1.2&#34;</span><span>},</span></span>
<span><span>    ]</span></span>
<span><span>  </span><span>end</span></span></code></pre></div></div><div><h3>Parsing the String</h3><p>First, make a new module and import Witchcraft at the top of the module.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>defmodule</span><span> </span><span>Card</span><span> </span><span>do</span></span>
<span><span>  </span><span>use</span><span> </span><span>Witchcraft</span></span>
<span> </span>
<span><span>end</span></span></code></pre></div><p>Then, write a function to parse the string into a list of digits and remove all non-digit items.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>def</span><span> </span><span>get_digits</span><span>(cardnumber) </span><span>do</span></span>
<span><span>  cardnumber</span></span>
<span><span>  |&gt; </span><span>String</span><span>.</span><span>split</span><span>(</span><span>&#34;&#34;</span><span>, </span><span>trim:</span><span> </span><span>true</span><span>)</span></span>
<span><span>  |&gt; </span><span>Enum</span><span>.</span><span>map</span><span>(</span><span>fn</span><span> x -&gt; </span><span>Integer</span><span>.</span><span>parse</span><span>(x) </span><span>end</span><span>)</span></span>
<span><span>  |&gt; </span><span>Enum</span><span>.</span><span>filter</span><span>(</span><span>fn</span><span> x -&gt; x </span><span>!=</span><span> </span><span>:</span><span>error</span><span> </span><span>end</span><span>)</span></span>
<span><span>  |&gt; </span><span>Enum</span><span>.</span><span>map</span><span>(</span><span>fn</span><span> {int, </span><span>_rest</span><span>} -&gt; int </span><span>end</span></span>
<span><span>end</span></span></code></pre></div><p>In the code above, we split the card number into characters and map <code>Integer.parse</code> (safe integer conversion) over them. <code>Integer.parse</code> returns either <code>{int, rest_of_binary}</code> or <code>:error</code>. We filter out the errors and unpack the tuples with the last two functions.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="bash" data-theme="default"><span><span>iex(1)&gt; Card.get_digits(</span><span>&#34;3456-3233-5689-4445&#34;</span><span>)</span></span>
<span><span>[3, 4, 5, 6, 3, 2, 3, 3, 5, 6, 8, 9, 4, 4, 4, 5]</span></span></code></pre></div><p>After that, we can write our first validation function with <code>Either</code>.</p></div><div><h3>Quick Intro to the <code>Either</code> Data Type</h3><p><code>Either</code> is a type that contains one of two different options: <code>Left</code> or <code>Right</code>. Each of these wraps another type. <code>Left</code> stores failures, and <code>Right</code> stores successes.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="haskell" data-theme="default"><span><span>-- Either data type as defined in Haskell</span></span>
<span><span>data</span><span> </span><span>Either</span><span> </span><span>a</span><span> </span><span>b</span><span> = </span><span>Left</span><span> </span><span>a</span><span> | </span><span>Right</span><span> </span><span>b</span></span></code></pre></div><p>Usually, we return it from computations that can fail when you want to know what kind of error made them fail.</p><p>When working with Witchcraft, you can use the predefined <a href="https://github.com/witchcrafters/algae/blob/main/lib/algae/either.ex">Algae.Either</a> to create new instances of the <code>Either</code> data type. We can do that by using one of two structs: <code>%Algae.Either.Left{left: value}</code> or <code>%Algae.Either.Right{right: value}</code>.</p><p>Most likely, you&#39;ve already run into it somewhere. In other languages, it’s sometimes called <code>Result</code> (in Rust, for example). It’s also structurally identical to the result tuple frequently used in Elixir.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>{</span><span>:</span><span>ok</span><span>, result} </span><span>-&gt;</span><span> {</span><span>:</span><span>right</span><span>, result} </span><span>-&gt;</span><span> %</span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Right</span><span>{</span><span>right:</span><span> result}</span></span>
<span><span>{</span><span>:</span><span>error</span><span>, reason} </span><span>-&gt;</span><span> {</span><span>:</span><span>left</span><span>, reason} </span><span>-&gt;</span><span> %</span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Left</span><span>{</span><span>left:</span><span> reason}</span></span></code></pre></div><p>In fact, we could technically use the result tuple for our exercise. I&#39;ve constructed it this way on purpose, so you can explore the machinery of Witchcraft while staying on more or less stable ground.</p></div><div><h3>Example of <code>Either</code></h3><p>Let’s look at an example of <code>Either</code>.</p><p>We have parsed a list of digits from the given string, and now we want to know whether there are 16 items in the list. If we took the easy way out, we could write something like this:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>def</span><span> </span><span>sixteen_digits</span><span>(cardnumber), </span><span>do:</span><span> </span><span>Enum</span><span>.</span><span>count</span><span>(cardnumber) </span><span>==</span><span> </span><span>16</span></span></code></pre></div><p>Unfortunately, the function above is not very composable: the return value loses the card number, so we won’t be able to pipe the result to do further computations on it.</p><p>Therefore, we want the result to be a more complicated structure such as <code>Either</code>.</p><ul><li>If there are 16 digits in the list, we want to return an <code>Either.Right</code> with the list.</li><li>If there is a different number of digits, we want to return an <code>Either.Left</code> with <code>:not_16_digits</code>.</li></ul><p>And here’s the function to do that:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>def</span><span> </span><span>sixteen_digits</span><span>(cardnumber) </span><span>do</span></span>
<span><span>  </span><span>case</span><span> </span><span>Enum</span><span>.</span><span>count</span><span>(cardnumber) </span><span>do</span></span>
<span><span>    </span><span>16</span><span> -&gt; %</span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Right</span><span>{</span><span>right:</span><span> cardnumber}</span></span>
<span><span>    </span><span>_</span><span> -&gt; %</span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Left</span><span>{</span><span>left:</span><span> </span><span>:</span><span>not_16_digits</span><span>}</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span></code></pre></div><p>Let’s try it out in <code>iex</code>:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="bash" data-theme="default"><span><span>iex(1)&gt; right_number = Card.get_digits(</span><span>&#34;3456-3233---5689-4445&#34;</span><span>)</span></span>
<span><span>[3, 4, 5, 6, 3, 2, 3, 3, 5, 6, 8, 9, 4, 4, 4, 5]</span></span>
<span><span>iex(2)&gt; Card.sixteen_digits(right_number)</span></span>
<span><span>%Algae.Either.Right{right: [3, 4, 5, 6, 3, 2, 3, 3, 5, 6, 8, 9, 4, 4, 4, 5]}</span></span>
<span><span>iex(3)&gt; wrong_number = Card.get_digits(</span><span>&#34;444&#34;</span><span>)</span></span>
<span><span>[4, 4, 4]</span></span>
<span><span>iex(4)&gt; Card.sixteen_digits(wrong_number)</span></span>
<span><span>%Algae.Either.Left{left: :not_16_digits}</span></span></code></pre></div></div><div><h3>Other Validation Functions</h3><p>In the same way, we can make a validation rule for each requirement.</p><p>I suggest you try doing it yourself first since they will be similar to the first example.</p><p>To remind you, here are the conditions we need to check:</p><ul><li>The number has at least two different digits.</li><li>The final digit of the number is even.</li><li>The sum of the digits is more than 16.</li></ul><p>Each of the conditions should have its own function. Each of the functions should take a list of numbers and return:</p><ul><li><code>%Algae.Either.Right{}</code> with the list inside if the condition is fulfilled</li><li><code>%Algae.Either.Left{}</code> with the reason inside if the condition is not fulfilled</li></ul><p>If you are ready to proceed, here are the functions that I will use further on in this article:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>def</span><span> </span><span>two_unique_digits</span><span>(cardnumber) </span><span>do</span></span>
<span><span>  unique </span><span>=</span></span>
<span><span>    cardnumber</span></span>
<span><span>    |&gt; </span><span>Enum</span><span>.</span><span>uniq</span><span>()</span></span>
<span><span>    |&gt; </span><span>Enum</span><span>.</span><span>count</span><span>()</span></span>
<span> </span>
<span><span>  </span><span>case</span><span> unique </span><span>&gt;=</span><span> </span><span>2</span><span> </span><span>do</span></span>
<span><span>    </span><span>true</span><span> -&gt; %</span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Right</span><span>{</span><span>right:</span><span> cardnumber}</span></span>
<span><span>    </span><span>_</span><span> -&gt; %</span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Left</span><span>{</span><span>left:</span><span> </span><span>:</span><span>not_2_unique_digits</span><span>}</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span>
<span> </span>
<span><span>def</span><span> </span><span>final_even</span><span>(cardnumber) </span><span>do</span></span>
<span><span>  last_digit </span><span>=</span><span> </span><span>Enum</span><span>.</span><span>at</span><span>(cardnumber, </span><span>-</span><span>1</span><span>)</span></span>
<span> </span>
<span><span>  </span><span>case</span><span> </span><span>rem</span><span>(last_digit, </span><span>2</span><span>) </span><span>do</span></span>
<span><span>    </span><span>0</span><span> -&gt; %</span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Right</span><span>{</span><span>right:</span><span> cardnumber}</span></span>
<span><span>    </span><span>_</span><span> -&gt; %</span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Left</span><span>{</span><span>left:</span><span> </span><span>:</span><span>last_not_even</span><span>}</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span>
<span> </span>
<span><span>def</span><span> </span><span>sum_greater_than_16</span><span>(cardnumber) </span><span>do</span></span>
<span><span>  </span><span>case</span><span> </span><span>Enum</span><span>.</span><span>sum</span><span>(cardnumber) </span><span>&gt;=</span><span> </span><span>16</span><span> </span><span>do</span></span>
<span><span>    </span><span>true</span><span> -&gt; %</span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Right</span><span>{</span><span>right:</span><span> cardnumber}</span></span>
<span><span>    </span><span>_</span><span> -&gt; %</span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Left</span><span>{</span><span>left:</span><span> </span><span>:</span><span>sum_smallr_than_16</span><span>}</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span></code></pre></div></div><div><h3>Connecting the Functions</h3><p>But how can we join these functions together? Each of them takes a list but returns a struct. We can’t pipe them into each other because their types don’t match up.</p><p>To chain them, we need something that knows how to unwrap <code>Algae.Either</code> and apply other functions to what&#39;s inside, and Witchcraft has just the thing we need.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>definst </span><span>Witchcraft</span><span>.</span><span>Chain</span><span>, </span><span>for:</span><span> </span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Left</span><span> </span><span>do</span></span>
<span><span>  </span><span>def</span><span> </span><span>chain</span><span>(left, </span><span>_</span><span>), </span><span>do:</span><span> left</span></span>
<span><span>end</span></span>
<span> </span>
<span><span>definst </span><span>Witchcraft</span><span>.</span><span>Chain</span><span>, </span><span>for:</span><span> </span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Right</span><span> </span><span>do</span></span>
<span><span>  </span><span>def</span><span> </span><span>chain</span><span>(%</span><span>Right</span><span>{</span><span>right:</span><span> data}, link), </span><span>do:</span><span> </span><span>link</span><span>.(data)</span></span>
<span><span>end</span></span></code></pre></div><p><em>From <a href="https://github.com/witchcrafters/algae/blob/main/lib/algae/either.ex">Algae.Either</a>.</em></p><p><a href="https://hexdocs.pm/witchcraft/Witchcraft.Chain.html#chain/1"><code>chain</code></a>, which can also be written in Witchcraft as <code>&gt;&gt;&gt;</code> (or <code>bind</code>), is the famous bind operator from Haskell: <code>&gt;&gt;=</code>. Let’s understand what it does.</p><p>As defined for <code>Either</code>, it will take a value — either <code>Left </code> or <code>Right</code> — and a function from a regular value to <code>Either</code>.</p><p>In the case of <code>Left</code>, it will ignore the function and pass the value further. In the case of <code>Right</code>, it will apply the function to the value inside <code>Right</code>.</p><p>In our code, we can conveniently use <code>&gt;&gt;&gt;</code> so that it looks pipe-y.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>def</span><span> </span><span>parse_number</span><span>(cardnumber) </span><span>do</span></span>
<span><span>  cardnumber</span></span>
<span><span>  |&gt; </span><span>get_digits</span><span>()</span></span>
<span><span>  |&gt; </span><span>sixteen_digits</span><span>()</span></span>
<span><span>    &gt;&gt;&gt; </span><span>fn</span><span> x -&gt; </span><span>two_unique_digits</span><span>(x) </span><span>end</span></span>
<span><span>    &gt;&gt;&gt; </span><span>fn</span><span> x -&gt; </span><span>final_even</span><span>(x) </span><span>end</span></span>
<span><span>    &gt;&gt;&gt; </span><span>fn</span><span> x -&gt; </span><span>sum_greater_than_16</span><span>(x) </span><span>end</span></span>
<span><span>end</span></span></code></pre></div><p>Unfortunately, the capture syntax (<code>&amp;two_unique_digits/1</code>) doesn’t work here. (The macro will expand the code to nested captures, which Elixir doesn’t allow you to do via <code>&amp;</code>.)</p><p>Combining the <code>Either</code> data type and its defined chain function lets us build up a chain of functions. Even though they take a list and return an <code>Either</code>, the functions can be chained to arrive at a result. The whole chain will return the list in case of success and the first encountered error in the case of failure.</p><p>We can try it out in <code>iex</code>.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="bash" data-theme="default"><span><span>iex(1)&gt; Card.parse_number(</span><span>&#34;4444-444-222-1&#34;</span><span>)</span></span>
<span><span>%Algae.Either.Left{left: :not_16_digits}</span></span>
<span><span>iex(2)&gt; Card.parse_number(</span><span>&#34;4444-4444-4444-4444&#34;</span><span>)</span></span>
<span><span>%Algae.Either.Left{left: :not_2_unique_digits}</span></span>
<span><span>iex(3)&gt; Card.parse_number(</span><span>&#34;4444-4444-4444-4435&#34;</span><span>)</span></span>
<span><span>%Algae.Either.Left{left: :last_not_even}</span></span>
<span><span>iex(4)&gt; Card.parse_number(</span><span>&#34;1020-0000-0000-0000&#34;</span><span>)</span></span>
<span><span>%Algae.Either.Left{left: :sum_smaller_than_16}</span></span>
<span><span>iex(5)&gt; Card.parse_number(</span><span>&#34;4545-3232-5423-6788&#34;</span><span>)</span></span>
<span><span>%Algae.Either.Right{right: [4, 5, 4, 5, 3, 2, 3, 2, 5, 4, 2, 3, 6, 7, 8, 8]}</span></span></code></pre></div><p>From this point onward, you can claim to have written monadic code in Elixir.</p></div><div><h3>Tinkering With the Codebase</h3><p>Here are some minor changes we can make to the code so it looks nicer. These are not essential to your understanding but can give you more practice with the code example in question.</p><p>First off, Witchcraft provides a very handy <code>~&gt;</code> operator that does the same as piping into <code>Enum.map</code>.</p><p>We can use it in our <code>get_digits</code> function.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>def</span><span> </span><span>get_digits</span><span>(cardnumber) </span><span>do</span></span>
<span><span>  cardnumber</span></span>
<span><span>  |&gt; </span><span>String</span><span>.</span><span>split</span><span>(</span><span>&#34;&#34;</span><span>, </span><span>trim:</span><span> </span><span>true</span><span>)</span></span>
<span><span>  ~&gt; </span><span>fn</span><span> x -&gt; </span><span>Integer</span><span>.</span><span>parse</span><span>(x) </span><span>end</span></span>
<span><span>  |&gt; </span><span>Enum</span><span>.</span><span>filter</span><span>(</span><span>fn</span><span> x -&gt; x </span><span>!=</span><span> </span><span>:</span><span>error</span><span> </span><span>end</span><span>)</span></span>
<span><span>  ~&gt; </span><span>fn</span><span> {int, </span><span>_rest</span><span>} -&gt; int </span><span>end</span></span>
<span><span>end</span></span></code></pre></div><p>After that, empty lists will cause some run-time errors with the <code>Enum.at</code> that we used, and having empty inputs probably isn’t part of the plan, so we can reject empty strings right at the start.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>def</span><span> </span><span>get_digits</span><span>(cardnumber) </span><span>do</span></span>
<span><span>  digits </span><span>=</span></span>
<span><span>    cardnumber</span></span>
<span><span>    |&gt; </span><span>String</span><span>.</span><span>split</span><span>(</span><span>&#34;&#34;</span><span>, </span><span>trim:</span><span> </span><span>true</span><span>)</span></span>
<span><span>    ~&gt; </span><span>fn</span><span> x -&gt; </span><span>Integer</span><span>.</span><span>parse</span><span>(x) </span><span>end</span></span>
<span><span>    |&gt; </span><span>Enum</span><span>.</span><span>filter</span><span>(</span><span>fn</span><span> x -&gt; x </span><span>!=</span><span> </span><span>:</span><span>error</span><span> </span><span>end</span><span>)</span></span>
<span><span>    ~&gt; </span><span>fn</span><span> {int, </span><span>_rest</span><span>} -&gt; int </span><span>end</span></span>
<span> </span>
<span><span>  </span><span>case</span><span> digits </span><span>do</span></span>
<span><span>    [] -&gt; %</span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Left</span><span>{</span><span>left:</span><span> </span><span>:</span><span>empty_input</span><span>}</span></span>
<span><span>    </span><span>_</span><span> -&gt; %</span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Right</span><span>{</span><span>right:</span><span> digits}</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span></code></pre></div><p>And finally, there is a macro that you can use in <code>parse_number</code> to simulate a more Haskell-like way of writing a sequence of actions in a certain context. This style is frequently called the <a href="https://hexdocs.pm/witchcraft/Witchcraft.Monad.html#monad/2">do-notation</a>.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>def</span><span> </span><span>parse_number</span><span>(cardnumber) </span><span>do</span></span>
<span> </span>
<span><span>  monad %</span><span>Algae</span><span>.</span><span>Either</span><span>.</span><span>Right</span><span>{} </span><span>do</span></span>
<span><span>    digits &lt;- </span><span>get_digits</span><span>(cardnumber)</span></span>
<span><span>    a &lt;- </span><span>sixteen_digits</span><span>(digits)</span></span>
<span><span>    b &lt;- </span><span>two_unique_digits</span><span>(a)</span></span>
<span><span>    c &lt;- </span><span>final_even</span><span>(b)</span></span>
<span><span>    d &lt;- </span><span>sum_greater_than_16</span><span>(c)</span></span>
<span><span>    </span><span>return</span><span>(d)</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span></code></pre></div><p>In the code sample above, we provide the kind of container that we will operate with — <code>%Algae.Either.Right{}</code>. Then we can do actions inside it, and the <a href="https://hexdocs.pm/witchcraft/Witchcraft.Monad.html#monad/2"><code>monad</code></a> macro will automatically chain our functions. In the end, it will return whatever we put in the return statement (but wrapped in the container).</p><p>It&#39;s very powerful, but also very confusing at first. If it is hard to understand what’s happening here, I encourage you to try out <code>monad []</code> first since it is very similar to <a href="https://elixir-lang.org/getting-started/comprehensions.html">list comprehensions</a>. In fact, if you think of this macro as generalized list comprehensions, you won&#39;t err too much.</p></div><div><h3><code>Either</code> and the Result Tuple in Elixir</h3><p><code>Either</code> is very similar to the result tuple in Elixir, and I’ve done that on purpose to keep you on somewhat familiar ground.</p><p>In fact, you can implement the same thing without using Witchcraft.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>defmodule</span><span> </span><span>Card2</span><span> </span><span>do</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>get_digits</span><span>(cardnumber) </span><span>do</span></span>
<span><span>    digits </span><span>=</span></span>
<span><span>      cardnumber</span></span>
<span><span>      |&gt; </span><span>String</span><span>.</span><span>split</span><span>(</span><span>&#34;&#34;</span><span>, </span><span>trim:</span><span> </span><span>true</span><span>)</span></span>
<span><span>      |&gt; </span><span>Enum</span><span>.</span><span>map</span><span>(</span><span>fn</span><span> x -&gt; </span><span>Integer</span><span>.</span><span>parse</span><span>(x) </span><span>end</span><span>)</span></span>
<span><span>      |&gt; </span><span>Enum</span><span>.</span><span>filter</span><span>(</span><span>fn</span><span> x -&gt; x </span><span>!=</span><span> </span><span>:</span><span>error</span><span> </span><span>end</span><span>)</span></span>
<span><span>      |&gt; </span><span>Enum</span><span>.</span><span>map</span><span>(</span><span>fn</span><span> {int, </span><span>_rest</span><span>} -&gt; int </span><span>end</span><span>)</span></span>
<span><span>  </span><span>end</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>sixteen_digits</span><span>(cardnumber) </span><span>do</span></span>
<span><span>    </span><span>case</span><span> </span><span>Enum</span><span>.</span><span>count</span><span>(cardnumber) </span><span>do</span></span>
<span><span>      </span><span>16</span><span> -&gt; {</span><span>:</span><span>ok</span><span>, cardnumber}</span></span>
<span><span>      </span><span>_</span><span> -&gt; {</span><span>:</span><span>error</span><span>, </span><span>:</span><span>not_16_digits</span><span>}</span></span>
<span><span>    </span><span>end</span></span>
<span><span>  </span><span>end</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>two_unique_digits</span><span>(cardnumber) </span><span>do</span></span>
<span><span>    unique </span><span>=</span></span>
<span><span>      cardnumber</span></span>
<span><span>      |&gt; </span><span>Enum</span><span>.</span><span>uniq</span><span>()</span></span>
<span><span>      |&gt; </span><span>Enum</span><span>.</span><span>count</span><span>()</span></span>
<span> </span>
<span><span>    </span><span>case</span><span> unique </span><span>&gt;=</span><span> </span><span>2</span><span> </span><span>do</span></span>
<span><span>      </span><span>true</span><span> -&gt; {</span><span>:</span><span>ok</span><span>, cardnumber}</span></span>
<span><span>      </span><span>_</span><span> -&gt; {</span><span>:</span><span>error</span><span>, </span><span>:</span><span>not_2_unique_digits</span><span>}</span></span>
<span><span>    </span><span>end</span></span>
<span><span>  </span><span>end</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>final_even</span><span>(cardnumber) </span><span>do</span></span>
<span><span>    last_digit </span><span>=</span><span> </span><span>Enum</span><span>.</span><span>at</span><span>(cardnumber, </span><span>-</span><span>1</span><span>)</span></span>
<span> </span>
<span><span>    </span><span>case</span><span> </span><span>rem</span><span>(last_digit, </span><span>2</span><span>) </span><span>do</span></span>
<span><span>      </span><span>0</span><span> -&gt; {</span><span>:</span><span>ok</span><span>, cardnumber}</span></span>
<span><span>      </span><span>_</span><span> -&gt; {</span><span>:</span><span>error</span><span>, </span><span>:</span><span>last_not_even</span><span>}</span></span>
<span><span>    </span><span>end</span></span>
<span><span>  </span><span>end</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>sum_greater_than_16</span><span>(cardnumber) </span><span>do</span></span>
<span><span>    </span><span>case</span><span> </span><span>Enum</span><span>.</span><span>sum</span><span>(cardnumber) </span><span>&gt;=</span><span> </span><span>16</span><span> </span><span>do</span></span>
<span><span>      </span><span>true</span><span> -&gt; {</span><span>:</span><span>ok</span><span>, cardnumber}</span></span>
<span><span>      </span><span>_</span><span> -&gt; {</span><span>:</span><span>error</span><span>, </span><span>:</span><span>sum_smaller_than_16</span><span>}</span></span>
<span><span>    </span><span>end</span></span>
<span><span>  </span><span>end</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>parse_number</span><span>(cardnumber) </span><span>do</span></span>
<span><span>    digits </span><span>=</span><span> </span><span>get_digits</span><span>(cardnumber)</span></span>
<span> </span>
<span><span>    </span><span>sixteen_digits</span><span>(digits)</span></span>
<span><span>    |&gt; </span><span>chain</span><span>(</span><span>&amp;</span><span>two_unique_digits</span><span>/</span><span>1</span><span>)</span></span>
<span><span>    |&gt; </span><span>chain</span><span>(</span><span>&amp;</span><span>final_even</span><span>/</span><span>1</span><span>)</span></span>
<span><span>    |&gt; </span><span>chain</span><span>(</span><span>&amp;</span><span>sum_greater_than_16</span><span>/</span><span>1</span><span>)</span></span>
<span><span>  </span><span>end</span></span>
<span> </span>
<span><span>  </span><span>defp</span><span> </span><span>chain</span><span>({</span><span>:</span><span>ok</span><span>, result}, f), </span><span>do:</span><span> </span><span>f</span><span>.(result)</span></span>
<span><span>  </span><span>defp</span><span> </span><span>chain</span><span>({</span><span>:</span><span>error</span><span>, </span><span>_error</span><span>} </span><span>=</span><span> result, _f), </span><span>do:</span><span> result</span></span>
<span><span>end</span></span></code></pre></div><p>Here, we could also have used a <a href="https://www.openmymind.net/Elixirs-With-Statement/"><code>with</code> statement</a>, which handles tagged result tuples in a monadic way.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>def</span><span> </span><span>parse_number_with</span><span>(cardnumber) </span><span>do</span></span>
<span><span>    </span><span>with</span><span> digits &lt;- </span><span>get_digits</span><span>(cardnumber),</span></span>
<span><span>         {</span><span>:</span><span>ok</span><span>, a} &lt;- </span><span>sixteen_digits</span><span>(digits),</span></span>
<span><span>         {</span><span>:</span><span>ok</span><span>, b} &lt;- </span><span>two_unique_digits</span><span>(a),</span></span>
<span><span>         {</span><span>:</span><span>ok</span><span>, c} &lt;- </span><span>final_even</span><span>(b),</span></span>
<span><span>         {</span><span>:</span><span>ok</span><span>, d} &lt;- </span><span>sum_greater_than_16</span><span>(c)</span></span>
<span><span>  </span><span>do</span></span>
<span><span>    {</span><span>:</span><span>ok</span><span>, d}</span></span>
<span><span>  </span><span>else</span></span>
<span><span>      err -&gt; err</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span></code></pre></div><p>But the benefit of Witchcraft is that you get a specific data type with a specific chain function and a large set of types, type classes, and functions, all of which work well with each other to support a particular programming style.</p></div></div><div><h2>Summing Up and Further Witchcraft Resources</h2><p>In this post, we looked at how you can write Haskell &#39;fan fiction&#39; in Elixir using Witchcraft with a credit card validation code example.</p><p>Hopefully, you&#39;ve seen that Witchcraft contains a ton of stuff, enough to satisfy your curiosity about this kind of programming and more.</p><p>But, while it is a good tool for teaching FP concepts, there aren&#39;t a lot of tutorials available. Brooklyn Zelenka did a <a href="https://www.youtube.com/watch?v=psdG5iV57q0">talk about Witchcraft</a>, but there isn&#39;t much else out there. If you would like to learn more about this programming style <em>right now</em>, your best bet is to start exploring a language like Haskell, F#, or OCaml (the latter two also have pipes).</p><p>Alternatively, you can explore typed BEAM by trying languages like <a href="https://gleam.run/">Gleam</a> or <a href="https://www.hamler-lang.org/">Hamler</a>.</p><p>Happy coding!</p><p><strong>P.S. If you&#39;d like to read Elixir Alchemy posts as soon as they get off the press, <a href="https://blog.appsignal.com/elixir-alchemy">subscribe to our Elixir Alchemy newsletter and never miss a single post</a>!</strong></p></div></div>
  </body>
</html>
