<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/">Original</a>
    <h1>Building an IoT Notification Device from Scratch</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><img alt="The SplashFlag Notification Device" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/splashflag.png"/></p>
<p>After setting up dozens of Internet of Things (IoT) smart home devices, I started to wonder: how hard could it be to build one from scratch?</p>
<p>I needed a project to learn on, so I decided to create something fun: a device that alerts my neighbors when my kids go swimming, extending the invitation for their kids to come swim too.</p>
<p>What follows are the lessons I learned from building such an IoT device from scratch.</p>

<p>Here&#39;s a short video demoing the device and its features:</p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" frameborder="0" src="https://www.youtube-nocookie.com/embed/m3u1LLpupH0"></iframe></p>
<p><a href="https://youtu.be/m3u1LLpupH0">Watch this video on YouTube</a></p>
<p><a href="#how-to-build-your-own-splashflag">The instructions and code for building your own Splashflag</a> can be found at the bottom of this post, otherwise keep reading to learn about my journey in building the device.</p>

<p>How many times can you play Marco Polo in a pool with an adult and two kids? I know that my kids far prefer the company of their friends who have a lot more energy.</p>
<p>Originally our idea was to put up a special &#34;we&#39;re swimming&#34; flag outside in our front yard when our kids were in the pool, alerting the neighbors that they are welcome to come over and swim as well. The flag would be an open invitation, without the overhead of planning, group texts, and phone calls.</p>
<p>I quickly realized this idea wouldn&#39;t work because:
1) The flag wouldn&#39;t be easily visible from every neighbor&#39;s house
2) By the time people saw the flag and came over, we might already be wrapping up our swimming session</p>
<p>What I needed to solve this social problem was technology (or rather, I needed an excuse for a new technology hobby project), which is how the idea for SplashFlag was born.</p>

<p>This wasn&#39;t my first time building an embedded device, but it was the first time I tried to follow at least some semblance of best practices: <code>main</code> loops less than a thousand lines long, no hardcoded passwords, etc...</p>
<p>If this was going to be a true learning project, I wanted to be more organized: use classes, design hardware and software that could handle errors gracefully, and create a way for users to connect the device to their WiFi without me ever needing to know their credentials. </p>
<p>While I wouldn&#39;t consider this code to be perfect (or even necessarily &#34;good&#34;), it&#39;s a huge improvement over hardware projects I&#39;ve built in the past, so I consider it a success.</p>
<p>Below is an overview of the major features I built into the device.</p>
<h2 id="servo-flag">Servo Flag</h2>
<p><img alt="The servo and plastic flag" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/servo_flag.png"/></p>
<p>This is how the idea started: instead of the physical flag in my front yard, it would be a small plastic flag sitting on the counter in a friend&#39;s home.</p>
<p>Whenever the device receives a message, the flag goes up until the message expires. Besides being a fun feature, it works well in households where the kids are still too young to read the details of the message - regardless of what the screen says, if the flag is raised, they know the Wagners are swimming and they&#39;re welcome to come swim too.</p>
<h2 id="clearreset-button">Clear/Reset Button</h2>
<p><img alt="Reset Button" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/back_button.jpeg"/></p>
<p>This button wasn&#39;t originally planned as a feature. The first time I got the servo flag working and realized it might be raised for an hour, I knew that as a parent I&#39;d want a way to clear the notification without my kid seeing it. So the hidden button on the back of the device became a necessary enhancement. Push it, and the message clears while the flag goes down.</p>
<p>It also serves double duty for triggering a factory reset.</p>
<h2 id="lcd">LCD</h2>
<p>In addition to the servo flag, the LCD displays messages about swimming. The default message indicates how long we plan to swim, but the web app (see below) lets me write any message, so something like &#34;feel free to stay for pizza&#34; is a potential customization.</p>
<p>The LCD also displays system messages, like when the device is having trouble connecting to WiFi or when the messaging server is down. </p>
<p>The code for the LCD was fun to write: since the screen can only fit two rows of 16 characters, I had to write a function that could <a href="https://github.com/bertwagner/splashflag/blob/main/hardware/src/Lcd.cpp#L70-L84">split any length message so it fit these constraints and scroll across multiple screens</a>.</p>
<p>This is also where I first encountered overflow errors and needed to add max-length validations:
<img alt="Memory overflows displaying garbled characters on the LCD screen" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/IMG_8377.png"/></p>
<p>The screen works well and serves its purpose, but along with the I2C adapter, it is easily the biggest component in the device. Next time, I plan to look for slimmer options, because the device size (especially the front frame with the LCD) could have been considerably smaller if I had chosen a different board.</p>
<h2 id="captive-portal">Captive Portal</h2>
<p><img alt="Screenshot of the Captive Portal" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/captive_portal.png"/></p>
<p>Before this project, I never knew the magic that allowed login pages to pop up on your device when connecting to a guest wifi network.</p>
<p>It turns out, it&#39;s DNS! </p>
<p>This guest wifi login experience is what I wanted to build into my device. After all, I wanted my neighbors to be able to set this up in their house, all on their own, without me needing to know or hardcode any WiFi passwords.</p>
<p>The short explanation of how this works is that when your phone connects to a new WiFi network, the phone will try to visit <a href="https://github.com/bertwagner/splashflag/blob/main/hardware/src/CaptivePortal.cpp#L113-L121">certain well-known URLs</a>. If you own the WiFi network, you can configure DNS to look for those standard URLs and intercept them, serving your own login page.</p>
<p>Fortunately there are some good libraries for setting up a DNS server on ESP32s and intercepting traffic, then <a href="https://github.com/bertwagner/splashflag/blob/main/hardware/src/CaptivePortal.cpp">serving your own captive portal where people can input their WiFi credentials</a>.</p>
<h2 id="over-the-air-ota-updates">Over the Air (OTA) Updates</h2>
<p>Another feature I wanted to include was the ability to update the firmware remotely. Debugging and flashing new firmware while the device was sitting on my desk was easy, but I know my code isn&#39;t perfect so I wanted a way to update these devices remotely in the future.</p>
<p>Fortunately the ESP32-S3 Nano device I was using allows for OTA firmware updates. I set up the library for this and have it <a href="https://github.com/bertwagner/splashflag/blob/main/hardware/src/SplashFlagController.cpp#L436-L539">check the GitHub releases page for SplashFlag every day to see if a new version is available</a>. If a new version exists, it will download the update and install it.</p>
<p>Here&#39;s hoping I don&#39;t accidentally brick anyones SplashFlag device.</p>
<h2 id="web-app">Web App</h2>
<p><img alt="SplashFlag web app" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/webapp.png"/></p>
<p>I wanted a simple interface for sending messages to all devices, so I created a <a href="https://github.com/bertwagner/splashflag/blob/main/backend/mosquitto/http/index.html">single page web application</a>. It defaults to the most common message I would send, with input parameters to adjust the duration of how long the message is displayed on the devices.</p>
<p>The website runs on my home server and I expose it through <a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/">CloudFlare Tunnels</a> so I can easily access it from my phone (or anywhere). I also added HTTP Basic Authentication to the website - not the most robust option, but good enough for this project. In the future, if I upgrade anything, it would be the authentication system. Basic Authentication is secure enough, but it doesn&#39;t play nicely with 1Password or Safari on iOS, which causes some minor annoyances.</p>
<p>The web app sends a message to the MQTT broker (see below) over WebSockets, which then publishes it to all devices. Because this is just a simple API call, I could easily program a smart button to trigger this in the future, allowing my kids to send the notification themselves when we head out to the pool.</p>
<h2 id="mqtt-messaging">MQTT Messaging</h2>
<p>I didn&#39;t want my devices long-polling a web server to check the status of new swim messages. Instead I decided to use an MQTT broker running in my home lab to transmit messages to the SplashFlag devices running the MQTT client code.</p>
<p>I am using <a href="https://mosquitto.org">mosquitto</a> as the MQTT broker. The MQTT broker service runs on my home server and is exposed via WebSockets to the web app. All of the devices subscribe to the broker service, so whenever a message is published, every device receives the message and updates its screen and raises its flag.</p>
<h2 id="debugging-hardware-flag">Debugging Hardware Flag</h2>
<p>Since I may need to continue development (e.g. fixing bugs) once these devices are in the wild, I wanted a way to send messages to only my debugging device. Fortunately, ESP32-S3 Nanos have a unique <a href="https://github.com/bertwagner/splashflag/blob/main/hardware/src/SplashFlagController.cpp#L642-L654">mac address identifier</a>, so I wrote code to check whether a device is a development unit under my control. If it is, it subscribes to an additional MQTT topic that only receives debugging messages. Debugging messages are set through the web app via a toggle:
<img alt="Debug mode toggle" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/Screenshot%202025-09-11%20at%2021.52.42.png"/></p>
<p><img alt="Debug mode message displayed on the device" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/debug_mode_lcd.png"/></p>
<p>The fact that the ESP32-S3 Nanos have their own unique identifier means I don&#39;t need different code for production devices versus debugging devices (or at least in that section of the code). While I could have handled this in other ways, I&#39;m satisfied with how this solution works.</p>
<h2 id="3d-printed-case">3D Printed Case</h2>
<p>While I learned a ton designing this case, the smartest thing I did was test print each CAD feature as I finished designing it. This meant printing something like the servo holder only took 15 minutes, and then I could dry fit the parts together to ensure they actually fit. This saved a lot of time on iterating fit and printing, as well as minimizing plastic waste.
<img alt="SplashFlag device" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/splashflag.png"/></p>
<p>My CAD design experience before SplashFlag was limited to simple enclosures. SplashFlag taught me how to make more complex designs, including screw mounts and snap-fit parts.</p>
<p>The case design is simple. The front panel holds the LCD. The remaining components (ESP32-S3 Nano, servo, USB-C power plug, tactile reset button) mount to the back panel.
<img alt="CAD design of the front panel" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/front_panel_front_render.PNG"/></p>
<p><img alt="CAD design of the front panel from the back" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/front_panel_back_render.PNG"/></p>
<p>As mentioned earlier, the LCD with I2C breakout took up a lot of room, leading to the wide frame around the LCD. </p>
<p>The ESP32-S3 Nano, servo, and USB-C plug attach to the case with small metric screws. The LCD panel bolts onto the front plate with an embedded nut.
<img alt="Backpanel render" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/back_panel.png"/></p>
<p>While I was designing this, it took many iterations to figure out how to get all the parts to fit together while minimizing space. I also had to consider the limitations of 3D printers and assembly so the final case would be possible to print and assemble successfully.</p>
<p>One oversight I made was forgetting to leave space for the bolts that would hold the two halves of the case together. Originally I was going to make the case snap-fit together without any hardware, so I didn&#39;t include bolts in my design, but I decided to add bolts once I realized how relatively heavy all the components would be and all the wiring that would need to stay confined to the inside of the device. If I had modeled the case <em>properly</em> in Fusion360 with components, I could have easily moved things around after I realized I needed case bolts. But since I didn&#39;t realize I could do that until I had spent hours designing the case the wrong way, I decided to be OK settling with the imperfections.
<img alt="Case bolts as an afterthought" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/back_panel_back_render.PNG"/></p>
<p>My favorite part of the case is the snap-fit housing for the tactile button. It allows for a small breadboard switch to become a neatly integrated button. Definitely a design I will use again in future projects:
<img alt="Exploded view of button" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/button_exploded.PNG"/></p>
<p><img alt="the final back button" src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/back_button.jpeg"/></p>
<p>As a final embellishment, I added the text SplashFlag to the top of the device. I only have a single-color 3D printer, so this meant printing the outline of the letters in blue, then the letters themselves (slightly smaller) in white. Final assembly involved super gluing them together on the top of the case.</p>
<h2 id="what-isnt-included">What Isn&#39;t Included</h2>
<p>As much as I packed this device with features, I didn&#39;t include everything.</p>
<p>If I wanted to devote more time to this project, I&#39;d probably first enable TLS for all HTTP connections. The idea of writing code to automatically update the CA certs on the device (and maintaining TLS certs on the server app) over time didn&#39;t seem worth it for a hobby project.</p>
<p>Also, secrets like the WiFi password and MQTT credentials are not encrypted at rest. They are stored in the ESP32-S3 Nano&#39;s non-volatile memory, allowing anyone with physical access to the device to potentially retrieve them without too much effort. The ESP32-S3 Nano does have eFuses which can help with storing cryptographic keys (which could then be used to encrypt the credentials), but adding that capability didn&#39;t make the cut due to time constraints.</p>

<p>Who knows if I will use it, but this build taught me I am capable of making steady, regular progress towards long-term projects.</p>
<p>I am probably not going to large scale manufacture these for the neighborhood, but I gained confidence in building a complete hardware device on my own that works well. When the next product idea strikes, I&#39;ll already have a lot of the knowledge (and code!) required for building it.</p>
<p>Is it perfect? No. Is it better than some IoT devices I&#39;ve purchased, with easier updates and repairs? Definitely.</p>

<h3 id="parts-list">Parts List</h3>
<ul>
<li>ESP32-S3 Nano</li>
<li>1602 LCD Display with I2C adapter for easier wiring</li>
<li>Feetech FS90 9g Servo</li>
<li>6x6x5mm tactile push button switch</li>
<li>.1 uF decoupling capacitor</li>
<li>220ohm pull-down resistor </li>
<li>USB-C Power Adapter and cable</li>
<li>Variety of M1.6-M2.5 screws and bolts to mount all the components</li>
</ul>
<h3 id="code-and-files">Code and Files</h3>
<p>Complete code for the ESP32-S3 Nano and web app, as well as the 3D printed case are available at the <a href="https://github.com/bertwagner/splashflag">SplashFlag GitHub Repo</a>.</p>
<p>The code for the ESP32-S3 Nano is configured with <a href="https://platformio.org">PlatformIO</a>. This configuration handles downloading and installing all C++ dependencies. If you use PlatformIO in Visual Studio Code like I do, you can open the repo&#39;s <code>hardware</code> folder, build the code, and upload it to the board.</p>
<p>The <a href="https://github.com/bertwagner/splashflag/tree/main/backend">web app runs</a> in a Docker container. You will need to generate an auth password for the mosquitto service as well as configure a Cloudflare Tunnel if you are going to be self hosting. Details for doing this are in <a href="https://github.com/bertwagner/splashflag/tree/main/backend">SplashFlag backend README</a>.</p>
<h3 id="case-assembly-and-wiring">Case Assembly and Wiring</h3>
<p>3D printing the files shouldn&#39;t require any supports, with the exception of the cutout for the USB-C cable. I used .10mm layer heights with PLA+ filaments. The snap-fit tactile button is the component with the tightest dimensional tolerance - I recommend slicing up the back panel and printing only this button enclosure at first to ensure your printer is calibrated correctly. If that piece prints correctly, the rest of the case should print without any issues.</p>
<p>I don&#39;t have a nice wiring schematic, but the photo below with details should help.</p>
<p>After confirming everything worked on a breadboard, I mounted the components to the case. I then soldered the component wires together, tested again, and once I was confident things still worked, encased all connections in hot glue:
<img src="https://bertwagner.com/posts/splashflag-building-an-iot-swimming-notification-device-from-scratch/B320640B-EFE2-4864-9E7C-DC8E973BA870_1_105_c.jpeg"/></p>
<p>Note: the red wire hanging off to the left in the above photo was an extra wire I later clipped off - I miscounted while creating my wires.</p>
<p>Maybe my next project will involve designing a custom PCB board to make the wiring easier.</p>
</div></div>
  </body>
</html>
