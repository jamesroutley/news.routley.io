<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rambo.codes/posts/2022-10-25-sirispy-ios-bug-allowed-apps-to-eavesdrop">Original</a>
    <h1>SiriSpy â€“ iOS bug allowed apps to eavesdrop on your conversations with Siri</h1>
    
    <div id="readability-page-1" class="page"><article><div><p><strong>TL;DR:</strong> Any app with access to Bluetooth could record your conversations with Siri and audio from the iOS keyboard dictation feature when using AirPods or Beats headsets. This would happen without the app requesting microphone access permission and without the app leaving any trace that it was listening to the microphone.</p><h2>Access to Sensitive Data on Apple&#39;s Platforms</h2><p>One of the biggest myths when it comes to security and privacy on mobile devices is the old saying that Facebook is using your device&#39;s microphone to listen to everything you say, in order to sell more targeted ads. There&#39;s never been any evidence of that, and iPhones have very strong security measures in place to prevent such a thing.</p><p><em>This section might be too basic for folks who are already familiar with how this stuff works under the hood, feel free to skip it.</em></p><p>The system that protects you from unfettered access to your sensitive data on Apple&#39;s operating systems is TCC (Transparency, Consent, and Control), which is directly responsible for most of the permission prompts you see when an app asks to access your location, calendar, microphone, camera, etc.</p><p>Access to system resources is mediated with the use of daemons, which are system processes that run in the background, many times with elevated privileges when compared to regular apps. Apps can then request information from those daemons, effectively opening a little door from their sandbox to the outside world.</p><p>Those doors are usually very tightly controlled on Apple&#39;s platforms with the use of code signing and entitlements. Out of the box, modern Apple devices will only run apps with a code signature that&#39;s been approved by Apple. You can think of a code signature of an app as the equivalent of a government-issued ID, where the government is Apple. Entitlements are like licenses, little bits of information that have also been verified by Apple and can give apps access to system resources that are normally not accessible.</p><p>All of these protections can be quite effective. However, their effectiveness relies heavily on how well Apple&#39;s engineers have implemented them in the system daemons, and sometimes unforeseen workarounds can result in a situation where the door has been very well shut and secured, but the window has been left wide open.</p><h2>AirPods and Siri</h2><p>Since the introduction of the H1 chip with the AirPods (2nd generation), users can trigger &#34;Hey, Siri&#34; with AirPods, and talk to the assistant without much effort <s>and then receive a reply in the form of &#34;here&#39;s what I found on the web...&#34;</s>. One thing you may or may not have noticed if you&#39;ve used Siri with modern AirPods is that there&#39;s no disruption to audio quality when you&#39;re talking to Siri, even though you&#39;re using the microphone in the AirPods to do so. This is very different from when you&#39;re using it for a video conference, for example, where you&#39;ll notice a significant drop in the output audio quality.</p><p>I always wondered why that was the case. Knowing that the drop in output quality when using the microphone is a physical limitation of the Bluetooth standards used by AirPods and other similar headsets, how talk to Siri had been implemented on AirPods without disrupting audio quality had always been a bit of a mystery to me, but I never put much thought or effort into figuring that out.</p><p>As part of my work developing <a href="https://airbuddy.app">AirBuddy</a>, I&#39;m constantly testing various aspects of AirPods and other Apple and Beats headsets in order to develop new features, troubleshoot issues, or just learn more about how these devices work under the hood.</p><p>I&#39;m a fan of creating tools that make my job easier, so a while back I wrote a little command-line tool that I call <code>bleutil</code>, which can be used to interact with Bluetooth Low Energy devices on macOS. I use it all the time to debug what&#39;s going on with my AirPods by looking at the advertisement packets they&#39;re sending out.</p><figure>
    <picture>
        <source srcset="/assets/img/SiriSpy/bleutil-dark.jpg" media="(prefers-color-scheme: dark)"/>
        <img src="https://rambo.codes/assets/img/SiriSpy/bleutil.jpg" alt="Screenshot of a Terminal window on macOS showing the invocation bleutil scan --mfg-prefix 4c0012 and a long list of timestamps, UUIDs, RSSI levels, MAC addresses and hex bytes"/>
    </picture>
</figure><p>While working on a new feature for this tool, which can be used to connect to a Bluetooth LE device and query its GATTÂ¹ database, I decided to add the ability to subscribe to notifications to a service&#39;s characteristics using this tool, which would then stream a hexadecimal representation of the values over time to the Terminal window.</p><p><em>Â¹ If you&#39;re not familiar with Bluetooth Low Energy terminology, GATT stands for &#34;Generic Attribute Profile&#34;. It&#39;s a standard adopted by Bluetooth LE devices that allows them to send data back and forth using services and characteristics. You can think of services as folders on a file system, where each service can have a bunch of characteristics within it, which are like files.</em></p><p>I had never looked into the services and characteristics present on AirPods and similar devices because most of the information I use to power AirBuddy&#39;s features comes from advertisements or Bluetooth Classic, which don&#39;t require me to connect to the devices over Bluetooth LE and interact with the GATT database.</p><p>Naturally, while testing this new feature I was working on, I was wearing my AirPods. I noticed that the AirPods included a service with the UUID <code>9bd708d7-64c7-4e9f-9ded-f6b6c4551967</code>, and with characteristics that supported notificationsÂ². I ran my tool against my AirPods and left it running for a while, but no events came through.</p><p><em>Â² In Bluetooth LE GATT, when a characteristic supports notifications (or indications), it means that other devices can subscribe to be notified when the data stored by that characteristic changes, without having to be constantly asking (polling) for the current data. It&#39;s essential for real-time communication between devices.</em></p><p>Digging a bit into it, I learned that <code>9bd708d7-64c7-4e9f-9ded-f6b6c4551967</code> is the DoAP service, a service used for Siri and Dictation support.</p><p>I decided to test it again. This time, while my tool was running and waiting for events to come from the AirPods, I invoked Siri while wearing them. As soon as I did that, a firehose of hex bytes started to stream down my Terminal window. Not only that, but as I spoke to Siri through my AirPods, I noticed that the bytes would change rapidly, and would settle down as I went silent again. Could it be that I was looking at audio data? ðŸ˜¨</p><p>You can watch a reproduction in the video below:</p><p>As it turns out, I was in fact looking at audio data coming from the AirPods. My first thought was &#34;oh, so that&#39;s how they do it, this is cool&#34;. My second thought was &#34;oh, no!&#34;.</p><p><em>I always have mixed feelings when I discover something like this: a mix of excitement for having found a cool new thing to investigate and learn from, and disappointment/concern that this issue has been there in the wild, sometimes for years.</em></p><p>Finding out that I could get audio from AirPods without asking for permission to use the microphone on macOS was the first step.</p><p>The second step was checking Apple&#39;s other platforms to see if they were also affected. So I wrote a little app that I could run on iPhone, iPad, Apple Watch, and the Apple TV, then tried it out on devices running both the shipping version of iOS 15 and the latest iOS 16 beta at the time (this happened in late August).</p><p>The third step was figuring out what the audio data was. I was definitely seeing a bunch of bytes coming in, but who knows, maybe they were encrypted or something. The seemingly direct correlation between me speaking to Siri and the bytes changing had already made me think they weren&#39;t, but I had to confirm it.</p><h3>Decoding DoAP Audio</h3><p>I know a little bit about how digital audio works, but it&#39;s definitely an area I&#39;ve had very little experience in throughout my career in software development, limiting myself to using high level APIs such as Apple&#39;s <code>AVFoundation</code> whenever I have to deal with audio or video.</p><p>The first thing I tried was to grab the hex dump from my Terminal window, paste it into <a href="https://hexfiend.com">HexFiend</a>, then use the &#34;open raw data&#34; option in tools such as Audacity and Adobe Audition, trying various combinations of sample rate, bit rate, endianness, etc.</p><p>I did notice with some combinations of parameters that the garbled mess I was hearing did vaguely match the loudness of what I had said during the recording, which again told me the data was likely unencrypted.</p><p>In hindsight, I should&#39;ve realized that it wouldn&#39;t make any sense for the audio being sent over Bluetooth LE to be uncompressed, given the bandwidth constraints of the technology. Now all I had to do was figure out which codec was being used, then I&#39;d be able to decode the audio and play it back.</p><p>After looking through some of the system components responsible for this feature, I noticed that <a href="https://opus-codec.org">Opus</a> was referenced quite a bit. Looking at the website for the Opus codec:</p><blockquote><p>Opus is unmatched for interactive speech [...]</p></blockquote><p>Well, sounds a lot like the sort of thing you&#39;d use for talking to digital assistants.</p><p>So I compiled the Opus library for all of Apple&#39;s platforms, then wrote a little app that would connect to the AirPods and keep the connection open in the background, listening to notifications and audio data.</p><p>It sounds simple, but the paragraph above comprises several hours of work â€“ almost a full day â€“ after which I had this:</p><p>Here&#39;s a summary of what the app does:</p><ul><li>Asks for Bluetooth permissionÂ³</li><li>Finds a connected Bluetooth LE device that has the DoAP service</li><li>Subscribes to its characteristics to be notified of when streaming starts and stops, and when audio data comes in</li><li>When streaming starts, creates a new wav file, then feeds the Opus packets coming from the AirPods into a decoder, which then writes the uncompressed audio to the file</li><li>Once streaming stops, closes the wav file, then sends a local push notification to demonstrate that the app has successfully recorded the user in the background</li></ul><p>In a real-world exploit scenario, an app that already has Bluetooth permission for some other reason could be doing this without any indication to the user that it&#39;s going on, because there&#39;s no request to access the microphone, and the indication in Control Center only lists &#34;Siri &amp; Dictation&#34;, not the app that was bypassing the microphone permission by talking directly to the AirPods over Bluetooth LE.</p><p><em>Â³ Yes, even though this exploit bypasses the microphone permission, it still needs access to Bluetooth, so that permission is not bypassed. However, most users would not expect that giving an app access to Bluetooth could also give it access to their conversations with Siri and audio from dictation. And, as you&#39;ll see in the following paragraphs, I was also able to find a way around the Bluetooth permission on macOS.</em></p><h3>Full TCC Bypass on macOS</h3><p>In the course of figuring out how things work for my report on the vulnerability described above, I had to investigate how Apple&#39;s operating systems communicate with the AirPods, which led me to discover another issue.</p><p>The system process responsible for handling of the DoAP protocol on Apple&#39;s platforms is <code>BTLEServerAgent</code> (or <code>BTLEServer</code>, depending on the platform). This agent or daemon provides an interface over the mach service <code>com.apple.BTLEAudioController.xpc</code>, which other processes on the system can use to request audio from the AirPods DoAP service.</p><p>There are hundreds (if not thousands) of mach services exposed by system agents and daemons on Apple&#39;s operating systems, but sandboxing restrictions and entitlement requirements prevent most apps from talking to them.</p><p>For services that are exposed to third-party apps, system daemons usually check for a specific entitlement before allowing an app to send requests to them, or put up a TCC prompt on the app&#39;s behalf, only allowing the communication to go through once the user has approved it.</p><p><a href="https://rambo.codes/posts/2022-03-15-how-a-macos-bug-could-have-allowed-for-a-serious-phishing-attack-against-users/">You can probably see where this is going</a>: <code>BTLEServerAgent</code> did not have any entitlement checks or TCC prompts in place for its <code>com.apple.BTLEAudioController.xpc</code> service, so any process on the system could connect to it, send requests, and receive audio frames from AirPods. This exploit would only work on macOS, because the more restricted sandbox of iOS prevents apps from accessing most global mach services directly.</p><p>So at least on macOS, apps would be able to record your conversations with Siri or dictation audio without any permission prompts at all. Even worse, this particular exploit would also allow the app to request DoAP audio on-demand, bypassing the need to wait for the user to talk to Siri or use dictation.</p><p>Here&#39;s a demo of this in action:</p><p>Once again, these issues show that no matter how private and secure Apple&#39;s products and software can be, there&#39;s always more work to be done.</p><h2>Timeline</h2><ul><li>August 26, 2022: I discovered the issues and reported them to Appleâ€™s security team</li><li>August 29, 2022: I got a reply confirming that they were investigating</li><li>October 24, 2022: iOS 16.1 and remaining Apple operating systems updated with the fix (CVE-2022-32946)</li><li>October 25, 2022: after reaching out, I was told I&#39;ll be receiving a US$7000 bug bounty payment for reporting these issues</li></ul><h2>Update: Mitigations</h2><p>When I first published this writeup, I hadn&#39;t included details about the mitigations Apple has put in place for the issues discussed, because to be honest they&#39;re not that interesting. Since a few folks have asked for details on this, here they are.</p><p>The main issue â€“ direct access to AirPods DoAP over BLE GATT â€“ was addressed by restricting access to the service. Even though AirPods and iPhones, Macs, etc are standard Bluetooth devices, Apple has a system in place to limit which services third-party apps can access, so they just added the DoAP service to that deny list.</p><p>For the second issue â€“ talking to BTLEServerAgent on macOS â€“ the system agent now correctly checks that the calling process has the <code>com.apple.bluetooth.system</code> entitlement before allowing communication to continue. This is the same entitlement that also opens up access to those &#34;forbidden&#34; GATT services.</p><p>Now, if an app attempts to talk to the agent without the appropriate entitlement, it closes the connection, then logs a passive-aggressive message to the console:</p><figure>
    <picture>
        <img src="https://rambo.codes/assets/img/SiriSpy/entitlement-console-message.jpg" alt="Not an entitled process. Good bye."/>
    </picture>
</figure></div></article></div>
  </body>
</html>
