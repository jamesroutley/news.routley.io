<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bit-hack.net/2025/11/10/fpga-based-ibm-pc-xt/">Original</a>
    <h1>FPGA Based IBM-PC-XT</h1>
    
    <div id="readability-page-1" class="page"><div>
		<div>
<figure><a href="https://bit-hack.net/wp-content/uploads/2025/11/img_5334.jpg"><img data-attachment-id="2427" data-permalink="https://bit-hack.net/2025/11/10/fpga-based-ibm-pc-xt/img_5334/#main" data-orig-file="https://bit-hack.net/wp-content/uploads/2025/11/img_5334.jpg" data-orig-size="4541,3706" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;Canon EOS R8&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;1761477878&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;25600&#34;,&#34;shutter_speed&#34;:&#34;0.004&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="IMG_5334" data-image-description="" data-image-caption="" data-medium-file="https://bit-hack.net/wp-content/uploads/2025/11/img_5334.jpg?w=300" data-large-file="https://bit-hack.net/wp-content/uploads/2025/11/img_5334.jpg?w=874" width="1024" height="835" src="https://bit-hack.net/wp-content/uploads/2025/11/img_5334.jpg?w=1024" alt="" srcset="https://bit-hack.net/wp-content/uploads/2025/11/img_5334.jpg?w=1024 1024w, https://bit-hack.net/wp-content/uploads/2025/11/img_5334.jpg?w=2048 2048w, https://bit-hack.net/wp-content/uploads/2025/11/img_5334.jpg?w=150 150w, https://bit-hack.net/wp-content/uploads/2025/11/img_5334.jpg?w=300 300w, https://bit-hack.net/wp-content/uploads/2025/11/img_5334.jpg?w=768 768w, https://bit-hack.net/wp-content/uploads/2025/11/img_5334.jpg?w=1440 1440w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure></div>


<hr/>



<p>Recently I undertook a hobby project to recreate an IBM XT Personal Computer from the 1980s using a mix of authentic parts and modern technology. I had a clear goal in mind: I wanted to be able to play the EGA version of Monkey Island 1 on it, with no features missing. This means I need mouse support, hard drive with write access for saving the game, and Adlib audio, my preferred version of the game’s musical score.</p>



<p>The catalyst for this project was the discovery that there are low-power versions of the NEC V20 CPU available (<a href="https://github.com/bit-hack/iceXt/blob/master/datasheets/UPD70108H.PDF">UPD70108H</a>), which is compatible with the Intel 8088 used in the XT. Being a low-power version significantly simplifies its connection to an FPGA, which typically operate with 3.3-volt IO voltages. Coupled with a low-power 1MB SRAM chip (<a href="https://github.com/bit-hack/iceXt/blob/master/datasheets/CY62158EV30.pdf">CY62158EV30</a>) to provide the XT with its 640KB of memory, and I started to have the bones of a complete system worked out.</p>



<p>I started off by designing the hardware of the system, which would then serve as my development board while I worked on the software/gateware. The following features were added:</p>


<div>
<figure><a href="https://bit-hack.net/wp-content/uploads/2025/11/schematic_minixt_2025-11-10.png"><img data-attachment-id="2433" data-permalink="https://bit-hack.net/2025/11/10/fpga-based-ibm-pc-xt/schematic_minixt_2025-11-10/#main" data-orig-file="https://bit-hack.net/wp-content/uploads/2025/11/schematic_minixt_2025-11-10.png" data-orig-size="1801,1202" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Schematic_MiniXt_2025-11-10" data-image-description="" data-image-caption="" data-medium-file="https://bit-hack.net/wp-content/uploads/2025/11/schematic_minixt_2025-11-10.png?w=300" data-large-file="https://bit-hack.net/wp-content/uploads/2025/11/schematic_minixt_2025-11-10.png?w=874" width="1024" height="683" src="https://bit-hack.net/wp-content/uploads/2025/11/schematic_minixt_2025-11-10.png?w=1024" alt="" srcset="https://bit-hack.net/wp-content/uploads/2025/11/schematic_minixt_2025-11-10.png?w=1024 1024w, https://bit-hack.net/wp-content/uploads/2025/11/schematic_minixt_2025-11-10.png?w=150 150w, https://bit-hack.net/wp-content/uploads/2025/11/schematic_minixt_2025-11-10.png?w=300 300w, https://bit-hack.net/wp-content/uploads/2025/11/schematic_minixt_2025-11-10.png?w=768 768w, https://bit-hack.net/wp-content/uploads/2025/11/schematic_minixt_2025-11-10.png?w=1440 1440w, https://bit-hack.net/wp-content/uploads/2025/11/schematic_minixt_2025-11-10.png 1801w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure></div>


<hr/>



<p>I drew up my design using the EasyEDA CAD software as I’m already familiar with it, and it has really good integration with the JLCPCB PCB assembly service. Some of the components in the design are too tricky for me to hand solder by myself. I did however have to solder the SRAM chips once the boards arrived since they were not stocked by LCSC so I had to source them elsewhere.</p>


<div>
<figure><a href="https://bit-hack.net/wp-content/uploads/2025/11/image.png"><img data-attachment-id="2430" data-permalink="https://bit-hack.net/2025/11/10/fpga-based-ibm-pc-xt/image-2/#main" data-orig-file="https://bit-hack.net/wp-content/uploads/2025/11/image.png" data-orig-size="895,757" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://bit-hack.net/wp-content/uploads/2025/11/image.png?w=300" data-large-file="https://bit-hack.net/wp-content/uploads/2025/11/image.png?w=874" width="895" height="757" src="https://bit-hack.net/wp-content/uploads/2025/11/image.png?w=895" alt="" srcset="https://bit-hack.net/wp-content/uploads/2025/11/image.png 895w, https://bit-hack.net/wp-content/uploads/2025/11/image.png?w=150 150w, https://bit-hack.net/wp-content/uploads/2025/11/image.png?w=300 300w, https://bit-hack.net/wp-content/uploads/2025/11/image.png?w=768 768w" sizes="(max-width: 895px) 100vw, 895px"/></a></figure></div>


<hr/>



<p>The first step was to write a bus controller for the processor. The V20 CPU clock is more forgiving than an original i8088 since its can be run right down to 0hz and its uses a regular 50% duty cycle. The external interface for an 8088 CPU operates in terms of bus cycles. At that start of a bus cycle the CPU asserts some pins to let everyone know what it wants to try and do… read memory, write to IO, etc. Each type of bus cycle follows a specific sequence of events that happen over a number of clock cycles. It was straight forward to make a state machine that could detect the start of a bus-cycle, figure out what kind it was, and then produce or consume the data as needed by the CPU. Key here, was to make sure that all of the timing requirements were met, so that signals the CPU generates are sampled at the correct time, and signals the CPU requires have been driven correctly before the CPU reads them.</p>


<div>
<figure><a href="https://bit-hack.net/wp-content/uploads/2025/11/image-3.png"><img data-attachment-id="2462" data-permalink="https://bit-hack.net/2025/11/10/fpga-based-ibm-pc-xt/image-5/#main" data-orig-file="https://bit-hack.net/wp-content/uploads/2025/11/image-3.png" data-orig-size="489,593" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://bit-hack.net/wp-content/uploads/2025/11/image-3.png?w=247" data-large-file="https://bit-hack.net/wp-content/uploads/2025/11/image-3.png?w=489" loading="lazy" width="489" height="593" src="https://bit-hack.net/wp-content/uploads/2025/11/image-3.png?w=489" alt="" srcset="https://bit-hack.net/wp-content/uploads/2025/11/image-3.png 489w, https://bit-hack.net/wp-content/uploads/2025/11/image-3.png?w=124 124w, https://bit-hack.net/wp-content/uploads/2025/11/image-3.png?w=247 247w" sizes="(max-width: 489px) 100vw, 489px"/></a><figcaption>An example memory write bus cycle timing diagram.</figcaption></figure></div>


<p>My first test for the bus controller was to write a simple program using NASM to be executed on the V20, with a simple goal… it will flash an LED mapped to an IO port address. Simple, but a blinking LED seems to be the hardware equivalent of the software hello-world. For the initial version, the program was simply loaded into a FPGA block ram and used directly as the system memory.</p>



<p>Later, I used a more complex approach for memory accesses. The bios, for example, is loaded into an FPGA block ram, so that CPU memory reads will come from that rather than the system SRAM chip. Video memory is implemented a differently still. CPU memory writes are passed to both the video memory block ram and system SRAM, but CPU reads alway come from only the system SRAM. This then means that I have a spare read port on the video block ram that can then be used by the VGA signal generator to display the video memory contents.</p>



<p>After my success with a blinky program, I installed a virtual copy of <a href="https://www.minuszerodegrees.net/supersoft_landmark/Supersoft%20Landmark%20ROM.htm">Supersoft/Landmark Diagnostic ROM</a> in place of the BIOS and wrote a basic CGA adapter for video output. I was then able to use the diagnostic ROM to test the SRAM memory interface as well as some of the peripherals required by the XT such as the <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable-interval-timer</a> (i8253) and <a href="https://en.wikipedia.org/wiki/Programmable_interrupt_controller">programmable-interrupt-controller</a> (i8259).</p>



<p>Once I was confident the basic system was stable I then swaped in a generic XT bios from <a href="https://www.phatcode.net/downloads.php?id=101">https://www.phatcode.net</a> in place of the diagnostic ROM. It was amazing to see the bios start to boot up, and complain when it couldnt find a boot disk.</p>



<p>Fixed Disk access is achieved by making a small Verilog SPI controller accessible to the CPU via some unused IO ports. I then wrote an option ROM to handle BIOS INT13H (disk service) calls, which had routines that could issue commands to the SD-Card over SPI. The tricky part for me was learning the SD card protocol and then writing 8088 assembly to perform the correct operations. The mapping itself is very straightforward as both SD card and DOS assume 512byte sectors.</p>



<p>I saved a lot of time when writing the option ROM by developing and debugging the code using a software emulator of the board that I cobbled together. Some historic sources for it can be found here: <a href="https://github.com/bit-hack/iceXt/tree/master/misc/emulator">https://github.com/bit-hack/iceXt/tree/master/misc/emulator</a></p>



<p>Perhaps the hardest part of the project was, surprisingly, getting the mouse to work. Mice of the XT era would typically be connected to a UART serial port. I had however placed a PS/2 connector on the hardware board, and those mice use a very different protocol. In my efforts to support a mouse I startedto learn about PS/2 devices, however I would need to implement a much more complex keyboard controller, and the BIOS I was also lacked support for such modern peripherals, and I just plain didn’t feel like I understood everything required to get that working.</p>



<p>What makes it tricky is that PS/2 is a bidirectional protocol, and the mouse has to be asked by the PC to broadcast updates, otherwise we will not receive any. That added a lot more complexity than I was wanting. The keyboard on the otherhand is relatively easy to work with and send out keypresses without having to be asked.</p>



<p>I chose an alternative. I wrote some Verilog code to talk directly to the PS/2 mouse, which would early in the boot process tell it to start sending over mouse events, as they have to be requested. When the bridge then receives mouse events, it translates and presents them to the computer via a pseudo UART peripheral. I had implemented a basic PS/2 mouse to Serial mouse bridge. A little convoluted but it works really well.</p>



<p>During this process, I lobotomised a spare mouse by attaching a logic analyser the clk and dat pads inside the mouse. I was then able to capture the communications between a real PC and the mouse and observe it during use. This gave me invaluable insight into exactly how the protocol worked, and what a real mouse expected.</p>



<p>I also found that having real waveforms to look at made it much easier to test components of my design in <a href="https://www.veripool.org/verilator/">verilator</a>, a Verilog simulator, as I could closely model the stimulus it should see when running in the FPGA.</p>


<div>
<figure><a href="https://bit-hack.net/wp-content/uploads/2025/11/image-2.png"><img data-attachment-id="2444" data-permalink="https://bit-hack.net/2025/11/10/fpga-based-ibm-pc-xt/image-4/#main" data-orig-file="https://bit-hack.net/wp-content/uploads/2025/11/image-2.png" data-orig-size="558,111" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://bit-hack.net/wp-content/uploads/2025/11/image-2.png?w=300" data-large-file="https://bit-hack.net/wp-content/uploads/2025/11/image-2.png?w=558" loading="lazy" width="558" height="111" src="https://bit-hack.net/wp-content/uploads/2025/11/image-2.png?w=558" alt="" srcset="https://bit-hack.net/wp-content/uploads/2025/11/image-2.png 558w, https://bit-hack.net/wp-content/uploads/2025/11/image-2.png?w=150 150w, https://bit-hack.net/wp-content/uploads/2025/11/image-2.png?w=300 300w" sizes="(max-width: 558px) 100vw, 558px"/></a><figcaption>I had to anotate these waveform captures by hand to better understand the PS/2 protocol.</figcaption></figure></div>


<hr/>



<p>Just like the XT, one of the channels of the PIT timer is used to drive the internal speaker to produce bleep and bloop sounds. I extended this by having disk accesses trigger short pulses out of the peizo speaker as a crude emulation of a hard disk seeking. I think it really adds to the experience when you can hear your computer thinking away while doing its tasks. When it comes to music, the internal PC speaker quickly looses its charm however. Writing an YM3812 implementation (the FM chip used in the Adlib card) is beyond my skill level but thankfully Jose Tejada has written an amazing open source version that I was able to pull into my project; <a href="https://github.com/jotego/jtopl">https://github.com/jotego/jtopl</a>.</p>



<p>I wrote a small Verilog module to take the PCM sample data generated by this soft YM3812 and convert it to the unusual 3:10 floating point format required by the YM3014 DAC on my board. This is very similar to the operation of the real Adlib hardware, where the YM3812 generates and sends serial audio data to a YM3014 DAC chip. A modern I2S DAC may have been cleaner, but having a chance to play with the authentic DAC seemed a little more fun to me. All of this combined results in the same lovely crisp FM tones I was so fond of when I played games on my PC growing up.</p>


<div>
<figure><a href="https://bit-hack.net/wp-content/uploads/2025/11/image-4.png"><img data-attachment-id="2468" data-permalink="https://bit-hack.net/2025/11/10/fpga-based-ibm-pc-xt/image-6/#main" data-orig-file="https://bit-hack.net/wp-content/uploads/2025/11/image-4.png" data-orig-size="462,320" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://bit-hack.net/wp-content/uploads/2025/11/image-4.png?w=300" data-large-file="https://bit-hack.net/wp-content/uploads/2025/11/image-4.png?w=462" loading="lazy" width="462" height="320" src="https://bit-hack.net/wp-content/uploads/2025/11/image-4.png?w=462" alt="" srcset="https://bit-hack.net/wp-content/uploads/2025/11/image-4.png 462w, https://bit-hack.net/wp-content/uploads/2025/11/image-4.png?w=150 150w, https://bit-hack.net/wp-content/uploads/2025/11/image-4.png?w=300 300w" sizes="(max-width: 462px) 100vw, 462px"/></a><figcaption>The YM3014 uses a 10bit DAC feeding into a 3bit divider for more dynamic range.</figcaption></figure></div>


<p>A lot of other elements of this project have been glossed over or omitted, such as support for CGA and EGA graphics. There is even a USB to UART bridge for sending files from a host PC directly to the SD card. I also made some nice clear acrylic panels on a CNC machine to round off the design and protect the bare PCB.</p>


<div>
<figure><a href="https://bit-hack.net/wp-content/uploads/2025/11/pxl_20251113_131957299-1.jpg"><img data-attachment-id="2477" data-permalink="https://bit-hack.net/pxl_20251113_131957299-3/" data-orig-file="https://bit-hack.net/wp-content/uploads/2025/11/pxl_20251113_131957299-1-edited.jpg" data-orig-size="3670,2756" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;1.89&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;Pixel 8a&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;1763039997&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;5.43&#34;,&#34;iso&#34;:&#34;59&#34;,&#34;shutter_speed&#34;:&#34;0.019996&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;,&#34;latitude&#34;:&#34;55.994572222222&#34;,&#34;longitude&#34;:&#34;-2.5042972222222&#34;}" data-image-title="PXL_20251113_131957299" data-image-description="" data-image-caption="" data-medium-file="https://bit-hack.net/wp-content/uploads/2025/11/pxl_20251113_131957299-1-edited.jpg?w=300" data-large-file="https://bit-hack.net/wp-content/uploads/2025/11/pxl_20251113_131957299-1-edited.jpg?w=874" loading="lazy" width="3670" height="2756" src="https://bit-hack.net/wp-content/uploads/2025/11/pxl_20251113_131957299-1-edited.jpg" alt="" srcset="https://bit-hack.net/wp-content/uploads/2025/11/pxl_20251113_131957299-1-edited.jpg 3670w, https://bit-hack.net/wp-content/uploads/2025/11/pxl_20251113_131957299-1-edited.jpg?w=150&amp;h=113 150w, https://bit-hack.net/wp-content/uploads/2025/11/pxl_20251113_131957299-1-edited.jpg?w=300&amp;h=225 300w, https://bit-hack.net/wp-content/uploads/2025/11/pxl_20251113_131957299-1-edited.jpg?w=768&amp;h=577 768w, https://bit-hack.net/wp-content/uploads/2025/11/pxl_20251113_131957299-1-edited.jpg?w=1024&amp;h=769 1024w, https://bit-hack.net/wp-content/uploads/2025/11/pxl_20251113_131957299-1-edited.jpg?w=1440&amp;h=1081 1440w" sizes="(max-width: 3670px) 100vw, 3670px"/></a></figure></div>


<p>A video demo is shown below.</p>



<figure><div>
<div><p><iframe title="FPGA-Based IBM PC-XT Clone" width="874" height="492" src="https://www.youtube.com/embed/EmwGfURk4s8?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></p></div>
</div></figure>



<hr/>



<p>Source code, schematics and gerber files are available on github here: <a href="https://github.com/bit-hack/iceXt">https://github.com/bit-hack/iceXt</a></p>



<p>Thanks for reading!</p>




			</div></div>
  </body>
</html>
