<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.spiraldb.com/compressing-strings-with-fsst/">Original</a>
    <h1>Random access string compression with FSST and Rust</h1>
    
    <div id="readability-page-1" class="page"><div>

    <article>

        <header>

                <a href="https://blog.spiraldb.com/tag/vortex/">vortex</a>
            
                <p>Random access string compression with FSST and Rust</p>

            <div>
                <p><a href="https://blog.spiraldb.com/author/andrew/">
                                <img src="https://blog.spiraldb.com/content/images/size/w160/2024/09/me_cropped-1-1.png" alt="Andrew Duffy"/>
                            </a>
                </p>
                <div>
                    
                    <p><time datetime="2024-09-09">Sep 9, 2024</time>
                            <span><span>‚Äî</span> 11 min read</span>
                    </p>
                </div>
            </div>

                <figure>
        <img srcset="/content/images/size/w320/2024/09/fsst_sorcerer-2-1.jpg 320w,
                    /content/images/size/w600/2024/09/fsst_sorcerer-2-1.jpg 600w,
                    /content/images/size/w960/2024/09/fsst_sorcerer-2-1.jpg 960w,
                    /content/images/size/w1200/2024/09/fsst_sorcerer-2-1.jpg 1200w,
                    /content/images/size/w2000/2024/09/fsst_sorcerer-2-1.jpg 2000w" src="https://blog.spiraldb.com/content/images/size/w1200/2024/09/fsst_sorcerer-2-1.jpg" alt="Compressing strings with FSST"/>
            <figcaption><span>A new string compression algorithm, conjured up by the wizards at CWI and TUM</span></figcaption>
    </figure>

        </header>

        <section>
            <blockquote><em>We‚Äôve released our Apache-licensed implementation of FSST, you can check it out on </em><a href="https://github.com/spiraldb/fsst?ref=blog.spiraldb.com"><em>GitHub</em></a><em>!</em></blockquote><p><a href="http://github.com/spiraldb/vortex/?ref=blog.spiraldb.com">Vortex</a>¬†is our open-source Rust library for compressed Arrow. If you want to have compressed Arrow arrays on-disk, in-memory, or over-the-wire, Vortex is designed to help out. </p><p>Vortex opts for a columnar representation that is the same both on-disk and in-memory, relying on a set of <a href="https://duckdb.org/2022/10/28/lightweight-compression.html?ref=blog.spiraldb.com">lightweight compression</a> schemes that allow readers to just-in-time decompress the data you need, when you need it. We‚Äôre building out a toolkit of open codecs to efficiently and effectively compress the widest range of data.</p><p>Our initial focus has been on numeric codecs, and we‚Äôve <a href="https://blog.spiraldb.com/life-in-the-fastlanes/">written about our approach</a> using the FastLanes layout to compress integers at the bleeding edge of what‚Äôs possible on today‚Äôs hardware. We‚Äôve also implemented <a href="https://ir.cwi.nl/pub/33334/33334.pdf?ref=blog.spiraldb.com">ALP</a> to compress floating point arrays, as well as <a href="https://arxiv.org/abs/1402.6407?ref=blog.spiraldb.com">Roaring Bitmaps</a>.</p><p>However, not all data is numeric. String data is incredibly prevalent in the real world. Apache Parquet, the most popular analytics data format, supports compressing strings with dictionary encoding, along with a range of general purpose compressors, which as we see later can be too heavyweight for use cases that favor random indexed access to data.</p><p>More recently, there‚Äôs been renewed interest within the research community around string compression in databases, and in this post we‚Äôre going to describe a relatively new codec called <a href="https://www.vldb.org/pvldb/vol13/p2649-boncz.pdf?ref=blog.spiraldb.com" rel="noreferrer">FSST</a>. FSST is fast‚Äìthe reference implementation achieves gigabytes-per-second decoding‚Äìand has shown to compress on average by a factor of 2-3x on many real-world datasets. We&#39;re open-sourcing a <a href="https://crates.io/crates/fsst-rs?ref=blog.spiraldb.com">Rust crate</a> for FSST, and we&#39;ve also <a href="https://github.com/spiraldb/vortex/tree/develop/encodings/fsst?ref=blog.spiraldb.com" rel="noopener noreferrer">integrated it into our </a><a href="https://github.com/spiraldb/vortex/tree/develop/encodings/fsst?ref=blog.spiraldb.com" rel="noopener noreferrer">Vortex toolkit</a>.</p><p>The next few sections provide a brief history of string compression, motivating the need for a new lightweight string codec like FSST, and then provides a walk through of the steps for compression and decompression.</p><h2 id="string-compression-in-brief">String compression, in brief</h2><p>String compression algorithms are not new, and you may already be familiar with some of the more common ones such as Zip, LZ4, and Zstd. All of these operate over <em>blocks</em> of data. Accessing individual values require decompressing the whole block. If you&#39;re processing an entire block at a time, this may amortize out, although recent research has shown that due to increasing network and disk bandwidth, <a href="https://15721.courses.cs.cmu.edu/spring2024/papers/02-data1/p148-zeng.pdf?ref=blog.spiraldb.com">reading these formats has become increasingly CPU bound</a>.</p><p>The CPU overhead of reading block-compressed data is especially apparent in applications that do lots of small random accesses across a column. Let&#39;s take as an example an array with fixed 128KB blocks :</p><figure><img src="https://blog.spiraldb.com/content/images/2024/09/image-4.png" alt="" loading="lazy" width="2000" height="514" srcset="https://blog.spiraldb.com/content/images/size/w600/2024/09/image-4.png 600w, https://blog.spiraldb.com/content/images/size/w1000/2024/09/image-4.png 1000w, https://blog.spiraldb.com/content/images/size/w1600/2024/09/image-4.png 1600w, https://blog.spiraldb.com/content/images/2024/09/image-4.png 2000w" sizes="(min-width: 720px) 720px"/></figure><p>Let&#39;s say to service a particular query, we want to access 8 values, or ~6% of the data in the array. In the best case‚Äìwhen the indices are clustered‚Äìwe can do so by only decompressing a single block.</p><figure><img src="https://blog.spiraldb.com/content/images/2024/09/image-10.png" alt="" loading="lazy" width="2000" height="627" srcset="https://blog.spiraldb.com/content/images/size/w600/2024/09/image-10.png 600w, https://blog.spiraldb.com/content/images/size/w1000/2024/09/image-10.png 1000w, https://blog.spiraldb.com/content/images/size/w1600/2024/09/image-10.png 1600w, https://blog.spiraldb.com/content/images/2024/09/image-10.png 2000w" sizes="(min-width: 720px) 720px"/></figure><p>However, if the indices are unclustered and spread out, then in the worst case we must decompress the entire array!</p><figure><img src="https://blog.spiraldb.com/content/images/2024/09/image-9.png" alt="" loading="lazy" width="2000" height="627" srcset="https://blog.spiraldb.com/content/images/size/w600/2024/09/image-9.png 600w, https://blog.spiraldb.com/content/images/size/w1000/2024/09/image-9.png 1000w, https://blog.spiraldb.com/content/images/size/w1600/2024/09/image-9.png 1600w, https://blog.spiraldb.com/content/images/2024/09/image-9.png 2000w" sizes="(min-width: 720px) 720px"/></figure><p>What we want for these more dynamic applications are codecs that support <em>random access</em>. We want a data structure that efficiently implements the following interface:</p><pre><code>pub trait StringCodec {
  /// Decode and return the string at the given index.
  fn decode(index: usize) -&gt; String;
}
</code></pre><p>This is a deep oversimplification of course, but a helpful one for demonstration purposes. We‚Äôll revisit this toy trait throughout the rest of the post to illustrate how random access is implemented for different encoding schemes.</p><h2 id="dictionary-encoding">Dictionary Encoding</h2><p>Dictionary encoding is probably the most well-known codec that supports efficient random access.</p><p>It is also one of the simplest: perform a single pass over your data to find the unique values, assign each value an integer <em>code</em>, and replace each occurrence of that value with the code.</p><p>We can illustrate with a simple example that has 3 unique strings:</p><figure><img src="https://blog.spiraldb.com/content/images/2024/09/dictionary_encoding-1.png" alt="A diagram demonstrating dictionary encoding a string array with 3 unique values." loading="lazy" width="2000" height="1837" srcset="https://blog.spiraldb.com/content/images/size/w600/2024/09/dictionary_encoding-1.png 600w, https://blog.spiraldb.com/content/images/size/w1000/2024/09/dictionary_encoding-1.png 1000w, https://blog.spiraldb.com/content/images/size/w1600/2024/09/dictionary_encoding-1.png 1600w, https://blog.spiraldb.com/content/images/2024/09/dictionary_encoding-1.png 2000w" sizes="(min-width: 720px) 720px"/></figure><p>Implementing the single-element decoding just requires access to the dictionary:</p><pre><code>pub struct DictionaryArray {
    /// The string at index `i` is replaced with the code `i`.
    /// Stored a single time at the top of the file.
    codes: Vec&lt;String&gt;,
    /// The encoded values. Each string is represented by
    /// an 8-byte code which is an index into the `codes`
    /// table.
    array: Vec&lt;usize&gt;,
}

impl StringCodec for DictionaryArray {
    fn decode(&amp;self, index: usize) -&gt; String {
        // Step 1: lookup the code in the `index` position
        let code = self.array[index];
        // Step 2: map the code back to a string
        self.codes[code].clone()
    }
}
</code></pre><p>Dictionary encoding is simple, and it performs excellently on many real-world datasets, particularly for categorical columns such as labels and event names. However, it‚Äôs not without its drawbacks:</p><ol><li>Dictionaries only operate at the level of entire strings. If you have repetition that only manifests at the substring level, dictionary encoding won‚Äôt help you.</li><li>Dictionaries only compress well if your data is low-cardinality. As the number of unique values approaches the length of the array, dictionary compression becomes useless, and if you‚Äôre not careful it can even be larger than the raw dataset. This is especially pertinent for request logs, JSON records, UUIDs, and free text.</li><li>You cannot use dictionary encoding to compress data that is not in the dictionary; you instead need to build a new dictionary from scratch. This comes up if you‚Äôre building a system that cares about fast append operations, and appending chunks to an existing column with a shared dictionary is desirable.</li></ol><h2 id="fsst-has-entered-the-chat">FSST has entered the chat</h2><p>The folks over at CWI in the Netherlands &amp; TUM in Germany have been studying databases for <a href="https://www.cidrdb.org/cidr2005/papers/P19.pdf?ref=blog.spiraldb.com">a long time</a>, and in 2020 they dropped another banger: <a href="https://www.vldb.org/pvldb/vol13/p2649-boncz.pdf?ref=blog.spiraldb.com"><em>FSST: Fast Random Access String Compression</em></a>. FSST stands for ‚ÄúFast Static Symbol Table‚Äù, a new data structure to act as the backbone for fast random-access string compression.</p><div><p>üéì</p><div><p>Peter Boncz, Thomas Neumann, and Viktor Leis. 2020. FSST: fast random access string compression. </p></div></div><h3 id="putting-the-st-in-fsst">Putting the ST in FSST</h3><p>Compressing text with FSST requires you to first build a <strong>symbol table</strong>, which like a dictionary is shipped with the actual data to be used at decoding time. Unlike dictionaries, which only hold whole-strings, the symbols in a symbol table are short substrings that can occur anywhere in the array. Because most computers have a native 64-bit word size, we say that a symbol can be between 1 and 8 bytes so that it will always fit in a single register.</p><p>To make it easy to pass FSST-encoded data around wherever string data would usually go, we set a max table length of 256. This ensures that all codes can be packed into a single byte, allowing our encoding to receive a slice of <code>u8</code> and return a slice of <code>u8</code>.</p><p>Compression works string-by-string, and proceeds greedily, matching the longest prefix against the symbol table, and recording the corresponding code into our output array.</p><p>Figure 1 in the paper has an example of what this looks like in practice for a small URL dataset:</p><figure><img src="https://blog.spiraldb.com/content/images/2024/09/fsst_symbols-1-1.png" alt="" loading="lazy" width="629" height="400" srcset="https://blog.spiraldb.com/content/images/size/w600/2024/09/fsst_symbols-1-1.png 600w, https://blog.spiraldb.com/content/images/2024/09/fsst_symbols-1-1.png 629w"/></figure><p>256 codes is a lot, but even with an ideal symbol table, you aren&#39;t guaranteed to be able represent any possible string. For that, we need to reserve code 255 (<code>0xFF</code>) to represent the <strong>escape code</strong>. If while compressing we encounter a substring that does not match any symbol in the table, then we emit each byte of the substring preceded by an escape byte. When the decompressor sees <code>0xFF</code> in the input, it knows to immediately emit the following byte without looking it up in the symbol table.</p><p>If you‚Äôre following along, you‚Äôll realize then that the worst-case compression factor is actually a <strong>doubling of the input</strong>, which we see if we attempt to compress using an empty symbol table.</p><p>For example, the string <code>‚Äúhello‚Äù</code> would be compressed into the byte string:</p><pre><code>[0xFF, b&#39;h&#39;, 0xFF, b&#39;e&#39;, 0xFF, b&#39;l&#39;, 0xFF, b&#39;l&#39;, 0xFF, b&#39;o&#39;]
</code></pre><p>Based on this, we can start to sketch out the codec and array implementations we‚Äôd need to implement FSST decoding with random access:</p><pre><code>struct FSSTArray {
    /// `symbols` stores the symbol table. Each symbol can be a string
    /// of 1 to 8 bytes, which we pack into a u64.
    symbols: Vec&lt;u64&gt;,

    /// The length of each symbol. This vector has the same length
    /// as `symbols`.
    symbol_lengths: Vec&lt;u8&gt;,

    /// The encoded variable-length byte array. bytes[i] is the i-th encoded
    /// string.
    ///
    /// Each encoded string will be a sequence of 8-bit unsigned
    /// integer offsets into the `symbols` table.
    bytes: Vec&lt;Vec&lt;u8&gt;&gt;
}

impl StringCodec for FSSTArray {
    fn decode(&amp;self, index: usize) -&gt; String {
        // Get the compressed value at the index.
        // This is a byte array of codes.
        let codes = self.bytes[index];
        let mut pos = 0;
        let mut result = Vec::new();
        while pos &lt; codes.len() {
            let next_code = codes[pos];
            if next_code == ESCAPE {
                // Emit an escape byte
                pos += 1;
                result.push(code[pos]);
            } else {
                // Lookup the code in the symbol table
                let symbol = self.symbols[code];
                let len = self.symbol_lengths[code] as usize;
                result.extend_from_slice(&amp;symbol.to_le_bytes()[0..len]);
            }

            pos += 1;
        }
		
        // Convert the UTF-8 encoded bytes into a String for the caller
        String::from_utf8(result).unwrap()
    }
}
</code></pre><p>Based on these characteristics, we can quickly see that the theoretical compression factors range from 8‚Äîthe maximum length of a symbol‚Äîto 0.5 in the case where every byte of a string is escaped. Thus, building a symbol table to preference long-matches and avoiding escapes is going to be key to both good compression factors and fast decompression speeds.</p><h3 id="a-seat-at-the-symbol-table">A seat at the (symbol) table</h3><p>FSST compression relies on a generational algorithm for building a symbol table. In each generation, it uses the current generation‚Äôs symbol table to compress a piece of sample text, then examines the used codes to create a set of new potential candidate symbols. At the end of the generation, the best symbols are preserved for the next generation.</p><p>We need to be more specific about how we decide the ‚Äútop‚Äù symbols however. In the paper, the author‚Äôs define a new metric for the ‚Äú<em>effective gain</em>‚Äù of a symbol. A symbol‚Äôs effective gain is equal to its <strong>length times its frequency</strong> of how it appears in the compressed text. Semantically, this is like the marginal compression factor of having this one symbol in the table, for the given piece of text we‚Äôre evaluating against.</p><p>The algorithm takes 3 parameters:</p><ul><li><strong>Maximum symbols</strong>: how big can the symbol table grow. This is directly linked to the code size. Because we‚Äôre using byte codes, this is 255 (leaving the 256th code for an escape).</li><li><strong>Maximum symbol length</strong>: How many bytes can each symbol hold? This was chosen to be 8 bytes so that it can always fit into a single 64-bit register.</li><li><strong>Number of generations</strong>: How many generations does the table selection algorithm proceed for? Because we concatenate symbols at the end of each generation, we must have at least 3 generations to have a chance to generate any 8 byte symbols. The creators of FSST did a lot of empirical testing and found 5 to provide the best balance between speed and compression quality.</li></ul><p>Now that we have all of the parameters of the algorithm, we can be a bit more rigorous in our description of the steps.</p><p>First, we initialize an empty symbol table. An empty symbol table will compress any string it receives into a byte array where each character is preceded by an escape byte.</p><p>For each generation:</p><ol><li>We compress our target string using our existing symbol table. When we compress, we count the symbols that were used in the encoded output. We also concatenate adjacent symbols as candidates for new symbols to add.</li><li>For all existing and candidate symbols, we assign them a gain (<code>count * length</code>), and preserve the top 255 symbols by gain.</li><li>We set the top 255 as the new symbol table to use in the next generation.</li></ol><p>We‚Äôve illustrated a simplified version of the algorithm below. We use a a toy string <code>mums tums</code> , and we‚Äôve altered the parameters to make things fit in one page:</p><ul><li><strong>Maximum symbols</strong>: 4</li><li><strong>Maximum symbol length</strong>: 3</li><li><strong>Number of generations</strong>: 2</li></ul><p>First comes Step 1: Compress using the existing symbol table. In this case, the symbol table is initialized to be empty, so this will escape all bytes, doubling the size of the text!</p><figure><img src="https://blog.spiraldb.com/content/images/2024/09/box1.png" alt="" loading="lazy" width="2000" height="1835" srcset="https://blog.spiraldb.com/content/images/size/w600/2024/09/box1.png 600w, https://blog.spiraldb.com/content/images/size/w1000/2024/09/box1.png 1000w, https://blog.spiraldb.com/content/images/size/w1600/2024/09/box1.png 1600w, https://blog.spiraldb.com/content/images/2024/09/box1.png 2000w" sizes="(min-width: 720px) 720px"/></figure><p>Step 2: Count the symbols that appear in the compressed text. In this case, the symbols are all single-character escapes. We also count all adjacent pairs of symbols that appear, as they are good candidates to merge into a single symbol.</p><figure><img src="https://blog.spiraldb.com/content/images/2024/09/box2-1.png" alt="" loading="lazy" width="1651" height="1247" srcset="https://blog.spiraldb.com/content/images/size/w600/2024/09/box2-1.png 600w, https://blog.spiraldb.com/content/images/size/w1000/2024/09/box2-1.png 1000w, https://blog.spiraldb.com/content/images/size/w1600/2024/09/box2-1.png 1600w, https://blog.spiraldb.com/content/images/2024/09/box2-1.png 1651w" sizes="(min-width: 720px) 720px"/></figure><p>Step 3: Rank the candidates by their effective gain. We preserve the top symbols (in this toy example, the top four) to use as the new symbol table.</p><figure><img src="https://blog.spiraldb.com/content/images/2024/09/box3_2.png" alt="" loading="lazy" width="2000" height="2316" srcset="https://blog.spiraldb.com/content/images/size/w600/2024/09/box3_2.png 600w, https://blog.spiraldb.com/content/images/size/w1000/2024/09/box3_2.png 1000w, https://blog.spiraldb.com/content/images/size/w1600/2024/09/box3_2.png 1600w, https://blog.spiraldb.com/content/images/2024/09/box3_2.png 2000w" sizes="(min-width: 720px) 720px"/></figure><p>We now have a complete symbol table. We repeat the steps above for the second generation:</p><figure><div><div><p><img src="https://blog.spiraldb.com/content/images/2024/09/image-1.png" width="2000" height="1302" loading="lazy" alt="" srcset="https://blog.spiraldb.com/content/images/size/w600/2024/09/image-1.png 600w, https://blog.spiraldb.com/content/images/size/w1000/2024/09/image-1.png 1000w, https://blog.spiraldb.com/content/images/size/w1600/2024/09/image-1.png 1600w, https://blog.spiraldb.com/content/images/size/w2400/2024/09/image-1.png 2400w" sizes="(min-width: 720px) 720px"/></p><p><img src="https://blog.spiraldb.com/content/images/2024/09/image-2.png" width="2000" height="1312" loading="lazy" alt="" srcset="https://blog.spiraldb.com/content/images/size/w600/2024/09/image-2.png 600w, https://blog.spiraldb.com/content/images/size/w1000/2024/09/image-2.png 1000w, https://blog.spiraldb.com/content/images/size/w1600/2024/09/image-2.png 1600w, https://blog.spiraldb.com/content/images/size/w2400/2024/09/image-2.png 2400w" sizes="(min-width: 720px) 720px"/></p><p><img src="https://blog.spiraldb.com/content/images/2024/09/image-3.png" width="1400" height="2654" loading="lazy" alt="" srcset="https://blog.spiraldb.com/content/images/size/w600/2024/09/image-3.png 600w, https://blog.spiraldb.com/content/images/size/w1000/2024/09/image-3.png 1000w, https://blog.spiraldb.com/content/images/2024/09/image-3.png 1400w" sizes="(min-width: 720px) 720px"/></p></div></div></figure><p>In the first generation, our empty symbol table initially doubles the size of our output, but over two generations we refine this table, arriving at one that actually compresses our string by more than a factor of 2!</p><figure><img src="https://blog.spiraldb.com/content/images/2024/09/box7-1-1.png" alt="" loading="lazy" width="1922" height="1127" srcset="https://blog.spiraldb.com/content/images/size/w600/2024/09/box7-1-1.png 600w, https://blog.spiraldb.com/content/images/size/w1000/2024/09/box7-1-1.png 1000w, https://blog.spiraldb.com/content/images/size/w1600/2024/09/box7-1-1.png 1600w, https://blog.spiraldb.com/content/images/2024/09/box7-1-1.png 1922w" sizes="(min-width: 720px) 720px"/></figure><p>As mentioned, this was a simplified example meant to strip away details to clarify the algorithm‚Äôs mechanics. There are quite a few moving pieces needed to actually bring this code to life:</p><ol><li>Extending support from single-strings to string arrays with many values. The naive way to do this is to call the compression/decompression kernels in a loop. A more advanced variant would compress the entire array range as a single mega-string to avoid branching.</li><li>Training the symbol table on a whole array forces us to compress the full-size array 5 times, which is slow. Instead, we choose a small fixed-size sample of 16KB, drawn as 512B chunks sampled uniformly at random across all elements of the array. Both 16KB and 512 were chose empirically by the authors as good tradeoffs between locality (longer runs are more realistic representations of the source) and performance (getting a diverse enough sample to train a table that compresses the whole array well).</li><li>The authors of the paper implemented an AVX-512 compression kernel, which we have not implemented in the Rust code but can lead to better performance over the scalar variant. You can learn more about their ‚Äúmeatgrinder‚Äù in Section 5 of the paper.</li></ol><h3 id="closing-thoughts">Closing thoughts</h3><p>For all the ink spilled in this post, there&#39;s still so much we didn&#39;t get to cover. For that, we encourage you to read <a href="https://www.vldb.org/pvldb/vol13/p2649-boncz.pdf?ref=blog.spiraldb.com">the paper</a> as well as the <a href="https://github.com/spiraldb/fsst?ref=blog.spiraldb.com">Rust code</a> for more details on the specific tricks needed to make the codec fast enough for use.</p><p>We believe that FSST is a great building block for working with string data, and providing a good wrapper around its power brings us closer to achieving our goal of making Vortex the absolute best way to build data-intensive applications. We‚Äôre building in the open, so if you‚Äôre interested in following along on the journey, be sure to <a href="https://github.com/spiraldb/vortex/?ref=blog.spiraldb.com">check us out on GitHub</a>!</p>
        </section>

    </article>


</div></div>
  </body>
</html>
