<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.trailofbits.com/2024/08/21/yolo-is-not-a-valid-hash-construction/">Original</a>
    <h1>&#34;YOLO&#34; is not a valid hash construction</h1>
    
    <div id="readability-page-1" class="page"><article id="post-107981">
	<!-- .entry-header -->

	<div>
		<p><em>By Opal Wright</em></p>
<p>Among the cryptographic missteps we see at Trail of Bits, “let’s build our own tool out of a hash function” is one of the most common. Clients have a problem along the lines of “we need to hash a bunch of different values together” or “we need a MAC” or “we need a key derivation function for passwords,” and the closest tool at hand is a hash function.</p>
<p>These needs are often met with what could be called “YOLO” constructions: <em>ad-hoc</em> functions that “solve” the instant problem in a way that’s obvious, straightforward, and usually wrong.</p>
<p>The fact is, these problems are harder than they seem. For us, it can be frustrating to see home-rolled solutions over and over in the products clients bring us because the problems have already been solved. So let’s discuss a few of the YOLO constructions we frequently see, what’s wrong with them, and what to do instead.</p>
<h3>YoloMultiHash</h3>
<p>This is the most common YOLO construction we see at Trail of Bits. Clients often use this when they have complex data structures or arrays of values and need to turn them into a Fiat-Shamir transcript.</p>
<h4>The YOLO construction</h4>
<p>Given a hash function <em>H</em> and a set of messages <em>M̂ = {M</em><sub>1</sub><em>,M</em><sub>2</sub><em>,…,M<sub>n</sub>}</em>, select a separator string <em>S</em>, and compute <em>YoloMultiHash(M̂) = H(M</em><sub>1</sub>‖<em>S</em>‖<em>M</em><sub>2</sub>‖<em>S</em>‖<em>…</em>‖<em>S</em>‖<em>M<sub>n</sub>)</em>.</p>
<h4>The problem</h4>
<p>The issue we run into here is <em>ambiguous encoding</em>.</p>
<p>What happens if the messages can contain the separator <em>S</em> as a substring? Suppose the message <em>M<sub>i</sub></em> contains <em>S</em> as a substring. Split <em>M<sub>i</sub></em> into <em>M<sub>i</sub> = M′</em><em><sub>i</sub></em>‖<em>S</em>‖<em> M′′<sub>i</sub></em> and define <em>M̃ = {M</em><sub>1</sub><em>,…,M′<sub>i</sub>,M′′<sub>i</sub>,…,M<sub>n</sub>}</em>. Then we have <em>YoloMultiHash(M̂) = YoloMultiHash(M̃)</em>. That’s two semantically distinct inputs that lead to the same hash value. This is akin to breaking the collision resistance requirement of a good hash function, which is a <em>Very Bad Thing</em> (<sup>tm</sup>).</p>
<p>This is not a hypothetical issue, either: <a href="https://www.verichains.io/tsshock/">it has been used to break the security of widely used libraries</a>.</p>
<h4>The better options</h4>
<p>Instead of using YoloMultiHash, use a function that’s designed for hashing multiple independent values into a single result. The most well-known example of this would be TupleHash, defined in <a href="https://www.nist.gov/publications/sha-3-derived-functions-cshake-kmac-tuplehash-and-parallelhash">SP800-185</a>. Several other hash functions support or make it easy to support similar functionality; the <a href="https://github.com/BLAKE3-team/BLAKE3">BLAKE3</a> specification, for instance, describes the process for creating “stateful hash objects” that can be used this way.</p>
<p>Alternatively, <em>get better at serializing your data</em>. If you’re trying to serialize a data structure, there are great options like <a href="https://protobuf.dev/">Protocol Buffers</a>, <a href="https://cbor.io/">CBOR</a>, and <a href="https://github.com/diem/bcs">BCS</a>. These all produce unambiguous encodings of your data, meaning that structures with different values won’t lead to the same hash input. As a rule of thumb, if you’re feeding structured data into a hash function, it should be in a format that can be converted losslessly back into the original data structure.</p>
<p>(Note that, while many serialization methods will create <em>unambiguous</em> encodings, they don’t all necessarily produce <em>unique</em> encodings. For instance, JSON is largely insensitive to changes in whitespace and element ordering, so using JSON serializations produced by different libraries could lead to different hashes. Be careful!)</p>
<h3>YoloMAC</h3>
<h4>The YOLO construction</h4>
<p>Given a key <em>K</em> and a message <em>M</em>, compute <em>YoloMAC(K,M) = H(K</em>‖<em>M)</em>. Sometimes folks will throw in a salt value or customization string <em>S</em> to let them do domain separation—something like <em>YoloMAC(K,M,S) = H(K</em>‖<em>S</em>‖<em>M)</em>. It doesn’t really change the nature of the attacks below, so we’re just going to go with the simplified version here.</p>
<h4>The first problem</h4>
<p>The first problem with YoloMAC is well-known: length-extension attacks. If <em>H</em> is a Merkle-Damgård hash algorithm, as SHA256 is, then given <em>H(M)</em>, an attacker can compute <em>H(M</em>‖<em>X)</em> for any <em>X</em> the attacker chooses. That means that, given <em>YoloMAC(K,M) = H(K</em>‖<em>M)</em>, an attacker can compute <em>YoloMAC(K,M</em>‖<em>X)</em>, without knowing <em>K</em> or even <em>M</em>.</p>
<p>This may sound silly, but if you have a message that’s being protected using an encrypt-then-MAC construction, using YoloMAC is a real problem. An attacker can append garbage data to the plaintext, updating the MAC to match. Depending on the underlying format, some parsers will attempt to process the garbage data. This can cause messages not to load correctly, crash parsers, or possibly leak timing information that allows an attacker to learn about how the message is being processed.</p>
<h4>The second problem</h4>
<p>The second problem is similar to the problem with YoloMultiHash: ambiguous encoding. This issue applies whether or not the hash function is susceptible to length extension attacks, so using SHA3 or Skein or BLAKE3 won’t save you here.</p>
<p>Say you have a message <em>M</em> and a 256-bit key <em>K = K1</em>‖<em>K2</em>, where <em>K1</em> and <em>K2</em> are 128 bits each. Let’s suppose we compute <em>C1 = YoloMAC(K,M) = H(K1</em>‖<em>K2</em>‖<em>M)</em>.</p>
<p>Now let’s define <em>M′ = K</em><sub>2</sub>‖<em>M</em> and compute our MAC using K<sub>1</sub> as our key: <em>C</em><sub>2</sub><em> = YoloMAC(K</em><sub>1</sub><em>,M′) = H(K</em><sub>1</sub>‖<em>M′)=H(K</em><sub>1</sub>‖<em>K</em><sub>2</sub>‖<em>M) = C</em><sub>1</sub>. We’ve just found two different message/key pairs that produce the same MAC.</p>
<p>Depending on the flexibility of the underlying file formats, this flexibility could allow Alice to produce a “root” message <em>M̃</em> and 128-bit deniability key <em>K̃</em> such that <em>M̃</em> parses as a valid PDF file that incriminates Bob in some sort of conspiracy with Alice, but K̃‖M̃ parses as an innocuous JPG file. Alice can negotiate a 128-bit MAC key <em>K</em> with Bob, compute <em>V = YoloMAC(K,K̃</em>‖<em>M̃)</em>, and send <em>V</em> and <em>K̃</em>‖<em>M̃</em> to Bob. Bob validates <em>V</em> and recovers the innocuous JPG file.</p>
<p>Alice contacts the authorities and provides them with convincing records that she sent a message to Bob with MAC <em>V</em>, then provides them with the key <em>K′ = K</em>‖<em>K̃</em> and message <em>M̃</em>. When the authorities check the authenticity of the incriminating PDF, they see that, in fact, <em>YoloMAC(K</em>‖<em>K̃,M̃)</em> matches the <em>V</em> provided by Alice.</p>
<p>This isn’t a pie-in-the-sky model: practical attacks have been demonstrated using a similar issue with <a href="https://eprint.iacr.org/2019/016.pdf">AES-GCM tags</a>.</p>
<p>This problem is particularly common in the case of Keccak, since <a href="https://keccak.team/keccak_strengths.html">the Keccak website says</a>:</p>
<blockquote><p>Unlike SHA-1 and SHA-2, Keccak does not have the length-extension weakness, hence does not need the HMAC nested construction. Instead, MAC computation can be performed by simply prepending the message with the key.</p></blockquote>
<p>While Keccak doesn’t suffer from the length-extension attacks that HMAC is meant to address, the phrase “simply prepending the message with the key” carries a lot of assumptions about key length and key formatting with it.</p>
<h4>The better options</h4>
<p>Use HMAC, KMAC, or built-in tools, depending on your hash function.</p>
<p>If you’re using the SHA2 class of hashes (SHA256/384/512/etc.), you <em>need</em> to use HMAC; its design specifically sidesteps length extension attacks. HMAC has been around since the late 1990s; this problem has been solved for a quarter century now. It’s supported in every major cryptographic library. Python even includes it in their <a href="https://docs.python.org/3/library/hmac.html">standard library</a>. There’s no good reason to be rolling your own solution to this problem.</p>
<p>If you’re using SHA3, use KMAC. KMAC was formalized in 2016, and lots of SHA3 libraries already support it. KMAC also has several useful features:</p>
<ul>
<li>It can be used in XOF mode, which is useful in some situations where MACs are also used as masks for sensitive values.</li>
<li>When not used as an XOF, the output length is <em>integrated</em> into the MAC calculation, so a 192-bit MAC is not just the truncation of a 256-bit MAC.</li>
<li>It includes customization strings for easy domain separation.</li>
</ul>
<p>SHA3 is a valid hash function to use with HMAC, but KMAC is faster and more flexible than HMAC-SHA3.</p>
<p>If you’re using BLAKE2 or BLAKE3, there’s already a keyed hashing mode built into the algorithm that you should use. As with SHA3, you can use BLAKE2/BLAKE3 with HMAC, but the keyed hashing approach will offer better performance.</p>
<h3>YoloPBKDF</h3>
<h4>The YOLO construction</h4>
<p>Given a password <em>P</em> and a salt <em>S</em>, compute <em>K = YoloPBKDF(S,P) = H(S</em>‖<em>P)</em>. Or maybe use <em>H(P</em>‖<em>S)</em> if that boats your float. This key is now suitable for use in cryptographic contexts. Easy-peasy!</p>
<p>If you want to make it <em>really</em> secure, just iterate a bunch of times: set <em>K</em><sub>0</sub><em> = P</em> and compute <em>YoloPBKDF<sub>i</sub>(S,P) = K<sub>i</sub></em>, where <em>K<sub>i</sub> = H(S</em>‖<em>K<sub>i-</sub></em><sub>1</sub><em>)</em>.</p>
<h4>The problems</h4>
<p>At this point, you may be thinking, “Oh, I’ve caught the pattern! It’s an ambiguous encoding!”</p>
<p>And maybe that’s an issue, but that’s not even on the map as a problem in this case.</p>
<p>Finding good ways to derive cryptographic keys from passwords is hard. Really hard. Like, “<a href="https://www.password-hashing.net/">multi-year international standardization effort</a>” hard. And that’s because converting a password into a key needs to be easy for the person who knows the password, but an absolute nightmare for anybody who doesn’t know it. Cryptography papers discussing how to crack keys generated by YoloPBKDF are practically their own genre: how to optimize hash software for the job, how to build custom hardware to do password cracking, how to cache data in tables for time-memory trade-offs, how to accelerate cracking efforts with graphics cards, how to model password selection, etc. YoloPBKDF isn’t just known to be insecure; cryptologists have been dunking on it for a couple decades at this point.</p>
<p>…yet it still shows up in our security reviews.</p>
<p>For a few bucks an hour, Mallory can rent <a href="https://aws.amazon.com/ec2/instance-types/p3/">AWS instances</a> that use GPUs to test hundreds of billions of YoloPBKDF password candidates per second. The memory overhead is negligible: for each password being attacked, there’s just the salt, the hash state, and the password currently being checked. Attacks scale linearly with processor speed and the number of processors available: if Mallory wants to speed up her computations, she can add extra instances, or switch to higher-performance CPUs and GPUs when they become available.</p>
<p>On Alice’s side, her ability to thwart Mallory is only linear: if she switches from <em>YoloPBKDF<sub>t</sub>(S,P)</em> to <em>YoloPBKDF</em><sub>10</sub><em><sub>t</sub>(S,P)</em>, then Mallory only has to spend about 10 times as much to attack Alice’s passwords at the same rate. If Alice wants to reduce Mallory’s ability to attack her passwords by a factor of a million, then deriving her keys takes a million times as long, which can impose a significant delay for Alice—especially if she mistypes her password.</p>
<p>To give Alice more of an advantage, modern password KDFs impose not only a processing requirement, but also a <em>memory</em> requirement. If you want to derive a key from a password, you’ll need to generate a large array of values in memory, then perform a specific calculation on those values in order to produce the final value.</p>
<p>This memory requirement tips the scales in Alice’s favor. A modern computer has gigabytes of memory, but even a small memory requirement can impose major limitations on Mallory’s ability to do parallel key derivations, requiring her to read and write memory faster than her computer(s) can handle, or placing limits on how many passwords she can test at one time.</p>
<p>For instance, the <a href="https://www.rfc-editor.org/rfc/rfc9106.html#name-parameter-choice">Argon2d RFC</a> includes a recommended parameter set that imposes a 64-megabyte memory requirement. Suppose Alice derives a key under these parameters. If Alice is deriving her key on a typical laptop with 8 GiB of RAM, 64 MiB is 0.8% of her memory. Alice is using remarkably little in terms of her resources. On the other hand, if Mallory wants to attack Alice’s key by checking a million passwords per second, she’ll need to generate and process 64 <em>terabytes</em> of data every second.</p>
<p>Alice won’t even notice the additional resources needed to generate a key from her password using a memory-hard function, but Mallory now has to marshal incredible resources in order to gain a <em>fraction</em> of the speed she would have if Alice had used YoloPBKDF.</p>
<h4>The better options</h4>
<p>Use a modern password KDF. The <a href="https://github.com/P-H-C/phc-winner-argon2">Argon2 family of functions</a> is great, as is <a href="https://datatracker.ietf.org/doc/html/rfc7914">scrypt</a>. Either one of them will do the job just fine, and libraries for both are widely available for multiple languages. For folks operating in the FIPS world, doing this can be difficult. NISTSP800-63-3 states the following:</p>
<blockquote><p>Examples of suitable key derivation functions include Password-based Key Derivation Function 2 (PBKDF2) and Balloon. A memory-hard function SHOULD be used because it increases the cost of an attack.</p></blockquote>
<p>Balloon has not been approved by NIST, though PBKDF2, which is not memory-hard, has been approved. If you want to make sure you can point to a NIST-approved function, you can use a memory-hard password KDF like Balloon or Argon2 to generate a key <em>K</em><sub>1</sub> from the password and salt, use PBKDF2 to generate a key <em>K</em><sub>2</sub> from the password and salt, and finally use a FIPS-approved function like HKDF to combine them into a final key <em>K = HKDF(K</em><sub>1</sub>‖<em>K</em><sub>2</sub><em>)</em>.</p>
<h3>Summing up</h3>
<p>If you’re not already locked into a hash function, take some time to consider <em>all</em> the ways you’ll be using a hash function, and let that guide you. Newer hash designs are built with cool ideas like multihash and MACs in mind, and if there’s no need to reinvent the wheel, <em>don’t</em>. BLAKE2 and BLAKE3 natively support keyed hashing and MACs, and KMAC is supported in many SHA3 libraries. TupleHash is usually implemented alongside KMAC, and BLAKE2 can be readily adapted for multihashing.</p>
<p>Whatever you need to do with a hash function, you’re probably not the first to need it. A <em>lot</em> of research has been done in this area, and it’s worth putting in the time and effort to find vetted, well-studied solutions to your problems rather than inventing your own.</p>

			</div><!-- .entry-content -->

	
</article></div>
  </body>
</html>
