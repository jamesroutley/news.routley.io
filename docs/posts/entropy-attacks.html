<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.cr.yp.to/20140205-entropy.html">Original</a>
    <h1>Entropy Attacks</h1>
    
    <div id="readability-page-1" class="page">

<hr/>
<div>

<details><summary>Table of contents (Access-I for index page)</summary>
<table>
<tbody><tr><td><a href="https://blog.cr.yp.to/20250118-flight.html"><b>2025.01.18: As expensive as a plane flight:</b></a> <span>Looking at some claims that quantum computers won&#39;t work. #quantum #energy #variables #errors #rsa #secrecy</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20241028-surveillance.html"><b>2024.10.28: The sins of the 90s:</b></a> <span>Questioning a puzzling claim about mass surveillance. #attackers #governments #corporations #surveillance #cryptowars</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20240803-clang.html"><b>2024.08.03: Clang vs. Clang:</b></a> <span>You&#39;re making Clang angry. You wouldn&#39;t like Clang when it&#39;s angry. #compilers #optimization #bugs #timing #security #codescans</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20240612-bibkeys.html"><b>2024.06.12: Bibliography keys:</b></a> <span>It&#39;s as easy as [1], [2], [3]. #bibliographies #citations #bibtex #votemanipulation #paperwriting</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20240102-hybrid.html"><b>2024.01.02: Double encryption:</b></a> <span>Analyzing the NSA/GCHQ arguments against hybrids. #nsa #quantification #risks #complexity #costs</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20231125-kyber.html"><b>2023.11.25: Another way to botch the security analysis of Kyber-512:</b></a> <span>Responding to a recent blog post. #nist #uncertainty #errorbars #quantification</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20231023-clumping.html"><b>2023.10.23: Reducing &#34;gate&#34; counts for Kyber-512:</b></a> <span>Two algorithm analyses, from first principles, contradicting NIST&#39;s calculation. #xor #popcount #gates #memory #clumping</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20231003-countcorrectly.html"><b>2023.10.03: The inability to count correctly:</b></a> <span>Debunking NIST&#39;s calculation of the Kyber-512 security level. #nist #addition #multiplication #ntru #kyber #fiasco</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20230609-turboboost.html"><b>2023.06.09: Turbo Boost:</b></a> <span>How to perpetuate security problems. #overclocking #performancehype #power #timing #hertzbleed #riskmanagement #environment</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20220805-nsa.html"><b>2022.08.05: NSA, NIST, and post-quantum cryptography:</b></a> <span>Announcing my second lawsuit against the U.S. government. #nsa #nist #des #dsa #dualec #sigintenablingproject #nistpqc #foia</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20220129-plagiarism.html"><b>2022.01.29: Plagiarism as a patent amplifier:</b></a> <span>Understanding the delayed rollout of post-quantum cryptography. #pqcrypto #patents #ntru #lpr #ding #peikert #newhope</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20201206-msword.html"><b>2020.12.06: Optimizing for the wrong metric, part 1: Microsoft Word:</b></a> <span>Review of &#34;An Efficiency Comparison of Document Preparation Systems Used in Academic Research and Development&#34; by Knauff and Nejasmic. #latex #word #efficiency #metrics</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20191024-eddsa.html"><b>2019.10.24: Why EdDSA held up better than ECDSA against Minerva:</b></a> <span>Cryptosystem designers successfully predicting, and protecting against, implementation failures. #ecdsa #eddsa #hnp #lwe #bleichenbacher #bkw</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20190430-vectorize.html"><b>2019.04.30: An introduction to vectorization:</b></a> <span>Understanding one of the most important changes in the high-speed-software ecosystem. #vectorization #sse #avx #avx512 #antivectors</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20171105-infineon.html"><b>2017.11.05: Reconstructing ROCA:</b></a> <span>A case study of how quickly an attack can be developed from a limited disclosure. #infineon #roca #rsa</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20171017-collisions.html"><b>2017.10.17: Quantum algorithms to find collisions:</b></a> <span>Analysis of several algorithms for the collision problem, and for the related multi-target preimage problem. #collision #preimage #pqcrypto</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20170723-random.html"><b>2017.07.23: Fast-key-erasure random-number generators:</b></a> <span>An effort to clean up several messes simultaneously. #rng #forwardsecrecy #urandom #cascade #hmac #rekeying #proofs</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20170719-pqbench.html"><b>2017.07.19: Benchmarking post-quantum cryptography:</b></a> <span>News regarding the SUPERCOP benchmarking system, and more recommendations to NIST. #benchmarking #supercop #nist #pqcrypto</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20161030-pqnist.html"><b>2016.10.30: Some challenges in post-quantum standardization:</b></a> <span>My comments to NIST on the first draft of their call for submissions. #standardization #nist #pqcrypto</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20160607-dueprocess.html"><b>2016.06.07: The death of due process:</b></a> <span>A few notes on technology-fueled normalization of lynch mobs targeting both the accuser and the accused. #ethics #crime #punishment</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20160516-quantum.html"><b>2016.05.16: Security fraud in Europe&#39;s &#34;Quantum Manifesto&#34;:</b></a> <span>How quantum cryptographers are stealing a quarter of a billion Euros from the European Commission. #qkd #quantumcrypto #quantummanifesto</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20160315-jefferson.html"><b>2016.03.15: Thomas Jefferson and Apple versus the FBI:</b></a> <span>Can the government censor how-to books? What if some of the readers are criminals? What if the books can be understood by a computer? An introduction to freedom of speech for software publishers. #censorship #firstamendment #instructions #software #encryption</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20151120-batchattacks.html"><b>2015.11.20: Break a dozen secret keys, get a million more for free:</b></a> <span>Batch attacks are often much more cost-effective than single-target attacks. #batching #economics #keysizes #aes #ecc #rsa #dh #logjam</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20150314-optimizing.html"><b>2015.03.14: The death of optimizing compilers:</b></a> <span>Abstract of my tutorial at ETAPS 2015. #etaps #compilers #cpuevolution #hotspots #optimization #domainspecific #returnofthejedi</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20150218-printing.html"><b>2015.02.18: Follow-You Printing:</b></a> <span>How Equitrac&#39;s marketing department misrepresents and interferes with your work. #equitrac #followyouprinting #dilbert #officespaceprinter</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20140602-saber.html"><b>2014.06.02: The Saber cluster:</b></a> <span>How we built a cluster capable of computing 3000000000000000000000 multiplications per year for just 50000 EUR. #nvidia #linux #howto</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20140517-insns.html"><b>2014.05.17: Some small suggestions for the Intel instruction set:</b></a> <span>Low-cost changes to CPU architecture would make cryptography much safer and much faster. #constanttimecommitment #vmul53 #vcarry #pipelinedocumentation</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20140411-nist.html"><b>2014.04.11: NIST&#39;s cryptographic standardization process:</b></a> <span>The first step towards improvement is to admit previous failures. #standardization #nist #des #dsa #dualec #nsa</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20140323-ecdsa.html"><b>2014.03.23: How to design an elliptic-curve signature system:</b></a> <span>There are many choices of elliptic-curve signature systems. The standard choice, ECDSA, is reasonable if you don&#39;t care about simplicity, speed, and security. #signatures #ecc #elgamal #schnorr #ecdsa #eddsa #ed25519</span></td></tr>
<tr><td><a href="https://blog.cr.yp.to/20140213-ideal.html"><b>2014.02.13: A subfield-logarithm attack against ideal lattices:</b></a> <span>Computational algebraic number theory tackles lattice-based cryptography.</span></td></tr>
<tr><td><b>2014.02.05: Entropy Attacks!</b> The conventional wisdom says that hash outputs can&#39;t be controlled; the conventional wisdom is simply wrong.</td></tr>
</tbody></table></details></div><hr/>
<h2>2014.02.05: Entropy Attacks! <span>The conventional wisdom says that hash outputs can&#39;t be controlled; the conventional wisdom is simply wrong.</span></h2>
<p>
The conventional wisdom is that hashing more entropy sources can&#39;t hurt:
if H is any modern cryptographic hash function then H(x,y,z) is at least
as good a random number as H(x,y), no matter how awful z is. So we pile
one source on top of another, hashing them all together and hoping that
at least one of them is good.
</p>
<p>
But what if z comes from a malicious source that can snoop on x and y?
For example, imagine a malicious &#34;secure randomness&#34; USB device that&#39;s
actually spying on all your other randomness sources through various
side channels, or—worse—imagine RDRAND microcode that&#39;s looking at
the randomness pool that it&#39;s about to be hashed into. I should note
that none of the attacks described below rely on tampering with x or y,
or otherwise modifying data outside the malicious entropy source; you
can&#39;t stop these attacks by double-checking the integrity of data.
</p>
<p>
Of course, the malicious device will also be able to see other sensitive
information, not just x and y. But this doesn&#39;t mean that it&#39;s cheap for
the attacker to exfiltrate this information! The attacker needs to find
a communication channel out of the spying device. Randomness generation
influenced by the device is a particularly attractive choice of channel,
as I&#39;ll explain below.
</p>
<p>
Here&#39;s an interesting example of an attack that can be carried out by
this malicious source:
</p>
<ol>
<li>Generate a random r.
</li><li>Try computing H(x,y,r).
</li><li>If H(x,y,r) doesn&#39;t start with bits 0000, go back to step 1.
</li><li>Output r as z.
</li></ol>
<p>
This attack forces H(x,y,z) to start 0000, even if x and y were
perfectly random. It&#39;s fast, taking just 16 computations of H on
average.
</p>
<p>
Maybe the randomness generator doesn&#39;t actually output H(x,y,z); it uses
H(x,y,z) as a seed for some generator G, and outputs G(H(x,y,z)). Okay:
the attacker changes H to G(H), and again forces the output G(H(x,y,z))
to start 0000. Similarly, the attack isn&#39;t stopped by pre-hashing of the
entropy source before it&#39;s mixed with other entropy sources. Every mix
from the malicious entropy source lets the attacker produce another
&#34;random&#34; number that starts 0000.
</p>
<p>
More generally, instead of producing &#34;random&#34; numbers that start with
0000, 0000, 0000, etc., the malicious entropy source can produce
&#34;random&#34; numbers that start with successive 4-bit components of
AES<sub>k</sub>(0),AES<sub>k</sub>(1),... where k is a secret key known only to the
attacker. Nobody other than the attacker will be able to detect this
pattern.
</p>
<p>
Recall that DSA and ECDSA require random &#34;nonces&#34; for signatures. It&#39;s
easy to imagine someone grabbing each nonce as a new &#34;random&#34; number
from the system&#39;s randomness generator. However, it&#39;s well known
(see, e.g., 
<a href="https://www.isg.rhul.ac.uk/~sdg/igor-slides.pdf">https://www.isg.rhul.ac.uk/~sdg/igor-slides.pdf</a>)
that an attacker
who can predict the first 4 bits of each nonce can quickly compute the
user&#39;s secret key after a rather small number of signatures. Evidently
hashing an extra entropy source <i>does</i> hurt—in the worst possible way;
the attacker has the user&#39;s secret key!—contrary to the conventional
wisdom stated above.
</p>
<p>
EdDSA
(see 
<a href="https://ed25519.cr.yp.to">https://ed25519.cr.yp.to</a>)
is different. It uses randomness
once to generate a secret key and is then completely deterministic in
its signature generation (following 1997 Barwood, 1997 Wigley, et al.).
The malicious entropy source can still control 4 bits of the secret key,
speeding up discrete-log attacks by a factor of 4, but this isn&#39;t a
problem—we use curves with ample security margins. The source can
increase the 4 bits by carrying out exponentially more H computations,
but this has to fit into the time available after inspecting x and y and
before generating a &#34;random&#34; number.
</p>
<p>
Of course, there are many other uses of randomness in cryptography: for
example, if you want forward secrecy then you&#39;re constantly generating
new ECDH keys. Controlling 4 bits of each secret key isn&#39;t nearly as
damaging as controlling 4 bits of DSA/ECDSA nonces—it&#39;s the same
factor of 4 mentioned above—but, as I mentioned above, the malicious
entropy source can also use randomness generation as a communication
channel to the attacker. For example, the source controls the low bit of
each <i>public</i> key with an average cost of just 2 public-key generations,
and uses the concatenation of these low bits across public keys to
communicate an encryption of the user&#39;s long-term key. This channel is
undetectable, reasonably high bandwidth, and reasonably low cost.
</p>
<p>
On the other hand, there&#39;s no actual need for this huge pile of random
numbers. If you&#39;ve somehow managed to generate one secure 256-bit key
then from that key you can derive all the &#34;random&#34; numbers you&#39;ll ever
need for every cryptographic protocol—and you can do this derivation
in a completely deterministic, auditable, testable way, as illustrated
by EdDSA. (If you <i>haven&#39;t</i> managed to generate one secure 256-bit key
then you have much bigger problems.)
</p>
<p>
With this as-deterministic-as-possible approach, the entire influence of
the malicious entropy source is limited to controlling a few &#34;random&#34;
bits somewhere. There are at least two obvious ways to further reduce
this control:
</p>
<ul>
<li>Read less-likely-to-be-malicious entropy sources <i>after</i> completing
     all reading of the more-likely-to-be-malicious entropy sources. Of
     course, this doesn&#39;t help if the last source turns out to be
     malicious.
</li><li>Increase the amount of processing, memory, etc. involved in H—as
     in hashcash, proofs of work in general, password hashing, etc. The
     costs are negligible, since all of this is done only once.
</li></ul>
<p>
Let me emphasize that what I&#39;m advocating here, for security reasons, is
a sharp transition between
</p>
<ul>
<li>before crypto: the whole system collecting enough entropy;
</li><li>after: the system using purely deterministic cryptography, never
     adding any more entropy.
</li></ul>
<p>
This is exactly the opposite of what people tend to do today, namely
adding new entropy all the time. The reason that new entropy is a
problem is that each addition of entropy is a new opportunity for a
malicious entropy source to control &#34;random&#34; outputs—breaking DSA,
leaking secret keys, etc. The conventional wisdom says that hash outputs
can&#39;t be controlled; the conventional wisdom is simply wrong.
</p>
<p>
(There are some special entropy sources for which this argument doesn&#39;t
apply. For example, an attacker can&#39;t exert any serious control over the
content of my keystrokes while I&#39;m logged in; I don&#39;t see how hashing
this particular content into my laptop&#39;s entropy pool can allow any
attacks. But I also don&#39;t see how it helps.)
</p>
<p>
Is there any serious argument that adding new entropy all the time is a
good thing? The Linux /dev/urandom manual page claims that without new
entropy the user is &#34;theoretically vulnerable to a cryptographic
attack&#34;, but (as I&#39;ve mentioned in various venues) this is a ludicrous
argument—how can anyone simultaneously believe that
</p>
<ul>
<li>we can&#39;t figure out how to deterministically expand one 256-bit
       secret into an endless stream of unpredictable keys (this is what
       we need from urandom), but
</li><li>we <i>can</i> figure out how to use a single key to safely encrypt
       many messages (this is what we need from SSL, PGP, etc.)?
</li></ul>
<p>
There are also people asserting that it&#39;s important for RNGs to provide
&#34;prediction resistance&#34; against attackers who, once upon a time, saw the
entire RNG state. But if the attacker sees the RNG state that was used
to generate your long-term SSL keys, long-term PGP keys, etc., then what
exactly are we gaining by coming up with unpredictable random numbers in
the future? I&#39;m reminded of a Mark Twain quote:
</p>
<blockquote>
   Behold, the fool saith, &#34;Put not all thine eggs in the one basket&#34;—which
   is but a manner of saying, &#34;Scatter your money and your
   attention;&#34; but the wise man saith, &#34;Put all your eggs in the one
   basket and—WATCH THAT BASKET.&#34;
</blockquote>
<p>
We obviously need systems that can maintain confidentiality of our
long-term keys. If we have such systems, how is the attacker supposed to
ever see the RNG state in the first place? Maybe &#34;prediction resistance&#34;
can be given a theoretical definition for an isolated RNG system, but I
don&#39;t see how it makes any sense for a complete cryptographic system.
</p>
<p>
[Advertisement: If you&#39;re interested in these topics,
you might want to join the
<a href="https://groups.google.com/group/randomness-generation">randomness-generation</a>
mailing list;
I sent this there a few days ago.
To subscribe, send email to
<a href="mailto:randomness-generation+subscribe@googlegroups.com">randomness-generation+subscribe@googlegroups.com</a>.
There&#39;s also a mailing list cleverly named
<a href="https://mailarchive.ietf.org/arch/browse/dsfjdssdfsd/">dsfjdssdfsd</a>
for discussion of randomness in IETF protocols.
Randomness is also a frequent topic on more general cryptographic mailing lists.]
</p>
<p>
[2022.01.09 update: Updated links above.]
</p>
<p>
[2023.03.17 update:
I should note related work from 2006, namely
Section 3.2 of
<a href="https://github.com/thomasbiege/papers/raw/master/random-device-analysis.pdf">&#34;Analysis of a strong pseudo random number generator&#34;</a>
by Thomas Biege.
The 2006 paper and this blog post are both
analyzing what a malicious entropy source can do.
After that setup,
the 2006 work is explaining
how a linear hash function
gives a malicious entropy source full control over outputs,
whereas this blog post
is explaining how a modern cryptographic hash function
gives a malicious entropy source partial control over outputs.]
</p>
<hr/><SPAN size="1"><b>Version:</b>
This is version 2023.03.17 of the 20140205-entropy.html web page.
</SPAN>

</div>
  </body>
</html>
