<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://k-monk.org/blog/ocaml-module-introduction/">Original</a>
    <h1>Introduction to the OCaml Module System</h1>
    
    <div id="readability-page-1" class="page"><div>
      

<p><strong>2024-09-10</strong></p>
<p>I got a request from the OCaml group at the <a rel="noopener" target="_blank" href="https://www.recurse.com/">Recurse Center</a> to go over modules and functors this week. Here are the notes I prepared. We&#39;ll be using Jane Street&#39;s <a rel="noopener" target="_blank" href="https://opensource.janestreet.com/core/">Core</a> standard library replacement throughout.</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>open </span><span>Core
</span></code></pre>
<h3 id="signatures-as-interfaces">Signatures as Interfaces</h3>
<p>A module is a collection of definitions. A signature (alternatively &#34;interface&#34;) is a specification of a module. Signatures are to modules as types are to values -- they are static specifications of behaviour.</p>
<p>The essence of signatures and modules is information hiding. Signatures allow the programmer to constrain the interface that must be agreed upon by two bodies of code (the module providing the interface and the module consuming the interface). The word &#34;constrain&#34; may sound negative, but this is a good thing! It gives us freedom to modify a module with confidence that our changes will not affect the rest of the program in ways we don&#39;t intend them to.</p>
<p>The relationship between modules and signatures is many-to-many: (infinitely) many modules may satisfy a given signature, and many signatures may be satisfied by a given module.</p>
<p>Suppose we want to write a program that makes use of the mathematical notion of a finite set. We might write the following signature.</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>module type </span><span>SET </span><span>= sig
</span><span>
</span><span>  </span><span>type &#39;a set
</span><span>
</span><span>  </span><span>(* create a singleton set *)
</span><span>  </span><span>val </span><span>singleton </span><span>: </span><span>&#39;a </span><span>-&gt; </span><span>&#39;a set
</span><span>
</span><span>  </span><span>(* create the set of all elements in a list *)
</span><span>  </span><span>val </span><span>of_list </span><span>: </span><span>&#39;a list </span><span>-&gt; </span><span>&#39;a set
</span><span>
</span><span>  </span><span>(* take the union of two sets *)
</span><span>  </span><span>val </span><span>union </span><span>: </span><span>&#39;a set </span><span>-&gt; </span><span>&#39;a set </span><span>-&gt; </span><span>&#39;a set
</span><span>
</span><span>  </span><span>(* take the difference of two sets *)
</span><span>  </span><span>val </span><span>difference </span><span>: </span><span>&#39;a set </span><span>-&gt; </span><span>&#39;a set </span><span>-&gt; </span><span>&#39;a set
</span><span>
</span><span>  </span><span>(* further operations omitted for the sake of brevity *)
</span><span>
</span><span>end
</span></code></pre>
<p>The type <code>set</code> is abstract. You can read <code>type &#39;a set</code> as a claim that &#34;the module will define a type (parametric in one variable) named set&#34;, without actually saying what that type is.</p>
<p>Here is a possible implementation of our <code>SET</code> interface.</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>module </span><span>SetModule </span><span>= struct
</span><span>
</span><span>  </span><span>type &#39;a set </span><span>= </span><span>&#39;a list
</span><span>
</span><span>  </span><span>(* Yes, polymorphic equality is controversial! We will get to that later. *)
</span><span>  </span><span>let </span><span>eq </span><span>= </span><span>Stdlib.(</span><span>=</span><span>)
</span><span>
</span><span>  </span><span>let rec </span><span>union </span><span>left </span><span>= function
</span><span>    </span><span>| </span><span>[] </span><span>-&gt; left
</span><span>    </span><span>| </span><span>x :: xs -&gt;
</span><span>        </span><span>if </span><span>List.exists left ~f:(eq x)
</span><span>        </span><span>then</span><span> union left xs
</span><span>        </span><span>else</span><span> union (x :: left) xs
</span><span>
</span><span>  </span><span>let </span><span>of_list </span><span>l </span><span>=
</span><span>    union </span><span>[]</span><span> l
</span><span>
</span><span>  </span><span>let </span><span>singleton </span><span>a </span><span>= </span><span>[ a ]
</span><span>
</span><span>  </span><span>let </span><span>difference </span><span>left right </span><span>=
</span><span>    </span><span>let </span><span>filter </span><span>a </span><span>= not </span><span>(List.exists right ~f:(eq a)) </span><span>in
</span><span>    List.filter left ~f:filter
</span><span>
</span><span>end
</span></code></pre>
<p>We may refer to names bound in the current module without an explicit qualifier. For example, in the definition of <code>union</code>, we reference <code>eq</code> without a prefix.</p>
<p>Because we didn&#39;t specify a signature for <code>SetModule</code>, all top level definitions are exposed by default. If we were to instead give it a signature...</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>module </span><span>Set </span><span>: </span><span>SET </span><span>= </span><span>SetModule
</span></code></pre>
<p>then only those values in the signature will be exposed. In this case, for example, <code>eq</code> would be hidden.</p>
<h3 id="functors">Functors</h3>
<p>OCaml functors are essentially functions between modules, evaluated at compile time.</p>
<p>As an example, let&#39;s consider our earlier <code>SET</code> interface. Polymorphic equality is problematic for reasons discussed <a rel="noopener" target="_blank" href="https://dev.realworldocaml.org/maps-and-hashtables.html">elsewhere</a>, so let&#39;s suppose we want to be explicit about our equality test. We could introduce an extra function parameter to <code>union</code> and <code>difference</code> to pass in an equality predicate. That may be a fine solution in some cases, but functors give us a way of specifying the equality predicate at compile time and not having to pass it around.</p>
<p>We&#39;ll define a signature of types that have decidable equality:</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>module type </span><span>EQUALITY </span><span>= sig
</span><span>  </span><span>type t
</span><span>  </span><span>val </span><span>eq </span><span>: </span><span>t </span><span>-&gt; </span><span>t </span><span>-&gt; </span><span>bool
</span><span>end
</span></code></pre>
<p>Then we can define our set implementation as a functor from <code>EQUALITY</code>.</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>module </span><span>SetFunctor </span><span>= functor </span><span>(</span><span>E </span><span>:</span><span> EQUALITY</span><span>) -&gt; </span><span>struct
</span><span>
</span><span>  </span><span>type element </span><span>= E</span><span>.t
</span><span>  </span><span>type set </span><span>= </span><span>element list
</span><span>
</span><span>  </span><span>let rec </span><span>union </span><span>left </span><span>= function
</span><span>    </span><span>| </span><span>[] </span><span>-&gt; left
</span><span>    </span><span>| </span><span>x :: xs -&gt;
</span><span>        </span><span>if </span><span>List.exists left ~f:(E.eq x)
</span><span>        </span><span>then</span><span> union left xs
</span><span>        </span><span>else</span><span> union (x :: left) xs
</span><span>
</span><span>  </span><span>let </span><span>of_list </span><span>l </span><span>=
</span><span>    union </span><span>[]</span><span> l
</span><span>
</span><span>  </span><span>let </span><span>singleton </span><span>a </span><span>= </span><span>[ a ]
</span><span>
</span><span>  </span><span>let </span><span>difference </span><span>left right </span><span>=
</span><span>    </span><span>let </span><span>filter </span><span>a </span><span>= not </span><span>(List.exists right ~f:(E.eq a)) </span><span>in
</span><span>    List.filter left ~f:filter
</span><span>
</span><span>end
</span></code></pre>
<p>Now, to instantiate <code>SetFunctor</code>, we&#39;ll first have to define an input module.</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>module </span><span>IntEquality </span><span>: </span><span>EQUALITY </span><span>= struct
</span><span>  </span><span>type t </span><span>= </span><span>int
</span><span>  </span><span>let </span><span>eq </span><span>= </span><span>Int.equal
</span><span>end
</span></code></pre>
<p>Applying the functor looks like this:</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>module </span><span>IntSet </span><span>= </span><span>SetFunctor</span><span>(</span><span>IntEquality</span><span>)
</span></code></pre>
<p>This is a rare case in OCaml where the syntax for application requires parentheses. We can give the functor an explicit signature, if we want:</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>module type </span><span>SET_FUNCTOR </span><span>= functor </span><span>(</span><span>E </span><span>:</span><span> EQUALITY</span><span>) -&gt; </span><span>sig
</span><span>
</span><span>  </span><span>type element </span><span>= E</span><span>.t
</span><span>  </span><span>type set
</span><span>
</span><span>  </span><span>(* create a singleton set *)
</span><span>  </span><span>val </span><span>singleton </span><span>: </span><span>element </span><span>-&gt; </span><span>set
</span><span>
</span><span>  </span><span>(* create the set of all elements in a list *)
</span><span>  </span><span>val </span><span>of_list </span><span>: </span><span>element list </span><span>-&gt; </span><span>set
</span><span>
</span><span>  </span><span>(* take the union of two sets *)
</span><span>  </span><span>val </span><span>union </span><span>: </span><span>set </span><span>-&gt; </span><span>set </span><span>-&gt; </span><span>set
</span><span>
</span><span>  </span><span>(* take the difference of two sets *)
</span><span>  </span><span>val </span><span>difference </span><span>: </span><span>set </span><span>-&gt; </span><span>set </span><span>-&gt; </span><span>set
</span><span>
</span><span>  </span><span>(* further operations omitted for the sake of brevity *)
</span><span>
</span><span>end
</span><span>
</span><span>module </span><span>SetFunctor&#39; </span><span>: </span><span>SET_FUNCTOR </span><span>= </span><span>SetFunctor
</span></code></pre>
<p>The type declaration <code>type element = E.t</code> requires that a module implementing this signature will define a type <code>element</code> that is equal to <code>E.t</code> from its input module.</p>
<p>Notice that <code>set</code> is no longer parametric. The set type we get when we apply the functor represents a set of elements specifically of type <code>E.t</code>. We&#39;ve essentially lifted the parameter to the level of the module system.</p>
<h3 id="type-classes-as-signatures">Type Classes as Signatures</h3>
<p>Haskell&#39;s type classes may be viewed as a particular kind of signature. For example, the Functor and Applicative classes are described by the following signatures:</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>module type </span><span>FUNCTOR </span><span>= sig
</span><span>  </span><span>type &#39;a t
</span><span>  </span><span>val </span><span>map </span><span>: (</span><span>&#39;a </span><span>-&gt; </span><span>&#39;b</span><span>) -&gt; </span><span>&#39;a t </span><span>-&gt; </span><span>&#39;b t
</span><span>end
</span><span>
</span><span>(* an example instance *)
</span><span>module </span><span>OptionFunctor </span><span>: </span><span>FUNCTOR </span><span>= struct
</span><span>  </span><span>type &#39;a t </span><span>= </span><span>&#39;a option
</span><span>  </span><span>let </span><span>map </span><span>f xs </span><span>= </span><span>Option.map xs ~f:f
</span><span>end
</span><span>
</span><span>module type </span><span>APPLICATIVE </span><span>= sig
</span><span>  </span><span>type &#39;a t
</span><span>  </span><span>val </span><span>pure </span><span>: </span><span>&#39;a </span><span>-&gt; </span><span>&#39;a t
</span><span>  </span><span>val </span><span>apply </span><span>: (</span><span>&#39;a </span><span>-&gt; </span><span>&#39;b</span><span>) </span><span>t </span><span>-&gt; </span><span>&#39;a t </span><span>-&gt; </span><span>&#39;b t
</span><span>end
</span><span>
</span><span>(* an example instance *)
</span><span>module </span><span>OptionApplicative </span><span>: </span><span>APPLICATIVE </span><span>= struct
</span><span>  </span><span>type &#39;a t </span><span>= </span><span>&#39;a option
</span><span>  </span><span>let </span><span>pure </span><span>a </span><span>= </span><span>Some</span><span> a
</span><span>  </span><span>let </span><span>apply </span><span>fs xs </span><span>= match </span><span>(fs, xs) </span><span>with
</span><span>  </span><span>| </span><span>(Some f, Some x) -&gt; </span><span>Some </span><span>(f x)
</span><span>  </span><span>| </span><span>_ </span><span>-&gt; </span><span>None
</span><span>end
</span></code></pre>
<p>It is conventional in OCaml to name the principal type of a module/signature <code>t</code>, if one exists.</p>
<p>In fact, OCaml modules are strictly more powerful than Haskell type classes. Type classes are limited to having at most one instance per type, while signatures may be inhabited by several modules that package a given type. (For example, Haskell is forced to ordain one ordering of the natural numbers as the canonical <code>Ord</code> instance, even though there are many possible orderings.) The cost is in verbosity -- we have to name which instance of a signature we&#39;re talking about. There is research being done on <a rel="noopener" target="_blank" href="https://www.cs.cmu.edu/~rwh/papers/mtc/short.pdf">modular type classes</a>, which are intended to combine the best of both worlds.</p>
<h3 id="resources">Resources</h3>
<p>The source code in this document is available <a rel="noopener" target="_blank" href="https://github.com/rdck/ocaml-module-introduction">here</a>.</p>
<p>Yaron Minsky and Anil Madhavapeddy have written an excellent <a rel="noopener" target="_blank" href="https://dev.realworldocaml.org/index.html">book</a> on OCaml, which includes sections on <a rel="noopener" target="_blank" href="https://dev.realworldocaml.org/files-modules-and-programs.html">modules</a> and <a rel="noopener" target="_blank" href="https://dev.realworldocaml.org/functors.html">functors</a>.</p>
<p>Robert Harper, one of the designers of Standard ML, has written about the importance of modularity on <a rel="noopener" target="_blank" href="https://existentialtype.wordpress.com/2011/04/16/modules-matter-most/">his blog</a>.</p>


    </div></div>
  </body>
</html>
