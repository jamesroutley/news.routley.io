<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://natkr.com/2025-08-14-modifying-other-peoples-software/">Original</a>
    <h1>Modifying other people&#39;s software</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>Every once in a while, we all feel the need to modify something that
someone else built.</p>
<p>Sometimes those patches make sense to upstream, but not always.</p>
<blockquote>
<p>Hey.</p>
</blockquote>
<h2 id="this-is-easy">
<a href="#this-is-easy" aria-label="Anchor link for: this-is-easy"></a>This is easy enough, right?</h2>
<p>These days, pretty much every project uses <a href="https://git-scm.com/">Git</a>.
It is, famously, a DVCS. A Distributed Version Control System.
Distributed. It&#39;s right there in the acronym. That means that it can
work without any central repository.</p>
<p>You can just clone anything you want, and commit whatever changes you
want. You can make your own new central repository, and push your
changes to there... original project be damned!</p>
<p>Hell, most Git hosts<sup id="fr-2-1"><a href="#fn-2">2</a></sup> have an easy-to-use button to do just that:
&#34;Fork&#34;!</p>
<p>So... that&#39;s the dream, right? Just use Git for what it&#39;s good at?
Right? Right?</p>
<h2 id="one-tiny-catch">
<a href="#one-tiny-catch" aria-label="Anchor link for: one-tiny-catch"></a>One tiny catch...</h2>
<p>Git really wants history to <em>roll forward</em>. You commit a change, and
then you make another commit that builds on that. You never change an
existing commit, you just add new commits with the further changes.</p>
<p>Or, well. You <em>can</em> change a commit,<sup id="fr-3-1"><a href="#fn-3">3</a></sup> but Git doesn&#39;t have any way
to relate the two commits. It just sees two entirely different
timelines, and gets very confused if they ever end up mixing. There&#39;s a
reason that &#34;Never rewrite public branches&#34; is a very common mantra.</p>
<p>And that works when you&#39;re working on a (relatively) static foundation.
When you&#39;re working on your own project, or even working on a patch
that you expect to integrate <em>relatively soon</em> into some public project.</p>
<p>You pick some foundation (usually just <code>main</code>), make your feature
branch, send it through review,<sup id="fr-4-1"><a href="#fn-4">4</a></sup> maybe backport it to a few older
versions, and then it just... becomes part of the project&#39;s history.
Irrelevant... until, a few years later, someone comes back to
<a href="https://git-scm.com/docs/git-bisect">bisect</a> past it, looking for where
on <code>$DEITY</code>&#39;s Green Earth™ <em>that damn bug</em> was introduced.</p>
<p>But such is not the fate of the capital-P Patch. When we make a Patch
that we intend to maintain over time, we have different needs.</p>
<p>Suddenly, we want to have the opposite of what Git wants us to do.</p>
<p>A Patch lives on, isolated from the upstream. For months, for years, for
decades.</p>
<p>And Git just.. can&#39;t really provide that.</p>
<h2 id="why-not-jujutsu">
<a href="#why-not-jujutsu" aria-label="Anchor link for: why-not-jujutsu"></a>Hey, what about Jujutsu?</h2>
<p><a href="https://jj-vcs.github.io/jj/latest/">Jujutsu</a> (jj) is a pretty new
version control system, whose main claim to fame is making it easier to
change your history. It even keeps an <a href="https://jj-vcs.github.io/jj/latest/operation-log/">&#34;operation
log&#34;</a> tracking the
repository&#39;s state over time!</p>
<p>In theory, that&#39;d be a great start... but jj still only concerns itself
with <em>local</em> behaviour. When you push a jj repository, you&#39;re still
only pushing the Git history that it currently corresponds to. If you
rewrite the history and push again, you push a completely distinct Git
history, just like what Git itself would have produced. There is, as far
as I know, no support for sharing or collaborating on the operation log
itself.</p>
<p>The granularity of the oplog is also a bit unhelpful.. it automatically
creates a new entry for every jj command you run, which ends up closer
to your editor&#39;s undo history than it is to the <em>intentional</em> kind of
history that Git tracks.</p>
<h2 id="already-solved">
<a href="#already-solved" aria-label="Anchor link for: already-solved"></a>Surely, this has been solved already?</h2>
<p>A while ago, the question came up at my old job. My (then-)manager
referred us to an old <a href="https://stackoverflow.com/questions/10705446/maintaining-multiple-patches-feature-branches-for-multiple-development-branches">Stack Overflow
question</a>
on the topic. ...a question that <em>he</em> wrote, about a decade earlier. One
that, to this day, didn&#39;t really have an answer, beyond a dejected
shrug.</p>
<p>Surely... this has to be a common problem already?</p>
<p>Now.. who has ran into this problem before? Who has to manage a lot of
patches for... everything?</p>
<p>If you&#39;re anything like me, you&#39;re all shouting at your monitors at
this point.</p>
<blockquote>
<p>Natalie, you&#39;re talking about Linux distributions!</p>
</blockquote>
<p>Yes.. yes.. point taken. Let&#39;s have a look at how the pros do it. How
<em>do</em> they do it, anyway?</p>
<h2 id="quilt">
<a href="#quilt" aria-label="Anchor link for: quilt"></a>A patchy quilt</h2>
<p>Most distributions maintain their patches as .patch files. You know the
ones, the ones you get from <code>git diff</code> (and <code>diff</code>!).</p>
<div>
<pre data-lang="diff"><code data-lang="diff"><span>diff --git a/README.org b/README.org
</span><span>index 3699653..3686b62 100644
</span><span>--- a/README.org
</span><span>+++ b/README.org
</span><span>@@ -3,3 +3,5 @@
</span><span> Lorem ipsum, blah blah.
</span><span>+
</span><span>+Look, here&#39;s one just now!
</span></code></pre>
</div>
<p>As it turns out, they have some pretty neat properties. They&#39;re just
text, so we can version and diff them like any other text file. We can
store them in our regular version control system of choice. (Git?)</p>
<p>But... where <em>do</em> they come from, anyway?</p>
<p><a href="https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/9/html/packaging_and_distributing_software/preparing-software-for-rpm-packaging_packaging-and-distributing-software#patching-software_preparing-software-for-rpm-packaging">Red
Hat</a>
doesn&#39;t really have an answer, beyond &#34;run <code>diff</code>!&#34;. That works when
you have one change that you want to save..., but it doesn&#39;t really
help us beyond that. If we have multiple changes, it&#39;s on us to split
up each change cleanly, or to manage changes to these diffs. Oh well.</p>
<p><a href="https://github.com/NixOS/nixpkgs/blob/ded2d32fc091c837c1d5cf49a588f36fc2ef705a/pkgs/README.md#patches">Nixpkgs</a>
tells us to prefer generating patches from upstream commits if possible.
That&#39;s reasonable advice - if it&#39;s been merged then the patch probably
won&#39;t be needed for any future releases, so we just want things to work
<em>now</em>. But for <em>other</em> cases, there&#39;s little to say apart from &#34;Spin
up a temporary git clone, and export each patch yourself&#34;. Meh.</p>
<p>But
<a href="https://wiki.archlinux.org/title/Patching_packages#Using_quilt">Arch</a>,
<a href="https://wiki.debian.org/UsingQuilt">Debian</a>, and
<a href="https://github.com/canonical/ubuntu-packaging-guide/blob/0211f5c207286efd72d861768233a1c3a45b6e18/docs/how-to/patch-management.rst">Ubuntu</a>
paint a different picture. They refer to this otherwise little-known
tool called <a href="https://man.archlinux.org/man/quilt.1">Quilt</a>. Quilt gives
us something that looks.. remarkably like a version control system. We
can <a href="https://man.archlinux.org/man/quilt.1#new">record</a> changes, and
<a href="https://man.archlinux.org/man/quilt.1#push">navi</a><a href="https://man.archlinux.org/man/quilt.1#pop">gate</a>
between them. We can
<a href="https://man.archlinux.org/man/quilt.1#patches">view</a> rudimentary
histories! And it all operates natively on .patch files!</p>
<p>Oh happy days, our problems are solved!</p>
<p>But it quickly becomes evident that Quilt is no Git. Aside from the
commands being pretty far from what we&#39;re used to,<sup id="fr-6-1"><a href="#fn-6">6</a></sup> it&#39;s pretty
easy to screw up.</p>
<p>Quilt doesn&#39;t really have a baseline for what it <em>expects</em> the original
source tree to look like, so every time we want to change a file we need
to <a href="https://man.archlinux.org/man/quilt.1#add">tell it</a> that <em>before</em> we
make the change, or the change will end up attributed to the wrong patch
(or missed, altogether).</p>
<p>And, that&#39;s kind of theme throughout. It can do what you want, but
there&#39;ll be some awkwardness involved.</p>
<p>Can&#39;t we have the same kind of readable and versionable (<em>text</em>-first)
history, but in a way that feels more... Gitty?</p>
<h2 id="lappverk">
<a href="#lappverk" aria-label="Anchor link for: lappverk"></a>Enter, Lappverk</h2>
<p>What if we could just.. import our patchset into Git, at the start of
our session, and then export it back out as a series of patch files when
we&#39;re done? That way we&#39;re effectively following the commandments of
The Holy Quiltmother, but still get to keep our familiar Git UI.</p>
<p>After all, nothing&#39;s more Git than Git.</p>
<p>As it turns out, Git actually has built-in commands for doing that kind
of import and export:
<a href="https://git-scm.com/docs/git-format-patch"><code>format-patch</code></a> (creates
patch files from the history, one patch per commit) and
<a href="https://git-scm.com/docs/git-am"><code>am</code></a> (imports patch files, creating
one commit per patch file).</p>
<p>They&#39;re not <em>quite</em> there, you still need to specify revision ranges
manually, and make sure you&#39;re not importing the same patch twice. And
they don&#39;t <em>quite</em> roundtrip cleanly, so every time you do an
<code>am &amp;&amp; format-patch</code> cycle you end up with ever-so-slightly different
patch files.</p>
<p>But those are edges we can file off, the core idea was there.</p>
<p>And so, I made <a href="https://codeberg.org/natkr/lappverk/">Lappverk</a>, a tool
that adds some conventions around the workflow.</p>
<p>It normalizes commit metadata, so every export looks the same. It keeps
track of the upstream, and it knows where the upstream commits end and
your patches begin. And (imports/exports aside), it&#39;s just the same old
git that your tooling already knows how to work with.</p>
<p>It&#39;s pretty neat, if I dare say so myself:</p>
<div>
<pre data-lang="bash"><code data-lang="bash"><span># Create the new project and patch series
</span><span>lappverk</span><span> init project example/patches/tyck</span><span> --upstream</span><span> https://codeberg.org/natkr/tyck.git
</span><span>lappverk</span><span> init patch-series example/patches/tyck/0.1.0</span><span> --base</span><span> v0.1.0
</span><span>
</span><span># Check out the current state of the patch series
</span><span># (which&#39;ll currently just be the upstream release)
</span><span># DANGER: This will clear all current state in the worktree
</span><span># - all unexported changes will be lost.
</span><span>lappverk</span><span> checkout example/patches/tyck/0.1.0
</span><span>
</span><span># Go to the checkout
</span><span># lappverk checkout also prints the path, so you can pushd that as well
</span><span>pushd </span><span>$(</span><span>lappverk</span><span> path worktree example/patches/tyck/0.1.0)
</span><span>
</span><span># Make some changes!
</span><span>echo </span><span>&#34;This edition brought to you by lappverk!&#34; </span><span>&gt;&gt;</span><span> templates/comment-list.html.j2
</span><span>git</span><span> add templates/comment-list.html.j2
</span><span>git</span><span> commit</span><span> -m </span><span>&#34;Add lappverk propaganda&#34;
</span><span>
</span><span># Update the patch series from the current commit of the worktree
</span><span># @ is a shorthand for the active project path
</span><span>lappverk</span><span> export @/0.1.0
</span><span>
</span><span># We can now inspect the patches, and commit them to our patch repository
</span><span>popd
</span><span>git</span><span> add example/patches/tyck
</span><span>git</span><span> status
</span><span># &gt; On branch main
</span><span># &gt; Your branch is up to date with &#39;origin/main&#39;.
</span><span># &gt;
</span><span># &gt; Changes to be committed:
</span><span># &gt;   (use &#34;git restore --staged &lt;file&gt;...&#34; to unstage)
</span><span># &gt;         new file:   example/patches/tyck/0.1.0/0001-Add-lappverk-propaganda.patch
</span><span># &gt;         new file:   example/patches/tyck/0.1.0/lappverk-series.toml
</span><span># &gt;         new file:   example/patches/tyck/lappverk-project.toml
</span><span>git</span><span> commit</span><span> -m </span><span>&#34;Add new patch series for tyck v0.1.0!&#34;
</span><span>
</span><span># Now anyone can obtain the patched source tree!
</span><span>lappverk</span><span> checkout example/patches/tyck/0.1.0
</span></code></pre>
</div>
<p>It&#39;s honestly kind of addictive, suddenly being able to easily just..
make the small tweaks I want, without having to worry about the overhead
of a full-fat fork.</p>
<p>In fact, this very blog is <a href="https://codeberg.org/natkr/blog-patches/src/commit/78eda56d3213cae82172e23cbf8c2d7d6468414b/zola/v0.21.0/0002-Remove-strikethroughs-from-plaintext.patch">powered
by</a>
Lappverk right now!</p>
<h2 id="history">
<a href="#history" aria-label="Anchor link for: history"></a>Acknowledging history</h2>
<p>Remember how my involvement here started out <a href="https://natkr.com/2025-08-14-modifying-other-peoples-software/#already-solved">at</a> the
old job?</p>
<p>In fact, Lappverk started out as
<a href="https://github.com/stackabletech/docker-images/tree/6c406caea6e00f390a3b51cf787214d4e8a74023/rust/patchable">Patchable</a>,
the internal tool I developed for <a href="https://github.com/stackabletech/docker-images/issues/677">that very use
case</a>.
Lappverk is effectively &#34;Patchable with the Stackable-specific
assumptions stripped out&#34;.</p>
<p>Without the Patchable there probably still wouldn&#39;t have been a
Lappverk. And my table of contents would have been a little more broken.</p>
<h2 id="bye">
<a href="#bye" aria-label="Anchor link for: bye"></a>Farewell, for now!</h2>
<p>Now go forth, and patch some software of your own!</p>
<section>
<ol>
<li id="fn-1">
<p>I&#39;m me, after all... <a href="#fr-1-1">↩</a></p>
</li>
<li id="fn-2">
<p>At least <a href="https://forgejo.org/">Forgejo</a> (including
<a href="https://codeberg.org/">Codeberg</a>), GitHub, and GitLab... I suspect
<a href="https://en.wikipedia.org/wiki/Gitorious">Gitorious</a> had it too,
back before they kicked the bucket. <a href="#fr-2-1">↩</a></p>
</li>
<li id="fn-3">
<p>And some people are very eager to tell you so. <a href="#fr-3-1">↩</a></p>
</li>
<li id="fn-4">
<p>Maybe repeating the process a few times. <a href="#fr-4-1">↩</a></p>
</li>
<li id="fn-5">
<p>Well, ideally... <a href="#fr-5-1">↩</a></p>
</li>
<li id="fn-6">
<p>This also means that any external tooling like IDEs will be pretty
confused. <a href="#fr-6-1">↩</a></p>
</li>
</ol>
</section>

        </div></div>
  </body>
</html>
