<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/hillelwayne/archive/microfeatures-id-like-to-see-in-more-languages/">Original</a>
    <h1>Microfeatures I&#39;d like to see in more languages</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                    
                        <p>There are roughly three classes of language features:</p>
<ol>
<li>Features that the language is effectively designed around, such that you can’t add it after the fact. Laziness in Haskell, the borrow checker in Rust, etc.</li>
<li>Features that heavily define how to use the language. Adding these are possible later, but would take a lot of design, engineering, and planning. I’d say pattern matching, algebraic data types, and async fall under here.</li>
<li>Quality-of-life features that aren’t too hard to add, and don’t meaningfully change a language in its absence. Often syntactic sugar, like Python’s chained evaluators (<code>if 2 &lt;= x &lt; 10</code>).</li>
</ol>
<p>Most PLT and language design work is focused around (1) and (2), because those are the most important, but I have a deep fondness for (3)-type features. <em>Because</em> they’re so minor, they’re the most likely to spread between languages, since the overhead of adding them is so small. Since I spend a lot of time in niche obscure languages, I also encounter a lot of cool QoL features that most people might not have seen before. Here’s a few of them!</p>
<h3>Number Representations</h3>
<p>There’s lot of small things we can do to make working with numbers easier. The first is adding a separator, as lots of languages already do. Instead of writing <code>10000500</code>, you can write <code>10_000_500</code>, or  <code>1_00_00_500</code> if you’re Indian. You can also do <code>1e3</code> instead of <code>1000</code>.</p>
<p>For more interesting number QoLs, we can look at <a href="https://www.jsoftware.com/#/" target="_blank">J</a>. In science and math you sometimes get equations with powers and roots of π. J has the standardized number format <code>{x}p{y}</code> for <code>xπ^y</code>. For example, you can write <code>5*sqrt(π)</code> as <code>5p0.5</code>. There’s also <code>x</code> for powers of <code>e</code> and <code>r</code> for exact rational numbers (<code>(2r3 + 1) = 5r3</code>).</p>
<h3>Balanced string literals</h3>
<p>In Lua you can write raw, multiline strings with <a href="https://www.lua.org/pil/2.4.html" target="_blank">[[]]</a>:</p>
<div><pre><span></span><code>[[
  Alice said &#34;Bob said &#39;hi&#39;&#34;.
]]
</code></pre></div>

<p>Most languages have multiline literals, but what makes the Lua version great is that the beginning and ending marks are different characters. This solves the infuriating “unnestable quotes” problem string literals have, and you don’t have to escape all your literal <code>\</code>s. My neovim has the string <code>[[\\]]</code> to <em>literally</em> mean the string <code>\\</code>. With escaping that’d be <code>&#34;\\\\&#34;</code> or something, ick.</p>
<h3>Generalized update syntax</h3>
<p>I saw this in <a href="https://github.com/betaveros/noulith/" target="_blank">Noulith</a> and immediately fell in love:</p>
<blockquote>
<p>Ever wanted to write <code>x max= y</code> while searching for some maximum value in some complicated loop? You can do that here. You can do it with literally any function.</p>
</blockquote>
<p>In other words, <code>x max= y ⇔ x = max(x, y)</code>. It should conceivably be extendible to things like <code>text sub= (regex, replacement)</code>, which would cover a lot of small munging and plumbing work I’d need to do.</p>
<h3>The Chapel Power Hour</h3>
<p><a href="https://chapel-lang.org/" target="_blank">Chapel</a> is a language for high-performance computing, where you need to run really fast algorithms across hundreds or thousands of processors. It’s got a ton of (1) and (2)-type features I’ve never seen anywhere else, and I find the language incredibly interesting. Even not knowing it, there’s a few QoL things I found in the docs that I now want in other languages.</p>
<p>First, there’s the <code>config</code> keyword. If you write <code>config var n=1</code>, the compiler will automatically add a <code>--n</code> flag to the binary. As someone who 1) loves having configurable program, and 2) hates wrangling CLI libraries, a quick-and-dirty way to add single-variable flags seems like an obvious win.</p>
<p>Second, you can write the sequence <code>1, 2, … n-1</code> as <code>1..&lt;n</code>. It’s an elegant extension to the standard <code>..</code> operator languages like Ruby and TLA+ use.</p>
<p>Third— and this is one is a lot more arguable— you have “promotion”, a sort of automatic type lifting. The gist of it is that if you have a function of type <code>a -&gt; a</code>, Chapel lets you call it with arrays, too, returning a mapped array. So if <code>f(x) = 2*x</code>, then <code>f([1, 2, 3]) = [2, 4, 6]</code>. This is completely type-safe, too. You can get the same effect in other languages with a <code>lift</code> or a <code>map</code>, but it’s a nice QoL to make it native.</p>
<p>(Chapel has an extra flex here: it automatically parallelizes the computation. That’s definitely outside of (3) territory, though).</p>
<p>These are just a few of the cool features in Chapel, and I’m not even touching the really fundamental things. I enthusiastically recommend anybody interested in PLT or scientific computing to check it out.</p>
<h3>Date literals</h3>
<p><a href="https://frinklang.org/" target="_blank">Frink</a> has special syntax for date values. You can write <code># 2001-08-12 #</code> to mean the <em>date</em> 2001-08-12, instead of writing something annoying like <code>Date(2001, 8, 12)</code> and having a bug because months (but <em>not</em> days) <a href="https://www.hillelwayne.com/post/always-more-history/" target="_blank">start at 0</a>.</p>
<h3>Expanded Parameters blocks</h3>
<p><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters?view=powershell-7.2" target="_blank">Powershell functions</a> can have an explicit <code>Param</code> block where you define attributes for each function parameter, like default values, help docs, validation constraints, etc. So instead of writing <code>fun f(str path = &#34;/&#34;, int x)</code>, you can write something like (in pseudocode)</p>
<div><pre><span></span><code>fun f {
  params (
    [default = &#34;/&#34;]
    [help = &#34;The path to your file&#34;]
    [mandatory]
    [str]path
  , [optional][int] x
  )
}
</code></pre></div>

<p>Now this makes a lot more sense for a shell language, where you want lots of optional flags, switches, and aliases, but I can see it being really useful in a compiled language too. For one, it makes adding <a href="https://learn.adacore.com/courses/intro-to-ada/chapters/contracts.html" target="_blank">variable-level contracts easier</a>. Second, what if parameter blocks were abstractable? If you look at something like <a href="https://numpy.org/doc/stable/reference/routines.math.html" target="_blank">numpy functions</a>, so many of them share the exact same parameter definitions. What if you could write <code>def log(standard-exp-params)</code> instead of having to write them out every single time?</p>
<h3>kebab-case</h3>
<p>As seen in most lisps. Instead of naming things <code>two_words</code> or <code>TwoWords</code>, you can use the name <code>two-words</code>. It’s easier to write and easier to read. Of course the reason why nonlisps can’t do that is because they have infix minus, and it’s ambiguous whether <code>x-y</code> is the expression x minus y or the invocation of the <code>x-y</code> function. Seems like a bad tradeoff, though. How often do you use <code>-</code>, and how often do you write multiword functions? Just say that <code>x-y</code> is always a function, and if you want math you can use spaces like the rest of us.</p>
<p>(Granted this couldn’t be added to existing languages without breaking everything, but maybe worth considering if you’re making a new language?) </p>
<h3>Symbols</h3>
<p>Ruby has a special data type called a <a href="https://ruby-doc.org/core-2.5.0/Symbol.html" target="_blank">symbol</a>, written like <code>:this</code>.<sup id="fnref:symbol"><a href="#fn:symbol">1</a></sup> A symbol compares equal to itself and has no other functionality. It replaces single-word strings— instead of writing <code>dict[&#34;employee_id&#34;]</code>, you write <code>dict[:employee_id]</code>.</p>
<p>The advantage of having symbols is that it makes <em>strings</em> easier to work with. In most languages, strings are used to represent a lot of different things: tokens, text, structured data, code, etc. If you see the string “book”, it’s not clear without context whether it’s a dictionary key, or a text field with just “book” in it, or a trivial CSV, or what. With symbols, you can at least rule it out the former case, because then it’d instead be <code>:book</code>.</p>
<h3>Dedicated testing syntax</h3>
<p>As seen in <a href="https://dlang.org/spec/unittest.html" target="_blank">D’s unit-test blocks on functions</a> and <a href="https://p-org.github.io/P/manual/monitors/" target="_blank">P’s monitors</a>. While it makes sense to keep the actual testing as library code, testing is so universal in larger software projects that it sounds nice to give it syntactic support.</p>
<hr/>
<p>Anyway I don’t think adding these to arbitrary languages would be easy or have no downstream impacts, but they all at least seem more orthogonal to existing language semantics than type-(2) features, which are often back-added (for lots of good benefits). So they’d more easily to spread across languages. Except kebab-case. We live in a fallen world.</p>
<hr/>
<h3>Update for the Internets</h3>
<p>This was sent as part of an email newsletter; you can subscribe <a href="https://buttondown.email/hillelwayne/" target="_blank">here</a>. Common topics are <a href="https://buttondown.email/hillelwayne/archive/why-uml-really-died/" target="_blank">software history</a>, <a href="https://buttondown.email/hillelwayne/archive/10-misconceptions-about-formal-methods/" target="_blank">formal methods</a>, the <a href="https://buttondown.email/hillelwayne/archive/reject-simplicity-embrace-complexity/" target="_blank">theory of software engineering</a>, and <a href="https://buttondown.email/hillelwayne/archive/whats-the-most-expensive-software-per-byte/" target="_blank">silly research dives</a>. Updates are 6x a month. I also have a <a href="https://www.hillelwayne.com/" target="_blank">website</a> where I put my polished writing (the newsletter is more for off-the-cuff stuff).</p>

                    
                
            </div></div>
  </body>
</html>
