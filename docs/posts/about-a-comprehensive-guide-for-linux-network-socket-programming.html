<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming">Original</a>
    <h1>About A comprehensive guide for Linux Network (Socket) programming</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><ul dir="auto">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#sockets">Sockets</a>
<ul dir="auto">
<li><a href="#type-of-sockets">Type of sockets</a></li>
<li><a href="#addressing-sockets">Addressing sockets</a></li>
<li><a href="#socket-apis">Socket APIs</a>
<ul dir="auto">
<li><a href="#getprotobyname">getprotobyname()</a></li>
<li><a href="#getservbyname">getservbyname()</a></li>
<li><a href="#getaddrinfo">getaddrinfo()</a></li>
<li><a href="#htonl-htons-ntohl-ntohs">htonl(), htons(), ntohl(), ntohs()</a></li>
<li><a href="#socket">socket()</a></li>
<li><a href="#setsockopt">setsockopt()</a></li>
<li><a href="#bind">bind()</a></li>
<li><a href="#listen">listen()</a></li>
<li><a href="#accept">accept()</a></li>
<li><a href="#connect">connect()</a></li>
<li><a href="#recv">recv()</a></li>
<li><a href="#send">send()</a></li>
<li><a href="#close">close()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#programming-client-server-models">Programming Client-Server Models</a>
<ul dir="auto">
<li><a href="#client-server-architecture">Client-Server Architecture</a></li>
<li><a href="#simple-http-client">Simple HTTP Client</a>
<ul dir="auto">
<li><a href="#include-necessary-headers">Include necessary headers</a></li>
<li><a href="#define-some-constants">Define some constants</a></li>
<li><a href="#define-helper-functions">Define Helper functions</a></li>
<li><a href="#get-tcp-protocol">Get TCP Protocol</a></li>
<li><a href="#get-port-of-http-service">Get Port of HTTP service</a></li>
<li><a href="#convert-port-to-network-byte-order">Convert Port to Network Byte Order</a></li>
<li><a href="#resolve-host-name">Resolve Host Name</a></li>
<li><a href="#create-a-socket">Create A Socket</a></li>
<li><a href="#connect-to-http-server">Connect to HTTP server</a></li>
<li><a href="#send-http-request">Send HTTP Request</a></li>
<li><a href="#receive-http-response">Receive HTTP Response</a></li>
<li><a href="#clean-up">Clean Up</a></li>
</ul>
</li>
<li><a href="#simple-tcp-based-client-server">Simple TCP-Based Client-Server</a>
<ul dir="auto">
<li><a href="#necessary-headers-and-macros">Necessary Headers And Macros</a></li>
<li><a href="#utility-functions">Utility Functions</a></li>
<li><a href="#setup-server">Setup Server</a></li>
<li><a href="#setup-client">Setup Client</a></li>
<li><a href="#main-function">Main Function</a></li>
</ul>
</li>
<li><a href="#multithread-tcp-based-client-server">Multithread TCP-Based Client-Server</a>
<ul dir="auto">
<li><a href="#setup-server-with-multithreading">Setup Server with multithreading</a></li>
</ul>
</li>
<li><a href="#simple-udp-based-client-server">Simple UDP-Based Client-Server</a>
<ul dir="auto">
<li><a href="#necessary-headers-and-macros-1">Necessary Headers And Macros</a></li>
<li><a href="#setup-server-1">Setup Server</a></li>
<li><a href="#setup-client-1">Setup Client</a></li>
</ul>
</li>
<li><a href="#advanced-techniques">Advanced Techniques</a>
<ul dir="auto">
<li><a href="#non-blocking-sockets">Non-blocking sockets</a></li>
<li><a href="#synchronous-io-multiplexing-with-select">Synchronous I/O Multiplexing with select()</a></li>
<li><a href="#synchronous-io-multiplexing-with-poll">Synchronous I/O Multiplexing with poll()</a></li>
<li><a href="#broadcasting-messages">Broadcasting Messages</a></li>
</ul>
</li>
<li><a href="#create-a-simple-http-server">Create A Simple HTTP Server</a>
<ul dir="auto">
<li><a href="#demo">Demo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#networking-libraries">Networking Libraries</a>
<ul dir="auto">
<li><a href="#using-libcurl">Using libcurl</a>
<ul dir="auto">
<li><a href="#curl-command-line-examples">curl command-line examples</a></li>
<li><a href="#basic-curl">Basic Curl</a></li>
<li><a href="#curl-multiple-handles">Curl Multiple Handles</a></li>
<li><a href="#curl-multithreading">Curl Multithreading</a></li>
</ul>
</li>
<li><a href="#secure-networking-with-openssl">Secure Networking with OpenSSL</a>
<ul dir="auto">
<li><a href="#a-https-client">A HTTPS Client</a></li>
<li><a href="#secure-client-server">Secure Client-Server</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<p dir="auto">In my opinion, Linux network programming, especially socket programming, isn’t that difficult. However, learning this topic on your own can be challenging because many online resources are unclear, and sample codes often only cover the basics. You might find yourself unsure of what to do next. That&#39;s why I created this tutorial. It aims to give you clear guidelines and plenty of examples to help you understand better.</p>
<p dir="auto">Linux network programming deals with the interaction between processes using network interfaces. It enables interprocess communication (<code>IPC</code>), allowing data exchange between processes running on the same machine or on different machines connected over a network.</p>
<p dir="auto">The foundation of Linux network programming lies in the use of sockets, a universal API designed for interprocess communication. Sockets originated from BSD Unix in 1983 and were later standardized by POSIX, making them a cornerstone of modern networking.</p>

<p dir="auto">A socket is an endpoint for communication. Think of it as a door through which data flows in and out of a process. Processes use sockets to send and receive messages, enabling seamless <code>IPC</code>.</p>
<p dir="auto">Sockets were initially designed to support two domains:</p>
<p dir="auto"><strong>Unix Domain (Unix)</strong>: Used for communication between processes within the same operating system.</p>
<p dir="auto"><strong>Internet Domain (INET)</strong>: Used for communication between processes on different systems connected via a TCP/IP network.</p>
<p dir="auto">Unix domain sockets are used for <code>IPC</code> within the same operating system. They are faster than <code>INET</code> sockets because they don&#39;t require network protocol overhead. Instead of IP addresses, Unix domain sockets use file system paths for addressing.</p>
<p dir="auto"><code>INET</code> domain sockets are used for communication between processes on different systems connected over a network. These sockets rely on the <code>TCP/IP</code> protocol stack, which ensures data integrity and delivery.</p>
<p dir="auto">Two common protocols used with <code>INET</code> domain sockets are:</p>
<p dir="auto"><strong>TCP (Transmission Control Protocol)</strong>: Provides reliable, ordered, and error-checked delivery of data.</p>
<p dir="auto"><strong>UDP (User Datagram Protocol)</strong>: Provides fast, connectionless data transmission without guarantees of delivery.</p>

<p dir="auto">The BSD socket API supports several types of sockets, which determine how data is transmitted between processes:</p>
<p dir="auto"><strong>Stream Sockets (SOCK_STREAM)</strong>: These provide a reliable, connection-oriented communication protocol. Data is sent and received as a continuous stream of bytes. Typically used with <code>TCP</code> (Transmission Control Protocol).</p>
<p dir="auto"><strong>Datagram Sockets (SOCK_DGRAM)</strong>: These provide a connectionless communication protocol. Data is sent in discrete packets, and delivery isn&#39;t guaranteed. Typically used with <code>UDP</code> (User Datagram Protocol).</p>
<p dir="auto"><strong>Raw Sockets (SOCK_RAW)</strong>: These allow processes to access lower-level network protocols directly, bypassing the standard <code>TCP</code> or <code>UDP</code> layers. Useful for custom protocol implementations or network monitoring tools.</p>

<p dir="auto">In the INET domain, sockets are identified by two components:</p>
<p dir="auto"><strong>IP Address</strong>: A 32-bit number (<code>IPv4</code>) or a 128-bit number (<code>IPv6</code>) that uniquely identifies a device on a network. IPv4 addresses are often represented in dotted decimal notation, such as <code>192.168.1.1</code>.</p>
<p dir="auto"><strong>Port Number</strong>: A 16-bit number that identifies a specific service or application on the device. For example, web servers typically use port 80 (<code>HTTP</code>) or 443 (<code>HTTPS</code>).</p>
<p dir="auto">Check some of well-known services in Linux system via <code>/etc/services</code> file. Ports under 1024 are often considered special, and usually require special OS privileges to use.</p>
<div data-snippet-clipboard-copy-content="worker@7e4a84e41875:~/study_workspace/LinuxNetworkProgramming$ cat /etc/services
tcpmux          1/tcp                           # TCP port service multiplexer
echo            7/tcp
echo            7/udp
...
ftp             21/tcp
fsp             21/udp          fspd
ssh             22/tcp                          # SSH Remote Login Protocol
telnet          23/tcp
smtp            25/tcp          mail
...
http            80/tcp          www             # WorldWideWeb HTTP
..."><pre><code>worker@7e4a84e41875:~/study_workspace/LinuxNetworkProgramming$ cat /etc/services
tcpmux          1/tcp                           # TCP port service multiplexer
echo            7/tcp
echo            7/udp
...
ftp             21/tcp
fsp             21/udp          fspd
ssh             22/tcp                          # SSH Remote Login Protocol
telnet          23/tcp
smtp            25/tcp          mail
...
http            80/tcp          www             # WorldWideWeb HTTP
...
</code></pre></div>


<div data-snippet-clipboard-copy-content="#include &lt;netdb.h&gt;

struct protoent *getprotobyname(const char *name);"><pre><code>#include &lt;netdb.h&gt;

struct protoent *getprotobyname(const char *name);
</code></pre></div>
<p dir="auto">Sample usage:</p>
<div data-snippet-clipboard-copy-content="struct protoent *proto;
proto = getprotobyname(&#34;tcp&#34;);
if (proto)
{
    printf(&#34;Protocol number for TCP: %d\n&#34;, proto-&gt;p_proto);
}"><pre><code>struct protoent *proto;
proto = getprotobyname(&#34;tcp&#34;);
if (proto)
{
    printf(&#34;Protocol number for TCP: %d\n&#34;, proto-&gt;p_proto);
}
</code></pre></div>
<p dir="auto"><strong>Description</strong>: <code>getprotobyname()</code> returns a <code>protoent</code> structure for the given protocol name, which contains information about the protocol.</p>

<div data-snippet-clipboard-copy-content="#include &lt;netdb.h&gt;

struct servent *getservbyname(const char *name, const char *proto);"><pre><code>#include &lt;netdb.h&gt;

struct servent *getservbyname(const char *name, const char *proto);
</code></pre></div>
<p dir="auto">Sample usage:</p>
<div data-snippet-clipboard-copy-content="struct servent *serv;
serv = getservbyname(&#34;http&#34;, &#34;tcp&#34;);
if (serv)
{
    printf(&#34;Port number for HTTP: %d\n&#34;, ntohs(serv-&gt;s_port));
}"><pre><code>struct servent *serv;
serv = getservbyname(&#34;http&#34;, &#34;tcp&#34;);
if (serv)
{
    printf(&#34;Port number for HTTP: %d\n&#34;, ntohs(serv-&gt;s_port));
}
</code></pre></div>
<p dir="auto"><strong>Description</strong>: <code>getservbyname()</code> returns a <code>servent</code> structure for the given service name and protocol, which contains information about the service.</p>

<div data-snippet-clipboard-copy-content="#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

struct addrinfo {
    int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
    int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC
    int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
    int              ai_protocol;  // use 0 for &#34;any&#34;
    size_t           ai_addrlen;   // size of ai_addr in bytes
    struct sockaddr *ai_addr;      // struct sockaddr_in or _in6
    char            *ai_canonname; // full canonical hostname

    struct addrinfo *ai_next;      // linked list, next node
};
 
int getaddrinfo(const char *node,     // e.g. &#34;www.example.com&#34; or IP
                const char *service,  // e.g. &#34;http&#34; or port number
                const struct addrinfo *hints,
                struct addrinfo **res);"><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

struct addrinfo {
    int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
    int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC
    int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
    int              ai_protocol;  // use 0 for &#34;any&#34;
    size_t           ai_addrlen;   // size of ai_addr in bytes
    struct sockaddr *ai_addr;      // struct sockaddr_in or _in6
    char            *ai_canonname; // full canonical hostname

    struct addrinfo *ai_next;      // linked list, next node
};
 
int getaddrinfo(const char *node,     // e.g. &#34;www.example.com&#34; or IP
                const char *service,  // e.g. &#34;http&#34; or port number
                const struct addrinfo *hints,
                struct addrinfo **res);
</code></pre></div>
<p dir="auto">Struct <code>addrinfo</code> has the pointer to struct <code>sockaddr</code> which is used in many socket functions.</p>
<p dir="auto">Sample usage:</p>
<div data-snippet-clipboard-copy-content="int status;
struct addrinfo hints;
struct addrinfo *servinfo;  // will point to the results
 
memset(&amp;hints, 0, sizeof(hints)); // make sure the struct is empty
hints.ai_family = AF_UNSPEC;     // don&#39;t care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP stream sockets
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me
 
if ((status = getaddrinfo(NULL, &#34;3490&#34;, &amp;hints, &amp;servinfo)) != 0)
{
    fprintf(stderr, &#34;getaddrinfo error: %s\n&#34;, gai_strerror(status));
    exit(1);
}
 
// servinfo now points to a linked list of 1 or more struct addrinfos
 
// ... do everything until you don&#39;t need servinfo anymore ....
 
freeaddrinfo(servinfo); // free the linked-list"><pre><code>int status;
struct addrinfo hints;
struct addrinfo *servinfo;  // will point to the results
 
memset(&amp;hints, 0, sizeof(hints)); // make sure the struct is empty
hints.ai_family = AF_UNSPEC;     // don&#39;t care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP stream sockets
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me
 
if ((status = getaddrinfo(NULL, &#34;3490&#34;, &amp;hints, &amp;servinfo)) != 0)
{
    fprintf(stderr, &#34;getaddrinfo error: %s\n&#34;, gai_strerror(status));
    exit(1);
}
 
// servinfo now points to a linked list of 1 or more struct addrinfos
 
// ... do everything until you don&#39;t need servinfo anymore ....
 
freeaddrinfo(servinfo); // free the linked-list
</code></pre></div>
<p dir="auto"><strong>Description</strong>: <code>getaddrinfo()</code> is used to get a list of address structures for the specified node and service, which can be used to create and connect sockets.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">htonl(), htons(), ntohl(), ntohs()</h3><a id="user-content-htonl-htons-ntohl-ntohs" aria-label="Permalink: htonl(), htons(), ntohl(), ntohs()" href="#htonl-htons-ntohl-ntohs"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="#include &lt;arpa/inet.h&gt;

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);"><pre><code>#include &lt;arpa/inet.h&gt;

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
</code></pre></div>
<p dir="auto">Sample usage:</p>
<div data-snippet-clipboard-copy-content="uint32_t host_port = 8080;
uint32_t net_port = htonl(host_port);
printf(&#34;Network byte order: 0x%x\n&#34;, net_port);"><pre><code>uint32_t host_port = 8080;
uint32_t net_port = htonl(host_port);
printf(&#34;Network byte order: 0x%x\n&#34;, net_port);
</code></pre></div>
<p dir="auto"><strong>Description</strong>: These functions convert values between host and network byte order. <code>htonl()</code> and <code>htons()</code> convert from host to network byte order, while <code>ntohl()</code> and <code>ntohs()</code> convert from network to host byte order.</p>
<p dir="auto"><code>htons(uint16_t hostshort)</code>: Converts a 16-bit number from host byte order to network byte order.</p>
<p dir="auto"><code>htonl(uint32_t hostlong)</code>: Converts a 32-bit number from host byte order to network byte order.</p>
<p dir="auto"><code>ntohs(uint16_t netshort)</code>: Converts a 16-bit number from network byte order to host byte order.</p>
<p dir="auto"><code>ntohl(uint32_t netlong)</code>: Converts a 32-bit number from network byte order to host byte order.</p>
<p dir="auto"><strong>What is Network Byte Order?</strong></p>
<p dir="auto">Network byte order is a standardized way of arranging the bytes of multi-byte data types (like integers) in network communication. Different CPU architecture may process data in different orders, we called it <strong>&#34;endianness&#34;</strong>.</p>
<blockquote>
<p dir="auto">Big-endian (BE): Stores the most significant byte (the “big end”) first. This means that the first byte (at the lowest memory address) is the largest, which makes the most sense to people who read left to right</p>
</blockquote>
<blockquote>
<p dir="auto">Little-endian (LE): Stores the least significant byte (the “little end”) first. This means that the first byte (at the lowest memory address) is the smallest, which makes the most sense to people who read right to left.</p>
</blockquote>
<p dir="auto">Data transferred in network is always Big-endian order.</p>
<p dir="auto">Data sending from host machine is called Host-byte order, could be big or little endian. Using the functions above ensure proper communication between systems.</p>

<div data-snippet-clipboard-copy-content="#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
 
int socket(int domain, int type, int protocol);"><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
 
int socket(int domain, int type, int protocol);
</code></pre></div>
<p dir="auto">Sample usage:</p>
<div data-snippet-clipboard-copy-content="int s;
struct addrinfo hints, *res;
 
getaddrinfo(&#34;www.example.com&#34;, &#34;http&#34;, &amp;hints, &amp;res);
 
s = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
if (s == -1)
{
    perror(&#34;socket&#34;);
    exit(1);
}"><pre><code>int s;
struct addrinfo hints, *res;
 
getaddrinfo(&#34;www.example.com&#34;, &#34;http&#34;, &amp;hints, &amp;res);
 
s = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
if (s == -1)
{
    perror(&#34;socket&#34;);
    exit(1);
}
</code></pre></div>
<p dir="auto"><strong>Description</strong>: <code>socket()</code> creates a new socket and returns a file descriptor for it.</p>

<div data-snippet-clipboard-copy-content="#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);"><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
</code></pre></div>
<p dir="auto">Sample usage:</p>
<div data-snippet-clipboard-copy-content="int sockfd; // Assume sockfd is a valid socket descriptor
int optval = 1;
if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval)) == -1)
{
    perror(&#34;setsockopt&#34;);
    exit(1);
}"><pre><code>int sockfd; // Assume sockfd is a valid socket descriptor
int optval = 1;
if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval)) == -1)
{
    perror(&#34;setsockopt&#34;);
    exit(1);
}
</code></pre></div>
<p dir="auto"><strong>Description</strong>: <code>setsockopt()</code> sets options on a socket, such as enabling the reuse of local addresses.</p>

<div data-snippet-clipboard-copy-content="#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);"><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre></div>
<p dir="auto">Sample usage:</p>
<div data-snippet-clipboard-copy-content="int sockfd; // Assume sockfd is a valid socket descriptor
struct sockaddr_in my_addr;
my_addr.sin_family = AF_INET;
my_addr.sin_port = htons(3490);
my_addr.sin_addr.s_addr = INADDR_ANY;

if (bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(my_addr)) == -1)
{
    perror(&#34;bind&#34;);
    exit(1);
}"><pre><code>int sockfd; // Assume sockfd is a valid socket descriptor
struct sockaddr_in my_addr;
my_addr.sin_family = AF_INET;
my_addr.sin_port = htons(3490);
my_addr.sin_addr.s_addr = INADDR_ANY;

if (bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(my_addr)) == -1)
{
    perror(&#34;bind&#34;);
    exit(1);
}
</code></pre></div>
<p dir="auto"><strong>Description</strong>: <code>bind()</code> assigns a local address to a socket.</p>

<div data-snippet-clipboard-copy-content="#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int listen(int sockfd, int backlog);"><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int listen(int sockfd, int backlog);
</code></pre></div>
<p dir="auto">Sample usage:</p>
<div data-snippet-clipboard-copy-content="int sockfd; // Assume sockfd is a valid socket descriptor
if (listen(sockfd, 10) == -1)
{
    perror(&#34;listen&#34;);
    exit(1);
}"><pre><code>int sockfd; // Assume sockfd is a valid socket descriptor
if (listen(sockfd, 10) == -1)
{
    perror(&#34;listen&#34;);
    exit(1);
}
</code></pre></div>
<p dir="auto"><strong>Description</strong>: <code>listen()</code> marks a socket as a passive socket that will be used to accept incoming connection requests.</p>

<div data-snippet-clipboard-copy-content="#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);"><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre></div>
<p dir="auto">Sample usage:</p>
<div data-snippet-clipboard-copy-content="int sockfd; // Assume sockfd is a valid socket descriptor
struct sockaddr_storage their_addr;
socklen_t addr_size = sizeof(their_addr);
int new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;addr_size);
if (new_fd == -1)
{
    perror(&#34;accept&#34;);
    exit(1);
}"><pre><code>int sockfd; // Assume sockfd is a valid socket descriptor
struct sockaddr_storage their_addr;
socklen_t addr_size = sizeof(their_addr);
int new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;addr_size);
if (new_fd == -1)
{
    perror(&#34;accept&#34;);
    exit(1);
}
</code></pre></div>
<p dir="auto"><strong>Description</strong>: <code>accept()</code> accepts a connection on a socket. If the server wants to send responding data back to client, it will send data to the returned fd.</p>

<div data-snippet-clipboard-copy-content="#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);"><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre></div>
<p dir="auto">Sample usage:</p>
<div data-snippet-clipboard-copy-content="int sockfd; // Assume sockfd is a valid socket descriptor
struct addrinfo hints, *res;

memset(&amp;hints, 0, sizeof(hints));
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;

if (getaddrinfo(&#34;www.example.com&#34;, &#34;http&#34;, &amp;hints, &amp;res) != 0)
{
    fprintf(stderr, &#34;getaddrinfo error\n&#34;);
    exit(1);
}

if (connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen) == -1)
{
    perror(&#34;connect&#34;);
    exit(1);
}"><pre><code>int sockfd; // Assume sockfd is a valid socket descriptor
struct addrinfo hints, *res;

memset(&amp;hints, 0, sizeof(hints));
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;

if (getaddrinfo(&#34;www.example.com&#34;, &#34;http&#34;, &amp;hints, &amp;res) != 0)
{
    fprintf(stderr, &#34;getaddrinfo error\n&#34;);
    exit(1);
}

if (connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen) == -1)
{
    perror(&#34;connect&#34;);
    exit(1);
}
</code></pre></div>
<p dir="auto"><strong>Description</strong>: <code>connect()</code> initiates a connection on a socket.</p>

<div data-snippet-clipboard-copy-content="#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t recv(int sockfd, void *buf, size_t len, int flags);"><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t recv(int sockfd, void *buf, size_t len, int flags);
</code></pre></div>
<p dir="auto">Sample usage:</p>
<div data-snippet-clipboard-copy-content="int sockfd; // Assume sockfd is a valid socket descriptor
char buf[100];
ssize_t bytes_received = recv(sockfd, buf, sizeof(buf), 0);
if (bytes_received == -1)
{
    perror(&#34;recv&#34;);
    exit(1);
}
else
{
    printf(&#34;Received %zd bytes\n&#34;, bytes_received);
}"><pre><code>int sockfd; // Assume sockfd is a valid socket descriptor
char buf[100];
ssize_t bytes_received = recv(sockfd, buf, sizeof(buf), 0);
if (bytes_received == -1)
{
    perror(&#34;recv&#34;);
    exit(1);
}
else
{
    printf(&#34;Received %zd bytes\n&#34;, bytes_received);
}
</code></pre></div>
<p dir="auto"><strong>Description</strong>: <code>recv()</code> receives data from a socket.</p>

<div data-snippet-clipboard-copy-content="#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t send(int sockfd, const void *buf, size_t len, int flags);"><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t send(int sockfd, const void *buf, size_t len, int flags);
</code></pre></div>
<p dir="auto">Sample usage:</p>
<div data-snippet-clipboard-copy-content="int sockfd; // Assume sockfd is a valid socket descriptor
char *msg = &#34;Hello, World!&#34;;
ssize_t bytes_sent = send(sockfd, msg, strlen(msg), 0);
if (bytes_sent == -1)
{
    perror(&#34;send&#34;);
    exit(1);
}
else
{
    printf(&#34;Sent %zd bytes\n&#34;, bytes_sent);
}"><pre><code>int sockfd; // Assume sockfd is a valid socket descriptor
char *msg = &#34;Hello, World!&#34;;
ssize_t bytes_sent = send(sockfd, msg, strlen(msg), 0);
if (bytes_sent == -1)
{
    perror(&#34;send&#34;);
    exit(1);
}
else
{
    printf(&#34;Sent %zd bytes\n&#34;, bytes_sent);
}
</code></pre></div>
<p dir="auto"><strong>Description</strong>: <code>send()</code> sends data to a socket.</p>

<div data-snippet-clipboard-copy-content="#include &lt;unistd.h&gt;

int close(int fd);"><pre><code>#include &lt;unistd.h&gt;

int close(int fd);
</code></pre></div>
<p dir="auto">Sample usage:</p>

<p dir="auto"><strong>Description</strong>: <code>close()</code> closes a file descriptor, so that it no longer refers to any file and may be reused.</p>

<div dir="auto"><h2 tabindex="-1" dir="auto">Client-Server Architecture</h2><a id="user-content-client-server-architecture" aria-label="Permalink: Client-Server Architecture" href="#client-server-architecture"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The client-server model is a way of organizing networked computers where one computer (the client) requests services or resources from another computer (the server). The server provides these services or resources to the client.</p>

<p dir="auto">Here are our goals:</p>
<ul dir="auto">
<li>we want to write a program which gets the address of a WWW site (e.g. <code>httpstat.us</code>) as the argument and fetches the document.</li>
<li>the program outputs the document to stdout;</li>
<li>the program uses TCP to connect to the <code>HTTP</code> server.</li>
</ul>
<p dir="auto">Click <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/blob/main/00_tutorials/07_http_redirection.c">HERE</a> for a complete source code.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/nguyenchiemminhvu/LinuxNetworkProgramming/refs/heads/main/http_connection.png"><img src="https://raw.githubusercontent.com/nguyenchiemminhvu/LinuxNetworkProgramming/refs/heads/main/http_connection.png" alt="HTTP Connection"/></a></p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Include necessary headers</h3><a id="user-content-include-necessary-headers" aria-label="Permalink: Include necessary headers" href="#include-necessary-headers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;"><pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
</code></pre></div>
<p dir="auto"><code>unistd.h</code>: Provides access to the POSIX operating system API, including file descriptors and the close() function.</p>
<p dir="auto"><code>stdio.h</code>: Standard I/O library for input/output operations (e.g., printf, fprintf).</p>
<p dir="auto"><code>stdlib.h</code>: Standard library for memory management (malloc, free) and program control (exit).</p>
<p dir="auto"><code>string.h</code>: Provides string manipulation functions like memset, strlen, etc.</p>
<p dir="auto"><code>arpa/inet.h</code>: Functions for manipulating IP addresses, such as ntohs and inet_ntoa.</p>
<p dir="auto"><code>netdb.h</code>: Functions for network database operations, such as getaddrinfo, getprotobyname, and getservbyname.</p>
<p dir="auto"><code>sys/socket.h</code>: Defines socket-related functions like socket, connect, send, and recv.</p>

<div data-snippet-clipboard-copy-content="const char* CPP_HOSTNAME = &#34;httpstat.us&#34;;
const int MESSAGE_SIZE = 1024;"><pre><code>const char* CPP_HOSTNAME = &#34;httpstat.us&#34;;
const int MESSAGE_SIZE = 1024;
</code></pre></div>
<p dir="auto"><code>CPP_HOSTNAME</code>: The hostname of the remote server the program will connect to.</p>
<p dir="auto"><code>MESSAGE_SIZE</code>: The size of the buffer used for sending and receiving data (1 KB in this case).</p>

<div data-snippet-clipboard-copy-content="void on_func_failure(const char* message)
{
    fprintf(stderr, &#34;Error: %s\n&#34;, message);
    exit(EXIT_FAILURE);
}"><pre><code>void on_func_failure(const char* message)
{
    fprintf(stderr, &#34;Error: %s\n&#34;, message);
    exit(EXIT_FAILURE);
}
</code></pre></div>
<p dir="auto">A helper function to handle errors. When a function fails, this function is called with an error message.</p>
<p dir="auto"><code>fprintf(stderr, ...)</code>: Prints the error message to the standard error output.</p>
<p dir="auto"><code>exit(EXIT_FAILURE)</code>: Terminates the program with a failure status code.</p>

<div data-snippet-clipboard-copy-content="struct protoent* p_proto_ent = getprotobyname(&#34;tcp&#34;);
if (p_proto_ent == NULL)
{
    on_func_failure(&#34;TCP protocol is not available&#34;);
}"><pre><code>struct protoent* p_proto_ent = getprotobyname(&#34;tcp&#34;);
if (p_proto_ent == NULL)
{
    on_func_failure(&#34;TCP protocol is not available&#34;);
}
</code></pre></div>
<p dir="auto"><code>getprotobyname(&#34;tcp&#34;)</code>: Retrieves the protocol entry for &#34;tcp&#34; (Transmission Control Protocol). The function returns a protoent structure that contains protocol information.</p>
<p dir="auto">If it returns NULL, the program exits using <code>on_func_failure</code> because TCP is required for the connection.</p>

<div data-snippet-clipboard-copy-content="servent* p_service_ent = getservbyname(&#34;http&#34;, p_proto_ent-&gt;p_name);
if (p_service_ent == NULL)
{
    on_func_failure(&#34;HTTP service is not available&#34;);
}"><pre><code>servent* p_service_ent = getservbyname(&#34;http&#34;, p_proto_ent-&gt;p_name);
if (p_service_ent == NULL)
{
    on_func_failure(&#34;HTTP service is not available&#34;);
}
</code></pre></div>
<p dir="auto"><code>getservbyname(&#34;http&#34;, p_proto_ent-&gt;p_name)</code>: Retrieves information about the &#34;http&#34; service, including the port number (usually 80 for HTTP).</p>
<p dir="auto">If getservbyname fails, the program exits. This function ensures the port number for HTTP is available.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Convert Port to Network Byte Order</h3><a id="user-content-convert-port-to-network-byte-order" aria-label="Permalink: Convert Port to Network Byte Order" href="#convert-port-to-network-byte-order"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="char port_buffer[6];
memset(port_buffer, 0, sizeof(port_buffer));
sprintf(port_buffer, &#34;%d&#34;, ntohs(p_service_ent-&gt;s_port));"><pre><code>char port_buffer[6];
memset(port_buffer, 0, sizeof(port_buffer));
sprintf(port_buffer, &#34;%d&#34;, ntohs(p_service_ent-&gt;s_port));
</code></pre></div>
<p dir="auto">Port Conversion: The port number from <code>getservbyname</code> is in network byte order (big-endian). <code>ntohs</code> converts it to host byte order (little-endian, on most systems).</p>
<p dir="auto"><code>sprintf</code>: Converts the port number to a string (stored in port_buffer), which is required by getaddrinfo.</p>

<div data-snippet-clipboard-copy-content="struct addrinfo hints;
memset(&amp;hints, 0, sizeof(hints));
hints.ai_family = AF_INET;
hints.ai_protocol = p_proto_ent-&gt;p_proto;
hints.ai_socktype = SOCK_STREAM;

struct addrinfo* server_addr;
int rc = getaddrinfo(CPP_HOSTNAME, port_buffer, &amp;hints, &amp;server_addr);
if (rc != 0)
{
    on_func_failure(&#34;Failed to resolve hostname&#34;);
}"><pre><code>struct addrinfo hints;
memset(&amp;hints, 0, sizeof(hints));
hints.ai_family = AF_INET;
hints.ai_protocol = p_proto_ent-&gt;p_proto;
hints.ai_socktype = SOCK_STREAM;

struct addrinfo* server_addr;
int rc = getaddrinfo(CPP_HOSTNAME, port_buffer, &amp;hints, &amp;server_addr);
if (rc != 0)
{
    on_func_failure(&#34;Failed to resolve hostname&#34;);
}
</code></pre></div>
<p dir="auto"><code>addrinfo</code>: A structure that holds information for socket creation.</p>
<p dir="auto"><code>ai_family = AF_INET</code>: Specifies IPv4 addresses.</p>
<p dir="auto"><code>ai_socktype = SOCK_STREAM</code>: Specifies a TCP connection.</p>
<p dir="auto"><code>ai_protocol = p_proto_ent-&gt;p_proto</code>: Ensures the protocol is TCP.</p>
<p dir="auto"><code>getaddrinfo</code>: Resolves the hostname (cppinstitute.org) and port (80) into an address that can be used for connecting.</p>
<p dir="auto">If getaddrinfo fails, the program exits.</p>

<div data-snippet-clipboard-copy-content="int sock_fd = socket(server_addr-&gt;ai_family, server_addr-&gt;ai_socktype, server_addr-&gt;ai_protocol);
if (sock_fd &lt; 0)
{
    freeaddrinfo(server_addr);
    on_func_failure(&#34;socket() failed&#34;);
}"><pre><code>int sock_fd = socket(server_addr-&gt;ai_family, server_addr-&gt;ai_socktype, server_addr-&gt;ai_protocol);
if (sock_fd &lt; 0)
{
    freeaddrinfo(server_addr);
    on_func_failure(&#34;socket() failed&#34;);
}
</code></pre></div>
<p dir="auto"><code>socket()</code>: Creates a new socket for communication.</p>
<p dir="auto">The arguments specify the address family, socket type, and protocol (IPv4, TCP).</p>
<p dir="auto">If the socket creation fails, the program exits.</p>

<div data-snippet-clipboard-copy-content="rc = connect(sock_fd, server_addr-&gt;ai_addr, sizeof(struct sockaddr));
if (rc != 0)
{
    freeaddrinfo(server_addr);
    on_func_failure(&#34;connect() failed&#34;);
}"><pre><code>rc = connect(sock_fd, server_addr-&gt;ai_addr, sizeof(struct sockaddr));
if (rc != 0)
{
    freeaddrinfo(server_addr);
    on_func_failure(&#34;connect() failed&#34;);
}
</code></pre></div>
<p dir="auto"><code>connect()</code>: Initiates a connection to the remote server using the socket.</p>
<p dir="auto">If connect fails, the program cleans up allocated resources and exits.</p>

<div data-snippet-clipboard-copy-content="char http_request[MESSAGE_SIZE];
memset(http_request, 0, MESSAGE_SIZE);
sprintf(http_request, &#34;GET / HTTP/1.1\r\nHost: %s\r\nConnection: close\r\n\r\n&#34;, CPP_HOSTNAME);

int http_request_len = strlen(http_request);
int sent_bytes = 0;
while (sent_bytes &lt; http_request_len)
{
    int sent_rc = send(sock_fd, http_request + sent_bytes, http_request_len - sent_bytes, 0);
    printf(&#34;sent %d bytes\n&#34;, sent_rc);
    sent_bytes += sent_rc;
}"><pre><code>char http_request[MESSAGE_SIZE];
memset(http_request, 0, MESSAGE_SIZE);
sprintf(http_request, &#34;GET / HTTP/1.1\r\nHost: %s\r\nConnection: close\r\n\r\n&#34;, CPP_HOSTNAME);

int http_request_len = strlen(http_request);
int sent_bytes = 0;
while (sent_bytes &lt; http_request_len)
{
    int sent_rc = send(sock_fd, http_request + sent_bytes, http_request_len - sent_bytes, 0);
    printf(&#34;sent %d bytes\n&#34;, sent_rc);
    sent_bytes += sent_rc;
}
</code></pre></div>
<p dir="auto">A conversation with the HTTP server consists of requests (sent by the client) and responses (sent by the server).</p>
<p dir="auto">To get a root document from a site named <a href="http://www.site.com" rel="nofollow">www.site.com</a>, the client should send the request to the server:</p>
<div data-snippet-clipboard-copy-content="GET / HTTP / 1.1 \ r \ n Host: www.site.com \ r \ n Connection:close \ r \ n \ r \ n"><pre><code>GET / HTTP / 1.1 \ r \ n Host: www.site.com \ r \ n Connection:close \ r \ n \ r \ n
</code></pre></div>
<p dir="auto">The request consists of:</p>
<ul dir="auto">
<li>a line containing a request name (<code>GET</code>) followed by the name of the resource the client wants to receive; the root documents is specified as a single slash (<code>/</code>); the line must also include the HTTP protocol version (<code>HTTP/1.1</code>), and must end with the <code>\r\n</code> characters; note: all the lines must be ended in the same way;</li>
<li>a line containing the name of the site (<code>www.site.com</code>) preceded by the parameter name (Host:)</li>
<li>a line containing the parameter named Connection: along with its value, close forces the server to close the connection after the first request is served; it will simplify our client’s code;</li>
<li>an empty line is the request’s terminator.</li>
</ul>
<p dir="auto">If the request is correct, the server’s response will begin with a more or less similar header.</p>
<div data-snippet-clipboard-copy-content="HTTP/1.1 200 OK
Content-Type: text/plain
Date: Thu, 05 Dec 2024 07:07:58 GMT
Server: Kestrel
Set-Cookie: ARRAffinity=b3b03edd65273a52d0e5a4a4995ddf09acfbb7f67adccaf277d300c0a375ea34;Path=/;HttpOnly;Domain=httpstat.us
Request-Context: appId=cid-v1:3548b0f5-7f75-492f-82bb-b6eb0e864e53
X-RBT-CLI: Name=LGEVN-Hanoi-ACC-5080M-A; Ver=9.14.2b;
Connection: close
Content-Length: 6

200 OK"><pre><code>HTTP/1.1 200 OK
Content-Type: text/plain
Date: Thu, 05 Dec 2024 07:07:58 GMT
Server: Kestrel
Set-Cookie: ARRAffinity=b3b03edd65273a52d0e5a4a4995ddf09acfbb7f67adccaf277d300c0a375ea34;Path=/;HttpOnly;Domain=httpstat.us
Request-Context: appId=cid-v1:3548b0f5-7f75-492f-82bb-b6eb0e864e53
X-RBT-CLI: Name=LGEVN-Hanoi-ACC-5080M-A; Ver=9.14.2b;
Connection: close
Content-Length: 6

200 OK
</code></pre></div>

<div data-snippet-clipboard-copy-content="char http_response[MESSAGE_SIZE];
memset(http_response, 0, MESSAGE_SIZE);
int received_bytes = 0;
while (1 == 1)
{
    int received_rc = recv(sock_fd, http_response + received_bytes, MESSAGE_SIZE - received_bytes, 0);
    printf(&#34;Received %d bytes\n&#34;, received_rc);
    received_bytes += received_rc;
}"><pre><code>char http_response[MESSAGE_SIZE];
memset(http_response, 0, MESSAGE_SIZE);
int received_bytes = 0;
while (1 == 1)
{
    int received_rc = recv(sock_fd, http_response + received_bytes, MESSAGE_SIZE - received_bytes, 0);
    printf(&#34;Received %d bytes\n&#34;, received_rc);
    received_bytes += received_rc;
}
</code></pre></div>
<p dir="auto"><code>recv()</code>: Receives the server&#39;s response in chunks and appends it to the http_response buffer.</p>
<p dir="auto">When <code>recv()</code> returns 0 or a negative value, it indicates the server has closed the connection or an error occurred.</p>

<div data-snippet-clipboard-copy-content="close(sock_fd);
freeaddrinfo(server_addr);"><pre><code>close(sock_fd);
freeaddrinfo(server_addr);
</code></pre></div>
<p dir="auto"><code>close()</code>: Closes the socket, releasing system resources.</p>
<p dir="auto"><code>freeaddrinfo()</code>: Frees the memory allocated by getaddrinfo.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Simple TCP-Based Client-Server</h2><a id="user-content-simple-tcp-based-client-server" aria-label="Permalink: Simple TCP-Based Client-Server" href="#simple-tcp-based-client-server"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Click <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/blob/main/00_tutorials/08_simple_client_server.c">HERE</a> for a complete source code.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/nguyenchiemminhvu/LinuxNetworkProgramming/refs/heads/main/tcp_based_client_server.png"><img src="https://raw.githubusercontent.com/nguyenchiemminhvu/LinuxNetworkProgramming/refs/heads/main/tcp_based_client_server.png" alt="TCP-Based Client-Server"/></a></p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Necessary Headers And Macros</h3><a id="user-content-necessary-headers-and-macros" aria-label="Permalink: Necessary Headers And Macros" href="#necessary-headers-and-macros"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/stat.h&gt;

#define PROTOCOL &#34;tcp&#34;
#define TCP_PORT 45123
#define MESSAGE_SIZE 1024
#define HOST_NAME &#34;localhost&#34;"><pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/stat.h&gt;

#define PROTOCOL &#34;tcp&#34;
#define TCP_PORT 45123
#define MESSAGE_SIZE 1024
#define HOST_NAME &#34;localhost&#34;
</code></pre></div>
<p dir="auto"><strong>Headers:</strong></p>
<p dir="auto"><code>unistd.h</code>: Provides POSIX API functions, e.g., close.</p>
<p dir="auto"><code>stdio.h</code>: For input/output operations, e.g., printf, fprintf.</p>
<p dir="auto"><code>time.h</code>: To get the current time using time().</p>
<p dir="auto"><code>string.h</code>: For string operations, e.g., strcmp, memset.</p>
<p dir="auto"><code>stdlib.h</code>: For memory allocation and process control.</p>
<p dir="auto"><code>arpa/inet.h</code>: For socket-related functions and data structures.</p>
<p dir="auto"><code>netdb.h</code>: To resolve hostnames using getaddrinfo and gethostbyname.</p>
<p dir="auto"><code>sys/socket.h</code>: Core socket programming functions, e.g., socket, connect, bind.</p>
<p dir="auto"><code>sys/stat.h</code>: For file and directory operations.</p>
<p dir="auto"><strong>Macros:</strong></p>
<p dir="auto"><code>PROTOCOL</code>: Defines the protocol as tcp.</p>
<p dir="auto"><code>TCP_PORT</code>: The port number the server and client use for communication.</p>
<p dir="auto"><code>MESSAGE_SIZE</code>: Maximum size for messages sent/received.</p>
<p dir="auto"><code>HOST_NAME</code>: Default hostname, set to localhost.</p>

<div data-snippet-clipboard-copy-content="void print_usage(const char *program_name)
{
    fprintf(stderr, &#34;Usage: %s &lt;client|server&gt;\n&#34;, program_name);
}"><pre><code>void print_usage(const char *program_name)
{
    fprintf(stderr, &#34;Usage: %s &lt;client|server&gt;\n&#34;, program_name);
}
</code></pre></div>
<p dir="auto">Prints a usage guide, showing how to execute the program. Example usage:</p>
<p dir="auto"><code>./program_name client</code></p>
<p dir="auto">or</p>
<p dir="auto"><code>./program_name server.</code></p>
<div data-snippet-clipboard-copy-content="void report_error(const char* message)
{
    fprintf(stderr, &#34;Error: %s\n&#34;, message);
}"><pre><code>void report_error(const char* message)
{
    fprintf(stderr, &#34;Error: %s\n&#34;, message);
}
</code></pre></div>
<p dir="auto">Prints error messages to stderr.</p>

<p dir="auto"><strong>Choose protocol and resolve server address</strong></p>
<div data-snippet-clipboard-copy-content="struct protoent* tcp_proto = getprotobyname(PROTOCOL);"><pre><code>struct protoent* tcp_proto = getprotobyname(PROTOCOL);
</code></pre></div>
<p dir="auto">Retrieves the protocol structure for the <code>&#34;tcp&#34;</code> protocol using <code>getprotobyname()</code>.</p>
<div data-snippet-clipboard-copy-content="char server_port[6];
memset(server_port, 0, 6);
sprintf(server_port, &#34;%d&#34;, htons(TCP_PORT));

struct addrinfo addr_hints;
memset(&amp;addr_hints, 0, sizeof(addr_hints));
addr_hints.ai_family = AF_INET;
addr_hints.ai_socktype = SOCK_STREAM;
addr_hints.ai_protocol = tcp_proto-&gt;p_proto;

struct addrinfo* addr_server;
rc = getaddrinfo(NULL, server_port, &amp;addr_hints, &amp;addr_server);"><pre><code>char server_port[6];
memset(server_port, 0, 6);
sprintf(server_port, &#34;%d&#34;, htons(TCP_PORT));

struct addrinfo addr_hints;
memset(&amp;addr_hints, 0, sizeof(addr_hints));
addr_hints.ai_family = AF_INET;
addr_hints.ai_socktype = SOCK_STREAM;
addr_hints.ai_protocol = tcp_proto-&gt;p_proto;

struct addrinfo* addr_server;
rc = getaddrinfo(NULL, server_port, &amp;addr_hints, &amp;addr_server);
</code></pre></div>
<p dir="auto">Converts the TCP port into network byte order using <code>htons()</code>.</p>
<p dir="auto">Initializes an addrinfo structure to specify connection parameters:</p>
<ul dir="auto">
<li>ai_family = AF_INET: IPv4.</li>
<li>ai_socktype = SOCK_STREAM: TCP socket.</li>
</ul>
<p dir="auto">Resolves the server&#39;s address information using <code>getaddrinfo()</code>.</p>
<p dir="auto"><strong>Create server socket</strong></p>
<div data-snippet-clipboard-copy-content="int sock_server = socket(addr_server-&gt;ai_family, addr_server-&gt;ai_socktype, addr_server-&gt;ai_protocol);"><pre><code>int sock_server = socket(addr_server-&gt;ai_family, addr_server-&gt;ai_socktype, addr_server-&gt;ai_protocol);
</code></pre></div>
<p dir="auto">Creates a socket using the <code>socket()</code> function.</p>
<div data-snippet-clipboard-copy-content="int sock_server_opt = 1;
rc = setsockopt(sock_server, SOL_SOCKET, SO_REUSEADDR | SO_KEEPALIVE, &amp;sock_server_opt, sizeof(sock_server_opt));"><pre><code>int sock_server_opt = 1;
rc = setsockopt(sock_server, SOL_SOCKET, SO_REUSEADDR | SO_KEEPALIVE, &amp;sock_server_opt, sizeof(sock_server_opt));
</code></pre></div>
<p dir="auto">Configures socket options:</p>
<p dir="auto"><code>SO_REUSEADDR</code>: Allows the server to reuse the same port.</p>
<p dir="auto"><code>SO_KEEPALIVE</code>: Keeps the connection alive.</p>
<p dir="auto"><strong>Bind socket to address and start to listen</strong></p>
<div data-snippet-clipboard-copy-content="for (addrinfo* p_server = addr_server; p_server != NULL; p_server = p_server-&gt;ai_next)
{
    rc = bind(sock_server, p_server-&gt;ai_addr, p_server-&gt;ai_addrlen);
    if (rc == 0)
    {
        break;
    }
}"><pre><code>for (addrinfo* p_server = addr_server; p_server != NULL; p_server = p_server-&gt;ai_next)
{
    rc = bind(sock_server, p_server-&gt;ai_addr, p_server-&gt;ai_addrlen);
    if (rc == 0)
    {
        break;
    }
}
</code></pre></div>
<p dir="auto">Binds the socket to the resolved address using <code>bind()</code> function.</p>
<p dir="auto">Iterates over potential addresses (<code>addrinfo</code> list) until successful.</p>
<div data-snippet-clipboard-copy-content="rc = listen(sock_server, 3);"><pre><code>rc = listen(sock_server, 3);
</code></pre></div>
<p dir="auto">Starts listening for incoming client connections with a backlog of 3.</p>
<p dir="auto"><strong>Server Loop - Accept incoming client connection</strong></p>
<div data-snippet-clipboard-copy-content="struct sockaddr addr_client;
socklen_t addr_len = sizeof(addr_client);
sock_client = accept(sock_server, (struct sockaddr*)&amp;addr_client, &amp;addr_len);"><pre><code>struct sockaddr addr_client;
socklen_t addr_len = sizeof(addr_client);
sock_client = accept(sock_server, (struct sockaddr*)&amp;addr_client, &amp;addr_len);
</code></pre></div>
<p dir="auto">Accepts incoming client connections using <code>accept()</code> function.</p>
<p dir="auto"><strong>Server Loop - Receiving requests</strong></p>
<div data-snippet-clipboard-copy-content="int received_bytes = recv(sock_client, request_buffer, MESSAGE_SIZE, 0);"><pre><code>int received_bytes = recv(sock_client, request_buffer, MESSAGE_SIZE, 0);
</code></pre></div>
<p dir="auto">Reads data from the client using <code>recv()</code> function.</p>
<p dir="auto"><strong>Server Loop - Processing requests</strong></p>
<div data-snippet-clipboard-copy-content="if (strcmp(request_buffer, &#34;exit&#34;) == 0
|| strcmp(request_buffer, &#34;quit&#34;) == 0
|| strcmp(request_buffer, &#34;shutdown&#34;) == 0)
{
    sprintf(response_buffer, &#34;OK&#34;);
    rc = send(sock_client, response_buffer, MESSAGE_SIZE, 0);
    close(sock_client);
    break;
}
else if (strcmp(request_buffer, &#34;time&#34;) == 0)
{
    sprintf(response_buffer, &#34;%d&#34;, time(NULL));
    rc = send(sock_client, response_buffer, MESSAGE_SIZE, 0);
}
else
{
    sprintf(response_buffer, &#34;Unknown request&#34;);
    rc = send(sock_client, response_buffer, MESSAGE_SIZE, 0);
}"><pre><code>if (strcmp(request_buffer, &#34;exit&#34;) == 0
|| strcmp(request_buffer, &#34;quit&#34;) == 0
|| strcmp(request_buffer, &#34;shutdown&#34;) == 0)
{
    sprintf(response_buffer, &#34;OK&#34;);
    rc = send(sock_client, response_buffer, MESSAGE_SIZE, 0);
    close(sock_client);
    break;
}
else if (strcmp(request_buffer, &#34;time&#34;) == 0)
{
    sprintf(response_buffer, &#34;%d&#34;, time(NULL));
    rc = send(sock_client, response_buffer, MESSAGE_SIZE, 0);
}
else
{
    sprintf(response_buffer, &#34;Unknown request&#34;);
    rc = send(sock_client, response_buffer, MESSAGE_SIZE, 0);
}
</code></pre></div>
<p dir="auto">Handles specific commands:</p>
<p dir="auto"><code>time</code>: Sends the current time.</p>
<p dir="auto"><code>exit, quit, shutdown</code>: Terminates the connection.</p>
<p dir="auto"><code>Other inputs</code>: Responds with &#34;Unknown request&#34;.</p>

<p dir="auto"><strong>Choose protocol and resolve server address</strong></p>
<div data-snippet-clipboard-copy-content="struct protoent* tcp_proto = getprotobyname(PROTOCOL);

struct addrinfo addr_hints;
memset(&amp;addr_hints, 0, sizeof(addr_hints));
addr_hints.ai_family = AF_INET;
addr_hints.ai_socktype = SOCK_STREAM;
addr_hints.ai_protocol = tcp_proto-&gt;p_proto;

struct addrinfo* addr_server;
rc = getaddrinfo(HOST_NAME, server_port, &amp;addr_hints, &amp;addr_server);"><pre><code>struct protoent* tcp_proto = getprotobyname(PROTOCOL);

struct addrinfo addr_hints;
memset(&amp;addr_hints, 0, sizeof(addr_hints));
addr_hints.ai_family = AF_INET;
addr_hints.ai_socktype = SOCK_STREAM;
addr_hints.ai_protocol = tcp_proto-&gt;p_proto;

struct addrinfo* addr_server;
rc = getaddrinfo(HOST_NAME, server_port, &amp;addr_hints, &amp;addr_server);
</code></pre></div>
<p dir="auto">Resolves the server&#39;s address.</p>
<p dir="auto"><strong>Create client socket and connect to server</strong></p>
<div data-snippet-clipboard-copy-content="int sock_client = socket(addr_server-&gt;ai_family, addr_server-&gt;ai_socktype, addr_server-&gt;ai_protocol);

for (addrinfo* p_server = addr_server; p_server != NULL; p_server = p_server-&gt;ai_next)
{
    rc = connect(sock_client, p_server-&gt;ai_addr, p_server-&gt;ai_addrlen);
    if (rc == 0)
    {
        break;
    }
}"><pre><code>int sock_client = socket(addr_server-&gt;ai_family, addr_server-&gt;ai_socktype, addr_server-&gt;ai_protocol);

for (addrinfo* p_server = addr_server; p_server != NULL; p_server = p_server-&gt;ai_next)
{
    rc = connect(sock_client, p_server-&gt;ai_addr, p_server-&gt;ai_addrlen);
    if (rc == 0)
    {
        break;
    }
}
</code></pre></div>
<p dir="auto">Creates a socket and connects to the server.</p>
<p dir="auto">Iterates over potential addresses (<code>addrinfo</code> list) until successful.</p>
<p dir="auto"><strong>Client Loop - Send request and wait for response</strong></p>
<div data-snippet-clipboard-copy-content="fgets(request_buffer, MESSAGE_SIZE, stdin);
request_buffer[strcspn(request_buffer, &#34;\n&#34;)] = 0;
send(sock_client, request_buffer, strlen(request_buffer), 0);
recv(sock_client, response_buffer, MESSAGE_SIZE, 0);"><pre><code>fgets(request_buffer, MESSAGE_SIZE, stdin);
request_buffer[strcspn(request_buffer, &#34;\n&#34;)] = 0;
send(sock_client, request_buffer, strlen(request_buffer), 0);
recv(sock_client, response_buffer, MESSAGE_SIZE, 0);
</code></pre></div>
<p dir="auto">Sends user input to the server and waits for a response.</p>

<div data-snippet-clipboard-copy-content="if (strcmp(argv[1], &#34;server&#34;) == 0)
{
    run_server();
}
else if (strcmp(argv[1], &#34;client&#34;) == 0)
{
    run_client();
}"><pre><code>if (strcmp(argv[1], &#34;server&#34;) == 0)
{
    run_server();
}
else if (strcmp(argv[1], &#34;client&#34;) == 0)
{
    run_client();
}
</code></pre></div>
<p dir="auto">Determines whether the program will run as a server or client based on the command-line argument.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Multithread TCP-Based Client-Server</h2><a id="user-content-multithread-tcp-based-client-server" aria-label="Permalink: Multithread TCP-Based Client-Server" href="#multithread-tcp-based-client-server"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The provided C program is a simple implementation of a TCP client-server application and works well for basic use cases. However, it has several limitations, particularly on the server-side: it can only handle one client connection at a time. While it processes a request from one client, other clients are left waiting.</p>
<p dir="auto"><strong>Improvement:</strong></p>
<p dir="auto">Use multithreading to handle multiple clients concurrently. Each client connection can be assigned to a separate thread, allowing the server to process multiple requests simultaneously.</p>
<p dir="auto">Click <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/blob/main/00_tutorials/09_multithread_client_server.c">HERE</a> for a complete source code.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Setup Server with multithreading</h3><a id="user-content-setup-server-with-multithreading" aria-label="Permalink: Setup Server with multithreading" href="#setup-server-with-multithreading"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The setup of Server socket and connection is the same as before. But in the Server Loop, each client connection will be handled in a detached thread.</p>
<div data-snippet-clipboard-copy-content="int* p_sock_client = (int*)calloc(1, sizeof(int));
*p_sock_client = sock_client;
pthread_t client_thread;
rc = pthread_create(&amp;client_thread, NULL, server_handle_client, p_sock_client);

rc = pthread_detach(client_thread);"><pre><code>int* p_sock_client = (int*)calloc(1, sizeof(int));
*p_sock_client = sock_client;
pthread_t client_thread;
rc = pthread_create(&amp;client_thread, NULL, server_handle_client, p_sock_client);

rc = pthread_detach(client_thread);
</code></pre></div>
<p dir="auto"><strong>Thread Code for a client</strong></p>
<div data-snippet-clipboard-copy-content="void* server_handle_client(void* arg)
{
    int* sock_client = ((int*)arg);
    if (sock_client == NULL)
    {
        return NULL;
    }

    int rc;
    char request_buffer[MESSAGE_SIZE];
    char response_buffer[MESSAGE_SIZE];
    while (true)
    {
        memset(request_buffer, 0, MESSAGE_SIZE);
        memset(response_buffer, 0, MESSAGE_SIZE);

        int received_bytes = recv(*sock_client, request_buffer, MESSAGE_SIZE, 0);
        
        rc = send(*sock_client, response_buffer, MESSAGE_SIZE, 0);

        if (strcmp(request_buffer, &#34;exit&#34;) == 0
        || strcmp(request_buffer, &#34;quit&#34;) == 0
        || strcmp(request_buffer, &#34;shutdown&#34;) == 0)
        {
            break;
        }
    }

    if (sock_client != NULL)
    {
        free(sock_client);
    }

    return NULL;
}"><pre><code>void* server_handle_client(void* arg)
{
    int* sock_client = ((int*)arg);
    if (sock_client == NULL)
    {
        return NULL;
    }

    int rc;
    char request_buffer[MESSAGE_SIZE];
    char response_buffer[MESSAGE_SIZE];
    while (true)
    {
        memset(request_buffer, 0, MESSAGE_SIZE);
        memset(response_buffer, 0, MESSAGE_SIZE);

        int received_bytes = recv(*sock_client, request_buffer, MESSAGE_SIZE, 0);
        
        rc = send(*sock_client, response_buffer, MESSAGE_SIZE, 0);

        if (strcmp(request_buffer, &#34;exit&#34;) == 0
        || strcmp(request_buffer, &#34;quit&#34;) == 0
        || strcmp(request_buffer, &#34;shutdown&#34;) == 0)
        {
            break;
        }
    }

    if (sock_client != NULL)
    {
        free(sock_client);
    }

    return NULL;
}
</code></pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Simple UDP-Based Client-Server</h2><a id="user-content-simple-udp-based-client-server" aria-label="Permalink: Simple UDP-Based Client-Server" href="#simple-udp-based-client-server"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Overall, the setup for UDP-Based client server application is similar with TCP-Based. I will show the different codes only.</p>
<p dir="auto">Click <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/blob/main/00_tutorials/10_peer_to_peer_client_server.c">HERE</a> for a complete source code.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/nguyenchiemminhvu/LinuxNetworkProgramming/refs/heads/main/udp_based_client_server.png"><img src="https://raw.githubusercontent.com/nguyenchiemminhvu/LinuxNetworkProgramming/refs/heads/main/udp_based_client_server.png" alt="UDP-Based Client-Server"/></a></p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Necessary Headers And Macros</h3><a id="user-content-necessary-headers-and-macros-1" aria-label="Permalink: Necessary Headers And Macros" href="#necessary-headers-and-macros-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="#define PROTOCOL &#34;udp&#34;
#define UDP_PORT 45123
#define MESSAGE_SIZE 1024
#define HOST_NAME &#34;localhost&#34;"><pre><code>#define PROTOCOL &#34;udp&#34;
#define UDP_PORT 45123
#define MESSAGE_SIZE 1024
#define HOST_NAME &#34;localhost&#34;
</code></pre></div>
<p dir="auto">Similar as previous explanation, but now the protocol is <strong>UDP</strong>.</p>

<p dir="auto"><strong>Resolve Server Address</strong></p>
<div data-snippet-clipboard-copy-content="struct protoent* udp_protocol = getprotobyname(PROTOCOL);

struct addrinfo hints;
memset(&amp;hints, 0, sizeof(hints));
hints.ai_family = AF_INET;
hints.ai_socktype = SOCK_DGRAM;
hints.ai_protocol = udp_protocol-&gt;p_proto;
struct addrinfo* addr_server;
rc = getaddrinfo(NULL, port_server, &amp;hints, &amp;addr_server); // INADDR_ANY"><pre><code>struct protoent* udp_protocol = getprotobyname(PROTOCOL);

struct addrinfo hints;
memset(&amp;hints, 0, sizeof(hints));
hints.ai_family = AF_INET;
hints.ai_socktype = SOCK_DGRAM;
hints.ai_protocol = udp_protocol-&gt;p_proto;
struct addrinfo* addr_server;
rc = getaddrinfo(NULL, port_server, &amp;hints, &amp;addr_server); // INADDR_ANY
</code></pre></div>
<p dir="auto">Specifies the socket type datagram for UDP connection.</p>
<p dir="auto"><strong>Server Loop - Listen client request and response</strong></p>
<div data-snippet-clipboard-copy-content="while (1)
{
    struct sockaddr addr_client;
    socklen_t addr_client_len = sizeof(struct sockaddr);
    int received_bytes = recvfrom(sock_server, request_buffer, MESSAGE_SIZE, 0, &amp;addr_client, &amp;addr_client_len);

    sprintf(response_buffer, &#34;Server received request at %d&#34;, time(NULL));
    int response_buffer_len = strlen(response_buffer);
    rc = sendto(sock_server, response_buffer, response_buffer_len, 0, &amp;addr_client, addr_client_len);
}"><pre><code>while (1)
{
    struct sockaddr addr_client;
    socklen_t addr_client_len = sizeof(struct sockaddr);
    int received_bytes = recvfrom(sock_server, request_buffer, MESSAGE_SIZE, 0, &amp;addr_client, &amp;addr_client_len);

    sprintf(response_buffer, &#34;Server received request at %d&#34;, time(NULL));
    int response_buffer_len = strlen(response_buffer);
    rc = sendto(sock_server, response_buffer, response_buffer_len, 0, &amp;addr_client, addr_client_len);
}
</code></pre></div>
<p dir="auto">The <code>recvfrom()</code> and <code>sendto()</code> functions are the general format of <code>recv()</code> and <code>send()</code> functions, they are suitable to use in UDP packet transferring.</p>

<div data-snippet-clipboard-copy-content="struct protoent* udp_protocol = getprotobyname(PROTOCOL);

struct addrinfo hints;
memset(&amp;hints, 0, sizeof(hints));
hints.ai_family = AF_INET;
hints.ai_socktype = SOCK_DGRAM;
hints.ai_protocol = udp_protocol-&gt;p_proto;
struct addrinfo* addr_server;
rc = getaddrinfo(HOST_NAME, port_server, &amp;hints, &amp;addr_server);"><pre><code>struct protoent* udp_protocol = getprotobyname(PROTOCOL);

struct addrinfo hints;
memset(&amp;hints, 0, sizeof(hints));
hints.ai_family = AF_INET;
hints.ai_socktype = SOCK_DGRAM;
hints.ai_protocol = udp_protocol-&gt;p_proto;
struct addrinfo* addr_server;
rc = getaddrinfo(HOST_NAME, port_server, &amp;hints, &amp;addr_server);
</code></pre></div>
<p dir="auto">Specifies the socket type datagram for UDP connection.</p>
<p dir="auto"><strong>Client Loop - Send request and wait for response</strong></p>
<div data-snippet-clipboard-copy-content="char request_buffer[MESSAGE_SIZE];
char response_buffer[MESSAGE_SIZE];
while (1)
{
    printf(&#34;Enter command: &#34;);
    fgets(request_buffer, MESSAGE_SIZE, stdin);
    request_buffer[strcspn(request_buffer, &#34;\r\n&#34;)] = &#39;\0&#39;;

    int request_buffer_len = strlen(request_buffer);
    rc = sendto(sock_client, request_buffer, request_buffer_len, 0, addr_server-&gt;ai_addr, addr_server-&gt;ai_addrlen);

    int received_bytes = recvfrom(sock_client, response_buffer, MESSAGE_SIZE, 0, addr_server-&gt;ai_addr, &amp;addr_server-&gt;ai_addrlen);
}"><pre><code>char request_buffer[MESSAGE_SIZE];
char response_buffer[MESSAGE_SIZE];
while (1)
{
    printf(&#34;Enter command: &#34;);
    fgets(request_buffer, MESSAGE_SIZE, stdin);
    request_buffer[strcspn(request_buffer, &#34;\r\n&#34;)] = &#39;\0&#39;;

    int request_buffer_len = strlen(request_buffer);
    rc = sendto(sock_client, request_buffer, request_buffer_len, 0, addr_server-&gt;ai_addr, addr_server-&gt;ai_addrlen);

    int received_bytes = recvfrom(sock_client, response_buffer, MESSAGE_SIZE, 0, addr_server-&gt;ai_addr, &amp;addr_server-&gt;ai_addrlen);
}
</code></pre></div>


<p dir="auto">Non-blocking sockets support to build responsive applications or handle multiple connections without blocking the main thread.</p>
<p dir="auto">The code <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/blob/main/00_tutorials/11_non_blocking_sockets.c">HERE</a> demonstrates the use of non-blocking sockets in a simple TCP-based application.</p>
<p dir="auto">In this example, the <code>fcntl()</code> function is used to set the server and client sockets to non-blocking mode.</p>
<div data-snippet-clipboard-copy-content="#include &lt;fcntl.h&gt;

int fcntl(int fd, int cmd, ... /* arg */);"><pre><code>#include &lt;fcntl.h&gt;

int fcntl(int fd, int cmd, ... /* arg */);
</code></pre></div>
<p dir="auto"><strong>Parameters:</strong></p>
<p dir="auto"><code>fd</code>: The file descriptor to operate on. It must already be open.</p>
<p dir="auto"><code>cmd</code>: The command to perform on the file descriptor. Common commands include:</p>
<ul dir="auto">
<li><code>F_DUPFD</code>: Duplicate a file descriptor.</li>
<li><code>F_GETFD</code>: Get the file descriptor flags.</li>
<li><code>F_SETFD</code>: Set the file descriptor flags.</li>
<li><code>F_GETFL</code>: Get the file status flags.</li>
<li><code>F_SETFL</code>: Set the file status flags.</li>
<li><code>F_SETLK</code>, <code>F_SETLKW</code>, <code>F_GETLK</code>: Manage file locks.</li>
</ul>
<p dir="auto"><code>arg (optional)</code>: An argument whose type and meaning depend on the cmd. It&#39;s typically an integer or a pointer, depending on the command.</p>
<p dir="auto"><strong>Utility Functions</strong></p>
<div data-snippet-clipboard-copy-content="void set_non_blocking(int socket)
{
    int flags = fcntl(socket, F_GETFL, 0);
    if (flags == -1)
    {
        report_error(&#34;fcntl(F_GETFL) failed&#34;);
        return;
    }

    if (fcntl(socket, F_SETFL, flags | O_NONBLOCK) == -1)
    {
        report_error(&#34;fcntl(F_SETFL) failed&#34;);
    }
}"><pre><code>void set_non_blocking(int socket)
{
    int flags = fcntl(socket, F_GETFL, 0);
    if (flags == -1)
    {
        report_error(&#34;fcntl(F_GETFL) failed&#34;);
        return;
    }

    if (fcntl(socket, F_SETFL, flags | O_NONBLOCK) == -1)
    {
        report_error(&#34;fcntl(F_SETFL) failed&#34;);
    }
}
</code></pre></div>
<p dir="auto">The utility function <code>set_non_blocking()</code> is used to configure the file descriptor of client and server sockets to operate non-blocking mode.</p>
<p dir="auto"><strong>Server socket initialization and binding</strong></p>
<div data-snippet-clipboard-copy-content="struct protoent* tcp_proto = getprotobyname(PROTOCOL);
int sock_server = socket(addr_server-&gt;ai_family, addr_server-&gt;ai_socktype, addr_server-&gt;ai_protocol);
set_non_blocking(sock_server);"><pre><code>struct protoent* tcp_proto = getprotobyname(PROTOCOL);
int sock_server = socket(addr_server-&gt;ai_family, addr_server-&gt;ai_socktype, addr_server-&gt;ai_protocol);
set_non_blocking(sock_server);
</code></pre></div>
<p dir="auto">Creates a TCP socket and sets it to non-blocking mode.</p>
<p dir="auto">Using <code>set_non_blocking()</code> ensures that the server does not block while waiting for connections.</p>
<p dir="auto"><strong>Accept client connection</strong></p>
<div data-snippet-clipboard-copy-content="sock_client = accept(sock_server, &amp;addr_client, &amp;addr_client_len);
if (sock_client &lt; 0)
{
    if (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK)
    {
        report_error(&#34;Server accept() failed&#34;);
        break;
    }
    else
    {
        printf(&#34;No client connection\n&#34;);
    }
}
else
{
    set_non_blocking(sock_client);
}"><pre><code>sock_client = accept(sock_server, &amp;addr_client, &amp;addr_client_len);
if (sock_client &lt; 0)
{
    if (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK)
    {
        report_error(&#34;Server accept() failed&#34;);
        break;
    }
    else
    {
        printf(&#34;No client connection\n&#34;);
    }
}
else
{
    set_non_blocking(sock_client);
}
</code></pre></div>
<p dir="auto">Because server socket is non-blocking, the <code>accept()</code> call returns immediately. If there is no connection available, errno is set to <code>EAGAIN</code> or <code>EWOULDBLOCK</code>.</p>
<p dir="auto"><strong>Receiving client data</strong></p>
<div data-snippet-clipboard-copy-content="int received_bytes = recv(sock_client, buffer, MESSAGE_SIZE, 0);
if (received_bytes &lt; 0)
{
    if (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK)
    {
        report_error(&#34;Server recv() failed&#34;);
        break;
    }
}"><pre><code>int received_bytes = recv(sock_client, buffer, MESSAGE_SIZE, 0);
if (received_bytes &lt; 0)
{
    if (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK)
    {
        report_error(&#34;Server recv() failed&#34;);
        break;
    }
}
</code></pre></div>
<p dir="auto">Socket of client connection is set to non-blocking mode as well, <code>recv()</code> does not block when no data is available. If no data is received, errno is set to <code>EAGAIN</code> or <code>EWOULDBLOCK</code>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Synchronous I/O Multiplexing with select()</h3><a id="user-content-synchronous-io-multiplexing-with-select" aria-label="Permalink: Synchronous I/O Multiplexing with select()" href="#synchronous-io-multiplexing-with-select"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Applying non-blocking file descriptor technique to network sockets allows the server to accept multiple client connection at a time without the need of using multithreading.</p>
<p dir="auto">However, there is a limitation in the <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/blob/main/00_tutorials/11_non_blocking_sockets.c">previous sample code</a>.</p>
<p dir="auto">The Server Loop continuously checks for connections and data, which can lead to high CPU usage.</p>
<p dir="auto">To address this, we can use I/O Multiplexing mechanism with the help of <code>select()</code> function.</p>
<div data-snippet-clipboard-copy-content="#include &lt;sys/select.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);"><pre><code>#include &lt;sys/select.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
</code></pre></div>
<p dir="auto"><strong>Parameters:</strong></p>
<p dir="auto"><code>nfds</code>: Specifies the range of file descriptors to be checked. This is usually set to the highest file descriptor + 1.</p>
<p dir="auto"><code>readfds</code>: A pointer to a set of file descriptors to monitor for readability. Use FD_SET() to add descriptors and FD_ISSET() to check them.</p>
<p dir="auto"><code>writefds</code>: A pointer to a set of file descriptors to monitor for writability.</p>
<p dir="auto"><code>exceptfds</code>: A pointer to a set of file descriptors to monitor for exceptional conditions.</p>
<p dir="auto"><code>timeout</code>: A pointer to a struct timeval that specifies the maximum time to wait. It can be: <code>NULL</code>: Wait indefinitely. <code>Zero timeout</code>: Non-blocking mode, checks the status immediately. <code>Specific value</code>: Blocks for the specified duration.</p>
<p dir="auto"><strong>Return Value:</strong></p>
<p dir="auto"><code>&gt; 0</code>: Number of file descriptors ready for I/O.</p>
<p dir="auto"><code>0</code>: Timeout occurred, no file descriptors are ready.</p>
<p dir="auto"><code>-1</code>: An error occurred, and errno is set appropriately.</p>
<p dir="auto">The <code>select()</code> function in C is used for monitoring multiple file descriptors to see if they are ready for I/O operations such as reading, writing, or if there’s an exceptional condition. It’s commonly used in network programming for managing multiple sockets without multithreading.</p>
<div data-snippet-clipboard-copy-content="#include &lt;sys/select.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);"><pre><code>#include &lt;sys/select.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
</code></pre></div>
<p dir="auto"><code>nfds</code>: The highest-numbered file descriptor + 1.</p>
<p dir="auto"><code>readfds</code>: Set of FDs to check for readability.</p>
<p dir="auto"><code>writefds</code>: Set of FDs to check for writability.</p>
<p dir="auto"><code>exceptfds</code>: Set of FDs to check for exceptional conditions.</p>
<p dir="auto"><code>timeout</code>: Maximum time <code>select()</code> should block, or <code>NULL</code> for indefinite blocking.</p>
<p dir="auto">Checkout the completed sample code using I/O Multiplexing with <code>select()</code> function <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/blob/main/00_tutorials/12_multiplexing_select_client_server.c">HERE</a>.</p>
<p dir="auto"><strong>Initialization of fd_set</strong></p>
<div data-snippet-clipboard-copy-content="fd_set read_set;
fd_set master_set;
FD_ZERO(&amp;master_set);
FD_SET(sock_server, &amp;master_set);
global_max_fd = MAX(global_max_fd, sock_server);"><pre><code>fd_set read_set;
fd_set master_set;
FD_ZERO(&amp;master_set);
FD_SET(sock_server, &amp;master_set);
global_max_fd = MAX(global_max_fd, sock_server);
</code></pre></div>
<p dir="auto"><code>master_set</code> keeps track of all file descriptors to monitor.</p>
<p dir="auto"><code>read_set</code> is a temporary copy used by select() to determine which descriptors are ready for I/O.</p>
<p dir="auto"><code>global_max_fd</code> variable is updated to the highest descriptor value for use in <code>select()</code>.</p>
<p dir="auto"><strong>I/O Multiplexing with select()</strong></p>
<div data-snippet-clipboard-copy-content="read_set = master_set;

int activity = select(global_max_fd + 1, &amp;read_set, NULL, NULL, NULL);
if (activity &lt; 0)
{
    report_error(&#34;Server select() failed&#34;);
}"><pre><code>read_set = master_set;

int activity = select(global_max_fd + 1, &amp;read_set, NULL, NULL, NULL);
if (activity &lt; 0)
{
    report_error(&#34;Server select() failed&#34;);
}
</code></pre></div>
<p dir="auto"><code>select()</code> monitors the file descriptors in read_set for readability. It blocks until at least one descriptor is ready for reading.</p>
<p dir="auto"><strong>Handling Ready Descriptors</strong></p>
<div data-snippet-clipboard-copy-content="for (int i = 0; i &lt;= global_max_fd; i++)
{
    if (FD_ISSET(i, &amp;read_set))
    {
        if (i == sock_server)
        {
            // Handle new incoming connections
        }
        else
        {
            // Handle client I/O
        }
    }
}"><pre><code>for (int i = 0; i &lt;= global_max_fd; i++)
{
    if (FD_ISSET(i, &amp;read_set))
    {
        if (i == sock_server)
        {
            // Handle new incoming connections
        }
        else
        {
            // Handle client I/O
        }
    }
}
</code></pre></div>
<p dir="auto"><code>FD_ISSET(i, &amp;read_set)</code> checks if descriptor i is ready for reading.</p>
<p dir="auto">If I/O is ready on the server socket, it has a new connection to accept. Otherwise, the descriptor corresponds to a client socket, and data can be read from it.</p>
<p dir="auto"><strong>Accepting Server I/O</strong></p>
<div data-snippet-clipboard-copy-content="struct sockaddr addr_client;
socklen_t addr_client_len = sizeof(struct sockaddr);
int sock_client = accept(sock_server, &amp;addr_client, &amp;addr_client_len);
FD_SET(sock_client, &amp;master_set);
global_max_fd = MAX(global_max_fd, sock_client);"><pre><code>struct sockaddr addr_client;
socklen_t addr_client_len = sizeof(struct sockaddr);
int sock_client = accept(sock_server, &amp;addr_client, &amp;addr_client_len);
FD_SET(sock_client, &amp;master_set);
global_max_fd = MAX(global_max_fd, sock_client);
</code></pre></div>
<p dir="auto">Adds the new client socket (sock_client) to <code>master_set</code> for monitoring.</p>
<p dir="auto">Updates <code>global_max_fd</code> if the new socket&#39;s value is higher.</p>
<p dir="auto"><strong>Handling Client I/O</strong></p>
<div data-snippet-clipboard-copy-content="int received_bytes = recv(i, request_buffer, MESSAGE_SIZE, 0);
if (received_bytes &lt;= 0)
{
    // Client disconnected or error occurred
    close(i);
    FD_CLR(i, &amp;master_set);
}
else
{
    // Process received data and send a response
    send(i, response_buffer, strlen(response_buffer), 0);
}"><pre><code>int received_bytes = recv(i, request_buffer, MESSAGE_SIZE, 0);
if (received_bytes &lt;= 0)
{
    // Client disconnected or error occurred
    close(i);
    FD_CLR(i, &amp;master_set);
}
else
{
    // Process received data and send a response
    send(i, response_buffer, strlen(response_buffer), 0);
}
</code></pre></div>
<p dir="auto">If received_bytes &lt;= 0, the client either disconnected or an error occurred, then removes the socket from <code>master_set</code>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Synchronous I/O Multiplexing with poll()</h3><a id="user-content-synchronous-io-multiplexing-with-poll" aria-label="Permalink: Synchronous I/O Multiplexing with poll()" href="#synchronous-io-multiplexing-with-poll"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<blockquote>
<p dir="auto">WARNING: select() can monitor only file descriptors numbers that are less than FD_SETSIZE (1024)—an unreasonably low limit for many modern applications—and this limitation will not change. All modern applications should instead use poll(2) or epoll(7), which do not suffer this limitation.</p>
</blockquote>
<p dir="auto">Similar to <code>select()</code>, the <code>poll()</code> function provides a way to monitor multiple file descriptors for readiness to perform I/O operations. However, <code>poll()</code> overcomes some limitations of <code>select()</code>, such as the fixed size of the file descriptor set.</p>
<p dir="auto">With <code>poll()</code>, the server can efficiently handle multiple connections without needing multithreading, while addressing high CPU usage in the server loop.</p>
<div data-snippet-clipboard-copy-content="#include &lt;poll.h&gt;
#include &lt;unistd.h&gt;

int poll(struct pollfd *fds, nfds_t nfds, int timeout);"><pre><code>#include &lt;poll.h&gt;
#include &lt;unistd.h&gt;

int poll(struct pollfd *fds, nfds_t nfds, int timeout);
</code></pre></div>
<p dir="auto"><strong>Parameters:</strong></p>
<p dir="auto"><code>fds</code>: A pointer to an array of struct pollfd, which represents the file descriptors to monitor.</p>
<p dir="auto"><code>nfds</code>: The number of file descriptors in the fds array.</p>
<p dir="auto"><code>timeout</code>: Specifies the maximum time to wait (in milliseconds). It can be: <code>-1</code>: Wait indefinitely. <code>0</code>: Return immediately (non-blocking mode). <code>Positive value</code>: Block for the specified time.</p>
<p dir="auto"><strong>Return Value:</strong></p>
<p dir="auto"><code>&gt; 0</code>: The number of file descriptors with events.</p>
<p dir="auto"><code>0</code>: Timeout occurred, no events detected.</p>
<p dir="auto"><code>-1</code>: An error occurred, and errno is set appropriately.</p>
<p dir="auto">The <code>poll()</code> function is more scalable than <code>select()</code> for monitoring a large number of file descriptors. It is commonly used in network programming to manage multiple connections, enabling efficient I/O multiplexing.</p>
<p dir="auto">Check out the complete code for poll() I/O multiplexing <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/blob/main/00_tutorials/13_multiplexing_poll_client_server.c">HERE</a>.</p>
<p dir="auto"><strong>Initialization of pollfd array</strong></p>
<div data-snippet-clipboard-copy-content="struct pollfd fds[MAX_CONNECTION];
memset(&amp;fds, 0, sizeof(fds));
fds[0].fd = sock_server;    // Monitor server socket
fds[0].events = POLLIN;     // Monitor for incoming connections
int nfds = 1;               // Start with one monitored socket"><pre><code>struct pollfd fds[MAX_CONNECTION];
memset(&amp;fds, 0, sizeof(fds));
fds[0].fd = sock_server;    // Monitor server socket
fds[0].events = POLLIN;     // Monitor for incoming connections
int nfds = 1;               // Start with one monitored socket
</code></pre></div>
<p dir="auto">The server socket is the first entry in the <code>pollfd</code> array, which is dynamically updated as clients connect or disconnect.</p>
<p dir="auto"><strong>Server Loop with poll()</strong></p>
<div data-snippet-clipboard-copy-content="int activity = poll(fds, nfds, -1);  // Wait indefinitely
if (activity &lt; 0)
{
    report_error(&#34;Server poll() failed&#34;);
    break;
}"><pre><code>int activity = poll(fds, nfds, -1);  // Wait indefinitely
if (activity &lt; 0)
{
    report_error(&#34;Server poll() failed&#34;);
    break;
}
</code></pre></div>
<p dir="auto">The loop continuously monitors the file descriptors and handles events as they occur.</p>
<p dir="auto"><strong>Handle Server socket ready to read event</strong></p>
<div data-snippet-clipboard-copy-content="if (fds[0].revents &amp; POLLIN)
{
    struct sockaddr addr_client;
    socklen_t addr_client_len = sizeof(struct sockaddr);
    int sock_client = accept(fds[0].fd, &amp;addr_client, &amp;addr_client_len);
    if (nfds &lt; MAX_CONNECTION)
    {
        fds[nfds].fd = sock_client;
        fds[nfds].events = POLLIN;  // Monitor for incoming data
        nfds++;
    }
}"><pre><code>if (fds[0].revents &amp; POLLIN)
{
    struct sockaddr addr_client;
    socklen_t addr_client_len = sizeof(struct sockaddr);
    int sock_client = accept(fds[0].fd, &amp;addr_client, &amp;addr_client_len);
    if (nfds &lt; MAX_CONNECTION)
    {
        fds[nfds].fd = sock_client;
        fds[nfds].events = POLLIN;  // Monitor for incoming data
        nfds++;
    }
}
</code></pre></div>
<p dir="auto">Each new connection is added to the <code>pollfd</code> array, and the total monitored descriptors <code>nfds</code> is incremented.</p>
<p dir="auto"><strong>Handle client I/O</strong></p>
<div data-snippet-clipboard-copy-content="for (int i = 1; i &gt;= 1 &amp;&amp; i &lt; nfds; i++)
{
    if (fds[i].revents &amp; POLLIN)
    {
        int received_bytes = recv(fds[i].fd, request_buffer, MESSAGE_SIZE, 0);
        if (received_bytes &lt;= 0)
        {
            close(fds[i].fd);
            fds[i].fd = fds[nfds - 1].fd;  // Replace with the last descriptor
            nfds--;                        // Reduce the total count
            i--;
        }
        else
        {
            sprintf(response_buffer, &#34;Server time: %ld&#34;, time(NULL));
            send(fds[i].fd, response_buffer, strlen(response_buffer), 0);
        }
    }
}"><pre><code>for (int i = 1; i &gt;= 1 &amp;&amp; i &lt; nfds; i++)
{
    if (fds[i].revents &amp; POLLIN)
    {
        int received_bytes = recv(fds[i].fd, request_buffer, MESSAGE_SIZE, 0);
        if (received_bytes &lt;= 0)
        {
            close(fds[i].fd);
            fds[i].fd = fds[nfds - 1].fd;  // Replace with the last descriptor
            nfds--;                        // Reduce the total count
            i--;
        }
        else
        {
            sprintf(response_buffer, &#34;Server time: %ld&#34;, time(NULL));
            send(fds[i].fd, response_buffer, strlen(response_buffer), 0);
        }
    }
}
</code></pre></div>
<p dir="auto">Receives data from the client.</p>
<p dir="auto">Sends a response or disconnects if necessary.</p>
<p dir="auto">Cleans up the <code>pollfd</code> array after disconnections by replacing the closed descriptor with the last one and reducing the monitored count.</p>

<p dir="auto">Broadcasting is a method in networking where a message is sent from one computer (called the sender) to all computers (called receivers) within the same network. This is like one person shouting a message in a room so that everyone in the room hears it (including yourself). The most common address for broadcasting is <code>255.255.255.255</code>.</p>
<p dir="auto">The full source code that demonstrate broadcasting socket can be found <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/blob/main/00_tutorials/14_broadcasting.c">HERE</a>.</p>
<p dir="auto"><strong>Setup broadcast receiver socket</strong></p>
<div data-snippet-clipboard-copy-content="int setup_broadcast_receiver(struct broadcast_t* receiver_info)
{
    int rc;

    receiver_info-&gt;fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (receiver_info-&gt;fd &lt; 0)
    {
        report_error(&#34;socket() failed for receiver&#34;);
        return -1;
    }

    int optval = 1;
    rc = setsockopt(receiver_info-&gt;fd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));
    if (rc != 0)
    {
        report_error(&#34;setsockopt(SO_REUSEADDR) failed&#34;);
        return -1;
    }

    receiver_info-&gt;addr_receiver.sin_family = AF_INET;
    receiver_info-&gt;addr_receiver.sin_port = htons(BROADCAST_PORT);
    receiver_info-&gt;addr_receiver.sin_addr.s_addr = htonl(INADDR_ANY);
    receiver_info-&gt;addr_receiver_len = sizeof(receiver_info-&gt;addr_receiver);

    rc = bind(receiver_info-&gt;fd, (struct sockaddr *)&amp;receiver_info-&gt;addr_receiver, receiver_info-&gt;addr_receiver_len);
    if (rc &lt; 0)
    {
        report_error(&#34;bind() failed for receiver&#34;);
        return -1;
    }

    return 0;
}"><pre><code>int setup_broadcast_receiver(struct broadcast_t* receiver_info)
{
    int rc;

    receiver_info-&gt;fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (receiver_info-&gt;fd &lt; 0)
    {
        report_error(&#34;socket() failed for receiver&#34;);
        return -1;
    }

    int optval = 1;
    rc = setsockopt(receiver_info-&gt;fd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));
    if (rc != 0)
    {
        report_error(&#34;setsockopt(SO_REUSEADDR) failed&#34;);
        return -1;
    }

    receiver_info-&gt;addr_receiver.sin_family = AF_INET;
    receiver_info-&gt;addr_receiver.sin_port = htons(BROADCAST_PORT);
    receiver_info-&gt;addr_receiver.sin_addr.s_addr = htonl(INADDR_ANY);
    receiver_info-&gt;addr_receiver_len = sizeof(receiver_info-&gt;addr_receiver);

    rc = bind(receiver_info-&gt;fd, (struct sockaddr *)&amp;receiver_info-&gt;addr_receiver, receiver_info-&gt;addr_receiver_len);
    if (rc &lt; 0)
    {
        report_error(&#34;bind() failed for receiver&#34;);
        return -1;
    }

    return 0;
}
</code></pre></div>
<p dir="auto"><code>socket()</code>: Creates a UDP socket (<code>SOCK_DGRAM</code>) for communication.</p>
<p dir="auto"><code>setsockopt()</code>: Configures the socket with <code>SO_REUSEADDR</code> option to allow binding the socket to an address that is already in use.</p>
<p dir="auto"><code>bind()</code>: Binds the socket to a specific port (<code>BROADCAST_PORT</code>) on the local machine. It listens for messages sent to this port.</p>
<p dir="auto">This receiver is set up to receive broadcast messages sent to the <code>BROADCAST_PORT</code> (defined as <code>5555</code>).</p>
<p dir="auto"><strong>Setup broadcast sender socket</strong></p>
<div data-snippet-clipboard-copy-content="int setup_broadcast_sender(struct broadcast_t* sender_info)
{
    int rc;

    sender_info-&gt;fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sender_info-&gt;fd &lt; 0)
    {
        report_error(&#34;socket() failed for sender&#34;);
        return -1;
    }

    int optval = 1;
    rc = setsockopt(sender_info-&gt;fd, SOL_SOCKET, SO_BROADCAST, &amp;optval, sizeof(optval));
    if (rc != 0)
    {
        report_error(&#34;setsockopt(SO_BROADCAST) failed&#34;);
        return -1;
    }

    sender_info-&gt;addr_receiver.sin_family = AF_INET;
    sender_info-&gt;addr_receiver.sin_port = htons(BROADCAST_PORT);
    inet_pton(AF_INET, BROADCAST_ADDR, &amp;sender_info-&gt;addr_receiver.sin_addr);
    sender_info-&gt;addr_receiver_len = sizeof(sender_info-&gt;addr_receiver);

    return 0;
}"><pre><code>int setup_broadcast_sender(struct broadcast_t* sender_info)
{
    int rc;

    sender_info-&gt;fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sender_info-&gt;fd &lt; 0)
    {
        report_error(&#34;socket() failed for sender&#34;);
        return -1;
    }

    int optval = 1;
    rc = setsockopt(sender_info-&gt;fd, SOL_SOCKET, SO_BROADCAST, &amp;optval, sizeof(optval));
    if (rc != 0)
    {
        report_error(&#34;setsockopt(SO_BROADCAST) failed&#34;);
        return -1;
    }

    sender_info-&gt;addr_receiver.sin_family = AF_INET;
    sender_info-&gt;addr_receiver.sin_port = htons(BROADCAST_PORT);
    inet_pton(AF_INET, BROADCAST_ADDR, &amp;sender_info-&gt;addr_receiver.sin_addr);
    sender_info-&gt;addr_receiver_len = sizeof(sender_info-&gt;addr_receiver);

    return 0;
}
</code></pre></div>
<p dir="auto"><code>socket()</code>: Creates a UDP socket (<code>SOCK_DGRAM</code>) for broadcasting.</p>
<p dir="auto"><code>setsockopt()</code>: Configures the socket to allow broadcasting with the <code>SO_BROADCAST</code> option.</p>
<p dir="auto"><code>inet_pton()</code>: Converts the broadcast IP address (<code>255.255.255.255</code>) from text to binary format to be used in the socket.</p>
<p dir="auto">The sender is set to send broadcast messages to the specified address and port.</p>
<p dir="auto"><strong>Run receiver thread</strong></p>
<div data-snippet-clipboard-copy-content="void* broadcast_receiver_thread_func(void* arg)
{
    struct broadcast_t* broadcast_receiver_info = (struct broadcast_t*)calloc(1, sizeof(struct broadcast_t));
    if (setup_broadcast_receiver(broadcast_receiver_info) != 0)
    {
        report_error(&#34;setup_broadcast_receiver() failed&#34;);
        return NULL;
    }

    char buffer[MESSAGE_SIZE];

    printf(&#34;Start to listen broadcast messages\n&#34;);
    while (1)
    {
        memset(buffer, 0, MESSAGE_SIZE);
        int received_bytes = recvfrom(broadcast_receiver_info-&gt;fd, buffer, MESSAGE_SIZE, 0, (struct sockaddr*)&amp;broadcast_receiver_info-&gt;addr_receiver, &amp;broadcast_receiver_info-&gt;addr_receiver_len);
        if (received_bytes &lt;= 0)
        {
            report_error(&#34;Broadcast receiver recvfrom() failed&#34;);
        }
        else
        {
            printf(&#34;Received broadcast message: %s\n&#34;, buffer);
        }
    }

    close(broadcast_receiver_info-&gt;fd);
    free(broadcast_receiver_info);

    return NULL;
}"><pre><code>void* broadcast_receiver_thread_func(void* arg)
{
    struct broadcast_t* broadcast_receiver_info = (struct broadcast_t*)calloc(1, sizeof(struct broadcast_t));
    if (setup_broadcast_receiver(broadcast_receiver_info) != 0)
    {
        report_error(&#34;setup_broadcast_receiver() failed&#34;);
        return NULL;
    }

    char buffer[MESSAGE_SIZE];

    printf(&#34;Start to listen broadcast messages\n&#34;);
    while (1)
    {
        memset(buffer, 0, MESSAGE_SIZE);
        int received_bytes = recvfrom(broadcast_receiver_info-&gt;fd, buffer, MESSAGE_SIZE, 0, (struct sockaddr*)&amp;broadcast_receiver_info-&gt;addr_receiver, &amp;broadcast_receiver_info-&gt;addr_receiver_len);
        if (received_bytes &lt;= 0)
        {
            report_error(&#34;Broadcast receiver recvfrom() failed&#34;);
        }
        else
        {
            printf(&#34;Received broadcast message: %s\n&#34;, buffer);
        }
    }

    close(broadcast_receiver_info-&gt;fd);
    free(broadcast_receiver_info);

    return NULL;
}
</code></pre></div>
<p dir="auto">The function <code>broadcast_receiver_thread_func</code> runs in a separate thread.</p>
<p dir="auto">It first calls <code>setup_broadcast_receiver()</code> to set up the receiver socket.</p>
<p dir="auto">Then, it listens for incoming messages using <code>recvfrom()</code>. Each received message is printed to the console.</p>
<p dir="auto">The <code>recvfrom()</code> function reads the broadcast message into the buffer and prints it. If there is an error or no data is received, it reports the issue.</p>
<p dir="auto">The receiver thread will continue to listen until the program is terminated.</p>
<p dir="auto"><strong>Run sender thread</strong></p>
<div data-snippet-clipboard-copy-content="void* broadcast_sender_thread_func(void* arg)
{
    char* nick_name = (char*)arg;

    struct broadcast_t* broadcast_sender_info = (struct broadcast_t*)calloc(1, sizeof(struct broadcast_t));
    if (setup_broadcast_sender(broadcast_sender_info) != 0)
    {
        report_error(&#34;setup_broadcast_sender() failed&#34;);
        return NULL;
    }

    char broadcast_message[MESSAGE_SIZE];
    while (1)
    {
        memset(broadcast_message, 0, MESSAGE_SIZE);
        sprintf(broadcast_message, &#34;%s is active&#34;, nick_name);
        int sent_bytes = sendto(broadcast_sender_info-&gt;fd, broadcast_message, MESSAGE_SIZE, 0, (struct sockaddr*)&amp;broadcast_sender_info-&gt;addr_receiver, broadcast_sender_info-&gt;addr_receiver_len);
        if (sent_bytes &lt;= 0)
        {
            report_error(&#34;Send broadcast message failed&#34;);
        }
        sleep(1);
    }

    close(broadcast_sender_info-&gt;fd);
    free(broadcast_sender_info);

    return NULL;
}"><pre><code>void* broadcast_sender_thread_func(void* arg)
{
    char* nick_name = (char*)arg;

    struct broadcast_t* broadcast_sender_info = (struct broadcast_t*)calloc(1, sizeof(struct broadcast_t));
    if (setup_broadcast_sender(broadcast_sender_info) != 0)
    {
        report_error(&#34;setup_broadcast_sender() failed&#34;);
        return NULL;
    }

    char broadcast_message[MESSAGE_SIZE];
    while (1)
    {
        memset(broadcast_message, 0, MESSAGE_SIZE);
        sprintf(broadcast_message, &#34;%s is active&#34;, nick_name);
        int sent_bytes = sendto(broadcast_sender_info-&gt;fd, broadcast_message, MESSAGE_SIZE, 0, (struct sockaddr*)&amp;broadcast_sender_info-&gt;addr_receiver, broadcast_sender_info-&gt;addr_receiver_len);
        if (sent_bytes &lt;= 0)
        {
            report_error(&#34;Send broadcast message failed&#34;);
        }
        sleep(1);
    }

    close(broadcast_sender_info-&gt;fd);
    free(broadcast_sender_info);

    return NULL;
}
</code></pre></div>
<p dir="auto">The function <code>broadcast_sender_thread_func</code> is responsible for sending broadcast messages to the broadcast address (<code>255.255.255.255</code>).</p>
<p dir="auto">It sets up the sender socket by calling <code>setup_broadcast_sender()</code>.</p>
<p dir="auto">Inside a loop, it creates a message string containing the user&#39;s nickname and sends it via the <code>sendto()</code> function to the broadcast address every second.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Create A Simple HTTP Server</h2><a id="user-content-create-a-simple-http-server" aria-label="Permalink: Create A Simple HTTP Server" href="#create-a-simple-http-server"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/nguyenchiemminhvu/LinuxNetworkProgramming/main/01_networking_libraries/my_http_server/http_server_design.png"><img src="https://raw.githubusercontent.com/nguyenchiemminhvu/LinuxNetworkProgramming/main/01_networking_libraries/my_http_server/http_server_design.png" alt="HTTP Server class diagram"/></a></p>
<p dir="auto">Full source code of my simple HTTP server is found <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/tree/main/01_networking_libraries/my_http_server">HERE</a>.</p>
<p dir="auto">This is a simple <code>HTTP</code> server written in <code>C++</code> using Linux socket programming. The server is designed to handle basic <code>HTTP</code> requests and responses. It listens for incoming connections, processes the requests, and sends back an appropriate response.</p>

<p dir="auto"><strong>Server side:</strong></p>
<div data-snippet-clipboard-copy-content="ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/my_http_server/build$ cmake ..

ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/my_http_server/build$ make

ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/my_http_server/build$ ./HTTPServer 8080

[1734346074] [INFO] 127.0.0.1:8080
[1734346074] [INFO] Server starts new poll()
[1734346086] [INFO] A client is connected
[1734346086] [INFO] 127.0.0.1:48146
[1734346086] [INFO] A client is disconnected
[1734346086] [INFO] Server starts new poll()"><pre><code>ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/my_http_server/build$ cmake ..

ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/my_http_server/build$ make

ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/my_http_server/build$ ./HTTPServer 8080

[1734346074] [INFO] 127.0.0.1:8080
[1734346074] [INFO] Server starts new poll()
[1734346086] [INFO] A client is connected
[1734346086] [INFO] 127.0.0.1:48146
[1734346086] [INFO] A client is disconnected
[1734346086] [INFO] Server starts new poll()
</code></pre></div>
<p dir="auto"><strong>Client side:</strong></p>
<div data-snippet-clipboard-copy-content="ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/my_http_server/build$ curl -I http://localhost:8080

HTTP/1.1 200 OK
Content-Length:1544
Content-Length: 1544"><pre><code>ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/my_http_server/build$ curl -I http://localhost:8080

HTTP/1.1 200 OK
Content-Length:1544
Content-Length: 1544
</code></pre></div>
<div data-snippet-clipboard-copy-content="ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/my_http_server/build$ curl http://localhost:8080

&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;
    &lt;title&gt;Main Page&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            color: #333;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        h1 {
            font-size: 2.5em;
            color: #333;
            margin-bottom: 20px;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        li {
            margin: 10px 0;
        }
        a {
            text-decoration: none;
            font-size: 1.2em;
            color: #007bff;
            padding: 10px 15px;
            border: 1px solid #007bff;
            border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
        }
        a:hover {
            background-color: #007bff;
            color: white;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Main Page&lt;/h1&gt;
    &lt;p&gt;Select a folder to view its contents:&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;./200&#34;&gt;200 - OK&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;./400&#34;&gt;400 - Bad Request&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;./403&#34;&gt;403 - Forbidden&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;./404&#34;&gt;404 - Not Found&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;./500&#34;&gt;500 - Internal Server Error&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;"><pre><code>ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/my_http_server/build$ curl http://localhost:8080

&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;
    &lt;title&gt;Main Page&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            color: #333;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        h1 {
            font-size: 2.5em;
            color: #333;
            margin-bottom: 20px;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        li {
            margin: 10px 0;
        }
        a {
            text-decoration: none;
            font-size: 1.2em;
            color: #007bff;
            padding: 10px 15px;
            border: 1px solid #007bff;
            border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
        }
        a:hover {
            background-color: #007bff;
            color: white;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Main Page&lt;/h1&gt;
    &lt;p&gt;Select a folder to view its contents:&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;./200&#34;&gt;200 - OK&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;./400&#34;&gt;400 - Bad Request&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;./403&#34;&gt;403 - Forbidden&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;./404&#34;&gt;404 - Not Found&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;./500&#34;&gt;500 - Internal Server Error&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div>


<p dir="auto"><a href="https://curl.se/libcurl/" rel="nofollow">libcurl</a> is a widely-used and powerful C library designed for transferring data over networks using a wide variety of protocols. It is the library behind the popular <code>curl</code> command-line tool and provides developers with a programmatic way to send and receive data through <code>HTTP</code>, <code>HTTPS</code>, <code>FTP</code>, and other protocols.</p>
<p dir="auto">Using libcurl is ideal for tasks that involve fetching web pages, uploading files to servers, interacting with <code>REST APIs</code>, or sending emails... It saves time and effort because it eliminates the need to deal with low-level socket programming and protocol parsing. Instead of manually implementing low-level socket operations and parsing protocols, we can rely on libcurl to do the heavy lifting (creating network connections, handling requests, and managing data streams...).</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">curl command-line examples</h3><a id="user-content-curl-command-line-examples" aria-label="Permalink: curl command-line examples" href="#curl-command-line-examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Fetches the content of <a href="http://example.com" rel="nofollow">http://example.com</a> and saves it into a file called <code>temp.txt</code>.</p>
<div data-snippet-clipboard-copy-content="curl http://example.com &gt; temp.txt"><pre><code>curl http://example.com &gt; temp.txt
</code></pre></div>
<hr/>
<p dir="auto">Downloads the content of <a href="http://example.com" rel="nofollow">http://example.com</a> and saves it as <code>index.html</code>.</p>
<div data-snippet-clipboard-copy-content="curl http://example.com -o index.html"><pre><code>curl http://example.com -o index.html
</code></pre></div>
<hr/>
<p dir="auto">Downloads a file called <code>file.zip</code> from <a href="http://example.com" rel="nofollow">http://example.com</a></p>
<div data-snippet-clipboard-copy-content="curl -O http://example.com/file.zip"><pre><code>curl -O http://example.com/file.zip
</code></pre></div>
<hr/>
<p dir="auto">Sends a <code>POST</code> request to <a href="http://example.com" rel="nofollow">http://example.com</a> with data &#34;name=ncmv&#34;.</p>
<div data-snippet-clipboard-copy-content="curl -X POST -d &#34;name=ncmv&#34; http://example.com"><pre><code>curl -X POST -d &#34;name=ncmv&#34; http://example.com
</code></pre></div>
<hr/>
<p dir="auto">Sends a <code>POST</code> request to <a href="http://example.com" rel="nofollow">http://example.com</a> with <code>JSON</code> data ({&#34;name&#34;:&#34;John&#34;,&#34;age&#34;:30}).</p>
<div data-snippet-clipboard-copy-content="curl -X POST -H &#34;Content-Type: application/json&#34; -d &#39;{&#34;name&#34;:&#34;John&#34;,&#34;age&#34;:30}&#39; http://example.com"><pre><code>curl -X POST -H &#34;Content-Type: application/json&#34; -d &#39;{&#34;name&#34;:&#34;John&#34;,&#34;age&#34;:30}&#39; http://example.com
</code></pre></div>
<hr/>
<p dir="auto">Fetches only the headers of the <code>HTTP</code> response from <a href="http://example.com" rel="nofollow">http://example.com</a></p>
<div data-snippet-clipboard-copy-content="curl -I http://example.com"><pre><code>curl -I http://example.com
</code></pre></div>
<hr/>
<p dir="auto">Accesses <a href="http://example.com" rel="nofollow">http://example.com</a> using <code>HTTP</code> Basic Authentication with the username <code>username</code> and password <code>password</code>.</p>
<div data-snippet-clipboard-copy-content="curl -u username:password http://example.com"><pre><code>curl -u username:password http://example.com
</code></pre></div>
<hr/>
<p dir="auto">Downloads the file <code>readme.txt</code> from the <code>FTP</code> server <code>test.rebex.net</code> using the username <code>demo</code> and password <code>password</code>.</p>
<div data-snippet-clipboard-copy-content="curl ftp://test.rebex.net/readme.txt --user demo:password"><pre><code>curl ftp://test.rebex.net/readme.txt --user demo:password
</code></pre></div>
<hr/>
<p dir="auto">Uploads the local file temp to the <code>FTP</code> server <code>test.rebex.net</code> using the username <code>demo</code> and password <code>password</code>.</p>
<div data-snippet-clipboard-copy-content="curl -T temp ftp://test.rebex.net/ --user demo:password"><pre><code>curl -T temp ftp://test.rebex.net/ --user demo:password
</code></pre></div>
<hr/>
<p dir="auto">Uploads the local file temp to the <code>SFTP</code> server at <code>localhost</code> into the folder <code>/home/ncmv/study_workspace/</code> using the username <code>demo</code> and password <code>password</code>.</p>
<div data-snippet-clipboard-copy-content="curl -u demo:passowrd -T temp sftp://localhost/home/ncmv/study_workspace/"><pre><code>curl -u demo:passowrd -T temp sftp://localhost/home/ncmv/study_workspace/
</code></pre></div>
<hr/>
<p dir="auto">Downloads the file temp from the <code>SFTP</code> server <code>localhost</code> (in the folder <code>/home/ncmv/study_workspace/</code>) using the username <code>demo</code> and password <code>password</code>, and saves it locally as <code>temp</code>.</p>
<div data-snippet-clipboard-copy-content="curl -u demo:password sftp://localhost/home/ncmv/study_workspace/temp -O temp"><pre><code>curl -u demo:password sftp://localhost/home/ncmv/study_workspace/temp -O temp
</code></pre></div>

<p dir="auto"><strong>Include necessary headers</strong></p>
<div data-snippet-clipboard-copy-content="#include &lt;iostream&gt;
#include &lt;curl/curl.h&gt;"><pre><code>#include &lt;iostream&gt;
#include &lt;curl/curl.h&gt;
</code></pre></div>
<p dir="auto"><strong>Callback function for receiving HTTP response</strong></p>
<div data-snippet-clipboard-copy-content="size_t WriteCallback(void *contents, size_t size, size_t nmemb, void *userp)
{
    size_t total_size = size * nmemb;
    ((std::string*)userp)-&gt;append((char*)contents, total_size);
    return total_size;
}"><pre><code>size_t WriteCallback(void *contents, size_t size, size_t nmemb, void *userp)
{
    size_t total_size = size * nmemb;
    ((std::string*)userp)-&gt;append((char*)contents, total_size);
    return total_size;
}
</code></pre></div>
<p dir="auto">Purpose: This function handles data received from the server during the HTTP request.</p>
<p dir="auto">Parameters:</p>
<ul dir="auto">
<li><code>contents</code>: A pointer to the data received.</li>
<li><code>size</code> and <code>nmemb</code>: Together, they specify the size of the received data (in bytes).</li>
<li><code>userp</code>: A user-provided pointer to store the received data (in this case, a std::string).</li>
</ul>
<p dir="auto">What it does:</p>
<ul dir="auto">
<li>Calculates the total size of the data: size * nmemb.</li>
<li>Appends the received data (converted to a string) to the <code>std::string</code> object passed in <code>userp</code>.</li>
<li>Returns the total size of the data to let libcurl know how much data was processed.</li>
</ul>
<p dir="auto"><strong>Check libcurl version</strong></p>
<div data-snippet-clipboard-copy-content="curl_version_info_data* info = curl_version_info(CURLVERSION_NOW);
if (info)
{
    std::cout &lt;&lt; &#34;libcurl version: &#34; &lt;&lt; info-&gt;version &lt;&lt; std::endl;
    std::cout &lt;&lt; &#34;SSL version: &#34; &lt;&lt; info-&gt;ssl_version &lt;&lt; std::endl;
    std::cout &lt;&lt; &#34;Libz version: &#34; &lt;&lt; info-&gt;libz_version &lt;&lt; std::endl;
    std::cout &lt;&lt; &#34;Features: &#34; &lt;&lt; info-&gt;features &lt;&lt; std::endl;

    const char *const *protocols = info-&gt;protocols;
    if (protocols)
    {
        std::cout &lt;&lt; &#34;Supported protocols: &#34;;
        for (int i = 0; protocols[i] != NULL; ++i)
        {
            std::cout &lt;&lt; protocols[i] &lt;&lt; &#34; &#34;;
        }
        std::cout &lt;&lt; std::endl;
    }
}"><pre><code>curl_version_info_data* info = curl_version_info(CURLVERSION_NOW);
if (info)
{
    std::cout &lt;&lt; &#34;libcurl version: &#34; &lt;&lt; info-&gt;version &lt;&lt; std::endl;
    std::cout &lt;&lt; &#34;SSL version: &#34; &lt;&lt; info-&gt;ssl_version &lt;&lt; std::endl;
    std::cout &lt;&lt; &#34;Libz version: &#34; &lt;&lt; info-&gt;libz_version &lt;&lt; std::endl;
    std::cout &lt;&lt; &#34;Features: &#34; &lt;&lt; info-&gt;features &lt;&lt; std::endl;

    const char *const *protocols = info-&gt;protocols;
    if (protocols)
    {
        std::cout &lt;&lt; &#34;Supported protocols: &#34;;
        for (int i = 0; protocols[i] != NULL; ++i)
        {
            std::cout &lt;&lt; protocols[i] &lt;&lt; &#34; &#34;;
        }
        std::cout &lt;&lt; std::endl;
    }
}
</code></pre></div>
<p dir="auto">Purpose: Displays the version information and features supported by <code>libcurl</code>.</p>
<p dir="auto">How it works:</p>
<ul dir="auto">
<li>Calls <code>curl_version_info(CURLVERSION_NOW)</code> to get information about the current version of <code>libcurl</code>.</li>
<li>Prints the version, <code>SSL</code> support, compression library (<code>Libz</code>), and the supported protocols (<code>HTTP</code>, <code>HTTPS</code>, <code>FTP</code>, ...).</li>
</ul>
<p dir="auto"><strong>Initialize libcurl</strong></p>
<div data-snippet-clipboard-copy-content="CURL *curl;
CURLcode res;
std::string readBuffer;

curl = curl_easy_init();"><pre><code>CURL *curl;
CURLcode res;
std::string readBuffer;

curl = curl_easy_init();
</code></pre></div>
<p dir="auto">Details:</p>
<ul dir="auto">
<li><code>CURL *curl</code>: A handle to manage the HTTP session.</li>
<li><code>curl_easy_init()</code>: Initializes the handle. If successful, curl will not be NULL.</li>
</ul>
<p dir="auto"><strong>Set libcurl options</strong></p>
<div data-snippet-clipboard-copy-content="curl_easy_setopt(curl, CURLOPT_URL, &#34;http://httpstat.us/200&#34;);
curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;readBuffer);"><pre><code>curl_easy_setopt(curl, CURLOPT_URL, &#34;http://httpstat.us/200&#34;);
curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;readBuffer);
</code></pre></div>
<p dir="auto">Purpose: Configures options for the HTTP request.</p>
<p dir="auto">Options:</p>
<ul dir="auto">
<li><code>CURLOPT_URL</code>: Sets the URL to request.</li>
<li><code>CURLOPT_WRITEFUNCTION</code>: Specifies the callback function (<code>WriteCallback</code>) to handle the response data.</li>
<li><code>CURLOPT_WRITEDATA</code>: Provides the <code>std::string</code> object (<code>readBuffer</code>) where the response data will be stored.</li>
</ul>
<p dir="auto"><strong>Perform HTTP request</strong></p>
<div data-snippet-clipboard-copy-content="res = curl_easy_perform(curl);"><pre><code>res = curl_easy_perform(curl);
</code></pre></div>
<p dir="auto"><code>curl_easy_perform(curl)</code>: Executes the HTTP request with the options set earlier.</p>
<p dir="auto"><strong>Clean up</strong></p>

<p dir="auto">Frees resources used by <code>curl</code>. Always call this after finishing with <code>curl</code>.</p>
<p dir="auto"><strong>Result</strong>:</p>
<div data-snippet-clipboard-copy-content="ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/libcurl/build$ ./basic_curl 

libcurl version: 8.5.0
SSL version: OpenSSL/3.0.13
Libz version: 1.3
Features: 1438599069
Supported protocols: dict file ftp ftps gopher gophers http https imap imaps ldap ldaps mqtt pop3 pop3s rtmp rtmpe rtmps rtmpt rtmpte rtmpts rtsp scp sftp smb smbs smtp smtps telnet tftp 

Response data: 200 OK"><pre><code>ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/libcurl/build$ ./basic_curl 

libcurl version: 8.5.0
SSL version: OpenSSL/3.0.13
Libz version: 1.3
Features: 1438599069
Supported protocols: dict file ftp ftps gopher gophers http https imap imaps ldap ldaps mqtt pop3 pop3s rtmp rtmpe rtmps rtmpt rtmpte rtmpts rtsp scp sftp smb smbs smtp smtps telnet tftp 

Response data: 200 OK
</code></pre></div>
<p dir="auto">Full source code of basic curl example <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/blob/main/01_networking_libraries/libcurl/src/basic_curl.cpp">HERE</a>.</p>

<p dir="auto"><strong>Include necessary headers</strong></p>
<div data-snippet-clipboard-copy-content="#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;curl/curl.h&gt;"><pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;curl/curl.h&gt;
</code></pre></div>
<p dir="auto"><strong>Define a Easy Handle struct</strong></p>
<div data-snippet-clipboard-copy-content="struct CurlEasyHandle
{
    CURL* easy_handle;
    std::string url;
    std::string data;
};"><pre><code>struct CurlEasyHandle
{
    CURL* easy_handle;
    std::string url;
    std::string data;
};
</code></pre></div>
<p dir="auto">Purpose: Stores information for each HTTP request.</p>
<ul dir="auto">
<li><code>CURL* easy_handle</code>: A handle for making a single HTTP request.</li>
<li><code>std::string url</code>: The URL to fetch.</li>
<li><code>std::string data</code>: Stores the HTTP response data.</li>
</ul>
<p dir="auto"><strong>Callback function for receiving HTTP response</strong></p>
<div data-snippet-clipboard-copy-content="std::size_t perform_callback(char* ptr, std::size_t size, std::size_t nmemb, void* userdata)
{
    std::string* str = static_cast&lt;std::string*&gt;(userdata);
    std::size_t total_size = size * nmemb;
    str-&gt;append(ptr, total_size);
    return total_size;
}"><pre><code>std::size_t perform_callback(char* ptr, std::size_t size, std::size_t nmemb, void* userdata)
{
    std::string* str = static_cast&lt;std::string*&gt;(userdata);
    std::size_t total_size = size * nmemb;
    str-&gt;append(ptr, total_size);
    return total_size;
}
</code></pre></div>
<p dir="auto">Purpose: Handles the data received from the server.</p>
<p dir="auto">How it works:</p>
<ul dir="auto">
<li>Calculates the total size of the received data: <code>size * nmemb</code>.</li>
<li>Appends this data to the <code>std::string</code> object pointed to by <code>userdata</code>.</li>
<li>Returns the total size of processed data to let <code>libcurl</code> know the data was handled.</li>
</ul>
<p dir="auto"><strong>Callback function for downloading progress</strong></p>
<div data-snippet-clipboard-copy-content="int perform_progress(void* ptr, double download_size, double downloaded, double upload_size, double uploaded)
{
    CurlEasyHandle* progData = (CurlEasyHandle*)ptr;
    std::cout &lt;&lt; &#34;Downloaded &#34; &lt;&lt; progData-&gt;url &lt;&lt; &#34;: &#34; &lt;&lt; downloaded &lt;&lt; &#34; bytes&#34; &lt;&lt; std::endl;

    return 0;
}"><pre><code>int perform_progress(void* ptr, double download_size, double downloaded, double upload_size, double uploaded)
{
    CurlEasyHandle* progData = (CurlEasyHandle*)ptr;
    std::cout &lt;&lt; &#34;Downloaded &#34; &lt;&lt; progData-&gt;url &lt;&lt; &#34;: &#34; &lt;&lt; downloaded &lt;&lt; &#34; bytes&#34; &lt;&lt; std::endl;

    return 0;
}
</code></pre></div>
<p dir="auto">Purpose: Tracks the download progress for each URL.</p>
<p dir="auto">How it works:</p>
<ul dir="auto">
<li>Prints the number of bytes downloaded for the URL.</li>
<li>Returning <code>0</code> signals <code>libcurl</code> to continue the download.</li>
<li>Returning non-zero would stop it.</li>
</ul>
<p dir="auto"><strong>Define a list of URLs</strong></p>
<div data-snippet-clipboard-copy-content="const std::vector&lt;std::string&gt; urls = {
    &#34;http://www.example.com&#34;,
    &#34;http://www.google.com&#34;,
    &#34;http://www.bing.com&#34;,
    &#34;http://www.speedtest.net&#34;,
};"><pre><code>const std::vector&lt;std::string&gt; urls = {
    &#34;http://www.example.com&#34;,
    &#34;http://www.google.com&#34;,
    &#34;http://www.bing.com&#34;,
    &#34;http://www.speedtest.net&#34;,
};
</code></pre></div>
<p dir="auto"><strong>Initialize libcurl</strong></p>
<div data-snippet-clipboard-copy-content="CURLM* curl_multi;
int running_status;

curl_global_init(CURL_GLOBAL_DEFAULT);
curl_multi = curl_multi_init();"><pre><code>CURLM* curl_multi;
int running_status;

curl_global_init(CURL_GLOBAL_DEFAULT);
curl_multi = curl_multi_init();
</code></pre></div>
<p dir="auto">Purpose: Prepares libcurl for multi-handle operations.</p>
<p dir="auto">Details:</p>
<ul dir="auto">
<li><code>curl_global_init()</code>: Initializes global resources for libcurl.</li>
<li><code>curl_multi_init()</code>: Creates a multi-handle for managing multiple simultaneous HTTP requests.</li>
</ul>
<p dir="auto"><strong>Create Easy Handles and add to Multi Handle</strong></p>
<div data-snippet-clipboard-copy-content="std::vector&lt;CurlEasyHandle&gt; easy_handles(urls.size());
for (int i = 0; i &lt; urls.size(); i++)
{
    easy_handles[i].easy_handle = curl_easy_init();
    easy_handles[i].url = urls[i];

    curl_easy_setopt(easy_handles[i].easy_handle, CURLOPT_URL, urls[i].c_str());
    curl_easy_setopt(easy_handles[i].easy_handle, CURLOPT_WRITEFUNCTION, perform_callback);
    curl_easy_setopt(easy_handles[i].easy_handle, CURLOPT_WRITEDATA, &amp;easy_handles[i].data);
    curl_easy_setopt(easy_handles[i].easy_handle, CURLOPT_NOPROGRESS, 0L);
    curl_easy_setopt(easy_handles[i].easy_handle, CURLOPT_PROGRESSFUNCTION, perform_progress);
    curl_easy_setopt(easy_handles[i].easy_handle, CURLOPT_PROGRESSDATA, &amp;easy_handles[i]);

    curl_multi_add_handle(curl_multi, easy_handles[i].easy_handle);
}"><pre><code>std::vector&lt;CurlEasyHandle&gt; easy_handles(urls.size());
for (int i = 0; i &lt; urls.size(); i++)
{
    easy_handles[i].easy_handle = curl_easy_init();
    easy_handles[i].url = urls[i];

    curl_easy_setopt(easy_handles[i].easy_handle, CURLOPT_URL, urls[i].c_str());
    curl_easy_setopt(easy_handles[i].easy_handle, CURLOPT_WRITEFUNCTION, perform_callback);
    curl_easy_setopt(easy_handles[i].easy_handle, CURLOPT_WRITEDATA, &amp;easy_handles[i].data);
    curl_easy_setopt(easy_handles[i].easy_handle, CURLOPT_NOPROGRESS, 0L);
    curl_easy_setopt(easy_handles[i].easy_handle, CURLOPT_PROGRESSFUNCTION, perform_progress);
    curl_easy_setopt(easy_handles[i].easy_handle, CURLOPT_PROGRESSDATA, &amp;easy_handles[i]);

    curl_multi_add_handle(curl_multi, easy_handles[i].easy_handle);
}
</code></pre></div>
<p dir="auto">Purpose: Creates and configures an easy handle for each URL, then adds it to the multi-handle.</p>
<p dir="auto">Steps:</p>
<ul dir="auto">
<li>Initialize a new easy handle using <code>curl_easy_init()</code>.</li>
<li>Configure each handle with:
<ul dir="auto">
<li>The URL to fetch (<code>CURLOPT_URL</code>).</li>
<li>A callback for handling response data (<code>CURLOPT_WRITEFUNCTION</code>).</li>
<li>A pointer to the data storage (<code>CURLOPT_WRITEDATA</code>).</li>
<li>Progress monitoring options (<code>CURLOPT_NOPROGRESS</code>, <code>CURLOPT_PROGRESSFUNCTION</code>, <code>CURLOPT_PROGRESSDATA</code>).</li>
</ul>
</li>
<li>Add the easy handle to the multi-handle with <code>curl_multi_add_handle()</code>.</li>
</ul>
<p dir="auto"><strong>Perform Multi Handle request</strong></p>
<div data-snippet-clipboard-copy-content="curl_multi_perform(curl_multi, &amp;running_status);

do
{
    int curl_multi_fds;
    CURLMcode rc = curl_multi_perform(curl_multi, &amp;running_status);
    if (rc == CURLM_OK)
    {
        rc = curl_multi_wait(curl_multi, nullptr, 0, 1000, &amp;curl_multi_fds);
    }

    if (rc != CURLM_OK)
    {
        std::cerr &lt;&lt; &#34;curl_multi failed, code &#34; &lt;&lt; rc &lt;&lt; std::endl;
        break;
    }
} while (running_status);"><pre><code>curl_multi_perform(curl_multi, &amp;running_status);

do
{
    int curl_multi_fds;
    CURLMcode rc = curl_multi_perform(curl_multi, &amp;running_status);
    if (rc == CURLM_OK)
    {
        rc = curl_multi_wait(curl_multi, nullptr, 0, 1000, &amp;curl_multi_fds);
    }

    if (rc != CURLM_OK)
    {
        std::cerr &lt;&lt; &#34;curl_multi failed, code &#34; &lt;&lt; rc &lt;&lt; std::endl;
        break;
    }
} while (running_status);
</code></pre></div>
<p dir="auto">Purpose: Executes all HTTP requests simultaneously.</p>
<p dir="auto">How it works:</p>
<ul dir="auto">
<li>Starts the <code>HTTP</code> requests with <code>curl_multi_perform()</code>.</li>
<li>Continuously calls <code>curl_multi_perform()</code> in a loop until all requests are complete (running_status becomes 0).</li>
<li>Uses <code>curl_multi_wait()</code> to wait for events (data availability) to avoid busy-waiting.</li>
</ul>
<p dir="auto"><strong>Save data and clean up</strong></p>
<div data-snippet-clipboard-copy-content="for (CurlEasyHandle&amp; handle : easy_handles)
{
    std::string filename = handle.url.substr(11, handle.url.find_last_of(&#34;.&#34;) - handle.url.find_first_of(&#34;.&#34;) - 1) + &#34;.html&#34;;
    std::ofstream file(filename);
    if (file.is_open())
    {
        file &lt;&lt; handle.data;
        file.close();
        std::cout &lt;&lt; &#34;Data written to &#34; &lt;&lt; filename &lt;&lt; std::endl;
    }

    curl_multi_remove_handle(curl_multi, handle.easy_handle);
    curl_easy_cleanup(handle.easy_handle);
}

curl_multi_cleanup(curl_multi);
curl_global_cleanup();"><pre><code>for (CurlEasyHandle&amp; handle : easy_handles)
{
    std::string filename = handle.url.substr(11, handle.url.find_last_of(&#34;.&#34;) - handle.url.find_first_of(&#34;.&#34;) - 1) + &#34;.html&#34;;
    std::ofstream file(filename);
    if (file.is_open())
    {
        file &lt;&lt; handle.data;
        file.close();
        std::cout &lt;&lt; &#34;Data written to &#34; &lt;&lt; filename &lt;&lt; std::endl;
    }

    curl_multi_remove_handle(curl_multi, handle.easy_handle);
    curl_easy_cleanup(handle.easy_handle);
}

curl_multi_cleanup(curl_multi);
curl_global_cleanup();
</code></pre></div>
<p dir="auto">Purpose: Saves the response data to files, then cleans up resources.</p>
<p dir="auto">Steps:</p>
<ul dir="auto">
<li>For each handle:
<ul dir="auto">
<li>Create a filename based on the <code>URL</code>.</li>
<li>Save the response data to the file.</li>
<li>Remove the handle from the multi-handle (<code>curl_multi_remove_handle()</code>).</li>
</ul>
</li>
<li>Clean up the handle (<code>curl_easy_cleanup()</code>).</li>
<li>Clean up the multi-handle (<code>curl_multi_cleanup()</code>) and global resources (<code>curl_global_cleanup()</code>).</li>
</ul>
<p dir="auto"><strong>Result</strong>:</p>
<div data-snippet-clipboard-copy-content="ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/libcurl/build$ ./curl_multi_handle 

...
Downloaded http://www.speedtest.net: 167 bytes
...
Downloaded http://www.bing.com: 53057 bytes
...
Downloaded http://www.google.com: 57709 bytes
...
Downloaded http://www.example.com: 1256 bytes
...
Data written to example.html
Data written to google.html
Data written to bing.html
Data written to speedtest.html"><pre><code>ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/libcurl/build$ ./curl_multi_handle 

...
Downloaded http://www.speedtest.net: 167 bytes
...
Downloaded http://www.bing.com: 53057 bytes
...
Downloaded http://www.google.com: 57709 bytes
...
Downloaded http://www.example.com: 1256 bytes
...
Data written to example.html
Data written to google.html
Data written to bing.html
Data written to speedtest.html
</code></pre></div>
<p dir="auto">Full source code of curl multiple handles example <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/blob/main/01_networking_libraries/libcurl/src/curl_multi_handle.cpp">HERE</a>.</p>

<p dir="auto"><strong>Include necessary headers</strong></p>
<div data-snippet-clipboard-copy-content="#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
#include &lt;curl/curl.h&gt;"><pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
#include &lt;curl/curl.h&gt;
</code></pre></div>
<p dir="auto"><strong>Define structures</strong></p>
<div data-snippet-clipboard-copy-content="struct ProgressData
{
    std::string url;
    double lastProgress;
};"><pre><code>struct ProgressData
{
    std::string url;
    double lastProgress;
};
</code></pre></div>
<p dir="auto">Purpose: Stores progress information for each download.</p>
<p dir="auto">Members:</p>
<ul dir="auto">
<li><code>std::string url</code>: The URL being downloaded.</li>
<li><code>double lastProgress</code>: The last recorded progress (in bytes) for this URL.</li>
</ul>
<p dir="auto"><strong>Callback function for receiving HTTP response</strong></p>
<div data-snippet-clipboard-copy-content="std::size_t perform_callback(char* ptr, std::size_t size, std::size_t nmemb, void* userdata)
{
    std::string* str = static_cast&lt;std::string*&gt;(userdata);
    std::size_t total_size = size * nmemb;
    str-&gt;append(ptr, total_size);
    return total_size;
}"><pre><code>std::size_t perform_callback(char* ptr, std::size_t size, std::size_t nmemb, void* userdata)
{
    std::string* str = static_cast&lt;std::string*&gt;(userdata);
    std::size_t total_size = size * nmemb;
    str-&gt;append(ptr, total_size);
    return total_size;
}
</code></pre></div>
<p dir="auto">Purpose: Handles data received from the server during an <code>HTTP</code> request.</p>
<p dir="auto">Details:</p>
<ul dir="auto">
<li>Appends received data to a <code>std::string</code> provided as userdata.</li>
<li>Returns the size of the data to confirm successful processing.</li>
</ul>
<p dir="auto"><strong>Callback function for downloading progress</strong></p>
<div data-snippet-clipboard-copy-content="int perform_progress(void* ptr, double download_size, double downloaded, double upload_size, double uploaded)
{
    ProgressData* progData = (ProgressData*)ptr;

    if (downloaded - progData-&gt;lastProgress &gt;= 1024.0)
    {
        std::cout &lt;&lt; &#34;Download &#34; &lt;&lt; progData-&gt;url &lt;&lt; &#34;: &#34; &lt;&lt; downloaded &lt;&lt; &#34; bytes&#34; &lt;&lt; std::endl;
        progData-&gt;lastProgress = downloaded;
    }

    return 0;
}"><pre><code>int perform_progress(void* ptr, double download_size, double downloaded, double upload_size, double uploaded)
{
    ProgressData* progData = (ProgressData*)ptr;

    if (downloaded - progData-&gt;lastProgress &gt;= 1024.0)
    {
        std::cout &lt;&lt; &#34;Download &#34; &lt;&lt; progData-&gt;url &lt;&lt; &#34;: &#34; &lt;&lt; downloaded &lt;&lt; &#34; bytes&#34; &lt;&lt; std::endl;
        progData-&gt;lastProgress = downloaded;
    }

    return 0;
}
</code></pre></div>
<p dir="auto">Purpose: Tracks and displays download progress for a specific URL.</p>
<p dir="auto">Details:</p>
<ul dir="auto">
<li>Checks if at least 1 KB (1024 bytes) of new data has been downloaded since the last update.</li>
<li>Prints the progress and updates lastProgress.</li>
</ul>
<p dir="auto"><strong>Function to perform HTTP request</strong></p>
<div data-snippet-clipboard-copy-content="void perform_request(const std::string&amp; url)
{
    CURL* curl;
    CURLcode res;

    curl = curl_easy_init();
    if (curl != nullptr)
    {
        std::string data;
        ProgressData progData;
        progData.url = url;
        progData.lastProgress = 0.0;

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, perform_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;data);
        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0L);
        curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, perform_progress);
        curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, &amp;progData);

        res = curl_easy_perform(curl);
        if (res == CURLE_OK)
        {
            std::string filename = url.substr(11, url.find_last_of(&#34;.&#34;) - url.find_first_of(&#34;.&#34;) - 1) + &#34;.html&#34;;
            std::ofstream file(filename);
            if (file.is_open())
            {
                file &lt;&lt; data;
                file.close();
                std::cout &lt;&lt; &#34;Data written to &#34; &lt;&lt; filename &lt;&lt; std::endl;
            }
        }
    }
}"><pre><code>void perform_request(const std::string&amp; url)
{
    CURL* curl;
    CURLcode res;

    curl = curl_easy_init();
    if (curl != nullptr)
    {
        std::string data;
        ProgressData progData;
        progData.url = url;
        progData.lastProgress = 0.0;

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, perform_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;data);
        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0L);
        curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, perform_progress);
        curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, &amp;progData);

        res = curl_easy_perform(curl);
        if (res == CURLE_OK)
        {
            std::string filename = url.substr(11, url.find_last_of(&#34;.&#34;) - url.find_first_of(&#34;.&#34;) - 1) + &#34;.html&#34;;
            std::ofstream file(filename);
            if (file.is_open())
            {
                file &lt;&lt; data;
                file.close();
                std::cout &lt;&lt; &#34;Data written to &#34; &lt;&lt; filename &lt;&lt; std::endl;
            }
        }
    }
}
</code></pre></div>
<p dir="auto">Purpose: Performs an <code>HTTP</code> request to download the content of a given <code>URL</code>.</p>
<p dir="auto">Steps:</p>
<ul dir="auto">
<li>Initializes a CURL easy handle.</li>
<li>Sets up callbacks for data writing (<code>perform_callback</code>) and progress tracking (<code>perform_progress</code>).</li>
<li>Executes the request using <code>curl_easy_perform()</code>.</li>
</ul>
<p dir="auto">On success:</p>
<ul dir="auto">
<li>Saves the downloaded data to a file named after the <code>URL</code>.</li>
</ul>
<p dir="auto"><strong>Set up multithreading HTTP perform</strong></p>
<div data-snippet-clipboard-copy-content="curl_global_init(CURL_GLOBAL_ALL);

std::vector&lt;std::thread&gt; threads;
std::vector&lt;std::string&gt; urls = {
    &#34;http://www.example.com&#34;,
    &#34;http://www.google.com&#34;,
    &#34;http://www.bing.com&#34;,
    &#34;http://www.speedtest.net&#34;,
};

for (const std::string&amp; url : urls)
{
    threads.push_back(std::thread(perform_request, url));
}

for (std::thread&amp; t : threads)
{
    t.join();
}

curl_global_cleanup();"><pre><code>curl_global_init(CURL_GLOBAL_ALL);

std::vector&lt;std::thread&gt; threads;
std::vector&lt;std::string&gt; urls = {
    &#34;http://www.example.com&#34;,
    &#34;http://www.google.com&#34;,
    &#34;http://www.bing.com&#34;,
    &#34;http://www.speedtest.net&#34;,
};

for (const std::string&amp; url : urls)
{
    threads.push_back(std::thread(perform_request, url));
}

for (std::thread&amp; t : threads)
{
    t.join();
}

curl_global_cleanup();
</code></pre></div>
<p dir="auto">Details:</p>
<ul dir="auto">
<li><code>curl_global_init(CURL_GLOBAL_ALL)</code>: Prepares libcurl for multi-threaded operations.</li>
<li>Creates a vector to store thread objects and another to store the list of URLs.</li>
<li>For each URL, creates a new thread to execute <code>perform_request()</code>.</li>
<li>Ensures all threads complete before the program exits using <code>join()</code> method.</li>
<li><code>curl_global_cleanup()</code>: Releases resources allocated by <code>libcurl</code>.</li>
</ul>
<p dir="auto">Full source code of basic curl multithreading <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/blob/main/01_networking_libraries/libcurl/src/curl_multithreaded.cpp">HERE</a>.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Secure Networking with OpenSSL</h2><a id="user-content-secure-networking-with-openssl" aria-label="Permalink: Secure Networking with OpenSSL" href="#secure-networking-with-openssl"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>SSL</code> (Secure Sockets Layer) is a cryptographic protocol originally designed to provide secure communication over a network, such as the internet. It ensures that the data transferred between a client (e.g., a web browser) and a server (e.g., a website) is encrypted, authenticated, and protected from being tampered with.</p>
<p dir="auto">Modern systems use <code>TLS</code> (Transport Layer Security), which is an updated and more secure version of <code>SSL</code>. When people say <code>SSL</code>, they often mean <code>SSL/TLS</code>.</p>
<p dir="auto">One of well-known <code>SSL/TLS</code> application is HTTPs protocol. TLS encryption method is used to secure communication on the web, such as browsing, submit forms, online payments...</p>
<p dir="auto"><strong>SSL Handshake:</strong></p>
<ul dir="auto">
<li>The client (e.g., a browser) connects to the server and says, &#34;I want to use SSL/TLS.&#34;</li>
<li>The server sends back its certificate, which contains its identity and a public key.</li>
<li>The client verifies the server&#39;s certificate to ensure it’s legitimate.</li>
<li>The client and server agree on a shared &#34;session key&#34; to encrypt the data during the session.</li>
</ul>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/nguyenchiemminhvu/LinuxNetworkProgramming/refs/heads/main/how_https_work.png"><img src="https://raw.githubusercontent.com/nguyenchiemminhvu/LinuxNetworkProgramming/refs/heads/main/how_https_work.png" alt="How HTTPs work"/></a></p>
<p dir="auto">To work with <code>SSL/TLS</code> protocol in programming, <code>OpenSSL</code> is a typical choice.</p>
<p dir="auto"><strong>Installation</strong></p>
<div data-snippet-clipboard-copy-content="sudo apt-get install libssl-dev openssl"><pre><code>sudo apt-get install libssl-dev openssl
</code></pre></div>
<p dir="auto"><code>libssl-dev</code>: Contains the development libraries for <code>OpenSSL</code>, which are needed to compile programs using <code>OpenSSL</code>.</p>
<p dir="auto"><code>openssl</code>: Installs the <code>OpenSSL</code> command-line tool, which can be used for generating keys and certificates or debugging <code>SSL/TLS</code> issues.</p>
<p dir="auto"><strong>Initialize OpenSSL</strong></p>
<div data-snippet-clipboard-copy-content="#include &lt;openssl/ssl.h&gt;
#include &lt;openssl/err.h&gt;

SSL_library_init();
SSL_load_error_strings();
OpenSSL_add_all_algorithms();"><pre><code>#include &lt;openssl/ssl.h&gt;
#include &lt;openssl/err.h&gt;

SSL_library_init();
SSL_load_error_strings();
OpenSSL_add_all_algorithms();
</code></pre></div>
<p dir="auto">These steps ensure that <code>OpenSSL</code> is ready to handle cryptography and provide meaningful error messages in case something goes wrong.</p>
<p dir="auto"><strong>Create SSL context</strong></p>
<div data-snippet-clipboard-copy-content="SSL_CTX *ctx = SSL_CTX_new(TLS_server_method());  // For server

SSL_CTX *ctx = SSL_CTX_new(TLS_client_method());  // For client"><pre><code>SSL_CTX *ctx = SSL_CTX_new(TLS_server_method());  // For server

SSL_CTX *ctx = SSL_CTX_new(TLS_client_method());  // For client
</code></pre></div>
<p dir="auto"><code>TLS_server_method()</code>: Configures the context for use in server mode.</p>
<p dir="auto"><code>TLS_client_method()</code>: Configures the context for use in client mode.</p>
<p dir="auto">The <code>SSL_CTX</code> structure holds protocol settings, certificates, and other necessary configurations.</p>
<p dir="auto"><strong>Load Certificates (only for server)</strong></p>
<div data-snippet-clipboard-copy-content="SSL_CTX_use_certificate_file(ctx, &#34;server.crt&#34;, SSL_FILETYPE_PEM);

SSL_CTX_use_PrivateKey_file(ctx, &#34;server.key&#34;, SSL_FILETYPE_PEM);"><pre><code>SSL_CTX_use_certificate_file(ctx, &#34;server.crt&#34;, SSL_FILETYPE_PEM);

SSL_CTX_use_PrivateKey_file(ctx, &#34;server.key&#34;, SSL_FILETYPE_PEM);
</code></pre></div>
<p dir="auto"><code>server.crt</code>: The server&#39;s certificate file (proves the server&#39;s identity to the client).</p>
<p dir="auto"><code>server.key</code>: The private key file associated with the certificate.</p>
<p dir="auto">This step ensures that the server can provide authentication during the <code>SSL/TLS </code>handshake.</p>
<p dir="auto"><strong>Create and Bind socket</strong></p>
<p dir="auto">Set up a regular <code>TCP</code> socket as you would for normal network programming.</p>
<p dir="auto"><strong>Wrap socket with SSL</strong></p>
<div data-snippet-clipboard-copy-content="SSL *ssl = SSL_new(ctx);
SSL_set_fd(ssl, socket_fd);"><pre><code>SSL *ssl = SSL_new(ctx);
SSL_set_fd(ssl, socket_fd);
</code></pre></div>
<p dir="auto">The <code>SSL</code> object manages the encryption and decryption for the socket connection.</p>
<p dir="auto"><strong>Perform Handshake</strong></p>
<div data-snippet-clipboard-copy-content="SSL_accept(ssl); // For server

SSL_connect(ssl); // For client"><pre><code>SSL_accept(ssl); // For server

SSL_connect(ssl); // For client
</code></pre></div>
<p dir="auto">The <code>SSL/TLS</code> handshake authenticates the server (and optionally the client) and establishes an encrypted communication channel.</p>
<p dir="auto"><code>SSL_accept()</code>: The server waits for the client to initiate the handshake.</p>
<p dir="auto"><code>SSL_connect()</code>: The client initiates the handshake with the server.</p>
<p dir="auto"><strong>Send and receive encrypted data</strong></p>
<p dir="auto">After the handshake, the <code>SSL</code> connection is ready to send and receive encrypted data.</p>
<div data-snippet-clipboard-copy-content="SSL_write(ssl, &#34;Hello, Secure World!&#34;, strlen(&#34;Hello, Secure World!&#34;));
char buffer[1024];

SSL_read(ssl, buffer, sizeof(buffer));"><pre><code>SSL_write(ssl, &#34;Hello, Secure World!&#34;, strlen(&#34;Hello, Secure World!&#34;));
char buffer[1024];

SSL_read(ssl, buffer, sizeof(buffer));
</code></pre></div>
<p dir="auto"><strong>Cleanup</strong></p>
<div data-snippet-clipboard-copy-content="SSL_shutdown(ssl);
SSL_free(ssl);
SSL_CTX_free(ctx);"><pre><code>SSL_shutdown(ssl);
SSL_free(ssl);
SSL_CTX_free(ctx);
</code></pre></div>
<p dir="auto">With all these steps, It is enough to establish secure communication between a client and server using the <code>SSL/TLS</code> protocol with <code>OpenSSL</code> library.</p>

<p dir="auto">Full source code of the example HTTPs Client is found <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/blob/main/01_networking_libraries/openssl/src/https_client.c">HERE</a>.</p>
<p dir="auto"><strong>Result</strong>:</p>
<div data-snippet-clipboard-copy-content="ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/openssl/build$ ./https_client example.com 443

93.184.215.14:443
SSL connection is done with cipher suite TLS_AES_256_GCM_SHA384

Received 361 bytes
Received 1256 bytes
HTTP/1.1 200 OK
Age: 140532
Cache-Control: max-age=604800
Content-Type: text/html; charset=UTF-8
Date: Sat, 14 Dec 2024 09:44:47 GMT
Etag: &#34;3147526947+gzip+ident&#34;
Expires: Sat, 21 Dec 2024 09:44:47 GMT
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Server: ECAcc (sed/58B0)
Vary: Accept-Encoding
X-Cache: HIT
Content-Length: 1256
Connection: close

(The remaining is HTTP content of example.com website)"><pre><code>ncmv@localhost:~/study_workspace/LinuxNetworkProgramming/01_networking_libraries/openssl/build$ ./https_client example.com 443

93.184.215.14:443
SSL connection is done with cipher suite TLS_AES_256_GCM_SHA384

Received 361 bytes
Received 1256 bytes
HTTP/1.1 200 OK
Age: 140532
Cache-Control: max-age=604800
Content-Type: text/html; charset=UTF-8
Date: Sat, 14 Dec 2024 09:44:47 GMT
Etag: &#34;3147526947+gzip+ident&#34;
Expires: Sat, 21 Dec 2024 09:44:47 GMT
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Server: ECAcc (sed/58B0)
Vary: Accept-Encoding
X-Cache: HIT
Content-Length: 1256
Connection: close

(The remaining is HTTP content of example.com website)
</code></pre></div>

<markdown-accessiblity-table><table>
<thead>
<tr>
<th>SSL Server Workflow</th>
<th>SSL Client Workflow</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/nguyenchiemminhvu/LinuxNetworkProgramming/refs/heads/main/SSL_server_workflow.png"><img src="https://raw.githubusercontent.com/nguyenchiemminhvu/LinuxNetworkProgramming/refs/heads/main/SSL_server_workflow.png" alt="SSL Server Workflow"/></a></td>
<td><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/nguyenchiemminhvu/LinuxNetworkProgramming/refs/heads/main/SSL_client_workflow.png"><img src="https://raw.githubusercontent.com/nguyenchiemminhvu/LinuxNetworkProgramming/refs/heads/main/SSL_client_workflow.png" alt="SSL Client Workflow"/></a></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Full source code of the example SSL Client-Server is found <a href="https://github.com/nguyenchiemminhvu/LinuxNetworkProgramming/blob/main/01_networking_libraries/openssl/src/ssl_client_server.c">HERE</a>.</p>

<p dir="auto"><strong>Reference</strong>:</p>
<p dir="auto"><a href="https://www.linuxhowtos.org/C_C++/socket.htm" rel="nofollow">https://www.linuxhowtos.org/C_C++/socket.htm</a></p>
<p dir="auto"><a href="https://www.tutorialspoint.com/unix_sockets/index.htm" rel="nofollow">https://www.tutorialspoint.com/unix_sockets/index.htm</a></p>
<p dir="auto"><a href="https://documentation.softwareag.com/adabas/wcp632mfr/wtc/wtc_prot.htm" rel="nofollow">https://documentation.softwareag.com/adabas/wcp632mfr/wtc/wtc_prot.htm</a></p>
<p dir="auto"><a href="https://www.geeksforgeeks.org/little-and-big-endian-mystery/" rel="nofollow">https://www.geeksforgeeks.org/little-and-big-endian-mystery/</a></p>
<p dir="auto"><a href="https://github.com/openssl/openssl/tree/691064c47fd6a7d11189df00a0d1b94d8051cbe0/demos/ssl">https://github.com/openssl/openssl/tree/691064c47fd6a7d11189df00a0d1b94d8051cbe0/demos/ssl</a></p>
<p dir="auto"><a href="https://beej.us/guide/bgnet/html/" rel="nofollow">https://beej.us/guide/bgnet/html/</a></p>
</article></div></div>
  </body>
</html>
