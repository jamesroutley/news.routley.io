<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lambdaland.org/posts/2026-01-21_tree-sitter_vs_lsp/">Original</a>
    <h1>Tree-sitter vs. Language Servers</h1>
    
    <div id="readability-page-1" class="page"><article>
  
  
  <h5>21 Jan 2026</h5>



  

  
  
  



<p>I got asked a good question today: what is the difference between <a href="https://en.wikipedia.org/wiki/Tree-sitter_%28parser_generator%29">Tree-sitter</a> and a <a href="https://en.wikipedia.org/wiki/Language_Server_Protocol">language server</a>? I don’t understand how either of these tools work in depth, so I’m just going to explain from an <em>observable</em>, <em>pragmatic</em> point of view.</p>
<h2 id="tree-sitter">
  Tree-sitter
  <a href="#tree-sitter">#</a>
</h2>
<p>Tree-sitter is a <em>parser generator</em>. What this means is that you can hand Tree-sitter a description for a programming language and it will create a program that will parse that language for you. What’s special about Tree-sitter is that it is a.) fast, and b.) can tolerate <em>syntax errors</em> in the input. These two properties make Tree-sitter ideal for creating syntax highlighting engines in text editors. When you’re editing a program, <em>most of the time</em> the program will be in a syntactically invalid state. During that time, you don’t want your colors changing or just outright breaking while you’re typing. Naïve regex-based syntax highlighters frequently suffer from this issue.</p>
<p>Tree-sitter also provides a query language where you can make queries against the parse tree. I use this in the Emacs <a href="https://codeberg.org/ashton314/citar-typst">package I’m trying to develop</a> to add <a href="https://typst.app/">Typst</a> support to the <a href="https://github.com/emacs-citar/citar">Citar</a> citation/bibliography tool: I can ask Tree-sitter to find a particular syntax object; it is safer and more robust than using a regular expression because it can do similar parsing to the Typst engine itself.</p>
<p>In short, Tree-sitter provides syntax highlighting that is faithful to how the language implementation parses the program, instead of relying on regular expressions that incidentally come close.</p>
<h2 id="language-server">
  Language server
  <a href="#language-server">#</a>
</h2>
<p>A <em>language server</em> is a program that can analyze a program and report interesting information about that program to a text editor. A standard, called the <a href="https://en.wikipedia.org/wiki/Language_Server_Protocol">Language Server Protocol (LSP)</a>, defines the kinds of JSON messages that pass between a text editor and the server. The protocol is an open standard; any language and any text editor can take advantage of the protocol to get nice smart programming helps in their system. Language servers can provide information like locating the definition of a symbol, possible completions at the cursor point, etc. to a text editor which can then decide how and when to display or use this information.</p>
<p>Language servers solve the “


<span>
  \(N \times M\)
</span>
 problem” where <span>
  \(N\)
</span>
 programming languages and <span>
  \(M\)
</span>
 text editors would mean there have to be <span>
  \(N \times M\)
</span>
 implementations for language analyzers. Now, every language just needs a language server, and every editor needs to be able to speak the LSP protocol.</p>
<p>Language servers are powerful because they can hook into the language’s runtime and compiler toolchain to get <em>semantically correct</em> answers to user queries. For example, suppose you have two versions of a <code>pop</code> function, one imported from a <code>stack</code> library, and another from a <code>heap</code> library. If you use a tool like the <a href="https://github.com/jacktasia/dumb-jump">dumb-jump</a> package in Emacs<label for="sn1"></label>

<span>
I just want to say that I think dumb-jump is very cool and I am not trying to knock it down at all. It’s honest about its limitations and can be handy when you do not have a language server available.
</span>
and you use it to jump to the definition for a call to <code>pop</code>, it might get confused as to where to go because it’s not sure what module is in scope at the point. A language server, on the other hand, should have access to this information and would not get confused.</p>
<h3 id="using-a-language-server-for-highlighting">
  Using a language server for highlighting
  <a href="#using-a-language-server-for-highlighting">#</a>
</h3>
<p>It <em>is</em> possible to use the language server for syntax highlighting. I am not aware of any particularly strong reasons why one would want to (or <em>not</em> want to) do this. The language server can be a more complicated program and so could surface particularly detailed information about the syntax; it might also be slower than tree-sitter.</p>
<p>Emacs’ built-in LSP client, <a href="https://github.com/joaotavora/eglot">Eglot</a>, recently added <code>eglot-semantic-tokens-mode</code> to support syntax highlighting as provided from the language server. I have tried this a little bit in Rust code and it seems fine; the Tree-sitter-based syntax highlighting has been working just fine for me, so I will probably stick to that unless I find a compelling reason to use the LSP-based highlighting.</p>
<p><strong>Update:</strong> Thanks to <a href="https://news.ycombinator.com/item?id=46721842">a comment on HN</a>, I now know of a good reason why you would want to use a language server for syntax highlighting: the Rust language server <a href="https://rust-analyzer.github.io/">rust-analyzer</a> can tell your text editor when a variable reference is mutable or not, which means you could highlight <code>mut</code> references differently than non-<code>mut</code> ones. Thanks to <a href="https://davidbarsky.com">David Barsky</a> for the tip!</p>

<p>I wrote all of the above article. I did not ask an LLM to generate any portion of it. Please know that whenever you read something on my blog, it comes 100% from a human—me, Ashton Wiersdorf.</p>
<p>I am not so anti-AI to say that LLMs are worthless or should never be used. I’ve used LLMs a little bit. I think they’re fantastic at translating between languages; this seems to be something that they should be good at doing. They’re helpful at writing some boring parts of the code I write. However, most of the time I find that I can typically write the tricky bits of the code about as fast as I could specify to an LLM what I want.</p>
<p>I know that an LLM could have generated a facile pile of text much like the above, and honestly it would probably be decently helpful. However, know that what you have just read came directly from the fingers of a person who thought about the topic and bent his effort to helping you understand. This is from <em>real</em> human who understands the meaning behind each word here. I do not play games with syntax and generate answer-shaped blog posts. There is real meaning here. Enjoy it, and go forth and make more of it.</p></article></div>
  </body>
</html>
