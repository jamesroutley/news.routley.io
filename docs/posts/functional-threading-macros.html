<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aartaka.me/threading.html">Original</a>
    <h1>Functional Threading &#34;Macros&#34;</h1>
    
    <div id="readability-page-1" class="page"><div>

<a href="https://blog.jacobvosmaer.nl/0062-vz-1-puredata/about.html">By Artyom Bologov</a>


<picture>
<source srcset="assets/threading-dark.png" media="screen and (prefers-color-scheme: dark)"/>
<img src="https://blog.jacobvosmaer.nl/0062-vz-1-puredata/assets/threading.png" dark="assets/threading-dark.png" alt="An almost monochrome clean thumbnail. On it, “T H R E A D I N G” is written in large bright letters. The letters are connected with one single line, going right through every one of them and ending with an arrow head cycling back to the letters. In the corners, there are attributions to “Artyom Bologov” and “aartaka.me” in a handwriting that seems to shift from one letter to another, making it less readable."/>
</picture>

<p>
I love Common Lisp.
But my dayjob is in Clojure (and TypeScript, ugh.)
I can’t help but notice the convenience of threading macros.

</p><section id="readability"><h2>Threading Readability <a href="#readability">#</a></h2>

<p>
Compare these two pieces of code:

</p><figure><pre lang="lisp"><span token=";;">;;</span> <span token="No">No</span> <span token="threading">threading</span>
(<span token="*">*</span> (<span token="1+">1+</span> (<span token="*">*</span> <span token="significand">significand</span> (<span token="flt">flt</span> (<span token="/">/</span> (<span token="expt">expt</span> <span token="2">2</span> <span token="significand">significand</span>)))))
   (<span token="expt">expt</span> <span token="2">2</span> (<span token="-">-</span> <span token="exponent">exponent</span> (<span token="flt">flt</span> <span token="bias">bias</span>)))
   <span token="sign">sign</span>)
<span token=";;">;;</span> <span token="Threading">Threading</span>
(<span token="-">-</span>&gt;&gt; <span token="significand">significand</span>
     (<span token="expt">expt</span> <span token="2">2</span>)
     <span token="/">/</span>
     <span token="flt">flt</span>
     (<span token="*">*</span> <span token="significand">significand</span>)
     <span token="1+">1+</span>
     (<span token="*">*</span> <span token="sign">sign</span> (<span token="expt">expt</span> <span token="2">2</span> (<span token="-">-</span> <span token="exponent">exponent</span> (<span token="flt">flt</span> <span token="bias">bias</span>)))))
</pre><figcaption>Threading vs. non-threading Lisp code</figcaption></figure>

<p>
Threading code is much more readable.
It shows the sequence of actions in the order they happen in.
It omits the obvious parentheses.
It highlights the patterns in function applications.

</p><p>
One problem with threading macros though: they are macros.
Lisps are good at sophisticated syntax transformations.
Other languages—not so much.
So we need other ways to thread functions together.
Like... combinators?

</p></section><section id="combinators"><h2>Threading Combinators <a href="#combinators">#</a></h2>

<p>
The idea is simple: we need several functions that’d pass closures around.
Bubbling outward and storing the inner functions for until the outer ones run.
(Reversing the applicative inner-&gt;outer evaluation order, thus the need for extra closures.)
Must look something like:

</p><figure><pre lang="lamber"><span token="piping">piping</span> <span token="3">3</span> <span token=":">:</span> <span token="pipe">pipe</span> (<span token="*">*</span> <span token="2">2</span>) <span token=":">:</span> <span token="pipe">pipe</span> <span token="1+">1+</span> <span token="piped">piped</span> .
<span token=";;">;;</span> <span token="or">or</span>, <span token="abbreviated">abbreviated</span>
<span token="--">--</span>&gt; <span token="3">3</span> <span token=":">:</span> <span token="-">-</span>&gt; (<span token="*">*</span> <span token="2">2</span>) <span token=":">:</span> <span token="-">-</span>&gt; <span token="1+">1+</span> &gt;-- .
<span token=";;">;;</span> <span token="or">or</span>, <span token="with">with</span> <span token="colons">colons</span> <span token="expanded">expanded</span> <span token="to">to</span> <span token="parens">parens</span>
<span token="--">--</span>&gt; <span token="3">3</span> (<span token="-">-</span>&gt; (<span token="*">*</span> <span token="2">2</span>) (<span token="-">-</span>&gt; <span token="1+">1+</span> &gt;--)) .
</pre><figcaption>Hypothetical threading syntax</figcaption></figure>

<details><summary> Note on Lamber syntax</summary>
<p>
The language I’m using in this post is
<a href="https://github.com/aartaka/lamber">Lamber</a>, my Lambda Calculus compiling language.
It features a minimalist syntax with only functions, values, <code>if</code>-s, and operators like
<a href="https://blog.jacobvosmaer.nl/0062-vz-1-puredata/wisp.html#inline-colon">Wisp’s colon nesting operator</a>
and terminating period (similar to Lua’s <code>end</code>.)
</p></details>

<p>
First, let’s add a function that’ll initiate the piping.
Nothing fancy, just take the initial value and a curried function.
And then apply the function to the value.

</p><figure><pre lang="lamber"><span token="def">def</span> <span token="piping">piping</span> <span token="fn">fn</span> (<span token="x">x</span> <span token="f">f</span>)
  <span token="f">f</span> <span token="x">x</span> .
<span token=";;">;;</span> <span token="also">also</span> <span token="known">known</span> <span token="as">as</span> <span token="T">T</span> <span token="combinator">combinator</span>
<span token="alias">alias</span> <span token="piping">piping</span> <span token="T">T</span> .
</pre><figcaption>Simple piping wrapper</figcaption></figure>

<p>
Now to the workhorse <code>pipe</code> function:

</p><figure><pre lang="lamber"><span token="def">def</span> <span token="pipe">pipe</span> <span token="fn">fn</span> (<span token="f">f</span> <span token="g">g</span> <span token="x">x</span>)
  <span token="g">g</span> <span token=":">:</span> <span token="f">f</span> <span token="x">x</span> .
</pre><figcaption>pipe combinator</figcaption></figure>

<p>
The way this magic works is:

</p><ul><li> We take a function to pipe and close over it
</li><li> Then we take a “continuation” to apply to this function
</li><li> And then we do the closed-over action on the value and “continue” the computation
</li></ul>

<p>
So <code>pipe (* 2) : pipe 1+ piped</code> means

</p><ul><li> closing over <code>(* 2)</code> and
</li><li> taking a function closed over <code>1+</code>
</li><li> and then applying this <code>1+</code> function to result of <code>(* 2)</code> applied to the data.
</li></ul>

<p>
Nice reversal, huh?
But what does this <code>piped</code> thing does?
It acts as a piping terminator, essentially returning what’s passed to it:

</p><figure><pre lang="lamber"><span token="def">def</span> <span token="piped">piped</span> <span token="fn">fn</span> (<span token="x">x</span>) <span token="x">x</span> .
<span token=";;">;;</span> <span token="or">or</span>
<span token="alias">alias</span> <span token="piped">piped</span> <span token="identity">identity</span> .
</pre><figcaption>Simple piped definition/alias</figcaption></figure>

<p>
We accept second function into <code>pipe</code>.
And then apply it to the result of the first one.
And the best way to stop the computation is to simply return the data passed into this second function.
Thus <code>identity</code>.

</p><p>
Not sure if I explain it well enough.
So here’s an expansion process:

</p><figure><pre lang="lamber"><span token="piping">piping</span> <span token="3">3</span> <span token=":">:</span> <span token="pipe">pipe</span> (<span token="*">*</span> <span token="2">2</span>) <span token=":">:</span> <span token="pipe">pipe</span> <span token="1+">1+</span> <span token="piped">piped</span> .
<span token="piping">piping</span> <span token="3">3</span> <span token=":">:</span> <span token="pipe">pipe</span> (<span token="*">*</span> <span token="2">2</span>) <span token=":">:</span> <span token="pipe">pipe</span> <span token="1+">1+</span> <span token="identity">identity</span> .
<span token="piping">piping</span> <span token="3">3</span> <span token=":">:</span> <span token="pipe">pipe</span> (<span token="*">*</span> <span token="2">2</span>) <span token=":">:</span> (<span token="fn">fn</span> (<span token="f">f</span> <span token="g">g</span> <span token="x">x</span>) <span token="g">g</span> <span token=":">:</span> <span token="f">f</span> <span token="x">x</span>) <span token="1+">1+</span> <span token="identity">identity</span> .
<span token="piping">piping</span> <span token="3">3</span> <span token=":">:</span> <span token="pipe">pipe</span> (<span token="*">*</span> <span token="2">2</span>) <span token=":">:</span> (<span token="fn">fn</span> (<span token="g">g</span> <span token="x">x</span>) <span token="g">g</span> <span token=":">:</span> <span token="1+">1+</span> <span token="x">x</span>)  <span token="identity">identity</span> .
<span token="piping">piping</span> <span token="3">3</span> <span token=":">:</span> <span token="pipe">pipe</span> (<span token="*">*</span> <span token="2">2</span>) <span token=":">:</span> (<span token="fn">fn</span> (<span token="x">x</span>) <span token="identity">identity</span> <span token=":">:</span> <span token="1+">1+</span> <span token="x">x</span>) .
<span token="piping">piping</span> <span token="3">3</span> <span token=":">:</span> <span token="pipe">pipe</span> (<span token="*">*</span> <span token="2">2</span>) (<span token="fn">fn</span> (<span token="x">x</span>) <span token="identity">identity</span> <span token=":">:</span> <span token="1+">1+</span> <span token="x">x</span>) .
<span token="piping">piping</span> <span token="3">3</span> <span token=":">:</span> (<span token="fn">fn</span> (<span token="f">f</span> <span token="g">g</span> <span token="x">x</span>) <span token="g">g</span> <span token=":">:</span> <span token="f">f</span> <span token="x">x</span>) (<span token="*">*</span> <span token="2">2</span>) (<span token="fn">fn</span> (<span token="x">x</span>) <span token="identity">identity</span> <span token=":">:</span> <span token="1+">1+</span> <span token="x">x</span>) .
<span token="piping">piping</span> <span token="3">3</span> <span token=":">:</span> (<span token="fn">fn</span> (<span token="g">g</span> <span token="x">x</span>) <span token="g">g</span> <span token=":">:</span> (<span token="*">*</span> <span token="2">2</span>) <span token="x">x</span>) (<span token="fn">fn</span> (<span token="x">x</span>) <span token="identity">identity</span> <span token=":">:</span> <span token="1+">1+</span> <span token="x">x</span>) .
<span token="piping">piping</span> <span token="3">3</span> <span token=":">:</span> (<span token="fn">fn</span> (<span token="x">x</span>) (<span token="fn">fn</span> (<span token="x">x</span>) <span token="identity">identity</span> <span token=":">:</span> <span token="1+">1+</span> <span token="x">x</span>) <span token=":">:</span> (<span token="*">*</span> <span token="2">2</span>) <span token="x">x</span>) .
(<span token="fn">fn</span> (<span token="x">x</span> <span token="f">f</span>) <span token="f">f</span> <span token="x">x</span>) <span token="3">3</span> (<span token="fn">fn</span> (<span token="x">x</span>) (<span token="fn">fn</span> (<span token="x">x</span>) <span token="identity">identity</span> <span token=":">:</span> <span token="1+">1+</span> <span token="x">x</span>) <span token=":">:</span> (<span token="*">*</span> <span token="2">2</span>) <span token="x">x</span>) .
(<span token="fn">fn</span> (<span token="f">f</span>) <span token="f">f</span> <span token="3">3</span>) (<span token="fn">fn</span> (<span token="x">x</span>) (<span token="fn">fn</span> (<span token="x">x</span>) <span token="identity">identity</span> <span token=":">:</span> <span token="1+">1+</span> <span token="x">x</span>) <span token=":">:</span> (<span token="*">*</span> <span token="2">2</span>) <span token="x">x</span>) .
(<span token="fn">fn</span> (<span token="x">x</span>) (<span token="fn">fn</span> (<span token="x">x</span>) <span token="identity">identity</span> <span token=":">:</span> <span token="1+">1+</span> <span token="x">x</span>) <span token=":">:</span> (<span token="*">*</span> <span token="2">2</span>) <span token="x">x</span>) <span token="3">3</span>.
(<span token="fn">fn</span> (<span token="x">x</span>) <span token="identity">identity</span> <span token=":">:</span> <span token="1+">1+</span> <span token="x">x</span>) <span token=":">:</span> (<span token="*">*</span> <span token="2">2</span>) <span token="3">3</span> .
(<span token="fn">fn</span> (<span token="x">x</span>) <span token="identity">identity</span> <span token=":">:</span> <span token="1+">1+</span> <span token="x">x</span>) <span token=":">:</span> (<span token="*">*</span> <span token="2">2</span> <span token="3">3</span>) .
(<span token="fn">fn</span> (<span token="x">x</span>) <span token="identity">identity</span> <span token=":">:</span> <span token="1+">1+</span> <span token="x">x</span>) <span token=":">:</span> <span token="6">6</span> .
<span token="identity">identity</span> <span token=":">:</span> <span token="1+">1+</span> <span token="6">6</span> .
<span token="identity">identity</span> <span token="7">7</span> .
<span token="7">7</span> .
</pre><figcaption>Meticulous expansion of piping ensemble</figcaption></figure>

<p>
This threading is still relatively wordy and noisy, even when using <code>-&gt;</code> aliases.
But that’s mostly due to Lamber’s minimalism and colon reliance.
Other languages might even introduce special operators behaving this way.
And it’ll work just fine without colons and nesting!

</p><p>
The implementation in this post is thread-last, which rhymes well with Lamber’s philosophy:
functions should be tail-heavy, putting the data to act on as last argument.
So I only need thread-last.
I leave thread-first combinator (and multi-arg ones) as an exercise to the reader.

</p><h2>Leave feedback! (via email)</h2>

</section>
</div></div>
  </body>
</html>
