<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://localstack.cloud/blog/2022-08-04-parity-explained/">Original</a>
    <h1>LocalStack and AWS Parity Explained</h1>
    
    <div id="readability-page-1" class="page"><section><div><div><div><article><p>At LocalStack we are committed to constantly improve the cloud dev experience. Here is how our AWS Server Framework and a new snapshot testing framework help us to stay on top of AWS changes.</p><a href="https://localstack.cloud/blog/2022-08-04-parity-explained/localstack-and-aws-parity-explained.png" target="_blank"><figure><img data-sizes="auto" src="https://localstack.cloud/blog/2022-08-04-parity-explained/localstack-and-aws-parity-explained_hudaf04163e8dfc19dfc0dce9dac833bdc_545063_20x0_resize_box_2.png" data-srcset="https://localstack.cloud/blog/2022-08-04-parity-explained/localstack-and-aws-parity-explained_hudaf04163e8dfc19dfc0dce9dac833bdc_545063_900x0_resize_box_2.png 900w,https://localstack.cloud/blog/2022-08-04-parity-explained/localstack-and-aws-parity-explained_hudaf04163e8dfc19dfc0dce9dac833bdc_545063_800x0_resize_box_2.png 800w,https://localstack.cloud/blog/2022-08-04-parity-explained/localstack-and-aws-parity-explained_hudaf04163e8dfc19dfc0dce9dac833bdc_545063_700x0_resize_box_2.png 700w,https://localstack.cloud/blog/2022-08-04-parity-explained/localstack-and-aws-parity-explained_hudaf04163e8dfc19dfc0dce9dac833bdc_545063_600x0_resize_box_2.png 600w,https://localstack.cloud/blog/2022-08-04-parity-explained/localstack-and-aws-parity-explained_hudaf04163e8dfc19dfc0dce9dac833bdc_545063_500x0_resize_box_2.png 500w" width="1280" height="720"/></figure></a><p>Parity for LocalStack means that when you, as a cloud developer, make an AWS API call to LocalStack’s cloud emulator, it behaves the same way AWS would.</p><p>Keeping parity with AWS has been our mission at LocalStack since day one.
This is essential for building a reliable cloud emulator that provides a great experience for cloud application developers.</p><p>Recently we introduced new mechanisms to scale the endeavor and ensure that the parity of LocalStack with AWS increases continuously over time while keeping our service implementations up-to-date.</p><p>Here are the three key things we have been working on:</p><ul><li><strong>Automated server-side code generation and API evolution:</strong> Facilitated by our new AWS Server Framework (ASF), this approach includes weekly, automated updates of API stubs, which verifies the operation definitions of each service in LocalStack are compatible with the latest changes in <code>botocore</code>.</li><li><strong>Parity Tests with Snapshot Testing:</strong> Further, we have been working on a new testing approach, called “snapshot testing”, that enables compatibility checks of LocalStack vs. AWS.</li><li><strong>Parity Metrics:</strong> Additionally, we started to collect detailed parity metrics in order to track test coverage and implementation status for services.</li></ul><h2 id="aws-server-framework">AWS Server Framework</h2><p>Distributed cloud systems like AWS have immense inherent complexity. Some people are skeptical when we tell them that LocalStack behaves in the same way AWS does.</p><p>How are we dealing with all that complexity? Since LocalStack runs on your local machine, many of the problems of distributed systems go away, and we can make simplifying assumptions about the implementation of services.</p><p>This makes emulating some services like Lambda, or SQS, which are normally complex distributed systems, much easier. Moreover, for many services, providing CRUD (Create, Read, Update, Delete) functionality is often sufficient to enable most use cases.</p><p>Each AWS service has a well-defined API and protocol specification. We have built a framework around these specs, which we call the AWS Server Framework (ASF).</p><p>ASF generates server-side stubs for services and all their supported operations. To create these APIs, LocalStack uses the definitions of the python package <code>botocore</code> - which is also a major part of the AWS CLI, and <code>boto3</code>.</p><p>All service requests are then routed to their respective server-side implementation through ASF, which implements the AWS protocol in a generalized way.</p><h3 id="asf-updates">ASF Updates</h3><p>To keep up with AWS API evolution, and <a href="https://awsapichanges.info/">there is a lot of it</a>, we have a weekly running Github action in place that checks for any API changes and will raise a pull request (PR) automatically in case changes are detected.</p><p>The PR also triggers our integration tests, and further has to be approved, and merged manually. Thus we ensure that nothing breaks accidentially.</p><a href="https://localstack.cloud/blog/2022-08-04-parity-explained/screenshot_update_asf_api.png" target="_blank"><figure><img data-sizes="auto" src="https://localstack.cloud/blog/2022-08-04-parity-explained/screenshot_update_asf_api_hueef2478bd49828552a4fee04048881ce_858977_20x0_resize_box_2.png" data-srcset="https://localstack.cloud/blog/2022-08-04-parity-explained/screenshot_update_asf_api_hueef2478bd49828552a4fee04048881ce_858977_900x0_resize_box_2.png 900w,https://localstack.cloud/blog/2022-08-04-parity-explained/screenshot_update_asf_api_hueef2478bd49828552a4fee04048881ce_858977_800x0_resize_box_2.png 800w,https://localstack.cloud/blog/2022-08-04-parity-explained/screenshot_update_asf_api_hueef2478bd49828552a4fee04048881ce_858977_700x0_resize_box_2.png 700w,https://localstack.cloud/blog/2022-08-04-parity-explained/screenshot_update_asf_api_hueef2478bd49828552a4fee04048881ce_858977_600x0_resize_box_2.png 600w,https://localstack.cloud/blog/2022-08-04-parity-explained/screenshot_update_asf_api_hueef2478bd49828552a4fee04048881ce_858977_500x0_resize_box_2.png 500w" width="2459" height="1422"/></figure></a><p>Of course, newly added operations will not work out of the box. By default, all operations that are not implemented will throw a <code>NotImplementedError</code> upon calling. However, we ensure that the declaration of each operation is compatible with AWS.</p><h2 id="parity-tests-with-snapshot-testing">Parity Tests with Snapshot Testing</h2><p>Parity tests are a special form of integration tests that verify the correctness of LocalStack compared to AWS. Recently, we have introduced this type of AWS compatible tests, with an approach that we call “snapshot testing”.</p><p>Over time, as more parity tests are added, LocalStack’s parity will be improved significantly.</p><h3 id="importance-of-parity">Importance of Parity</h3><p>Parity helps to build trust in LocalStack’s service implementation. While this should already be reason enough to put focus on parity tests, there are sometimes also internals relying on a response to be in a certain format, or to have an exact wording.</p><p>To give you one example: recently, <a href="https://github.com/localstack/localstack/pull/5978">we had a case</a>, where a slightly different message from a <code>ValidationException</code> caused an entire cdk-deployment to fail. The only thing that had changed was the wording of the message contained in that exception.</p><p>It turned out that the <a href="https://github.com/aws/aws-cdk/blob/v1-main/packages/aws-cdk/lib/api/util/cloudformation.ts#L35">aws-cdk verified the message of the exception</a> like this:</p><pre><code>
} catch (e) {
    if (e.code === &#39;ValidationError&#39; &amp;&amp; e.message === `Stack with id ${stackName} does not exist`) {
        return new CloudFormationStack(cfn, stackName, undefined);
    }
    throw e;
}
</code></pre><p>Another example is Terraform: when you setup your infrastructure with Terraform it performs very strict schema parsing. Hence, unexpected responses could even crash the deployment, for example when the return type is <code>int</code> but should be <code>string</code>.</p><p>This highlights the importance of parity tests as a technique to ensure consistency and boost the confidence in LocalStack.</p><h3 id="parity-tests-in-a-nutshell">Parity Tests in a Nutshell</h3><p>Initially, a parity test is designed to run against AWS. We will mark certain responses in the test to be part of the “snapshot.” Those responses are collected and stored in json-format in a separate file, which we call the snapshot.</p><p>We will use the snapshot to verify the behavior of LocalStack later on.
As the initial test runs against AWS, we record the “ground truth.” Consequent test runs will run against LocalStack.</p><p>During the test execution against LocalStack, the responses will be collected and compared to the recorded snapshot from AWS. This way, we can ensure that LocalStack behaves just like AWS.</p><h3 id="snapshot-testing-framework">Snapshot Testing Framework</h3><p>Of course, comparing the response bit-by-bit or character-by-character is impossible. There might be unique identifiers (like region, account-id, ARNs, timestamps) that will differ for every execution.</p><p>Thus we prepared a snapshot testing framework that, on the one hand, replaces some common, pre-defined values with placeholders. On the other hand, it also allows specifying more complex replacements for specific API calls.</p><p>For this kind of replacement we use “transformers” that do the same kind of transformation when recording the original response from AWS, and when running the test against LocalStack.</p><p>Let’s see in an example how this framework can be used.</p><h4 id="example-of-a-snapshot-integration-test">Example of a Snapshot Integration Test</h4><p>Assume we want to verify that the creation and invocation of a Lambda function has the same outcome in AWS and LocalStack:</p><ul><li>We construct our test case by adding the fixture <em>snapshot</em>.</li><li>Next, we define all responses that should be part of the recorded snapshot.</li></ul><pre><code># add the fixture &#39;snapshot&#39;
def test_basic_invoke(
        self, lambda_client, create_lambda, snapshot
    ):
			
    # custom transformers
    snapshot.add_transformer(snapshot.transform.lambda_api())

    # predefined name
    fn_name = f&#34;ls-fn-{short_uid()}&#34;

    # create the function
    response = create_lambda(FunctionName=fn_name, ...  )
    # record the response as part of the snapshot
    snapshot.match(&#34;lambda_create_fn&#34;, response)

    # invoke function
    invoke_result = lambda_client.invoke(FunctionName=fn_name, Payload=bytes(&#34;{}&#34;, &#34;utf-8&#34;))
    snapshot.match(&#34;lambda_invoke_result&#34;, invoke_result)

</code></pre><ul><li>Now, we need to <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html">configure the AWS credentials</a></li><li>Additionally, we need to:<ul><li>set the environment variable <code>TEST_TARGET=AWS_CLOUD</code>.
This instructs the framework to run the test against AWS.</li><li>enable the snapshot file creation, by running the test with the parameter <code>--snapshot-update</code></li></ul></li></ul><p>The snapshot recording will look similar to this one:</p><pre><code>{
  &#34;test_lambda_api.py::TestLambda::test_basic_invoke&#34;: {
    &#34;recorded-date&#34;: ...,
    &#34;recorded-content&#34;: {
      &#34;lambda_create_fn&#34;: {
        &#34;ResponseMetadata&#34;: {
          &#34;HTTPStatusCode&#34;: 201,
          &#34;HTTPHeaders&#34;: {}
        },
        &#34;FunctionName&#34;: &#34;&lt;function-name:1&gt;&#34;,
        &#34;FunctionArn&#34;: &#34;arn:aws:lambda:&lt;region&gt;:111111111111:function:&lt;function-name:1&gt;&#34;,
        &#34;Runtime&#34;: &#34;python3.9&#34;,
        &#34;Role&#34;: &#34;arn:aws:iam::111111111111:role/&lt;resource:1&gt;&#34;,
        &#34;Handler&#34;: &#34;index.handler&#34;,
        &#34;CodeSize&#34;: 276,
        &#34;Description&#34;: &#34;&#34;,
        &#34;Timeout&#34;: 3,
        &#34;MemorySize&#34;: 128,
        &#34;LastModified&#34;: &#34;date&#34;,
        &#34;CodeSha256&#34;: &#34;zMYxuJ0J/jyyHt1fYZUuOqZ/Gc9Gm64Wp8fT6XNiXro=&#34;,
        &#34;Version&#34;: &#34;$LATEST&#34;,
        &#34;TracingConfig&#34;: {
          &#34;Mode&#34;: &#34;PassThrough&#34;
        },
        &#34;RevisionId&#34;: &#34;&lt;uuid:1&gt;&#34;,
        &#34;State&#34;: &#34;Pending&#34;,
        &#34;StateReason&#34;: &#34;The function is being created.&#34;,
        &#34;StateReasonCode&#34;: &#34;Creating&#34;,
        &#34;PackageType&#34;: &#34;Zip&#34;,
        &#34;Architectures&#34;: [
          &#34;x86_64&#34;
        ],
        &#34;EphemeralStorage&#34;: {
          &#34;Size&#34;: 512
        }
      },
      &#34;lambda_invoke_result&#34;: {
        &#34;ResponseMetadata&#34;: {
          &#34;HTTPStatusCode&#34;: 200,
          &#34;HTTPHeaders&#34;: {}
        },
        &#34;StatusCode&#34;: 200,
        &#34;ExecutedVersion&#34;: &#34;$LATEST&#34;,
        &#34;Payload&#34;: {}
      }
    }
  }
}
</code></pre><p>For each <code>snapshot.match</code> call in the test, we see a corresponding json-response in the snapshot-file.</p><p>The snapshot also indicates that some kind of transformation was applied on the actual response.</p><p>To outline a few transformations:</p><ul><li>The function names were replaced with <code>&lt;function-name:1&gt;</code> and allows to distinguish functions without revealing the actual name.<ul><li>This can be very useful, e.g., when names are randomly generated in a test case.</li><li>We can see that the <code>FunctionName</code> is also contained in the <code>FunctionArn</code>, meaning that the function names were replaced everywhere.</li></ul></li><li>The actual region was replaced by the placeholder <code>&lt;region&gt;</code>.</li><li>The account-id was replaced by dummy account-id.</li><li>The role-name was also replaced with a reference in the field <code>Role</code>.</li></ul><p>Next, the test can be run with LocalStack. Simply remove the ENV for <code>TEST_TARGET</code> and the parameter <code>--snapshot-update</code>.</p><p>When running this example against LocalStack, any differences between the recorded snapshots will be outlined:</p><a href="https://localstack.cloud/blog/2022-08-04-parity-explained/blog-snapshot-diff.png" target="_blank"><figure><img data-sizes="auto" src="https://localstack.cloud/blog/2022-08-04-parity-explained/blog-snapshot-diff_hu6a5ff3a0a4bafb086bc8fdf0f1c21a11_32618_20x0_resize_box_2.png" data-srcset="https://localstack.cloud/blog/2022-08-04-parity-explained/blog-snapshot-diff_hu6a5ff3a0a4bafb086bc8fdf0f1c21a11_32618_900x0_resize_box_2.png 900w,https://localstack.cloud/blog/2022-08-04-parity-explained/blog-snapshot-diff_hu6a5ff3a0a4bafb086bc8fdf0f1c21a11_32618_800x0_resize_box_2.png 800w,https://localstack.cloud/blog/2022-08-04-parity-explained/blog-snapshot-diff_hu6a5ff3a0a4bafb086bc8fdf0f1c21a11_32618_700x0_resize_box_2.png 700w,https://localstack.cloud/blog/2022-08-04-parity-explained/blog-snapshot-diff_hu6a5ff3a0a4bafb086bc8fdf0f1c21a11_32618_600x0_resize_box_2.png 600w,https://localstack.cloud/blog/2022-08-04-parity-explained/blog-snapshot-diff_hu6a5ff3a0a4bafb086bc8fdf0f1c21a11_32618_500x0_resize_box_2.png 500w" width="486" height="274"/></figure></a><p>As you can see, there are some additional parameters in the AWS snapshot, that are missing in the LocalStack response, and vice versa.</p><p>This information is very important and helps us to access, improve, and fix expected responses.</p><p>While this is just a simplified example, it showcases the power of the snapshot recording and testing.</p><h4 id="parity-tests-in-action">Parity Tests in Action</h4><p>Snapshot tests should be the preferred way of writing new tests. However, some tests require additional preparation and setup to work against AWS, which naturally slows down the process of migration.</p><p>We already have some snapshot tests included in our repository.
In order to make the migration easier, we also added a marker <code>pytest.mark.skip_snapshot_verify</code> to temporarly disable the verification, which can be helpful when preparing or re-writing a test case.</p><p>With this marker it is also possible to specify a list of json-paths, which would disable the verification of the snapshot only for the specified paths:</p><pre><code>@pytest.mark.skip_snapshot_verify(paths=[&#34;$..User.Tags&#34;])
def test_iam_username_defaultname(deploy_cfn_template, iam_client, snapshot):
    snapshot.add_transformer(snapshot.transform.iam_api())
    snapshot.add_transformer(snapshot.transform.cloudformation_api())

    template = json.dumps(
        {
            &#34;Resources&#34;: {
                &#34;DefaultNameUser&#34;: {
                    &#34;Type&#34;: &#34;AWS::IAM::User&#34;,
                }
            },
            &#34;Outputs&#34;: {&#34;DefaultNameUserOutput&#34;: {&#34;Value&#34;: {&#34;Ref&#34;: &#34;DefaultNameUser&#34;}}},
        }
    )
    stack = deploy_cfn_template(template=template)
    user_name = stack.outputs[&#34;DefaultNameUserOutput&#34;]
    assert user_name

    get_iam_user = iam_client.get_user(UserName=user_name)
    snapshot.match(&#34;get_iam_user&#34;, get_iam_user)
</code></pre><p>This can be helpful in a situation like in the test case <code>test_iam_username_defaultname</code> above: one attribute is added in the output, e.g., it is not returned by AWS, but returned by LocalStack.</p><p>This strategy allows us to collect and outline deviations, while making sure that existing behavior is not broken accidentally.</p><h2 id="outlook">Outlook</h2><p>We also introduced a metric collection utility with the new AWS Server Framework. It enables us to collect details during the test execution, including used parameter values or raised exceptions.</p><p>This information will help us to increase test coverage and consequently improve the parity with AWS.</p><p>Additionally, we will provide regular metric updates and insights about supported services and operations. Thus our communication will be more transparent regarding implemented APIs and improve confidence overall.</p><p>We hope you are as excited as we are about our AWS Server Framework, which ensures the latest compatibility with AWS, and the new snapshot testing framework, which will help us to write validated test cases.</p></article></div></div></div></section></div>
  </body>
</html>
