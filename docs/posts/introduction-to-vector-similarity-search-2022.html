<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zilliz.com/blog/vector-similarity-search">Original</a>
    <h1>Introduction to vector similarity search (2022)</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>In the previous tutorials, we took a look at <a href="https://zilliz.com/blog/introduction-to-unstructured-data">unstructured data</a>, <a href="https://zilliz.com/learn/what-is-vector-database">vector databases</a>, and <a href="https://zilliz.com/blog/introduction-to-milvus-vector-database">Milvus</a> - the world&#39;s most popular <a href="https://milvus.io/">open-source vector database</a>. We also briefly touched upon the idea of <em>embeddings</em>, high-dimensional vectors which serve as awesome semantic representations of unstructured data. One key note to remember - embeddings which are &#34;close&#34; to one another represent semantically similar pieces of data.</p>
<p>In this introduction to vector search, we&#39;ll define what vector search is, and answer some fundamental questions about it. Then, we will build on that knowledge by going over a word embedding example and seeing how semantically similar pieces of unstructured data are &#34;near&#34; one another while dissimilar pieces of unstructured data are &#34;far&#34; from one another. This will lead into a high-level overview of <em><a href="https://zilliz.com/glossary/anns">nearest neighbor search</a></em>, a computing problem that involves finding the closest vector(s) to a query vector based on a unified <em>distance metric</em>. We&#39;ll go over some well-known methods for nearest neighbor search (including my favorite - <a href="https://zilliz.com/learn/approximate-nearest-neighbor-oh-yeah-ANNOY">ANNOY</a>) in addition to commonly used <em>distance metrics</em>.</p>
<p>Let&#39;s dive in.</p>
<p>Vector search, also known as vector similarity search or nearest neighbor search, is a technique used in data retrieval and information retrieval systems to find items or data points that are similar or closely related to a given query vector. In vector search, we represent data points, such as images, texts, and audio, as vectors in a high-dimensional space. The goal of vector search is to efficiently search and retrieve the most relevant vectors that are similar or nearest to a query vector.</p>
<p>Typically, distance metrics such as Euclidean distance or cosine similarity measure the similarity between vectors. The vector&#39;s proximity in the vector space determines how similar it is. To efficiently organize and search vectors, vector search algorithms use indexing structures such as tree-based structures or hashing techniques.</p>
<p>Vector search has various applications, including recommendation systems, image and video retrieval, natural language processing, anomaly detection, and question and answer chatbots. Using vector search makes it possible to find relevant items, patterns, or relationships within high-dimensional data, enabling more accurate and efficient information retrieval.</p>
<p>Vector search is a powerful method for analyzing and retrieving information from high-dimensional spaces. It enables users to find similar or closely related items to a given query, making it crucial in various domains. Here are the benefits of vector search:</p>
<ul>
<li><strong>Similarity-based Retrieval</strong>— Vector search allows for similarity-based Retrieval, enabling users to find similar or closely related items to a given query. Similarity-based Retrieval is crucial in various domains, such as recommendation systems, where users expect personalized recommendations based on their preferences or similarities to other users.</li>
<li><strong>High-dimensional Data Analysis</strong> — With the increasing availability of high-dimensional data, such as images, audio, and textual data, traditional search methods become less effective. Vector search provides a powerful way to analyze and retrieve information from high-dimensional spaces, allowing for more accurate and efficient data exploration.</li>
<li><strong>Nearest-Neighbor Search</strong> — Efficient nearest-neighbor search algorithms find the nearest neighbors to a given query vector. Nearest-neighbor search is handy for critical tasks such as an image or document similarity search, content-based Retrieval, or anomaly detection that require finding the closest matches or similar items.</li>
<li><strong>Improved User Experience</strong>— By leveraging vector search, applications can provide users with more relevant and personalized results. Whether delivering relevant recommendations, retrieving visually similar images, or finding documents with similar content, vector search enhances the overall user experience by providing more targeted and meaningful results.</li>
<li><strong>Scalability</strong> — Vector search algorithms and indexing structures handle large-scale datasets and high-dimensional spaces efficiently. They enable fast search and retrieval operations, making it feasible to perform similarity-based queries in real-time, even on massive datasets.</li>
</ul>
<ul>
<li>Image, video, audio similarity search</li>
<li>AI drug discovery</li>
<li>Semantic search engine</li>
<li>DNA sequence classification</li>
<li>Question answering system</li>
<li>Recommender system</li>
<li>Anomaly detection</li>
</ul>
<p>Now that we have covered the basics of vector search, let’s look into the more technical details by looking at a word embedding example and finish with a high-level overview of nearest neighbor search.</p>
<p>Let&#39;s go through a couple of word embedding examples. For the sake of simplicity, we&#39;ll use <code>word2vec</code>, an old model which uses a training methodology based on <em>skipgrams</em>. BERT and other modern transformer-based models will be able to provide you with more contextualized word embeddings, but we&#39;ll stick with <code>word2vec</code> for simplicity. Jay Alammar provides a <a href="https://jalammar.github.io/illustrated-word2vec/">great tutorial on <code>word2vec</code></a>, if you&#39;re interested in learning a bit more.</p>
<p>Before beginning, we&#39;ll need to install the <code>gensim</code> library and load a <code>word2vec</code> model.</p>
<pre><code><span>% </span><span>pip install gensim --disable-pip-version-check</span>
<span>% </span><span>wget https://s3.amazonaws.com/dl4j-distribution/GoogleNews-vectors-negative300.bin.gz</span>
<span>% </span><span>gunzip GoogleNews-vectors-negative300.bin</span>
</code></pre>
<pre><code>Requirement already satisfied: gensim in /Users/fzliu/.pyenv/lib/python3.8/site-packages (4.1.2)
Requirement already satisfied: smart-open&gt;=1.8.1 in /Users/fzliu/.pyenv/lib/python3.8/site-packages (from gensim) (5.2.1)
Requirement already satisfied: numpy&gt;=1.17.0 in /Users/fzliu/.pyenv/lib/python3.8/site-packages (from gensim) (1.19.5)
Requirement already satisfied: scipy&gt;=0.18.1 in /Users/fzliu/.pyenv/lib/python3.8/site-packages (from gensim) (1.7.3)
--2022-02-22 00:30:34--  https://s3.amazonaws.com/dl4j-distribution/GoogleNews-vectors-negative300.bin.gz
Resolving s3.amazonaws.com (s3.amazonaws.com)... 52.216.20.165
Connecting to s3.amazonaws.com (s3.amazonaws.com)|52.216.20.165|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 1647046227 (1.5G) [application/x-gzip]
Saving to: GoogleNews-vectors-negative300.bin.gz

GoogleNews-vectors- 100%[===================&gt;]   1.53G  2.66MB/s    in 11m 23s

2022-02-22 00:41:57 (2.30 MB/s) - GoogleNews-vectors-negative300.bin.gz saved [1647046227/1647046227]

gunzip: GoogleNews-vectors-negative300.bin: unknown suffix -- ignored
</code></pre>
<p>Now that we&#39;ve done all the prep work required to generate word-to-vector embeddings, let&#39;s load the trained <code>word2vec</code> model.</p>
<pre><code><span>&gt;&gt;&gt; </span><span>from</span> gensim.models <span>import</span> KeyedVectors
<span>&gt;&gt;&gt; </span>model = KeyedVectors.load_word2vec_format(<span>&#39;GoogleNews-vectors-negative300.bin&#39;</span>, binary=<span>True</span>)
</code></pre>
<h3 id="Example-0-Marlon-Brando">Example 0: Marlon Brando</h3><p>Let&#39;s take a look at how <code>word2vec</code> interprets the famous actor Marlon Brando.</p>
<pre><code><span>&gt;&gt;&gt; </span><span>print</span>(model.most_similar(positive=[<span>&#39;Marlon_Brando&#39;</span>]))
</code></pre>
<pre><code>[(&#39;Brando&#39;, 0.757453978061676), (&#39;Humphrey_Bogart&#39;, 0.6143958568572998), (&#39;actor_Marlon_Brando&#39;, 0.6016287207603455), (&#39;Al_Pacino&#39;, 0.5675410032272339), (&#39;Elia_Kazan&#39;, 0.5594002604484558), (&#39;Steve_McQueen&#39;, 0.5539456605911255), (&#39;Marilyn_Monroe&#39;, 0.5512186884880066), (&#39;Jack_Nicholson&#39;, 0.5440199375152588), (&#39;Shelley_Winters&#39;, 0.5432392954826355), (&#39;Apocalypse_Now&#39;, 0.5306933522224426)]
</code></pre>
<p>Marlon Brando worked with Al Pacino in The Godfather and Elia Kazan in A Streetcar Named Desire. He also starred in Apocalypse Now.</p>
<p>Vectors can be added and subtracted from each other to demo underlying semantic changes.</p>
<pre><code><span>&gt;&gt;&gt; </span><span>print</span>(model.most_similar(positive=[<span>&#39;king&#39;</span>, <span>&#39;woman&#39;</span>], negative=[<span>&#39;man&#39;</span>], topn=<span>1</span>))
</code></pre>
<pre><code>[(&#39;queen&#39;, 0.7118193507194519)]
</code></pre>
<p>Who says engineers can&#39;t enjoy a bit of dance-pop now and then?</p>
<p>The word &#34;apple&#34; can refer to both the company as well as the delicious red fruit. In this example, we can see that Word2Vec retains both meanings.</p>
<pre><code><span>&gt;&gt;&gt; </span><span>print</span>(model.most_similar(positive=[<span>&#39;samsung&#39;</span>, <span>&#39;iphone&#39;</span>], negative=[<span>&#39;apple&#39;</span>], topn=<span>1</span>))
<span>&gt;&gt;&gt; </span><span>print</span>(model.most_similar(positive=[<span>&#39;fruit&#39;</span>], topn=<span>10</span>)[<span>9</span>:])
</code></pre>
<pre><code>[(&#39;droid_x&#39;, 0.6324754953384399)]
[(&#39;apple&#39;, 0.6410146951675415)]
</code></pre>
<p>&#34;Droid&#34; refers to Samsung&#39;s first 4G LTE smartphone (&#34;Samsung&#34; + &#34;iPhone&#34; - &#34;Apple&#34; = &#34;Droid&#34;), while &#34;apple&#34; is the 10th closest word to &#34;fruit&#34;.</p>
<p>Now that we&#39;ve seen the power of embeddings, let&#39;s briefly take a look at some of the ways we can conduct nearest neighbor search. This is not a comprehensive list; we&#39;ll just briefly go over some common methods in order to provide a high-level overview of how vector search is conducted at scale. Note that some of these methods are not exclusive to each other - it&#39;s possible, for example, to use quantization in conjunction with space partitioning.</p>
<p>(We&#39;ll also be going over each of these methods in detail in future tutorials, so stay tuned for more.)</p>
<p>The simplest but most naïve nearest neighbor search algorithm is good old linear search: computing the distance from a query vector to all other vectors in the vector database.</p>
<p>For obvious reasons, naïve search does not work when trying to scale our vector database to tens or hundreds of millions of vectors. But when the total number of elements in the database is small, this can actually be the most efficient way to perform vector search since a separate data structure for the index is not required, while inserts and deletes can be implemented fairly easily.</p>
<p>Due to the lack of space complexity as well as constant space overhead associated with naïve search, this method can often outperform space partitioning even when querying across a moderate number of vectors.</p>
<p>Space partitioning is not a single algorithm, but rather a family of algorithms that all use the same concept.</p>
<p>K-dimensional trees (kd-trees) are perhaps the most well-known in this family, and work by continuously bisecting the search space (splitting the vectors into “left” and “right” buckets) in a manner similar to binary search trees.</p>
<p>Inverted file index (IVF) is also a form of space partitioning, and works by assigning each vector to its nearest centroid - searches are then conducted by first determining the query vector&#39;s closest centroid and conducting the search around there, significantly reducing the total number of vectors that need to be searched. IVF is a fairly popular indexing strategy and is commonly combined with other indexing algorithms to improve performance.</p>
<p>Quantization is a technique for reducing the total size of the database by reducing the precision of the vectors.</p>
<p>Scalar quantization (SQ), for example, works by multiplying high-precision floating point vectors with a scalar value, then casting the elements of the resultant vector to their nearest integers. This not only reduces the effective size of the entire database (e.g. by a factor of eight for conversion from <code>float64_t</code> to <code>int8_t</code>), but also has the positive side-effect of speeding up vector-to-vector distance computations.</p>
<p>Product quantization (PQ) is another quantization technique that works similar to dictionary compression. In PQ, all vectors are split into equally-sized subvectors, and each subvector is then replaced with a centroid.</p>
<p>Hierarchical Navigable Small Worlds is a graph-based indexing and retrieval algorithm.</p>
<p>This works differently from product quantization: instead of improving the searchability of the database by reducing its effective size, HNSW creates a multi-layer graph from the original data. Upper layers contain only &#34;long connections&#34; while lower layers contain only &#34;short connections&#34; between vectors in the database (see the next section for an overview of vector distance metrics). Individual graph connections are created a-la skip lists.</p>
<p>With this architecture in place, searching becomes fairly straightforward – we greedily traverse the uppermost graph (the one with the longest inter-vector connections) for the vector closest to our query vector. We then do the same for the second layer, using the result of the first layer search as the starting point. This continues until we complete the search at the bottommost layer, the result of which becomes the nearest neighbor of the query vector.</p>
<p>
      <span>
        <a href="https://assets.zilliz.com/hnsw_visualized_9bd0417e4d.png" title="HNSW, visualized. Image source: https://arxiv.org/abs/1603.09320" target="_blank"><img src="https://assets.zilliz.com/hnsw_visualized_9bd0417e4d.png" alt="HNSW, visualized. Image source: https://arxiv.org/abs/1603.09320" id="hnsw,-visualized.-image-source:-https://arxiv.org/abs/1603.09320"/></a>
        <span>HNSW, visualized. Image source: https://arxiv.org/abs/1603.09320</span>
      </span>
    </p>
<p>This is probably my favorite ANN algorithm simply due to its playful and unintunitive name. <a href="https://github.com/spotify/annoy">Approximate Nearest Neighbors Oh Yeah</a> (ANNOY) is a tree-based algorithm popularized by Spotify (it’s used in their music recommendation system). Despite the strange name, the underlying concept behind ANNOY is actually fairly simple – binary trees.</p>
<p>ANNOY works by first randomly selecting two vectors in the database and bisecting the search space along the hyperplane separating those two vectors. This is done iteratively until there are fewer than some predefined parameter <code>NUM_MAX_ELEMS</code> per node. Since the resulting index is essentially a binary tree, this allows us to do our search on O(log n) complexity.</p>
<p>
      <span>
        <a href="https://assets.zilliz.com/annoy_visualized_1adb042e7e.png" title="ANNOY, visualized. Image source: https://github.com/spotify/annoy" target="_blank"><img src="https://assets.zilliz.com/annoy_visualized_1adb042e7e.png" alt="ANNOY, visualized. Image source: https://github.com/spotify/annoy" id="annoy,-visualized.-image-source:-https://github.com/spotify/annoy"/></a>
        <span>ANNOY, visualized. Image source: https://github.com/spotify/annoy</span>
      </span>
    </p>
<p>The <a href="https://zilliz.com/">very best vector databases</a> are useless without similarity metrics – methods for computing the distance between two vectors. Numerous metrics exist, so we will discuss only the most commonly used subset here.</p>
<p>The most common floating point vector similarity metrics are, in no particular order, <em>L1 distance</em>, <em>L2 distance</em>, and <em>cosine similarity</em>. The first two values are <em>distance metrics</em> (lower values imply more similarity while higher values imply lower similarity), while cosine similarity is a <em>similarity metric</em> (higher values imply more simlarity).</p>
<ol>
<li><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>d</mi><mrow><mi>l</mi><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi mathvariant="bold">a</mi><mo separator="true">,</mo><mi mathvariant="bold">b</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mi mathvariant="normal">∣</mi><msub><mi mathvariant="bold">a</mi><mi>i</mi></msub><mo>−</mo><msub><mi mathvariant="bold">b</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">d_{l1}(\mathbf{a},\mathbf{b})=\sum_{i=1}^{N}|\mathbf{a}_i-\mathbf{b}_i|</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>d</span><span><span><span><span><span><span></span><span><span><span>l</span><span>1</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>a</span><span>,</span><span></span><span>b</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span><span></span><span><span>∑</span></span></span><span><span></span><span><span><span>N</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span><span>∣</span><span><span>a</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span></span><span><span></span><span><span>b</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>∣</span></span></span></span></span></li>
<li><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>d</mi><mrow><mi>l</mi><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi mathvariant="bold">a</mi><mo separator="true">,</mo><mi mathvariant="bold">b</mi><mo stretchy="false">)</mo><mo>=</mo><msqrt><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mo stretchy="false">(</mo><msub><mi mathvariant="bold">a</mi><mi>i</mi></msub><mo>−</mo><msub><mi mathvariant="bold">b</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">d_{l2}(\mathbf{a},\mathbf{b})=\sqrt{\sum_{i=1}^{N}(\mathbf{a}_i-\mathbf{b}_i)^2}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>d</span><span><span><span><span><span><span></span><span><span><span>l</span><span>2</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>a</span><span>,</span><span></span><span>b</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span><span><span><span><span></span><span><span><span><span><span><span><span></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span><span></span><span><span>∑</span></span></span><span><span></span><span><span><span>N</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span>(</span><span><span>a</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span><span><span>b</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span><span>)</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span></span></span></span></span></span></span><span><span></span><span><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="3.3738em" viewBox="0 0 400000 3373" preserveAspectRatio="xMinYMin slice"><path d="M702 80H40000040
H742v3239l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 80H400000v40H742z"></path></svg></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></li>
<li><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>d</mi><mrow><mi>c</mi><mi>o</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi mathvariant="bold">a</mi><mo separator="true">,</mo><mi mathvariant="bold">b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi mathvariant="bold">a</mi><mo>⋅</mo><mi mathvariant="bold">b</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="bold">a</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="bold">b</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">d_{cos}(\mathbf{a},\mathbf{b})=\frac{\mathbf{a}\cdot\mathbf{b}}{|\mathbf{a}||\mathbf{b}|}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>d</span><span><span><span><span><span><span></span><span><span><span>cos</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>a</span><span>,</span><span></span><span>b</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span>∣</span><span>a</span><span>∣∣</span><span>b</span><span>∣</span></span></span><span><span></span><span></span></span><span><span></span><span><span>a</span><span></span><span>⋅</span><span></span><span>b</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span></span></span></span></li>
</ol>
<p>L1 distance is also commonly referred to as Manhattan distance, aptly named after the fact that getting from point A to point B in Manhattan requires moving along one of two perpendicular directions. The second equation, L2 distance, is simply the distance between two vectors in Euclidean space. The third and final equation is cosine distance, equivalent to the cosine of the angle between two vectors. Note the equation for cosine similarity works out to be the dot product between normalized versions of input vectors <strong>a</strong> and <strong>b</strong>.</p>
<p>With a bit of math, we can also show that L2 distance and cosine similarity are effectively equivalent when it comes to similarity ranking for unit norm vectors:</p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>d</mi><mrow><mi>l</mi><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi mathvariant="bold">a</mi><mo separator="true">,</mo><mi mathvariant="bold">b</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="bold">a</mi><mo>−</mo><mi mathvariant="bold">b</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mo stretchy="false">(</mo><mi mathvariant="bold">a</mi><mo>−</mo><mi mathvariant="bold">b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_{l2}(\mathbf{a},\mathbf{b})=(\mathbf{a}-\mathbf{b})^T(\mathbf{a}-\mathbf{b})</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>d</span><span><span><span><span><span><span></span><span><span><span>l</span><span>2</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>a</span><span>,</span><span></span><span>b</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span>(</span><span>a</span><span></span><span>−</span><span></span></span><span><span></span><span>b</span><span><span>)</span><span><span><span><span><span><span></span><span><span>T</span></span></span></span></span></span></span></span><span>(</span><span>a</span><span></span><span>−</span><span></span></span><span><span></span><span>b</span><span>)</span></span></span></span></span>
<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><msup><mi mathvariant="bold">a</mi><mi>T</mi></msup><mi mathvariant="bold">a</mi><mo>−</mo><mn>2</mn><msup><mi mathvariant="bold">a</mi><mi>T</mi></msup><mi mathvariant="bold">b</mi><mo>+</mo><msup><mi mathvariant="bold">b</mi><mi>T</mi></msup><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">=\mathbf{a}^T\mathbf{a}-2\mathbf{a}^T\mathbf{b}+\mathbf{b}^T\mathbf{b}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>=</span><span></span></span><span><span></span><span><span>a</span><span><span><span><span><span><span></span><span><span>T</span></span></span></span></span></span></span></span><span>a</span><span></span><span>−</span><span></span></span><span><span></span><span>2</span><span><span>a</span><span><span><span><span><span><span></span><span><span>T</span></span></span></span></span></span></span></span><span>b</span><span></span><span>+</span><span></span></span><span><span></span><span><span>b</span><span><span><span><span><span><span></span><span><span>T</span></span></span></span></span></span></span></span><span>b</span></span></span></span></span></p>
<p>Recall that unit norm vectors have a magnitude of 1:</p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi mathvariant="bold">a</mi><mi>T</mi></msup><mi mathvariant="bold">a</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mathbf{a}^T\mathbf{a}=1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>a</span><span><span><span><span><span><span></span><span><span>T</span></span></span></span></span></span></span></span><span>a</span><span></span><span>=</span><span></span></span><span><span></span><span>1</span></span></span></span></span></p>
<p>With this, we get:</p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi mathvariant="bold">a</mi><mi>T</mi></msup><mi mathvariant="bold">a</mi><mo>−</mo><mn>2</mn><msup><mi mathvariant="bold">a</mi><mi>T</mi></msup><mi mathvariant="bold">b</mi><mo>+</mo><msup><mi mathvariant="bold">b</mi><mi>T</mi></msup><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\mathbf{a}^T\mathbf{a}-2\mathbf{a}^T\mathbf{b}+\mathbf{b}^T\mathbf{b}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>a</span><span><span><span><span><span><span></span><span><span>T</span></span></span></span></span></span></span></span><span>a</span><span></span><span>−</span><span></span></span><span><span></span><span>2</span><span><span>a</span><span><span><span><span><span><span></span><span><span>T</span></span></span></span></span></span></span></span><span>b</span><span></span><span>+</span><span></span></span><span><span></span><span><span>b</span><span><span><span><span><span><span></span><span><span>T</span></span></span></span></span></span></span></span><span>b</span></span></span></span></span>
<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><mn>2</mn><mo>−</mo><mn>2</mn><msup><mi mathvariant="bold">a</mi><mi>T</mi></msup><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">=2-2\mathbf{a}^T\mathbf{b}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>=</span><span></span></span><span><span></span><span>2</span><span></span><span>−</span><span></span></span><span><span></span><span>2</span><span><span>a</span><span><span><span><span><span><span></span><span><span>T</span></span></span></span></span></span></span></span><span>b</span></span></span></span></span></p>
<p>Since we have unit norm vectors, cosine distance works out to be the dot product between <strong>a</strong> and <strong>b</strong> (the denominator in equation 3 above works out to be 1):</p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>2</mn><mo>−</mo><mn>2</mn><msup><mi mathvariant="bold">a</mi><mi>T</mi></msup><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">2-2\mathbf{a}^T\mathbf{b}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>2</span><span></span><span>−</span><span></span></span><span><span></span><span>2</span><span><span>a</span><span><span><span><span><span><span></span><span><span>T</span></span></span></span></span></span></span></span><span>b</span></span></span></span></span>
<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><mn>2</mn><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>d</mi><mrow><mi>c</mi><mi>o</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi mathvariant="bold">a</mi><mo separator="true">,</mo><mi mathvariant="bold">b</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">=2(1-d_{cos}(\mathbf{a},\mathbf{b}))</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>=</span><span></span></span><span><span></span><span>2</span><span>(</span><span>1</span><span></span><span>−</span><span></span></span><span><span></span><span><span>d</span><span><span><span><span><span><span></span><span><span><span>cos</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>a</span><span>,</span><span></span><span>b</span><span>))</span></span></span></span></span></p>
<p>Essentially, for unit norm vectors, L2 distance and cosine similarity are functionally equivalent! Always remember to normalize your embeddings.</p>
<p>Binary vectors, as their name suggest, do not have metrics based in arithmetics a-la floating point vectors. Similarity metrics for binary vectors instead rely on either set mathematics, bit manipulation, or a combination of both (it&#39;s okay, I also hate discrete math). Here are the formulas for two commonly used binary vector similarity metrics:</p>
<ol>
<li><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>d</mi><mi>J</mi></msub><mo stretchy="false">(</mo><mi mathvariant="bold">a</mi><mo separator="true">,</mo><mi mathvariant="bold">b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mi mathvariant="bold">a</mi><mo>⋅</mo><mi mathvariant="bold">b</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">∣</mi><mi>b</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>−</mo><mi mathvariant="bold">a</mi><mo>⋅</mo><mi mathvariant="bold">b</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">d_J(\mathbf{a},\mathbf{b})=1-\frac{\mathbf{a}\cdot\mathbf{b}}{|a|^2+|b|^2-\mathbf{a}\cdot\mathbf{b}}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>d</span><span><span><span><span><span><span></span><span><span>J</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>a</span><span>,</span><span></span><span>b</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span>1</span><span></span><span>−</span><span></span></span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span>∣</span><span>a</span><span><span>∣</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span></span></span></span></span><span></span><span>+</span><span></span><span>∣</span><span>b</span><span><span>∣</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span></span></span></span></span><span></span><span>−</span><span></span><span>a</span><span></span><span>⋅</span><span></span><span>b</span></span></span><span><span></span><span></span></span><span><span></span><span><span>a</span><span></span><span>⋅</span><span></span><span>b</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span></span></span></span></li>
<li><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>d</mi><mi>J</mi></msub><mo stretchy="false">(</mo><mi mathvariant="bold">a</mi><mo separator="true">,</mo><mi mathvariant="bold">b</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi mathvariant="bold">a</mi><mi>i</mi></msub><mo>⊕</mo><msub><mi mathvariant="bold">b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_J(\mathbf{a},\mathbf{b})=\sum_{i=1}^{N}\mathbf{a}_i\oplus\mathbf{b}_i</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>d</span><span><span><span><span><span><span></span><span><span>J</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>a</span><span>,</span><span></span><span>b</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span><span></span><span><span>∑</span></span></span><span><span></span><span><span><span>N</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span><span><span>a</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>⊕</span><span></span></span><span><span></span><span><span>b</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></li>
</ol>
<p>The first equation is called Tanimoto/Jaccard distance, and is essentially a measure of the amount of overlap between two binary vectors. The second equation is Hamming distance, and is a count of the number of vector elements in a and b which differ from each other.</p>
<p>You can most likely safely ignore these similarity metrics, since the majority of applications use cosine similarity over floating point embeddings.</p>
<p>In this tutorial, we took a look at vector search / vector similarity search, along with some common vector search algorithms and distance metrics. Here are some key takeaways:</p>
<ul>
<li>Embedding vectors are powerful representations, both in terms of distance between the vectors and in terms of vector arithmetic. By applying a liberal quantity of vector algebra to embeddings, we can perform scalable semantic analysis using just basic mathematical operators.</li>
<li>There are a wide variety of approximate nearest neighbor search algorithms and/or index types to choose from. The most commonly one used today is HNSW, but a different indexing algorithm may work better for your particular application, depending on the total number of embeddings you have in addition to the length of each individual vector.</li>
<li>The two primary distance metrics used today are L2/Euclidean distance and cosine distance. These two metrics, when used on normalized embeddings, are functionally equivalent.</li>
</ul>
<p>Thanks for joining us for this tutorial! Vector search is a core part of Milvus, and it will continue to be.  In future tutorials, we&#39;ll be doing some deeper dives into the most commonly used ANNS algorithms - HNSW and ScaNN.</p>
<ol>
<li><ul>
<li><a href="https://zilliz.com/blog/introduction-to-unstructured-data">Introduction to Unstructured Data</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/learn/what-is-vector-database">What is a Vector Database?</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/blog/introduction-to-milvus-vector-database">Introduction to Milvus</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/blog/milvus-vector-database-quickstart">Milvus Quickstart</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/blog/vector-similarity-search">Introduction to Vector Similarity Search</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/blog/vector-index">Vector Index Basics and the Inverted File Index</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/blog/scalar-quantization-and-product-quantization">Scalar Quantization and Product Quantization</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/blog/hierarchical-navigable-small-worlds-HNSW">Hierarchical Navigable Small Worlds (HNSW)</a></li>
</ul></li>
<li><ul>
<li><a href="https://zilliz.com/learn/approximate-nearest-neighbor-oh-yeah-ANNOY">Approximate Nearest Neighbor Oh Yeah (ANNOY)</a></li>
</ul></li>
</ol>
</div></div></div>
  </body>
</html>
