<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chromium.googlesource.com/chromium/src/&#43;/refs/heads/main/docs/security/rust-toolchain.md">Original</a>
    <h1>Experimenting with Rust in Chromium</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>Parsing untrustworthy data is a major source of security bugs, and it&#39;s therefore against Chromium rules <a href="https://thewitchofendor.com/2022/06/15/ma-bookclub-space-time-knots/rule-of-2.md">to do it in the browser process</a> unless you can use a memory safe language.</p><p>For teams building browser process features which need to handle untrustworthy data, they usually have to do the parsing in a utility process which incurs a performance overhead and adds engineering complexity.</p><p>The Chrome security team is working to make a cross-platform memory safe language available to Chromium developers. This document describes how to use that language in Chromium. The language, at least for now, is Rust.</p><p>Support for Rust in Chromium is experimental. We appreciate your help in these experiments, but please remember that Rust is not supported for production use cases.</p><p>So:</p><ul><li>any experiments must be reversible (you may have to write a C++ equivalent in order to ship)</li><li>Rust code must not affect production Chrome binaries nor be shipped to Chrome users (we provide <code>#if defined(...)</code> and other facilities to make this easy) - so if you put Rust code in Chrome, the sole purpose is to help experiment and provide data for evaluation of future memory safe language options</li><li>Rust is not yet available on all Chromium platforms (just Linux and Android for now)</li><li>Facilities and tooling in Rust are not as rich as other languages yet.</li></ul><p>That said, if presence of Rust would make your feature easier, we are keen for you to join in our experiments. Here&#39;s how. Please also let us know your interest via <code>rust-dev@chromium.org</code>.</p><p>Add <code>enable_rust = true</code> in your <code>gn</code> arguments. At the moment, this works only for Linux platforms (but <a href="#Building-on-non-Linux-platforms">see below</a> for how to enable on other platforms).</p><p>Also add <code>&#34;use_rust&#34;: True</code> to your <code>.gclient</code> file to enable fetching required tools and libraries:</p><pre>solutions = [
  {
    ...
    &#34;custom_vars&#34;: {
      ...
      &#34;use_rust&#34;: True,
    },
  },
]
</pre><p>See also <a href="#using-vscode">Using VSCode</a>.</p><p>Assume you want to add some Rust code to an existing C++ <code>source_set</code>. Simply:</p><ul><li><code>import(&#34;//build/rust/mixed_source_set.gni&#34;)</code></li><li>Replace <code>source_set</code> with <code>mixed_source_set</code></li><li>Add <code>rs_sources = [ &#34;src/lib.rs&#34; ]</code> (and likely <code>rs_cxx_bindings</code>, see below)</li><li>Add your Rust code in <code>src/lib.rs</code></li><li>In your C++ code, make Rust calls based on the <code>#if defined(RUST_ENABLED)</code>.</li></ul><p>In toolchains with Rust disabled, your <code>source_set</code> will continue to be a plain C++ source set and absolutely nothing will change.</p><p>In toolchains with Rust, <code>RUST_ENABLED</code> will be defined and then you can call into Rust code (again, see the section on C++/Rust interop bindings below).</p><h2><a name="A-note-on-source-code-naming" href="#A-note-on-source-code-naming"><span></span></a><a name="a-note-on-source-code-naming" href="#a-note-on-source-code-naming"><span></span></a>A note on source code naming</h2><p>Within a mixed code source set, it‘s (currently) normal to have C/C++ code in its main directory, whilst Rust code goes into a subdirectory called <code>src</code> (and the main file is always called <code>lib.rs</code>.) This follows the practice of other teams, but if you don’t like it, that&#39;s fine: feel free to store your <code>.rs</code> code alongside your <code>.cc</code> code, but specify also <code>rs_crate_root</code> in your <code>mixed_source_set</code>.</p><h2><a name="I_m-not-using-a" href="#I_m-not-using-a"><span></span></a><a name="i_m-not-using-a" href="#i_m-not-using-a"><span></span></a>I&#39;m not using a <code>source_set</code></h2><p>There are equivalent templates for <code>mixed_component</code> and <code>mixed_executable</code>. But if you need to do something more sophisticated, you can create a new pure-Rust language target - see <code>//build/rust/rust_source_set.gni</code>. C++ targets can simply depend on this Rust target but with the suffix <code>_cpp_bindings</code> appended to the target name:</p><pre>deps = [ &#34;//path/to/my_rust_target:my_rust_target_cpp_bindings&#34; ]
</pre><p>If your Rust code calls back into C++, this is more complex in order to avoid layering violations - look into <code>mutually_dependent_target</code> in that <code>.gni</code> file.</p><p>Rust supports unit tests within the primary source code files (e.g. see <a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">an example here</a>). This section describes how to build and run such unit tests.</p><h2><a name="Automatically-generated-targets" href="#Automatically-generated-targets"><span></span></a><a name="automatically-generated-targets" href="#automatically-generated-targets"><span></span></a>Automatically generated targets</h2><p>GN templates that work with Rust sources will automatically generate a bonus <code>gn</code> target called <code>&lt;your target name&gt;_unittests</code> (for pure-Rust targets like <code>cargo_crate</code>, <code>executable</code>, or <code>rust_source_set</code>) or <code>&lt;your target name&gt;_rs_unittests</code> (for mixed C++/Rust targets like (<code>mixed_component</code>, <code>mixed_executable</code>, or <code>mixed_source_set</code>).  This bonus target builds:</p><ul><li>An <code>out/Default/&lt;bonus target name&gt;</code> executable containing Rust unit tests from your code</li><li>An <code>out/Default/bin/run_&lt;bonus target name&gt;</code> script that enables running the tests on Chromium bots.</li></ul><h2><a name="Explicitly-defined-groups-of-tests" href="#Explicitly-defined-groups-of-tests"><span></span></a><a name="explicitly-defined-groups-of-tests" href="#explicitly-defined-groups-of-tests"><span></span></a>Explicitly defined groups of tests</h2><p>To group multiple Rust unit test executables into a single test step, please use the <code>rust_unit_tests_group(&#34;my_test_group&#34;)</code> template:</p><pre>rust_unit_tests_group(&#34;my_group_of_rust_unit_tests&#34;) {
  deps = [
    &#34;my_rust_source_set1&#34;,
    &#34;my_rust_source_set2&#34;,
    &#34;my_rust_executable&#34;,
    # ...
  ]
}
</pre><p>The example above will build all the <code>deps</code>.  This will also generate a wrapper script that wraps all the Rust unit test executables from <code>deps</code> and their transitive dependencies.  In the example above, the script will be generated at <code>out/Default/bin/run_my_group_of_rust_unit_tests</code>.</p><p>The generated script can be used for integration with Chromium bots, but can also be used as a convenience to manually/locally run all tests from the group. Run the script with the <code>--help</code> argument to see more details (e.g. how to filter which tests to run).</p><h2><a name="Configuring-running-Rust-unit-tests-on-bots" href="#Configuring-running-Rust-unit-tests-on-bots"><span></span></a><a name="configuring-running-rust-unit-tests-on-bots" href="#configuring-running-rust-unit-tests-on-bots"><span></span></a>Configuring running Rust unit tests on bots</h2><p>To manually configure running Rust unit tests on bots, please follow the pattern from <a href="https://crrev.com/c/3322199">https://crrev.com/c/3322199</a>:</p><ul><li>Define a new isolate in <code>//testing/buildbot/gn_isolate_map.pyl</code>:<ul><li>Set <code>label</code> to the fully qualified name of either the implicit bonus target (e.g. <code>..._rs_unittests</code>) or the explicit <code>rust_unit_tests_group</code> target.</li><li>Set <code>type</code> to <code>generated_script</code></li><li>There are no requirements on the name of the new isolate, but typically it will have the same name as the target mentioned in the <code>label</code>.</li></ul></li><li>Define a new test step, or extend an existing test step in <code>//testing/buildbot/test_suites.pyl</code> (adding an entry referring to the new isolate above).  Note that the tests grouped under the test step need to have uniform kind (e.g. cannot mix GTest and Rust tests).</li><li>Ensure that <code>//testing/buildbot/waterfalls.pyl</code> asks to run the test step on specific bots.  The test step needs to be listed under the <code>isolated_scripts</code> key (rather than under <code>gtest_tests</code> key).</li><li>Run <code>//testing/buildbot/generate_buildbot_json.py</code>.</li></ul><p>Future work:</p><ul><li>At present, there is no automatic integration of such unit tests into our existing test infrastructure, but this is something we&#39;re working on.</li><li>At present, the bot integration only supports reporting whether the tests passed or failed, and doesn&#39;t capture results or output of individual tests.</li><li>At present, there is no support for running native Rust unit tests on Android.</li></ul><p>Adding Rust third party dependencies follows the same protocols <a href="https://thewitchofendor.com/chromium/src/+/refs/heads/main/docs/adding_to_third_party.md">as for C++ or other languages</a>. But practically, Rust libraries are almost always distributed as cargo “crates” which have build scripts and metadata in <code>Cargo.toml</code> files.</p><p>The crate you need may already be listed in <code>//third_party/rust/third_party.toml</code> - if so, just depend upon it like this:</p><pre>deps = [ &#34;//third_party/rust/cxx/v1:lib&#34; ]
</pre><p>(Only those crates explicitly listed in <code>//third_party/rust/third_party.toml</code> are visible to first-party code; other crates in <code>//third_party/rust</code> are transitive dependencies).</p><p>If you need to add new Rust third-party dependencies, there are scripts and gn templates to make it nearly automatic (except of course for review). Please reach out to <code>rust-dev@chromium.org</code> for advice.</p><p>There are multiple different solutions for Rust/C++ interop. In this phase of our experiments, we&#39;re supporting just one: <a href="https://cxx.rs">cxx, described in this excellent online book</a>.</p><p>To use this interop facility in Chromium:</p><ul><li>define your <code>#[cxx::bridge]</code> module in your <code>.rs</code> file</li><li>in your <code>mixed_source_set</code>, add <code>rs_cxx_bindings = [ &#34;src/lib.rs&#34; ]</code></li><li>from your C++,</li></ul><pre>#ifdef RUST_ENABLED
#include &#34;path/to/your/target/src/lib.rs.h`
#endif
</pre><p>You can now simply call functions and use types declared/defined in your CXX bridge. A typical usage might be to pass a <code>const std::string&amp;</code> or <code>rust::Slice&lt;const uint8_t&gt;</code> from C++ into Rust and then return a struct with the parsed results.</p><p>If you need to call back into C++ from Rust, this is also supported - <code>include!</code> directives within an <code>extern &#34;C++&#34;</code> section should work:</p><pre>#[cxx::bridge]
mod ffi {
    unsafe extern &#34;C++&#34; {
        include!(&#34;path/to/my_cpp_header.h&#34;);
        fn some_function_defined_in_cpp();
    }
}

// Rust code calls ffi::some_function_defined_in_cpp()
</pre><p>Future work may expose existing C++ Chromium APIs to Rust with no need to declare the interface in a <code>#[cxx::bridge]</code> module.</p><h2><a name="Dependencies-between-Rust-targets" href="#Dependencies-between-Rust-targets"><span></span></a><a name="dependencies-between-rust-targets" href="#dependencies-between-rust-targets"><span></span></a>Dependencies between Rust targets</h2><p>If your <code>rust_source_set</code> exposes Rust APIs for other Rust targets in Chromium, those targets should be able to depend directly on your <code>rust_source_set</code> target.</p><p>If you have a <code>mixed_source_set</code> or any other component which is intended for both Rust <em>and</em> C++ consumers, please reach out to <code>rust-dev@chromium.org</code> with your use-case. (This <em>should</em> be possible with the current gn rules but layering here is fragile so we&#39;d rather discuss it.)</p><p>To see an example of all this, look at <code>//build/rust/tests/test_variable_source_set</code>.</p><h2><a name="Known-cases-which-don_t-work" href="#Known-cases-which-don_t-work"><span></span></a><a name="known-cases-which-don_t-work" href="#known-cases-which-don_t-work"><span></span></a>Known cases which don&#39;t work</h2><ul><li>At the moment LTO doesn‘t work, so you can’t use <code>is_official_build = true</code>. (<a href="https://crbug.com/1229423">Bug.</a>)</li><li>Windows doesn&#39;t work just yet. (<a href="https://crbug.com/1268157">Bug.</a>)</li></ul><h2><a name="Building-on-non_Linux-platforms" href="#Building-on-non_Linux-platforms"><span></span></a><a name="building-on-non_linux-platforms" href="#building-on-non_linux-platforms"><span></span></a>Building on non-Linux platforms</h2><p>The Rust toolchain is provided only for Linux and Android. To use it on other platforms, you will need to provide your own nightly Rust toolchain. You can then tell <code>gn</code> about it using these <code>gn</code> arguments:</p><pre>enable_rust=true
rust_sysroot_absolute=&#34;/Users/you/.rustup/toolchains/&lt;toolchain name&gt;&#34;
rustc_version=&#34;&lt;your rustc version&gt;&#34; # add output of rustc -V
# added_rust_stdlib_libs=[]
# removed_rust_stdlib_libs=[]
</pre><p>The last two arguments are any Rust standard library .rlibs which have been added or removed between the version that‘s distributed for Linux/Android, and the version you’re using. They should rarely be necessary; if you get errors about missing standard libraries then adjust <code>removed_rust_stdlib_libs</code>; if you get errors about undefined symbols then have a look in your equivalent of the <code>.rustup/toolchains/&lt;toolchain name&gt;/lib/rustlib/&lt;target&gt;/lib</code> directory and add any new libraries which are not listed in <code>//build/rust/std/BUILD.gn</code> to the <code>added_rust_stlib_libs</code> list.</p><h2><a name="Using-VSCode" href="#Using-VSCode"><span></span></a><a name="using-vscode" href="#using-vscode"><span></span></a>Using VSCode</h2><ol><li>Ensure you&#39;re using the <code>rust-analyzer</code> extension for VSCode, rather than earlier forms of Rust support.</li><li>Run <code>gn</code> with this extra flag: <code>gn gen out/Release --export-rust-project</code>.</li><li><code>ln -s out/Release/rust-project.json rust-project.json</code></li><li>When you run VSCode, or any other IDE that uses <a href="https://rust-analyzer.github.io/">rust-analyzer</a> it should detect the <code>rust-project.json</code> and use this to give you rich browsing, autocompletion, type annotations etc. for all the Rust within the Chromium codebase.</li></ol><h2><a name="Source-code-format" href="#Source-code-format"><span></span></a><a name="source-code-format" href="#source-code-format"><span></span></a>Source code format</h2><ul><li><code>git cl format</code> and <code>git cl presubmit</code> have been extended to automatically cover <code>.rs</code> files on Linux. (Currently whole files are re-formatted and/or checked; support for only looking at the modified lines is not yet implemented.)</li><li>Rust defaults to 100-columns-wide formatting (similarly to Java). This may necessitate tweaking settings in various tools - e.g. in Gerrit you might want to increase the default “Diff width” under <a href="https://chromium-review.googlesource.com/settings/">https://chromium-review.googlesource.com/settings/</a></li></ul></div></div></div></div>
  </body>
</html>
