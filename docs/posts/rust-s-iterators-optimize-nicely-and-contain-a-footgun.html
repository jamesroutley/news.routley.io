<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/rusts-iterators-optimize-footgun/?utm_source=atom&amp;utm_medium=feed">Original</a>
    <h1>Rust&#39;s iterators optimize nicelyâ€”and contain a footgun</h1>
    
    <div id="readability-page-1" class="page"><div><p>I saw <a href="https://buttondown.email/hillelwayne/archive/some-notes-on-for-loops/">a claim</a> recently that in functional programming using &#34;map/filter iterates over the list twice, while the foreach loop iterates only once.&#34;
The author continued that &#34;Haskell can fuse maps together as an optimization but I don&#39;t think you safely fuse arbitrary map/filters? I dunno.&#34;</p>
<p>There are really two claims here:</p>
<ul>
<li>in functional programming, map/filter will do two iterations</li>
<li>there is an optimization in Haskell to combine maps, but this may not generalize to arbitrary maps/filters</li>
</ul>
<p>The first claim is generally linked to whether your language has lazy iterators or not.
In Rust (and Python and many others), there are lazy iterators, so we can <em>generally</em> avoid two iterations while doing map/filter.</p>
<p>The second claim gets trickier.
In Rust, it appears that this does generalize to arbitrary maps/filters.
It depends on the compiler, but it certainly seems doable since it looks like there are clear rewriting rules.</p>
<p>The upshot of all of these is that there&#39;s a footgun involved in all of this.
The lazy iterator behavior is unintuitive for many when they encounter it, and there&#39;s a trap here that has bit many Rust users I&#39;ve talked to.</p>

<p>Testing whether or not we have multiple passes is pretty straightforward.
We can write a program that prints where it is as it goes.</p>
<pre data-lang="rust"><code data-lang="rust">let xs: Vec&lt;i32&gt; = (1..5).collect();

let ys: Vec&lt;i32&gt; =
xs.iter()
    .map(|a| {
        println!(&#34;map: {}&#34;, a);
        *a
    })
    .filter(|a| {
        println!(&#34;filter: {}&#34;, a);
        a % 2 == 0
    })
    .collect();

println!(&#34;ys = {:?}&#34;, ys);
</code></pre>
<p>If this takes multiple passes over the list, we would expect to see it print all the maps, then print all the filters.
If it takes <em>one</em> pass over the list, then we would expect to see it print map and filter steps interleaved.</p>
<p>It turns out, it prints the interleaved version:</p>
<pre data-lang="text"><code data-lang="text">map: 1
filter: 1
map: 2
filter: 2
map: 3
filter: 3
map: 4
filter: 4
ys = [2, 4]
</code></pre>
<p>The more interesting question though is <em>why</em> this is the case?
It&#39;s a common thing I run into, the expectation that map will go through the list in full, then again for filter, etc.
The fundamental reason is because <em>iterators are lazy</em>.
We don&#39;t iterate through anything at all until we need it in the end result.
So in this example, if we didn&#39;t call <code>collect</code> and <code>println!</code> to materialize the list, we would have <em>zero</em> iterations through the list.</p>
<p>Because iterators are lazy, we can do some really cool things.
We can iterate over an infinite list, taking only until a condition is met.
We can apply a map and filter and other operations to things like network streams!</p>
<p>These hold true in other languages, too: you can go confirm the same thing is true in Python, and it&#39;s common across languages as far as I can tell.</p>

<p>Now we come to a really fun, meaty question: what can compilers optimize here?
In Haskell, as Hillel points out, GHC has an <a href="https://wiki.haskell.org/GHC_optimisations#Fusion">optimization called fusion</a>.
What this does, essentially, is transform the program at compile time such that intermediate states of iteration are removed.</p>
<p>Imagine, for example, that you have an expression like this in Rust:</p>
<pre data-lang="rust"><code data-lang="rust">(1..10).filter(|x| x%2 == 0).map(|x| x+1)
</code></pre>
<p>The question is: can we take arbitrary compositions of iterators like these and perform an optimization like GHC does with fusion of maps, filters, etc?</p>
<p>Here are three separate programs.
The first uses <code>filter</code> and <code>map</code>.
The second uses <code>filter_map</code>, a concise form of filtering and mapping.
And the third is what we would write by hand with a for loop.</p>
<pre data-lang="rust"><code data-lang="rust">fn main() {
    let xs = [1, 2, 3, 4, 5];
    xs.iter()
        .filter(|x| *x % 2 == 0)
        .map(|x| x + 1)
        .for_each(|x| println!(&#34;{}&#34;, x));
}
</code></pre>
<pre data-lang="rust"><code data-lang="rust">fn main() {
    let xs = [1, 2, 3, 4, 5];
    xs.iter()
        .filter_map(|x| if *x % 2 == 0 { Some(x + 1) } else { None })
        .for_each(|x| println!(&#34;{}&#34;, x));
}
</code></pre>
<pre data-lang="rust"><code data-lang="rust">fn main() {
    let xs = [1, 2, 3, 4, 5];
    for x in xs.iter() {
        if x % 2 == 0 {
            println!(&#34;{}&#34;, x+1);
        }
    }
}
</code></pre>
<p>If Rust is doing optimization similar to GHC&#39;s fusion, then these should output similar code without different performance characteristics.
If it&#39;s not, then we&#39;d expect to see some extra overhead inside each of the iterator-based versions that&#39;s not present in the for loop one.</p>
<p>To test this, I used <a href="https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2021">Rust&#39;s playground</a> and compiled each to assembly using the release target and the stable channel.
Each of them output... the <em>exact</em> same assembly.
The end result of each of these programs is the exact same binary.</p>
<p>So: yes.
Rust will optimize iterator usage in much the same way that Haskell does.
It will combine arbitrary iterator usage and reduce it down to a for loop.
That&#39;s pretty neat!</p>
<p>Now, how does it do it?
That&#39;s beyond my expertise.
It happens <em>somewhere</em> in the compiler.
I&#39;d love to find that out, though!</p>

<p>Just like <a href="https://en.wikipedia.org/wiki/Chekhov%27s_gun">Chekhov&#39;s gun</a>, any mentioned footgun will return at the end.
This one is a footgun I&#39;ve seen quite a few Rust programmers run into when they try to parallelize code.
I&#39;ve written about this one previously after I helped someone debug why <a href="https://ntietz.com/blog/rust-iterators-and-threads/">their code got slower when using iterators</a>.</p>
<p>Basically, they&#39;d changed their code from this for-loop version:</p>
<pre data-lang="rust"><code data-lang="rust">fn main() {
    let mut handles = Vec::new();

    for i in 0..10 {
        let handle = do_work(i);
        handles.push(handle);
    }

    for handle in handles {
        handle.join();
    }
}
</code></pre>
<p>Into this iterator version:</p>
<pre data-lang="rust"><code data-lang="rust">fn main() {
    (0..10)
        .map(do_work)
        .for_each(|handle| {
            handle.join();
        });
}
</code></pre>
<p>The rationale was along the lines of &#34;using iterators is more idiomatic in Rust.&#34;
The footgun here was that since iterators <em>compose</em> together, we changed the semantics of the program:
Where we previously had <em>two</em> iterations through the list, one to populate it with thread handles and one to join those handles, we now have <em>just one</em> iteration to create and immediately join the handles.</p>
<p>The equivalent code instead would be this:</p>
<pre data-lang="rust"><code data-lang="rust">fn main() {
    let handles: Vec&lt;_&gt; = (0..10).map(do_work).collect();
    handles.for_each(|handle| { handle.join() });
}

</code></pre>
<p>Composition of iterators is incredibly powerful, and iterators are a fantastic tool in the Rust programmer&#39;s tool belt.
And you have to remember that they <em>do</em> compose, so if you want multiple passes through a list, you have to ask for that explicitly.</p>
<hr/>
<p>Huge thanks to <a href="https://erikarow.land/">Erika</a> and Hillel Wayne for feedback and encouragement on a draft of this post!</p>
<hr/>



</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts and support my work, subscribe to the <a href="https://ntietz.com/newsletter/">newsletter</a>. There is also an <a href="https://ntietz.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
