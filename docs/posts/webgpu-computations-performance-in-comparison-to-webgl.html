<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pixelscommander.com/javascript/webgpu-computations-performance-in-comparison-to-webgl/">Original</a>
    <h1>WebGPU computations performance in comparison to WebGL</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>WebGPU – the successor of WebGL, a brand new API to utilize GPUs in the browser. It is promised to be available in regular Chrome in Q1 2022. In comparison to WebGL, WebGPU promises better performance and better compatibility with modern hardware, but the most recognizable feature of WebGPU is a special API for performing computations on GPU.</p>
<p><a href="http://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-1.png"><img src="http://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-1.png" alt="Matrices multiplication WebGPU vs WebGL" width="795" height="492" srcset="https://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-1.png 795w, https://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-1-300x186.png 300w, https://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-1-768x475.png 768w" sizes="(max-width: 795px) 100vw, 795px"/></a></p>

<h3>Does not WebGL have the same feature?</h3>
<p>Yes and no. WebGL does not have a special API for computation but still, there is a hack that makes it possible. Data is being converted into an image, image uploaded to GPU as a texture, texture rendered synchronously with a pixel shader that does an actual computation. Then the result of computation we have as a set of pixels on a <code>&lt;canvas&gt;</code> element and we have to read it synchronously with <code>getPixelsData</code> then color codes to be converted back to your data. Looks like an inefficient mess, right?</p>
<p><a href="http://pixelscommander.com/wp-content/uploads/2021/11/computation_schemas-3.png"><img src="http://pixelscommander.com/wp-content/uploads/2021/11/computation_schemas-3.png" alt="WebGL computation pipeline" width="1420" height="148" srcset="https://pixelscommander.com/wp-content/uploads/2021/11/computation_schemas-3.png 1420w, https://pixelscommander.com/wp-content/uploads/2021/11/computation_schemas-3-300x31.png 300w, https://pixelscommander.com/wp-content/uploads/2021/11/computation_schemas-3-768x80.png 768w, https://pixelscommander.com/wp-content/uploads/2021/11/computation_schemas-3-1024x107.png 1024w" sizes="(max-width: 1420px) 100vw, 1420px"/></a></p>

<h3>How WebGPU is different?</h3>
<p>API WebGPU provides for computations (compute shaders) is different in the way it is easy to miss the importance of the improvements, however, it empowers developers with absolutely new features. The way it works is:</p>
<p><a href="http://pixelscommander.com/wp-content/uploads/2021/11/computation_schemas-4.png"><img src="http://pixelscommander.com/wp-content/uploads/2021/11/computation_schemas-4.png" alt="WebGPU computations pipeline" width="1420" height="150" srcset="https://pixelscommander.com/wp-content/uploads/2021/11/computation_schemas-4.png 1420w, https://pixelscommander.com/wp-content/uploads/2021/11/computation_schemas-4-300x32.png 300w, https://pixelscommander.com/wp-content/uploads/2021/11/computation_schemas-4-768x81.png 768w, https://pixelscommander.com/wp-content/uploads/2021/11/computation_schemas-4-1024x108.png 1024w" sizes="(max-width: 1420px) 100vw, 1420px"/></a></p>

<h3>The differences</h3>
<ol>
<li>Data uploaded to GPU as a buffer, you do not convert it to pixels so it is cheaper</li>
<li>Computation is being performed asynchronously and does not block JS main thread (say hi to real-time post-processing and complex physics simulation at 60FPS)</li>
<li>We do not need canvas element and we avoid its limitation on size</li>
<li>We do not do expensive and synchronous getPixelsData</li>
<li>We do not spend time converting pixels values back to data</li>
</ol>
<p>So WebGPU’s promise is that we can compute without blocking the main thread and compute faster, but how much faster?</p>
<h3>How do we benchmark?</h3>
<p>As a benchmark, we use matrix multiplication which lets us scale the complexity and amount of computations easily.</p>
<p>For example, 16×16 matrix multiplication requires 7936 multiplication operations and 60×60 already gets us 428400 operations.</p>
<p>Sure thing we run the test in an appropriate browser which is Chrome Canary with <code>#unsafe-webgpu-enabled</code> flag on.</p>
<h3>Results</h3>
<p>The first results were discouraging and WebGL outperformed WebGPU at the bigger numbers:</p>
<p><a href="http://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-2.png"><img src="http://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-2.png" alt="Matrices multiplication benchmark WebGPU incorrect" width="795" height="492" srcset="https://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-2.png 795w, https://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-2-300x186.png 300w, https://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-2-768x475.png 768w" sizes="(max-width: 795px) 100vw, 795px"/></a></p>
<p>Then I found that the size of a working group (number of operations to calculate in a single batch) is set in code to be as big as the matrix side. It works fine until the matrix side is lower than the number of ALUs on GPU (arithmetic logical unit) which is reflected in WebGPU API as a maximumWorkingGroupSize property. For me, it was 256. Once the working group was set to be less or equal to 256 this is the result we get:</p>
<p><a href="http://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-1.png"><img src="http://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-1.png" alt="Matrices multiplication WebGPU vs WebGL" width="795" height="492" srcset="https://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-1.png 795w, https://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-1-300x186.png 300w, https://pixelscommander.com/wp-content/uploads/2021/10/Matrices-multiplication-benchmark-1-768x475.png 768w" sizes="(max-width: 795px) 100vw, 795px"/></a></p>
<p>This is quite impressive while is expected. WebGPU initialization and data transfer times are remarkably lower because we do not convert data to textures and do not read it from pixels. WebGPU performance is significantly higher and gets to 3.5x faster compared to WebGL while it does not block the main thread.</p>
<p>It is also interesting to see WebGL failing after matrix size gets over 4096×4096 because of canvas and texture size limitations while WebGPU is capable to perform for matrices up to 5000×5000 which sounds not much of a difference but actually is 112552823744 more operations to perform and 817216 more values to hold.</p>
<p>Small but interesting fact – both WebGL / WebGPU require some time to warm up while JS goes full power straight away.</p>
<h3>Conclusion</h3>
<p>The experiment proved that WebGPU compute shaders are in practice 3.5x faster than WebGL computing with pixel shaders while having significantly higher limits regarding the amount of data to process also it does not block the main thread. This allows new kinds of tasks in the browser: video and audio editing, real-time physics simulation, and more realistic visual effects, machine learning. This is the incomplete list of jobs to benefit from WebGPU where we can expect the new generation of apps to appear and the boundaries of what is possible to do on the Web significantly expanded.</p>
<!-- AddThis Advanced Settings above via filter on the_content --><!-- AddThis Advanced Settings below via filter on the_content --><!-- AddThis Advanced Settings generic via filter on the_content --><!-- AddThis Share Buttons above via filter on the_content --><!-- AddThis Share Buttons below via filter on the_content --><!-- AddThis Share Buttons generic via filter on the_content -->                
            </div></div>
  </body>
</html>
