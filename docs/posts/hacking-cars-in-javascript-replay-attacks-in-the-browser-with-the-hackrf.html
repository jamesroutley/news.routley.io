<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://charliegerard.dev/blog/replay-attacks-javascript-hackrf/">Original</a>
    <h1>Hacking cars in JavaScript (Replay attacks in the browser with the HackRF)</h1>
    
    <div id="readability-page-1" class="page"><div><p>A couple of years ago, I built a project using the <a href="https://www.rtl-sdr.com/buy-rtl-sdr-dvb-t-dongles/">RTL-SDR</a> to get <a href="https://liquidbrain.net/project/rtl-sdr-airplane-tracking">live raw data from passing airplanes</a>, in the browser.
As I wanted to explore more using Software-Defined Radios, I bought a <a href="https://greatscottgadgets.com/hackrf/one/">HackRF One</a> device that can both receive and transmit data, and I downloaded <a href="https://github.com/jopohl/urh">Universal Radio Hacker</a> to start playing around with it.
After tinkering a little bit, I had a hunch that it would probably be possible to recreate a similar tool in the browser, all in JavaScript, so I spent time doing just that!</p>
<p>My ultimate goal was to answer the question... <strong>is it possible to hack a car using JavaScript?</strong> I didn&#39;t know at all if I was going to get there because my knowledge of all things SDR related is still minimal, but I&#39;m very excited to share that <strong>it works</strong>!! üòÉ This blog post explains the process I went through to figure things out.</p>
<div><p>
‚ö†Ô∏è <b>Important notes</b> ‚ö†Ô∏è
</p><ul>
<li>I am writing this blog post for <strong>educational purposes only</strong>. Even though using SDRs to listen and transmit data is not illegal in itself, please check with your local laws regarding the need to have a radio license to transmit on specific frequencies. Additionally, recreating some of the experiments explained in this blog post without explicit consent is illegal.</li>
<li>I take no responsibility for how you decide to use the information shared in this post.
</li></ul></div>


<h2>Demo</h2>
<p>Before diving into the technical details, you can check out <a href="https://car-hacking-hackrf.netlify.app/">the website</a> that you can use to receive, record and transmit data, so you can use it to hack doorbells, garage doors, and more.
Below is a quick demo video using it to run a rolljam/replay attack to hack my friend&#39;s car (with consent).</p>
<p>
<iframe width="70%" height="100%" src="https://www.youtube.com/embed/vmjD2x0Tgac?si=vX67H5q8dC6tzFIu" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
</p>
<h2>Receiving data</h2>
<p>To receive data from the HackRF, I first wrote the code needed to connect the device to the browser using <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebUSB_API">the WebUSB API</a>.</p>
<p>On the web, when connecting to a USB device, the user first needs to select it from a pop-up.</p>
<p><img src="https://liquidbrain.net/popup.png"/></p><p>The code below handles displaying the list of available devices in that pop-up window. The value of the <code>filters</code> parameter is optional. If no value is specified, the pop-up will list all devices currently connected to the computer via USB, but if you pass an object with a product and vendor ID, it will only display the device you&#39;re looking to connect to.</p>
<div data-language="js"><pre><code><span>const</span> device <span>=</span> <span>await</span> <span>connect</span><span>(</span><span>)</span><span>;</span>

<span>const</span> <span>connect</span> <span>=</span> <span>async</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> dev <span>=</span> <span>await</span> navigator<span>.</span>usb
    <span>.</span><span>requestDevice</span><span>(</span><span>{</span>
      <span>filters</span><span>:</span> <span>[</span>
        
        <span>{</span> <span>vendorId</span><span>:</span> <span>0x1d50</span><span>,</span> <span>productId</span><span>:</span> <span>0x6089</span> <span>}</span><span>,</span>
      <span>]</span><span>,</span>
    <span>}</span><span>)</span>
    <span>.</span><span>catch</span><span>(</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>null</span><span>)</span><span>;</span>
  <span>return</span> dev<span>;</span>
<span>}</span><span>;</span></code></pre></div>
<p>There are a few different ways to find the vendor and product ID for a device but in the context of the WebUSB API, the easiest one is to visit <code>chrome://usb-internals</code> in Chrome while having the HackRF device plugged into your computer and select the <code>Devices</code> tab. You should see a table with a <code>vendor ID</code> and <code>product ID</code> column like the one below:</p>
<p><img src="https://liquidbrain.net/usb-internals.png"/></p><p>Then you can copy these values in your code.</p>
<p>Once that device is selected in the UI, the following code handles the connection:</p>
<div data-language="js"><pre><code><span>await</span> device<span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>
<span>await</span> device<span>.</span><span>selectConfiguration</span><span>(</span><span>1</span><span>)</span><span>;</span>
<span>await</span> device<span>.</span><span>claimInterface</span><span>(</span><span>0</span><span>)</span><span>;</span></code></pre></div>
<p>The value passed as configuration and interface can be found in two ways, either by reading the code in <a href="https://github.com/greatscottgadgets/hackrf/blob/master/host/libhackrf/src/hackrf.c">the official HackRF SDK</a> or by inspecting the device in the browser.</p>
<p>For, the first option, you can read through the source code of the SDK and find <a href="https://github.com/greatscottgadgets/hackrf/blob/master/host/libhackrf/src/hackrf.c#L710-L716">where the configuration and interface is set</a> and look at the values passed.</p>
<p>Otherwise, the second option is a bit faster and relies on the <code>chrome://usb-internals</code> page mentioned just before.
If you click on the <code>Inspect</code> button in the table, you get additional details about the device, including the configuration (that should be <code>1</code>), and the interface (that should be <code>0</code>).</p>
<p>At this point, the browser should be connected to the device but nothing is really happening. Settings still need to be set such as the gain, sample rate and frequency.</p>
<h3>Setting the gain</h3>
<p>To set the LNA (Low-Noise Amplifier) gain, I used the <code>controlTransferIn</code> method of the WebUSB API.
To figure out exactly the values to pass to this method, I referred to <a href="https://github.com/greatscottgadgets/hackrf/blob/master/host/libhackrf/src/hackrf.c#L1659-L1684">the official HackRF SDK</a>. In the SDK, the function that sets the LNA gain calls another function <code>libusb_control_transfer</code> which led me to the official <a href="https://libusb.sourceforge.io/api-1.0/group__libusb__syncio.html">libusb documentation</a> that describes the arguments that need to be passed in.</p>
<p>The <code>libsub_control_transfer</code> function takes 8 parameters. Looking at the official HackRF SDK, the function is used the following way:</p>
<div data-language="c"><pre><code>result <span>=</span> <span>libusb_control_transfer</span><span>(</span>
  device<span>-&gt;</span>usb_device<span>,</span>
  LIBUSB_ENDPOINT_IN <span>|</span> LIBUSB_REQUEST_TYPE_VENDOR <span>|</span> LIBUSB_RECIPIENT_DEVICE<span>,</span>
  HACKRF_VENDOR_REQUEST_SET_LNA_GAIN<span>,</span>
  <span>0</span><span>,</span>
  value<span>,</span>
  <span>&amp;</span>retval<span>,</span>
  <span>1</span><span>,</span>
  <span>0</span><span>)</span></code></pre></div>
<p>I&#39;m not going to explain in depth the different arguments here as they are explained in the documentation but the ones that are particularly important for this project are the 2nd, 3rd, 4th and 5th.</p>
<p>The 2nd argument will help understand if we need to use <code>controlTransferIn</code> or <code>controlTransferOut</code> from the WebUSB API. <code>LIBUSB_ENDPOINT_IN</code> indicates we need to use <code>controlTransferIn</code>.</p>
<p>The 3rd argument <code>HACKRF_VENDOR_REQUEST_SET_LNA_GAIN</code> will be the one to use as the <code>request</code> parameter in the WebUSB API.</p>
<p>The 4th one (<code>0</code>) will be used as the <code>value</code> parameter and the 5th one (<code>value</code>, which is the gain value used) will be the <code>index</code> parameter.</p>
<div data-language="js"><pre><code><span>const</span> result <span>=</span> <span>await</span> device<span>.</span><span>controlTransferIn</span><span>(</span>
  <span>{</span>
    <span>requestType</span><span>:</span> <span>&#34;vendor&#34;</span><span>,</span>
    <span>recipient</span><span>:</span> <span>&#34;device&#34;</span><span>,</span>
    <span>request</span><span>:</span> HackRF<span>.</span><span>HACKRF_VENDOR_REQUEST_SET_LNA_GAIN</span><span>,</span>
    <span>value</span><span>:</span> <span>0</span><span>,</span>
    <span>index</span><span>:</span> <span>40</span><span>,</span> 
  <span>}</span><span>,</span>
  <span>1</span>
<span>)</span><span>;</span></code></pre></div>
<p>You can also refer to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/USBDevice/controlTransferIn">MDN web docs</a> to understand more about this function.</p>
<p>At this point, the LNA gain should be set but more settings are needed.</p>
<h3>Setting the sample rate</h3>
<p>Following the same logic as the previous section, the sample rate can also be set, with a slight difference that you might notice if you look at the code sample below:</p>
<div data-language="js"><pre><code><span>const</span> params <span>=</span> <span>new</span> <span>DataView</span><span>(</span><span>new</span> <span>ArrayBuffer</span><span>(</span><span>8</span><span>)</span><span>)</span><span>;</span>
params<span>.</span><span>setUint32</span><span>(</span><span>0</span><span>,</span> freqHz<span>,</span> <span>true</span><span>)</span><span>;</span>
params<span>.</span><span>setUint32</span><span>(</span><span>4</span><span>,</span> divider<span>,</span> <span>true</span><span>)</span><span>;</span>

<span>const</span> result <span>=</span> <span>await</span> device<span>.</span><span>controlTransferOut</span><span>(</span>
  <span>{</span>
    <span>requestType</span><span>:</span> <span>&#34;vendor&#34;</span><span>,</span>
    <span>recipient</span><span>:</span> <span>&#34;device&#34;</span><span>,</span>
    <span>request</span><span>:</span> HackRF<span>.</span><span>HACKRF_VENDOR_REQUEST_SAMPLE_RATE_SET</span><span>,</span>
    <span>value</span><span>:</span> <span>0</span><span>,</span>
    <span>index</span><span>:</span> <span>0</span><span>,</span>
  <span>}</span><span>,</span>
  params<span>.</span>buffer
<span>)</span><span>;</span></code></pre></div>
<p>First, the sample rate is set using <code>controlTransferOut</code>. I referred to <a href="https://github.com/greatscottgadgets/hackrf/blob/master/host/libhackrf/src/hackrf.c#L1529-L1538">this section of the HackRF SDK</a> to figure that out, notice it is using <code>LIBUSB_ENDPOINT_OUT</code>.</p>
<p>Then, you&#39;ll notice the index is set to <code>0</code> and the data representing the sample rate is actually used as second parameter in <code>controlTransferOut</code>, which is described in the <a href="https://developer.mozilla.org/en-US/docs/Web/API/USBDevice/controlTransferOut">MDN docs</a>.</p>
<h3>Setting the frequency</h3>
<p>Now that I&#39;ve explained how to set the LNA gain and the sample rate, setting the frequency follows the same logic and is done with the following code:</p>
<div data-language="js"><pre><code><span>const</span> data <span>=</span> <span>new</span> <span>DataView</span><span>(</span><span>new</span> <span>ArrayBuffer</span><span>(</span><span>8</span><span>)</span><span>)</span><span>;</span>
<span>const</span> freqMhz <span>=</span> Math<span>.</span><span>floor</span><span>(</span>freqHz <span>/</span> <span>1e6</span><span>)</span><span>;</span>
<span>const</span> freqHz0 <span>=</span> freqHz <span>-</span> freqMhz <span>*</span> <span>1e6</span><span>;</span>
data<span>.</span><span>setUint32</span><span>(</span><span>0</span><span>,</span> freqMhz<span>,</span> <span>true</span><span>)</span><span>;</span>
data<span>.</span><span>setUint32</span><span>(</span><span>4</span><span>,</span> freqHz0<span>,</span> <span>true</span><span>)</span><span>;</span>

<span>const</span> result <span>=</span> <span>await</span> device<span>.</span><span>controlTransferOut</span><span>(</span>
  <span>{</span>
    <span>requestType</span><span>:</span> <span>&#34;vendor&#34;</span><span>,</span>
    <span>recipient</span><span>:</span> <span>&#34;device&#34;</span><span>,</span>
    <span>request</span><span>:</span> HackRF<span>.</span><span>HACKRF_VENDOR_REQUEST_SET_FREQ</span><span>,</span>
    <span>value</span><span>:</span> <span>0</span><span>,</span>
    <span>index</span><span>:</span> <span>0</span><span>,</span>
  <span>}</span><span>,</span>
  data<span>.</span>buffer
<span>)</span><span>;</span></code></pre></div>
<p>At this point, the necessary settings are set but the device is not yet listening.</p>
<h3>Start receiving data</h3>
<p>The last two steps to start receiving data are to set the device to receiving mode and use the <code>transferIn</code> method from the WebUSB API to indicate to the device to start transferring the data to the UI.</p>
<div data-language="js"><pre><code><span>const</span> <span>setDeviceReceivingMode</span> <span>=</span> <span>async</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>await</span> device<span>.</span><span>controlTransferOut</span><span>(</span><span>{</span>
    <span>requestType</span><span>:</span> <span>&#34;vendor&#34;</span><span>,</span>
    <span>recipient</span><span>:</span> <span>&#34;device&#34;</span><span>,</span>
    <span>request</span><span>:</span> HackRF<span>.</span><span>HACKRF_VENDOR_REQUEST_SET_TRANSCEIVER_MODE</span><span>,</span>
    <span>value</span><span>:</span> HackRF<span>.</span><span>HACKRF_TRANSCEIVER_MODE_RECEIVE</span><span>,</span>
    <span>index</span><span>:</span> <span>0</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></div>
<p>Once the device is in receiving mode, the following code triggers the transfer of the data.</p>
<div data-language="js"><pre><code><span>const</span> <span>startRx</span> <span>=</span> <span>async</span> <span>(</span><span>callback</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>await</span> <span>setDeviceReceivingMode</span><span>(</span><span>)</span><span>;</span> 

  <span>const</span> <span>transfer</span> <span>=</span> <span>async</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> result <span>=</span> <span>await</span> device<span>.</span><span>transferIn</span><span>(</span><span>1</span><span>,</span> HackRF<span>.</span><span>TRANSFER_BUFFER_SIZE</span><span>)</span><span>;</span>

    <span>if</span> <span>(</span>result<span>)</span> <span>{</span>
      <span>callback</span><span>(</span><span>new</span> <span>Uint8Array</span><span>(</span>result<span>.</span>data<span>.</span>buffer<span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>await</span> <span>transfer</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>

  <span>await</span> <span>transfer</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>await</span> <span>startRx</span><span>(</span><span>(</span><span>data</span><span>)</span> <span>=&gt;</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>data<span>)</span><span>;</span> 
<span>}</span><span>)</span><span>;</span></code></pre></div>
<p>You use can then use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas API</a> to build a visualization of this data. In my tool, I tuned the antenna to the frequency 433.92MHz, pressed the button on a cheap doorbell I bought and was able to confirm everything worked by seeing the data in the spectrum visualizer.</p>
<p><img src="https://liquidbrain.net/receive-rf.gif"/></p><h2>Recording data</h2>
<p>Once I confirmed that I could receive live data, I used the <a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_API">File System Web API</a> to implement the recording functionality.</p>
<p>First, the user needs to select a file that the data will be recorded to:</p>
<div data-language="js"><pre><code><span>let</span> fH<span>;</span>

<span>const</span> <span>selectFile</span> <span>=</span> <span>async</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>[</span>fH<span>]</span> <span>=</span> <span>await</span> window<span>.</span><span>showOpenFilePicker</span><span>(</span><span>)</span><span>;</span>
  <span>let</span> writableFile <span>=</span> <span>await</span> fH<span>.</span><span>createWritable</span><span>(</span><span>)</span><span>;</span>
  <span>return</span> writableFile<span>;</span>
<span>}</span><span>;</span></code></pre></div>
<p>Then, when receiving data, we can write it to the file:</p>
<div data-language="js"><pre><code><span>await</span> <span>startRx</span><span>(</span><span>(</span><span>data</span><span>)</span> <span>=&gt;</span> <span>{</span> 
  <span>if</span><span>(</span>recording<span>)</span><span>{</span> 
    <span>await</span> writableFile<span>.</span><span>write</span><span>(</span>data<span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>await</span> writableFile<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span><span>)</span></code></pre></div>
<p>And that&#39;s it! The live data will be saved to the selected file.</p>
<h2>Transmitting data</h2>
<p>Once receiving and recording data works, the next step is to transfer it back. To do this, I am using the File System Web API again to load the data recorded in the local file and transmitting it using <code>transferOut</code> from the Web USB API.</p>
<div data-language="js"><pre><code><span>let</span> file<span>,</span> fH<span>;</span>

<span>const</span> <span>selectFile</span> <span>=</span> <span>async</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>[</span>fH<span>]</span> <span>=</span> <span>await</span> window<span>.</span><span>showOpenFilePicker</span><span>(</span><span>)</span><span>;</span>
  file <span>=</span> <span>await</span> fH<span>.</span><span>getFile</span><span>(</span><span>)</span><span>;</span>
  <span>return</span> file<span>;</span>
<span>}</span><span>;</span></code></pre></div>
<p>After the file is selected, the device needs to be set to <code>transmit</code> mode.</p>
<div data-language="js"><pre><code><span>await</span> device<span>.</span><span>controlTransferOut</span><span>(</span><span>{</span>
  <span>requestType</span><span>:</span> <span>&#34;vendor&#34;</span><span>,</span>
  <span>recipient</span><span>:</span> <span>&#34;device&#34;</span><span>,</span>
  <span>request</span><span>:</span> HackRF<span>.</span><span>HACKRF_VENDOR_REQUEST_SET_TRANSCEIVER_MODE</span><span>,</span>
  <span>value</span><span>:</span> HackRF<span>.</span><span>HACKRF_TRANSCEIVER_MODE_TRANSMIT</span><span>,</span>
  <span>index</span><span>:</span> <span>0</span><span>,</span>
<span>}</span><span>)</span><span>;</span></code></pre></div>
<p>Then, a transmitting gain needs to be set, the same way as the other settings defined earlier in this post.</p>
<div data-language="js"><pre><code><span>await</span> device<span>.</span><span>controlTransferIn</span><span>(</span>
  <span>{</span>
    <span>requestType</span><span>:</span> <span>&#34;vendor&#34;</span><span>,</span>
    <span>recipient</span><span>:</span> <span>&#34;device&#34;</span><span>,</span>
    <span>request</span><span>:</span> HackRF<span>.</span><span>HACKRF_VENDOR_REQUEST_SET_TXVGA_GAIN</span><span>,</span>
    <span>value</span><span>:</span> <span>0</span><span>,</span>
    <span>index</span><span>:</span> <span>40</span><span>,</span> 
  <span>}</span><span>,</span>
  <span>1</span>
<span>)</span><span>;</span></code></pre></div>
<p>Finally, we can get the data from the file, store it into a variable and pass it as the second argument to the <code>transferOut</code> method.</p>
<div data-language="js"><pre><code><span>const</span> data <span>=</span> <span>await</span> file<span>.</span><span>arrayBuffer</span><span>(</span><span>)</span><span>;</span>

<span>await</span> device<span>.</span><span>transferOut</span><span>(</span><span>2</span><span>,</span> data<span>)</span><span>;</span></code></pre></div>
<p>To check that it works properly, I also decided to use the Canvas API to visualize the imported data so I could have an idea of what the signal recorded looks like.</p>
<p><img src="https://liquidbrain.net/transmit-data.png"/></p><p>At this point, you can receive, record and transmit data back from the HackRF device, all in the browser, only using vanilla JavaScript and browser APIs!</p>
<h2>Rolljam &amp; replay attack</h2>
<p>I&#39;m not actually interested in hacking cars in a malicious way but one of the things I wanted to experiment with is running a rolljam/replay attack from the browser and this can be done with the three functionalities I explained in the rest of this post.</p>
<p>So how does a rolljam attack work?</p>
<p>First let&#39;s briefly talk about how a car usually opens and closes. To keep it very simple, to lock/unlock a car, in general, pressing the button on your fob sends a code to your car&#39;s receiver. If the car recognises the code, it locks or unlocks the car.</p>
<p>Before 1995, it worked with the same code sent to the car everytime, one to lock and one to unlock. However, this system poses a security risk because if the code is intercepted, the car can be locked and unlocked by anyone who recorded the signal. You can see how easy it would be to use the code explained above to hack a car that way.</p>
<p>To mitigate this, most cars manufactured after 1995 implement what is called <strong>&#34;rolling codes&#34;</strong>. Instead of a unique code for locking and unlocking, a list of codes rotates so when one of them is used, it becomes temporarily obsolete until the list rotates and gets back to that code.</p>
<p>So a rolljam attack consists in jamming the car&#39;s receiver so it cannot receive the code sent by the fob, while simultaneously recording that code so the attacker can replay it.</p>
<p>In the context of the code shown in this post, the only piece missing is the one to jam. However, jamming is basically transmitting a bunch of random data so the code sample to transmit a recorded file can be updated to transmit random values instead, for example:</p>
<div data-language="js"><pre><code><span>const</span> randomData <span>=</span> Array<span>.</span><span>from</span><span>(</span><span>{</span> <span>length</span><span>:</span> <span>3670000</span> <span>}</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span>
  Math<span>.</span><span>floor</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>100</span><span>)</span>
<span>)</span><span>;</span>

<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>20</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>await</span> <span>startTx</span><span>(</span><span>new</span> <span>Uint8Array</span><span>(</span>randomData<span>)</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p>Also, as this attack needs the setup to both transmit and record at the same time, it requires two HackRF devices to work. One will be used to listen to the frequency used by the fob and record the signal to a file, while the other one will be jamming the receiver.
Once the signal is recorded successfully, it can be replayed by one of the devices.</p>
<h2>Conclusion</h2>
<p>Overall, it was a super fun project to work on and it was really exciting to be able to validate that hacking a car in JavaScript is possible! üéâ</p>
<p>Even though this post is about cars specifically, this can be used to hack garage doors, remote lights, doorbells, some drones, theoretically anything that is remotely controlled by an RF receiver/transmitter.</p>
<p>Parts of this project are still a work in progress, I really wanted to implement a functionality to analyze the binary data recorded to be able to do some reverse engineering but I haven&#39;t gottent to it yet.</p>
<p>If you end up getting a HackRF or other device and build something with it, let me know!</p></div></div>
  </body>
</html>
