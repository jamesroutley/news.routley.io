<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/5%29-Binary-Tree-Inversion">Original</a>
    <h1>5) Binary Tree Inversion</h1>
    
    <div id="readability-page-1" class="page"><article>
<pre><code>
// Pseudocode
// let tree = []
// if (!tree[0]) tree[0] = []
// tree[0].push(2)
// console.log(tree)
// -&gt; OUtput of 2, 3, 1
// So the identification of parts of the list is like,
// i=0 is the root.
// i[1, 2] is layer one
// i[3, 4, 5, 6] is layer two
// i[7, 8, 9, 10, 11, 12, 13, 14] is layer three
//             0
//           1, 2
//        3, 4, 5, 6
// 7, 8, 9, 10, 11, 12, 13, 14

// So the pattern of layer lengths is 1, 2, 4, 8, 16, 32, etc.
// The max layers we can have, by the way, is 7, where the 7th layer isn&#39;t totally full

// I feel like all I need to do is create a tree where we have each layer organized
// as an array in an array of layers
// And then for each one after the 1st one, we flip it
// Yeah?
// Okay, at 7:33 I&#39;m gonna go for it

// So my challenge is, at each index, I need to figure out which layer it is a part of.
// I COULD do this by just generating a list of layer lengths,
// which sure, let&#39;s do that, and just cap it out
</code></pre>

<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>/**</span></span>
<span data-line=""><span> * Definition for a binary tree node.</span></span>
<span data-line=""><span> * function TreeNode(val, left, right) {</span></span>
<span data-line=""><span> *     this.val = (val===undefined ? 0 : val)</span></span>
<span data-line=""><span> *     this.left = (left===undefined ? null : left)</span></span>
<span data-line=""><span> *     this.right = (right===undefined ? null : right)</span></span>
<span data-line=""><span> * }</span></span>
<span data-line=""><span> */</span></span>
<span data-line=""><span>/**</span></span>
<span data-line=""><span> * </span><span>@param</span><span> {TreeNode}</span><span> root</span></span>
<span data-line=""><span> * </span><span>@return</span><span> {TreeNode}</span></span>
<span data-line=""><span> */</span></span>
<span data-line=""><span>var</span><span> invertTree</span><span> =</span><span> function</span><span>(</span><span>root</span><span>) {</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>  let</span><span> tree </span><span>=</span><span> []</span></span>
<span data-line=""><span>  let</span><span> layerLengths </span><span>=</span><span> [</span><span>1</span><span>, </span><span>2</span><span>, </span><span>4</span><span>, </span><span>8</span><span>, </span><span>16</span><span>, </span><span>32</span><span>, </span><span>64</span><span>, </span><span>128</span><span>]</span></span>
<span data-line=""><span>  layer </span><span>=</span><span> 0</span></span>
<span data-line=""> </span>
<span data-line=""><span>  for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> root.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>    if</span><span> (</span><span>!</span><span>tree[layer]) tree[layer] </span><span>=</span><span> []</span></span>
<span data-line=""><span>    tree[layer].</span><span>push</span><span>(root[i])</span></span>
<span data-line=""><span>    // So we push the current layer, and then we check and see...</span></span>
<span data-line=""><span>    // Is the current layer now the max length it should be according to layer lengths?</span></span>
<span data-line=""><span>    // if so, we just add another layer</span></span>
<span data-line=""><span>    // Which we will now push to.</span></span>
<span data-line=""><span>    if</span><span> (tree[layer].</span><span>length</span><span> ===</span><span> layerLengths[layer]){</span></span>
<span data-line=""><span>      layer</span><span>++</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  // Handle case where last layer is not full</span></span>
<span data-line=""><span>  // But only do so if last layer is VALID, since we layer++ to a layer that may not exist</span></span>
<span data-line=""><span>  // in cases where a layer is perfectly full</span></span>
<span data-line=""><span>  if</span><span> (tree[layer]){</span></span>
<span data-line=""><span>    let</span><span> valenceLength </span><span>=</span><span> tree[layer].</span><span>length</span></span>
<span data-line=""><span>    let</span><span> diff </span><span>=</span><span> layerLengths[layer] </span><span>-</span><span> valenceLength</span></span>
<span data-line=""><span>    let</span><span> compensation </span><span>=</span><span> new</span><span> Array</span><span>(diff)</span></span>
<span data-line=""><span>    tree[layer].</span><span>concat</span><span>(compensation)</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  for</span><span> (layer </span><span>of</span><span> tree){</span></span>
<span data-line=""><span>    layer.</span><span>reverse</span><span>()</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  return</span><span> tree</span></span>
<span data-line=""> </span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>};</span></span>
<span data-line=""> </span>
<span data-line=""><span>console.</span><span>log</span><span>(</span><span>invertTree</span><span>([</span><span>4</span><span>,</span><span>2</span><span>,</span><span>7</span><span>,</span><span>1</span><span>,</span><span>3</span><span>,</span><span>6</span><span>,</span><span>9</span><span>]))</span></span>
<span data-line=""> </span></code></pre></figure>
<p>I‚Äôve never worked with binary trees before, and so mistake made involved missing the fundamental domain of the question of itself and no actually working with a binary tree data structure at all. I ended up returning an array instead.</p>
<p>While I am proud that the array I returned is, I believe, in the right order to implement the binary tree this exercise asks for, it‚Äôs not a binary tree. At least not by the definition of the question.</p>
<p>I think that a class could be written that would be able to content with this similarly to how a binary tree would function while still maintaining that single array as the source of truth for the data structure.</p>
<p>What I‚Äôm not sure about is which is more performant - this abstract binary tree I created that refers to indexes in a single list, or true binary tree.</p>
<p>To move forward, I see two paths</p>
<ul>
<li>Stubbornly stick to my weirdly unique idea of what a binary tree is and just construct one out of the reversal I‚Äôve created myself</li>
<li>Create the binary tree from the data, and then just reverse the <code>left</code> and <code>right</code> values</li>
</ul>
<p>These approaches are that different - they mostly just involve learning how to construct a binary tree out of a list using javascript.</p>
<p>What‚Ä¶it would right?</p>
<pre><code>    1
   4, 5
6, 7, 4, 2
</code></pre>
<p>If I swapped right and left values of the above tree, I‚Äôd get:</p>
<pre><code>   1
  5, 4
2, 4, 7, 6
</code></pre>
<p>Yeah that works.</p>
<p>Okay so I tried to create a recursive tree:</p>
<pre><code>let root = [1, 4, 2, 5, 5, 7, 2, 3]

class TreeNode{
  constructor(val, left, right){
    this.val = (val===undefined ? 0 : val)
    this.left = (left===undefined ? null : left)
    this.right = (right===undefined ? null : right)
  }
}

function recursiveTree(source, index){
  if (index &gt;= source.length) return // don&#39;t try to create a leaf if no values left
  let node = new TreeNode(
    source[0 + index],
    index+1 &gt;= source.length ? null : recursiveTree(source, index+1),
    index+2 &gt;= source.length ? null : recursiveTree(source, index+2)
   )
  if (index === 0) return node
}

console.log(recursiveTree(root, 0))
</code></pre>
<p>I made some pretty serious mistakes. Here they are as far as I can tell:</p>
<ol>
<li>Checking against an out of bound index twice (or debatably thrice) - at the beginning of the recurse function AND inside of the new TreeNode. This might even cause an error, since I‚Äôm not even checking if the index is null despite checking it explicitly as null</li>
<li>0 + index is a silly thing to do - not a problem, but there‚Äôs no reason to add anything to 0</li>
<li>Only returning the node when index === 0 was a mis-use of a recursive function - each successive recursion <em>needs to return</em>; that‚Äôs how the tree is built. I‚Äôm not editing a tree in place</li>
<li>Only adding 1 or adding 2 to the index isn‚Äôt enough. It is for the first generation of children, when we add 1 or 2 to 0 to get 1 and 2 as the values for the next generation. But if we add 1 to the first generation value of 1 we get 2, which is <em>also</em> in generation 1. This will lead us trying to create a generation 2 that has 2 of the same indexes as those in generation 1 - not sure if this leads to infinite recursion, but it <em>will</em> create a janky, redundant binary tree. Rather than each element getting its own node, each element will, I think, get two nodes each, which is not what we want.</li>
</ol>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/31429ae34209dc9c3fc48466746f2fa9.png" alt="image"/></p>
<p>If we fix the code it looks like this:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>let</span><span> root </span><span>=</span><span> [</span><span>1</span><span>, </span><span>4</span><span>, </span><span>2</span><span>, </span><span>5</span><span>, </span><span>5</span><span>, </span><span>7</span><span>, </span><span>2</span><span>, </span><span>3</span><span>]</span></span>
<span data-line=""> </span>
<span data-line=""><span>class</span><span> TreeNode</span><span>{</span></span>
<span data-line=""><span>  constructor</span><span>(</span><span>val</span><span>, </span><span>left</span><span>, </span><span>right</span><span>){</span></span>
<span data-line=""><span>    this</span><span>.val </span><span>=</span><span> (val </span><span>===</span><span> undefined</span><span> ?</span><span> 0</span><span> :</span><span> val)</span></span>
<span data-line=""><span>    this</span><span>.left </span><span>=</span><span> (left </span><span>===</span><span> undefined</span><span> ?</span><span> null</span><span> :</span><span> left)</span></span>
<span data-line=""><span>    this</span><span>.right </span><span>=</span><span> (right </span><span>===</span><span> undefined</span><span> ?</span><span> null</span><span> :</span><span> right)</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> recursiveTree</span><span>(</span><span>source</span><span>, </span><span>index</span><span>){</span></span>
<span data-line=""><span>  if</span><span> (index </span><span>&gt;=</span><span> source.</span><span>length</span><span>) </span><span>return</span><span> null</span><span> // Return null if no values left</span></span>
<span data-line=""><span>  </span></span>
<span data-line=""><span>  // Create the node with its left and right children</span></span>
<span data-line=""><span>  let</span><span> node </span><span>=</span><span> new</span><span> TreeNode</span><span>(</span></span>
<span data-line=""><span>    source[index],</span></span>
<span data-line=""><span>    recursiveTree</span><span>(source, </span><span>2</span><span> *</span><span> index </span><span>+</span><span> 1</span><span>),</span></span>
<span data-line=""><span>    recursiveTree</span><span>(source, </span><span>2</span><span> *</span><span> index </span><span>+</span><span> 2</span><span>)</span></span>
<span data-line=""><span>  )</span></span>
<span data-line=""><span>  </span></span>
<span data-line=""><span>  return</span><span> node </span><span>// Always return the node</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>console.</span><span>log</span><span>(</span><span>recursiveTree</span><span>(root, </span><span>0</span><span>))</span></span>
<span data-line=""> </span></code></pre></figure>
<p>And creates this binary tree:</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/e71661367a4b127d8f658c71eb605b98.png" alt="image"/></p>
<p>Except it doesn‚Äôt because I still have a few more mistakes.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>class</span><span> TreeNode</span><span>{</span></span>
<span data-line=""><span>  constructor</span><span>(</span><span>val</span><span>, </span><span>left</span><span>, </span><span>right</span><span>){</span></span>
<span data-line=""><span>    this</span><span>.val </span><span>=</span><span> (val </span><span>===</span><span> undefined</span><span> ?</span><span> 0</span><span> :</span><span> val)</span></span>
<span data-line=""><span>    this</span><span>.left </span><span>=</span><span> (left </span><span>===</span><span> undefined</span><span> ?</span><span> null</span><span> :</span><span> left)</span></span>
<span data-line=""><span>    this</span><span>.right </span><span>=</span><span> (right </span><span>===</span><span> undefined</span><span> ?</span><span> null</span><span> :</span><span> right)</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> invertTree</span><span>(</span><span>source</span><span>, </span><span>index</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>  if</span><span> (index </span><span>&gt;=</span><span> source.</span><span>length</span><span> ||</span><span> source[index] </span><span>===</span><span> null</span><span>) </span><span>return</span><span> null</span></span>
<span data-line=""><span>  </span></span>
<span data-line=""><span>  // Create the node with its left and right children</span></span>
<span data-line=""><span>  return</span><span> new</span><span> TreeNode</span><span>(</span></span>
<span data-line=""><span>    source[index],</span></span>
<span data-line=""><span>    invertTree</span><span>(source, index </span><span>*</span><span> 2</span><span> +</span><span> 2</span><span>),</span></span>
<span data-line=""><span>    invertTree</span><span>(source, index </span><span>*</span><span> 2</span><span> +</span><span> 1</span><span>),</span></span>
<span data-line=""><span>  )</span></span>
<span data-line=""><span>  </span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>console.</span><span>log</span><span>(</span><span>invertTree</span><span>([</span><span>4</span><span>,</span><span>2</span><span>,</span><span>7</span><span>,</span><span>1</span><span>,</span><span>3</span><span>,</span><span>6</span><span>,</span><span>9</span><span>], </span><span>0</span><span>))</span></span></code></pre></figure>
<p>I needed to add the <code>if (...source[index] === null) return null</code> condition. The <code>index &gt;= source.length</code> conditions covers issues where we have run out of values, but it is also very possible to NOT have a fully packed final generation, in which case we are‚Ä¶no that‚Äôs not it. Because this example has no nulls. So this should work.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>var</span><span> invertTree</span><span> =</span><span> function</span><span>(</span><span>root</span><span>) {</span></span>
<span data-line=""><span>  // base case</span></span>
<span data-line=""><span>  if</span><span>(</span><span>!</span><span>root) </span><span>return</span><span> null</span><span>;</span></span>
<span data-line=""><span>  const</span><span> t3</span><span> =</span><span> new</span><span> TreeNode</span><span>();</span></span>
<span data-line=""> </span>
<span data-line=""><span>  //recursive case</span></span>
<span data-line=""><span>  t3.val </span><span>=</span><span> root.val;</span></span>
<span data-line=""><span>  t3.left </span><span>=</span><span> invertTree</span><span>(root.right);</span></span>
<span data-line=""><span>  t3.right </span><span>=</span><span> invertTree</span><span>(root.left);</span></span>
<span data-line=""><span>  return</span><span> t3;</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Turns out I definitely misunderstood a couple things. I am being <em>given a tree to begin with</em>. ü§¶üèª‚Äç‚ôÇÔ∏è</p>

<ul>
<li>I now know how to create a binary tree</li>
<li>I didn‚Äôt need to create a binary tree for this challenge at all, just interact with existing ones</li>
</ul></article></div>
  </body>
</html>
