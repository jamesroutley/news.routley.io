<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.vaxry.net/articles/2024-cursors">Original</a>
    <h1>Improving cursor rendering on Wayland</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>As I&#39;ve recently launched <a href="https://github.com/hyprwm/hyprcursor">hyprcursor</a>, a completely new cursor format
for use in a modern desktop aimed at replacing the old standard of XCursor, I think it&#39;s a good idea
to make a blogpost about how cursors actually work on Linux (and BSD, blah blah) in general to help
people understand what&#39;s going on.</p>
<h2 id="terminology">Terminology</h2>
<p>A quick one on the terms used:</p>
<ul>
<li>A &#34;theme&#34; is a pack of cursor shapes.</li>
<li>A &#34;shape&#34; is, well, a shape. E.g. a pointer, a text indicator, a grabbing hand.</li>
<li>An &#34;image&#34; is a single picture of a shape at a set resolution (or an svg)</li>
</ul>
<h2 id="how-does-a-cursor-work">How does a cursor work?</h2>
<blockquote>
<p><em>&#34;Well lol just draw a png haha&#34;</em></p>
</blockquote>
<p>Well, no, it&#39;s not that simple.</p>
<p>Rasters are annoying. Raster means an image is stored with pixels, for example a png, or an mp4. The problem with rasters
is that when you resize them, the computer has to take a wild guess at what it should look like. 
There are various algorithms that do it, but the most used are bilinear and nearest neighbor.</p>
<p>Nearest neighbor will produce a &#34;pixelated&#34; look, while bilinear will make it more blurry.</p>
<p>Now, if we just encoded our cursor in e.g. 128x128, we could just downscale it to the user-requested size and be done with it,
right?</p>
<p>Well, not exactly. No matter the algorithm, it will almost never produce pixel-perfect results. It will almost always look &#34;odd&#34;.</p>
<p>That&#39;s why, with raster cursors, the best course of action is to just encode a few common sizes and be done with it. That&#39;s what XCursor does.</p>
<p>Every XCursor shape is just a few images at different sizes. 96, 64, 48, 32, 24, 18, etc.</p>
<p>The obvious problem with this is that first, we are storing multiple images per shape, and second, that we can&#39;t get anything in-between.</p>
<p>XCursor does not allow for resizing those images, so either the client has to do it or it&#39;s not happening. In most cases, it&#39;s not happening.</p>
<h3 id="thats-not-too-bad">That&#39;s not too bad</h3>
<p>Oh wait, we got more!</p>
<p>Most cursor sizes have their largest images at 96x96. That&#39;s, on an 8K screen, already considerably smaller than a 32px on a 1080p screen.</p>
<p>You might think that a 1080p PNG is like a megabyte, so why not encode more? like 128px and 256px?</p>
<p>Well, the reason is simple. XCursor predates PNG. GIF too. JPEG as well. That&#39;s why, XCursor images are... uncompressed.</p>
<p>A max 96x96 Bibata cursor, a single cursor, is about 2MB. That&#39;s a lot. The entire theme is 44.1MB. Ouch.</p>
<p><em>Amendment</em>: A single static cursor in Bibata is almost 170kB, and animated ones are about 16MB each, my bad. The 44.1MB figure is correct.</p>
<h2 id="a-modern-format">A modern format</h2>
<p>To stop storing uncompressed pixel data like a caveman, I&#39;ve made hyprcursor.</p>
<p>Hyprcursor has a few key advantages:</p>
<ul>
<li>Cursors can be stored as <em>either</em> PNG or SVG image(s).</li>
<li>Each cursor has metadata describing how it wants to be presented</li>
<li>Simplified and straightforward API</li>
<li><em>Way</em> less space usage.</li>
</ul>
<p>Let&#39;s elaborate on each point a bit:</p>
<h3 id="storage-format">Storage format</h3>
<p>Your cursors can be either PNG, which is an efficient, extremely widely used, lossless raster image format,
or SVG, which is the most adopted standard for vector-based images.</p>
<p>Almost all cursors start out as an SVG, because they are infinitely scalable. An SVG basically describes the &#34;shape&#34; of your cursor
instead of the raw pixels, and is then rendered at different resolutions for packing into a theme.</p>
<p>With hyprcursor, hyprcursor itself can do the rendering, which has two benefits:</p>
<ul>
<li>You can support any and all sizes (For fun I rendered Bibata at 2048px the other day, it looks beautiful)</li>
<li>Way less space usage: SVGs of cursors are usually around 1kB.</li>
</ul>
<h3 id="metadata">Metadata</h3>
<p>Some cursors cannot become SVGs, and that&#39;s fine. Some cursors are used for more than one shape, and that&#39;s fine. Some cursors are animated, and that&#39;s fine!</p>
<p>All of a shape&#39;s properties are described in a small <code>meta.hl</code> file alongside them.</p>
<p>For overrides, instead of being a caveman and making symlinks all over the place, a simple <code>define_override = name</code> in the meta is enough.</p>
<p>For raster shapes, you can define what scaling algorithm to use, if any, so that you can control how your cursors scale to sizes
outside of the ones you&#39;ve made.</p>
<h3 id="api">API</h3>
<p>Rendering a cursor shape with hyprcursor to a png on disk takes about 10 lines of C if we exclude error checking. With it, it&#39;s about 25.</p>
<p>You can also use the C++ API, which does some additional QoL stuff behind the scenes for you :)</p>
<h3 id="space-efficiency">Space efficiency</h3>
<p>PNGs are way more efficient than uncompressed data, bringing down Bibata from 44.1MB to about 6MB. However, with svg, we get down to <strong>171kB</strong>,
which is a 250x reduction.</p>
<h2 id="okay-okay-but-how-is-that-used">Okay okay but how is that used?</h2>
<p>Who draws the cursor? Well, you might assume it&#39;s the, well, display server, the compositor, right?</p>
<p>Well, kind of.</p>
<p>In the beginning, the earth was without form, and void. Wait, a bit too far behind.</p>
<p>In the beginning of wayland, and in the core design spec, it&#39;s the <em>client&#39;s</em> job to draw the cursor.
I mean, it kind of makes sense, as some apps might want to draw a custom cursor (e.g. games)</p>
<p>However, for desktop usage, that kinda sucks. Each app has to support rendering cursors, and 
some apps might render them differently, leading to inconsistencies. You probably have encountered them
especially if using a HiDPI screen.</p>
<p>Recently, we&#39;ve got the wp_cursor_shape protocol, which allows the apps to just say &#34;hey compositor,
render a <del>shape</del>&#34;, which is miles better, as the compositor can now draw the cursor.</p>
<p>There are about 35 defined shapes in the protocol, which is, to be honest, enough.</p>
<p>If your compositor supports hyprcursor (like hyprland), then whenever server-side cursors are being
used, hyprcursor will also be utilized. However, if client-side, the classic style, is used, it&#39;s up
to the app, and most, at the moment, don&#39;t support hyprcursors.</p>
<h3 id="whats-the-support-looking-like">What&#39;s the support looking like?</h3>
<p>Well, right now, not perfect. QT, chromium, electron and hypr* apps support cursor_shape, so in hyprland (or any other
compositor using hyprcursors) you will get your pixel-perfect hyprcursors.</p>
<p>Notably, GTK does not support the protocol, so apps like firefox, or the entire gnome suite will
fall back to the ugly XCursor themes.</p>
<h2 id="will-this-ever-be-adopted">Will this ever be adopted?</h2>
<p>I don&#39;t know! All I know is that it&#39;s a clearly superior system that is easy to implement.</p>
<p>The best path, in my opinion, would be to push for wp_cursor_shape adoption over at gtk. If gtk
finally supports the protocol, almost all desktop apps that people might wanna use on Linux will
be able to utilize hyprcursors via the compositor.</p>
<p>Support from the toolkits themselves for hyprcursor itself is likely not going to happen,
as hyprcursor is not made by a million-dollar non-profit entity via a 10-year-long
bureaucratic process, unless somehow the developers over there decide it&#39;s more beneficial to
use hyprcursors now rather than wait and develop their own, new standard. Who knows? :)</p>
<h2 id="how-do-i-make-a-hyprcursor-theme-can-i-use-my-current-themes">How do I make a hyprcursor theme? Can I use my current themes?</h2>
<p>You can convert an xcursor theme to a hyprcursor theme in 5 minutes using the <code>hyprcursor-util</code> in the hyprcursor repo.</p>
<p>However, you probably would rather go to the original cursor source and replace all the generated <code>.png</code> files with the
source <code>.svg</code> versions to get the benefits of vector images. This process will take a bit longer, but is surely worth it :)
<em>Remember to update the meta.hl with the new images!</em></p>
<p>If you want to share the theme with other people (and it is allowed via its license), feel free to post it in
<code>#hyprcursor-themes</code> on the Hyprland discord server :)</p>
<p>Check out the docs and the util on the <a href="https://github.com/hyprwm/hyprcursor">hyprcursor github page</a> for more. You can also
find instructions there for the end users and developers wishing to adopt this library in the <code>docs/</code> directory.</p>
<h2 id="closing-thoughts">Closing thoughts</h2>
<p>Thanks to everyone for the constant support towards making the Hypr* project better and better!</p>
<p>We&#39;ve got some big plans moving forward so stick around for the journey :)</p>
<p>As a small gift, here&#39;s bibata&#39;s left_ptr, rendered with hyprcursor at 4K, just because I thought it was funny:</p>
<p><a href="https://blog.vaxry.net/resource/articleCursor/arrow.png">click here</a></p>
<p><em>I tried 16K but it almost crashed my computer lol</em></p>

    </div></div>
  </body>
</html>
