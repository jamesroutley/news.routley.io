<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://questdb.io/blog/leveraging-rust-in-our-high-performance-java-database/">Original</a>
    <h1>Leveraging Rust in our Java database</h1>
    
    <div id="readability-page-1" class="page"><div><article><figure><img alt="Rust and QuestDB! Rustaceans are welcome here." src="https://questdb.io/img/blog/2023-08-29/banner.webp" loading="lazy"/></figure><blockquote><p>QuestDB is a high-performance time-series database built in Java and C++, with
no dependencies and zero garbage collection. And increasingly: Rust! Check us
out if you have time series data and are looking for high throughput ingestion
and fast SQL queries.</p></blockquote><p>In this article, I will summarize how and why we&#39;ve started using Rust in our
Java code base. Specifically, I&#39;ll cover:</p><ul><li>Our style of Zero-GC Java.</li><li>Circumstances when we pick Rust over Java.</li><li>Rust build integration with Maven.</li><li>A few JNI basics.</li><li>Integrated logging between Rust and Java.</li><li>Developer Workflow.</li><li>Upcoming QuestDB features in Rust.</li></ul><p>Hopefully, this blog post will act as a starting point and guide for anyone
wishing to embed Rust within their Java code base.</p><p>In this article, I assume both Java and Rust basics.</p><p>Currently, QuestDB&#39;s open-source code base comprises ~90% Java and ~10% C, C++,
or Assembly.</p><p>The code has been written by wrapping system calls and networking primitives for
Windows, Linux, and MacOS into JNI bindings and then writing the database logic
in Java on top of that layer. Similarly, bulk memory allocation (as used by
network buffers and queries) is typically done off the Java heap by calling the
<code>malloc</code> and <code>free</code> functions via JNI.</p><p>Our code aims to avoid garbage collection, as much as possible, and is always
free of garbage collection on any performance-critical paths (such as when
ingesting data).</p><figure><img alt="A do not litter sign in front of some foliage. It is a play on garbage collection in Java." src="https://questdb.io/img/blog/2023-08-29/please_dont_litter_java_garbage_collection_clean.webp" loading="lazy"/><figcaption>Please don&#39;t litter - help keep your Java garbage collection clean</figcaption></figure><p>Our Java code is not idiomatic: We seldom use the <code>new</code> keyword and objects are
designed to be pooled and reused. Many of our types implement the <code>Closable</code>
interface to manage the lifetime of native code resources (memory, network
sockets, etc).</p><p>Over time, we ended up with our internally-developed standard library to handle
things like networking, threading, collections, logging, and even text
encodings.</p><p>When we compile, we bundle everything (Java <code>.class</code> files and native code
artifacts) into a single <code>.jar</code> which relies solely on the JVM as its
dependency.</p><p>These techniques are time-intensive, but the results are clear with a product
that&#39;s easy to compile, deploy and run. The performance is evident from the
first time launching the database, which is ready to serve requests within
seconds.</p><p>However, there is a trade-off. As we evolve our product and integrate it with
third-party technologies we face a challenge: Most Java projects do not design
their code to minimize garbage collection and we can&#39;t use other JAR
dependencies without violating our zero-GC performance standards.</p><p>We&#39;ve considered extending our C++ code base, but this has significant tooling
overhead and introduces problems of its own. Although these are problems that
can be worked around, they are tedious, time-consuming, and full of pitfalls.</p><p>Let&#39;s take the case of using QuestDB as an embedded database. In this scenario,
our compiled symbols share the process space with those of another application.
It&#39;s thus important to mitigate potential symbol clashes. C++ compilers
complicate this issue by dynamically linking to the standard library by default.
More generally, resolving linkage and dependency issues in CMake is no walk in
the park and to avoid these issues we&#39;ve resorted to compiling our C++ code
without exceptions, RTTI, or the standard library.</p><p>We started looking for a more productive alternative.</p><p>Rust appeals to us not as a technology to rewrite our database in, but as a
technology to extend our database&#39;s capabilities. The
<a href="https://crates.io" target="_blank" rel="noopener noreferrer">crates.io</a> repository holds a large collection of
dependencies that, due to the language, are GC-free. Additionally, Rust also
statically links all dependencies, reducing the risk of symbol collisions.</p><p>We started experimenting with Rust and realized that due to the wider surface
area of the APIs we would be dealing with, it would mean breaking away from the
practice of just writing thin JNI wrappers over native code to developing
complete components outside of Java.</p><p>The first thing we&#39;d need is good build tool integration and a streamlined
developer workflow.</p><p>Since we use Maven to build our code, we looked around for plugins that could
help but found none that would make it easy to build Rust and Java code
together. As such, we wrote the
<a href="https://github.com/questdb/rust-maven-plugin" target="_blank" rel="noopener noreferrer">rust-maven-plugin</a> which can
invoke <code>cargo</code> commands. Build integration might have been easier were we using
Gradle, but we were not interested in switching our build system.</p><p>Without rehashing its whole documentation, we can now dedicate a source
directory to a Rust crate, wire up a small amount of config and then let Maven
build both our Java and Rust code with a single:</p><p>This is how our <code>pom.xml</code> setup integrates the build for our Rust JNI crate
called <code>qdb</code>:</p><p>The <code>&lt;profile&gt;</code> section allows building release (as opposed to debug) binaries
when calling <code>mvn</code> with <code>-Pqdb-release</code>.</p><p>Our <code>Cargo.toml</code> configuration adds a dependency to the <code>jni crate</code> and compiles
the crate to a dynamic library.</p><p>The <code>&lt;copyTo&gt;</code> config instructs the <code>rust-maven-plugin</code> to copy the compiled
Rust dynamic library to the <code>target/classes</code> directory. During the <code>mvn package</code>
phase, Maven bundles the contents of this path into the final <code>.jar</code>.</p><p>Then, at start-up, the auxiliary <code>jar-jni</code> Java library (shipped alongside the
<code>rust-maven-plugin</code>) extracts the compiled binary to a temporary location and
loads the Rust code&#39;s dynamic library into memory.</p><p>Multi-platform support is enabled by a common subdirectory naming convention
shared by the <code>rust-maven-plugin</code> and associated loading <code>jar-jni</code> libraries
(this is covered later in the article).</p><p>In the Java code above you might have noticed that we also do some library
initialization.</p><p>In Rust, the <code>libInit</code> function allows us to save the <code>JavaVM</code> JNI object in a
global for later use.</p><p>We will need this to register Rust threads with the Java VM and allow them to
call back into Java code, such as for logging.</p><p>Here <code>unwrap_or_throw</code> is a macro that bubbles up any Rust error as a Java
exception.</p><p>A full explanation of JNI is beyond the scope of this blog post, but I&#39;ll touch
on a few key points to provide context on the code above.</p><p>Earlier, <code>lib.rs</code> registered a <code>JavaVM</code> object as a global. This is the &#34;root&#34;
object that represents the loaded Java runtime and there&#39;s one per process. It
doesn&#39;t allow us to create or introspect objects, however. That job is delegated
to <code>JNIEnv</code> objects that are associated with individual threads.</p><figure><img alt="Shows relationship between JavaVM and JNI" src="https://questdb.io/img/blog/2023-08-29/javavm_and_jnienv.webp" loading="lazy"/><figcaption>JavaVM and JNIEnv</figcaption></figure><p>Each time any code is invoked from Java, JNI provides access to the thread&#39;s
<code>JNIEnv</code> object for our use through the JNI call. With this, we can read and
create Java strings or call other Java methods. If we wish to call into Java
from a thread that wasn&#39;t created from Java, we must first register it via the
<code>JavaVM</code> object. This will give us a handle to a new <code>JNIEnv</code> object for our
non-Java thread.</p><p>Next is understanding Java object references. These are pointers from the native
code back into objects managed by the JVM. They create a new root and prevent
the object from being garbage collected. These come in two kinds: Local
references (<code>jni::objects::JObject</code>) and global references
(<code>jni::objects::GlobalRef</code>).</p><p>When we obtain references, these are - at first - always local ones. If the
native call was initiated from Java, the local references live for the duration
of the native call. When initiated from Rust they last the duration of the
thread unless they are dropped explicitly.</p><p>Local references can be converted to global references. This extends their
lifetime until the global reference is dropped and also allows the Java object
to be passed to other threads.</p><figure><img alt="Indicating the relationship between references" src="https://questdb.io/img/blog/2023-08-29/global_and_local_refs.webp" loading="lazy"/><figcaption>Global and local refs in Java JNI</figcaption></figure><p>In the next section, we&#39;ll see some of these concepts in use, integrating Java
and Rust code.</p><p>The Java logging layer in QuestDB is custom, but we&#39;ve managed to wire it up to
the ubiquitous rust <code>log</code> crate to send all Rust logging to Java.</p><p>Integrating logging is valuable: It not only allows us to sprinkle <code>info!</code> and
<code>error!</code> logs throughout our code, but also gives us an insight into other
dependencies we might be working with. QuestDB, for example, uses Rust to read
and write data to AWS S3. Having our database log messages interspersed with
those of the <code>aws_sdk_s3</code> crate simplifies debugging.</p><p>Showing how we bound our logging layer would be too lengthy. Instead here I&#39;ll
simplify things while still demonstrating the approach. You&#39;ll see examples of
calling Rust from Java, Java from Rust, and how we can sometimes avoid expensive
String copies.</p><p>The starting point for the simplified example has a single <code>Log</code> class:</p><ul><li>The <code>getLog</code> static method creates or obtains a <code>Log</code> object, looked up by a
key (a module name in Rust).</li><li>The <code>info</code> instance method is designed to be efficiently called from Rust: It
logs a message by accepting a <code>msgLen</code> argument holding the number of bytes in
the UTF-8 string passed in through the <code>msgPtr</code> address. We do this because
our destination file is already UTF-8 and we want to avoid text encoding
conversions and the garbage collection involved in using Java Strings. In our
Java code, we then use the <code>sun.misc.Unsafe</code> class to deal with raw buffer.</li><li>The class&#39;s static initialization block invokes <code>Qdb.init()</code> to ensure that
the Rust dynamic library is loaded and then calls the static native method
<code>setup</code>.</li></ul><p>Here is the Rust code called during initialization:</p><p>The call state is what we need to keep the logger working. Along with the method
ID JNI objects, we also initialize an empty concurrent hashmap
(<code>logs: DashMap&lt;..&gt;</code>) which will associate one Java <code>Log</code> object per Rust module
name (as provided by the Rust <code>log</code> crate — more on this later).</p><p>Creating the call state is pretty straightforward and revolves around a few
lookups. These lookups are always best done during start-up where they can fail
early, increasing the likelihood of catching any potential JNI binding bugs
during the development process.</p><p>Next, we need a &#34;trampoline&#34; logger: The Rust <code>log</code> crate funnels all calls to a
single object. One of the arguments we receive for each log line is the
<code>target</code>, a <code>&amp;str</code> holding the name of the module we&#39;re logging for.</p><p>The trampoline logger is an empty <code>struct</code> that implements the <code>log::Log</code> trait.</p><p>In the code above, the <code>format_msg</code> function uses a thread-local and returns a
<code>&amp;str</code>:</p><p>The <code>call_state.with_log</code> method performs a hashmap lookup returning a cached
Java <code>Log</code> object (<code>GlobalRef</code> in Rust) or constructs a new one if needed.</p><p>The concurrent map lookup-or-insert code does some &#34;gymnastics&#34; to allow looking
up by <code>&amp;str</code> and avoids allocating a new <code>Box&lt;str&gt;</code> as would otherwise be
required by the more commonly used <code>DashMap::entry</code> API.</p><p>Finally, all that&#39;s left is to register the trampoline logger in the
<code>setup_logger</code> function:</p><p>With JNI covered, we can proceed to the more mundane — but often overlooked —
aspects of cross-language development: IDE setup and continuous integration.</p><h2><a aria-hidden="true" tabindex="-1" id="intellij"></a>IntelliJ<a href="#intellij" title="Direct link to heading">#</a></h2><p>We use IntelliJ for all of our Java development. The IDE also provides an
excellent Rust plugin allowing us to edit all our code from one single tool.</p><p>When IntelliJ loads up a Maven project it parses it and uses its own Java
compiler instead of invoking <code>mvn</code> commands. This means that by default
rebuilding from the IDE will compile the Java code, but not the Rust code.</p><p>To work around this limitation: While IntelliJ can&#39;t run custom commands before
a build, it can invoke Ant targets.</p><p>As such we wrote a little Ant glue to call Maven. The idea of bringing in Ant
may sound painful at first, but it&#39;s reassuringly simple. The Ant file gets
committed in <code>git</code> and shared with the team.</p><p>With this setup, the development workflow is seamless and allows us to edit some
Rust code and immediately then run one of the Java test cases: The Rust crate is
rebuilt automatically.</p><p>Our <code>intellij-triggers.xml</code> buildfile determines the right Maven executable,
then calls the configured <code>rust-maven-plugin</code> execution by its ID.</p><p>The reason to build the Rust code via the <code>rust-maven-plugin</code> instead of
invoking <code>cargo build</code> directly is that the plugin additionally copies the
generated dynamic lib to its final <code>target/classes</code> destination, ready to be
loaded by the Java code.</p><p>There&#39;s also a config file for IntelliJ that just tells the IDE what to do. Its
location is <code>.idea/ant.xml</code>. This file is also checked into <code>git</code>.</p><p>Once set up, this integration can be seen in the Ant tool window (View → Tool
Windows → Ant) in IntelliJ.</p><figure><img alt="The Ant editor" src="https://questdb.io/img/blog/2023-08-29/ant.webp" loading="lazy"/><figcaption>Meet Ant</figcaption></figure><p>Now each time IntelliJ builds the Java code, it will also build the Rust code.
The Ant tool window also allows switching over to building the release binaries
instead (Right-click → Execute on → Before compilation).</p><h2><a aria-hidden="true" tabindex="-1" id="building-release-for-multiple-platforms"></a>Building release for multiple platforms<a href="#building-release-for-multiple-platforms" title="Direct link to heading">#</a></h2><p>Building for multiple platforms is still quite manual for us, but are in the
process of fully automating it in CI.</p><p>For now, locally on Apple M1 (because we don&#39;t have Apple Silicon cloud compute
yet):</p><p>This step builds both Java class files and Rust binaries.</p><p>Then for each other platform:</p><p>Remotely, this generates binaries in platform-specific directories, so we copy
them back to our Apple Silicon dev machine.</p><p>Back on our local dev box, we end up with the following structure:</p><p>Finally, we package a complete JAR.</p><h2><a aria-hidden="true" tabindex="-1" id="running-rust-tests-from-maven"></a>Running Rust tests from Maven<a href="#running-rust-tests-from-maven" title="Direct link to heading">#</a></h2><p>In our <code>pom.xml</code>, we create a test execution that invokes <code>cargo test</code> via the
<code>rust-maven-plugin</code> when running <code>mvn test</code>.</p><p>Our first use of Rust is in our &#34;enterprise&#34; source code repository. In addition
to our open-source database releases, the QuestDB Enterprise edition offers
enhanced features, catering specifically to enterprise customers. This advanced
version can be accessed either through
<a href="https://questdb.io/blog/getting-started-questdb-cloud/">QuestDB Cloud</a>, our hosted service, or
<a href="https://questdb.io/enterprise/">deployed on-premises</a>.</p><p>Rust, along with some of the features mentioned below, will eventually be
integrated into our
<a href="https://github.com/questdb/questdb" target="_blank" rel="noopener noreferrer">open-source GitHub repository</a>.</p><p>Here is the pipeline of features we&#39;re currently building in Rust:</p><ul><li>Replication</li><li>Cold Storage</li><li>Native SSL/TLS</li><li>Authentication Cryptography</li></ul><h2><a aria-hidden="true" tabindex="-1" id="replication"></a>Replication<a href="#replication" title="Direct link to heading">#</a></h2><p>QuestDB will offer primary-replica replication with eventual consistency by
using an object store (S3, HDFS, etc) as a replication conduit.</p><p>Replication will work by electing a single &#34;primary&#34; database that uploads a
copy of each table&#39;s WAL files onto a remote object store so these can be
downloaded and applied (at a later time or continuously) by zero or more
separate &#34;replica&#34; QuestDB instances.</p><figure><img alt="Explained in text above." src="https://questdb.io/img/blog/2023-08-29/replication.webp" loading="lazy"/><figcaption>Replication Architecture</figcaption></figure><p>We are using Rust to compress, upload, download, and recreate the WAL data. We
are currently using the <code>aws-sdk-s3</code> crate directly, but are in the process of
transitioning over to the <code>opendal</code> crate. We&#39;ve also managed to integrate
<code>tokio</code> into our setup.</p><h2><a aria-hidden="true" tabindex="-1" id="cold-storage-in-parquet"></a>Cold Storage in Parquet<a href="#cold-storage-in-parquet" title="Direct link to heading">#</a></h2><p>Tables in QuestDB are columnar, but written in partitions (usually daily). Our
cold storage feature will transparently relocate partitions over a certain age
threshold onto an object store (S3, HDFS). The data will be stored as Parquet.</p><p>These remotely stored Parquet partitions will not only remain queriable within
QuestDB (which will fetch them just-in-time dynamically) but also be accessible
from big-data tools like Apache Spark, Impala, etc.</p><figure><img alt="Explained in text above." src="https://questdb.io/img/blog/2023-08-29/cold_storage.webp" loading="lazy"/><figcaption>Cold Storage Architecture</figcaption></figure><p>Even discounting the ability to use external tools, cold storage will allow
using cheaper, slower storage for less frequently accessed data.</p><p>Rust is playing a major role here where we&#39;re using the
<a href="https://crates.io/crates/arrow" target="_blank" rel="noopener noreferrer"><code>arrow</code></a> and
<a href="https://crates.io/crates/parquet" target="_blank" rel="noopener noreferrer"><code>parquet</code></a> crates.</p><h2><a aria-hidden="true" tabindex="-1" id="native-ssltls"></a>Native SSL/TLS<a href="#native-ssltls" title="Direct link to heading">#</a></h2><p>At the moment QuestDB relies on an external proxy process to serve secure HTTPS.
The extra network hop complicates deployment and can cause bottlenecks in
certain high-throughput scenarios. Our attempts using the Java libraries for TLS
resulted in poor performance.</p><p>Instead, we&#39;re looking to integrate with the
<a href="https://crates.io/crates/rustls" target="_blank" rel="noopener noreferrer"><code>rustls</code></a> crate. Since all our network
operations are already implemented in JNI we can do this without crossing the
JNI layer any more often than we are already doing.</p><h2><a aria-hidden="true" tabindex="-1" id="authentication-cryptography"></a>Authentication Cryptography<a href="#authentication-cryptography" title="Direct link to heading">#</a></h2><p>Our enterprise product has
<a href="https://questdb.io/blog/navigating-access-control-design-clarity-simplicity/">access</a>
<a href="https://questdb.io/blog/concurrent-lockfree-datastructure-design-walkthrough/">control</a>
<a href="https://questdb.io/blog/enterprise-rbac-access-control-list-tutorial/">lists</a> (ACL) and as part
of that feature, we&#39;re improving authentication across all our network endpoints
(ILP fast streaming data ingestion, PostgreSQL query interface, HTTP Rest query
interface).</p><p>These improvements are being written using the
<a href="https://crates.io/crates/rustls" target="_blank" rel="noopener noreferrer"><code>rustls</code></a> and
<a href="https://crates.io/crates/ring" target="_blank" rel="noopener noreferrer"><code>ring</code></a> Rust crates.</p><p>We&#39;re seeing orders of magnitute performance improvements in hash verification.</p><p>Writing as the person having introduced Rust to QuestDB, it&#39;s been reassuring to
see other developers in the team learning the language enthusiastically. This
enthusiasm is the best confirmation that the language is a good fit for us.</p><p>There are many other exciting challenges that we want to solve with Rust,
especially with open-source features!</p><p>For us, Rust is here to stay.</p><figure><img alt="QuestDB, Java, and Rust -- their logos getting along famously" src="https://questdb.io/img/blog/2023-08-29/banner.webp" loading="lazy"/><figcaption>QuestDB loves Java and Rust</figcaption></figure><div><div><div><p><a href="https://cloud.questdb.com/signup?utm_source=Website&amp;utm_content=Blog&amp;utm_campaign=Signup">Trial QuestDB</a><span> Blasting fast ingest. SQL analytics. $200 in free credit. </span></p></div></div></div></article></div></div>
  </body>
</html>
