<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.linusakesson.net/music/family-bass/index.php">Original</a>
    <h1>The Family Bass - Music with an NES</h1>
    
    <div id="readability-page-1" class="page"><div>


<p><span>I connected a Family BASIC keyboard to an NES via a
bespoke adapter in order to play its unique triangle waveform live.</span></p>

<p>Here&#39;s a short technical presentation:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/j9D4a6ws6TY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>

<p>And here&#39;s a performance of my NES-style tune <a href="https://www.linusakesson.net/music/platform-hopping/index.php">Platform Hopping</a>, originally
composed for the music compo at X 2023:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/Gds1EeQGMaQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>

<h2>Download</h2>

<ul><li><a href="https://hd0.linusakesson.net/files/Linus%20Akesson%20-%20Platform%20Hopping%20%28Family%20Bass%29.mp3">Linus Akesson - Platform Hopping (Family Bass).mp3</a> (MP3, 5.7 MB)</li>
</ul>

<h2>How the adapter works</h2>

<p>As outlined in the presentation video above, the Family BASIC keyboard is
designed to plug into the expansion port of the Famicom, but I wanted to hook
it up to one of the controller ports on my NES. This called for a custom adapter.</p>

<h3>The keyboard</h3>

<p><a href="https://www.linusakesson.net/music/family-bass/bass-large.jpg"><img src="https://www.linusakesson.net/music/family-bass/bass-small.jpg"/></a></p><p>The 72 keys of the Family BASIC keyboard are wired up in a simple
matrix, nine rows by eight columns, and the columns are further subdivided into
half-columns of four bits each. During transmission, there&#39;s also a tenth row
that is left blank. This is because the protocol is designed around a 4017
decade-counter chip inside the keyboard, which is responsible for driving one
row of keys at a time. An input signal to the keyboard selects between the two
half-columns of the current row, and the same input signal also acts as a
positive-edge clock to the decade counter, advancing to the next row. After ten
positive edges, the cycle repeats. There&#39;s also a separate reset input. In
summary:</p>

<table>
<tbody><tr><th>Direction</th><th>Function</th></tr>
<tr><td>To keyboard</td><td>Reset</td></tr>
<tr><td>To keyboard</td><td>Half-row select and Clock</td></tr>
<tr><td>From keyboard</td><td>Data 1</td></tr>
<tr><td>From keyboard</td><td>Data 2</td></tr>
<tr><td>From keyboard</td><td>Data 3</td></tr>
<tr><td>From keyboard</td><td>Data 4</td></tr>
</tbody></table>

<p>(I&#39;m ignoring a few additional signals that control two jacks at the back of
the keyboard, used for storing BASIC programs to tape and loading them
back.)</p>

<h3>The NES controller ports</h3>

<p><a href="https://www.linusakesson.net/music/family-bass/ports-large.jpg"><img src="https://www.linusakesson.net/music/family-bass/ports-small.jpg"/></a></p><p>Now let&#39;s turn to the NES controller ports. Here we find two output signals
called <tt>OUT</tt> and <tt>CLK</tt> and three input signals. <tt>OUT</tt> is
actually a common signal shared by both ports, while <tt>CLK</tt> and the input
pins are available for each port separately.</p>

<p>However, the cable I&#39;m plugging into the oddly-shaped NES port happens to be
a replacement cable for a standard controller, and the standard controllers
only make use of one of the input pins. To save cost and make the cable as
flexible as possible, only the signals that are actually used by the controller
are connected. Thus, the only signals I can use are:</p>

<table>
<tbody><tr><th>Direction</th><th>Function</th></tr>
<tr><td>From NES</td><td><tt>OUT</tt></td></tr>
<tr><td>From NES</td><td><tt>CLK</tt></td></tr>
<tr><td>To NES</td><td>Data</td></tr>
</tbody></table>

<p><tt>OUT</tt> and Data are easy to access from software running on the NES,
by writing and reading a hardware register respectively. But the <tt>CLK</tt>
signal is different: It generates a pulse every time the corresponding Data
register is read.</p>

<p>Inside each hand controller, a parallel-in, serial-out shift register chip
is connected to these three lines, so that the NES can assert <tt>OUT</tt> to
latch the status of all eight buttons into the shift register, and then read
Data eight times to clock it out, one bit at a time. Such automatic
<tt>CLK</tt> generation is handy when interfacing standard controllers, but
it&#39;s a bad fit for the protocol used by the keyboard, so we can&#39;t really make
use of this signal.</p>

<p>That leaves us with a single output line and a single input line.</p>

<h3>The serial protocol</h3>

<p>I wired <tt>OUT</tt> straight to the “Half-row select and Clock” line, which
allows me to cycle through the keyboard matrix one half-row at a time. There
was no room for the Reset signal, but I solved that in the user interface, as
explained in the video.</p>

<p>That still leaves us with four data signals coming from the keyboard, and
only a single input on the NES side. I decided to use an AVR ATtiny85
microcontroller to multiplex the four parallel signals into a UART-like
bitstream. This chip has five GPIO pins, which is exactly what we need.</p>

<p><a href="https://www.linusakesson.net/music/family-bass/adapter-large.jpg"><img src="https://www.linusakesson.net/music/family-bass/adapter-small.jpg"/></a></p><p>Of course, a bigger microcontroller would have allowed a more sophisticated
protocol and state-machine, probably also incorporating the Reset signal to the
keyboard. But I like the compact DIL8 package.</p>

<p>The serial output works like this: First, the signal is idle (high) for a
period of at least five bit-times. This is followed by a start-bit (low) and
four data bits, and then the signal returns to idle. That way, the receiver can
wait for a sufficiently long continuous high level—guaranteed to be the idle
state—and sync up with the next transition to a low level (i.e. the start bit)
to know when the data bits are due.</p>

<p>The ATtiny85 is clocked by its internal calibrated RC oscillator and runs at
about 1 MHz. The code is implemented in assembly language, arranged to
make each data bit exactly six cycles long, which comes out to 6 μs.</p>

<p>Turning now to the receiving end, a PAL NES is running at 1.66 MHz. We
first wait for a sufficiently long stretch of high level (the bit in the
register is inverted):</p>

<div><pre>        lda     #$01

waitforidle
        bit     $4017
        bne     waitforidle

        bit     $4017
        bne     waitforidle

        bit     $4017
        bne     waitforidle

        bit     $4017
        bne     waitforidle

        bit     $4017
        bne     waitforidle

        bit     $4017
        bne     waitforidle

        bit     $4017
        bne     waitforidle
</pre></div>

<p>Then we immediately busy-wait for a low level:</p>

<div><pre>waitforstart
        bit     $4017
        beq     waitforstart
</pre></div>

<p>This loop takes seven cycles per iteration, and the signal could toggle at
any time during the loop, so we now have to a jitter of up to
6 / 1.66 MHz = 3.6 μs. That is well within a
bit-time; the extra margin is good to have because of the imprecise RC
oscillator.</p>

<p>Then we simply read the data bits, exactly ten NES-cycles (6.0 μs)
apart:</p>

<div><pre>        nop		; wait 2 cycles
        bit     0	; wait 3 cycles

        lda     $4017
        nop
        sta     temp1
        lda     $4017
        nop
        sta     temp2
        lda     $4017
        sta     temp3
        lda     #$01
        and     $4017
</pre></div>

<p>...and put the bits together:</p>

<div><pre>	lsr     temp3
        rol
        lsr     temp2
        rol
        lsr     temp1
        rol
</pre></div>

<p>In the above, I&#39;ve left out a bit of protective code to deal with the
situation where an interrupt occurs during our timed code. This is just a
matter of setting a flag at the beginning of the critical section, clearing it
in the interrupt handler, and checking that it&#39;s still set at the end of the
critical section. If any such interference was detected, we have to wait for
the next idle period and try again.</p>

<p><a href="https://www.linusakesson.net/music/family-bass/connected-large.jpg"><img src="https://www.linusakesson.net/music/family-bass/connected-small.jpg"/></a></p><p>Posted Friday 17-Jan-2025 07:59</p>
<div>
<h3>Discuss this page</h3><p>Disclaimer: I am not responsible for what people (other than myself) write in the forums. Please report any abuse, such as insults, slander, spam and illegal material, and I will take appropriate actions. Don&#39;t feed the trolls.</p><p>Jag tar inget ansvar för det som skrivs i forumet, förutom mina egna inlägg. Vänligen rapportera alla inlägg som bryter mot reglerna, så ska jag se vad jag kan göra. Som regelbrott räknas till exempel förolämpningar, förtal, spam och olagligt material. Mata inte trålarna.</p><div><p>This made me incredibly happy!</p></div>
</div>
</div></div>
  </body>
</html>
