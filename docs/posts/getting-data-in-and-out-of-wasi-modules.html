<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://petermalmgren.com/serverside-wasm-data/">Original</a>
    <h1>Getting data in and out of WASI modules</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="the-problem">The problem</h2><p>After learning about WebAssembly, I kept running into a problem: Getting data in and out of WebAssembly, specifically server-side WebAssembly run with wasmtime, can be really hard.</p><p>Even though there are lots of examples of how to do this on the web, most of them focus specifically on JS and browser contexts. Here I’m going to focus on server-side WebAssembly, and in particular WebAssembly modules compiled into WebAssembly System Interface, or WASI.</p><h2 id="the-future-solution">The (future) solution</h2><p>The main limitation with WebAssembly is that it only supports four different types: i32, i64, f32, and f64. Passing around more complex values like strings, arrays, or record types can’t be done without some kind of glue code.</p><p>The WebAssembly interface types proposal looks like the most promising approach.</p><p>Once the interface types proposal is finalized and implemented, I think this will be the best path forward.</p><p>Another approach I’m not going to cover is using a library to produce the bindings and glue code. I recommend doing this unless you’re writing a platform for running compiled WebAssembly, which I am :).</p><p>You can use wasm-bindgen, which also has a way to produce bindings for browser and web APIs. There is also a newer library called <a href="https://github.com/fiberplane/fp-bindgen">fp-bindgen</a> which helps produce bindings for non-web environments, like Rust.</p><h2 id="an-example">An example</h2><p>Let’s say we want to run a compiled WASI module from Rust with this program:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>main</span><span>()</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>engine</span><span> </span><span>=</span><span> </span><span>Engine</span>::<span>default</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>linker</span>: <span>Linker</span><span>&lt;</span><span>WasiCtx</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>Linker</span>::<span>new</span><span>(</span><span>&amp;</span><span>engine</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>wasmtime_wasi</span>::<span>add_to_linker</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>linker</span><span>,</span><span> </span><span>|</span><span>s</span><span>|</span><span> </span><span>s</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>module</span><span> </span><span>=</span><span> </span><span>Module</span>::<span>from_file</span><span>(</span><span>&amp;</span><span>engine</span><span>,</span><span> </span><span>&#34;wasm-demo.wasm&#34;</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>wasi</span><span> </span><span>=</span><span> </span><span>WasiCtxBuilder</span>::<span>new</span><span>()</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>inherit_stdio</span><span>()</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>inherit_args</span><span>()</span><span>?</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>build</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>store</span><span> </span><span>=</span><span> </span><span>Store</span>::<span>new</span><span>(</span><span>&amp;</span><span>engine</span><span>,</span><span> </span><span>wasi</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>linker</span><span>.</span><span>module</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>store</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&amp;</span><span>module</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>linker</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>get_default</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>store</span><span>,</span><span> </span><span>&#34;&#34;</span><span>)</span><span>?</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>typed</span>::<span>&lt;</span><span>(),</span><span> </span><span>(),</span><span> </span><span>_</span><span>&gt;</span><span>(</span><span>&amp;</span><span>store</span><span>)</span><span>?</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>call</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>store</span><span>,</span><span> </span><span>())</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>How do we get data in and out of the WASI module?</p><h2 id="approach-1-treat-wasi-like-a-regular-program">Approach 1: Treat WASI like a regular program</h2><p>WASI was designed to be POSIX-like. This means it has access to resources like files (including standard input and output), command line arguments, environment variables, pipes, and network sockets.</p><p>We can use stdin, stdout, and stderr to pass data in and out of the WASI module, kind of like a UNIX program. We could also use environment variables, or pass the arguments in with command line arguments. Because the environment variable and command line argument approaches are pretty straightforward, I’ll be describing how to share state with stdin and stdout, even if command line arguments are probably the better choice.</p><p>This approach requires coming up with a data format which supports serialization and de-serialization. We’ll also need a runtime which supports overriding stdin and stdout.</p><h3 id="building-a-string-multiplier-with-wasi-stdio">Building a string multiplier with WASI stdio</h3><p>Here is how I used this approach to build a WASI module which takes in a string and a number in a JSON object, then returns a serialized JSON object with the string repeated the specified number of times.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>serde</span>::<span>{</span><span>Serialize</span><span>,</span><span> </span><span>Deserialize</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[derive(Serialize, Deserialize, Debug, Clone)]</span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>Input</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>name</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>num</span>: <span>i32</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[derive(Serialize, Deserialize, Debug, Clone)]</span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>Output</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>pub</span><span> </span><span>names</span>: <span>Vec</span><span>&lt;</span><span>String</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Since we’re using the wasmtime crate, we can use the WasiContextBuilder to specify the stdin and stdout of the WASI module. For convenience I used wasi-common and its WritePipe and ReadPipe structs.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>input</span><span> </span><span>=</span><span> </span><span>Input</span><span> </span><span>{</span><span> </span><span>name</span>: <span>&#34;Rust&#34;</span><span>.</span><span>into</span><span>(),</span><span> </span><span>num</span>: <span>10</span><span> </span><span>};</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>serialized_input</span><span> </span><span>=</span><span> </span><span>serde_json</span>::<span>to_string</span><span>(</span><span>&amp;</span><span>input</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>stdin</span><span> </span><span>=</span><span> </span><span>ReadPipe</span>::<span>from</span><span>(</span><span>serialized_input</span><span>);</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>stdout</span><span> </span><span>=</span><span> </span><span>WritePipe</span>::<span>new_in_memory</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>wasi</span><span> </span><span>=</span><span> </span><span>WasiCtxBuilder</span>::<span>new</span><span>()</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>stdin</span><span>(</span><span>Box</span>::<span>new</span><span>(</span><span>stdin</span><span>.</span><span>clone</span><span>()))</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>stdout</span><span>(</span><span>Box</span>::<span>new</span><span>(</span><span>stdout</span><span>.</span><span>clone</span><span>()))</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>inherit_stderr</span><span>()</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>build</span><span>();</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>store</span><span> </span><span>=</span><span> </span><span>Store</span>::<span>new</span><span>(</span><span>&amp;</span><span>engine</span><span>,</span><span> </span><span>wasi</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>module</span><span> </span><span>=</span><span> </span><span>Module</span>::<span>from_file</span><span>(</span><span>&amp;</span><span>engine</span><span>,</span><span> </span><span>&#34;wasi-demo.wasm&#34;</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span></span><span>linker</span><span>.</span><span>module</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>store</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&amp;</span><span>module</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span></span><span>linker</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>get_default</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>store</span><span>,</span><span> </span><span>&#34;&#34;</span><span>)</span><span>?</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>typed</span>::<span>&lt;</span><span>(),</span><span> </span><span>(),</span><span> </span><span>_</span><span>&gt;</span><span>(</span><span>&amp;</span><span>store</span><span>)</span><span>?</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>call</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>store</span><span>,</span><span> </span><span>())</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>drop</span><span>(</span><span>store</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>contents</span>: <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>stdout</span><span>.</span><span>try_into_inner</span><span>()</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>map_err</span><span>(</span><span>|</span><span>_err</span><span>|</span><span> </span><span>anyhow</span>::<span>Error</span>::<span>msg</span><span>(</span><span>&#34;sole remaining reference&#34;</span><span>))</span><span>?</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>into_inner</span><span>();</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>output</span>: <span>Output</span><span> </span><span>=</span><span> </span><span>serde_json</span>::<span>from_slice</span><span>(</span><span>&amp;</span><span>contents</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span></code></pre></div><p>Calling <code>drop(store)</code> is important, otherwise converting the <code>WritePipe</code> into a <code>Vec&lt;u8&gt;</code> will fail. This is because the <code>WritePipe</code> wraps the data in an <code>Arc</code> and calls <code>try_unwrap</code> on it, which will fail unless there is only 1 strong reference to the data. The store holds a strong reference to the <code>WritePipe</code>.</p><h2 id="approach-1-proscons">Approach 1 pros/cons</h2><p>Coming up with a wire data format and using a serialization library introduces complexity. However, it also decouples things pretty nicely. Other approaches tend to be pretty opinionated about both the host and guest environment. We could use the wasmtime Python runtime, and write a WASI module with AssemblyScript.</p><p>This approach isn’t very flexible. Input is read at the beginning of the program from stdin, and when the program is done it will emit its output to stdout.</p><p>I can also only think of 3-4 languages which target WASI: C/C++, Rust, and AssemblyScript.</p><p>There are probably more pros and cons, but overall this approach works pretty well.</p><h2 id="approach-2-using-exported-functions-and-memory">Approach 2: Using exported functions and memory</h2><p>WebAssembly functions can be exported by both the host and other modules. They are exposed to running WebAssembly code in wasmtime with a Linker object. This allows us to either compile a WebAssembly module and link that against a running WASI module, or to directly expose a host function which we can call from WebAssembly.</p><p>WebAssembly allows data to be shared between a host and a running WebAssembly module with linear memory. wasmtime does this with its Memory struct, which is accessible in the host function defined on the Linker object.</p><h3 id="passing-arguments-through-linear-memory-and-a-host-callback">Passing arguments through linear memory and a host callback</h3><p>Linear memory is configured through the Store struct and is used by the guest when it allocates memory. Linear memory is allocated in pages of 64kb.</p><p>Here’s how we tell the store to allocate a single page of memory for use by a running wasm module:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>mut</span><span> </span><span>store</span><span> </span><span>=</span><span> </span><span>Store</span>::<span>new</span><span>(</span><span>&amp;</span><span>engine</span><span>,</span><span> </span><span>wasi</span><span>);</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>memory_ty</span><span> </span><span>=</span><span> </span><span>MemoryType</span>::<span>new</span><span>(</span><span>1</span><span>,</span><span> </span><span>None</span><span>);</span><span>
</span></span></span><span><span><span></span><span>Memory</span>::<span>new</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>store</span><span>,</span><span> </span><span>memory_ty</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span></code></pre></div><p>And here’s how we’re turning our Input into a serialized JSON object:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>input</span><span> </span><span>=</span><span> </span><span>Input</span><span> </span><span>{</span><span> </span><span>name</span>: <span>&#34;hey&#34;</span><span>.</span><span>into</span><span>(),</span><span> </span><span>num</span>: <span>5</span><span> </span><span>};</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>buf</span><span> </span><span>=</span><span> </span><span>serde_json</span>::<span>to_vec</span><span>(</span><span>&amp;</span><span>input</span><span>).</span><span>expect</span><span>(</span><span>&#34;should serialize&#34;</span><span>);</span><span>
</span></span></span></code></pre></div><p>Once we have store set up, we need to figure out a way to get this serialized buffer into the running WebAssembly module.</p><h4 id="step-1-export-the-host-function">Step 1: Export the host function</h4><p>A host function runs on the guest, but is defined completely on the host. We can use a host function to manipulate memory inside the guest, write our serialized input, and check for errors.</p><p>Here is how we can use the Linker struct’s func_wrap method to define two exported hosts function, one two fetch the put and one to get the input size in bytes:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>input</span><span> </span><span>=</span><span> </span><span>Input</span><span> </span><span>{</span><span> </span><span>name</span>: <span>&#34;hey&#34;</span><span>.</span><span>into</span><span>(),</span><span> </span><span>num</span>: <span>5</span><span> </span><span>};</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>buf</span><span> </span><span>=</span><span> </span><span>serde_json</span>::<span>to_vec</span><span>(</span><span>&amp;</span><span>input</span><span>).</span><span>expect</span><span>(</span><span>&#34;should serialize&#34;</span><span>);</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>input_size</span><span> </span><span>=</span><span> </span><span>buf</span><span>.</span><span>len</span><span>()</span><span> </span><span>as</span><span> </span><span>i32</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>linker</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>func_wrap</span><span>(</span><span>&#34;host&#34;</span><span>,</span><span> </span><span>&#34;get_input&#34;</span><span>,</span><span> </span><span>move</span><span> </span><span>|</span><span>mut</span><span> </span><span>caller</span>: <span>Caller</span><span>&lt;&#39;</span><span>_</span><span>,</span><span> </span><span>WasiCtx</span><span>&gt;</span><span>,</span><span> </span><span>ptr</span>: <span>i32</span><span>|</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// This will be explained in step 3 below
</span></span></span><span><span><span></span><span>        </span><span>println!</span><span>(</span><span>&#34;Hello from the host!&#34;</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>0</span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>})</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>expect</span><span>(</span><span>&#34;should define the function&#34;</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>linker</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>func_wrap</span><span>(</span><span>&#34;host&#34;</span><span>,</span><span> </span><span>&#34;get_input_size&#34;</span><span>,</span><span> </span><span>move</span><span> </span><span>||</span><span> </span>-&gt; <span>i32</span> <span>{</span><span>
</span></span></span><span><span><span>        </span><span>input_size</span><span>   
</span></span></span><span><span><span>    </span><span>})</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>expect</span><span>(</span><span>&#34;should define the function&#34;</span><span>);</span><span>
</span></span></span></code></pre></div><p>The first two arguments define the module and the exported function name, respectively. We’ll need to use these if we want to import the host functionality into our WebAssembly module.</p><p>The caller parameter to the Fn is pretty important. It contains a reference to the store and the memory it contains. The addresses on the host and on the guest are different, so it’s important that we only access memory using the guest provided offsets from within this Fn.</p><h4 id="step-2-link-against-the-function-in-webassembly">Step 2: Link against the function in WebAssembly</h4><p>We can use the extern keyword to let the compiler know that we’re going to be importing a function from the host module called get_input. It takes an argument which is the offset to the memory we allocated in WebAssembly.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[link(wasm_import_module = </span><span>&#34;host&#34;</span><span>)]</span><span>
</span></span></span><span><span><span></span><span>extern</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>get_input</span><span>(</span><span>ptr</span>: <span>i32</span><span>)</span><span> </span>-&gt; <span>();</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>get_input_size</span><span>()</span><span> </span>-&gt; <span>i32</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Here’s how to allocate this from within the WebAssembly module:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mem_size</span><span> </span><span>=</span><span> </span><span>unsafe</span><span> </span><span>{</span><span> </span><span>get_input_size</span><span>()</span><span> </span><span>};</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>buf</span>: <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>Vec</span>::<span>with_capacity</span><span>(</span><span>mem_size</span><span> </span><span>as</span><span> </span><span>usize</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>ptr</span><span> </span><span>=</span><span> </span><span>buf</span><span>.</span><span>as_mut_ptr</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>std</span>::<span>mem</span>::<span>forget</span><span>(</span><span>ptr</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><h4 id="step-3-write-serialized-input-to-linear-memory">Step 3: Write serialized input to linear memory</h4><p>Here’s the function I used to write the serialized input to linear memory. First, we fetch the exported memory from the compiled WebAssembly module, and write our serialized input at the location passed in from the module:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>linker</span><span> </span><span>=</span><span> </span><span>linker</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>func_wrap</span><span>(</span><span>
</span></span></span><span><span><span>        </span><span>&#34;host&#34;</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>&#34;get_input&#34;</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>move</span><span> </span><span>|</span><span>mut</span><span> </span><span>caller</span>: <span>Caller</span><span>&lt;&#39;</span><span>_</span><span>,</span><span> </span><span>WasiCtx</span><span>&gt;</span><span>,</span><span> </span><span>ptr</span>: <span>i32</span><span>|</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>let</span><span> </span><span>mem</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>caller</span><span>.</span><span>get_export</span><span>(</span><span>&#34;memory&#34;</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>Some</span><span>(</span><span>Extern</span>::<span>Memory</span><span>(</span><span>mem</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>mem</span><span>,</span><span>
</span></span></span><span><span><span>                </span><span>_</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>Err</span><span>(</span><span>Trap</span>::<span>new</span><span>(</span><span>&#34;failed to find host memory&#34;</span><span>)),</span><span>
</span></span></span><span><span><span>            </span><span>};</span><span>
</span></span></span><span><span><span>            </span><span>let</span><span> </span><span>offset</span><span> </span><span>=</span><span> </span><span>ptr</span><span> </span><span>as</span><span> </span><span>u32</span><span> </span><span>as</span><span> </span><span>usize</span><span>;</span><span>
</span></span></span><span><span><span>            </span><span>match</span><span> </span><span>mem</span><span>.</span><span>write</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>caller</span><span>,</span><span> </span><span>offset</span><span>,</span><span> </span><span>&amp;</span><span>buf</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>Ok</span><span>(</span><span>_</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{}</span><span>
</span></span></span><span><span><span>                </span><span>_</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>Err</span><span>(</span><span>Trap</span>::<span>new</span><span>(</span><span>&#34;failed to write to host memory&#34;</span><span>)),</span><span>
</span></span></span><span><span><span>            </span><span>};</span><span>
</span></span></span><span><span><span>            </span><span>let</span><span> </span><span>offset</span><span> </span><span>=</span><span> </span><span>ptr</span><span> </span><span>as</span><span> </span><span>i32</span><span>;</span><span>
</span></span></span><span><span><span>            </span><span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span>        </span><span>},</span><span>
</span></span></span><span><span><span>    </span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>expect</span><span>(</span><span>&#34;should define the function&#34;</span><span>);</span><span>
</span></span></span></code></pre></div><h4 id="step-4-get-the-input-and-de-serialize-it-into-a-vec">Step 4: Get the input and de-serialize it into a vec</h4><p>Finally, we can allocate memory on the host, pass in the location to the memory to get_input, and serialize the result:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>main</span><span>()</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>(),</span><span> </span><span>box</span><span>&lt;</span><span>dyn</span><span> </span><span>std</span>::<span>error</span>::<span>Error</span><span>&gt;&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mem_size</span><span> </span><span>=</span><span> </span><span>unsafe</span><span> </span><span>{</span><span> </span><span>get_input_size</span><span>()</span><span> </span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>buf</span>: <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>Vec</span>::<span>with_capacity</span><span>(</span><span>mem_size</span><span> </span><span>as</span><span> </span><span>usize</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>ptr</span><span> </span><span>=</span><span> </span><span>buf</span><span>.</span><span>as_mut_ptr</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>std</span>::<span>mem</span>::<span>forget</span><span>(</span><span>ptr</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>input_buf</span><span> </span><span>=</span><span> </span><span>unsafe</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>get_input</span><span>(</span><span>ptr</span><span> </span><span>as</span><span> </span><span>i32</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>Vec</span>::<span>from_raw_parts</span><span>(</span><span>ptr</span><span>,</span><span> </span><span>mem_size</span><span> </span><span>as</span><span> </span><span>usize</span><span>,</span><span> </span><span>mem_size</span><span> </span><span>as</span><span> </span><span>usize</span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34;input_buf = {:?}&#34;</span><span>,</span><span> </span><span>input_buf</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>input</span>: <span>Input</span><span> </span><span>=</span><span> </span><span>serde_json</span>::<span>from_slice</span><span>(</span><span>&amp;</span><span>input_buf</span><span>)</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>map_err</span><span>(</span><span>|</span><span>e</span><span>|</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>eprintln!</span><span>(</span><span>&#34;ser: {e}&#34;</span><span>);</span><span>
</span></span></span><span><span><span>            </span><span>e</span><span>
</span></span></span><span><span><span>        </span><span>})</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34;input = {:?}&#34;</span><span>,</span><span> </span><span>input</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Unfortunately, we do need to call Vec::from_raw_parts, which is unsafe and quite dangerous. But since WebAssembly is sand boxed, overwriting memory bounds will produce a trap and shouldn’t be able to do too much damage.</p><h4 id="step-5-skipped-write-the-output-to-a-buffer-and-pass-it-back-to-the-host">Step 5 (skipped): Write the output to a buffer and pass it back to the host</h4><p>I’m going to skip explaining how I did this because it would repeat a lot of things I explained earlier in the blog post.</p><p>If you’re curious, there is a working example <a href="https://github.com/pmalmgren/wasi-data-sharing/tree/shared-linear-memory-demo">on GitHub</a>.</p><h3 id="linear-memory-proscons">Linear memory pros/cons</h3><p>Using linear memory should be pretty fast. This is the only advantage I can think of.</p><p>The downsides to using linear memory are: unsafe code, fragmentation (allocation is done in pages), and the complexities of managing memory on the runtime. If you provide a platform for people to run WebAssembly on, you’ll probably have to deal with memory. Otherwise, I think using the first approach is probably better.</p><h2 id="conclusion">Conclusion</h2><p>WebAssembly is really fun but passing in data can be a bit of a pain 😅. Interface types should help take care of this in the future.</p><p>Here is a full working version of the code for the <a href="https://github.com/pmalmgren/wasi-data-sharing/tree/shared-stdio-demo">sharing with stdio</a> and <a href="https://github.com/pmalmgren/wasi-data-sharing/tree/shared-linear-memory-demo">sharing with memory</a> approaches.</p><h2 id="references">References</h2><p>Here are the docs and blog posts which helped me learn this stuff, in no particular order:</p><ul><li><a href="https://docs.wasmtime.dev/">wasmtime docs</a></li><li><a href="https://radu-matei.com/blog/practical-guide-to-wasm-memory/">A practical guide to WebAssembly memory</a></li><li><a href="https://adlrocha.substack.com/p/adlrocha-playing-with-wasmtime-and">@adlrocha - Playing with Wasmtime and Web Assembly’s linear memory</a></li></ul></div></div>
  </body>
</html>
