<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/922968/4a69aa7f1f2332d7/">Original</a>
    <h1>An overview of single-purpose Linux distributions</h1>
    
    <div id="readability-page-1" class="page"><div>
<!-- $Id: slink-trial,v 1.1 2005-11-04 21:27:01 corbet Exp $ -->
<center>
<table>
<tbody><tr><td>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider accepting the trial offer on the right.  Thank you
for visiting LWN.net!
</p></td><td>
<div>
<h3>Free trial subscription</h3>
           <p>
           Try LWN for free for 1 month: no payment
           or credit card required.  <a href="https://lwn.net/Promo/slink-trial2-3/claim">Activate
           your trial subscription now</a> and see why thousands of
           readers subscribe to LWN.net.
           
</p></div>
</td>
</tr>

</tbody></table>
</center>

<p>Many people, when they are installing a Linux distribution for a single
purpose such as 
running containers, would prefer an install-and-forget
type of deployment. At <a href="https://fosdem.org/2023/">FOSDEM 2023</a> in Brussels, several
projects of this minimal Linux distribution type were presented. <a href="https://docs.fedoraproject.org/en-US/fedora-coreos/">Fedora
CoreOS</a>, <a href="https://ubuntu.com/core">Ubuntu Core</a>, <a href="https://microos.opensuse.org/">openSUSE MicroOS</a>, and <a href="https://github.com/bottlerocket-os/bottlerocket">Bottlerocket OS</a>
all tackle this problem in their own way. The talks at FOSDEM gave an
interesting overview of how these projects differ in their approaches. 
</p>

<h4>Fedora CoreOS</h4>

<p>Akashdeep Dhar and Sumantro Mukherjee, who are both members of the Fedora
Council and work at Red Hat as software engineers, <a href="https://fosdem.org/2023/schedule/event/container_fedora_coreos/">explained</a> how they
use Fedora CoreOS as the base operating system to run multiplayer
game servers in containers. As described in its documentation, Fedora
CoreOS is &#34;an automatically updating, minimal, monolithic,
container-focused operating system&#34;. 
</p>

<p>Fedora CoreOS (sometimes abbreviated FCOS) provides the host operating
system for these containers; it only includes those packages that are
needed for a minimal networking-enabled and container-ready setup. At the
time of this writing, the latest <a href="https://getfedora.org/en/coreos?stream=stable">stable release</a>
had 415 packages. It supports the x86_64, aarch64 (including the <a href="https://docs.fedoraproject.org/en-US/fedora-coreos/provisioning-raspberry-pi4/">Raspberry
Pi 4</a>), and s390x architectures; it runs on bare metal, virtualized, or on
various cloud platforms. 
</p>

<p>A Fedora CoreOS machine is provisioned using <a href="https://coreos.github.io/ignition/">Ignition</a>, which is a tool that
partitions disks, formats partitions, enables systemd units, and configures
users. Ignition only runs once during the first boot of the system, from
the initramfs. An Ignition configuration file is formatted as JSON, but for end 
users Fedora CoreOS recommends using a <a href="https://coreos.github.io/butane/config-fcos-v1_4/">Butane
configuration</a>, which is a YAML file that Butane translates into an
Ignition configuration. The &#34;<a href="https://docs.fedoraproject.org/en-US/fedora-coreos/producing-ign/">System
Configuration</a>&#34; section in Fedora CoreOS&#39;s documentation shows some examples
of how to configure storage, network, containers, users and groups, time
zones, and more in a Butane configuration. In their talk, Dhar and
Mukherjee showed a Butane configuration to set up a Minecraft server in a
container, and they also published it in their <a href="https://github.com/t0xic0der/fcos-workshop-fosdemcd-2023">GitHub
repository</a>. 
</p>

<p>When installing Fedora CoreOS, you choose one of three <a href="https://docs.fedoraproject.org/en-US/fedora-coreos/update-streams/">update
streams</a>. &#34;Next&#34; is for experimenting with new features, &#34;testing&#34;
represents what is coming in the next stable stream, and &#34;stable&#34; is the stream
with changes that have spent a time in the testing stream. Most end users
should choose the stable stream. You refer to the Ignition file with your
customizations, in a manner that depends on your installation type. For
instance, 
when <a href="https://docs.fedoraproject.org/en-US/fedora-coreos/bare-metal/#_installing_from_pxe">installing
from PXE</a> you append the <tt>coreos.inst.ignition_url=URL</tt> option to
the kernel, referring it to the location of the Ignition file on a web
server. 
</p>

<p>After installation, the system is updated automatically when a new
release is rolled out on the chosen stream. The <a href="https://coreos.github.io/zincati/">Zincati</a> agent checks for
operating-system updates and applies them using <a href="https://coreos.github.io/rpm-ostree/">rpm-ostree</a>. Zincati can be
configured as well; for example, one can configure how &#34;wary&#34; it is to
update (that is, 
how early 
in the phased rollout cycle it receives updates) and how eager it is to
reboot after applying an update (immediately or only within configured
maintenance windows). If an update causes problems, the user is always able
to manually roll back to the previous system state with:
</p><pre>    $ sudo rpm-ostree rollback -r
</pre> 


<p>There are no <tt>dnf</tt> or <tt>yum</tt> commands in Fedora
CoreOS. Extending the package set is done with <tt>rpm-ostree</tt>, which
layers the packages on top of the current operating-system image. But,
since Fedora CoreOS is a container-focused system, extra services would
generally be installed as containers. 
</p>

<h4>Ubuntu Core</h4>

<p>Canonical&#39;s Valentin David <a href="https://fosdem.org/2023/schedule/event/image_linux_secureboot_ubuntu_core/">talked</a>
about Ubuntu Core. According to the 
project&#39;s home page, it&#39;s &#34;a secure, application-centric IoT OS for
embedded devices&#34;. 
Ubuntu Core targets high-end embedded devices such as industrial computers 
for IoT gateways, signage, robotics, and automotive applications; at home 
it could be useful on a Raspberry Pi to run services such as <a href="https://nextcloud.com/">Nextcloud</a> or home-automation software. 
 The distribution&#39;s software is based
on Ubuntu&#39;s main operating-system builds, but without using deb packages or
the <tt>dpkg</tt> and <tt>apt</tt> commands. Instead, it only uses <a href="https://snapcraft.io/docs/getting-started">snaps</a> to install
software. In essence, a 
snap package is a squashfs image with some metadata about how to install
and run
the software. 
</p>

<p>Snaps are isolated from other snaps and the underlying operating
system. If a snap is run <a href="https://snapcraft.io/docs/snap-confinement">in strict
confinement</a>, it runs in a sandbox, making use of AppArmor, seccomp, and
control groups. By default, snaps don&#39;t have access to resources outside of the
sandbox, but they can get access to specific resources using <a href="https://snapcraft.io/docs/supported-interfaces">interfaces</a>. 
</p>

<p>David explained that there are five types of snaps in Ubuntu Core. 
The &#34;gadget&#34; snap contains device-specific or architecture-specific 
components such as the boot loader, device tree, board-specific 
packages, and configurations. The &#34;kernel&#34; snap comes with the Linux 
kernel, modules, firmware, and systemd stubs. The &#34;base&#34; snap contains the
root file system for the Ubuntu Core operating system. The &#34;snapd&#34; snap 
has snapd, the daemon that installs and updates all snaps. And last but 
not least, each application is packaged in an application snap. This 
includes the root file system of a base snap; it can also make services 
and commands available to the underlying operating system.
</p>

<p>The gadget snap also describes the disk layout. Ubuntu Core typically
has <a href="https://ubuntu.com/core/docs/storage-layout">four
partitions</a>. On UEFI systems, the &#34;seed&#34; partition is the EFI System
Partition (ESP), containing the configuration for the first-stage boot
loader and at least one recovery system. The &#34;boot&#34; partition contains the
second-stage boot loader, a kernel, and initramfs that decrypts the &#34;save&#34; and
&#34;data&#34; partitions. The latter two are <a href="https://en.wikipedia.org/wiki/Linux_Unified_Key_Setup">LUKS2</a> encrypted. The save partition
contains a backup of the device identity and other data to facilitate
recovery, while the data partition stores the user and system data. 
</p>

<p>Most of the Ubuntu Core operating system is read-only. For instance,
<tt>/etc</tt> and <tt>/var</tt> are read-only by default. However, specific
paths are bind-mounted from the data partition, such as
<tt>/etc/systemd</tt>, which allows  the 
system to change any
systemd unit files for the services and mount the snap&#39;s squashfs image. <a href="https://snapcraft.io/docs/transactional-updates">Transactional
updates</a> are handled by snapd: if an update of a snap fails, the system
automatically rolls back to the previous version of the snap. 
</p>

<h4>openSUSE MicroOS</h4>

<p>Ignaz Forster, research engineer at SUSE, <a href="https://fosdem.org/2023/schedule/event/image_linux_secureboot_suse_micro_os/">described</a>
the design of <a href="https://microos.opensuse.org/">openSUSE MicroOS</a>. It&#39;s a
rolling-release distribution of <a href="https://get.opensuse.org/tumbleweed/">openSUSE Tumbleweed</a>,
developed to run as a 
single-purpose system. A typical target would be for hosting containers, but
it can even be used to create <a href="https://en.opensuse.org/Portal:MicroOS/Desktop">a minimal
desktop</a>. As with Fedora CoreOS and Ubuntu Core, openSUSE MicroOS
automatically updates itself and has a minimal package selection. In
openSUSE MicroOS&#39;s case, these are just RPM packages from openSUSE&#39;s
repositories. There&#39;s also an enterprise version, SUSE Linux Enterprise
Micro, and a community version based on the latter, <a href="https://get.opensuse.org/leapmicro/5.3/">Leap Micro</a>. 
</p>

<p>OpenSUSE MicroOS has a read-only root file system, using
Btrfs. Transactional updates are handled by a SUSE-specific wrapper script
around the package manager zypper, <a href="https://github.com/openSUSE/transactional-update">transactional-update</a>. This
creates a new Btrfs snapshot of the root file system and then performs an
update of the system. If the installation was successful, the script marks the
new snapshot as the default snapshot. On errors, the snapshot is discarded
and the previous one remains as the default. A reboot activates the new
snapshot.  Forster announced that, since all of the read-only parts of
openSUSE MicroOS have now 
been moved to 
<tt>/usr</tt>, the upcoming 4.2.0 release of
transactional-update would also be able to apply new snapshots without
rebooting. MicroOS runs a <a href="https://github.com/openSUSE/health-checker">health-checker</a>
systemd service that checks whether the system boots as expected after an
update. This starts an automatic rollback to the previous default
snapshot of the root file system if the system isn&#39;t healthy. 
</p>

<p>The original transactional-update script has been evolving into a
generic library for atomic system updates, libtukit. The current
implementation only supports Btrfs with openSUSE&#39;s snapshot utility <a href="https://github.com/openSUSE/snapper">Snapper</a>, as used in openSUSE
MicroOS. But according to Forster, the API is developed to support other
backends. 
</p>

<p>In contrast to Ubuntu Core, all of <tt>/var</tt> and <tt>/etc</tt> are
writable, while <tt>/usr</tt> is read-only. For instance, the default
system configuration is put in <tt>/usr</tt>. Only changes made by the
administrative user are in <tt>/etc</tt>. OpenSUSE&#39;s <a href="https://github.com/openSUSE/libeconf">libeconf</a> merges the
configuration files placed in several locations. Most of the default
MicroOS packages have been changed to work with this. Only
<tt>/etc/fstab</tt> does not follow this convention yet. Forster concluded
that openSUSE MicroOS takes a pragmatic approach to use existing
infrastructure and packages, and that it&#39;s &#34;a functional read-only OS in an
imperfect world&#34;. 
</p>

<h4>Bottlerocket</h4>

<p>While the previous three operating systems originated from a
general-purpose mother distribution, Bottlerocket is created by Amazon,
tailored to host containers in its Amazon Web Services (AWS) cloud. In his
<a href="https://fosdem.org/2023/schedule/event/container_bottlerocket_os/">talk</a>,
AWS software development engineer Sean
McGinnis was quick to
emphasize that the operating system is &#34;backed by AWS, but not
AWS-only&#34;. As an example, the project&#39;s GitHub repository has <a href="https://github.com/bottlerocket-os/bottlerocket/blob/develop/PROVISIONING-METAL.md">instructions
to run it on bare-metal servers</a>. 
</p>

<p>Bottlerocket was <a href="https://aws.amazon.com/blogs/aws/bottlerocket-open-source-os-for-container-hosting/">announced
in March 2020</a> and made <a href="https://aws.amazon.com/about-aws/whats-new/2020/08/announcing-general-availability-of-bottlerocket/">generally
available in August 2020</a>. To keep its footprint as small as possible,
Amazon publishes variants for particular use cases. For instance, there&#39;s a
aws-k8s variant with containerd and kubelet to run as a Kubernetes node on
AWS, a vmware-k8s variant to do the same on VMware with Amazon Elastic
Kubernetes Service (EKS), and a
metal-k8s variant that supports Amazon EKS running on bare metal. 
</p>

<p>Bottlerocket runs two completely separate container runtimes. One is
running host containers for operational tasks. The other one is used for
running containers with an orchestrator, such as Kubernetes pods. Both
runtimes have different security profiles. 
</p>

<p>Each container, be it a host container or a for-orchestrator container, is
running an API client that talks over a Unix socket to an API server
running on Bottlerocket. When Bottlerocket boots, its boot configuration
(including user data) is loaded into the API server. User interaction is
also typically done <a href="https://github.com/bottlerocket-os/bottlerocket/tree/develop/sources/api">through
this API</a> to make real-time changes to the system configuration. 
</p>

<p>One of the host containers is the &#34;control&#34; container, which is launched
on boot. This container is used to configure the Bottlerocket host. Another
host container is the &#34;admin&#34; container. This isn&#39;t launched by default: it
should only be launched in exceptional circumstances to troubleshoot the host
operating system. It has additional privileges and can use
the root process namespace to access the other containers for
troubleshooting purposes. The admin 
container runs an SSH server that is reachable through the host&#39;s
primary network interface. A final type of host container is the bootstrap
container: this bootstraps the host before services like Kubernetes or
Docker start. It has additional permissions, for instance to provide access
to the 
underlying host file system. 
</p>

<p>Security is one of the focal points of Bottlerocket. The root file
system is read-only, and <tt>/etc</tt> is backed by a tmpfs file system
that is regenerated on boot. For container images and volumes, a separate
user partition is mounted. Moreover, there&#39;s no package manager, no shell,
and no Python interpreter. &#34;If an attacker is able to escape a container,
there are not many tools to work with&#34;, McGinnis said. 
</p>

<p>To check the integrity of the block devices, Bottlerocket uses
<a href="https://docs.kernel.org/admin-guide/device-mapper/verity.html"><tt>dm-verity</tt></a>. The
kernel boots in lockdown mode, which prevents the 
root user from modifying the kernel. McGinnis explained that this increases
assurance that the running kernel corresponds to the booted kernel. Another
security feature he emphasized is that Bottlerocket runs with SELinux in
enforcing mode. 
</p>

<p>For updates, Bottlerocket uses an image-based model. The kernel,
system packages, and container runtime packages are all stored inside an
operating-system image. The first block device of the host has an active
and inactive partition. An upgraded image is downloaded to the inactive
partition, and upon reboot the host boots into this partition, which is
then made active. The previous Bottlerocket image is still stored in the
then inactive partition, and can be rolled back if required. 
</p>

<h4>Conclusion</h4>

<p>When looking at the different approaches of these single-purpose Linux
distributions, it&#39;s clear that there&#39;s no one best way. Which one you
choose depends on how they align to your goals and what tools you&#39;re
comfortable with. Are you heavily invested in the API-first AWS or
Kubernetes world? Then Bottlerocket seems to be the best fit. Do you prefer
snaps to run your services? Then Ubuntu Core is a no-brainer. If you want
to run containers on a host system without too much maintenance, then
Fedora CoreOS or openSUSE MicroOS are for you. Whether they are using
rpm-ostree or Btrfs snapshots under the hood is probably less important
when all of the workloads are running in containers anyway. 
</p></div></div>
  </body>
</html>
