<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://unkey.dev/blog/uuid-ux">Original</a>
    <h1>The UX of UUIDs</h1>
    
    <div id="readability-page-1" class="page"><p>Unique identifiers play a crucial role in all applications, from user authentication to resource management. While using a standard UUID will satisfy all your security concerns, there’s a lot we can improve for our users.</p><div><p>TLDR: Please don&#39;t do this:</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="bash" data-theme="default"><code><span data-line=""><span>https://company.com/resource/c6b10dd3-1dcf-416c-8ed8-ae561807fcaf</span></span></code></pre></div>
<hr/>
<h2 id="the-baseline-ensuring-global-uniqueness">The baseline: Ensuring global uniqueness</h2>
<p>Unique identifiers are essential for distinguishing individual entities within a system. They provide a reliable way to ensure that each item, user, or piece of data has a unique identity. By maintaining uniqueness, applications can effectively manage and organize information, enabling efficient operations and facilitating data integrity.</p>
<p>Let’s not pretend like we are Google or AWS who have special needs around this. Any securely generated UUID with 128 bits is more than enough for us. There are lots of libraries that generate one, or you could fall back to the standard library of your language of choice. In this blog, I&#39;ll be using Typescript examples, but the underlying ideas apply to any language.</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="tsx" data-theme="default"><code><span data-line=""><span>const</span><span> </span><span>id</span><span> </span><span>=</span><span> crypto.</span><span>randomUUID</span><span>()</span></span>
<span data-line=""><span>// &#39;5727a4a4-9bba-41ae-b7fe-e69cf60bb0ab&#39;</span></span></code></pre></div>
<p>Stopping here is an option, but let&#39;s take the opportunity to enhance the user experience with small yet effective iterative changes:</p>
<ol>
<li>Make them easy to copy</li>
<li>Prefixing</li>
<li>More efficient encoding</li>
<li>Changing the length</li>
</ol>
<h3 id="copying-uuids-is-annoying">Copying UUIDs is annoying</h3>
<p>Try copying this UUID by double-clicking on it:</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="typescript" data-theme="default"><code><span data-line=""><span>c6b10dd3</span><span>-</span><span>1dcf</span><span>-</span><span>416c</span><span>-</span><span>8ed8</span><span>-</span><span>ae561807fcaf</span></span></code></pre></div>
<p>If you&#39;re lucky, you got the entire UUID but for most people, they got a single section. One way to enhance the usability of unique identifiers is by making them easily copyable. This can be achieved by removing the hyphens from the UUIDs, allowing users to simply double-click on the identifier to copy it. By eliminating the need for manual selection and copy-pasting, this small change can greatly improve the user experience when working with identifiers.</p>
<p>Removing the hyphens is probably trivial in all languages, here’s how you can do it in js/ts:</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="tsx" data-theme="default"><code><span data-line=""><span>const</span><span> </span><span>id</span><span> </span><span>=</span><span> crypto.</span><span>randomUUID</span><span>().</span><span>replace</span><span>(</span><span>/-/</span><span>g</span><span>, </span><span>&#34;&#34;</span><span>)</span></span>
<span data-line=""><span>// fe4723eab07f408384a2c0f051696083</span></span></code></pre></div>
<p>Try copying it now, it’s much nicer!</p>
<h3 id="prefixing">Prefixing</h3>
<p>Have you ever accidentally used a production API key in a development environment? I have, and it’s not fun.
We can help the user differentiate between different environments or resources within the system by adding a meaningful prefix. For example, Stripe uses prefixes like <code>sk_live_</code> for production environment secret keys or <code>cus_</code> for customer identifiers. By incorporating such prefixes, we can ensure clarity and reduce the chances of confusion, especially in complex systems where multiple environments coexist.</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="tsx" data-theme="default"><code><span data-line=""><span>const</span><span> </span><span>id</span><span> </span><span>=</span><span> </span><span>`hello_${</span><span>crypto</span><span>.</span><span>randomUUID</span><span>().</span><span>replace</span><span>(</span><span>/-/</span><span>g</span><span>, </span><span>&#34;&#34;</span><span>)</span><span>}`</span></span>
<span data-line=""><span>// hello_1559debea64142f3b2d29f8b0f126041</span></span></code></pre></div>
<p>Naming prefixes is an art just like naming variables. You want to be descriptive but be as short as possible. I&#39;ll share ours further down.</p>
<h3 id="encoding-in-base58">Encoding in base58</h3>
<p>Instead of using a hexadecimal representation for identifiers, we can also consider encoding them more efficiently, such as base58. Base58 encoding uses a larger character set and avoids ambiguous characters, such as upper case <code>I</code> and lower case <code>l</code> resulting in shorter identifier strings without compromising readability.</p>
<p>As an example, an 8-character long base58 string, can store roughly 30.000 times as many states as an 8-char hex string. And at 16 chars, the base58 string can store 889.054.070 as many combinations.</p>
<p>You can probably still do this with the standard library of your language but you could also use a library like <a href="https://github.com/ai/nanoid">nanoid</a> which is available for most languages.</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="ts" data-theme="default"><code><span data-line=""><span>import</span><span> { customAlphabet } </span><span>from</span><span> </span><span>&#34;nanoid&#34;</span><span>;</span></span>
<span data-line=""><span>export</span><span> </span><span>const</span><span> </span><span>nanoid</span><span> </span><span>=</span><span> </span><span>customAlphabet</span><span>(</span><span>&#34;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#34;</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>const</span><span> </span><span>id</span><span> </span><span>=</span><span> </span><span>`prefix_${</span><span>nanoid</span><span>(</span><span>22</span><span>)</span><span>}`</span></span>
<span data-line=""><span>// prefix_KSPKGySWPqJWWWa37RqGaX</span></span></code></pre></div>
<p>We generated a 22 character long ID here, which can encode ~100x as many states as a UUID while being 10 characters shorter.</p>
<table><thead><tr><th></th><th>Characters</th><th>Length</th><th>Total States</th></tr></thead><tbody><tr><td>UUID</td><td>16</td><td>32</td><td>2^122 = 5.3e+36</td></tr><tr><td>Base58</td><td>58</td><td>22</td><td>58^22 = 6.2e+38</td></tr></tbody></table>
<p><em>The more states, the higher your collision resistance is because it takes more generations to generate the same ID twice (on average and if your algorithm is truly random)</em></p>
<h3 id="changing-the-entropy">Changing the entropy</h3>
<p>Not all identifiers need to have a high level of collision resistance. In some cases, shorter identifiers can be sufficient, depending on the specific requirements of the application. By reducing the entropy of the identifiers, we can generate shorter IDs while still maintaining an acceptable level of uniqueness.</p>
<p>Reducing the length of your IDs can be nice, but you need to be careful and ensure your system is protected against ID collissions. Fortunately, this is pretty easy to do in your database layer. In our MySQL database we use IDs mostly as primary key and the database protects us from collisions. In case an ID exists already, we just generate a new one and try again. If our collision rate would go up significantly, we could simply increase the length of all future IDs and we’d be fine.</p>
<table><thead><tr><th>Length</th><th>Example</th><th>Total States</th></tr></thead><tbody><tr><td>nanoid(8)</td><td>re6ZkUUV</td><td>1.3e+14</td></tr><tr><td>nanoid(12)</td><td>pfpPYdZGbZvw</td><td>1.4e+21</td></tr><tr><td>nanoid(16)</td><td>sFDUZScHfZTfkLwk</td><td>1.6e+28</td></tr><tr><td>nanoid(24)</td><td>u7vzXJL9cGqUeabGPAZ5XUJ6</td><td>2.1e+42</td></tr><tr><td>nanoid(32)</td><td>qkvPDeH6JyAsRhaZ3X4ZLDPSLFP7MnJz</td><td>2.7e+56</td></tr></tbody></table>
<h2 id="conclusion">Conclusion</h2>
<p>By implementing these improvements, we can enhance the usability and efficiency of unique identifiers in our applications. This will provide a better experience for both users and developers, as they interact with and manage various entities within the system. Whether it&#39;s copying identifiers with ease, differentiating between different environments, or achieving shorter and more readable identifier strings, these strategies can contribute to a more user-friendly and robust identification system.</p>
<h2 id="ids-and-keys-at-unkey">IDs and keys at Unkey</h2>
<p>Lastly, I&#39;d like to share our implementation here and how we use it in our <a href="https://github.com/unkeyed/unkey/blob/main/internal/id/src/index.ts">codebase</a>. We use a simple function that takes a typed prefix and then generates the ID for us. This way we can ensure that we always use the same prefix for the same type of ID. This is especially useful when you have multiple types of IDs in your system.</p>
<div data-rehype-pretty-code-fragment=""><p>/internal/ids/src/index.ts</p><pre tabindex="0" data-language="ts" data-theme="default"><code><span data-line=""><span>import</span><span> { customAlphabet } </span><span>from</span><span> </span><span>&#34;nanoid&#34;</span><span>;</span></span>
<span data-line=""><span>export</span><span> </span><span>const</span><span> </span><span>nanoid</span><span> </span><span>=</span><span> </span><span>customAlphabet</span><span>(</span><span>&#34;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#34;</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>const</span><span> </span><span>prefixes</span><span> </span><span>=</span><span> {</span></span>
<span data-line=""><span>  key: </span><span>&#34;key&#34;</span><span>,</span></span>
<span data-line=""><span>  api: </span><span>&#34;api&#34;</span><span>,</span></span>
<span data-line=""><span>  policy: </span><span>&#34;pol&#34;</span><span>,</span></span>
<span data-line=""><span>  request: </span><span>&#34;req&#34;</span><span>,</span></span>
<span data-line=""><span>  workspace: </span><span>&#34;ws&#34;</span><span>,</span></span>
<span data-line=""><span>  keyAuth: </span><span>&#34;key_auth&#34;</span><span>, </span><span>// &lt;-- this is internal and does not need to be short or pretty</span></span>
<span data-line=""><span>  vercelBinding: </span><span>&#34;vb&#34;</span><span>,</span></span>
<span data-line=""><span>  test: </span><span>&#34;test&#34;</span><span>, </span><span>// &lt;-- for tests only</span></span>
<span data-line=""><span>} </span><span>as</span><span> </span><span>const</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>export</span><span> </span><span>function</span><span> </span><span>newId</span><span>(</span><span>prefix</span><span>:</span><span> </span><span>keyof</span><span> </span><span>typeof</span><span> prefixes)</span><span>:</span><span> </span><span>string</span><span> {</span></span>
<span data-line=""><span>  </span><span>return</span><span> [prefixes[prefix], </span><span>nanoid</span><span>(</span><span>16</span><span>)].</span><span>join</span><span>(</span><span>&#34;_&#34;</span><span>);</span></span>
<span data-line=""><span>}</span></span></code></pre></div>
<p>And when we use it in our codebase, we can ensure that we always use the correct prefix for the correct type of id.</p>
<div data-rehype-pretty-code-fragment=""><p>somewhere.ts</p><pre tabindex="0" data-language="ts" data-theme="default"><code><span data-line=""><span>import</span><span> { newId } </span><span>from</span><span> </span><span>&#34;@unkey/id&#34;</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>const</span><span> </span><span>id</span><span> </span><span>=</span><span> </span><span>newId</span><span>(</span><span>&#34;workspace&#34;</span><span>)</span></span>
<span data-line=""><span>// ws_dYuyGV3qMKvebjML</span></span>
<span data-line=""> </span>
<span data-line=""><span>const</span><span> </span><span>id</span><span> </span><span>=</span><span> </span><span>newId</span><span>(</span><span>&#34;keyy&#34;</span><span>)</span></span>
<span data-line=""><span>// invalid because `keyy` is not a valid prefix name</span></span></code></pre></div>
<hr/>
<p>I&#39;ve been mostly talking about identifiers here, but an api key really is just an identifier too. It&#39;s just a special kind of identifier that is used to authenticate requests. We use the same strategies for our api keys as we do for our identifiers. You can add a prefix to let your users know what kind of key they are looking at and you can specify the length of the key within reason.
Colissions for API keys are much more serious than ids, so we enforce secure limits.</p>
<p>It&#39;s quite common to prefix your API keys with something that identifies your company. For example <a href="https://resend.com">Resend</a> are using <code>re_</code> and <a href="https://openstatus.dev">OpenStatus</a> are using <code>os_</code> prefixes. This allows your users to quickly identify the key and know what it&#39;s used for.</p>
<div data-rehype-pretty-code-fragment=""><p>setting the key length and a prefix using @unkey/api</p><pre tabindex="0" data-language="ts" data-theme="default"><code><span data-line=""><span>const</span><span> </span><span>key</span><span> </span><span>=</span><span> </span><span>await</span><span> unkey.key.</span><span>create</span><span>({</span></span>
<span data-line=""><span>  apiId: </span><span>&#34;api_dzeBEZDwJ18WyD7b&#34;</span><span>,</span></span>
<span data-line=""><span>  prefix: </span><span>&#34;blog&#34;</span><span>,</span></span>
<span data-line=""><span>  byteLength: </span><span>16</span><span>,</span></span>
<span data-line=""><span>  </span><span>// ... omitted for brevity</span></span>
<span data-line=""><span>})</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Created key:</span></span>
<span data-line=""><span>// blog_cLsvCvmY35kCfchi</span></span></code></pre></div></div></div>
  </body>
</html>
