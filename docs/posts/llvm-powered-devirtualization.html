<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.thalium.re/posts/llvm-powered-devirtualization/">Original</a>
    <h1>LLVM-powered devirtualization</h1>
    
    <div id="readability-page-1" class="page"><div><p>This work was carried out during an <strong>internship</strong> at Thalium on the subject of deobfuscation of virtualized binaries.</p><h2 id="context">Context</h2><p>Obfuscation is the process of deliberately making code difficult to understand in order to hinder its analysis. It is often used in malware to conceal malicious intent and avoid detection.</p><p>Various binary obfuscation strategies exist today, including:</p><ul><li>Removing comments / symbols</li><li>Adding opaque predicates (branches on a constant condition)</li><li>Control flow flattening</li><li>Virtualization</li></ul><p><strong>Virtualization</strong> is one of the most popular, and potent<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> forms of obfuscation today.</p><p>Various obfuscators including <a href="https://tigress.wtf/">Tigress</a>, <a href="https://www.oreans.com/Themida.php">Themida</a> and <a href="https://vmpsoft.com/">VMProtect</a> offer virtualization. Due to its potency and the high availability of obfuscators, virtualization has unfortunately been used by threat actors and found in numerous malware (<a href="https://attack.mitre.org/techniques/T1027/002/">source: MITRE</a>).</p><p>Here is a rough outline of the architecture of a virtualized obfuscated binary:</p><p><a href="https://moerner.com/posts/img/llvm-powered-devirtualization/image.png" target="_blank"><img src="https://moerner.com/posts/img/llvm-powered-devirtualization/image.png" alt="Virtualized binary schematized architecture"/></a></p><p>In a virtualized binary, the original program gets encoded into a sequence of <em>virtual instructions</em>.
The obfuscated program is going to contain these <em>virtual instructions</em> as well as an <em>interpreter</em>.
The <em>interpreter</em> is responsible for executing the virtual instructions. It often contains distinctive components:</p><ul><li>a <em>VM entry</em> responsible for context switching and initializing the virtual CPU;</li><li>a <em>VM exit</em>, also for context switching;</li><li>a <em>dispatcher</em> which retrieves the <em>virtual instruction</em> at the <em>virtual program counter</em> (VPC), then sends the control flow to the appropriate <em>handler</em> for the given <em>virtual instruction</em>;</li><li><em>handlers</em>, which encode the semantics of the different <em>virtual instructions</em>.</li></ul><p>Virtual instructions can be anything ranging from logical operations (AND, XOR), control flow operations (JUMP, BRANCH) to more complex operations (see Schloegel <em>et. al.</em> <strong>Loki: Hardening Code Obfuscation Against Automated Attacks</strong> (<a href="https://www.usenix.org/conference/usenixsecurity22/presentation/schloegel">usenix.org</a>)).</p><h2 id="devirtualization-strategy">Devirtualization strategy</h2><h3 id="manual-analysis">Manual analysis</h3><p>If you have ever been led to manually reverse engineering a VM (a program protected with virtualization), you know that it is often a long and complex task. If you haven’t, you can check out our other post <a href="https://moerner.com/posts/ecw-2023-kaleidoscope-write-up/">kaleidoscope</a> and give it a try yourself!</p><p>The intuitive approach to devirtualization is usually to identify the VM context (e.g. where are located the virtual program counter and other virtual registers), reverse engineer each handler, and then create a custom disassembler for this VM.
We can then disassemble the virtual instructions and reverse engineer the original program.</p><p>This is extremely tedious, mainly because the architecture used in the VM may change in each obfuscated program.
Moreover, virtualized binaries can be further obfuscated, making it hard to identify and reverse engineer the handlers.
For example, a common hardening strategy is to encrypt the virtual instructions.</p><h3 id="automated-analysis">Automated analysis</h3><p>A different approach put forward by Yadegari <em>et al.</em> in their paper <strong>A Generic Approach to Automatic Deobfuscation of Executable Code</strong> (<a href="https://ieeexplore.ieee.org/document/7163054">ieee.org</a>) consists in using a dynamic taint analysis to reconstruct the original program’s CFG.
Jonathan Salwan <em>et al.</em> expanded this strategy in <strong>Symbolic deobfuscation: from virtualized code back to the original</strong> (<a href="https://shell-storm.org/talks/DIMVA2018-deobfuscation-salwan-bardin-potet.pdf">shell-storm.org</a>) by then leveraging symbolic execution and compiler optimizations to recreate a devirtualized program.</p><p>Our devirtualization approach was heavily inspired by these taint-based methods. Given the limited timeframe of the internship, we slightly simplified this approach. We also wanted to experiment with <strong>removing the symbolic execution component</strong> which is notoriously slow.</p><p>For our devirtualization, we perform a dynamic taint analysis on the obfuscated function, tainting its parameters.
We then split an execution trace of the obfuscated binary each time we encounter a tainted conditional instruction in the CFG (branches, <code>cmove</code>, etc.).
Finally, we combine these blocks to reconstruct a CFG.</p><p>This approach is not the most robust, but worked well for the Tigress obfuscated binaries we tested against (this will be further detailed in the <em>Results</em> section).</p><h3 id="example">Example</h3><p>The best way of explaining our approach is through an example.</p><p>Let’s consider we have a simple program:</p><div><pre tabindex="0"><code data-lang="C"><span><span><span>int</span> <span>counter</span>(<span>int</span> input) {
</span></span><span><span>    <span>int</span> i <span>=</span> <span>0</span>;
</span></span><span><span>    <span>while</span> (i <span>&lt;</span> input) {
</span></span><span><span>        i <span>+=</span> <span>1</span>;
</span></span><span><span>    }
</span></span><span><span>    <span>return</span> i;
</span></span><span><span>}
</span></span></code></pre></div><p>Its CFG would look like this:</p><p><a href="https://moerner.com/posts/img/llvm-powered-devirtualization/image-7.png" target="_blank"><img src="https://moerner.com/posts/img/llvm-powered-devirtualization/image-7.png" alt="CFG of the counter function"/></a></p><p>A virtualized version of this program could look like this:</p><p><a href="https://moerner.com/posts/img/llvm-powered-devirtualization/image-8.png" target="_blank"><img src="https://moerner.com/posts/img/llvm-powered-devirtualization/image-8.png" alt="CFG of the virtualized counter function"/></a></p><p>The main elements of a VM are present in the above diagram.
Here, the virtual instructions (“opcodes”) are simply the handlers’ colors.</p><p>Note that the process of obfuscating this program added additional basic blocks (the hatched ones). These include operations that modify the VPC and the dispatcher.</p><h4 id="taint">Taint</h4><p>Performing a taint analysis on the above obfuscated program reveals that the red block (the branching instruction) is the only tainted instruction (it is the only one which interacts with the user input).</p><blockquote><p><em>This is a very simplified view: in a more complex program, the taint would get propagated during the execution.</em></p></blockquote><h4 id="execution-trace">Execution trace</h4><p>We then collect an execution trace of the obfuscated program with a random input (in this example we picked <code>2</code>):</p><p><a href="https://moerner.com/posts/img/llvm-powered-devirtualization/image-10.png" target="_blank"><img src="https://moerner.com/posts/img/llvm-powered-devirtualization/image-10.png" alt="Trace of the virtualized counter function"/></a></p><p>These instructions are all consecutive, the arrows are simply to make the trace fit on screen.</p><p>Note that the trace depends on the input. Had we picked input <code>-1</code>, the trace would not contain the green block.</p><h4 id="splitting-the-trace">Splitting the trace</h4><p>At this stage, we can split the trace on the tainted CFG instructions (which we determined was the red block).</p><p>After splitting, our blocks look like this:</p><p><a href="https://moerner.com/posts/img/llvm-powered-devirtualization/image-11.png" target="_blank"><img src="https://moerner.com/posts/img/llvm-powered-devirtualization/image-11.png" alt="Split trace of the virtualized counter function"/></a></p><p>As you can see, the second and the third groups of blocks are identical. We could therefore merge them.
Using various heuristics detailed in the complete report, we are able to merge and split blocks to create this final CFG:</p><p><a href="https://moerner.com/posts/img/llvm-powered-devirtualization/image-12.png" target="_blank"><img src="https://moerner.com/posts/img/llvm-powered-devirtualization/image-12.png" alt="Reconstructed CFG of the counter function"/></a></p><h3 id="simplifying-the-cfg">Simplifying the CFG</h3><p>At this point, the CFG is still quite complex with many useless instructions. The next step in the deobfuscation process consists in simplifying the code using compiler optimizations.</p><h2 id="using-llvm">Using LLVM</h2><p>As we just saw, taint-based devirtualization relies on compiler optimizations to simplify the recreated CFG and deobfuscate the program.
We decided to use LLVM’s state-of-the-art optimizations.</p><p>Instead of simply integrating LLVM at the very end of our deobfuscation pipeline, we decided to perform all our analysis in LLVM IR.
We were inspired by another deobfuscator: <a href="https://arxiv.org/pdf/1909.01752"><em>Saturn</em></a>, which uses LLVM IR as an intermediate representation to deobfuscate opaque predicates.</p><p>First and foremost, this allows us to perform optimizations at the very beginning of our deobfuscation pipeline.
This initial round of optimizations allows us to remove simple obfuscation passes allowing further analysis to run faster.</p><p>Another important consideration, is that using an IR we are able to easily create a multi-architecture tool. As of writing this article, we were able to devirtualize both <code>amd64</code> and <code>aarch64</code> binaries. We are in the process of adding support for their 32-bit counterparts.</p><p>Last but not least, using LLVM’s IR gives us access to a whole suite of tools. LLVM’s ecosystem not only includes LLVM’s analysis and optimization passes, but also third party tools such as the symbolic execution engine <a href="https://klee-se.org/">KLEE</a>.
Notably, this also works the other way around: we will be able to contribute to LLVM’s ecosystem with our analysis modules. For example, during this internship, we were led to create a dynamic taint analysis engine for LLVM IR (version 17).</p><h3 id="lifting">Lifting</h3><p>An important step is <em>lifting</em>: the process of translating machine instructions to another representation (in this case, LLVM IR).</p><p>To do so, we used Trail of Bits’ <a href="https://github.com/lifting-bits/remill"><em>remill</em></a> library.
Using <em>remill</em> proved to be tricky, but we received some helpful advice from the authors of <em>Saturn</em> detailing not only strategies to lift complete CFGs but also custom LLVM passes and tricks to simplify the generated LLVM IR.</p><p>Lifting binaries was a large and complex part of the internship.</p><h2 id="results">Results</h2><p>During this internship, we were able to use our devirtualization tool on binaries (both <code>amd64</code> and <code>aarch64</code>) obfuscated with the Tigress obfuscator.</p><p>Notably, we were able to partially deobfuscate the first <a href="https://tigress.cs.arizona.edu/challenges.html">Tigress challenge</a>, and so very quickly.</p><p>For example, on our machine (OS: Linux - Fedora 40, CPU: 6-core Intel Core i5-8500, Mem: 15.44 GiB), we <strong>partially</strong> deobfuscated <code>challenge0000-binary1</code> in under a second.
For reference, <em>Triton</em> claims to <strong>fully</strong> deobfuscate the same binary in 9.20s.</p><p>Here is the obfuscated <code>amd64</code> <code>challenge0000-binary1</code>:
<a href="https://moerner.com/posts/img/llvm-powered-devirtualization/image-5.png" target="_blank"><img src="https://moerner.com/posts/img/llvm-powered-devirtualization/image-5.png" alt="CFG of the SECRET function in the obfuscated binary: challenge0000-binary1"/></a></p><p>And here is the deobfuscated LLVM IR partial result (132 lines of LLVM IR):</p><p><img src="https://moerner.com/posts/img/llvm-powered-devirtualization/image-6.png" alt="Partially devirtualized SECRET function from the obfuscated binary: challenge0000-binary1" width="100"/></p><p>And here is a C extract after compiling the result with <code>llc</code> then decompiling it with IDA:</p><div><pre tabindex="0"><code data-lang="C"><span><span>v16_0 <span>=</span> (input <span>&amp;</span> <span>0x222C2AFC</span>) <span>-</span> <span>0x14582014</span>;
</span></span><span><span>v16_1 <span>=</span> input <span>+</span> <span>0x1DF2339F</span> <span>*</span> v16_0 <span>+</span> <span>0x22D2B77C</span>;
</span></span><span><span>V16_2 <span>=</span> (input <span>&amp;</span> <span>0x140538E4</span>) <span>-</span> <span>0x5F1E4CE7</span>;
</span></span><span><span>v16_3 <span>=</span>
</span></span><span><span>input <span>+</span> (v16_1 <span>&gt;&gt;</span> ((((<span>unsigned</span> <span>__int8</span>)((input <span>&amp;</span> <span>0xE4</span>) <span>+</span> <span>0x19</span>) <span>&gt;&gt;</span> <span>3</span>) <span>&amp;</span> <span>7u</span>) <span>-</span> <span>1</span>) <span>&gt;&gt;</span> <span>1</span>);
</span></span><span><span><span>if</span> ((v16_0 <span>^</span> v16_1) <span>==</span> V16_2 <span>*</span> v16_3) {
</span></span><span><span>    <span>_mermaid_missing_block</span>();
</span></span><span><span>    <span>JUMPOUT</span>(<span>0x2B2LL</span>);
</span></span><span><span>}
</span></span></code></pre></div><blockquote><p><em>In the C extract, you can see a call to a missing block because we did not visit that execution path. Had we chosen a different input, we could have explored this branch (but not another). To achieve better coverage, we could use symbolic execution to find inputs allowing us to visit various execution paths.</em></p></blockquote><h3 id="limitations">Limitations</h3><p>Although we achieved promising results regarding speed and modularity, the scope of this internship was still quite limited:</p><ul><li>we only considered deobfuscation of pure functions with no calls;</li><li>we only deobfuscate a single execution path;</li><li>our deobfuscator struggles with certain loops.</li></ul><h2 id="complete-report">Complete report</h2><p>If you found this work interesting, we have decided to make the full internship report publically available <a href="https://moerner.com/posts/misc/llvm-powered-devirtualization/internship-report.pdf">here</a>. The report contains additional technical details, a discussion on limitations as well as our future plans.</p><p>I am continuing with a PhD at Thales, so stay tuned for further developments. If you have any questions feel free to reach out!</p></div></div>
  </body>
</html>
