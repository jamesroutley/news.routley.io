<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gustedt.wordpress.com/2025/06/30/the-provenance-memory-model-for-c/">Original</a>
    <h1>The provenance memory model for C</h1>
    
    <div id="readability-page-1" class="page"><div><p>A years-long effort led by <a href="https://www.cl.cam.ac.uk/~km569/">Kayvan
Memarian</a> and <a href="https://www.cl.cam.ac.uk/~pes20/">Peter
Sewell</a> from Cambridge University,
UK, <a href="https://www.tugraz.at/institute/ibi/institute/team/">Martin
Uecker</a> from Graz
University of Technology, Austria, and
<a href="https://icps.icube.unistra.fr/index.php?title=Jens_Gustedt">myself</a>
(from ICube/Inria, France) has guided the C community to accept a
common vision of so-called <em>pointer provenance</em>, defining how to trace
the origins of pointer values through program execution.  Our
<a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3057.pdf">provenance-aware memory object model for
C</a>
provides a precise mathematical specification, in place of the
ambiguity of these aspects of the current <a href="https://www.iso.org/standard/82075.html">C
standard</a>. It has also
stimulated and informed discussion of provenance in the broader C,
C++, Rust, and compiler communities.</p>
<p>This work has finally resulted in the publication of an international
standard, Technical Specification <a href="https://webstore.iec.ch/en/publication/107524">ISO/IEC TS
6010</a> (edited by <a href="https://www.linkedin.com/in/henrykleynhans/">Henry
Kleynhans</a>, Bloomberg,
UK).  With the goal of making modern information systems safer and
more secure, this official technical specification provides direction
to all stakeholders in the industry such that they can converge their
platforms and tools.</p>
<p>In this article, I will try to explain what this is all about, namely
on how a provenance model for pointers interferes with alias analysis
of modern compilers. For those that are not fluent with the
terminology or the concept we have a short intro <a href="#pointer-aliasing-and-program-optimization">what pointer
aliasing is all about</a>, a
<a href="#helping-the-compiler">review of existing tools to help the compiler and inherent
difficulties</a> and then the <a href="#the-provenance-model">proposed model
itself</a>. At the end there is a brief
<a href="#takeaway">takeaway</a> that explains how to generally avoid
complications and loss of optimization opportunities that could result
from mis-guided aliasing analysis.</p>
</div><div><h2>Pointer aliasing and program optimization</h2>
<p>We say that two pointer values <code>p</code> and <code>q</code> during the execution of a
program <em>alias</em> if they point to the same object in
memory. To see that the question if two pointers alias
has an influence on the optimization of code, let’s consider the
following simple example of an iterative function.</p>
<p>It implements an approximation algorithm for the reciprocal <code>r := 1/a</code> of the value <code>a := *aₚ</code> which doesn’t use division.</p>
<pre><code>// Reciprocal approximation
//
// This interface is horrific, don&#39;t use it.
// This just serves as an artificial example
// for this article.

constexpr double ε  = 0x1P-24;
constexpr double Π⁻ = 1.0 - ε;
constexpr double Π⁺ = 1.0 + ε;

void recip(double* aₚ, double* řₚ) {
    for (;;) {
        register double Π = (*aₚ)*(*řₚ);
        if ((Π⁻ &amp;lt; Π) &amp;amp;&amp;amp; (Π &amp;lt; Π⁺)) {
            break;
        } else {
            (*řₚ) *= (2.0 - Π);
        }
    }
}
</code></pre>
<p>The function receives a pointer to a second value <code>ř := *řₚ</code> with a
rough approximation for <code>r</code>. It then iteratively approaches <code>r</code> within
a chosen precision <code>ε</code>: the current values <code>a</code> and <code>ř</code> are multiplied
into a value <code>Π</code> and if that value is sufficiently close to <code>1.0</code> the
iteration stops. If it is not, <code>ř</code> is corrected and the loop
continues.</p>
<p>What is interesting for our context of aliasing is that this function
has two pointer arguments that both point to a value of the same type
<code>double</code>. One of these pointer targets <code>*řₚ</code> is loaded from memory,
modified and stored at each iteration. In total, the non-optimized
function as specified above in each iteration has</p>
<ul>
<li>3 load and 1 store operations,</li>
<li>2 comparisons,</li>
<li>1 logical operation, and</li>
<li>3 arithmetic operations.</li>
</ul>
<p>So loads and stores from memory make up 4 of about 10 operations in
total.</p>
<p>But wait, can’t this be done better? Yes, obviously, a much better
version of this could look as follows.</p>
<pre><code>void recip⁺(double* aₚ, double* řₚ) {
    register double a = *aₚ;
    register double ř = *řₚ;
    for (;;) {
        register double Π = a*ř;
        if ((Π⁻ &lt; Π) &amp;&amp; (Π &lt; Π⁺)) {
            break;
        } else {
            ř *= (2.0 - Π);
        }
    }
    *řₚ = ř;
}
</code></pre>
<p>That is, we load <code>a</code> and <code>ř</code> once, at the beginning, and then only
update <code>*řₚ</code> when we have finished our computation. The hope here is
that these new local variables use “hardware registers” that can be
used directly by the processor, without going through loads and stores
from and to the program memory.</p>
<p>So roughly the optimized function saves us 40% of the operations.
This means that the optimized function is in general much faster and
achieves its goal by wasting less energy.</p>
<p>Unfortunately no C compiler can do this optimization automatically:</p>
<blockquote>
<p><em>The functions <code>recip</code> and <code>recip⁺</code> and not equivalent.</em></p>
</blockquote>
<p>We didn’t see this, yet, because we failed to discuss an important
feature of the original program; the pointers <code>aₚ</code> and <code>řₚ</code> may either
point</p>
<ul>
<li>to different objects, or</li>
<li>to the same object.</li>
</ul>
<p>Indeed, our optimized function <code>recip⁺</code> only covers the first of these
possibilities and not the second: the second case provides a
completely different algorithm for which I wouldn’t know any use or
properties. But since the compiler can’t know which of these cases we
have in mind (maybe both?) it cannot do an optimization that excludes
the second.</p>
<p>In general, loads and stores from memory are expensive operations, so
a lot of effort in modern compiler frameworks goes into so-called
alias analysis, that is in an detailed analysis of which pointers
may alias each other (or not). Such alias analysis then can be used to
mechanically prove whether a specific optimization is feasible or not.</p>
<p>&gt; <em>Good alias analysis of pointer targets is crucial for
&gt; optimization in modern compilers.</em></p>
<p>In the case of <code>recip</code> we see that our specification is not precise
enough to know whether or not the second case (where the pointers
alias), can be excluded. We also see that misguided assumptions about
pointer aliasing can result in implementing a completely different
algorithm. Or, in other words, they may result in a severe bug.</p>
<p>&gt; <em>Mislead aliasing assumptions result in bugs.</em></p>
<p>In one of our
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2363.pdf">papers</a>,
we provide a long list of examples where pointer aliasing can lead to
different interpretations by users and compilers, see also <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2311.pdf">this paper
here</a>.</p>
<p>Note also that a previous attempt by the C committee to introduce
stricter aliasing rules had turned into years of flame wars between
alienated parts of the user community, compiler builders and committee
members.  A communication disaster that was very harmful for the
industry in general and to the trust of the community in the C
committee in particular.</p>
<h2>Helping the compiler</h2>
<p>Modern compilers have several mechanisms that help to deduce more
information about the intended use cases for pointers and from there
to provide correct optimizations. These mechanisms are</p>
<ul>
<li>Type-based alias analysis.</li>
<li>Flow-based alias analysis.</li>
</ul>
<p>For type-based alias analysis, C takes a relatively simple approach,
at least on the surface level.</p>
<p>&gt; <em>Two pointers that point to objects of different non-character type
&gt; are supposed not to alias.</em></p>
<p>So, for our function <code>recip</code> above, it would have been sufficient to
have arguments pointing to differently typed objects. Then, an
optimization similar to <code>recip⁺</code> would have been valid.</p>
<p>But …</p>
<p>… notice the “supposed” in the phrase above. In C, it is entirely
the programmers responsibility to ensure that two differently typed
objects are in fact different. If you are casting spells to convert
pointers from one target type to another, you have to prove for
yourself that you may pass such pointers as arguments to functions
without causing problems, there. You are completely on your own.</p>
<p>Flow-based analysis in C is supported by several tools</p>
<ul>
<li>The <code>register</code> storage class.</li>
<li>The <code>restrict</code> pointer qualifier.</li>
<li>The <code>volatile</code> qualifier on the target type.</li>
</ul>
<p>The first ensures that the address of a so-declared object is never
taken. And in C, when there are no pointers, there is no
aliasing. Although this is easy enough to use and
provides feedback if one tries to obtain the address of such an
object, it seems that this is much less used than it should.</p>
<p>The second is much more subtle. If a pointer parameter of a function
is declared with <code>restrict</code>, every user of the function has to ensure
that the pointer value is the unique view on the object from within
for each call to the function. The definition in the standard of that
feature is obscure and, again, it has the same drawback as type-based
alias analysis in C: you are completely on your own.</p>
<p>The third is a feature that imposes that each access to a <code>volatile</code>
qualified object reloads the object from memory, regardless what the
compiler might know about its previous value. Using this feature
excessively is like stepping on the break: basically all optimization
opportunities concerning that object are lost.</p>
<p>As extensions, some compilers also have command line flags that help
the user to steer through. For example gcc has the options
<code>-fstrict-aliasing</code> and <code>-fno-strict-aliasing</code> to switch aliasing
analysis as defined by the C standard on or off.</p>
<h3>And then, there is provenance …</h3>
<p>In the current C standard provenance is only a hidden concept, the
word “provenance” appears in it exactly 0 times. Nevertheless, it
marks an important assumption for existing C, namely that somehow
compilers are allowed to assume that two pointers don’t alias when
they are known to come from different “sources” in the program.</p>
<p>For programmers, the current state is a disaster. In many cases there
is no way to know which assumptions a compiler makes:</p>
<ul>
<li>There is no way (but <code>restrict</code> and types, see above) to claim that
two pointers never alias.</li>
<li>It is difficult (but for <code>volatile</code>) to specify that they might
alias such as to force optimization to be more restricted,
either. This even in situations where, for example, the base types
are in fact different, but where the user knows that the underlying
object might still be the same.</li>
</ul>
<p>The concept of provenance created many difficulties because it was left undefined exactly what it meant, so each compiler implementer had their own ideas how to assert that two pointers do (or don’t) alias, and how to use that in optimization.</p>
<p>When digging deeper we observed several problem spots, and it took us
in fact a long time to understand the different assumptions.</p>
<h4>Object granularity</h4>
<p>The first question that comes up is to figure out at which granularity
we can do or want to do aliasing analysis. At the level of bytes,
words, basic type objects, structure objects, memory allocations, or,
the whole address space?</p>
<p>The main problem here is that in C we can move from one pointer
address to the next via arithmetic. The easiest examples are
arrays. If we have access to an element in the middle of an array, we
can move back and forth by simply adding or subtracting an integer
value to the corresponding pointer value. How would we (the
programmers) or the compiler know if two pointers point into the some
array but at different elements?  What happens if we start to step
backwards from such pointers?</p>
<p>This picture becomes even more confusing, if we allow pointer
arithmetic on the byte level. In C, the <code>offsetof</code> macro allows us to
access arbitrary members of a structure by using such pointer
arithmetic.</p>
<h4>Pointer equality and object life time</h4>
<p>When you are programming with pointers in C, you are hopefully aware
of the “dangling pointer” problem. This refers to the fact that for
example a pointer to a local variable becomes invalid once you leave
the scope (e.g. function) where it is declared.</p>
<p>For aliasing analysis, this becomes even more complicated: not only
does a pointer become invalid, the address of the dead object may be
reused in a different context. So two pointers may even be equal, one
pointing to a dead object, the other to a new one.</p>
<p>There is another situation where two pointer values are the same, but
where they talk about two different objects. This occurs when two
arrays, <code>A</code> and <code>B</code>, say, happen to live in adjacent memory
locations. If <code>A</code> has <code>n</code> elements, the pointer value <code>&amp;amp;A[0]+n</code> (the
end of <code>A</code>) might be the same as <code>&amp;amp;B[0]</code> (the start of <code>B</code>).  So then
we have two pointer values that are the same but that have quite a
different meaning for the programmer.</p>
<h4>Information flow for addresses</h4>
<p>Another concept influences aliasing analysis a lot, namely the
possibility that a pointer value escapes from a limited scope of the
program (e.g the address of a local variable) and becomes known in
other parts of the program.</p>
<p>For example a variable that is declared <code>static</code> in a block is usually
only visible there. In general the compiler masters very well which
pointers may alias with a pointer value that corresponds to the
address of that <code>static</code> variable. If the address of that variable
“escapes” from the local scope, for example by passing it as an
argument to a function, the address could come back into the same
scope via unknown paths that are difficult to control.</p>
<p>There are surprisingly many ways that pointer values as a whole or
parts of them may escape from one context and reappear in
another. Among them are</p>
<ul>
<li>manipulations of the byte-representations of pointers for example
<ul>
<li>copying by <code>memcpy</code>,</li>
<li>copying by bytes,</li>
<li>IO using <code>%p</code> in <code>printf</code> or</li>
<li><code>fwrite</code></li>
</ul>
</li>
<li>manipulation of integers that are the result of pointer-to-integer
conversions.</li>
</ul>
<p>Perhaps surprisingly the latter is an important point that had to be
handled carefully in our proposal. The reason is that pointer
bit-manipulations are used in contexts where the available memory
relatively constrained, such as systems programming for
example. Bit-manipulation tricks are then used to save on the size of
data structures. This has not only the advantage that storage space
for the data can be reduced, but also that a reduced size also
improves the performance for data that are used intensively due to
improved use of processor caches.</p>
<p>A famous example is the XOR trick for doubly linked lists, where a
data structure stores the XOR of the bit patterns of two pointer
values. So for that particular use we have an integer (here of type
<code>uintptr_t</code>) that contains information that comes from two different
pointers, that then is used to sometimes reconstruct one or the other
of these pointer values.</p>
<pre><code>typedef struct elem elem;
struct elem {
    uintptr_t both;
    double data;
};

void elem_store(elem* e, elem* prev, elem* next, double val) {
    (*e) = (elem){
        both = (uintptr_t)prev ^ (uintptr_t)next,
        data = val,
    };
}
</code></pre>
<p>Such a data structure can then be used for elements of a list that can
be traversed consistently forward and backward, but the memory
footprint is only that of a simply-linked list:</p>
<pre><code>elem* elem_next(elem const* e, elem* prev) {
    return (elem*)((uintptr_t)prev ^ e-&amp;gt;both);
}

elem* elem_prev(elem const* e, elem* next) {
    return (elem*)((uintptr_t)next ^ e-&amp;gt;both);
}

</code></pre>
<p>As you can see, besides their names these two functions are completely
identical, and I can’t imagine any compiler being able to track the
origin of a pointer that one of these two functions returns.</p>
<h3>Tracking provenance through integers?</h3>
<p>The fact that in C pointer values are closely related to integers
creates a lot of confusion. In the case of aliasing analysis, the lack
of separation between those terms has it that we have to integrate a
model of information flow of pointer values (or just some bits or
bytes of them) through integers and back to pointer values.</p>
<p>When Peter and Kayvan started their investigations, they had to
consider different possibilities, one of them being to track
information about pointers through such a chain of conversions. It
turned out, that such a model would be possible (they provided a sound
specification for it) but that it would come at an important cost. For
code as for the XOR trick used above a pointer value (the result of a
call to <code>elem_next</code> for example) would have two origins (<code>prev</code> and
<code>next</code> in a call to <code>elem_store</code>) and not only one. Since such
different origins could then accumulate if we do more operations,
basically an integer and a pointer derived from it, could have an
arbitrary number of origins.</p>
<p>Such a model with multiple origins of pointers seemed complicated and
impractical. Complicated for users, because they would have to be
aware that information about pointers could be used in surprising ways
by a sophisticated compiler. Impractical for compilers because keeping
track of all possible in-flow of information would result in a
combinatorial explosion of the state of the abstract machine.</p>
<p>Presented with such a complication, one possibility would have been to
just “forbid” using pointers in that way. We could have stated
something along the lines of “<em>if a pointer has several origins, the
behavior is undefined</em>” and thus leaving everything (the “undefined”
part) to compiler implementations. But because these situation appear
in real life code, this would have left these important parts
non-portable between different compilers and architectures.</p>
<p>So the overall conclusion was not to ban such usage of pointers
through integers, but to formalize it and label such pointers as
<em>exposed</em>, that is that no user has to fear that compilers will
present them with optimization that uses knowledge of such information
flow, and no compiler has the pressure to optimize such code, either.</p>
<h2>The provenance model</h2>
<p>The provenance model that we came up with, and which is at the base of
TS 6010, tries to take all of these aspects into account with the
goal to provide something that at the same time can easily be referred
to by users and compiler implementers. It provides some compromise
between the expectations of the two communities in the sense that it
does not leave all the liberty they might dream of to compiler
providers for optimization, and it still has some sort of complexity
and difficulty for users.</p>
<p>In the following we present the most important parts of that model.</p>
<h3>Storage instance</h3>
<p>As said above, we have to agree upon the granularity of memory
accesses for which aliasing of pointers will be considered. When we
combed through the existing standard (C11 an C17 at the time) we
quickly noticed that there was not even agreement within that
standard. When it talks about what is found at the other end of a
pointer, it talks about “object”, “space”, “memory” or
“storage” and even some combinations of these.</p>
<p>It seemed important to us to emphasize that pointers and addresses are
already an abstraction that does not necessarily denote a physical
device: most modern platforms nowadays form so-called virtual address
spaces. Such “virtual addresses” then are in general transformed by
low-level tools to “physical addresses” that represent concrete memory
hardware. To make that distinction clearer we decided to use the term
“storage” in most places where one of the terms noted above appear.</p>
<p>Another important observation to have is that we even have to talk
about things that do not have an address. For example if we declare a
variable width the <code>register</code> storage class, we cannot receive a
pointer to that object and the whole point is that it is not necessary
for the compiler to realize this variable in the main memory.</p>
<p>Then, the aspect of temporality also comes into play. A chunk of
memory that is obtained for example by a call to <code>malloc</code> can be
returned to the system by calling <code>free</code> and then might again be
served by another call to <code>malloc</code>. It is important that the two
entities to which the pointer refers are seen as completely different
and that the fact that they reside in the same memory location is a
simple coincidence.</p>
<p>For the granularity, we decided to go on the level of maximal region
in which “legally” a C program could operate. Since inside any
allocation or declared object all bytes are reachable by
character-pointer arithmetic, we decided to take this as the level of
granularity. Therefore</p>
<p>&gt; A <em>storage instance</em> is the maximal region of storage that is
&gt; provided by
&gt; – an allocation (<code>malloc</code> and similar),
&gt; – a variable definition,
&gt; – a compound literal, or
&gt; – an object with temporary lifetime.</p>
<p>Note here that the second point talks about the definition of a
variable, not its declaration. For local variables these two coincide,
but for file scope variables (outside any function) there can be
declarations (with <code>extern</code>) that are not definitions. The definition
of a variable is always unique and specifies <em>where</em> it is located,
namely in our terminology here, where the storage instance that
represents it comes to be.</p>
<p>&gt; If a storage instance is addressable, the conversion of a pointer to
&gt; its start to the type <code>unsigned char*</code> points into an array, called
&gt; its <em>byte array</em>, where each element is one byte of the storage
&gt; instance.</p>
<p>By that definition, conversions of pointers to character types and to
<code>void*</code> are defined and it is uniquely prescribed how arithmetic on a
byte level works.</p>
<p>&gt; A storage instance has a lifetime that expands
&gt; – from the allocation (typically <code>malloc</code>) to the deallocation
&gt;   (typically <code>free</code>)
&gt; – from the definition of the variable to the point where the block of the
&gt;   definition left (for a VLA)
&gt; – from the point of entering the block of the definition until it is
&gt;   left (for other variables with automatic storage duration)
&gt; – from the point of entering the innermost block that contains the
&gt;   expression until that scope is left (for compound literals with
&gt;   automatic storage duration)
&gt; – from the start of the program execution until its end (for <code>static</code>
&gt;   objects)
&gt; – from the start of the thread execution until its end (for
&gt;   <code>thread_local</code> objects)
&gt; – during the evaluation of the full expression that contains it (for
&gt;   objects of temporary lifetime).</p>
<p>So in addition to the “where” above, this definition describes <em>when</em>
the storage instance that represents an object comes to be and ceases
to exist.</p>
<p>If you are not familiar with all the concepts in that item list, just
ignore these. The importance here really is to make it clear for the
features that you use in your program and know about, that in general
their lifetime is limited and that any such allocation or definition
gives rise to one single storage instance per context in which the
construct is met.</p>
<p>For example in the following code we see three storage instances in
action</p>
<pre><code>{
    size_t n  = 32;
    double (*A)[n][n] = malloc(sizeof(*A));
    ...
    free(A);
    A = nullptr;
    ...
}
</code></pre>
<p>The two obvious ones are</p>
<ul>
<li>The one for <code>n</code>, a variable of integer type, and for which the
lifetime starts when we enter the block at the <code>{</code> and that ends
when we leave it at <code>}</code>.</li>
<li>The storage instance that is allocated by the call to <code>malloc</code> and
that is deallocated by the call to <code>free</code>.</li>
</ul>
<p>But then there is also a storage instance for the pointer <code>A</code> itself
that, similar to <code>n</code>, lives during the execution of the block. In
particular, after we freed the contents of <code>A</code> we may still access it
to set it to a null pointer value.</p>
<p>For a case where the notion of storage instance is perhaps a bit less
intuitive we note that calls to <code>realloc</code> are a bit peculiar with
respect to that definition. In a call</p>
<pre><code>void* p = realloc(q, 77);
</code></pre>
<p>we first have the storage instance to which <code>q</code> points. Then, if the
call is successful, that old storage instance is released and a
pointer to a new storage instance is stored in <code>p</code>. Even if these two
pointers are identical (possibly the storage instances start a the
same address) they are nevertheless considered as two different
entities.</p>
<p>With the term storage instance immediately comes the notion of
provenance.</p>
<p>&gt; The <em>provenance</em> of a valid pointer value is the storage instance
&gt; into which (or one beyond which) the pointer value points.</p>
<p>With the exception of one particular border case (<a href="#ambiguities" title="Ambiguities">see
below</a>) the provenance of a valid pointer
value is unique.</p>
<h3>Address space</h3>
<p>To be useful in an aliasing model, the concept of an address space is
not provided with enough precision in the current C standard. We need
to talk consistently about addresses, how pointers convert, compare or
relate.</p>
<p>The model we came up with, has the following properties:</p>
<ul>
<li>To each object pointer value corresponds an abstract address that is
a positive integer value.</li>
<li>Bytes within an addressable storage instance have abstract addresses
that increase from start to end.</li>
<li>If the distinct storage instances <em>A</em> and <em>B</em> are alive at a common
point in time, the abstract addresses of all bytes of <em>A</em> are either
all smaller or all greater than the abstract addresses of all bytes
of <em>B</em>.</li>
<li>Two pointer values are equal if they correspond to the same abstract
address.</li>
<li>One pointer value is smaller than another pointer value, if both
point into the same storage instance and if the address of the first
is smaller than the one of the second.</li>
<li>If the platform is able to represent all addresses in some integer
type, the type <code>uintptr_t</code> is provided and a conversion from a
pointer to that type provides the abstract address.</li>
<li>Conversion from pointers to any integer type are consistent with
that mapping to abstract addresses.</li>
</ul>
<p>This model falls short from defining a “flat” address space:</p>
<ul>
<li>Arithmetic on pointers and arithmetic on abstract addresses need not
to be consistent.</li>
<li>Even within the same storage instance, the increase from one byte to
next may not be one, and may not even be uniform.</li>
<li>The type <code>uintptr_t</code> may not exist.</li>
<li>Conversion to integer types that are too narrow has undefined
behavior.</li>
</ul>
<p>The reasons for only having such a lax definition are simple, for each
of the weird properties in the list there are examples that make it
necessary.  In particular, there are platforms with segmented memories
that have “bumps” in the address space, and platforms that pack
additional bits into pointer values that are not related to the
corresponding abstract address.</p>
<h3>Exposure and synthesis of pointer values</h3>
<p>Another observation is crucial for our model: most aliasing analysis
isn’t perfect. That is, compilers as well as programmers have limits
of which tracks of the pointer information they can follow. For
example the XOR trick shows that a pointer value can have several
origins. In all we have to foresee a mechanism that describes the
boundaries of the assumption that a compiler may make on one hand, and
the guarantees that a programmer has to give on the other.</p>
<p>The mechanism with which we came up has two sides</p>
<ul>
<li>A pointer value is <em>exposed</em> if information about its abstract
address or its in-memory representation leaks to the outside or to
distant parts of the program.</li>
<li>A pointer value is <em>synthesized</em> if it is assembled from outside
information, from byte information or from integer values.</li>
</ul>
<p>The goal is to describe that mechanism in a way such that (in
principle) some auxiliary information could be added to each pointer
value that would either allow</p>
<ul>
<li>compilers and users to establish aliasing properties of a set of
pointer values, or</li>
<li>easily come to a consensus for situations for which such analysis is
abandoned an may not be assumed.</li>
</ul>
<h4>Exposure</h4>
<p>Let’s now have a look at a possible normative text as it should be
integrated into the C standard at some point</p>
<p>&gt; A storage instance becomes <em>exposed</em> when a pointer value <code>p</code> of effective
&gt; type <code>T*</code> with this provenance is used in the following contexts:
&gt; – Any byte of the object representation of <code>p</code> is used in an
&gt;   expression.
&gt; – The byte array pointed-to by the first argument of a call to the
&gt;   <code>fwrite</code> library function intersects with an object representation of
&gt;   <code>p</code>.
&gt; – <code>p</code> is converted to an integer.
&gt; – <code>p</code> is used as an argument to a <code>%p</code> conversion specifier of the
&gt;    <code>printf</code> family of library functions.</p>
<p>The idea of the first bullet point is that if we read bytes of the
object representation of a pointer, cascaded <code>if/else</code> control flow
could be used to reconstruct pointers and thus jeopardize any aliasing
analysis.  But what we also didn’t wanted, is that “normal” operations
that programmers do on pointer representations as a whole would have
similar effect as access.</p>
<p>Therefore notice that <code>memcpy</code> or similar functions do not appear in
the list above; as long as we use it to copy pointer representations
as a whole, provenance can simply be transferred.  For example, using
<code>memcpy</code> on structure objects that have pointer members is fine: such
an operation copies the whole pointer without exposing individual
bytes. So we simply assume that the provenance information is
transferred at the same time to the target structure.</p>
<p>We also don’t want that small changes in the way that we look at a
pointer representation has an influence on aliasing
analysis. Therefore we add the following paragraph</p>
<p>&gt; Nevertheless, if the object representation of <code>p</code> is read through an
&gt; lvalue of a pointer type <code>S*</code> that has the same representation and
&gt; alignment requirements as <code>T*</code>, that lvalue has the same provenance
&gt; as <code>p</code> and the provenance does not thereby become exposed.</p>
<p>Here the term “same representation and alignment” covers for example
the possibility to look at</p>
<ul>
<li>a pointer that has different qualifiers than the original,</li>
<li>where one type would be a signed type and the other unsigned, or</li>
<li>one would be a structure and the other would be another structure
that sits at the beginning of the first.</li>
</ul>
<p>Also exposure is meant to be a one-way street, once exposed we will
never know where the information about the pointer could creep into
our program execution.</p>
<p>&gt; Exposure of a storage instance is irreversible and constitutes a
&gt; side effect in the abstract state machine.</p>
<h4>Synthesis</h4>
<p>The inverse operation that uses other information to produce a pointer
looks as follows:</p>
<p>&gt; A pointer value <code>p</code> is synthesized if it is constructed by one of the
&gt; following:
&gt; – Any byte of the object representation of <code>p</code> is changed
&gt;   * by an explicit byte operation,
&gt;   * by type punning with a non-pointer object or with a pointer object
&gt;     that only partially overlaps,
&gt;   * or by a call to <code>memcpy</code> or similar function that does not write
&gt;     the entire pointer representation or where the source object does
&gt;     not have an effective pointer type.
&gt; – The object representation of <code>p</code> intersects with a byte array
&gt;   pointed-to by the first argument of a call to the <code>fread</code> library
&gt;   function.
&gt; – <code>p</code> is converted from an integer value.
&gt; – <code>p</code> is used as an argument to a <code>%p</code> conversion specifier of the
&gt;   <code>scanf</code> family of library functions.</p>
<p>Additionally, we always require that the storage instance that is
synthesized has been exposed before.</p>
<h3>Ambiguities</h3>
<p>With all of that the situation about <a href="#pointer-equality-and-object-life-time">adjacent storage
instances</a> still remains. That
is, a situation where two arrays <code>A</code> and <code>B</code> are adjacent in
memory. Let’s suppose the two arrays have two elements, each, and that
the base type has four bytes:</p>
<table>
<thead>
<tr>
<th><code>A[0]</code></th>
<th><code>A[1]</code></th>
<th><code>B[0]</code></th>
<th><code>B[1]</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a₀ a₁ a₂ a₃</code></td>
<td><code>a₄ a₅ a₆ a₇</code></td>
<td><code>b₀ b₁ b₂ b₃</code></td>
<td><code>b₄ b₅ b₆ b₇</code></td>
</tr>
</tbody>
</table>
<p>When we are taking addresses the following are valid expressions:
<code>&amp;amp;A[2]</code>, which points to the element just after the array <code>A</code>, and
<code>&amp;amp;B[0]</code>, which points to the beginning of <code>B</code>. So if <code>A</code> and <code>B</code> are
adjacent objects, the pointer value of the first expression is exactly
the same as for the second. So both represent different semantics but
with an abstract address that is the same, the byte address of byte
<code>b₀</code>.</p>
<p>So far, so good. Using these pointers with clearly indicated semantics
doesn’t pose a problem for aliasing analysis. In particular in our
model a pointer value as given above always has a unique provenance. A
problem arises only if</p>
<ul>
<li>The storage instance of <code>A</code> and <code>B</code> have both been exposed, by a
conversion to <code>uintptr_t</code>, say.</li>
<li>A pointer <code>Λ</code> is synthesized that corresponds to the byte address of
<code>b₀</code> by converting some <code>uintptr_t</code> value back.</li>
</ul>
<p>Then we are in the dilemma that <code>Λ</code> could have both provenances, that
of <code>A</code> or that of <code>B</code>.</p>
<p>Already from the length of the text that is needed to describe the
situation you might guess that this is a very rare situation, the
easiest remedy against its difficulties is just not to have it in the
first place. But in the case that it arises we have to foresee a
mechanism that is consistent with the model. Since there is generally
no additional information available that could guide the compiler to
see which semantics the programmer meant, the semantics are deduced
from the usage of the pointer value:</p>
<p>&gt; A synthesized pointer value <code>Λ</code> with two possible provenances <code>A</code> or
&gt; <code>B</code> is assumed to have the one provenance among the two that is
&gt; consistent with its use in expressions.</p>
<p>That is for example, if we use <code>Λ</code> in</p>
<ul>
<li><code>Λ[0]</code>, <code>*Λ</code> or <code>Λ+1</code> it is assumed that the provenance is the one
of <code>B</code></li>
<li><code>Λ[-1]</code> or <code>Λ-1</code> it is assumed that the provenance is the one of
<code>A</code>.</li>
</ul>
<p>A use as in <code>Λ+0</code> that has the same value <code>Λ</code> gives no indication of a
direction in which we want to step through the array. So it does not
fix a choice of one provenance or the other. But <code>Λ+1-1</code> which
resolves to <code>(Λ+1)-1</code> has the provenance of <code>B</code> and similarly
<code>Λ-1+1 ≡ (Λ-1)+1</code> has the one of <code>A</code>.</p>
<p>So if and when you have to use that marginal constructs, make sure
that you give clear indications to the compiler into which of the two
storage instance you want to walk.</p>
<h2>Takeaway</h2>
<p>If you were brave enough to follow this article up to here, you
probably deserve some reassuring words such that you are not left
alone with a complicated web of choices and interrelationships between
parts of your code that are impossible to master. In the contrary, our
model provides a very simple method to guarantee sound aliasing
analysis by compilers of your every day code:</p>
<p>&gt; <em>Do not expose pointer values</em> …</p>
<p>… if you can avoid it. And in most cases you can. In particular avoid</p>
<p>&gt; – taking the address of variables (maybe use <code>register</code> to be sure),
&gt; – casts of pointer values to and from integers,
&gt; – accessing individual bytes of pointer targets (AKA coversion to
&gt;   character pointers),
&gt; – conversions of pointer values to any other unrelated pointer type,
&gt; – accessing individual bytes of byte-representations of pointer values,
&gt; – printing pointer values with <code>%p</code> or by using <code>fwrite</code>,
&gt; – using the end address of an array to walk backwards into the array,</p>
<p>and you will be fine.</p>
<p>Obviously, these features are important for C and contribute for a lot of
its power. But you should only use them when (and where) you master
them in all of their consequences. For example, if in the context of
system’s programming you need the XOR trick for your doubly-linked
list, that is fine as long as you are aware, that this might cost you
some other optimization opportunities. Or if you are debugging your
code, printing pointer values with <code>%p</code> can be crucial, but you should
make sure that you disable all traces of such printing when you
compile for production.</p>
<p>Generally, using more modern features of C will help your compiler to
provide you with more efficient and safer executables. For example, in
addition to the above</p>
<ul>
<li>not using pointer parameters on functions when you are only
interested in the value (our <code>recip</code> function is a bad example),</li>
<li>using <code>const</code> qualification wherever you may,</li>
<li>not using casts,</li>
<li>not using integer zero as a null pointer,</li>
<li>using signed and unsigned integer types consistently,</li>
</ul>
<p>all contribute to help your C compiler to do at what it’s best:
nagging you about things that you might have overlooked.</p>


</div></div>
  </body>
</html>
