<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://go.dev/blog/gofix">Original</a>
    <h1>Using go fix to modernize Go code</h1>
    
    
<div id="blog"><div id="content">
  <div id="content">

    <div class="Article" data-slug="/blog/gofix">
    
    <h1 class="small"><a href="/blog/">The Go Blog</a></h1>
    

    <h1>Using go fix to modernize Go code</h1>
      
      <p class="author">
      Alan Donovan<br>
      17 February 2026
      </p>
      
      <div class='markdown'>
<style>
.beforeafter {
  display: grid;
  font-size: 180%;
  grid-template-columns: 1fr 2em 1fr;
  @media screen and (max-width: 57.7rem) {
    grid-template-columns: 1fr;
  }
}
.beforeafter-arrow {
  place-self: center;
}
.beforeafter-arrow::before {
  content: "⟶";
  @media screen and (max-width: 57.7rem) {
    content: "⇓";
  }
}
</style>
<p>The 1.26 release of Go this month includes a completely rewritten go fix subcommand. Go fix uses a suite of algorithms to identify opportunities to improve your code, often by taking advantage of more modern features of the language and library. In this post, we’ll first show you how to use <code>go fix</code> to modernize your Go codebase. Then in the <a href="#go/analysis">second section</a> we’ll dive into the infrastructure behind it and how it is evolving. Finally, we’ll present the theme of <a href="#self-service">“self-service”</a> analysis tools to help module maintainers and organizations encode their own guidelines and best practices.</p>
<!-- see https://go.dev/blog/survey2025#challenges -->
<h2 id="running-go-fix">Running go fix</h2>
<p>The <code>go fix</code> command, like <code>go build</code> and <code>go vet</code>, accepts a set of patterns that denote packages. This command fixes all packages beneath the current directory:</p>
<pre><code>$ go fix ./...
</code></pre>
<p>On success, it silently updates your source files. It discards any fix that touches <a href="https://pkg.go.dev/cmd/go#hdr-Generate_Go_files_by_processing_source" rel="noreferrer" target="_blank">generated files</a> since the appropriate fix in that case is to the logic of the generator itself. We recommend running <code>go fix</code> over your project each time you update your build to a newer Go toolchain release. Since the command may fix hundreds of files, start from a clean git state so that the change consists only of edits from go fix; your code reviewers will thank you.</p>
<p>To preview the changes the above command would have made, use the <code>-diff</code> flag:</p>
<pre><code>$ go fix -diff ./...
--- dir/file.go (old)
+++ dir/file.go (new)
-                       eq := strings.IndexByte(pair, '=')
-                       result[pair[:eq]] = pair[1+eq:]
+                       before, after, _ := strings.Cut(pair, &quot;=&quot;)
+                       result[before] = after
…
</code></pre>
<p>You can list the available fixers by running this command:</p>
<pre><code>$ go tool fix help
…
Registered analyzers:
    any          replace interface{} with any
    buildtag     check //go:build and // +build directives
    fmtappendf   replace []byte(fmt.Sprintf) with fmt.Appendf
    forvar       remove redundant re-declaration of loop variables
    hostport     check format of addresses passed to net.Dial
    inline       apply fixes based on 'go:fix inline' comment directives
    mapsloop     replace explicit loops over maps with calls to maps package
    minmax       replace if/else statements with calls to min or max
…
</code></pre>
<p>Adding the name of a particular analyzer shows its complete documentation:</p>
<pre><code>$ go tool fix help forvar

forvar: remove redundant re-declaration of loop variables

The forvar analyzer removes unnecessary shadowing of loop variables.
Before Go 1.22, it was common to write `for _, x := range s { x := x ... }`
to create a fresh variable for each iteration. Go 1.22 changed the semantics
of `for` loops, making this pattern redundant. This analyzer removes the
unnecessary `x := x` statement.

This fix only applies to `range` loops.
</code></pre>
<p>By default, the <code>go fix</code> command runs all analyzers. When fixing a large project it may reduce the burden of code review if you apply fixes from the most prolific analyzers as separate code changes. To enable only specific analyzers, use the flags matching their names. For example, to run just the <code>any</code> fixer, specify the <code>-any</code> flag. Conversely, to run all the analyzers <em>except</em> selected ones, negate the flags, for instance <code>-any=false</code>.</p>
<p>As with <code>go build</code> and <code>go vet</code>, each run of the <code>go fix</code> command analyzes only a specific build configuration. If your project makes heavy use of files tagged for different CPUs or platforms, you may wish to run the command more than once with different values of <code>GOARCH</code> and <code>GOOS</code> for better coverage:</p>
<pre><code>$ GOOS=linux   GOARCH=amd64 go fix ./...
$ GOOS=darwin  GOARCH=arm64 go fix ./...
$ GOOS=windows GOARCH=amd64 go fix ./...
</code></pre>
<p>Running the command more than once also provides opportunities for synergistic fixes, as we’ll see below.</p>
<h3 id="modernizers">Modernizers</h3>
<p>The introduction of <a href="intro-generics">generics</a> in Go 1.18 marked the end of an era of very few changes to the language spec and the start of a period of more rapid—though still careful—change, especially in the libraries. Many of the trivial loops that Go programmers routinely write, such as to gather the keys of a map into a slice, can now be conveniently expressed as a call to a generic function such as <a href="https://pkg.go.dev/maps#Keys" rel="noreferrer" target="_blank"><code>maps.Keys</code></a>. Consequently these new features create many opportunities to simplify existing code.</p>
<p>In December 2024, during the frenzied adoption of LLM coding assistants, we became aware that such tools tended—unsurprisingly—to produce Go code in a style similar to the mass of Go code used during training, even when there were newer, better ways to express the same idea. Less obviously, the same tools often refused to use the newer ways even when directed to do so in general terms such as “always use the latest idioms of Go 1.25.” In some cases, even when explicitly told to use a feature, the model would deny that it existed. (See my 2025 GopherCon <a href="https://www.youtube.com/watch?v=_VePjjjV9JU&amp;t=3m50s" rel="noreferrer" target="_blank">talk</a> for more exasperating details.) To ensure that future models are trained on the latest idioms, we need to ensure that these idioms are reflected in the training data, which is to say the global corpus of open-source Go code.</p>
<p>Over the past year, we have built <a href="https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize" rel="noreferrer" target="_blank">dozens of analyzers</a> to identify opportunities for modernization. Here are three examples of the fixes they suggest:</p>
<p><strong>minmax</strong> replaces an <code>if</code> statement by a use of Go 1.21’s <code>min</code> or <code>max</code> functions:</p>
<div class="beforeafter">
<pre>
x := f()
if x &lt; 0 {
    x = 0
}
if x > 100 {
    x = 100
}
</pre>
<div class="beforeafter-arrow"></div>
<pre>
x := min(max(f(), 0), 100)
</pre>
</div>
<p><strong>rangeint</strong> replaces a 3-clause <code>for</code> loop by a Go 1.22 <code>range</code>-over-int loop:</p>
<div class="beforeafter">
<pre>
for i := 0; i &lt; n; i++ {
    f()
}
</pre>
<div class="beforeafter-arrow"></div>
<pre>
for range n {
    f()
}
</pre>
</div>
<p><strong>stringscut</strong> (whose <code>-diff</code> output we saw earlier) replaces uses of <code>strings.Index</code> and slicing by Go 1.18’s <code>strings.Cut</code>:</p>
<div class="beforeafter">
<pre>
i := strings.Index(s, ":")
if i >= 0 {
     return s[:i]
}
</pre>
<div class="beforeafter-arrow"></div>
<pre>
before, _, ok := strings.Cut(s, ":")
if ok {
    return before
}
</pre>
</div>
<p>These modernizers are included in <a href="/gopls">gopls</a>, to provide instant feedback as you type, and in <code>go fix</code>, so that you can modernize several entire packages at once in a single command. In addition to making code clearer, modernizers may help Go programmers learn about newer features. As part of the process of approving each new change to the language and standard library, the <a href="https://go.googlesource.com/proposal/+/master/README.md" rel="noreferrer" target="_blank">proposal</a> review group now considers whether it should be accompanied by a modernizer. We expect to add more modernizers with each release.</p>
<h2 id="example-a-modernizer-for-go-126s-newexpr">Example: a modernizer for Go 1.26’s new(expr)</h2>
<p>Go 1.26 includes a small but widely useful change to the language specification. The built-in <code>new</code> function creates a new variable and returns its address. Historically, its sole argument was required to be a type, such as <code>new(string)</code>, and the new variable was initialized to its “zero” value, such as <code>&quot;&quot;</code>. In Go 1.26, the <code>new</code> function may be called with any value, causing it to create a variable initialized to that value, avoiding the need for an additional statement. For example:</p>
<div class="beforeafter">
<pre>
ptr := new(string)
*ptr = "go1.25"
</pre>
<div class="beforeafter-arrow"></div>
<pre>
ptr := new("go1.26")
</pre>
</div>
<p>This feature filled a gap that had been discussed for over a decade and resolved one of the most popular <a href="/issue/45624">proposals</a> for a change to the language. It is especially convenient in code that uses a pointer type <code>*T</code> to indicate an optional value of type <code>T</code>, as is common when working with serialization packages such as <a href="https://pkg.go.dev/encoding/json#Marshal" rel="noreferrer" target="_blank">json.Marshal</a> or <a href="https://protobuf.dev/getting-started/gotutorial/" rel="noreferrer" target="_blank">protocol buffers</a>. This is such a common pattern that people often capture it in a helper, such as the <code>newInt</code> function below, saving the caller from the need to break out of an expression context to introduce additional statements:</p>
<pre><code>type RequestJSON struct {
    URL      string
    Attempts *int  // (optional)
}

data, err := json.Marshal(&amp;RequestJSON{
    URL:      url,
    Attempts: newInt(10),
})

func newInt(x int) *int { return &amp;x }
</code></pre>
<p>Helpers such as <code>newInt</code> are so frequently needed with protocol buffers that the <code>proto</code> API itself provides them as <a href="https://pkg.go.dev/google.golang.org/protobuf/proto#Int64" rel="noreferrer" target="_blank"><code>proto.Int64</code></a>, <a href="https://pkg.go.dev/google.golang.org/protobuf/proto#String" rel="noreferrer" target="_blank"><code>proto.String</code></a>, and so on. But Go 1.26 makes all these helpers unnecessary:</p>
<pre><code>data, err := json.Marshal(&amp;RequestJSON{
    URL:      url,
    Attempts: new(10),
})
</code></pre>
<p>To help you take advantage of this feature, the <code>go fix</code> command now includes a fixer, <a href="https://tip.golang.org/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/modernize/newexpr.go" rel="noreferrer" target="_blank">newexpr</a>, that recognizes “new-like” functions such as <code>newInt</code> and suggests fixes to replace the function body with <code>return new(x)</code> and to replace every call, whether in the same package or an importing package, with a direct use of <code>new(expr)</code>.</p>
<p>To avoid introducing premature uses of new features, modernizers offer fixes only in files that require at least the minimum appropriate version of Go (1.26 in this instance), either through a <a href="/ref/mod#versions"><code>go 1.26</code> directive</a> in the enclosing go.mod file or a <code>//go:build go1.26</code> <a href="https://pkg.go.dev/cmd/go#hdr-Build_constraints" rel="noreferrer" target="_blank">build constraint</a> in the file itself.</p>
<p>Run this command to update all calls of this form in your source tree:</p>
<pre><code>$ go fix -newexpr ./...
</code></pre>
<p>At this point, with luck, all of your <code>newInt</code>-like helper functions will have become unused and may be safely deleted (assuming they aren’t part of a stable published API). A few calls may remain where it would be unsafe to suggest a fix, such as when the name <code>new</code> is locally shadowed by another declaration. You can also use the <a href="deadcode">deadcode</a> command to help identify unused functions.</p>
<h2 id="synergistic-fixes">Synergistic fixes</h2>
<p>Applying one modernization may create opportunities to apply another. For example, this snippet of code, which clamps <code>x</code> to the range 0–100, causes the minmax modernizer to suggest a fix to use <code>max</code>. Once that fix is applied it suggests a second fix, this time to use <code>min</code>.</p>
<div class="beforeafter">
<pre>
x := f()
if x &lt; 0 {
    x = 0
}
if x > 100 {
    x = 100
}
</pre>
<div class="beforeafter-arrow"></div>
<pre>
x := min(max(f(), 0), 100)
</pre>
</div>
<p>Synergies may also occur between different analyzers. For example, a common mistake is to repeatedly concatenate strings within a loop, resulting in quadratic time complexity—a bug and a potential vector for a denial-of-service attack. The <code>stringsbuilder</code> modernizer recognizes the problem and suggests using Go 1.10’s <code>strings.Builder</code>:</p>
<div class="beforeafter">
<pre>
s := ""
for _, b := range bytes {
    s += fmt.Sprintf("%02x", b)
}
use(s)
</pre>
<div class="beforeafter-arrow"></div>
<pre>
var s strings.Builder
for _, b := range bytes {
    s.WriteString(fmt.Sprintf("%02x", b))
}
use(s.String())
</pre>
</div>
<p>Once this fix is applied, a second analyzer may recognize that the <code>WriteString</code> and <code>Sprintf</code> operations can be combined as <code>fmt.Fprintf(&amp;s, &quot;%02x&quot;, b)</code>, which is both cleaner and more efficient, and offer a second fix. (This second analyzer is <a href="https://staticcheck.dev/docs/checks#QF1012" rel="noreferrer" target="_blank">QF1012</a> from Dominik Honnef’s <a href="https://staticcheck.dev/" rel="noreferrer" target="_blank">staticcheck</a>, which is already enabled in gopls but not yet in <code>go fix</code>, though we <a href="/issue/76918">plan</a> to add staticcheck analyzers to the go command starting in Go 1.27.)</p>
<p>Consequently, it may be worth running <code>go fix</code> more than once until it reaches a fixed point; twice is usually enough.</p>
<!-- Aside: The reason the tool does not apply the fixed point iteration itself is that (a) despite our efforts there is a non-zero chance that the transformation breaks the build, preventing most analyzers (those not marked RunDespiteErrors) from running on the second pass, and (b) the transformations in the first round of fixes may add imports for packages whose type information is not available, requiring the “build” to be restarted, which is impossible in many drivers such as Blaze, nogo, Tricorder, etc. Fundamentally this is a consequence of the analysis framework being designed like a distributed build (batch, coarse-grained, distributed pure function) not like an IDE (interactive fine-grained local mutations). -->
<h3 id="merging-fixes-and-conflicts">Merging fixes and conflicts</h3>
<p>A single run of <code>go fix</code> may apply dozens of fixes within the same source file. All fixes are conceptually independent, analogous to a set of git commits with the same parent. The <code>go fix</code> command uses a simple three-way merge algorithm to reconcile the fixes in sequence, analogous to the task of merging a set of git commits that edit the same file. If a fix conflicts with the list of edits accumulated so far, it is discarded, and the tool issues a warning that some fixes were skipped and that the tool should be run again.</p>
<p>This reliably detects <em>syntactic</em> conflicts arising from overlapping edits, but another class of conflict is possible: a <em>semantic</em> conflict occurs when two changes are textually independent but their meanings are incompatible. As an example consider two fixes that each remove the second-to-last use of a local variable: each fix is fine by itself, but when both are applied together the local variable becomes unused, and in Go that’s a compilation error. Neither fix is responsible for removing the variable declaration, but someone has to do it, and that someone is the user of <code>go fix</code>.</p>
<p>A similar semantic conflict arises when a set of fixes causes an import to become unused. Because this case is so common, the <code>go fix</code> command applies a final pass to detect unused imports and remove them automatically.</p>
<p>Semantic conflicts are relatively rare. Fortunately they usually reveal themselves as compilation errors, making them impossible to overlook. Unfortunately, when they happen, they do demand some manual work after running <code>go fix</code>.</p>
<p>Let’s now delve into the infrastructure beneath these tools.</p>
<p><a name='go/analysis'></a></p>
<h2 id="the-go-analysis-framework">The Go analysis framework</h2>
<p>Since the earliest days of Go, the <code>go</code> command has had two subcommands for static analysis, <code>go vet</code> and <code>go fix</code>, each with its own suite of algorithms: “checkers” and “fixers”. A checker reports likely mistakes in your code, such as passing a string instead of an integer as the operand of a <code>fmt.Printf(&quot;%d&quot;)</code> conversion. A fixer safely edits your code to fix a bug or to express the same thing in a better way, perhaps more clearly, concisely, or efficiently. Sometimes the same algorithm appears in both suites when it can both report a mistake and safely fix it.</p>
<p>In 2017 we redesigned the then-monolithic <code>go vet</code> program to separate the checker algorithms (now called “analyzers”) from the “driver”, the program that runs them; the result was the <a href="https://pkg.go.dev/golang.org/x/tools/go/analysis" rel="noreferrer" target="_blank">Go analysis framework</a>. This separation enables an analyzer to be written once then run in a diverse range of drivers for different environments, such as:</p>
<ul>
<li><a href="https://pkg.go.dev/golang.org/x/tools/go/analysis/unitchecker" rel="noreferrer" target="_blank">unitchecker</a>, which turns a suite of analyzers into a subcommand that can be run by the go command’s scalable incremental build system, analogous to a compiler in go build. This is the basis of <code>go fix</code> and <code>go vet</code>.</li>
<li><a href="https://github.com/bazel-contrib/rules_go/blob/master/go/nogo.rst" rel="noreferrer" target="_blank">nogo</a>, the analogous driver for alternative build systems such as Bazel and Blaze.</li>
<li><a href="https://pkg.go.dev/golang.org/x/tools/go/analysis/singlechecker" rel="noreferrer" target="_blank">singlechecker</a>, which turns an analyzer into a standalone command that loads, parses, and type-checks a set of packages (perhaps a whole program) and then analyzes them. We often use it for ad hoc experiments and measurements over the module mirror (<a href="https://proxy.golang.org/" rel="noreferrer" target="_blank">proxy.golang.org</a>) corpus.</li>
<li><a href="https://pkg.go.dev/golang.org/x/tools/go/analysis/multichecker" rel="noreferrer" target="_blank">multichecker</a>, which does the same thing for a suite of analyzers with a ‘swiss-army knife’ CLI.</li>
<li><a href="/gopls">gopls</a>, the <a href="https://microsoft.github.io/language-server-protocol/" rel="noreferrer" target="_blank">language server</a> behind VS Code and other editors, which provides real-time diagnostics from analyzers after each editor keystroke.</li>
<li>the highly configurable driver used by the <a href="https://staticcheck.dev/" rel="noreferrer" target="_blank">staticcheck</a> tool. (Staticcheck also provides a large suite of analyzers that can be run in other drivers.)</li>
<li><a href="https://research.google/pubs/tricorder-building-a-program-analysis-ecosystem/" rel="noreferrer" target="_blank">Tricorder</a>, the batch static analysis pipeline used by Google’s monorepo and integrated with its code review system.</li>
<li>gopls’ <a href="/gopls/features/mcp">MCP server</a>, which makes diagnostics available to LLM-based coding agents, providing more robust “guardrails”.</li>
<li><a href="https://pkg.go.dev/golang.org/x/tools/go/analysis/analysistest" rel="noreferrer" target="_blank">analysistest</a>, the analysis framework’s test harness.</li>
</ul>
<p>One benefit of the framework is its ability to express helper analyzers that don’t report diagnostics or suggest fixes of their own but instead compute some intermediate data structure that may be useful to many other analyzers, amortizing the costs of its construction. Examples include <a href="https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/ctrlflow" rel="noreferrer" target="_blank">control-flow graphs</a>, the <a href="https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/buildssa" rel="noreferrer" target="_blank">SSA representation</a> of function bodies, and data structures for <a href="https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/inspect" rel="noreferrer" target="_blank">optimized AST navigation</a>.</p>
<p>Another benefit of the framework is its support for making deductions across packages. An analyzer can attach a “<a href="https://pkg.go.dev/golang.org/x/tools/go/analysis#hdr-Modular_analysis_with_Facts" rel="noreferrer" target="_blank">fact</a>” to a function or other symbol so that information learned while analyzing the function’s body can be used when later analyzing a call to the function, even if the call appears in another package or the later analysis occurs in a different process. This makes it easy to define scalable interprocedural analyses. For example, the printf checker can tell when a function such as <code>log.Printf</code> is really just a wrapper around <code>fmt.Printf</code>, so it knows that calls to <code>log.Printf</code> should be checked in a similar manner. This process works by induction, so the tool will also check calls to further wrappers around <code>log.Printf</code>, and so on. An example of an analyzer that makes heavy use of facts is <a href="https://github.com/uber-go/nilaway" rel="noreferrer" target="_blank">Uber’s nilaway</a>, which reports potential mistakes resulting in nil pointer dereferences.</p>
<img src="gofix-analysis-facts.svg">
<p>The process of “separate analysis” in <code>go fix</code>  is analogous to the process of separate compilation in <code>go build</code>. Just as the compiler builds packages starting from the bottom of the dependency graph and passing type information up to importing packages, the analysis framework works from the bottom of the dependency graph up, passing facts (and types) up to importing packages.</p>
<p>In 2019, as we started developing <a href="/gopls">gopls</a>, the language server for Go, we added the ability for an analyzer to suggest a <a href="https://pkg.go.dev/golang.org/x/tools/go/analysis#SuggestedFix" rel="noreferrer" target="_blank">fix</a> when reporting a diagnostic. The printf analyzer, for example, offers to replace <code>fmt.Printf(msg)</code> with <code>fmt.Printf(&quot;%s&quot;, msg)</code> to avoid misformatting should the dynamic <code>msg</code> value contain a <code>%</code> symbol. This mechanism has become the basis for many of the quick fixes and refactoring features of gopls.</p>
<p>While all these developments were happening to <code>go vet</code>, <code>go fix</code> remained stuck as it was back before the <a href="/doc/go1compat">Go compatibility promise</a>, when early adopters of Go used it to maintain their code during the rapid and sometimes incompatible evolution of the language and libraries.</p>
<p>The Go 1.26 release brings the Go analysis framework to <code>go fix</code>. The <code>go vet</code> and <code>go fix</code> commands have converged and are now almost identical in implementation. The only differences between them are the criteria for the suites of algorithms they use, and what they do with computed diagnostics. Go <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.26rc1:src/cmd/vet/main.go;l=62" rel="noreferrer" target="_blank">vet analyzers</a> must detect likely mistakes with low false positives; their diagnostics are reported to the user. Go <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.26rc1:src/cmd/fix/main.go;l=46" rel="noreferrer" target="_blank">fix analyzers</a> must generate fixes that are safe to apply without regression in correctness, performance, or style; their diagnostics may not be reported, but the fixes are directly applied. Aside from this difference of emphasis, the task of developing a fixer is no different from that of developing a checker.</p>
<h3 id="improving-analysis-infrastructure">Improving analysis infrastructure</h3>
<p>As the number of analyzers in <code>go vet</code> and <code>go fix</code> continues to grow, we have been investing in infrastructure both to improve the performance of each analyzer and to make it easier to write each new analyzer.</p>
<p>For example, most analyzers start by traversing the syntax trees of each file in the package looking for a particular kind of node such as a range statement or function literal. The existing <a href="https://pkg.go.dev/golang.org/x/tools/go/ast/inspector" rel="noreferrer" target="_blank">inspector</a> package makes this scan efficient by pre-computing a compact index of a complete traversal so that later traversals can quickly skip subtrees that don’t contain any nodes of interest. Recently we extended it with the <a href="https://pkg.go.dev/golang.org/x/tools/go/ast/inspector#Cursor" rel="noreferrer" target="_blank">Cursor</a> datatype to allow flexible and efficient navigation between nodes in all four cardinal directions—up, down, left, and right, similar to navigating the elements of an HTML DOM—making it easy and efficient to express a query such as “find each go statement that is the first statement of a loop body”:</p>
<pre><code>    var curFile inspector.Cursor = ...

    // Find each go statement that is the first statement of a loop body.
    for curGo := range curFile.Preorder((*ast.GoStmt)(nil)) {
        kind, index := curGo.ParentEdge()
        if kind == edge.BlockStmt_List &amp;&amp; index == 0 {
            switch curGo.Parent().ParentEdgeKind() {
            case edge.ForStmt_Body, edge.RangeStmt_Body:
                ...
            }
        }
    }
</code></pre>
<p>Many analyzers start by searching for calls to a specific function, such as <code>fmt.Printf</code>. Function calls are among the most numerous expressions in Go code, so rather than search every call expression and test whether it is a call to <code>fmt.Printf</code>, it is much more efficient to pre-compute an index of symbol references, which is done by <a href="https://pkg.go.dev/golang.org/x/tools/internal/typesinternal/typeindex" rel="noreferrer" target="_blank">typeindex</a> and its <a href="https://pkg.go.dev/golang.org/x/tools@v0.41.0/internal/analysis/typeindex" rel="noreferrer" target="_blank">helper</a> analyzer. Then the calls to <code>fmt.Printf</code> can be enumerated directly, making the cost proportional to the number of calls instead of to the size of the package. For an analyzer such as <a href="https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/hostport" rel="noreferrer" target="_blank">hostport</a> that seeks an infrequently used symbol (<code>net.Dial</code>), this can easily make it <a href="/cl/657958">1,000× faster</a>.</p>
<p>Some other infrastructural improvements over the past year include:</p>
<ul>
<li>a <strong>dependency graph of the standard library</strong> that analyzers can consult to avoid introducing import cycles. For example, we can’t introduce a call to <code>strings.Cut</code> in a package that is itself imported by <code>strings</code>.</li>
<li>support for <strong>querying the effective Go version</strong> of a file as determined by the enclosing go.mod file and build tags, so that analyzers don’t insert uses of features that are “too new”.</li>
<li>a richer <strong>library of refactoring primitives</strong> (e.g. “delete this statement”) that correctly handle adjacent comments and other tricky edge cases.</li>
</ul>
<p>We have come a long way, but there remains much to do. Fixer logic can be tricky to get right. Since we expect users to apply hundreds of suggested fixes with only cursory review, it&rsquo;s critical that fixers are correct even in obscure edge cases. As just one example (see my GopherCon <a href="https://www.youtube.com/watch?v=_VePjjjV9JU&amp;t=13m17s" rel="noreferrer" target="_blank">talk</a> for several more), we built a modernizer that replaces calls such as <code>append([]string{}, slice...)</code> by the clearer <code>slices.Clone(slice)</code> only to discover that, when <code>slice</code> is empty, the result of Clone is nil, a subtle behavior change that in rare cases can cause bugs; so we had to exclude <a href="https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize#hdr-Analyzer_appendclipped" rel="noreferrer" target="_blank">that modernizer</a> from the <code>go fix</code> suite.</p>
<p>Some of these difficulties for authors of analyzers can be ameliorated with better documentation (both for humans and LLMs), particularly checklists of surprising edge cases to consider and test. A pattern-matching engine for syntax trees, similar to those in <a href="https://pkg.go.dev/honnef.co/go/tools/pattern" rel="noreferrer" target="_blank">staticcheck</a> and <a href="https://tree-sitter.github.io/tree-sitter/using-parsers/queries/index.html" rel="noreferrer" target="_blank">Tree Sitter</a>, could simplify the fiddly task of efficiently identifying the locations that need fixing. A richer library of operators for computing accurate fixes would help avoid common mistakes. A better test harness would let us check that fixes don’t break the build, and preserve dynamic properties of the target code. These are all on our roadmap.</p>
<p><a name='self-service'></a></p>
<h2 id="the-self-service-paradigm">The “self-service” paradigm</h2>
<p>More fundamentally, we are turning our attention in 2026 to a “self-service” paradigm.</p>
<p>The <code>newexpr</code> analyzer we saw earlier is a typical modernizer: a bespoke algorithm tailored to a particular feature. The bespoke model works well for features of the language and standard library, but it doesn’t really help update uses of third-party packages. Although there’s nothing to stop you from writing a modernizer for your own public APIs and running it on your own project, there’s no automatic way to get users of your API to run it too. Your modernizer probably wouldn’t belong in gopls or the <code>go vet</code> suite unless your API is particularly widely used across the Go ecosystem. Even in that case you would have to obtain code reviews and approvals and then wait for the next release.</p>
<p>Under the self-service paradigm, Go programmers would be able to define modernizations for their own APIs that their users can apply without all the bottlenecks of the current centralized paradigm. This is especially important as the Go community and global Go corpus are growing much faster than the ability of our team to review analyzer contributions.</p>
<p>The <code>go fix</code> command in Go 1.26 includes a preview of the first fruits of this new paradigm: the <strong>annotation-driven source-level inliner</strong>, which we’ll describe in an upcoming companion blog post next week. In the coming year, we plan to investigate two more approaches within this paradigm.</p>
<!-- TODO(adonovan): update the reference above when this post is ready: [//go:fix inline and source-level inliner](https://docs.google.com/document/d/16n29TcxMnZoEZtIo8BZcz6PSnh2dakWLSaa6UkROIEQ/edit?resourcekey=0-8QYiy7RDd2QbVAgKDOycoQ) -->
<p>First, we will be exploring the possibility of <a href="/issue/59869">dynamically loading</a> modernizers from the source tree and securely executing them, either in gopls or <code>go fix</code>. In this approach a package that provides an API for, say, a SQL database could additionally provide a checker for misuses of the API, such as SQL injection vulnerabilities or failure to handle critical errors. The same mechanism could be used by project maintainers to encode internal housekeeping rules, such as avoiding calls to certain problematic functions or enforcing stronger coding disciplines in critical parts of the code.</p>
<p>Second, many existing checkers can be informally described as “don’t forget to X after you Y!”, such as “close the file after you open it”, “cancel the context after you create it”, “unlock the mutex after you lock it”, “break out of the iterator loop after yield returns false”, and so on. What such checkers have in common is that they enforce certain invariants on all execution paths. We plan to explore generalizations and unifications of these control-flow checkers so that Go programmers can easily apply them to new domains, without complex analytical logic, simply by annotating their own code.</p>
<p>We hope that these new tools will save you effort during maintenance of your Go projects and help you learn about and benefit from newer features sooner. Please try out <code>go fix</code> on your projects and <a href="/issue/new">report</a> any problems you find, and do share any ideas you have for new modernizers, fixers, checkers, or self-service approaches to static analysis.</p>
<!--
Local Variables:
indent-tabs-mode: nil
tab-width: 4
End:
-->
</div>

    </div>

    
    <div class="Article prevnext">
    
    
      
        <p>
        
        
          
            <b>Previous article: </b><a href="/blog/go1.26">Go 1.26 is released</a><br>
          
        
        <b><a href="/blog/all">Blog Index</a></b>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    </div>
    

  </div>
</div>

<script src="/js/play.js"></script>


  </body>
</html>
