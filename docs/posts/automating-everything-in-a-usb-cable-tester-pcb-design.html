<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jitx.com/blog/automating-everything-in-a-usb-cable-tester-pcb-design">Original</a>
    <h1>Automating everything in a USB cable tester PCB design</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>‍</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6044fe74a6d10f725c72398f/646f9d700c11a646efaf883e_project.gif" loading="lazy" alt=""/></p></figure><h4><strong>TL;DR</strong></h4><p>I’m Cayden, an electrical engineer and transhumanist hacker. In this article, I explore the frustrations of repetitive manual tasks in PCB design and the benefits of automation. I demonstrate the automation of tasks such as connecting pins, generating test points and indicator LEDs, programmatically placing components, and autorouting.</p><h2><strong>Introduction</strong></h2><p>If I’m writing a program, I’ll write a function one time, then use that function every time afterwards. Usually, if problems arise over and over again, we solve them once really well, then we don’t solve them again.</p><p>Yet as an electrical engineer designing circuit boards, I often burn a lot of time on repetitive tasks. These tasks can get annoying - they’re something I’d rather automate.</p><p>For example, to design a simple USB-C cable testing board I would have to:</p><p>•	Calculate and source a different current limiting resistor to get the desired brightness for every color of LED.</p><p>•	Type out, size, and place a custom text label that tells me what net each test point belongs to.</p><p>•	Redraw supporting circuitry from scratch every time I reuse a component in a new design.</p><p>•	Recheck datasheets many times as I connect various GPIOs and peripherals.</p><p>It’s annoying to repeat tasks like this, and each piece of manual work carries a little risk of making a mistake. For my first design with JITX, I wanted to see how many of these pains I could automate away, and I wanted to know what design would feel like when I did. Electrical design shouldn’t be death by 1,000 paper cuts. Let’s automate the simplest board possible and see what that does for our experience as designers.</p><blockquote>You can see the full code and design files for this project in the JITX Cookbook: <a href="https://github.com/JITx-Inc/jitx-cookbook">https://github.com/JITx-Inc/jitx-cookbook</a></blockquote><h3><strong>The Project</strong></h3><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6044fe74a6d10f725c72398f/646f90c030250c0195045aea_upload_07623380c4f317ba6b139f2257f4815f.jpg" loading="lazy" alt=""/></p></figure><p>A USB-C cable tester board tests every wire in a USB cable. It has two ports which connect to either end of the same cable. The board sends a voltage through each independent wire in the cable, through an indicator LED, and to ground. If the LED lights up - there is a connection. If it doesn’t light up - no connection.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6044fe74a6d10f725c72398f/646f9c7afdf5d59bb5a516dd_indicator.png" loading="lazy" alt=""/></p><figcaption><strong>Indicator LED Schematic</strong></figcaption></figure><p>‍<br/></p><p>Bad USB cables cause headaches when doing board bring-up - I’ve personally spent hours debugging the UART on an embedded system only to find that the USB cable had a bad data connection. A USB cable tester can indicate the type and health of a USB cable, saving us from this pain.</p><p>I’ve purposefully chosen a simple, easy design as I want to explore PCB design automation, and this will help me focus on trying to automate common, repetitive tasks.</p><h3><strong>Automation TODO</strong></h3><p>What can one automate here? I’ll try:</p><p>1.	Connection of nets to the USB connectors.</p><p>2.	Calculation of 18 LED ballast resistors given a desired color and brightness.</p><p>3.	Naming all 18 test pads.</p><p>4.	Placement</p><p>Let’s do it.</p><h3><strong>How?</strong></h3><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6044fe74a6d10f725c72398f/646f9b66cf29194240c93a16_How.png" loading="lazy" alt=""/></p><figcaption>JITX EDA Tool in VS Code</figcaption></figure><p>I’m going to use JITX to automate these tasks. JITX is a software defined electronics CAD tool. It’s similar to KiCad, Altium, and the other EDA packages, but instead of <em>drawing</em> PCBs, we <em>define</em> PCBs in code. That gives one the ability to turn manual tasks into code.</p><h3><strong>Pin It To Win It - Connecting Pins</strong></h3><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6044fe74a6d10f725c72398f/646f9ca4ce41a9d149799728_Pintowin.png" loading="lazy" alt=""/></p></figure><p>Let’s create two USB connectors and a power net:</p><div><pre><code>
net POWER (power)
...
public inst in-usb : components/USB-C-1054500101/component
public inst out-usb : components/USB-C-1054500101/component
</code></pre></div><p>One side of the USB should be fully connected to our positive voltage rail. Instead of drawing a wire from every pin, let’s just connect them all at once:</p><div><pre><code>
; connect all pins of in-usb to power
net (POWER pins(in-usb))
</code></pre></div><h3><strong>Test Points, Test Points Everywhere</strong></h3><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6044fe74a6d10f725c72398f/646f9b701c72c27102ece619_testpoints.png" loading="lazy" alt=""/></p></figure><p>I’m going to create an indicator LED for every connection in the USB cable, so I’ll start with a text label and test point for each net. In the traditional EDA process, these are made and placed manually. I’ll automate it with a function that identifies the connected net and generates a silk screen label for the test point. This is a general helper function which I’ll write once now and expect to use over and over again in future designs.</p><p>Below, I define a function which makes a test point and places a silk screen label with custom text:</p><div><pre><code>
; place a testpad
defn my-testpoint-strap (tp:JITXObject, tp-name:String, diameter:Double) -&gt; JITXObject:
  inside pcb-module :
    public inst tp-pad : gen-testpad(diameter)
    net (tp-pad.p tp)
    ; name the test point
    value-label(tp-pad) = Text(tp-name, 1.0, W, loc(1.2, 0.0))
    inst my-label : ocdb/artwork/board-text/text(tp-name, 1.0, 0.0)
    place(my-label) at loc(1.2, -0.4, 0.0) on Top (relative-to tp-pad)
    tp-pad
</code>
</pre></div><p>I can call this function in the above loop that generated the LEDs. I have now generated testpoints with custom silk screen labels.</p><div><pre><code>
; add a testpoint for this pin
val test-pad = my-testpoint-strap(IN, net-name, 2.0)
</code>
</pre></div><h3><strong>Next Generation LED Generation</strong></h3><p>To test all the USB connections, the other USB connector must be split into separate nets. I’ll set up those nets:</p><div><pre><code>
; make nets for all of the pins on the usb C that we want to test
for p in pins(out-usb) do : ; for each pin of the USB, we make a net
    make-net-from-pin-name(p)
</code>
</pre></div><p>Each of these nets should then connect to an indicator LED. But first, to help with routing, I can order the nets based on their physical location.</p><div><pre><code>
; get all pins of the USB, and order them based on how they physically appear
val ordered-pins = get-pins-physically-ordered(out-usb)
; convert from ordered list of pins to ordered list of nets
val ordered-nets = map(get-named-net{self, _}, ordered-pins)
</code>
</pre></div><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6044fe74a6d10f725c72398f/646f9cc27b31441eb9bcb2b3_nextgenled.png" loading="lazy" alt=""/></p><figcaption><strong>Routes are made in order of pads&#39; physical location.</strong></figcaption></figure><p>‍<br/></p><p>Routes are made in order of pads’ physical location.</p><p>Now to generate an indicator LED for every USB pin. It’s a common issue for different LEDs on the same board to have vastly different brightnesses, like this:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6044fe74a6d10f725c72398f/646f9e5a2c35a81a8c3874fe_led_tester_1k_cropped_lr.jpg" loading="lazy" alt=""/></p><figcaption><strong>Uneven LED Brightness (Credit: SparkFun)</strong></figcaption></figure><p>‍<br/></p><p>To automate this common task and to make sure I don’t hit the common uneven LED brightness “gotcha”, I define a function called generate-test-led which takes in a color and an input voltage and uses those values to pick an LED and a suitable ballast resistor to achieve a nominal brightness.</p><div><pre><code>
; take a Tuple of pins we want to add status LEDs to, and the GND pin. Add status LEDs and test pins to each of the input pins.
defn generate-test-leds-array (in-pins:Tuple<net>, gnd-pin:JITXObject, voltage:Toleranced) :
  inside pcb-module :
    val colors:Seq<components led-maker-roygb="" led-colors=""> = generate-rainbow(length(in-pins))
    for (in-pin in in-pins, color in colors, place in 0 to false) do :
      ; create test LED and connect it
      inst test-led : generate-test-led(voltage, to-string(ref(in-pin)), color)
      net (in-pin test-led.in)
      net (gnd-pin test-led.out)

    ...
    
; generate an array of test LEDs for each net we just made
generate-test-leds-array(ordered-nets, GND, property(battery.power.vdd.voltage))
</components></net></code>
</pre></div><p>‍</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6044fe74a6d10f725c72398f/646f9daaa2f6385e44a8eb68_other_pic_lr.jpg" loading="lazy" alt=""/></p></figure><h3><strong>Laziness Redefined - Programmatic Placement</strong></h3><p>I now have 18 LEDs, 18 test points, and 18 ballast resistors. If I were to export now and open it in a legacy CAD tool, it’s just a big pile of components:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6044fe74a6d10f725c72398f/646f9dc1612911dea3a75bb8_lazinessredefined1.png" loading="lazy" alt=""/></p></figure><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6044fe74a6d10f725c72398f/646f9dcace41a9d1497aa186_lazinessredefined2.png" loading="lazy" alt=""/></p></figure><p>Usually, the strategy now is to grab every component and manually drag them wherever we want. Or, one might use some basic alignment automation in existing CAD tools, but this still requires manual effort and time.</p><p>Let’s do it better with automation. I can programmatically place components or submodules in code, which happens faster and works better than manual placement. In the for loop where I created the testpoints and LED modules, I can programmatically place anything I want on the board, with a bit of iterative arithmetic each time through the loop:</p><div><pre><code>
val colors:Seq<components led-maker-roygb="" led-colors=""> = generate-rainbow(length(in-pins))
for (in-pin in in-pins, color in colors, place in 0 to false) do :
  ; create test LED and connect it
  inst test-led : generate-test-led(voltage, to-string(ref(in-pin)), color)
  net (in-pin test-led.in)
  net (gnd-pin test-led.out)

  ; place components here
  ...
</components></code>
</pre></div><p>Now everything is automatically placed. Better yet, if I change the LED type, test point size, board size, etc., it doesn’t matter, this will rerun to automatically yield the layout I want. Cheers to laziness!</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6044fe74a6d10f725c72398f/646f9de72d740f4dcd5451b8_lazinessredefined3.png" loading="lazy" alt=""/></p></figure><h3><strong>Routing in Your Sleep</strong></h3><p>JITX has a built in autorouter, which automates a significant amount of the routing process. I can route most of this board in 30 seconds with a couple of clicks:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6044fe74a6d10f725c72398f/646fa5c79169fc94e8676640_JITX_autorouter_20230518_big.gif" loading="lazy" alt=""/></p></figure><p>‍<br/></p><p>Notice these autorouted traces look different than the traces on the physical board. In the first pass of this design, I manually routed everything in an external CAD tool. Afterwards, JITX released an autorouter, so I redid the routing with the autorouter, which is what you see above.</p><h3><strong>Conclusion</strong></h3><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/6044fe74a6d10f725c72398f/646f9d700c11a646efaf883e_project.gif" loading="lazy" alt=""/></p></figure><p>This is some very simple automation, but it does feel a bit magical to have the test points automatically created and properly named. The manual process of creating silk screen text and sliding it around in EDA board tools is always annoying, so I’m glad to have it automated away now and in the future. The LED generation module probably didn’t save me time <em>yet</em>, as I had to write it from scratch, which takes time, but now it exists forever, and I’m looking forward to reusing it many times in the future.</p><p>It’s not all perfect though - one might notice that the LEDs on this board are <strong>bright</strong>. While all of the LEDs were the same brightness - they were all brighter than I’d want. I manually chose 50 mcd as the intensity, and this was way too high. An automation improvement would be to accept an enum of lighting options (e.g. nightime, indoor, outdoor) that could automatically choose the correct intensity for the application.</p></div></div></div>
  </body>
</html>
