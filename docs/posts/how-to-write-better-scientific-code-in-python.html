<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zerowithdot.com/improve-data-science-code/">Original</a>
    <h1>How to write better scientific code in Python?</h1>
    
    <div id="readability-page-1" class="page"><div>
	<main>
		<article>

<time>Feb 14, 2022</time>
            

			<h2 id="introduction">Introduction</h2>
<p>A large part of any scientific effort lies down in writing code.
Be it typical machine-learning modeling, an analysis, or contributing to a data project,
a significant part of the time goes into prototyping new functionalities.
Being exploratory, it is expected that several parts of the program will be 
replaced or modified often beyond what was planned initially.</p>

<p>Unlike for “consumer software”, changes are often induced not by customer’s requirements,
but rather by outcomes of the process along the way.
For this reason, it is extremely valuable to design it in ways,
which will not require a “total reconstruction”, if experimental evidence suggests a different
path.</p>

<p>Writing science code comes with two (additional) specific challenges:
The first one relates to mathematical errors.
Mistakes in computations are often hard to trace, especially when the code is semantically
correct.
No bugs are found.
No exception is raised.
All looks good, but the (numerical) result is wrong.
Especially, with implementing probabilistic models, the results may sometimes look good,
depending on some initial conditions or a random factor.</p>

<p>The second comes from the fact described earlier.
There will always be experimental parts, and they change all the time.
Therefore, the key is to design each component, so that most of the work can stay
and serve as a rock-solid foundation for the next stage of development.</p>

<p>In this article, we focus on patterns that can make the code more robust,
understandable, and overall easier to handle.
You will see how simple improvements can lead to more reusable code and fewer bugs.</p>

<h3 id="toy-task">Toy task</h3>
<p>Our task, for the sake of demonstration, is to calculate the <strong>expected value</strong>
of outcomes of a random process.
Mathematically, it comes down to this formula:</p>



<p>where  is a probability mass function (PMC), or for a continuous variable:</p>



<p>where  is a probability density function (PDF).</p>

<p>As you may wonder, the challenge here is that you want it to work with <em>any</em> distribution:
continuous or discrete.
Or if not plausible, you want at least to recognize the nature of the problem,
so you can adapt the code smoothly.</p>

<h2 id="bad-code---the-starting-point">Bad code - the starting point</h2>
<p>Let’s start with a not-so-good code, to begin with.
Say you want to roll six-sided dice.
With each outcome equally probable, it comes down to calculating the mean value over sampled results.</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td><pre><span>import</span> <span>random</span>
<span>import</span> <span>statistics</span>


<span>def</span> <span>die</span><span>(</span><span>sides</span> <span>=</span> <span>6</span><span>):</span>
    <span>return</span> <span>random</span><span>.</span><span>randint</span><span>(</span><span>1</span><span>,</span> <span>sides</span><span>)</span>

<span>def</span> <span>expected_value</span><span>(</span><span>n_samples</span><span>):</span>
    <span>samples</span> <span>=</span> <span>[</span><span>die</span><span>()</span> <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>n_samples</span><span>)]</span>
    <span>return</span> <span>statistics</span><span>.</span><span>mean</span><span>(</span><span>samples</span><span>)</span></pre></td></tr></tbody></table></code></pre></figure>

<p>What’s wrong with this code?
Several things…</p>

<p>First of all, the <code>die</code> function returns one sample at a time.
It needs to be called <code>N</code> times to get <code>N</code> samples, which is slow.</p>

<p>Secondly, the <code>expected_value</code> function strongly depends on the <code>die</code> function
that produces samples.
It is evident, once you consider using a different die, say a 12-sided one.
With this design, you need to “open” the <code>expected_value</code> to accept an additional
parameter <code>sides</code>, only to pass it on to <code>die</code> to extend it for the more general case.
While this would work, it makes the <em>interface</em> of <code>expected_value</code> unintuitive,
but the solution still relies on using <code>die</code> as the source of samples
thus making it hard to consider other distributions.</p>

<h3 id="remedies">Remedies…</h3>
<p>Let’s consider the options you have:</p>

<h4 id="idea-1">Idea #1</h4>
<p>You can use an external variable to store samples:</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>def</span> <span>expected_value</span><span>(</span><span>samples</span><span>):</span>
    <span>return</span> <span>statistics</span><span>.</span><span>mean</span><span>(</span><span>samples</span><span>)</span>

<span>samples</span> <span>=</span> <span>[</span><span>die</span><span>(</span><span>12</span><span>)</span> <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>n_samples</span><span>)]</span>

<span>ev</span> <span>=</span> <span>expected_value</span><span>(</span><span>samples</span><span>)</span></pre></td></tr></tbody></table></code></pre></figure>

<p>This is pretty obvious, but you just move the problem elsewhere…
Now, <code>samples</code> become a new entity, storage for data (even very large),
and it is quite anonymous.
The <code>expected_value</code> function expects to receive it but to prepare it is on you.</p>

<h4 id="idea-2">Idea #2</h4>
<p>Another way is to keep the <code>die</code> inside, by passing it to <code>expected_value</code> as an object.</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td><pre><span>from</span> <span>functools</span> <span>import</span> <span>partial</span>

<span>twelve_sided_die</span> <span>=</span> <span>partial</span><span>(</span><span>die</span><span>,</span> <span>12</span><span>)</span>

<span>def</span> <span>expected_values</span><span>(</span><span>die</span><span>,</span> <span>n_samples</span><span>):</span>
    <span>samples</span> <span>=</span> <span>[</span><span>die</span><span>()</span> <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>n_samples</span><span>)]</span>
    <span>return</span> <span>statistics</span><span>.</span><span>mean</span><span>(</span><span>samples</span><span>)</span>


<span>ev</span> <span>=</span> <span>expected_values</span><span>(</span><span>twelve_sided_die</span><span>,</span> <span>10000</span><span>)</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The idea uses a prepared “version” of <code>die</code> and makes <code>expected_value</code> use it as the source
of samples.
However, a new problem arises:
The <code>expected_value</code> is only compatible with <code>die</code>.
It can’t compute the result with any other “sample generator”, or at least it is not
guaranteed to do it correctly.</p>

<h4 id="idea-3">Idea #3</h4>
<p>The third idea is to recognize the problem at a more abstract level and design better interfaces.</p>

<p>At the abstract level, we have two concepts:</p>
<ul>
  <li>There exist a <strong>probability distribution</strong> from which we can sample. (It can be a die, a coin, normal distribution - doesn’t matter).</li>
  <li>There is a <strong>mathematical operation</strong> that consumes and transforms data. (E.g. calculating mean, variance, etc.).</li>
</ul>

<p>Let’s give is more attention to how we can build the right abstractions
and how to control their mutual compatibility.</p>

<h2 id="distribution-data">Distribution (Data)</h2>
<p>Mathematically, a probability distribution can be function - continuous or discrete, finite or infinite, from which we can <em>draw samples.</em>
The “prescription” for this function can be very different depending on the problem.
We may use an “existing” formula such as Gaussian or Poisson distribution, but it can also be a “custom” creation derived from e.g. histogram.</p>

<p>With this in mind, let’s establish the following abstraction:</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>from</span> <span>abc</span> <span>import</span> <span>ABC</span><span>,</span> <span>abstractmethod</span>

<span>class</span> <span>Distribution</span><span>(</span><span>ABC</span><span>):</span>
    
    <span>@abstractmethod</span>
    <span>def</span> <span>sample</span><span>(</span><span>self</span><span>):</span>
        <span>...</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="implementation">Implementation</h3>
<p>Due to <code>@abstractmethod</code>, our distribution enforces that we implement <code>sample</code> method to any child class that derives from this abstraction.
For our die, this can be:</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>


<span>class</span> <span>Die</span><span>(</span><span>Distribution</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>sides</span> <span>=</span> <span>6</span><span>):</span>
        <span>self</span><span>.</span><span>sides</span> <span>=</span> <span>sides</span>

    <span>def</span> <span>sample</span><span>(</span><span>self</span><span>,</span> <span>n_samples</span><span>):</span>
        <span>return</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randint</span><span>(</span><span>1</span><span>,</span> <span>self</span><span>.</span><span>sides</span> <span>+</span> <span>1</span><span>,</span> <span>size</span><span>=</span><span>n_samples</span><span>)</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Here, the delivery of samples happens by invoking the method <code>sample</code> that is specific
to tossing a fair die: <code>Die(12).sample(10000)</code>.
Moreover, thanks to <code>numpy</code>, we can create large amounts of data very quickly by
replacing the list comprehension with <code>np.ndarray</code>.</p>

<p>In fact, things can be improved even further.
Currently, calling <code>Die()</code> returns something like this <code>&lt;__main__.Die at 0x7f43f4448400&gt;</code>,
which is not imformative. Aslo <code>Die() == Die()</code> evaluates to <code>False</code>, as for python
they are two different object instances of the same class.
To fix it, we need to implement two more methods:</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre>    <span>def</span> <span>__repr__</span><span>(</span><span>self</span><span>):</span>
        <span>return</span> <span>f</span><span>&#34;{self.__class__.__name__}(sides={self.sides})&#34;</span>

    <span>def</span> <span>__eq__</span><span>(</span><span>self</span><span>,</span> <span>other</span><span>):</span>
        <span>if</span> <span>isinstance</span><span>(</span><span>other</span><span>,</span> <span>self</span><span>.</span><span>__class__</span><span>):</span>
            <span>return</span> <span>self</span><span>.</span><span>sides</span> <span>==</span> <span>other</span><span>.</span><span>sides</span>
        <span>return</span> <span>False</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The <code>__repr__</code> method makes the rendering of the object nice,
and <code>__eq__</code> will only return <code>True</code> if the dice are “equally sided”.</p>

<h3 id="dataclasses">Dataclasses</h3>
<p>Implementing the four methods each time can be tedious.
Besides, the current implementation of <code>Die</code> does not prevent altering of an object, even accidentally, by assigning the attribute to an existing object like this <code>die.sides = 20</code>.</p>

<p>Therefore, we can redefine the <code>Die</code> class using python’s <code>dataclasses</code>.</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>from</span> <span>dataclasses</span> <span>import</span> <span>dataclass</span>


<span>@dataclass</span><span>(</span><span>frozen</span><span>=</span><span>True</span><span>)</span>
<span>class</span> <span>Die</span><span>(</span><span>Distribution</span><span>):</span>
    <span>sides</span><span>:</span> <span>int</span> <span>=</span> <span>6</span>

    <span>def</span> <span>sample</span><span>(</span><span>self</span><span>,</span> <span>n</span><span>):</span>
        <span>return</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randint</span><span>(</span><span>1</span><span>,</span> <span>self</span><span>.</span><span>sides</span> <span>+</span> <span>1</span><span>,</span> <span>size</span><span>=</span><span>n</span><span>)</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The behavior of this example is the same as the one before.
Additionally, setting <code>frozen=True</code>, assigning a new value to <code>die.sides</code> will raise an exception.
If we want a new die, we should create a new object.</p>

<p>Now, our <code>expected_value</code> function will likely take <code>die</code> as a distribution object
and do the math by calling its <code>sample</code> method.</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>def</span> <span>expected_value</span><span>(</span><span>distribution</span><span>,</span> <span>n</span><span>):</span>
    <span>return</span> <span>distribution</span><span>.</span><span>sample</span><span>(</span><span>n</span><span>=</span><span>n</span><span>)</span><span>.</span><span>mean</span><span>()</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="typings">Typings</h3>
<p>The above example is neat.
We know exactly what <code>expected_value</code> does, and it is easy to test.
However, an n-sided die is not the only distribution we may want to calculate the expected
value of.
For example, for the tossing of a coin, the outcomes are not numeric (unless we establish a convention and stick to it).
Naturally, it makes sense to provide some hints as to what interfaces can be used
together and how.</p>

<p>For a <em>dynamically typed</em> language like python, you are not forced to stick to variables’ types.
However, with various IDEs and tools such as <code>mypy</code>, typing can help you spot
potential points of failure and make the code more transparent.</p>

<p>Let’s redefine our classes using <code>typing</code> and create two more specific distributions.</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td><pre><span>from</span> <span>typing</span> <span>import</span> <span>Generic</span><span>,</span> <span>Sequence</span><span>,</span> <span>TypeVar</span>


<span>D</span> <span>=</span> <span>TypeVar</span><span>(</span><span>&#34;D&#34;</span><span>)</span>


<span>class</span> <span>Distribution</span><span>(</span><span>ABC</span><span>,</span> <span>Generic</span><span>[</span><span>D</span><span>]):</span>
    
    <span>@abstractmethod</span>
    <span>def</span> <span>sample</span><span>(</span><span>self</span><span>,</span> <span>n</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>Sequence</span><span>[</span><span>D</span><span>]:</span>
        <span>...</span>


<span>@dataclass</span><span>(</span><span>frozen</span><span>=</span><span>True</span><span>)</span>
<span>class</span> <span>Die</span><span>(</span><span>Distribution</span><span>[</span><span>int</span><span>]):</span>
    <span>sides</span><span>:</span> <span>int</span> <span>=</span> <span>6</span>

    <span>def</span> <span>sample</span><span>(</span><span>self</span><span>,</span> <span>n</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>Sequence</span><span>[</span><span>int</span><span>]:</span>
        <span>return</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randint</span><span>(</span><span>1</span><span>,</span> <span>self</span><span>.</span><span>sides</span> <span>+</span> <span>1</span><span>,</span> <span>size</span><span>=</span><span>n</span><span>)</span>


<span>@dataclass</span><span>(</span><span>frozen</span><span>=</span><span>True</span><span>)</span>
<span>class</span> <span>Coin</span><span>(</span><span>Distribution</span><span>[</span><span>str</span><span>]):</span>
    <span>outcomes</span><span>:</span> <span>tuple</span> <span>=</span> <span>(</span><span>&#34;H&#34;</span><span>,</span> <span>&#34;T&#34;</span><span>)</span>
    <span>fairness</span><span>:</span> <span>float</span> <span>=</span> <span>0.5</span>

    <span>def</span> <span>sample</span><span>(</span><span>self</span><span>,</span> <span>n</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>Sequence</span><span>[</span><span>str</span><span>]:</span>
        <span>p</span> <span>=</span> <span>(</span><span>self</span><span>.</span><span>fairness</span><span>,</span> <span>1.0</span> <span>-</span> <span>self</span><span>.</span><span>fairness</span><span>)</span>
        <span>return</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>choice</span><span>(</span><span>self</span><span>.</span><span>outcomes</span><span>,</span> <span>size</span><span>=</span><span>n</span><span>,</span> <span>p</span><span>=</span><span>p</span><span>)</span>


<span>@dataclass</span><span>(</span><span>frozen</span><span>=</span><span>True</span><span>)</span>
<span>class</span> <span>Gaussian</span><span>(</span><span>Distribution</span><span>[</span><span>float</span><span>]):</span>
    <span>mu</span><span>:</span> <span>float</span> <span>=</span> <span>0.0</span>
    <span>sigma</span><span>:</span> <span>float</span> <span>=</span> <span>1.0</span>

    <span>def</span> <span>sample</span><span>(</span><span>self</span><span>,</span> <span>n</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>Sequence</span><span>[</span><span>float</span><span>]:</span>
        <span>np</span><span>.</span><span>random</span><span>.</span><span>normal</span><span>(</span><span>loc</span><span>=</span><span>self</span><span>.</span><span>mu</span><span>,</span> <span>scale</span><span>=</span><span>self</span><span>.</span><span>sigma</span><span>,</span> <span>size</span><span>=</span><span>n</span><span>)</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Several things that happen here.
Thanks to <code>D = TypeVar(&#34;D&#34;)</code>, we can now define a new variable type, by which
we parametrize each distribution’s type.
You can notice that <code>Distribution</code> inherits not only after the abstract base class
but also after <code>Generic[D]</code>, which turns it also into a new (parametrized) type.
Now, it becomes a sort of identity, constituting a new data type.</p>

<p>Each version of <code>sample</code> is expected to return a sequence of a particular type
that makes sense to each individual distribution’s context.
This way, we have a unified interface that is a also parametrized.
We can use this to ensure the correct behavior of <code>expected_value</code>:</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>def</span> <span>expected_value</span><span>(</span><span>distribution</span><span>:</span> <span>Distribution</span><span>[</span><span>float</span> <span>|</span> <span>int</span><span>],</span> <span>n</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>float</span><span>:</span>
    <span>return</span> <span>distribution</span><span>.</span><span>sample</span><span>(</span><span>n</span><span>=</span><span>n</span><span>)</span><span>.</span><span>mean</span><span>()</span></pre></td></tr></tbody></table></code></pre></figure>

<p>While passing e.g. <code>die = Die()</code> or <code>gaussian = Gaussian()</code> to <code>expected_value</code> will work
(as both <code>int</code> and <code>float</code> are numeric), passing <code>coin = Coin()</code> will be flagged out
by e.g. <code>mypy</code>, stating that</p>

<div><div><pre><code>&gt; error: Argument 1 to &#34;expected_value&#34; has incompatible type &#34;Coin&#34;;
&gt; expected &#34;Distribution[Union[float, int]]&#34;
</code></pre></div></div>

<p>This can give us an early warning before we even run the code.</p>

<h3 id="boosting-up-the-purity">Boosting up the purity</h3>
<p>As you can see, designing interfaces using <code>typing</code> helps to formalize the intensions
and catch bugs early.
You can even bring it to the next level by leveraging 
<code>numpy</code>’s <code>dtype</code>.
This way, you will not only ensure that the different elements fit together, but also
be more conscious regarding the memory footprint of your data.</p>

<p>For example:</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td><pre><span>import</span> <span>numpy.typing</span> <span>as</span> <span>npt</span>


<span>class</span> <span>Distribution</span><span>(</span><span>ABC</span><span>,</span> <span>Generic</span><span>[</span><span>D</span><span>]):</span>
    
    <span>@abstractmethod</span>
    <span>def</span> <span>sample</span><span>(</span><span>self</span><span>,</span> <span>n</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>np</span><span>.</span><span>NDArray</span><span>[</span><span>np</span><span>.</span><span>generic</span><span>]:</span>
        <span>...</span>


<span>class</span> <span>Die</span><span>(</span><span>Distribution</span><span>[</span><span>int</span><span>]):</span>
    <span>sides</span><span>:</span> <span>int</span> <span>=</span> <span>6</span>

    <span>def</span> <span>sample</span><span>(</span><span>self</span><span>,</span> <span>n</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>npt</span><span>.</span><span>NDArray</span><span>[</span><span>np</span><span>.</span><span>uint8</span><span>]:</span>
        <span>return</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randint</span><span>(</span>
            <span>1</span><span>,</span> <span>self</span><span>.</span><span>sides</span> <span>+</span> <span>1</span><span>,</span> <span>size</span><span>=</span><span>n</span><span>,</span> <span>dtype</span><span>=</span><span>np</span><span>.</span><span>uint8</span>
        <span>)</span></pre></td></tr></tbody></table></code></pre></figure>

<p>This way, you will even be informed if the <code>die.sample</code> method returns numbers that
are different than strictly unsigned 8-bit integers.
The question is whether you want to go that deep?
It’s something to think about.</p>

<h2 id="calculations">Calculations</h2>
<p>Let’s come back to designing the calculation part.
So far, we have <code>expected_value</code> that is prepared to work with numerical distributions.
Naturally, we can compute the expected value for <code>Die</code> and <code>Gaussian</code>, but not for <code>Coin</code>.
Not with the current design.</p>

<p>To fix this, have two choices:</p>
<ul>
  <li>We can create a <em>proxy</em> distribution by mapping e.g. <code>(&#34;H&#34;, &#34;T&#34;) -&gt; (0, 1)</code>, or</li>
  <li>We incorporate a mapping within <code>expected_value</code>, giving a possible “adapter”.</li>
</ul>

<p>The first approach creates an artificial body, whose idea relies on convention.
It doesn’t prevent anyone from defining another proxy with <code>(&#34;H&#34;, &#34;T&#34;) -&gt; (1, 0)</code>,
leading to a hard to detect the bug.</p>

<p>Instead, we can modify <code>expected_value</code> and give it a possibility to use custom adapters.</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>def</span> <span>expected_value</span><span>(</span>
    <span>d</span><span>:</span> <span>Distribution</span><span>[</span><span>D</span><span>],</span>
    <span>f</span><span>:</span> <span>Callable</span><span>[[</span><span>D</span><span>],</span> <span>Any</span><span>]</span> <span>=</span> <span>lambda</span> <span>x</span><span>:</span> <span>x</span><span>,</span>
    <span>n</span><span>:</span> <span>int</span> <span>=</span> <span>1000</span>
<span>)</span> <span>-&gt;</span> <span>float</span><span>:</span>
    <span>return</span> <span>np</span><span>.</span><span>mean</span><span>(</span><span>np</span><span>.</span><span>apply_along_axis</span><span>(</span><span>f</span><span>,</span> <span>axis</span><span>=</span><span>0</span><span>,</span> <span>arr</span><span>=</span><span>d</span><span>.</span><span>sample</span><span>(</span><span>n</span><span>)))</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The second argument to <code>expected_value</code> is a callable (a function), that we can optionally
use to translate outcomes of e.g. <code>Coin()</code> distribution.
By default, however, it will leave the outcomes intact.</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>die</span> <span>=</span> <span>Die</span><span>(</span><span>12</span><span>)</span>
<span>expected_values</span><span>(</span><span>die</span><span>,</span> <span>n</span><span>=</span><span>10000</span><span>)</span>

<span>gaussian</span> <span>=</span> <span>Gaussian</span><span>(</span><span>mu</span><span>=</span><span>4.0</span><span>,</span> <span>sigma</span><span>=</span><span>2.0</span><span>)</span>
<span>expected_value</span><span>(</span><span>gaussian</span><span>,</span> <span>n</span><span>=</span><span>100000</span><span>)</span>

<span># but</span>
<span>coin</span> <span>=</span> <span>Coin</span><span>(</span><span>fairness</span><span>=</span><span>0.75</span><span>)</span>
<span>expected_value</span><span>(</span><span>coin</span><span>,</span> <span>f</span><span>=</span><span>lambda</span> <span>x</span><span>:</span> <span>np</span><span>.</span><span>where</span><span>(</span><span>x</span> <span>==</span> <span>&#34;H&#34;</span><span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>))</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Here, we not only avoided creating a proxy distribution but also managed to avoid
tying <code>expected_value</code> to any specific way of converting the data.
The <code>expected_value</code> function does only what it promises to do: computes the expected value.
If any adaptation or conversion is required, it is provided externally.
Note that also here we have an option: we can define a named function (e.g. <code>coin_conversion</code>)
in case we plan to reuse it or stick to <code>lambda</code> when a separate definition does
not add value.</p>

<h3 id="composition-and-iteration">Composition and iteration</h3>
<p>Abstracting away mathematical calculations proves itself useful especially with
designing <em>iterative</em> algorithms.
Oftentimes, aside from the main computations, we have to keep an eye on some
collateral results such as convergence, early stopping (max iterations), metrics, and so on.</p>

<p>Let’s take the  constant for example.
Mathematically, we can get its value by taking the following limit:</p>



<p>The higher  is, the more precise the approximation.</p>

<p>How can we solve it adequately?</p>

<h4 id="not-the-best-way">Not the best way…</h4>
<p>Let’s start with a poor man’s approach with a loop.</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td><pre><span>def</span> <span>approximate_e</span><span>(</span>
    <span>initial_guess</span><span>:</span> <span>float</span><span>,</span>
    <span>max_iter</span><span>:</span> <span>int</span> <span>=</span> <span>10</span><span>,</span>
    <span>epsilon</span><span>:</span> <span>float</span> <span>=</span> <span>0.01</span>
<span>)</span> <span>-&gt;</span> <span>float</span><span>:</span>
    <span>e_value</span> <span>=</span> <span>initial_guess</span>
    <span>for</span> <span>n</span> <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>max_iter</span> <span>+</span> <span>1</span><span>):</span>
        <span>new_e_value</span> <span>=</span> <span>(</span><span>1.0</span> <span>+</span> <span>1.0</span> <span>/</span> <span>n</span><span>)</span> <span>**</span> <span>n</span>
        <span>if</span> <span>abs</span><span>(</span><span>new_e_value</span> <span>-</span> <span>e_value</span><span>)</span> <span>&lt;</span> <span>epsilon</span><span>:</span>
            <span>return</span> <span>new_e_value</span>
        <span>e_value</span> <span>=</span> <span>new_e_value</span>

    <span>return</span> <span>new_e_value</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Again, what’s wrong with this approach?</p>

<p>First of all, the function does three things instead of just one.
Line <code>8.</code> is the absolute essence of the calculation.
Yet, with the early stopping and convergence conditions, we are left with a lot of code
overhead, which is tightly coupled with the actual calculations.
Although the two conditions look like something more generic, if we choose to replace
the subject of the approximation (to a square root for example), we will have to
copy-paste this additional code and make sure it doesn’t break the new algorithm.</p>

<p>Secondly, our only options regarding parametrizing the two conditions are to either
hard-code the values for <code>max_iter</code> and <code>epsilon</code> or allow users to provide them as
arguments.
It spoils the interface and makes testing more difficult.</p>

<p>Finally, the algorithm generates the data “eagerly”.
Instead of focusing on the math and providing values “when asked”, it throws the data
at you.
For large amounts of data, this can cause memory issues.</p>

<h3 id="abstraction-over-calculations">Abstraction over calculations</h3>
<p>Now, let’s address all three problems at once by separating the responsibility between the
different parts.
We have three things:</p>
<ul>
  <li>something that we expect to return us correct numbers (the actual calculations),</li>
  <li>something to stop the process if enough number of iterations pass (early stopping),</li>
  <li>something to stop the process if the values no longer get noticeably improved (convergence).</li>
</ul>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td><pre><span>from</span> <span>typing</span> <span>import</span> <span>Iterator</span>
<span>import</span> <span>itertools</span>


<span>def</span> <span>approximate_e</span><span>()</span> <span>-&gt;</span> <span>Iterator</span><span>[</span><span>float</span><span>]:</span>
    <span>n</span> <span>=</span> <span>1</span>
    <span>while</span> <span>True</span><span>:</span>
        <span>yield</span> <span>(</span><span>1.0</span> <span>+</span> <span>1.0</span> <span>/</span> <span>n</span><span>)</span> <span>**</span> <span>n</span>
        <span>n</span> <span>+=</span> <span>1</span>

<span>def</span> <span>early_stop</span><span>(</span>
    <span>values</span><span>:</span> <span>Iterator</span><span>[</span><span>float</span><span>],</span> <span>max_iter</span><span>:</span> <span>int</span> <span>=</span> <span>100</span>
<span>)</span> <span>-&gt;</span> <span>Iterator</span><span>[</span><span>float</span><span>]:</span>
    <span>return</span> <span>itertools</span><span>.</span><span>islice</span><span>(</span><span>values</span><span>,</span> <span>max_iter</span><span>)</span>

<span>def</span> <span>convergence</span><span>(</span>
    <span>values</span><span>:</span> <span>Iterator</span><span>[</span><span>float</span><span>],</span> <span>epsilon</span><span>:</span> <span>float</span> <span>=</span> <span>0.01</span>
<span>)</span> <span>-&gt;</span> <span>Iterator</span><span>[</span><span>float</span><span>]:</span>
    <span>for</span> <span>a</span><span>,</span> <span>b</span> <span>in</span> <span>itertools</span><span>.</span><span>pairwise</span><span>(</span><span>values</span><span>):</span>
        <span>yield</span> <span>a</span>

        <span>if</span> <span>(</span><span>a</span> <span>-</span> <span>b</span><span>)</span> <span>&lt;</span> <span>epsilon</span><span>:</span>
            <span>break</span></pre></td></tr></tbody></table></code></pre></figure>

<p>This design uses iterators, which implement “lazy” loading.
The data items are only returned one by one when requested (hence the keyword <code>yield</code>).
Thanks to that, we (almost) don’t have to worry about the memory.</p>

<p>Furthermore, each of the three functions can exist separately.
They have their specific interface and can be unit-tested in isolation.</p>

<p>Finally (and most importantly), the final result can be obtaied by <em>chaining</em> them together!</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>values</span> <span>=</span> <span>approximate_e</span><span>()</span>
<span>values</span> <span>=</span> <span>early_stop</span><span>(</span><span>values</span><span>,</span> <span>max_iter</span><span>=</span><span>50</span><span>)</span>
<span>values</span> <span>=</span> <span>convergence</span><span>(</span><span>values</span><span>,</span> <span>epsilon</span><span>=</span><span>0.001</span><span>)</span>

<span>for</span> <span>value</span> <span>in</span> <span>values</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;e becomes:&#34;</span><span>,</span> <span>value</span><span>)</span></pre></td></tr></tbody></table></code></pre></figure>

<h4 id="older-python">Older python</h4>
<p>For python older than 3.10, the <code>itertools.pairwise</code> can be written:</p>

<figure><pre><code data-lang="python"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>def</span> <span>pairwise</span><span>(</span><span>values</span><span>:</span> <span>Iterator</span><span>[</span><span>D</span><span>])</span> <span>-&gt;</span> <span>Iterator</span><span>[</span><span>Tuple</span><span>[</span><span>D</span><span>,</span> <span>D</span><span>]]:</span>
    <span>a</span> <span>=</span> <span>next</span><span>(</span><span>values</span><span>,</span> <span>None</span><span>)</span>
    <span>if</span> <span>a</span> <span>is</span> <span>None</span><span>:</span>
        <span>return</span>
    <span>for</span> <span>b</span> <span>in</span> <span>values</span><span>:</span>
        <span>yield</span> <span>a</span><span>,</span> <span>b</span>
        <span>a</span> <span>=</span> <span>b</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="conclusions">Conclusions</h2>
<p>Scientific programming comes with additional challenges.
It is an exciting discipline, but the number of pitfalls seems to grow at least quadratically
with problem complexity.</p>

<p>In this article, we have discussed two main components that seem to occur again 
and again in every scientific programming task: data and calculations.
Hopefully, by abstracting them in the right way, you can not only increase the
efficiency of your code and reduce bugs but also make coding a much better experience.
For you and your team!</p>


            

		</article>
	</main>
    </div></div>
  </body>
</html>
