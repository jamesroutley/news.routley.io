<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zackoverflow.dev/writing/unsafe-rust-vs-zig/">Original</a>
    <h1>Zig as an alternative to writing unsafe Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
			<article>
				
                <span>3/7/2023</span>
				
				<!-- {pubDate && <time>{pubDate.toString()}</time>} -->
				
				<p>There are endless debates online about Rust vs. Zig, this post explores a side of the argument I don&#39;t think is mentioned enough.</p><hr/>
I was intrigued to learn that the Roc language <a href="https://github.com/roc-lang/roc/blob/main/FAQ.md#why-does-roc-use-both-rust-and-zig">rewrote their standard library from Rust to Zig</a>. What made Zig the better option?
<p>They wrote that they were using a lot of unsafe Rust and it was getting in their way. They also mentioned that Zig had <i>“more tools for working in a memory-unsafe environment, such as reporting memory leaks in tests”</i>, making the overall process much better.</p>
<p>So is Zig a better alternative to writing unsafe Rust?</p>
<p>I wanted to test this myself and see how hard unsafe Rust would be by building a project that required a substantial amount of unsafe code.</p>
<p>Then I would re-write the project in Zig to see if would be easier/better.</p>
<p>After I finished both versions, I found that the Zig implementation was safer, faster, and easier to write. I’ll share a bit about building both and what I learned.</p>

We’ll be writing a bytecode interpreter (or VM) for a programming language that uses mark-sweep <i>garbage collection</i>.
<p>The garbage collection is the important part, it’s hard to make it work <i>and</i> be fast <i>and</i> be safe because its fundamentally a problem that doesn’t play nicely with the borrow checker.</p>
<p>There are two ways I can think of to do it in safe Rust: using reference-counting<sup><a id="footnote-ref-1" href="#footnote-1">1</a></sup> and using arenas+handles<sup><a id="footnote-ref-2" href="#footnote-2">2</a></sup>, but both seem to be slower than a traditional mark/sweep approach<sup><a id="footnote-ref-3" href="#footnote-3">3</a></sup>.</p>
<p>The specific bytecode interpreter implementation is from one of my favorite books: <a href="https://github.com/munificent/craftinginterpreters">Crafting Interpreters</a>. In particular, it’s a stack-based VM for a language that supports functions, closures, classes/instances, etc.</p>
<p>You can view the code for this <a href="https://github.com/zackradisic/rust-vs-zig">here</a>.</p>

Overall, the experience was not great, especially compared to the joy of writing regular safe Rust. I’ll hone in on why that is exactly.

<b>Unsafe Rust is hard</b>. A lot harder than C, this is because unsafe Rust has a lot of nuanced rules about undefined behaviour (UB)  — thanks to the borrow checker — that make it easy to perniciously break things and introduce bugs.
<p>This is because the compiler makes optimizations assuming you’re following its ownership rules. But if you break them, thats considered undefined behaviour, and the compiler chugs along, applying those same optimizations and potentially transforming your code into something dangerous.</p>
<p>To make matters worse, Rust doesn’t fully know what behaviour is considered undefined<sup><a id="footnote-ref-4" href="#footnote-4">4</a></sup>, so you could be writing code that exhibits undefined behaviour without even knowing it.</p>
<p>One way to alleviate this is to use <a href="https://github.com/rust-lang/miri">Miri</a>, it’s an interpreter for Rust’s mid-level intermediate representation that can detect undefined behaviour.</p>
<p>It does its job, but it comes with its own warts<sup><a id="footnote-ref-5" href="#footnote-5">5</a></sup>.</p>
<p>Here’s Miri showing me undefined behaviour:</p>
<p><img src="https://zackoverflow.dev/img/rust-v-zig-miri.png" alt="Miri telling me I did a nono"/></p>

The most challenging source of undefined behaviour I ran into was related to Rust’s aliasing rules.
<p>As mentioned before, Rust leverages its borrowing/ownership rules to make compiler optimizations. If you break these rules, you get undefined behaviour.</p>
<p>So how can I even write this?</p>
<p>The trick is to use <b>raw pointers</b>. They don’t have the same borrowing constraints as regular Rust <b>references</b>, allowing you to side-step the borrow checker.</p>
<p>For example, you can have as many mutable (<code>*mut T</code>) or immutable (<code>*const T</code>) raw pointers as you want.</p>
<p>Then the solution should be easy, right? Not quite.</p>
<p>If you turn a <b>raw pointer</b> into a <b>reference</b> (<code>&amp;mut T</code> or <code>&amp;T</code>), you have to make sure it <b>abides by the rules for that type of reference</b> for the duration of its lifetime. For example a mutable reference cannot exist while other mutable/immutable references exist too.</p>
<pre><code><span><span>fn</span><span> </span><span>do_something</span><span>(value</span><span>:</span><span> </span><span>*mut</span><span> </span><span>Foo</span><span>) {</span></span>
<span><span>    // Turn the raw pointer into a mutable reference</span></span>
<span><span>    </span><span>let</span><span> value_mut_ref</span><span>:</span><span> </span><span>&amp;mut</span><span> </span><span>Foo</span><span> </span><span>=</span><span> value</span><span>.</span><span>as_mut</span><span>()</span><span>.</span><span>unwrap</span><span>();</span></span>
<span></span>
<span><span>    // If I create another ref (mutable or immutable) while the above ref</span></span>
<span><span>    // is alive, that&#39;s undefined behaviour!!</span></span>
<span></span>
<span><span>    // Undefined behaviour!</span></span>
<span><span>    </span><span>let</span><span> value_ref</span><span>:</span><span> </span><span>&amp;</span><span>Foo</span><span> </span><span>=</span><span> value</span><span>.</span><span>as_ref</span><span>()</span><span>.</span><span>unwrap</span><span>();</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>This is really easy to violate. You might make a mutable reference to some data, call some functions, and then like 10 layers deep into the call stack one function might make an immutable reference to that same data, and now you have undefined behaviour. Woo!</p>
<p>Okay, so what if we just avoid making references entirely and only use raw pointers?</p>
<p>Well, the issue with that is raw pointers don’t have the same ergonomics as references. Firstly, you can’t have associated functions that take the <code>self</code> as a raw pointer:</p>
<pre><code><span><span>struct</span><span> </span><span>Class</span><span> {</span></span>
<span><span>    </span><span>/* fields... */</span></span>
<span><span>}</span></span>
<span></span>
<span><span>impl</span><span> </span><span>Class</span><span> {</span></span>
<span><span>    // Regular associated function</span></span>
<span><span>    </span><span>fn</span><span> </span><span>clear_methods</span><span>(</span><span>&amp;mut</span><span> </span><span>self</span><span>) {</span></span>
<span><span>        </span><span>/* ... */</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>fn</span><span> </span><span>clear_methods_raw</span><span>(class</span><span>:</span><span> </span><span>*mut</span><span> </span><span>Class</span><span>) {</span></span>
<span><span>        </span><span>/* ... */</span></span>
<span><span>    }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>unsafe</span><span> </span><span>fn</span><span> </span><span>test</span><span>(class</span><span>:</span><span> </span><span>*mut</span><span> </span><span>Class</span><span>) {</span></span>
<span><span>    </span><span>let</span><span> class_mut_ref</span><span>:</span><span> </span><span>&amp;mut</span><span> </span><span>Class</span><span> </span><span>=</span><span> class</span><span>.</span><span>as_mut</span><span>()</span><span>.</span><span>unwrap</span><span>();</span></span>
<span><span>    // This syntax is nice and ergonomic</span></span>
<span><span>    class_mut_ref</span><span>.</span><span>clear_methods</span><span>();</span></span>
<span></span>
<span><span>    // But with raw pointers you&#39;ll have to just call the function like in C</span></span>
<span><span>    </span><span>Class</span><span>::</span><span>clear_methods_raw</span><span>(class);</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Next, there isn’t any nice pointer derefence syntax like C’s <code>ptr-&gt;field</code>. The code is littered with ugly <code>(*ptr).field</code> everywhere, it’s disgusting.</p>
<p>It really sucks when you have to chain dereferences. Here are two monstrosities I found in the code:</p>
<pre><code><span><span>// The way to make these readable is to create a variable for each dereference,</span></span>
<span><span>// but that&#39;s annoying so in some places I got lazy.</span></span>
<span></span>
<span><span>// ew</span></span>
<span><span>(</span><span>*</span><span>(</span><span>*</span><span>closure</span><span>.</span><span>as_ptr</span><span>())</span><span>.</span><span>upvalues</span><span>.</span><span>as_ptr</span><span>()</span><span>.</span><span>offset</span><span>(i </span><span>as</span><span> </span><span>isize</span><span>)) </span><span>=</span><span> upvalue;</span></span>
<span></span>
<span><span>// ewwwwww</span></span>
<span><span>let</span><span> name </span><span>=</span><span> (</span><span>*</span><span>(</span><span>*</span><span>(</span><span>*</span><span>ptr</span><span>.</span><span>cast</span><span>::</span><span>&lt;</span><span>ObjBoundMethod</span><span>&gt;()</span><span>.</span><span>as_ptr</span><span>())</span><span>.</span><span>method</span><span>.</span><span>as_ptr</span><span>())</span></span>
<span><span>    </span><span>.</span><span>function</span></span>
<span><span>    </span><span>.</span><span>as_ptr</span><span>())</span><span>.</span><span>name;</span></span>
<span></span></code></pre>
<p>Another problem was working with arrays.</p>
<p>If I have a raw pointer to an array of data (<code>*mut T</code>), I can turn it into a slice <code>&amp;mut [T]</code>, and I get to use a <code>for ... in</code> loop on it or any of the handy iterators (<code>.for_each()</code>, <code>.map()</code>, etc.).</p>
<p>But turning it into a <code>&amp;mut [T]</code> basically makes a reference to all the data in the array, so it makes it really easy to violate Rust’s aliasing rules yet again.</p>
<pre><code><span><span>unsafe</span><span> </span><span>fn</span><span> </span><span>do_stuff_with_array</span><span>(values</span><span>:</span><span> </span><span>*mut</span><span> </span><span>Value</span><span>, len</span><span>:</span><span> </span><span>usize</span><span>) {</span></span>
<span><span>    </span><span>let</span><span> values</span><span>:</span><span> </span><span>&amp;mut</span><span> [</span><span>Value</span><span>] </span><span>=</span><span> </span><span>std</span><span>::</span><span>slice</span><span>::</span><span>from_raw_parts_mut</span><span>(values, k);</span></span>
<span><span>    // I can use the ergonomics of iterators!</span></span>
<span><span>    </span><span>for</span><span> val </span><span>in</span><span> values {</span></span>
<span><span>        </span><span>/* ... */</span></span>
<span><span>    }</span></span>
<span><span>    // I just have to make sure none of the Values are turned</span></span>
<span><span>    // into references (mutable or immutable) while the above slice is active...</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Again, the solution is to avoid making references, so in some places I ended up writing regular C-style for-loops on the array raw ptr. But raw pointers suck in comparison to Rust’s slices because you can’t index them and you don’t get out-of-bounds checking.</p>
<pre><code><span><span>pub</span><span> </span><span>struct</span><span> </span><span>Closure</span><span> {</span></span>
<span><span>    upvalues</span><span>:</span><span> </span><span>*mut</span><span> </span><span>Upvalue</span></span>
<span><span>}</span></span>
<span></span>
<span><span>unsafe</span><span> </span><span>fn</span><span> </span><span>cant_index_raw_pointer</span><span>(closure</span><span>:</span><span> </span><span>*mut</span><span> </span><span>Closure</span><span>) {</span></span>
<span><span>    // Can&#39;t do this:</span></span>
<span><span>    </span><span>let</span><span> second_value </span><span>=</span><span> (</span><span>*</span><span>closure</span><span>.</span><span>upvalues)[</span><span>1</span><span>];</span></span>
<span></span>
<span><span>    // Have to do this, and no out-of-bounds checking</span></span>
<span><span>    </span><span>let</span><span> value </span><span>=</span><span> </span><span>*</span><span>(</span><span>*</span><span>closure)</span><span>.</span><span>upvalues</span><span>.</span><span>offset</span><span>(</span><span>1</span><span>);</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Miri uses the <a href="https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md">Stacked Borrows model</a> so it can detect UB related to these aliasing rules mentioned above, but fixing them was challenging.</p>
<p>It felt a lot like when I was learning Rust, there are these rules that exist but I don’t have a solid mental model of them.</p>
<p>I would have to figure out why what I was doing was wrong, then experiment to find a way to fix it. Also note that the feedback loop is way slower because there’s no LSP in my code editor guiding me, I have to recompile the program each time and see Miri’s output.</p>
<p>This really ruined the experience for me. By the end of it I wasn’t really writing Rust, just this weird half-Rust half-C language that was way more error prone and delicate.</p>

After spending a lot of time practicing the dark arts in Rust, I was excited to leave unsafe Rust and learn Zig and start rewriting the project in it.
<p>Apart from not having crazy UB like in unsafe Rust, Zig is a language that understands that you are going to be doing memory-unsafe things, so its designed and optimized around making that experience much better and less error prone. These were some key things that helped:</p>

In Zig, any function that allocates memory must be passed an <code>Allocator</code>.
<p>This was amazing because I made the garbage collector a custom <code>Allocator</code>. Each allocation/deallocation tracked how many bytes were allocated and triggered gargbage collection if needed.</p>
<pre><code><span><span>const</span><span> </span><span>GC</span><span> = </span><span>struct</span><span> {</span></span>
<span><span>    </span><span>// the allocator we wrap over that does</span></span>
<span><span>    </span><span>// the heavy lifting</span></span>
<span><span>    </span><span>inner_allocator</span><span>: </span><span>Allocator</span></span>
<span></span>
<span><span>    </span><span>bytes_allocated</span><span>: </span><span>usize</span></span>
<span></span>
<span><span>    </span><span>// and other fields...</span></span>
<span></span>
<span><span>    </span><span>// `alloc`, `resize`, and `free` are required functions</span></span>
<span><span>    </span><span>// to implement an Allocator</span></span>
<span><span>    </span><span>fn</span><span> </span><span>alloc</span><span>(</span><span>self</span><span>: </span><span>*</span><span>GC</span><span>, </span><span>len</span><span>: </span><span>usize</span><span>, </span><span>ptr_align</span><span>: </span><span>u29</span><span>, </span><span>len_align</span><span>: </span><span>u29</span><span>, </span><span>ret_addr</span><span>: </span><span>usize</span><span>) </span><span>!</span><span>[]</span><span>u8</span><span> {</span></span>
<span><span>        </span><span>// let the inner allocator do the work</span></span>
<span><span>        </span><span>const</span><span> </span><span>bytes</span><span> = </span><span>try</span><span> </span><span>self</span><span>.</span><span>inner_allocator</span><span>.</span><span>rawAlloc</span><span>(</span><span>len</span><span>, </span><span>ptr_align</span><span>, </span><span>len_align</span><span>, </span><span>ret_addr</span><span>);</span></span>
<span></span>
<span><span>        </span><span>// keep track of how much we allocated</span></span>
<span><span>        </span><span>self</span><span>.</span><span>bytes_allocated</span><span> </span><span>+=</span><span> </span><span>bytes</span><span>.</span><span>len</span><span>;</span></span>
<span></span>
<span><span>        </span><span>// collect if we exceed the heap growth factor</span></span>
<span><span>        </span><span>try</span><span> </span><span>self</span><span>.</span><span>collect_if_needed</span><span>();</span></span>
<span></span>
<span><span>        </span><span>return</span><span> </span><span>bytes</span><span>;</span></span>
<span><span>    }</span></span>
<span><span>};</span></span>
<span></span></code></pre>
<p>What I love about this design choice of Zig’s is it makes it frictionless and idiomatic to use different allocation strategies that are optimal for your use-case.</p>
<p>For example, if you know some allocations have a similar and finite lifetime, you can use a super fast bump arena allocation (or linear arena allocation) to speed up your program. This stuff exists in Rust, but it’s not as nice as in Zig<sup><a id="footnote-ref-6" href="#footnote-6">6</a></sup>.</p>

When used, it detects use-after-frees and double-frees. It prints a nice stack trace of when/where the data was allocated, freed, and used.
<pre><code><span><span>// All you have to do is this</span></span>
<span><span>const</span><span> </span><span>alloc</span><span> = </span><span>std</span><span>.</span><span>heap</span><span>.</span><span>GeneralPurposeAllocator</span><span>(.{</span></span>
<span><span>    .</span><span>retain_metadata</span><span> = </span><span>true</span><span>,</span></span>
<span><span>}){};</span></span>
<span></span></code></pre>
<p>This in particular was a life-saver during development.</p>

Most memory safety bugs are null pointer dereferences and out-of-bounds array indexing.
<p>Rust’s raw pointer types are nullable by default and have no null-pointer dereference checking. There is a <a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html">NonNull&lt;T&gt;</a> pointer type that gives you more safety. I’m not sure why it’s not the default, since Rust’s references are non-nullable.</p>
<p>Zig pointers, by default, are non-null and you opt-in to nullability using the <code>?</code> syntax (e.g. <code>?*Value</code>). And of course, you get null pointer dereference checking enabled by default too.</p>
<p>I much prefer this, it makes the default choice the safest.</p>

Zig understands you are going to be working with pointers, so it makes that experience great.
<p>A big problem with the unsafe Rust version was that raw pointers had terrible ergonomics. The syntax for dereferencing was awful, and I couldn’t index raw ptr arrays using the <code>slice[idx]</code> syntax.</p>
<p>Zig’s pointers have the same ergonomics as Rust references, namely that the dot operator doubles as pointer dereferencing:</p>
<pre><code><span><span>fn</span><span> </span><span>do_stuff</span><span>(</span><span>closure</span><span>: </span><span>*</span><span>Closure</span><span>) {</span></span>
<span><span>    </span><span>// This dereferences `closure` to get the</span></span>
<span><span>    </span><span>// `upvalues field`</span></span>
<span><span>    </span><span>const</span><span> </span><span>upvalues</span><span> = </span><span>closure</span><span>.</span><span>upvalues</span><span>;</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Zig also has some additional pointer types that help you disambiguate “pointers to a single value” from “pointers to an array”:</p>
<pre><code><span><span>const</span><span> </span><span>STACK_TOP</span><span> = </span><span>256</span><span>;</span></span>
<span><span>const</span><span> </span><span>VM</span><span> = </span><span>struct</span><span> {</span></span>
<span><span>    </span><span>// pointer to unknown number of items</span></span>
<span><span>    </span><span>stack_top</span><span>: [</span><span>*</span><span>]</span><span>Value</span><span>,</span></span>
<span><span>    </span><span>// like a rust slice:</span></span>
<span><span>    </span><span>// contains a [*]Value + length</span></span>
<span><span>    </span><span>// has bounds checking too</span></span>
<span><span>    </span><span>stack</span><span>: []</span><span>Value</span><span>,</span></span>
<span><span>    </span><span>// alternative to slices when</span></span>
<span><span>    </span><span>// N is a comptime known constant</span></span>
<span><span>    </span><span>stack_alt</span><span>: </span><span>*</span><span>[</span><span>STACK_TOP</span><span>]</span><span>Value</span></span>
<span><span>};</span></span>
<span></span></code></pre>
<p>These support indexing with the <code>array[idx]</code> syntax, while regular pointers (<code>*T</code>) don’t, which is really great for safety.</p>
<p>The cool part is that it’s very easy to convert between the different pointer types:</p>
<pre><code><span><span>fn</span><span> </span><span>conversion_example</span><span>(</span><span>chars</span><span>: [</span><span>*</span><span>]</span><span>u8</span><span>, </span><span>len</span><span>: </span><span>u8</span><span>) []</span><span>Value</span><span> {</span></span>
<span><span>    </span><span>// Converting to a []T is easy:</span></span>
<span><span>    </span><span>var</span><span> </span><span>slice</span><span>: []</span><span>const</span><span> </span><span>u8</span><span> = </span><span>chars</span><span>[</span><span>0</span><span>..</span><span>len</span><span>];</span></span>
<span></span>
<span><span>    </span><span>// And back</span></span>
<span><span>    </span><span>var</span><span> </span><span>ptr</span><span>: [</span><span>*</span><span>]</span><span>u8</span><span> = </span><span>@ptrCast</span><span>([</span><span>*</span><span>]</span><span>u8</span><span>, </span><span>&amp;</span><span>slice</span><span>[</span><span>0</span><span>]);</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>“Traditional” pointers, like the ones you’d see in C/C++, are very error prone.</p>
<p>Rust solves this by adding a facade layer over pointers: its reference types (<code>&amp;T</code> or <code>&amp;mut T</code>). But unfortunately for Rust, its raw pointers still have the same issues as in C/C++.</p>
<p>Zig solves this by simply removing a lot of the footguns from pointers and adding additional guard rails.</p>

Now it’s time for what everyone wants to see, the benchmarks<sup><a id="footnote-ref-7" href="#footnote-7">7</a></sup>.

Here are a few pics of the results, if you want to look at the specific code check out the <a href="https://github.com/zackradisic/rust-vs-zig/tree/master/benchmarks">repo</a>.

<img src="https://zackoverflow.dev/img/rust-v-zig-fib.png" alt="Computing the 35th fibonacci number"/>
<p>Zig is 1.54 ± 0.06 times faster than Rust.</p>

<img src="https://zackoverflow.dev/img/rust-v-zig-method_call.png" alt="Stress testing the instance method calling"/>
<p>Zig is 1.76 ± 0.04 times faster than Rust.</p>

<img src="https://zackoverflow.dev/img/rust-v-zig-string_equality.png" alt="Stress testing string equality"/>
<p>Zig is 1.56 ± 0.05 times faster than Rust.</p>

<img src="https://zackoverflow.dev/img/rust-v-zig-zoo.png" alt="Zoo"/>
<p>Zig is 1.73 ± 0.04 times faster than Rust.</p>

From the benchmarks, the Zig implementation was around 1.56-1.76x faster than Rust. Why is that?
<p>I tried profiling the two, but I didn’t get any useful information out of that.</p>
<p>I think the reason is that in the Rust version there were a few places where I was using indices instead of pointers (for the stack, next instruction, call frame stack, some places for upvalues) because it was too complicated to get them to use pointers and satisfy Miri’s UB checks.</p>
<p>The Zig version uses pointers for those places. So super common operations like manipulating the top of the stack, getting the next instruction, or the current call frame were a simple pointer derefence — while Rust had to do pointer arithmetic.</p>
<p>Keep in mind these operations are happening super frequently in the VM, so these extra ops add up.</p>
<p>I tried refactoring the Rust version, but each time I tried it would take a long time and wouldn’t satisfy Miri’s checks so I gave up after a bit.</p>
<p>If anyone has another idea for why the Rust version is slower or has any ideas on how to speed it up let me know!</p>

Writing a substantial amount of unsafe Rust really sucks the beauty out of the language. I felt like I was either tiptoeing through this broken glass of undefined behaviour, or I was writing in this weird half-Rust/half-C mutated abomination of a language.
<p>The whole point of Rust is to use the borrow checker, but when you frequently need to do something the borrow checker doesn’t like… should you really be using the language?</p>
<p>That aspect of Rust doesn’t seem to be talked about enough when people compare Rust vs. Zig, and definitely should be considered if you’re going to be doing memory-unsafe things for performance.</p>
<p>As someone who loves Rust, I’m definitely going to explore using Zig more for projects. I like the idea of being able choose different memory allocation strategies and the performance opportunities that brings.</p>
<p>While I was writing the Zig version, I took comprehensive notes on my thoughts and feelings learning and using the language. I’ll clean that up and post that as separate blog post.</p>

This 3-part series <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">“What Every C Programmar Should Know About Undefined Behavior”</a> by LLVM’s Chris Lattner, talks more about how compiler optimizations can cause code with undefined behaviour to become unsound.
<p>This <a href="https://doc.rust-lang.org/nomicon/aliasing.html">section from the Rustonomicon</a> gives an example of breaking Rust’s aliasing rules and how a compiler optimization might cause problems.</p>
<p>A <a href="https://ceronman.com/2021/07/22/my-experience-crafting-an-interpreter-with-rust/">post</a> I read 2 years ago by Manuel Cerón inspired the idea for this post.</p>
<p>Checkout <a href="http://journal.stuffwithstuff.com/">Crafting Interpreters</a>, the two interpreters are based on the one from this book.</p>
<p><a href="https://github.com/zackradisic/rust-vs-zig">Here’s</a> the repo containing the code for the Rust and Zig interpreters.</p>
<p>Thanks to <a href="https://mas.to/@calebjasik">Caleb</a>, <a href="https://hachyderm.io/@lovely_danny">Danny</a>, and <a href="https://eatonphil.com/">Phil Eaton</a> for proofreading this post for me.</p>








			</article>
		</div></div>
  </body>
</html>
