<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mattkeeter.com/blog/2022-05-31-xmodem/">Original</a>
    <h1>XMODEM in 2022</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<!-- End header -->







<h2>XMODEM in 2022</h2>
<p>The year is 2022.</p>
<p>How did I find myself writing a new implementation of a <a href="https://en.wikipedia.org/wiki/XMODEM">45-year old protocol</a>?</p>
<h3>Using XMODEM for file transfers</h3>
<p>Let&#39;s start at the beginning:
it all started with me trying to boot a system which receives its
<a href="https://en.wikipedia.org/wiki/Initial_ramdisk">initial ramdisk</a> over XMODEM.</p>
<p>XMODEM is a <em>very</em> simple protocol for sending data over a
<a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication">serial link</a>.
It&#39;s a way to transmit files from a <strong>host</strong> (which is sending the file) to
a <strong>device</strong> (which receives the file).</p>
<p>In this case, the host is my laptop, and the device is an
<a href="https://oxide.computer/product">Oxide Computer Company server sled</a>.</p>
<p>In an XMODEM transfer, the target file is broken up into chunks of a particular
size and sent over the serial link to the device.  After each chunk, the device
replies with an acknowledgement.</p>
<p>Our system is running in 1024-byte mode with 16-bit CRC checksums.
Each packet is therefore 1029 bytes:</p>
<ul>
<li><code>0x02</code> (<code>STX</code>), indicating that we&#39;re sending a 1K block</li>
<li>Block number, starting at 1 (1 byte)</li>
<li>255 - block number (1 byte, used as a primitive checksum)</li>
<li>1024 bytes of data from the file</li>
<li>CRC checksum (2 bytes)</li>
</ul>
<p>This is followed by a single-byte reply from the receiver:</p>
<ul>
<li><code>0x06</code> (<code>ACK</code>) indicating that the packet was received, or <code>0x15</code> (<code>NAK</code>)
if something went wrong.</li>
</ul>
<p>Using XMODEM makes the device bootloader simple, and it&#39;s an old enough standard that
it&#39;s well-supported everywhere.  It&#39;s also <strong>stable</strong>: the recommended tool
for loading the bootloader is <a href="https://www.ohse.de/uwe/software/lrzsz.html"><code>lrzsz</code></a>&#39;s <code>sx</code> executable,
which was last updated in 1998 (and is therefore old enough to drink).</p>
<h3>Getting started</h3>
<p>In theory, it should be simple:</p>
<ul>
<li>Connect the host and device with a serial cable</li>
<li>Open a serial terminal on the host (e.g. <a href="https://linux.die.net/man/8/picocom"><code>picocom</code></a>)</li>
<li>Use the bootloader&#39;s command-line interface to switch into <strong>receive mode</strong></li>
<li>Transfer the ramdisk file with <code>sx</code> (the XMODEM sender from <code>lrzsz</code>).</li>
</ul>
<p>My colleagues using Linux (and occasionally <a href="https://illumos.org/">illumos</a>)
had been booting systems in this way for months; I was the first to attempt
the process on macOS.</p>
<p>As you may have guessed, it didn&#39;t work.</p>
<p>The ramdisk is 64 MB and the serial link is running at 3 MBaud, which means
you&#39;d expect a transfer time of roughly 4 minutes:</p>
<p>$$
\sf
\frac{10\ \frac{\textsf{bits}}{\textsf{byte}}}{3000000\ \frac{\textsf{bits}}{\textsf{sec}}}
\times
64\ \textsf{megabytes} = 223\ \textsf{secs} = 3.7\ \textsf{mins}
$$
(Each byte takes 10 bits because there&#39;s a start and stop bit; this
analysis ignores the overhead due to XMODEM framing and <code>ACK</code>s)</p>
<p>I was seeing performance that trended towards about 20 minutes â€“ and more
importantly, it was hanging partway through the process.</p>
<pre><code>Xmodem sectors/kbytes sent: 53168/6646kRetry 0: Timeout on sector ACK
Xmodem sectors/kbytes sent: 53176/6647kRetry 0: Cancelled

Transfer incomplete

*** exit status: 128 ***
</code></pre>
<p>Sometimes it would make it halfway;
other times, it would fail after only a few megabytes,
but it never succeeded in sending all of the data.</p>
<h3>Failing faster</h3>
<p>The first order of business was to figure out why my system was much
slower than the theoretical performance.  In short, this was due to
implementation details of our USB-to-serial converter chip!</p>
<p>Taking a step back, since very few computers have hardware serial ports in the
modern era, we&#39;re using
<a href="https://ftdichip.com/products/ft4232ha-mini-module/">FTDI&#39;s USB-to-serial modules</a>.
These chips have the notion of a <a href="https://www.ftdichip.com/Support/Knowledgebase/index.html?settingacustomdefaultlaten.htm">&#34;latency timer&#34;</a>,
which determines how long the chip waits before sending an incomplete packet.
By default, this parameter is 16 milliseconds.</p>
<p>XMODEM breaks the data into 65536 packets of 1024 bytes, and reads
<strong>a single byte</strong> (<code>ACK</code>) from the target after each packet.  The internal packet buffer
is larger than 1 byte, so the chip waits for the latency timer period before
transfering this <code>ACK</code> to the host.  This adds 65536 Ã— 16 milliseconds = 17
minutes, which matches the performance I saw!</p>
<p>On Linux, this can be adjusted by writing to the <code>sysfs</code>:</p>
<pre><code>echo 1 &gt; /sys/devices/pci0000:00/.../usb1/1-3/1-3:1.0/ttyUSB0/latency_timer
</code></pre>
<p>My colleagues on Linux were adjusting the latency timer before sending the
ramdisk image, and seeing much more reasonable transfer times.</p>
<p>On macOS, there&#39;s no such functionality.  As it turns out, I&#39;m not the first
person to find
<a href="https://openbci.com/forum/index.php?p=/discussion/3108/ftdi-driver-latency-timer-for-macbook-m1">this</a>
<a href="https://www.ftdicommunity.com/index.php?topic=547.msg2009#msg2009">issue</a>,
but FTDI&#39;s response leaves something to be desired.
In the past, folks were advised to unpack the <code>.kext</code> file and
<a href="https://ftdichip.com/wp-content/uploads/2020/08/TN_105-Adding-Support-for-New-FTDI-Devices-to-Mac-Driver.pdf"><em>manually edit an XML file</em></a>
(ðŸ˜±) to change these parameters.
However, with the rise of signed drivers,
this hack is no longer possible!</p>
<p>In their <a href="https://www.ftdicommunity.com/index.php?topic=547.msg2134#msg2134">final message</a>,
FTDI effectively shrugs and says
&#34;buy a signing certificate from Apple or go look at our low-level drivers,
good luck!&#34;.</p>
<p>I didn&#39;t want to buy a signing certificate, and <em>definitely</em> didn&#39;t want to
use FTDI&#39;s drivers, so I decided to look elsewhere.
Linux is open source (surprise!), so we can see exactly
<a href="https://github.com/torvalds/linux/blob/080eba785fe10ba21c40bbdd80f2bd5331a28be6/drivers/usb/serial/ftdi_sio.c#L1413">what the aforementioned command is doing</a>:</p>
<pre><code>static int write_latency_timer(struct usb_serial_port *port)
{
    /* ... setup elided ... */

    rv = usb_control_msg(udev,
                 usb_sndctrlpipe(udev, 0),
                 FTDI_SIO_SET_LATENCY_TIMER_REQUEST,
                 FTDI_SIO_SET_LATENCY_TIMER_REQUEST_TYPE,
                 l, priv-&gt;interface,
                 NULL, 0, WDR_TIMEOUT);

    /* ... */
}
</code></pre>
<p>It&#39;s just a <a href="https://www.beyondlogic.org/usbnutshell/usb4.shtml#Control">USB control transfer</a>!
We can do that!</p>
<p>Doing the raw transfer myself proved unnecessary:
<a href="https://www.intra2net.com/en/developer/libftdi/"><code>libftdi</code></a>
provides a C API, and is available in <a href="https://brew.sh">Homebrew</a>.
(Looking at the code, <code>libftdi</code> is just <code>libusb</code> in a trench coat, but I
appreciate the slightly higher level of abstraction!)</p>
<p><a href="https://gist.github.com/mkeeter/c43c3990ecdb8dcb6547ac3dbac8e881">97 lines of C later</a>,
I had a program which would adjust the latency timer.</p>
<p>When I ran this program before starting the transfer, it went much faster â€“
and still failed consistently.</p>
<h3>The first rule of debugging embedded communications</h3>
<p>At this point, I admitted (to myself) that I had failed to follow the first
rule of debugging embedded communications problems:</p>
<blockquote>
<p>If something is going wrong, stop messing with software and put a logic
analyzer on the communication lines.</p>
</blockquote>
<p>It&#39;s tempting to skip this step, because poking at software is easier, but
seeing the actual signals is <em>almost always</em> the best way to understand what&#39;s
going on.</p>
<p>I unpacked my <a href="https://usd.saleae.com/products/saleae-logic-pro-8">Saleae logic analyzer</a>
and soldered a few wires to the serial adapter.
The serial link includes four lines (plus ground):</p>
<ul>
<li><code>TX</code> is data sent from the host to the device</li>
<li><code>RX</code> is data sent from the device to the host</li>
<li><code>RTS</code> indicates that the host is ready to receive data</li>
<li><code>CTS</code> indicates that the device is ready to receive data</li>
</ul>
<p>The latter two signals are used for <a href="https://en.wikipedia.org/wiki/Flow_control_(data)#Hardware_flow_control">hardware flow control</a>.
In our traces, <code>RTS</code> and <code>CTS</code> are always low, because the devices are
processing data fast enough to avoid needing flow control.</p>
<p>With everything wired up, I captured an attempted upload while recording all
four serial lines.
As a reminder, here&#39;s what we expect to see in a single 1029-byte packet:</p>
<ul>
<li><code>0x02</code> (<code>STX</code>), indicating that we&#39;re sending a 1K block</li>
<li>Block number, starting at 1 (1 byte)</li>
<li>255 - block number (1 byte, used as a primitive checksum)</li>
<li>1024 bytes of data</li>
<li>CRC checksum (2 bytes)</li>
</ul>
<p>In the logic analyzer&#39;s trace, we can see the start of the first block:</p>
<p><img src="https://www.mattkeeter.com/blog/2022-05-31-xmodem/start.png" alt="Start of the first block"/></p>
<p>As expected, the packet starts with <code>0x02, 0x01, 0xFE</code>, then begins
sending our data (which is all zeros).</p>
<p>Scrolling past the data, we see the end of the block and an <code>ACK</code> (0x06)
from the target device:</p>
<p><img src="https://www.mattkeeter.com/blog/2022-05-31-xmodem/end.png" alt="End of the first block"/></p>
<p>(Since the first block is entirely 0, the two-byte checksum is also 0)</p>
<p>Zooming out, we see our expected 1029-byte packet:</p>
<p><img src="https://www.mattkeeter.com/blog/2022-05-31-xmodem/good.png" alt="Good packet, with 1029 bytes"/></p>
<p>Now, let&#39;s scroll <strong>all the way</strong> to the end of the transmission,
where <code>sx</code> eventually hangs with a timeout.
What do we have here?</p>
<p><img src="https://www.mattkeeter.com/blog/2022-05-31-xmodem/bad.png" alt="Bad packet, with 1024 bytes"/></p>
<p>Well, there&#39;s your problem: my computer stops sending bytes before reaching
the end of the packet!
The bootloader is exonerated: it politely waits 60 seconds, then declares
a timeout and drops back into its command-line interface.</p>
<p>At this point, the issue has been isolated to the sending side of the system:</p>
<ul>
<li><code>picocom</code> invokes <code>sx</code> to send a file</li>
<li><code>sx</code> writes bytes to <code>/dev/tty.usbserial-FT51SYUL</code></li>
<li>macOS sends those bytes to the FTDI chip</li>
</ul>
<p>Because my colleagues are using the same versions of <code>picocom</code> and <code>sx</code>
(on Linux instead of macOS), I <em>mostly</em> trust those two layers of the stack.
The macOS driver is a black box, so I trust it a little less.</p>
<p>The error message from <code>sx</code> also hints that the OS driver is the issue:</p>
<pre><code>Xmodem sectors/kbytes sent: 53168/6646kRetry 0: Timeout on sector ACK
</code></pre>
<p>This suggests that <code>sx</code> has sent all of its bytes and is waiting for the target
device to send an <code>ACK</code> (<code>0x06</code>).  However, the captured data shows that
not all of the bytes have actually gone down the wire!</p>
<h3>Sidestepping the macOS driver</h3>
<p>After all of this debugging,
the actual resolution is somewhat anticlimactic.</p>
<p>Remember <code>libftdi</code> from earlier, which I used to adjust the latency timer?</p>
<p>It turns out that it <em>also</em> exposes functions to send and receive bytes directly,
which lets you sidestep the macOS driver entirely!</p>
<p>Using the <a href="https://crates.io/crates/ftdi"><code>ftdi</code></a> bindings, I wrote a
<a href="https://gist.github.com/mkeeter/509ad699cfac0112944f4b968ce04187">minimal XMODEM sender</a>
in 143 lines of Rust,
including CRC code copied out of <code>lrzsz</code>.</p>
<p>This system <strong>worked reliably</strong>, sending the entire ramdisk with similar
speeds as we were seeing on Linux.</p>
<p>The one downside is that you can&#39;t use this as a sender from <code>picocom</code>, since
the USB device has to be released.</p>
<p>(This is a slightly confounder to the results, since it means <code>picocom</code> <em>could</em>
have been the source of my original issue; it&#39;s unlikely, because my colleagues
were using the same version.  To completely isolate the issue, I&#39;d need to test
using <code>sx</code> without <code>picocom</code>, which I didn&#39;t think of at the time)</p>
<h3>Polishing and releasing</h3>
<p>If you find yourself in a similar situation, I&#39;ve <a href="https://github.com/oxidecomputer/rfsx">released <code>rfsx</code> on Github</a>.</p>
<p>It&#39;s a bit more polished than the Gist above: I discovered the
<a href="https://crates.io/crates/xmodem"><code>xmodem.rs</code> crate</a>,
which implements the core protocol and let me delete a lot of code.
The <code>xmodem.rs</code> API accepts a handle to a <code>Read + Write</code> object,
and does everything else automatically!</p>
<p>(I&#39;m using the <a href="https://github.com/oxidecomputer/xmodem.rs"><code>oxidecomputer/xmodem.rs</code></a>
fork, which has been maintained by colleagues, rather than the version
from <a href="https://crates.io">crates.io</a>)</p>
<p>I also added a snazzy progress bar, command-line flags to select an FTDI device
by VID / PID, and a dummy mode to run without an actual serial link.</p>
<p>Thanks to Keith, Robert, and Cliff for helping debug this issue, and to
<a href="https://dev.to/wesen">Manuel</a> for feedback on this blog post.</p>
<p>If you enjoy this kind of debugging story, also check out
<a href="https://podcasts.apple.com/us/podcast/more-tales-from-the-bringup-lab/id1625932222?i=1000563558130">&#34;More Tales from the Bringup Lab&#34;</a>
from the Oxide and Friends podcast.</p>

<!-- Begin footer -->
</div></div>
  </body>
</html>
