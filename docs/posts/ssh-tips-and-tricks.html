<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://carlosbecker.dev/posts/ssh-tips-and-tricks/">Original</a>
    <h1>SSH Tips and Tricks</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>Since I joined <a href="https://carlosbecker.com/posts/charm/">Charm</a>, I’ve been working
and learning more about SSH, and I thought I would share a few quick tips and
tricks with you.</p>

<p>If you use a Yubikey (you should), you can use it in your remotes by having the
key in a SSH agent and forwarding it.</p>
<p>To manage the agent, I strongly recommend
<a href="https://github.com/FiloSottile/yubikey-agent">yubikey-agent</a>.</p>
<p>You can then forward it in your <code>~/.ssh/config</code> like the following:</p>
<div><pre tabindex="0"><code data-lang="fallback">Host example.org
  ForwardAgent true
</code></pre></div><p>And then, after SSHing you can check its working by running:</p>
<p>Which should list your key.</p>
<p>You might also want to add this to your <code>~/.tmux.conf</code>, so the agent works
properly on reconnect:</p>
<div><pre tabindex="0"><code data-lang="bash"><span>set</span> -g update-environment <span>&#34;DISPLAY SSH_ASKPASS SSH_AGENT_PID SSH_CONNECTION WINDOWID XAUTHORITY&#34;</span>
setenv -g SSH_AUTH_SOCK $HOME/.ssh/ssh_auth_sock
</code></pre></div><p>You’ll also need to create a <code>~/.ssh/rc</code> with the following content in your target machine:</p>
<div><pre tabindex="0"><code data-lang="bash"><span>#!/bin/bash
</span><span></span><span>if</span> <span>test</span> <span>&#34;</span>$SSH_AUTH_SOCK<span>&#34;</span> ; <span>then</span>
  ln -sf $SSH_AUTH_SOCK ~/.ssh/ssh_auth_sock
<span>fi</span>
</code></pre></div><p>SSH runs this file when connecting, and it’ll override a local link to the agent
socket, which we use as our actual <code>SSH_AUTH_SOCK</code> (see the tmux config above).</p>
<p>You can learn more about it by reading <a href="https://blog.testdouble.com/posts/2016-11-18-reconciling-tmux-and-ssh-agent-forwarding/">this blog
post</a>.</p>
<p>By the way, do not enable this to all hosts, as it might be considered insecure,
especially if you are using a shared user.
I only do this on a local server in my home network.</p>

<p>If you connect and disconnect from some machines “a lot”, or, maybe, you’re
using some sort of SSH application or API, you might benefit from keeping a
connection open and reusing it.</p>
<p>You can do so by adding something like this to your <code>~/.ssh/config</code>:</p>
<div><pre tabindex="0"><code data-lang="fallback">Host example.org
  ControlMaster    auto
  ControlPath      ~/.ssh/%r@%h:%p.sock
  ControlPersist   yes
</code></pre></div><p>This will create a Unix Socket at <code>~/.ssh/user@host:port.sock</code>, and use that
connection when it is available.</p>
<p>Eventually the server will close the connection (on its timeout), or you can
force it by running:</p>
<p>You can also force a given max time for a socket to be alive by setting
<code>ControlPersist</code> to a duration instead of <code>yes</code>, e.g. <code>ControlPersist 60s</code>, so
it’ll be kept open for at most 1 minute.</p>
<p>Also worth noting that its not very safe to do this in just about any server you
have access to, especially if you set <code>ControlPath</code> to, say, <code>/tmp</code>.</p>

<p>If you work into a remote machine like I do, its likely you use a multiplexer as
well, like tmux for example.
If that’s the case, you might want to SSH directly into a predefined tmux
session to speed things up.</p>
<p>You can do so by adding something like this to your <code>~/.ssh/config</code>:</p>
<div><pre tabindex="0"><code data-lang="fallback">Host example.org
	RemoteCommand tmux new -A -s default
</code></pre></div><p>This will either attach to or create and attach to a session named <code>default</code>.
This is what I use regularly, and it works like a charm.</p>

<p>If you SSH into a host very often, you might want to have a shorter name for it.</p>
<p>A common way to go around that is with a shell <code>alias</code>, but you can also do so
with pure SSH config.</p>
<p>For instance:</p>
<div><pre tabindex="0"><code data-lang="fallback">Host ex
  HostName example.org
  User foo
  Port 2223
</code></pre></div><p>Will allow you to, instead of typing:</p>
<div><pre tabindex="0"><code data-lang="bash">ssh foo@example.org -p <span>2223</span>
</code></pre></div><p>Type:</p>
<p>Instead.</p>
<p>I particularly use this in conjunction with some previous tips in my
development server, so I can simply <code>ssh dev</code> and get into a tmux session,
with my Yubikey SSH agent forwarded, with a simple command.</p>

<p>I develop some SSH apps using <a href="https://github.com/charmbracelet/wish">Wish</a>, and I usually test them locally
quite a bit.
This might end up cluttering my <code>~/.ssh/known_hosts</code> file, also leading to key
checking errors.</p>
<p>I prevent that by disabling strict key checking and using <code>/dev/null</code> as the
known hosts file on <code>localhost</code>:</p>
<div><pre tabindex="0"><code data-lang="fallback">Host localhost
	UserKnownHostsFile /dev/null
	StrictHostKeyChecking no
</code></pre></div><p>You can use globs in the <code>Host</code> part, so you can, for example, do the same for
your company testing servers or something in that sense.</p>

<p>If the server has a short idle timeout, it might disconnect you sooner than you
wish.
You can prevent that by having your client ping the server every X time.</p>
<p>You can do so by adding something like this to your <code>~/.ssh/config</code>:</p>
<div><pre tabindex="0"><code data-lang="fallback">Host *
	ServerAliveInterval 60
</code></pre></div><p>This will ping the server every 60 seconds for all hosts.</p>

<p>If you access multiple machines in the same TLD, you might want to enable
hostname canonicalization:</p>
<div><pre tabindex="0"><code data-lang="fallback">Host *
  CanonicalizeHostName yes
  CanonicalizeFallbackLocal yes
  CanonicalDomains mytld.foo.bar
</code></pre></div><p>That way, to SSH into <code>host1.mytld.foo.bar</code>, you can simply run:</p>
<p>It might be particularly useful for <code>.local</code>, so you can access other machines
in your network with just their name, without the <code>.local</code> suffix.</p>

<p>If you find it a bit annoying that <a href="https://github.com/FiloSottile/yubikey-agent">yubikey-agent</a> asks you to touch it every
time you do anything with Git, this might be helpful, although it is a bit
against the principles of using a Yubikey.</p>
<p>In any case, here you go:</p>
<div><pre tabindex="0"><code data-lang="fallback">Host github.com
  ControlMaster        auto
  ControlPath          ~/.ssh/github.sock
  ControlPersist       10s
  ServerAliveInterval  0
</code></pre></div><p>This will use the <code>ControlPersist</code> tip we saw earlier, but instead of closing
the connection after the server times it out, we explicitly tell it to last 30
seconds.
We also disable the <code>ServerAliveInterval</code> feature.</p>
<p>So what happens is here:</p>
<ul>
<li>when you do some remote git operation, it’ll open the socket, asking you to
touch the Yubikey</li>
<li>if you do another operation in the next 10 seconds, it will reuse the same
connection</li>
<li>10 seconds after the initial connection, the socket will be closed, and you’ll
have to authenticate again</li>
</ul>
<p>It might be useful when you do a lot of git operations at the same time, e.g.
update Vim plugins.</p>

<p>That’s what I wanted to share today.
Let me know if you have more tips or tricks I forgot to mention or don’t know
about, I’d love to learn them!</p>
<p>Cheers!</p>

    </div></div>
  </body>
</html>
