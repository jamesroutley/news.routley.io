<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2013/11/05/how-to-jit-an-introduction">Original</a>
    <h1>How to JIT – An Introduction</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
    <section id="content">
        <article>
            
            <div>
                
                
        <p>When I wrote the <a href="http://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1/">introductory article for libjit</a>, I aimed it at programmers who know what JITs are, at least to some extent. I did mention what a JIT is, but only very briefly. The purpose of this article is to provide a better introductory overview of JITing, with code samples that don&#39;t rely on any libraries.</p>
<div id="defining-jit">
<h3>Defining JIT</h3>
<p>JIT is simply an acronym for &#34;Just In Time&#34;. That, in itself, doesn&#39;t help much - the term is quite cryptic and seems to have little to do with programming. First, let&#39;s define what &#34;a JIT&#34; actually refers to. I find the following way to think about this useful:</p>
<blockquote>
Whenever a program, while running, creates and runs some new executable code which was not part of the program when it was stored on disk, it’s a JIT.</blockquote>
<p>What about the historical usage of the term &#34;JIT&#34;, though? Luckily, John Aycock from the University of Calgary has written a very interesting paper named &#34;A Brief History of Just-In-Time&#34; (google it, PDFs are available online) looking at JIT techniques from a historical point of view. According to Aycock&#39;s paper, the first mention of code generation and execution during program runtime is apparent as early as McCarthy&#39;s LISP paper from 1960. In later work, such as Thompson&#39;s 1968 regex paper, it was even more apparent (regexes are compiled into machine code and executed on the fly).</p>
<p>The term JIT was first brought into use in computing literature by James Gosling for Java. Aycock mentions that Gosling has borrowed the term from the domain of <a href="http://en.wikipedia.org/wiki/Just_in_time_%28business%29">manufacturing</a> and started using it in the early 1990s.</p>
<p>This is as far as I&#39;ll go into history here. Read the Aycock paper if you&#39;re interested in more details. Let&#39;s now see what the definition quoted above means in practice.</p>
</div>
<div id="jit-create-machine-code-then-run-it">
<h3>JIT - create machine code, then run it</h3>
<p>I think that JIT technology is easier to explain when divided into two distinct phases:</p>
<ul>
<li>Phase 1: create <a href="http://en.wikipedia.org/wiki/Machine_code">machine code</a> at program run-time.</li>
<li>Phase 2: execute that machine code, also at program run-time.</li>
</ul>
<p>Phase 1 is where 99% of the challenges of JITing are. But it&#39;s also the less mystical part of the process, because this is exactly what a compiler does. Well known compilers like <tt>gcc</tt> and <tt>clang</tt> translate C/C++ source code into machine code. The machine code is emitted into an output stream, but it could very well be just kept in memory (and in fact, both <tt>gcc</tt> and <tt>clang/llvm</tt> have building blocks for keeping the code in memory for JIT execution). Phase 2 is what I want to focus on in this article.</p>
</div>
<div id="running-dynamically-generated-code">
<h3>Running dynamically-generated code</h3>
<p>Modern operating systems are picky about what they allow a program to do at runtime. The wild-west days of the past came to an end with the advent of <a href="http://en.wikipedia.org/wiki/Protected_mode">protected mode</a>, which allows an OS to restrict chunks of virtual memory with various permissions. So in &#34;normal&#34; code, you can create new data dynamically on the heap, but <a href="http://en.wikipedia.org/wiki/Executable_space_protection">you can&#39;t just run stuff from the heap</a> without asking the OS to explicitly allow it.</p>
<p>At this point I hope it&#39;s obvious that machine code is just data - a stream of bytes. So, this:</p>
<div><pre><span>unsigned</span> <span>char</span>[] code = {<span>0x48</span>, <span>0x89</span>, <span>0xf8</span>};
</pre></div>
<p>Really depends on the eye of the beholder. To some, it&#39;s just some data that could represent anything. To others, it&#39;s the binary encoding of real, valid x86-64 machine code:</p>

<p>So getting machine code into memory is easy. But how to make it runnable, and then run it?</p>
</div>
<div id="let-s-see-some-code">
<h3>Let&#39;s see some code</h3>
<p>The rest of this article contains code samples for a POSIX-compliant Unix OS (specifically Linux). On other OSes (like Windows) the code would be different in the details, but not in spirit. All modern OSes have convenient APIs to implement the same thing.</p>
<p>Without further ado, here&#39;s how we dynamically create a function in memory and execute it. The function is intentionally very simple, implementing this C code:</p>
<div><pre><span>long</span> <span>add4</span>(<span>long</span> num) {
  <span>return</span> num + <span>4</span>;
}
</pre></div>
<p>Here&#39;s a first try (the full code with a Makefile is available in <a href="https://github.com/eliben/libjit-samples">this repo</a>):</p>
<div><pre><span>#include &lt;stdio.h&gt;</span>
<span>#include &lt;stdlib.h&gt;</span>
<span>#include &lt;string.h&gt;</span>
<span>#include &lt;sys/mman.h&gt;</span>


<span>// Allocates RWX memory of given size and returns a pointer to it. On failure,</span>
<span>// prints out the error and returns NULL.</span>
<span>void</span>* <span>alloc_executable_memory</span>(<span>size_t</span> size) {
  <span>void</span>* ptr = mmap(<span>0</span>, size,
                   PROT_READ | PROT_WRITE | PROT_EXEC,
                   MAP_PRIVATE | MAP_ANONYMOUS, -<span>1</span>, <span>0</span>);
  <span>if</span> (ptr == (<span>void</span>*)-<span>1</span>) {
    perror(<span>&#34;mmap&#34;</span>);
    <span>return</span> <span>NULL</span>;
  }
  <span>return</span> ptr;
}

<span>void</span> <span>emit_code_into_memory</span>(<span>unsigned</span> <span>char</span>* m) {
  <span>unsigned</span> <span>char</span> code[] = {
    <span>0x48</span>, <span>0x89</span>, <span>0xf8</span>,                   <span>// mov %rdi, %rax</span>
    <span>0x48</span>, <span>0x83</span>, <span>0xc0</span>, <span>0x04</span>,             <span>// add $4, %rax</span>
    <span>0xc3</span>                                <span>// ret</span>
  };
  memcpy(m, code, <span>sizeof</span>(code));
}

<span>const</span> <span>size_t</span> SIZE = <span>1024</span>;
<span>typedef</span> <span>long</span> (*JittedFunc)(<span>long</span>);

<span>// Allocates RWX memory directly.</span>
<span>void</span> <span>run_from_rwx</span>() {
  <span>void</span>* m = alloc_executable_memory(SIZE);
  emit_code_into_memory(m);

  JittedFunc func = m;
  <span>int</span> result = func(<span>2</span>);
  printf(<span>&#34;result = %d\n&#34;</span>, result);
}
</pre></div>
<p>The main 3 steps performed by this code are:</p>
<ol>
<li>Use <tt>mmap</tt> to allocate a readable, writable and executable chunk of memory on the heap.</li>
<li>Copy the machine code implementing <tt>add4</tt> into this chunk.</li>
<li>Execute code from this chunk by casting it to a function pointer and calling through it.</li>
</ol>
<p>Note that step 3 can only happen because the memory chunk containing the machine code is <em>executable</em>. Without setting the right permission, that call would result in a runtime error from the OS (most likely a segmentation fault). This would happen if, for example, we allocated <tt>m</tt> with a regular call to <tt>malloc</tt>, which allocates readable and writable, but not executable memory.</p>
</div>
<div id="digression-heap-malloc-and-mmap">
<h3>Digression - heap, malloc and mmap</h3>
<p>Diligent readers may have noticed a half-slip I made in the previous section, by referring to memory returned from <tt>mmap</tt> as &#34;heap memory&#34;. Very strictly speaking, &#34;heap&#34; is a name that designates the memory used by <tt>malloc</tt>, <tt>free</tt> et. al. to manage runtime-allocated memory, as opposed to &#34;stack&#34; which is managed implicitly by the compiler.</p>
<p>That said, it&#39;s not so simple :-) While traditionally (i.e. a long time ago) <tt>malloc</tt> only used one source for its memory (the <tt>sbrk</tt> system call), these days most malloc implementations use <tt>mmap</tt> in many cases. The details differ between OSes and implementations, but often <tt>mmap</tt> is used for the large chunks and <tt>sbrk</tt> for the small chunks. The tradeoffs have to do with the relative efficiency of the two methods of requesting more memory from the OS.</p>
<p>So calling memory provided by <tt>mmap</tt> &#34;heap memory&#34; is not a mistake, IMHO, and that&#39;s what I intend to keep on doing.</p>
</div>
<div id="caring-more-about-security">
<h3>Caring more about security</h3>
<p>The code shown above has a problem - it&#39;s a security hole. The reason is the RWX (Readable, Writable, eXecutable) chunk of memory it allocates - a paradise for attacks and exploits. So let&#39;s be a bit more responsible about it. Here&#39;s some slightly modified code:</p>
<div><pre><span>// Allocates RW memory of given size and returns a pointer to it. On failure,</span>
<span>// prints out the error and returns NULL. Unlike malloc, the memory is allocated</span>
<span>// on a page boundary so it&#39;s suitable for calling mprotect.</span>
<span>void</span>* <span>alloc_writable_memory</span>(<span>size_t</span> size) {
  <span>void</span>* ptr = mmap(<span>0</span>, size,
                   PROT_READ | PROT_WRITE,
                   MAP_PRIVATE | MAP_ANONYMOUS, -<span>1</span>, <span>0</span>);
  <span>if</span> (ptr == (<span>void</span>*)-<span>1</span>) {
    perror(<span>&#34;mmap&#34;</span>);
    <span>return</span> <span>NULL</span>;
  }
  <span>return</span> ptr;
}

<span>// Sets a RX permission on the given memory, which must be page-aligned. Returns</span>
<span>// 0 on success. On failure, prints out the error and returns -1.</span>
<span>int</span> <span>make_memory_executable</span>(<span>void</span>* m, <span>size_t</span> size) {
  <span>if</span> (mprotect(m, size, PROT_READ | PROT_EXEC) == -<span>1</span>) {
    perror(<span>&#34;mprotect&#34;</span>);
    <span>return</span> -<span>1</span>;
  }
  <span>return</span> <span>0</span>;
}

<span>// Allocates RW memory, emits the code into it and sets it to RX before</span>
<span>// executing.</span>
<span>void</span> <span>emit_to_rw_run_from_rx</span>() {
  <span>void</span>* m = alloc_writable_memory(SIZE);
  emit_code_into_memory(m);
  make_memory_executable(m, SIZE);

  JittedFunc func = m;
  <span>int</span> result = func(<span>2</span>);
  printf(<span>&#34;result = %d\n&#34;</span>, result);
}
</pre></div>
<p>It&#39;s equivalent to the earlier snippet in all respects except one: the memory is first allocated with RW permissions (just like a normal <tt>malloc</tt> would do). This is all we really need to write our machine code into it. When the code is there, we use <tt>mprotect</tt> to change the chunk&#39;s permission from RW to RX, making it executable but <em>no longer writable</em>. So the effect is the same, but at no point in the execution of our program the chunk is both writable and executable, which is good from a security point of view.</p>
</div>
<div id="what-about-malloc">
<h3>What about malloc?</h3>
<p>Could we use <tt>malloc</tt> instead of <tt>mmap</tt> for allocating the chunk in the previous snippet? After all, RW memory is exactly what <tt>malloc</tt> provides. Yes, we could. However, it&#39;s more trouble than it&#39;s worth, really. The reason is that protection bits can only be set on virtual memory page boundaries. Therefore, had we used <tt>malloc</tt> we&#39;d have to manually ensure that the allocation is aligned at a page boundary. Otherwise, <tt>mprotect</tt> could have unwanted effects from failing to enabling/disabling more than actually required. <tt>mmap</tt> takes care of this for us by only allocating at page boundaries (because <tt>mmap</tt>, by design, maps whole pages).</p>
</div>
<div id="tying-loose-ends">
<h3>Tying loose ends</h3>
<p>This article started with a high-level overview of what we mean when we say JIT, and ended with hands-on code snippets that show how to dynamically emit machine code into memory and execute it.</p>
<p>The technique shown here is pretty much how real JIT engines (e.g. LLVM and libjit) emit and run executable machine code from memory. What remains is just a &#34;simple&#34; matter of synthesizing that machine code from something else.</p>
<p>LLVM has a full compiler available, so it can actually translate C and C++ code (through LLVM IR) to machine code at runtime, and then execute it. libjit picks the ball up at a much lower level - it can serve as a backend for a compiler. In fact, <a href="http://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1/">my introductory article on libjit</a> already demonstrates how to emit and run non-trivial code with libjit. But JITing is a more general concept. Emitting code at run-time can be done for <a href="http://pyevolve.sourceforge.net/wordpress/?p=914">data structures</a>, <a href="http://sljit.sourceforge.net/">regular expressions</a>  and even <a href="http://luajit.org/ext_ffi.html">accessing C from language VMs</a>. Digging in my blog&#39;s archives helped me find a mention of some <a href="http://eli.thegreenplace.net/2005/09/04/cool-hack-creating-custom-subroutines-on-the-fly-in-perl/">JITing I did 8 years ago</a>. That was Perl code generating more Perl code at run-time (from a XML description of a serialization format), but the idea is the same.</p>
<p>This is why I felt that splitting the JITing concept into two phases is important. For phase 2 (which was explained in this article), the implementation is relatively obvious and uses well defined OS APIs. For phase 1, the possibilites are endless and what you do ultimately depends on the application you&#39;re developing.</p>
</div>

    
            </div>
            <!-- /.entry-content -->
<hr/>
<p>
For comments, please send me
<a href="mailto:eliben@gmail.com"><i></i> an email</a>.
</p>        </article>
    </section>

    </div>
</div></div>
  </body>
</html>
