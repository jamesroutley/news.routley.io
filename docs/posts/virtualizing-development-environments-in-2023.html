<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hocus.dev/blog/virtualizing-development-environments/">Original</a>
    <h1>Virtualizing development environments in 2023</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content" itemprop="articleBody"><p><img loading="lazy" alt="Virtualization Technologies" src="https://hocus.dev/blog/assets/images/virt-dev-env-bg-c54d067f50f2dd05e316526a5cf78ac6.png" width="4750" height="1358"/></p><p>Hocus uses virtualization to let you define your development environment, build it in CI, and then run it on a devbox in a virtual machine. When we were designing the product, we followed a principles-first approach. We didn&#39;t choose a ready-to-go virtualization tool like Docker, but evaluated the pros and cons of different runtimes, and then created a custom-made system that precisely solved our problems.</p><p>In this post, I&#39;ll tell you about the limits of two modern virtualization methods: containers and virtual machines. You&#39;ll gain an overview of how they isolate processes, what tradeoffs they make to balance security and efficiency, and when you should use one over the other. Also, you&#39;ll learn how you can use them to boost your development environments.</p><h2 id="the-limits-of-docker">The Limits of Docker<a href="#the-limits-of-docker" aria-label="Direct link to The Limits of Docker" title="Direct link to The Limits of Docker">​</a></h2><p>When we first considered how to virtualize a development environment, we wanted to use Docker. But once we looked closer, we started seeing problems.</p><p>We wanted to build a solution that would allow multiple software engineers to work on a single machine, each one isolated in their own development environment. They should be able to run any software they want inside their own workspaces without impacting each other.</p><p>However, Docker was not designed with highly-privileged isolation in mind. For example, most developers would like to use Docker itself in their dev environment, and, by default, the only way to run Docker in Docker is with a privileged container. This gives the developer root access to the machine where their dev environment is hosted, completely compromising any isolation.</p><p>But, in fact, you can use containers to achieve a higher degree of isolation. Container engines<sup id="fnref-container-engine-384cde"><a href="#fn-container-engine-384cde">1</a></sup> like Docker and Containerd include a subsystem called a runtime which spawns containerized processes. By default, they use <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener noreferrer">runc</a>, but they let you replace it with, for example, <a href="https://github.com/nestybox/sysbox" target="_blank" rel="noopener noreferrer">Sysbox</a>. By using Linux kernel features such as <a href="https://man7.org/linux/man-pages/man7/user_namespaces.7.html" target="_blank" rel="noopener noreferrer">user namespaces</a> and emulating certain syscalls, it lets containerized processes run with a root user that has no privileges on the host, but can do almost anything within the container. If you&#39;re not confined to the OCI ecosystem, there is also <a href="https://linuxcontainers.org/" target="_blank" rel="noopener noreferrer">LXC</a>, which is more mature.</p><p>But these solutions come with limits. Sysbox <a href="https://github.com/nestybox/sysbox/issues/50" target="_blank" rel="noopener noreferrer">does not support GPUs</a> and <a href="https://github.com/nestybox/sysbox/blob/b27597294d3aa1c74ae724f558859c0d39acc4ff/docs/user-guide/limitations.md#sysbox-container-limitations" target="_blank" rel="noopener noreferrer">cannot run</a> nested Sysbox containers. As a developer, if you are working on a web app, you will not run into any issues. But some Linux subsystems, such as block devices, currently can&#39;t be isolated within a container. If your development environment depends on them, you&#39;re out of luck.</p><h2 id="virtual-machines-galore">Virtual Machines Galore<a href="#virtual-machines-galore" aria-label="Direct link to Virtual Machines Galore" title="Direct link to Virtual Machines Galore">​</a></h2><p>To solve this, you can use a virtual machine. VMs can run full, separate Linux kernels so you can virtualize any single Linux feature. The main caveat is memory efficiency.</p><p>The Linux kernel loves RAM. Whenever it sees free memory, it stuffs it into various caches, so software can run faster. That&#39;s a great design when the kernel is running on bare metal, since unused RAM is wasted RAM. But when it&#39;s running in a VM, the VM gobbles up as much memory as it can and, by itself, shows no inclination to give it back.</p><p>There are techniques you can use to reclaim it, such as memory ballooning or <a href="https://docs.kernel.org/mm/free_page_reporting.html" target="_blank" rel="noopener noreferrer">free page reporting</a> in combination with <a href="https://www.kernel.org/doc/html/v5.17/vm/damon/index.html" target="_blank" rel="noopener noreferrer">DAMON</a>, but it&#39;s not straightforward<sup id="fnref-memory-384cde"><a href="#fn-memory-384cde">2</a></sup> to make them work. And, even if you implement them, you will not gain the efficiency that containers boast.</p><p>If you&#39;ve got multiple VMs running on a host, you can also use <a href="https://docs.kernel.org/admin-guide/mm/ksm.html" target="_blank" rel="noopener noreferrer">Kernel Samepage Merging</a>, which deduplicates identical memory pages between processes. Last we tested it, we had multiple VMs with similar workloads running that together consumed 15 GB of RAM, and after enabling KSM, this dropped down to only 6 GB. However, even though the memory savings are colossal, you should be cautious about using it. Enabling KSM introduces a side channel vulnerability that potentially lets a process running in one VM read files from a different VM.<sup id="fnref-ksm-384cde"><a href="#fn-ksm-384cde">3</a></sup></p><p>VMs are also not as portable as containers. Many cloud providers, like AWS inside VM-based EC2 instances, won&#39;t let you run a VM since they don&#39;t support nested virtualization.</p><h2 id="our-solution">Our Solution<a href="#our-solution" aria-label="Direct link to Our Solution" title="Direct link to Our Solution">​</a></h2><p>There was no silver bullet we could use to virtualize development environments. VMs are not very memory-efficient, and containers can&#39;t isolate all workloads. Many of our users would not need the virtualization capabilities of VMs, and could save costs by putting more containers on a single machine. However, Hocus itself depends on low-level kernel features, and can&#39;t be fully developed inside a container. We wanted to use Hocus to develop Hocus as soon as we could, so the first version of Hocus uses VMs. However, we designed the system in a way that allows us to add container<sup id="fnref-lxc-384cde"><a href="#fn-lxc-384cde">4</a></sup> support later.</p><p>Hocus is a work in progress, a proof of concept, and we want to finish it in collaboration with people who need it. We are looking for individuals who can&#39;t stand their huge, slow dev environments at work and want to do something about it. We recently figured out how to start 100 GB+ dev environments in seconds even when you haven&#39;t downloaded them onto your host yet,<sup id="fnref-lazypulling-384cde"><a href="#fn-lazypulling-384cde">5</a></sup> and we&#39;d love to find someone to implement it for. If that&#39;s you, you can sign up for the closed beta of <a href="https://hocus.dev/enterprise" target="_blank" rel="noopener noreferrer">Hocus Enterprise</a>. We will work with you to introduce Hocus at your company, and adapt it to your needs. But, if you&#39;re just interested in what we&#39;ve built so far, you can check out the <a href="https://github.com/hocus-dev/hocus" target="_blank" rel="noopener noreferrer">alpha version on GitHub</a>.</p></div></div>
  </body>
</html>
