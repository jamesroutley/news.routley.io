<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mveg.es/posts/writing-a-device-driver-for-unix-v6/">Original</a>
    <h1>Writing a device driver for Unix V6</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>In this post we will learn the useful skill of writing a device driver for Unix V6 (released in 1975) and run it on an emulator. The implemented device is fairly trivial: it will open a message box on the host OS. The goal is that we can execute the following command:</p>
<p>The message box is opened in the host OS, so effectively we create a special file (<code>/dev/mb</code>) that accepts text input and opens a message box.</p>
<p>Since Unix V6 runs on PDP-11 and I do not have access to one, everything is run via SimH. SimH is a family of old computer emulators, ranging from IBM 1401 to Altair 8800. We only need the PDP-11 one though.</p>
<h2>Background</h2>
<p>Unix V6 was developed in 1975 on a PDP-11. By this version, most of the code was written in C and only a couple of hundreds assembly code remained. Already, it had many of the utilities that are common on a today&#39;s Linux system: cp, rm, bc/dc, cron, dd, chmod, ls. The OS was very powerful: had memory management, multiple users and pre-emptive multitasking. It is funny to see that many of these features arrived only in the 90s for personal comptuters, while bigger minicomputers had them for decades.</p>
<p>The choice of Unix V6 is motivated by two facts: first, it is written mostly in C, thus easy to understand. Second, there exists a full documentation of the kernel code. John Lion&#39;s  Commentary on UNIX 6th Edition is a thorough description of the inner workings of Unix and the underlying algorithms. It is begginer friendly, guiding you through the kernel step-by-step.</p>
<p>PDP-11 was a family of computers produced between 1970 and 1990. The Bell Research Lab used these devices so both the Unix OS and the C language was developed primarily on them. PDP-11 minicomputers introduced inportant innovations, that let Thompson and Ritchie implement several advanced features for Unix: hardware support for memory paging, user and kernel mode, different priority levels for interrupts. Again, CPUs of personal computers only had these in the late 80s â€“ early 90s.</p>
<h2>Implementing a new device</h2>
<p>To add the new device to Unix, first we have to create a device in the emulator. On the PDP-11 it was common to map certain regions of the memory to a device and communicate with the device via this memory region. When a value was written to a particular address, the values were forwarded to the device. Conversely, the status of the device could be read by reading the right locations.</p>
<p>We will follow the same strategy. The device, called <code>mb</code>, is mapped to the 17777340-17777342 addresses (addresses are in octal). The characters of the message are written one-by-one at 17777340 which our virtual device reads and stores the letters in a buffer. Upon receiving a newline or zero (<code>\0</code>) character the buffer is converted to a string and displayed in a message box. The device handles ASCII character only, however PDP-11 has a 16 bit CPU, so 2 bytes are written at a time. This is the reason why we have mapped a 2 bytes long region instead of a single byte.</p>
<p>Our choice of emulator is SimH. SimH is not actually an emulator but a framework for writing emulators. Roughly speaking, it lets you define devices that can be attached to an emulated machine. These devices include peripherals such as magnetic tape reader, disk drive or teletypes. When attached, a device provides additional registers and can be memory-mapped to a hardcoded region. The implementation interface is quite simple: a pair of read/write functions must be defined for the registers and the memory-mapping. Since want to use only the latter, and only for output, it is enough to implement the memory write function:</p>
<pre><code><span><span>#</span><span>define</span> <span>BUF_LEN <span>250</span></span></span></code></pre>
<p>The function takes an address (<code>PA</code>) and a value (<code>data</code>) that will be written to the address. Since our virtual device supports ASCII only, we take the lower byte. If the buffer is full or we have received a newline or <code>\0</code> character, the message box is shown. Otherwise, the character is appended to the buffer. We ignore the address, as the device is attached to a single word address anyway.</p>
<p>All that&#39;s left is to connect the device to a certain memory address and tell SimH the name of the write function.</p>
<pre><code><span><span>#</span><span>define</span> <span>IOBA_MB         <span>017777340</span>           </span></span></code></pre>
<p>In the <code>mb_dib</code> structure, the first value is the start of the memory segment, followed by the length and the memory read-write functions. The device does not support reading so the read function is <code>NULL</code>. The <code>mb_dib</code>  structure is then passed to SimH to make it aware of the existence of mb.</p>
<p>Let&#39;s test if the new device works. After firing up SimH:</p>
<pre><code></code></pre>
<p>First, the device have to be turned on an initialized with <code>reset</code>. Then, the octal values <code>101</code> and <code>0</code> are written at the adress <code>17777340</code>. Upon writing the <code>0</code> byte, the message box appears:</p>
<p><img src="https://mveg.es/images/simh_a.png" alt="Result"/></p>
<h2>Implementing the driver</h2>
<p>Let&#39;s move on to the implementation of the driver itself. In UNIX V6, there are two types of devices: block and character special devices. The first one uses a buffering mechanism implemented in the kernel and reads/writes blocks of data. Typically, floppy and cartridge drives use this method. Character devices can do whatever they want, though most of the time they will print/read one character at a time. Examples are terminals and paper tape punchers.</p>
<p>Let&#39;s start with the driver code:</p>
<pre><code><span><span>#</span><span>define</span>	<span>MBADDR	<span>0177340</span></span></span></code></pre>
<p>UNIX will call the <code>mbwrite</code> function when something is written to the device. <code>mbwrite</code> calls the <code>cpass</code> function in a loop, <code>cpass</code> returns the next character from the argument of the <code>write</code> system call. There is one strangeness in this code: the anonymous struct and using the <code>MBADDR</code> address as a struct. This is an ancient behaviour of the C language from the early 70s. Back then, struct field names were kind of global, meaning when seeing an expression <code>var-&gt;structfield</code>, the compiler ignored the type of <code>var</code> and calculated the offset based on <code>structfield</code> alone. This also meant that field names in structs had to be unique. In this code <code>MBADDR-&gt;mbchr</code> is equivalent to <code>*(MBADDR+0)</code>. This saves putting <code>MBADDR</code> into a temporary pointer and dereferencing the pointer.</p>
<p>The second quirk astute readers might have noticed is that we are writing to the address 177340 while the device was mapped 17777340. This is because UNIX is using virtual memory to have access to more than the 64kb RAM that 16 bit would allow to address. In kernel mode, the last 8kb of virtual memory (160000 to 177777) is always mapped to the last 8kb of the physical memory (17760000 to 17777777 in the emulator configuration).</p>
<p>Having the device driver, we just have to tell the kernel about it by adding an entry to the device configuration table:</p>
<pre><code><span>int</span>     <span>(</span><span>*</span>cdevsw<span>[</span><span>]</span><span>)</span><span>(</span><span>)</span></code></pre>
<p>The table contains the implementations of the open, close, read and write system calls for every device. By the way, this table can be generated automatically by the <a href="https://github.com/memnoth/unix-v6/blob/master/sys/conf/mkconf.c"><code>mkconf</code></a> utility.</p>
<p>After rebuilding the kernel, we can mount the device like this:</p>
<pre><code>/etc/mknod /dev/mb c <span>16</span> <span>0</span></code></pre>
<p>The name of the mountpoint is <code>/dev/mb</code>, <code>c</code> means it is a character special device. 16 is the major device number, it is the row index of the driver in the <code>cdevsw</code> table. <code>0</code> is the minor device number: when multiple devices of the same type are attached, this signifies the id of the specific device.</p>
<p>Now let&#39;s see what happens, when someone enters the following code to the shell:</p>
<pre><code><span>echo</span> Hello world<span>!</span> <span>&gt;</span> /dev/mb</code></pre>
<p>The shell, after parsing the command, will call the write system call, which just calls <a href="https://github.com/memnoth/unix-v6/blob/2c7099ee501923775c4c96079a6fe94da109b552/sys/ken/sys2.c#L22"><code>rdwr</code></a>. <code>rdwr</code> is the common implementation of the <code>read</code> and <code>write</code> system calls. After checking permissions, it decides whether the file is a pipe or inode, and eventually calls the writei function (<a href="https://github.com/memnoth/unix-v6/blob/2c7099ee501923775c4c96079a6fe94da109b552/sys/ken/sys2.c#L54">link</a>). <code>writei</code> means &#34;write inode&#34;, that is it will write to that node in the file system. Since <code>/dev/mb</code> is a character special file, <a href="https://github.com/memnoth/unix-v6/blob/2c7099ee501923775c4c96079a6fe94da109b552/sys/ken/rdwri.c#L76"><code>writei</code></a> quickly dispatches the code to the driver:</p>
<pre><code><span>if</span><span>(</span><span>(</span>ip<span>-&gt;</span>i_mode<span>&amp;</span>IFMT<span>)</span> <span>==</span> IFCHR<span>)</span> <span>{</span></code></pre>
<p>The if clause checks if the inode to write to is a character device. If yes, it will look up the write function of the device in the <code>cdevsw</code> table (using the major device number as index) and call it with the minor device number (stored in <code>ip-&gt;i_addr[0]</code>). The <code>d_write</code> function is mapped to <code>mbwrite</code> and will write the string one character at a time to the address <code>0177340</code>. This triggers our device&#39;s code in the emulator and results in showing the message box.</p>

  </div></div>
  </body>
</html>
