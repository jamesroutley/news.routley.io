<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dev.37signals.com/running-our-docker-registry-on-prem-with-harbor/">Original</a>
    <h1>Running our Docker registry on-prem with Harbor</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>As of early 2025, we’re deploying all of our applications with <a href="https://kamal-deploy.org/">Kamal</a> using Docker as our containerization platform. The container registry that holds our app images is one of the most integral pieces of our deployment pipeline.</p>

<p>Like many organizations, we’d been using external container registries for years. Our ecosystem was tightly coupled to both Dockerhub and Amazon’s Elastic Container Registry.</p>

<p>However, as part of our <a href="https://world.hey.com/dhh/we-have-left-the-cloud-251760fb">cloud exit</a> and <a href="https://dev.37signals.com/bringing-our-apps-back-home/">kamalization</a> journey, several issues started emerging:</p>

<ul>
  <li><strong>Cost:</strong> Not only does the paid license for Dockerhub produce a considerable invoice — pulling and pushing our images over the internet dozens of times a day caused us to hit the contracted bandwidth limit with our datacenter provider <a href="https://www.summithq.com/">Deft</a> repeatedly. We tried working around this by running pull-through caches, but this still locked us to Dockerhub.</li>
  <li><strong>Performance:</strong> Migrating HEY to Kamal and expanding the deployment to another continent caused deploy time penalties — up to 45 seconds on uncached pulls per host. This was exacerbated once our largest application <a href="https://basecamp.com/">Basecamp 4</a> was moved to Kamal — suddenly deployments took minutes longer simply because of push/pull speeds out of our control.</li>
  <li><strong>Security and Governance:</strong> We all hope to never leak credentials in our images, and yet it still happens — the scale ranging from easily mitigated to catastrophic. We wanted to eliminate that threat surface once and for all by keeping our artifacts where they belong — with us.</li>
  <li><strong>Independence:</strong> Despite being on a paid account, we fell into the crunch of API limitations for arbitrary reasons a couple of times. In addition, we’d been keeping all of the images used in our Chef CI/CD infrastructure still on AWS.</li>
</ul>

<p>Our criteria for the solution to pick were fairly simple: reliable, performant, easy to set up, open-source.</p>

<p>We evaluated running the <a href="https://hub.docker.com/_/registry">default distribution implementation</a> as our registry, but quickly set our eyes on <a href="https://goharbor.io/">Harbor</a>. Harbor provided us with a more expandable and rich feature set right out of the box, and required minimal extra tooling to make it robust and scalable.</p>

<hr/>

<h2 id="setting-up-harbor">Setting up Harbor</h2>

<p>Harbor’s deployment is optimized for using it within Kubernetes environments, but the single-server setup using the pre-packaged docker-compose configuration proved to be exactly what we were looking for.</p>

<p>We had three key points to cover in our plan for the v1 of our on-premise registry:</p>

<ul>
  <li>Use our own S3 storage.</li>
  <li>Make sure we have at least two replicating sites that can be easily failed over.</li>
  <li>Keep the storage footprint as small as possible by enabling retention policies.</li>
</ul>

<h3 id="configuring-s3-storage">Configuring S3 storage</h3>

<p>At 37signals, we’re running our own <a href="https://www.purestorage.com/products/unstructured-data-storage/flashblade-s.html">Pure FlashBlade</a> storage cluster providing us with S3 object storage right out of the box, but for Harbor, any S3-compatible backend will do.</p>

<p>The configuration in Harbor was easy, but it was crucial to get the permissions set right on the Pure backend. You can obviously run an <code>s3:*</code> policy, but let’s be real, we want to do better! After some trial and error with broken image pushes, these are the minimal permissions needed on the bucket to operate Harbor with a custom S3 backend:</p>

<div><div><pre><code>s3:AbortMultipartUpload
s3:DeleteObject
s3:GetBucketLocation
s3:GetObject
s3:ListBucket
s3:ListBucketMultipartUploads
s3:ListMultipartUploadParts
s3:PutObject
</code></pre></div></div>

<h3 id="configuring-multiple-instances">Configuring multiple instances</h3>

<p>For the v1 of the Harbor deployment, we opted to run two stand-alone instances at first: one in our Ashburn and one in our Chicago location.</p>

<p>Harbor comes with several components, such as PostgreSQL and Redis services, handling manifest/user management and job scheduling. We explored an elaborate HA per datacenter with colocated instances of those services, but decided to wait for the first results of the all-in-one stand-alone deployment before making it more complicated than it has to be.</p>

<p>This is an excerpt of our <code>harbor.yml</code> in use, which gives you a functional instance, including the s3 configuration and enabled monitoring:</p>

<div><div><pre><code><span>hostname</span><span>:</span> <span>&#34;</span><span>#{node[&#39;fqdn&#39;]}&#34;</span>
<span>http</span><span>:</span>
  <span>port</span><span>:</span> <span>80</span>
<span>data_volume</span><span>:</span> <span>/data</span>
<span>harbor_admin_password</span><span>:</span> <span>&#34;</span><span>#{admin_password}&#34;</span>
<span>storage_service</span><span>:</span>
  <span>s3</span><span>:</span>
    <span>bucket</span><span>:</span> <span>docker-registry-bucket</span>
    <span>accesskey</span><span>:</span> <span>&#34;</span><span>#{bucket_credentials[&#39;access_key&#39;]}&#34;</span>
    <span>secretkey</span><span>:</span> <span>&#34;</span><span>#{bucket_credentials[&#39;secret_key&#39;]}&#34;</span>
    <span>regionendpoint</span><span>:</span> <span>&#34;</span><span>https://purestorage.#{node[&#34;domain&#34;]}&#34;</span>
    <span>region</span><span>:</span> <span>us-east-1</span>
    <span>encrypt</span><span>:</span> <span>false</span>
    <span>secure</span><span>:</span> <span>true</span>
    <span>v4auth</span><span>:</span> <span>true</span>
    <span>chunksize</span><span>:</span> <span>5242880</span>
    <span>loglevel</span><span>:</span> <span>debug</span>
<span>metric</span><span>:</span>
  <span>enabled</span><span>:</span> <span>true</span>
  <span>port</span><span>:</span> <span>9090</span>
  <span>path</span><span>:</span> <span>/metrics</span>
<span>database</span><span>:</span>
  <span>password</span><span>:</span> <span>&#34;</span><span>#{db_password}&#34;</span>
  <span>max_idle_conns</span><span>:</span> <span>50</span>
  <span>max_open_conns</span><span>:</span> <span>100</span>
<span>clair</span><span>:</span>
  <span>updaters_interval</span><span>:</span> <span>12</span>
<span>jobservice</span><span>:</span>
  <span>max_job_workers</span><span>:</span> <span>20</span>
  <span>job_loggers</span><span>:</span>
    <span>-</span> <span>FILE</span>
  <span>logger_sweeper_duration</span><span>:</span> <span>3600</span>
<span>log</span><span>:</span>
  <span>level</span><span>:</span> <span>info</span>
  <span>local</span><span>:</span>
    <span>rotate_count</span><span>:</span> <span>50</span>
    <span>rotate_size</span><span>:</span> <span>200M</span>
    <span>location</span><span>:</span> <span>/var/log/harbor</span>
<span>notification</span><span>:</span>
  <span>webhook_job_max_retry</span><span>:</span> <span>3</span>
  <span>webhook_job_http_client_timeout</span><span>:</span> <span>10</span>
<span>_version</span><span>:</span> <span>2.10.0</span>
</code></pre></div></div>

<p>As you can see, it is a fairly default config. Encapsulated in a Chef recipe, this will be executed on the respective nodes in each DC, setting the correct FQDN and pointing to the correct storage endpoint. These nodes are then fronted by our F5 loadbalancers for SSL termination and region-specific domains.</p>

<p>Each Harbor node is currently a virtual machine equipped with 64GB of RAM, 32 vCPU and 320GB of storage.</p>

<h3 id="configuring-replication">Configuring replication</h3>

<p>The initial Chef setup only needs to run once for bootstrapping. For further configuration we decided to rely on the <a href="https://registry.terraform.io/providers/goharbor/harbor/3.10.21">terraform provider for Harbor</a>. In addition to the initial user management setup, here we could also configure replication between the endpoints easily. We decided on a two-way replication scheme to keep it all in sync, inspired by <a href="https://www.unix-experience.fr/en/devops/harbor_multidc_replicated/">this setup</a>.</p>

<ul>
  <li>Images are pushed to a registry endpoint.</li>
  <li>The endpoint pulls data from the opposite registry every 10 minutes.</li>
</ul>

<div><div><pre><code><span>resource</span> <span>&#34;harbor_replication&#34;</span> <span>&#34;replication_push_sc_chi&#34;</span> <span>{</span>
  <span>provider</span>               <span>=</span> <span>harbor</span><span>.</span><span>sc</span><span>-</span><span>chi</span>
  <span>name</span>                   <span>=</span> <span>&#34;Replicate images on push to df-iad&#34;</span>
  <span>action</span>                 <span>=</span> <span>&#34;push&#34;</span>
  <span>registry_id</span>            <span>=</span> <span>harbor_registry</span><span>.</span><span>df_iad</span><span>.</span><span>registry_id</span>
  <span>schedule</span>               <span>=</span> <span>&#34;event_based&#34;</span>
  <span>dest_namespace_replace</span> <span>=</span> <span>-</span><span>1</span>
  <span>filters</span> <span>{</span>
    <span>name</span> <span>=</span> <span>&#34;**&#34;</span>
  <span>}</span>
  <span>filters</span> <span>{</span>
    <span>tag</span> <span>=</span> <span>&#34;**&#34;</span>
  <span>}</span>
<span>}</span>

<span>resource</span> <span>&#34;harbor_replication&#34;</span> <span>&#34;replication_pull_sc_chi&#34;</span> <span>{</span>
  <span>provider</span>               <span>=</span> <span>harbor</span><span>.</span><span>sc</span><span>-</span><span>chi</span>
  <span>name</span>                   <span>=</span> <span>&#34;Replicate missing images/artifacts from df-iad&#34;</span>
  <span>action</span>                 <span>=</span> <span>&#34;pull&#34;</span>
  <span>registry_id</span>            <span>=</span> <span>harbor_registry</span><span>.</span><span>df_iad</span><span>.</span><span>registry_id</span>
  <span>schedule</span>               <span>=</span> <span>&#34;0 0/10 * * * *&#34;</span>
  <span>enabled</span>                <span>=</span> <span>false</span>
  <span>dest_namespace_replace</span> <span>=</span> <span>-</span><span>1</span>
  <span>filters</span> <span>{</span>
    <span>name</span> <span>=</span> <span>&#34;**&#34;</span>
  <span>}</span>
  <span>filters</span> <span>{</span>
    <span>tag</span> <span>=</span> <span>&#34;**&#34;</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>In addition, we’re replicating the underlying S3 buckets directly on our Pure cluster for an extra failsafe backup mechanism. It’s important to note however that this is <strong>not enough</strong> to make Harbor aware of the data in the other location — explicit replication on the Harbor level like the setup above must be configured.</p>

<hr/>

<h2 id="syncing-the-catalogue">Syncing the catalogue</h2>

<p>You could of course start with an empty registry and fill it as you go, but this isn’t very feasible if you want a drop-in replacement for your current registry. In our case, we had to make sure that the entire image catalog from Dockerhub gets copied into Harbor — the challenge being that this meant dealing with 80+ individual image repositories. Thankfully, Harbor offers replication directly from Dockerhub, so we opted for that.</p>

<p>Sounds straightforward? Here’s a funny caveat — depending on the amount of repositories you want to fetch and replicate, Dockerhub is likely going to throttle you on the API level if you want to do this all at once. You could totally write a functional replication rule that just targets <code>**/**</code>, only to be showered with <code>429</code> — even on a paid account.</p>

<p>Thus, the replication has to happen in batches. For this, we chose to create individual replication rules per repository with a “manual” (also scripted) trigger to avoid overloading the API.</p>

<p>The definition for the replication rules in Terraform:</p>
<div><div><pre><code><span>variable</span> <span>&#34;repositories&#34;</span> <span>{</span>
  <span>type</span> <span>=</span> <span>map</span><span>(</span><span>string</span><span>)</span>
<span>}</span>

<span>resource</span> <span>&#34;harbor_registry&#34;</span> <span>&#34;dockerhub&#34;</span> <span>{</span>
  <span>provider</span>      <span>=</span> <span>harbor</span><span>.</span><span>sc</span><span>-</span><span>chi</span>
  <span>provider_name</span> <span>=</span> <span>&#34;docker-hub&#34;</span>
  <span>name</span>          <span>=</span> <span>&#34;DockerHub&#34;</span>
  <span>endpoint_url</span>  <span>=</span> <span>&#34;https://registry-1.docker.io&#34;</span>
  <span>description</span>   <span>=</span> <span>&#34;Endpoint for replicating the existing catalogue&#34;</span>
  <span>access_id</span>     <span>=</span> <span>var</span><span>.</span><span>dockerhub_username</span>
  <span>access_secret</span> <span>=</span> <span>var</span><span>.</span><span>dockerhub_password</span>
<span>}</span>

<span>resource</span> <span>&#34;harbor_replication&#34;</span> <span>&#34;dockerhub_mirror&#34;</span> <span>{</span>
  <span>for_each</span> <span>=</span> <span>var</span><span>.</span><span>repositories</span>

  <span>provider</span>               <span>=</span> <span>harbor</span><span>.</span><span>sc</span><span>-</span><span>chi</span>
  <span>name</span>                   <span>=</span> <span>&#34;mirror-dockerhub-${each.key}&#34;</span>
  <span>description</span>            <span>=</span> <span>&#34;Replicate and mirror images from DockerHub&#34;</span>
  <span>registry_id</span>            <span>=</span> <span>harbor_registry</span><span>.</span><span>dockerhub</span><span>.</span><span>registry_id</span>
  <span>dest_namespace</span>         <span>=</span> <span>&#34;yourorg&#34;</span>
  <span>override</span>               <span>=</span> <span>true</span>
  <span>dest_namespace_replace</span> <span>=</span> <span>1</span>
  <span>copy_by_chunk</span>          <span>=</span> <span>true</span>

  <span>filters</span> <span>{</span>
    <span>name</span> <span>=</span> <span>&#34;yourorg/${each.key}&#34;</span>
  <span>}</span>

  <span>filters</span> <span>{</span>
    <span>tag</span> <span>=</span> <span>&#34;**&#34;</span>
  <span>}</span>

  <span>action</span> <span>=</span> <span>&#34;pull&#34;</span>
<span>}</span>
</code></pre></div></div>

<p>The script to pull out a list of repositories from Dockerhub, make it accessible to Terraform and create the individual replication rules per repository:</p>

<details id="dockerhub-to-harbor">
  <summary>dockerhub-to-harbor.sh</summary>
  <div>

    <div><div><pre><code><span>#!/usr/bin/env bash</span>

<span>set</span> <span>-euo</span> pipefail

<span># -----------------------------</span>
<span># Config</span>
<span># -----------------------------</span>
<span>DOCKERHUB_USER</span><span>=</span><span>&#34;</span><span>${</span><span>DOCKERHUB_USER</span><span>:-</span><span>your</span><span>-dockerhub-username</span><span>}</span><span>&#34;</span>
<span>DOCKERHUB_PASSWORD</span><span>=</span><span>&#34;</span><span>${</span><span>DOCKERHUB_PASSWORD</span><span>:-</span><span>your</span><span>-dockerhub-password</span><span>}</span><span>&#34;</span>
<span>DOCKERHUB_ORG</span><span>=</span><span>&#34;yourorg&#34;</span>
<span>TFVARS_DIR</span><span>=</span><span>&#34;./generated_tfvars&#34;</span>
<span>TFVARS_FILE</span><span>=</span><span>&#34;</span><span>$TFVARS_DIR</span><span>/all_repos.tfvars.json&#34;</span>

<span>mkdir</span> <span>-p</span> <span>&#34;</span><span>$TFVARS_DIR</span><span>&#34;</span>

<span># -----------------------------</span>
<span># Authentication</span>
<span># -----------------------------</span>
<span>echo</span> <span>&#34;🔐 Getting Docker Hub token...&#34;</span>
<span>TOKEN</span><span>=</span><span>$(</span>curl <span>-s</span> <span>-X</span> POST https://hub.docker.com/v2/users/login/ <span>\</span>
  <span>-H</span> <span>&#34;Content-Type: application/json&#34;</span> <span>\</span>
  <span>-d</span> <span>&#39;{&#34;username&#34;: &#34;&#39;</span><span>&#34;</span><span>$DOCKERHUB_USER</span><span>&#34;</span><span>&#39;&#34;, &#34;password&#34;: &#34;&#39;</span><span>&#34;</span><span>$DOCKERHUB_PASSWORD</span><span>&#34;</span><span>&#39;&#34;}&#39;</span> |
  jq <span>-r</span> .token<span>)</span>

<span>if</span> <span>[[</span> <span>&#34;</span><span>$TOKEN</span><span>&#34;</span> <span>==</span> <span>&#34;null&#34;</span> <span>||</span> <span>-z</span> <span>&#34;</span><span>$TOKEN</span><span>&#34;</span> <span>]]</span><span>;</span> <span>then
  </span><span>echo</span> <span>&#34;❌ Failed to authenticate. Check Docker Hub credentials.&#34;</span>
  <span>exit </span>1
<span>fi

</span><span>export </span><span>AUTH_HEADER</span><span>=</span><span>&#34;Authorization: Bearer </span><span>$TOKEN</span><span>&#34;</span>

<span># -----------------------------</span>
<span># Helper Functions</span>
<span># -----------------------------</span>
fetch_repos_starting_with<span>()</span> <span>{</span>
  <span>local </span><span>letter</span><span>=</span><span>&#34;</span><span>$1</span><span>&#34;</span>
  <span>local </span><span>page</span><span>=</span>1
  <span>local </span><span>repos</span><span>=()</span>

  <span>while</span> :<span>;</span> <span>do
    </span><span>local </span><span>url</span><span>=</span><span>&#34;https://hub.docker.com/v2/repositories/</span><span>${</span><span>DOCKERHUB_ORG</span><span>}</span><span>/?page=</span><span>$page</span><span>&amp;page_size=100&#34;</span>
    <span>local </span><span>response</span><span>=</span><span>$(</span>curl <span>-s</span> <span>-H</span> <span>&#34;</span><span>$AUTH_HEADER</span><span>&#34;</span> <span>&#34;</span><span>$url</span><span>&#34;</span><span>)</span>

    <span>local </span><span>matched</span><span>=</span><span>$(</span><span>echo</span> <span>&#34;</span><span>$response</span><span>&#34;</span> |
      jq <span>-r</span> <span>&#34;.results[] | select(.name | startswith(</span><span>\&#34;</span><span>$letter</span><span>\&#34;</span><span>)) | .name&#34;</span><span>)</span>

    repos+<span>=(</span><span>$matched</span><span>)</span>

    <span>local </span><span>next</span><span>=</span><span>$(</span><span>echo</span> <span>&#34;</span><span>$response</span><span>&#34;</span> | jq <span>-r</span> <span>&#34;.next&#34;</span><span>)</span>
    <span>[[</span> <span>&#34;</span><span>$next</span><span>&#34;</span> <span>==</span> <span>&#34;null&#34;</span> <span>]]</span> <span>&amp;&amp;</span> <span>break</span>
    <span>((</span>page++<span>))</span>
  <span>done

  </span><span>echo</span> <span>&#34;</span><span>${</span><span>repos</span><span>[@]</span><span>}</span><span>&#34;</span>
<span>}</span>

generate_tfvars_file<span>()</span> <span>{</span>
  <span>local </span><span>repos</span><span>=(</span><span>&#34;</span><span>$@</span><span>&#34;</span><span>)</span>
  <span>local </span><span>tfvars_file</span><span>=</span><span>&#34;</span><span>$TFVARS_FILE</span><span>&#34;</span>

  <span>echo</span> <span>&#34;{ </span><span>\&#34;</span><span>repositories</span><span>\&#34;</span><span>: {&#34;</span> <span>&gt;</span> <span>&#34;</span><span>$tfvars_file</span><span>&#34;</span>
  <span>for </span>repo <span>in</span> <span>&#34;</span><span>${</span><span>repos</span><span>[@]</span><span>}</span><span>&#34;</span><span>;</span> <span>do
    </span><span>echo</span> <span>&#34;  </span><span>\&#34;</span><span>$repo</span><span>\&#34;</span><span>: </span><span>\&#34;</span><span>$repo</span><span>\&#34;</span><span>,&#34;</span> <span>&gt;&gt;</span> <span>&#34;</span><span>$tfvars_file</span><span>&#34;</span>
  <span>done
  </span><span>sed</span> <span>-i</span> <span>&#39;&#39;</span> <span>&#39;$ s/,$//&#39;</span> <span>&#34;</span><span>$tfvars_file</span><span>&#34;</span>
  <span>echo</span> <span>&#34;} }&#34;</span> <span>&gt;&gt;</span> <span>&#34;</span><span>$tfvars_file</span><span>&#34;</span>

  <span>&gt;</span>&amp;2 <span>echo</span> <span>&#34;💾 Created tfvars file: </span><span>$tfvars_file</span><span>&#34;</span>
  <span>&gt;</span>&amp;2 <span>ls</span> <span>-l</span> <span>&#34;</span><span>$tfvars_file</span><span>&#34;</span>

  <span># Only echo the filename to stdout</span>
  <span>echo</span> <span>&#34;</span><span>$tfvars_file</span><span>&#34;</span>
<span>}</span>

run_terraform_once<span>()</span> <span>{</span>
  <span>local </span><span>tfvars</span><span>=</span><span>&#34;</span><span>$1</span><span>&#34;</span>

  <span>local </span>abs_tfvars
  <span>abs_tfvars</span><span>=</span><span>$(</span><span>realpath</span> <span>&#34;</span><span>$tfvars</span><span>&#34;</span><span>)</span>

  <span>echo</span> <span>&#34;🔁 Applying Terraform with </span><span>$abs_tfvars</span><span>&#34;</span>

  <span>(</span>
    <span>cd </span>harbor-production <span>||</span> <span>exit </span>1
    <span>local </span>rel_tfvars
    <span>rel_tfvars</span><span>=</span><span>$(</span>python3 <span>-c</span> <span>&#34;import os.path; print(os.path.relpath(&#39;</span><span>$abs_tfvars</span><span>&#39;, &#39;.&#39;))&#34;</span><span>)</span>

    terraform apply <span>-var-file</span><span>=</span><span>&#34;</span><span>$rel_tfvars</span><span>&#34;</span> <span>-auto-approve</span>
  <span>)</span>
<span>}</span>

<span># -----------------------------</span>
<span># Execution</span>
<span># -----------------------------</span>
main<span>()</span> <span>{</span>
  <span>echo</span> <span>&#34;🚀 Starting repository sync...&#34;</span>
  <span>letters</span><span>=(</span>a b c d e f g h i j k l m n o p q r s t u v w x y z<span>)</span>
  <span>all_repos</span><span>=()</span>

  <span>for </span>letter <span>in</span> <span>&#34;</span><span>${</span><span>letters</span><span>[@]</span><span>}</span><span>&#34;</span><span>;</span> <span>do
    </span><span>echo</span> <span>&#34;📦 Fetching repos for prefix: </span><span>$letter</span><span>&#34;</span>
    <span>repos</span><span>=(</span><span>$(</span>fetch_repos_starting_with <span>&#34;</span><span>$letter</span><span>&#34;</span><span>)</span><span>)</span>
    all_repos+<span>=(</span><span>&#34;</span><span>${</span><span>repos</span><span>[@]</span><span>}</span><span>&#34;</span><span>)</span>
  <span>done

  if</span> <span>[[</span> <span>&#34;</span><span>${#</span><span>all_repos</span><span>[@]</span><span>}</span><span>&#34;</span> <span>-eq</span> 0 <span>]]</span><span>;</span> <span>then
    </span><span>echo</span> <span>&#34;⚠️ No repositories found.&#34;</span>
    <span>exit </span>0
  <span>fi

  </span><span>tfvars_file</span><span>=</span><span>$(</span>generate_tfvars_file <span>&#34;</span><span>${</span><span>all_repos</span><span>[@]</span><span>}</span><span>&#34;</span> 2&gt;/dev/null<span>)</span>
  run_terraform_once <span>&#34;</span><span>$tfvars_file</span><span>&#34;</span>

  <span>echo</span> <span>&#34;✅ All repositories synced.&#34;</span>
<span>}</span>

main <span>&#34;</span><span>$@</span><span>&#34;</span>
</code></pre></div>    </div>

  </div>
</details>

<p>And the script to enable those rules alphabetically in batches:</p>

<details id="trigger-replication">
  <summary>trigger-replication.sh</summary>
  <div>

    <div><div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> <span>-euo</span> pipefail

<span># -----------------------------</span>
<span># Config</span>
<span># -----------------------------</span>
<span>HARBOR_URL</span><span>=</span><span>&#34;</span><span>${</span><span>HARBOR_URL</span><span>:-</span><span>https</span>://registry.yourdomain.com<span>}</span><span>&#34;</span>
<span>HARBOR_USER</span><span>=</span><span>&#34;</span><span>${</span><span>HARBOR_USER</span><span>:-</span><span>your</span><span>-harbor-user</span><span>}</span><span>&#34;</span>
<span>HARBOR_PASSWORD</span><span>=</span><span>&#34;</span><span>${</span><span>HARBOR_PASSWORD</span><span>:-</span><span>your</span><span>-harbor-password</span><span>}</span><span>&#34;</span>
<span>BATCH_DELAY</span><span>=</span>10  <span># seconds between batches</span>
<span>PREFIX</span><span>=</span><span>&#34;mirror-dockerhub-&#34;</span>

<span># -----------------------------</span>
<span># CLI Args</span>
<span># -----------------------------</span>
<span>DRY_RUN</span><span>=</span><span>false
</span><span>RANGE_START</span><span>=</span><span>&#34;a&#34;</span>
<span>RANGE_END</span><span>=</span><span>&#34;z&#34;</span>

usage<span>()</span> <span>{</span>
  <span>cat</span> <span>&lt;&lt;</span><span>EOF</span><span>
Usage: </span><span>$0</span><span> [--dry-run] [--range &lt;start-end&gt;]

Options:
  --dry-run         Only print the rules that would be triggered, no API calls.
  --range a-d       Trigger only rules whose names start with &#39;</span><span>${</span><span>PREFIX</span><span>}</span><span>&#39; plus letter in &lt;start-end&gt;.
                    Example: --range a-d
</span><span>EOF
</span>  <span>exit </span>1
<span>}</span>

<span>while</span> <span>[[</span> <span>$# </span><span>-gt</span> 0 <span>]]</span><span>;</span> <span>do
  case</span> <span>&#34;</span><span>$1</span><span>&#34;</span> <span>in</span>
    <span>--dry-run</span><span>)</span>
      <span>DRY_RUN</span><span>=</span><span>true
      shift</span>
      <span>;;</span>
    <span>--range</span><span>)</span>
      <span>if</span> <span>[[</span> <span>&#34;</span><span>$2</span><span>&#34;</span> <span>=</span>~ ^[a-zA-Z]-[a-zA-Z]<span>$ </span><span>]]</span><span>;</span> <span>then
        </span><span>RANGE_START</span><span>=</span><span>$(</span><span>echo</span> <span>&#34;</span><span>$2</span><span>&#34;</span> | <span>cut</span> <span>-d-</span> <span>-f1</span> | <span>tr</span> <span>&#39;[:upper:]&#39;</span> <span>&#39;[:lower:]&#39;</span><span>)</span>
        <span>RANGE_END</span><span>=</span><span>$(</span><span>echo</span> <span>&#34;</span><span>$2</span><span>&#34;</span> | <span>cut</span> <span>-d-</span> <span>-f2</span> | <span>tr</span> <span>&#39;[:upper:]&#39;</span> <span>&#39;[:lower:]&#39;</span><span>)</span>
        <span>shift </span>2
      <span>else
        </span><span>echo</span> <span>&#34;Invalid range format. Expected like &#39;a-d&#39;.&#34;</span>
        usage
      <span>fi</span>
      <span>;;</span>
    <span>*</span><span>)</span>
      <span>echo</span> <span>&#34;Unknown argument: </span><span>$1</span><span>&#34;</span>
      usage
      <span>;;</span>
  <span>esac</span>
<span>done

if</span> <span>[[</span> <span>&#34;</span><span>$RANGE_START</span><span>&#34;</span> <span>&gt;</span> <span>&#34;</span><span>$RANGE_END</span><span>&#34;</span> <span>]]</span><span>;</span> <span>then
  </span><span>echo</span> <span>&#34;Invalid range: start (</span><span>$RANGE_START</span><span>) &gt; end (</span><span>$RANGE_END</span><span>)&#34;</span>
  <span>exit </span>1
<span>fi</span>

<span># -----------------------------</span>
<span># Auth &amp; Token</span>
<span># -----------------------------</span>
<span>echo</span> <span>&#34;🔐 Authenticating with Harbor...&#34;</span>
<span>AUTH_HEADER</span><span>=</span><span>&#34;Authorization: Basic </span><span>$(</span><span>echo</span> <span>-n</span> <span>&#34;</span><span>$HARBOR_USER</span><span>:</span><span>$HARBOR_PASSWORD</span><span>&#34;</span> | <span>base64</span><span>)</span><span>&#34;</span>

curl <span>-s</span> <span>-H</span> <span>&#34;</span><span>$AUTH_HEADER</span><span>&#34;</span> <span>&#34;</span><span>$HARBOR_URL</span><span>/api/v2.0/users/current&#34;</span> | jq <span>-e</span> .username <span>&gt;</span> /dev/null <span>||</span> <span>{</span>
  <span>echo</span> <span>&#34;❌ Harbor auth failed&#34;</span>
  <span>exit </span>1
<span>}</span>

<span>echo</span> <span>&#34;📋 Fetching all replication rules...&#34;</span>
<span>rules</span><span>=</span><span>$(</span>curl <span>-s</span> <span>-H</span> <span>&#34;</span><span>$AUTH_HEADER</span><span>&#34;</span> <span>&#34;</span><span>$HARBOR_URL</span><span>/api/v2.0/replication/policies?page_size=100&#34;</span><span>)</span>

<span>declare</span> <span>-A</span> letter_to_ids

<span>while </span><span>IFS</span><span>=</span> <span>read</span> <span>-r</span> rule<span>;</span> <span>do
  </span><span>id</span><span>=</span><span>$(</span><span>echo</span> <span>&#34;</span><span>$rule</span><span>&#34;</span> | jq <span>-r</span> <span>&#39;.id&#39;</span><span>)</span>
  <span>name</span><span>=</span><span>$(</span><span>echo</span> <span>&#34;</span><span>$rule</span><span>&#34;</span> | jq <span>-r</span> <span>&#39;.name&#39;</span><span>)</span>

  <span># Filter by prefix first</span>
  <span>if</span> <span>[[</span> <span>&#34;</span><span>$name</span><span>&#34;</span> <span>==</span> <span>&#34;</span><span>$PREFIX</span><span>&#34;</span><span>*</span> <span>]]</span><span>;</span> <span>then</span>
    <span># Get letter after the prefix</span>
    <span>suffix_letter</span><span>=</span><span>$(</span><span>echo</span> <span>&#34;</span><span>${</span><span>name</span><span>#</span><span>$PREFIX</span><span>}</span><span>&#34;</span> | <span>cut</span> <span>-c1</span> | <span>tr</span> <span>&#39;[:upper:]&#39;</span> <span>&#39;[:lower:]&#39;</span><span>)</span>
    <span>if</span> <span>[[</span> <span>&#34;</span><span>$suffix_letter</span><span>&#34;</span> &lt; <span>&#34;</span><span>$RANGE_START</span><span>&#34;</span> <span>||</span> <span>&#34;</span><span>$suffix_letter</span><span>&#34;</span> <span>&gt;</span> <span>&#34;</span><span>$RANGE_END</span><span>&#34;</span> <span>]]</span><span>;</span> <span>then
      continue
    fi
    </span>letter_to_ids[<span>&#34;</span><span>$suffix_letter</span><span>&#34;</span><span>]</span>+<span>=</span><span>&#34;</span><span>$id</span><span> &#34;</span>
  <span>fi
done</span> &lt; &lt;<span>(</span><span>echo</span> <span>&#34;</span><span>$rules</span><span>&#34;</span> | jq <span>-c</span> <span>&#39;.[]&#39;</span><span>)</span>

<span>echo</span> <span>&#34;✅ Loaded replication rules matching prefix &#39;</span><span>$PREFIX</span><span>&#39;.&#34;</span>

increment_letter<span>()</span> <span>{</span>
  <span>local </span><span>c</span><span>=</span><span>$1</span>
  <span>printf</span> <span>&#34;</span><span>\\</span><span>$(</span><span>printf</span> <span>&#39;%03o&#39;</span> <span>&#34;</span><span>$((</span> <span>$(</span><span>printf</span> <span>&#39;%d&#39;</span> <span>&#34;&#39;</span><span>$c</span><span>&#34;</span><span>)</span> <span>+</span> <span>1</span> <span>))</span><span>&#34;</span><span>)</span><span>&#34;</span>
<span>}</span>

<span>current</span><span>=</span><span>&#34;</span><span>$RANGE_START</span><span>&#34;</span>
<span>while</span> <span>[[</span> <span>$current</span> &lt; <span>$RANGE_END</span> <span>||</span> <span>$current</span> <span>==</span> <span>$RANGE_END</span> <span>]]</span><span>;</span> <span>do
  </span><span>ids</span><span>=</span><span>${</span><span>letter_to_ids</span><span>[</span><span>$current</span><span>]</span><span>:-}</span>
  <span>if</span> <span>[[</span> <span>-n</span> <span>&#34;</span><span>$ids</span><span>&#34;</span> <span>]]</span><span>;</span> <span>then
    </span><span>echo</span> <span>&#34;🚀 Processing prefix &#39;</span><span>$PREFIX$current</span><span>&#39; with rule IDs: </span><span>$ids</span><span>&#34;</span>
    <span>for </span><span>id </span><span>in</span> <span>$ids</span><span>;</span> <span>do
      if</span> <span>$DRY_RUN</span><span>;</span> <span>then
        </span><span>echo</span> <span>&#34;   (dry-run) Would trigger rule ID: </span><span>$id</span><span>&#34;</span>
      <span>else
        </span><span>echo</span> <span>&#34;   🔁 Triggering rule ID: </span><span>$id</span><span>&#34;</span>
        curl <span>-s</span> <span>-X</span> POST <span>-H</span> <span>&#34;</span><span>$AUTH_HEADER</span><span>&#34;</span> <span>\</span>
          <span>-H</span> <span>&#34;Content-Type: application/json&#34;</span> <span>\</span>
          <span>-d</span> <span>&#34;{</span><span>\&#34;</span><span>policy_id</span><span>\&#34;</span><span>: </span><span>$id</span><span>}&#34;</span> <span>\</span>
          <span>&#34;</span><span>$HARBOR_URL</span><span>/api/v2.0/replication/executions&#34;</span> <span>&gt;</span> /dev/null
      <span>fi
    done
    if</span> <span>!</span> <span>$DRY_RUN</span><span>;</span> <span>then
      </span><span>echo</span> <span>&#34;⏳ Waiting </span><span>$BATCH_DELAY</span><span> seconds before next batch...&#34;</span>
      <span>sleep</span> <span>&#34;</span><span>$BATCH_DELAY</span><span>&#34;</span>
    <span>fi
  fi
  </span><span>current</span><span>=</span><span>$(</span>increment_letter <span>&#34;</span><span>$current</span><span>&#34;</span><span>)</span>
<span>done

</span><span>echo</span> <span>&#34;✅ Done.&#34;</span>
</code></pre></div>    </div>

  </div>
</details>

<p>The progress of all replication tasks at the same time is quite hard to monitor within Harbor’s UI (despite excellent logging). Thus, another small script helped summarize this:</p>

<details id="harbor-replication-monitor">
  <summary>harbor-replication-monitor.sh</summary>
  <div>

    <div><div><pre><code><span>#!/usr/bin/env bash</span>

<span>HARBOR_URL</span><span>=</span><span>&#34;</span><span>${</span><span>HARBOR_URL</span><span>:-</span><span>https</span>://registry.yourdomain.com<span>}</span><span>&#34;</span>
<span>HARBOR_USER</span><span>=</span><span>&#34;</span><span>${</span><span>HARBOR_USER</span><span>:-</span><span>your</span><span>-harbor-user</span><span>}</span><span>&#34;</span>
<span>HARBOR_PASSWORD</span><span>=</span><span>&#34;</span><span>${</span><span>HARBOR_PASSWORD</span><span>:-</span><span>your</span><span>-harbor-password</span><span>}</span><span>&#34;</span>

<span># Check required env vars</span>
<span>if</span> <span>[[</span> <span>-z</span> <span>&#34;</span><span>$HARBOR_USERNAME</span><span>&#34;</span> <span>||</span> <span>-z</span> <span>&#34;</span><span>$HARBOR_PASSWORD</span><span>&#34;</span> <span>||</span> <span>-z</span> <span>&#34;</span><span>$HARBOR_URL</span><span>&#34;</span> <span>]]</span><span>;</span> <span>then
  </span><span>echo</span> <span>&#34;❌ Missing HARBOR_USERNAME, HARBOR_PASSWORD or HARBOR_URL. Set them as env vars.&#34;</span>
  <span>exit </span>1
<span>fi</span>

<span># -----------------------------</span>
<span># Auth</span>
<span># -----------------------------</span>
<span>echo</span> <span>&#34;🔐 Authenticating with Harbor...&#34;</span>
<span>pong</span><span>=</span><span>$(</span>curl <span>-s</span> <span>-u</span> <span>&#34;</span><span>$HARBOR_USERNAME</span><span>:</span><span>$HARBOR_PASSWORD</span><span>&#34;</span> <span>&#34;</span><span>$HARBOR_URL</span><span>/ping&#34;</span><span>)</span>
<span>if</span> <span>[</span> <span>&#34;</span><span>$pong</span><span>&#34;</span> <span>!=</span> <span>&#34;Pong&#34;</span> <span>]</span><span>;</span> <span>then
  </span><span>echo</span> <span>&#34;❌ Authentication failed. Harbor did not return expected &#39;Pong&#39;.&#34;</span>
  <span>echo</span> <span>&#34;Response: </span><span>$pong</span><span>&#34;</span>
  <span>exit </span>1
<span>fi
</span><span>echo</span> <span>&#34;✅ Auth successful.&#34;</span>

<span># -----------------------------</span>
<span># Fetch executions</span>
<span># -----------------------------</span>
<span>echo</span> <span>&#34;📋 Fetching replication executions...&#34;</span>
<span>executions</span><span>=</span><span>$(</span>curl <span>-s</span> <span>-u</span> <span>&#34;</span><span>$HARBOR_USERNAME</span><span>:</span><span>$HARBOR_PASSWORD</span><span>&#34;</span> <span>&#34;</span><span>$HARBOR_URL</span><span>/replication/executions?page_size=100&#34;</span><span>)</span>

<span># Cache for policy ID to name mapping</span>
<span>declare</span> <span>-A</span> POLICY_NAMES
get_policy_name<span>()</span> <span>{</span>
  <span>local </span><span>policy_id</span><span>=</span><span>&#34;</span><span>$1</span><span>&#34;</span>
  <span>if</span> <span>[[</span> <span>-n</span> <span>&#34;</span><span>${</span><span>POLICY_NAMES</span><span>[</span><span>$policy_id</span><span>]</span><span>}</span><span>&#34;</span> <span>]]</span><span>;</span> <span>then
    </span><span>echo</span> <span>&#34;</span><span>${</span><span>POLICY_NAMES</span><span>[</span><span>$policy_id</span><span>]</span><span>}</span><span>&#34;</span>
  <span>else
    </span><span>local </span><span>name</span><span>=</span><span>$(</span>curl <span>-s</span> <span>-u</span> <span>&#34;</span><span>$HARBOR_USERNAME</span><span>:</span><span>$HARBOR_PASSWORD</span><span>&#34;</span> <span>&#34;</span><span>$HARBOR_URL</span><span>/replication/policies/</span><span>$policy_id</span><span>&#34;</span> | jq <span>-r</span> <span>&#39;.name // &#34;unknown&#34;&#39;</span><span>)</span>
    POLICY_NAMES[<span>$policy_id</span><span>]=</span><span>&#34;</span><span>$name</span><span>&#34;</span>
    <span>echo</span> <span>&#34;</span><span>$name</span><span>&#34;</span>
  <span>fi</span>
<span>}</span>

<span># -----------------------------</span>
<span># Build table</span>
<span># -----------------------------</span>
<span>rows</span><span>=()</span>
<span>while </span><span>IFS</span><span>=</span> <span>read</span> <span>-r</span> <span>exec</span><span>;</span> <span>do
  </span><span>id</span><span>=</span><span>$(</span><span>echo</span> <span>&#34;</span><span>$exec</span><span>&#34;</span> | jq <span>-r</span> <span>&#39;.id&#39;</span><span>)</span>
  <span>policy_id</span><span>=</span><span>$(</span><span>echo</span> <span>&#34;</span><span>$exec</span><span>&#34;</span> | jq <span>-r</span> <span>&#39;.policy_id&#39;</span><span>)</span>
  <span>status</span><span>=</span><span>$(</span><span>echo</span> <span>&#34;</span><span>$exec</span><span>&#34;</span> | jq <span>-r</span> <span>&#39;.status&#39;</span><span>)</span>
  <span>start_time</span><span>=</span><span>$(</span><span>echo</span> <span>&#34;</span><span>$exec</span><span>&#34;</span> | jq <span>-r</span> <span>&#39;.start_time&#39;</span> | <span>sed</span> <span>&#39;s/\.[0-9]*Z$/Z/&#39;</span><span>)</span>

  <span>start_epoch</span><span>=</span><span>$(</span><span>date</span> <span>-u</span> <span>-d</span> <span>&#34;</span><span>$start_time</span><span>&#34;</span> +%s 2&gt;/dev/null<span>)</span>
  <span>now_epoch</span><span>=</span><span>$(</span><span>date</span> +%s<span>)</span>
  <span>runtime_min</span><span>=</span><span>$((</span> <span>(</span>now_epoch <span>-</span> start_epoch<span>)</span> <span>/</span> <span>60</span> <span>))</span>

  <span>policy_name</span><span>=</span><span>$(</span>get_policy_name <span>&#34;</span><span>$policy_id</span><span>&#34;</span><span>)</span>

  <span>row</span><span>=</span><span>$(</span><span>printf</span> <span>&#34;%-8s %-10s %-25s %-12s %-14s %s&#34;</span> <span>&#34;</span><span>$id</span><span>&#34;</span> <span>&#34;</span><span>$policy_id</span><span>&#34;</span> <span>&#34;</span><span>$policy_name</span><span>&#34;</span> <span>&#34;</span><span>$status</span><span>&#34;</span> <span>&#34;</span><span>$runtime_min</span><span>&#34;</span> <span>&#34;</span><span>$start_time</span><span>&#34;</span><span>)</span>
  rows+<span>=(</span><span>&#34;</span><span>$runtime_min</span><span> </span><span>$row</span><span>&#34;</span><span>)</span>
<span>done</span> &lt; &lt;<span>(</span><span>echo</span> <span>&#34;</span><span>$executions</span><span>&#34;</span> | jq <span>-c</span> <span>&#39;.[] | select(.status == &#34;InProgress&#34;)&#39;</span><span>)</span>

<span>echo
echo</span> <span>&#34;🟡 In-progress replication tasks (sorted by runtime):&#34;</span>
<span>printf</span> <span>&#34;%-8s %-10s %-25s %-12s %-14s %s</span><span>\n</span><span>&#34;</span> <span>&#34;ID&#34;</span> <span>&#34;Policy_ID&#34;</span> <span>&#34;Rule Name&#34;</span> <span>&#34;Status&#34;</span> <span>&#34;Runtime(min)&#34;</span> <span>&#34;Start Time&#34;</span>

<span># -----------------------------</span>
<span># Print</span>
<span># -----------------------------</span>
<span>for </span>line <span>in</span> <span>&#34;</span><span>${</span><span>rows</span><span>[@]</span><span>}</span><span>&#34;</span><span>;</span> <span>do
  </span><span>echo</span> <span>&#34;</span><span>$line</span><span>&#34;</span>
<span>done</span> | <span>sort</span> <span>-rn</span> | <span>cut</span> <span>-d</span><span>&#39; &#39;</span> <span>-f2-</span>
</code></pre></div>    </div>

  </div>
</details>

<p>After enabling those rules in batches, it’s also crucial to make sure enough job worker resources are available to sufficiently speed up this process.</p>

<hr/>

<h2 id="analyzing-performance">Analyzing performance</h2>

<p>After migrating all our Kamal-ized apps to push and pull from our new on-premise registry, it was finally time to actually get some numbers on performance in. We grabbed this data directly from the deployment logs printed by Kamal.</p>

<p>You can use these quick one-liners for extracting the pull times from the Kamal log on your terminal:</p>
<div><div><pre><code><span># Mac</span>
pbpaste | <span>sort</span> | <span>sed</span> <span>&#39;s/  INFO //&#39;</span> | <span>grep</span> <span>-E</span> <span>&#34;Running docker pull&#34;</span> <span>-B1</span> | <span>grep </span>Finished | <span>awk</span> <span>&#39;{print $4}&#39;</span> | <span>sort</span> | <span>tr</span> <span>&#39;\n&#39;</span> <span>&#39; &#39;</span>
<span># Linux</span>
xclip <span>-o</span> | <span>sort</span> | <span>sed</span> <span>&#39;s/  INFO //&#39;</span> | <span>grep</span> <span>-E</span> <span>&#34;Running docker pull&#34;</span> <span>-B1</span> | <span>grep </span>Finished | <span>awk</span> <span>&#39;{print $4}&#39;</span> | <span>sort</span> | <span>tr</span> <span>&#39;\n&#39;</span> <span>&#39; &#39;</span>
</code></pre></div></div>

<p>Or from a logfile:</p>
<div><div><pre><code><span>awk</span> <span>&#39;
/Running .*docker pull/ {
  if (match($0, /\[([a-f0-9]+)\]/, m)) {
    id = m[1]
    running[id] = $0
  }
}
/Finished/ {
  if (match($0, /\[([a-f0-9]+)\]/, m)) {
    id = m[1]
    if (id in running) {
      print running[id]
      print $0
      print &#34;&#34;
      delete running[id]
    }
  }
}
&#39;</span> /path/to/kamal.log
</code></pre></div></div>

<p>After analyzing the numbers, we were quite happy to see that:</p>

<ul>
  <li>The overall image pull timings on our fleet <strong>decreased by up to 25 seconds</strong> for HEY, Basecamp 4 and Basecamp 2 (our three largest apps), with the lion’s share of improvement on our HEY nodes on the Amsterdam outposts.</li>
  <li>Deploy times <strong>decreased by 15 seconds for HEY</strong>.</li>
</ul>

<p>In addition, it allowed us to:</p>

<ul>
  <li>Retire the Dockerhub cache setup, further detangling our infrastructure.</li>
  <li>Implement proper retention policies and garbage collection to decrease the overall storage quota from almost 9 TiB to 1.5 TiB.</li>
  <li>Save roughly $5k/year on subscription fees going forward.</li>
</ul>

<p><strong>Remember:</strong> this is basically a single-node infrastructure, with the primary endpoint being in Chicago, and the Ashburn site providing the backup. We found that this small setup has been reliable for roughly two months now. During this time, Harbor has served more than 32,000 pulls under company-wide use in day-to-day business.</p>

<hr/>

<h2 id="conclusion">Conclusion</h2>

<p>This project proved to us that it’s — again — worth considering a departure from large SaaS offerings and public cloud providers. We’ve been dependent on external registries keeping our app images for years, but the simplicity and benefits of our current setup give little reason to doubt that cutting the cord was the right decision: better performance at less cost with minimal infrastructure.</p>




            </div><div>
  <p>Sign up to get posts via email,</p>
  
</div></div>
  </body>
</html>
