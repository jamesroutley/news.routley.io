<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://eieio.games/nonsense/teleyegraph/">Original</a>
    <h1>TelEyegraph: Convert blinks to morse code</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
        <p>I made a little tool. It’s called telEyegraph. It converts blinks to morse code.</p>



<p>I built it because I’m fascinated with <a href="http://eieio.games/nonsense/game-12-stranger-video/">controlling things with your eyes</a> and as a test of the React and CSS skills that I spent January learning.</p>

<p>You can play with it <a href="http://eieio.games/teleyegraph">here</a> or <a href="https://github.com/nolenroyalty/teleyegraph">check out the code on github</a>.
<!-- excerpt-end --></p>


<p>Before we talk about how TelEyegraph works let’s talk about the basics of morse code.</p>

<p>Characters in morse code are described using “dits” and “dahs” - you may know these as “dots” and “dashes.” An “S” is written as “. . .” (dit dit dit) and an O as “- - -“ (dah dah dah).</p>

<p>Morse code is sequence of signals that are “on” or “off.” Being “on” typically means sending a sound. In TelEyegraph it means your eyes being closed. Being off means silence (or your eyes being open).</p>

<p>Dits and dahs are distinguished by <em>time</em> - a dah is three times longer than a dit. A dit’s length isn’t fixed; different operators may choose different dit speeds (if you’re new to morse code - and I suspect you are - you probably want to use a slow dit speed!).</p>

<div>
    
    <p><img src="http://eieio.games/assets/images/teleyegraph/morse-legend.png" alt=""/></p><p> a guide to morse code from wikipedia </p>
    
</div>

<p>To separate dits, dahs, characters, and words we use spaces. One space is represented as being “off” for 1 dit. Dits and dahs within a character are separated by one space, characters within a word are separated by four spaces, and words are separated by seven spaces.</p>

<p>So interpreting morse code is something like:</p>
<ol>
  <li>Agree on a dit speed.</li>
  <li>When you’ve been on for one dit add a . to the current signal</li>
  <li>When you’ve been on for three dits convert that . to a -</li>
  <li>When you’ve been off for one dit append your . or - to the current character</li>
  <li>When you’ve been off for four dits convert your current set of signals (e.g - -) to a character (M) and add it to the current word.</li>
  <li>When you’ve been off for seven dits, add your current word to the sentence.</li>
</ol>

<p>Not too bad! How does that translate to React?</p>


<p><em>Feel free to skip or skim this if you don’t want to hear about my React struggles</em></p>

<p>Ok, well, I did not translate this to React particularly well. But that’s largely because I was about 3 weeks into <a href="https://courses.joshwcomeau.com/joy-of-react">Josh W. Comeau’s lovely React course</a> when I made TelEyegraph.</p>

<p>Morse code is all about consuming a long series of short events and updating your state in response to it. React is all about re-rendering your UI in response to state updates. And I struggled to reconcile these two things - to consume events on each video frame without re-rendering the entire site on each video frame (there are a lot of frames in a second - that’s a lot of re-rendering!).</p>

<p>My naive React implementation looked something like:</p>
<div><div><pre><code><span>function</span> <span>useProcessFrame</span><span>(</span><span>signalState</span><span>,</span> <span>updateSignalState</span><span>,</span> <span>video</span><span>)</span> <span>{</span>
    <span>const</span> <span>requestRef</span> <span>=</span> <span>React</span><span>.</span><span>useRef</span><span>();</span>

    <span>React</span><span>.</span><span>useEffect</span><span>(()</span> <span>=&gt;</span> <span>{</span>
        <span>const</span> <span>processFrame</span> <span>=</span> <span>()</span> <span>=&gt;</span> <span>{</span>
            <span>const</span> <span>eyesClosed</span> <span>=</span> <span>determineEyesClosed</span><span>(</span><span>video</span><span>);</span>
            <span>if</span> <span>(</span><span>eyesClosed</span><span>)</span> <span>{</span>
                <span>updateSignalState</span><span>(</span><span>&#34;</span><span>on</span><span>&#34;</span><span>);</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>updateSignalState</span><span>(</span><span>&#34;</span><span>off</span><span>&#34;</span><span>);</span>
            <span>}</span>

            <span>if</span> <span>(</span><span>signalState</span><span>.</span><span>on</span> <span>&gt;</span> <span>DIT_LENGTH</span><span>)</span> <span>{</span>
                <span>addDit</span><span>();</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>signalState</span><span>.</span><span>off</span> <span>&gt;</span> <span>DIT_LENGTH</span><span>)</span> <span>{</span>
                <span>addSpace</span><span>();</span>
            <span>}</span>
            <span>requestRef</span><span>.</span><span>current</span> <span>=</span> <span>window</span><span>.</span><span>requestAnimationFrame</span><span>(</span><span>processFrame</span><span>);</span>
        <span>}</span>

        <span>requestRef</span><span>.</span><span>current</span> <span>=</span> <span>window</span><span>.</span><span>requestAnimationFrame</span><span>(</span><span>processFrame</span><span>);</span>
        <span>// Cleanup</span>
        <span>return</span> <span>()</span> <span>=&gt;</span> <span>window</span><span>.</span><span>cancelAnimationFrame</span><span>(</span><span>requestRef</span><span>.</span><span>current</span><span>)</span>
    <span>},</span> <span>[</span><span>updateSignalState</span><span>,</span> <span>signalState</span><span>]</span>
<span>}</span>
</code></pre></div></div>

<p>The basic idea here is: every frame, check whether the user is closing their eyes and potentially add a dit or a space to our current state. This is pseudo-codey and doesn’t actually work in React (for one, signalState won’t be updated immediately so our if statements that check its value won’t follow at the right time). But let’s ignore that for now.</p>

<p>The fundamental problem here is that this loop requires access to the current <code>signalState</code> - but the rules of React say that if <code>signalState</code> is a state variable (the type of thing that can force your UI to update when it changes), <code>procesFrame</code> needs to be redeclared every time <code>signalState</code> changes. “Redeclaring” here means canceling the current <code>requestAnimationFrame</code> (using the cleanup function that I return), redefining <code>processFrame</code>, and re-registering it with <code>requestAnimationFrame.</code> And we’d need to do that on <em>every</em> frame - 60 times a second!</p>

<p>I worked around this by using <code>refs</code><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup> - React’s way of declaring state that can be mutated <em>without</em> triggering a state update. I use a <em>ton</em> of refs. Too many. I store <em>all</em> of the state about whether a user is blinking in <code>refs</code> and then have a single state variable called <code>consume</code> that I flip to <code>true</code> when it’s time for the UI to update (when we add a new dit or space). The UI notices that <code>consume</code> is true, updates its state, and then flips <code>consume</code> to false.</p>

<p>This…works. It’s ugly and not very React-y, but I didn’t know how else to handle the problem.</p>

<p>This was frustrating to me because I know how I’d like to solve this in a functional way - I want a state machine that consumes a sequence of updates (“ons” and “offs”) and potentially updates its state in response. I just didn’t know how to make that happen in React.</p>

<p>Immediately after finishing TelEyegraph I went back to <a href="https://courses.joshwcomeau.com/joy-of-react">Josh’s Class</a> and learned about <a href="https://react.dev/reference/react/useReducer">useReducer</a>, which is React’s way of creating a state machine that receives updates and updates its state in response. I kicked myself a little for not finding it, but hey - I’m never going to forget that useReducer exists.</p>


<p>One fun challenge with TelEyegraph was figuring out how to help folks understand how Morse code works, since I figured people wouldn’t come in knowing much.</p>

<p>Fortunately Morse code is pretty straightforward - we use a simple series of rules to move from “creating a dit or dah” to adding a character to adding a word.</p>

<p>I chose to visualize these transitions by fading things in and out. As a character is added to a word, the dits and dahs of that character fade out and the character to be added fades in. The same thing happens when adding a word to a paragraph.</p>

<div>
<div>
    
    
    <video playsinline="" controls="" muted="" poster=" /assets/images/teleyegraph/fade-example-firstframe.png ">
    
        <source src="/assets/images/teleyegraph/fade-example.mp4" type="video/mp4"/>
    </video>
    
    <p> Dits transform into dahs, which fade out as characters fade in </p>
    
</div>

</div>

<p>I also chose to add a telegraph button that you could to manually send signals, since it’s probably easier to focus on visualizations when your eyes are open.</p>

<p>I’m pretty happy with how all of this turned out! It certainly gave me a better understanding of Morse code.</p>


<p>I’d never used React before - why’d I decide to go learn it?</p>

<p>Well, at the start of this year I realized that I wasn’t very happy with the tools that I was using. I had tons of energy to work on things like <a href="http://eieio.games/nonsense/game-11-flappy-bird-finder">flappy dird</a> where I was using technology that I liked, but found myself dragging my feet every time I went back to making a game in Godot.</p>

<p>My initial reaction to this was to try to push through. Sometimes you don’t want to work and still have to! But I eventually decided that that wasn’t the right attitude. I’m building games and toys because it’s fun and I like doing it. I’m at my best when I’m excited about my work. And when my tools are causing me to not like my work, <em>that’s a problem.</em></p>

<p>I made a list of things that Godot didn’t have that I thought I really needed to be happy as a developer. Things like:</p>
<ul>
  <li>A mature ecosystem with a good package manager</li>
  <li>First class functions<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup></li>
  <li>A well supported code formatter that auto-formats on save</li>
  <li>A type system that I like</li>
  <li>The ability to work without a mouse (and a pleasant development experience on a laptop)</li>
</ul>

<p>Javascript (with TypeScript) checks all of those boxes. I enjoyed using it for <a href="http://eieio.games/nonsense/game-12-stranger-video/">stranger video</a> - and really enjoyed using CSS to lay things out instead of dragging things with my mouse. And so I figured I’d give it a try.</p>

<p>I started with React because I figured it was a good choice for some of what I wanted to make, that it’d be helpful for understanding other tools built in response to React, that it’d be a good way to get used to writing Javascript, and because I knew of a good class on it. The fact that Josh also had a <a href="https://courses.joshwcomeau.com/css-for-js">class on CSS</a> which I also needed to learn certainly helped<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup>.</p>

<p>So far I’m really happy with my decisions here. I like using React and I’m excited to build some other stuff with it. I’m excited to learn about the broader Javascript ecosystem and to take a look at tools more purpose built for game building. And more than anything I’m excited that I chose to replace the tools that I didn’t like.</p>


<p>I’d like to write more about the experience of picking better tools but I’ll save that for a separate blog. I’ve got all sorts of dumb stuff that I’m ready to go build now - both webapps and broader nonsense. Last night I started working on “pong running in Apple Calendar via iOS shortcuts.” We’ll see how that goes.</p>

<p>Till next time!</p>



    </div></div>
  </body>
</html>
