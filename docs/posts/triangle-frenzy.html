<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cancandan.github.io/julia/graphics/cuda/2022/05/07/triangles.html">Original</a>
    <h1>Triangle frenzy</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Suppose we want to draw a batch of images, where each image is made up of randomly positioned and colored triangles, that are blending. It will look like this:</p>

<p><img src="https://cancandan.github.io/assets/static/avnicompare.png" alt="triangles"/></p>

<p>and then find the euclidean distance of each such image to a given target image.</p>

<p>Now why on earth am I doing this? Well, this turns into an interesting optimization problem of finding the closest triangle image and also an excuse to practise Julia. The inspiration is from the <a href="https://github.com/google/brain-tokyo-workshop/tree/master/es-clip">this repo</a> based on <a href="https://github.com/google/evojax">EvoJax</a>.</p>

<p>Towards framing this as an optimization problem, we will represent a triangle as a vector of size 10, made up of floating point numbers between 0 and 1. Four numbers of this vector are for the color of the triangle; r,g,b and alpha, and for the three vertices of the triangle we need 6 numbers, (x1,y1), (x2,y2), (x3,y3). Hence, if we want to draw M images, each image having N triangles, we need a matrix of size (10,N,M), which will be our parameters matrix. I want to randomly create such a matrix and <a href="https://en.wikipedia.org/wiki/Feature_scaling#Rescaling_\(min-max_normalization\)">min-max scale</a> it along the triangle dimension, by which I mean, for each image, I first find the minimum and maximum of a triangle parameter among the N triangles, and then subtract from the parameter this minimum and then divide the result by the difference between the maximum and the minimum. I want to end up with an array of size (3,w,h,M) for the images, where w is width and h is height, and an array of size M for the distances. Let’s see how fast we can do this.</p>

<p>First order of business is setting this up, note that I am scaling the numbers to the given width and height:</p>

<figure><pre><code data-lang="julia"><span>using</span> <span>Images</span>
<span>using</span> <span>Statistics</span>
<span>using</span> <span>Cairo</span>
<span>using</span> <span>BenchmarkTools</span>
<span>using</span> <span>Random</span><span>:</span> <span>seed!</span>

<span>function</span><span> prepare</span><span>()</span>
    <span>seed!</span><span>(</span><span>123</span><span>)</span>
    <span>w</span><span>,</span><span>h</span><span>=</span><span>128</span><span>,</span><span>128</span>
    <span>num_params</span><span>=</span><span>10</span>
    <span>num_triangles</span><span>=</span><span>50</span>
    <span>num_images</span><span>=</span><span>256</span>
    <span>target</span> <span>=</span> <span>rand</span><span>(</span><span>Float32</span><span>,</span> <span>3</span><span>,</span> <span>h</span><span>,</span> <span>w</span><span>)</span>
    <span>prms</span> <span>=</span> <span>rand</span><span>(</span><span>Float32</span><span>,</span> <span>num_params</span><span>,</span> <span>num_triangles</span><span>,</span> <span>num_images</span><span>);</span>
    <span>prms</span> <span>.=</span> <span>(</span><span>prms</span> <span>.-</span> <span>minimum</span><span>(</span><span>prms</span><span>,</span> <span>dims</span><span>=</span><span>2</span><span>))</span> <span>./</span> <span>(</span><span>maximum</span><span>(</span><span>prms</span><span>,</span> <span>dims</span><span>=</span><span>2</span><span>)</span> <span>.-</span> <span>minimum</span><span>(</span><span>prms</span><span>,</span> <span>dims</span><span>=</span><span>2</span><span>))</span>   
    <span>prms</span><span>[</span><span>collect</span><span>(</span><span>1</span><span>:</span><span>2</span><span>:</span><span>6</span><span>),</span><span>:</span><span>,</span><span>:</span><span>]</span> <span>.*=</span> <span>w</span>
    <span>prms</span><span>[</span><span>collect</span><span>(</span><span>2</span><span>:</span><span>2</span><span>:</span><span>6</span><span>),</span><span>:</span><span>,</span><span>:</span><span>]</span> <span>.*=</span> <span>h</span>         
    <span>return</span> <span>prms</span><span>,</span> <span>target</span><span>,</span> <span>num_images</span><span>,</span> <span>num_triangles</span><span>,</span> <span>w</span><span>,</span> <span>h</span>
<span>end</span></code></pre></figure>

<h2 id="with-a-2d-library">With a 2d library</h2>

<p>The first thing that comes to mind is to use a 2d graphics library for drawing, and since the <a href="https://github.com/JuliaGraphics/Cairo.jl">Cairo lib</a> is available, let’s try that. The function below is drawing the triangles on a blank white Cairo canvas, and copying it to the img array at the end:</p>

<figure><pre><code data-lang="julia"><span>@views</span> <span>function</span><span> renderCairo</span><span>(</span><span>img</span><span>,</span> <span>prms</span><span>,</span> <span>num_triangles</span><span>,</span> <span>w</span><span>,</span> <span>h</span><span>)</span>                  
    <span># blank white canvas</span>
    <span>buffer</span> <span>=</span> <span>ones</span><span>(</span><span>UInt32</span><span>,</span> <span>w</span><span>,</span> <span>h</span><span>)</span> <span>*</span> <span>typemax</span><span>(</span><span>UInt32</span><span>)</span>    
    <span>c</span> <span>=</span> <span>Cairo</span><span>.</span><span>CairoImageSurface</span><span>(</span><span>buffer</span><span>,</span> <span>Cairo</span><span>.</span><span>FORMAT_ARGB32</span><span>,</span> <span>flipxy</span><span>=</span><span>false</span><span>)</span>
    <span>cr</span> <span>=</span> <span>CairoContext</span><span>(</span><span>c</span><span>);</span>        
    
    <span>for</span> <span>i</span> <span>in</span> <span>1</span><span>:</span><span>num_triangles</span>
        <span>q</span> <span>=</span> <span>prms</span><span>[</span><span>:</span><span>,</span><span>i</span><span>]</span>
        <span>set_source_rgba</span><span>(</span><span>cr</span><span>,</span><span>q</span><span>[</span><span>7</span><span>],</span> <span>q</span><span>[</span><span>8</span><span>],</span> <span>q</span><span>[</span><span>9</span><span>],</span> <span>q</span><span>[</span><span>10</span><span>])</span>        
        <span>move_to</span><span>(</span><span>cr</span><span>,</span> <span>q</span><span>[</span><span>1</span><span>],</span><span>q</span><span>[</span><span>2</span><span>]);</span>
        <span>line_to</span><span>(</span><span>cr</span><span>,</span> <span>q</span><span>[</span><span>3</span><span>],</span><span>q</span><span>[</span><span>4</span><span>]);</span>
        <span>line_to</span><span>(</span><span>cr</span><span>,</span> <span>q</span><span>[</span><span>5</span><span>],</span><span>q</span><span>[</span><span>6</span><span>]);</span>
        <span>close_path</span><span>(</span><span>cr</span><span>);</span>
        <span>fill</span><span>(</span><span>cr</span><span>);</span>            
    <span>end</span>        
            
    <span>resultimg</span> <span>=</span> <span>reinterpret</span><span>(</span><span>ARGB32</span><span>,</span> <span>permutedims</span><span>(</span><span>c</span><span>.</span><span>data</span><span>,</span> <span>(</span><span>2</span><span>,</span> <span>1</span><span>)))</span>
    <span>resultchn</span> <span>=</span> <span>Float32</span><span>.</span><span>(</span><span>channelview</span><span>(</span><span>RGB</span><span>.</span><span>(</span><span>resultimg</span><span>)))</span>                
    <span>img</span> <span>.=</span> <span>resultchn</span>
    <span>Cairo</span><span>.</span><span>finish</span><span>(</span><span>c</span><span>)</span>
    <span>Cairo</span><span>.</span><span>destroy</span><span>(</span><span>c</span><span>)</span>        
<span>end</span></code></pre></figure>

<p>Now let’s draw each image in this fashion:</p>

<figure><pre><code data-lang="julia"><span>@views</span> <span>function</span><span> withCairo</span><span>()</span> 
    <span>prms</span><span>,</span> <span>target</span><span>,</span> <span>num_images</span><span>,</span> <span>num_triangles</span><span>,</span> <span>w</span><span>,</span> <span>h</span> <span>=</span> <span>prepare</span><span>()</span> 

    <span>imgs</span> <span>=</span> <span>Array</span><span>{</span><span>Float32</span><span>}(</span><span>undef</span><span>,</span> <span>3</span><span>,</span> <span>h</span><span>,</span> <span>w</span><span>,</span> <span>num_images</span><span>)</span>    
    <span>for</span> <span>i</span> <span>in</span> <span>1</span><span>:</span><span>num_images</span>
        <span>img</span> <span>=</span> <span>imgs</span><span>[</span><span>:</span><span>,</span><span>:</span><span>,</span><span>:</span><span>,</span><span>i</span><span>]</span>        
        <span>renderCairo</span><span>(</span><span>img</span><span>,</span> <span>prms</span><span>[</span><span>:</span><span>,</span><span>:</span><span>,</span><span>i</span><span>],</span> <span>num_triangles</span><span>,</span> <span>w</span><span>,</span> <span>h</span><span>)</span>        
    <span>end</span>
    <span>dists</span> <span>=</span> <span>reshape</span><span>(</span><span>mean</span><span>((</span><span>imgs</span> <span>.-</span> <span>target</span><span>)</span> <span>.^</span><span>2</span><span>,</span> <span>dims</span><span>=</span><span>(</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>)),</span> <span>num_images</span><span>)</span>
    <span>return</span> <span>imgs</span><span>,</span> <span>1</span> <span>.-</span> <span>dists</span>
<span>end</span></code></pre></figure>

<p>Benchmarking this with <code>@btime withCairo();</code></p>

<p>I see <code>428.101 ms (3157 allocations: 205.09 MiB)</code>.</p>

<h2 id="the-cross-product-method">The cross product method</h2>

<p>Now the cool part. Move your mouse inside and outside of the triangle below. You will see a bar chart, depicting the magnitude and direction of the 3rd components of the cross products, AB with AP (reds), BC with BP (greens) and CA with CP (blues). Observe that all those bars point to the same direction ONLY inside the triangle!</p>





<p>Whats great about this is that, cross products are just multiplications and subtractions, perfect job to parallelize with a GPU.</p>

<p>So, what needs to be done is clear. For each of the M images, and for each of the N triangles, our operation is to update a pixel color to blend with the current triangle’s color, if that pixel is inside the triangle. We will parallelize this operation with a CUDA kernel, shown below:</p>

<figure><pre><code data-lang="julia"><span>using</span> <span>CUDA</span>

<span>function</span><span> puttri</span><span>(</span><span>prms</span><span>,</span> <span>imgs</span><span>,</span> <span>tri</span><span>,</span> <span>ins</span><span>)</span>    
    <span>idx</span> <span>=</span> <span>(</span><span>blockIdx</span><span>()</span><span>.</span><span>x</span> <span>-</span> <span>1</span><span>)</span> <span>*</span> <span>blockDim</span><span>()</span><span>.</span><span>x</span> <span>+</span> <span>threadIdx</span><span>()</span><span>.</span><span>x</span>  
    <span>idy</span> <span>=</span> <span>(</span><span>blockIdx</span><span>()</span><span>.</span><span>y</span> <span>-</span> <span>1</span><span>)</span> <span>*</span> <span>blockDim</span><span>()</span><span>.</span><span>y</span> <span>+</span> <span>threadIdx</span><span>()</span><span>.</span><span>y</span>
    
    <span>abx</span> <span>=</span> <span>prms</span><span>[</span><span>3</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span> <span>-</span> <span>prms</span><span>[</span><span>1</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
    <span>aby</span> <span>=</span> <span>prms</span><span>[</span><span>4</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span> <span>-</span> <span>prms</span><span>[</span><span>2</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
    <span>apx</span> <span>=</span> <span>idx</span> <span>-</span> <span>prms</span><span>[</span><span>1</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
    <span>apy</span> <span>=</span> <span>idy</span> <span>-</span> <span>prms</span><span>[</span><span>2</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
    <span>cr1</span> <span>=</span> <span>apx</span> <span>*</span> <span>aby</span> <span>-</span> <span>apy</span> <span>*</span> <span>abx</span>

    <span>bcx</span> <span>=</span> <span>prms</span><span>[</span><span>5</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span> <span>-</span> <span>prms</span><span>[</span><span>3</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
    <span>bcy</span> <span>=</span> <span>prms</span><span>[</span><span>6</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span> <span>-</span> <span>prms</span><span>[</span><span>4</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
    <span>bpx</span> <span>=</span> <span>idx</span> <span>-</span> <span>prms</span><span>[</span><span>3</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
    <span>bpy</span> <span>=</span> <span>idy</span> <span>-</span> <span>prms</span><span>[</span><span>4</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
    <span>cr2</span> <span>=</span> <span>bpx</span> <span>*</span> <span>bcy</span> <span>-</span> <span>bpy</span> <span>*</span> <span>bcx</span>

    <span>cax</span> <span>=</span> <span>prms</span><span>[</span><span>1</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span> <span>-</span> <span>prms</span><span>[</span><span>5</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
    <span>cay</span> <span>=</span> <span>prms</span><span>[</span><span>2</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span> <span>-</span> <span>prms</span><span>[</span><span>6</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
    <span>cpx</span> <span>=</span> <span>idx</span> <span>-</span> <span>prms</span><span>[</span><span>5</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
    <span>cpy</span> <span>=</span> <span>idy</span> <span>-</span> <span>prms</span><span>[</span><span>6</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
    <span>cr3</span> <span>=</span> <span>cpx</span> <span>*</span> <span>cay</span> <span>-</span> <span>cpy</span> <span>*</span> <span>cax</span>

    <span>if</span> <span>((</span><span>cr1</span><span>&gt;=</span><span>0</span><span>)</span> <span>&amp;</span> <span>(</span><span>cr2</span><span>&gt;=</span><span>0</span><span>)</span> <span>&amp;</span> <span>(</span><span>cr3</span><span>&gt;=</span><span>0</span><span>))</span> <span>|</span> <span>((</span><span>cr1</span><span>&lt;=</span><span>0</span><span>)</span> <span>&amp;</span> <span>(</span><span>cr2</span><span>&lt;=</span><span>0</span><span>)</span> <span>&amp;</span> <span>(</span><span>cr3</span><span>&lt;=</span><span>0</span><span>))</span>
        <span>oneMinusAlpha</span> <span>=</span> <span>(</span><span>1.0f0</span><span>-</span><span>prms</span><span>[</span><span>10</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>])</span>        
        <span>imgs</span><span>[</span><span>1</span><span>,</span><span>idx</span><span>,</span><span>idy</span><span>,</span><span>ins</span><span>]</span> <span>=</span> <span>imgs</span><span>[</span><span>1</span><span>,</span><span>idx</span><span>,</span><span>idy</span><span>,</span><span>ins</span><span>]</span> <span>*</span> <span>oneMinusAlpha</span> <span>+</span> <span>prms</span><span>[</span><span>7</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span> <span>*</span> <span>prms</span><span>[</span><span>10</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
        <span>imgs</span><span>[</span><span>2</span><span>,</span><span>idx</span><span>,</span><span>idy</span><span>,</span><span>ins</span><span>]</span> <span>=</span> <span>imgs</span><span>[</span><span>2</span><span>,</span><span>idx</span><span>,</span><span>idy</span><span>,</span><span>ins</span><span>]</span> <span>*</span> <span>oneMinusAlpha</span> <span>+</span> <span>prms</span><span>[</span><span>8</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span> <span>*</span> <span>prms</span><span>[</span><span>10</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
        <span>imgs</span><span>[</span><span>3</span><span>,</span><span>idx</span><span>,</span><span>idy</span><span>,</span><span>ins</span><span>]</span> <span>=</span> <span>imgs</span><span>[</span><span>3</span><span>,</span><span>idx</span><span>,</span><span>idy</span><span>,</span><span>ins</span><span>]</span> <span>*</span> <span>oneMinusAlpha</span> <span>+</span> <span>prms</span><span>[</span><span>9</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span> <span>*</span> <span>prms</span><span>[</span><span>10</span><span>,</span><span>tri</span><span>,</span><span>ins</span><span>]</span>
    <span>end</span>
    <span>return</span>
<span>end</span></code></pre></figure>

<p>We will need to pass our parameters and target array to the GPU, and then call the kernel with <code>@cuda</code>. We can create white canvases with <code>CUDA.ones</code> here, so no need to pass it.</p>

<figure><pre><code data-lang="julia"><span>function</span><span> withGpu</span><span>()</span>
    <span>prms</span><span>,</span> <span>target</span><span>,</span> <span>num_images</span><span>,</span> <span>num_triangles</span><span>,</span> <span>w</span><span>,</span> <span>h</span> <span>=</span> <span>prepare</span><span>()</span>     

    <span>prms</span> <span>=</span> <span>CuArray</span><span>(</span><span>prms</span><span>)</span>    
    <span>imgs</span> <span>=</span> <span>CUDA</span><span>.</span><span>ones</span><span>(</span><span>3</span><span>,</span> <span>h</span><span>,</span> <span>w</span><span>,</span> <span>num_images</span><span>)</span>
    <span>target</span> <span>=</span> <span>CuArray</span><span>(</span><span>target</span><span>)</span>
    <span>for</span> <span>tri</span> <span>in</span> <span>1</span><span>:</span><span>num_triangles</span>
        <span>for</span> <span>i</span> <span>in</span> <span>1</span><span>:</span><span>num_images</span>
            <span>@cuda</span> <span>threads</span><span>=</span><span>(</span><span>32</span><span>,</span><span>32</span><span>)</span> <span>blocks</span><span>=</span><span>(</span><span>8</span><span>,</span><span>8</span><span>)</span> <span>puttri</span><span>(</span><span>prms</span><span>,</span> <span>imgs</span><span>,</span> <span>tri</span><span>,</span> <span>i</span><span>)</span>        
        <span>end</span>                                
    <span>end</span>
    <span>gpufitnesses</span> <span>=</span> <span>1.0f0</span> <span>.-</span> <span>reshape</span><span>(</span><span>mean</span><span>((</span><span>imgs</span> <span>.-</span> <span>target</span><span>)</span> <span>.^</span> <span>2</span><span>,</span> <span>dims</span><span>=</span><span>(</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>)),</span><span>num_images</span><span>)</span>
    <span>return</span> <span>Array</span><span>(</span><span>imgs</span><span>),</span> <span>Array</span><span>(</span><span>gpufitnesses</span><span>)</span>
<span>end</span></code></pre></figure>

<p>Benchmarking this I see <code>120.315 ms (38689 allocations: 52.53 MiB)</code></p>

<p>That’s about 4x speedup, not really impressive, but perhaps not too bad considering I have an old GPU. Note that I benchmarked with <code>--check-bounds=no</code>, which is a startup option that you pass to Julia, when launching, that disables the performance killer “bounds checking”.</p>

<p>In the next post, I will talk about the very cool and general <a href="https://people.idsia.ch/~juergen/icann2008sehnke.pdf">PGPE</a> algorithm used in <a href="https://github.com/google/evojax">EvoJax</a> to steer these images towards a target image. You can see one example of this <a href="https://cancandan.github.io/about/">here</a>.</p>

<p>Please let me know if you have any comments, suggestions, improvements.</p>

  </div>
</article>

        
      </div>      
    </div></div>
  </body>
</html>
