<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.kenanb.com/code/low-level/2024/01/06/encoding-diagram-attempt.html">Original</a>
    <h1>Exploring x86-64 Instruction Encoding</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>I tried to generate a diagram of the x86-64 legacy encoding based on what I know so far.</p>

<p>In <a href="https://blog.kenanb.com/code/low-level/2024/01/05/x86-64-insn-encoding.html">the last post</a>, we dove into the x86-64 binary we generated earlier, and figured out the encoding.</p>

<p>[ <em>Check out all posts in “low-level” series <a href="https://blog.kenanb.com/series/#low-level">here</a>.</em> ]</p>

<p>Recently, based on my limited (and possibly faulty) understanding, I drew an encoding diagram to help myself hand-decode x86-64. Today, I decided to share that diagram.</p>

<p>We will also test it with a few instruction variations. Hopefully, it will at least help someone build a minimal mental model.</p>

<p><strong>Update [ 2024-01-08 ]</strong>: This post generated <a href="https://news.ycombinator.com/item?id=38899860">a super informative discussion on HN</a>.</p>

<h2 id="addressing-modes">Addressing Modes</h2>

<p>Understanding the complete encoding requires understanding all possible “addressing modes” used in x86 family, in detail. However, the nomenclature regarding addressing modes varies.</p>

<p><strong>I am pretty much a newbie in assembly.</strong> So I rather avoid adding further to the confusion by trying to document addressing modes. I just skimmed <a href="https://stackoverflow.com/a/34058400">this StackOverflow answer</a> and <a href="https://blog.yossarian.net/2020/06/13/How-x86_64-addresses-memory">this blog post</a>, both look like good, detailed descriptions.</p>

<p>But I will mention a few “building block” terms to help read the diagram.</p>

<p>These three terms will show up in the <code>SIB byte</code>:</p>
<ul>
  <li>Base: A base address stored in a register.</li>
  <li>Index: A, possibly scaled, numeric offset stored in a register.</li>
  <li>Scale: A scaling factor, scaling options being 1, 2, 4, and 8, stored in the instruction.</li>
</ul>

<p>While at it, I also often encounter these terms that refer to static <code>displacements</code> encoded in the instruction:</p>
<ul>
  <li>Absolute: Means there is a static address literally encoded in the instruction.</li>
  <li>Offset: Means there is a static numeric offset literally encoded in the instruction.</li>
</ul>

<p>If you read up further on addressing modes, note that there are also cases where two addressing methods sound identical, while they are subtly different <a href="https://stackoverflow.com/a/34058400">due to encoding limitations</a>.</p>

<h2 id="encoding-diagram">Encoding Diagram</h2>

<p>Below is the diagram. It doesn’t document <a href="https://en.wikipedia.org/wiki/VEX_prefix">VEX encoding</a>. This is just the legacy encoding with REX prefix. The <code>ModR/M</code> and <code>SIB</code> bytes are vertically placed (least-significant-bit being the top), to emphasize that REX byte “extends” the values stored of those bytes. Their actual placement in the instruction layout should also be clear
.
<img src="https://blog.kenanb.com/assets/img/x86-64-insn-encoding.png" alt="Legacy (non-VEX) x86-64 Instruction Encoding" width="740"/></p>

<p>The source of this diagram is (and future iterations will be) <a href="https://github.com/kenanb/kenanb-blog/tree/main/diagram/x86-insn-encoding">available here in SVG form</a>.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>Right click and open the image in new tab to see the diagram in full size.</p>

<h3 id="other-resources">Other Resources</h3>

<p>Of course, this is inherently complicated. x86-only and simpler diagrams in <a href="http://www.c-jump.com/CIS77/CPU/x86/lecture.html">Encoding Real x86 Instructions</a> page are super useful for learning the layout without the added complexity of the REX prefix.</p>

<p>As usual, if you need reliable information on this, you should check out Intel’s <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Software Developer’s Manual</a> and AMD’s <a href="https://www.amd.com/en/search/documentation/hub.html#q=AMD64%20Architecture&amp;sortCriteria=%40amd_release_date%20descending&amp;f-amd_product_type=Processors&amp;f-amd_document_type=Programmer%20References">AMD64 Architecture Programmer’s Manual</a> volumes.</p>

<p><strong>Update [ 2024-01-08 ]</strong>: The complete set of resources is being <a href="https://blog.kenanb.com/code/low-level/2024/01/07/x86-insn-encoding-resources.html">collected in a separate post</a>.</p>

<h2 id="testing">Testing</h2>

<p>Now, let’s start testing with an instruction, and make modifications based on the diagram.</p>

<p>We start with <code>mov r8,rcx</code>. If we assemble this, we get <code>49 89 c8</code>.</p>

<p>The <code>4</code> (<code>b0100</code>) at the beginning matches the REX Fixed Bit Pattern.</p>

<p>The second byte is <strong>not</strong> <code>0F</code>, so this instruction has a single-byte opcode. Therefore,<code>89</code> is the opcode.</p>

<p>According to <a href="http://ref.x86asm.net/coder64.html#x89">reference table</a>, opcode <code>89</code> doesn’t store any register values itself. But it states that <code>ModR/M.reg</code> stores a register.</p>

<p>Therefore:</p>
<div><div><pre><code>REX   : 49
OPCODE: 89
MODR/M: c8
</code></pre></div></div>

<p>Now that we know the overall instruction layout, let’s figure out the details.</p>

<h3 id="rex-prefix">REX Prefix</h3>

<p>Looking at the REX byte (<code>49</code>) in binary:</p>


<p>We said <code>4</code> (<code>0100</code>) is the REX Fixed Bit Pattern. The remaining bits (<code>1001</code>) of the REX byte are:</p>
<div><div><pre><code>REX.W: 1
REX.R: 0
REX.X: 0
REX.B: 1
</code></pre></div></div>

<ul>
  <li><code>REX.W</code> flag being set means the instruction uses 64 bit operands.</li>
  <li><code>REX.B</code> is going to extend some register code somewhere, effectively adding 8 to its value.</li>
</ul>

<p>Since opcode doesn’t encode a register itself, and since there is no SIB byte, I guess it is <code>ModR/M.rm</code> being extended. (I am actually not sure if this reasoning is solid enough to cover all cases.)</p>

<p>It is easy to visually confirm if there is an “extended” register code, because it should show up as a register that has a numeric name pattern from <code>R8*</code> to <code>R15*</code> instead of something like <code>RDX</code>.</p>

<p>Remember, our original instruction was <code>49 89 c8</code>, which is <code>mov r8,rcx</code>.</p>
<ul>
  <li>We can see the effect of <code>REX.W</code> being set, as 64-bit registers are used.</li>
  <li>If we disassemble the version that has <code>REX.W</code> unset (<code>41 89 c8</code>), we get <code>mov r8d, ecx</code> which has 32-bit register operands.</li>
  <li>And if we toggle <code>REX.B</code> instead (<code>48 89 c8</code>), we get <code>mov rax, rcx</code>, which replaced <code>r8</code> with <code>rax</code>. Register code for <code>rax</code> is 0, and register code for <code>r8</code> is 8.</li>
  <li>We can also try to toggle <code>REX.R</code>, which is supposed to extend the <code>ModR/M.reg</code> slot. Disassembling <code>4d 89 c8</code> will give us <code>mov r8, r9</code>. So this time, <code>rcx</code> became <code>r9</code>.</li>
  <li>Since there is no <code>SIB</code> byte, I assume <code>REX.X</code> doesn’t have an impact for this instruction. (I am not sure if toggling that is valid or not.)</li>
</ul>

<p>So the mystery of the REX is solved, and there is nothing to decode in the opcode itself.</p>

<p>We can move on to the ModR/M byte.</p>

<h3 id="modrm-byte">ModR/M Byte</h3>

<p>We will split the ModR/M byte (<code>c8</code>) in binary form, into octal groups:</p>
<div><div><pre><code>MOD:  11
REG: 001
RM : 000
</code></pre></div></div>

<p>The opcode already established that <code>ModR/M.reg</code> stores a register, not an opcode extension.</p>

<p>REX.R extends <code>ModR/M.reg</code>, but it is unset. So effective register code for <code>ModR/M.reg</code> is 1, which means <code>rcx</code>.</p>

<p>REX.B extends <code>ModR/M.rm</code>, and it is set. So effective register code for <code>ModR/M.rm</code> is 8, which means <code>r8</code>.</p>

<ul>
  <li>If we bump <code>ModR/M.rm</code> by 1 (<code>49 89 c9</code>), we get <code>mov r9, rcx</code>.</li>
  <li>If we instead bump <code>ModR/M.reg</code> by 1 (<code>49 89 d0</code>), we get <code>mov r8, rdx</code>.</li>
</ul>

<p>So the overall encoding looks like this:</p>
<div><div><pre><code>          ____________________
         /                    \
0100 1001  10001001  11  001  (B)000
     |  |  MOV        | %RCX ,   %R8
     |  |             |
64-bit  extend        register addressing
        ModR/M.rm
</code></pre></div></div>

<h3 id="the-end">The End</h3>

<p>That’s it!</p>

<p>I think this is all I want to write about instruction encoding for a while. But I learned a lot in the process.</p>

<p>In the next post, I will share a list of resources that I found while writing these posts, and wrap this topic. But the “low-level” series will continue.</p>

<p>Thanks for reading!</p>



  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
