<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.vaxry.net/articles/2025-dbusSucks">Original</a>
    <h1>Problems with D-Bus on the Linux desktop</h1>
    
    <div id="readability-page-1" class="page"><div>
         <p><note data-title="FAQs"> There has been quite a bunch of interest in this post, I&#39;ve added a FAQ section at the bottom.</note> </p><p>D-Bus was introduced by GNOME folks about 20 years ago. For software made only 20 years ago, as opposed to 40 like X, it&#39;s surprisingly almost equally as bad. </p><p>As a service, D-Bus is incredibly handy and useful, and overall, I believe the <i>idea</i> should absolutely be used by more apps. However, the implementation... oh boy. </p> <p>Everyone has heard about D-Bus, but what is it, actually? </p><p>D-Bus&#39; idea is pretty simple: let applications, services and other <i>things</i> expose methods or properties in a way that other apps can find them in one place, on the bus. </p><p>Let&#39;s say we have a service that monitors the weather. Instead of each app knowing how to talk to each weather service, or even worse, implementing one itself, it can connect to the bus, and see if any service on the system exposes some weather API, then use it to get weather. </p><p>Great, right? And yeah, the idea is wonderful. </p> <p>D-Bus is a <i>lenient</i>, <i>unorganized</i> and <i>forgiving</i> bus. Those three add to one of the biggest, fundamental, and conceptual blunders to any protocol, language or system. </p><p>The most important blunders are: </p><ul><li>Objects on the bus can register whatever they want.</li> <li>Objects on the bus can call whatever they want, however they want, whenever they want.</li> <li>The protocol allows and even in a sense incentivises vendor-specific unchecked garbage.</li></ul> <p>What this means in practice is the definition of <b>&#34;Garbage in, garbage out&#34;</b>. </p><h2> D-Bus standards, part 1</h2> <p>Okay, apps need to communicate, right? Well, in some way right? Where do we find the way? </p><p>Uhh... somewhere online, probably. Nobody actually knows because some of them are here, some there, many are unfinished, unreadable, or convoluted garbage docs, and no client follows them anyways. </p><p>Let&#39;s take a look at some gems. <i>These are actual docs</i> </p><p><img title="" src="https://blog.vaxry.net/resource/articleDbus/image1.png"/> </p><p>Truly secure. </p><p><img title="" src="https://blog.vaxry.net/resource/articleDbus/image2.png"/> </p><p>I guess service implementors should learn telepathy. </p><p><img title="" src="https://blog.vaxry.net/resource/articleDbus/image3.png"/> </p><p>So is it a draft or widely used? </p><p>D-Bus standards are a mess. And that&#39;s if we assume that implementors on both sides actually follow them (they often don&#39;t, as we will learn in a moment...) </p><h2> D-Bus standards, part 2</h2> <p>Okay, let&#39;s say we have a standard and we understand it. Great! Now... </p><p><b>nobody gives a shit</b>, literally. Even if you read a spec, nothing, literally nothing, guides, ensures, or helps you stick to it. NOTHING. You send anonymous calls with whatever bullshit you want to throw in. </p><p>Let me tell you a story... </p><p>Back when I was writing xdg-desktop-portal-hyprland, I had to use a few dbus protocols (xdg portals run on dbus) to implement some of the communication. If we go to the portal documentation, we can find the protocols. </p><p>Great! So I implemented it. It worked more-or-less. Then, I implemented <i>restore tokens</i>, which allow the app to restore its previously saved share configuration. And here, dbus falls apart. </p><p>None of the apps, I repeat, <i>fucking none</i> followed the spec. I wrote a spec-compliant mechanism and <i>nothing fucking used it</i>. Why? Simple, they all used a different spec, which came out of <i>fucking</i> nowhere, I legit couldn&#39;t find a single doc with it. What I ended up doing was I looked at KDE which already had an impl and mimic&#39;d that. </p><p>What the actual fuck. &#34;Spec&#34; my ass. </p><p>Fun fact: <b>THIS IS STILL THE CASE!</b> The spec advertises a &#34;restore_token&#34; string prop on SelectSources and Start, where no app does this and uses &#34;restore_data&#34; in &#34;options&#34;. </p><h2> D-Bus standards, part 3</h2> <p>Let me just say one word: <i>variants</i>. What in the actual, everloving fuck? Half of D-Bus protocols have either this BS, or some &#34;a{sv}&#34; (array of string + variant) passed somewhere. </p><p>Putting something like this, even <i>allowing</i> that in a core spec should be subject to a permanent ban from creating software. What this allows, and even incentivises, is for apps to send random shit over the wire and hope the other side understands it. (see the example above in part 2, prime dbus) This has been tried many times, most notably in X with atoms, and it has time and time again proven to only bring disaster. </p><h2> D-Bus standards, part 4</h2> <p>Ever heard of permissions? Neither have D-Bus developers. D-Bus is as insecure as it gets. Everybody sees everything and calls whatever. If the app doesn&#39;t have a specific security mechanism, cowabunga it is. Furthermore, there is no such thing as a &#34;rejection&#34; in a universal sense. Either the protocol invents its own &#34;rejection&#34; or just... something happens, god knows what, actually. </p><p>This is one of the prime reasons flatpak apps can <i>not</i> see your session bus. </p><h2> D-Bus standards, part 5</h2> <p>Ever seen kwallet or gnome-keyring? Yeah, these things. These are supposed to be &#34;secret storage&#34; for things like signing keys, passwords, etc. They can be protected by a password, which means they are secure... right? </p><p>No. No, they aren&#39;t. These secrets may be encrypted on disk, which technically prevents them from being stolen if your laptop is stolen. If you just cringed at that because disk encryption has been a thing for 20 years now or so, you&#39;re not alone. </p><p>However, the best thing is this: <i>any app</i> on the bus can read <i>all secrets</i> in the store if the store is unlocked. No, this is not a fucking joke. Once you input that password, any app can just read all of them without you noticing. </p><p>This is the <i>real</i> stance of GNOME developers on the issue: </p><p><img title="" src="https://blog.vaxry.net/resource/articleDbus/image4.png"/> </p><p>Honestly, I am at a loss of words as to how to describe this without being <i>extremely</i> rude. </p><p>Security so good microsoft might steal it for their recall. </p> <p>I&#39;ve had enough of D-Bus in my apps. I would greatly benefit from a session (and later, system) bus for my ecosystem, but I will not stand the absolute shitfest that D-Bus is. </p><p>That is why, I&#39;ve decided to take matters into my own hands. I am writing a new bus. From the ground up, with zero copying, interop, or other recognition of D-Bus. There are <i>so many</i> stupid ideas crammed into D-Bus that I do not wish to have any of them poison my own. </p><h2> XKCD 927</h2> <p><img title="xkcd927" src="https://imgs.xkcd.com/comics/standards.png"/> </p><p>A lot of people quote this xkcd comic for each new implementation. However, this is not exactly the same. </p><p>For example, with wayland, when you switch, you abandon X. You cannot run an X11 session together with a wayland one, simply not how it works. </p><p>You <i>can</i>, however, run two session buses. Or three. Or 17. Nothing stops you. That&#39;s why <i>gradual</i> migration is absolutely possible. Sure, these buses can&#39;t talk to each other, but you can also create a proxy client that can &#34;translate&#34; dbus APIs into new ones. </p><h2> Wire</h2> <p>The first thing I focused on was <a href="https://github.com/hyprwm/hyprwire">hyprwire</a>. I needed a wire protocol anyways for hypr* stuff like hyprlauncher, hyprpaper, etc. </p><p>The wire protocol is inspired by how Wayland decided to handle things. Its most important strengths are: </p><ul><li>consistency: the wire itself enforces types and message arguments. No &#34;a{sv}&#34;, no &#34;just send something lol&#34;</li> <li>simplicity: the wire protocol is fast and simple. Nobody needs complicated struct types, these just add annoyances.</li> <li>speed: fast handshakes and protocol exchanges, connections are estabilished very quickly.</li></ul> <p>Hyprwire is already used for IPC in hyprpaper, hyprlauncher and parts of hyprctl, and has been serving us well. </p><h2> Bus</h2> <p>The bus is called <a href="https://github.com/hyprwm/hyprtavern">hyprtavern</a>, as it is not <i>exactly</i> what D-Bus is, but it&#39;s more like a tavern. </p><p>Apps register <i>objects</i> on the bus, which have exposed protocols and key properties defined by the protocols. These objects can be discovered by other apps connecting to the bus. </p><p>In a sense, hyprtavern acts like a <i>tavern</i>, where each app is a <i>client</i>, that can advertise the <i>languages</i> they speak, but also go up to someone else and <i>strike up a conversation</i> if they have a language in common. </p><p>Some overall improvements over D-Bus, in no particular order: </p><ul><li>Permissions: baked in, in-spec permissions. Suitable for exposing to sandboxed apps by default.</li> <li>Strict protocols: don&#39;t know the language? Don&#39;t poison the wire. Worth noting this does not stop you from making your own extensions, it just enforces you stay in-spec.</li> <li>Simplified API: D-Bus has a lot of stupid ideas (shoutout broadcast) that we intentionally do <i>not</i> inherit.</li> <li>Way better defaults: The core spec also includes a few things that are optional (and dumb) in D-Bus like an actually secure kv store.</li></ul> <h3> Kv</h3> <p>With relation to the Secrets API discussed a bit above, I wanted to mention kv. </p><p>hyprtavern-kv is the default implementation of the <i>core</i> protocol for a kv store. A kv store is a &#34;key-value&#34; store, which means apps register values for &#34;keys&#34;, e.g. &#34;user_secret_key = password&#34;. </p><p>This is essentially what D-Bus Secrets API does, but instead of being a security joke, it&#39;s actually secure by-design. </p><p>Any app can register secrets, which <i>only it can read back</i>. Secrets <i>cannot be enumerated</i>. This means that when &#34;/usr/bin/firefox&#34; sets a &#34;passwords:superwebsite.com = animebooba&#34;, an app called &#34;~/Downloads/totally_legit.sh&#34; can not see the value, or the key, or that firefox even set anything. </p><p>This also (will) work with Flatpak, Snap and AppImage applications by additionally using their Flatpak ID, Snap ID or AppImage path respectively. This is not implemented, but planned. </p><p>This kv store is always encrypted, but a default password can be used which means it will be unlocked by default and the store file can be trivially decrypted. The difference is that if you set a password here, it will actually be secure, even if an app with access to the bus tries to steal all of the secrets. </p><p>Additionally, this protocol is <i>core</i>. It <i>must</i> be implemented by the bus, which means all apps can benefit from a secure secret storage. </p><h2> Is hyprtavern ready?</h2> <p>No, absolutely not. I started work on it just recently, and I still need to cook a bit. It&#39;s coming though, really! </p><p>I hope to get it widely used within hypr* by 0.54 of hyprland (that is the release after the upcoming 0.53). </p><h2> Do I expect adoption?</h2> <p>No, definitely not at the beginning. But, it&#39;s an easier transition than X11 -&gt; Wayland, and I didn&#39;t expect Hyprland to be widely adopted either, but here we are. </p><p>Time will tell. All I can say is that it is <i>just better</i> than D-Bus. </p><p>An important part of adoption will probably be bindings to other languages. The libraries are all in C++, but since they aren&#39;t very big (by design), making Rust / Go / Python bindings shouldn&#39;t be hard for someone experienced with those languages. </p><p>The wire format is also simple and open, so you could also write a Memory-Safeâ„¢ libhyprwire in Rust for example. </p> <p>D-Bus has been an annoyance of mine for years now, but I finally have the ecosystem and resources to write something to replace it. </p><p>Let&#39;s hope we can make the userspace a bit nicer to work with :) </p> <p>This post is quickly gathering attention so I will answer some FAQs: </p><p> Reinventing the wheel won&#39;t help<br/> </p><p>The wheel is fundamentally broken. D-Bus is <i>unfixable</i> due to its core principles being terrible. </p><p> Where docs?<br/> </p><p>As I&#39;ve said, hyprtavern is a heavy WIP. Once it is ready for app developers, which I hope to be done with within a month, I will write extensive docs about both the wire protocol (so that you can implement it yourself if you don&#39;t like libhyprwire) and the tavern itself. </p><p> Why not use wayland?<br/> </p><p>I&#39;ve implemented a few improvements to hyprwire for bus usage (e.g. array types), and additionally wayland is not meant to be a generic IPC protocol. Connecting is restricted to sockets and WAYLAND_DISPLAY, for example. One could fork it, but at this point, it&#39;s better to write your own impl. </p><p> Can we add dbus-compatibility translators?<br/> </p><p>Yes. You can write a for example hyprtavern-dbus-notification-proxy which sets up a dbus notification service and exposes the events as an appropriate tavern protocol. Worth noting of course such a protocol doesn&#39;t exist yet as I am working on the core spec atm. There will be though. </p><p> Why C++ and not memory safe rust?<br/> </p><p>Because I am a C++ dev. You are free to reimplement the bus / wire in Rust. You are also free to write bindings. BSD-3. </p><p>Hyprland (and related) historically have had less and less memory issues over time thanks to our shift to hyprutils and very common (almost religious) refcounting practices. However, nothing&#39;s stopping you from rewriting things in Rust. </p><p> The portal docs are actually correct, you just were reading the wrong ones<br/> </p><p>Yes, a person on hackernews named mahkoh pointed this out (thanks!). This doesn&#39;t change the fact that: </p><ul><li>the docs are poorly separated, such that I could not easily find that information.</li> <li>the names for things for app -&gt; portal and portal -&gt; portal impl are different (wtf, what are you guys smoking?)</li> <li>the website he links didn&#39;t exist (IIRC at all, or at least in its current state, IIRC it was a mostly blank page) back when I was impl&#39;ing it.</li> <li>most importantly: <b>DBus allows you to do whatever while a real protocol would enforce the types outright and forbid invalid usage</b>.</li></ul> <p> Fragmentation, gnome and kde have different needs<br/> </p><p>Hasn&#39;t stopped them from both using D-Bus to this day. Apparently you can have one bus for both. </p><p> What about symlinks in paths?<br/> </p><p>Just resolve them. For chrooted apps, both Linux and BSD provide a way to get root from pid. I&#39;ve been told it will break on Nix, but I will let the Nix folks figure this one out as I don&#39;t use it. </p><p> Where can we follow development or see the protocol?<br/> </p><p>Hyprwire&#39;s wire format is not yet documented, but it&#39;s quite simple. Docs will be written by me once tavern&#39;s ready. </p><p>For the core tavern protocol spec WIP, please see <a href="https://github.com/hyprwm/hyprwire-protocols/pull/1">here</a>. Please note it&#39;s of course a WIP so breaking changes do happen as I try to accomodate more usecases. Feedback is welcome though, feel free to leave feedback if you&#39;re an app or DE developer with a specific usecase in mind.</p>
    </div></div>
  </body>
</html>
