<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://microformats.org">Original</a>
    <h1>Microformats – building blocks for data-rich web pages</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>A (very) belated follow up to <a href="https://waterpigs.co.uk/articles/getting-started-with-microformats2/">Getting Started with Microformats 2</a>, covering the basics of consuming and using microformats 2 data. Originally posted <a href="https://waterpigs.co.uk/articles/consuming-microformats/">on waterpigs.co.uk</a>.</p>

<p>More and more people are using microformats 2 to mark up profiles, posts, events and other data on their personal sites, enabling developers to build applications which use this data in useful and interesting ways. Whether you want to add basic support for webmention comments to your personal site, or have ambitious plans for a structured-data-aware-social-graph-search-engine-super-feed-reader, you’re going to need a solid grasp of how to parse and handle microformats 2 data.</p>

<h2 id="choose-a-parser">Choose a Parser</h2>

<p>To turn a web page containing data marked up with microformats 2 (or classic microformats, if supported) into a canonical MF2 JSON data structure, you’ll need a parser.</p>

<p>At the time of writing, there are actively supported <a href="https://microformats.org/wiki/microformats2#Parsers">microformats 2 parsers</a> available for the following programming languages:</p>

<ul>
<li><a href="https://pkg.go.dev/willnorris.com/go/microformats">Go</a></li>
<li><a href="https://github.com/microformats/microformats-parser">Javascript (server-side and browser)</a></li>
<li><a href="https://github.com/indieweb/php-mf2">PHP</a></li>
<li><a href="https://github.com/microformats/mf2py">Python</a></li>
<li><a href="https://github.com/microformats/microformats-ruby">Ruby</a></li>
<li><a href="https://crates.io/crates/microformats/0.2.0">Rust</a></li>
</ul>

<p>Parsers for various other languages exist, but might not be actively supported or support recent changes to the parsing specification.</p>

<p>There are also various websites which you can use to experiment with microformats markup without having to download a library and write any code:</p>

<ul>
<li>My own live-updating <a href="https://waterpigs.co.uk/php-mf2/">php-mf2 sandbox</a></li>
<li>The various parser comparison tools hosted on <a href="https://microformats.io/">microformats.io</a></li>
<li><a href="https://aaronparecki.com">Aaron Parecki</a>’s <a href="http://pin13.net/mf2/">pin13.net microformats parser</a> for parsing either URLs or HTML fragments</li>
</ul>

<p>If there’s not currently a parser available for your language of choice, you have a few options:</p>

<ul>
<li>Call the command-line tools provided by one of the existing libraries from your code, and consume the JSON they provide</li>
<li>Make use of one of the online mf2 parsers capable of parsing sites, and consume the JSON it returns (only recommended for very low volume usage!)</li>
<li>Write your own microformats 2 parser! There are plenty of people <a href="https://indieweb.org/discuss">happy to help</a>, and a language-agnostic test suite you can plug your implementation into for testing.</li>
</ul>

<h2 id="considerations-during-fetching-and-parsing">Considerations During Fetching and Parsing</h2>

<p>Most real-world microformats data is fetched from a URL, which could potentially redirect to a different URL one or more times. The final URL in the redirect chain is called the “effective URL”. HTML often contains relative URLs, which need to be resolved against a base URL in order to be useful out of context.</p>


<p>If your parser has a function for “parsing microformats from a URL”, it should deal with all of this for you. If you’re making the request yourself (e.g. to use custom caching or network settings) and then passing the response HTML and base URL to the parser, make sure to <strong>use the effective URL, not the starting URL!</strong> The parser will handle relative URL resolution, but it needs to know the correct base URL.</p>

<p>When parsing microformats, an HTTP request which returns a non-200 value doesn’t necessarily mean that there’s nothing to parse! For example, a <code>410 Gone</code> response might contain a h-entry with a message explaining the deletion of whatever was there before.

</p><h2 id="storing-raw-html-vs-parsed-mf2-json-vs-derived-data">Storing Raw HTML vs Parsed Canonical JSON vs Derived Data</h2>

<p>When consuming microformats 2 data, you’ll most often be fetching raw HTML from a URL, parsing it to canonical JSON, then finally processing it into a simpler, cleaned and sanitised format ready for use in your website or application. That’s three different representations of the same data — you’ll most likely end up storing the derived data somewhere for quick access, but what about the other two?</p>

<p>Experience shows that, over time:</p>

<ul>
<li>the way a particular application cleans up mf2 data will be tweaked and improved as you add new features and handle unexpected edge-cases</li>
<li>mf2 parsers gradually get improved, fixing bugs and occasionally adding entirely new features.</li>
</ul>

<p>Therefore, if it makes sense for your use case, I recommend archiving a copy of the original HTML as well as your derived data, leaving out the intermediate canonical JSON. That way, you can easily create scripts or background jobs to update all the derived data based on the original HTML, taking advantage of both parser improvements and improvements to your own code at the same time, without having to re-fetch potentially hundreds of potentially broken links.</p>

<p>As mentioned in the previous section, if you archive original HTML for re-parsing, you’ll need to additionally store the effective URL for correct relative URL resolution.</p>

<p>For some languages, there are already libraries (such as <a href="https://github.com/aaronpk/XRay/">XRay</a> for PHP) which will perform common cleaning and sanitisation for you. If the assumptions with which these libraries are built suit your applications, you may be able to avoid a lot of the hard work of handling raw microformats 2 data structures!</p>

<p>If not, read on…</p>

<h2 id="microformat-structures">Navigating Microformat Structures</h2>

<p>A parsed page may contain a number of microformat data structures (mf structs), in various different places.</p>

<p>Take a look at <a href="http://pin13.net/mf2/?url=https%3A%2F%2Fwaterpigs.co.uk%2Farticles%2Fconsuming-microformats%2F">the parsed canonical microformats JSON for the article you’re reading right now</a>, for example.</p>

<p><code>items</code> is a list of top-level mf structs, each of which may contain nested mf structs either under their <code>properties</code> or <code>children</code> keys.</p>

<p>Each individual mf struct is guaranteed to have at least two keys, <code>type</code> and <code>properties</code>. <code>type</code> is the primary way of identifying what sort of thing that struct represents (e.g. a person, a post, an event). Structs can have more than one type if they represent multiple things at once without wanting to nest them — for example, a post detailing an event might be both a h-entry and a h-event at the same time. Structs can also have additional top-level keys such as <code>id</code> and <code>lang</code>.</p>

<p>Generally speaking, <code>type</code> information is most useful when dealing with top-level mf structs, and mf structs nested under a <code>children</code> key. Nested mf structs found in <code>properties</code> will also have <code>type</code> information, but their usage is usually implied by the property name they’re found under.</p>

<p>For many common use cases (e.g. a homepage feed and profile) there are several different ways people might nest mf structs to achieve the same goals, so it’s important that your code is capable of searching the entire tree, rather than just looking at the top-level mf structs. <strong>Never assume that the microformat struct you’re looking for will be in the top-level of the <code>items</code> list!</strong> You need to search the whole tree.</p>

<p>I recommend writing some functions which can traverse a mf tree and return all structs which match a filtering callback. This can then be used as a basis for writing more specific convenience functions for common tasks such as finding all microformats on a page of a particular type, or where a certain property matches a certain value.</p>

<p>See <a href="https://github.com/barnabywalters/php-mf-cleaner/blob/master/src/BarnabyWalters/Mf2/Functions.php">my microformats2 PHP functions</a> for some working examples.</p>

<h2 id="possible-property-values">Possible Property Values</h2>

<p>Each key in a mf struct’s <code>properties</code> dict maps to a list of values for that property. Every property may map to multiple values, and those values may be a mixture of any of the following:</p>

<p>A plain string value, containing no HTML, and leaving HTML entities unescaped (e.g. <code>&lt;</code>)</p>

<pre><code>{
  <span>&#34;items&#34;</span>: [{
    <span>&#34;type&#34;</span>: [<span>&#34;h-card&#34;</span>],
    <span>&#34;properties&#34;</span>: {
      <span>&#34;name&#34;</span>: [<span>&#34;Barnaby Walters&#34;</span>]
    }
  }]
}
</code></pre>

<p>(In future examples I will leave out the encapsulating <code>{&#34;items&#34;: [{&#34;type&#34;: [•••], •••}]}</code> for brevity, focusing on the <code>properties</code> key of a single mf struct.)</p>

<p>An embedded HTML struct, containing two keys: <code>html</code>, which maps to an HTML representation of the property, and <code>value</code>, mapping to a plain text version.</p>

<pre><code>&#34;properties&#34;: {
  &#34;content&#34;: [{
    &#34;html&#34;: &#34;&lt;p&gt;The content <span>of</span> a post, <span>as</span> &lt;strong&gt;raw HTML&lt;/strong&gt; (<span>or</span> <span>not</span>).&lt;/p&gt;&#34;,
    &#34;value&#34;: &#34;The content <span>of</span> a post, <span>as</span> raw HTML (<span>or</span> <span>not</span>).&#34;
  }]
}
</code></pre>
<p>An img/alt struct, containing the URL of a parsed image under <code>value</code>, and its alt text under <code>alt</code>.</p>

<pre><code><span>&#34;properties&#34;</span>: {
  <span>&#34;photo&#34;</span>: [{
    <span>&#34;value&#34;</span>: <span>&#34;https://example.com/profile-photo.jpg&#34;</span>,
    <span>&#34;alt&#34;</span>: <span>&#34;Example Person&#34;</span>
  }]
}
</code></pre>
<p>A nested microformat data structure, with an additional <code>value</code> key containing a plaintext representation of the data contained within.</p>

<pre><code><span>&#34;properties&#34;</span>: {
  <span>&#34;author&#34;</span>: [{
    <span>&#34;type&#34;</span>: [<span>&#34;h-card&#34;</span>],
    <span>&#34;properties&#34;</span>: {
      <span>&#34;name&#34;</span>: [<span>&#34;Barnaby Walters&#34;</span>]
    },
    <span>&#34;value&#34;</span>: <span>&#34;Barnaby Walters</span>
  }]
}
</code></pre>
<p>All properties may have more than one value. In cases where you expect a single property value (e.g. <code>name</code>), simply take the first one you find, and in cases where you expect multiple values, use all values you consider valid. There are also some cases where it may make sense to use multiple values, but to prioritise one based on some heuristic — for example, an h-card may have multiple <code>url</code> values, in which case the first one is usually the “canonical” URL, and further URLs refer to external profiles.</p>

<p>Let’s look at the implications of each of the potential property value structures in turn.</p>

<p>Firstly, <strong>Never assume that a property value will be a plaintext string</strong>. Microformats publishers can nest microformats, embedded content and img/alt structures in a variety of different ways, and your consuming code should be as flexible as possible.</p>

<p>To partially make up for this complexity, you can <strong>always rely on the <code>value</code> key of nested structs to provide you with an equivalent plaintext value</strong>, regardless of what type of struct you’ve found.</p>

<p>When you start consuming microformats 2, write a function like this, and get into the habit of using it <strong>every time</strong> you want a single, plaintext value from a property:</p>

<pre><code><span><span>def</span> <span>get_first_plaintext</span><span>(mf_struct, property_name)</span>:</span>
  <span>try</span>:
    first_val = mf_struct[<span>&#39;properties&#39;</span>][property_name][<span>0</span>]
    <span>if</span> isinstance(first_val, str):
      <span>return</span> first_val
    <span>else</span>:
      <span>return</span> first_val[<span>&#39;value&#39;</span>]
  <span>except</span> (IndexError, KeyError):
    <span>return</span> <span>None</span>
</code></pre>

<p>Secondly, <strong>Never assume that a particular property will contain an embedded HTML struct</strong> — this usually applies to <code>content</code>, but is relevant anywhere your application expects embedded HTML. If you want to reliably get a value encoded as raw HTML, then you need to:</p>

<ol>
<li>Check whether the first property value is an embedded HTML struct (i.e. has an <code>html</code> key). If so, take the value of the <code>html</code> key</li>
<li>Otherwise, get the first plaintext property value using the approach above, and HTML-escape it</li>
<li>If neither is found, the property has no value.</li>
</ol>

<p>In Python 3.5+, that could look something like this:</p>

<pre><code><span>from</span> html <span>import</span> escape

<span><span>def</span> <span>get_first_html</span><span>(mf_struct, property_name)</span>:</span>
  <span>try</span>:
    first_val = mf_struct[<span>&#39;properties&#39;</span>][property_name][<span>0</span>]
    <span>if</span> isinstance(first_val, dict) <span>and</span> <span>&#39;html&#39;</span> <span>in</span> first_val:
      <span>return</span> first_val[<span>&#39;html&#39;</span>]
    <span>else</span>:
      plaintext_val = get_first_plaintext(mf_struct, property_name)

      <span>if</span> plaintext_val <span>is</span> <span>not</span> <span>None</span>:
        plaintext_val = escape(plaintext_val)

      <span>return</span> plaintext_val
  <span>except</span> (IndexError, KeyError):
    <span>return</span> <span>None</span>
</code></pre>
<p>In some cases, it may make sense for your application to be aware of whether a value was parsed as embedded HTML or a plain text string, and to store/treat them differently. In all other cases, <strong>always</strong> use a function like this when you’re expecting embedded HTML data.</p>

<p>Thirdly, when expecting an image URL, check for an img/alt structure, falling back to the plain text value (and either assuming an empty alt text or inferring an appropriate one, depending on your specific use case). Something like this could be a good starting point:</p>

<pre><code><span><span>def</span> <span>get_img_alt</span><span>(mf_struct, property_name)</span>:</span>
  <span>try</span>:
    first_val = mf_struct[<span>&#39;properties&#39;</span>][property_name][<span>0</span>]
    <span>if</span> isinstance(first_val, dict) <span>and</span> <span>&#39;alt&#39;</span> <span>in</span> first_val:
      <span>return</span> first_val
    <span>else</span>:
      plaintext_val = get_first_plaintext(mf_struct, property_name)

      <span>if</span> plaintext_val <span>is</span> <span>not</span> <span>None</span>:
        <span>return</span> {<span>&#39;value&#39;</span>: plaintext_val, <span>&#39;alt&#39;</span>: <span>&#39;&#39;</span>}

      <span>return</span> <span>None</span>
  <span>except</span> (IndexError, KeyError):
    <span>return</span> <span>None</span>
</code></pre>
<p>Finally, in cases where you expect a nested microformat, you might end up getting something else. This is the hardest case to deal with, and the one which depends the most on the specific data and use-case you’re dealing with. For example, if you’re expecting a nested h-card under an <code>author</code> property, but get something else, you could use any of the following approaches:</p>

<ul>
<li>If you got a plain string which doesn’t look like a URL, treat it as the <code>name</code> property of an implied h-card structure with no other properties (and if you need a URL, you could potentially take the hostname of the effective URL, if it works in context as a useful fallback value)</li>
<li>If you got an img alt struct, you could treat the <code>value</code> as the <code>photo</code> property, the <code>alt</code> as the <code>name</code> property, and potentially even take the hostname of the <code>photo</code> URL to be the implied fallback <code>url</code> property (although that’s pushing it a bit, and in most cases it’s probably better to just leave out the <code>url</code>)</li>
<li>If you got an embedded HTML struct, take its plaintext <code>value</code> and use one of the first two approaches</li>
<li>If you got a plain string, check to see if it looks like a URL. If so, fetch that URL and look for a representative h-card to use as the author value</li>
<li>If you get an embedded mf struct with a <code>url</code> property but no <code>photo</code>, you could fetch the <code>url</code>, look for a representative h-card (more on that in the next section) and see if it has a <code>photo</code> property</li>
<li>Treat the <code>author</code> property as invalid and run the h-entry (or entire page if relevant) through the <a href="https://indieweb.org/authorship-spec">authorship algorithm</a></li>
</ul>

<p>The first three are general principles which can be applied to many scenarios where you expect an embedded mf struct but find something else. The last three, however, are examples of a common trend in consuming microformats 2 data: for many common use-cases, there are well-thought-through algorithms you can use to interpret data in a standardised way.</p>

<h2 id="know-your-algorithms-and-vocabularies">Know Your Algorithms and Vocabularies</h2>

<p>The authorship algorithm mentioned above is one of several more-or-less formally established algorithms used to solve common problems in indieweb usages of microformats 2. Some others which are worth knowing about include:</p>

<ul>
<li>“Who wrote this post?”: <a href="https://indieweb.org/authorship-spec">authorship algorithm</a></li>
<li>“There’s more than one h-card on this page, which one should I use?”: <a href="https://microformats.org/wiki/representative-h-card-parsing">representative h-card</a></li>
<li>“I want to get a paginated feed of posts from this page”: <a href="https://indieweb.org/feed#How_To_Consume">How to consume h-feed</a></li>
<li>“How do I find and display the main post on this page?”: <a href="https://indieweb.org/authorship-spec">How to consume h-entry</a></li>
<li>“I received a response to one of my posts via webmention, how do I display it?”: <a href="https://indieweb.org/comments#How_to_display">How to display comments</a></li>
</ul>

<p>Library implementations of these algorithms exist for some languages, although they often deviate slightly from the exact text. See if you can find one which meets your needs, and if not, write your own and share it with the community!</p>

<p>In addition to the formal consumption algorithms, it’s worth looking through the definitions of the microformats vocabularies you’re using (as well as testing with real-world data) and adding support for properties or publishing techniques you might not have thought of the first time around. Some examples to get you started:</p>

<ul>
<li>If an h-card has no valid <code>photo</code>, see if there’s a valid <code>logo</code> you can use instead</li>
<li>When presenting a h-entry with a featured photo, check both the <code>photo</code> property and the <code>featured</code> property, as one or the other might be used in different scenarios</li>
<li>When dealing with address or location data (e.g. on an h-card, h-entry or h-event), be aware that either might be present in various different forms. Co-ordinates might be separate <code>latitude</code> and <code>longitude</code> properties, a combined plaintext <code>geo</code> property, or an embedded <code>h-geo</code>. Addresses might be separate top-level properties or an embedded h-adr. There are many variations which are totally valid to publish, and your consuming code should be as liberal as possible in what it accepts.</li>
<li>If a h-entry contains images which are marked up with <code>u-photo</code> within the <code>e-content</code>, they’ll be present both in the <code>content</code> <code>html</code> key and also under the <code>photo</code> property. If your app shows the embedded <code>content</code> HTML rather than using the plaintext version, and also supports <code>photo</code> properties (which may also be present outside the <code>content</code>), you may have to sniff the presence of photos within the <code>content</code>, and either remove them from it or ignore the corresponding <code>photo</code> properties to avoid showing photos twice.</li>
</ul>

<h2 id="sanitise-validate-and-truncate">Sanitise, Validate, and Truncate</h2>

<p>In the vast majority of cases, consuming microformats 2 data involves handling, storing and potentially re-publishing untrusted and potentially dangerous input data. Preventing XSS and other attacks is out of the scope of the microformats parsing algorithm, so the data your parser gives you is just as dangerous as the original source. You need to take your own measures for sanitising and truncating it so you can store and display it safely.</p>

<p>Covering every possible injection and XSS attack is out of the scope of this article, so I highly recommend referring to the OWASP resources on <a href="https://owasp.org/www-community/attacks/xss/">XSS Prevention</a>, <a href="https://owasp.org/www-community/attacks/Unicode_Encoding">Unicode Attacks</a> and <a href="https://owasp.org/Top10/A03_2021-Injection/">Injection Attacks</a> for more information.</p>

<p>Other than that, the following ideas are a good start:</p>

<ul>
<li>Use plaintext values where possible, only using embedded HTML when absolutely necessary</li>
<li>Pass everything (HTML or not) through a well-respected HTML sanitizer such as PHP’s <a href="https://github.com/ezyang/htmlpurifier">HTML Purifier</a>. Configure it to make sure that embedded HTML can’t interfere with your own markup or CSS. It probably shouldn’t contain any javascript ever, either.</li>
<li>In any case where you’re expecting a value with a specific format, validate it as appropriate.</li>
<li>More specifically, everywhere that you expect a URL, check that what you got was actually a URL. If you’re using the URL as an image, consider fetching it an checking its content type</li>
<li>Consider either proxying resource such as images, or storing local copies of them (reducing size and resolution as necessary), to avoid mixed content issues, potential attacks, and missing images if the links break in the future.</li>
<li>Decide on relevant maximum length values for each separate piece of external content, and truncate them as necessary. Ideally, use a language-aware truncation algorithm to avoid breaking words apart. When the content of a post is truncated, consider adding a “Read More” link for convenience.</li>
</ul>

<h2 id="test-with-real-world-data">Test with Real-World Data</h2>

<p>The web is a diverse place, and microformats are a flexible, permissive method of marking up structured data. There are often several different yet perfectly valid ways to achieve the same goal, and as a good consumer of mf2 data, your application should strive to accept as many of them as possible!</p>

<p>The best way to test this is with <em>real world data</em>. If your application is built with a particular source of data in mind, then start off with testing it against that. If you want to be able to handle a wider variety of sources, the best way is to determine what vocabularies and publishing use-cases your application consumes, and look at the Examples sections of the relevant <a href="https://indieweb.org">indieweb.org</a> wiki pages for real-world sites to test your code against.</p>

<p>Don’t forget to test your code against examples you’ve published on your own personal site!</p>

<h2 id="next-steps">Next Steps</h2>

<p>Hopefully this article helped you avoid a lot of common gotchas, and gave you a good head-start towards successfully consuming real-world microformats 2 data.</p>

<p>If you have questions or issues, or want to share something cool you’ve built, come and join us in the <a href="https://indieweb.org/discuss">indieweb chat room</a>.</p>
	</div></div>
  </body>
</html>
