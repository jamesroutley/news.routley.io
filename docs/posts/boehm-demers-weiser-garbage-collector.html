<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ivmai/bdwgc">Original</a>
    <h1>Boehm-Demers-Weiser Garbage Collector</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><a href="https://app.travis-ci.com/github/ivmai/bdwgc" rel="nofollow"><img src="https://camo.githubusercontent.com/a5128b00c3091b851b36e1feb17b338715442528341e11891bed106c8ea1c499/68747470733a2f2f6170702e7472617669732d63692e636f6d2f69766d61692f62647767632e7376673f6272616e63683d6d6173746572" alt="Travis-CI build status" data-canonical-src="https://app.travis-ci.com/ivmai/bdwgc.svg?branch=master"/></a>
<a href="https://ci.appveyor.com/project/ivmai/bdwgc" rel="nofollow"><img src="https://camo.githubusercontent.com/ddceffb93b065e0501f6a09f6366f76e835fd1c234bcd09abb7de53cc52038aa/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f69766d61692f62647767633f6272616e63683d6d6173746572267376673d74727565" alt="AppVeyor CI build status" data-canonical-src="https://ci.appveyor.com/api/projects/status/github/ivmai/bdwgc?branch=master&amp;svg=true"/></a>
<a href="https://codecov.io/github/ivmai/bdwgc?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/a84729866cd62dbc46a34023e57de77458898cd4657e86995f706cd71be92603/68747470733a2f2f636f6465636f762e696f2f6769746875622f69766d61692f62647767632f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="Codecov.io" data-canonical-src="https://codecov.io/github/ivmai/bdwgc/coverage.svg?branch=master"/></a>
<a href="https://coveralls.io/github/ivmai/bdwgc" rel="nofollow"><img src="https://camo.githubusercontent.com/944a548cbebb5bce8e686191d13e269452eac47fa890c9f7699aaddd3391dfab/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f69766d61692f62647767632f62616467652e706e673f6272616e63683d6d6173746572" alt="Coveralls test coverage status" data-canonical-src="https://coveralls.io/repos/github/ivmai/bdwgc/badge.png?branch=master"/></a>
<a href="https://scan.coverity.com/projects/ivmai-bdwgc" rel="nofollow"><img src="https://camo.githubusercontent.com/1e57a29c8a2fa1db0a992a368d73cdb8bfa1aadfc6b363cf81a735106e1d1ad2/68747470733a2f2f7363616e2e636f7665726974792e636f6d2f70726f6a656374732f31303831332f62616467652e737667" alt="Coverity Scan build status" data-canonical-src="https://scan.coverity.com/projects/10813/badge.svg"/></a>
<a href="https://app.fossa.com/projects/git%2Bgithub.com%2Fivmai%2Fbdwgc?ref=badge_shield" rel="nofollow"><img src="https://camo.githubusercontent.com/45342d02206b7ff99c071ad72231d3c5cf103682026d9342541de1dae8434ecf/68747470733a2f2f6170702e666f7373612e636f6d2f6170692f70726f6a656374732f6769742532426769746875622e636f6d25324669766d616925324662647767632e7376673f747970653d736869656c64" alt="FOSSA Status" data-canonical-src="https://app.fossa.com/api/projects/git%2Bgithub.com%2Fivmai%2Fbdwgc.svg?type=shield"/></a>
<a href="https://bestpractices.coreinfrastructure.org/projects/6332" rel="nofollow"><img src="https://camo.githubusercontent.com/1d1b55147d91517e68550e8d6b94cebe740464c12cb4bb66b8968bd3c5f840e0/68747470733a2f2f626573747072616374696365732e636f7265696e6672617374727563747572652e6f72672f70726f6a656374732f363333322f6261646765" alt="CII Best Practices" data-canonical-src="https://bestpractices.coreinfrastructure.org/projects/6332/badge"/></a>
<a href="https://hitsofcode.com/github/ivmai/bdwgc/view" rel="nofollow"><img src="https://camo.githubusercontent.com/fe703d42bbbe5df908d9f4224ecfa5957adadfaa6c007639720abbe1f692757d/68747470733a2f2f686974736f66636f64652e636f6d2f6769746875622f69766d61692f62647767633f6272616e63683d6d6173746572" alt="Hits-of-Code" data-canonical-src="https://hitsofcode.com/github/ivmai/bdwgc?branch=master"/></a>
<a href="https://shields.io/category/size" rel="nofollow"><img src="https://camo.githubusercontent.com/b09a82e61f4ef3f34fde0dcaa3de1f2e81a80282f9dfdd6fb93ac8c2dd72133c/68747470733a2f2f696d672e736869656c64732e696f2f746f6b65692f6c696e65732f6769746875622f69766d61692f6264776763" alt="Lines of code" data-canonical-src="https://img.shields.io/tokei/lines/github/ivmai/bdwgc"/></a>
<a href="https://shields.io/category/size" rel="nofollow"><img src="https://camo.githubusercontent.com/4c1783ecfad7c62d53709b4a22fd80164cd900b1f3015e2b37f6a0ae5ea4a386/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c616e6775616765732f636f64652d73697a652f69766d61692f6264776763" alt="GitHub code size in bytes" data-canonical-src="https://img.shields.io/github/languages/code-size/ivmai/bdwgc"/></a>
<a href="https://shields.io/category/downloads" rel="nofollow"><img src="https://camo.githubusercontent.com/8ced9157afab68ee26b6d8be41d8f278c380952663897b22fb00888270683628/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f646f776e6c6f6164732f69766d61692f62647767632f746f74616c2e737667" alt="Github All Releases" data-canonical-src="https://img.shields.io/github/downloads/ivmai/bdwgc/total.svg"/></a>
<a href="https://repology.org/project/boehm-gc/versions" rel="nofollow"><img src="https://camo.githubusercontent.com/e7f78b36b3edecd350b3c2e5db41deb8a45a5ac1d69c8baf5b24bb42c1fa2d95/68747470733a2f2f7265706f6c6f67792e6f72672f62616467652f74696e792d7265706f732f626f65686d2d67632e737667" alt="Packaging status" data-canonical-src="https://repology.org/badge/tiny-repos/boehm-gc.svg"/></a></p>
<p dir="auto">This is version 8.3.0 (next release development) of a conservative garbage
collector for C and C++.</p>
<p dir="auto">License: <a href="https://blog.plover.com/ivmai/bdwgc/blob/master/LICENSE">MIT-style</a></p>
<h2 tabindex="-1" dir="auto"><a id="user-content-download" aria-hidden="true" href="#download"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Download</h2>
<p dir="auto">You might find a more recent/stable version on the
<a href="https://github.com/ivmai/bdwgc/wiki/Download">Download</a> page, or
<a href="http://www.hboehm.info/gc/" rel="nofollow">BDWGC site</a>.</p>
<p dir="auto">Also, the latest bug fixes and new features are available in the
<a href="https://github.com/ivmai/bdwgc">development repository</a>.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-overview" aria-hidden="true" href="#overview"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Overview</h2>
<p dir="auto">This is intended to be a general purpose, garbage collecting storage
allocator.  The algorithms used are described in:</p>
<ul dir="auto">
<li>
<p dir="auto">Boehm, H., and M. Weiser, &#34;Garbage Collection in an Uncooperative
Environment&#34;, Software Practice &amp; Experience, September 1988, pp. 807-820.</p>
</li>
<li>
<p dir="auto">Boehm, H., A. Demers, and S. Shenker, &#34;Mostly Parallel Garbage Collection&#34;,
Proceedings of the ACM SIGPLAN &#39;91 Conference on Programming Language Design
and Implementation, SIGPLAN Notices 26, 6 (June 1991), pp. 157-164.</p>
</li>
<li>
<p dir="auto">Boehm, H., &#34;Space Efficient Conservative Garbage Collection&#34;, Proceedings
of the ACM SIGPLAN &#39;91 Conference on Programming Language Design and
Implementation, SIGPLAN Notices 28, 6 (June 1993), pp. 197-206.</p>
</li>
<li>
<p dir="auto">Boehm H., &#34;Reducing Garbage Collector Cache Misses&#34;, Proceedings of the
2000 International Symposium on Memory Management.</p>
</li>
</ul>
<p dir="auto">Possible interactions between the collector and optimizing compilers are
discussed in</p>
<ul dir="auto">
<li>
<p dir="auto">Boehm, H., and D. Chase, &#34;A Proposal for GC-safe C Compilation&#34;,
The Journal of C Language Translation 4, 2 (December 1992).</p>
</li>
<li>
<p dir="auto">Boehm H., &#34;Simple GC-safe Compilation&#34;, Proceedings of the ACM SIGPLAN &#39;96
Conference on Programming Language Design and Implementation.</p>
</li>
</ul>
<p dir="auto">Unlike the collector described in the second reference, this collector
operates either with the mutator stopped during the entire collection
(default) or incrementally during allocations.  (The latter is supported
on fewer machines.)  On the most common platforms, it can be built
with or without thread support.  On some platforms, it can take advantage
of a multiprocessor to speed up garbage collection.</p>
<p dir="auto">Many of the ideas underlying the collector have previously been explored
by others.  Notably, some of the run-time systems developed at Xerox PARC
in the early 1980s conservatively scanned thread stacks to locate possible
pointers (cf. Paul Rovner, &#34;On Adding Garbage Collection and Runtime Types
to a Strongly-Typed Statically Checked, Concurrent Language&#34; Xerox PARC
CSL 84-7).  Doug McIlroy wrote a simpler fully conservative collector that
was part of version 8 UNIX (tm), but appears to not have received
widespread use.</p>
<p dir="auto">Rudimentary tools for use of the collector as a <a href="https://blog.plover.com/ivmai/bdwgc/blob/master/docs/leak.md">leak detector</a>
are included, as is a fairly sophisticated string package &#34;cord&#34; that
makes use of the collector.  (See <a href="https://blog.plover.com/ivmai/bdwgc/blob/master/docs/README.cords">README.cords</a> and
H.-J. Boehm, R. Atkinson, and M. Plass, &#34;Ropes: An Alternative to Strings&#34;,
Software Practice and Experience 25, 12 (December 1995), pp. 1315-1330.
This is very similar to the &#34;rope&#34; package in Xerox Cedar, or the &#34;rope&#34;
package in the SGI STL or the g++ distribution.)</p>
<p dir="auto">Further collector documentation can be found in the
<a href="https://blog.plover.com/ivmai/bdwgc/blob/master/docs/overview.md">overview</a>.</p>
<p dir="auto">Some of the known uses of the collector are listed on the GitHub
<a href="https://github.com/ivmai/bdwgc/wiki/Known-clients">Known-clients</a> page.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-general-description" aria-hidden="true" href="#general-description"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>General Description</h2>
<p dir="auto">This is a garbage collecting storage allocator that is intended to be
used as a plug-in replacement for C&#39;s malloc.</p>
<p dir="auto">Since the collector does not require pointers to be tagged, it does not
attempt to ensure that all inaccessible storage is reclaimed.  However,
in our experience, it is typically more successful at reclaiming unused
memory than most C programs using explicit deallocation.  Unlike manually
introduced leaks, the amount of unreclaimed memory typically stays
bounded.</p>
<p dir="auto">In the following, an &#34;object&#34; is defined to be a region of memory allocated
by the routines described below.</p>
<p dir="auto">Any objects not intended to be collected must be pointed to either
from other such accessible objects, or from the registers,
stack, data, or statically allocated bss segments.  Pointers from
the stack or registers may point to anywhere inside an object.
The same is true for heap pointers if the collector is compiled with
<code>ALL_INTERIOR_POINTERS</code> defined, or <code>GC_all_interior_pointers</code> is otherwise
set, as is now the default.</p>
<p dir="auto">Compiling without <code>ALL_INTERIOR_POINTERS</code> may reduce accidental retention
of garbage objects, by requiring pointers from the heap to the beginning
of an object.  But this no longer appears to be a significant
issue for most programs occupying a small fraction of the possible
address space.</p>
<p dir="auto">There are a number of routines which modify the pointer recognition
algorithm.  <code>GC_register_displacement</code> allows certain interior pointers
to be recognized even if <code>ALL_INTERIOR_POINTERS</code> is not defined.
<code>GC_malloc_ignore_off_page</code> allows some pointers into the middle of
large objects to be disregarded, greatly reducing the probability of
accidental retention of large objects.  For most purposes it seems
best to compile with <code>ALL_INTERIOR_POINTERS</code> and to use
<code>GC_malloc_ignore_off_page</code> if you get collector warnings from
allocations of very large objects.  See <a href="https://blog.plover.com/ivmai/bdwgc/blob/master/docs/debugging.md">here</a> for details.</p>
<p dir="auto"><em>WARNING</em>: pointers inside memory allocated by the standard (system) <code>malloc</code>
are not seen by the garbage collector.  Thus objects pointed to only from such
a region may be prematurely deallocated.  It is thus suggested that the
standard <code>malloc</code> be used only for memory regions, such as I/O buffers, that
are guaranteed not to contain pointers to garbage collectible memory.
Pointers in C language automatic, static, or register variables,
are correctly recognized.  (Note that <code>GC_malloc_uncollectable</code> has
semantics similar to standard malloc, but allocates objects that are
traced by the collector.)</p>
<p dir="auto"><em>WARNING</em>: the collector does not always know how to find pointers in data
areas that are associated with dynamic libraries.  This is easy to remedy
if you know how to find those data areas on your operating system (see
<code>GC_add_roots</code>).  Code for doing this under SunOS, IRIX 5.X and 6.X, HP/UX,
Alpha OSF/1, Linux, and Win32 is included and used by default.
(See <a href="https://blog.plover.com/ivmai/bdwgc/blob/master/docs/platforms/README.win32">README.win32</a> and
<a href="https://blog.plover.com/ivmai/bdwgc/blob/master/docs/platforms/README.win64">README.win64</a> for Windows details.)  On other
systems, pointers from dynamic library data areas may not be considered by the
collector.  If you&#39;re writing a program that depends on the collector scanning
dynamic library data areas, it may be a good idea to include at least one call
to <code>GC_is_visible</code> to ensure that those areas are visible to the collector.</p>
<p dir="auto">Note that the garbage collector does not need to be informed of shared
read-only data.  However, if the shared library mechanism can introduce
discontiguous data areas that may contain pointers then the collector does
need to be informed.</p>
<p dir="auto">Signal processing for most signals may be deferred during collection,
and during uninterruptible parts of the allocation process.
Like standard ANSI C mallocs, by default it is unsafe to invoke
malloc (and other GC routines) from a signal handler while another
malloc call may be in progress.</p>
<p dir="auto">The allocator/collector can also be configured for thread-safe operation.
(Full signal safety can also be achieved, but only at the cost of two system
calls per malloc, which is usually unacceptable.)</p>
<p dir="auto"><em>WARNING</em>: the collector does not guarantee to scan thread-local storage
(e.g. of the kind accessed with <code>pthread_getspecific</code>).  The collector
does scan thread stacks, though, so generally the best solution is to
ensure that any pointers stored in thread-local storage are also
stored on the thread&#39;s stack for the duration of their lifetime.
(This is arguably a longstanding bug, but it hasn&#39;t been fixed yet.)</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-installation-and-portability" aria-hidden="true" href="#installation-and-portability"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation and Portability</h2>
<p dir="auto">The collector operates silently in the default configuration.
In the event of issues, this can usually be changed by defining the
<code>GC_PRINT_STATS</code> or <code>GC_PRINT_VERBOSE_STATS</code> environment variables.  This
will result in a few lines of descriptive output for each collection.
(The given statistics exhibit a few peculiarities.
Things don&#39;t appear to add up for a variety of reasons, most notably
fragmentation losses.  These are probably much more significant for the
contrived program <code>gctest</code> than for your application.)</p>
<p dir="auto">On most Unix-like platforms, the collector can be built either using a
GNU autoconf-based build infrastructure (type <code>./configure; make</code> in the
simplest case), or using CMake (see the sample below), or with a classic
makefile by itself (type <code>make -f Makefile.direct</code>).</p>
<p dir="auto">Please note that the collector source repository does not contain configure
and similar auto-generated files, thus the full procedure of autoconf-based
build of <code>master</code> branch of the collector could look like:</p>
<div data-snippet-clipboard-copy-content="git clone https://github.com/ivmai/bdwgc
cd bdwgc
git clone https://github.com/ivmai/libatomic_ops
./autogen.sh
./configure
make -j
make check"><pre><code>git clone https://github.com/ivmai/bdwgc
cd bdwgc
git clone https://github.com/ivmai/libatomic_ops
./autogen.sh
./configure
make -j
make check
</code></pre></div>
<p dir="auto">Cloning of <code>libatomic_ops</code> is now optional provided the compiler supports
atomic intrinsics.  See <a href="https://blog.plover.com/ivmai/bdwgc/blob/master/docs/README.autoconf">README.autoconf</a> for details.</p>
<p dir="auto">As noted above, alternatively, the collector could be built with CMake, like
this:</p>
<div data-snippet-clipboard-copy-content="mkdir out
cd out
cmake -Dbuild_tests=ON ..
cmake --build .
ctest"><pre><code>mkdir out
cd out
cmake -Dbuild_tests=ON ..
cmake --build .
ctest
</code></pre></div>
<p dir="auto">See <a href="https://blog.plover.com/ivmai/bdwgc/blob/master/docs/README.cmake">README.cmake</a> for details.</p>
<p dir="auto">Finally, on most targets, the collector could be built and tested directly
with a single compiler invocation, like this:</p>
<div data-snippet-clipboard-copy-content="gcc -I include -o gctest tests/gctest.c extra/gc.c &amp;&amp; ./gctest"><pre><code>gcc -I include -o gctest tests/gctest.c extra/gc.c &amp;&amp; ./gctest
</code></pre></div>
<p dir="auto">On Windows, CMake could be used to build the library as described above or
by typing <code>nmake -f NT_MAKEFILE</code>, this assumes you have Microsoft command-line
tools installed and suitably configured.  See
<a href="https://blog.plover.com/ivmai/bdwgc/blob/master/docs/platforms/README.win32">README.win32</a> for details.</p>
<p dir="auto">The library is built with threads support on (i.e. for thread-safe operation)
by default, unless <code>--disable-threads</code> is passed to <code>./configure</code> (or
<code>-Denable_threads=OFF</code> is passed to <code>cmake</code> tool).</p>
<p dir="auto">The library could be configured more precisely during the build by defining
the macros listed in <a href="https://blog.plover.com/ivmai/bdwgc/blob/master/docs/README.macros">README.macros</a> file.</p>
<p dir="auto">Below we focus on the collector build using classic makefile.  For the
Makefile.direct-based process, typing <code>make check</code> instead of <code>make</code> will
automatically build the collector and then run <code>setjmp_test</code> and <code>gctest</code>.
<code>setjmp_test</code> will give you information about configuring the collector, which
is useful primarily if you have a machine that&#39;s not already supported.
gctest is a somewhat superficial test of collector functionality.  Failure is
indicated by a core dump or a message to the effect that the collector is
broken.  gctest takes about a second to two to run on reasonable 2007 vintage
desktops.  It may use up to about 30 MB of memory.  (The multi-threaded
version will use more.  64-bit versions may use more.) <code>make check</code> will also,
as its last step, attempt to build and test the &#34;cord&#34; string library.)</p>
<p dir="auto">Makefile.direct will generate a library libgc.a which you should link against.
Typing <code>make -f Makefile.direct cords</code> will build the cord library (libcord.a)
as well.</p>
<p dir="auto">The GNU style build process understands the usual targets.  <code>make check</code>
runs a number of tests.  <code>make install</code> installs at least libgc, and libcord.
Try <code>./configure --help</code> to see the configuration options.  It is currently
not possible to exercise all combinations of build options this way.</p>
<p dir="auto">All include files that need to be used by clients will be put in the
include subdirectory.  (Normally this is just gc.h.  <code>make cords</code> adds
&#34;cord.h&#34; and &#34;ec.h&#34;.)</p>
<p dir="auto">The collector currently is designed to run essentially unmodified on
machines that use a flat 32-bit or 64-bit address space.
That includes the vast majority of Workstations and x86 (i386 or later) PCs.</p>
<p dir="auto">In a few cases (e.g., OS/2, Win32) a separate makefile is supplied; these have
a separate host-specific docs/platforms/README.* file.</p>
<p dir="auto">Dynamic libraries are completely supported only under SunOS/Solaris,
(and even that support is not functional on the last Sun 3 release),
Linux, FreeBSD, NetBSD, IRIX, HP/UX, Win32 (not win32s) and OSF/1
on DEC AXP machines plus perhaps a few others listed near the top
of dyn_load.c.  On other machines we recommend that you do one of
the following:</p>
<ol dir="auto">
<li>Add dynamic library support (and send us the code).</li>
<li>Use static versions of the libraries.</li>
<li>Arrange for dynamic libraries to use the standard malloc. This is still
dangerous if the library stores a pointer to a garbage collected object.
But nearly all standard interfaces prohibit this, because they deal
correctly with pointers to stack allocated objects.  (<code>strtok</code> is an
exception.  Don&#39;t use it.)</li>
</ol>
<p dir="auto">In all cases we assume that pointer alignment is consistent with that
enforced by the standard C compilers.  If you use a nonstandard compiler
you may have to adjust the alignment parameters defined in gc_priv.h.
Note that this may also be an issue with packed records/structs, if those
enforce less alignment for pointers.</p>
<p dir="auto">A port to a machine that is not byte addressed, or does not use 32 bit
or 64 bit addresses will require a major effort.  A port to plain MSDOS
or win16 is hard.</p>
<p dir="auto">For machines not already mentioned, or for nonstandard compilers,
some porting suggestions are provided <a href="https://blog.plover.com/ivmai/bdwgc/blob/master/docs/porting.md">here</a>.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-the-c-interface-to-the-allocator" aria-hidden="true" href="#the-c-interface-to-the-allocator"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The C Interface to the Allocator</h2>
<p dir="auto">The following routines are intended to be directly called by the user.
Note that usually only <code>GC_malloc</code> is necessary.  <code>GC_clear_roots</code> and
<code>GC_add_roots</code> calls may be required if the collector has to trace
from nonstandard places (e.g. from dynamic library data areas on a
machine on which the collector doesn&#39;t already understand them.)  On
some machines, it may be desirable to set <code>GC_stackbottom</code> to a good
approximation of the stack base (bottom).</p>
<p dir="auto">Client code may include &#34;gc.h&#34;, which defines all of the following, plus many
others.</p>
<ol dir="auto">
<li>
<p dir="auto"><code>GC_malloc(bytes)</code> - Allocate an object of a given size.  Unlike malloc,
the object is cleared before being returned to the user.  <code>GC_malloc</code> will
invoke the garbage collector when it determines this to be appropriate.
GC_malloc may return 0 if it is unable to acquire sufficient space from the
operating system.  This is the most probable consequence of running out
of space.  Other possible consequences are that a function call will fail
due to lack of stack space, or that the collector will fail in other ways
because it cannot maintain its internal data structures, or that a crucial
system process will fail and take down the machine.  Most of these
possibilities are independent of the malloc implementation.</p>
</li>
<li>
<p dir="auto"><code>GC_malloc_atomic(bytes)</code> - Allocate an object of a given size that
is guaranteed not to contain any pointers.  The returned object is not
guaranteed to be cleared. (Can always be replaced by <code>GC_malloc</code>, but
results in faster collection times.  The collector will probably run faster
if large character arrays, etc. are allocated with <code>GC_malloc_atomic</code> than
if they are statically allocated.)</p>
</li>
<li>
<p dir="auto"><code>GC_realloc(object, new_bytes)</code> - Change the size of object to be of
a given size.  Returns a pointer to the new object, which may, or may not,
be the same as the pointer to the old object.  The new object is taken to
be atomic if and only if the old one was.  If the new object is composite
and larger than the original object then the newly added bytes are cleared.
This is very likely to allocate a new object.</p>
</li>
<li>
<p dir="auto"><code>GC_free(object)</code> - Explicitly deallocate an object returned by
<code>GC_malloc</code> or <code>GC_malloc_atomic</code>, or friends.  Not necessary, but can be
used to minimize collections if performance is critical.  Probably
a performance loss for very small objects (&lt;= 8 bytes).</p>
</li>
<li>
<p dir="auto"><code>GC_expand_hp(bytes)</code> - Explicitly increase the heap size.  (This is
normally done automatically if a garbage collection failed to reclaim
enough memory.  Explicit calls to <code>GC_expand_hp</code> may prevent unnecessarily
frequent collections at program startup.)</p>
</li>
<li>
<p dir="auto"><code>GC_malloc_ignore_off_page(bytes)</code> - Identical to <code>GC_malloc</code>, but the
client promises to keep a pointer to the somewhere within the first 256
bytes of the object while it is live.  (This pointer should normally be
declared volatile to prevent interference from compiler optimizations.)
This is the recommended way to allocate anything that is likely to be
larger than 100 KB or so.  (<code>GC_malloc</code> may result in a failure to reclaim
such objects.)</p>
</li>
<li>
<p dir="auto"><code>GC_set_warn_proc(proc)</code> - Can be used to redirect warnings from the
collector.  Such warnings should be rare, and should not be ignored during
code development.</p>
</li>
<li>
<p dir="auto"><code>GC_enable_incremental()</code> - Enables generational and incremental
collection.  Useful for large heaps on machines that provide access to page
dirty information.  Some dirty bit implementations may interfere with
debugging (by catching address faults) and place restrictions on heap
arguments to system calls (since write faults inside a system call may not
be handled well).</p>
</li>
<li>
<p dir="auto"><code>GC_register_finalizer(object, proc, data, 0, 0)</code> and friends - Allow for
registration of finalization code.  User supplied finalization code
(<code>(*proc)(object, data)</code>) is invoked after object becomes unreachable.
For more sophisticated uses, and for finalization ordering issues, see gc.h.</p>
</li>
</ol>
<p dir="auto">The global variable <code>GC_free_space_divisor</code> may be adjusted up from it
default value of 3 to use less space and more collection time, or down for
the opposite effect.  Setting it to 1 will almost disable collections
and cause all allocations to simply grow the heap.</p>
<p dir="auto">The variable <code>GC_non_gc_bytes</code>, which is normally 0, may be changed to reflect
the amount of memory allocated by the above routines that should not be
considered as a candidate for collection.  Careless use may, of course, result
in excessive memory consumption.</p>
<p dir="auto">Some additional tuning is possible through the parameters defined
near the top of gc_priv.h.</p>
<p dir="auto">If only <code>GC_malloc</code> is intended to be used, it might be appropriate to define:</p>
<div data-snippet-clipboard-copy-content="#define malloc(n) GC_malloc(n)
#define calloc(m,n) GC_malloc((m)*(n))"><pre><code>#define malloc(n) GC_malloc(n)
#define calloc(m,n) GC_malloc((m)*(n))
</code></pre></div>
<p dir="auto">For small pieces of VERY allocation intensive code, <code>gc_inline.h</code> includes
some allocation macros that may be used in place of <code>GC_malloc</code> and
friends.</p>
<p dir="auto">All externally visible names in the garbage collector start with <code>GC_</code>.
To avoid name conflicts, client code should avoid this prefix, except when
accessing garbage collector routines.</p>
<p dir="auto">There are provisions for allocation with explicit type information.
This is rarely necessary.  Details can be found in <code>gc_typed.h</code>.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-the-c-interface-to-the-allocator-1" aria-hidden="true" href="#the-c-interface-to-the-allocator-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The C++ Interface to the Allocator</h2>
<p dir="auto">The Ellis-Hull C++ interface to the collector is included in the collector
distribution.  If you intend to use this, type
<code>./configure --enable-cplusplus &amp;&amp; make</code> (or
<code>cmake -Denable_cplusplus=ON . &amp;&amp; cmake --build .</code>, or
<code>make -f Makefile.direct c++</code> depending on the build system you use).
This creates libgccpp.a and libgctba.a files, or their shared library
equivalents (libgccpp.so and libgctba.so).  You should link with either the
first (gccpp) or the second one (gctba), but not both.  See gc_cpp.h and
<a href="https://blog.plover.com/ivmai/bdwgc/blob/master/docs/gcinterface.md">here</a> for the definition of the interface.
This interface tries to approximate the Ellis-Detlefs C++ garbage collection
proposal without compiler changes.</p>
<p dir="auto">Very often it will also be necessary to use <code>gc_allocator.h</code> and the
allocator declared there to construct STL data structures.  Otherwise
subobjects of STL data structures will be allocated using a system
allocator, and objects they refer to may be prematurely collected.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-use-as-leak-detector" aria-hidden="true" href="#use-as-leak-detector"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Use as Leak Detector</h2>
<p dir="auto">The collector may be used to track down leaks in C programs that are
intended to run with malloc/free (e.g. code with extreme real-time or
portability constraints).  To do so define <code>FIND_LEAK</code> in Makefile.
This will cause the collector to print a human-readable object description
whenever an inaccessible object is found that has not been explicitly freed.
Such objects will also be automatically reclaimed.</p>
<p dir="auto">If all objects are allocated with <code>GC_DEBUG_MALLOC</code> (see the next section)
then, by default, the human-readable object description will at least contain
the source file and the line number at which the leaked object was allocated.
This may sometimes be sufficient.  (On a few machines, it will also report
a cryptic stack trace.  If this is not symbolic, it can sometimes be called
into a symbolic stack trace by invoking program &#34;foo&#34; with
<code>tools/callprocs.sh foo</code>.  It is a short shell script that invokes adb to
expand program counter values to symbolic addresses.  It was largely supplied
by Scott Schwartz.)</p>
<p dir="auto">Note that the debugging facilities described in the next section can
sometimes be slightly LESS effective in leak finding mode, since in the latter
<code>GC_debug_free</code> actually results in reuse of the object.  (Otherwise the
object is simply marked invalid.)  Also, note that most GC tests are not
designed to run meaningfully in <code>FIND_LEAK</code> mode.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-debugging-facilities" aria-hidden="true" href="#debugging-facilities"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Debugging Facilities</h2>
<p dir="auto">The routines <code>GC_debug_malloc</code>, <code>GC_debug_malloc_atomic</code>, <code>GC_debug_realloc</code>,
and <code>GC_debug_free</code> provide an alternate interface to the collector, which
provides some help with memory overwrite errors, and the like.
Objects allocated in this way are annotated with additional
information.  Some of this information is checked during garbage
collections, and detected inconsistencies are reported to stderr.</p>
<p dir="auto">Simple cases of writing past the end of an allocated object should
be caught if the object is explicitly deallocated, or if the
collector is invoked while the object is live.  The first deallocation
of an object will clear the debugging info associated with an
object, so accidentally repeated calls to <code>GC_debug_free</code> will report the
deallocation of an object without debugging information.  Out of
memory errors will be reported to stderr, in addition to returning <code>NULL</code>.</p>
<p dir="auto"><code>GC_debug_malloc</code> checking during garbage collection is enabled
with the first call to this function.  This will result in some
slowdown during collections.  If frequent heap checks are desired,
this can be achieved by explicitly invoking <code>GC_gcollect</code>, e.g. from
the debugger.</p>
<p dir="auto"><code>GC_debug_malloc</code> allocated objects should not be passed to <code>GC_realloc</code>
or <code>GC_free</code>, and conversely.  It is however acceptable to allocate only
some objects with <code>GC_debug_malloc</code>, and to use <code>GC_malloc</code> for other objects,
provided the two pools are kept distinct.  In this case, there is a very
low probability that <code>GC_malloc</code> allocated objects may be misidentified as
having been overwritten.  This should happen with probability at most
one in 2**32.  This probability is zero if <code>GC_debug_malloc</code> is never called.</p>
<p dir="auto"><code>GC_debug_malloc</code>, <code>GC_debug_malloc_atomic</code>, and <code>GC_debug_realloc</code> take two
additional trailing arguments, a string and an integer.  These are not
interpreted by the allocator.  They are stored in the object (the string is
not copied).  If an error involving the object is detected, they are printed.</p>
<p dir="auto">The macros <code>GC_MALLOC</code>, <code>GC_MALLOC_ATOMIC</code>, <code>GC_REALLOC</code>, <code>GC_FREE</code>,
<code>GC_REGISTER_FINALIZER</code> and friends are also provided.  These require the same
arguments as the corresponding (nondebugging) routines.  If gc.h is included
with <code>GC_DEBUG</code> defined, they call the debugging versions of these
functions, passing the current file name and line number as the two
extra arguments, where appropriate.  If gc.h is included without <code>GC_DEBUG</code>
defined then all these macros will instead be defined to their nondebugging
equivalents.  (<code>GC_REGISTER_FINALIZER</code> is necessary, since pointers to
objects with debugging information are really pointers to a displacement
of 16 bytes from the object beginning, and some translation is necessary
when finalization routines are invoked.  For details, about what&#39;s stored
in the header, see the definition of the type oh in dbg_mlc.c file.)</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-incrementalgenerational-collection" aria-hidden="true" href="#incrementalgenerational-collection"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Incremental/Generational Collection</h2>
<p dir="auto">The collector normally interrupts client code for the duration of
a garbage collection mark phase.  This may be unacceptable if interactive
response is needed for programs with large heaps.  The collector
can also run in a &#34;generational&#34; mode, in which it usually attempts to
collect only objects allocated since the last garbage collection.
Furthermore, in this mode, garbage collections run mostly incrementally,
with a small amount of work performed in response to each of a large number of
<code>GC_malloc</code> requests.</p>
<p dir="auto">This mode is enabled by a call to <code>GC_enable_incremental</code>.</p>
<p dir="auto">Incremental and generational collection is effective in reducing
pause times only if the collector has some way to tell which objects
or pages have been recently modified.  The collector uses two sources
of information:</p>
<ol dir="auto">
<li>
<p dir="auto">Information provided by the VM system.  This may be provided in one of
several forms.  Under Solaris 2.X (and potentially under other similar
systems) information on dirty pages can be read from the /proc file system.
Under other systems (e.g. SunOS4.X) it is possible to write-protect
the heap, and catch the resulting faults. On these systems we require that
system calls writing to the heap (other than read) be handled specially by
client code. See <code>os_dep.c</code> for details.</p>
</li>
<li>
<p dir="auto">Information supplied by the programmer.  The object is considered dirty
after a call to <code>GC_end_stubborn_change</code> provided the library has been
compiled suitably. It is typically not worth using for short-lived objects.
Note that bugs caused by a missing <code>GC_end_stubborn_change</code> or
<code>GC_reachable_here</code> call are likely to be observed very infrequently and
hard to trace.</p>
</li>
</ol>
<h2 tabindex="-1" dir="auto"><a id="user-content-bugs" aria-hidden="true" href="#bugs"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Bugs</h2>
<p dir="auto">Any memory that does not have a recognizable pointer to it will be
reclaimed.  Exclusive-or&#39;ing forward and backward links in a list
doesn&#39;t cut it.</p>
<p dir="auto">Some C optimizers may lose the last undisguised pointer to a memory
object as a consequence of clever optimizations.  This has almost
never been observed in practice.</p>
<p dir="auto">This is not a real-time collector.  In the standard configuration,
percentage of time required for collection should be constant across
heap sizes.  But collection pauses will increase for larger heaps.
They will decrease with the number of processors if parallel marking
is enabled.</p>
<p dir="auto">(On 2007 vintage machines, GC times may be on the order of 5 ms
per MB of accessible memory that needs to be scanned and processed.
Your mileage may vary.)  The incremental/generational collection facility
may help in some cases.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-feedback-contribution-questions-and-notifications" aria-hidden="true" href="#feedback-contribution-questions-and-notifications"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Feedback, Contribution, Questions and Notifications</h2>
<p dir="auto">Please address bug reports and new feature ideas to
<a href="https://github.com/ivmai/bdwgc/issues">GitHub issues</a>.  Before the
submission please check that it has not been done yet by someone else.</p>
<p dir="auto">If you want to contribute, submit
a <a href="https://github.com/ivmai/bdwgc/pulls">pull request</a> to GitHub.</p>
<p dir="auto">If you need help, use
<a href="https://stackoverflow.com/questions/tagged/boehm-gc" rel="nofollow">Stack Overflow</a>.
Older technical discussions are available in <code>bdwgc</code> mailing list archive - it
can be downloaded as a
<a href="https://github.com/ivmai/bdwgc/files/1038163/bdwgc-mailing-list-archive-2017_04.tar.gz">compressed file</a>
or browsed at <a href="http://bdwgc.opendylan.narkive.com" rel="nofollow">Narkive</a>.</p>
<p dir="auto">To get new release announcements, subscribe to
<a href="https://github.com/ivmai/bdwgc/releases.atom">RSS feed</a>.
(To receive the notifications by email, a 3rd-party free service like
<a href="https://ifttt.com/feed" rel="nofollow">IFTTT RSS Feed</a> can be setup.)
To be notified on all issues, please
<a href="https://github.com/ivmai/bdwgc/watchers">watch</a> the project on
GitHub.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-copyright--warranty-contributors" aria-hidden="true" href="#copyright--warranty-contributors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Copyright &amp; Warranty, Contributors</h2>
<p dir="auto">Our intent is to make it easy to use bdwgc (libgc), in both free and
proprietary software.  Hence, the Boehm-Demers-Weiser conservative garbage
collector code that we expect to be linked dynamically or statically into
a client application is covered by own license, which is similar in
spirit to an MIT-style one.</p>
<p dir="auto">The exact licensing information is provided in <a href="https://blog.plover.com/ivmai/bdwgc/blob/master/LICENSE">LICENSE</a> file.</p>
<p dir="auto">All the contributors are listed in <a href="https://blog.plover.com/ivmai/bdwgc/blob/master/AUTHORS">AUTHORS</a> file.</p>
</article>
          </div></div>
  </body>
</html>
