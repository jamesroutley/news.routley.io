<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.stochasticlifestyle.com/implicit-ode-solvers-are-not-universally-more-robust-than-explicit-ode-solvers-or-why-no-ode-solver-is-best/">Original</a>
    <h1>Implicit ODE solvers are not universally more robust than explicit ODE solvers</h1>
    
    <div id="readability-page-1" class="page"><div id="post-1901">
    <!--end post header-->
    <div>
                <p>A very common adage in ODE solvers is that if you run into trouble with an explicit method, usually some explicit Runge-Kutta method like RK4, then you should try an implicit method. Implicit methods, because they are doing more work, solving an implicit system via a Newton method having “better” stability, should be the thing you go to on the “hard” problems.</p>
<p>This is at least what I heard at first, and then I learned about edge cases. Specifically, you hear people say “but for hyperbolic PDEs you need to use explicit methods”. You might even intuit from this “PDEs can have special properties, so sometimes special things can happen with PDEs… but ODEs, that should use implicit methods if you need more robustness”. This turns out to not be true, and really understanding the ODEs will help us understand better why there are some PDE semidiscretizations that have this “special cutout”.</p>
<p>What I want to do in this blog post is more clearly define what “better stability” actually means, and show that it has certain consequences that can sometimes make explicit ODE solvers actually more robust on some problems. And not just some made-up problems, lots of real problems that show up in the real world.</p>
<h2>A Quick Primer on Linear ODEs</h2>
<p>First, let’s go through the logic of why implicit ODE solvers are considered to be more robust, which we want to define in some semi-rigorous way as “having a better chance to give an answer closer to the real answer”. In order to go from semi-rigorous into a rigorous definition, we can choose a test function, and what better test function to use than a linear ODE. So let’s define a linear ODE:</p>
<p>$$u’ = \lambda u$$</p>
<p>is the simplest ODE. We can even solve it analytically, $u(t) = \exp(\lambda t)u(0)$. For completeness, we can generalize this to a linear system of ODEs, where instead of having a scalar $u$ we can let $u$ be a vector, in which case the linear ODE has a matrix of parameters $A$, i.e.</p>
<p>$$u’ = Au$$</p>
<p>In this case, if $A$ is diagonalizable, $A = P^{-1}DP$, then we can replace $A$:</p>
<p>$$u’ = P^{-1}DP u$$</p>
<p>$$Pu’ = DPu$$</p>
<p>or if we let $w = Pu$, then</p>
<p>$$w’ = Dw$$</p>
<p>where $D$ is a diagonal matrix. This means that for every element of $w$ we have the equation:</p>
<p>$$w_i’ = \lambda_i w_i$$</p>
<p>where $w_i$ is the vector in the direction of the $i$th eigenvector of $A$, and $\lambda_i$ is the $i$th eigenvalue of $A$. Thus our simple linear ODE $u’ = \lambda u$ tells us about general linear systems along the eigenvectors. Importantly, since even for real $A$ we can have $\lambda$ be a complex number, i.e. real-valued matrices can have complex eigenvalues, it’s important to allow for $\lambda$ to be complex to understand all possible systems.</p>
<p>But why is this important for any other ODE? Well by the Hartman-Grobman theorem, for any sufficiently nice ODE:</p>
<p>$$u’ = f(u)$$</p>
<p>We can locally approximate the ODE by:</p>
<p>$$u’ = Au$$</p>
<p>where $A = f&#39;(u)$, i.e. $A$ is the linear system defined by the Jacobian local to the point. This is effectively saying any “sufficiently nice” system (i.e. if $f$ isn’t some crazy absurd function and has properties like being differentiable), you can understand how things locally move by looking at the system approximated by a linear system, where the right linear approximation is given by the Jacobian. And we know that linear systems then boil down generally to just the scalar linear system, and so understanding the behavior of a solver on the scalar linear system tells us a lot about how it will do “for small enough h”.</p>
<p>Okay, there are lots of unanswered questions, such as what if $A$ is not diagonalizable? What if $f$ is not differentiable? What if the system is very nonlinear so the Jacobian changes very rapidly? But under assumptions that things are nice enough, we can say that if a solver does well on $u’ = \lambda u$ then it is probably some idea of good.</p>
<h2>Why implicit ODE solvers are “better”, i.e. more robust</h2>
<p>So now we have a metric by which we can analyze ODEs: if they have good behavior on $u’ = \lambda u$, then they are likely to be good in general. So what does it mean to have good behavior on $u’ = \lambda u$? One nice property would be to at least be asymptotically correct for the most basic statement, i.e. does it go to zero when it should? If you have $u’ = \lambda u$ and $\lambda$ is negative, then the analytical solution $u(t) = \exp(\lambda t)u(0)$ goes to zero as $t$ goes to infinity. So a good question to ask is, for a given numerical method, for what values of $h$ (the time step size) does the numerical method give a solution that goes to zero, and for which $h$ does it get an infinitely incorrect answer?</p>
<p>To understand this, we just take a numerical method and plug in the test equation. So the first thing to look at is Euler’s method. For Euler’s method, we step forward by $h$ by assuming the derivative is constant along the interval, or:</p>
<p>$$u_{n+1} = u_n + hf(u_n)$$</p>
<p>When does this method give a solution that is asymptotically consistent? With a little bit of algebra:</p>
<p>$$u_{n+1} = u_n + h\lambda u_n$$</p>
<p>$$u_{n+1} = (1 + h\lambda) u_n$$</p>
<p>Let $z = h\lambda$, which means</p>
<p>$$u_{n+1} = (1 + z) u_n$$</p>
<p>This is a discrete dynamical system which has the analytical solution:</p>
<p>$$u_n = u_0 (1+z)^{n}$$</p>
<p>Note that if $1 + z &gt; 1$, then $(1+z)^n$ keeps growing as $n$ increases, so this goes to infinity, while if $1 + z &lt; 1$ it goes to zero. But since $\lambda$ can actually be a complex number, the analysis is a little bit more complex (pun intended), but it effectively means that if $z$ is in the unit circle shifted to the left in the complex plane by 1, then $u_n \rightarrow 0$. This gives us the definition of the stability region, $G(z)$ is the region for which $u_n \rightarrow 0$, and this is the shifted unit circle in the complex plane for explicit Euler.

<a href="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_Euler_method.svg.png?ssl=1" rel="lightbox[1901]"><img data-recalc-dims="1" loading="lazy" decoding="async" data-attachment-id="1912" data-permalink="https://www.stochasticlifestyle.com/implicit-ode-solvers-are-not-universally-more-robust-than-explicit-ode-solvers-or-why-no-ode-solver-is-best/stability_region_for_euler_method-svg/" data-orig-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_Euler_method.svg.png?fit=500%2C375&amp;ssl=1" data-orig-size="500,375" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Stability_region_for_Euler_method.svg" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_Euler_method.svg.png?fit=300%2C225&amp;ssl=1" data-large-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_Euler_method.svg.png?fit=500%2C375&amp;ssl=1" src="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_Euler_method.svg.png?resize=500%2C375&amp;ssl=1" alt="" width="500" height="375" srcset="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_Euler_method.svg.png?w=500&amp;ssl=1 500w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_Euler_method.svg.png?resize=300%2C225&amp;ssl=1 300w" sizes="auto, (max-width: 500px) 100vw, 500px"/></a></p>
<p>This shows a pretty bad property for this method. For any given $\lambda$ with negative real part, there is a maximum $h$, actually $h = 1/\lambda$, such that for any larger step size we don’t just get a bad answer, we can get an infinitely bad answer, i.e. the analytical solution goes to zero but the numerical solution goes to infinity!</p>
<p>So, is there a method that doesn’t have this bad property? In comes the implicit methods. If you run the same analysis with implicit Euler,</p>
<p>$$u_{n+1} = u_n + hf(u_{n+1})$$</p>
<p>$$u_{n+1} = u_n + h\lambda u_{n+1}$$</p>
<p>$$(1-z) u_{n+1} = u_n$$</p>
<p>$$u_{n+1} = \frac{1}{1-z} u_n$$</p>
<p>Then we have almost an “inverse” answer, i.e. $G(z)$ is everything except the unit circle in the complex plane shifted to the right. This means that for any $\lambda$ with negative real part, for any $h$ the implicit Euler method has $u_n \rightarrow 0$, therefore it’s never infinitely wrong.</p>
<p><a href="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_BDF1.svg.png?ssl=1" rel="lightbox[1901]"><img data-recalc-dims="1" loading="lazy" decoding="async" data-attachment-id="1913" data-permalink="https://www.stochasticlifestyle.com/implicit-ode-solvers-are-not-universally-more-robust-than-explicit-ode-solvers-or-why-no-ode-solver-is-best/stability_region_for_bdf1-svg/" data-orig-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_BDF1.svg.png?fit=500%2C375&amp;ssl=1" data-orig-size="500,375" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Stability_region_for_BDF1.svg" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_BDF1.svg.png?fit=300%2C225&amp;ssl=1" data-large-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_BDF1.svg.png?fit=500%2C375&amp;ssl=1" src="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_BDF1.svg.png?resize=500%2C375&amp;ssl=1" alt="" width="500" height="375" srcset="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_BDF1.svg.png?w=500&amp;ssl=1 500w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_BDF1.svg.png?resize=300%2C225&amp;ssl=1 300w" sizes="auto, (max-width: 500px) 100vw, 500px"/></a></p>
<p>Therefore it’s just better, QED.</p>
<p>This then generalizes to more advanced methods. For example, the stability region of RK4</p>
<p><a href="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk4_stability.png?ssl=1" rel="lightbox[1901]"><img data-recalc-dims="1" loading="lazy" decoding="async" data-attachment-id="1911" data-permalink="https://www.stochasticlifestyle.com/implicit-ode-solvers-are-not-universally-more-robust-than-explicit-ode-solvers-or-why-no-ode-solver-is-best/rk4_stability/" data-orig-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk4_stability.png?fit=432%2C464&amp;ssl=1" data-orig-size="432,464" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rk4_stability" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk4_stability.png?fit=279%2C300&amp;ssl=1" data-large-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk4_stability.png?fit=432%2C464&amp;ssl=1" src="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk4_stability.png?resize=432%2C464&amp;ssl=1" alt="" width="432" height="464" srcset="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk4_stability.png?w=432&amp;ssl=1 432w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk4_stability.png?resize=279%2C300&amp;ssl=1 279w" sizes="auto, (max-width: 432px) 100vw, 432px"/></a></p>
<p>an explicit method has a maximum $h$, while the stability region of BDF2</p>
<p><a href="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_BDF2.svg.png?ssl=1" rel="lightbox[1901]"><img data-recalc-dims="1" loading="lazy" decoding="async" data-attachment-id="1915" data-permalink="https://www.stochasticlifestyle.com/implicit-ode-solvers-are-not-universally-more-robust-than-explicit-ode-solvers-or-why-no-ode-solver-is-best/stability_region_for_bdf2-svg/" data-orig-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_BDF2.svg.png?fit=500%2C375&amp;ssl=1" data-orig-size="500,375" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Stability_region_for_BDF2.svg" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_BDF2.svg.png?fit=300%2C225&amp;ssl=1" data-large-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_BDF2.svg.png?fit=500%2C375&amp;ssl=1" src="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_BDF2.svg.png?resize=500%2C375&amp;ssl=1" alt="" width="500" height="375" srcset="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_BDF2.svg.png?w=500&amp;ssl=1 500w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Stability_region_for_BDF2.svg.png?resize=300%2C225&amp;ssl=1 300w" sizes="auto, (max-width: 500px) 100vw, 500px"/></a></p>
<p>an implicit method does not. You can even prove it’s impossible for any explicit method to have this “good” property, so “implicit methods are better”. QED times 2, done deal.</p>
<h2>Wait a second, what about that other “wrongness”?</h2>
<p>Any attentive student should immediately throw their hand up. “Teacher, given the $G(z)$ you said, you also have that for any $\lambda$ where $\text{Re}(\lambda)&gt;1$, you also have that $u_n \rightarrow 0$, but in reality the analytical solution has $u(t) \rightarrow \infty$, so implicit Euler is infinitely wrong! And explicit Euler has the correct asymptotic behavior since it goes to infinity!”</p>
<p>That is completely correct! But it can be easy to brush this off with “practical concerns”. If you have a real model which has positive real eigenvalues like that, then it’s just going to explode to infinity. Those kinds of models aren’t really realistic? Energy goes to infinity, angular momentum goes to infinity, the chemical concentration goes to infinity: whatever you’re modeling just goes crazy! If you’re in this scenario, then your model is probably wrong. Or if the model isn’t wrong, the numerical methods aren’t very good anyways. If you analyze the error propagation properties, you’ll see the error of the numerical method also increases exponentially! So this is a case you shouldn’t be modeling anyways.</p>
<h2>Seeing this robustness in practice</h2>
<p>Therefore if you need a more accurate result, use an implicit method. And you don’t need to go to very difficult models to see this manifest in practice. Take the linear ODE:</p>
<p>$$T’ = 5(300-T)$$</p>
<p>with $T(0) = 320$. This is a simple model of cooling an object with a constant temperature influx. It’s easy to analytically solve, you just have an exponential fall in the temperature towards $T = 300$ the steady state. But when we solve it with an explicit method at default tolerances, that’s not what we see:</p>


<div><div><div><div><div><div><div><pre><span>using</span> OrdinaryDiffEq
<span>function</span> cooling<span>(</span>du,u,p,t<span>)</span>
    du<span>[</span><span>1</span><span>]</span> = <span>5.0</span><span>*</span><span>(</span><span>300</span>-u<span>[</span><span>1</span><span>]</span><span>)</span>
<span>end</span>
u0 = <span>[</span><span>310.0</span><span>]</span>
tspan = <span>(</span><span>0.0</span>,<span>10.0</span><span>)</span>
prob = ODEProblem<span>(</span>cooling, u0, tspan<span>)</span>
sol = solve<span>(</span>prob, Tsit5<span>(</span><span>)</span><span>)</span>
 
<span>using</span> Plots
plot<span>(</span>sol, title=<span>&#34;RK Method, Cooling Problem&#34;</span><span>)</span>
savefig<span>(</span><span>&#34;rk_cooling.png&#34;</span><span>)</span></pre></div></div></div></div></div></div></div>


<p><a href="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_cooling.png?ssl=1" rel="lightbox[1901]"><img data-recalc-dims="1" loading="lazy" decoding="async" data-attachment-id="1910" data-permalink="https://www.stochasticlifestyle.com/implicit-ode-solvers-are-not-universally-more-robust-than-explicit-ode-solvers-or-why-no-ode-solver-is-best/rk_cooling/" data-orig-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_cooling.png?fit=600%2C400&amp;ssl=1" data-orig-size="600,400" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rk_cooling" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_cooling.png?fit=300%2C200&amp;ssl=1" data-large-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_cooling.png?fit=600%2C400&amp;ssl=1" src="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_cooling.png?resize=600%2C400&amp;ssl=1" alt="" width="600" height="400" srcset="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_cooling.png?w=600&amp;ssl=1 600w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_cooling.png?resize=300%2C200&amp;ssl=1 300w" sizes="auto, (max-width: 600px) 100vw, 600px"/></a></p>
<p>We see that the explicit method gives oscillations in the solution! Meanwhile, if we take a “robust” implicit method like the BDF method from the classic C++ library SUNDIALS, we can solve this:</p>


<div><div><div><div><div><div><div><pre><span>using</span> Sundials
sol = solve<span>(</span>prob, CVODE_BDF<span>(</span><span>)</span><span>)</span>
plot<span>(</span>sol, title=<span>&#34;BDF Method, Cooling Problem&#34;</span><span>)</span>
savefig<span>(</span><span>&#34;bdf_cooling.png&#34;</span><span>)</span></pre></div></div></div></div></div></div></div>


<p><a href="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/bdf_cooling.png?ssl=1" rel="lightbox[1901]"><img data-recalc-dims="1" loading="lazy" decoding="async" data-attachment-id="1908" data-permalink="https://www.stochasticlifestyle.com/implicit-ode-solvers-are-not-universally-more-robust-than-explicit-ode-solvers-or-why-no-ode-solver-is-best/bdf_cooling/" data-orig-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/bdf_cooling.png?fit=600%2C400&amp;ssl=1" data-orig-size="600,400" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="bdf_cooling" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/bdf_cooling.png?fit=300%2C200&amp;ssl=1" data-large-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/bdf_cooling.png?fit=600%2C400&amp;ssl=1" src="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/bdf_cooling.png?resize=600%2C400&amp;ssl=1" alt="" width="600" height="400" srcset="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/bdf_cooling.png?w=600&amp;ssl=1 600w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/bdf_cooling.png?resize=300%2C200&amp;ssl=1 300w" sizes="auto, (max-width: 600px) 100vw, 600px"/></a></p>
<p>Sure it’s not perfectly accurate, but at least it doesn’t give extremely wrong behavior. We can decrease tolerances to make this all go away,</p>
<p><a href="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_cooling_lowtol.png?ssl=1" rel="lightbox[1901]"><img data-recalc-dims="1" loading="lazy" decoding="async" data-attachment-id="1909" data-permalink="https://www.stochasticlifestyle.com/implicit-ode-solvers-are-not-universally-more-robust-than-explicit-ode-solvers-or-why-no-ode-solver-is-best/rk_cooling_lowtol/" data-orig-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_cooling_lowtol.png?fit=600%2C400&amp;ssl=1" data-orig-size="600,400" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rk_cooling_lowtol" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_cooling_lowtol.png?fit=300%2C200&amp;ssl=1" data-large-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_cooling_lowtol.png?fit=600%2C400&amp;ssl=1" src="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_cooling_lowtol.png?resize=600%2C400&amp;ssl=1" alt="" width="600" height="400" srcset="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_cooling_lowtol.png?w=600&amp;ssl=1 600w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_cooling_lowtol.png?resize=300%2C200&amp;ssl=1 300w" sizes="auto, (max-width: 600px) 100vw, 600px"/></a></p>
<p>But the main point is that the explicit method is just generally “less robust”, you have to be more careful, it can give things that are just qualitatively wrong.</p>
<p>This means that “good tools”, tools that have a reputation for robustness, they should default to just using implicit solvers because that’s going to be better. And you see that in tools like Modelica. For example, the <a href="https://modelica.university/">Modelica University’s playground</a> and other tools in the space like OpenModelica and Dymola, default to implicit solvers like DASSL. And you can see they do great on this problem by default!</p>
<p><a href="https://playground.modelica.university/?model=UmVhbCB4OwpSZWFsIHY7CmluaXRpYWwgZXF1YXRpb24KICB4ID0gMTsKICB2ID0gMTsKZXF1YXRpb24KZGVyKHgpID0gNTAwKnY7CmRlcih2KSA9IC01MDAqeDs%253D&amp;report=PGNoYXJ0IHNpZ25hbHM9IngiPg%253D%253D">Modelica tools gives a good answer out of the box.</a></p>
<p><a href="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-10.43.55-PM-scaled.png?ssl=1" rel="lightbox[1901]"><img data-recalc-dims="1" loading="lazy" decoding="async" data-attachment-id="1907" data-permalink="https://www.stochasticlifestyle.com/implicit-ode-solvers-are-not-universally-more-robust-than-explicit-ode-solvers-or-why-no-ode-solver-is-best/screenshot-2025-09-03-at-10-43-55-pm/" data-orig-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-10.43.55-PM-scaled.png?fit=2560%2C1102&amp;ssl=1" data-orig-size="2560,1102" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Screenshot 2025-09-03 at 10.43.55 PM" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-10.43.55-PM-scaled.png?fit=300%2C129&amp;ssl=1" data-large-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-10.43.55-PM-scaled.png?fit=1024%2C441&amp;ssl=1" src="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-10.43.55-PM-scaled.png?resize=2560%2C1102&amp;ssl=1" alt="" width="2560" height="1102" srcset="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-10.43.55-PM-scaled.png?w=2560&amp;ssl=1 2560w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-10.43.55-PM-scaled.png?resize=300%2C129&amp;ssl=1 300w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-10.43.55-PM-scaled.png?resize=1024%2C441&amp;ssl=1 1024w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-10.43.55-PM-scaled.png?resize=768%2C331&amp;ssl=1 768w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-10.43.55-PM-scaled.png?resize=1536%2C661&amp;ssl=1 1536w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-10.43.55-PM-scaled.png?resize=2048%2C882&amp;ssl=1 2048w" sizes="auto, (max-width: 1000px) 100vw, 1000px"/></a></p>
<p>So QED, that’s the “right thing to do”: if you want to be robust, stick to implicit methods.</p>
<h2>But why oscillations?</h2>
<p>Hold up a bit… why does the explicit method give oscillations? While we know that’s wrong, it would be good to understand why it gives the qualitatively wrong behavior that it does. It turns out that this falls right out of the definition of the method. If you go back to the definition of explicit Euler on the test problem, i.e.</p>
<p>$$u_{n+1} = u_n + hf(u_n)$$</p>
<p>then substitute in:</p>
<p>$$u_{n+1} = (1 + h\lambda) u_{n}$$</p>
<p>If we think about our stability criteria $G(z)$ another way, its boundaries are exactly the value by which the next $u_{n+1}$ would have a negative real part. So the analytical solution is supposed to go to zero, but the “bad” behavior is when we choose a step size $h$ such that if we extrapolate out with a straight line for $h$ long in time, then we will “jump” over this zero, something that doesn’t happen in the analytical solution. But now let’s think about what happens in that case. If you jump over zero, then $u_n &lt; 0$ (think real right now), so therefore the derivative of the next update points in the other direction, i.e. we&#39;re still going towards zero, but now from the negative side we go up to zero. But since $\|1 + h\lambda\| &gt; 1$, we have that $\|u_{n+1}\| &gt; \|u_n\|$, i.e. the norm of the solution keeps growing. So you jump from positive to negative, then negative to positive, then positive to negative, where the jumps are growing each time. This is the phantom oscillations of the explicit ODE solver!</p>
<p>So what’s happening is the default tolerances of the explicit ODE solver were large enough that the chosen $h$s were in the range of the phantom oscillation behavior, and so you just need to cap $h$ below that value, which is dependent on the real part of the eigenvalue of $h$ (you can do the same analysis with complex numbers, but that just gives rotations in the complex plane along with the real part oscillation).</p>
<p>But if explicit methods give oscillations, what’s going on with implicit ODE solvers with large $h$? Let’s look at the update equation again:</p>
<p>$$u_{n+1} = \frac{1}{1-z} u_n$$</p>
<p>now instead of multiplying each time by $(1-z)$, we divide by it. This means that when $\lambda &lt; 0$ (or $\text{Re}(\lambda) &lt; 0$ to be more exact), then for any $h$ we have that $\|u_{n+1}\| &lt; \|u_{n}\|$. Therefore, we might jump over the zero with a big enough $h$, but we are guaranteed that our &#34;jump size&#34; is always shrinking. Thus for any $h$, we will get to zero because we&#39;re always shrinking in absolute value.

This means that implicit methods are working because they have a natural dampening effect. So:



</p><h4>Explicit methods introduce spurious oscillations, but implicit methods naturally damp oscillations</h4>
<p>This explains in more detail why we saw what we saw: the explicit method when the error tolerance is sufficiently high will introduce oscillations that don’t exist, while the implicit method will not have this behavior. This is a more refined version of the “energy doesn’t go to infinity!”, now it’s “energy doesn’t come from nowhere in real systems”, and because of this implicit solvers give a better qualitative answer. This is why they are more robust, which is why robust software for real engineers just always default to them.</p>
<h2>Wait a second… do we always want that?</h2>
<p>You should now be the student in the front row raising your hand, “implicit methods are always dampening… is that actually a good idea? Are you sure that’s always correct?” And the answer is… well it’s not. And that then gives us exactly the failure case for which implicit methods are less robust. If you have a system that is supposed to actually oscillate, then this “hey let’s always dampen everything to make solving more robust” actually leads to very wrong answers!</p>
<p>To highlight this, let’s just take a simple oscillator. You can think of this as a harmonic oscillator, or you can think about it as a simple model of a planet going around a star. However you want to envision it, you can write it out as a system of ODEs:</p>
<p>$$u_1′ = 500u_2$$</p>
<p>This is the linear ODE $u’ = Au$ where $A = [0\ 500; -500\ 0]$, which has complex eigenvalues with zero real part. In other words, the analytical solution is $\sin(500t)$ and $\cos(500t)$, just a pure oscillation that just keeps going around and around in circles. If we solve this with an explicit ODE solver:</p>


<div><div><div><div><div><div><div><pre><span>function</span> f<span>(</span>du,u,p,t<span>)</span>
    du<span>[</span><span>1</span><span>]</span> = 500u<span>[</span><span>2</span><span>]</span>
    du<span>[</span><span>2</span><span>]</span> = -500u<span>[</span><span>1</span><span>]</span>
<span>end</span>
u0 = <span>[</span><span>1.0</span>,<span>1.0</span><span>]</span>
tspan = <span>(</span><span>0.0</span>,<span>1.0</span><span>)</span>
prob = ODEProblem<span>(</span>f, u0, tspan<span>)</span>
sol = solve<span>(</span>prob, Tsit5<span>(</span><span>)</span><span>)</span>
 
plot<span>(</span>sol, title=<span>&#34;RK Method&#34;</span>, idxs=<span>(</span><span>1</span>,<span>2</span><span>)</span><span>)</span>
savefig<span>(</span><span>&#34;rk_oscillate.png&#34;</span><span>)</span></pre></div></div></div></div></div></div></div>


<p><a href="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_oscillate.png?ssl=1" rel="lightbox[1901]"><img data-recalc-dims="1" loading="lazy" decoding="async" data-attachment-id="1906" data-permalink="https://www.stochasticlifestyle.com/implicit-ode-solvers-are-not-universally-more-robust-than-explicit-ode-solvers-or-why-no-ode-solver-is-best/rk_oscillate/" data-orig-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_oscillate.png?fit=600%2C400&amp;ssl=1" data-orig-size="600,400" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rk_oscillate" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_oscillate.png?fit=300%2C200&amp;ssl=1" data-large-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_oscillate.png?fit=600%2C400&amp;ssl=1" src="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_oscillate.png?resize=600%2C400&amp;ssl=1" alt="" width="600" height="400" srcset="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_oscillate.png?w=600&amp;ssl=1 600w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/rk_oscillate.png?resize=300%2C200&amp;ssl=1 300w" sizes="auto, (max-width: 600px) 100vw, 600px"/></a></p>
<p>we can see that it generally gets the right answer. Over time you get some drift where the energy is slowly increasing due to numerical error in each step, but it’s going around in circles relatively well. However, our “robust implicit method”…</p>


<div><div><div><div><div><div><div><pre>sol = solve<span>(</span>prob, CVODE_BDF<span>(</span><span>)</span><span>)</span>
plot<span>(</span>sol, title=<span>&#34;BDF Method&#34;</span>, idxs=<span>(</span><span>1</span>,<span>2</span><span>)</span><span>)</span>
savefig<span>(</span><span>&#34;bdf_oscillate.png&#34;</span><span>)</span></pre></div></div></div></div></div></div></div>


<p><a href="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/bdf_oscallate.png?ssl=1" rel="lightbox[1901]"><img data-recalc-dims="1" loading="lazy" decoding="async" data-attachment-id="1905" data-permalink="https://www.stochasticlifestyle.com/implicit-ode-solvers-are-not-universally-more-robust-than-explicit-ode-solvers-or-why-no-ode-solver-is-best/bdf_oscallate/" data-orig-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/bdf_oscallate.png?fit=600%2C400&amp;ssl=1" data-orig-size="600,400" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="bdf_oscallate" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/bdf_oscallate.png?fit=300%2C200&amp;ssl=1" data-large-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/bdf_oscallate.png?fit=600%2C400&amp;ssl=1" src="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/bdf_oscallate.png?resize=600%2C400&amp;ssl=1" alt="" width="600" height="400" srcset="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/bdf_oscallate.png?w=600&amp;ssl=1 600w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/bdf_oscallate.png?resize=300%2C200&amp;ssl=1 300w" sizes="auto, (max-width: 600px) 100vw, 600px"/></a></p>
<p>is just not even close. And you can see that even our <a href="https://playground.modelica.university/?model=UmVhbCB4OwpSZWFsIHY7CmluaXRpYWwgZXF1YXRpb24KICB4ID0gMTsKICB2ID0gMTsKZXF1YXRpb24KZGVyKHgpID0gNTAwKnY7CmRlcih2KSA9IC01MDAqeDs%253D&amp;report=PGNoYXJ0IHNpZ25hbHM9IngiPg%253D%253D">“robust Modelica tools” completely fall apart</a>:</p>
<p><a href="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.08.10-PM-scaled.png?ssl=1" rel="lightbox[1901]"><img data-recalc-dims="1" loading="lazy" decoding="async" data-attachment-id="1904" data-permalink="https://www.stochasticlifestyle.com/implicit-ode-solvers-are-not-universally-more-robust-than-explicit-ode-solvers-or-why-no-ode-solver-is-best/screenshot-2025-09-03-at-11-08-10-pm/" data-orig-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.08.10-PM-scaled.png?fit=2560%2C1102&amp;ssl=1" data-orig-size="2560,1102" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Screenshot 2025-09-03 at 11.08.10 PM" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.08.10-PM-scaled.png?fit=300%2C129&amp;ssl=1" data-large-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.08.10-PM-scaled.png?fit=1024%2C441&amp;ssl=1" src="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.08.10-PM-scaled.png?resize=2560%2C1102&amp;ssl=1" alt="" width="2560" height="1102" srcset="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.08.10-PM-scaled.png?w=2560&amp;ssl=1 2560w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.08.10-PM-scaled.png?resize=300%2C129&amp;ssl=1 300w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.08.10-PM-scaled.png?resize=1024%2C441&amp;ssl=1 1024w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.08.10-PM-scaled.png?resize=768%2C331&amp;ssl=1 768w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.08.10-PM-scaled.png?resize=1536%2C661&amp;ssl=1 1536w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.08.10-PM-scaled.png?resize=2048%2C882&amp;ssl=1 2048w" sizes="auto, (max-width: 1000px) 100vw, 1000px"/></a></p>
<p>It says the answer goes to zero! Even when the analytical solution is just a circle! But we can understand why this is the case: the software developers made the implicit assumption that “dampening oscillations is always good, because generally that’s what happens in models, so let’s always do this by default so people get better answers”, and the result of this choice is that if someone puts in a model of the Earth going around the sun, then oops the Earth hits the sun pretty quickly.</p>
<h2>Conclusion: ODE solvers make trade-offs, you need to make the right ones for your domain</h2>
<p>This gives us the conclusion: there is no “better” or “more robust” ODE solver method, it’s domain-specific. This is why <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/">the Julia ODE solver package has hundreds of methods</a>, because each domain can be asking for different properties that they want out of the method. Explicit methods are not generally faster, they are also something that tends to preserve (or generate) oscillations. Implicit methods are not generally more robust, they are methods which work by dampening transients, which is a good idea for some models but not for others. But then there’s a ton of nuance. For example, can you construct an explicit ODE solver so that on such oscillations you don’t get energy growth? You can! <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/#Explicit-Runge-Kutta-Methods">Anas5(w) is documented as “4th order Runge-Kutta method designed for periodic problems. Requires a periodicity estimate w which when accurate the method becomes 5th order (and is otherwise 4th order with less error for better estimates)”</a>, i.e. if you give it a canonical frequency 500 it will be able to do extremely well on this problem (and being a bit off in that estimate still works, it just has energy growth that is small).</p>
<p>What about what was mentioned at the beginning of the article, “for hyperbolic PDEs you need to use explicit methods”? This isn’t a “special behavior” of PDEs, this is simply because for this domain, for example advective models of fluids, you want to conserve fluid as it moves. If you choose an implicit method, it “dampens” the solver, which means you get that as you integrate you get less and less fluid, breaking the conservation laws and giving qualitatively very incorrect solutions. If you use explicit methods, you don’t have this extraneous dampening, and this gives a better looking solution. But you can go even further and develop methods for which, if $h$ is sufficiently small, then you get little to no dampening. These are <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/#Explicit-Strong-Stability-Preserving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)">SSP methods</a>, which we say are “for Hyperbolic PDEs (Conservation Laws)” but in reality what we mean is “when you don’t want things to dampen”.</p>
<p>But the point is, you can’t just say “if you want a better solution, use an implicit solver”. Maybe in some domains and for some problems that is true, but in other domains and problems that’s not true. And many numerical issues can stem from the implicit assumptions that follow from the choice being made for the integrator. Given all of this, it should be no surprise that much of the Modelica community has had many problems handling fluid models, the general flow of “everything is a DAE” → “always use an implicit solver” → “fluid models always dampen” → “we need to fix the dampening” could be fixed by making different assumptions at the solver level.</p>
<p>So, the next time someone tells you should just use ode15s or scipy.integrate.radau in order to make things robust without knowing anything about your problem, say “umm actually”.</p>
<h2>Little Extra Details</h2>
<p>The article is concluded. But here’s a few points I couldn’t fit into the narrative I want to mention:</p>
<h3>Trapezoidal is cool</h3>
<p>One piece I didn’t fit in here is that the Trapezoidal method is cool. The dampening property comes from L-stability, i.e. $G(z) \rightarrow 0$ as $\text{Re}(z) \rightarrow -\infty$. This is a stricter form of stability, since instead of just being stable for any finite $\lambda$, this also enforces that you are stable at the limit of bigger lambdas. “Most” implicit solvers that are used in practice, like Implicit Euler, have this property, and you can show the dampening is directly related to this property. But you can have an implicit method that isn’t L-stable. Some of these methods include Adams-Bashforth-Moulton methods, which are not even A-stable so they tend to have stability properties and act more like explicit methods. But the Trapezoidal method is A-stable without being L-stable, so it doesn’t tend to dampen while it tends to be also pretty stable. Though it’s not as stable, and the difference between “is stable for any linear ODE” versus “actually stable for nonlinear ODEs” (i.e. B-stability) is pronounced on real-world stiff problems. What this means in human terms is that the Trapezoidal method tends to not be stable enough for hard stiff problems, but it also doesn’t artificially dampen, so it can be a good default in cases where you know you have “some stiffness” but also want to keep some oscillations. One particular case of this is in some electrical circuit models with natural oscillators.</p>
<h3>Lower order methods have purposes too</h3>
<p>“All ODE solvers have a purpose”, I <a href="https://www.youtube.com/watch?v=s_t6dIKjUUc">give some talks that give the justification for many high order methods</a>, so in general “higher order is good if you solve with stricter tolerances and need more precision”. But lower order methods can be better because the higher order methods require that more derivatives of $f$ are defined, and if that’s not the case (like derivative discontinuities), then lower order methods will be more efficient. So even implicit Euler has cases where it’s better than higher order BDF methods, and it has to do with “how nice” $f$ is.</p>
<h3>BDF methods like DASSL are actually α-stable</h3>
<p>I said that generally implicit methods that you use are A-stable. That’s also a small lie to make the narrative simpler. The BDF methods which Sundials, DASSL, LSODE, FBDF, etc. use are actually α-stable, which means that they are actually missing some angle α of the complex plane for stability. The stability regions look like this:</p>
<p><a href="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.33.51-PM.png?ssl=1" rel="lightbox[1901]"><img data-recalc-dims="1" loading="lazy" decoding="async" data-attachment-id="1903" data-permalink="https://www.stochasticlifestyle.com/implicit-ode-solvers-are-not-universally-more-robust-than-explicit-ode-solvers-or-why-no-ode-solver-is-best/screenshot-2025-09-03-at-11-33-51-pm/" data-orig-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.33.51-PM.png?fit=1758%2C1230&amp;ssl=1" data-orig-size="1758,1230" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Screenshot 2025-09-03 at 11.33.51 PM" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.33.51-PM.png?fit=300%2C210&amp;ssl=1" data-large-file="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.33.51-PM.png?fit=1024%2C716&amp;ssl=1" src="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.33.51-PM.png?resize=1758%2C1230&amp;ssl=1" alt="" width="1758" height="1230" srcset="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.33.51-PM.png?w=1758&amp;ssl=1 1758w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.33.51-PM.png?resize=300%2C210&amp;ssl=1 300w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.33.51-PM.png?resize=1024%2C716&amp;ssl=1 1024w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.33.51-PM.png?resize=768%2C537&amp;ssl=1 768w, https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2025/09/Screenshot-2025-09-03-at-11.33.51-PM.png?resize=1536%2C1075&amp;ssl=1 1536w" sizes="auto, (max-width: 1000px) 100vw, 1000px"/></a></p>
<p>So these BDF methods are actually pretty bad for other reasons on very oscillatory problems! Meanwhile, things like Rosenbrock methods can also solve DAEs while actually being L-stable, which can make them more stable in many situations where there’s oscillations towards a steady state. So there’s a trade-off there… again every method has a purpose. But this is another “ode15s is more stable than ode23s”… “well actually…”</p>

                    </div><!--end entry-->
    <!--end post footer-->
  </div></div>
  </body>
</html>
