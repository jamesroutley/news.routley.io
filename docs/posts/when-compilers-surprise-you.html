<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xania.org/202512/24-cunning-clang">Original</a>
    <h1>When Compilers Surprise You</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
        <h2>When compilers surprise you</h2>

        <p>Written by me, proof-read by an LLM.
</p>
<p>Every now and then a compiler will surprise me with a really smart trick. When I first saw this optimisation I could hardly believe it. I was looking at loop optimisation, and wrote something like this simple function that sums all the numbers up to a given value:</p>


<p>So far so decent: GCC has done some preliminary checks, then fallen into a loop that efficiently sums numbers using <code>lea</code> (we’ve <a href="https://www.moderndescartes.com/202512/02-adding-integers">seen this before</a>). But taking a closer look at the loop we see something unusual:</p>
<div><pre><code><span>.L3:</span>
<span>  </span><span>lea</span><span> </span><span>edx</span><span>,</span><span> </span><span>[</span><span>rdx</span><span>+</span><span>1</span><span>+</span><span>rax</span><span>*</span><span>2</span><span>]</span><span>        </span><span>; result = result + 1 + x*2</span>
<span>  </span><span>add</span><span> </span><span>eax</span><span>,</span><span> </span><span>2</span><span>                    </span><span>; x += 2</span>
<span>  </span><span>cmp</span><span> </span><span>edi</span><span>,</span><span> </span><span>eax</span><span>                  </span><span>; x != value</span>
<span>  </span><span>jne</span><span> </span><span>.L3</span><span>                       </span><span>; keep looping</span>
</code></pre></div>

<p>The compiler has cleverly realised it can do two numbers<sup id="fnref:check"><a href="#fn:check">1</a></sup> at a time using the fact it can see we’re going to add <code>x</code> <em>and</em> <code>x + 1</code>, which is the same as adding <code>x*2 + 1</code>. Very cunning, I think you’ll agree!</p>
<p>If you turn the optimiser up to <code>-O3</code> you’ll see the compiler works even harder to vectorise the loop using parallel adds. All very clever.</p>
<p>This is all for GCC. Let’s see what clang does with our code:</p>


<p>This is where I nearly fell off my chair: <strong>there is no loop</strong>! Clang checks for positive <code>value</code>, and if so it does:</p>
<div><pre><code><span>  </span><span>lea</span><span> </span><span>eax</span><span>,</span><span> </span><span>[</span><span>rdi</span><span> </span><span>-</span><span> </span><span>1</span><span>]</span><span>        </span><span>; eax = value - 1</span>
<span>  </span><span>lea</span><span> </span><span>ecx</span><span>,</span><span> </span><span>[</span><span>rdi</span><span> </span><span>-</span><span> </span><span>2</span><span>]</span><span>        </span><span>; ecx = value - 2</span>
<span>  </span><span>imul</span><span> </span><span>rcx</span><span>,</span><span> </span><span>rax</span><span>             </span><span>; rcx = (value - 1) * (value - 2)</span>
<span>  </span><span>shr</span><span> </span><span>rcx</span><span>                   </span><span>; rcx &gt;&gt;= 1</span>
<span>  </span><span>lea</span><span> </span><span>eax</span><span>,</span><span> </span><span>[</span><span>rdi</span><span> </span><span>+</span><span> </span><span>rcx</span><span>]</span><span>      </span><span>; eax = value + rcx</span>
<span>  </span><span>dec</span><span> </span><span>eax</span><span>                   </span><span>; --eax</span>
<span>  </span><span>ret</span>
</code></pre></div>

<p>It was not at all obvious to me what on earth was going on here. By backing out the maths a little, this is equivalent to:</p>
<div><pre><code>v + ((v - 1)(v - 2) / 2) - 1;
</code></pre></div>

<p>Expanding the parentheses:</p>
<div><pre><code>v + (v² - 2v - v + 2) / 2 - 1
</code></pre></div>

<p>Rearranging a bit:</p>
<div><pre><code>(v² - 3v + 2) / 2 + (v - 1)
</code></pre></div>

<p>Multiplying the <code>(v - 1)</code> by 2 / 2:</p>
<div><pre><code>(v² - 3v + 2) / 2 + (2v - 2)/2
</code></pre></div>

<p>Combining those and cancelling:</p>


<p>Simplifying and factoring gives us <code>v(v - 1) / 2</code> which is the closed-form solution to the “sum of integers”! Truly amazing<sup id="fnref:why"><a href="#fn:why">2</a></sup> - we’ve gone from an O(n) algorithm as written, to an O(1) one!</p>
<p>I love that despite working with compilers for more than twenty years, they can still surprise and delight me. The years of experience and work that have been poured into making compilers great is truly humbling, and inspiring.</p>
<p>We’re nearly at the end of this series - there’s so much more to say but that will have to wait for another time. Tomorrow will be a little different: see you then!</p>
<p><em>See <a href="https://youtu.be/V9dy34slaxA">the video</a> that accompanies this post.</em></p>
<hr/>
<p><em>This post is day 24 of <a href="https://www.moderndescartes.com/AoCO2025">Advent of Compiler Optimisations 2025</a>,
a 25-day series exploring how compilers transform our code.</em></p>
<p><em>This post was written by a human (<a href="https://www.moderndescartes.com/MattGodbolt">Matt Godbolt</a>) and reviewed and proof-read by LLMs and humans.</em></p>
<p><em>Support Compiler Explorer on <a href="https://patreon.com/c/mattgodbolt">Patreon</a>
or <a href="https://github.com/sponsors/compiler-explorer">GitHub</a>,
or by buying CE products in the <a href="https://shop.compiler-explorer.com">Compiler Explorer Shop</a></em>.</p>

    </div>
</div></div>
  </body>
</html>
