<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://catgirl.ai/log/comfy-software/">Original</a>
    <h1>Comfy Software: A software aesthetic for hackers with depression</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articlebody">
    <p>Modern software can be... a mess. Electron has made it easier to develop
cross-platform applications, but at the cost of bloating everything by the
footprint of an entire browser, and browsers themselves are getting more and
more complicated. It feels like developers aren&#39;t really optimizing for
resource usage; for a while, my main laptop was a Thinkpad T450s. In mid-2015,
it was a fairly respectable laptop. In 2021, opening Twitter would make the
fans spin up.</p>
<p>But there&#39;s still software out here that makes me feel <em>happy</em> to use, software
that embodies an aesthetic that, for lack of a better word, I call <strong>cozy
software</strong>. (Note: I originally called it &#39;cozy software&#39;, and I go back and
forth depending on how much I like the /mf/ consonant cluster that day. The two terms are synonymous. My friend <a href="https://l4.pm/">Luna</a> referred to it as &#39;cuteware&#39;.)</p>
<p>I&#39;m not the person to come up with the term; I
picked it up from someone or another on the Fediverse, and they might
well have picked it up from someone else. But I&#39;ve definitely been
thinking about it a lot: what makes software a joy to use, both
practically and ideologically?</p>
<h2 id="the-pillars-of-cozy-software">The pillars of cozy software</h2>
<p>In my opinion, the pillars of coziness (in no particular order) are:</p>
<ul>
<li>Customizability</li>
<li>Keyboard-focused navigation</li>
<li>Non-corporate governance</li>
<li>Good documentation</li>
<li>Make the common things easy</li>
<li>A cute name</li>
</ul>
<p>This isn&#39;t a list I had in mind when I first thought about the concept; &#39;cozy software&#39; is more of a <a href="https://en.wikipedia.org/wiki/Family_resemblance">family resemblance</a> than something with rigorous definitions.</p>
<h3 id="customizability">Customizability</h3>
<p>I like making things feel like my own. This is part of why I switched
away from macOS back to Linux a couple years ago: sure, things would
usually &#39;just work&#39; on macOS, but I didn&#39;t have the degree of
<em>control</em> over it that I wanted. With Linux, I can pick my own window
manager, my own desktop environment (or lack thereof), my own package
management system, and so on. This machine feels like it&#39;s <em>mine</em> in a
way that a Macbook never could.</p>
<p>Some people might say that, well, Ash, the time spent getting your
window manager&#39;s background blur just right or optimizing your
keybindings is time that you could&#39;ve spent writing actual code. And
that&#39;s certainly true. But: I actually <em>like</em> tweaking things like
this. The point of all of this, all of the recreational stuff that I
do, is to have fun. And then at work I can transfer my setup and have
a nice environment that works just the way I like it, but without all
the effort of having to get that stuff re-set-up again.</p>
<h3 id="extensive-keyboard-focused-controls">Extensive keyboard-focused controls</h3>
<p>This doesn&#39;t mean that it has to be keyboard-<em>only</em> navigation or that the
keyboard should be considered the primary way of interacting with the
software. But you should be able to do most things with the keyboard that you
could with the mouse. emacs and vim are the canonical examples of this, of
course, but I&#39;d say <a href="https://www.blender.org/">Blender</a> actually falls in this
category as well, from my limited time tooling around with it for a personal
side project. It&#39;s very much designed to support a workflow where you use the
mouse to pick out points and objects in the scene (which would probably be too
painful to do with a keyboard) and then use the keyboard with your other hand
to act on those objects. I&#39;m not an artist, but from what I hear a lot of their
tools work similarly; you set up shortcuts and keybinds so that you don&#39;t have
to take your drawing hand off the mouse or the tablet pen.</p>
<h3 id="not-for-profit-governance">Not-for-profit governance</h3>
<p>In order for software to be comfy, the people who have the final say
over what does and doesn&#39;t go into it shouldn&#39;t be beholden to a
for-profit entity. This doesn&#39;t mean that the entity&#39;s development
can&#39;t be led by a corporation; there are plenty of legal reasons to
have your leadership be its own legal entity if you&#39;re a large
project. But that entity itself should be <em>actually</em> a community focus, and not just a thin facade around one or two megacorporations that just dictate what happens (see: the emoji consortium, everything to do with the web).</p>
<p>I think of this as the &#39;no VS Code&#39; clause: no matter how good VS Code is, I
refuse to use it because it&#39;s fundamentally a Microsoft product and I want my text editor to actually be FOSS, dammit. It doesn&#39;t help that Pylance, their Python language implementation, <a href="https://www.reddit.com/r/linux/comments/k0s8qw/vs_code_developers_prevent_running_the_new/">is only licensed to work on official builds</a>. Which ties in with the relationship between open source tooling and corporations... but that&#39;s a separate blog post.</p>
<h3 id="good-documentation">Good documentation</h3>
<p>This is an important part of good software in general, of course. But it&#39;s especially important for the cozy software aesthetic. Documentation should be available, and if the software is meant to run on a Unix machine, both <code>--help</code> and manpages should show you the help (<a href="https://catgirl.ai/log/cut-c-harmful/">no, GNU info doesn&#39;t count</a>).</p>
<p>I shouldn&#39;t have to read the code to find out how something works; I shouldn&#39;t have to search &#34;how do I X in Y&#34;. The program should be as self-contained as possible.</p>
<p>Funny enough, I think the class of software that succeeds at this the most is video games: they&#39;ll often have tutorials for things that someone who plays games as a hobby has done a hundred times before, just because every game is someone&#39;s first. If you have to look up how to do something online, that feels like a failure of the game.</p>
<p>Even in the days where games had actual manuals to go with them, <em>Super Mario 64</em> tells you how to jump, punch, and move around. Of course, that&#39;s not <em>universal</em>; to pick another genre-defining example, <em>Final Fantasy VI</em> doesn&#39;t explain in the game itself how to move or what that number next to your character name in the battle screen is. Presumably the manual does, of course. But it <em>does</em> explain systems unique to the game like the Espers or Gau&#39;s Rage. </p>

<p>Of course, there are a lot of differences: tutorial sections are culturally accepted in games, but considered annoying in software. And a lot of software doesn&#39;t even have an interface at all; imagine trying to run <code>find(1)</code> for the first time only for it to open a curses-based tutorial! But it&#39;s something to think about.</p>
<h3 id="make-the-common-things-easy">Make the common things easy</h3>
<p>The prototypical example here is <code>find</code> vs <a href="https://github.com/sharkdp/fd"><code>fd</code></a>. Probably the single most common use case for these tools is finding something with a given string somewhere in the name underneath a given directory.</p>
<p><code>find</code> has a <em>very</em> generic system where you can define a bunch of predicates and combine them arbitrarily, so you can say things like &#34;find me files that were not modified in the past 5 months and are also more than 50 megabytes&#34;. The flip side of that is that it makes the common case annoyingly verbose: to find all files with <code>foo</code> in their names, you have to run <code>find . -iname &#34;*foo*&#34;</code> (the &#34;i&#34; standing for &#34;ignoring case&#34;). With <code>fd</code>, on the other hand, it&#39;s just <code>fd foo .</code>. </p>
<p>Similarly, it&#39;s also pretty common that you actually want to execute a command over all these files. Both tools let you do so, but the syntax is very different</p>
<pre data-lang="sh"><code data-lang="sh">find . -iname &#34;*.pyc&#34; -exec rm {} \;
fd . --extension pyc --exec rm
</code></pre>
<p><code>find</code> requires you to explicitly terminate the command and specify where to splice in the argument; <code>fd</code> will infer both of those for you (but lets you specify them if the defaults don&#39;t work out). Of course, you can also use <code>xargs</code> in both cases, but if you&#39;re going to supply a way to do something then you should make it nice to use.</p>
<p>Finally, <code>fd</code> has various other niceties like respecting <code>.gitignore</code> and color output.</p>
<p>I&#39;m not using this to pick on <code>find</code> specifically, but it&#39;s a good illustration of how one of these was written a few years ago and the other was written in 1990.</p>
<h3 id="a-cute-name">A cute name</h3>
<p>This is the most vague and &#39;vibe-based&#39; of them all, and is the least important. But I like it when software has a name that <a href="https://github.com/arttuperala/kmbmpdc">has &#39;kawaii&#39; in the acronym</a> or <a href="https://github.com/emersion/mako">is named after a fictional character</a> or <a href="https://github.com/magic-wormhole/magic-wormhole">has a name that&#39;s just plain fun</a>. <a href="https://obsidian.md/">Obsidian</a> also falls in this category; even though I can&#39;t think of how the name relates to note-taking, it&#39;s just a nice name for software.</p>
<h2 id="towards-a-cozier-future">Towards a cozier future</h2>
<p>Obviously, not all software needs to fit into this. Most software written professionally will fail the &#39;non-corporate governance&#39; test, and it&#39;s harder to get that &#39;cute&#39; feeling going for something that isn&#39;t something you&#39;re working on because you&#39;re getting paid. But I&#39;ve been giving the internal tools I&#39;ve been building at work some of this character: naming them after video game characters, writing long &#34;if you got this error, you probably tried to do X. That doesn&#39;t work because Y. Do Z instead&#34; messages, and so on. And if that means you name your firewall management service <code>yuna</code>, so be it. Having a little fun is important.</p>


  </div></div>
  </body>
</html>
