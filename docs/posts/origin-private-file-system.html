<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_API/Origin_private_file_system">Original</a>
    <h1>Origin private file system</h1>
    
    <div id="readability-page-1" class="page"><article lang="en-US"><header></header><div><p><strong>Note:</strong> This feature is available in <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">Web Workers</a>.</p>
<p>The <strong>origin private file system</strong> (OPFS) is a storage endpoint provided as part of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_API">File System API</a>, which is private to the origin of the page and not visible to the user like the regular file system. It provides access to a special kind of file that is highly optimized for performance and offers in-place write access to its content.</p></div><section aria-labelledby="working_with_files_using_the_file_system_access_api"><h2 id="working_with_files_using_the_file_system_access_api"><a href="#working_with_files_using_the_file_system_access_api">Working with files using the File System Access API</a></h2><div><p>The <a href="https://wicg.github.io/file-system-access/" target="_blank">File System Access API</a>, which extends the <a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_API">File System API</a>, provides access to files using picker methods. For example:</p>
<ol>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/showOpenFilePicker"><code>Window.showOpenFilePicker()</code></a> allows the user to choose a file to access, which results in a <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle"><code>FileSystemFileHandle</code></a> object being returned.</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle/getFile"><code>FileSystemFileHandle.getFile()</code></a> is called to get access to the file&#39;s contents, the content is modified using <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle/createWritable"><code>FileSystemFileHandle.createWritable()</code></a> / <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemWritableFileStream/write"><code>FileSystemWritableFileStream.write()</code></a>.</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemHandle/requestPermission" title="FileSystemHandle.requestPermission({mode: &#39;readwrite&#39;})"><code>FileSystemHandle.requestPermission({mode: &#39;readwrite&#39;})</code></a> is used to request the user&#39;s permission to save the changes.</li>
  <li>If the user accepts the permission request, the changes are saved back to the original file.</li>
</ol>
<p>This works, but it has some restrictions. These changes are being made to the user-visible file system, so there are a lot of security checks in place (for example, <a href="https://developers.google.com/safe-browsing" target="_blank">safe browsing</a> in Chrome) to guard against malicious content being written to that file system. These writes are not in-place, and instead use a temporary file. The original is not modified unless it passes all the security checks.</p>
<p>As a result, these operations are fairly slow. It is not so noticeable when you are making small text updates, but the performance suffers when making more significant, large-scale file updates such as <a href="https://www.sqlite.org/wasm" target="_blank">SQLite</a> database modifications.</p></div></section><section aria-labelledby="how_does_the_opfs_solve_such_problems"><h2 id="how_does_the_opfs_solve_such_problems"><a href="#how_does_the_opfs_solve_such_problems">How does the OPFS solve such problems?</a></h2><div><p>The OPFS offers low-level, byte-by-byte file access, which is private to the origin of the page and not visible to the user. As a result, it doesn&#39;t require the same series of security checks and permission grants and is therefore faster than File System Access API calls. It also has a set of synchronous calls available (other File System API calls are asynchronous) that can be run inside web workers only so as not to block the main thread.</p>
<p>To summarize how the OPFS differs from the user-visible file system:</p>
<ul>
  <li>The OPFS is subject to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage_API/Storage_quotas_and_eviction_criteria">browser storage quota restrictions</a>, just like any other origin-partitioned storage mechanism (for example <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" title="IndexedDB API">IndexedDB API</a>). You can access the amount of storage space the OPFS is using via <a href="https://developer.mozilla.org/en-US/docs/Web/API/StorageManager/estimate" title="navigator.storage.estimate()"><code>navigator.storage.estimate()</code></a>.</li>
  <li>Clearing storage data for the site deletes the OPFS.</li>
  <li>Permission prompts and security checks are not required to access files in the OPFS.</li>
  <li>Browsers persist the contents of the OPFS to disk somewhere, but you cannot expect to find the created files matched one-to-one. The OPFS is not intended to be visible to the user.</li>
</ul></div></section><section aria-labelledby="how_do_you_access_the_opfs"><h2 id="how_do_you_access_the_opfs"><a href="#how_do_you_access_the_opfs">How do you access the OPFS?</a></h2><div><p>To access the OPFS in the first place, you call the <a href="https://developer.mozilla.org/en-US/docs/Web/API/StorageManager/getDirectory" title="navigator.storage.getDirectory()"><code>navigator.storage.getDirectory()</code></a> method. This returns a reference to a <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryHandle"><code>FileSystemDirectoryHandle</code></a> object that represents the root of the OPFS.</p></div></section><section aria-labelledby="manipulating_the_opfs_from_the_main_thread"><h2 id="manipulating_the_opfs_from_the_main_thread"><a href="#manipulating_the_opfs_from_the_main_thread">Manipulating the OPFS from the main thread</a></h2><div><p>When accessing the OPFS from the main thread, you will use asynchronous, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>-based APIs. You can access file (<a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle"><code>FileSystemFileHandle</code></a>) and directory (<a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryHandle"><code>FileSystemDirectoryHandle</code></a>) handles by calling <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryHandle/getFileHandle"><code>FileSystemDirectoryHandle.getFileHandle()</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryHandle/getDirectoryHandle"><code>FileSystemDirectoryHandle.getDirectoryHandle()</code></a> respectively on the <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryHandle"><code>FileSystemDirectoryHandle</code></a> object representing the OPFS root (and child directories, as they are created).</p>
<p><strong>Note:</strong> Passing <code>{ create: true }</code> into the above methods causes the file or folder to be created if it doesn&#39;t exist.</p>
<div><pre><code>// Create a hierarchy of files and folders
const fileHandle = await opfsRoot.getFileHandle(&#34;my first file&#34;, {
  create: true,
});
const directoryHandle = await opfsRoot.getDirectoryHandle(&#34;my first folder&#34;, {
  create: true,
});
const nestedFileHandle = await directoryHandle.getFileHandle(
  &#34;my first nested file&#34;,
  { create: true },
);
const nestedDirectoryHandle = await directoryHandle.getDirectoryHandle(
  &#34;my first nested folder&#34;,
  { create: true },
);

// Access existing files and folders via their names
const existingFileHandle = await opfsRoot.getFileHandle(&#34;my first file&#34;);
const existingDirectoryHandle =
  await opfsRoot.getDirectoryHandle(&#34;my first folder&#34;);
</code></pre></div></div></section><section aria-labelledby="reading_a_file"><h3 id="reading_a_file"><a href="#reading_a_file">Reading a file</a></h3><div><ol>
  <li>Make a <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryHandle/getFileHandle"><code>FileSystemDirectoryHandle.getFileHandle()</code></a> call to return a <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle"><code>FileSystemFileHandle</code></a> object.</li>
  <li>Call the <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle/getFile"><code>FileSystemFileHandle.getFile()</code></a> object to return a <a href="https://developer.mozilla.org/en-US/docs/Web/API/File"><code>File</code></a> object. This is a specialized type of <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob"><code>Blob</code></a>, and as such can be manipulated just like any other <code>Blob</code>. For example, you could access the text content directly via <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob/text"><code>Blob.text()</code></a>.</li>
</ol></div></section><section aria-labelledby="writing_a_file"><h3 id="writing_a_file"><a href="#writing_a_file">Writing a file</a></h3></section><section aria-labelledby="deleting_a_file_or_folder"><h3 id="deleting_a_file_or_folder"><a href="#deleting_a_file_or_folder">Deleting a file or folder</a></h3><div><p>You can call <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryHandle/removeEntry"><code>FileSystemDirectoryHandle.removeEntry()</code></a> on the parent directory, passing it the name of the item you want to remove:</p>
<div><pre><code>directoryHandle.removeEntry(&#34;my first nested file&#34;);
</code></pre></div>
<p>You can also call <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemHandle/remove"><code>FileSystemHandle.remove()</code></a> on the <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle"><code>FileSystemFileHandle</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryHandle"><code>FileSystemDirectoryHandle</code></a> representing the item you want to remove. To delete a folder including all subfolders, pass the <code>{ recursive: true }</code> option.</p>
<div><pre><code>await fileHandle.remove();
await directoryHandle.remove({ recursive: true });
</code></pre></div>
<p>The following provides a quick way to clear the entire OPFS:</p>
<div><pre><code>await (await navigator.storage.getDirectory()).remove({ recursive: true });
</code></pre></div></div></section><section aria-labelledby="listing_the_contents_of_a_folder"><h3 id="listing_the_contents_of_a_folder"><a href="#listing_the_contents_of_a_folder">Listing the contents of a folder</a></h3><div><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryHandle"><code>FileSystemDirectoryHandle</code></a> is an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols">asynchronous iterator</a>. As such, you can iterate over it with a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of"><code>for await...of</code></a> loop and standard methods such as <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryHandle/entries"><code>entries()</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryHandle/entries"><code>values()</code></a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryHandle/entries"><code>keys()</code></a>.</p>
<p>For example:</p>
<div><pre><code>for await (let [name, handle] of directoryHandle) {
}
for await (let [name, handle] of directoryHandle.entries()) {
}
for await (let handle of directoryHandle.values()) {
}
for await (let name of directoryHandle.keys()) {
}
</code></pre></div></div></section><section aria-labelledby="manipulating_the_opfs_from_a_web_worker"><h2 id="manipulating_the_opfs_from_a_web_worker"><a href="#manipulating_the_opfs_from_a_web_worker">Manipulating the OPFS from a web worker</a></h2><div><p>Web Workers don&#39;t block the main thread, which means you can use the synchronous file access APIs in this context. Synchronous APIs are faster as they avoid having to deal with promises.</p>
<p>You can synchronously access a file by calling <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle/createSyncAccessHandle"><code>FileSystemFileHandle.createSyncAccessHandle()</code></a> on a regular <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle"><code>FileSystemFileHandle</code></a>:</p>
<p><strong>Note:</strong> Despite having &#34;Sync&#34; in its name, the <code>createSyncAccessHandle()</code> method itself is asynchronous.</p>
<div><pre><code>const opfsRoot = await navigator.storage.getDirectory();
const fileHandle = await opfsRoot.getFileHandle(&#34;my-high-speed-file.txt&#34;, {
  create: true,
});
const syncAccessHandle = await fileHandle.createSyncAccessHandle();
</code></pre></div>
<p>There are a number of <em>synchronous</em> methods available on the returned <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemSyncAccessHandle"><code>FileSystemSyncAccessHandle</code></a>:</p>
<ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemSyncAccessHandle/getSize" title="getSize()"><code>getSize()</code></a>: Returns the size of the file in bytes.</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemSyncAccessHandle/write" title="write()"><code>write()</code></a>: Writes the content of a buffer into the file, optionally at a given offset, and returns the number of written bytes. Checking the returned number of written bytes allows callers to detect and handle errors and partial writes.</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemSyncAccessHandle/read" title="read()"><code>read()</code></a>: Reads the contents of the file into a buffer, optionally at a given offset.</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemSyncAccessHandle/truncate" title="truncate()"><code>truncate()</code></a>: Resizes the file to the given size.</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemSyncAccessHandle/flush" title="flush()"><code>flush()</code></a>: Ensures that the file contents contain all the modifications done through <code>write()</code>.</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemSyncAccessHandle/close" title="close()"><code>close()</code></a>: Closes the access handle.</li>
</ul>
<p>Here is an example that uses all the methods mentioned above:</p>
<div><pre><code>const opfsRoot = await navigator.storage.getDirectory();
const fileHandle = await opfsRoot.getFileHandle(&#34;fast&#34;, { create: true });
const accessHandle = await fileHandle.createSyncAccessHandle();

const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();

// Initialize this variable for the size of the file.
let size;
// The current size of the file, initially `0`.
size = accessHandle.getSize();
// Encode content to write to the file.
const content = textEncoder.encode(&#34;Some text&#34;);
// Write the content at the beginning of the file.
accessHandle.write(content, { at: size });
// Flush the changes.
accessHandle.flush();
// The current size of the file, now `9` (the length of &#34;Some text&#34;).
size = accessHandle.getSize();

// Encode more content to write to the file.
const moreContent = textEncoder.encode(&#34;More content&#34;);
// Write the content at the end of the file.
accessHandle.write(moreContent, { at: size });
// Flush the changes.
accessHandle.flush();
// The current size of the file, now `21` (the length of
// &#34;Some textMore content&#34;).
size = accessHandle.getSize();

// Prepare a data view of the length of the file.
const dataView = new DataView(new ArrayBuffer(size));

// Read the entire file into the data view.
accessHandle.read(dataView, { at: 0 });
// Logs `&#34;Some textMore content&#34;`.
console.log(textDecoder.decode(dataView));

// Read starting at offset 9 into the data view.
accessHandle.read(dataView, { at: 9 });
// Logs `&#34;More content&#34;`.
console.log(textDecoder.decode(dataView));

// Truncate the file after 4 bytes.
accessHandle.truncate(4);
</code></pre></div></div></section><section aria-labelledby="see_also"><h2 id="see_also"><a href="#see_also">See also</a></h2></section></article></div>
  </body>
</html>
