<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.christo.sh/building-agi-on-the-tokio-runtime/">Original</a>
    <h1>My failed attempt at AGI on the Tokio Runtime</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    
        
    

    
        

        <p>
            <i>
                <time datetime="2024-12-25T17:41Z">
                    25 Dec, 2024
                </time>
            </i>
        </p>
    

    <blockquote>
<p>Note: I am not, nor do I claim to be an expert in machine learning or neuroscience. This will become abundantly obvious as you continue reading.</p>
</blockquote>
<p>A few weeks ago I decided to try and build AGI. OpenAI, Deepmind and xAI haven&#39;t delivered yet with the smartest researchers and billions in compute so I had to take matters into my own hands (what could go wrong?).</p>
<p>I bought a couple of books on Artificial Intelligence and Neuroscience and started:</p>

<p>Assume you are racing a Formula 1 car. You are in last place. You are a worse driver in a worse car. If you follow the same strategy as the cars in front of you, pit at the same time and choose the same tires, you will certainly lose. The <em>only</em> chance you have is to pick a different strategy.</p>
<p>The same goes for me. If I go down the transformer / deep learning route I am outgunned. The only hope I have is to try something completely novel (or more precisely <em>think</em> I&#39;m working on something novel only to discover this was done in the 1970s).</p>
<h2 id="concrete-strategy">Concrete Strategy</h2><p>For reasons we&#39;ll cover in the following sections, I decided to go down the fully biologically inspired path. The rough idea was to build a fully asynchronous neural network and run it on a data center.</p>
<h2 id="neurons-and-brains">Neurons and Brains</h2><p>When I started reading neuroscience I got the impression we don&#39;t really understand how the brain works. It&#39;s complicated and complex and the books I read model neuronal firing as partial differential equations. But before that a small primer.</p>
<p>At a high level a neuron consists of 3 main components.</p>
<p><img src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/christos/neuron.webp" alt="neuron"/></p>
<p>The dendrites on the left act as inputs to the neuron from other neurons (we&#39;ll call those &#34;pre-synaptic neurons&#34;). The cell body has a cell wall which acts as a barrier between the internals of the neuron and the goop surrounding it. The axon on the right is connected to dendrites of other downstream neurons (we&#39;ll call those post-synaptic neurons).</p>
<p>When a neuron receives a signal from a pre-synaptic neuron it increases the potential in the neuron&#39;s cell body. If this potential increases past some threshold voltage (relative to the surrounding goop) it triggers a response where the neuron fires a signal down its axon to the post-synaptic neurons and resets its internal voltage. After firing a neuron has a rest period called the &#34;refactory&#34; period during which it does not respond to stimuli. After the refactory period the neuron is ready to fire again.</p>
<p><img src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/christos/firing.webp" alt="firing"/></p>
<p>This is massively simplified. There are different types of neurons, a bunch of chemistry but I&#39;m going to hand-wave those away and call them &#34;implementation details&#34;. In fact I&#39;m going to assume that the continuous nature of the signals fired is an implementation detail due to the substrate i.e. the underlying biological wetware and is not functionally important. There is no reason why signals can&#39;t be binary.</p>
<h3 id="conductance-based-models">Conductance-Based Models</h3><p>I didn&#39;t mention earlier that the cell body leaks potential into the surrounding goop over time. In 1963 Alan Hodgkin and Andrew Huxley received the Nobel Prize in Physiology and Medicine for describing this as a dynamical system described by a series of nonlinear differential equations. They modelled the relationship between the flow of ions across the neuron&#39;s cell membrane and the voltage of the cell. The experimental work for this was done on the squid giant axon because it was large enough for an electrode to be placed inside it.</p>
<p>Again I&#39;m going to hand wave the chemistry away and call it an implementation detail using a simplified &#34;Leaky integrate and fire&#34; model.</p>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mrow><mstyle displaystyle="true" scriptlevel="0"><msub><mi>C</mi><mrow><mrow><mi mathvariant="normal">m</mi></mrow></mrow></msub><mrow><mfrac><mrow><mi>d</mi><msub><mi>V</mi><mrow><mrow><mi mathvariant="normal">m</mi></mrow></mrow></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mrow><mo>=</mo><mi>I</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>−</mo><mrow><mfrac><mrow><msub><mi>V</mi><mrow><mrow><mi mathvariant="normal">m</mi></mrow></mrow></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>R</mi><mrow><mrow><mi mathvariant="normal">m</mi></mrow></mrow></msub></mrow></mfrac></mrow></mstyle></mrow></mrow></math></p>
<p>This is also a differential equation over the capacitance, resistance and current across the neuron membrane and voltage of the cell. But really it boils down to:</p>
<ol>
<li>Pre-synaptic impulses increase membrane potential</li>
<li>Time decreases membrane potential</li>
</ol>
<p>Or in pseudocode:</p>
<div><pre><span></span>let k = ... // some decay constant
let delta = ... // some potential difference constant
loop {
      if signal.next() {
         let now = time::now()
         membrane_potential = membrane_potential * e^-k(now - previous_firing)
         membrane_potential += delta
         if membrane_potental &gt; firing_threshold {
            fire()
            membrane_potential = 0
            previous_firing = now
         }
   }
}
</pre></div>
<p><img src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/christos/firing1.webp" alt="firing2"/></p>
<h3 id="encoding-information-in-neuronal-signals">Encoding Information in Neuronal Signals</h3><p>It looks like the jury is still out on how exactly neurons encode information. Namely is information encoded in neuron <strong>timings</strong>, i.e. <em>when</em> a neuron fires, or neuron firing <strong>rates</strong>, the <em>rate</em> at which a neuron fires. There&#39;s a bunch of statistics and math that&#39;s been developed to talk intelligently about neuronal firing rates, but I&#39;m going to assume that I don&#39;t care because the firing rates are going to be emergent from the underlying neuron timings anyway.</p>
<h2 id="design">Design</h2><p>Meditating on the structure of a neuron described above and modern artificial neural networks like transformers, a few questions jump out at you.</p>
<p>Even if a network of these neurons is not being driven externally, there are certain configurations which allow for signals to propagate in cycles in your neuronal graph. There are configurations which sustain themselves without needing external stimuli to drive it while at the same time not having divergent outputs.</p>
<p>This is far-fetched but it feels like something that might implement consciousness rather than a pure feed-forward system.</p>
<h2 id="implementation">Implementation</h2><p>I decided to implement this network by employing something like an <a href="https://en.wikipedia.org/wiki/Actor_model">Actor Model</a> on the <a href="https://tokio.rs/">Tokio</a> runtime. Tokio is fast asynchronous runtime for Rust and exposes primitives which would make my life easier such as broadcast channels to implement synapses. Also it would be easy to hot-swap it for a non-local version if I want to run my AI across multiple machines.</p>
<h3 id="neurons">Neurons</h3><p>Neurons are implemented pretty much as described above.</p>
<div><pre><span></span><span>pub</span><span> </span><span>struct</span><span> </span><span>Neuron</span><span> </span><span>{</span>
<span>    </span><span>#[allow(unused)]</span>
<span>    </span><span>index</span><span>:</span><span> </span><span>usize</span><span>,</span>
<span>    </span><span>membrane_potential</span><span>:</span><span> </span><span>u32</span><span>,</span>
<span>    </span><span>axon</span><span>:</span><span> </span><span>broadcast</span><span>::</span><span>Sender</span><span>&lt;</span><span>Impulse</span><span>&gt;</span><span>,</span>
<span>    </span><span>dendrites</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>broadcast</span><span>::</span><span>Receiver</span><span>&lt;</span><span>Impulse</span><span>&gt;&gt;</span><span>,</span>
<span>}</span>
</pre></div>
<p>A <code>broadcast::Sender</code> is used to broadcast signals to post-synaptic neurons and signals from the pre-synaptic neurons which are <code>broadcast::Receiver</code> are used to drive the neuron.</p>
<p>An <code>Impulse</code> is just an empty tuple for now - we are assuming that the signal potential isn&#39;t important (or is constant) and information is encoded purely in the timing of firings (and consequently the firing rates).</p>
<p>To run the neuron we combine the dendrite receivers into a single stream and keep popping them implementing the leaky integrate and fire method:</p>
<div><pre><span></span><span>impl</span><span> </span><span>Neuron</span><span> </span><span>{</span>
<span>    </span><span>async</span><span> </span><span>fn</span><span> </span><span>start</span><span>(</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>// Convert each receiver to a stream of messages</span>
<span>        </span><span>let</span><span> </span><span>streams</span><span> </span><span>=</span><span> </span><span>self</span>
<span>            </span><span>.</span><span>dendrites</span>
<span>            </span><span>.</span><span>drain</span><span>(</span><span>..</span><span>)</span>
<span>            </span><span>.</span><span>map</span><span>(</span><span>|</span><span>mut</span><span> </span><span>rx</span><span>|</span><span> </span><span>{</span>
<span>                </span><span>Box</span><span>::</span><span>pin</span><span>(</span><span>async_stream</span><span>::</span><span>stream</span><span>!</span><span> </span><span>{</span>
<span>                        </span><span>loop</span><span> </span><span>{</span>
<span>                            </span><span>match</span><span> </span><span>rx</span><span>.</span><span>recv</span><span>().</span><span>await</span><span> </span><span>{</span>
<span>                                </span><span>Ok</span><span>(</span><span>msg</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>yield</span><span> </span><span>msg</span><span>,</span>
<span>                                </span><span>Err</span><span>(</span><span>broadcast</span><span>::</span><span>error</span><span>::</span><span>RecvError</span><span>::</span><span>Closed</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>break</span><span>,</span>
<span>                                </span><span>Err</span><span>(</span><span>broadcast</span><span>::</span><span>error</span><span>::</span><span>RecvError</span><span>::</span><span>Lagged</span><span>(</span><span>skipped</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>                                    </span><span>// debug!(&#34;Receiver lagged by {} messages&#34;, skipped);</span>
<span>                                    </span><span>continue</span><span>;</span>
<span>                                </span><span>}</span>
<span>                            </span><span>}</span>
<span>                        </span><span>}</span>
<span>                </span><span>})</span>
<span>            </span><span>})</span>
<span>            </span><span>.</span><span>collect</span><span>::</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt;&gt;</span><span>();</span>

<span>        </span><span>// Combine all streams into a single unified stream</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>combined</span><span> </span><span>=</span><span> </span><span>stream</span><span>::</span><span>select_all</span><span>(</span><span>streams</span><span>);</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>last_fire</span><span> </span><span>=</span><span> </span><span>Instant</span><span>::</span><span>now</span><span>();</span>

<span>        </span><span>// Process each message as it arrives from any receiver</span>
<span>        </span><span>while</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>impulse</span><span>)</span><span> </span><span>=</span><span> </span><span>combined</span><span>.</span><span>next</span><span>().</span><span>await</span><span> </span><span>{</span>
<span>            </span><span>let</span><span> </span><span>firings</span><span> </span><span>=</span><span> </span><span>FIRINGS</span><span>.</span><span>fetch_add</span><span>(</span><span>1</span><span>,</span><span> </span><span>Ordering</span><span>::</span><span>Relaxed</span><span>);</span>
<span>            </span><span>// Implement the &#34;Integrate and fire&#34; method.</span>
<span>            </span><span>let</span><span> </span><span>now</span><span> </span><span>=</span><span> </span><span>Instant</span><span>::</span><span>now</span><span>();</span>
<span>            </span><span>if</span><span> </span><span>last_fire</span><span> </span><span>+</span><span> </span><span>ABSOLUTE_REFACTORY_PERIOD</span><span> </span><span>&gt;</span><span> </span><span>now</span><span> </span><span>{</span>
<span>                </span><span>self</span><span>.</span><span>membrane_potential</span><span> </span><span>=</span><span> </span><span>self</span><span>.</span><span>membrane_potential</span><span> </span><span>+</span><span> </span><span>1</span><span>;</span>
<span>                </span><span>if</span><span> </span><span>self</span><span>.</span><span>membrane_potential</span><span> </span><span>&gt;</span><span> </span><span>FIRING_THRESHOLD</span><span> </span><span>{</span>
<span>                    </span><span>self</span><span>.</span><span>emit</span><span>(</span><span>Impulse</span><span>);</span>
<span>                    </span><span>self</span><span>.</span><span>membrane_potential</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>                    </span><span>last_fire</span><span> </span><span>=</span><span> </span><span>now</span><span>;</span>
<span>                </span><span>}</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>fn</span><span> </span><span>emit</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>impulse</span><span>:</span><span> </span><span>Impulse</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>if</span><span> </span><span>let</span><span> </span><span>Err</span><span>(</span><span>e</span><span>)</span><span> </span><span>=</span><span> </span><span>self</span><span>.</span><span>axon</span><span>.</span><span>send</span><span>(</span><span>impulse</span><span>)</span><span> </span><span>{</span>
<span>            </span><span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span><span> </span><span>FIRINGS</span><span>.</span><span>fetch_add</span><span>(</span><span>0</span><span>,</span><span> </span><span>Ordering</span><span>::</span><span>Relaxed</span><span>));</span>
<span>            </span><span>panic!</span><span>()</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</pre></div>
<h3 id="brains">Brains</h3><p>Brains are modelled as a bag of neurons with a set of inputs and outputs.</p>
<div><pre><span></span><span>pub</span><span> </span><span>struct</span><span> </span><span>Brain</span><span> </span><span>{</span>
<span>    </span><span>neurons</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>Neuron</span><span>&gt;</span><span>,</span>
<span>    </span><span>inputs</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>broadcast</span><span>::</span><span>Sender</span><span>&lt;</span><span>Impulse</span><span>&gt;&gt;</span><span>,</span>
<span>    </span><span>outputs</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>broadcast</span><span>::</span><span>Receiver</span><span>&lt;</span><span>Impulse</span><span>&gt;&gt;</span><span>,</span>
<span>}</span>
</pre></div>
<p>The synapses for the neurons are already constructed beforehand as a brain is built from DNA.</p>
<div><pre><span></span><span>impl</span><span> </span><span>From</span><span>&lt;&amp;</span><span>Dna</span><span>&gt;</span><span> </span><span>for</span><span> </span><span>Brain</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>from</span><span>(</span><span>dna</span><span>:</span><span> </span><span>&amp;</span><span>Dna</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Self</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>neurons</span><span> </span><span>=</span><span> </span><span>Vec</span><span>::</span><span>new</span><span>();</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>broadcasts</span><span> </span><span>=</span><span> </span><span>Vec</span><span>::</span><span>new</span><span>();</span>

<span>        </span><span>// Step 1: Initialize neurons and broadcast channels</span>
<span>        </span><span>for</span><span> </span><span>index</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>Dna</span><span>::</span><span>num_neurons</span><span>()</span><span> </span><span>{</span>
<span>            </span><span>let</span><span> </span><span>(</span><span>tx</span><span>,</span><span> </span><span>rx</span><span>)</span><span> </span><span>=</span><span> </span><span>broadcast</span><span>::</span><span>channel</span><span>(</span><span>CHANNEL_CAPACITY</span><span>);</span>
<span>            </span><span>neurons</span><span>.</span><span>push</span><span>(</span><span>Neuron</span><span> </span><span>{</span>
<span>                </span><span>membrane_potential</span><span>:</span><span> </span><span>0</span><span>,</span>
<span>                </span><span>axon</span><span>:</span><span> </span><span>tx</span><span>.</span><span>clone</span><span>(),</span>
<span>                </span><span>dendrites</span><span>:</span><span> </span><span>Vec</span><span>::</span><span>new</span><span>(),</span>
<span>            </span><span>});</span>
<span>            </span><span>broadcasts</span><span>.</span><span>push</span><span>((</span><span>tx</span><span>,</span><span> </span><span>rx</span><span>));</span>
<span>        </span><span>}</span>
<span>        </span><span>let</span><span> </span><span>connectivity</span><span> </span><span>=</span><span> </span><span>dna</span><span>.</span><span>connectivity</span><span>();</span>

<span>        </span><span>for</span><span> </span><span>(</span><span>src</span><span>,</span><span> </span><span>row</span><span>)</span><span> </span><span>in</span><span> </span><span>connectivity</span><span>.</span><span>iter</span><span>().</span><span>enumerate</span><span>()</span><span> </span><span>{</span>
<span>            </span><span>for</span><span> </span><span>(</span><span>dest</span><span>,</span><span> </span><span>&amp;</span><span>value</span><span>)</span><span> </span><span>in</span><span> </span><span>row</span><span>.</span><span>iter</span><span>().</span><span>enumerate</span><span>()</span><span> </span><span>{</span>
<span>                </span><span>if</span><span> </span><span>src</span><span> </span><span>==</span><span> </span><span>dest</span><span> </span><span>{</span>
<span>                    </span><span>// do not allow neurons to wire back to themselves</span>
<span>                    </span><span>continue</span><span>;</span>
<span>                </span><span>}</span>
<span>                </span><span>if</span><span> </span><span>value</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>{</span>
<span>                    </span><span>let</span><span> </span><span>receiver</span><span> </span><span>=</span><span> </span><span>broadcasts</span><span>[</span><span>src</span><span>].</span><span>0.</span><span>subscribe</span><span>();</span>
<span>                    </span><span>neurons</span><span>[</span><span>dest</span><span>].</span><span>dendrites</span><span>.</span><span>push</span><span>(</span><span>receiver</span><span>);</span>
<span>                </span><span>}</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>

<span>        </span><span>let</span><span> </span><span>inputs</span><span> </span><span>=</span><span> </span><span>dna</span>
<span>            </span><span>.</span><span>inputs</span><span>()</span>
<span>            </span><span>.</span><span>iter</span><span>()</span>
<span>            </span><span>.</span><span>map</span><span>(</span><span>|</span><span>input_id</span><span>|</span><span> </span><span>broadcasts</span><span>[</span><span>*</span><span>input_id</span><span>].</span><span>0.</span><span>clone</span><span>())</span>
<span>            </span><span>.</span><span>collect</span><span>::</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt;&gt;</span><span>();</span>

<span>        </span><span>let</span><span> </span><span>outputs</span><span> </span><span>=</span><span> </span><span>dna</span>
<span>            </span><span>.</span><span>outputs</span><span>()</span>
<span>            </span><span>.</span><span>iter</span><span>()</span>
<span>            </span><span>.</span><span>map</span><span>(</span><span>|</span><span>output_id</span><span>|</span><span> </span><span>broadcasts</span><span>[</span><span>*</span><span>output_id</span><span>].</span><span>0.</span><span>subscribe</span><span>())</span>
<span>            </span><span>.</span><span>collect</span><span>::</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt;&gt;</span><span>();</span>

<span>        </span><span>Brain</span><span> </span><span>{</span>
<span>            </span><span>neurons</span><span>,</span>
<span>            </span><span>inputs</span><span>,</span>
<span>            </span><span>outputs</span><span>,</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</pre></div>
<h3 id="dna">DNA</h3><p>The average brain of a human being has 85 billion neurons and over 100 trillion synaptic connections. If every neuron is connected to every other neuron you get <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>/</mo><mn>2</mn></mrow></math> synapses. Even in a sparsely connected brain you still get an unfeasibly large number of synapses for my 64 Gb RAM (neurons are thought to have 1,000-100,000 connections typically, depending to the type of neuron, its location etc.)</p>
<p>The sheer number of neurons and synapses mean that they are not deterministically encoded in your DNA. Instead your DNA defines rules for protein synthesis which generate these neurons and synapses.</p>
<p>This seems hard. I&#39;m going to go down the road of the <em>C. Elegans.</em> nematode with exactly 302. I&#39;m not sure I understand if its synapses are hard wired but mine will be.</p>
<div><pre><span></span><span>pub</span><span> </span><span>struct</span><span> </span><span>Dna</span><span>&lt;</span><span>const</span><span> </span><span>NUM_NEURONS</span><span>:</span><span> </span><span>usize</span><span>,</span><span> </span><span>const</span><span> </span><span>NUM_INPUT</span><span>:</span><span> </span><span>usize</span><span>,</span><span> </span><span>const</span><span> </span><span>NUM_OUTPUT</span><span>:</span><span> </span><span>usize</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>potential_decay_ns</span><span>:</span><span> </span><span>f64</span><span>,</span>
<span>    </span><span>threshold</span><span>:</span><span> </span><span>u16</span><span>,</span>
<span>    </span><span>initiation_delay_ns</span><span>:</span><span> </span><span>u64</span><span>,</span>
<span>    </span><span>connectivity</span><span>:</span><span> </span><span>Box</span><span>&lt;</span><span>[[</span><span>u8</span><span>;</span><span> </span><span>NUM_NEURONS</span><span>];</span><span> </span><span>NUM_NEURONS</span><span>]</span><span>&gt;</span><span>,</span>
<span>    </span><span>// point to the input neurons of the connectivity matrix.</span>
<span>    </span><span>input_neurons</span><span>:</span><span> </span><span>[</span><span>usize</span><span>;</span><span> </span><span>NUM_INPUT</span><span>],</span>
<span>    </span><span>// point to the output neurons of the connectivity matrix.</span>
<span>    </span><span>output_neurons</span><span>:</span><span> </span><span>[</span><span>usize</span><span>;</span><span> </span><span>NUM_OUTPUT</span><span>],</span>
<span>}</span>
</pre></div>
<p>We define a hard-coded connectivity matrix in our brain&#39;s DNA. The inputs and outputs point to specific neurons in the brain irrespective of positioning.</p>
<h3 id="games">Games</h3><p>Our brain is going to try to get better at playing a simple game I created for it. The game is basically snake. Your score increases every time you eat food. You can only go up, down, left and right. A higher score is better.</p>
<div><pre><span></span><span>#[derive(Clone, Copy, PartialEq, Debug)]</span>
<span>pub</span><span> </span><span>enum</span><span> </span><span>Direction</span><span> </span><span>{</span>
<span>    </span><span>Up</span><span>,</span>
<span>    </span><span>Down</span><span>,</span>
<span>    </span><span>Left</span><span>,</span>
<span>    </span><span>Right</span><span>,</span>
<span>}</span>

<span>#[derive(Clone, PartialEq)]</span>
<span>pub</span><span> </span><span>struct</span><span> </span><span>Position</span><span> </span><span>{</span>
<span>    </span><span>x</span><span>:</span><span> </span><span>i32</span><span>,</span>
<span>    </span><span>y</span><span>:</span><span> </span><span>i32</span><span>,</span>
<span>}</span>

<span>pub</span><span> </span><span>struct</span><span> </span><span>Game</span><span> </span><span>{</span>
<span>    </span><span>pub</span><span> </span><span>width</span><span>:</span><span> </span><span>usize</span><span>,</span>
<span>    </span><span>pub</span><span> </span><span>height</span><span>:</span><span> </span><span>usize</span><span>,</span>
<span>    </span><span>pub</span><span> </span><span>snake</span><span>:</span><span> </span><span>Position</span><span>,</span>
<span>    </span><span>pub</span><span> </span><span>direction</span><span>:</span><span> </span><span>Direction</span><span>,</span>
<span>    </span><span>pub</span><span> </span><span>food</span><span>:</span><span> </span><span>Position</span><span>,</span>
<span>    </span><span>pub</span><span>(</span><span>crate</span><span>)</span><span> </span><span>score</span><span>:</span><span> </span><span>usize</span><span>,</span>
<span>    </span><span>pub</span><span> </span><span>game_over</span><span>:</span><span> </span><span>bool</span><span>,</span>
<span>}</span>
</pre></div>
<h3 id="organism">Organism</h3><p>In order for our brain to play this game, it needs to be wrapped up in an organism. The organism is responsible for driving the inputs of the brain by reading the game state and playing the game using the brain&#39;s outputs.</p>
<p>The brain is constantly driven by the organism being fed the game&#39;s state even if it hasn&#39;t changed (much like you keep seeing an image in front of you even if it hasn&#39;t changed).</p>
<div><pre><span></span><span>pub</span><span> </span><span>struct</span><span> </span><span>Organism</span><span> </span><span>{</span>
<span>    </span><span>pub</span><span>(</span><span>crate</span><span>)</span><span> </span><span>dna</span><span>:</span><span> </span><span>Dna</span><span>,</span>
<span>    </span><span>inputs</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>broadcast</span><span>::</span><span>Sender</span><span>&lt;</span><span>Impulse</span><span>&gt;&gt;</span><span>,</span>
<span>    </span><span>outputs</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>broadcast</span><span>::</span><span>Receiver</span><span>&lt;</span><span>Impulse</span><span>&gt;&gt;</span><span>,</span>
<span>}</span>

<span>impl</span><span> </span><span>Organism</span><span> </span><span>{</span>
<span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>new</span><span>(</span><span>dna</span><span>:</span><span> </span><span>Dna</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Organism</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>brain</span><span> </span><span>=</span><span> </span><span>Brain</span><span>::</span><span>from</span><span>(</span><span>&amp;</span><span>dna</span><span>);</span>
<span>        </span><span>let</span><span> </span><span>(</span><span>inputs</span><span>,</span><span> </span><span>outputs</span><span>)</span><span> </span><span>=</span><span> </span><span>brain</span><span>.</span><span>start</span><span>();</span>
<span>        </span><span>Self</span><span> </span><span>{</span>
<span>            </span><span>dna</span><span>,</span>
<span>            </span><span>inputs</span><span>,</span>
<span>            </span><span>outputs</span><span>,</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>// Given a 2D representation of the world state</span>
<span>    </span><span>// stimulates the appropriate input neurons.</span>
<span>    </span><span>pub</span><span>(</span><span>crate</span><span>)</span><span> </span><span>fn</span><span> </span><span>drive_input</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>state</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;&gt;</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>for</span><span> </span><span>(</span><span>i</span><span>,</span><span> </span><span>row</span><span>)</span><span> </span><span>in</span><span> </span><span>state</span><span>.</span><span>iter</span><span>().</span><span>enumerate</span><span>()</span><span> </span><span>{</span>
<span>            </span><span>for</span><span> </span><span>(</span><span>j</span><span>,</span><span> </span><span>val</span><span>)</span><span> </span><span>in</span><span> </span><span>row</span><span>.</span><span>iter</span><span>().</span><span>enumerate</span><span>()</span><span> </span><span>{</span>
<span>                </span><span>match</span><span> </span><span>val</span><span> </span><span>{</span>
<span>                    </span><span>0</span><span> </span><span>=&gt;</span><span> </span><span>continue</span><span>,</span>
<span>                    </span><span>_</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>                        </span><span>let</span><span> </span><span>index</span><span> </span><span>=</span><span> </span><span>i</span><span> </span><span>*</span><span> </span><span>row</span><span>.</span><span>len</span><span>()</span><span> </span><span>+</span><span> </span><span>j</span><span>;</span>
<span>                        </span><span>self</span><span>.</span><span>inputs</span>
<span>                            </span><span>.</span><span>get</span><span>(</span><span>index</span><span>)</span>
<span>                            </span><span>.</span><span>unwrap</span><span>()</span>
<span>                            </span><span>.</span><span>send</span><span>(</span><span>Impulse</span><span>)</span>
<span>                            </span><span>.</span><span>expect</span><span>(</span><span>&amp;</span><span>format!</span><span>(</span><span>&#34;Failed at index {}&#34;</span><span>,</span><span> </span><span>index</span><span>));</span>
<span>                    </span><span>}</span>
<span>                </span><span>}</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>..</span><span>.</span>
</pre></div>
<h3 id="training">Training</h3><p>Ok how the hell do we train this thing? Stochastic gradient descent with back-propagation won&#39;t work here (or if it does I have no idea how to implement it).</p>
<p>Instead I resorted to using genetic algorithms. Genetic algorithms are a class of optimisation algorithms inspired by nature using a combination of genetic darwinian selection based on individual fitness along with a small probability of genetic mutation to help explore the domain&#39;s search space and escape from local minima.</p>
<p>To do this for our Tokio brains requires a few steps:</p>
<ol>
<li>Initialise a population of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>N</mi></mrow></math> DNA with random connectivity matrices</li>
<li>Create brains from the DNA and put those brains in organisms and let them play our game.</li>
<li>The <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msqrt><mrow><mi>N</mi></mrow></msqrt></mrow></math> individuals with the highest scores are bred with each other resulting in a new population.</li>
<li>Breeding works by splitting the connectivity matrix into sections and randomly picking sections from each parent (along with any other relevant genes)</li>
<li>Repeat</li>
<li>Profit</li>
</ol>
<div><pre><span></span><span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>train</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>info</span><span>!</span><span>(</span><span>&#34;Starting training.&#34;</span><span>);</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>population</span><span> </span><span>=</span><span> </span><span>self</span><span>.</span><span>initialize_population</span><span>();</span>
<span>        </span><span>while</span><span> </span><span>self</span><span>.</span><span>epoch</span><span> </span><span>&lt;</span><span> </span><span>self</span><span>.</span><span>max_epoch</span><span> </span><span>{</span>
<span>            </span><span>let</span><span> </span><span>runtime</span><span> </span><span>=</span><span> </span><span>tokio</span><span>::</span><span>runtime</span><span>::</span><span>Runtime</span><span>::</span><span>new</span><span>().</span><span>unwrap</span><span>();</span>
<span>            </span><span>runtime</span><span>.</span><span>block_on</span><span>(</span><span>async</span><span> </span><span>{</span>
<span>                </span><span>info</span><span>!</span><span>(</span><span>&#34;Starting epoch: {}&#34;</span><span>,</span><span> </span><span>self</span><span>.</span><span>epoch</span><span>);</span>
<span>                </span><span>let</span><span> </span><span>mut</span><span> </span><span>handles</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[];</span>
<span>                </span><span>for</span><span> </span><span>(</span><span>id</span><span>,</span><span> </span><span>dna</span><span>)</span><span> </span><span>in</span><span> </span><span>population</span><span>.</span><span>iter</span><span>().</span><span>enumerate</span><span>()</span><span> </span><span>{</span>
<span>                    </span><span>let</span><span> </span><span>dna</span><span> </span><span>=</span><span> </span><span>dna</span><span>.</span><span>clone</span><span>();</span>
<span>                    </span><span>let</span><span> </span><span>handle</span><span> </span><span>=</span><span> </span><span>tokio</span><span>::</span><span>spawn</span><span>(</span><span>async</span><span> </span><span>move</span><span> </span><span>{</span><span> </span><span>Simulation</span><span>::</span><span>simulate</span><span>(</span><span>id</span><span>,</span><span> </span><span>dna</span><span>).</span><span>await</span><span> </span><span>});</span>
<span>                    </span><span>handles</span><span>.</span><span>push</span><span>(</span><span>handle</span><span>);</span>
<span>                </span><span>}</span>
<span>                </span><span>let</span><span> </span><span>population_with_scores</span><span> </span><span>=</span><span> </span><span>join_all</span><span>(</span><span>handles</span><span>)</span>
<span>                    </span><span>.</span><span>await</span>
<span>                    </span><span>.</span><span>into_iter</span><span>()</span>
<span>                    </span><span>.</span><span>filter_map</span><span>(</span><span>|</span><span>handle</span><span>|</span><span> </span><span>match</span><span> </span><span>handle</span><span> </span><span>{</span>
<span>                        </span><span>Ok</span><span>(</span><span>dna_and_score</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>Some</span><span>(</span><span>dna_and_score</span><span>),</span>
<span>                        </span><span>Err</span><span>(</span><span>e</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>                            </span><span>error</span><span>!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span><span> </span><span>e</span><span>);</span>
<span>                            </span><span>None</span>
<span>                        </span><span>}</span>
<span>                    </span><span>})</span>
<span>                    </span><span>.</span><span>collect</span><span>::</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt;&gt;</span><span>();</span>
<span>                </span><span>let</span><span> </span><span>top_score</span><span> </span><span>=</span><span> </span><span>population_with_scores</span>
<span>                    </span><span>.</span><span>iter</span><span>()</span>
<span>                    </span><span>.</span><span>map</span><span>(</span><span>|</span><span>pop_with_score</span><span>|</span><span> </span><span>pop_with_score</span><span>.</span><span>1</span><span>)</span>
<span>                    </span><span>.</span><span>max</span><span>();</span>
<span>                </span><span>info</span><span>!</span><span>(</span><span>&#34;Epoch: {}, Top Score: {:?}&#34;</span><span>,</span><span> </span><span>self</span><span>.</span><span>epoch</span><span>,</span><span> </span><span>top_score</span><span>);</span>
<span>                </span><span>population</span><span> </span><span>=</span><span> </span><span>self</span><span>.</span><span>reproduce_top_performers</span><span>(</span><span>population_with_scores</span><span>);</span>
<span>                </span><span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span><span> </span><span>population</span><span>.</span><span>get</span><span>(</span><span>0</span><span>).</span><span>unwrap</span><span>());</span>
<span>                </span><span>self</span><span>.</span><span>epoch</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span>
<span>            </span><span>});</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
</pre></div>
<h2 id="results">Results</h2><p>Nothing. Nada. I couldn&#39;t get this to work at all past a score of 3 which would disappear in the next epoch!</p>
<p>For reference, a human easily gets arbitrarily high scores. My brains have 512 neurons with up to ~13,000 synapses. I&#39;m not sure if this is due to the lack of Neurons but I doubt it.</p>
<p>If I had to guess I would say the culprits are:</p>
<ol>
<li>A huge number of impulses being generated means that tokio struggled to process them all in a timely manner and these neurons <em>are</em> timing sensitive.</li>
<li>Trying to do optimisation over a connectivity matrix by breaking it down into small chunks probably doesn&#39;t work.</li>
</ol>
<p>Mother nature has defeated me once more. I&#39;m going to put this project on ice for now. I&#39;m going to continue reading neuroscience and pick it back up if / when inspiration strikes.</p>
<hr/>



    

    
        

        
            


        
    


  </div></div>
  </body>
</html>
