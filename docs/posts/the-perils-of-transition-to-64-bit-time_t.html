<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blogs.gentoo.org/mgorny/2024/09/28/the-perils-of-transition-to-64-bit-time_t/">Original</a>
    <h1>The perils of transition to 64-bit time_t</h1>
    
    <div id="readability-page-1" class="page"><article id="post-2218">
	<!-- .entry-header -->

	
	
	<div>
		<p>In the <a href="https://blogs.gentoo.org/mgorny/2024/09/23/overview-of-cross-architecture-portability-problems/">Overview of cross-architecture portability problems</a>, I have dedicated a section to the problems resulting from use of 32-bit <kbd>time_t</kbd> type.  This design decision, still affecting Gentoo systems using glibc, means that 32-bit applications will suddenly start failing in horrible ways in 2038: they will be getting <kbd>-1</kbd> error instead of the current time, they won’t be able to <kbd>stat()</kbd> files.  In one word: complete mayhem will emerge.</p>
<p>There is a general agreement that the way forward is to change <kbd>time_t</kbd> to a 64-bit type.  Musl has already switched to that, glibc supports it as an option.  A number of other distributions such as Debian have taken the leap and switched.  Unfortunately, source-based distributions such as Gentoo don’t have it that easy.  So we are still debating the issue and experimenting, trying to figure out a maximally safe upgrade path for our users.</p>
<p>Unfortunately, that’s nowhere near trivial.  Above all, we are talking about a breaking ABI change.  It’s all-or-nothing.  If a library uses <kbd>time_t</kbd> in its API, everything linking to it needs to use the same type width.  In this post, I’d like to explore the issue in detail — why is it so bad, and what we can do to make it safer.</p>
<h2>Going back to Large File Support</h2>
<p>Before we get into the time64 change, as I’m going to shortly call it, we need to go back in history a bit and consider another similar problem: Large File Support.</p>
<p>Long story short, originally 32-bit architectures specify two important file-related types that were 32 bits wide: <kbd>off_t</kbd> used to specify file offsets (signed to support relative offsets) and <kbd>ino_t</kbd> used to specify inode numbers.  This had two implications: you couldn’t open files larger than 2 GiB, and you couldn’t open files whose inode numbers exceeded 32-bit unsigned integer range.</p>
<p>To resolve this problem, Large File Support was introduced.  It involved replacing these two types with 64-bit variants, and on glibc it is still optional today.  In its case, we didn’t take the leap and transitioned globally.  Instead, packages generally started enabling LFS support upstream — also taking care to resolve any ABI breakage in the process.  While many packages did that, we shouldn’t consider the problem solved.</p>
<p>The important point here is that time64 support in glibc requires LFS to be used.  This makes sense — if we are going to break stuff, we may as well solve both problems.</p>
<h2>What ABIs are we talking about?</h2>
<p>To put it simply, we have three possible sub-ABIs here:</p>
<ol>
<li>the original ABI with 32-bit types,</li>
<li>LFS: 64-bit <kbd>off_t</kbd> and <kbd>ino_t</kbd>, 32-bit <kbd>time_t</kbd>,</li>
<li>time64: LFS + 64-bit <kbd>time_t</kbd>.</li>
</ol>
<p>What’s important here is that a single glibc build remains compatible with all three variants.  However, libraries that use these types in their API are not.</p>
<p>Today, 32-bit systems roughly use a mix of the first and second ABI — the latter including packages that enabled LFS explicitly.  For the future, our goal is to focus on the third option.  We are not concerned about providing full-LFS systems with 32-bit <kbd>time_t</kbd>.</p>
<h2>Why the ABI change is so bad?</h2>
<p>Now, the big deal is that we are replacing a 32-bit type with a 64-bit type, in place.  Unlike with LFS, glibc does not provide any transitional API that could be used to enable new functions while preserving backwards compatibility — it’s all-or-nothing.</p>
<p>Let’s consider structures.  If a structure contains <kbd>time_t</kbd> with its natural 32-bit alignment, then there’s no padding for the type to extend to.  Inevitable, all fields will have to shift to make room for the new type.  Let’s consider a trivial example:</p>
<pre>struct {
    int a;
    time_t b;
    int c;
};</pre>
<p>With 32-bit <kbd>time_t</kbd>, the offset of <kbd>c</kbd> is 8.  With the 64-bit type, it’s 16.  If you mix binaries using different <kbd>time_t</kbd> width, they’re inevitably are going to read or write the wrong fields!  Or perhaps even read or write out of bounds!</p>
<p>Let’s just look at the size of <kbd>struct stat</kbd>, as an example of structure that uses both file and time-related types.  On plain 32-bit x86 glibc it’s 88 byte long.  With LFS, it’s 96 byte long (size and inode number fields are expanded).  With LFS + time64, it’s 108 byte long (three timestamps are expanded).</p>
<p>However, you don’t even need to use structures.  After all, we are talking about x86 where function parameters are passed on stack.  If one of the parameters is <kbd>time_t</kbd>, then positions of all parameters on stack change, and we find ourselves seeing the exact same problem!  Consider the following prototype:</p>
<pre>extern void foo(int a, time_t b, int c);</pre>
<p>Let’s say we’re calling it as <kbd>foo(1, 2, 3)</kbd>.  With 32-bit types, the call looks like the following:</p>
<pre>	pushl	$3
	pushl	$2
	pushl	$1
	call	foo@PLT</pre>
<p>However, with 64-bit <kbd>time_t</kbd>, it changes to:</p>
<pre>	pushl	$3
	pushl	$0
	pushl	$2
	pushl	$1
	call	foo@PLT</pre>
<p>An additional 32-bit value (zero) is pushed between the “old” <kbd>b</kbd> and <kbd>c</kbd>.  Once again, if we mix both kinds of binaries, they are going to fail to read the parameters correctly!</p>
<p>So yeah, it’s a big deal.  And right now, there are no real protections in place to prevent mixing these ABIs.  So what you actually may get is runtime breakage, potentially going as far as to create security issues.</p>
<p>You don’t have to take my word for it.  You can reproduce it yourself on x86/amd64 easily enough.  Let’s take the more likely case of a time32 program linked against a library that has been rebuilt for time64:</p>
<pre>$ cat &gt;libfoo.c &lt;&lt;EOF
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

void foo(int a, time_t b, int *c) {
   printf(&#34;a = %d\n&#34;, a);
   printf(&#34;b = %lld&#34;, (long long) b);
   printf(&#34;%s&#34;, ctime(&amp;b));
   printf(&#34;c = %d\n&#34;, *c);
}
EOF
$ cat &gt;foo.c &lt;&lt;EOF
#include &lt;stddef.h&gt;
#include &lt;time.h&gt;

extern void foo(int a, time_t b, int *c);

int main() {
    int three = 3;
    foo(1, time(NULL), &amp;three);
    return 0;
}
EOF
$ cc -m32 libfoo.c -shared -o libfoo.so
$ cc -m32 foo.c -o foo -Wl,-rpath,. libfoo.so
$ ./foo
a = 1
b = 1727154919
Tue Sep 24 07:15:19 2024
c = 3
$ cc -m32 -D_FILE_OFFSET_BITS=64 -D_TIME_BITS=64 \
  libfoo.c -shared -o libfoo.so
$ ./foo 
a = 1
b = -34556652301432063
Thu Jul 20 06:16:17 -1095054749
c = 771539841</pre>
<p>On top of that, the source-first nature of Gentoo amplifies these problems.  An average binary distribution rebuilds all binary packages — and then the user upgrades the system in a single, relatively atomic step.  Sure, if someone uses third-party repositories or has locally built programs that link to system libraries, problems can emerge but the process is relatively safe.</p>
<p>On the other hand, in Gentoo we are talking about rebuilding <kbd>@world</kbd> while breaking ABI in place.  For a start, we are talking around prolonged periods of time between two packages being rebuilt when they would actually be mixing incompatible ABI.  Then, there is a fair risk that some rebuild will fail and leave your system half-transitioned with no easy way out.  Then, there is a real risk that cyclic dependencies will actually make rebuild impossible — rebuilding a dependency will break build-time tools, preventing stuff from being rebuilt.  It’s a true horror.</p>
<h2>What can we do to make it safer?</h2>
<p>Our deliberations currently revolve about three ideas, that are semi-related, though not inevitably dependent one upon another:</p>
<ol>
<li>Changing the platform tuple (<kbd>CHOST</kbd>) for the new ABIs, to clearly distinguish them from the baseline 32-bit ABI.</li>
<li>Changing the libdir for the new ABIs, effectively permitting the rebuilt libraries to be installed independently of the original versions.</li>
<li>Introducing an binary-level ABI distinction that could prevent binaries using different sub-ABI to be linked to one another.</li>
</ol>
<p>The subsequent sections will focus on each of these changes in detail.  Note that all the values used there are just examples, and not necessarily the strings used in a final solution.</p>
<h2>The platform tuple change</h2>
<p>The platform tuple (generally referenced through the <kbd>CHOST</kbd> variable) identifies the platform targeted by the toolchain.  For example, it is used as a part of GCC/binutils install paths, effectively allowing toolchains for multiple targets to be installed simultaneously.  In clang, it can be used to switch between supported cross-compilation targets, and can control the defaults to match the specified ABI.  In Gentoo, it is also used to uniquely identify ABIs for the purpose of multilib support.  Because of that, we require that no two co-installable ABIs share the same tuple.</p>
<p>A tuple consists of four parts, separated by hyphens: architecture, vendor, operating system and libc.  Of these, vendor is generally freeform but the other three are restricted to some degree.  A few semi-equivalent examples of tuples used for 32-bit x86 platform include:</p>
<pre>i386-pc-linux-gnu
i686-pc-linux-gnu
i686-unknown-linux-gnu</pre>
<p>Historically, two approaches were used to introduce new ABIs.  Either the vendor field was changed, or an additional ABI specification was appended to the libc field.  For example, Gentoo historically used two different kind of tuples for ARM ABIs with hardware floating-point unit:</p>
<pre>armv7a-hardfloat-linux-gnueabi
armv7a-unknown-linux-gnueabihf</pre>
<p>The former approach was used earlier, to avoid incompatibility problems resulting from altering other tuple fields.  However, as these were fixed and upstreams normalized on the latter solution, Gentoo followed suit.</p>
<p>Similarly, the discussion of time64 ABIs resurfaced the same dilemma: should we just “abuse” the vendor field for this, or instead change libc field and fix packages?  The main difference is that the former is “cleaner” as a downstream solution limited to Gentoo, while the latter generally opens up discussions about interoperability.  Therefore, the options look like:</p>
<pre>i686-gentoo_t64-linux-gnu
i686-pc-linux-gnut64
armv7a-gentoo_t64-linux-gnueabihf
armv7a-unknown-linux-gnueabihft64</pre>
<p>Fortunately, changing the tuple should not require much patching.  The GNU toolchain and GNU build system both ignore everything following “gnu” in the libc field.  Clang will require patching — but upstream is likely to accept our patches, and we will want to make patches anyway, as they will permit clang to automatically choose the right ABI based on the tuple.</p>
<h2>The libdir change</h2>
<p>The term “libdir” refers to the base name of the library install directory.  Having different libdirs, and therefore separate library install directories, makes it possible to build multilib systems, i.e. installing multiple ABI variations of libraries on a single system, and making it possible to run executables for different ABIs.  For example, this is what makes it possible to run 32-bit x86 executables on amd64 systems.</p>
<p>The libdir values are generally specified in the ABI.  Naturally, the baseline value is plain <kbd>lib</kbd>.  As a historical convention (since 32-bit architectures were first), usually 32-bit platforms (arm, ppc, x86) use <kbd>lib</kbd>, whereas their more modern 64-bit counterparts (amd64, arm64, ppc64) use <kbd>lib64</kbd> — even if a particular architecture never really supported multilib on Gentoo.</p>
<p>Architectures that support multiple ABIs also define different libdirs.  For example, the additional x32 ABI on x86 uses <kbd>libx32</kbd>.  MIPS n32 ABI uses <kbd>lib32</kbd> (with plain <kbd>lib</kbd> defining the o32 ABI).</p>
<p>Now, we are considering changing the libdir value for time64 variants of 32-bit ABIs, for example from <kbd>lib</kbd> to <kbd>libt64</kbd>.  This would make it possible to install the rebuilt libraries separately from the old libraries, effectively bringing three advantages:</p>
<ol>
<li>reducing the risk of time64 executables accidentally linking to time32 libraries,</li>
<li>enabling Portage’s <kbd>preserved-libs</kbd> feature to preserve time32 libraries once the respective packages have been rebuilt for time64, and before their reverse dependencies have been rebuilt,</li>
<li>optionally, making it possible to use a time32 + time64 multilib profiles, that could be used to preserve compatibility with prebuilt time32 applications linking to system libraries.</li>
</ol>
<p>In my opinion, the second point is a killer feature.  As I’ve mentioned before, we are talking about the kind of migration that would break executables for a prolonged time on production systems, and possibly break build-time tools, preventing the rebuild from proceeding further.  By preserving original libraries, we are minimizing the risk of actual breakage, since the existing executables will keep using the time32 libraries until they are rebuilt and linked to the time64 libraries.</p>
<p>The libdir change is definitely going to require some toolchain patching.  We may want to also consider special-casing glibc, as the same set of glibc libraries is valid for all of the sub-ABIs we were considering.  However, we will probably want a separate <kbd>ld.so</kbd> executable, as it would need to load libraries from the correct libdir, and then we will want to set <kbd>.interp</kbd> in time64 executables to reference the time64 <kbd>ld.so</kbd>.</p>
<p>Note that due to how multilib is designed in Gentoo, a proper multilib support for this (i.e. the third point) requires a unique platform tuple for the ABI as well — so that specific aspect is dependent on the tuple change.</p>
<h2>Ensuring binary incompatibility</h2>
<p>In general, you can’t mix binaries using different ABIs.  For example, if you try to link a 64-bit program to a 32-bit library, the linker will object:</p>
<pre>$ cc foo.c libfoo.so 
/usr/lib/gcc/x86_64-pc-linux-gnu/14/../../../../x86_64-pc-linux-gnu/bin/ld: libfoo.so: error adding symbols: file in wrong format
collect2: error: ld returned 1 exit status</pre>
<p>Similarly, the dynamic loader will refuse to use a 32-bit library with 64-bit program:</p>
<pre>$ ./foo 
./foo: error while loading shared libraries: libfoo.so: wrong ELF class: ELFCLASS32</pre>
<p>There are a few mechanisms that are used for this.  As demonstrated above, architectures with 32-bit and 64-bit ABIs use two distinct ELF classes (<kbd>ELFCLASS32</kbd> and <kbd>ELFCLASS64</kbd>).  Additionally, some architectures use different machine identifiers (<kbd>EM_386</kbd> vs. <kbd>EM_X86_64</kbd>, <kbd>EM_PPC</kbd> vs. <kbd>EM_PPC64</kbd>).  The x32 bit ABI on x86 “abuses” this by declaring its binaries as <kbd>ELFCLASS32 + EM_X86_64</kbd> (and therefore distinct from <kbd>ELFCLASS32 + EM_386</kbd> and from <kbd>ELFCLASS64 + EM_X86_64</kbd>).</p>
<p>Both ARM and MIPS use the flags field (it is a bit-field with architecture-specific flags) to distinguish different ABIs (hardfloat vs. softfloat, n32 ABI on MIPS…).  Additionally, both feature a dedicated attribute section — and again, the linker refuses to link incompatible object files.</p>
<p>It may be desirable to implement a similar mechanism for time32 and time64 systems.  Unfortunately, it’s not a trivial task.  It doesn’t seem that there is a reusable generic mechanism that could be used for that.  On top of that, we need a solution that would fit a fair number of different architectures.  It seems that the most reasonable solution right now would be to add a new ELF note section dedicated to this feature, and implement complete toolchain support for it.</p>
<p>However, whatever we decide to do, we need to take into consideration that the user may want to disable it.  Particularly, there is a fair number of prebuilt software that have no sources available, and it may continue working correctly against system libs, provided it does not call into any API using <kbd>time_t</kbd>.  The cure of unconditionally preventing them from working might be worse than the disease.</p>
<p>On the bright side, it should be possible to create a non-fatal QA check for this without much hacking, provided that we go with separate libdirs.  We can distinguish time64 executables by their <kbd>.interp</kbd> section, pointing to the dynamic loader in the appropriate libdir, and then verify that time32 programs will not load any libraries from <kbd>libt64</kbd>, and that time64 programs will not load any libraries directly from <kbd>lib</kbd>.</p>
<h2>What about old prebuilt applications?</h2>
<p>So far we were concerned about packages that are building from sources.  However, there is still a fair number of old applications, usually proprietary, that are available only as prebuilt binaries — particularly for x86 and PowerPC architectures.  These packages are going to face two problems: firstly, compatibility issues with system libraries, and secondly, the y2k38 problem itself.</p>
<p>For the compatibility problem, we have a reasonably good solution already.  Since we already had to make them work on amd64, we have a multilib layout in place, along with necessary machinery to build multiple library versions.  In fact, given that the primary purpose of multilib is compatibility with old software, it’s not even clear if there is much of a point in switching amd64 multilib to use time64 for 32-bit binaries.  Either way, we can easily extend our multilib machinery to distinguish the regular <kbd>abi_x86_32</kbd> target from <kbd>abi_x86_t64</kbd> (and we probably should do that anyway), and then create new multilib x86 profiles that would support both ABIs.</p>
<p>The second part is much harder.  Obviously, as soon as we’re past the 2038 cutoff date, all 32-bit programs — using system libraries or not — will simply start failing in horrible ways.  One possibility is to work with <a rel="external" href="https://github.com/wolfcw/libfaketime">faketime</a> to control the system clock.  Another is to run a whole VM that’s moved back in time.</p>
<h2>Summary</h2>
<p>As 2038 is approaching, 32-bit applications exercising 32-bit <kbd>time_t</kbd> are up to stop working.  At this point, it is pretty clear that the only way forward is to rebuild these applications with 64-bit <kbd>time_t</kbd> (and while at it, force <abbr title="Large File Support">LFS</abbr> as well).  Unfortunately, that’s not a trivial task since it involves an ABI change, and mixing time32 and time64 programs and libraries can lead to horrible runtime bugs.</p>
<p>While the exact details are still in the making, the proposed changes revolve around three ideas that can be implemented independently to some degree: changing the platform tuple (<kbd>CHOST</kbd>), changing libdir and preventing accidentally mixing time32 and time64 binaries.</p>
<p>The tuple change is mostly a more formal way of distinguishing builds for the regular time32 ABI (e.g. <kbd>i686-pc-linux-gnu</kbd>) from ones specifically targeting time64 (e.g. <kbd>i686-pc-linux-gnut64</kbd>).  It should be relatively harmless and easy to carry out, with minimal amount of fixing necessary.  For example, clang will need to be updated to accept new tuples.</p>
<p>The libdir change is probably the most important of all, as it permits a breakage-free transition, thanks to Portage’s <kbd>preserved-libs</kbd> feature.  Long story short, time64 libraries get installed to a new libdir (e.g. <kbd>libt64</kbd>), and the original time32 libraries remain in <kbd>lib</kbd> until the applications using them are rebuilt.  Unfortunately, it’s a bit harder to implement — it requires toolchain changes, and ensuring that all software correctly respects libdir.  The extra difficulty is that with this change alone, the dynamic loader won’t ignore time32 libraries if e.g. <kbd>-Wl,-rpath,/usr/lib</kbd> is injected somewhere.</p>
<p>The incompatibility part is quite important, but also quite difficult.  Ideally, we’d like to stop the linker from trying to accidentally link time32 libraries with time64 programs, and likewise the dynamic loader from trying to load them.  Unfortunately, so far we weren’t able to come up with a realistic way of doing that, short of actually making some intrusive changes to the toolchain.  On the positive side, writing a QA check to detect accidental mixing at build time shouldn’t be that hard.</p>
<p>Doing all three should enable us to provide a clean and relatively safe transition path for 32-bit Gentoo systems using glibc.  However, these only solve problems for packages built from source.  Prebuilt 32-bit applications, particularly proprietary software like old games, can’t be helped that way.  And even if time64 changes won’t break them via breaking the ABI compatibility with system libraries, then year 2038 will.  Unfortunately, there does not seem to be a good solution to that, short of actually running them with faked system time, one way or another.</p>
<p>Of course, all of this is still only a rough draft.  A lot may still change, following experiments, discussion and patch submission.</p>
<h2>Acknowledgements</h2>
<p>I would like to thank the following people for proof-reading and suggestions, and for their overall work towards time64 support in Gentoo: Arsen Arsenović, Andreas K. Hüttel, Sam James and Alexander Monakov.</p>
	</div><!-- .entry-content -->

	<!-- .entry-footer -->
</article></div>
  </body>
</html>
