<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ariadne.space/2021/06/06/actually-bsd-kqueue-is-a-mountain-of-technical-debt/">Original</a>
    <h1>BSD kqueue is a mountain of technical debt</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>A side effect of <a href="https://ariadne.space/2021/05/20/the-whole-freenode-kerfluffle/">the whole freenode kerfluffle</a> is that I’ve been looking at IRCD again.  IRC, is of course a very weird and interesting place, and the smaller community of people who run IRCDs are largely weirder and even more interesting.</p>
<p>However, in that community of IRCD administrators there happens to be a few incorrect systems programming opinions that have been cargo culted around for years.  This particular blog is about one of these bikesheds, namely the <em>kqueue vs epoll debate</em>.</p>
<p>You’ve probably heard it before.  It goes something like this, <em>“BSD is better for networking, because it has kqueue.  Linux has nothing like kqueue, epoll doesn’t come close.&#34;</em>  While I agree that epoll doesn’t come close, I think that’s actually a feature that has lead to a much more flexible and composable design.</p>
<h2 id="in-the-beginning">In the beginning…</h2>
<p>Originally, IRCD like most daemons used <code>select</code> for polling sockets for readiness, as this was the first polling API available on systems with BSD sockets.  The <code>select</code> syscall works by taking a set of three bitmaps, with each bit describing a file descriptor number: bit 1 refers to file descriptor 1 and so on.  The bitmaps are the <code>read_set</code>, <code>write_set</code> and <code>err_set</code>, which map to sockets that can be read, written to or have errors accordingly.  Due to design defects with the <code>select</code> syscalls, it can only support up to <code>FD_SETSIZE</code> file descriptors on most systems.  This can be mitigated by making <code>fd_set</code> an arbitrarily large bitmap and depending on <code>fdmax</code> to be the upper bound, which is what WinSock has traditionally done on Windows.</p>
<p>The <code>select</code> syscall clearly had some design deficits that negatively affected scalability, so AT&amp;T introduced the <code>poll</code> syscall in System V UNIX.  The <code>poll</code> syscall takes an array of <code>struct pollfd</code> of user-specified length, and updates a bitmap of flags in each <code>struct pollfd</code> entry with the current status of each socket.  Then you iterate over the <code>struct pollfd</code> list.  This is naturally a lot more efficient than <code>select</code>, where you have to iterate over all file descriptors up to <code>fdmax</code> and test for membership in each of the three bitmaps to ascertain each socket’s status.</p>
<p>It can be argued that <code>select</code> was bounded by <code>FD_SETSIZE</code> (which is usually 1024 sockets), while <code>poll</code> begins to have serious scalability issues at around <code>10240</code> sockets.  These arbitrary benchmarks have been referred to as the C1K and C10K problems accordingly.  Dan Kegel has a <a href="http://www.kegel.com/c10k.html">very lengthy post on his website</a> about his experiences mitigating the C10K problem in the context of running an FTP site.</p>
<h2 id="then-there-was-kqueue">Then there was kqueue…</h2>
<p>In July 2000, Jonathan Lemon introduced kqueue into FreeBSD, which quickly propagated into the other BSD forks as well.  kqueue is a kernel-assisted event notification system using two syscalls: <code>kqueue</code> and <code>kevent</code>.  The <code>kqueue</code> syscall creates a handle in the kernel represented as a file descriptor, which a developer uses with <code>kevent</code> to add and remove <em>event filters</em>.  Event filters can match against file descriptors, processes, filesystem paths, timers, and so on.</p>
<p>This design allows for a single-threaded server to process hundreds of thousands of connections at once, because it can register all of the sockets it wishes to monitor with the kernel and then lazily iterate over the sockets as they have events.</p>
<p>Most IRCDs have supported <code>kqueue</code> for the past 15 to 20 years.</p>
<h2 id="and-then-epoll">And then epoll…</h2>
<p>In October 2002, Davide Libenzi got <a href="http://www.xmailserver.org/linux-patches/nio-improve.html">his <code>epoll</code> patch</a> merged into Linux 2.5.44.  Like with kqueue, you use the <code>epoll_create</code> syscall to create a kernel handle which represents the set of descriptors to monitor.  You use the <code>epoll_ctl</code> syscall to add or remove descriptors from that set.  And finally, you use <code>epoll_wait</code> to wait for kernel events.</p>
<p>In general, the scalability aspects are the same to the application programmer: you have your sockets, you use <code>epoll_ctl</code> to add them to the kernel’s <code>epoll</code> handle, and then you wait for events, just like you would with <code>kevent</code>.</p>
<p>Like <code>kqueue</code>, most IRCDs have supported <code>epoll</code> for the past 15 years.</p>
<h2 id="what-is-a-file-descriptor-anyway">What is a file descriptor, anyway?</h2>
<p>To understand the argument I am about to make, we need to talk about <em>file descriptors</em>.  UNIX uses the term <em>file descriptor</em> a lot, even when referring to things which are clearly <em>not</em> files, like network sockets.  Outside the UNIX world, a file descriptor is usually referred to as a <em>kernel handle</em>.  Indeed, in Windows, kernel-managed resources are given the <code>HANDLE</code> type, which makes this relationship more clear.  Essentially, a kernel handle is basically an opaque reference to an object in kernel space, and the astute reader may notice some similarities to the <a href="https://en.wikipedia.org/wiki/Object-capability_model">object-capability model</a> as a result.</p>
<p>Now that we understand that file descriptors are actually just kernel handles, we can now talk about <code>kqueue</code> and <code>epoll</code>, and why <code>epoll</code> is actually the correct design.</p>
<h2 id="the-problem-with-event-filters">The problem with event filters</h2>
<p>The key difference between <code>epoll</code> and <code>kqueue</code> is that <code>kqueue</code> operates on the notion of <em>event filters</em> instead of <em>kernel handles</em>.  This means that any time you want <code>kqueue</code> to do something new, you have to add a new type of <em>event filter</em>.</p>
<p><a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2">FreeBSD presently has 10 different event filter types</a>: <code>EVFILT_READ</code>, <code>EVFILT_WRITE</code>, <code>EVFILT_EMPTY</code>, <code>EVFILT_AIO</code>, <code>EVFILT_VNODE</code>, <code>EVFILT_PROC</code>, <code>EVFILT_PROCDESC</code>, <code>EVFILT_SIGNAL</code>, <code>EVFILT_TIMER</code> and <code>EVFILT_USER</code>.  Darwin has additional event filters concerning monitoring Mach ports.</p>
<p>Other than <code>EVFILT_READ</code>, <code>EVFILT_WRITE</code> and <code>EVFILT_EMPTY</code>, all of these different event filter types are related to entirely different concerns in the kernel: they don’t monitor kernel handles, but instead other specific subsystems than sockets.</p>
<p>This makes for a powerful API, but one which lacks <a href="https://en.wikipedia.org/wiki/Composability">composability</a>.</p>
<h2 id="epoll-is-better-because-it-is-composable"><code>epoll</code> is better because it is composable</h2>
<p>It is possible to do almost everything that <code>kqueue</code> can do on FreeBSD in Linux, but instead of having a single monolithic syscall to handle <em>everything</em>, Linux takes the approach of providing syscalls which allow almost anything to be represented as a <em>kernel handle</em>.</p>
<p>Since <code>epoll</code> strictly monitors <em>kernel handles</em>, you can register <em>any</em> kernel handle you have with it and get events back when its state changes.  As a comparison to Windows, this basically means that <code>epoll</code> is a kernel-accelerated form of <code>WaitForMultipleObjects</code> in the Win32 API.</p>
<p>You are probably wondering how this works, so here’s a table of commonly used <code>kqueue</code> event filters and the Linux syscall used to get a kernel handle for use with <code>epoll</code>.</p>
<table>
<thead>
<tr>
<th>BSD event filter</th>
<th>Linux equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EVFILT_READ</code>, <code>EVFILT_WRITE</code>, <code>EVFILT_EMPTY</code></td>
<td>Pass the socket with <code>EPOLLIN</code> etc.</td>
</tr>
<tr>
<td><code>EVFILT_VNODE</code></td>
<td><code>inotify</code></td>
</tr>
<tr>
<td><code>EVFILT_SIGNAL</code></td>
<td><code>signalfd</code></td>
</tr>
<tr>
<td><code>EVFILT_TIMER</code></td>
<td><code>timerfd</code></td>
</tr>
<tr>
<td><code>EVFILT_USER</code></td>
<td><code>eventfd</code></td>
</tr>
<tr>
<td><code>EVFILT_PROC</code>, <code>EVFILT_PROCDESC</code></td>
<td><code>pidfd</code>, alternatively bind processes to a <code>cgroup</code> and monitor <code>cgroup.events</code></td>
</tr>
<tr>
<td><code>EVFILT_AIO</code></td>
<td><code>aiocb.aio_fildes</code> (treat as socket)</td>
</tr>
</tbody>
</table>
<p>Hopefully, as you can see, <code>epoll</code> can automatically monitor <em>any</em> kind of kernel resource without having to be modified, due to its composable design, which makes it superior to <code>kqueue</code> from the perspective of having less technical debt.</p>
<p>Interestingly, <a href="https://www.freebsd.org/cgi/man.cgi?query=eventfd&amp;apropos=0&amp;sektion=2&amp;manpath=FreeBSD+13.0-RELEASE+and+Ports&amp;arch=default&amp;format=html">FreeBSD has added support for Linux’s <code>eventfd</code> recently</a>, so it appears that they may take <code>kqueue</code> in this direction as well.  Between that and FreeBSD’s <a href="https://www.freebsd.org/cgi/man.cgi?query=procdesc&amp;sektion=4&amp;apropos=0&amp;manpath=FreeBSD+13.0-RELEASE+and+Ports">process descriptors</a>, it seems likely.</p>

  </div></div>
  </body>
</html>
