<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.opencog.org/2013/03/24/why-hypergraphs/">Original</a>
    <h1>Why Hypergraphs? (2013)</h1>
    
    <div id="readability-page-1" class="page"><div>
						<p>OpenCog uses <a href="http://en.wikipedia.org/wiki/Hypergraph">hypergraphs</a> to represent knowledge.  Why?  I don’t think this is clearly, succinctly explained anywhere, so I will try to do so here.  This is a very important point: I can’t begin to tell you how many times <a href="http://linas.org/agi.html">I went searching</a> for some whiz-bang logic programming system,  or inference engine, or theorem-prover, or some <a href="http://en.wikipedia.org/wiki/Graph_rewriting">graph re-writing engine</a>, or some <a href="http://probabilistic-programming.org">probabilistic programming system</a>, only to throw up my hands up and realize that, after many wasted hours, none of them do what I want.  If you’re interested in AGI, then let me assure you: they don’t do what you want, either.  So, what do I want them to do, and why?</p>
<p>Well, lets begin easy: with graph re-writing systems.  These days, almost everyone agrees that a great way to represent knowledge is with graphs.  The structure <tt>IsA(Cat, Animal)</tt> looks like a graph with two vertexes, <tt>Cat</tt> and <tt>Animal</tt>, and a labelled edge, <tt>IsA</tt>, between them.  If I also know that <tt>IsA(Binky, Cat)</tt>, then, in principle, I should be able to deduce that <tt>IsA(Binky, Animal)</tt>.  This is a simple transitive relationship, and the act of logical deduction, for this example, is a simple graph re-write rule: If you see two <tt>IsA</tt> edges in a row, you should draw a third <tt>IsA</tt> edge between the first and the last vertex.  Easy, right?</p>
<p>So perhaps you’d think that all logic induction and reasoning engines have graph rewrite systems at their core, right? So you’d think. In fact, almost none of them do.  And those that do, do it in some internal, ad hoc, non-public, undocumented way: there’s no API, its not exposed externally; its not an ‘official’ part of the system for you to use or tinker with.</p>
<p>OK, so why do I need a graph re-write system? Well, I’ve been working on a natural language parser, a so-called <a href="https://blog.opencog.org/2013/03/19/the-viterbi-parser/">Viterbi decoder for Link Grammar</a>.  My initial graph is a string of words: a sentence.  The vertexes are words, and the edges are arrows called “next word”. Real simple. To parse this sentence, I want to apply a certain set of simple graph-rewrite rules: for example, if word X is a noun, then create an arrow, called ‘part-of-speech’ (POS),  from word X to the special vertex ‘noun’.  If the word immediately before word X is an adjective (<em>i.e.</em> if  it has a POS arrow pointing to ‘adjective’), then create a new arrow, called ‘noun modifier’, pointing from X to this word before it.   This kind of graph markup is called ‘<a href="http://en.wikipedia.org/wiki/Dependency_grammar">dependency parsing</a>‘, and is a very popular way of doing natural language parsing.  So you’d think that all dependency parsers have a graph re-write system at their core, right?  Hardly. In fact, just about none of them do.  And if they do, they’re walled off, hacked up, undocumented … you get the idea.</p>
<p>The only dependency parser that I know of that has an explicit graph-rewriting system in it, that is open for tinkering, <a href="http://wiki.opencog.org/w/Sentence_algorithms">and is documented</a> (!) is <a href="http://wiki.opencog.org/w/RelEx_Dependency_Relationship_Extractor">RelEx</a>.  And that’s great.  Wow!  Although RelEx invented and used its own, custom, graph rewrite system, I suppose that, in principle, it could have used some other, pre-existing system to do this (Well, it couldn’t, because in 2005, there weren’t any robust, open-source graph rewriting systems. Whatever).</p>
<p>What else do I want to do? Well, I daydream about using a machine-learning system to learn new rules!   I mean, this is the goal of AGI, right? Have a machine that can learn new things?  Well, to learn new rules, lets see, I need to have some simple syntax for representing rules.  Basically a simple graph language.  So you’d think that all graph re-writing systems have some simple, easy-to-use graph language, right?  No. Emphatically, hell no. With maybe one exception, you have to program in Java or C++ or C#.net. Unfortunately, my machine learning system doesn’t yet know how to program in those languages.</p>
<p>Here’s the leap of faith, the leap of logic that I’ve come to: It would be convenient if I could express graph re-write rules as graphs themselves.  It would be convenient if I could express logical implications as graphs themselves.  It would be convenient if  my graphical programming language itself could be written as a graph. Well, it can be. In fact, it is easiest to do this if the graph is actually a hypergraph. I’ll explain why in the next section below.  If I had a hypergraph re-writing system, than I would have a place where I could unify natural language processing, logical reasoning and machine learning, all in one place.  So you’d think that anyone who was trying to build an AGI system wouldbe writing its foundations on a hypergraph rewriting system, right? No, you’d be wrong. Apparently, OpenCog is the only system that does this.  Now, the OpenCog implementation has many design warts and architectural flaws. Its hard to understand and hard to use.  But now, perhaps, now you see why I’ve pledged allegiance to it,   instead of running off with some other reasoning system or parser or Bayesian network or whatever.</p>
<h2>Mathematical Foundations</h2>
<p>In this section, I will try to put all of the above comments on a solid mathematical footing, invoking <a href="http://en.wikipedia.org/wiki/Model_theory">model theory</a>, <a href="http://en.wikipedia.org/wiki/Category_theory">category theory</a>, (and even <a href="http://ncatlab.org">n-categories</a>!), and <a href="http://en.wikipedia.org/wiki/Type_theory">type theory</a>.  The upshot of all of this will be that the easiest way to represent data structures so that machine learning algorithms can learn them, and then apply them both to natural-language parsing, and to logical reasoning, is to represent the data structures as hypergraphs.</p>
<p>From model theory and computer science, we have the concept of a signature: a set of functions which take some number of arguments and return some value (just like a signature in Java or C++).  If one ignores types for a moment (which is what lisp and scheme do), then, in principle, one can pass any value in any position of any function, and stack these up arbitrarily, recursively, even.  This is called a <a href="http://en.wikipedia.org/wiki/Term_algebra">term algebra</a>, or more precisely a free term algebra or ‘free theory’.  If the functions don’t have names, but are anonymous, then one has the <a href="http://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a>.</p>
<p>One way to envision a member of a term algebra is as a directed tree graph.  So, if we have two functions f(x,y) and g(x,y) and three constants a,b,c, then f(a, g(b,c)) is a binary tree, with f at the top node, and g as the left node, and a, b and c as the leaves. A term algebra is then just the collection of all such trees. Nothing more, nothing less.</p>
<p>To do useful programming, one also needs predicates or relations: things that have truth values, and order terms. Thus, ‘greater then’ is a relation, and ‘a&gt;b’ is either true or false.  Relations can also be things like IsA, HasA, BelongsTo, LivesIn, EmployedAt. The last two examples should make clear that <a href="http://en.wikipedia.org/wiki/Relational_algebra">relational algebras</a> form the foundation of databases, whether SQL or noSQL.  Relations are combined with logical operators (<tt>employee X LivesIn city Y AND ReportsTo dept Z</tt> is a textbook example).</p>
<p>In general, one combines both term algebras and relational algebras, so that one writes things like 3&lt;f(x,y) where f(x,y) is a term, &lt; is a relation, 3 is a constant.  Add to this the special free-variable binding operators ForAll and ThereExists, one gets a First-Order Logic. So, for example, <tt>ForAll x ThereExists y such that 3&lt;f(x,y)</tt>.</p>
<p>A special case of a relation is a term re-write rule.  This is a relation that takes a term, and replaces it with a different term: for example, <tt>ab-&gt;c</tt>, which says ‘whenever you see the string ab, replace it with c’. The BNF notation of computer languages is just a collection of term re-writing relations. One uses a <a href="http://en.wikipedia.org/wiki/Term_rewriting_system">term rewriting system</a> to parse a (formal) language. Graph rewriting is just a variation of this: whenever you see a graph x, replace it with a graph y.</p>
<p>So far, I’ve avoided the issue of types.  In programming, types allow type safety.  Types make code more readable: <tt>f(string, int)</tt> is less mysterious than <tt>f(x,y)</tt>. Types solve certain abstract recursion problems in lambda calculus.  A re-write rule in <a href="http://en.wikipedia.org/wiki/Backus–Naur_Form">BNF notation</a> is a typed rewrite rule: a substitution <tt>a-&gt;bc</tt> holds not just for any <tt>a</tt>, but specifically, only when <tt>a</tt> is a web page, or an IP address or a URL.  A graph re-write rule that says ‘whenever you see x, replace it with y’ implicitly demands that x be typed: x can’t be just anything, it has to be a specific kind of graph, having a specific shape and linkage.  The rule applies for all graphs that have this shape, that are of this kind or type.  So a re-write rule <tt>x-&gt;y</tt> is really a rule <tt>(type x)-&gt;(type y)</tt>. Graphically, its still two points x and y, with a directed edge -&gt; in between them. Oh, wait, x and y aren’t points, x and y are graphs.  What kind of a graph has graphs as points?  What kind of graph has edges between graphs? A hypergraph!</p>
<p>And that is the main Ah-HA! moment.  Once you see that, you start seeing hypergraphs everywhere. Sure, you can visualize Set(a,b,c) as a tree-graph, with Set as the parent node, and three children a,b,c.  Or you can visualize this as a hypergraph: Set as a ‘link’ (a ‘hyper-edge’ with 3 endpoints, not 2), and the points a,b,c as the nodes contained in the link.  In fact, all hypergraphs are dual to these directed trees; if you have one, you can have the other.  Hypergraphs are just a convenient notation.</p>
<p>Lets take a moment to look back on what just happened: a function f(x,y,z) is just a hyperedge f connecting three nodes x,y,z. A boolean expression <tt>a AND b AND c</tt> can be written as <tt>AND(a,b,c)</tt>, which shows a specific example of a hypergraph equivalance. It can be written as a reduction rule: <tt>(a AND b AND c) -&gt; AND(a,b,c)</tt> which is itself just a hypergraph of the form x-&gt;y with x and y being hypergraphs.  The first-order logic constructs ‘for-all’ and ‘there-exists’ are just special cases of the lambda-calculus binding operation lambda, which binds free variables in an expression. Again, hypergraphs: lambda is just a hyperlink that binds a variable x in an expression y, and y was just a term, ahem, hypergraph!</p>
<p>I mentioned categories and n-categories, and I suppose I should justify this mention. Insofar as category theory is the theory of points and arrows, then a rewrite rule between graphs is a morphism in the category of small diagrams.  A subtle but important point about category theory that is almost never discussed in intro-to-cat-theory texts, is that all objects are implicitly typed. In the the category of Sets, the objects are all of the same kind: they are sets.  Its not mentioned because in a given category, all objects are of the same type; types change only when a functor maps from one to another.   So, to understand the category-theoretic equivalent of types in computer science, we must think of functors.  But, as we just saw, a graph rewriting rule is a morphism between functors.  So you could say that graph re-writing is just the category Cat of small categories.  Or you could slide down this slope in a different direction, and start calling it a 2-category. Whatever.  Perhaps its useful to point out that graph rewriting algorithms are sometimes expressed as being one-<a href="http://en.wikipedia.org/wiki/Pushout_(category_theory)">pushout</a>s or as being 2-pushouts, with a pushout being a certain category-theoretic concept. Notable, for graph rewriting, is that any category with pushouts and equalizers has all (co-)limits. Except that, as we just saw, we want hyper-graph rewriting systems, not graph rewriting systems. So there.</p>
<h2>What else are they good for?</h2>
<p>In OpenCog, the Link and Node types inherit from the type Atom. This naming convention is intentionally suggestive: ‘Atom’ is meant to invoke the notion of an ‘atomic formula’ from model theory or first-order logic: that is, a formula that has no variables in it (its fully grounded), and that does have a truth value (its not composed of boolean connectives, and has no quantifiers in it).  This suggestive naming helps establish the intended use of OpenCog hypergraphs with regards to first-order logic.</p>
<p>The truth value is a different matter. The default (simplest) OpenCog truth value is a pair of floating point numbers: a probability and a confidence. These numbers allow several other AI concepts to be mapped into hypegraphs: Bayesian networks, Markov networks, and artificial neural networks. All three of these are graphs: directed graphs, at that. They differ in how they assign and propagate floating-point probabilites, entropies, activations. Ideas such as Markov logic networks, which implement maximum entropy principles (aka Boltzmann parition function) on a network of first-order logic expressions, can be represented with OpenCog hypergraphs.  Oh, and I should mention PLN (Probabilistic Logic Networks), which is what the atomspace was originally designed for. That’s what I like about the OpenCog hypergraph atomspace: it has a tremendously powerful ability to succinctly and easily represent complex modern AI concepts.</p>
<h2>The good, the bad and the ugly.</h2>
<p>You’ve heard about the good.  Now for the bad and the ugly.  First, the OpenCog atomspace implementation is slow and inefficient, over-complicated, badly architected, weakly-distributed, non-scalable, single-threaded. But lets not go there.  All this might be fixable, after a lot of programming effort (and deep, architectural thinking). Its been hotly debated in the past. Someday, maybe it’ll get fixed.</p>
<p>The bad thing about the OpenCog atomspace is that almost no one understands that, ahem, <strong><em>it is a programming language</em></strong>. Let me be very clear on this: OpenCog implements graph re-writing rules with the <a href="http://wiki.opencog.org/w/ImplicationLink">ImplicationLink</a>. A sequence of ImplicationLinks can be used to compute things. In that sense, it is somewhat like the language <a href="http://www.cs.york.ac.uk/plasma/wiki/index.php?title=GP_%28Graph_Programs%29">Graph Programs</a>, except that OpenCog allows fractional truth values, and logic programming and other good things.  If we stick to using ImplicationLinks with crisp truth values (T/F), then the resulting system is essentially Prolog. Of course you know that Prolog is popular for AI programming projects, because its fairly easy to write reasoning engines and expert systems and the like in Prolog.  What you may not know is that closely related to Prolog is <a href="http://en.wikipedia.org/wiki/Answer_set_programming">Answer-Set Programming</a> (ASP) . In fact, ASP uses exactly the same notation as Prolog does. It differs in two important ways: first, when you run a Prolog program, you get one answer. With ASP, you get all of the answers!  Its dramatically more powerful, and the reason for this is that  modern-day ASP solvers are built on top of modern-day <a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem">Boolean SAT solvers</a>. Which means that they are stunningly efficient and effective.</p>
<p>So what does this have to do with OpenCog? Well, here we have a system that, using ImplicationLinks, is essentially Prolog, more or less, when run in crisp-logic mode. Or, you could say, its like typed Lambda calculus. But do we have a simple, easy-to-use syntax like Prolog for it? No we don’t. That’s bad. Can we take an existing Prolog program, run a tool on it, and convert it to ImplicationLinks? No we don’t.  Would it run fast? No it wouldn’t: it would probably be slower than the slowest Prolog ever: Borland prolog running on a 5MHz IBM PC AT in 1986.  And forget an ASP solver for OpenCog.  For the special case where all OpenCog truth values are crisp T/F values, we do not have a Boolean SAT solver to find solutions for our graphs of ImplicationLinks.  This is bad, Really Bad. But I think that this is because very few people seem to understand that the OpenCog Atomspace really is a petri dish for programming languages.</p>
<p>Heck, we don’t even have anything equivalent to the RelEx <a href="http://wiki.opencog.org/w/Sentence_algorithms">Sentence Algorithms</a> for OpenCog, even though RelEx is OpenCog-like. This absence is slowing down my efforts to continue work on the Link-Grammar parser, and to <a href="https://blog.opencog.org/2013/03/19/the-viterbi-parser/">move natural language processing out of its stand-alone arena, into a general, flexible framework</a>.</p>
<p>(And we’ve barely scratched the surface. In order to make implication and pattern mining run quickly in the atomspace, we need to implement something like the concept of ‘<a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>‘ from lisp/scheme.  But it turns out that memoization is really just a relational algebra: it is a database of short expressions that stand in for long ones. The OpenCog Atomspace is also, among other things, a relational database that can store and query not only flat tables or key-value pairs, but full-blown hypergraphs.  And this isn’t a day-dream; its crucial for performance (and its partially implemented)).</p>
<p>Why don’t we have these things? Well, its hard. Its just not easy. We don’t have the infrastructure to make it easy, and we don’t have the users who demand these tools.   I don’t think most users are even aware of what the atomspace could even do.   Almost no one is thinking about ‘how to program in the language of OpenCog’ even though it has the potential of far surpassing any of the existing <a href="http://probabilistic-programming.org/wiki/Home">probabilistic programming languages</a> out there.  Its time to change all this, but it will take someone smart and dedicated to do this. Many someones. This could be you.</p>
											</div></div>
  </body>
</html>
