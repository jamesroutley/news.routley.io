<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.uninformativ.de/blog/postings/2022-04-21/0/POSTING-en.html">Original</a>
    <h1>Python’s “type hints” are a bit of a disappointment to me</h1>
    
    <div id="readability-page-1" class="page"><div id="blogpostcontent">

<p><a href="https://www.uninformativ.de/blog/">blog</a> · <a href="https://www.uninformativ.de/git/">git</a> · <a href="https://www.uninformativ.de/desktop/">desktop</a> · <a href="https://www.uninformativ.de/pics/stream.html">images</a> · <a href="https://www.uninformativ.de/contact.html">contact &amp; privacy</a> · <a href="gopher://uninformativ.de">gopher</a></p>
<hr/>

<p>2022-04-21</p>

<p>In Python 3.5, “<a href="https://docs.python.org/3/library/typing.html">type hints</a>” were introduced. I was really excited when
I first heard this. You can now annotate functions:</p>
<pre><code>def greeting(name: str) -&gt; str:
    return &#39;Hello &#39; + name
</code></pre>
<p>And variables:</p>
<pre><code>foo: str = greeting(&#39;penguin&#39;)
</code></pre>
<p>That looks very promising. I was expecting that I could finally do
static typing in Python. I’m a big fan of that, because it allows me to
catch lots of errors in advance. You don’t need to <em>run</em> every single
line of code to make sure that your types are correct – instead, a
static analyzer can now inspect your code.</p>
<p>There are several limitations, though.</p>
<p>I had already made up my mind about this a while ago and decided to not
use type hints in my own projects, but recently, we started a new
project at work and people wanted to use type hints again. I decided to
give them another chance. It didn’t go so well. I stand by my initial
decision, sadly.</p>
<p>Despite all that, what I’m hoping for is that someone will come along
and tell me that I got it all wrong. “When you do it as follows, the
system works: <code>$explanation</code>” Because, you know, I’d really like to have
static typing in Python.</p>
<h2>The short version</h2>
<p><a href="https://docs.python.org/3/library/typing.html">The documentation</a> says:</p>
<blockquote>
<p>The Python runtime does not enforce function and variable type
annotations. They can be used by third party tools such as type
checkers, IDEs, linters, etc.</p>
</blockquote>
<p>So, this executes perfectly fine:</p>
<pre><code>foo: int = &#39;hello&#39;
print(foo)
</code></pre>
<p>The fact that you can put nonsensical types wherever you want and still
get a working program has consequences. Let’s explore them.</p>
<h2>Worse than comments and worse than Hungarian Notation</h2>
<p>You sometimes see this:</p>
<pre><code># returns str
def greeting(name):
    return &#39;Hello &#39; + name
</code></pre>
<p>Since the language’s syntax itself has no concept of typing, people
resort to adding a comment which states the return type. Similar to
Python’s type hints, nothing ever checks these comments. But the thing
is: <em>They are comments.</em> It is obvious that they are not <em>binding</em>.</p>
<p><a href="https://en.wikipedia.org/wiki/Hungarian_notation">Hungarian Notation</a>, e.g. <code>strName</code>, can be deceptive, too. I think
it’s a little worse than comments, because every time you read <code>strName</code>
you are being nudged into thinking it’s a string, even though it might
actually be something else. But at least it’s just a name and the reader
knows that.</p>
<p>Type hints, on the other hand, <em>appear to be</em> binding. They are part of
the official language and, to the uninitiated, they create the
impression that they matter. Except they only kind of somewhat matter
sometimes, as we’ll see. They are essentially a comment in disguise.</p>
<h2>Type checking is your job after all</h2>
<p>Now, if Python itself does not care about those hints in the slightest
way, then what does? Well, maybe an IDE does or maybe an external tool
like <a href="http://mypy-lang.org/">mypy</a> does. I’ll be talking about mypy a lot now, but I think that
all of this applies to every other tool as well. I don’t blame mypy for
any of this.</p>
<p>But as a general rule: You <em>don’t know</em> if there really is a tool in
place to check them. You especially don’t know this when you join a new
project, but it’s also a little hard to tell afterwards. Did the mypy
task in your build pipeline silently break? Maybe mypy is misconfigured?
Maybe it spits out errors but does not cause build jobs to actually
fail? What if mypy has a bug? What if mypy is not even complete and
doesn’t cover all cases?</p>
<p>You see, unlike traditional compiled languages, where there is
absolutely no way around type checks being performed, because you then
wouldn’t get an executable program at all, you manually have to make
sure that things like mypy do their job and do it correctly. It is very
easy for things to go wrong here, because running mypy is not an
<em>essential</em> step – it’s an additional, <em>optional</em> step, which requires
maintenance.</p>
<p>Mypy and the Python runtime are also inherently out of sync and just
because one of them says it’s fine, doesn’t mean the other one will
agree.</p>
<p>My favorite story about this: Back when I was young and naïve, I joined
a Python project which was full of type hints. I knew that, unlike me,
these guys were very fond of type hints. As such, I assumed that they
had tooling in place to check the hints (and that the hints were correct
as a result). Guess what, they didn’t. Well, they did, but only in their
IDEs – and the warnings of IDEs are simple to ignore. As a result, I
read their code, saw those type hints, and my brain started to assume,
“aha, this is of type foo, that’s type bar, …”. Most of this turned out
to be wrong and it threw me off the track during my debugging session.</p>
<p>Note that <em>their program worked</em> and it had a good test suite and
everything. Just the type hints were wrong. (Well, and there was this
one bug that I was going to fix, which was an error in the program’s
logic, though, unrelated to typing.)</p>
<p>It is much harder to fall into this trap when using a compiled language:
When you write <code>int</code> instead of <code>struct foo</code> somewhere, it is very
unlikely to go unnoticed. Your program will either not compile or it
will show up when running your test suite. (Yes, C has its pitfalls in
this regard.)</p>
<p>I don’t want to blame the other guys in the project here. Mistakes
happen, it’s fine. Us humans need tools to avoid making them. My point
is that Python’s type hints are probably too fragile for this job.</p>
<h2>There is an <code>Any</code> type and it renders everything useless</h2>
<p>Python is a dynamically typed language. By definition, you don’t know
the real types of variables at runtime. This is a feature.</p>
<p>So, natually, there now is an <code>Any</code> type. The following program passes
mypy validation:</p>
<pre><code>from random import randint
from typing import Any


def foo() -&gt; Any:
    if randint(0, 1) == 0:
        return 42
    else:
        return &#39;foo,bar,baz&#39;


bar = foo()
print(bar.split(&#39;,&#39;))
</code></pre>
<p>Of course, in 50% of the cases you get an exception.</p>
<p><code>Any</code> also <a href="https://docs.python.org/3/library/typing.html#the-any-type">goes both ways</a>, which was pretty surprising to me:</p>
<blockquote>
<p>A special kind of type is Any. A static type checker will treat every
type as being compatible with Any and Any as being compatible with
every type.</p>
</blockquote>
<p>So, this is valid code:</p>
<pre><code>from typing import Any


def foo() -&gt; int:
    bar: Any = &#39;hello&#39;
    return bar


result = foo()
print(result)
</code></pre>
<p>In other words, <em>even if</em> your project uses type hints all over the
place <em>and</em> has a checker like mypy in place, your type hints might
<em>still</em> be wrong. <code>foo()</code> does <em>not</em> return an integer.</p>
<p>Mypy has an option to turn this into an error:</p>
<pre><code>$ mypy --warn-return-any foo.py
foo.py:9: error: Returning Any from function declared to return &#34;int&#34;
Found 1 error in 1 file (checked 1 source file)
</code></pre>
<p>I guess they cannot turn this on by default, because, well, the Python
docs say it’s valid. So, yes, you can somehow avoid this trap, but it
reminds me a lot about having to do things like <code>-pedantic -Wall
-Werror -Wyes-really -Wyeah-i-mean-it --dont-you-listen-to-me</code> in C
projects. Flags like these are problematic because you have to remember
to use them – and in new versions of your type checker, you have to make
sure that they didn’t change their meaning and that they didn’t
introduce new flags that you really, really should use.</p>
<p>Also, what if some of your code <em>relies</em> on using <code>Any</code>? Python is a
dynamically typed language and it’s perfectly legal to do these kinds of
things. You will then probably proceed to tell mypy to turn off the
<code>Any</code> checks just for some modules … which is a recipe for chaos.</p>
<p>You must also be aware that <code>Any</code> can <em>sneak in through libraries</em>. This
happened to me and it went unnoticed for quite a while. Let’s take the
example from above again and make it more explicit:</p>
<pre><code>from typing import Any


def an_imported_library_function() -&gt; int:
    bar: Any = &#39;hello&#39;
    return bar


result: int = an_imported_library_function()
print(result, type(result))
</code></pre>
<p>Suppose you look at the documentation for that library: It says it
returns <code>int</code>. You might even glance at the source code and see that <code>-&gt;
int</code>. You make your own variable <code>result</code> an <code>int</code>. Everything screams
<code>int</code>. Mypy does not report any errors by default. And yet, when you run
it, you get this:</p>
<pre><code>$ ./foo.py
hello &lt;class &#39;str&#39;&gt;
</code></pre>
<p>Last but not least, <code>Any</code> lurks in a couple of places. When you write
<code>foo: Dict = {}</code>, it’s actually <code>foo: Dict[Any, Any] = {}</code>, and boom.</p>
<h2>Duck type compatibility</h2>
<p>Example:</p>
<pre><code>foo: int = 123
bar: float = foo

if isinstance(foo, int):
    print(&#39;foo is an int&#39;)
if isinstance(foo, float):
    print(&#39;foo is a float&#39;)

if isinstance(bar, int):
    print(&#39;bar is an int&#39;)
if isinstance(bar, float):
    print(&#39;bar is a float&#39;)
</code></pre>
<p>Passes validation:</p>
<pre><code>$ mypy --strict numeric.py
Success: no issues found in 1 source file
</code></pre>
<p>Unexpected result:</p>
<pre><code>$ python3 numeric.py
foo is an int
bar is an int
</code></pre>
<p>How can I declare <code>bar</code> as <code>float</code>, but then it accepts an <code>int</code> and
actually is an <code>int</code> at runtime (so it’s not like it’s being converted
automatically – of course not, the runtime does not care about type
hints)?</p>
<p>The reason is <a href="https://mypy.readthedocs.io/en/latest/duck_type_compatibility.html?highlight=float#duck-type-compatibility">duck type compatibility</a>.</p>
<p>This is <em>probably</em> not a big deal in Python, though. When you divide two
integers, <code>1 / 3</code>, the result is a <code>float</code> and not accidentally an
<code>int</code>, like in some other languages. And luckily this is limited to just
a few built-in types.</p>
<p>And yet … It says <code>bar: float</code> but it’s an <code>int</code>. They could have just
called it <code>number</code>, if it’s ambiguous anyway.</p>
<h2>Most projects need third-party type hints</h2>
<p>Most Python projects out there pre-date type hints, so they are
completely untyped. The default of mypy is to go “🤷” and accept
untyped code almost as if it was declared <code>Any</code>. Again, there is an
option to turn on these checks, so this is another thing to know and
remember.</p>
<p>Now, if do you want to make use of type hints when using such libraries,
well, you have to add the hints. <a href="https://github.com/python/typeshed/">typeshed</a> contains hints for a bunch
of popular projects.</p>
<p>I hope you realize what this means: The library itself and its type
hints are <em>out of sync</em>. When mypy does not report any errors for your
code, what does that mean? Do you actually call that library correctly?
Do you really know that now, just because mypy spits out a green line?
Are you sure?</p>
<h2>Sadly, dataclasses ignore type hints as well</h2>
<p>So we were making a client for a REST API. Traditionally, we would have
built <code>dict</code>s and then POSTed them:</p>
<pre><code>payload = {
    &#39;cars&#39;: [
        {
            &#39;name&#39;: &#39;toy yoda&#39;,
            &#39;wheels&#39;: 4,
        },
    ],
    &#39;salad&#39;: &#39;potato&#39;,
    &#39;version&#39;: 8,
}
</code></pre>
<p>Code like this can get really messy really fast. Python 3.7 introduced
<a href="https://docs.python.org/3/library/dataclasses.html">dataclasses</a>. Together with type hints, it might look like this:</p>
<pre><code>from dataclasses import dataclass
from typing import List, Literal


@dataclass
class Car:
    name: str
    wheels: int


@dataclass
class APIRequest:
    cars: List[Car]
    salad: Literal[&#39;potato&#39;, &#39;italian&#39;]
    version: Literal[8]


payload = APIRequest(
    cars=[
        Car(
            name=&#39;toy yoda&#39;,
            wheels=4,
        ),
    ],
    salad=&#39;potato&#39;,
    version=8,
)
</code></pre>
<p>If you now turned <code>wheels=4</code> into <code>wheels=&#39;4&#39;</code>, mypy would report an
error.</p>
<p>I’d argue that this is better code. Dataclasses and type hints allow the
reader to know how an API request is composed. Looks like it’s
self-documenting, right?</p>
<p>Of course, writing <code>wheels=&#39;4&#39;</code> can be reported as an error, but how
much of your code handles <em>static</em> data like this? Isn’t it much more
likely that this <code>&#39;4&#39;</code> is actually a variable? The big question then
becomes where this variable comes from and whether it’s covered by
(correct) type hints. If it isn’t (or if it’s <code>Any</code>), then your build is
green, but your code might be wrong and will fail somewhere down the
road (just as if you didn’t have type hints in the first place).</p>
<p>It would have been really nice if dataclasses automatically honored
their type hints and raised errors on mismatches.</p>
<p><code>Literal</code> is extra deceptive: It not only states the type of something,
but also declares which contents are allowed. Again, this is not
relevant at runtime. All your type hints can be perfectly fine, but if
you read the string <code>potatu</code> instead of <code>potato</code> from a file or an HTTP
response or whatever, then nothing will ever complain about it.</p>
<p>I’d still argue that it’s better to use dataclasses (maybe without type
hints) than to compose chaotic <code>dict</code>s, but this is probably a personal
preference of mine. Many Python programmers praise the language for not
having to use classes like this. People <em>like</em> that they can just throw
around dicts.</p>
<h2>Type inference and lazy programmers</h2>
<p>Consider this:</p>
<pre><code>foo = {
    &#39;hello&#39;: &#39;world&#39;,
    &#39;bar&#39;: [&#39;baz&#39;],
}

foo[&#39;bar&#39;].append(&#39;potato&#39;)

print(foo)
</code></pre>
<p>Since all programmers are as lazy as they can get away with, this code
does not contain any type hints. Most code probably looks like this.
Mypy then has no other choice but to guess what the types must be,
because, well, you want to do type checking, don’t you?</p>
<p>So, while the code snippet executes just fine:</p>
<pre><code>$ ./bar.py
{&#39;hello&#39;: &#39;world&#39;, &#39;bar&#39;: [&#39;baz&#39;, &#39;potato&#39;]}
</code></pre>
<p>Mypy is not happy with it:</p>
<pre><code>$ mypy bar.py
bar.py:9: error: &#34;Sequence[str]&#34; has no attribute &#34;append&#34;
Found 1 error in 1 file (checked 1 source file)
</code></pre>
<p>The detected type isn’t wrong per se, because both <code>world</code> and <code>[&#39;baz&#39;,
&#39;potato&#39;]</code> are technically sequences of <code>str</code> (run <code>python -c &#39;for i in
&#34;foo&#34;: print(type(i))&#39;</code> to see it in action). It’s not quite what the
code intended to say, though, because the latter is clearly supposed to
be a list which indeed has an <code>.append()</code> method.</p>
<p>How do you solve this? The obvious answer is to add the correct hints:</p>
<pre><code>from typing import Dict, List, Union


foo: Dict[str, Union[str, List[str]]] = {
    &#39;hello&#39;: &#39;world&#39;,
    &#39;bar&#39;: [&#39;baz&#39;],
}

foo[&#39;bar&#39;].append(&#39;potato&#39;)

print(foo)
</code></pre>
<p>Now, it … wait, it’s still wrong:</p>
<pre><code>$ mypy bar.py
bar.py:12: error: Item &#34;str&#34; of &#34;Union[str, List[str]]&#34; has no attribute &#34;append&#34;
Found 1 error in 1 file (checked 1 source file)
</code></pre>
<p>Crap, we couldn’t properly express that only <code>bar</code> is a list and <code>hello</code>
is a string. We now first have to resolve the type ambiguity of this
<code>Union</code>, so that we’re making sure that what we’re dealing with really
is a list:</p>
<pre><code>if isinstance(foo[&#39;bar&#39;], list):
    foo[&#39;bar&#39;].append(&#39;potato&#39;)
</code></pre>
<p>Note, though, that this is one of the few instances where I think that
mypy can be <em>beneficial</em>: It tells you that, whoops, you’re dealing with
something that might not be what you think it is. This is good, this is
what I want to see. It happened a couple of times in our code base and
prevented actual bugs. Great!</p>
<p>Another way might be to used <a href="https://mypy.readthedocs.io/en/stable/more_types.html#typeddict">TypedDict</a>:</p>
<pre><code>from typing import List, TypedDict


TypedFoo = TypedDict(
    &#39;TypedFoo&#39;,
    {
        &#39;hello&#39;: str,
        &#39;bar&#39;: List[str],
    },
)

foo = TypedFoo(
    hello=&#39;world&#39;,
    bar=[&#39;baz&#39;],
)

foo[&#39;bar&#39;].append(&#39;potato&#39;)

print(foo)
</code></pre>
<p>What happens <em>in real life</em>, though, will probably be this:</p>
<pre><code>from typing import Dict


foo: Dict = {
    &#39;hello&#39;: &#39;world&#39;,
    &#39;bar&#39;: [&#39;baz&#39;],
}

foo[&#39;bar&#39;].append(&#39;potato&#39;)

print(foo)
</code></pre>
<p>Now, <code>foo</code> is of type <code>Dict[Any, Any]</code>, the damn tool is happy, the
Python runtime doesn’t care anyway (your program worked the entire
time), and the lazy programmer can finally close that annoying Jira
ticket. ;-)</p>
<p>See, since <em>good</em> typing isn’t enforced or even encouraged by this whole
thing, there are many ways to avoid having to deal with types at all, if
you’re just not in the mood right now. You don’t even have to do
something along the lines of <code>#pragma disable type_check</code> – you can just
throw in some type that’s probably close enough and then claim: “Hey,
look, we got type hints!”</p>
<p>It requires a lot of discipline and good faith to get those hints right.</p>
<h2>Exceptions are not covered</h2>
<p>Exceptions are out of scope of type hints: You cannot annotate a
function and say, “this might throw a <code>ValueError</code>”.</p>
<p>This is a bit unfortunate. In Python, exceptions can be very surprising,
because you never know when they are being thrown. In, say, Java,
exceptions are part of a function’s signature, and this helps a lot.</p>
<h2>What you really want is a compiler, isn’t it?</h2>
<p>If you’re a fan of type hints, you should ask yourself that question.</p>
<p>You <em>must</em> run the compiler on your code, you cannot skip that step. It
checks types (and other things) and thus catches <em>a lot</em> of errors in
advance. Do you call that function correctly? Does that object have a
<code>.split()</code> method? Is this variable even defined? Hey, let’s
auto-generate some meaningful API docs directly from the code, which is
something we can do, because we know that the types are correct, so the
generated HTML files will also be correct. And so on.</p>
<p>It feels really good to see a program compile without warnings or
errors. You then know that you got it right. This is especially true for
Rust, which really doesn’t let a lot of things slip. (You might get a
little bit of a different experience with C, though.)</p>
<p>And this is the kind of thing that I initially hoped could be
accomplished by using Python’s type hints, but, sadly, no.</p>
<p><em>Even if</em> the Python runtime did check all the type hints <em>at runtime</em>,
then it would still be too late. I don’t want a fancy type exception at
runtime. That already exists (most of the time). I want to know about
type mismatches <em>in advance</em>.</p>
<p>What I want is this: Some language that’s as easy to use as Python and
it should be compiled and with good static typing, but it should also
<em>not</em> be compiled because then it wouldn’t be as easy to use as Python
anymore. Whoops?</p>
<h2>Still, aren’t type hints better than nothing?</h2>
<p>This blog post was originally titled “Python’s Type Hints considered
harmful”. Whether they are harmful or not depends on the answer to that
question: Isn’t it better to detect at least <em>some</em> errors than to
detect none at all?</p>
<p>I’d say: No. Type hints are not binding. You can not be sure that they
are correct. As such, you must always treat them as if they were wrong.
And I think that indeed makes them more harmful then useful. They waste
mental energy when reading code, they create new maintenance burdens,
and they are potentially deceiving: You cannot trust them. There’s too
much that can go wrong with them and I don’t think that’s fixable unless
you make it a new language.</p>
<p>While writing the code examples for this blog post, I had a nagging
feeling at the back of my head: “Is my code even correct?” Yes, even
just those few lines. We’re not even talking about <code>Dict[str,
Union[Dict[str, Union[int, str, bool]], List[int]]]</code>, which I have seen
in the wild, even though you could argue that your code shouldn’t deal
with that stuff in the first place.</p>
<h2>Conclusion</h2>
<p>I like Python. It’s a nice and easy to use language. And if <code>foo: int</code>
made sure that <code>foo</code> will always be an <code>int</code> and nothing else, then I’d
be using type hints everywhere. Would that still be Python?</p>


        </div></div>
  </body>
</html>
