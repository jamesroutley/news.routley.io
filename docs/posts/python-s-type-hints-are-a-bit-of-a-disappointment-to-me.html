<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.uninformativ.de/blog/postings/2022-04-21/0/POSTING-en.html">Original</a>
    <h1>Python‚Äôs ‚Äútype hints‚Äù are a bit of a disappointment to me</h1>
    
    <div id="readability-page-1" class="page"><div id="blogpostcontent">

<p><a href="https://www.uninformativ.de/blog/">blog</a> ¬∑ <a href="https://www.uninformativ.de/git/">git</a> ¬∑ <a href="https://www.uninformativ.de/desktop/">desktop</a> ¬∑ <a href="https://www.uninformativ.de/pics/stream.html">images</a> ¬∑ <a href="https://www.uninformativ.de/contact.html">contact &amp; privacy</a> ¬∑ <a href="gopher://uninformativ.de">gopher</a></p>
<hr/>

<p>2022-04-21</p>

<p>In Python 3.5, ‚Äú<a href="https://docs.python.org/3/library/typing.html">type hints</a>‚Äù were introduced. I was really excited when
I first heard this. You can now annotate functions:</p>
<pre><code>def greeting(name: str) -&gt; str:
    return &#39;Hello &#39; + name
</code></pre>
<p>And variables:</p>
<pre><code>foo: str = greeting(&#39;penguin&#39;)
</code></pre>
<p>That looks very promising. I was expecting that I could finally do
static typing in Python. I‚Äôm a big fan of that, because it allows me to
catch lots of errors in advance. You don‚Äôt need to <em>run</em> every single
line of code to make sure that your types are correct ‚Äì instead, a
static analyzer can now inspect your code.</p>
<p>There are several limitations, though.</p>
<p>I had already made up my mind about this a while ago and decided to not
use type hints in my own projects, but recently, we started a new
project at work and people wanted to use type hints again. I decided to
give them another chance. It didn‚Äôt go so well. I stand by my initial
decision, sadly.</p>
<p>Despite all that, what I‚Äôm hoping for is that someone will come along
and tell me that I got it all wrong. ‚ÄúWhen you do it as follows, the
system works: <code>$explanation</code>‚Äù Because, you know, I‚Äôd really like to have
static typing in Python.</p>
<h2>The short version</h2>
<p><a href="https://docs.python.org/3/library/typing.html">The documentation</a> says:</p>
<blockquote>
<p>The Python runtime does not enforce function and variable type
annotations. They can be used by third party tools such as type
checkers, IDEs, linters, etc.</p>
</blockquote>
<p>So, this executes perfectly fine:</p>
<pre><code>foo: int = &#39;hello&#39;
print(foo)
</code></pre>
<p>The fact that you can put nonsensical types wherever you want and still
get a working program has consequences. Let‚Äôs explore them.</p>
<h2>Worse than comments and worse than Hungarian Notation</h2>
<p>You sometimes see this:</p>
<pre><code># returns str
def greeting(name):
    return &#39;Hello &#39; + name
</code></pre>
<p>Since the language‚Äôs syntax itself has no concept of typing, people
resort to adding a comment which states the return type. Similar to
Python‚Äôs type hints, nothing ever checks these comments. But the thing
is: <em>They are comments.</em> It is obvious that they are not <em>binding</em>.</p>
<p><a href="https://en.wikipedia.org/wiki/Hungarian_notation">Hungarian Notation</a>, e.g. <code>strName</code>, can be deceptive, too. I think
it‚Äôs a little worse than comments, because every time you read <code>strName</code>
you are being nudged into thinking it‚Äôs a string, even though it might
actually be something else. But at least it‚Äôs just a name and the reader
knows that.</p>
<p>Type hints, on the other hand, <em>appear to be</em> binding. They are part of
the official language and, to the uninitiated, they create the
impression that they matter. Except they only kind of somewhat matter
sometimes, as we‚Äôll see. They are essentially a comment in disguise.</p>
<h2>Type checking is your job after all</h2>
<p>Now, if Python itself does not care about those hints in the slightest
way, then what does? Well, maybe an IDE does or maybe an external tool
like <a href="http://mypy-lang.org/">mypy</a> does. I‚Äôll be talking about mypy a lot now, but I think that
all of this applies to every other tool as well. I don‚Äôt blame mypy for
any of this.</p>
<p>But as a general rule: You <em>don‚Äôt know</em> if there really is a tool in
place to check them. You especially don‚Äôt know this when you join a new
project, but it‚Äôs also a little hard to tell afterwards. Did the mypy
task in your build pipeline silently break? Maybe mypy is misconfigured?
Maybe it spits out errors but does not cause build jobs to actually
fail? What if mypy has a bug? What if mypy is not even complete and
doesn‚Äôt cover all cases?</p>
<p>You see, unlike traditional compiled languages, where there is
absolutely no way around type checks being performed, because you then
wouldn‚Äôt get an executable program at all, you manually have to make
sure that things like mypy do their job and do it correctly. It is very
easy for things to go wrong here, because running mypy is not an
<em>essential</em> step ‚Äì it‚Äôs an additional, <em>optional</em> step, which requires
maintenance.</p>
<p>Mypy and the Python runtime are also inherently out of sync and just
because one of them says it‚Äôs fine, doesn‚Äôt mean the other one will
agree.</p>
<p>My favorite story about this: Back when I was young and na√Øve, I joined
a Python project which was full of type hints. I knew that, unlike me,
these guys were very fond of type hints. As such, I assumed that they
had tooling in place to check the hints (and that the hints were correct
as a result). Guess what, they didn‚Äôt. Well, they did, but only in their
IDEs ‚Äì and the warnings of IDEs are simple to ignore. As a result, I
read their code, saw those type hints, and my brain started to assume,
‚Äúaha, this is of type foo, that‚Äôs type bar, ‚Ä¶‚Äù. Most of this turned out
to be wrong and it threw me off the track during my debugging session.</p>
<p>Note that <em>their program worked</em> and it had a good test suite and
everything. Just the type hints were wrong. (Well, and there was this
one bug that I was going to fix, which was an error in the program‚Äôs
logic, though, unrelated to typing.)</p>
<p>It is much harder to fall into this trap when using a compiled language:
When you write <code>int</code> instead of <code>struct foo</code> somewhere, it is very
unlikely to go unnoticed. Your program will either not compile or it
will show up when running your test suite. (Yes, C has its pitfalls in
this regard.)</p>
<p>I don‚Äôt want to blame the other guys in the project here. Mistakes
happen, it‚Äôs fine. Us humans need tools to avoid making them. My point
is that Python‚Äôs type hints are probably too fragile for this job.</p>
<h2>There is an <code>Any</code> type and it renders everything useless</h2>
<p>Python is a dynamically typed language. By definition, you don‚Äôt know
the real types of variables at runtime. This is a feature.</p>
<p>So, natually, there now is an <code>Any</code> type. The following program passes
mypy validation:</p>
<pre><code>from random import randint
from typing import Any


def foo() -&gt; Any:
    if randint(0, 1) == 0:
        return 42
    else:
        return &#39;foo,bar,baz&#39;


bar = foo()
print(bar.split(&#39;,&#39;))
</code></pre>
<p>Of course, in 50% of the cases you get an exception.</p>
<p><code>Any</code> also <a href="https://docs.python.org/3/library/typing.html#the-any-type">goes both ways</a>, which was pretty surprising to me:</p>
<blockquote>
<p>A special kind of type is Any. A static type checker will treat every
type as being compatible with Any and Any as being compatible with
every type.</p>
</blockquote>
<p>So, this is valid code:</p>
<pre><code>from typing import Any


def foo() -&gt; int:
    bar: Any = &#39;hello&#39;
    return bar


result = foo()
print(result)
</code></pre>
<p>In other words, <em>even if</em> your project uses type hints all over the
place <em>and</em> has a checker like mypy in place, your type hints might
<em>still</em> be wrong. <code>foo()</code> does <em>not</em> return an integer.</p>
<p>Mypy has an option to turn this into an error:</p>
<pre><code>$ mypy --warn-return-any foo.py
foo.py:9: error: Returning Any from function declared to return &#34;int&#34;
Found 1 error in 1 file (checked 1 source file)
</code></pre>
<p>I guess they cannot turn this on by default, because, well, the Python
docs say it‚Äôs valid. So, yes, you can somehow avoid this trap, but it
reminds me a lot about having to do things like <code>-pedantic -Wall
-Werror -Wyes-really -Wyeah-i-mean-it --dont-you-listen-to-me</code> in C
projects. Flags like these are problematic because you have to remember
to use them ‚Äì and in new versions of your type checker, you have to make
sure that they didn‚Äôt change their meaning and that they didn‚Äôt
introduce new flags that you really, really should use.</p>
<p>Also, what if some of your code <em>relies</em> on using <code>Any</code>? Python is a
dynamically typed language and it‚Äôs perfectly legal to do these kinds of
things. You will then probably proceed to tell mypy to turn off the
<code>Any</code> checks just for some modules ‚Ä¶ which is a recipe for chaos.</p>
<p>You must also be aware that <code>Any</code> can <em>sneak in through libraries</em>. This
happened to me and it went unnoticed for quite a while. Let‚Äôs take the
example from above again and make it more explicit:</p>
<pre><code>from typing import Any


def an_imported_library_function() -&gt; int:
    bar: Any = &#39;hello&#39;
    return bar


result: int = an_imported_library_function()
print(result, type(result))
</code></pre>
<p>Suppose you look at the documentation for that library: It says it
returns <code>int</code>. You might even glance at the source code and see that <code>-&gt;
int</code>. You make your own variable <code>result</code> an <code>int</code>. Everything screams
<code>int</code>. Mypy does not report any errors by default. And yet, when you run
it, you get this:</p>
<pre><code>$ ./foo.py
hello &lt;class &#39;str&#39;&gt;
</code></pre>
<p>Last but not least, <code>Any</code> lurks in a couple of places. When you write
<code>foo: Dict = {}</code>, it‚Äôs actually <code>foo: Dict[Any, Any] = {}</code>, and boom.</p>
<h2>Duck type compatibility</h2>
<p>Example:</p>
<pre><code>foo: int = 123
bar: float = foo

if isinstance(foo, int):
    print(&#39;foo is an int&#39;)
if isinstance(foo, float):
    print(&#39;foo is a float&#39;)

if isinstance(bar, int):
    print(&#39;bar is an int&#39;)
if isinstance(bar, float):
    print(&#39;bar is a float&#39;)
</code></pre>
<p>Passes validation:</p>
<pre><code>$ mypy --strict numeric.py
Success: no issues found in 1 source file
</code></pre>
<p>Unexpected result:</p>
<pre><code>$ python3 numeric.py
foo is an int
bar is an int
</code></pre>
<p>How can I declare <code>bar</code> as <code>float</code>, but then it accepts an <code>int</code> and
actually is an <code>int</code> at runtime (so it‚Äôs not like it‚Äôs being converted
automatically ‚Äì of course not, the runtime does not care about type
hints)?</p>
<p>The reason is <a href="https://mypy.readthedocs.io/en/latest/duck_type_compatibility.html?highlight=float#duck-type-compatibility">duck type compatibility</a>.</p>
<p>This is <em>probably</em> not a big deal in Python, though. When you divide two
integers, <code>1 / 3</code>, the result is a <code>float</code> and not accidentally an
<code>int</code>, like in some other languages. And luckily this is limited to just
a few built-in types.</p>
<p>And yet ‚Ä¶ It says <code>bar: float</code> but it‚Äôs an <code>int</code>. They could have just
called it <code>number</code>, if it‚Äôs ambiguous anyway.</p>
<h2>Most projects need third-party type hints</h2>
<p>Most Python projects out there pre-date type hints, so they are
completely untyped. The default of mypy is to go ‚Äúü§∑‚Äù and accept
untyped code almost as if it was declared <code>Any</code>. Again, there is an
option to turn on these checks, so this is another thing to know and
remember.</p>
<p>Now, if do you want to make use of type hints when using such libraries,
well, you have to add the hints. <a href="https://github.com/python/typeshed/">typeshed</a> contains hints for a bunch
of popular projects.</p>
<p>I hope you realize what this means: The library itself and its type
hints are <em>out of sync</em>. When mypy does not report any errors for your
code, what does that mean? Do you actually call that library correctly?
Do you really know that now, just because mypy spits out a green line?
Are you sure?</p>
<h2>Sadly, dataclasses ignore type hints as well</h2>
<p>So we were making a client for a REST API. Traditionally, we would have
built <code>dict</code>s and then POSTed them:</p>
<pre><code>payload = {
    &#39;cars&#39;: [
        {
            &#39;name&#39;: &#39;toy yoda&#39;,
            &#39;wheels&#39;: 4,
        },
    ],
    &#39;salad&#39;: &#39;potato&#39;,
    &#39;version&#39;: 8,
}
</code></pre>
<p>Code like this can get really messy really fast. Python 3.7 introduced
<a href="https://docs.python.org/3/library/dataclasses.html">dataclasses</a>. Together with type hints, it might look like this:</p>
<pre><code>from dataclasses import dataclass
from typing import List, Literal


@dataclass
class Car:
    name: str
    wheels: int


@dataclass
class APIRequest:
    cars: List[Car]
    salad: Literal[&#39;potato&#39;, &#39;italian&#39;]
    version: Literal[8]


payload = APIRequest(
    cars=[
        Car(
            name=&#39;toy yoda&#39;,
            wheels=4,
        ),
    ],
    salad=&#39;potato&#39;,
    version=8,
)
</code></pre>
<p>If you now turned <code>wheels=4</code> into <code>wheels=&#39;4&#39;</code>, mypy would report an
error.</p>
<p>I‚Äôd argue that this is better code. Dataclasses and type hints allow the
reader to know how an API request is composed. Looks like it‚Äôs
self-documenting, right?</p>
<p>Of course, writing <code>wheels=&#39;4&#39;</code> can be reported as an error, but how
much of your code handles <em>static</em> data like this? Isn‚Äôt it much more
likely that this <code>&#39;4&#39;</code> is actually a variable? The big question then
becomes where this variable comes from and whether it‚Äôs covered by
(correct) type hints. If it isn‚Äôt (or if it‚Äôs <code>Any</code>), then your build is
green, but your code might be wrong and will fail somewhere down the
road (just as if you didn‚Äôt have type hints in the first place).</p>
<p>It would have been really nice if dataclasses automatically honored
their type hints and raised errors on mismatches.</p>
<p><code>Literal</code> is extra deceptive: It not only states the type of something,
but also declares which contents are allowed. Again, this is not
relevant at runtime. All your type hints can be perfectly fine, but if
you read the string <code>potatu</code> instead of <code>potato</code> from a file or an HTTP
response or whatever, then nothing will ever complain about it.</p>
<p>I‚Äôd still argue that it‚Äôs better to use dataclasses (maybe without type
hints) than to compose chaotic <code>dict</code>s, but this is probably a personal
preference of mine. Many Python programmers praise the language for not
having to use classes like this. People <em>like</em> that they can just throw
around dicts.</p>
<h2>Type inference and lazy programmers</h2>
<p>Consider this:</p>
<pre><code>foo = {
    &#39;hello&#39;: &#39;world&#39;,
    &#39;bar&#39;: [&#39;baz&#39;],
}

foo[&#39;bar&#39;].append(&#39;potato&#39;)

print(foo)
</code></pre>
<p>Since all programmers are as lazy as they can get away with, this code
does not contain any type hints. Most code probably looks like this.
Mypy then has no other choice but to guess what the types must be,
because, well, you want to do type checking, don‚Äôt you?</p>
<p>So, while the code snippet executes just fine:</p>
<pre><code>$ ./bar.py
{&#39;hello&#39;: &#39;world&#39;, &#39;bar&#39;: [&#39;baz&#39;, &#39;potato&#39;]}
</code></pre>
<p>Mypy is not happy with it:</p>
<pre><code>$ mypy bar.py
bar.py:9: error: &#34;Sequence[str]&#34; has no attribute &#34;append&#34;
Found 1 error in 1 file (checked 1 source file)
</code></pre>
<p>The detected type isn‚Äôt wrong per se, because both <code>world</code> and <code>[&#39;baz&#39;,
&#39;potato&#39;]</code> are technically sequences of <code>str</code> (run <code>python -c &#39;for i in
&#34;foo&#34;: print(type(i))&#39;</code> to see it in action). It‚Äôs not quite what the
code intended to say, though, because the latter is clearly supposed to
be a list which indeed has an <code>.append()</code> method.</p>
<p>How do you solve this? The obvious answer is to add the correct hints:</p>
<pre><code>from typing import Dict, List, Union


foo: Dict[str, Union[str, List[str]]] = {
    &#39;hello&#39;: &#39;world&#39;,
    &#39;bar&#39;: [&#39;baz&#39;],
}

foo[&#39;bar&#39;].append(&#39;potato&#39;)

print(foo)
</code></pre>
<p>Now, it ‚Ä¶ wait, it‚Äôs still wrong:</p>
<pre><code>$ mypy bar.py
bar.py:12: error: Item &#34;str&#34; of &#34;Union[str, List[str]]&#34; has no attribute &#34;append&#34;
Found 1 error in 1 file (checked 1 source file)
</code></pre>
<p>Crap, we couldn‚Äôt properly express that only <code>bar</code> is a list and <code>hello</code>
is a string. We now first have to resolve the type ambiguity of this
<code>Union</code>, so that we‚Äôre making sure that what we‚Äôre dealing with really
is a list:</p>
<pre><code>if isinstance(foo[&#39;bar&#39;], list):
    foo[&#39;bar&#39;].append(&#39;potato&#39;)
</code></pre>
<p>Note, though, that this is one of the few instances where I think that
mypy can be <em>beneficial</em>: It tells you that, whoops, you‚Äôre dealing with
something that might not be what you think it is. This is good, this is
what I want to see. It happened a couple of times in our code base and
prevented actual bugs. Great!</p>
<p>Another way might be to used <a href="https://mypy.readthedocs.io/en/stable/more_types.html#typeddict">TypedDict</a>:</p>
<pre><code>from typing import List, TypedDict


TypedFoo = TypedDict(
    &#39;TypedFoo&#39;,
    {
        &#39;hello&#39;: str,
        &#39;bar&#39;: List[str],
    },
)

foo = TypedFoo(
    hello=&#39;world&#39;,
    bar=[&#39;baz&#39;],
)

foo[&#39;bar&#39;].append(&#39;potato&#39;)

print(foo)
</code></pre>
<p>What happens <em>in real life</em>, though, will probably be this:</p>
<pre><code>from typing import Dict


foo: Dict = {
    &#39;hello&#39;: &#39;world&#39;,
    &#39;bar&#39;: [&#39;baz&#39;],
}

foo[&#39;bar&#39;].append(&#39;potato&#39;)

print(foo)
</code></pre>
<p>Now, <code>foo</code> is of type <code>Dict[Any, Any]</code>, the damn tool is happy, the
Python runtime doesn‚Äôt care anyway (your program worked the entire
time), and the lazy programmer can finally close that annoying Jira
ticket. ;-)</p>
<p>See, since <em>good</em> typing isn‚Äôt enforced or even encouraged by this whole
thing, there are many ways to avoid having to deal with types at all, if
you‚Äôre just not in the mood right now. You don‚Äôt even have to do
something along the lines of <code>#pragma disable type_check</code> ‚Äì you can just
throw in some type that‚Äôs probably close enough and then claim: ‚ÄúHey,
look, we got type hints!‚Äù</p>
<p>It requires a lot of discipline and good faith to get those hints right.</p>
<h2>Exceptions are not covered</h2>
<p>Exceptions are out of scope of type hints: You cannot annotate a
function and say, ‚Äúthis might throw a <code>ValueError</code>‚Äù.</p>
<p>This is a bit unfortunate. In Python, exceptions can be very surprising,
because you never know when they are being thrown. In, say, Java,
exceptions are part of a function‚Äôs signature, and this helps a lot.</p>
<h2>What you really want is a compiler, isn‚Äôt it?</h2>
<p>If you‚Äôre a fan of type hints, you should ask yourself that question.</p>
<p>You <em>must</em> run the compiler on your code, you cannot skip that step. It
checks types (and other things) and thus catches <em>a lot</em> of errors in
advance. Do you call that function correctly? Does that object have a
<code>.split()</code> method? Is this variable even defined? Hey, let‚Äôs
auto-generate some meaningful API docs directly from the code, which is
something we can do, because we know that the types are correct, so the
generated HTML files will also be correct. And so on.</p>
<p>It feels really good to see a program compile without warnings or
errors. You then know that you got it right. This is especially true for
Rust, which really doesn‚Äôt let a lot of things slip. (You might get a
little bit of a different experience with C, though.)</p>
<p>And this is the kind of thing that I initially hoped could be
accomplished by using Python‚Äôs type hints, but, sadly, no.</p>
<p><em>Even if</em> the Python runtime did check all the type hints <em>at runtime</em>,
then it would still be too late. I don‚Äôt want a fancy type exception at
runtime. That already exists (most of the time). I want to know about
type mismatches <em>in advance</em>.</p>
<p>What I want is this: Some language that‚Äôs as easy to use as Python and
it should be compiled and with good static typing, but it should also
<em>not</em> be compiled because then it wouldn‚Äôt be as easy to use as Python
anymore. Whoops?</p>
<h2>Still, aren‚Äôt type hints better than nothing?</h2>
<p>This blog post was originally titled ‚ÄúPython‚Äôs Type Hints considered
harmful‚Äù. Whether they are harmful or not depends on the answer to that
question: Isn‚Äôt it better to detect at least <em>some</em> errors than to
detect none at all?</p>
<p>I‚Äôd say: No. Type hints are not binding. You can not be sure that they
are correct. As such, you must always treat them as if they were wrong.
And I think that indeed makes them more harmful then useful. They waste
mental energy when reading code, they create new maintenance burdens,
and they are potentially deceiving: You cannot trust them. There‚Äôs too
much that can go wrong with them and I don‚Äôt think that‚Äôs fixable unless
you make it a new language.</p>
<p>While writing the code examples for this blog post, I had a nagging
feeling at the back of my head: ‚ÄúIs my code even correct?‚Äù Yes, even
just those few lines. We‚Äôre not even talking about <code>Dict[str,
Union[Dict[str, Union[int, str, bool]], List[int]]]</code>, which I have seen
in the wild, even though you could argue that your code shouldn‚Äôt deal
with that stuff in the first place.</p>
<h2>Conclusion</h2>
<p>I like Python. It‚Äôs a nice and easy to use language. And if <code>foo: int</code>
made sure that <code>foo</code> will always be an <code>int</code> and nothing else, then I‚Äôd
be using type hints everywhere. Would that still be Python?</p>


        </div></div>
  </body>
</html>
