<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.appliedscience.studio/articles/array-programming-for-clojurists.html">Original</a>
    <h1>Array Languages for Clojurians (2020)</h1>
    
    <div id="readability-page-1" class="page"><article>

<section>

<p>A discussion in the Clojure data science Zulip led me to Slobodan Blazeski’s enlightening article <a href="http://archive.vector.org.uk/art10500180">Array languages for Lisp programmers</a> in the journal of the British APL Association. He quotes Alan Perlis:</p>

<blockquote>A language that doesn’t affect the way you think about programming is not worth knowing.</blockquote>

<p>As a lisp, Clojure of course qualifies as one such mind-altering substance. (It arguably qualifies again on the basis of its focus on immutability.) But Blazeski’s article points out that array-based languages such as <a href="https://en.wikipedia.org/wiki/J_(programming_language)">J</a>, its predecessor <a href="https://en.wikipedia.org/wiki/APL_(programming_language)">APL</a> (&#34;A Programming Language&#34;), and the proprietary <a href="https://en.wikipedia.org/wiki/Q_(programming_language_from_Kx_Systems)">q</a> are equally mind-expanding. Let’s see what was – and remains – so compelling about the array programming approach to problems, and compare it to Clojure’s approach.</p>

</section>

<section>

<p><h2>Array functions</h2></p>

<p>Array languages make it both simple and easy to work on whole containers the same way as you work on scalars. Let’s look at J first. (Our array programming examples will be one-liners, with the result on the following lines.) We’ll start by adding the scalar 2 to an array of 2, 3, and 4:</p>


<p>The same <code>+</code> operator works on multiple arrays element-wise:</p>



<p>One operator to do both is pretty handy. We can of course replicate each with out-of-the-box Clojure:</p>
<p><code><pre><div><pre><span>(</span><span>map</span> <span>(</span><span>partial</span> <span>+</span> <span>2</span><span>)</span> <span>[</span><span>2</span> <span>3</span> <span>4</span><span>]</span><span>)</span> <span>(</span><span>map</span> <span>+</span> <span>[</span><span>2</span> <span>3</span> <span>4</span><span>]</span> <span>[</span><span>1</span> <span>2</span> <span>3</span><span>]</span><span>)</span>     </pre></div></pre></code></p>

<p>But Clojure’s arithmetic functions lack the number/array polymorphism of J’s <code>+</code>. Let’s use multimethods to achieve precisely that property:</p>
<p><code><pre><div><pre><span>(</span><span>defmulti</span> <span>j+</span>
  <span>(</span><span>fn</span> <span>[</span><span>&amp;</span> <span>args</span><span>]</span>
    <span>(</span><span>cond</span>
      <span>(</span><span>number?</span> <span>(</span><span>first</span> <span>args</span><span>)</span><span>)</span>     <span>:number</span>
      <span>(</span><span>sequential?</span> <span>(</span><span>first</span> <span>args</span><span>)</span><span>)</span> <span>:sequential</span>
      <span>:else</span>                      <span>(</span><span>class</span> <span>(</span><span>first</span> <span>args</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>defmethod</span> <span>j+</span> <span>:number</span>
  <span>[</span><span>n</span> <span>xs</span><span>]</span>
  <span>(</span><span>map</span> <span>(</span><span>partial</span> <span>+</span> <span>n</span><span>)</span> <span>xs</span><span>)</span><span>)</span>

<span>(</span><span>defmethod</span> <span>j+</span> <span>:sequential</span>
  <span>[</span><span>ys</span> <span>xs</span><span>]</span>
  <span>(</span><span>map</span> <span>+</span> <span>xs</span> <span>ys</span><span>)</span><span>)</span>

<span>#_</span> <span>(</span><span>ns-unmap</span> <span>*ns*</span> <span>&#39;</span><span>j+</span><span>)</span></pre></div></pre></code></p>

<p>Now we have one function that can add scalars to vectors or vectors to vectors:</p>
<p><code><pre><div><pre><span>(</span><span>j+</span> <span>2</span> <span>[</span><span>2</span> <span>3</span> <span>4</span><span>]</span><span>)</span>       <span>(</span><span>j+</span> <span>[</span><span>2</span> <span>3</span> <span>4</span><span>]</span> <span>[</span><span>1</span> <span>2</span> <span>3</span><span>]</span><span>)</span> </pre></div></pre></code></p>

<p>I may not need this in my day-to-day, but for some kinds of mathematical programming it is just what you want. Clojurians in that situation often reach for libraries like <a href="https://github.com/mikera/core.matrix">core.matrix</a>, which takes a similar approach.</p>

</section>

<section>

<p><h2>Array-making tools</h2></p>

<p>To work fluently with multidimensional arrays, one needs a way to create them fluidly. J’s <a href="https://code.jsoftware.com/wiki/Vocabulary/idot">integer-sequence-creating</a> operator <code>i.</code> creates pre-populated arrays of arbitrary dimensions:</p>



<p>(And people say lisp is terse.) This operator produces an array of the given shape – 2 rows, 3 columns – and populates it with the incrementing integers from 0. Clojure’s sequence functions make this simple to implement:</p>

<p><code><pre><div><pre><span>(</span><span>defn</span> <span>i-dot</span> <span>[</span><span>n</span> <span>m</span><span>]</span>
  <span>(</span><span>take</span> <span>n</span> <span>(</span><span>partition</span> <span>m</span> <span>(</span><span>range</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>i-dot</span> <span>2</span> <span>3</span><span>)</span>
</pre></div></pre></code></p>

<p>We’re also going to need something to turn a sequence of values into an array (matrix) of some desired shape. For this J has the <code>$</code> operator:</p>



<p>Here’s a fairly slapdash Clojure replication, which we might conceive at the REPL:</p>

<p><code><pre><div><pre><span>(</span><span>take</span> <span>2</span> <span>(</span><span>partition</span> <span>3</span> <span>(</span><span>cycle</span> <span>&#34;abcde&#34;</span><span>)</span><span>)</span><span>)</span>
</pre></div></pre></code></p>

<p>That looks familiar. Because <code>i.</code> is so similar to <code>$</code>, we end up using the same Clojure functions to implement both:</p>

<p><code><pre><div><pre><span>(</span><span>defn</span> <span>shape</span> <span>[</span><span>n</span> <span>m</span> <span>coll</span><span>]</span>
  <span>(</span><span>take</span> <span>n</span> <span>(</span><span>partition</span> <span>m</span> <span>(</span><span>cycle</span> <span>coll</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>shape</span> <span>2</span> <span>3</span> <span>(</span><span>vec</span> <span>&#34;abcde&#34;</span><span>)</span><span>)</span> 
<span>(</span><span>shape</span> <span>5</span> <span>5</span> <span>(</span><span>range</span><span>)</span><span>)</span>
</pre></div></pre></code></p>

</section>


<section>
<p>One might legitimately say that while the Clojure version is both readable and concise, it isn’t optimized for performance the way it could be in an array language. This is a fair point: specialized languages have more leeway to focus their performance optimization efforts. Still, I found it interesting that one array language, IDL, ran into the same performance concern that Clojure did:</p>

<blockquote>[W]hen you have very nested operations with vectors, during each step, IDL might create (possibly large) temporary storage for intermediate results.  For really big data-sets one would have to play tricks to make it allocate a large enough contigious block of memory, or do special declarations, to tell the compiler/evaluator that what it was calculating was just temporary, and will be discarded soon. <cite>–from a <a href="https://groups.google.com/forum/#!topic/comp.lang.lisp/LRT6x5OcrEo">mailing list comment</a> on the original article</cite></blockquote>

<p>This of course is the drawback Rich Hickey encountered with Clojure’s lazy sequences. That doesn’t make lazy sequences bad. They are merely unsuited to one particular set of requirements, suggesting the need for a different tool in that situation. In Clojure’s case this gave rise to transducers, which avoid creating intermediate or cached values by creating a single compound transformation to use in one eager pass over its input. (See <a href="https://clojure.org/guides/faq#transducers_vs_seqs">What are good use cases for transducers?</a>) To me, this demonstrates Clojure’s power as a general-purpose language, able to deal with varying requirements without switching languages just for a particular feature.</p></section>

<section>

<p><h2>Array reducers</h2></p>

<p>The creator of APL and co-creator of J, <a href="https://en.wikipedia.org/wiki/Kenneth_E._Iverson">Kenneth E. Iverson</a>, wrote:</p>

<blockquote>Because my formal education was in mathematics, the fundamental notions in APL have been drawn largely from mathematics.</blockquote>

<p>This suggests that the one- and two-character <a href="https://code.jsoftware.com/wiki/NuVoc">primitives</a> found in Iverson’s languages can find their ancestry in mathematical symbols. We can confirm this by tracing J’s <code>i.</code> back to its predecessor in APL: ⍳ – the actual lowercase Greek letter iota, standing here for &#34;integers&#34;. For instance, one would enter the expression <code>⍳10</code> to generate the first 10 integers.</p>

</section>

<section>
<div><p><img alt="An APL keyboard layout" src="https://www.scannedinavian.com/public/img/800px-APL-keybd2.svg.png" title="An APL keyboard layout"/></p><p>An APL keyboard layout</p></div>

<p>This meant that to program APL required a specialized keyboard, an experience which you can replicate in the browser with <a href="https://tryapl.org/">Try APL</a>. To the modern programmer a bespoke piece of input hardware for a programming language may seem bizarre. But Clojurians should remember that their own Lisp lineage traces back to an entire computer architecture (the <a href="https://en.wikipedia.org/wiki/Lisp_machine">Lisp Machine</a>), including a series of <a href="http://xahlee.info/kbd/lisp_keyboards.html">keyboards</a>, designed around their programming language.</p>


</section>

<section>
<p>With such a close relationship to mathematical notation, it occurs to ask how APL-derived languages represent mathematical functions like the sum (<a href="https://en.wiktionary.org/wiki/%CE%A3">∑</a>) or product (<a href="https://en.wiktionary.org/wiki/%E2%88%8F">∏</a>) of a sequence, which have clear use in array programming. J achieves this with <em>adverbs</em>, which are cleverly designed with more power than an individual symbol for each operation:</p>

<blockquote>An adverb applies to a verb to produce a related verb; thus +\ is the verb “partial sums.” <cite>–K.E. Iverson, <a href="https://www.jsoftware.com/papers/APLPersonalView1.htm">A Personal View of APL</a></cite></blockquote>

<p>That is, J has an entire system of modifying functions to create new ones. For one, element-wise arithmetic operators like the <code>+</code> we replicated earlier transform into array-consuming versions when combined with <code>/</code>:</p>

<p><code><pre><div><pre>+/ 1 2 3 4
10

*/ 5 5 5
125
</pre></div></pre></code></p>

<p>As lispers, we should recognize the power of this approach right away. We solve the same problem with a similarly generalizable solution, higher order functions, which let us reduce over sequential collections any way we like:</p>

<p><code><pre><div><pre><span>(</span><span>reduce</span> <span>+</span> <span>[</span><span>1</span> <span>2</span> <span>3</span> <span>4</span><span>]</span><span>)</span> 
<span>(</span><span>apply</span> <span>*</span> <span>[</span><span>5</span> <span>5</span> <span>5</span><span>]</span><span>)</span> </pre></div></pre></code></p>

<p>Applying J’s adverbed <code>+/</code> to multidimensional arrays causes them to work column-wise. For this next example, remember that <code>i. 2 3</code> returns the equivalent of <code>[[0 1 2] [3 4 5]]</code>.</p>



<p>Once again we can compute this with out-of-the-box Clojure, because our <code>map</code> is variadic on collections:</p>
<p><code><pre><div><pre><span>(</span><span>apply</span> <span>map</span> <span>+</span> <span>(</span><span>shape</span> <span>2</span> <span>3</span><span>)</span><span>)</span> </pre></div></pre></code></p>

<p>I visualize this <code>apply map</code> idiom as &#34;rotating&#34; the sequences by 90 degrees before <a href="https://clojure.org/guides/faq#arg_order">feeding</a> them to the sequence function.</p>

<p>We could also use the <code>j+</code> we defined above, giving us a closer translation:</p>


<p>Adverbs let J solve something like a factorial simply. Consider this J expression, which I find easiest to read right-to-left as &#34;create an array 5 elements long of incrementing integers starting at 0, increment each, and then compute the product of that sequence&#34;:</p>



<p>We can robotically transliterate that to Clojure, piece by piece:</p>

<p><code><pre><div><pre><span>(</span><span>-&gt;&gt;</span> <span>(</span><span>range</span> <span>5</span><span>)</span>                 <span>(</span><span>map</span> <span>(</span><span>partial</span> <span>+</span> <span>1</span><span>)</span><span>)</span>       <span>(</span><span>reduce</span> <span>*</span><span>)</span><span>)</span>          
<span>(</span><span>reduce</span> <span>*</span> <span>(</span><span>j+</span> <span>1</span> <span>(</span><span>range</span> <span>5</span><span>)</span><span>)</span><span>)</span></pre></div></pre></code></p>

<p>But personally I would probably use <code>(reduce * (range 1 6))</code>.</p>
</section>

<section>


<p><h2>Omitting parameters</h2></p>

<p>Another cool feature in q that caught Blazeski’s eye was the ability to omit arguments to a function, like so:</p>

<p><code><pre><div><pre>{x+y+z}⇔{[x;y;z] x+y+z}
</pre></div></pre></code></p>

<p>To be honest, this snippet from Blazeski’s article confused me deeply. The example is a little under-specified; the <a href="https://code.kx.com/q/basics/function-notation/">q docs</a> on this topic can help, but we need to take a brief detour.</p>

<p>Here’s a &#34;signed lambda&#34; function definition-and-invocation in q:</p>

<p><code><pre><div><pre>{[x;y](x*x)+(y*y)+2*x*y}[20;4]
576
</pre></div></pre></code></p>

<p>In Clojure we would write this as</p>

<p><code><pre><div><pre><span>(</span><span>(</span><span>fn</span> <span>[</span><span>x</span> <span>y</span><span>]</span> <span>(</span><span>+</span> <span>(</span><span>*</span> <span>x</span> <span>x</span><span>)</span> <span>(</span><span>*</span> <span>y</span> <span>y</span><span>)</span> <span>(</span><span>*</span> <span>2</span> <span>x</span> <span>y</span><span>)</span><span>)</span><span>)</span> <span>20</span> <span>4</span><span>)</span>
<span>=&gt;</span> <span>576</span></pre></div></pre></code></p>

<p>That is, we define an anonymous function that sums the squares and double of its parameters <code>x</code> and <code>y</code>, and call it with the arguments <code>20</code> and <code>4</code>. The q docs point out that</p>

<blockquote>Functions with 3 or fewer arguments may omit the signature and instead use default argument names x, y and z.</blockquote>

<p>This allows us to rewrite the above more concisely as an &#34;unsigned lambda&#34;, or what Clojurians dub an anonymous function:</p>

<p><code><pre><div><pre>{(x*x)+(y*y)+2*x*y}[20;4]
576
</pre></div></pre></code></p>

<p>It should now be clear that Clojure’s anonymous function syntax provides a more general version of this syntactic sugar:</p>

<p><code><pre><div><pre><span>(</span><span>#</span><span>(</span><span>+</span> <span>(</span><span>*</span> <span>%</span> <span>%</span><span>)</span> <span>(</span><span>*</span> <span>%2</span> <span>%2</span><span>)</span> <span>(</span><span>*</span> <span>2</span> <span>%</span> <span>%2</span><span>)</span><span>)</span> <span>20</span> <span>4</span><span>)</span>
<span>=&gt;</span> <span>576</span></pre></div></pre></code></p>

<p>That is, instead of providing implied arguments up to—but only!—<code>x</code>, <code>y</code>, and <code>z</code>, Clojure provides <code>%</code> and <code>%n</code>. It’s interesting to note the trade-offs of these two approaches: <code>%n</code> is longer, but allows greater variability; <code>xyz</code> may be more readable, but are more likely to conflict with existing names. (I tend to stick to <code>%</code> and avoid <code>%2</code>, <code>%3</code>, and so on unless it’s something obvious like the <code>(compare %2 %1)</code> <a href="https://clojure.org/guides/comparators#_reverse_order">idiom</a>.)</p>
</section>

<section>
<p>Blazeski ported this omitted-arguments feature to Common Lisp using a macro. Clojure already has anonymous function syntax baked in, but if it didn’t, macros and reader literals would give us access to it anyway. This may be useful to remember if you come across a syntactic feature in another language that Clojure doesn’t have. The lesson here is not that Clojure was ahead of the curve (though it was) but that a lisp with macros is endlessly extensible. As Blazeski puts it:</p>

<blockquote>It seems it’s always the same old story. As soon as Lisp integrates the needed utility or invests into a domain-specific language, the advantage of the other language is lost. The big ball of mud is like a warlock, able to steal opponents’ powers while still staying the same.</blockquote>

<p>Clojure avoided the Lisp language family’s &#34;big ball of mud&#34; reputation by building on fresh foundations with a few syntactic extensions and clear, consistent, effective abstractions. But the point stands: it is the superhero that takes on new powers with a touch.</p>
</section>


<section>
<p><h2>A puzzle</h2></p>

<p>The programming world seems to have mostly moved on from arguing language effectiveness on the code golf course. This is truly a blessing, but we’ll make an exception on pedagogical grounds.</p>

<p>The problem is from an undated <a href="http://www.nsl.com/papers/kisntlisp.htm">comp.lang.lisp post</a> extolling the virtues of q’s predecessor K:</p>

<blockquote>We have a list of elements, some are duplicates. We’re
trying to figure out how to find the duplicate elements and increase a
counter value by 1 for each instance of the element found. The list
consists of lists with two elements, the first being the incremental
counter, the second being the string sought. Example:

<p><code><pre><div><pre>((1 &#34;one&#34;) (1 &#34;two&#34;) (1 &#34;three&#34;) (1 &#34;one&#34;) (1 &#34;four&#34;) (1 &#34;two&#34;))</pre></div></pre></code></p>

The result should be:
 
<p><code><pre><div><pre>((2 &#34;one&#34;) (2 &#34;two&#34;) (1 &#34;three&#34;) (1 &#34;four&#34;))</pre></div></pre></code></p></blockquote>

<p>The array programming solution is impressively concise, and quite readable. <code>v</code> is the input value:</p>

<p><code><pre><div><pre>count:flip(count each group v[;1];unique v[;1])</pre></div></pre></code></p>

<p>I won’t repeat the Common Lisp solutions here; they’re fine for what they are. But the problem is ill-formed. One could solve it as-is, with <code>v</code> as the input value again:</p>

<p><code><pre><div><pre><span>(</span><span>reduce</span> <span>(</span><span>fn</span> <span>[</span><span>acc</span> <span>[</span><span>s</span> <span>xs</span><span>]</span><span>]</span>
          <span>(</span><span>cons</span> <span>(</span><span>list</span> <span>(</span><span>count</span> <span>xs</span><span>)</span> <span>s</span><span>)</span> <span>acc</span><span>)</span><span>)</span>
        <span>(</span><span>list</span><span>)</span>
     <span>(</span><span>group-by</span> <span>second</span> <span>v</span><span>)</span><span>)</span>
</pre></div></pre></code></p>

<p>But we should look a little askance at such an answer, as programmers but especially as Clojurians. It works, but what problem is it really solving? Sifting out the true problem from someone’s stated requirements is a vital skill. We should ignore the crufty half-solution implied in the problem statement and solve the true, hidden task:</p>

<p><code><pre><div><pre><span>(</span><span>frequencies</span> <span>[</span><span>&#34;one&#34;</span> <span>&#34;two&#34;</span> <span>&#34;three&#34;</span> <span>&#34;one&#34;</span> <span>&#34;four&#34;</span> <span>&#34;two&#34;</span><span>]</span><span>)</span>
</pre></div></pre></code></p>

<p>Delightful simplicity from the right data structure and a well-designed standard library.</p>
</section>

<section>

<p><h2>Parsing identifiers</h2></p>

<p>We’ve already explored most of the benefits of array languages: concision, functions which change according to input or adverbs, and &#34;the opportunities opened by thinking at the higher level of container abstraction.&#34; We’ll finish with one more translation exercise:</p>

<blockquote>This piece of [Haskell] code goes through a parse tree of Haskell source code, locates every reference to an identifier that ends with Widget, puts it on a list, and removes duplicates so every identifier is represented in the list only once.</blockquote>

<p>In Haskell:</p>
<p><code><pre><div><pre>extractWidgets :: (Data a) =&gt; a -&gt; [String]
extractWidgets = nub . map (\(HsIdent a)-&gt;a) . listify isWidget
  where isWidget (HsIdent actionName)
      | &#34;Widget&#34; `isSuffixOf` actionName = True
    isWidget _ = False
</pre></div></pre></code></p>

<p>q:</p>
<p><code><pre><div><pre>a:distinct raze over x
a where a like &#34;*Widget&#34;
</pre></div></pre></code></p>

<p>Lisp:</p>
<p><code><pre><div><pre>(defun widgets (l)
  (unique (keep (f like x &#34;*Widget&#34;) (flatten l))))
</pre></div></pre></code></p>

<p>Clojure:</p>
<p><code><pre><div><pre><span>(</span><span>defn</span> <span>widgets</span> <span>[</span><span>tree</span><span>]</span>
  <span>(</span><span>distinct</span> <span>(</span><span>filter</span> <span>#</span><span>(</span><span>string/ends-with?</span> <span>%</span> <span>&#34;Widget&#34;</span><span>)</span>
                    <span>(</span><span>flatten</span> <span>tree</span><span>)</span><span>)</span><span>)</span><span>)</span></pre></div></pre></code></p>
<p>Take it for a test drive:</p>
<p><code><pre><div><pre><span>(</span><span>widgets</span> <span>&#39;</span><span>(</span><span>abcWidget</span> <span>foo</span> <span>(</span><span>abcWidget</span> <span>bar</span> <span>abcWidget</span> <span>defWidget</span><span>)</span>
                     <span>(</span><span>baz</span> <span>abcWidget</span> <span>defWidget</span><span>)</span>
                     <span>(</span><span>qrsWidget</span> <span>tuvWidget</span><span>)</span>
                     <span>(</span><span>qrsWidget</span> <span>xyzWidget</span><span>)</span><span>)</span><span>)</span>
</pre></div></pre></code></p>

<p>It’s nice to travel: try the food, learn a few phrases, visit their monuments. It shows us how strongly history molds a culture, and how differently lives can be lived. We visit other programming language communities to broaden our horizons and remind ourselves that other sometimes folks have different tools for different needs, and sometimes they have the same needs and the same tools, only under a different set of names.</p>
</section>
<p>— <em>Dave Liepmann</em>, 04 May 2020</p></article></div>
  </body>
</html>
