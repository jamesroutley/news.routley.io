<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.lohr.dev/embedded-rust">Original</a>
    <h1>Embedded Rust in Production?</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content-parent"><div id="post-content-wrapper"><p>When I mention that we use Rust on the embedded ESP32 platform the most common reaction is a jaw-dropping &#34;This is possible?!&#34;. Yes, it is indeed possible! - And we at STABL Energy have used it successfully for over a year now. And because so many people seem interested in why we use Rust and how it is going for us, I decided to write this blog post.</p>
<blockquote>
<p>&#34;Thanks to its direct access to both hardware and memory, Rust is well suited for embedded systems and bare-metal development.&#34; - <a target="_blank" href="https://github.blog/2023-08-30-why-rust-is-the-most-admired-language-among-developers/">GitHub</a></p>
</blockquote>
<p>It all started in 2022, with me getting annoyed by our C implementation of a small piece of software running on an ESP32 (a microcontroller with built-in internet connectivity). The purpose of the software was to read messages via UART (serial interface/protocol, often used to communicate between embedded devices) and send them to some cloud services via MQTT (messaging protocol, often used to communicate between IoT devices). Seems simple enough, right? Well, we had some additional requirements in terms of reliability, regarding the layout of the resulting JSON MQTT messages and concerning the content of the UART messages which is rather difficult to parse.</p>
<p>To give you some more context: I work for a startup named <a target="_blank" href="https://stabl.com/?ref=ml-blog">STABL Energy</a> where we build revolutionary energy storage systems, that are based on second-life batteries (batteries that were used in electric cars before). Instead of recycling them just now, we can use those perfectly fine batteries to (for example) back large PV farms and prolong their lives just a little bit more. The device I was talking about before is used to connect our battery storage systems to the cloud for monitoring and remote control. We also use it during development, to test new features in our system - so it really needs to be reliable, because we don&#39;t want to lose any data.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1706812711815/53a4d26a-2e21-486c-b052-245e017cd584.png?auto=compress,format&amp;format=webp" alt=""/></p>
<p>Our C implementation was a small (very prototype) software running on the <a target="_blank" href="https://www.espressif.com/en/products/socs/esp32">ESP32</a> platform. It had some serious runtime issues, preventing it from working reliably, that were hard to debug. And debugging on embedded is a lot more complicated than debugging software targeting desktop architectures. I have much respect for C (and even more for people programming in C), but I think its era is coming to an end. As I wrote in <a target="_blank" href="https://blog.lohr.dev/after-a-day-of-programming-in-zig">a previous blog post</a>, Zig could be a quite good modern replacement in the future. But Zig is rather new and at the time we worked with the C implementation, I didn&#39;t even know that Zig existed. However, I did a lot with Rust in personal projects at that time. The developer experience in Rust is just on the next level and the software you write is reliable without giving reliability, memory allocation etc. too much thought in the first place.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1706813402492/571c6001-33b8-4c77-a2d8-ec6cc95bd21c.webp?auto=compress,format&amp;format=webp" alt=""/></p>
<p>At STABL Energy, we didn&#39;t use any Rust before. We mainly used C for embedded and Python for anything else. But since I got to lead this project and had a great time with Rust, we ended up writing a prototype using <a target="_blank" href="https://esp-rs.github.io/book/overview/using-the-standard-library.html">ESP IDF</a>, which even allowed us to use the Rust standard library. Long story short: Our Rust prototype ended up much more reliable than the C implementation. We spent a little bit more time writing the software (Rust takes longer to write than C) to achieve the same functionality but spent basically zero time debugging (since there weren&#39;t that many bugs) - so we stuck with it. At that time the Rust support from Espressif (the company behind the ESP32) was rather new and experimental (and it still is), but it kept improving and we noticed quite the investment from Espressif in terms of work spent working on Rust support for their platform.</p>
<p>Fast forward to 2024: We now used the ESP32 with our custom software written in Rust for over a year in production, with great success. The devices transmit data 24/7 and we have no known bugs (I don&#39;t even remember the last bug we had). There is just one problem: Who maintains and further develops this project? While there are some pretty passionate Rust developers (&amp; consultancies) out there (even in Germany) and even more that would be willing to learn Rust, it is not viable to hire one sole Rust developer for this (small) project. Since Rust, and especially embedded Rust (lots of FFI &amp; unsafe), is quite hard to learn, it is not viable (for us) to retrain a C developer to Rust. Luckily we <a target="_blank" href="https://github.com/Shemnei/">found a Rust developer</a> who was willing to learn C as well.</p>
<p>So what&#39;s the state of embedded Rust outside of our small project? Dion, from Tweedegolf, recently published <a target="_blank" href="https://tweedegolf.nl/en/blog/101/are-we-embedded-yet">a great article</a> about the current state: He says that what works and does not work heavily depends on the specific use case and willingness to build the missing pieces yourself or rely on open-source software. There are still some rough edges, as visualised in his infographic, but overall Rust is a viable programming language choice for embedded projects.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1706813382842/c04013ce-7a07-4e46-9bec-71c8d45b3ad7.png?auto=compress,format&amp;format=webp" alt="The state of embedded Rust by https://tweedegolf.nl/en/blog/101/are-we-embedded-yet"/></p>
<p>If, in the future, I were faced with a choice between C and Rust for embedded development again, I would most likely choose Rust because of how successfully we used it in the past. Let me know if you heard about some similar projects - I am always excited to hear about embedded Rust!</p>
</div></div></div>
  </body>
</html>
