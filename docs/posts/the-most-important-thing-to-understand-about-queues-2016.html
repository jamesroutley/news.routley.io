<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.danslimmon.com/2016/08/26/the-most-important-thing-to-understand-about-queues/">Original</a>
    <h1>The most important thing to understand about queues (2016)</h1>
    
    <div id="readability-page-1" class="page"><article id="post-1064">
	<div>
		<!-- .entry-header -->

		<div>
			<p>You only need to learn a little bit of queueing theory before you start getting that ecstatic “everything is connected!” high that good math always evokes. So many damn things follow the same set of abstract rules. Queueing theory lets you reason effectively about an enormous class of diverse systems, all with a tiny number of theorems.</p>
<p>I want to share with you the most important fundamental fact I have learned about queues. It’s counterintuitive, but once you understand it, you’ll have deeper insight into the behavior not just of CPUs and database thread pools, but also grocery store checkout lines, ticket queues, highways – really just a mind-blowing collection of systems.</p>
<p>Okay. Here’s the Important Thing:</p>
<p><strong>As you approach maximum throughput, average queue size – and therefore average wait time – approaches infinity.</strong></p>
<p>“Wat,” you say? Let’s break it down.</p>

<p>A queueing is exactly what you think it is: a processor that processes tasks whenever they’re available, and a queue that holds tasks until the processor is ready to process them. When a task is processed, it leaves the system.</p>
<figure data-shortcode="caption" id="attachment_1158" aria-describedby="caption-attachment-1158"><img loading="lazy" data-attachment-id="1158" data-permalink="https://blog.danslimmon.com/2016/08/26/the-most-important-thing-to-understand-about-queues/queue_basic/" data-orig-file="https://danslimmon.files.wordpress.com/2016/08/queue_basic.gif" data-orig-size="640,256" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="queue_basic" data-image-description="" data-image-caption="" data-medium-file="https://danslimmon.files.wordpress.com/2016/08/queue_basic.gif?w=300" data-large-file="https://danslimmon.files.wordpress.com/2016/08/queue_basic.gif?w=640" src="https://danslimmon.files.wordpress.com/2016/08/queue_basic.gif?w=640&amp;h=256" alt="queue_basic" width="640" height="256"/><figcaption id="caption-attachment-1158">A queueing system with a single queue and a single processor. Tasks (yellow circles) arrive at random intervals and take different amounts of time to process.</figcaption></figure>
<p>The Important Thing I stated above applies to a specific type of queue called an <span><a href="https://en.wikipedia.org/wiki/M/M/1_queue">M/M/1/∞ queue</a></span>. That blob of letters and numbers and symbols is a description in <span><a href="https://en.wikipedia.org/wiki/Kendall%27s_notation">Kendall’s notation</a></span>. I won’t go into the M/M/1 part, as it doesn’t really end up affecting the Important Thing I’m telling you about. What <em>does</em> matter, however, is that ‘∞’.</p>
<p>The ‘∞’ in “M/M/1/∞” means that the queue is <strong>unbounded</strong>. There’s no limit to the number of tasks that can be waiting in the queue at any given time.</p>
<p>Like most infinities, this doesn’t reflect any real-world situation. It would be like a grocery store with infinite waiting space, or an I/O scheduler that can queue infinitely many operations. But really, all we’re saying with this ‘∞’ is that the system under study never hits its maximum occupancy.</p>

<p>The processor (or processors) of a queueing system have a given total <strong>capacity</strong>. Capacity is the number of tasks per unit time that can be processed. For an I/O scheduler, the capacity might be measured in IOPS (I/O operations per second). For a ticket queue, it might be measured in tickets per sprint.</p>
<p>Consider a simple queueing system with a single processor, like the one depicted in the GIF above. If, on average, 50% of the system’s capacity is in use, that means that the processor is working on a task 50% of the time. At 0% utilization, no tasks are ever processed. At 100% utilization, the processor is <em>always</em> busy.</p>
<p>Let’s think about 100% utilization a bit more. Imagine a server with all 4 of its CPUs constantly crunching numbers, or a dev team that’s working on high-priority tickets every hour of the day. Or a devOp who’s so busy putting out fires that he never has time to blog.</p>
<p>When a system has steady-state 100% utilization, its queue will grow to infinity. It might shrink over short time scales, but over a sufficiently long time it will grow without bound.</p>
<p>Why is that?</p>
<p>If the processor is always busy, that means there’s never even an <em>instant</em> when a newly arriving task can be assigned immediately to the processor. That means that, whenever a task finishes processing, there must always be a task waiting in the queue; otherwise the processor would have an idle moment. And by induction, we can show that a system that’s forever at 100% utilization will exceed any finite queue size you care to pick:</p>
<figure data-shortcode="caption" id="attachment_1227" aria-describedby="caption-attachment-1227"><img loading="lazy" data-attachment-id="1227" data-permalink="https://blog.danslimmon.com/2016/08/26/the-most-important-thing-to-understand-about-queues/no_good_0/" data-orig-file="https://danslimmon.files.wordpress.com/2016/08/no_good_0.png" data-orig-size="640,256" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="no_good_0" data-image-description="" data-image-caption="" data-medium-file="https://danslimmon.files.wordpress.com/2016/08/no_good_0.png?w=300" data-large-file="https://danslimmon.files.wordpress.com/2016/08/no_good_0.png?w=640" src="https://danslimmon.files.wordpress.com/2016/08/no_good_0.png?w=640&amp;h=256" alt="no_good_0" width="640" height="256" srcset="https://danslimmon.files.wordpress.com/2016/08/no_good_0.png 640w, https://danslimmon.files.wordpress.com/2016/08/no_good_0.png?w=150&amp;h=60 150w, https://danslimmon.files.wordpress.com/2016/08/no_good_0.png?w=300&amp;h=120 300w" sizes="(max-width: 640px) 100vw, 640px"/><figcaption id="caption-attachment-1227">No good. Processor idle, so utilization can’t be 100%.</figcaption></figure>
<figure data-shortcode="caption" id="attachment_1229" aria-describedby="caption-attachment-1229"><img loading="lazy" data-attachment-id="1229" data-permalink="https://blog.danslimmon.com/2016/08/26/the-most-important-thing-to-understand-about-queues/no_good_1/" data-orig-file="https://danslimmon.files.wordpress.com/2016/08/no_good_1.png" data-orig-size="640,256" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="no_good_1" data-image-description="" data-image-caption="" data-medium-file="https://danslimmon.files.wordpress.com/2016/08/no_good_1.png?w=300" data-large-file="https://danslimmon.files.wordpress.com/2016/08/no_good_1.png?w=640" src="https://danslimmon.files.wordpress.com/2016/08/no_good_1.png?w=640&amp;h=256" alt="no_good_1.png" width="640" height="256" srcset="https://danslimmon.files.wordpress.com/2016/08/no_good_1.png 640w, https://danslimmon.files.wordpress.com/2016/08/no_good_1.png?w=150&amp;h=60 150w, https://danslimmon.files.wordpress.com/2016/08/no_good_1.png?w=300&amp;h=120 300w" sizes="(max-width: 640px) 100vw, 640px"/><figcaption id="caption-attachment-1229">No good. As soon as the task finishes, we’re back to the above picture.</figcaption></figure>
<figure data-shortcode="caption" id="attachment_1231" aria-describedby="caption-attachment-1231"><img loading="lazy" data-attachment-id="1231" data-permalink="https://blog.danslimmon.com/2016/08/26/the-most-important-thing-to-understand-about-queues/no_good_2/" data-orig-file="https://danslimmon.files.wordpress.com/2016/08/no_good_2.png" data-orig-size="640,256" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="no_good_2" data-image-description="" data-image-caption="" data-medium-file="https://danslimmon.files.wordpress.com/2016/08/no_good_2.png?w=300" data-large-file="https://danslimmon.files.wordpress.com/2016/08/no_good_2.png?w=640" src="https://danslimmon.files.wordpress.com/2016/08/no_good_2.png?w=640&amp;h=256" alt="no_good_2.png" width="640" height="256" srcset="https://danslimmon.files.wordpress.com/2016/08/no_good_2.png 640w, https://danslimmon.files.wordpress.com/2016/08/no_good_2.png?w=150&amp;h=60 150w, https://danslimmon.files.wordpress.com/2016/08/no_good_2.png?w=300&amp;h=120 300w" sizes="(max-width: 640px) 100vw, 640px"/><figcaption id="caption-attachment-1231">No good. As soon as the current task finishes, we’re back to the above picture, which we’ve already decided is no good.</figcaption></figure>
<figure data-shortcode="caption" id="attachment_1232" aria-describedby="caption-attachment-1232"><img loading="lazy" data-attachment-id="1232" data-permalink="https://blog.danslimmon.com/2016/08/26/the-most-important-thing-to-understand-about-queues/no_good_3/" data-orig-file="https://danslimmon.files.wordpress.com/2016/08/no_good_3.png" data-orig-size="640,256" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="no_good_3" data-image-description="" data-image-caption="" data-medium-file="https://danslimmon.files.wordpress.com/2016/08/no_good_3.png?w=300" data-large-file="https://danslimmon.files.wordpress.com/2016/08/no_good_3.png?w=640" src="https://danslimmon.files.wordpress.com/2016/08/no_good_3.png?w=640&amp;h=256" alt="no_good_3.png" width="640" height="256" srcset="https://danslimmon.files.wordpress.com/2016/08/no_good_3.png 640w, https://danslimmon.files.wordpress.com/2016/08/no_good_3.png?w=150&amp;h=60 150w, https://danslimmon.files.wordpress.com/2016/08/no_good_3.png?w=300&amp;h=120 300w" sizes="(max-width: 640px) 100vw, 640px"/><figcaption id="caption-attachment-1232">You get the idea.</figcaption></figure>
<p>So basically, the statements “average capacity utilization is 100%” and “the queue size is growing without bound” are equivalent. And remember: by <span><a href="https://en.wikipedia.org/wiki/Little%27s_law">Little’s Law</a></span>, we know that average service time is directly proportional to queue size. That means that a queueing system with 100% average capacity utilization will have wait times that grow without bound.</p>
<p>If all the developers on a team are constantly working on critical tickets, then the time it takes to complete tickets in the queue will approach infinity. If all the CPUs on a server are constantly grinding, load average will climb and climb. And so on.</p>
<p>Now you may be saying to yourself, “100% capacity utilization is a purely theoretical construct. There’s always some amount of idle capacity, so queues will never grow toward infinity forever.” And you’re right. But you might be surprised at how quickly things start to look ugly as you get closer to maximum throughput.</p>

<p>The problems start well before you get to 100% utilization. Why?</p>
<p>Sometimes a bunch of tasks will just happen to show up at the same time. These tasks will get queued up. If there’s not much capacity available to crunch through that backlog, then it’ll probably still be around when the next random bunch of tasks show up. The queue will just keep getting longer until there happens to be along enough period of low activity to clear it out.</p>
<p>I ran a <span><a href="https://github.com/danslimmon/qsim">qsim</a></span> simulation to illustrate this point. It simulates a single queue that can process, on average, one task per second. I ran the simulation for a range of arrival rates to get different average capacity usages. (For the wonks: I used a Poisson arrival process and exponentially distributed processing times). Here’s the plot:</p>
<p><img data-attachment-id="1287" data-permalink="https://blog.danslimmon.com/2016/08/26/the-most-important-thing-to-understand-about-queues/without_extreme/" data-orig-file="https://danslimmon.files.wordpress.com/2016/08/without_extreme.png" data-orig-size="1071,405" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="without_extreme" data-image-description="" data-image-caption="" data-medium-file="https://danslimmon.files.wordpress.com/2016/08/without_extreme.png?w=300" data-large-file="https://danslimmon.files.wordpress.com/2016/08/without_extreme.png?w=640" src="https://danslimmon.files.wordpress.com/2016/08/without_extreme.png?w=640" alt="without_extreme" srcset="https://danslimmon.files.wordpress.com/2016/08/without_extreme.png?w=640 640w, https://danslimmon.files.wordpress.com/2016/08/without_extreme.png?w=150 150w, https://danslimmon.files.wordpress.com/2016/08/without_extreme.png?w=300 300w, https://danslimmon.files.wordpress.com/2016/08/without_extreme.png?w=768 768w, https://danslimmon.files.wordpress.com/2016/08/without_extreme.png?w=1024 1024w, https://danslimmon.files.wordpress.com/2016/08/without_extreme.png 1071w" sizes="(max-width: 640px) 100vw, 640px"/></p>
<p>Notice how things start to get a little crazy around 80% utilization. By the time you reach 96% utilization (the rightmost point on the plot), average wait times are already 20 seconds. And what if you go further and run at 99.8% utilization?</p>
<p><img data-attachment-id="1288" data-permalink="https://blog.danslimmon.com/2016/08/26/the-most-important-thing-to-understand-about-queues/with_extreme/" data-orig-file="https://danslimmon.files.wordpress.com/2016/08/with_extreme.png" data-orig-size="1071,405" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="with_extreme" data-image-description="" data-image-caption="" data-medium-file="https://danslimmon.files.wordpress.com/2016/08/with_extreme.png?w=300" data-large-file="https://danslimmon.files.wordpress.com/2016/08/with_extreme.png?w=640" src="https://danslimmon.files.wordpress.com/2016/08/with_extreme.png?w=640" alt="with_extreme" srcset="https://danslimmon.files.wordpress.com/2016/08/with_extreme.png?w=640 640w, https://danslimmon.files.wordpress.com/2016/08/with_extreme.png?w=150 150w, https://danslimmon.files.wordpress.com/2016/08/with_extreme.png?w=300 300w, https://danslimmon.files.wordpress.com/2016/08/with_extreme.png?w=768 768w, https://danslimmon.files.wordpress.com/2016/08/with_extreme.png?w=1024 1024w, https://danslimmon.files.wordpress.com/2016/08/with_extreme.png 1071w" sizes="(max-width: 640px) 100vw, 640px"/></p>
<p>Check out that Y axis. Crazy. You don’t want any part of that.</p>
<p>This is why <span><a href="https://danslimmon.wordpress.com/2015/07/09/when-efficiency-hurts-more-than-it-helps/">overworked engineering teams get into death spirals</a><span>. It’s also why, when you finally log in to that server that’s been slow as a dog, you’ll sometimes find that it has a load average of like 500. Queues are everywhere.</span></span></p>

<p>To reiterate:</p>
<p><strong>As you approach maximum throughput, average queue size – and therefore average wait time – approaches infinity.</strong></p>
<p>What’s the solution, then? We only have so many variables to work with in a queueing system. Any solution for the exploding-queue-size problem is going to involve some combination of these three approaches:</p>
<ol>
<li>Increase capacity</li>
<li>Decrease demand</li>
<li>Set an upper bound for the queue size</li>
</ol>
<p>I like number 3. It forces you to acknowledge the fact that queue size is <em>always</em> finite, and to think through the failure modes that a full queue will engender.</p>
<p>Stay tuned for a forthcoming blog post in which I’ll examine some of the common methods for dealing with this property of queueing systems. Until then, I hope I’ve helped you understand a very important truth about many of the systems you encounter on a daily basis.</p>
					</div><!-- .entry-content -->

		<!-- .entry-footer -->
	</div>
</article></div>
  </body>
</html>
