<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hwisnu.bearblog.dev/giving-c-a-superpower-custom-header-file-safe_ch/">Original</a>
    <h1>Giving C a Superpower</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    

    
        

        <p>
            <i>
                <time datetime="2025-11-09T15:47Z">
    09 Nov, 2025
</time>
            </i>
        </p>
    

    <p><em>The story of how I wrote a leak-free, thread-safe grep in C23 without shooting yourself in the foot, and how you can too!</em></p>
<p>Let&#39;s be honest: most people have a love-hate relationship with C. We love its raw speed, its direct connection to the metal, and its elegant simplicity. But we hate its footguns, its dragons, the untamed beasts. The segfaults that appear from nowhere, the memory leaks that slowly drain the life from our applications, and the endless goto cleanup; chains that make our code look like a plate of spaghetti pasta.</p>
<p>This is the classic C curse: power without guardrails...at least that&#39;s the <em>fear mongering mantra</em> being said again and again. But is that still relevant in today&#39;s world with all the tools available for C devs like static analyzer and dynamic sanitizers? I&#39;ve written about this <a href="https://hwisnu.bearblog.dev/make-c-safe-again/" target="_blank">here</a> and <a href="https://hwisnu.bearblog.dev/debunking-the-unsafe-c-myths-part-2/" target="_blank">here</a>.</p>
<p>What if, with the help of the modern tools and a custom header file (600 loc), you could tame those footguns beasts? What if you could keep C&#39;s power but wrap it in a suit of modern armor? That&#39;s what the custom header file safe_c.h is for. It&#39;s designed to give C some <mark>safety and convenience features from C++ and Rust</mark>, and I&#39;m using it to build a high-performance grep clone called cgrep as my test case.</p>
<p>By the end this article I hope it could provide the audience with the idea of C is super flexible and extensible, sort of <em>&#34;do whatever you want with it&#34;</em> kind of thing. And this is why C (and its close cousin: Zig) remain to be my favorite language to write programs in; it&#39;s the language of freedom!</p>
<p>Is a custom C header file that takes features mainly from C++ and Rust and implements them into our C code ~ [write C code, get C++ and Rust features!]</p>
<p>It starts by bridging the gap between old and new C. C23 gave us <code>[[cleanup]]</code> attributes, but in the real world, you need code that compiles on GCC 11 or Clang 18. safe_c.h detects your compiler and gives you the same RAII semantics everywhere. No more <code>#ifdef</code> soup.</p>
<div><pre><span></span>// The magic behind CLEANUP: zero overhead, maximum safety
#if defined(__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 202311L
#define CLEANUP(func) [[cleanup(func)]]
#else
#define CLEANUP(func) __attribute__((cleanup(func)))
#endif

// Branch prediction that actually matters in hot paths
#ifdef __GNUC__
#define LIKELY(x)   __builtin_expect(!!(x), 1)
#define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#define LIKELY(x)   (x)
#define UNLIKELY(x) (x)
#endif
</pre></div>
<p>Your cleanup code runs even if you return early, goto out, or panic. It&#39;s <code>finally</code>, but for C.</p>
<h2 id="the-memory-management-beast-slain-with-smart-pointers-c-feature">The Memory Management Beast: Slain with Smart Pointers (C++ feature)</h2><p>The oldest, fiercest and most feared by devs: manual memory management.</p>
<p>Before: the highway path to leaks.</p>
<div><pre><span></span><span>// The Old Way (don&#39;t do this)</span>
<span>char</span><span>*</span><span> </span><span>include_pattern</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span>
<span>if</span><span> </span><span>(</span><span>optarg</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>include_pattern</span><span> </span><span>=</span><span> </span><span>strdup</span><span>(</span><span>optarg</span><span>);</span>
<span>}</span>
<span>// ...200 lines later...</span>
<span>if</span><span> </span><span>(</span><span>some_error</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>(</span><span>include_pattern</span><span>)</span><span> </span><span>free</span><span>(</span><span>include_pattern</span><span>);</span><span> </span><span>// Did I free it? Did I??</span>
<span>    </span><span>return</span><span> </span><span>1</span><span>;</span>
<span>}</span>
<span>// And remember to free it at *every* return path...</span>
</pre></div>
<p>After: memory that <strong>automatically</strong> cleans itself up.</p>
<p>Here&#39;s the machinery inside <code>safe_c.h</code>:</p>
<div><pre><span></span>// The UniquePtr machinery: a struct + automatic cleanup
typedef struct {
    void* ptr;
    void (*deleter)(void*);
} UniquePtr;

#define AUTO_UNIQUE_PTR(name, ptr, deleter) \
    UniquePtr name CLEANUP(unique_ptr_cleanup) = UNIQUE_PTR_INIT(ptr, deleter)

static inline void unique_ptr_cleanup(UniquePtr* uptr) {
    if (uptr &amp;&amp; uptr-&gt;ptr &amp;&amp; uptr-&gt;deleter) {
        uptr-&gt;deleter(uptr-&gt;ptr);
        uptr-&gt;ptr = NULL;
    }
}
</pre></div>
<p>And here&#39;s how cgrep uses it. The cleanup is automatic, even if errors happen:</p>
<div><pre><span></span><span>// In cgrep, we use this for command-line arguments</span>
<span>AUTO_UNIQUE_PTR</span><span>(</span><span>include_pattern_ptr</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>options_string_deleter</span><span>);</span>

<span>// When we get a new pattern, the old one is automatically freed!</span>
<span>unique_ptr_delete</span><span>(</span><span>&amp;</span><span>include_pattern_ptr</span><span>);</span>
<span>include_pattern_ptr</span><span>.</span><span>ptr</span><span> </span><span>=</span><span> </span><span>strdup</span><span>(</span><span>optarg</span><span>);</span>
<span>// No leaks, even if an error happens later!</span>
</pre></div>
<p><strong>Sharing Safely with SharedPtr</strong></p>
<p>Before: manual, bug-prone reference counting.</p>
<div><pre><span></span><span>// The old way of manual reference counting</span>
<span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>MatchStore</span><span>*</span><span> </span><span>store</span><span>;</span>
<span>    </span><span>int</span><span> </span><span>ref_count</span><span>;</span>
<span>    </span><span>pthread_mutex_t</span><span> </span><span>mutex</span><span>;</span>
<span>}</span><span> </span><span>SharedStore</span><span>;</span>

<span>void</span><span> </span><span>release_store</span><span>(</span><span>SharedStore</span><span>*</span><span> </span><span>s</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>pthread_mutex_lock</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>mutex</span><span>);</span>
<span>    </span><span>s</span><span>-&gt;</span><span>ref_count</span><span>--</span><span>;</span>
<span>    </span><span>bool</span><span> </span><span>is_last</span><span> </span><span>=</span><span> </span><span>(</span><span>s</span><span>-&gt;</span><span>ref_count</span><span> </span><span>==</span><span> </span><span>0</span><span>);</span>
<span>    </span><span>pthread_mutex_unlock</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>mutex</span><span>);</span>

<span>    </span><span>if</span><span> </span><span>(</span><span>is_last</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>match_store_deleter</span><span>(</span><span>s</span><span>-&gt;</span><span>store</span><span>);</span>
<span>        </span><span>free</span><span>(</span><span>s</span><span>);</span>
<span>    </span><span>}</span>
<span>}</span>
</pre></div>
<p>After: automated reference counting.</p>
<div><pre><span></span>// The SharedPtr machinery: reference counting without the boilerplate
typedef struct {
    void* ptr;
    void (*deleter)(void*);
    size_t* ref_count;
} SharedPtr;

#define AUTO_SHARED_PTR(name) \
    SharedPtr name CLEANUP(shared_ptr_cleanup) = {.ptr = NULL, .deleter = NULL, .ref_count = NULL}

static inline void shared_ptr_cleanup(SharedPtr* sptr) {
    shared_ptr_delete(sptr); // Decrement and free if last reference
}
</pre></div>
<p>The usage is clean and safe. No more manual counting.</p>
<div><pre><span></span><span>// In our thread worker context, multiple threads access the same results store</span>
<span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>// ...</span>
<span>    </span><span>SharedPtr</span><span> </span><span>store</span><span>;</span><span>  </span><span>// No more worrying about who frees this!</span>
<span>    </span><span>SharedPtr</span><span> </span><span>file_counts</span><span>;</span>
<span>    </span><span>// ...</span>
<span>}</span><span> </span><span>FileWorkerContext</span><span>;</span>

<span>// In main(), we create it once and share it safely</span>
<span>// SharedPtr: Reference-counted stores for thread-safe sharing</span>
<span>SharedPtr</span><span> </span><span>store_shared</span><span> </span><span>=</span><span> </span><span>{</span><span>0</span><span>};</span>
<span>shared_ptr_init</span><span>(</span><span>&amp;</span><span>store_shared</span><span>,</span><span> </span><span>store_ptr</span><span>.</span><span>ptr</span><span>,</span><span> </span><span>match_store_deleter</span><span>);</span>
<span>// Pass to threads: ctx-&gt;store = shared_ptr_copy(&amp;store_shared);</span>
<span>// ref-count increments automatically; last thread out frees it.</span>
</pre></div>
<h2 id="the-buffer-overflow-beast-contained-with-vectors-and-views-c-feature">The Buffer Overflow Beast: Contained with Vectors and Views (C++ feature)</h2><p>Dynamically growing arrays in C is a horror show.</p>
<p>Before: the realloc dance routine.</p>
<div><pre><span></span><span>// The old way: manual realloc is inefficient and complex</span>
<span>MatchEntry</span><span>**</span><span> </span><span>matches</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span>
<span>size_t</span><span> </span><span>matches_count</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>size_t</span><span> </span><span>matches_capacity</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>

<span>for</span><span> </span><span>(</span><span>/*...each match...*/</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>(</span><span>matches_count</span><span> </span><span>&gt;=</span><span> </span><span>matches_capacity</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>matches_capacity</span><span> </span><span>=</span><span> </span><span>(</span><span>matches_capacity</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>?</span><span> </span><span>8</span><span> </span><span>:</span><span> </span><span>matches_capacity</span><span> </span><span>*</span><span> </span><span>2</span><span>;</span>
<span>        </span><span>MatchEntry</span><span>**</span><span> </span><span>new_matches</span><span> </span><span>=</span><span> </span><span>realloc</span><span>(</span><span>matches</span><span>,</span><span> </span><span>matches_capacity</span><span> </span><span>*</span><span> </span><span>sizeof</span><span>(</span><span>MatchEntry</span><span>*</span><span>));</span>
<span>        </span><span>if</span><span> </span><span>(</span><span>!</span><span>new_matches</span><span>)</span><span> </span><span>{</span>
<span>            </span><span>free</span><span>(</span><span>matches</span><span>);</span><span> </span><span>// Don&#39;t leak!</span>
<span>            </span><span>/* handle error */</span>
<span>        </span><span>}</span>
<span>        </span><span>matches</span><span> </span><span>=</span><span> </span><span>new_matches</span><span>;</span>
<span>    </span><span>}</span>
<span>    </span><span>matches</span><span>[</span><span>matches_count</span><span>++</span><span>]</span><span> </span><span>=</span><span> </span><span>current_match</span><span>;</span>
<span>}</span>
</pre></div>
<p>After: a type-safe, auto-growing vector.</p>
<div><pre><span></span>// The magic that generates a complete vector type from a single line
#define DEFINE_VECTOR_TYPE(name, type) \
    typedef struct { \
        Vector base; \
        type* data; \
    } name##Vector; \
    \
    static inline bool name##_vector_push_back(name##Vector* vec, type value) { \
        bool result = vector_push_back(&amp;vec-&gt;base, &amp;value); \
        vec-&gt;data = (type*)vec-&gt;base.data; /* Sync pointer after potential realloc */ \
        return result; \
    } \
    \
    static inline bool name##_vector_reserve(name##Vector* vec, size_t new_capacity) { \
        bool result = vector_reserve(&amp;vec-&gt;base, new_capacity); \
        vec-&gt;data = (type*)vec-&gt;base.data; /* Sync pointer after potential realloc */ \
        return result; \
    } \


    /* more helper functions not outlined here */

// And the underlying generic Vector implementation
typedef struct {
    size_t size;
    size_t capacity;
    void* data;
    size_t element_size;
} Vector;
</pre></div>
<p>Using it in cgrep is simple and safe. The vector cleans itself up when it goes out of scope.</p>
<div><pre><span></span><span>// Type-safe vector for collecting matches</span>
<span>DEFINE_VECTOR_TYPE</span><span>(</span><span>MatchEntryPtr</span><span>,</span><span> </span><span>MatchEntry</span><span>*</span><span>)</span>

<span>AUTO_TYPED_VECTOR</span><span>(</span><span>MatchEntryPtr</span><span>,</span><span> </span><span>all_matches_vec</span><span>);</span>
<span>MatchEntryPtr_vector_reserve</span><span>(</span><span>&amp;</span><span>all_matches_vec</span><span>,</span><span> </span><span>store</span><span>-&gt;</span><span>total_matches</span><span>);</span>

<span>// Pushing elements is safe and simple</span>
<span>for</span><span> </span><span>(</span><span>MatchEntry</span><span>*</span><span> </span><span>entry</span><span> </span><span>=</span><span> </span><span>store</span><span>-&gt;</span><span>buckets</span><span>[</span><span>i</span><span>];</span><span> </span><span>entry</span><span>;</span><span> </span><span>entry</span><span> </span><span>=</span><span> </span><span>entry</span><span>-&gt;</span><span>next</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>MatchEntryPtr_vector_push_back</span><span>(</span><span>&amp;</span><span>all_matches_vec</span><span>,</span><span> </span><span>entry</span><span>);</span>
<span>}</span>
</pre></div>
<h2 id="views-look-dont-touch-or-malloc-c-feature">Views: Look, Don&#39;t Touch (or malloc) - C++ feature</h2><p>Before: needless allocations.</p>
<div><pre><span></span><span>// The old way: allocating a new string just to get a substring</span>
<span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>line</span><span> </span><span>=</span><span> </span><span>&#34;this is a long line of text&#34;</span><span>;</span>
<span>char</span><span>*</span><span> </span><span>pattern</span><span> </span><span>=</span><span> </span><span>&#34;long line&#34;</span><span>;</span>
<span>// To pass just the pattern to a function, you might do this:</span>
<span>char</span><span>*</span><span> </span><span>sub</span><span> </span><span>=</span><span> </span><span>malloc</span><span>(</span><span>strlen</span><span>(</span><span>pattern</span><span>)</span><span> </span><span>+</span><span> </span><span>1</span><span>);</span>
<span>strncpy</span><span>(</span><span>sub</span><span>,</span><span> </span><span>pattern</span><span>,</span><span> </span><span>strlen</span><span>(</span><span>pattern</span><span>)</span><span> </span><span>+</span><span> </span><span>1</span><span>);</span>
<span>// ... use sub ...</span>
<span>free</span><span>(</span><span>sub</span><span>);</span><span> </span><span>// And hope you remember this free call</span>
</pre></div>
<p>After: zero-cost, non-owning views.</p>
<div><pre><span></span><span>// The StringView and Span definitions: pure, simple, zero-cost</span>
<span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>data</span><span>;</span>
<span>    </span><span>size_t</span><span> </span><span>size</span><span>;</span>
<span>}</span><span> </span><span>StringView</span><span>;</span>

<span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>void</span><span>*</span><span> </span><span>data</span><span>;</span>
<span>    </span><span>size_t</span><span> </span><span>size</span><span>;</span>
<span>    </span><span>size_t</span><span> </span><span>element_size</span><span>;</span>
<span>}</span><span> </span><span>Span</span><span>;</span>
</pre></div>
<p>In cgrep, the search pattern becomes a StringView, avoiding allocation entirely.</p>
<div><pre><span></span><span>// Our options struct holds a StringView, not a char*</span>
<span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>StringView</span><span> </span><span>pattern</span><span>;</span><span> </span><span>// Clean, simple, and safe</span>
<span>    </span><span>// ...</span>
<span>}</span><span> </span><span>GrepOptions</span><span>;</span>

<span>// Initializing it is a piece of cake</span>
<span>options</span><span>.</span><span>pattern</span><span> </span><span>=</span><span> </span><span>string_view_init</span><span>(</span><span>argv</span><span>[</span><span>optind</span><span>]);</span>
</pre></div>
<p>For safe array access, Span provides a bounds-checked window into existing data.</p>
<div><pre><span></span>// safe_c.h
#define DEFINE_SPAN_TYPE(name, type) \
    typedef struct { \
        type* data; \
        size_t size; \
    } name##Span; \
    \
    static inline name##Span name##_span_init(type* data, size_t size) { \
        return (name##Span){.data = data, .size = size}; \
    } \
    \

    /* other helper functions not outlined here */
</pre></div>
<div><pre><span></span><span>// Span: Type-safe array slices for chunk processing</span>
<span>DEFINE_SPAN_TYPE</span><span>(</span><span>LineBuffer</span><span>,</span><span> </span><span>char</span><span>)</span>
<span>LineBufferSpan</span><span> </span><span>input_span</span><span> </span><span>=</span><span> </span><span>LineBuffer_span_init</span><span>((</span><span>char</span><span>*</span><span>)</span><span>start</span><span>,</span><span> </span><span>len</span><span>);</span>

<span>for</span><span> </span><span>(</span><span>size_t</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>LineBuffer_span_size</span><span>(</span><span>&amp;</span><span>input_span</span><span>);</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>char</span><span>*</span><span> </span><span>line</span><span> </span><span>=</span><span> </span><span>LineBuffer_span_at</span><span>(</span><span>&amp;</span><span>input_span</span><span>,</span><span> </span><span>i</span><span>);</span><span> </span><span>// asserts i &lt; span.size</span>
<span>}</span>
</pre></div>
<h2 id="the-error-handling-codegotocode-beast-replaced-with-results-rust-feature-and-raii-c-feature">The Error-Handling <code>goto</code> Beast: Replaced with Results (Rust feature) and RAII (C++ feature)</h2><p>C&#39;s error handling is notoriously messy.</p>
<p>Before: goto cleanup spaghetti carbonara.</p>
<div><pre><span></span><span>// The old way: goto cleanup</span>
<span>int</span><span> </span><span>do_something</span><span>(</span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>path</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>int</span><span> </span><span>fd</span><span> </span><span>=</span><span> </span><span>open</span><span>(</span><span>path</span><span>,</span><span> </span><span>O_RDONLY</span><span>);</span>
<span>    </span><span>if</span><span> </span><span>(</span><span>fd</span><span> </span><span>&lt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>-1</span><span>;</span><span> </span><span>// Error</span>
<span>    </span><span>}</span>

<span>    </span><span>void</span><span>*</span><span> </span><span>mem</span><span> </span><span>=</span><span> </span><span>malloc</span><span>(</span><span>1024</span><span>);</span>
<span>    </span><span>if</span><span> </span><span>(</span><span>!</span><span>mem</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>close</span><span>(</span><span>fd</span><span>);</span><span> </span><span>// Manual cleanup</span>
<span>        </span><span>return</span><span> </span><span>-1</span><span>;</span>
<span>    </span><span>}</span>
<span>    </span>
<span>    </span><span>// ... do more work ...</span>

<span>    </span><span>free</span><span>(</span><span>mem</span><span>);</span>
<span>    </span><span>close</span><span>(</span><span>fd</span><span>);</span>
<span>    </span><span>return</span><span> </span><span>0</span><span>;</span><span> </span><span>// Success</span>
<span>}</span>
</pre></div>
<p>After: explicit, type-safe result.</p>
<div><pre><span></span>// The Result type machinery: tagged unions for success/failure
typedef enum { RESULT_OK, RESULT_ERROR } ResultStatus;

#define DEFINE_RESULT_TYPE(name, value_type, error_type) \
    typedef struct { \
        ResultStatus status; \
        union { \
            value_type value; \
            error_type error; \
        }; \
    } Result##name;
</pre></div>
<p>Handling errors becomes easy. You can&#39;t accidentally use an error as a valid value.</p>
<div><pre><span></span><span>// Define a Result for file operations</span>
<span>DEFINE_RESULT_TYPE</span><span>(</span><span>FileOp</span><span>,</span><span> </span><span>i32</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span>)</span>

<span>// Our function now returns a clear Result</span>
<span>static</span><span> </span><span>ResultFileOp</span><span> </span><span>submit_stat_request_safe</span><span>(...)</span><span> </span><span>{</span>
<span>    </span><span>// ...</span>
<span>    </span><span>if</span><span> </span><span>(</span><span>!</span><span>sqe</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>return</span><span> </span><span>RESULT_ERROR</span><span>(</span><span>FileOp</span><span>,</span><span> </span><span>&#34;Could not get SQE for stat&#34;</span><span>);</span>
<span>    </span><span>}</span>
<span>    </span><span>return</span><span> </span><span>RESULT_OK</span><span>(</span><span>FileOp</span><span>,</span><span> </span><span>0</span><span>);</span>
<span>}</span>

<span>// And handling it is clean</span>
<span>ResultFileOp</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>submit_stat_request_safe</span><span>(</span><span>path</span><span>,</span><span> </span><span>&amp;</span><span>ring</span><span>,</span><span> </span><span>&amp;</span><span>pending_ops</span><span>);</span>
<span>if</span><span> </span><span>(</span><span>!</span><span>RESULT_IS_OK</span><span>(</span><span>result</span><span>))</span><span> </span><span>{</span>
<span>    </span><span>fprintf</span><span>(</span><span>stderr</span><span>,</span><span> </span><span>&#34;Error: %s</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>RESULT_UNWRAP_ERROR</span><span>(</span><span>result</span><span>));</span>
<span>}</span>
</pre></div>
<p>This is powered by RAII. The <code>CLEANUP</code> attribute ensures resources are freed no matter how a function exits.</p>
<div><pre><span></span><span>#define AUTO_MEMORY(name, size) \</span>
<span>    void* name CLEANUP(memory_cleanup) = malloc(size)</span>

<span>// DIR pointers are automatically closed, even on an early return.</span>
<span>DIR</span><span>*</span><span> </span><span>dir</span><span> </span><span>CLEANUP</span><span>(</span><span>dir_cleanup</span><span>)</span><span> </span><span>=</span><span> </span><span>opendir</span><span>(</span><span>req</span><span>-&gt;</span><span>path</span><span>);</span>
<span>if</span><span> </span><span>(</span><span>!</span><span>dir</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>return</span><span> </span><span>RESULT_ERROR</span><span>(</span><span>FileOp</span><span>,</span><span> </span><span>&#34;Failed to open dir&#34;</span><span>);</span><span> </span><span>// dir_cleanup is NOT called</span>
<span>}</span>
<span>if</span><span> </span><span>(</span><span>some_condition</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>return</span><span> </span><span>RESULT_OK</span><span>(</span><span>FileOp</span><span>,</span><span> </span><span>0</span><span>);</span><span> </span><span>// closedir() is called automatically HERE!</span>
<span>}</span>
</pre></div>
<h2 id="the-assumption-beast-challenged-with-contracts-and-safe-strings">The Assumption Beast: Challenged with Contracts and Safe Strings</h2><p>Before: <code>assert()</code> and pray.</p>
<p>After: self-documenting contracts.</p>
<div><pre><span></span>#define requires(cond) assert_msg(cond, &#34;Precondition failed&#34;)
#define ensures(cond) assert_msg(cond, &#34;Postcondition failed&#34;)

#define assert_msg(cond, msg) /* ... full implementation ... */
</pre></div>
<p>This turns assertions into executable documentation:</p>
<div><pre><span></span><span>// Preconditions that document and enforce contracts</span>
<span>static</span><span> </span><span>inline</span><span> </span><span>bool</span><span> </span><span>arena_create</span><span>(</span><span>Arena</span><span>*</span><span> </span><span>arena</span><span>,</span><span> </span><span>size_t</span><span> </span><span>size</span><span>)</span>
<span>{</span>
<span>    </span><span>requires</span><span>(</span><span>arena</span><span> </span><span>!=</span><span> </span><span>NULL</span><span>);</span><span>  </span><span>// Precondition: arena must not be null</span>
<span>    </span><span>requires</span><span>(</span><span>size</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>);</span><span>       </span><span>// Precondition: size must be positive</span>
<span>    </span>
<span>    </span><span>// ... implementation ...</span>
<span>    </span>
<span>    </span><span>ensures</span><span>(</span><span>arena</span><span>-&gt;</span><span>buffer</span><span> </span><span>!=</span><span> </span><span>NULL</span><span>);</span><span>  </span><span>// Postcondition: buffer is allocated</span>
<span>    </span><span>ensures</span><span>(</span><span>arena</span><span>-&gt;</span><span>size</span><span> </span><span>==</span><span> </span><span>size</span><span>);</span><span>    </span><span>// Postcondition: size is set correctly</span>
<span>    </span>
<span>    </span><span>return</span><span> </span><span>true</span><span>;</span>
<span>}</span>
</pre></div>
<h3 id="codestrcpycode-is-a-security-vulnerability"><code>strcpy()</code> is a Security Vulnerability</h3><p>Before: buffer overflows.</p>
<div><pre><span></span><span>// The old, dangerous way</span>
<span>char</span><span> </span><span>dest</span><span>[</span><span>20</span><span>];</span>
<span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>src</span><span> </span><span>=</span><span> </span><span>&#34;This is a very long string that will overflow the buffer&#34;</span><span>;</span>
<span>strcpy</span><span>(</span><span>dest</span><span>,</span><span> </span><span>src</span><span>);</span><span> </span><span>// Undefined behavior! Stack corruption!</span>
</pre></div>
<p>After: safe, bounds-checked operations.</p>
<div><pre><span></span><span>// The safe string operations: bounds checking that can&#39;t be ignored</span>
<span>static</span><span> </span><span>inline</span><span> </span><span>bool</span><span> </span><span>safe_strcpy</span><span>(</span><span>char</span><span>*</span><span> </span><span>dest</span><span>,</span><span> </span><span>size_t</span><span> </span><span>dest_size</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>src</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>(</span><span>!</span><span>dest</span><span> </span><span>||</span><span> </span><span>dest_size</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>||</span><span> </span><span>!</span><span>src</span><span>)</span><span> </span><span>return</span><span> </span><span>false</span><span>;</span>
<span>    </span><span>size_t</span><span> </span><span>src_len</span><span> </span><span>=</span><span> </span><span>strlen</span><span>(</span><span>src</span><span>);</span>
<span>    </span><span>if</span><span> </span><span>(</span><span>src_len</span><span> </span><span>&gt;=</span><span> </span><span>dest_size</span><span>)</span><span> </span><span>return</span><span> </span><span>false</span><span>;</span>
<span>    </span><span>memcpy</span><span>(</span><span>dest</span><span>,</span><span> </span><span>src</span><span>,</span><span> </span><span>src_len</span><span> </span><span>+</span><span> </span><span>1</span><span>);</span>
<span>    </span><span>return</span><span> </span><span>true</span><span>;</span>
<span>}</span>
</pre></div>
<p>In cgrep, this prevents path buffer overflows cleanly:</p>
<div><pre><span></span><span>// Returns bool, not silent truncation</span>
<span>if</span><span> </span><span>(</span><span>!</span><span>safe_strcpy</span><span>(</span><span>req</span><span>-&gt;</span><span>path</span><span>,</span><span> </span><span>PATH_MAX</span><span>,</span><span> </span><span>path</span><span>))</span><span> </span><span>{</span>
<span>    </span><span>free</span><span>(</span><span>req</span><span>);</span>
<span>    </span><span>return</span><span> </span><span>RESULT_ERROR</span><span>(</span><span>FileOp</span><span>,</span><span> </span><span>&#34;Path is too long&#34;</span><span>);</span>
<span>}</span>
</pre></div>
<h2 id="concurrency-mutexes-that-unlock-themselves-rust-feature">Concurrency: Mutexes That Unlock Themselves (Rust feature)</h2><p>Before: leaked locks and deadlocks.</p>
<div><pre><span></span><span>// The Buggy Way</span>
<span>pthread_mutex_lock</span><span>(</span><span>&amp;</span><span>mutex</span><span>);</span>
<span>if</span><span> </span><span>(</span><span>some_error</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>return</span><span>;</span><span> </span><span>// Oops, mutex is still locked! Program will deadlock.</span>
<span>}</span>
<span>pthread_mutex_unlock</span><span>(</span><span>&amp;</span><span>mutex</span><span>);</span>
</pre></div>
<p>After: RAII-based locks.</p>
<div><pre><span></span><span>// With a cleanup function, unlocking is automatic.</span>
<span>void</span><span> </span><span>mutex_unlock_cleanup</span><span>(</span><span>pthread_mutex_t</span><span>**</span><span> </span><span>lock</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>(</span><span>lock</span><span> </span><span>&amp;&amp;</span><span> </span><span>*</span><span>lock</span><span>)</span><span> </span><span>pthread_mutex_unlock</span><span>(</span><span>*</span><span>lock</span><span>);</span>
<span>}</span>

<span>// RAII lock guard via cleanup attribute</span>
<span>pthread_mutex_t</span><span> </span><span>my_lock</span><span>;</span>
<span>pthread_mutex_t</span><span>*</span><span> </span><span>lock_ptr</span><span> </span><span>CLEANUP</span><span>(</span><span>mutex_unlock_cleanup</span><span>)</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>my_lock</span><span>;</span>
<span>pthread_mutex_lock</span><span>(</span><span>lock_ptr</span><span>);</span>

<span>if</span><span> </span><span>(</span><span>some_error</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>return</span><span>;</span><span> </span><span>// Mutex is automatically unlocked here!</span>
<span>}</span>
</pre></div>
<p>Simple wrappers also clean up the boilerplate of managing threads:</p>
<div><pre><span></span>// The concurrency macros: spawn and join without boilerplate
#define SPAWN_THREAD(name, func, arg) \
    thrd_t name; \
    thrd_create(&amp;name, (func), (arg))

#define JOIN_THREAD(name) \
    thrd_join(name, NULL)
</pre></div>
<p>And in cgrep:</p>
<div><pre><span></span>// Thread pool spawn without boilerplate
SPAWN_THREAD(workers[i], file_processing_worker, &amp;contexts[i]);
JOIN_THREAD(workers[i]); // No manual pthread_join() error handling
</pre></div>
<h2 id="performance-safety-at-o2-not-o0">Performance: Safety at -O2, Not -O0</h2><p>Safety doesn&#39;t mean slow. The UNLIKELY() macro tells the compiler which branches are cold, adding zero overhead in hot paths.</p>
<div><pre><span></span>#ifdef __GNUC__
#define LIKELY(x)   __builtin_expect(!!(x), 1)
#define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#define LIKELY(x)   (x)
#define UNLIKELY(x) (x)
#endif
</pre></div>
<p>The real win is in the fast paths:</p>
<div><pre><span></span><span>// In hot allocation path: branch prediction</span>
<span>if</span><span> </span><span>(</span><span>UNLIKELY</span><span>(</span><span>store</span><span>-&gt;</span><span>local_buffer_sizes</span><span>[</span><span>thread_id</span><span>]</span><span> </span><span>&gt;=</span><span> </span><span>LOCAL_BUFFER_CAPACITY</span><span>))</span><span> </span><span>{</span>
<span>    </span><span>match_store_flush_buffer</span><span>(</span><span>store</span><span>,</span><span> </span><span>thread_id</span><span>);</span><span> </span><span>// Rarely taken</span>
<span>}</span>

<span>// In match checking: likely path first</span>
<span>if</span><span> </span><span>(</span><span>!</span><span>options</span><span>-&gt;</span><span>case_insensitive</span><span> </span><span>&amp;&amp;</span><span> </span><span>options</span><span>-&gt;</span><span>fixed_string</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>// Most common case: fast path with no branches</span>
<span>    </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>strstr</span><span>(</span><span>line</span><span>,</span><span> </span><span>options</span><span>-&gt;</span><span>pattern</span><span>.</span><span>data</span><span>);</span>
<span>    </span><span>return</span><span> </span><span>result</span><span> </span><span>!=</span><span> </span><span>NULL</span><span>;</span>
<span>}</span>
</pre></div>
<p>The above is similar to what a PGO (Profile Guided Optimization) would have.</p>
<p>This is what main() looks like when you stop fighting the language:</p>
<div><pre><span></span><span>int</span><span> </span><span>main</span><span>(</span><span>int</span><span> </span><span>argc</span><span>,</span><span> </span><span>char</span><span>*</span><span> </span><span>argv</span><span>[])</span><span> </span><span>{</span>
<span>    </span><span>initialize_simd</span><span>();</span>
<span>    </span><span>output_buffer_init</span><span>();</span><span> </span><span>// Auto-cleanup on exit</span>
<span>    </span>
<span>    </span><span>GrepOptions</span><span> </span><span>options</span><span> </span><span>=</span><span> </span><span>{</span><span>0</span><span>};</span>
<span>    </span><span>AUTO_UNIQUE_PTR</span><span>(</span><span>include_pattern_ptr</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>options_string_deleter</span><span>);</span>
<span>    </span>
<span>    </span><span>// ... parse args with getopt_long ...</span>
<span>    </span>
<span>    </span><span>AUTO_UNIQUE_PTR</span><span>(</span><span>store_ptr</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>match_store_deleter</span><span>);</span>
<span>    </span><span>SharedPtr</span><span> </span><span>store_shared</span><span> </span><span>=</span><span> </span><span>{</span><span>0</span><span>};</span>
<span>    </span><span>if</span><span> </span><span>(</span><span>need_match_store</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>store_ptr</span><span>.</span><span>ptr</span><span> </span><span>=</span><span> </span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>ConcurrentMatchStore</span><span>));</span>
<span>        </span><span>if</span><span> </span><span>(</span><span>!</span><span>store_ptr</span><span>.</span><span>ptr</span><span> </span><span>||</span><span> </span><span>!</span><span>match_store_create</span><span>(</span><span>store_ptr</span><span>.</span><span>ptr</span><span>,</span><span> </span><span>hash_capacity</span><span>,</span><span> </span><span>1000</span><span>))</span><span> </span><span>{</span>
<span>            </span><span>return</span><span> </span><span>1</span><span>;</span><span> </span><span>// All allocations cleaned up automatically</span>
<span>        </span><span>}</span>
<span>        </span><span>shared_ptr_init</span><span>(</span><span>&amp;</span><span>store_shared</span><span>,</span><span> </span><span>store_ptr</span><span>.</span><span>ptr</span><span>,</span><span> </span><span>match_store_deleter</span><span>);</span>
<span>    </span><span>}</span>
<span>    </span>
<span>    </span><span>// Process files with thread pool...</span>
<span>    </span>
<span>cleanup</span><span>:</span><span> </span><span>// Single cleanup label needed -- RAII handles the rest</span>
<span>    </span><span>output_buffer_destroy</span><span>();</span><span> </span><span>// Flushes and destroys</span>
<span>    </span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>
</pre></div>
<p>In the end, cgrep is 2,300 lines of C. Without safe_c.h, it would have required over 50 manual free() calls ~ a recipe for leaks and segfaults. With the custom header file, it&#39;s 2,300 lines that compile to the same assembly, run just as fast, and are fundamentally safer.</p>
<p>This proves that the best abstraction is the one you don&#39;t pay for and can&#39;t forget to use. It enables a clear and powerful development pattern: validate inputs at the boundary, then unleash C&#39;s raw speed on the core logic. You get all the power of C without the infamous self-inflicted footgun wounds.</p>
<p>C simplicity makes writing programs with it becomes fun, however there are ways to make it both <strong>fun and safe</strong>..just like using condoms, you know?</p>
<p>This post has gotten too long for comfort, but I have one final food for thought for you the readers: after all these guard rails, what do you think of cgrep&#39;s performance? Check the screenshots below:</p>
<ul>
<li><p>grep bench on recursive directories
<img src="https://i.ibb.co.com/ZpKKd4FS/grep-bench-recursive-Dirs.png" alt="recursive-Dirs"/></p>
</li>
<li><p>grep bench on single large file
<img src="https://i.ibb.co.com/qMKqFhmm/grep-bench-single-Large-File.png" alt="Large-File"/>
<strong>NOTE: make sure you check the memory usage comparison between cgrep and ripgrep</strong></p>
</li>
</ul>
<hr/>
<hr/>
<p>In the next article, I will discuss how I built cgrep, the design I chose for it, why and how cgrep managed to be a couple of times faster than ripgrep (more than 2x faster in the recursive directory bench) while being super efficient with resource usage (20x smaller memory footprint in the single large file bench).</p>
<p>It&#39;s gonna be a lot of fun! Cheers!</p>
<p><mark>If you enjoyed this post, click the little up arrow chevron on the bottom left of the page to help it rank in Bear&#39;s Discovery feed and if you got any questions or anything, please use the comments section.</mark></p>


    

    
        

        
            


        

        
            
        
    


  </div></div>
  </body>
</html>
