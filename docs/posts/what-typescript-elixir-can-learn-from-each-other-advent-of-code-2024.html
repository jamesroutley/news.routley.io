<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://effectivetypescript.com/2025/11/24/advent2024-elixir/">Original</a>
    <h1>What TypeScript &amp; Elixir Can Learn from each Other (Advent of Code 2024)</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p><img src="https://effectivetypescript.com/images/advent-of-code.png" title="Advent of Code Logo" width="64" height="64"/>The <a target="_blank" rel="noopener" href="https://adventofcode.com/" onclick="return trackOutboundLink(&#39;what typescript amp elixir can learn from each other advent of code&#39;, &#39;https://adventofcode.com/&#39;, event);">Advent of Code</a> is a fun annual programming competition with an Elf theme. It consists of 25 two-part problems of increasing difficulty, released every day in December leading up to Christmas.</p>
<p>Every December, I complete it in a new programming language. Every January, I intend to blog about the experience, but inevitably it slips, this year all the way back to November! (Sorry, I got <a target="_blank" rel="noopener" href="https://www.danvk.org/2025/08/25/boggle-roundup.html" onclick="return trackOutboundLink(&#39;what typescript amp elixir can learn from each other advent of code&#39;, &#39;https://www.danvk.org/2025/08/25/boggle-roundup.html&#39;, event);">completely consumed</a> by a non-TypeScript <a target="_blank" rel="noopener" href="https://www.danvk.org/2025/04/23/boggle-solved.html" onclick="return trackOutboundLink(&#39;what typescript amp elixir can learn from each other advent of code&#39;, &#39;https://www.danvk.org/2025/04/23/boggle-solved.html&#39;, event);">side project</a>.)</p>
<p>In 2024, I did the Advent of Code in <a target="_blank" rel="noopener" href="https://elixir-lang.org/" onclick="return trackOutboundLink(&#39;what typescript amp elixir can learn from each other advent of code&#39;, &#39;https://elixir-lang.org/&#39;, event);">Elixir</a>, a functional programming language with immutable data types based on <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Erlang_(programming_language)" onclick="return trackOutboundLink(&#39;what typescript amp elixir can learn from each other advent of code&#39;, &#39;https://en.wikipedia.org/wiki/Erlang_(programming_language)&#39;, event);">Erlang</a>. This is analogous to how the JVM was built for Java, but also serves as a runtime for other languages like Kotlin and Scala.</p>
<p>I picked Elixir largely because a friend of mine worked in it. I&#39;d also never written a substantial amount of code in a purely-functional language, and I was curious to see how it worked.</p>
<p>I suspect there&#39;s relatively little overlap between TypeScript and Elixir developers. They serve different roles and occupy different niches. But they do have a thing or two in common. In particular, Elixir is in the process of adding a gradual, optional typing system. Sound familiar?</p>
<ol>
<li><a href="#A-quick-intro-to-Elixir">A quick intro to Elixir</a></li>
<li><a href="#What-can-TypeScript-learn-from-Elixir">What can TypeScript learn from Elixir?</a></li>
<li><a href="#What-can-Elixir-learn-from-TypeScript">What can Elixir learn from TypeScript?</a><ol>
<li><a href="#Prioritize-Language-Services">Prioritize Language Services</a></li>
<li><a href="#Adopting-Types">Adopting Types</a></li>
</ol>
</li>
<li><a href="#General-Impressions-of-Elixir">General Impressions of Elixir</a></li>
<li><a href="#Thoughts-on-the-2024-Advent-of-Code">Thoughts on the 2024 Advent of Code</a></li>
<li><a href="#Conclusions">Conclusions</a></li>
</ol>
<!-- more -->

<p>Here are the previous installments in this series:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://medium.com/@danvdk/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd" onclick="return trackOutboundLink(&#39;what typescript amp elixir can learn from each other advent of code&#39;, &#39;https://medium.com/@danvdk/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd&#39;, event);">2019: Python</a></li>
<li><a target="_blank" rel="noopener" href="https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc" onclick="return trackOutboundLink(&#39;what typescript amp elixir can learn from each other advent of code&#39;, &#39;https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc&#39;, event);">2020: Rust</a></li>
<li><a href="https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/">2021: Go</a></li>
<li><a href="https://effectivetypescript.com/2023/04/27/aoc2022/">2022: TypeScript / Deno</a></li>
<li><a href="https://effectivetypescript.com/2024/07/17/advent2023-zig/">2023: Zig</a></li>
</ul>
<h2 id="A-quick-intro-to-Elixir"><a href="#A-quick-intro-to-Elixir" title="A quick intro to Elixir"></a>A quick intro to Elixir</h2><p>Here&#39;s an Elixir function to read lines from a file (pretty helpful for Advent of Code problems!):</p>
<figure><div><pre><code><span><span>def</span> <span>read_lines</span></span>(file) <span>do</span></code></pre></div></figure>

<p>Here you can see Elixir&#39;s pipeline operator (<code>|&gt;</code>). This has been a hot topic in the JavaScript world for nearly a decade, so it was fun for me to get to play around with it. It wasn&#39;t as useful as I expected (more on this below).</p>
<p>Here&#39;s another pair of functions to &#34;chunk&#34; a list of strings into groups delineated by blanks (also very helpful in Advent of Code):</p>
<figure><div><pre><code></code></pre></div></figure>

<p>Here you can see more uses of the pipeline operator, a helper method from the <a target="_blank" rel="noopener" href="https://hexdocs.pm/elixir/enum-cheat.html" onclick="return trackOutboundLink(&#39;a quick intro to elixir&#39;, &#39;https://hexdocs.pm/elixir/enum-cheat.html&#39;, event);">ubiquitous <code>Enum</code> module</a>, pattern matching on tuples, and an anonymous function (<code>&amp;(&amp;1 != &#34;&#34;)</code>). In TypeScript, we might write this function in a more imperative style as:</p>
<figure><div><pre><code><span><span>function</span> <span>splitOnBlanks</span>(<span>lines: <span>readonly</span> <span>string</span>[]</span>): <span>string</span>[][] </span>{</code></pre></div></figure>

<p>Here&#39;s one final Elixir snippet that reads a grid into an <code>(x, y) -&gt; char</code> map and calculates its width and height. Again, this is very handy for Advent of Code problems!</p>
<figure><div><pre><code><span><span>def</span> <span>read_grid_from_lines</span></span>(lines) <span>do</span></code></pre></div></figure>

<p>Here you can see Elixir&#39;s list comprehensions (<code>for</code>), which are a flexible way to build data structures. The <code>into: %{}</code> clause in the first comprehension says to put the results into a Map (<code>%{}</code> is an empty Map). These comprehensions all do pattern matching on the enumerable (what JavaScript would call an iterable). The last two use the pipeline operator to extract the max.</p>
<p>That gives you some of the flavor of Elixir. You can read much more about it on the <a target="_blank" rel="noopener" href="https://hexdocs.pm/elixir/introduction.html" onclick="return trackOutboundLink(&#39;a quick intro to elixir&#39;, &#39;https://hexdocs.pm/elixir/introduction.html&#39;, event);">official docs</a>.</p>
<h2 id="What-can-TypeScript-learn-from-Elixir"><a href="#What-can-TypeScript-learn-from-Elixir" title="What can TypeScript learn from Elixir?"></a>What can TypeScript learn from Elixir?</h2><p>There are many long-stalled proposals to extend JavaScript, perhaps none more famous than the <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-pipeline-operator" onclick="return trackOutboundLink(&#39;what can typescript learn from elixir&#39;, &#39;https://github.com/tc39/proposal-pipeline-operator&#39;, event);">pipeline proposal</a>, which has been around in some form since <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md" onclick="return trackOutboundLink(&#39;what can typescript learn from elixir&#39;, &#39;https://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md&#39;, event);">at least 2015</a>.</p>
<p>At first blush, the pipeline proposal is simple and uncontroversial. Instead of writing nested function application as:</p>
<figure><div><pre><code><span>console</span>.log(<span>Object</span>.keys(getUserPreferences(getCurrentUser())))<br/></code></pre></div></figure>

<p>You&#39;d be able to write it as:</p>
<figure><div><pre><code>getCurrentUser()</code></pre></div></figure>

<p>The beauty of this is that the order of the code reflects the order of execution (top-down here, rather than right-to-left) and there&#39;s much less nesting.</p>
<p>You can simulate a pipe in a few ways in JavaScript today. One approach is to repeatedly assign to a temporary variable:</p>
<figure><div><pre><code><span>let</span> t;</code></pre></div></figure>

<p>This eliminates the nesting and inside-out order, but I can already see TypeScript users grimacing. While this works in JavaScript, it typically won&#39;t in TypeScript, where a symbol&#39;s type can only change in a very specific set of ways. Instead, you&#39;d need to introduce a new variable for every assignment (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Static_single-assignment_form" onclick="return trackOutboundLink(&#39;what can typescript learn from elixir&#39;, &#39;https://en.wikipedia.org/wiki/Static_single-assignment_form&#39;, event);">static single assignment</a> form).</p>
<p>Functional libraries typically offer pipelines via a wrapper object, notably jQuery and lodash:</p>
<figure><div><pre><code><span>console</span>.log(_(obj).meth1().meth2().value)<br/></code></pre></div></figure>

<p>These are limited to methods provided by the library, though. <a target="_blank" rel="noopener" href="https://lodash.com/docs/#chain" onclick="return trackOutboundLink(&#39;what can typescript learn from elixir&#39;, &#39;https://lodash.com/docs/#chain&#39;, event);">Lodash&#39;s chains</a> can&#39;t help us with the <code>getUserPreferences</code> example. It would be much better if pipes were built into the language itself.</p>
<p>Why has the pipeline proposal has been stalled for so long? One reason is that there are different ideas about whether to offer special syntax for calling a function in a chain, and how that should work. This has always seemed like a secondary concern to me. Why not just add a basic pipe operator and worry about syntactic sugar later? Elixir has built-in pipes, so I was excited to see how they worked in practice.</p>
<p>The TL;DR is that pipes alone aren&#39;t all they&#39;re cracked up to be. I understand now why TC39 is so hung up on syntax extensions. It was incredibly rare that I used a function in a pipe without having to pass other arguments or adapt it in some way.</p>
<p>Elixir offers a few shorthands to facilitate working with pipes. For example:</p>
<figure><div><pre><code>f(x)      </code></pre></div></figure>

<p>This is stranger than it looks. When you write <code>x |&gt; f()</code>, Elixir doesn&#39;t call <code>f</code> with zero arguments. Instead, it rewrites this expression to pass <code>x</code> as the first parameter to <code>f</code> (I assume using <a target="_blank" rel="noopener" href="https://hexdocs.pm/elixir/macros.html" onclick="return trackOutboundLink(&#39;what can typescript learn from elixir&#39;, &#39;https://hexdocs.pm/elixir/macros.html&#39;, event);">macros</a>). This winds up feeling pretty natural when you use constructs like <code>map</code>:</p>
<figure><div><pre><code>[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>]</code></pre></div></figure>

<p>The <code>Enum</code> module contains many general functions for working with collections. These functions all take the collection as their first argument, which is conducive to piping. (I found this <a target="_blank" rel="noopener" href="https://hexdocs.pm/elixir/enum-cheat.html" onclick="return trackOutboundLink(&#39;what can typescript learn from elixir&#39;, &#39;https://hexdocs.pm/elixir/enum-cheat.html&#39;, event);">Enum cheatsheet</a> extremely helpful.)</p>
<p>This example includes two ways of writing anonymous functions. <code>&amp;1</code> is the first argument to the function. This is convenient for writing very short functions. (You write the identity <code>&amp; &amp;1</code>.)</p>
<p>What would this look like with a plain vanilla JavaScript pipe? You&#39;d have to create lots of wrapper functions:</p>
<figure><div><pre><code>[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>]</code></pre></div></figure>

<p>(this example looks silly since <code>map</code> and <code>filter</code> are already methods on <code>Array</code>)</p>
<p>This adds boilerplate and has been flagged as a <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md#20182020:~:text=V8)%20also%20expresses%20%E2%80%9C-,strong%20reservations,-%E2%80%9D%20about%20PFA%20syntax" onclick="return trackOutboundLink(&#39;what can typescript learn from elixir&#39;, &#39;https://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md#20182020:~:text=V8)%20also%20expresses%20%E2%80%9C-,strong%20reservations,-%E2%80%9D%20about%20PFA%20syntax&#39;, event);">performance concern</a> by browser vendors. The proposal suggests introducing a new, concise syntax for creating anonymous functions using a placeholder symbol (perhaps <code>%</code>):</p>
<figure><div><pre><code>[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>]</code></pre></div></figure>

<p>This at least makes the pipe more concise.</p>
<p>I enjoyed using Elixir pipes. (I would have enjoyed using them more with better typing!) But as I solved more AoC problems in Elixir, I found myself using them less and less. Instead, I starting using more and more <a target="_blank" rel="noopener" href="https://hexdocs.pm/elixir/comprehensions.html" onclick="return trackOutboundLink(&#39;what can typescript learn from elixir&#39;, &#39;https://hexdocs.pm/elixir/comprehensions.html&#39;, event);">comprehensions</a>.</p>
<figure><div><pre><code><span>for</span>(</code></pre></div></figure>

<p>Comprehensions let you combine multiple inputs, reduce your results and put them into any sort of collection you want. You can read more about them in this <a target="_blank" rel="noopener" href="https://www.mitchellhanberg.com/the-comprehensive-guide-to-elixirs-for-comprehension/" onclick="return trackOutboundLink(&#39;what can typescript learn from elixir&#39;, &#39;https://www.mitchellhanberg.com/the-comprehensive-guide-to-elixirs-for-comprehension/&#39;, event);">Comprehensive Guide</a>. Perhaps it&#39;s because I&#39;m comfortable with Python comprehensions or due to the Advent of Code problems themselves, but this was usually what I wanted. (One gotcha: a <code>when</code> clause in a comprehension is <a target="_blank" rel="noopener" href="https://hexdocs.pm/elixir/1.6.5/guards.html" onclick="return trackOutboundLink(&#39;what can typescript learn from elixir&#39;, &#39;https://hexdocs.pm/elixir/1.6.5/guards.html&#39;, event);">weirdly restricted</a>. I understand this has something to do with Erlang and it&#39;s been explained to me a few times, but it never really clicked what I could and couldn&#39;t do.)</p>
<p>In conclusion: adding simple pipes to JavaScript probably wouldn&#39;t be that useful because you&#39;d have to define so many small wrapper functions. If you want to fix that, too, you can understand why the proposal has gotten bogged down. At the end of the day, what I really want is comprehensions.</p>
<p>I&#39;m not aware of any active proposals to add comprehensions to JavaScript. Interestingly, Firefox <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Deprecated_and_obsolete_features#legacy_generator_and_iterator" onclick="return trackOutboundLink(&#39;what can typescript learn from elixir&#39;, &#39;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Deprecated_and_obsolete_features#legacy_generator_and_iterator&#39;, event);">used to have</a> its own non-standard comprehensions. There was discussion about adding this to what became ES2015, but it was <a target="_blank" rel="noopener" href="https://github.com/tc39/notes/blob/main/meetings/2014-06/jun-5.md#generator-comprehensions-slides-plz" onclick="return trackOutboundLink(&#39;what can typescript learn from elixir&#39;, &#39;https://github.com/tc39/notes/blob/main/meetings/2014-06/jun-5.md#generator-comprehensions-slides-plz&#39;, event);">deferred</a> to a future standard in 2014 and seems to have died there.</p>
<h2 id="What-can-Elixir-learn-from-TypeScript"><a href="#What-can-Elixir-learn-from-TypeScript" title="What can Elixir learn from TypeScript?"></a>What can Elixir learn from TypeScript?</h2><h3 id="Prioritize-Language-Services"><a href="#Prioritize-Language-Services" title="Prioritize Language Services"></a>Prioritize Language Services</h3><p>When you install TypeScript, you get two binaries:</p>
<ul>
<li><code>tsc</code>: the TypeScript compiler</li>
<li><code>tsserver</code>: the TypeScript language service</li>
</ul>
<p><code>tsc</code> is typically the only one you invoke directly, but you interact with <code>tsserver</code> more because it&#39;s what powers your editor. The TypeScript team treats the language service as a first-class citizen. It&#39;s just as important as the compiler or the language itself.</p>
<p>I didn&#39;t get the sense that <a target="_blank" rel="noopener" href="https://github.com/elixir-lsp/elixir-ls" onclick="return trackOutboundLink(&#39;what can elixir learn from typescript&#39;, &#39;https://github.com/elixir-lsp/elixir-ls&#39;, event);">Elixir Language Server</a> got nearly so much attention. Three quick examples will illustrate the point.</p>
<p>First, Elixir has two modes, &#34;scripting mode&#34; (<code>.exs</code> file) and regular mode (<code>.ex</code> files). I started off in &#34;scripting mode&#34; for simplicity, but wasn&#39;t getting any editor support. Sure enough, this just <a target="_blank" rel="noopener" href="https://github.com/elixir-lsp/elixir-ls?tab=readme-ov-file#known-issueslimitations" onclick="return trackOutboundLink(&#39;what can elixir learn from typescript&#39;, &#39;https://github.com/elixir-lsp/elixir-ls?tab=readme-ov-file#known-issueslimitations&#39;, event);">isn&#39;t supported</a>.</p>
<p>Second, syntax errors make the entire document flash red. I found this incredibly irritating. It often happens if you&#39;ve just typed the &#34;en&#34; in <code>end</code>, say:</p>

<p>Third, there are basic features you expect from an IDE that simply don&#39;t work with Elixir. <a target="_blank" rel="noopener" href="https://github.com/elixir-lsp/elixir-ls/issues/765" onclick="return trackOutboundLink(&#39;what can elixir learn from typescript&#39;, &#39;https://github.com/elixir-lsp/elixir-ls/issues/765&#39;, event);">Rename support</a> is high on the list.</p>
<p>Writing a great language service is no easy task. But the TypeScript experience is that it&#39;s critical to invest in it, because it determines how it feels to use the language.</p>
<h3 id="Adopting-Types"><a href="#Adopting-Types" title="Adopting Types"></a>Adopting Types</h3><p>Side effects and mutation are notoriously difficult to model in a static type system. (<a target="_blank" rel="noopener" href="https://github.com/danvk/effective-typescript/blob/main/samples/ch-inference/one-var-one-type.md" onclick="return trackOutboundLink(&#39;what can elixir learn from typescript&#39;, &#39;https://github.com/danvk/effective-typescript/blob/main/samples/ch-inference/one-var-one-type.md&#39;, event);">Chapter Three</a> of <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" onclick="return trackOutboundLink(&#39;what can elixir learn from typescript&#39;, &#39;https://amzn.to/3UjPrsK&#39;, event);"><em>Effective TypeScript</em></a> is all about this.) Elixir is purely functional (no side effects) and has exclusively immutable data structures. This makes writing code harder (at least for me!) but it should make static type analysis easier.</p>
<p>And yet, despite being fertile ground for static type analysis, Elixir has, historically, been untyped. So I was excited to learn that they&#39;re <a target="_blank" rel="noopener" href="https://elixir-lang.org/blog/2022/10/05/my-future-with-elixir-set-theoretic-types/" onclick="return trackOutboundLink(&#39;what can elixir learn from typescript&#39;, &#39;https://elixir-lang.org/blog/2022/10/05/my-future-with-elixir-set-theoretic-types/&#39;, event);">introducing</a> an optional, gradual type system to the language. This should sound familiar to TypeScript users: TS pulled the same trick with JavaScript.</p>
<p>My first experiments with the new type system were deeply confusing. The new type system is, indeed, quite new. But if you search online for &#34;elixir type system,&#34; you&#39;ll find lots of material about how to use it. This only cleared up for me when I realized that Elixir has <em>two</em> type systems: the old one (<a target="_blank" rel="noopener" href="https://hexdocs.pm/dialyxir/readme.html" onclick="return trackOutboundLink(&#39;what can elixir learn from typescript&#39;, &#39;https://hexdocs.pm/dialyxir/readme.html&#39;, event);">Dialyzer</a>) and the new one (<a target="_blank" rel="noopener" href="https://hexdocs.pm/elixir/main/gradual-set-theoretic-types.html" onclick="return trackOutboundLink(&#39;what can elixir learn from typescript&#39;, &#39;https://hexdocs.pm/elixir/main/gradual-set-theoretic-types.html&#39;, event);">gradual set-theoretical types</a>).</p>
<p>There&#39;s a <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2306.06391" onclick="return trackOutboundLink(&#39;what can elixir learn from typescript&#39;, &#39;https://arxiv.org/abs/2306.06391&#39;, event);">paper</a> (arXiv) describing the high-level goals and workings of the new type system, as well a <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Jf5Hsa1KOc8" onclick="return trackOutboundLink(&#39;what can elixir learn from typescript&#39;, &#39;https://www.youtube.com/watch?v=Jf5Hsa1KOc8&#39;, event);">video</a> introducing it.</p>
<p>Set-theoretical type checking in Elixir seems very much a work-in-progress at this point. For example, you do get some errors in your editor:</p>
<figure><div><pre><code><span><span>def</span> <span>bad_add</span></span>() <span>do</span></code></pre></div></figure>

<p><img src="https://www.artima.com/images/elixir-type-error.png" alt="Type error for bad_add"/></p>
<p>But you get more errors when you compile from the command line. I never got type errors in function chains, where it&#39;s sometimes hard to remember if you&#39;re working with a list or list of lists. And I was constantly making errors in how I read from maps with tuple keys:</p>
<figure><div><pre><code><span><span>def</span> <span>read_tuple_from_map</span></span>() <span>do</span></code></pre></div></figure>

<p>The bad example does not produce a type error, at least not with Elixir 1.19.</p>
<p>It looks like the upcoming Elixir 1.20 release will add <a target="_blank" rel="noopener" href="https://hexdocs.pm/elixir/main/changelog.html#full-type-inference" onclick="return trackOutboundLink(&#39;what can elixir learn from typescript&#39;, &#39;https://hexdocs.pm/elixir/main/changelog.html#full-type-inference&#39;, event);">inference for whole functions</a>:</p>
<figure><div><pre><code><span><span>def</span> <span>add_foo_and_bar</span></span>(data) <span>do</span></code></pre></div></figure>
<blockquote>
<p>Elixir now infers that the function expects a map as first argument, and the map must have the keys .foo and .bar whose values are either integer() or float(). The return type will be either integer() or float().</p>
</blockquote>
<p>This is quite different than the sort of type inference that TypeScript does. TypeScript will infer a function&#39;s return type, but it never infers a parameter&#39;s type from the way that it&#39;s used in the function&#39;s body. (TypeScript will infer a parameter&#39;s type if it knows the function&#39;s type from context, for example if it&#39;s used as a callback.)</p>
<p>It&#39;s appealing to write fewer types, so why doesn&#39;t TypeScript do this sort of inference? The problem is that an implementation error in the function body can &#34;leak&#34; out into its signature, which will produce errors at call sites. Anders Hejlsberg, the creator of TypeScript, calls this &#34;spooky action at a distance.&#34; For example, if you had a typo in <code>add_foo_and_bar</code>, say you accessed <code>.baz</code>:</p>
<figure><div><pre><code><span><span>def</span> <span>add_foo_and_bar</span></span>(data) <span>do</span></code></pre></div></figure>

<p>then this would change the inferred type signature and you&#39;d get errors at all your call sites. But the mistake is in the function body, not the call sites! The idea behind requiring type annotations for parameters is that you should know these types when you write your function. By writing explicit annotations, you make it clear to TypeScript whether the error is in the implementation or the caller.</p>
<p>We&#39;ll see how much of an issue this winds up being for Elixir. I suspect TypeScript&#39;s policy would be hard for Elixir to adopt in practice because its functional style encourages you to write lots of small, standalone helper functions that might be boilerplatey to type explicitly.</p>
<p>(See <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/15114#issuecomment-307201572" onclick="return trackOutboundLink(&#39;what can elixir learn from typescript&#39;, &#39;https://github.com/microsoft/TypeScript/issues/15114#issuecomment-307201572&#39;, event);">this comment</a> from Ryan Cavanaugh for more on why TypeScript doesn&#39;t infer types for function parameters.)</p>
<h2 id="General-Impressions-of-Elixir"><a href="#General-Impressions-of-Elixir" title="General Impressions of Elixir"></a>General Impressions of Elixir</h2><p>AoC isn’t a very good showcase for Elixir — it’s most well-known for concurrency, which is completely irrelevant for Advent of Code problems. Overall I didn’t dislike Elixir as much as I thought I might after the first week, but I never really came to like it that much, either.</p>
<ul>
<li>Elixir editor integration isn’t great, at least not in VS Code. There are big things (lack of types and quickinfo on variables) and small things (lack of F2 rename, bad autocompletes, screens of red).</li>
<li>The lack of types makes Elixir dramatically less enjoyable to use.</li>
<li>FP &amp; immutability didn’t throw me off as much as I’d worried. After a few days, you get used to <code>Enum.reduce</code>. The pipeline operator is nice and comprehensions feel more like <code>for</code> loops that you’d write in other languages.</li>
<li>There are some weird things: why the obsession with function arity? Why those weirdly-restricted filter clauses in for loops? Why aren’t functions first-class? Printing things is surprisingly fraught. The differences between <code>&amp;&amp;</code> and <code>and</code>. The crazy range operator. No either/or matches. The weird <code>Map.get_and_update</code> method.</li>
<li>My sense is that performance isn’t great… I assume that being compiled helps, but being functional and immutable hurts. My solutions generally seemed to be slower than the Python ones. Linked lists are a terrible data structure, but FP pushes you to use them for everything. There’s tons of potential for accidental O(N^2). ex: charlists</li>
</ul>
<h2 id="Thoughts-on-the-2024-Advent-of-Code"><a href="#Thoughts-on-the-2024-Advent-of-Code" title="Thoughts on the 2024 Advent of Code"></a>Thoughts on the 2024 Advent of Code</h2><p>This was the first year where AI assistants like GitHub Copilot were relevant to the competition. I think Eric made some of the problem statements more elaborate than in the past to try and throw them off. I doubt it worked. Some of the winning times were suspiciously fast.</p>
<p>I didn&#39;t find GitHub Copilot particularly helpful for the 2024 Advent of Code problems. I did a few of the <a target="_blank" rel="noopener" href="https://github.com/danvk/aoc2016" onclick="return trackOutboundLink(&#39;thoughts on the  advent of code&#39;, &#39;https://github.com/danvk/aoc2016&#39;, event);">2016 problems</a> as a warm-up, and it was <em>wildly</em> helpful there. Sometimes you&#39;d just start writing some boilerplate and Copilot autocomplete would fill in the entire solution! This makes sense if you think about it: the LLM&#39;s training data includes thousands of solutions to old Advent of Code problems in many languages, including Elixir.</p>
<p>The difficulty level in 2024 didn&#39;t feel too high. For me, 2019 remains the most difficult Advent of Code. As usual, building some tools for working with grids and doing BFS / A* search is helpful.</p>
<p>Standout puzzles for me included:</p>
<ul>
<li>Days 11–13: linear algebra in unfamiliar contexts</li>
<li><a target="_blank" rel="noopener" href="https://adventofcode.com/2024/day/14" onclick="return trackOutboundLink(&#39;thoughts on the  advent of code&#39;, &#39;https://adventofcode.com/2024/day/14&#39;, event);">Day 14</a>: I loved hearing how everyone found their Christmas tree. I looked for states where an unusual number of robots had neighbors, but I think the best was to look for the lowest entropy state.</li>
<li><a target="_blank" rel="noopener" href="https://adventofcode.com/2024/day/16" onclick="return trackOutboundLink(&#39;thoughts on the  advent of code&#39;, &#39;https://adventofcode.com/2024/day/16&#39;, event);">Day 16</a>: I liked the variations on BFS.</li>
<li><a target="_blank" rel="noopener" href="https://adventofcode.com/2024/day/19" onclick="return trackOutboundLink(&#39;thoughts on the  advent of code&#39;, &#39;https://adventofcode.com/2024/day/19&#39;, event);">Day 19</a>: Eric teaches everyone how <code>grep</code> works.</li>
<li><a target="_blank" rel="noopener" href="https://adventofcode.com/2024/day/21" onclick="return trackOutboundLink(&#39;thoughts on the  advent of code&#39;, &#39;https://adventofcode.com/2024/day/21&#39;, event);">Day 21</a>: Recursive keypads. This was probably my favorite puzzle this year, though it took some fiddling to get the right solution in the end.</li>
<li><a target="_blank" rel="noopener" href="https://adventofcode.com/2024/day/24" onclick="return trackOutboundLink(&#39;thoughts on the  advent of code&#39;, &#39;https://adventofcode.com/2024/day/24&#39;, event);">Day 24</a>: I enjoyed the variety of solutions, particularly the people who visualized the circuit. I looked at the inputs to each output bit and used that to pare down to a manageable set of gates.</li>
</ul>
<p>I didn&#39;t like day 20, the number we were computed felt very contrived and that threw me off. Days 22 and 23 were surprisingly easy. I had trouble with days 9 and 17 and wound up implementing solutions in Python.</p>
<p>Just like <a target="_blank" rel="noopener" href="https://medium.com/@danvdk/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd" onclick="return trackOutboundLink(&#39;thoughts on the  advent of code&#39;, &#39;https://medium.com/@danvdk/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd&#39;, event);">2019</a>, I was traveling for much of December and internet connectivity was sometimes an issue. Some of the lodges we stayed in had Starlink in the dining area, so I&#39;d load the Advent of Code problem on my phone and Airdrop my input to my laptop back in our room. I queued up five or six problems to work on during my flight back and submitted all my answers on my phone when we landed.</p>
<h2 id="Conclusions"><a href="#Conclusions" title="Conclusions"></a>Conclusions</h2><p>Overall I enjoyed the 2024 Advent of Code. I wasn&#39;t a big fan of Elixir, though I understand that Advent of Code doesn&#39;t play to its strengths. Solving problems in a functional language wasn&#39;t as painful as I expected, so I might try it again next year. Speaking of which, the 2025 Advent of Code is going to be <a target="_blank" rel="noopener" href="https://adventofcode.com/2025/about#faq_num_days" onclick="return trackOutboundLink(&#39;conclusions&#39;, &#39;https://adventofcode.com/2025/about#faq_num_days&#39;, event);">quite different</a>!</p>
<p>You can find my code at <a target="_blank" rel="noopener" href="https://github.com/danvk/aoc2024" onclick="return trackOutboundLink(&#39;conclusions&#39;, &#39;https://github.com/danvk/aoc2024&#39;, event);">danvk/aoc2024</a> (all days) and <a target="_blank" rel="noopener" href="https://github.com/danvk/aoc2016" onclick="return trackOutboundLink(&#39;conclusions&#39;, &#39;https://github.com/danvk/aoc2016&#39;, event);">danvk/aoc2016</a> (days 1-11).</p>

          </div></div>
  </body>
</html>
