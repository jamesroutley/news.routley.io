<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://shikaan.github.io/assembly/x86/guide/2024/09/08/x86-64-introduction-hello.html">Original</a>
    <h1>A Friendly Introduction to Assembly for High-Level Programmers</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Coming from JavaScript, Rust, C, or any other high-level language, looking at assembly snippets can be confusing or even scary.</p>

<p>Let’s take the following snippet:</p>
<div><div><pre><code><span>section</span> <span>.data</span>
  <span>msg</span> <span>db</span> <span>&#34;Hello, World!&#34;</span>

<span>section</span> <span>.text</span>
  <span>global</span> <span>_start</span>

<span>_start:</span>
  <span>mov</span> <span>rax</span><span>,</span> <span>1</span>
  <span>mov</span> <span>rdi</span><span>,</span> <span>1</span>
  <span>mov</span> <span>rsi</span><span>,</span> <span>msg</span>
  <span>mov</span> <span>rdx</span><span>,</span> <span>13</span>
  <span>syscall</span>

  <span>mov</span> <span>rax</span><span>,</span> <span>60</span>
  <span>mov</span> <span>rdi</span><span>,</span> <span>0</span>
  <span>syscall</span>
</code></pre></div></div>
<p>Thankfully the second line gives away what this does.</p>

<p>None of the bread and butter of programming as we know it is here: conditionals and loops are nowhere to be seen, there is no way to create functions… heck, variables don’t even have names!</p>

<p>Where does one even start?</p>

<p>This little introduction is meant to introduce you, somebody with programming experience, to the world of assembly. We’ll discuss the basics of the language and map them to high-level programming constructs.</p>

<p>By the end of this guide, you will be able to navigate assembly code, know where to look for information, and even write some simple programs all by yourself.</p>

<p>Let’s get started!</p>

<h2 id="hello-world">Hello world</h2>

<p>Unsurprisingly, our first program will be a “Hello World”.</p>

<p>Before jumping into the code though, we need to briefly introduce the language we’ll be using. At the end of this section, we will be able to write and run our first assembly program.</p>

<h3 id="x86-64-assembly">x86-64 assembly</h3>

<p>First things first, assembly is not a language.</p>

<p>Assembly refers to a <em>family of programming languages</em> featuring instructions that closely map to the machine code that the CPU will execute. In fact, one of the raisons d’etre of assembly languages is to provide a human-readable version of machine code in situations like reverse engineering, hardware programming, or developing games for consoles.</p>

<p>In this guide, we will use <em>x86-64 assembly</em> which can be assembled and executed on most personal computers. This choice should ease running and tinkering with the snippets along the way.</p>

<p>For historical reasons, there are two “flavors” of the x64-64 assembly syntax: one called <em>Intel</em> and the other is called <em>AT&amp;T</em><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<p>In this guide we will stick to the <em>Intel</em> dialect because it’s used by the <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel Software Developer Manuals (SDM)</a>, the source of truth on what the CPU <em>really</em> does when fed an instruction.</p>

<p>Assembly is all about working close to the hardware. Optimizimg for portability of the code examples across operative systems and architactures would obfuscate the content of this introduction.</p>

<p>The snippets we will be written for Linux, and they should run fine on Window’s WSL as well. The general concepts and practices are nonetheless valid regardless of your OS of choice.</p>

<h3 id="anatomy-of-an-instruction">Anatomy of an instruction</h3>

<p>Instructions are the way we tell the CPU what to do. They look something like this:</p>



<p>They represent the smallest unit of assembly language and are mostly composed of two parts:</p>

<ul>
  <li><strong>mnemonic</strong>: a shortened word or sentence that specifies the operation to be performed</li>
  <li><strong>operands</strong>: a list of 0-3 items representing what’s affected by the operation</li>
</ul>

<p>In our example, the mnemonic is <code>mov</code>, which stands for <em>move</em>, and the operands are <code>rax</code> and <code>rbx</code>. This instruction in plain English would read: move the content of <code>rbx</code> in <code>rax</code>.</p>

<blockquote>
  <p><strong>Note</strong></p>

  <p><code>rax</code> and <code>rbx</code> are registers and we will introduce them in the next paragraph. In the meantime, you can imagine them as variables holding a value.</p>
</blockquote>

<p>Some instructions will have more then mnemonic and operands. Additional parts such as <em>prefixes</em> and <em>size directives</em> will only be needed later, and we’ll talk through them at the right moment.</p>

<p>Fear not, there is no need to memorize all the possible instructions now. Whenever we’ll come across new operations, we will discuss them, and with repetition you will remember in no time.</p>

<p>The <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel Software Developer Manuals (SDM)</a> will be our instruction reference in the next chapters. Keep it handy!</p>

<h3 id="storing-data-registers">Storing data: Registers</h3>

<p>You can think of registers as storage space baked right into the CPU itself. They are small and incredibly fast to access.</p>

<p>The most common registers are the so-called <em>general purpose</em> registers. In x86-64 they are sixteen in total, and they are 64 bits wide.</p>

<p>One can access the whole register or a subset by using different names. For example, using <code>rax</code> (as in the code above) would address all the 64 bits in the <code>rax</code> register. With <code>al</code>, you can access the lower byte of the same register.</p>

<table>
  <thead>
    <tr>
      <th>Register</th>
      <th>Higher byte</th>
      <th>Lower byte</th>
      <th>Lower 2 bytes¹</th>
      <th>Lower 4 bytes²</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>rax</td>
      <td>ah</td>
      <td>al</td>
      <td>ax</td>
      <td>eax</td>
    </tr>
    <tr>
      <td>rcx</td>
      <td>ch</td>
      <td>cl</td>
      <td>cx</td>
      <td>ecx</td>
    </tr>
    <tr>
      <td>rbx</td>
      <td>bh</td>
      <td>bl</td>
      <td>bx</td>
      <td>ebx</td>
    </tr>
    <tr>
      <td>rdx</td>
      <td>dh</td>
      <td>dl</td>
      <td>dx</td>
      <td>edx</td>
    </tr>
    <tr>
      <td>rsp</td>
      <td> </td>
      <td>spl</td>
      <td>sp</td>
      <td>esp</td>
    </tr>
    <tr>
      <td>rsi</td>
      <td> </td>
      <td>sil</td>
      <td>si</td>
      <td>esi</td>
    </tr>
    <tr>
      <td>rdi</td>
      <td> </td>
      <td>dil</td>
      <td>di</td>
      <td>edi</td>
    </tr>
    <tr>
      <td>rbp</td>
      <td> </td>
      <td>bpl</td>
      <td>bp</td>
      <td>ebp</td>
    </tr>
    <tr>
      <td>r8</td>
      <td> </td>
      <td>r8b</td>
      <td>r8w</td>
      <td>r8d</td>
    </tr>
    <tr>
      <td>r9</td>
      <td> </td>
      <td>r9b</td>
      <td>r9w</td>
      <td>r9d</td>
    </tr>
    <tr>
      <td>r10</td>
      <td> </td>
      <td>r10b</td>
      <td>r10w</td>
      <td>r10d</td>
    </tr>
    <tr>
      <td>r11</td>
      <td> </td>
      <td>r11b</td>
      <td>r11w</td>
      <td>r11d</td>
    </tr>
    <tr>
      <td>r12</td>
      <td> </td>
      <td>r12b</td>
      <td>r12w</td>
      <td>r12d</td>
    </tr>
    <tr>
      <td>r13</td>
      <td> </td>
      <td>r13b</td>
      <td>r13w</td>
      <td>r13d</td>
    </tr>
    <tr>
      <td>r14</td>
      <td> </td>
      <td>r14b</td>
      <td>r14w</td>
      <td>r14d</td>
    </tr>
    <tr>
      <td>r15</td>
      <td> </td>
      <td>r15b</td>
      <td>r15w</td>
      <td>r15d</td>
    </tr>
  </tbody>
</table>

<p><sup>
¹: 2 bytes are sometimes called words (hence the w suffix)
</sup></p>

<p>General purpose means that they can store anything in principle. In practice, we’ll see that some registers have special meanings, some instructions only use certain registers, and some conventions dictate who is expected to write where.</p>

<p>The only non-general-purpose register we will be concerned with is <code>rip</code> the <em>instruction pointer</em> register. It holds the address of the next instruction to execute, and therefore, modifying <code>rip</code> allows programs to jump to arbitrary instructions in the code.</p>

<h3 id="our-first-assembly-file">Our first assembly file</h3>

<p>Assembly files typically have an <code>.s</code> or <code>.asm</code> extension and they are split in three sections:</p>
<ul>
  <li><strong>data</strong>: where we define constants and initialized variables;</li>
  <li><strong>bss</strong>: where we define non-initialized variables;</li>
  <li><strong>text</strong>: where we will type our code, this is the only mandatory section of the file.</li>
</ul>

<div><div><pre><code><span>section</span> <span>.data</span>
  <span>; constants here</span>

<span>section</span> <span>.bss</span>
  <span>; variables here</span>

<span>section</span> <span>.text</span>
  <span>; code here</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Note</strong></p>

  <p>The semicolon <code>;</code> is the comment character: whatever comes after it will not be executed.</p>
</blockquote>

<p>Assembly programs run as you would expect. They start with the first instruction and sequentially execute one instruction after the other, from top to bottom. To create control flow, such as conditionals and loops, we make our programs ‘jump’ to specific instructions. We will look at jumps in detail in the next sections.</p>

<p>Just as you’d use a <code>main</code> function in many high-level languages, assembly requires us to specify an entry point for our program. We do this using the <code>global</code> declaration, which points to a <em>label</em>.</p>

<p>Labels are the assembly’s way of giving human-readable names to specific instructions. They serve two purposes: making our code more understandable and allowing us to reference these instructions elsewhere in our program. You can declare a label by writing it followed by a colon, like this: <code>label:</code>. When you want to reference a label (for example, in a jump instruction), use it without the colon: <code>label</code>.</p>

<p>Typically, <code>global</code> references a <code>_start</code> label declared immediately after it. That is where our program will start executing.</p>

<div><div><pre><code><span>section</span> <span>.data</span>
  <span>; constants here</span>

<span>section</span> <span>.bss</span>
  <span>; variables here</span>

<span>section</span> <span>.text</span>
  <span>global</span> <span>_start</span>
<span>_start:</span>
  <span>; instructions here</span>
</code></pre></div></div>

<h3 id="at-last-hello-world">At last, “Hello World”</h3>

<p>Finally, we have all the tools to build software in assembly. Very Nice!</p>

<p>Our program will use two system calls: <code>sys_write</code> to print characters in a terminal and <code>exit</code> to terminate the process with a given status code.</p>

<p>Using syscalls goes like this:</p>
<ul>
  <li>select the syscall to invoke by moving its identifier in <code>rax</code></li>
  <li>pass arguments to the syscall by populating appropriate registers</li>
  <li>use the <code>syscall</code> instruction to fire the call</li>
</ul>

<p>The only other instruction we will use is <code>mov</code> which we have seen in the instruction paragraph. It works pretty much like an assignment (the <code>=</code> operator) in many high-level languages: it moves the content of the second operand into the first operand.</p>

<p>Let’s look at the code to see how this plays together.</p>

<blockquote>
  <p><strong>Coding along</strong></p>

  <p>Throughout this series, we’ll use an embedded editor to tinker with the code and run the examples as we go. The same content can be found in the sibling repository <a href="https://github.com/shikaan/x86-64-asm-intro">shikaan/x86-64-asm-intro</a> if you want to run locally.</p>

  <p>All the snippets are commented to explain what’s going on step by step. Make sure you read the comments carefully!</p>
</blockquote>

<code-editor exercise="01-hello.asm"></code-editor>

<h3 id="conclusion">Conclusion</h3>

<p>We have a “hello world”!</p>

<p>In this first article, we learned some basic assembly concepts, we cut our teeth on its syntax, and we even wrote some working software. Moreover, we explored how to communicate with the operative system and are ready to produce more interesting programs <a href="https://shikaan.github.io/assembly/x86/guide/2024/09/16/x86-64-conditionals.html">in the next article</a>.</p>



<hr/>

<template id="code-editor">
  
  
  
  <pre id="output">Loading...</pre>
</template>





  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
