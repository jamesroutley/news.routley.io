<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ariadne.space/2022/07/17/how-efficient-can-cat1-be/">Original</a>
    <h1>How efficient can cat(1) be?</h1>
    
    <div id="readability-page-1" class="page"><div id="site-content">

	
<article id="post-483">

	
<!-- .entry-header -->

	<div>

		<div>

			
<p>There have been a few initiatives in recent years to implement new a new userspace base system for Linux distributions as an alternative to the GNU coreutils and BusyBox.  Recently, one of the authors of one of these proposed implementations made the pitch in a few IRC channels <a href="https://vimuser.org/cat.c.txt">that her <code>cat</code> implementation</a>, which was derived from OpenBSD’s implementation, was the most efficient.  But is it actually?</p>



<h2>Understanding what <code>cat</code> actually does</h2>



<p>At the most basic level, <code>cat</code> takes one or more files and dumps them to <code>stdout</code>.  But do we need to actually use <code>stdio</code> for this?  Actually, we don’t, and most competent <code>cat</code> implementations at least use <code>read(2)</code> and <code>write(2)</code> if not more advanced approaches.</p>



<p>If we consider <code>cat</code> as a form of buffer copy between an arbitrary file descriptor and <code>STDOUT_FILENO</code>, we can understand what the most efficient strategy to use for <code>cat</code> would be: splicing.  Anything which isn’t doing splicing, after all, involves unnecessary buffer copies, and thus cannot be the most efficient.</p>



<p>To get the best performance out of spliced I/O, we have to have some prerequisites:</p>



<ul><li>The source and destination file descriptors should be unbuffered.</li><li>Any intermediate buffer should be a multiple of the filesystem block size.  In general, to avoid doing a <code>stat</code> syscall, we can assume that a multiple of <code>PAGE_SIZE</code> is likely acceptable.</li></ul>



<h2>A simple <code>cat</code> implementation</h2>



<p>The simplest way to implement <code>cat</code> is the way that it is done in BSD: using <code>read</code> and <code>write</code> on an intermediate buffer.  This results in two buffer copies, but has the best portability.  Most implementations of <code>cat</code> work this way, as it generally offers good enough performance.</p>



<pre><code>/* This program is released into the public domain. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;err.h&gt;
#include &lt;errno.h&gt;
#include &lt;limits.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

void dumpfile(const char *path)
{
	int srcfd = STDIN_FILENO;
	char buf[PAGE_SIZE * 16];
	ssize_t nread, nwritten;
	size_t offset;

	/* POSIX allows - to represent stdin. */
	if (*path != &#39;-&#39;)
	{
		srcfd = open(path, O_RDONLY);
		if (srcfd &lt; 0)
			err(EXIT_FAILURE, &#34;open %s&#34;, path);
	}

	while ((nread = read(srcfd, buf, sizeof buf)) &gt;= 1)
	{
		for (offset = 0; nread &gt; 0; nread -= nwritten, offset += nwritten)
		{
			if ((nwritten = write(STDOUT_FILENO, buf + offset, nread)) &lt;= 0)
				err(EXIT_FAILURE, &#34;write stdout&#34;);
		}
	}

	if (srcfd != STDIN_FILENO)
		(void) close(srcfd);
}

int main(int argc, const char *argv[])
{
	int i;

	for (i = 1; i &lt; argc; i++)
		dumpfile(argv[i]);

	return EXIT_SUCCESS;
}</code></pre>



<h2>Implementing spliced I/O</h2>



<p>Linux has no shortage of ways to perform spliced I/O.  For our <code>cat</code> implementation, we have two possible ways to do it.</p>



<p>The first possible option is the venerable <code>sendfile</code> syscall, which was <a href="https://yarchive.net/comp/linux/sendfile.html">originally added to improve the file serving performance of web servers</a>.  Originally, <code>sendfile</code> required the destination file descriptor to be a socket, but this restriction was removed in Linux 2.6.33.  Unfortunately, <code>sendfile</code> is not perfect: because it only supports file descriptors which can be memory mapped, we must use a different strategy when using copying from <code>stdin</code>.</p>



<pre><code>/* This program is released into the public domain. */
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;err.h&gt;
#include &lt;errno.h&gt;
#include &lt;limits.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/sendfile.h&gt;

bool spliced_copy(int srcfd)
{
	ssize_t nwritten;
	off_t offset = 0;

	do
	{
		nwritten = sendfile(STDOUT_FILENO, srcfd, &amp;offset,
				    PAGE_SIZE * 16);
		if (nwritten &lt; 0)
			return false;
	} while (nwritten &gt; 0);

	return true;
}

void copy(int srcfd)
{
	char buf[PAGE_SIZE * 16];
	size_t nread, nwritten, offset;

	while ((nread = read(srcfd, buf, sizeof buf)) &gt;= 1)
	{
		for (offset = 0; nread &gt; 0;
		     nread -= nwritten, offset += nwritten)
		{
			if ((nwritten = write(STDOUT_FILENO,
					      buf + offset, nread)) &lt;= 0)
				err(EXIT_FAILURE, &#34;write stdout&#34;);
		}
	}
}

void dumpfile(const char *path)
{
	int srcfd = STDIN_FILENO;
	char buf[PAGE_SIZE * 16];

	/* POSIX allows - to represent stdin. */
	if (*path != &#39;-&#39;)
	{
		srcfd = open(path, O_RDONLY);
		if (srcfd &lt; 0)
			err(EXIT_FAILURE, &#34;open %s&#34;, path);
	}

	/* Fall back to traditional copy if the spliced version fails. */
	if (!spliced_copy(srcfd))
		copy(srcfd);

	if (srcfd != STDIN_FILENO)
		(void) close(srcfd);
}

int main(int argc, const char *argv[])
{
	int i;
	int stdout_flags;

	stdout_flags = fcntl(STDOUT_FILENO, F_GETFL);
	if (stdout_flags &lt; 0)
		err(EXIT_FAILURE, &#34;fcntl(STDOUT_FILENO, F_GETFL)&#34;);
	stdout_flags &amp;= ~O_APPEND;
	if (fcntl(STDOUT_FILENO, F_SETFL, stdout_flags) &lt; 0)
		err(EXIT_FAILURE, &#34;fcntl(STDOUT_FILENO, F_SETFL)&#34;);

	for (i = 1; i &lt; argc; i++)
		dumpfile(argv[i]);

	return EXIT_SUCCESS;
}</code></pre>



<p>Another approach is to use <code>splice</code> and a pipe.  This allows for true zero-copy I/O in userspace, as a pipe is simply implemented as a 64KB ring buffer in the kernel.  In this case, we just use two splice operations per block of data we want to copy: one to move the data to the pipe and another to move the data from the pipe to the output file.</p>



<pre><code>/* This program is released into the public domain. */
#define _GNU_SOURCE
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;err.h&gt;
#include &lt;errno.h&gt;
#include &lt;limits.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/sendfile.h&gt;

#define BLOCK_SIZE ((PAGE_SIZE * 16) - 1)

bool spliced_copy(int srcfd)
{
	int pipefd[2];
	ssize_t nread, nwritten;
	off_t in_offset = 0;
	bool ret = true;

	if (pipe(pipefd) &lt; 0)
		err(EXIT_FAILURE, &#34;pipe&#34;);

	do
	{
		nread = splice(srcfd, &amp;in_offset, pipefd[1], NULL,
			       BLOCK_SIZE, SPLICE_F_MOVE | SPLICE_F_MORE);
		if (nread &lt;= 0)
		{
			ret = nread &lt; 0 ? false : true;
			goto out;
		}

		nwritten = splice(pipefd[0], NULL, STDOUT_FILENO, NULL,
				  BLOCK_SIZE, SPLICE_F_MOVE | SPLICE_F_MORE);
		if (nwritten &lt; 0)
		{
			ret = false;
			goto out;
		}
	} while (nwritten &gt; 0);

out:
	close(pipefd[0]);
	close(pipefd[1]);

	return ret;
}

void copy(int srcfd)
{
	char buf[PAGE_SIZE * 16];
	size_t nread, nwritten, offset;

	while ((nread = read(srcfd, buf, sizeof buf)) &gt;= 1)
	{
		for (offset = 0; nread &gt; 0;
		     nread -= nwritten, offset += nwritten)
		{
			if ((nwritten = write(STDOUT_FILENO,
					      buf + offset, nread)) &lt;= 0)
				err(EXIT_FAILURE, &#34;write stdout&#34;);
		}
	}
}

void dumpfile(const char *path)
{
	int srcfd = STDIN_FILENO;
	char buf[PAGE_SIZE * 16];

	/* POSIX allows - to represent stdin. */
	if (*path != &#39;-&#39;)
	{
		srcfd = open(path, O_RDONLY);
		if (srcfd &lt; 0)
			err(EXIT_FAILURE, &#34;open %s&#34;, path);

		(void) posix_fadvise(srcfd, 0, 0, POSIX_FADV_SEQUENTIAL);
	}

	/* Fall back to traditional copy if the spliced version fails. */
	if (!spliced_copy(srcfd))
		copy(srcfd);

	if (srcfd != STDIN_FILENO)
		(void) close(srcfd);
}

int main(int argc, const char *argv[])
{
	int i;
	int stdout_flags;

	stdout_flags = fcntl(STDOUT_FILENO, F_GETFL);
	if (stdout_flags &lt; 0)
		err(EXIT_FAILURE, &#34;fcntl(STDOUT_FILENO, F_GETFL)&#34;);
	stdout_flags &amp;= ~O_APPEND;
	if (fcntl(STDOUT_FILENO, F_SETFL, stdout_flags) &lt; 0)
		err(EXIT_FAILURE, &#34;fcntl(STDOUT_FILENO, F_SETFL)&#34;);

	for (i = 1; i &lt; argc; i++)
		dumpfile(argv[i]);

	return EXIT_SUCCESS;
}</code></pre>



<h2>Honorable mention: <code>copy_file_range</code></h2>



<p>While <code>copy_file_range</code> is not really that relevant to a <code>cat</code> implementation, if both the source and output files are normal files, you can use it to get even faster performance than using splice, as the kernel handles all of the details on its own.  An optimized <code>cat</code> might try this strategy and then downgrade to <code>splice</code>, <code>sendfile</code>, and the normal <code>read</code> and <code>write</code> loop.</p>



<h2>Performance comparison</h2>



<p>To measure the performance of each strategy, we can simply use <code>dd</code> as a sink, running each cat program piped into <code>dd of=/dev/null bs=64K iflag=fullblock</code>.  The runs in the table below are averaged across 1000 runs on a 8GB RAM Linode, using a 4GB file in <code>tmpfs</code>.</p>



<figure><table><thead><tr><th>Strategy</th><th>Throughput</th></tr></thead><tbody><tr><td><code>cat-simple</code> (<code>read</code> and <code>write</code> loop)</td><td>3.6 GB/s</td></tr><tr><td><code>cat-sendfile</code></td><td>6.4 GB/s</td></tr><tr><td><code>cat-splice</code></td><td>11.6 GB/s</td></tr></tbody></table></figure>



<p>If you are interested in using these implementations in your own <code>cat</code> implementation, you may do so under any license terms you wish.</p>


		</div><!-- .entry-content -->

	</div><!-- .post-inner -->

	<!-- .section-inner -->

	
	<!-- .pagination-single -->

	
		<!-- .comments-wrapper -->

		
</article><!-- .post -->

</div></div>
  </body>
</html>
