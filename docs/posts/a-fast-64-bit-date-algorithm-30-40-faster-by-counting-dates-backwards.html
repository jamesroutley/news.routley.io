<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.benjoffe.com/fast-date-64">Original</a>
    <h1>A Fast 64-Bit Date Algorithm (30–40% faster by counting dates backwards)</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><nav><strong>Other Date/Time Articles:</strong><ul><li><a href="https://www.benjoffe.com/fast-date" data-discover="true">Article 1: Fast Date (32-Bit)</a></li><li><a href="https://www.benjoffe.com/safe-date" data-discover="true">Article 2: Safe Date (32-Bit)</a></li><li><b>Article 3: Very Fast Date (64-Bit)</b></li></ul><ul><li><a href="https://www.benjoffe.com/smoitus" data-discover="true">Smoital System - Time on Mars</a></li><li><a href="https://www.benjoffe.com/weekle">Weekle - Weekday Guessing Game</a></li></ul></nav><h2><em>Counting years backwards unlocks faster speed.</em></h2><p><small>23 November 2025</small></p><p>In this article I present my final <em>very</em> fast date conversion algorithm. It represents a significant speed gain — being similar in magnitude to the speed gains achieved by the previous fastest algorithm (Neri-Schneider 2021) over its predecessor (C++ Boost). The full algorithm <a href="https://github.com/benjoffe/fast-date-benchmarks/blob/main/algorithms/benjoffe_fast64.hpp" target="_blank">implementation in C++ <img src="https://www.benjoffe.com/static/media/link-external.8c7dd7499c66b544fc0495ec612b0288.svg"/></a> is released as free open source software (BSL-1.0 License).</p><p>The algorithm provides accurate results over a period of ±1.89 Trillion years, making it suitable to process the full UNIX 64–bit time (in seconds).</p><p>The entire algorithm has been re-written top-to-bottom, with various micro-optimisations, but three main new ideas:</p><ul><li><b>Years are calculated <em>backwards</em></b>, which removes various intermediate steps.</li><li><b>The step to calculate day-of-year is <em>skipped</em></b>, instead using a year-modulus-bitshift technique which removes a division.</li><li><b>The <em>&#34;Julian Map&#34;</em> technique is utilised</b> from my previous article, which speeds up the 100/400 year calculation, removing two more hardware multiplications.</li></ul><p>While fast date algorithms have always used 7 or more expensive computations (multiplication, division, or modulus by non-power-of-2 numbers), <b>this algorithm uses only 4 multiplications</b>. The speed-gain can be seen at a glance.</p><div><p><b>Relative Speeds of Fastest Algorithms</b>As tested on Intel x64 and Apple M4 Pro processors</p></div><p>The benchmark results match what is expected by hand-counting operations:</p><table><thead><tr><th colspan="4">Approx. CPU Cycles Comparison (x64)</th></tr><tr><th>Algorithm</th><th>Multiplications <code>`M`</code></th><th>Basic Operations <code>`B`</code></th><th>Approx Cycles</th></tr></thead><tbody><tr><th>C++ Boost</th><td>10</td><td>21</td><td>51</td></tr><tr><th>Neri-Schneider</th><td>7</td><td>19</td><td>40</td></tr><tr><th>This Algorithm</th><td>4</td><td>15</td><td>27</td></tr></tbody></table><p>I will first present the general algorithm in pseudocode, then explain <a href="#backwards">why it counts years backwards</a>, then <a href="#explanation">step through it line-by-line</a> with an explanation of each step. <a href="#optimisations">Platform-specific optimisations</a> are then outlined (x64 vs ARM / Apple Silicon), followed by details about <a href="#range">range/accuracy</a>, a discussion of various <a href="#portability">32–bit fallback options</a>, and finally the <a href="#benchmarks">benchmark results</a> (which you can test yourself).</p><hr/><h2>The Full Algorithm</h2><p>Colours are used to indicate the following:</p><ul><li><span>Red</span>: Expensive operations <i>(i.e. the four multiplications)</i></li><li><span>Green</span>: Operations that are <em>“free”</em> on x64 processors</li><li><span>Pink</span> Comments: Highlighting the most notable new concepts</li></ul><p>Given:   <code><em><b>days</b></em> = <em>Days since epoch, where &#34;1970-01-01&#34; is zero</em></code>   —   Then:</p><div><p><strong>Very Fast 64–Bit Date Algorithm (x64 version)</strong></p><div><ol><li><pre><span>const</span> <em>ERAS</em> = 4726498270         </pre></li><li><pre><span>const</span> <em>D_SHIFT</em> = 146097 * ERAS - 719469</pre></li><li><pre><span>const</span> <em>Y_SHIFT</em> = 400 * ERAS - 1</pre></li><li><pre><span>const</span> <em>C1</em> = 505054698555331      </pre></li><li><pre><span>const</span> <em>C2</em> = 50504432782230121    </pre></li><li><pre><span>const</span> <em>C3</em> = 8619973866219416     </pre></li><li><pre></pre></li><li><pre></pre></li><li><pre><em>rev</em> = <em>D_SHIFT</em> - <em>days</em>            </pre></li><li><pre><em>cen</em> = (<em>rev</em> <b>*</b> <em>C1</em>) <span>&gt;&gt; 64</span>          </pre></li><li><pre><em>jul</em> = <em>rev</em> + <em>cen</em> - <em>cen</em> / 4       </pre></li><li><pre></pre></li><li><pre></pre></li><li><pre><em>num</em> = <em>jul</em> <b>*</b> <em>C2</em>                  </pre></li><li><pre><em>yrs</em> = <em>Y_SHIFT</em> - (<em>num</em> <span>&gt;&gt; 64</span>)     </pre></li><li><pre><span><em>low</em> = <em>num</em> % (1 &lt;&lt; 64)</span>           </pre></li><li><pre><em>ypt</em> = (782432 <b>*</b> <em>low</em>) <span>&gt;&gt; 64</span>      </pre></li><li><pre></pre></li><li><pre><em>bump</em> = <em>ypt</em> &lt; 126464             </pre></li><li><pre><em>shift</em> = <em>bump</em> ? 191360 : 977792  </pre></li><li><pre></pre></li><li><pre></pre></li><li><pre></pre></li><li><pre><em>N</em> = (<em>yrs</em> % 4) * 512 + <em>shift</em> - <em>ypt</em></pre></li><li><pre><em>D</em> = ((<em>N</em> <span>% 65536</span>) <b>*</b> C3) <span>&gt;&gt; 64</span>    </pre></li><li><pre></pre></li><li><pre><em><b>day</b></em> = <em>D</em> + 1</pre></li><li><pre><em><b>month</b></em> = <em>N</em> / 65536</pre></li><li><pre><em><b>year</b></em> = <em>yrs</em> + <em>bump</em></pre></li></ol></div></div><p>Note:</p><ul><li>This is the x64 optimised version of the algorithm. See the section later for <a href="#optimisations">ARM-specific optimisations</a>.</li></ul><hr/><h2 id="backwards">Why Count Backwards</h2><p>It is no surprise that most (if not all) fast date conversion algorithms have counted years in the forward direction, it is the default intuitive choice.</p><p>When doing so, one ends up with terms of the format <code>(foo * 4 + 3) / N</code>. This is one of the most common patterns you&#39;ll see across fast date algorithms. An example from C++ Boost is shown below:</p><div><p><strong>C++ Boost (extract)<a href="https://github.com/boostorg/date_time/blob/85e637cb325208c2af9af791c3a1948b4888c6cd/include/boost/date_time/gregorian_calendar.ipp#L114" target="_blank">Full C++ Version <img src="https://www.benjoffe.com/static/media/link-external.8c7dd7499c66b544fc0495ec612b0288.svg"/></a></strong></p><div><ol><li><pre><em>century</em> = (<em>days</em> * 4 + 3) <b>/</b> 146097       </pre></li><li><pre><em>year</em> = (<em>dayOfCentury</em> * 4 + 3) <b>/</b> 1461    </pre></li></ol></div></div><p>The multiplication by <code>4</code> and division by <code>146097</code> and <code>1461</code> is not too hard to understand, the larger constants being the number of days in 400-years and 4-years respectively — but what about those “<code>+ 3</code>” terms?</p><p>The reason for those is due to the longer years and longer centuries being offset slightly from the epoch. This is best understood by viewing the tables below. The first table shows the distribution of leap years when counting from the year zero:</p><div><div><table><thead><tr><th colspan="9"><b>Traditional forward counting <code>years</code></b> <em>— epoch: 0000-03-01</em></th></tr><tr><th>Year</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><th>Start</th><td><em>0000-03-01</em></td><td><em>0001-03-01</em></td><td><em>0002-03-01</em></td><td><em>0003-03-01</em></td></tr><tr><th>Length</th><td>365</td><td>365</td><td>365</td><td>366</td></tr></tbody></table></div></div><p>Since the Gregorian leap year rule omits a usual leap year every 100 years, except years divisible by 400, we get the same pattern for centuries:</p><div><div><table><thead><tr><th colspan="9"><b>Traditional forward counting <code>centuries</code></b> <em>— epoch: 0000-03-01</em></th></tr><tr><th>Century</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><th>Start</th><td><em>0000-03-01</em></td><td><em>0100-03-01</em></td><td><em>0200-03-01</em></td><td><em>0300-03-01</em></td></tr><tr><th>Length</th><td>36,524</td><td>36,524</td><td>36,524</td><td>36,525</td></tr></tbody></table></div></div><p>If we could find a way to count the dates from an epoch where these both start with a <em>Leap/Long</em> immediately (instead of offset-by-3) we could delete the “<code>+ 3</code>” terms. Not only that, we will have a way of merging the terms: <code>foo * 4 / N</code> into a single multiplication and bit-shift. This has the potential to remove up to four CPU-cycles from the algorithm <em>(although the exact speed gain will be platform dependent)</em>.</p><p>I first tried by setting the epoch at the year<code>-100</code> (101 BC), but that only solves half the problem: the century slicing <em>must</em> end on a date <code>XX00-02-2Y</code>, which means it must start immediately <em>after</em> a February in a year divisible by <code>4</code>.</p><p>As you know, it turns out counting <em>backwards</em> is the way to solve this problem fully:</p><div><div><table><thead><tr><th colspan="9"><b><strong>Backwards</strong> counting <code>years</code></b> <em>— epoch: 2400-02-29</em></th></tr><tr><th>Year</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><th>Start</th><td><em>2400-02-29</em></td><td><em>2399-02-28</em></td><td><em>2398-02-28</em></td><td><em>2397-02-28</em></td></tr><tr><th>Length</th><td>366</td><td>365</td><td>365</td><td>365</td></tr></tbody></table></div></div><p>This allows the epoch to begin in a leap-year as shown above, as well as to start in a long century as shown below:</p><div><div><table><thead><tr><th colspan="9"><b><strong>Backwards</strong> counting <code>centuries</code></b> <em>— epoch: 2400-02-29</em></th></tr><tr><th>Century</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><th>Start</th><td><em>2400-02-29</em></td><td><em>2300-02-28</em></td><td><em>2200-02-28</em></td><td><em>2100-02-28</em></td></tr><tr><th>Length</th><td>36,525</td><td>36,524</td><td>36,524</td><td>36,524</td></tr></tbody></table></div></div><p>Fortunately, reversing the timeline comes at zero speed cost, as all date algorithms tend to have <em>epoch</em> adjustments. It will just be a matter of using a minus sign where an addition would normally be.</p><p>Now that this general concept is out of the way, we can proceed with the nitty-gritty of the individual steps of the algorithm.</p><hr/><h2 id="explanation">The Algorithm - Line by Line</h2><p>With the timeline reversed, we can now begin explaining the algorithm from the top:</p><p>Given:   <code><em><b>days</b></em> = <em>Days since epoch, where &#34;1970-01-01&#34; is zero</em></code>   —   Then:</p><div><p><strong>The Algorithm — Step 1</strong></p><div><ol><li><pre><span>const</span> <em>ERAS</em> = 4726498270</pre></li><li><pre><span>const</span> <em>D_SHIFT</em> = 146097 * ERAS - 719469</pre></li><li><pre><em>rev</em> = <em>D_SHIFT</em> - <em>days</em>            </pre></li></ol></div></div><p>The constants <code><em>D_SHIFT</em></code> is calculated at compile-time:</p><ul><li><code>719469</code> is the number of days to count back from the UNIX epoch of <code>1970-01-01</code> to <code>0000-02-29</code> — our natural alignment point.</li><li><code>146097</code> is the number of days per 400 year <em>era</em>, and we will add a large multiple <code>ERAS</code> of these to set our far future count-back point.</li></ul><p>The specific value for <code>ERAS = 4726498270</code> was selected to provide the maximum possible range centred around the UNIX epoch in 64–bit.</p><p>Finally, the calculation of <code><em>rev</em></code> involves that minus sign to reverse the timeline.</p><div><p><strong>The Algorithm — Step 2</strong></p><div><ol><li><pre><span>const</span> <em>C1</em> = 505054698555331      </pre></li><li><pre><em>cen</em> = (<em>rev</em> <b>*</b> <em>C1</em>) <span>&gt;&gt; 64</span>          </pre></li></ol></div></div><p>In this step, we are performing what was previously <code>cen = (days * 4 + 3) / 146097</code>, but with just a single multiplication.</p><p>There are two reasons that we are hand-writing our own mul-shift in this case</p><ol><li>We want to integer-divide by <code>36524.25</code> — something that cannot be done with a standard integer division.</li><li>We can specify a bit-shift of <em>precisely</em> <code>64</code>, which is “free” in 64–bit computers.</li></ol><p>The reason a bit-shift of 64 in this case is “free” is due to the way 64–bit computers work. Since 64–bit computers cannot hold a number larger than 64–bits in a single register, a multiplication will place the full 128–bit result from the multiplication into two adjacent registers. The bit-shift of 64 is therefore just the compiled machine-code making use of the first of these two registers, and hence, does not actually involve any work.</p><p>The reason a compiler would normally use a larger bit-shift when using a normal division, is that eventually, with astronomically large values, this calculation will no longer be correct. We don&#39;t need this to be correct forever, just for a very large range to make the algorithm useful. A compiler does not know such requirements, and will usually err on the safe side and go with the more accurate, larger, and costlier, bit-shift.</p><div><p><strong>The Algorithm — Step 3</strong></p><div><ol><li><pre><em>jul</em> = <em>rev</em> + <em>cen</em> - <em>cen</em> / 4       </pre></li></ol></div></div><p>This is also a “new” step not found in <em>recent</em> fast date algorithms.</p><p>What we are doing here is quickly, and efficiently, accounting for the 100-year and 400-year leap year rules. Boost and Neri-Schneider both use alternative steps to calculate the specific day within the associated 400-year block (costly modulus or subtraction and multiplication), and later construct the year with another costly addition and multiplication.</p><p>I wrote about this technique in a <a href="https://www.benjoffe.com/fast-date" data-discover="true">previous article</a> earlier this month. It is a technique used by some former date-algorithm designers, but the speed gains were either not well understood, or not communicated clearly to later designers. I recommend reading the previous article for more details.</p><div><p><strong>The Algorithm — Step 4</strong></p><div><ol><li><pre><span>const</span> <em>Y_SHIFT</em> = 400 * ERAS - 1</pre></li><li><pre><span>const</span> <em>C2</em> = 50504432782230121    </pre></li><li><pre><em>num</em> = <em>jul</em> <b>*</b> <em>C2</em>                  </pre></li><li><pre><em>yrs</em> = <em>Y_SHIFT</em> - (<em>num</em> <span>&gt;&gt; 64</span>)     </pre></li><li><pre><span><em>low</em> = <em>num</em> % (1 &lt;&lt; 64)</span>           </pre></li></ol></div></div><p>Once again, we are doing a fast division with a single multiplication, where previous algorithms would have to <em>first</em> calculate <code>4 * jul + 3</code>.</p><p>The high 64–bit part of <code>num</code>, represents the number of years that have elapsed backwards since our forward-epoch, so subtracting this by a carefully selected constant will yield the correct year. As with most other fast date algorithms, this year will later need to be incremented if it is determined that the month is either January or February, since the internal logic of the algorithm is using treating the start of the year as 1 March.</p><p>While the upper-64 bits are easy to explain, the lower 64 bits are going to be treated different to usual.</p><div><p><strong>The Algorithm — Step 5</strong></p><div><ol><li><pre><em>ypt</em> = (782432 <b>*</b> <em>low</em>) <span>&gt;&gt; 64</span>      </pre></li></ol></div></div><p>This is where things start to get very different. In the Neri-Schneider algorithm, the lower bits are <b>divided</b> by a constant in order to calculate the exact <code>day_of_year</code> (0-365). That <code>day_of_year</code> is then later <b>multiplied</b> again to recover the month and day.</p><p>At first glance, a division followed by a multiplication sounds like it could be merged into a single combined operation. However, the division step introduces an important integer rounding, and that rounding cannot be removed without changing the result.</p><p>In this algorithm, we deliberately skip the explicit <code>day_of_year</code> step and merge the multiplication and division together to get just a <em>year-part</em>. This temporarily loses that rounding effect, causing a drift in the value of <em>year-part</em> equal to 1/4 of a day per year — resetting every 4 years. We will allow this “error” to occur and correct it later using a year-modulus-bitshift technique. Hold that thought for now — we will return to it when we construct <code>N</code> on line 27 (Step 7).</p><div><p><strong>The Algorithm — Step 6</strong></p><div><ol><li><pre><em>bump</em> = <em>ypt</em> &lt; 126464             </pre></li><li><pre><em>shift</em> = <em>bump</em> ? 191360 : 977792  </pre></li></ol></div></div><p>We will adopt the term <code>bump</code> used by Neri-Schneider to indicate that the year beginning <em>1 March</em> has overflowed to the next calendar year — i.e. the month is January or February. Other algorithms often use <code>day_of_year</code> or <code>month</code> to calculate this, however we are not computing <code>day_of_year</code>, and we&#39;ll require <code>bump</code> in order to calculate <code>month</code>. As such, we&#39;ll determine this value early via this more cryptic looking method.</p><p>Next, <code>shift</code> is a value that will be used in the next line to shift a linear equation by 12-months to achieve a similar “bump” overflow to our year.</p><p>Other fast date algorithms often use a step near the end such as <code>month = bump ? month - 12 : month</code>, however on x64 processors that takes 2 CPU-cycles to compute, as <code>M - 12</code> must always be calculated before the ternary check is performed.</p><div><p><strong>The Algorithm — Step 7</strong></p><div><ol><li><pre></pre></li><li><pre></pre></li><li><pre><em>N</em> = (<em>yrs</em> % 4) * 512 + <em>shift</em> - <em>ypt</em></pre></li></ol></div></div><p>This is the <em>year-modulus-bitshift</em> magic hinted at earlier. The value of <code>N</code> will be split into two parts, where the high 16 bits will become the <code>month</code> and the low 16 bits will map to the <code>day</code>.</p><p>We have already explained <em>shift</em>, but <code>(<em>yrs</em> % 4) * 512</code> is certainly an unusual looking term.</p><p><b>How is it 1/4 of a day?</b></p><p>Of course, actual Gregorian months are not exactly 32 days long, but they are <em>just  close enough</em> to 32 days long to make this work. There is just enough wiggle room in the valid range of <em>shift</em> for the rounding to land correctly across all months.</p><p><b>Note:</b> at first this trickery looks like it might only save minimal cycles, but it is actually a necessary step to avoid those pesky <code>+3</code> terms that we worked so hard to remove earlier. If we used the Neri–Schneider technique from line 17 onwards, that offset would have reappeared.</p><p>It is very fortunate that the Julian and Gregorian calendars have month-lengths close to a power of two to make this trick possible. Other calendars that have month-lengths closer to the actual synodic lunar month might not be able to adopt this technique.</p><div><p><strong>The Algorithm — Step 8</strong></p><div><ol><li><pre><span>const</span> <em>C3</em> = 8619973866219416     </pre></li><li><pre><em>D</em> = ((<em>N</em> <span>% 65536</span>) <b>*</b> C3) <span>&gt;&gt; 64</span>    </pre></li></ol></div></div><p>This is the last non-trivial step, where we take the lower 16–bits and map them to the day-number.</p><div><p><strong>The Algorithm — Step 9</strong></p><div><ol><li><pre><em><b>day</b></em> = <em>D</em> + 1</pre></li><li><pre><em><b>month</b></em> = <em>N</em> / 65536</pre></li><li><pre><em><b>year</b></em> = <em>yrs</em> + <em>bump</em></pre></li></ol></div></div><p>Finally, we clean up the values as previously described:</p><ul><li>Increment day so it is 1-indexed</li><li>Take the upper 16 bits of <code>N</code> for <code>month</code></li><li>Overflow the <code>year</code> when the month is January or February.</li></ul><p><b>That&#39;s it.</b> The date has now been calculated faster than ever before.</p><h2 id="optimisations">Optimisations for ARM64 and Apple Silicon</h2><p>Many ARM chips take longer to load integers that are larger than 16 bits (max: 65,535).</p><p>The reason for their size is that they allow calculation of <code>D</code> to involve <code>N % 65536</code>, which compiles to taking the lowest 16–bits of <code>N</code>, which is a <em>free</em> operation on x64.</p><p>These constants have been carefully selected to each be divisible by 32. One can use a compile-time check to divide these constants by 32 if the target is ARM (or use the smaller constants and scale by 32 for x64). When doing so, they all fit under 16–bit in size, leading to a speed bump for many ARM chips. Other constants also need adjusting in this case: divide <code>512</code> by 32 (for calculating <code>N</code>), and the constant of <code>C3</code> should be <em>increased</em> by a factor <code>32</code>.</p><p>Additionally, in Step-6 of the explanation, I noted that the new approach using <code>shift</code> specifically improves the performance on x64 based computers, and <em>should</em> have no effect on ARM devices. From my testing, I have found that this particular optimisation negatively impacts the performance on Apple M4 Pro, presumably due to some parallelisation that is lost. As such, my recommendation is to use a compile-time check to limit this improvement specifically to x64 devices.</p><p>Adopting the above changes results in the following changes to the algorithm:</p><ul><li>Note: terms highlighted in Green are simplified at compile-time.</li></ul><div><div><div><p><strong>ARM64 / Apple Silicon Improvement</strong></p><div><ol><li><pre><span>#if IS_ARM</span></pre></li><li><pre><span>    <span>const</span> <em>SCALE</em> = 1</span></pre></li><li><pre><span>#else</span></pre></li><li><pre><span>    <span>const</span> <em>SCALE</em> = 32</span></pre></li><li><pre><span>#endif</span></pre></li><li><pre></pre></li><li><pre><span>const</span> <em>C3</em> = <span>8619973866219416 * 32 / <em>SCALE</em></span></pre></li><li><pre></pre></li><li><pre><em>ypt</em> = (<span>(24451 * <em>SCALE</em>)</span> * <em>low</em>) &gt;&gt; 64</pre></li><li><pre></pre></li><li><pre><span>#if IS_ARM</span></pre></li><li><pre><span>    <em>shift</em> = <span>(30556 * <em>SCALE</em>)</span></span></pre></li><li><pre><span>#else</span></pre></li><li><pre><span>    <em>bump</em> = <em>ypt</em> &lt; 126464</span></pre></li><li><pre><span>    <em>shift</em> = <em>bump</em> ? <span>(24412 * <em>SCALE</em>)</span> : <span>(30556 * <em>SCALE</em>)</span></span></pre></li><li><pre><span>#endif</span></pre></li><li><pre></pre></li><li><pre>    <em>N</em> = (<em>yrs</em> % 4) * <span>(16 * <em>SCALE</em>)</span> + <em>shift</em> - <em>ypt</em></pre></li><li><pre>    <em>D</em> = ((<em>N</em> % <span>(2048 * <em>SCALE</em>)</span>) <b>*</b> C3) &gt;&gt; 64</pre></li><li><pre>    <em>M</em> = <em>N</em> / <span>(2048 * <em>SCALE</em>)</span></pre></li><li><pre></pre></li><li><pre><span>#if IS_ARM</span></pre></li><li><pre><span>    <em>bump</em> = <em>M</em> &gt; 12</span></pre></li><li><pre><span>    <em><b>month</b></em> = bump ? <em>M</em> - 12 : <em>M</em></span></pre></li><li><pre><span>#else</span></pre></li><li><pre><span>    <em><b>month</b></em> = <em>M</em></span></pre></li><li><pre><span>#endif</span></pre></li><li><pre></pre></li></ol></div></div></div></div><h2 id="range">Accuracy and Range</h2><p>Fortunately, the range of accurate values of the algorithm is very wide:</p><div><div><table><tbody><tr><th>Total Days</th><td>1,381,054,434,006,886</td> <td>~1.381 × 10<sup>15</sup></td><td>~1.381 Quadrillion</td><td>~2<sup>50.29</sup></td></tr><tr><th>Total Years</th><td>3,781,198,611,900</td><td>~3.781 × 10<sup>12</sup></td><td>~3.781 Trillion</td><td>~2<sup>41.78</sup></td></tr><tr><th>Max Date</th><td colspan="4">+1,890,599,308,000-02-29     — Rata Die:   +690,527,217,032,721</td></tr><tr><th>Min Date</th><td colspan="4">−1,890,599,303,900-03-01     — Rata Die:   −690,527,216,974,164</td></tr></tbody></table></div></div><p>The first date above this range will overflow.</p><p>64–bit UNIX time (measured in seconds) covers a range of around 585 Billion years in total, while this algorithm is accurate in the range of Trillions of years. This makes it sufficient to handle the full 64–bit UNIX time range.</p><p>While I have not developed a formal proof of this range, there is a <a href="https://github.com/benjoffe/fast-date-benchmarks/blob/main/tests/fast_64_range.cpp" target="_blank">testcase <img src="https://www.benjoffe.com/static/media/link-external.8c7dd7499c66b544fc0495ec612b0288.svg"/></a> in the benchmark codebase which verifies the above range. It is very slow to check the entire range (around a month on Apple M4 Pro), so it first quickly checks:</p><ul><li><code>[-2<sup>32</sup> ... 2<sup>32</sup>]</code></li><li><code>[MAX_DATE − 2<sup>32</sup> ... MAX_DATE]</code></li><li><code>[MIN_DATE ... MIN_DATE + 2<sup>32</sup>]</code></li><li>A random sample of <code>2<sup>32</sup></code> dates</li></ul><h2 id="portability">Portability</h2><p>Since this algorithm is 64–bit only, some library authors may be interested in techniques to safely deploy this in a portable manner that can support 32–bit computers.</p><p>The fast 32–bit algorithms from <a href="https://www.benjoffe.com/fast-date" data-discover="true">Article 1</a> (fastest) and <a href="https://www.benjoffe.com/safe-date" data-discover="true">Article 2</a> (full 32–bit input range safe), have been updated with techniques from this algorithm. They are each now notably faster than as stated in their respective articles.</p><p>If your API only needs to support a restricted day range of around 2<sup>30</sup> days (~1 Billion days / ~2.9 Million years), then the following combination is the fastest known for each platform type:</p><ul><li>This algorithm for 64–bit computers</li><li>My algorithm from <a href="https://www.benjoffe.com/fast-date" data-discover="true">Article 1</a> for 32–bit computers</li></ul><p>If you prefer your API to handle dates in the full 32–bit input range (often the best choice), then the following combination is suitable:</p><ul><li>This algorithm for 64–bit computers</li><li>My algorithm from <a href="https://www.benjoffe.com/safe-date" data-discover="true">Article 2</a> for 32–bit computers.</li></ul><p>My algorithm from Article 2 is the only fast 32–bit date algorithm that I am aware of that is 100% overflow safe within the 32–bit input range. It is both overflow-safe, and very fast. It is faster than Boost but either slower or faster than Neri-Schneider depending on the device. Note that Boost and Neri-Schneider only support around 25% of the 32–bit input range.</p><h2 id="benchmarks">Benchmark Results</h2><p>The benchmark code is a direct fork of the benchmarks provided by Neri‑Schneider <a href="https://github.com/benjoffe/fast-date-benchmarks" target="_blank">(GitHub link <img src="https://www.benjoffe.com/static/media/link-external.8c7dd7499c66b544fc0495ec612b0288.svg"/>)</a>. The relative speed ratios are calculated by first subtracting the &#34;scan&#34; performance, which removes the overhead of calling the function from the benchmarks, as is also used by Neri‑Schneider.</p><p><em>Lower numbers are faster.</em></p><div><div><table><thead><tr><th>Algorithm:</th><th>Scan</th><th>Boost</th><th>Neri‑</th><th>New Fast</th><th>New Fast</th><th>New Fast</th><th>Speed Gain</th></tr><tr><th>Input range supported</th><th>-</th><th>~25%</th><th>~25%</th><th>~25%</th><th><b>100%</b></th><th>N/A</th><th>-</th></tr></thead><tbody><tr><td>Dell Inspiron 13-5378 (Windows 10 22H2)</td><td>-</td><td><b>2.57x</b></td><td><b>1.78x</b></td><td><b>1.21x</b></td><td><b>1.74x</b></td><td><b>1.00x</b></td><td><b>43.7%</b></td></tr><tr><td>Lenovo MIIX 520 13-5378 (Windows 11 Pro 26200)</td><td>-</td><td><b>2.33x</b></td><td><b>1.66x</b></td><td><b>1.18x</b></td><td><b>1.64x</b></td><td><b>1.00x</b></td><td><b>39.9%</b></td></tr><tr><td>MacBook Pro 2024 (MacOS 15.6.1)</td><td>-</td><td><b>2.45x</b></td><td><b>1.62x</b></td><td><b>1.38x</b></td><td><b>1.92x</b></td><td><b>1.00x</b></td><td><b>38.4%</b></td></tr></tbody></table></div></div><p>The above platforms were chosen because they produce stable, consistent results that match expectations. I also tested the algorithm on a Lenovo IdeaPad Slim 5 (Snapdragon ARM64), but it reported nearly a 60% speed gain. This strongly suggests a thermal or power-management behaviour that distorts short benchmark loops. Similarly, x86-based MacBook Pros from 2016 and 2020 reported speed improvements of only 2–10%, while other algorithms appeared twice as slow as expected. This again indicates that the CPU is applying aggressive battery or thermal optimisation, making those measurements unreliable.</p><hr/><p>If you found this interesting, you should <a href="https://x.com/benjoffe" target="_blank">follow me on X <img src="https://www.benjoffe.com/static/media/link-external.8c7dd7499c66b544fc0495ec612b0288.svg"/></a> to get notified when I publish more date and algorithm related articles.</p></div></div></div></div>
  </body>
</html>
