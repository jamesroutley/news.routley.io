<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://samgeo.codes/layers-of-abstraction/">Original</a>
    <h1>Understanding the costs of our abstractions</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>Since the beginning of February, there has been a big conversation about
client-side JavaScript in the web development community.</p>
<p>There has been a salvo of blog posts discussing the performance implications of
single page applications:</p>
<ul>
<li>Alex Russell&#39;s <a href="https://infrequently.org/2023/02/the-market-for-lemons/">The Market for Lemons</a></li>
<li>Eric Bailey&#39;s <a href="https://ericwbailey.website/published/modern-health-frameworks-performance-and-harm/">Modern Health, frameworks, performance, and harm</a></li>
<li>Laurie Voss&#39; <a href="https://seldo.com/posts/the_case_for_frameworks/">The case for frameworks</a></li>
</ul>
<p>These posts and the resources linked within are worth reading. I think this
is an interesting conversation, and I think the ideas extend far beyond
front end web development. I spent a lot of time listening to podcasts in the
car this past week, and there has been a common thread in many of the discussions
that I&#39;ve listened to: abstractions have (sometimes hidden) costs.</p>
<p>How can we do a better job of choosing the right abstractions as an industry?</p>
<p>I could try to write a bunch about incentive structures, scope creep and
rising complexity. But I think most of what I have to say boils down to this:
we should aspire to understand the benefits and costs of the abstractions that we build on top of.</p>
<h2 id="understanding-abstractions">Understanding abstractions</h2>
<p>Most software projects are built atop a perilously tall stack of abstractions.</p>
<p>Joel Spolsky wrote a post entitled <a href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/">The Law of Leaky Abstractions</a>
in 2002 claiming:</p>
<blockquote>
<p>All non-trivial abstractions, to some degree, are leaky.</p>
</blockquote>
<p>To build context for this claim, Joel uses TCP as an example noting that
under certain circumstances, the unreliable nature of the network will leak
through the reliability guarantees that TCP provides. Unfortunately, Joel
omits an important detail: TCP is not free, it comes with a <em>lot</em> of overhead.</p>
<p>TCP provides a variety of features including packet ordering: for the code that
uses TCP, packets <em>appear</em> to arrive in the order they were sent. Many applications
don&#39;t require all of the features that TCP provides, but many of those applications
still use TCP (or even HTTP) under the hood. Check out these resources for more
information about the tradeoffs that TCP makes in a couple of different applications:</p>
<ul>
<li><a href="https://lwn.net/Articles/913260/">Moving past TCP in the data center</a></li>
<li><a href="https://signalsandthreads.com/multicast-and-the-markets/">Multicast and the Markets</a></li>
</ul>
<h3 id="react">React</h3>
<p>We can apply the same thought process to React and similar client-side JavaScript
abstractions. My oversimplified perspective: React aims to provide a declarative
alternative to imperative web APIs for providing real-time interactivity.</p>
<p>The web API provides methods like <code>Element.append()</code> or enables mutation of
<code>innerHTML</code> to directly modify the text contents of a document element.
React enables programmers to specify the desired state of a document fragment
and promises to make the necessary adjustments to the document. In many ways
React with JSX imitates the style of many popular backend web frameworks
(look at Rails, Django or almost any PHP application). There are several benefits
to the declarative interface but I think the most important benefit is
composability. Since React components behave like pure functions, they can be
reused in myriad ways. But those benefits are not free, React can balloon bundle sizes and increase
the time it takes for an application to become interactive.</p>
<p>If your application does not need real-time interactivity, the benefits of
declarative components are low or your application does not leverage many of the
features that React provides, you should probably seek a simpler alternative.</p>
<p>Eric Bailey describes their experience using a mental health portal that has
an endless spinner due to a deadlock in client-side JavaScript.
Can most users of a mental health portal wait for the latency of an HTTP request
when they interact with the page? Probably. Maybe there is a chat feature in the
portal where a client-side component library is valuable; but even still, it
doesn&#39;t seem like a use case that necessitates React.</p>
<h3 id="python-and-high-level-scripting-languages">Python and high-level scripting languages</h3>
<p>There are a few technologists that have derided the overuse of high-level
scripting languages like Python and Ruby. Many of these folks come from the
game development space where performance is paramount. Two of the loudest voices
in the room are Jonathan Blow (see <a href="https://www.youtube.com/watch?v=pW-SOdj4Kkk">Preventing the Collapse of Civilization</a>)
and Casey Muratori (see <a href="https://www.youtube.com/watch?v=hxM8QmyZXtg">How fast should an unoptimized terminal run?</a>).</p>
<p>Casey recently started a &#34;Performance-Aware Programming&#34; series. So far,
Casey has published a prologue that compares the performance of
naiively adding two integers in Python with a variety of implementations in C,
ultimately getting close to optimal with the use of SIMD instructions and
multi-threading. Casey achieves a staggering ~8,000x speedup over the Python implementation.
Casey wraps up the prologue by demonstrating and benchmarking alternative
summation implementations in Python.</p>
<p>During these videos, Casey describes the interpreter overhead of Python
as &#34;waste&#34;. I think this discounts the value that high-level interpreted
programming languages provide. As a self-described static
typing fanatic, I still find Python to be significantly easier to use for creating
rapid prototypes than languages like Rust, C++ or C. For getting up and running,
Python and similar languages enable you to focus more on the problem that you&#39;re
trying to solve and less on the mechanics of the language that you&#39;re using
to solve that problem. Not to mention, Python has a huge batteries-included
standard library and an enormous ecosystem of third-party libraries to lean on.</p>
<p>I believe that scripting languages are a good choice as long as you acknowledge
the performance and maintainability tradeoffs that you are making. Often,
this explicit acknowledgement or context is missing.</p>
<h2 id="leaving-a-paper-trail">Leaving a paper trail</h2>
<p>When we make decisions about the tools and technologies that we use to build
applications in a professional setting, we should aim to leave a paper trail.
Even if the rationale for using a particular technology is &#34;we needed to get
started and this was the most popular option,&#34; that is valuable context!</p>
<p>When we have that context, we can make informed decisions about how to move
forward, whether that means forging ahead with the existing choices or making
adjustments to set ourselves up for the future.</p>
<p>Of course, outside of a professional setting or when writing software for yourself,
use whatever you want! If you want to experiment with React, experiment with React.
If you want to <a href="https://oxide.computer/podcasts/oxide-and-friends/1208089">write C++ in the comfort of your own home</a>, do it!
But when writing software professionally or for a larger audience, it&#39;s significantly
more important to think about the implications of the decisions we make. When
that consideration is missing, we&#39;re doing a disservice to our colleagues and our users.</p>

        </div></div>
  </body>
</html>
