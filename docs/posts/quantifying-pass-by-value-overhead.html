<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://owen.cafe/posts/struct-sizes/">Original</a>
    <h1>Quantifying pass-by-value overhead</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>Should you pass data by value, or by reference?</p>

<!-- NOTE Assembly dump command: objdump --visualize-jumps -M intel intel-mnemonic --no-show-raw-insn --no-addresses -d benchmark -->
<p>When youâ€™re a certain kind of perfectionist, the kind that prevents you from
being productive, this is a question that might plague you every time you write
a function.</p>
<p>Iâ€™ve heard a few opinions on this, floating around. Iâ€™ve heard <em>â€œstack-to-stack
copies are super cheapâ€</em>, but.. how cheap are they?</p>
<hr/>
<p>Fine, Iâ€™ll write a benchmark. Canâ€™t take too long.</p>
<p>3â€¦ 2â€¦ (several months pass) 1â€¦ ğŸª„</p>
<p>And thatâ€™s how I ended up writing a graphing library<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>, and a benchmark.</p>
<hr/>
<p>If you want to run these benchmarks on your own machine, or dump the
assembly, you can check out the <a href="https://github.com/414owen/call-by-value-benchmarks" target="_blank" rel="noopener">benchmark code</a>.</p>
<hr/>

<h2 id="all-the-data"><a href="#all-the-data"><span>#Â </span>All the data</a></h2>
<p>This graph shows the overhead of passing structs of different sizes by value,
on different machines.</p>
<p>In general, passing any struct by reference incurs the same overhead as passing
a pointer-sized struct by value.</p>
<p><img alt="spinner" src="https://owen.cafe/img/hourglass-d.webp"/>
</p>
<p>Okay, on a macro level, passing a function parameter by value takes time
proportional to the size of the data.</p>
<p>Makes sense.</p>
<h2 id="minuscule"><a href="#minuscule"><span>#Â </span>Minuscule</a></h2>


<div>
    <p><label for="tab-minuscule-0">graph</label><label for="tab-minuscule-1">asm - 1 byte</label><label for="tab-minuscule-2">asm - 32 bytes</label>
    </p>
    <div>
        
        <p><img alt="spinner" src="https://owen.cafe/img/hourglass-d.webp"/>
</p>

        
        <div><pre tabindex="0"><code data-lang="asm"><span><span><span>â•­â”€â¤</span> <span>xor</span>    <span>edi</span><span>,</span><span>edi</span>
</span></span><span><span><span>â”‚</span>   <span>call</span>   <span>feed30</span> <span>&lt;</span><span>pass_1_fields_by_value</span><span>&gt;</span>
</span></span><span><span><span>â”‚</span>   <span>sub</span>    <span>ebx</span><span>,</span><span>0x1</span>
</span></span><span><span><span>â•°â”€â”€</span> <span>jne</span>    <span>4786f0</span> <span>&lt;</span><span>bench_1</span><span>+</span><span>0x20</span><span>&gt;</span>
</span></span></code></pre></div>
        
        <div><pre tabindex="0"><code data-lang="asm"><span><span><span>â•­â”€â¤</span> <span>sub</span>    <span>rsp</span><span>,</span><span>0x20</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x20</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x30</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x10</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>call</span>   <span>fef080</span> <span>&lt;</span><span>pass_32_fields_by_value</span><span>&gt;</span>
</span></span><span><span><span>â”‚</span>   <span>add</span>    <span>rsp</span><span>,</span><span>0x20</span>
</span></span><span><span><span>â”‚</span>   <span>sub</span>    <span>ebx</span><span>,</span><span>0x1</span>
</span></span><span><span><span>â•°â”€â”€</span> <span>jne</span>    <span>479510</span> <span>&lt;</span><span>bench_32</span><span>+</span><span>0x40</span><span>&gt;</span>
</span></span></code></pre></div>
        
    </div>
</div>
<p>For smaller struct sizes, it doesnâ€™t look like thereâ€™s a huge difference
between passing 8 bytes, or passing 32.</p>
<p>In the tabs above, you can inspect the assembly for the benchmark loops
of 1-byte and 32-byte structs.</p>
<p>The assembly says thereâ€™s a difference, but seemingly not one youâ€™d notice.
Technically the 32-byte value is being passed on the stack, using vector
registers, whereas the 1-byte value is being passed in a register,
but the speed difference is negligible.</p>
<h2 id="small"><a href="#small"><span>#Â </span>Small</a></h2>


<div>
    <p><label for="tab-small-0">graph</label><label for="tab-small-1">asm - 256 bytes</label><label for="tab-small-2">asm - 257 bytes</label>
    </p>
    <div>
        
        <p><img alt="spinner" src="https://owen.cafe/img/hourglass-d.webp"/>
</p>

        
        <div><pre tabindex="0"><code data-lang="asm"><span><span><span>â•­â”€â¤</span> <span>sub</span>    <span>rsp</span><span>,</span><span>0x100</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x100</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x110</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x10</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x120</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x20</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x130</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x30</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x140</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x40</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x150</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x50</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x160</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x60</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x170</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x70</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x180</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x80</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x190</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x90</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x1a0</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0xa0</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x1b0</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0xb0</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x1c0</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0xc0</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x1d0</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0xd0</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x1e0</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0xe0</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>movdqa</span> <span>xmm0</span><span>,</span><span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0x1f0</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movups</span> <span>XMMWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>+</span><span>0xf0</span><span>],</span><span>xmm0</span>
</span></span><span><span><span>â”‚</span>   <span>call</span>   <span>fefe80</span> <span>&lt;</span><span>pass_256_fields_by_value</span><span>&gt;</span>
</span></span><span><span><span>â”‚</span>   <span>add</span>    <span>rsp</span><span>,</span><span>0x100</span>
</span></span><span><span><span>â”‚</span>   <span>sub</span>    <span>ebx</span><span>,</span><span>0x1</span>
</span></span><span><span><span>â•°â”€â”€</span> <span>jne</span>    <span>4927c0</span> <span>&lt;</span><span>bench_256</span><span>+</span><span>0x100</span><span>&gt;</span>
</span></span></code></pre></div>
        
        <div><pre tabindex="0"><code data-lang="asm"><span><span><span>â•­â”€â¤</span> <span>sub</span>    <span>rsp</span><span>,</span><span>0x110</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>ecx</span><span>,</span><span>0x20</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>rsi</span><span>,</span><span>rbp</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>rdi</span><span>,</span><span>rsp</span>
</span></span><span><span><span>â”‚</span>   <span>rep</span> <span>movs</span> <span>QWORD</span> <span>PTR</span> <span>es</span><span>:[</span><span>rdi</span><span>],</span><span>QWORD</span> <span>PTR</span> <span>ds</span><span>:[</span><span>rsi</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>movzx</span>  <span>eax</span><span>,</span><span>BYTE</span> <span>PTR</span> <span>[</span><span>rsi</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>BYTE</span> <span>PTR</span> <span>[</span><span>rdi</span><span>],</span><span>al</span>
</span></span><span><span><span>â”‚</span>   <span>call</span>   <span>fefe90</span> <span>&lt;</span><span>pass_257_fields_by_value</span><span>&gt;</span>
</span></span><span><span><span>â”‚</span>   <span>add</span>    <span>rsp</span><span>,</span><span>0x110</span>
</span></span><span><span><span>â”‚</span>   <span>sub</span>    <span>ebx</span><span>,</span><span>0x1</span>
</span></span><span><span><span>â•°â”€â”€</span> <span>jne</span>    <span>492a00</span> <span>&lt;</span><span>bench_257</span><span>+</span><span>0x110</span><span>&gt;</span>
</span></span></code></pre></div>
        
    </div>
</div>
<p>Thereâ€™s a beautiful clean cliff here at 257 bytes. This seems to represent the
difference between an unrolled, vectorized memcpy routine, and one using
<code>rep movs</code> (ie. a microcoded for loop).</p>
<p>In the tabs above, you can inspect the assembly for 256 and 257 bytes.</p>
<h2 id="periodic"><a href="#periodic"><span>#Â </span>Periodic</a></h2>


<div>
    <p><label for="tab-periodic-0">graph</label><label for="tab-periodic-1">asm - 1682 bytes</label><label for="tab-periodic-2">asm - 1696 bytes</label>
    </p>
    <div>
        
        <p><img alt="spinner" src="https://owen.cafe/img/hourglass-d.webp"/>
</p>

        
        <div><pre tabindex="0"><code data-lang="asm"><span><span><span>â•­â”€â¤</span> <span>sub</span>    <span>rsp</span><span>,</span><span>0x690</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>ecx</span><span>,</span><span>0xd1</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>rsi</span><span>,</span><span>rbp</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>rdi</span><span>,</span><span>rsp</span>
</span></span><span><span><span>â”‚</span>   <span>rep</span> <span>movs</span> <span>QWORD</span> <span>PTR</span> <span>es</span><span>:[</span><span>rdi</span><span>],</span><span>QWORD</span> <span>PTR</span> <span>ds</span><span>:[</span><span>rsi</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>call</span>   <span>&lt;</span><span>pass_1672_fields_by_value</span><span>&gt;</span>
</span></span><span><span><span>â”‚</span>   <span>add</span>    <span>rsp</span><span>,</span><span>0x690</span>
</span></span><span><span><span>â”‚</span>   <span>sub</span>    <span>ebx</span><span>,</span><span>0x1</span>
</span></span><span><span><span>â•°â”€â”€</span> <span>jne</span>    <span>&lt;</span><span>bench_1672</span><span>+</span><span>0x120</span><span>&gt;</span>
</span></span></code></pre></div>
        
        <div><pre tabindex="0"><code data-lang="asm"><span><span><span>â•­â”€â¤</span> <span>sub</span>    <span>rsp</span><span>,</span><span>0x6a0</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>ecx</span><span>,</span><span>0xd4</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>rsi</span><span>,</span><span>rbp</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>rdi</span><span>,</span><span>rsp</span>
</span></span><span><span><span>â”‚</span>   <span>rep</span> <span>movs</span> <span>QWORD</span> <span>PTR</span> <span>es</span><span>:[</span><span>rdi</span><span>],</span><span>QWORD</span> <span>PTR</span> <span>ds</span><span>:[</span><span>rsi</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>call</span>   <span>&lt;</span><span>pass_1696_fields_by_value</span><span>&gt;</span>
</span></span><span><span><span>â”‚</span>   <span>add</span>    <span>rsp</span><span>,</span><span>0x6a0</span>
</span></span><span><span><span>â”‚</span>   <span>sub</span>    <span>ebx</span><span>,</span><span>0x1</span>
</span></span><span><span><span>â•°â”€â”€</span> <span>jne</span>    <span>&lt;</span><span>bench_1696</span><span>+</span><span>0x100</span><span>&gt;</span>
</span></span></code></pre></div>
        
    </div>
</div>
<p>Well this is interesting.</p>
<p>The period is 32, with 8 fast, and 24 slow struct widths per period.</p>
<p>Now, you may think that this would be something to do with having to copy
other leftover memory after <code>rep movs</code>, but that doesnâ€™t seem to be the
case. Iâ€™ve dumped the assembly of two functions above, one from the valley,
and one from the hill, which have near-identical assembly.</p>
<p>Instead, it looks like the performance of <code>rep movs</code> itself is periodic.</p>
<h2 id="spikes"><a href="#spikes"><span>#Â </span>Spikes</a></h2>


<div>
    <p><label for="tab-spikes-0">graph</label><label for="tab-spikes-1">asm - 4064 bytes</label><label for="tab-spikes-2">asm - 4072 bytes</label>
    </p>
    <div>
        
        <p><img alt="spinner" src="https://owen.cafe/img/hourglass-d.webp"/>
</p>

        
        <div><pre tabindex="0"><code data-lang="asm"><span><span><span>â•­â”€â¤</span> <span>sub</span>    <span>rsp</span><span>,</span><span>0xfe0</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>ecx</span><span>,</span><span>0x1fc</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>rsi</span><span>,</span><span>rbp</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>rdi</span><span>,</span><span>rsp</span>
</span></span><span><span><span>â”‚</span>   <span>rep</span> <span>movs</span> <span>QWORD</span> <span>PTR</span> <span>es</span><span>:[</span><span>rdi</span><span>],</span><span>QWORD</span> <span>PTR</span> <span>ds</span><span>:[</span><span>rsi</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>call</span>   <span>&lt;</span><span>pass_4064_fields_by_value</span><span>&gt;</span>
</span></span><span><span><span>â”‚</span>   <span>add</span>    <span>rsp</span><span>,</span><span>0xfe0</span>
</span></span><span><span><span>â”‚</span>   <span>sub</span>    <span>ebx</span><span>,</span><span>0x1</span>
</span></span><span><span><span>â•°â”€â”€</span> <span>jne</span>    <span>&lt;</span><span>bench_4064</span><span>+</span><span>0x100</span><span>&gt;</span>
</span></span></code></pre></div>
        
        <div><pre tabindex="0"><code data-lang="asm"><span><span><span>â•­â”€â¤</span> <span>sub</span>    <span>rsp</span><span>,</span><span>0xff0</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>ecx</span><span>,</span><span>0x1fd</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>rsi</span><span>,</span><span>rbp</span>
</span></span><span><span><span>â”‚</span>   <span>mov</span>    <span>rdi</span><span>,</span><span>rsp</span>
</span></span><span><span><span>â”‚</span>   <span>rep</span> <span>movs</span> <span>QWORD</span> <span>PTR</span> <span>es</span><span>:[</span><span>rdi</span><span>],</span><span>QWORD</span> <span>PTR</span> <span>ds</span><span>:[</span><span>rsi</span><span>]</span>
</span></span><span><span><span>â”‚</span>   <span>call</span>   <span>&lt;</span><span>pass_4072_fields_by_value</span><span>&gt;</span>
</span></span><span><span><span>â”‚</span>   <span>add</span>    <span>rsp</span><span>,</span><span>0xff0</span>
</span></span><span><span><span>â”‚</span>   <span>sub</span>    <span>ebx</span><span>,</span><span>0x1</span>
</span></span><span><span><span>â•°â”€â”€</span> <span>jne</span>    <span>&lt;</span><span>bench_4072</span><span>+</span><span>0x120</span><span>&gt;</span>
</span></span></code></pre></div>
        
    </div>
</div>
<p>Alright, whatâ€™s going on here?</p>
<p>Passing a struct of 4064 bytes takes 53ns, but passing one of 4065 bytes takes 222ns,
in other words 4x longer.</p>
<p>And yes, these results are reproducible. I can run the benchmark as
many times as I want, and always get the same spikes.</p>
<p>Again, Iâ€™ve dumped what is essentially matching assembly from the non-hill and
from the hill, in the tabs above.</p>
<p>Since the spike doesnâ€™t persist for greater struct widths, this probably isnâ€™t
a case of hitting a <a href="https://en.wikipedia.org/wiki/CPU_cache" target="_blank" rel="noopener">CPU cache</a>
limit.</p>
<p>It would appear that the <code>rep movs</code> instruction has a serious performance bug
for these very specific ranges, as implemented in AMD Zen* CPU microcode.
If any AMD engineers know whatâ€™s going on, please shoot me an email :)</p>
<p>If you work on GCC, Clang, or another compiler, and want to add an
absolutely disgusting hack that removes 1-2 <code>rep movs</code> iterations, and
adds a few extra manual <code>mov</code>s, on my CPU (and probably other AMD CPUs),
Iâ€™d also love to hear about it.</p>
<h2 id="conclusions"><a href="#conclusions"><span>#Â </span>Conclusions</a></h2>
<ul>
<li>Passing structs up to size 256 is very cheap, and uses SIMD registers.</li>
<li>Passing structs larger than 256 uses <code>rep movs</code>.</li>
<li>Unrolled vectorized moves seem to be faster than <code>rep movs</code>.</li>
<li>The performance of <code>rep movs</code> is probably periodic.</li>
<li>You can pass <strong>730 million</strong> structs of size <strong>16</strong> by value per second.</li>
<li>You can pass <strong>26 million</strong> structs of size <strong>2048</strong> by value per second.</li>
<li><strong>Donâ€™t</strong> pass around data of size 4046-4080 bytes or 8161-8176 bytes,
by value (at least not on an AMD Ryzen 3900X).</li>
</ul>


    </div></div>
  </body>
</html>
