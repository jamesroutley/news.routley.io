<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nanochess.org/locs.html">Original</a>
    <h1>LOCS: Language developed at age 9 in Z80 machine code (1988)</h1>
    
    <div id="readability-page-1" class="page"><div>

<p><img src="https://nanochess.org/img/locs_1.png" width="30%" alt="LOCS in action"/></p><p>
The Logo language created by Seymour Papert in 1967 was pretty famous in the eighties as a tool to teach programming to kids. Now in 2024, I can see it was great to make nice drawings on the screen and learn trigonometry, and some very fortunate kids had a real robotic turtle drawing on paper, but it wasn&#39;t so good for teaching programming because no home computer came with Logo, it was expensive, and its implementations differed greatly in their support of important programming constructs.
</p>
<p>
For example, there is at least one Logo language for Commodore 64 that implemented support for sprites, but it wasn’t portable to other versions. I learned this the hard way as I wanted to play a “Hunt the Dragon” game made for C64 Logo published in the <a href="https://archive.org/details/MiComputerVolumen05/page/n217/mode/2up">Mi computer</a> magazine (the whole volume contains Logo tutorials that I used to learn Logo), but Dr. Logo just kept throwing me error messages that I didn’t understand.
</p>
<p>
Anyway, I was in love with Logo, and being the bold kid I was, I decided to make a Logo language for the student&#39;s computer developed by my father, and I would code it in Z80 machine code at age 9. Furthermore, I would have forgotten this completely if it wasn’t because the handwritten program was saved away in the class folder that my father still kept and I found the pages the last Sunday, March 10, 2024, almost 36 years later. I almost couldn&#39;t believe it!
</p>
<p>
These are pictures of the three pages composing the program. You can see the machine code is somewhat readable because each instruction is separated. The final page contains the manual!
</p>
<p><img src="https://nanochess.org/img/locs_1.jpg" width="30%" alt="LOCS handwritten Z80 machine code, page 1"/>
    <img src="https://nanochess.org/img/locs_2.jpg" width="30%" alt="LOCS handwritten Z80 machine code, page 2"/>
    <img src="https://nanochess.org/img/locs_3.jpg" width="30%" alt="LOCS handwritten Z80 machine code, page 3"/>
</p>
<p>
I’m glad I put a date on the page: Friday, September 9, 1988. It means it was written after <a href="https://nanochess.org/notebook.html">my first Z80 machine code game</a>, so this is my second big machine code program.
</p>
<p>
LOCS means Lenguaje de Oscar Computadora eStudiantil (or Oscar&#39;s language for students&#39; computers). OTEK comes from my father&#39;s initials (Oscar Toledo Esteva) which we used as a kind of company name.
</p>
<p>
My language commands are pretty simple: BORRA clears the screen, TORTUGA centers the &#34;turtle&#34;, there are four commands to draw (SM up, AM down, DM right, IM left), and finally we have the PT command (Pone Tortuga) to place the turtle anywhere on the screen.
</p>
<h2>Making it to work</h2>
<p>
This program depends heavily on having a keyboard, so this time I won’t port it to Colecovision to save me time. I could assign a function to each key in the keypad but it would require a big code chunk and I would end up rewriting the program completely.
</p>
<p>
Anyway, here we go analyzing it. We’ll start by preparing a simple MSX translation layer.
</p>
<pre><small>
    ;
	; LOCS 
	;
	; by Oscar Toledo G.
	; (c) Copyright 1988 Oscar Toledo G.
	;
	; Creation date: Sep/09/1988. I was age 9.
	;

	;
	; Layer to adapt it to MSX computers.
	;
WRTVDP: EQU $0047       ; Set VDP address HL.
WRTVRM: EQU $004D       ; Write byte A to VRAM address HL.
FILVRM: EQU $0056       ; Fill VRAM address HL with A repeated BC times.
SETWRT: EQU $0053       ; Set write address HL for VDP.
CHGET:  EQU $009F       ; Read character from keyboard into A.

VDP:    EQU $98         ; Base VDP port.

        ; MSX Cartridge header

        ORG $4000
        DB &#34;AB&#34;
        DW START
        DW 0
        DW 0
        DW 0
        DW 0

	;
	; Set a VDP address to write.
	;
L0100:  JP SETWRT

	;
	; Copy immediate data to VRAM.
	;
L0169:  EX (SP),HL

.1:     LD A,(HL)
        OR A
        JR Z,.2
        OUT (VDP),a
        INC HL
        JR .1

.2:     EX (SP),HL
        RET

        ;
        ; Clear the screen.
        ; Set screen buffer to VRAM $3c00.
        ;
L04CC:
        LD BC,$0F02     ; VDP register 2 = $3c00.
        CALL WRTVDP
        LD HL,$3C00     ; Clear the screen.
        LD BC,$0300     ; 32x24 grid.
        LD A,$20        ; Space character.
        JP FILVRM       ; Fill VRAM.

	;
	; Read the keyboard.
	;
L04F5:
        CALL CHGET      ; Read keyboard.
        CP $61          ; Is it lowercase?
        RET C
        CP $7B
        RET NC          ; No, return.
        SUB $20         ; Yes, make it uppercase.
        RET

	;
	; Read a hexadecimal number in HL.
	;
READ_WORD:
        CALL READ_BYTE	; Read a byte.
READ_BYTE:
        CALL READ_HEX	; Read a hexadecimal digit.
READ_HEX:
        CALL L04F5	; Read the keyboard.
        PUSH HL
        LD HL,(L87F0)	; Get cursor address.
        CALL WRTVRM	; Display key on the screen.
        INC HL
        LD (L87F0),HL	; Update cursor address.
        POP HL
        SUB $30		; Convert ASCII 0-9 to 0-9.
        CP $0A
        JR C,.1
        SUB $07		; Convert ASCII A-F to 10-15.
.1:     ADD HL,HL       ; Shift HL to the left 4 bits.
        ADD HL,HL
        ADD HL,HL
        ADD HL,HL
        OR L		; Add hexadecimal digit.
        LD L,A
        RET
</small></pre>
<p>
This program calls the ROM of the educative computer. It uses five functions:
</p>
<ol>
<li><tt>L0100</tt>, Set VDP address.
</li><li><tt>L0169</tt>, Copy a message to VRAM.
</li><li><tt>L04CC</tt>, Clear the screen.
</li><li><tt>L04F5</tt>, Read the keyboard.
</li><li><tt>RST $10</tt>, Read a hexadecimal number into HL (4 digits).
</li></ol>
<p>
It depends also on the screen grid to be available at the VRAM address $3c00 (the MSX default is $1800) so in my translation layer for L04CC it writes the VDP register 2 to change it.
</p>
<p>
The program starts like this:
</p>
<pre><small>
START:
	LD SP,L87F0
	CALL L8114
	CALL L0100
	CALL L0169
	DB &#34;LOCS OTEK&#34;,0
    IF 0
	LD HL,$3C41
	CALL L0100
	CALL L0169
	DB &#34;32 BYTES&#34;,0
    ELSE
	DB 0,0,0
	DB 0,0,0
	DB 0,0,0
	DB 0,0,0,0
	DB 0,0,0,0
	DB 0
    ENDIF
</small></pre>
<p>
It sets the stack pointer at the initial address for the 2K RAM students computer, and immediately the code is patched before showing the program title.
</p>
<pre><small>
L8114:	CALL L8075
	LD HL,$3C01
	RET

L8075:	LD HL,$3D50
	LD (L86F0),HL
	CALL L04CC
	RET
</small></pre>
<p>
The patch sets the &#34;turtle&#34; position to $3D50 (the center of the screen), this position is saved in the L86F0 address, then it clears the screen calling L04CC, and then loads HL with $3C01 to point to the top left of the screen. Notice it isn&#39;t exactly $3C00 but $3c01 because my Sony Trinitron TV of the time &#34;ate&#34; the first column.
</p>
<p>
It took me probably half an hour to discover what I patched with tons of handwritten zero bytes (NOP instructions), and it was simply an extra message saying &#34;32 BYTES&#34;. I think that Dr. Logo showed the total bytes available for the program, and I think that saying 32 bytes was my joke because there isn&#39;t such thing as a memory manager.
</p>
<pre><small>
L8028:
        CALL L81C1
        CALL L807F
        CALL L0169
        DB &#34;GRAFICO&#34;,0
        LD HL,$3EE1
        CALL L8063
        LD A,$3E
        OUT (VDP),A
        LD (L86F2),HL
        LD DE,L8700
L8049:
        CALL L04F5
        LD (DE),A
        INC DE
        CP $0D
        JR Z,L8068
        LD HL,(L86F2)
        PUSH AF
        CALL L0100
        POP AF
        OUT (VDP),A
        INC HL
        LD (L86F2),HL
        JP L8049

L8063:
        CALL L0100
        INC HL
        RET

L807F:
        PUSH HL
        LD HL,(L86F0)
        CALL L0100
        LD A,$2A
        OUT (VDP),A
        POP HL
        CALL L0100
        RET

L81C1: 
        LD HL,$0118     ; Redefine the # character
        CALL L0100      ; as a solid block.
        LD B,$08
L81C9:
        LD A,$FF
        OUT (VDP),A
        DJNZ L81C9
L81CF: 
        LD HL,$0918
        CALL L0100
        LD B,$08
L81D7:
        LD A,$FF
        OUT (VDP),A
        DJNZ L81D7
        LD HL,$1118
        CALL L0100
        LD B,$08
L81E5:
        LD A,$FF
        OUT (VDP),A
        DJNZ L81E5
        LD HL,$3EC1	; Point to command area.
        RET
</small></pre>
<p>
The main loop starts by calling L81C1, obviously a patch, because it ends setting HL to $3EC1 (the command area on the screen), but first it redefines the # character to be a solid block. The redefinition is done in three areas of VRAM because the educative computer was hardcoded to VDP mode 2, but the MSX starts in mode 0, so only the first loop is necessary but I kept it all.
</p>
<p>
The next call jumps to L807F to draw the &#34;turtle&#34; in the current position. An asterisk, I&#39;m surprised I didn&#39;t even try to draw a turtle. At the end of the L807F it calls L0100 to point to the VRAM address for the command area.
</p>
<p>
Now it shows a &#34;GRAFICO&#34; message (akin to a READY message), and in the next row ($3EE1 in VRAM) it puts a &gt; sign to wait for the keyboard. Notice the L8063 patch because I couldn&#39;t fit an INC HL to save the current address in VRAM at L86F2.
</p>
<p>
There&#39;s no cursor, it simply waits for the keyboard and displays the typed key on the screen (L86F2 contains the current address in VRAM), and saves the key also in the RAM buffer located at L8700. I&#39;ve moved early the CP $0D comparison waiting for the Enter key, so it doesn&#39;t show trash in MSX, because in the educative computer that character wasn&#39;t defined so when displayed it was invisible.
</p>
<p>
It doesn&#39;t handle the backspace key, so you have to think before typing anything.</p>
<h2>On your command</h2>
<p>At this point, it starts processing the language commands:</p>
<pre><small>
L8068:
        LD A,(L8700)
	CP $42
	JR NZ,L808F
	CALL L04CC
	JP L8028
</small></pre>
<p>
The first implemented command is &#34;BORRA&#34;, but at the time I didn&#39;t know how to compare whole words, so it simply checks for the first letter &#34;B&#34; (ASCII $42), calls L04CC and jumps back to L8028.
</p>
<pre><small>
L808F:
        CP $54
        JR NZ,L80BF
        LD HL,(L86F0)
        CALL L0100
        LD A,$20
        OUT (VDP),A
        LD HL,$3D50
        LD (L86F0),HL
        CALL L0100
        LD A,$2A
        OUT (VDP),A
        CALL L80B0
        JP L8028

L80B0: 
        LD HL,$3EC1
L80B3:
        CALL L0100
        LD B,$40
L80B8:
        LD A,$20
        OUT (VDP),A
        DJNZ L80B8
        RET
</small></pre>
<p>
The second command is &#34;TORTUGA&#34; (T). It simply gets the current position of the turtle, puts a space character to erase it, centers it again on the screen, and draws it again. Apparently I forgot I had a turtle drawing subroutine at L807F, or that the L8028 jump already draws the turtle.
</p>
<pre><small>
L80BF:
        CP $53		
        JR NZ,L80E6
        LD A,(L8700+3)
        SUB $30
        LD B,A
L80C9:
        LD HL,(L86F0)
        CALL L0100
        LD A,$23
        OUT (VDP),A
        LD DE,$0020
        SBC HL,DE
        LD (L86F0),HL
        DJNZ L80C9
        CALL L80B0
        CALL L807F
        JP L8028
</small></pre>
<p>
The third command is &#34;SM&#34; (S). It expects the length in the fourth byte as a digit, so you need to type exactly SM followed by a space and the digit.
</p>
<p>
It converts the digit to a value between 0-9 and saves it into B as counter. It takes the current position of the turtle and draws a block, displaces the pointer, and repeats. It ends clearing the command area, redrawing the turtle, and jumping back to the main loop.
</p>
<p>
Notice it never validates the length, zero will draw 256 blocks.
</p>
<p>
Did I say block? Right, I didn&#39;t know anything about pixels, so when you don&#39;t have pixels, you have blocks, right? A very bold kid.
</p>
<pre><small>
L80E6:
        CP $44
        JR NZ,L811B
        LD A,(L8700+3)
        SUB $30
        LD B,A
L80F0:
        LD HL,(L86F0)
        CALL L0100
        LD A,$23
        OUT (VDP),A
        LD DE,$0001
        ADD HL,DE
        NOP
        LD (L86F0),HL
        DJNZ L80F0
        CALL L80B0
        CALL L807F
        JP L8028
</small></pre>
<p>
The fourth command is &#34;DM&#34; (D). It is exactly the same code, I only changed the displacement offset to go the right.
</p>
<pre><small>
L811B:
        CP $41
        JR NZ,L8142
        LD A,(L8700+3)
        SUB $30
        LD B,A
L8125:
        LD HL,(L86F0)
        CALL L0100
        LD A,$23
        OUT (VDP),A
        LD DE,$0020
        ADD HL,DE
        NOP
        LD (L86F0),HL
        DJNZ L8125
        CALL L80B0
        CALL L807F
        JP L8028

L8142:
        CP $49
        JR NZ,L8169
        LD A,(L8700+3)
        SUB $30
        LD B,A
L814C:
        LD HL,(L86F0)
        CALL L0100
        LD A,$23
        OUT (VDP),A
        LD DE,$0001
        SBC HL,DE
        LD (L86F0),HL
        DJNZ L814C      
        CALL L80B0 
        CALL L807F
        JP L8028
</small></pre>
<p>
The fifth command is &#34;AM&#34; (A) for going down, and the sixth command &#34;IM&#34; (I) for going to left. Again, I only changed the displacement offsets. I could have saved tons of bytes by having a generic drawing subroutine where you could provide an offset, but I was still learning, and probably afraid of juggling with registers.
</p>
<pre><small>
L8169:
        CP $50
        JR NZ,L8194-1
        LD HL,$3EE5
        LD (L87F0),HL
        CALL READ_WORD  ; Modified from RST $10
        LD D,H
        LD E,L
        LD HL,(L86F0)
        CALL L0100
        LD A,$20
        OUT (VDP),A
        LD HL,$3C00
        ADD HL,DE
        LD (L86F0),HL
        CALL L0100
        LD A,$2A
        OUT (VDP),A
        CALL L80B0
        JP L8028
</small></pre>
<p>
The seventh command is &#34;PT&#34;. It sets a position for the internal cursor by reading a hexadecimal word into HL that is saved right away into DE. It deletes the turtle from the screen, and repositions it at the DE position added $3c00 to put it into the right VRAM address. Almost the same code as the TORTUGA command, and again I forgot I had a turtle redraw subroutine.
</p>
<p>
By the way, there is a tiny bug here. In the machine code I calculated wrongly the relative jump JR NZ and it jumps one byte before the right address, as the opcode $81 is an ADD instruction, it doesn&#39;t affect and it works just right ($41 in MSX, LD B,C)
</p>
<pre><small>
L8194:
        LD HL,$3C01
        CALL L0100
        CALL L0169
        DB &#34;* ERROR *&#34;,0
        LD B,$05
L81A9:
        PUSH BC
        LD BC,$0000
L81AD:
        DEC BC
        LD A,B
        OR C
        JR NZ,L81AD
        POP BC
        DJNZ L81A9
        LD HL,$3C00
        CALL L80B3
        CALL L80B0
        JP L8028
</small></pre>
<p>
Finally, my LOCS program ends with an error message for an unrecognized command. It does a big delay, erases it, and returns to the main loop.
</p>
<p>
I&#39;ve made a tiny video showing my LOCS program in action.
</p>
<p><iframe width="420" height="315" src="https://www.youtube.com/embed/Gkko3HA-PIw" frameborder="0" allowfullscreen=""></iframe></p>
<h2>Downloads</h2>
<p>
You can download the original LOCS program (495 bytes), and the MSX adapted version (589 bytes with the translation layer), along with the original assembler code for both.
</p>
<ul>
    <li>Download <a href="https://nanochess.org/archive/locs.zip">locs.zip</a> (4.33 kb) containing assembler source code and binaries.</li>
</ul>
<div><p>
You can assemble it with my all-new assembler Gasm80 (available from <a href="https://github.com/nanochess/gasm80">https://github.com/nanochess/gasm80</a>) or with TNIasm v0.45.
</p></div>
<h2>Epilogue</h2>
<p>
To be a complete language it would need variables, expressions, and at least a conditional loop. But doesn&#39;t matter, HTML is called a language and doesn&#39;t have this!
</p>
<p>
I didn&#39;t understand exactly how angles worked at the time so there are none at all in my program. The use of blocks instead of pixels was crazy, also the lack of validation of the user&#39;s typing, but I can understand I was pretty enthusiastic (detecting commands with one single letter!) and I empirically discovered the principle of &#34;it is better to have it working than having nothing&#34;.
</p>
<p>
Over the years I kept working on compilers and interpreters for several languages going from BASIC to Pascal and then C, maybe later I&#39;ll talk about this. But it wasn&#39;t until 2014 that I made again my own language: <a href="https://nanochess.org/intybasic.html">IntyBASIC</a>, a dialect of BASIC with dedicated statements for Intellivision consoles, and more recently <a href="https://nanochess.org/cvbasic.html">CVBasic</a>.
</p>
<h2>Related links</h2>
<ul>
    <li><a href="https://nanochess.org/notebook.html">My first game coded in Z80 assembly language</a>.</li>
    <li><a href="https://hackaday.com/2024/02/08/revisiting-a-z80-game-from-1990/">Mention of Viboritas in Hackaday!</a></li>
    <li><a href="https://nanochess.org/cubos.html">Cubos</a>: Another of my early machine code games, written in 1991 when I was age 12.</li>
    <li><a href="https://nanochess.org/intybasic.html">IntyBASIC</a> is my BASIC language compiler for Intellivision.</li>
    <li><a href="https://nanochess.org/cvbasic.html">CVBasic</a> is my BASIC language compiler for Colecovision/SG1000/MSX.</li>
<li><a href="http://biyubi.com/educacion.html">The modern version of the course still being taught by my father</a>.</li>
</ul>
<p>Last modified: Mar/12/2024</p>
</div></div>
  </body>
</html>
