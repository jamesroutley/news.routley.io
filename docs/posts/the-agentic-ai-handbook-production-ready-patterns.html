<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.nibzard.com/agentic-handbook">Original</a>
    <h1>The Agentic AI Handbook: Production-Ready Patterns</h1>
    
    <div id="readability-page-1" class="page"><div> <blockquote>
Something happened over the 2025 winter holidays that caught everyone by surprise. While people were supposed to be relaxing with family and exchanging gifts, a quiet revolution was underway—and it showed up in the metrics.
</blockquote>
<h2 id="the-christmas-that-changed-everything"><a href="#the-christmas-that-changed-everything" aria-label="Link to The Christmas That Changed Everything" title="Link to The Christmas That Changed Everything">#</a> The Christmas That Changed Everything</h2>
<p>The <a href="https://github.com/nibzard/awesome-agentic-patterns?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">GitHub repository</a> for “Awesome Agentic Patterns” had been growing steadily since its launch. But around Christmas, the growth chart went vertical. In just a few days, the repository jumped from relative obscurity to nearly 2,500 stars. The <a href="https://agentic-patterns.com/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">website</a> traffic mirrored this spike. Something had clicked.</p>
<p>But the real story wasn’t in the metrics—it was in <em>who</em> was talking about AI agents.</p>

<p>Linus Torvalds, creator of Linux and Git, wrote about using AI coding agents for “vibe coding” and programming guitar pedal effects. Think about that for a second. The person who literally invented the version control system that powers modern software development was publicly embracing agents.</p>
<p>Tobias Lütke, CEO of Shopify and already deep into agent-assisted development, declared it his “most productive time.” This from someone running one of the world’s largest e-commerce platforms.</p>
<p>Perhaps most telling was Armin Ronacher, creator of Flask—one of the most respected voices in Python. He had been skeptical of coding agents, publicly raising concerns about their limitations. Then, seemingly overnight, his stance shifted. He started promoting agent-assisted workflows, documenting his learnings, and acknowledging that the technology had crossed a threshold.</p>
<h3 id="the-real-bottleneck-time">The Real Bottleneck: Time</h3>
<p>Here’s what all these stories have in common: <strong>the holidays gave people something that everyday life rarely provides—dedicated time.</strong></p>
<p>Learning to work effectively with AI agents isn’t something you pick up in five minutes between meetings. It requires:</p>
<ul>
<li><strong>Exploration time</strong>: Experimenting with what agents can and can’t do</li>
<li><strong>Failure cycles</strong>: Watching an agent go down a wrong path and understanding why</li>
<li><strong>Pattern recognition</strong>: Developing intuition for which problems suit agents</li>
<li><strong>Workflow redesign</strong>: Rethinking how you structure your development process</li>
<li><strong>Tool building</strong>: Creating the scaffolding that makes agents productive</li>
</ul>
<p>During the work year, these activities compete with deadlines, meetings, and the relentless pressure to ship. During the holidays, with meetings suspended and project urgency dialed down, developers finally had the bandwidth to actually <em>learn</em>.</p>
<p>This repository, with its 113 patterns collected from real production systems, became the curriculum that accelerated that learning. Each pattern represented a battle-tested solution—something that worked outside the demo environment and in the messy reality of production code.</p>
<h3 id="the-ralph-wiggum-phenomenon">The “Ralph Wiggum” Phenomenon</h3>
<p>Another phenomenon that exploded during the holidays was the “Ralph Wiggum coding loop”—named after the Simpsons character who means well but misses context. As <a href="https://ghuntley.com/ralph/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">ghuntley describes it</a>, this describes the cycle where an agent starts working on something, seems productive, but gradually drifts off-course because it lacks the deeper context that a human would implicitly understand.</p>
<p>The holiday spike represented people collectively figuring out how to break this cycle. The patterns in this collection—particularly around human-in-the-loop collaboration, monitoring, and control transfer—represent the solutions developers discovered. (For more on avoiding the Ralph Wiggum trap, see <a href="https://github.com/ghuntley/how-to-ralph-wiggum?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">ghuntley’s guide</a>).</p>
<h3 id="why-this-moment-matters">Why This Moment Matters</h3>
<p>The Christmas 2025 spike wasn’t just about more people trying AI agents. It was about a critical mass of developers reaching the “production patterns” stage of understanding. They’d moved beyond:</p>
<ul>
<li>“Wow, this can write code!”</li>
<li>“This is cool but makes mistakes…”</li>
<li>“How do I actually build with this?”</li>
</ul>
<p>To:</p>
<ul>
<li>“Here are the patterns that work in production”</li>
<li>“Here’s how to integrate agents into real workflows”</li>
<li>“Here’s how to make agents reliable, not just impressive”</li>
</ul>
<p>This guide represents a synthesis of those 113 patterns—a comprehensive map of the territory that the holiday explorers charted. Whether you’re just starting your journey or looking to deepen your understanding, these patterns represent the accumulated wisdom of teams who’ve shipped agents to production.</p>
<hr/>
<h2 id="what-are-agentic-patterns"><a href="#what-are-agentic-patterns" aria-label="Link to What Are Agentic Patterns?" title="Link to What Are Agentic Patterns?">#</a> What Are Agentic Patterns?</h2>
<p><strong>Agentic patterns</strong> are repeatable solutions, workflows, and mini-architectures that help autonomous or semi-autonomous AI agents get useful work done in production.</p>
<p>That definition deserves unpacking.</p>
<h3 id="the-gap-they-fill">The Gap They Fill</h3>
<p>If you’ve worked with AI agents, you’ve likely experienced the frustration of the <strong>demo-to-production gap</strong>:</p>
<ul>
<li><strong>Tutorials</strong> show single-shot successes: “Here’s how an agent writes a REST API”</li>
<li><strong>Demos</strong> highlight best-case scenarios: curated inputs, happy paths, perfect outputs</li>
<li><strong>Real products</strong> hide the messy implementation details that make agents actually work</li>
</ul>
<p>The gap is real. An agent that nails a demo can fail spectacularly in production because:</p>
<ul>
<li>Edge cases emerge at scale</li>
<li>Context windows fill up</li>
<li>Security constraints bite</li>
<li>Human workflows need integration</li>
<li>Reliability requirements demand safeguards</li>
</ul>
<p>Agentic patterns are the bridge across this gap. Each pattern represents something <strong>more than one team has implemented and validated</strong>. They’re not theoretical—they’re born from production experience.</p>
<h3 id="the-three-criteria">The Three Criteria</h3>
<p>Every pattern in this collection meets three criteria:</p>
<ol>
<li><strong>Repeatable</strong> – Multiple teams are using it successfully</li>
<li><strong>Agent-centric</strong> – It specifically improves how an AI agent senses, reasons, or acts</li>
<li><strong>Traceable</strong> – It’s backed by a public source: blog post, talk, paper, or repository</li>
</ol>
<p>This isn’t a collection of “clever prompt ideas” or “optimization tricks.” These are architectural patterns for building AI agents that work in the real world.</p>
<h3 id="why-patterns-matter">Why Patterns Matter</h3>
<p>The software industry learned the value of patterns decades ago. Design patterns gave us a shared vocabulary—a way to communicate complex architectural ideas efficiently. Instead of saying “let me describe how we’re structuring these objects,” you’d say “we’re using the Factory pattern.”</p>
<p>Agentic patterns serve the same purpose:</p>
<ul>
<li><strong>Shared vocabulary</strong>: “We’re using <a href="https://agentic-patterns.com/patterns/plan-then-execute-pattern/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Plan-Then-Execute</a>” conveys a whole architecture</li>
<li><strong>Accumulated wisdom</strong>: Learn from others’ production failures and successes</li>
<li><strong>Avoiding reinvention</strong>: Don’t re-derive solutions others have already validated</li>
<li><strong>Design discourse</strong>: Patterns give us something to critique and improve</li>
</ul>
<p>As of early 2026, this repository contains <strong>113 patterns</strong> organized into <strong>8 categories</strong>. Let’s explore what those categories represent.</p>
<hr/>
<h2 id="the-eight-categories-of-agentic-patterns"><a href="#the-eight-categories-of-agentic-patterns" aria-label="Link to The Eight Categories of Agentic Patterns" title="Link to The Eight Categories of Agentic Patterns">#</a> The Eight Categories of Agentic Patterns</h2>
<p>The patterns cluster naturally into eight categories, each addressing a different dimension of building production agents:</p>
<h3 id="1-orchestration--control">1. Orchestration &amp; Control</h3>
<p><strong>The brain of the agent.</strong> How does the agent decide what to do, in what order, and when to stop?</p>
<p>This is the largest category because it’s the most fundamental challenge: <strong>coordination</strong>. Agents need to plan, execute, adapt, and know when to ask for help.</p>
<p>Key patterns include:</p>
<ul>
<li><strong><a href="https://agentic-patterns.com/patterns/plan-then-execute-pattern/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Plan-Then-Execute</a></strong>: Separate planning from execution for security and reliability</li>
<li><strong><a href="https://agentic-patterns.com/patterns/inversion-of-control/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Inversion of Control</a></strong>: Give the agent tools and a goal, not step-by-step instructions</li>
<li><strong><a href="https://agentic-patterns.com/patterns/swarm-migration-pattern/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Swarm Migration</a></strong>: Orchestrate 10+ parallel subagents for large-scale tasks</li>
<li><strong><a href="https://agentic-patterns.com/patterns/language-agent-tree-search-lats/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Language Agent Tree Search (LATS)</a></strong>: Apply Monte Carlo Tree Search to reasoning problems</li>
<li><strong><a href="https://agentic-patterns.com/patterns/tree-of-thought-reasoning/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Tree of Thoughts</a></strong>: Structure reasoning as exploratory tree search</li>
</ul>
<h3 id="2-tool-use--environment">2. Tool Use &amp; Environment</h3>
<p><strong>The hands of the agent.</strong> How does the agent interact with external systems—APIs, databases, file systems, browsers?</p>
<p>Building agents is as much about the tools as the model. Poor tool design creates unusable agents. Great tool design unlocks capabilities.</p>
<p>Key patterns include:</p>
<ul>
<li><strong><a href="https://agentic-patterns.com/patterns/code-over-api-pattern/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Code-Over-API</a></strong>: Generate and execute code instead of calling REST APIs</li>
<li><strong><a href="https://agentic-patterns.com/patterns/progressive-tool-discovery/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Progressive Tool Discovery</a></strong>: Don’t overwhelm the agent with all tools at once</li>
<li><strong><a href="https://agentic-patterns.com/patterns/egress-lockdown-no-exfiltration-channel/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Egress Lockdown</a></strong>: Security pattern for agents that shouldn’t exfiltrate data</li>
<li><strong><a href="https://agentic-patterns.com/patterns/llm-friendly-api-design/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">LLM-Friendly API Design</a></strong>: Design APIs that language models can actually use effectively</li>
</ul>
<h3 id="3-context--memory">3. Context &amp; Memory</h3>
<p><strong>The mind of the agent.</strong> How does the agent manage limited context windows while building up knowledge over time?</p>
<p>Context is the scarcest resource in agent systems. These patterns address how to be strategic about what’s in context, what’s retrieved, and what’s persisted.</p>
<p>Key patterns include:</p>
<ul>
<li><strong><a href="https://agentic-patterns.com/patterns/context-window-anxiety-management/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Context Window Anxiety Management</a></strong>: Handle models that panic about token limits</li>
<li><strong><a href="https://agentic-patterns.com/patterns/episodic-memory-retrieval-injection/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Episodic Memory Retrieval</a></strong>: Build long-term memory across sessions</li>
<li><strong><a href="https://agentic-patterns.com/patterns/curated-code-context-window/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Curated Code Context</a></strong>: Selectively include only relevant code in context</li>
<li><strong><a href="https://agentic-patterns.com/patterns/progressive-disclosure-large-files/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Progressive Disclosure for Large Files</a></strong>: Load file contents incrementally</li>
</ul>
<h3 id="4-feedback-loops">4. Feedback Loops</h3>
<p><strong>The growth mechanism of the agent.</strong> How does the agent improve its outputs through iteration and evaluation?</p>
<p>The best agents don’t get it right on the first try—they iterate, reflect, and refine. These patterns structure that improvement process.</p>
<p>Key patterns include:</p>
<ul>
<li><strong><a href="https://agentic-patterns.com/patterns/reflection/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Reflection Loop</a></strong>: Generate, evaluate, refine until quality threshold is met</li>
<li><strong><a href="https://agentic-patterns.com/patterns/rich-feedback-loops/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Rich Feedback Loops &gt; Perfect Prompts</a></strong>: Better to iterate than obsess over initial prompts</li>
<li><strong><a href="https://agentic-patterns.com/patterns/coding-agent-ci-feedback-loop/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Coding Agent CI Feedback Loop</a></strong>: Use test failures as learning signals</li>
<li><strong><a href="https://agentic-patterns.com/patterns/graph-of-thoughts/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Graph of Thoughts (GoT)</a></strong>: Structure reasoning as a graph with interconnected thoughts</li>
</ul>
<h3 id="5-ux--collaboration">5. UX &amp; Collaboration</h3>
<p><strong>The partnership between human and agent.</strong> How do humans and agents work together effectively?</p>
<p>The best agents amplify human capabilities, they don’t replace humans. These patterns focus on collaboration, control transfer, and visibility.</p>
<p>Key patterns include:</p>
<ul>
<li><strong><a href="https://agentic-patterns.com/patterns/chain-of-thought-monitoring-interruption/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Chain-of-Thought Monitoring &amp; Interruption</a></strong>: Watch agent reasoning and intervene early</li>
<li><strong><a href="https://agentic-patterns.com/patterns/spectrum-of-control-blended-initiative/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Spectrum of Control</a></strong>: Fluidly shift between human and agent control</li>
<li><strong><a href="https://agentic-patterns.com/patterns/verbose-reasoning-transparency/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Verbose Reasoning Transparency</a></strong>: Make agent thinking visible for trust and debugging</li>
<li><strong><a href="https://agentic-patterns.com/patterns/abstracted-code-representation-for-review/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Abstracted Code Representation for Review</a></strong>: Higher-level summaries instead of raw diffs</li>
</ul>
<h3 id="6-reliability--eval">6. Reliability &amp; Eval</h3>
<p><strong>The quality assurance of the agent.</strong> How do you know your agent is working correctly?</p>
<p>Testing agents is fundamentally different from testing traditional software. These patterns address evaluation, reproducibility, and observability.</p>
<p>Key patterns include:</p>
<ul>
<li><strong><a href="https://agentic-patterns.com/patterns/lethal-trifecta-threat-model/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Lethal Trifecta Threat Model</a></strong>: Security framework for agent capabilities</li>
<li><strong><a href="https://agentic-patterns.com/patterns/anti-reward-hacking-grader-design/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Anti-Reward-Hacking Grader Design</a></strong>: Prevent agents from gaming evaluation metrics</li>
<li><strong><a href="https://agentic-patterns.com/patterns/extended-coherence-work-sessions/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Extended Coherence Work Sessions</a></strong>: Maintain agent focus across long interactions</li>
<li><strong><a href="https://agentic-patterns.com/patterns/workflow-evals-with-mocked-tools/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Workflow Evals with Mocked Tools</a></strong>: Test agent logic without real tool calls</li>
</ul>
<h3 id="7-learning--adaptation">7. Learning &amp; Adaptation</h3>
<p><strong>The evolution of the agent.</strong> How do agents improve over time and build institutional knowledge?</p>
<p>The smallest but perhaps most important category for long-term agent success. These patterns enable compounding improvement.</p>
<p>Key patterns include:</p>
<ul>
<li><strong><a href="https://agentic-patterns.com/patterns/skill-library-evolution/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Skill Library Evolution</a></strong>: Persist working code as reusable capabilities</li>
<li><strong><a href="https://agentic-patterns.com/patterns/agent-reinforcement-fine-tuning/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Agent Reinforcement Fine-Tuning (Agent RFT)</a></strong>: Train on successful tool interactions</li>
<li><strong><a href="https://agentic-patterns.com/patterns/compounding-engineering-pattern/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Compounding Engineering Pattern</a></strong>: Build on previous agent work</li>
<li><strong><a href="https://agentic-patterns.com/patterns/variance-based-rl-sample-selection/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Variance-Based RL</a></strong>: Select training examples based on uncertainty</li>
</ul>
<h3 id="8-security--safety">8. Security &amp; Safety</h3>
<p><strong>The safeguards for the agent.</strong> How do you prevent agents from causing harm?</p>
<p>This category is small but critical. As agents become more capable, security considerations become paramount.</p>
<p>Key patterns include:</p>
<ul>
<li><strong><a href="https://agentic-patterns.com/patterns/pii-tokenization/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">PII Tokenization</a></strong>: Protect privacy by tokenizing sensitive data</li>
<li><strong><a href="https://agentic-patterns.com/patterns/isolated-vm-per-rl-rollout/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Isolated VM per RL Rollout</a></strong>: Sandboxing for reinforcement learning</li>
<li><strong><a href="https://agentic-patterns.com/patterns/deterministic-security-scanning-build-loop/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Deterministic Security Scanning</a></strong>: Automated security checks in the loop</li>
</ul>
<hr/>
<h2 id="foundational-patterns-every-developer-should-know"><a href="#foundational-patterns-every-developer-should-know" aria-label="Link to Foundational Patterns Every Developer Should Know" title="Link to Foundational Patterns Every Developer Should Know">#</a> Foundational Patterns Every Developer Should Know</h2>
<p>With 113 patterns, where should you start? These four patterns represent the foundations—they’re simple, widely applicable, and address core challenges that emerge early in agent development.</p>
<h3 id="plan-then-execute-pattern">Plan-Then-Execute Pattern</h3>
<p><strong>The problem:</strong> If an agent’s tool outputs can alter the <em>choice</em> of later actions, malicious instructions can redirect the agent toward harmful steps. This is a variant of prompt injection, but at the tool-use level.</p>
<p><strong>The solution:</strong> Split reasoning into two distinct phases:</p>
<ol>
<li><strong>Plan phase</strong> – The LLM generates a <em>fixed</em> sequence of tool calls before seeing any untrusted data</li>
<li><strong>Execution phase</strong> – A controller runs that exact sequence. Tool outputs may shape <em>parameters</em>, but cannot change <em>which tools run</em></li>
</ol>
<p>This pattern is implemented in Claude Code’s “plan mode” and has been shown to <strong>2-3x success rates</strong> for complex tasks by aligning on approach before execution.</p>
<p><strong>When to use it:</strong> Any task where the action set is known but parameters vary—email/calendar bots, SQL assistants, code review helpers.</p>
<p><strong>Key insight:</strong> The boundary of what requires planning changes with each model generation. As models get more capable (Sonnet 4.5 vs. Opus 4.1), simpler tasks become one-shot and planning is reserved for genuinely complex workflows.</p>
<h3 id="inversion-of-control">Inversion of Control</h3>
<p><strong>The problem:</strong> Traditional “prompt-as-puppeteer” workflows force humans to spell out every step, limiting scale and creativity. You become a bottleneck to your own agent.</p>
<p><strong>The solution:</strong> Give the agent <strong>tools + a high-level goal</strong> and let <em>it</em> decide the orchestration. Humans supply guardrails (first 10% + last 3%) while the agent handles the middle 87%.</p>
<p><strong>Example:</strong> Instead of:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>&#34;Read the file, extract the UploadService class, check if it has async methods,</span></span>
<span><span>if not, add them, then update the tests to handle async...&#34;</span></span></code></pre>
<p>You’d say:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>&#34;Refactor UploadService to use async patterns. I&#39;ve given you tools to read files,</span></span>
<span><span>run tests, and make edits. Let me know when you have a PR ready for review.&#34;</span></span></code></pre>
<p><strong>When to use it:</strong> Nearly all production workflows. The more you try to micromanage agent execution, the less value you get. Trust the agent to figure out the “how” once you’ve defined the “what.”</p>
<p><strong>Key insight:</strong> This pattern comes from software development’s dependency injection principle, flipped. Instead of the framework controlling the flow, the agent controls the flow—but within constraints you provide.</p>
<h3 id="reflection-loop">Reflection Loop</h3>
<p><strong>The problem:</strong> Generative models produce subpar output when they never review or critique their own work. One-shot generation misses the opportunity for iterative improvement.</p>
<p><strong>The solution:</strong> After generating a draft, have the model grade it against a given metric and refine the response using that feedback:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>for attempt in range(max_iters):</span></span>
<span><span>    draft = generate(prompt)</span></span>
<span><span>    score, critique = evaluate(draft, metric)</span></span>
<span><span>    if score &gt;= threshold:</span></span>
<span><span>        return draft</span></span>
<span><span>    prompt = incorporate(critique, prompt)</span></span></code></pre>
<p><strong>When to use it:</strong> Any task where quality matters—writing, reasoning, or code. The loop continues until quality threshold is met or max iterations reached.</p>
<p><strong>Key insight:</strong> This is the engine behind many “magic” agent capabilities. The difference between a mediocre agent output and a great one is often just 2-3 reflection iterations. Status: “established” showing proven value across many implementations.</p>
<h3 id="chain-of-thought-monitoring--interruption">Chain-of-Thought Monitoring &amp; Interruption</h3>
<p><strong>The problem:</strong> Agents can pursue misguided reasoning paths for extended periods before producing final outputs. By the time you realize the approach is wrong, significant time and tokens have been wasted.</p>
<p><strong>The solution:</strong> Implement active surveillance of the agent’s intermediate reasoning with the capability to interrupt and redirect early. Monitor chain-of-thought outputs, tool calls, and intermediate results in real-time.</p>
<p>Tanner Jones of Vulcan advises: “Have your finger on the trigger to escape and interrupt any bad behavior.”</p>
<p><strong>When to use it:</strong> Complex refactoring, deep codebase understanding, high-stakes operations (database migrations, API changes), or when the agent might misinterpret ambiguous requirements.</p>
<p><strong>Key insight:</strong> The first tool call an agent makes often reveals whether it understands the problem. Monitor that first decision closely—if it’s wrong, interrupt immediately. Don’t wait for completion of a flawed sequence.</p>
<hr/>
<h2 id="the-architecture-of-multi-agent-systems"><a href="#the-architecture-of-multi-agent-systems" aria-label="Link to The Architecture of Multi-Agent Systems" title="Link to The Architecture of Multi-Agent Systems">#</a> The Architecture of Multi-Agent Systems</h2>
<p>Single agents hit limits. They get stuck in local optima, struggle with complex parallelization, and fail when problems require diverse expertise. Multi-agent systems address these limitations through specialization and coordination.</p>
<h3 id="why-multiple-agents">Why Multiple Agents?</h3>
<p>The jump from single-agent to multi-agent systems follows a natural progression:</p>
<ul>
<li><strong>Single agent</strong>: Good for straightforward, sequential tasks</li>
<li><strong>Multiple agents</strong>: Necessary for complex, parallelizable, or multi-domain problems</li>
</ul>
<p>The key insight: <strong>specialization beats generalization</strong>. An agent optimized for code review will outperform a generalist agent asked to review code. A swarm of specialized agents, properly coordinated, can outperform any single agent.</p>
<h3 id="swarm-migration-pattern">Swarm Migration Pattern</h3>
<p><strong>The problem:</strong> Large-scale code migrations are time-consuming when done sequentially—framework upgrades, lint rule rollouts, API migrations across hundreds of files.</p>
<p><strong>The solution:</strong> Use a <strong>swarm architecture</strong> where a main agent orchestrates 10+ parallel subagents working simultaneously on independent chunks:</p>
<ol>
<li>Main agent creates migration plan (enumerate all files needing changes)</li>
<li>Create todo list and break into parallelizable chunks</li>
<li>Spawn subagent swarm (10+ agents concurrently, each taking N items)</li>
<li>Map-reduce execution (each subagent migrates its chunk independently)</li>
<li>Main agent verifies results and consolidates</li>
</ol>
<p><strong>Real-world usage at Anthropic:</strong> Internal users spend over $1,000/month on migrations. The common pattern: “The main agent makes a big to-do list for everything and then just kind of map reduces over a bunch of subagents. Start 10 agents and then just go 10 at a time and migrate all the stuff over.”</p>
<p><strong>Result:</strong> 10x+ speedup vs sequential approaches. Migrations that would take weeks manually happen in hours.</p>
<p><strong>Key insight:</strong> This only works when migrations are atomic—each file can be migrated independently. Clear specifications and good test coverage are prerequisites.</p>
<h3 id="language-agent-tree-search-lats">Language Agent Tree Search (LATS)</h3>
<p><strong>The problem:</strong> Single agents struggle with complex reasoning tasks requiring exploration of multiple solution paths. Simple linear approaches get stuck in local optima or fail to consider alternative strategies.</p>
<p><strong>The solution:</strong> Combine Monte Carlo Tree Search (MCTS) with language model reflection:</p>
<ul>
<li>Nodes represent states (partial solutions or reasoning steps)</li>
<li>Edges represent actions (next steps in reasoning)</li>
<li>Leaf nodes are evaluated using the LLM’s self-reflection capabilities</li>
<li>Backpropagation updates value estimates throughout the tree</li>
</ul>
<p>The agent explores promising branches more deeply while maintaining breadth to avoid getting stuck.</p>
<p><strong>Results:</strong> Outperforms ReACT, Reflexion, and <a href="https://agentic-patterns.com/patterns/tree-of-thought-reasoning/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Tree of Thoughts</a> on complex reasoning tasks.</p>
<p><strong>When to use it:</strong> Strategic planning, mathematical reasoning, multi-step problem solving where early decisions significantly impact later outcomes.</p>
<p><strong>Key insight:</strong> This is expensive in compute but effective for genuinely hard problems. Not worth it for simple tasks—the overhead outweighs the benefit.</p>
<h3 id="the-oracleworker-pattern">The Oracle/Worker Pattern</h3>
<p><strong>The problem:</strong> Different models have different strengths and costs. Using the most capable model for everything is economically unsustainable.</p>
<p><strong>The solution:</strong> Use a “cheap” model for workers and an “expensive” model for the oracle:</p>
<ul>
<li><strong>Oracle</strong>: High-end model (e.g., Opus) does planning, review, and error correction</li>
<li><strong>Workers</strong>: Smaller models (e.g., Haiku) execute individual tasks</li>
</ul>
<p><strong>Trade-off:</strong> You get the intelligence of the best model at a fraction of the cost—most work is parallelizable and can be done by smaller models. But coordination complexity increases, and you need robust task decomposition.</p>
<p><strong>Key insight:</strong> This pattern is production-proven at scale. It’s how companies ship capable agents without burning their entire compute budget on the most expensive model for every request.</p>
<blockquote>
The jump from single-agent to multi-agent systems follows a natural progression. Specialization beats generalization. An agent optimized for code review will outperform a generalist agent asked to review code.
</blockquote>
<hr/>
<h2 id="the-human-ai-collaboration-spectrum"><a href="#the-human-ai-collaboration-spectrum" aria-label="Link to The Human-AI Collaboration Spectrum" title="Link to The Human-AI Collaboration Spectrum">#</a> The Human-AI Collaboration Spectrum</h2>
<p>Despite the hype about “fully autonomous agents,” the most successful systems are fundamentally <strong>collaborative</strong>. The best patterns amplify human capabilities rather than replacing humans.</p>
<h3 id="its-orchestration-not-replacement">It’s Orchestration, Not Replacement</h3>
<p>The framing matters. If you think of agents as “replacement,” you design for autonomy and get frustration. If you think of agents as “orchestration,” you design for collaboration and get leverage.</p>
<p>Key patterns that enable effective collaboration:</p>
<h3 id="spectrum-of-control--blended-initiative">Spectrum of Control / Blended Initiative</h3>
<p><strong>The problem:</strong> Treating human-agent interaction as binary—either human is in control or agent is in control—misses the nuanced reality of effective collaboration.</p>
<p><strong>The solution:</strong> Design for fluid, intentional, reversible control transfer:</p>
<ul>
<li><strong>Human-led</strong>: Human directs, agent executes (e.g., “help me refactor this function”)</li>
<li><strong>Agent-led</strong>: Agent proposes, human approves (e.g., “I found 10 potential bugs, review them”)</li>
<li><strong>Blended</strong>: Fluid back-and-forth based on confidence and context</li>
</ul>
<p><strong>Implementation:</strong> Agents should explicitly signal confidence levels and when they’re crossing control boundaries. Humans should have clear mechanisms to intervene or take back control.</p>
<p><strong>Key insight:</strong> The most productive state isn’t fully autonomous or fully manual—it’s the dynamic middle where control flows smoothly based on context, confidence, and capability.</p>
<h3 id="chain-of-thought-monitoring">Chain-of-Thought Monitoring</h3>
<p>We covered this in foundational patterns, but it’s worth emphasizing in the collaboration context. <strong>Visibility equals control</strong>.</p>
<p>When you can see the agent’s reasoning in real-time:</p>
<ul>
<li>You catch wrong assumptions early</li>
<li>You understand <em>why</em> it made decisions</li>
<li>You can intervene before it wastes resources</li>
<li>You build trust through transparency</li>
</ul>
<p>The “have finger on the trigger” philosophy is literal—you’re not passively watching, you’re ready to intervene the moment something goes off-track.</p>
<h3 id="abstracted-code-representation-for-review">Abstracted Code Representation for Review</h3>
<p><strong>The problem:</strong> Traditional code review shows raw diffs—line-by-line changes that miss the forest for the trees. Agents generate changes that span many files, making traditional review overwhelming.</p>
<p><strong>The solution:</strong> Generate higher-level representations for review:</p>
<ul>
<li>Pseudocode summaries of changes</li>
<li>Intent descriptions (“this refactors X to enable Y”)</li>
<li>Architectural rationales (“reorganizing to separate concerns”)</li>
<li>Before/after behavior descriptions</li>
</ul>
<p><strong>Result:</strong> Review becomes faster and more effective. You’re evaluating <em>whether the change is right</em>, not scrutinizing every line.</p>
<p><strong>Key insight:</strong> Agents are good at generating summaries of their own work. Leverage this to make human-in-the-loop review actually scalable.</p>
<hr/>
<h2 id="security-patterns-for-the-agentic-age"><a href="#security-patterns-for-the-agentic-age" aria-label="Link to Security Patterns for the Agentic Age" title="Link to Security Patterns for the Agentic Age">#</a> Security Patterns for the Agentic Age</h2>
<p>As agents become more capable, security considerations become more urgent. The Lethal Trifecta threat model provides a framework for thinking about agent security.</p>
<h3 id="the-lethal-trifecta">The Lethal Trifecta</h3>
<p><strong>The problem:</strong> Combining three capabilities creates a straightforward path for prompt-injection attacks:</p>
<ol>
<li><strong>Access to private data</strong> (secrets, user data, internal systems)</li>
<li><strong>Exposure to untrusted content</strong> (user input, web content, emails)</li>
<li><strong>Ability to externally communicate</strong> (API calls, webhooks, message sending)</li>
</ol>
<p>When all three circles overlap, attackers can inject instructions that cause agents to exfiltrate sensitive data. LLMs cannot reliably distinguish “good” instructions from malicious ones once they appear in the same context window.</p>
<p><strong>The solution:</strong> Guarantee that at least one circle is missing in any execution path:</p>
<ul>
<li>Remove external network access (no exfiltration)</li>
<li>Deny direct file/database reads (no private data)</li>
<li>Sanitize or segregate untrusted inputs (no hostile instructions)</li>
</ul>
<p><strong>Implementation:</strong> Enforce this at orchestration time with a capability matrix for every tool, not with brittle prompt guardrails.</p>
<p><strong>Status:</strong> Best practice—this is the security framework teams should adopt for production agents.</p>
<h3 id="compartmentalization">Compartmentalization</h3>
<p><strong>The principle:</strong> Apply least-privilege principles to agent tool design. Agents should only have access to tools required for their specific task.</p>
<p><strong>Implementation:</strong></p>
<ul>
<li>Scoped tool sets per agent type</li>
<li>Permission boundaries (read-only vs read-write)</li>
<li>Environment isolation (sandboxed execution)</li>
<li>Audit logging of all tool access</li>
</ul>
<p><strong>Key insight:</strong> Security through compartmentalization is more robust than security through monitoring. If an agent can’t access sensitive data in the first place, prompt injection can’t steal it.</p>
<h3 id="pii-tokenization">PII Tokenization</h3>
<p><strong>The problem:</strong> Agents need to work with sensitive data, but including raw PII in prompts creates privacy and compliance risks.</p>
<p><strong>The solution:</strong> Use MCP-based tokenization that replaces sensitive data with tokens before the agent sees it:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>Original: &#34;Send email to john@example.com&#34;</span></span>
<span><span>Tokenized: &#34;Send email to [EMAIL_TOKEN_123]&#34;</span></span></code></pre>
<p>The agent works with tokens. A downstream service resolves tokens to actual values when executing actions.</p>
<p><strong>Benefits:</strong></p>
<ul>
<li>Transparent to agent reasoning</li>
<li>PII never enters model context</li>
<li>Compliance-friendly for regulated workflows</li>
<li>Reversible when needed for execution</li>
</ul>
<p><strong>Key insight:</strong> Privacy preservation doesn’t require blocking agents from working with data—it just requires careful representation of that data.</p>
<blockquote>
The Christmas 2025 spike wasn&#39;t just about more people trying AI agents. It was about a critical mass of developers reaching the &#34;production patterns&#34; stage of understanding.
</blockquote>
<hr/>
<h2 id="production-patterns-others-learned-the-hard-way"><a href="#production-patterns-others-learned-the-hard-way" aria-label="Link to Production Patterns Others Learned The Hard Way" title="Link to Production Patterns Others Learned The Hard Way">#</a> Production Patterns Others Learned The Hard Way</h2>
<p>Some patterns only emerge after you’ve deployed agents to production and watched them fail. These represent hard-won lessons from teams who’ve been in the trenches.</p>
<h3 id="context-window-anxiety">Context Window Anxiety</h3>
<p><strong>The discovery:</strong> Models like Claude Sonnet 4.5 exhibit “context anxiety”—they become aware of approaching context window limits and proactively summarize or close tasks prematurely, even when sufficient context remains.</p>
<p><strong>Symptoms:</strong></p>
<ul>
<li>Sudden summarization mid-task</li>
<li>Rushed decisions to “wrap up”</li>
<li>Explicit mentions of “running out of space”</li>
<li>Incomplete work despite adequate context capacity</li>
</ul>
<p><strong>The solution:</strong></p>
<ol>
<li>Enable large context windows (e.g., 1M tokens) but cap actual usage at 200k tokens—provides psychological “runway”</li>
<li>Aggressive counter-prompting: “You have plenty of context remaining—do not rush”</li>
<li>Explicit token budget transparency in prompts</li>
</ol>
<p><strong>Source:</strong> Cognition AI’s experience building Devin with Claude Sonnet 4.5.</p>
<p><strong>Key insight:</strong> Model behavior includes psychological quirks that wouldn’t exist in deterministic systems. Understanding these quirks is part of production agent engineering.</p>
<h3 id="agent-reinforcement-fine-tuning-agent-rft">Agent Reinforcement Fine-Tuning (Agent RFT)</h3>
<p><strong>The problem:</strong> Traditional RL requires millions of training samples. For agent-specific tasks, gathering that much data is impractical.</p>
<p><strong>The breakthrough:</strong> End-to-end training on actual tool interactions is sample-efficient. Real results show <strong>50-72% performance improvements</strong> from just 100-1000 successful trajectories.</p>
<p><strong>How it works:</strong></p>
<ol>
<li>Collect trajectories of successful agent executions (tools called, intermediate reasoning, final outcomes)</li>
<li>Fine-tune the model to imitate these successful patterns</li>
<li>The model learns <em>strategies</em> for tool use, not just responses</li>
</ol>
<p><strong>Key insight:</strong> The key is training on <em>agent workflows</em>, not just input-output pairs. The model learns when to call tools, how to sequence them, and how to recover from failures.</p>
<h3 id="skill-library-evolution">Skill Library Evolution</h3>
<p><strong>The problem:</strong> Agents frequently solve similar problems across different sessions. Without persistence, they must rediscover solutions each time, wasting tokens and time.</p>
<p><strong>The solution:</strong> Persist working code implementations as reusable skills that evolve over time:</p>
<p>graph LR
    A[Ad-hoc Code] --&gt; B[Save Working Solution]
    B --&gt; C[Reusable Function]
    C --&gt; D[Documented Skill]
    D --&gt; E[Agent Capability]</p>
<p><strong>Evolution path:</strong></p>
<ol>
<li>Agent writes code to solve immediate problem</li>
<li>If solution works, save to skills/ directory</li>
<li>Refactor for generalization (parameterize hard-coded values)</li>
<li>Add documentation (purpose, parameters, returns, examples)</li>
<li>Agent discovers and reuses skill in future sessions</li>
</ol>
<p><strong>Progressive disclosure optimization:</strong> Instead of loading all skills into context, inject skill descriptions and provide on-demand loading. This achieved <strong>91% token reduction</strong> in one implementation (26 tools at 17k tokens → 4 selected tools at 1.5k tokens).</p>
<p><strong>Key insight:</strong> Organizations want agents to build capability over time, not start from scratch every session. Skills become institutional knowledge.</p>
<hr/>
<h2 id="the-maturity-model"><a href="#the-maturity-model" aria-label="Link to The Maturity Model" title="Link to The Maturity Model">#</a> The Maturity Model</h2>
<p>Not all patterns are equally validated. The repository uses a status system to track maturity:</p>
<ul>
<li><strong>proposed</strong> – Suggested but not yet widely adopted</li>
<li><strong>emerging</strong> – Early adoption, promising but not yet proven</li>
<li><strong>established</strong> – Widely used, well-understood</li>
<li><strong>validated-in-production</strong> – Proven in real production systems at scale</li>
<li><strong>best-practice</strong> – Industry consensus that this is the right approach</li>
<li><strong>rapidly-improving</strong> – The area is moving quickly, patterns evolve frequently</li>
<li><strong>experimental-but-awesome</strong> – Not proven yet, but too interesting to ignore</li>
</ul>
<h3 id="why-maturity-matters">Why Maturity Matters</h3>
<p>In a fast-moving field like agentic AI, maturity tracking is crucial because:</p>
<ul>
<li><strong>Early adoption risk</strong>: Emerging patterns may have hidden failure modes</li>
<li><strong>Stability vs innovation</strong>: Production systems need established patterns; R&amp;D needs experimental ones</li>
<li><strong>Investment decisions</strong>: Where do you invest engineering resources?</li>
<li><strong>Expectation setting</strong>: What can you realistically expect from a pattern?</li>
</ul>
<h3 id="the-rapidly-improving-category">The “Rapidly-Improving” Category</h3>
<p>This status acknowledges that some areas of agent development are moving so fast that patterns have short half-lives. Something that’s best-practice today might be superseded in six months.</p>
<p>Examples include inference optimization, token budgeting strategies, and some aspects of tool design.</p>
<h3 id="the-experimental-but-awesome-category">The “Experimental-but-Awesome” Category</h3>
<p>Some patterns are too promising to ignore despite limited validation. They might be:</p>
<ul>
<li>Novel approaches from cutting-edge research</li>
<li>Patterns from a single visionary team</li>
<li>Techniques that work spectacularly in specific contexts</li>
</ul>
<p>The label signals: “This is exciting, but proceed with caution and validate for your use case.”</p>
<hr/>
<h2 id="practical-takeaways-how-to-start"><a href="#practical-takeaways-how-to-start" aria-label="Link to Practical Takeaways: How to Start" title="Link to Practical Takeaways: How to Start">#</a> Practical Takeaways: How to Start</h2>
<p>You’ve just absorbed a comprehensive guide to agentic patterns. Where do you actually start?</p>
<h3 id="step-1-pick-three-patterns">Step 1: Pick Three Patterns</h3>
<p>Don’t try to adopt 113 patterns at once. Pick three that address your immediate challenges:</p>
<p><strong>If you’re building your first agent:</strong></p>
<ul>
<li><a href="https://agentic-patterns.com/patterns/inversion-of-control/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Inversion of Control</a> (orchestration)</li>
<li><a href="https://agentic-patterns.com/patterns/reflection/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Reflection Loop</a> (quality)</li>
<li><a href="https://agentic-patterns.com/patterns/chain-of-thought-monitoring-interruption/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Chain-of-Thought Monitoring</a> (visibility)</li>
</ul>
<p><strong>If you’re scaling an existing agent:</strong></p>
<ul>
<li><a href="https://agentic-patterns.com/patterns/skill-library-evolution/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Skill Library Evolution</a> (knowledge persistence)</li>
<li><a href="https://agentic-patterns.com/patterns/plan-then-execute-pattern/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Plan-Then-Execute</a> (reliability)</li>
<li><a href="https://agentic-patterns.com/patterns/spectrum-of-control-blended-initiative/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Spectrum of Control</a> (collaboration)</li>
</ul>
<p><strong>If you’re focused on security:</strong></p>
<ul>
<li><a href="https://agentic-patterns.com/patterns/lethal-trifecta-threat-model/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Lethal Trifecta Threat Model</a> (security framework)</li>
<li><a href="https://agentic-patterns.com/patterns/tool-capability-compartmentalization/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Compartmentalization</a> (tool design)</li>
<li><a href="https://agentic-patterns.com/patterns/pii-tokenization/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">PII Tokenization</a> (privacy)</li>
</ul>
<h3 id="step-2-implement-observe-iterate">Step 2: Implement, Observe, Iterate</h3>
<p>Patterns aren’t plug-and-play. They require adaptation to your specific context:</p>
<ol>
<li><strong>Implement the pattern</strong> in your environment</li>
<li><strong>Observe how it behaves</strong> with your actual workload</li>
<li><strong>Iterate on the implementation</strong> based on what you learn</li>
<li><strong>Document your learnings</strong>—even failures are valuable</li>
</ol>
<h3 id="step-3-build-your-pattern-library">Step 3: Build Your Pattern Library</h3>
<p>As you gain experience, you’ll discover patterns of your own:</p>
<ol>
<li>Notice recurring solutions in your agent implementations</li>
<li>Extract the core pattern (problem → solution → trade-offs)</li>
<li>Document with examples and references</li>
<li>Contribute back to the community</li>
</ol>
<p>The growth of this repository from 0 to 113 patterns happened because teams shared their learnings. Your patterns could help others.</p>
<h3 id="step-4-stay-current">Step 4: Stay Current</h3>
<p>This field moves fast. “Rapidly-improving” patterns today might be “established” or “best-practice” tomorrow. Or completely superseded.</p>
<ul>
<li>Watch the repository for new patterns</li>
<li>Follow the thought leaders who share openly (Anthropic, Sourcegraph, Cognition, Will Larson, Simon Willison)</li>
<li>Experiment with emerging patterns in low-stakes contexts</li>
<li>Share your own discoveries</li>
</ul>
<hr/>
<h2 id="the-future-whats-missing-whats-next"><a href="#the-future-whats-missing-whats-next" aria-label="Link to The Future: What’s Missing, What’s Next" title="Link to The Future: What’s Missing, What’s Next">#</a> The Future: What’s Missing, What’s Next</h2>
<p>The 113 patterns in this collection represent the state of agentic AI in early 2026. But the frontier is moving. What’s missing?</p>
<h3 id="gaps-and-opportunities">Gaps and Opportunities</h3>
<p><strong>Small categories that should grow:</strong></p>
<ul>
<li><strong>Security &amp; Safety</strong> – Will expand as agents become more deployed</li>
<li><strong>Learning &amp; Adaptation</strong> – The holy grail of agents that actually improve</li>
</ul>
<p><strong>Underexplored areas:</strong></p>
<ul>
<li>Multi-modal agents (beyond text and code)</li>
<li>Long-running autonomous agents (hours/days, not minutes)</li>
<li>Agent-to-agent communication protocols</li>
<li>Economic models for agent resource allocation</li>
<li>Legal and compliance frameworks for agent actions</li>
</ul>
<h3 id="the-next-wave">The Next Wave</h3>
<p>The next major evolution is likely in <strong>agent learning</strong>. Current agents are mostly static—they don’t fundamentally improve from experience. <a href="https://agentic-patterns.com/patterns/agent-reinforcement-fine-tuning/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">Agent RFT</a>, <a href="https://agentic-patterns.com/patterns/skill-library-evolution/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">skill libraries</a>, and <a href="https://agentic-patterns.com/patterns/compounding-engineering-pattern/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">compounding patterns</a> point toward agents that:</p>
<ul>
<li>Learn from every interaction</li>
<li>Build institutional knowledge over time</li>
<li>Share skills across agent instances</li>
<li>Improve without manual fine-tuning</li>
</ul>
<p>This is the transition from “smart tools” to “genuinely intelligent systems.”</p>
<hr/>
<h2 id="conclusion-the-holidays-are-over-the-revolution-continues"><a href="#conclusion-the-holidays-are-over-the-revolution-continues" aria-label="Link to Conclusion: The Holidays Are Over, The Revolution Continues" title="Link to Conclusion: The Holidays Are Over, The Revolution Continues">#</a> Conclusion: The Holidays Are Over, The Revolution Continues</h2>
<p>The Christmas 2025 spike in interest was real, but it was just the beginning. Those 2,500 GitHub stars and the explosion of developer interest represent a collective “aha moment”—the realization that AI agents are production-ready when you have the right patterns.</p>
<p>But patterns alone aren’t enough. The real work is:</p>
<ul>
<li><strong>Understanding your domain</strong> well enough to know where agents fit</li>
<li><strong>Building the tooling</strong> and infrastructure that makes agents productive</li>
<li><strong>Developing the judgment</strong> to know when to trust the agent and when to intervene</li>
<li><strong>Cultivating the patience</strong> to iterate through failures to reach reliable systems</li>
</ul>
<p>This collection of 113 patterns is a map, but you still have to walk the territory.</p>
<h3 id="this-is-still-day-one">This Is Still Day One</h3>
<p>As impressive as the current state of agentic AI is, we’re remarkably early. The patterns validated in 2026 will seem primitive by 2028. Agents that seem cutting-edge today will be table stakes tomorrow.</p>
<p>The teams that win will be the ones who:</p>
<ul>
<li>Learn faster by sharing patterns openly</li>
<li>Fail faster by iterating quickly</li>
<li>Build on shared knowledge instead of reinventing</li>
<li>Stay curious as the frontier advances</li>
</ul>
<h3 id="your-next-step">Your Next Step</h3>
<p>You’ve just read a comprehensive guide to agentic patterns. The most valuable next step is to <strong>actually use one</strong>.</p>
<p>Pick a pattern. Implement it. Watch it fail. Fix it. Watch it succeed. Then <a href="https://github.com/nibzard/awesome-agentic-patterns?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">share what you learned</a> with the community.</p>
<p>The best time to start exploring agents was during the holidays. The second best time is now.</p>
<hr/>
<p><em>Written in early 2026 based on the collective wisdom of teams shipping agents to production. Explore the full collection of 113 patterns at <a href="https://agentic-patterns.com/?utm_source=nibzard.com" target="_blank" rel="noopener noreferrer">agentic-patterns.com</a>.</em></p>  </div></div>
  </body>
</html>
