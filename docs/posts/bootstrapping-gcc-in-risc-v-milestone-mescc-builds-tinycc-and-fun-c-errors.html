<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ekaitz.elenq.tech/bootstrapGcc8.html">Original</a>
    <h1>Bootstrapping GCC in RISC-V: Milestone: MesCC builds TinyCC and fun C errors</h1>
    
    <div id="readability-page-1" class="page"><div>
        
<section id="content">
  <header>
    <h2>
      <a href="https://ekaitz.elenq.tech/bootstrapGcc8.html" rel="bookmark" title="Permalink to Milestone — MesCC builds TinyCC and fun C errors for everyone">Milestone — MesCC builds TinyCC and fun C errors for everyone</a></h2>
 


  <!-- /.post-info -->

  <blockquote>
    <p>
        From the series:
        <a href="https://ekaitz.elenq.tech/tag/bootstrapping-gcc-in-risc-v.html">Bootstrapping GCC in RISC-V</a>
    </p>
  </blockquote>
  </header>


  <div>
    <p>It’s been a while since the latest technical update in the project and I am
fully aware that you were missing it so it’s time to recap with a really cool announcement:</p>
<p><span>
<strong>We finally made a self-hosted Bootstrappable TinyCC in <span>RISC</span>-V</strong>
</span></p>
<p>Most of you probably remember I <a href="https://ekaitz.elenq.tech/bootstrapGcc6.html">already backported</a> the
Bootstrappable TinyCC compiler, but I didn’t test it in a proper environment.
Now, we can confidently say it is able to compile itself, a “large” program
that makes use of more complex C features than I did in the tests.</p>
<p>All this work was done by Andrius Štikonas and myself. Janneke helped us a lot
with Mes related parts, too. The work this time was pretty hard, honestly. Most
of the things we did here are not obvious, even for C programmers.</p>
<p>I’m not used to this kind of quirks of the C language. Most of them are really
specific, related with the standards and many others are just things were
missing. I hope the ones I chose to discuss here help you understand your
computing better, as they did to me.</p>
<p>This is going to be veery long post, so take a ToC to help you out:</p>
<ol>
<li><a href="#context">Context</a><ol>
<li><a href="#why-important">Why is this important?</a></li>
</ol>
</li>
<li><a href="#problems">Problems fixed</a><ol>
<li><a href="#tinycc-missing-instructions">TinyCC misses assembly instructions needed for MesLibC</a></li>
<li><a href="#tcc-assembly">TinyCC’s assembly syntax is weird</a></li>
<li><a href="#extended-assembly">TinyCC does not support Extended Asm in <span>RV64</span></a></li>
<li><a href="#main-args">MesLibC <code>main</code> function arguments are not set properly</a></li>
<li><a href="#dollars">TinyCC says <code>__global_pointer$</code> is not a valid symbol</a></li>
<li><a href="#tcc-casting-issues">Bootstrappable TinyCC’s casting issues</a></li>
<li><a href="#long-double">Bootstrappable TinyCC’s <code>long double</code> support was missing</a></li>
<li><a href="#mescc-struct-init">MesCC struct initialization issues</a></li>
<li><a href="#size-problems">MesCC vs TinyCC size problems</a></li>
<li><a href="#mes-signed-shift">MesCC add support for signed shift operation</a></li>
<li><a href="#broken-case">MesCC switch/case falls-back to default case</a></li>
<li><a href="#got">Boostrappable TinyCC problems with <span>GOT</span></a></li>
<li><a href="#wrong-conditionals">Bootstrappable TinyCC generates wrong assembly in conditionals</a></li>
<li><a href="#varargs">Support for variable length arguments</a></li>
<li><a href="#int8">MesLibC use <code>signed char</code> for <code>int8_t</code></a></li>
<li><a href="#jmp">MesLibC Implement <code>setjmp</code> and <code>longjmp</code></a></li>
<li><a href="#more">More</a></li>
</ol>
</li>
<li><a href="#reproducing">Reproducing what we did</a><ol>
<li><a href="#live-bootstrap">Using live-bootstrap</a></li>
<li><a href="#guix">Using Guix</a></li>
</ol>
</li>
<li><a href="#conclusions">Conclusions</a></li>
<li><a href="#next">What is next?</a></li>
</ol>
<h3 id="context">Context</h3>
<p>You have many blogposts in the series to find the some context about the
project, and even a <span>FOSDEM</span> talk about it, but they all give a very broad
explanation, so let’s focus on what we are doing right now.</p>
<p>Here we have Mes, a Scheme interpreter, that runs MesCC, a C compiler, that is
compiling our simplified fork of TinyCC, let’s call that Bootstrappable TinyCC.
That Bootstrappable TinyCC compiler then tries to compile its own code. It
compiles it’s own code because it’s goal is to add more flags in each
compilation, so it has more features in each round<sup id="fnref:rounds"><a href="#fn:rounds">1</a></sup>. We do all this
because TinyCC is way faster than MesCC and it’s also more complex, but MesCC
is only able to build a simple TinyCC with few features enabled.</p>
<p>During all this process we use a standard library provided by the Mes project,
we’ll call it MesLibC, because we can’t build glibc at this point, and TinyCC
does not provide it’s own C standard library.</p>
<p>With all this well understood, this is the achievement:</p>
<p><strong>We made MesCC able to compile the Bootstrappable TinyCC, using MesLibC, to an
executable that is able to compile the Bootstrappable TinyCC’s codebase to a
binary that works and has all the features we need enabled.</strong><sup id="fnref:self-hosted"><a href="#fn:self-hosted">2</a></sup></p>
<p>The process affected all the pieces in the system. We added changes in MesCC,
MesLibC and the Bootstrappable TinyCC.</p>
<h4 id="why-important">Why is this important?</h4>
<p>We already talked long about the bootstrapping issue, the trusting trust attack
and all that. I won’t repeat that here. What I’ll do instead is to be specific.
This step is a big thing because this allows us to go way further in the chain.</p>
<p>All the steps before Mes were already ported to <span>RISC</span>-V mostly thanks to Andrius
Štikonas who worked in <a href="https://github.com/oriansj/stage0-posix">Stage0-<span>POSIX</span></a> and the rest of glue projects
that are needed to reach Mes.</p>
<p>Mes had been ported to <span>RISC</span>-V (64 bit) by <span>W. J.</span> van der Laan, and some patches
were added on top of it by Andrius Štikonas himself before our current effort started.</p>
<p>At this moment in time, Mes was unable to build our bootstrappable TinyCC in
<span>RISC</span>-V, the next step in the process, and the bootstrappable TinyCC itself was
unable to build itself either. This was a very limiting point, because TinyCC
is the first “proper” C compiler in the chain.</p>
<p>When I say “proper” I mean fast and fully featured as a C compiler. In x86,
TinyCC is able to compile old versions of <span>GCC</span>. If we manage to port it to
<span>RISC</span>-V we will eventually be able to build <span>GCC</span> with it and with that the world.</p>
<p>In summary, TinyCC is a key step in the bootstrapping chain.</p>
<h3 id="problems">Problems fixed</h3>
<p>This work can be easily followed in the commits in my <span>TCC</span> fork’s
<a href="https://github.com/ekaitz-zarraga/tcc/tree/riscv-mes"><code>riscv-mes</code></a> branch, and in my Mes clone’s <a href="https://github.com/ekaitz-zarraga/mes/tree/riscv-tcc-boot"><code>riscv-tcc-boot</code></a>
branch. We are also identifying the contents of this blogpost in the git
history by adding the git tag <code>self-hosted-tcc-rv64</code> to both of my forks. We
will try to keep both for future reference.</p>
<p>In Mes the process might be a little bit harder to follow because we sent most
of the patches to Janneke and he merged them so when we were about to release
this post I continued from Janneke’s branch to avoid divergences (I had some
problems with that before). In any case, the code is there and searching by
authors (Andrius and myself) would guide you to the changes we did.</p>
<p>Many commits have a long message you can go read there, but this post was born
to summarize the most interesting changes we did, and write them in a more
digestible way. Lets see if I manage to do that.</p>
<p>The following list is not ordered in any particular way, but we hope the
selection of problems we found is interesting for you. We found some errors
more, but these are the ones we consider more relevant.</p>
<h4 id="tinycc-missing-instructions">TinyCC misses assembly instructions needed for MesLibC</h4>
<p>TinyCC is not like <span>GCC</span>, TinyCC generates binary code directly, no assembly code
in between. TinyCC has a separate assembler that doesn’t follow the path that C
code follows.</p>
<p>It works the same in all architectures, but we can take <span>RISC</span>-V as an example:</p>
<p>TinyCC has <code>riscv64-gen.c</code> which generates the binary files, but
<code>riscv64-asm.c</code> file parses assembly code and also generates binary. As you can
see, binary generation is somehow duplicated.</p>
<p>In the <span>RISC</span>-V case, the C part had support for mostly everything since my
backport, but the assembler did not support many instructions (which, by the
way are supported by the C part).</p>
<p>MesLibC’s <code>crt1.c</code> is written in assembly code. Its goal is to prepare the
<code>main</code> function and call it. For that it needs to call <code>jalr</code> instruction and
others that were not supported by TinyCC, neither upstream nor our
bootstrappable fork.</p>
<p>These changes appear in several commits because I didn’t really understood how
the TinyCC assembler worked, and some instructions need to use relocations
which I didn’t know how to add. The following commit can show how it feels to
work on this, and shares how relocations are done:</p>
<p>There you can see we started to understand things in TinyCC, but some other
changes came after this.</p>
<p>A very important not here is upstream TinyCC does not have support for these
instructions yet so we need to patch upstream TinyCC when we use it, contribute
the changes or find other kind of solutions. Each solution has its downsides
and upsides, so we need to take a decision about this later.</p>
<h4 id="tcc-assembly">TinyCC’s assembly syntax is weird</h4>
<p>Following with the previous fix, TinyCC does not support <span>GNU</span>-Assembler’s syntax
in <span>RISC</span>-V. It uses a simplified assembly syntax instead.</p>
<p>When we would do:</p>
<pre><code>sd s1, 8(a0)
</code></pre>
<p>In TinyCC’s assembly we have to do:</p>
<pre><code>sd a0, s1, 8
</code></pre>
<p>This requires changes in MesLibC, and it makes us create a separate folder for
TinyCC in MesLibC. See <code>lib/riscv64-mes-tcc/</code> and <code>lib/linux/riscv64-mes-tcc</code>
for more details.</p>
<h4 id="extended-assembly">TinyCC does not support Extended Asm in <span>RV64</span></h4>
<p>Way later in time we also found TinyCC does not support <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">Extended Asm</a>
in <span>RV64</span>. The functions that manage that are simply empty.</p>
<p>We spent some time until we realized what was going on in here for two reasons.
First, there are few cases of Extended Asm in the code we were compiling.
Second, it was failing silently.</p>
<p>Extended Asm is important because it lets you tell the compiler you are going
to touch some registers in the assembly block, so it can protect variables and
apply optimizations properly.</p>
<p>In our case, our assembly blocks were clobbering some variables that would have
been protected by the compiler if the Extended Asm support was implemented.</p>
<p>Andrius found all the places in MesLibC where Extended Asm was used and rewrote
the assembly code to keep variables safe in the cases it was needed.</p>
<p>The other option was to add Extended Asm support for TinyCC, but we would need
to add it in the Bootstrappable TinyCC and also upstream. This also means
understanding TinyCC codebase very well and making the changes without errors,
so we decided to simplify MesLibC, because that is easier to make right. We are
probably going to need to do this later on anyway, but we’ll try to delay this
as much as possible.</p>
<h4 id="main-args">MesLibC <code>main</code> function arguments are not set properly</h4>
<p>Following the previous problem with assembly, we later found input arguments of
the <code>main</code> function, that come from the command line arguments, were not
properly set by our MesLibC. Andrius also took care of that in
<a href="https://github.com/ekaitz-zarraga/mes/commit/4f4a11745d1c7ed0995e9d31c7994abfb4a60b25">4f4a1174</a> in Mes.</p>
<p>This error was easier to find than others because when we found issues with
this we already had a compiled TinyCC. So we just needed to fix simple things
around it.</p>
<h4 id="dollars">TinyCC says <code>__global_pointer$</code> is not a valid symbol</h4>
<p>This is a small issue that was a headache for a while, but it happened to be a
very simple issue.</p>
<p>In <span>RISC</span>-V there’s a symbol, <code>__global_pointer$</code>, that is used for dynamic
linking, defined in the <span>ABI</span>. But TinyCC had issues to parse code around it and
it took us some time to realize it was the dollar sign (<code>$</code>) which was causing
the issues in this point.</p>
<p>TinyCC does not process dollars in identifiers unless you specifically set a
flag (<code>-fdollars-in-identifiers</code>) when running it. In the <span>RISC</span>-V case, that
flag must be always active because if it isn’t the <code>__global_pointer$</code> can’t be processed.</p>
<p>We tried to set that flag in the command line but we had other issues in the
command line argument parsing (we found and fixed them later later) so we just
hardcoded it.</p>
<p>This issue is interesting because it’s an extremely simple problem, but its
effect appears in weird ways and it’s not always easy to know where the problem
is coming from.</p>
<h4 id="tcc-casting-issues">Bootstrappable TinyCC’s casting issues</h4>
<p>This one was a really hard one to fix.</p>
<p>When running our Bootstrappable TinyCC to build MesLibC we found this error:</p>
<pre><code>    cannot cast from/to void
</code></pre>
<p>We managed to isolate a piece of C code that was able to replicate the
problem.<sup id="fnref:reproducer"><a href="#fn:reproducer">3</a></sup></p>
<pre><code>long cast_charp_to_long (char const *i)
{
  return (long)i;
}

long cast_int_to_long (int i)
{
  return (long)i;
}

long cast_voidp_to_long (void const *i)
{
  return (long)i;
}

void main(int argc, char* argv[]){
    return;
}
</code></pre>
<p>Compiling this file raised the same issue, but then I realized I could remove
two of the functions on the top and the error didn’t happen. Adding one of
those functions back raised the error again.</p>
<p>I tried to change the order of the functions and the functions I chose to add,
and I could reproduce it: if there were two functions it failed but it could
build with only one.</p>
<p>Andrius found that the function type was not properly set in the <span>RISC</span>-V code
generation and its default value was <code>void</code>, so it only failed when it compiled
the second function.</p>
<p>Knowing that, we could take other architectures as a reference to fix this, and
so we did.</p>
<p>See <a href="https://github.com/ekaitz-zarraga/tcc/commit/6fbd17852aa11a2d0bc047183efaca4ff57ab80c">6fbd1785</a>.</p>
<h4 id="long-double">Bootstrappable TinyCC’s <code>long double</code> support was missing</h4>
<p>When I backported the <span>RISC</span>-V support to our Bootstrappable TinyCC I missed the
<code>long double</code> support and I didn’t realize that because I never tested large
programs with it.</p>
<p>The C standard doesn’t define a size for <code>long double</code> (it just says it has to
be at least as long as the <code>double</code>), but its size is normally set to 16 bytes.
All this is weird in <span>RV64</span>, because it doesn’t have 16 byte size registers. It
needs some extra support.</p>
<p>Before we fixed this, the following code:</p>
<pre><code>long double f(int a){
    return  a;
}
</code></pre>
<p>Failed with:</p>
<pre><code>    riscv64-gen.c:449 (`assert(size == 4 || size == 8)`)
</code></pre>
<p>Because it was only expecting to use <code>double</code>s (8 bytes) or <code>float</code>s (4 bytes).</p>
<p>In upstream TinyCC there were some commits that added <code>long double</code> support
using, and I quote, a <em>mega hack</em>, so I just copied that support to our
Bootstrappable TinyCC.</p>
<p>See <a href="https://github.com/ekaitz-zarraga/tcc/commit/a7f3da33456b4354e0cc79bb1e3f4c665937395b">a7f3da33456b</a>.</p>
<p>After this commit, some extra problems appeared with some missing symbols. But
these errors were link-time problems, because TinyCC had the floating point
helper functions needed for <span>RISC</span>-V defined in <code>lib/lib-arm64.c</code>, because they
were reusing aarch64 code for them.</p>
<p>After this, we also compile and link <code>lib-arm64.c</code> and we have <code>long double</code>
support.</p>
<h4 id="mescc-struct-init">MesCC struct initialization issues</h4>
<p>This one was a lot of fun. Our Bootstrappable TinyCC exploded with random
issues: segfaults, weird branch decisions…</p>
<p>After tons of debugging Andrius found some values in <code>struct</code>s were not set
properly. As we don’t really know TinyCC’s codebase really well, that was hard
to follow and we couldn’t really know where was the value coming from.</p>
<p>Andrius finally realized some <code>struct</code>s were not initialized properly. Consider
this example:</p>
<pre><code>typedef struct {
    int one;
    int two;
} Thing;

Thing a = {0};
</code></pre>
<p>That’s supposed to initialize <em>all</em> fields in the <code>Thing</code> <code>struct</code> to <code>0</code>,
according to the C standard<sup id="fnref:cppref"><a href="#fn:cppref">4</a></sup>.</p>
<p>As a first solution we set struct fields manually to <code>0</code>, to make sure they
were initialized properly. See <a href="https://github.com/ekaitz-zarraga/tcc/commit/29ac0f40a7afba6a2d055df23a8ee2ee2098529e">29ac0f40a7afb</a></p>
<p>After some debugging we found that the fields that were not explicitly set were
initialized to <code>22</code>. So I decided to go to MesCC and see if the struct
initialization was broken.</p>
<p>This was my first dive in MesCC’s code, and I have to say it’s really easy to
follow. It took me some time to read through it because I’m not that used to
<code>match</code>, but I managed to find the struct initialization code.</p>
<p>What I found in MesCC is there was a <code>22</code> hardcoded in the struct
initialization code, probably coming from some debug code that never was
removed. As no part of the x86 bootstrapping used that kind of initializations,
or nothing relied on them, the error went unnoticed.</p>
<p>I set that to <code>0</code>, as it should be, and continued with our life.</p>
<h4 id="size-problems">MesCC vs TinyCC size problems</h4>
<p>The C standard does not set a size for integers. It only sets relative sizes:
<code>short</code> has to be shorter or equal to <code>int</code>, <code>int</code> has to be shorter or equal
to a <code>long</code>, and so on. If you platform wants, all the integers, including the
<code>char</code>s can have 8 bits, and that’s ok for the C standard.</p>
<p>TinyCC’s <span>RISC</span>-V backed was written under the assumption that <code>int</code> is 32 bit
wide. You can see this happening in <code>riscv64-gen.c</code>, for example, here:</p>
<pre><code>    EI(0x13, 0, rr, rr, (int)pi &lt;&lt; 20 &gt;&gt; 20);   // addi RR, RR, lo(up(fc))
</code></pre>
<p>The bit shifting there is done to clear the upper 20 bits of the pi variable.
This code’s behavior might be different from one platform to another. Taking
the example before, of that possible platform that only has 8 bit integers,
this code would send a <code>0</code> instead of the lower 12 bits of <code>pi</code>.</p>
<p>In our case, we had MesCC using the whole register width, 64bits, for temporary
values so the lowest <code>44</code> bits were left and the next assertion that checked
the immediate was less than 12 bits didn’t pass.</p>
<p>This is a huge problem, as most of the code in the <span>RISC</span>-V generation is written
using this style.</p>
<p>There are other ways to do the same thing (<code>pi &amp; 0xFFF</code> maybe?) in a more
portable way, but we don’t know why upstream TinyCC decided to do it this way.
Probably they did because <span>GCC</span> (and TinyCC itself) use 32 bit integers, but they
didn’t handle other possible cases, like the one we had here with MesCC.</p>
<p>In any case, this made us rethink MesCC, dig on how are its integers defined,
how to change this to be compatible with TinyCC and so on, but I finally
decided to add casts in the middle to make sure all this was compiled as expected.</p>
<p>It was a good reason to make us re-think MesCC’s integers, but it took a very
long time to deal with this, that could be better used in something else. Now,
we all became paranoids about integers and we still think some extra errors
will arise from them in the future. Integers are hard.</p>
<h4 id="mes-signed-shift">MesCC add support for signed shifting</h4>
<p>Integers were in our minds for long, as described in the previous block, but I
didn’t talk about signedness in that one.</p>
<p>Following one of the crazy errors we had in TinyCC, I somehow realized (I don’t
remember how!) that we were missing signed shifting support in MesCC. I think
that I found this while doing some research of the code MesCC was outputting
when I spotted some bit shifts done using unsigned instructions for signed
values and I started digging in MesCC to find out why. I finally realized that
there was no support for that and the shift operation wasn’t selected
depending on the signedness of the value being shifted.</p>
<p>Let’s see this with an example:</p>
<pre><code>signed char a = 0xF0;
unsigned char b = 0xF0;

// What is this?                (Answer: 0xFF =&gt; 255)
a &gt;&gt; 4;

// And this?                    (Answer: 0x0F =&gt; 15)
b &gt;&gt; 4;
</code></pre>
<p>In the example you can see the shifting operation does not work the same way if
the value is signed or not. If you always use the unsigned version of the <code>&gt;&gt;</code>
operation, you don’t have the results you expected. Signs are also hard.</p>
<p>In this case, like in many others, the fix was easier than realizing what was
going wrong. I just added support for the signed shifting operation, not only
for <span>RISC</span>-V but for all architectures, and I added the correct signedness check
to the shifting operation to select the correct instruction. The patch (see
<a href="https://github.com/ekaitz-zarraga/mes/commit/88f24ea8661dd279c2a919f8fbd5f601bb2509ae">88f24ea8</a> in Mes) is very clean and easy to read, because
MesCC’s codebase is really well ordered.</p>
<blockquote>
<p><span>EDIT</span>: Some person in the web noted I called the <em>bit-shift</em> operations
<em>rotation</em> operations. I normally use both words interchangeably but it is
true they don’t mean the exact same thing. A shift is when the values are
lost, and a rotation when they come from the other side of the register. I
edited the article to use the correct word.</p>
</blockquote>
<h4 id="broken-case">MesCC switch/case falls-back to default case</h4>
<p>In the early bootstrap runs, our Bootstrappable TinyCC it did weird things.
After many debugging sessions we realized the <code>switch</code> statements in
<code>riscv64-gen.c</code>, more specifically in <code>gen_opil</code>, were broken. The fall-backs
in the <code>switch</code> were automatically directed to the <code>default</code> case. Weird!</p>
<p>MesCC has many tests so I read all that were related with the <code>switch</code>
statements and the ones that handled the fall-backs were all falling-back to
the <code>default</code> case, so our weird behavior wasn’t tested.</p>
<p>I added the tests for our case and read the disassemble of simple examples when
I realized the problem.</p>
<p>Each of the <code>case</code> blocks has two parts: the clause that checks if the value
of the expression is the one of the case, and the body of the case itself.</p>
<p>The <code>switch</code> statement generation was doing some magic to deal with <code>case</code>
blocks, but it was failing to deal with complex fall-through schemes because
the clause of the target <code>case</code> block was always run, making the code fall to
the <code>default</code> case, as the clause was always false because the one that matched
was the one that made the fall-back.</p>
<p>There were some problems to fix this, as NyaCC (MesCC’s C parser) returns
<code>case</code> blocks as nested when they don’t have a <code>break</code> statement:</p>
<pre><code>(case testA
  (case testB
    (case testC BODY)))
</code></pre>
<p>Instead of doing this, I decided to flatten the <code>case</code> blocks with empty
bodies. This way we can deal with the structure in a simpler way.</p>
<pre><code>((case testA (expr-stmt))
 (case testB (expr-stmt))
 (case testC BODY))
</code></pre>
<p>Once this is done, I expanded each <code>case</code> block to a jump that jumps over the
clause, the clause and then its body. Doing this, the fall-back doesn’t
re-evaluate the clause, as it doesn’t need to. The generated code looks like
this in pseudocode:</p>
<pre><code>    ;; This doesn&#39;t have the jump because it&#39;s the first
CASE1:
    testA
CASE1_BODY:
    ...

    goto CASE2_BODY
CASE2:
    testB
CASE2_BODY:
    ...

    goto CASE3_BODY
CASE3:
    testB
CASE3_BODY:
    ...
</code></pre>
<p>If one of the <code>case</code>s has a <code>break</code>, it’s treated as part of its body, and it
will end the execution of the <code>switch</code> statement normally, no fall-back.</p>
<p>This results in a simpler <code>case</code> block control. The previous approach dealt
with nested <code>case</code> blocks and tried to be clever about them, but
unsuccessfully. The best thing about this commit is most of the cleverness was
simply removed with a simple solution (flatten all the things!).</p>
<p>It wasn’t that easy to implement, but I first built a simple prototype and
Janneke’s scheme magic made my approach usable in production.</p>
<p>All this is added in Mes’s codebase in several commits, as we needed some
iterations to make it right. <a href="https://github.com/ekaitz-zarraga/mes/commit/22cbf823582e3699b6a21ee0cf74c2dbf0a6a4e9">22cbf823582</a> has the base of this commit,
but there were some iterations more in Mes.</p>
<h4 id="got">Boostrappable TinyCC problems with <span>GOT</span></h4>
<p>The Global Offset Table is a table that helps with relocatable binaries. Our
Bootstrappable TinyCC segfaulted because it was generating an empty <span>GOT</span>.</p>
<p>Andrius debugged upstream TinyCC alongside ours and realized there was a
missing check in an <code>if</code> statement. He fixed it in
<a href="https://github.com/ekaitz-zarraga/tcc/commit/f636cf3d4839d1ca3f5af9c0ad9aef43a4bfccd9">f636cf3d4839d1ca</a>.</p>
<p>The problem with this kind of errors is TinyCC’s codebase is really hard to
read. It’s a very small compiler but it’s not obvious to see how things are
done on it, so we had to spend many hours in debugging sessions that went
nowhere. If we had a compiler that is easier to read and change, it would be
way simpler to fix and we would have had a better experience with it.</p>
<h4 id="wrong-conditionals">Bootstrappable TinyCC generates wrong assembly in conditionals</h4>
<p>We spent a long time debugging a bug I introduced during the backport when I
tried to undo some optimization upstream TinyCC applied to comparison operations.</p>
<p>Consider the following code:</p>
<pre><code>if ( x &lt; 8 )
    whatever();
else
    whatever_else();
</code></pre>
<p>Our Bootstrappable TinyCC was unable to compile this code correctly, instead,
it outputted a code that always took the same branch, regardless of the value
in <code>x</code>.</p>
<p>In TinyCC, a conditional like <code>if (x &lt; CONSTANT)</code> has a special treatment, and
it’s converted to something like this pseudoassembly:</p>
<pre><code>load x to a0
load CONSTANT to a1
set a0 if less than a1
branch if a0 not equal 0     ; Meaning it&#39;s `set`
</code></pre>
<p>This behaviour uses the <code>a0</code> register as a flag, emulating what other CPUs
use for comparisons. <span>RISC</span>-V doesn’t need that, but it’s still done here
probably for compatibility with other architectures. In <span>RISC</span>-V it could look
like this:</p>
<pre><code>load x to a0
load CONSTANT to a1
branch if a0 less than a1
</code></pre>
<p>You can easily see the <code>branch</code> <span>“</span>instruction” does a different comparison in
one case versus the other. In the one in the top it checks if <code>a0</code> is set,
and in the other checks if <code>a0</code> is smaller than <code>a1</code>.</p>
<p>TinyCC handles this case in a very clever way (maybe too clever?). When they
emit the <code>set a0 if less than a1</code> instruction they replace the current
comparison operation with <code>not equal</code> and they remove the <code>CONSTANT</code> and
replace it with a <code>0</code>. That way, when the <code>branch</code> instruction is generated,
they insert the correct clause.</p>
<p>In my code I forgot to replace the comparison operator so the branch checked
<code>if a0 is less than 0</code> and it was always false, as the <code>set</code> operation writes
a <code>0</code> or a <code>1</code> and none of them is less than <code>0</code>.</p>
<p>The commit <a href="https://github.com/ekaitz-zarraga/tcc/commit/5a0ef8d0628f719ebb01c952797a86a14051228c">5a0ef8d0628f719</a> explains this in a more technical way,
using actual <span>RISC</span>-V instructions.</p>
<p>This was also a hard to fix, because TinyCC’s variable names (<code>vtop-&gt;c.i</code>) are
really weird and they are used for many different purposes.</p>
<h4 id="varargs">Support for variable length arguments</h4>
<p>In C you can define functions with variable argument length. In <span>RISC</span>-V, those
arguments are sent using registers while in other architectures are sent using
the stack. This means the <span>RISC</span>-V case is a little bit more complex to deal
with, and needs special treatment.</p>
<p>Andrius realized in our Bootsrappable TinyCC we had issues with variable length
arguments, specially in the most famous function that uses them: <code>printf</code>. He
also found that the problem came from the arguments not being properly set and
found the problem.</p>
<p>Reading upstream TinyCC we found they use a really weird system for the defines
that deal with this. They have a header file, <code>include/tccdefs.h</code>, which is
included in the codebase, but also processed by a tool that generates strings
that are later injected at execution time in TinyCC.</p>
<p>This was too much for us so we just extracted the simplest variable arguments
definitions for <span>RISC</span>-V and introduced that in MesLibC and our Bootstrappable TinyCC.</p>
<h5>Extra: files generated with no permissions</h5>
<p>The bootstrappable TinyCC built using MesCC generated files with no permissions
and Andrius found that this problem came from the variable length argument
support definitions. So he fixed that, too<sup id="fnref:stikonas"><a href="#fn:stikonas">5</a></sup>.</p>
<p>The macro that defined <code>va_start</code> was broken pointer arithmetic. At the
beginning he thought it was related with MesCC’s internals but he tested in <span>GCC</span>
later and realized the problem was in the macro definition. That’s why
currently the commit says “workaround” in the name, but it’s more than a
workaround: it’s a proper fix. We are rewording that, but that would happen
after we release this post.</p>
<h4 id="int8">MesLibC use <code>signed char</code> for <code>int8_t</code></h4>
<p>We already had a running Bootstrappable TinyCC compiled using MesCC when we
stumbled upon this issue. Somehow, when assembling:</p>
<pre><code>addi a0, a0, 9
</code></pre>
<p>The code was trying to read <code>9</code> as a register name, and failed to do it (of
course). It was weird to realize that the following code (in <code>riscv64-asm.c</code>)
was always using the true branch in the <code>if</code> statement, even if
<code>asm_parse_regvar</code> returned <code>-1</code>:</p>
<pre><code>int8_t reg;
...
if ((reg = asm_parse_regvar(tok)) != -1) {
    ...
} else ...
</code></pre>
<p>I disassembled and saw something like this:</p>
<pre><code>call asm_parse_regvar   ;; Returns value in a0
reg = a0
a0 = a0 + 1
branch if a0 equals 0
</code></pre>
<p>This looks ok, it does some magic with the <code>-1</code> but it makes sense anyway. The
problem is that it didn’t branch because <code>a0</code> was <code>256</code> even when
<code>asm_parse_regvar</code> returned <code>-1</code>.</p>
<p>During some of the <code>int</code> related problems someone told me in the Fediverse that
<code>char</code><span>‘</span>s default signedness is not defined in the C standard. I read MesLibC
and, exactly: <code>int8_t</code> was defined as an alias to <code>char</code>.</p>
<p>In <span>RISC</span>-V <code>char</code> is by default <code>unsigned</code> (don’t ask me why) but we are used to
x86 where it’s <code>signed</code> by default. Only saying <code>char</code> is not portable.</p>
<p>Replacing:</p>
<pre><code>typedef char int8_t;
</code></pre>
<p>With:</p>
<pre><code>typedef signed char int8_t;
</code></pre>
<p>Fixed the issue.</p>
<p>From this you can learn several things:</p>
<ol>
<li>Don’t assume <code>char</code><span>‘</span>s signedness in C</li>
<li>If you design a programming language, be consistent with your decisions. In
   C <code>int</code> is always <code>signed int</code>, but <code>char</code><span>‘</span>s don’t act like that. Don’t do this.</li>
</ol>
<h4 id="jmp">MesLibC Implement <code>setjmp</code> and <code>longjmp</code></h4>
<p>Those that are not that versed in C, as I was before we found this issue, won’t
know about <code>setjmp</code> and <code>longjmp</code> but they are, simplifying a lot, like a
<code>goto</code> you can use in any part of the code. <code>setjmp</code> needs a buffer and it
stores the state of the program on it, <code>longjmp</code> sets the status of the program
to the values on the buffer, so it jumps to the position stored in <code>setjmp</code>.</p>
<p>Both functions are part of the C standard library and they need specific
support for each architecture because they need to know which registers are
considered part of the state of the program. They need to know how to store the
program counter, the return address, and so on, and how to restore them.</p>
<p>In their simplest form they are a set of stores in the case of the <code>setjmp</code> and
a set of loads in the case of <code>longjmp</code>.</p>
<p>In <span>RISC</span>-V they only need to store the <code>s*</code> registers, as they are the ones that
are not treated as temporary. It’s simple, but it needs to be done, which
wasn’t in neither for <span>GCC</span> nor for <span>RISC</span>-V in MesLibC.</p>
<p>Andrius is not convinced with our commit in here, and I agree with his
concerns. We added the full <code>setjmp</code> and <code>longjmp</code> implementations directly
<del>stolen from</del> inspired in the ones in Musl<sup id="fnref:stolen"><a href="#fn:stolen">6</a></sup> but it has also
floating point register support, using instructions that are not implemented in
TinyCC yet. This is going to be a problem in the future because later
iterations will try to execute instructions they don’t actually understand.</p>
<p>There are two (or three) possible solutions here. The first is to remove the
floating point instructions for now (another flavor for this solution is to
hide them under an <code>#ifdef</code>). The second is to implement the floating point
instructions in TinyCC’s <span>RISC</span>-V assembler, which sounds great but forces us to
upstream the changes, and that process may take long and we’d need to patch it
in our bootstrapping scripts until it happens.</p>
<p>We just added the <code>#ifdef</code>s because our code is full of them anyway and sent it
to Mes: <a href="https://github.com/ekaitz-zarraga/mes/commit/0e2c55697df285250c8a24442f169bc52d729c31">0e2c5569</a>.</p>
<h4 id="more">More</h4>
<p>Those are mostly the coolest errors we needed to deal with but we stumbled upon
a lot of errors more.</p>
<p>Before this effort started Andrius added support for 64 bit instructions in Mes
and fixed some issues 64bit architectures had in M2.</p>
<p>I found a <a href="https://issues.guix.gnu.org/65225">bug in Guix shell</a> (it’s still
open) and had to fix some <span>ELF</span> headers in MesCC generated files because objdump
and gdb refused to work on them.</p>
<p>Andrius also found issues with weak symbols in MesLibC that were triggered
because <span>TCC</span> didn’t have support for them, thankfully upstream <span>TCC</span> had that
issue fixed and we just cherry-picked for the win.</p>
<p>He even had the energy to test all this in real <span>RISC</span>-V we specifically acquired
for this task.</p>
<p>There are many more things to tell, but this is already getting too long and if
I continue writing we’ll probably end up fixing some stuff more.</p>
<p>In the end, a project like this is like hitting your head against a wall until
one of them breaks. Sometimes it feels like the head did, but it’s all good.</p>
<h4 id="reproducing">Reproducing what we did</h4>
<p>All we did means nothing if you can’t reproduce it. We provide two ways to
reproduce this process: live-bootstrap and Guix.</p>
<p>Both provide a similar thing but there are some differences from the
high-level that is worth mention now.</p>
<p>Comparing with <code>live-bootstrap</code>, using Guix helps because it reuses the
previous steps if they didn’t change. This results in shorter waits once Mes is
sorted out.</p>
<p>On the other hand, I’ve have had issues with the failed builds in Guix (in
emulated systems). It was hard to jump inside the build container and play
around inside so the development cycle suffered a lot. In <code>live-bootstrap</code>, if
you are good with <code>bwrap</code> you can jump and tweak things with no issues.</p>
<p>For those who enjoy digging in the code and trying to follow the process I
recommend following <code>live-bootstrap</code><span>‘</span>s scripts. The directory structure is a
little bit confusing but the scripts are very plain and linear. The ones in the
Guix process come from previous bootstrap efforts and they are designed to do
many things automagically, that makes them a hard to follow.</p>
<h5 id="live-bootstrap">Using live-bootstrap</h5>
<p>Andrius is part of the <code>live-bootstrap</code> effort and he’s doing all the scripting
there to keep the process reproducible.</p>
<p><a href="https://github.com/fosslinux/live-bootstrap">Live-bootstrap</a> is…</p>
<blockquote>
<p>An attempt to provide a reproducible, automatic, complete end-to-end
bootstrap from a minimal number of binary seeds to a supported fully
functioning operating system.</p>
</blockquote>
<p>That’s the official description of the project. From a more practical
perspective, it’s a set of scripts that build the whole operating system from
scratch, depending on few binary seeds.</p>
<p>That’s not very different to what Guix provides from a bootstrapping
perspective. Guix is “just” an environment where you can run “scripts” (the
packages define how they are built) in a reproducible way. Of course, Guix is
way more than that, but if we focus on what we are doing right now it acts like
the exact same thing.</p>
<blockquote>
<p><span>NOTE</span>: <code>live-bootstrap</code><span>‘</span>s project description is a little bit outdated. If you
read the comparison with Guix, what you’d read is old information. If you
want to read a more up-to-date information about Guix’s bootstrapping process
I suggest you to read this page of Guix manual:
<a href="https://guix.gnu.org/manual/devel/en/html_node/Full_002dSource-Bootstrap.html">https://guix.gnu.org/manual/devel/en/html_node/Full_002dSource-Bootstrap.html</a></p>
</blockquote>
<p>Being very different projects, in a practical level, the main difference
between them is <code>live-bootstrap</code> is probably easier for you to test if you are
working on any <span>GNU</span>/Linux distribution<sup id="fnref:in-guix"><a href="#fn:in-guix">7</a></sup>.</p>
<p>If you want to reproduce this exact point in time you only need to use my fork
of <a href="https://github.com/ekaitz-zarraga/live-bootstrap/">live-bootstrap</a>, branch
<code>riscv-tcc-boot</code>. I also made a tag on it, <code>self-hosted-tcc-rv64</code>, to make it
easier to remember when was this post released. Andrius made all the magic to
set that process to take all the inputs from Mes and TinyCC from the correct tag.</p>
<p>Clone the repository, set up the dependencies and run this (if you are not in a
<span>RISC</span>-V host you need to configure Qemu and binfmt):</p>
<pre><code> ./rootfs.py --bwrap --arch riscv64 --preserve
</code></pre>
<p>That should, after a long time, reach a point where there’s a properly compiled
bootstrappable TinyCC.</p>
<h4 id="guix">Using Guix for a reproducible environment</h4>
<p>I made a Guix recipe that can replicate the whole process, too. It took me long
time to make it work but it finally does.</p>
<p>From my <span>TCC</span> fork reproducing this should be easy for the people versed in Guix.
There’s a <code>guix</code> folder with some files, (most of them broken, not gonna lie)
but there are two you should pay attention to:</p>
<ul>
<li>
<p><code>channels.scm</code> stores the state of my Guix checkout so you can reproduce it
  in the future using <code>guix time-machine</code>. At the moment it doesn’t feel
  necessary but if something fails when you try it, please refer to that.</p>
</li>
<li>
<p><code>commencement.scm</code> is an edited copy of the Guix bootstrapping process,
  directly obtained from <code>gnu/packages/commencement.scm</code> from Guix’s codebase.
  I patched this to make it work for <span>RISC</span>-V, using some more modern commits in
  the dependencies.</p>
</li>
</ul>
<p>In order to reproduce all our work in Guix you just need to build <code>tcc-boot0</code>
package from the <code>commencement.scm</code> file using <code>riscv64-linux</code> as your
<code>--system</code>. I’m a nice guy so I just added a command there you can use for
this, just run:</p>
<pre><code>./tcc-boot0-from-source.sh
</code></pre>
<p>And that should build the whole thing. It takes hours, you have been warned.</p>
<p>Also it adds <code>--no-grafts</code> (thanks Efraim), because if you keep the grafts it
compiles the world from scratch (curl, x11… not good).</p>
<p>If you just want to build <code>mes-boot</code> as an intermediate step, I also made a
file for that:</p>
<pre><code>./mes-boot-from-source.sh
</code></pre>
<p>The both scripts will load variables from the <code>commencement.scm</code> module
provided. The module is not complex if you are used to Guix, but it calls
some complex shell scripts in both Mes and TinyCC to build. Those contain all
the magic.</p>
<h3 id="conclusions">Conclusions</h3>
<p>Of course, the problems we fixed now look easy and simple to fix. This blog
post doesn’t really do justice to the countless debugging hours and all the
nights we, Andrius and I, spent thinking about where could the issues be
coming from.</p>
<p>The debugging setup wasn’t as good as you might imagine. The early steps of the
bootstrap don’t have all the debug symbols as a “normal” userspace program
would. In many cases, function names were all we had.</p>
<p>I have thank my colleague Andrius here because he did a really good debugging
job, and he provided me with small reproducers that I could finally fix. Most
of the times he made the assist and I scored the goal.</p>
<p>He also did a great job with the testing which I couldn’t do because I was
struggling with Guix from the early days, trying to make the compilers find the
header files and libraries.</p>
<p>In the emotional part it is also a great improvement to have someone to rely
on. Andrius, Janneke and I had a good teamwork and we supported each other when
our faith started to crumble. And believe, it does crumble when a new bug
appears after you fixed one that you needed a week for. There were times this
summer I thought we would never reach this point.</p>
<p>It’s also worth mention here that the bootstrapping process is extremely slow:
it takes hours. This kills the responsiveness and makes testing way harder than
it should be. Not to mention that we are working on a foreign architecture,
which has it’s own problems too.</p>
<p>If you have to take some lesson from something like this, here you have a
suggestion list:</p>
<ul>
<li>The simplest error can take ages to debug if your code is crazy enough.</li>
<li>Don’t be clever. It sets a very high standard for your future self and people
  who will read your code in the future.</li>
<li>I guess we can summarize the previous two points in one: If we could remove
  TinyCC from the chain, we would. It’s a source of errors and it’s hard to
  debug. The codebase is really hard to read for no apparent reason.</li>
<li>When build times are long, small reproducers help.</li>
<li>Add tests for each new case you find.</li>
<li>Don’t trust, disassemble and debug.</li>
<li>Be careful with C and standards and undefined behavior.</li>
<li>Integers are hard. Signedness makes them harder.</li>
<li>Being surrounded by the correct people makes your life easier.</li>
</ul>
<p>Also, as a personal note I noticed I’m a better programmer since the previous
post in the this series. I feel way more comfortable with complex reasoning and
even writing new programs in other languages, even if I spent almost no time
coding anything from scratch. It’s like dealing with this kind of issues about
the internals give you some level of awareness that is useful in a more general
way than it looks. Crazy stuff.</p>
<p>If you can, try to play with the internals of things from time to time. It
helps. At least it helped me.</p>
<h3 id="next">What is next?</h3>
<p>Now we have a fully featured Bootstrappable TinyCC we need to decide what to do next.</p>
<p>On the short term, all this has to be released in the original projects: Mes,
M2, and so on. That’s the easy part, as everything has proved to be ready.</p>
<p>On the mid term, it’s not very clear what to do first. We suspect we’ll need
upstream TinyCC for the next steps, because we many different tools to
continue with the bootstrapping chain, and the bootstrappable TinyCC might not
be enough to build them. On the other hand, when we go for a standard library
we’ll miss the extended assembly support we already mentioned. There’s some
uncertainty in the next step.</p>
<p>The long-term is pretty much clear though, the goal is <span>GCC</span>. First <span>GCC</span> for C and
then for C++ to make it able build <span>GCC</span> 7.5 which should enable the rest of the
chain pretty easily (famous last words). I anticipate we are going to have
problems with <span>GCC</span> (I know this because I left them there last time) so we’ll
need to fix those, too. Once that is done, we would use <span>GCC</span> to compile more
recent versions of <span>GCC</span> until we compile the world.</p>
<p>That’s more or less the description of what we will do in the next months.</p>
<p>And this is pretty much it. I hope you learned something new about C, the
Bootstrapping process or at least had a good time reading this wall of text.</p>
<p>We’ll try to work less for the next one, but we can’t promise that. 😉</p>
<p>Take care.</p>
<hr/>
<!--

MANY OF THIS ARE REALLY HARD TO REASON ABOUT!!!!
WITH THIS WE START PASSING MANY MORE TESTS IN MESCC AND ALSO ADDED SOME EXTRA
TESTS THAT CHECK COMPLEX BEHAVIOR HERE AND THERE

- `int`s are 64 bit in MesCC and TinyCC is written like they are 32 bit.

- TinyCC's assembly for RISC-V is not complete and we need some of that in
  meslibc. We implemented the missing instructions (jal, jalr, lla and some
  pseudoinstructions).

- TinyCC's assembler for RISC-V uses a simplified syntax, so we need to rewrite
  our meslibc according to that.

- RISC-V uses a `__global_pointer$` symbol, but TinyCC does not allow dollars
  in identifiers by default. The `-fdollars-in-identifiers` flag exploded when
  used so we hardcoded the flag to true.

- We backported the `long double` support from TinyCC's `mob` branch.
    - And large constant generation.

- Fixed some weird casting issues in TinyCC (see Fix casting issues (missing
  func_vt in riscvgen.c)

- MesCC produced binaries that were impossible to debug with GDB and OBJDUMP
  complained about them. We fixed those too (some archs are missing)

- MesCC's struct initialization to zeroes like `Whatever a = {0};` initialized
  everything to `22` and is now working as expected.

- `switch/case` statements in MesCC fallback always to default because they
  check the fallback clause and then jump to default.

- Mes had some incompatibilities with Guile that prevented us from running the
  code fast. Fixed those.

- Added support for RISC-V instruction formats in MesCC
  (https://git.savannah.gnu.org/cgit/mes.git/commit/?h=wip-riscv&id=e42cf58d14520a5360d7d527d1c2c18c0a498c28)

- Added support for signed rotation in MesCC. (all arches affected)

- And also fixed some M2 things that allow all this 64 bit support happen in
  MesCC, which didn't have 64 bit support before. Stikonas?

- Stikonas also fixed problems in M2:
    https://github.com/oriansj/M2-Planet/commit/85dd953b70c5f607769016bbf2a0aa3de7e41b6c

- Fix Bootstrappable TinyCC's GOT (global offset table). It was just a broken
  condition in an if (stikonas dealt with that)

- Meslibc again! Tinycc does not support [extended
  asm](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html) in RV64 but
  stikonas fixes it replacing the extended asm by abi-compatible handwired asm.
  The good fix would be to implement it, but upstream doesn't have it either...

- `int size = 0; if (size < 8) size = 8;` does not work because TCC generated
  wrong assembly and it jumps over the true branch even if it checks the
  condition is ok. (reproducer in `C_TESTS/if.c`)

- Variable length arguments were broken in Bootstrappable TCC. Upstream TCC
  does some string magic to support them (c2str) where the same header file is
  used twice: one in the binary and one in runtime. That functionality was lost
  in the ~translation~ backport. We had to push some defines to Meslibc that
  support that.

- Meslibc had `typedef char int8_t` in `stdint.h` but that's not reliable,
  because the C standard doesn't define the signedness of the `char`. In RISC-V
  the signedness of the char is `unsigned` by default, so we have to be
  explicit and say `signed char`, to avoid issues.

- Remove some 0bXXXX literals I introduced in the assembler to simplify
  things... They happen not to be standard C but a GCC extension.

- Add a setjmp and longjmp implementation to meslibc that also support tinycc
  assembler syntax. (copy from musl but with our syntax)
-->


  </div><!-- /.entry-content -->
</section>
      </div></div>
  </body>
</html>
