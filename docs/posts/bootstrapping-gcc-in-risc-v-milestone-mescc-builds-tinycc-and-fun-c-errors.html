<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ekaitz.elenq.tech/bootstrapGcc8.html">Original</a>
    <h1>Bootstrapping GCC in RISC-V: Milestone: MesCC builds TinyCC and fun C errors</h1>
    
    <div id="readability-page-1" class="page"><div>
        
<section id="content">
  <header>
    <h2>
      <a href="https://ekaitz.elenq.tech/bootstrapGcc8.html" rel="bookmark" title="Permalink to Milestone â€” MesCC builds TinyCC and fun C errors forÂ everyone">Milestone â€” MesCC builds TinyCC and fun C errors forÂ everyone</a></h2>
 


  <!-- /.post-info -->

  <blockquote>
    <p>
        From the series:
        <a href="https://ekaitz.elenq.tech/tag/bootstrapping-gcc-in-risc-v.html">Bootstrapping GCC in RISC-V</a>
    </p>
  </blockquote>
  </header>


  <div>
    <p>Itâ€™s been a while since the latest technical update in the project and I am
fully aware that you were missing it so itâ€™s time to recap with a really coolÂ announcement:</p>
<p><span>
<strong>We finally made a self-hosted Bootstrappable TinyCC in <span>RISC</span>-V</strong>
</span></p>
<p>Most of you probably remember I <a href="https://ekaitz.elenq.tech/bootstrapGcc6.html">already backported</a> the
Bootstrappable TinyCC compiler, but I didnâ€™t test it in a proper environment.
Now, we can confidently say it is able to compile itself, a â€œlargeâ€ program
that makes use of more complex C features than I did in theÂ tests.</p>
<p>All this work was done by Andrius Å tikonas and myself. Janneke helped us a lot
with Mes related parts, too. The work this time was pretty hard, honestly. Most
of the things we did here are not obvious, even for CÂ programmers.</p>
<p>Iâ€™m not used to this kind of quirks of the C language. Most of them are really
specific, related with the standards and many others are just things were
missing. I hope the ones I chose to discuss here help you understand your
computing better, as they did toÂ me.</p>
<p>This is going to be veery long post, so take a ToC to help youÂ out:</p>
<ol>
<li><a href="#context">Context</a><ol>
<li><a href="#why-important">Why is thisÂ important?</a></li>
</ol>
</li>
<li><a href="#problems">Problems fixed</a><ol>
<li><a href="#tinycc-missing-instructions">TinyCC misses assembly instructions needed forÂ MesLibC</a></li>
<li><a href="#tcc-assembly">TinyCCâ€™s assembly syntax isÂ weird</a></li>
<li><a href="#extended-assembly">TinyCC does not support Extended Asm in <span>RV64</span></a></li>
<li><a href="#main-args">MesLibC <code>main</code> function arguments are not setÂ properly</a></li>
<li><a href="#dollars">TinyCC says <code>__global_pointer$</code> is not a validÂ symbol</a></li>
<li><a href="#tcc-casting-issues">Bootstrappable TinyCCâ€™s castingÂ issues</a></li>
<li><a href="#long-double">Bootstrappable TinyCCâ€™s <code>long double</code> support wasÂ missing</a></li>
<li><a href="#mescc-struct-init">MesCC struct initializationÂ issues</a></li>
<li><a href="#size-problems">MesCC vs TinyCC sizeÂ problems</a></li>
<li><a href="#mes-signed-shift">MesCC add support for signed shiftÂ operation</a></li>
<li><a href="#broken-case">MesCC switch/case falls-back to defaultÂ case</a></li>
<li><a href="#got">Boostrappable TinyCC problems with <span>GOT</span></a></li>
<li><a href="#wrong-conditionals">Bootstrappable TinyCC generates wrong assembly inÂ conditionals</a></li>
<li><a href="#varargs">Support for variable lengthÂ arguments</a></li>
<li><a href="#int8">MesLibC use <code>signed char</code> for <code>int8_t</code></a></li>
<li><a href="#jmp">MesLibC Implement <code>setjmp</code> and <code>longjmp</code></a></li>
<li><a href="#more">More</a></li>
</ol>
</li>
<li><a href="#reproducing">Reproducing what we did</a><ol>
<li><a href="#live-bootstrap">UsingÂ live-bootstrap</a></li>
<li><a href="#guix">UsingÂ Guix</a></li>
</ol>
</li>
<li><a href="#conclusions">Conclusions</a></li>
<li><a href="#next">What isÂ next?</a></li>
</ol>
<h3 id="context">Context</h3>
<p>You have many blogposts in the series to find the some context about the
project, and even a <span>FOSDEM</span> talk about it, but they all give a very broad
explanation, so letâ€™s focus on what we are doing rightÂ now.</p>
<p>Here we have Mes, a Scheme interpreter, that runs MesCC, a C compiler, that is
compiling our simplified fork of TinyCC, letâ€™s call that Bootstrappable TinyCC.
That Bootstrappable TinyCC compiler then tries to compile its own code. It
compiles itâ€™s own code because itâ€™s goal is to add more flags in each
compilation, so it has more features in each round<sup id="fnref:rounds"><a href="#fn:rounds">1</a></sup>. We do all this
because TinyCC is way faster than MesCC and itâ€™s also more complex, but MesCC
is only able to build a simple TinyCC with few featuresÂ enabled.</p>
<p>During all this process we use a standard library provided by the Mes project,
weâ€™ll call it MesLibC, because we canâ€™t build glibc at this point, and TinyCC
does not provide itâ€™s own C standardÂ library.</p>
<p>With all this well understood, this is theÂ achievement:</p>
<p><strong>We made MesCC able to compile the Bootstrappable TinyCC, using MesLibC, to an
executable that is able to compile the Bootstrappable TinyCCâ€™s codebase to a
binary that works and has all the features we need enabled.</strong><sup id="fnref:self-hosted"><a href="#fn:self-hosted">2</a></sup></p>
<p>The process affected all the pieces in the system. We added changes in MesCC,
MesLibC and the BootstrappableÂ TinyCC.</p>
<h4 id="why-important">Why is thisÂ important?</h4>
<p>We already talked long about the bootstrapping issue, the trusting trust attack
and all that. I wonâ€™t repeat that here. What Iâ€™ll do instead is to be specific.
This step is a big thing because this allows us to go way further in theÂ chain.</p>
<p>All the steps before Mes were already ported to <span>RISC</span>-V mostly thanks to Andrius
Å tikonas who worked in <a href="https://github.com/oriansj/stage0-posix">Stage0-<span>POSIX</span></a> and the rest of glue projects
that are needed to reachÂ Mes.</p>
<p>Mes had been ported to <span>RISC</span>-V (64 bit) by <span>W. J.</span> van der Laan, and some patches
were added on top of it by Andrius Å tikonas himself before our current effortÂ started.</p>
<p>At this moment in time, Mes was unable to build our bootstrappable TinyCC in
<span>RISC</span>-V, the next step in the process, and the bootstrappable TinyCC itself was
unable to build itself either. This was a very limiting point, because TinyCC
is the first â€œproperâ€ C compiler in theÂ chain.</p>
<p>When I say â€œproperâ€ I mean fast and fully featured as a C compiler. In x86,
TinyCC is able to compile old versions of <span>GCC</span>. If we manage to port it to
<span>RISC</span>-V we will eventually be able to build <span>GCC</span> with it and with that theÂ world.</p>
<p>In summary, TinyCC is a key step in the bootstrappingÂ chain.</p>
<h3 id="problems">ProblemsÂ fixed</h3>
<p>This work can be easily followed in the commits in my <span>TCC</span> forkâ€™s
<a href="https://github.com/ekaitz-zarraga/tcc/tree/riscv-mes"><code>riscv-mes</code></a> branch, and in my Mes cloneâ€™s <a href="https://github.com/ekaitz-zarraga/mes/tree/riscv-tcc-boot"><code>riscv-tcc-boot</code></a>
branch. We are also identifying the contents of this blogpost in the git
history by adding the git tag <code>self-hosted-tcc-rv64</code> to both of my forks. We
will try to keep both for futureÂ reference.</p>
<p>In Mes the process might be a little bit harder to follow because we sent most
of the patches to Janneke and he merged them so when we were about to release
this post I continued from Jannekeâ€™s branch to avoid divergences (I had some
problems with that before). In any case, the code is there and searching by
authors (Andrius and myself) would guide you to the changes weÂ did.</p>
<p>Many commits have a long message you can go read there, but this post was born
to summarize the most interesting changes we did, and write them in a more
digestible way. Lets see if I manage to doÂ that.</p>
<p>The following list is not ordered in any particular way, but we hope the
selection of problems we found is interesting for you. We found some errors
more, but these are the ones we consider moreÂ relevant.</p>
<h4 id="tinycc-missing-instructions">TinyCC misses assembly instructions needed forÂ MesLibC</h4>
<p>TinyCC is not like <span>GCC</span>, TinyCC generates binary code directly, no assembly code
in between. TinyCC has a separate assembler that doesnâ€™t follow the path that C
codeÂ follows.</p>
<p>It works the same in all architectures, but we can take <span>RISC</span>-V as anÂ example:</p>
<p>TinyCC has <code>riscv64-gen.c</code> which generates the binary files, but
<code>riscv64-asm.c</code> file parses assembly code and also generates binary. As you can
see, binary generation is somehowÂ duplicated.</p>
<p>In the <span>RISC</span>-V case, the C part had support for mostly everything since my
backport, but the assembler did not support many instructions (which, by the
way are supported by the CÂ part).</p>
<p>MesLibCâ€™s <code>crt1.c</code> is written in assembly code. Its goal is to prepare the
<code>main</code> function and call it. For that it needs to call <code>jalr</code> instruction and
others that were not supported by TinyCC, neither upstream nor our
bootstrappableÂ fork.</p>
<p>These changes appear in several commits because I didnâ€™t really understood how
the TinyCC assembler worked, and some instructions need to use relocations
which I didnâ€™t know how to add. The following commit can show how it feels to
work on this, and shares how relocations areÂ done:</p>
<p>There you can see we started to understand things in TinyCC, but some other
changes came afterÂ this.</p>
<p>A very important not here is upstream TinyCC does not have support for these
instructions yet so we need to patch upstream TinyCC when we use it, contribute
the changes or find other kind of solutions. Each solution has its downsides
and upsides, so we need to take a decision about thisÂ later.</p>
<h4 id="tcc-assembly">TinyCCâ€™s assembly syntax isÂ weird</h4>
<p>Following with the previous fix, TinyCC does not support <span>GNU</span>-Assemblerâ€™s syntax
in <span>RISC</span>-V. It uses a simplified assembly syntaxÂ instead.</p>
<p>When we wouldÂ do:</p>
<pre><code>sd s1, 8(a0)
</code></pre>
<p>In TinyCCâ€™s assembly we have toÂ do:</p>
<pre><code>sd a0, s1, 8
</code></pre>
<p>This requires changes in MesLibC, and it makes us create a separate folder for
TinyCC in MesLibC. See <code>lib/riscv64-mes-tcc/</code> and <code>lib/linux/riscv64-mes-tcc</code>
for moreÂ details.</p>
<h4 id="extended-assembly">TinyCC does not support Extended Asm in <span>RV64</span></h4>
<p>Way later in time we also found TinyCC does not support <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">Extended Asm</a>
in <span>RV64</span>. The functions that manage that are simplyÂ empty.</p>
<p>We spent some time until we realized what was going on in here for two reasons.
First, there are few cases of Extended Asm in the code we were compiling.
Second, it was failingÂ silently.</p>
<p>Extended Asm is important because it lets you tell the compiler you are going
to touch some registers in the assembly block, so it can protect variables and
apply optimizationsÂ properly.</p>
<p>In our case, our assembly blocks were clobbering some variables that would have
been protected by the compiler if the Extended Asm support wasÂ implemented.</p>
<p>Andrius found all the places in MesLibC where Extended Asm was used and rewrote
the assembly code to keep variables safe in the cases it wasÂ needed.</p>
<p>The other option was to add Extended Asm support for TinyCC, but we would need
to add it in the Bootstrappable TinyCC and also upstream. This also means
understanding TinyCC codebase very well and making the changes without errors,
so we decided to simplify MesLibC, because that is easier to make right. We are
probably going to need to do this later on anyway, but weâ€™ll try to delay this
as much asÂ possible.</p>
<h4 id="main-args">MesLibC <code>main</code> function arguments are not setÂ properly</h4>
<p>Following the previous problem with assembly, we later found input arguments of
the <code>main</code> function, that come from the command line arguments, were not
properly set by our MesLibC. Andrius also took care of that in
<a href="https://github.com/ekaitz-zarraga/mes/commit/4f4a11745d1c7ed0995e9d31c7994abfb4a60b25">4f4a1174</a> inÂ Mes.</p>
<p>This error was easier to find than others because when we found issues with
this we already had a compiled TinyCC. So we just needed to fix simple things
aroundÂ it.</p>
<h4 id="dollars">TinyCC says <code>__global_pointer$</code> is not a validÂ symbol</h4>
<p>This is a small issue that was a headache for a while, but it happened to be a
very simpleÂ issue.</p>
<p>In <span>RISC</span>-V thereâ€™s a symbol, <code>__global_pointer$</code>, that is used for dynamic
linking, defined in the <span>ABI</span>. But TinyCC had issues to parse code around it and
it took us some time to realize it was the dollar sign (<code>$</code>) which was causing
the issues in thisÂ point.</p>
<p>TinyCC does not process dollars in identifiers unless you specifically set a
flag (<code>-fdollars-in-identifiers</code>) when running it. In the <span>RISC</span>-V case, that
flag must be always active because if it isnâ€™t the <code>__global_pointer$</code> canâ€™t beÂ processed.</p>
<p>We tried to set that flag in the command line but we had other issues in the
command line argument parsing (we found and fixed them later later) so we just
hardcodedÂ it.</p>
<p>This issue is interesting because itâ€™s an extremely simple problem, but its
effect appears in weird ways and itâ€™s not always easy to know where the problem
is comingÂ from.</p>
<h4 id="tcc-casting-issues">Bootstrappable TinyCCâ€™s castingÂ issues</h4>
<p>This one was a really hard one toÂ fix.</p>
<p>When running our Bootstrappable TinyCC to build MesLibC we found thisÂ error:</p>
<pre><code>    cannot cast from/to void
</code></pre>
<p>We managed to isolate a piece of C code that was able to replicate the
problem.<sup id="fnref:reproducer"><a href="#fn:reproducer">3</a></sup></p>
<pre><code>long cast_charp_to_long (char const *i)
{
  return (long)i;
}

long cast_int_to_long (int i)
{
  return (long)i;
}

long cast_voidp_to_long (void const *i)
{
  return (long)i;
}

void main(int argc, char* argv[]){
    return;
}
</code></pre>
<p>Compiling this file raised the same issue, but then I realized I could remove
two of the functions on the top and the error didnâ€™t happen. Adding one of
those functions back raised the errorÂ again.</p>
<p>I tried to change the order of the functions and the functions I chose to add,
and I could reproduce it: if there were two functions it failed but it could
build with onlyÂ one.</p>
<p>Andrius found that the function type was not properly set in the <span>RISC</span>-V code
generation and its default value was <code>void</code>, so it only failed when it compiled
the secondÂ function.</p>
<p>Knowing that, we could take other architectures as a reference to fix this, and
so weÂ did.</p>
<p>See <a href="https://github.com/ekaitz-zarraga/tcc/commit/6fbd17852aa11a2d0bc047183efaca4ff57ab80c">6fbd1785</a>.</p>
<h4 id="long-double">Bootstrappable TinyCCâ€™s <code>long double</code> support wasÂ missing</h4>
<p>When I backported the <span>RISC</span>-V support to our Bootstrappable TinyCC I missed the
<code>long double</code> support and I didnâ€™t realize that because I never tested large
programs withÂ it.</p>
<p>The C standard doesnâ€™t define a size for <code>long double</code> (it just says it has to
be at least as long as the <code>double</code>), but its size is normally set to 16 bytes.
All this is weird in <span>RV64</span>, because it doesnâ€™t have 16 byte size registers. It
needs some extraÂ support.</p>
<p>Before we fixed this, the followingÂ code:</p>
<pre><code>long double f(int a){
    return  a;
}
</code></pre>
<p>FailedÂ with:</p>
<pre><code>    riscv64-gen.c:449 (`assert(size == 4 || size == 8)`)
</code></pre>
<p>Because it was only expecting to use <code>double</code>s (8 bytes) or <code>float</code>s (4Â bytes).</p>
<p>In upstream TinyCC there were some commits that added <code>long double</code> support
using, and I quote, a <em>mega hack</em>, so I just copied that support to our
BootstrappableÂ TinyCC.</p>
<p>See <a href="https://github.com/ekaitz-zarraga/tcc/commit/a7f3da33456b4354e0cc79bb1e3f4c665937395b">a7f3da33456b</a>.</p>
<p>After this commit, some extra problems appeared with some missing symbols. But
these errors were link-time problems, because TinyCC had the floating point
helper functions needed for <span>RISC</span>-V defined in <code>lib/lib-arm64.c</code>, because they
were reusing aarch64 code forÂ them.</p>
<p>After this, we also compile and link <code>lib-arm64.c</code> and we have <code>long double</code>
support.</p>
<h4 id="mescc-struct-init">MesCC struct initializationÂ issues</h4>
<p>This one was a lot of fun. Our Bootstrappable TinyCC exploded with random
issues: segfaults, weird branchÂ decisionsâ€¦</p>
<p>After tons of debugging Andrius found some values in <code>struct</code>s were not set
properly. As we donâ€™t really know TinyCCâ€™s codebase really well, that was hard
to follow and we couldnâ€™t really know where was the value comingÂ from.</p>
<p>Andrius finally realized some <code>struct</code>s were not initialized properly. Consider
thisÂ example:</p>
<pre><code>typedef struct {
    int one;
    int two;
} Thing;

Thing a = {0};
</code></pre>
<p>Thatâ€™s supposed to initialize <em>all</em> fields in the <code>Thing</code> <code>struct</code> to <code>0</code>,
according to the C standard<sup id="fnref:cppref"><a href="#fn:cppref">4</a></sup>.</p>
<p>As a first solution we set struct fields manually to <code>0</code>, to make sure they
were initialized properly. See <a href="https://github.com/ekaitz-zarraga/tcc/commit/29ac0f40a7afba6a2d055df23a8ee2ee2098529e">29ac0f40a7afb</a></p>
<p>After some debugging we found that the fields that were not explicitly set were
initialized to <code>22</code>. So I decided to go to MesCC and see if the struct
initialization wasÂ broken.</p>
<p>This was my first dive in MesCCâ€™s code, and I have to say itâ€™s really easy to
follow. It took me some time to read through it because Iâ€™m not that used to
<code>match</code>, but I managed to find the struct initializationÂ code.</p>
<p>What I found in MesCC is there was a <code>22</code> hardcoded in the struct
initialization code, probably coming from some debug code that never was
removed. As no part of the x86 bootstrapping used that kind of initializations,
or nothing relied on them, the error wentÂ unnoticed.</p>
<p>I set that to <code>0</code>, as it should be, and continued with ourÂ life.</p>
<h4 id="size-problems">MesCC vs TinyCC sizeÂ problems</h4>
<p>The C standard does not set a size for integers. It only sets relative sizes:
<code>short</code> has to be shorter or equal to <code>int</code>, <code>int</code> has to be shorter or equal
to a <code>long</code>, and so on. If you platform wants, all the integers, including the
<code>char</code>s can have 8 bits, and thatâ€™s ok for the CÂ standard.</p>
<p>TinyCCâ€™s <span>RISC</span>-V backed was written under the assumption that <code>int</code> is 32 bit
wide. You can see this happening in <code>riscv64-gen.c</code>, for example,Â here:</p>
<pre><code>    EI(0x13, 0, rr, rr, (int)pi &lt;&lt; 20 &gt;&gt; 20);   // addi RR, RR, lo(up(fc))
</code></pre>
<p>The bit shifting there is done to clear the upper 20 bits of the pi variable.
This codeâ€™s behavior might be different from one platform to another. Taking
the example before, of that possible platform that only has 8 bit integers,
this code would send a <code>0</code> instead of the lower 12 bits of <code>pi</code>.</p>
<p>In our case, we had MesCC using the whole register width, 64bits, for temporary
values so the lowest <code>44</code> bits were left and the next assertion that checked
the immediate was less than 12 bits didnâ€™tÂ pass.</p>
<p>This is a huge problem, as most of the code in the <span>RISC</span>-V generation is written
using thisÂ style.</p>
<p>There are other ways to do the same thing (<code>pi &amp; 0xFFF</code> maybe?) in a more
portable way, but we donâ€™t know why upstream TinyCC decided to do it this way.
Probably they did because <span>GCC</span> (and TinyCC itself) use 32 bit integers, but they
didnâ€™t handle other possible cases, like the one we had here withÂ MesCC.</p>
<p>In any case, this made us rethink MesCC, dig on how are its integers defined,
how to change this to be compatible with TinyCC and so on, but I finally
decided to add casts in the middle to make sure all this was compiled asÂ expected.</p>
<p>It was a good reason to make us re-think MesCCâ€™s integers, but it took a very
long time to deal with this, that could be better used in something else. Now,
we all became paranoids about integers and we still think some extra errors
will arise from them in the future. Integers areÂ hard.</p>
<h4 id="mes-signed-shift">MesCC add support for signedÂ shifting</h4>
<p>Integers were in our minds for long, as described in the previous block, but I
didnâ€™t talk about signedness in thatÂ one.</p>
<p>Following one of the crazy errors we had in TinyCC, I somehow realized (I donâ€™t
remember how!) that we were missing signed shifting support in MesCC. I think
that I found this while doing some research of the code MesCC was outputting
when I spotted some bit shifts done using unsigned instructions for signed
values and I started digging in MesCC to find out why. I finally realized that
there was no support for that and the shift operation wasnâ€™t selected
depending on the signedness of the value beingÂ shifted.</p>
<p>Letâ€™s see this with anÂ example:</p>
<pre><code>signed char a = 0xF0;
unsigned char b = 0xF0;

// What is this?                (Answer: 0xFF =&gt; 255)
a &gt;&gt; 4;

// And this?                    (Answer: 0x0F =&gt; 15)
b &gt;&gt; 4;
</code></pre>
<p>In the example you can see the shifting operation does not work the same way if
the value is signed or not. If you always use the unsigned version of the <code>&gt;&gt;</code>
operation, you donâ€™t have the results you expected. Signs are alsoÂ hard.</p>
<p>In this case, like in many others, the fix was easier than realizing what was
going wrong. I just added support for the signed shifting operation, not only
for <span>RISC</span>-V but for all architectures, and I added the correct signedness check
to the shifting operation to select the correct instruction. The patch (see
<a href="https://github.com/ekaitz-zarraga/mes/commit/88f24ea8661dd279c2a919f8fbd5f601bb2509ae">88f24ea8</a> in Mes) is very clean and easy to read, because
MesCCâ€™s codebase is really wellÂ ordered.</p>
<blockquote>
<p><span>EDIT</span>: Some person in the web noted I called the <em>bit-shift</em> operations
<em>rotation</em> operations. I normally use both words interchangeably but it is
true they donâ€™t mean the exact same thing. A shift is when the values are
lost, and a rotation when they come from the other side of the register. I
edited the article to use the correctÂ word.</p>
</blockquote>
<h4 id="broken-case">MesCC switch/case falls-back to defaultÂ case</h4>
<p>In the early bootstrap runs, our Bootstrappable TinyCC it did weird things.
After many debugging sessions we realized the <code>switch</code> statements in
<code>riscv64-gen.c</code>, more specifically in <code>gen_opil</code>, were broken. The fall-backs
in the <code>switch</code> were automatically directed to the <code>default</code> case.Â Weird!</p>
<p>MesCC has many tests so I read all that were related with the <code>switch</code>
statements and the ones that handled the fall-backs were all falling-back to
the <code>default</code> case, so our weird behavior wasnâ€™tÂ tested.</p>
<p>I added the tests for our case and read the disassemble of simple examples when
I realized theÂ problem.</p>
<p>Each of the <code>case</code> blocks has two parts: the clause that checks if the value
of the expression is the one of the case, and the body of the caseÂ itself.</p>
<p>The <code>switch</code> statement generation was doing some magic to deal with <code>case</code>
blocks, but it was failing to deal with complex fall-through schemes because
the clause of the target <code>case</code> block was always run, making the code fall to
the <code>default</code> case, as the clause was always false because the one that matched
was the one that made theÂ fall-back.</p>
<p>There were some problems to fix this, as NyaCC (MesCCâ€™s C parser) returns
<code>case</code> blocks as nested when they donâ€™t have a <code>break</code> statement:</p>
<pre><code>(case testA
  (case testB
    (case testC BODY)))
</code></pre>
<p>Instead of doing this, I decided to flatten the <code>case</code> blocks with empty
bodies. This way we can deal with the structure in a simplerÂ way.</p>
<pre><code>((case testA (expr-stmt))
 (case testB (expr-stmt))
 (case testC BODY))
</code></pre>
<p>Once this is done, I expanded each <code>case</code> block to a jump that jumps over the
clause, the clause and then its body. Doing this, the fall-back doesnâ€™t
re-evaluate the clause, as it doesnâ€™t need to. The generated code looks like
this inÂ pseudocode:</p>
<pre><code>    ;; This doesn&#39;t have the jump because it&#39;s the first
CASE1:
    testA
CASE1_BODY:
    ...

    goto CASE2_BODY
CASE2:
    testB
CASE2_BODY:
    ...

    goto CASE3_BODY
CASE3:
    testB
CASE3_BODY:
    ...
</code></pre>
<p>If one of the <code>case</code>s has a <code>break</code>, itâ€™s treated as part of its body, and it
will end the execution of the <code>switch</code> statement normally, noÂ fall-back.</p>
<p>This results in a simpler <code>case</code> block control. The previous approach dealt
with nested <code>case</code> blocks and tried to be clever about them, but
unsuccessfully. The best thing about this commit is most of the cleverness was
simply removed with a simple solution (flatten all theÂ things!).</p>
<p>It wasnâ€™t that easy to implement, but I first built a simple prototype and
Jannekeâ€™s scheme magic made my approach usable inÂ production.</p>
<p>All this is added in Mesâ€™s codebase in several commits, as we needed some
iterations to make it right. <a href="https://github.com/ekaitz-zarraga/mes/commit/22cbf823582e3699b6a21ee0cf74c2dbf0a6a4e9">22cbf823582</a> has the base of this commit,
but there were some iterations more inÂ Mes.</p>
<h4 id="got">Boostrappable TinyCC problems with <span>GOT</span></h4>
<p>The Global Offset Table is a table that helps with relocatable binaries. Our
Bootstrappable TinyCC segfaulted because it was generating an empty <span>GOT</span>.</p>
<p>Andrius debugged upstream TinyCC alongside ours and realized there was a
missing check in an <code>if</code> statement. He fixed it in
<a href="https://github.com/ekaitz-zarraga/tcc/commit/f636cf3d4839d1ca3f5af9c0ad9aef43a4bfccd9">f636cf3d4839d1ca</a>.</p>
<p>The problem with this kind of errors is TinyCCâ€™s codebase is really hard to
read. Itâ€™s a very small compiler but itâ€™s not obvious to see how things are
done on it, so we had to spend many hours in debugging sessions that went
nowhere. If we had a compiler that is easier to read and change, it would be
way simpler to fix and we would have had a better experience withÂ it.</p>
<h4 id="wrong-conditionals">Bootstrappable TinyCC generates wrong assembly inÂ conditionals</h4>
<p>We spent a long time debugging a bug I introduced during the backport when I
tried to undo some optimization upstream TinyCC applied to comparisonÂ operations.</p>
<p>Consider the followingÂ code:</p>
<pre><code>if ( x &lt; 8 )
    whatever();
else
    whatever_else();
</code></pre>
<p>Our Bootstrappable TinyCC was unable to compile this code correctly, instead,
it outputted a code that always took the same branch, regardless of the value
in <code>x</code>.</p>
<p>In TinyCC, a conditional like <code>if (x &lt; CONSTANT)</code> has a special treatment, and
itâ€™s converted to something like thisÂ pseudoassembly:</p>
<pre><code>load x to a0
load CONSTANT to a1
set a0 if less than a1
branch if a0 not equal 0     ; Meaning it&#39;s `set`
</code></pre>
<p>This behaviour uses the <code>a0</code> register as a flag, emulating what other CPUs
use for comparisons. <span>RISC</span>-V doesnâ€™t need that, but itâ€™s still done here
probably for compatibility with other architectures. In <span>RISC</span>-V it could look
likeÂ this:</p>
<pre><code>load x to a0
load CONSTANT to a1
branch if a0 less than a1
</code></pre>
<p>You can easily see the <code>branch</code> <span>â€œ</span>instructionâ€ does a different comparison in
one case versus the other. In the one in the top it checks if <code>a0</code> is set,
and in the other checks if <code>a0</code> is smaller than <code>a1</code>.</p>
<p>TinyCC handles this case in a very clever way (maybe too clever?). When they
emit the <code>set a0 if less than a1</code> instruction they replace the current
comparison operation with <code>not equal</code> and they remove the <code>CONSTANT</code> and
replace it with a <code>0</code>. That way, when the <code>branch</code> instruction is generated,
they insert the correctÂ clause.</p>
<p>In my code I forgot to replace the comparison operator so the branch checked
<code>if a0 is less than 0</code> and it was always false, as the <code>set</code> operation writes
a <code>0</code> or a <code>1</code> and none of them is less than <code>0</code>.</p>
<p>The commit <a href="https://github.com/ekaitz-zarraga/tcc/commit/5a0ef8d0628f719ebb01c952797a86a14051228c">5a0ef8d0628f719</a> explains this in a more technical way,
using actual <span>RISC</span>-VÂ instructions.</p>
<p>This was also a hard to fix, because TinyCCâ€™s variable names (<code>vtop-&gt;c.i</code>) are
really weird and they are used for many differentÂ purposes.</p>
<h4 id="varargs">Support for variable lengthÂ arguments</h4>
<p>In C you can define functions with variable argument length. In <span>RISC</span>-V, those
arguments are sent using registers while in other architectures are sent using
the stack. This means the <span>RISC</span>-V case is a little bit more complex to deal
with, and needs specialÂ treatment.</p>
<p>Andrius realized in our Bootsrappable TinyCC we had issues with variable length
arguments, specially in the most famous function that uses them: <code>printf</code>. He
also found that the problem came from the arguments not being properly set and
found theÂ problem.</p>
<p>Reading upstream TinyCC we found they use a really weird system for the defines
that deal with this. They have a header file, <code>include/tccdefs.h</code>, which is
included in the codebase, but also processed by a tool that generates strings
that are later injected at execution time inÂ TinyCC.</p>
<p>This was too much for us so we just extracted the simplest variable arguments
definitions for <span>RISC</span>-V and introduced that in MesLibC and our BootstrappableÂ TinyCC.</p>
<h5>Extra: files generated with noÂ permissions</h5>
<p>The bootstrappable TinyCC built using MesCC generated files with no permissions
and Andrius found that this problem came from the variable length argument
support definitions. So he fixed that, too<sup id="fnref:stikonas"><a href="#fn:stikonas">5</a></sup>.</p>
<p>The macro that defined <code>va_start</code> was broken pointer arithmetic. At the
beginning he thought it was related with MesCCâ€™s internals but he tested in <span>GCC</span>
later and realized the problem was in the macro definition. Thatâ€™s why
currently the commit says â€œworkaroundâ€ in the name, but itâ€™s more than a
workaround: itâ€™s a proper fix. We are rewording that, but that would happen
after we release thisÂ post.</p>
<h4 id="int8">MesLibC use <code>signed char</code> for <code>int8_t</code></h4>
<p>We already had a running Bootstrappable TinyCC compiled using MesCC when we
stumbled upon this issue. Somehow, whenÂ assembling:</p>
<pre><code>addi a0, a0, 9
</code></pre>
<p>The code was trying to read <code>9</code> as a register name, and failed to do it (of
course). It was weird to realize that the following code (in <code>riscv64-asm.c</code>)
was always using the true branch in the <code>if</code> statement, even if
<code>asm_parse_regvar</code> returned <code>-1</code>:</p>
<pre><code>int8_t reg;
...
if ((reg = asm_parse_regvar(tok)) != -1) {
    ...
} else ...
</code></pre>
<p>I disassembled and saw something likeÂ this:</p>
<pre><code>call asm_parse_regvar   ;; Returns value in a0
reg = a0
a0 = a0 + 1
branch if a0 equals 0
</code></pre>
<p>This looks ok, it does some magic with the <code>-1</code> but it makes sense anyway. The
problem is that it didnâ€™t branch because <code>a0</code> was <code>256</code> even when
<code>asm_parse_regvar</code> returned <code>-1</code>.</p>
<p>During some of the <code>int</code> related problems someone told me in the Fediverse that
<code>char</code><span>â€˜</span>s default signedness is not defined in the C standard. I read MesLibC
and, exactly: <code>int8_t</code> was defined as an alias to <code>char</code>.</p>
<p>In <span>RISC</span>-V <code>char</code> is by default <code>unsigned</code> (donâ€™t ask me why) but we are used to
x86 where itâ€™s <code>signed</code> by default. Only saying <code>char</code> is notÂ portable.</p>
<p>Replacing:</p>
<pre><code>typedef char int8_t;
</code></pre>
<p>With:</p>
<pre><code>typedef signed char int8_t;
</code></pre>
<p>Fixed theÂ issue.</p>
<p>From this you can learn severalÂ things:</p>
<ol>
<li>Donâ€™t assume <code>char</code><span>â€˜</span>s signedness inÂ C</li>
<li>If you design a programming language, be consistent with your decisions. In
   C <code>int</code> is always <code>signed int</code>, but <code>char</code><span>â€˜</span>s donâ€™t act like that. Donâ€™t doÂ this.</li>
</ol>
<h4 id="jmp">MesLibC Implement <code>setjmp</code> and <code>longjmp</code></h4>
<p>Those that are not that versed in C, as I was before we found this issue, wonâ€™t
know about <code>setjmp</code> and <code>longjmp</code> but they are, simplifying a lot, like a
<code>goto</code> you can use in any part of the code. <code>setjmp</code> needs a buffer and it
stores the state of the program on it, <code>longjmp</code> sets the status of the program
to the values on the buffer, so it jumps to the position stored in <code>setjmp</code>.</p>
<p>Both functions are part of the C standard library and they need specific
support for each architecture because they need to know which registers are
considered part of the state of the program. They need to know how to store the
program counter, the return address, and so on, and how to restoreÂ them.</p>
<p>In their simplest form they are a set of stores in the case of the <code>setjmp</code> and
a set of loads in the case of <code>longjmp</code>.</p>
<p>In <span>RISC</span>-V they only need to store the <code>s*</code> registers, as they are the ones that
are not treated as temporary. Itâ€™s simple, but it needs to be done, which
wasnâ€™t in neither for <span>GCC</span> nor for <span>RISC</span>-V inÂ MesLibC.</p>
<p>Andrius is not convinced with our commit in here, and I agree with his
concerns. We added the full <code>setjmp</code> and <code>longjmp</code> implementations directly
<del>stolen from</del> inspired in the ones in Musl<sup id="fnref:stolen"><a href="#fn:stolen">6</a></sup> but it has also
floating point register support, using instructions that are not implemented in
TinyCC yet. This is going to be a problem in the future because later
iterations will try to execute instructions they donâ€™t actuallyÂ understand.</p>
<p>There are two (or three) possible solutions here. The first is to remove the
floating point instructions for now (another flavor for this solution is to
hide them under an <code>#ifdef</code>). The second is to implement the floating point
instructions in TinyCCâ€™s <span>RISC</span>-V assembler, which sounds great but forces us to
upstream the changes, and that process may take long and weâ€™d need to patch it
in our bootstrapping scripts until itÂ happens.</p>
<p>We just added the <code>#ifdef</code>s because our code is full of them anyway and sent it
to Mes: <a href="https://github.com/ekaitz-zarraga/mes/commit/0e2c55697df285250c8a24442f169bc52d729c31">0e2c5569</a>.</p>
<h4 id="more">More</h4>
<p>Those are mostly the coolest errors we needed to deal with but we stumbled upon
a lot of errorsÂ more.</p>
<p>Before this effort started Andrius added support for 64 bit instructions in Mes
and fixed some issues 64bit architectures had inÂ M2.</p>
<p>I found a <a href="https://issues.guix.gnu.org/65225">bug in Guix shell</a> (itâ€™s still
open) and had to fix some <span>ELF</span> headers in MesCC generated files because objdump
and gdb refused to work onÂ them.</p>
<p>Andrius also found issues with weak symbols in MesLibC that were triggered
because <span>TCC</span> didnâ€™t have support for them, thankfully upstream <span>TCC</span> had that
issue fixed and we just cherry-picked for theÂ win.</p>
<p>He even had the energy to test all this in real <span>RISC</span>-V we specifically acquired
for thisÂ task.</p>
<p>There are many more things to tell, but this is already getting too long and if
I continue writing weâ€™ll probably end up fixing some stuffÂ more.</p>
<p>In the end, a project like this is like hitting your head against a wall until
one of them breaks. Sometimes it feels like the head did, but itâ€™s allÂ good.</p>
<h4 id="reproducing">Reproducing what weÂ did</h4>
<p>All we did means nothing if you canâ€™t reproduce it. We provide two ways to
reproduce this process: live-bootstrap andÂ Guix.</p>
<p>Both provide a similar thing but there are some differences from the
high-level that is worth mentionÂ now.</p>
<p>Comparing with <code>live-bootstrap</code>, using Guix helps because it reuses the
previous steps if they didnâ€™t change. This results in shorter waits once Mes is
sortedÂ out.</p>
<p>On the other hand, Iâ€™ve have had issues with the failed builds in Guix (in
emulated systems). It was hard to jump inside the build container and play
around inside so the development cycle suffered a lot. In <code>live-bootstrap</code>, if
you are good with <code>bwrap</code> you can jump and tweak things with noÂ issues.</p>
<p>For those who enjoy digging in the code and trying to follow the process I
recommend following <code>live-bootstrap</code><span>â€˜</span>s scripts. The directory structure is a
little bit confusing but the scripts are very plain and linear. The ones in the
Guix process come from previous bootstrap efforts and they are designed to do
many things automagically, that makes them a hard toÂ follow.</p>
<h5 id="live-bootstrap">UsingÂ live-bootstrap</h5>
<p>Andrius is part of the <code>live-bootstrap</code> effort and heâ€™s doing all the scripting
there to keep the processÂ reproducible.</p>
<p><a href="https://github.com/fosslinux/live-bootstrap">Live-bootstrap</a>Â isâ€¦</p>
<blockquote>
<p>An attempt to provide a reproducible, automatic, complete end-to-end
bootstrap from a minimal number of binary seeds to a supported fully
functioning operatingÂ system.</p>
</blockquote>
<p>Thatâ€™s the official description of the project. From a more practical
perspective, itâ€™s a set of scripts that build the whole operating system from
scratch, depending on few binaryÂ seeds.</p>
<p>Thatâ€™s not very different to what Guix provides from a bootstrapping
perspective. Guix is â€œjustâ€ an environment where you can run â€œscriptsâ€ (the
packages define how they are built) in a reproducible way. Of course, Guix is
way more than that, but if we focus on what we are doing right now it acts like
the exact sameÂ thing.</p>
<blockquote>
<p><span>NOTE</span>: <code>live-bootstrap</code><span>â€˜</span>s project description is a little bit outdated. If you
read the comparison with Guix, what youâ€™d read is old information. If you
want to read a more up-to-date information about Guixâ€™s bootstrapping process
I suggest you to read this page of Guix manual:
<a href="https://guix.gnu.org/manual/devel/en/html_node/Full_002dSource-Bootstrap.html">https://guix.gnu.org/manual/devel/en/html_node/Full_002dSource-Bootstrap.html</a></p>
</blockquote>
<p>Being very different projects, in a practical level, the main difference
between them is <code>live-bootstrap</code> is probably easier for you to test if you are
working on any <span>GNU</span>/Linux distribution<sup id="fnref:in-guix"><a href="#fn:in-guix">7</a></sup>.</p>
<p>If you want to reproduce this exact point in time you only need to use my fork
of <a href="https://github.com/ekaitz-zarraga/live-bootstrap/">live-bootstrap</a>, branch
<code>riscv-tcc-boot</code>. I also made a tag on it, <code>self-hosted-tcc-rv64</code>, to make it
easier to remember when was this post released. Andrius made all the magic to
set that process to take all the inputs from Mes and TinyCC from the correctÂ tag.</p>
<p>Clone the repository, set up the dependencies and run this (if you are not in a
<span>RISC</span>-V host you need to configure Qemu andÂ binfmt):</p>
<pre><code> ./rootfs.py --bwrap --arch riscv64 --preserve
</code></pre>
<p>That should, after a long time, reach a point where thereâ€™s a properly compiled
bootstrappableÂ TinyCC.</p>
<h4 id="guix">Using Guix for a reproducibleÂ environment</h4>
<p>I made a Guix recipe that can replicate the whole process, too. It took me long
time to make it work but it finallyÂ does.</p>
<p>From my <span>TCC</span> fork reproducing this should be easy for the people versed in Guix.
Thereâ€™s a <code>guix</code> folder with some files, (most of them broken, not gonna lie)
but there are two you should pay attentionÂ to:</p>
<ul>
<li>
<p><code>channels.scm</code> stores the state of my Guix checkout so you can reproduce it
  in the future using <code>guix time-machine</code>. At the moment it doesnâ€™t feel
  necessary but if something fails when you try it, please refer toÂ that.</p>
</li>
<li>
<p><code>commencement.scm</code> is an edited copy of the Guix bootstrapping process,
  directly obtained from <code>gnu/packages/commencement.scm</code> from Guixâ€™s codebase.
  I patched this to make it work for <span>RISC</span>-V, using some more modern commits in
  theÂ dependencies.</p>
</li>
</ul>
<p>In order to reproduce all our work in Guix you just need to build <code>tcc-boot0</code>
package from the <code>commencement.scm</code> file using <code>riscv64-linux</code> as your
<code>--system</code>. Iâ€™m a nice guy so I just added a command there you can use for
this, justÂ run:</p>
<pre><code>./tcc-boot0-from-source.sh
</code></pre>
<p>And that should build the whole thing. It takes hours, you have beenÂ warned.</p>
<p>Also it adds <code>--no-grafts</code> (thanks Efraim), because if you keep the grafts it
compiles the world from scratch (curl, x11â€¦ notÂ good).</p>
<p>If you just want to build <code>mes-boot</code> as an intermediate step, I also made a
file forÂ that:</p>
<pre><code>./mes-boot-from-source.sh
</code></pre>
<p>The both scripts will load variables from the <code>commencement.scm</code> module
provided. The module is not complex if you are used to Guix, but it calls
some complex shell scripts in both Mes and TinyCC to build. Those contain all
theÂ magic.</p>
<h3 id="conclusions">Conclusions</h3>
<p>Of course, the problems we fixed now look easy and simple to fix. This blog
post doesnâ€™t really do justice to the countless debugging hours and all the
nights we, Andrius and I, spent thinking about where could the issues be
comingÂ from.</p>
<p>The debugging setup wasnâ€™t as good as you might imagine. The early steps of the
bootstrap donâ€™t have all the debug symbols as a â€œnormalâ€ userspace program
would. In many cases, function names were all weÂ had.</p>
<p>I have thank my colleague Andrius here because he did a really good debugging
job, and he provided me with small reproducers that I could finally fix. Most
of the times he made the assist and I scored theÂ goal.</p>
<p>He also did a great job with the testing which I couldnâ€™t do because I was
struggling with Guix from the early days, trying to make the compilers find the
header files andÂ libraries.</p>
<p>In the emotional part it is also a great improvement to have someone to rely
on. Andrius, Janneke and I had a good teamwork and we supported each other when
our faith started to crumble. And believe, it does crumble when a new bug
appears after you fixed one that you needed a week for. There were times this
summer I thought we would never reach thisÂ point.</p>
<p>Itâ€™s also worth mention here that the bootstrapping process is extremely slow:
it takes hours. This kills the responsiveness and makes testing way harder than
it should be. Not to mention that we are working on a foreign architecture,
which has itâ€™s own problemsÂ too.</p>
<p>If you have to take some lesson from something like this, here you have a
suggestionÂ list:</p>
<ul>
<li>The simplest error can take ages to debug if your code is crazyÂ enough.</li>
<li>Donâ€™t be clever. It sets a very high standard for your future self and people
  who will read your code in theÂ future.</li>
<li>I guess we can summarize the previous two points in one: If we could remove
  TinyCC from the chain, we would. Itâ€™s a source of errors and itâ€™s hard to
  debug. The codebase is really hard to read for no apparentÂ reason.</li>
<li>When build times are long, small reproducersÂ help.</li>
<li>Add tests for each new case youÂ find.</li>
<li>Donâ€™t trust, disassemble andÂ debug.</li>
<li>Be careful with C and standards and undefinedÂ behavior.</li>
<li>Integers are hard. Signedness makes themÂ harder.</li>
<li>Being surrounded by the correct people makes your lifeÂ easier.</li>
</ul>
<p>Also, as a personal note I noticed Iâ€™m a better programmer since the previous
post in the this series. I feel way more comfortable with complex reasoning and
even writing new programs in other languages, even if I spent almost no time
coding anything from scratch. Itâ€™s like dealing with this kind of issues about
the internals give you some level of awareness that is useful in a more general
way than it looks. CrazyÂ stuff.</p>
<p>If you can, try to play with the internals of things from time to time. It
helps. At least it helpedÂ me.</p>
<h3 id="next">What isÂ next?</h3>
<p>Now we have a fully featured Bootstrappable TinyCC we need to decide what to doÂ next.</p>
<p>On the short term, all this has to be released in the original projects: Mes,
M2, and so on. Thatâ€™s the easy part, as everything has proved to beÂ ready.</p>
<p>On the mid term, itâ€™s not very clear what to do first. We suspect weâ€™ll need
upstream TinyCC for the next steps, because we many different tools to
continue with the bootstrapping chain, and the bootstrappable TinyCC might not
be enough to build them. On the other hand, when we go for a standard library
weâ€™ll miss the extended assembly support we already mentioned. Thereâ€™s some
uncertainty in the nextÂ step.</p>
<p>The long-term is pretty much clear though, the goal is <span>GCC</span>. First <span>GCC</span> for C and
then for C++ to make it able build <span>GCC</span> 7.5 which should enable the rest of the
chain pretty easily (famous last words). I anticipate we are going to have
problems with <span>GCC</span> (I know this because I left them there last time) so weâ€™ll
need to fix those, too. Once that is done, we would use <span>GCC</span> to compile more
recent versions of <span>GCC</span> until we compile theÂ world.</p>
<p>Thatâ€™s more or less the description of what we will do in the nextÂ months.</p>
<p>And this is pretty much it. I hope you learned something new about C, the
Bootstrapping process or at least had a good time reading this wall ofÂ text.</p>
<p>Weâ€™ll try to work less for the next one, but we canâ€™t promise that.Â ğŸ˜‰</p>
<p>TakeÂ care.</p>
<hr/>
<!--

MANY OF THIS ARE REALLY HARD TO REASON ABOUT!!!!
WITH THIS WE START PASSING MANY MORE TESTS IN MESCC AND ALSO ADDED SOME EXTRA
TESTS THAT CHECK COMPLEX BEHAVIOR HERE AND THERE

- `int`s are 64 bit in MesCC and TinyCC is written like they are 32 bit.

- TinyCC's assembly for RISC-V is not complete and we need some of that in
  meslibc. We implemented the missing instructions (jal, jalr, lla and some
  pseudoinstructions).

- TinyCC's assembler for RISC-V uses a simplified syntax, so we need to rewrite
  our meslibc according to that.

- RISC-V uses a `__global_pointer$` symbol, but TinyCC does not allow dollars
  in identifiers by default. The `-fdollars-in-identifiers` flag exploded when
  used so we hardcoded the flag to true.

- We backported the `long double` support from TinyCC's `mob` branch.
    - And large constant generation.

- Fixed some weird casting issues in TinyCC (see Fix casting issues (missing
  func_vt in riscvgen.c)

- MesCC produced binaries that were impossible to debug with GDB and OBJDUMP
  complained about them. We fixed those too (some archs are missing)

- MesCC's struct initialization to zeroes like `Whatever a = {0};` initialized
  everything to `22` and is now working as expected.

- `switch/case` statements in MesCC fallback always to default because they
  check the fallback clause and then jump to default.

- Mes had some incompatibilities with Guile that prevented us from running the
  code fast. Fixed those.

- Added support for RISC-V instruction formats in MesCC
  (https://git.savannah.gnu.org/cgit/mes.git/commit/?h=wip-riscv&id=e42cf58d14520a5360d7d527d1c2c18c0a498c28)

- Added support for signed rotation in MesCC. (all arches affected)

- And also fixed some M2 things that allow all this 64 bit support happen in
  MesCC, which didn't have 64 bit support before. Stikonas?

- Stikonas also fixed problems in M2:
    https://github.com/oriansj/M2-Planet/commit/85dd953b70c5f607769016bbf2a0aa3de7e41b6c

- Fix Bootstrappable TinyCC's GOT (global offset table). It was just a broken
  condition in an if (stikonas dealt with that)

- Meslibc again! Tinycc does not support [extended
  asm](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html) in RV64 but
  stikonas fixes it replacing the extended asm by abi-compatible handwired asm.
  The good fix would be to implement it, but upstream doesn't have it either...

- `int size = 0; if (size < 8) size = 8;` does not work because TCC generated
  wrong assembly and it jumps over the true branch even if it checks the
  condition is ok. (reproducer in `C_TESTS/if.c`)

- Variable length arguments were broken in Bootstrappable TCC. Upstream TCC
  does some string magic to support them (c2str) where the same header file is
  used twice: one in the binary and one in runtime. That functionality was lost
  in the ~translation~ backport. We had to push some defines to Meslibc that
  support that.

- Meslibc had `typedef char int8_t` in `stdint.h` but that's not reliable,
  because the C standard doesn't define the signedness of the `char`. In RISC-V
  the signedness of the char is `unsigned` by default, so we have to be
  explicit and say `signed char`, to avoid issues.

- Remove some 0bXXXX literals I introduced in the assembler to simplify
  things... They happen not to be standard C but a GCC extension.

- Add a setjmp and longjmp implementation to meslibc that also support tinycc
  assembler syntax. (copy from musl but with our syntax)
-->


  </div><!-- /.entry-content -->
</section>
      </div></div>
  </body>
</html>
