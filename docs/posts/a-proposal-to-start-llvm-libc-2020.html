<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://llvm.org/docs/Proposals/LLVMLibC.html">Original</a>
    <h1>A proposal to start “llvm-libc” (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <div>
          <div role="main">
            
  <div id="llvm-libc-c-standard-library">


<div id="introduction">
<h2><a href="#id1">Introduction</a><a href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This is a proposal to start <em>llvm-libc</em>, an implementation of the
C standard library targeting C17 and above, as part of the LLVM project.
llvm-libc will also provide platform specific extensions as relevant.
For example, on Linux it also provides pthreads, librt and other POSIX
extension libraries.</p>
</div>
<div id="features">
<h2><a href="#id2">Features</a><a href="#features" title="Permalink to this headline">¶</a></h2>
<p>llvm-libc will be developed to have a certain minimum set of features:</p>
<ul>
<li>C17 and upwards conformant.</li>
<li>A modular libc with individual pieces implemented in the “as a
library” philosophy of the LLVM project.</li>
<li>Ability to layer this libc over the system libc if possible and desired
for a platform.</li>
<li>Provide C symbols as specified by the standards, but take advantage
and use C++ language facilities for the core implementation.</li>
<li>Provides POSIX extensions on POSIX compliant platforms.</li>
<li>Provides system-specific extensions as appropriate. For example,
provides the Linux API on Linux.</li>
<li>Vendor extensions if and only if necessary.</li>
<li>Designed and developed from the start to work with LLVM tooling and
testing like fuzz testing and sanitizer-supported testing.</li>
<li>ABI independent implementation as far as possible.</li>
<li>Use source based implementations as far possible rather than
assembly. Will try to <em>fix</em> the compiler rather than use assembly
language workarounds.</li>
<li>Extensive unit testing and standards conformance testing. If relevant
and possible, differential testing: We want to be able
to test llvm-libc against another battle-tested libc. This is
essentially to understand how we differ from other libcs. Also if
relevant and possible, test against the testsuite of an another
battle-tested libc implementation.</li>
</ul>
</div>
<div id="why-a-new-c-standard-library">
<h2><a href="#id3">Why a new C Standard Library?</a><a href="#why-a-new-c-standard-library" title="Permalink to this headline">¶</a></h2>
<p>Implementing a libc is no small task and is not be taken lightly. A
natural question to ask is, “why a new implementation of the C
standard library?” There is no single answer to this question, but
some of the major reasons are as follows:</p>
<ul>
<li>Most libc implementations are monolithic. It is a non-trivial
porting task to pick and choose only the pieces relevant to one’s
platform. The llvm-libc will be developed with sufficient modularity to
make picking and choosing a straightforward task.</li>
<li>Most libc implementations break when built with sanitizer specific
compiler options. The llvm-libc will be developed from the start to
work with those specialized compiler options.</li>
<li>The llvm-libc will be developed to support and employ fuzz testing
from the start.</li>
<li>Most libc implementations use a good amount of assembly language,
and assume specific ABIs (may be platform dependent). With the llvm-libc
implementation, we want to use normal source code as much as possible so
that compiler-based changes to the ABI are easy. Moreover, as part of the
LLVM project, we want to use this opportunity to fix performance related
compiler bugs rather than using assembly workarounds.</li>
<li>A large hole in the LLVM toolchain will be plugged with llvm-libc.
With the broad platform expertise in the LLVM community, and the
strong license and project structure, we think that llvm-libc will
be more tunable and robust, without sacrificing the simplicity and
accessibility typical of the LLVM project.</li>
</ul>
</div>
<div id="platform-support">
<h2><a href="#id4">Platform Support</a><a href="#platform-support" title="Permalink to this headline">¶</a></h2>
<p>We envision that llvm-libc will support a variety of platforms in the coming
years. Interested parties are encouraged to participate in the design and
implementation, and add support for their favorite platforms.</p>
</div>
<div id="abi-compatibility">
<h2><a href="#id5">ABI Compatibility</a><a href="#abi-compatibility" title="Permalink to this headline">¶</a></h2>
<p>As llvm-libc is new, it will not offer ABI stability in the initial stages.
However, as we’ve heard from other LLVM contributors that they are interested
in having ABI stability, llvm-libc code will be written in a manner which is
amenable to ABI stability. We are looking for contributors interested in
driving the design in this space to help us define what exactly does ABI
stability mean for llvm-libc.</p>
</div>
<div id="layering-over-another-libc">
<h2><a href="#id6">Layering Over Another libc</a><a href="#layering-over-another-libc" title="Permalink to this headline">¶</a></h2>
<p>When meaningful and practically possible on a platform, llvm-libc will be
developed in a fashion that it will be possible to layer it over the system
libc. This does not mean that one can mix llvm-libc with the system-libc. Also,
it does not mean that layering is the only way to use llvm-libc. What it
means is that, llvm-libc can optionally be packaged in a way that it can
delegate parts of the functionality to the system-libc. The delegation happens
internal to llvm-libc and is invisible to the users. From the user’s point of
view, they only call into llvm-libc.</p>
<p>There are a few problems one needs to be mindful of when implementing such a
delegation scheme in llvm-libc. Examples of such problems are:</p>
<p>1. One cannot mix data structures from llvm-libc with those from the
system-libc. A translation from one set of data structures to the other should
happen internal to llvm-libc.
2. The delegation mechanism has to be implemented over a related set of
functions. For example, one cannot delegate just the <cite>fopen</cite> function to the
system-libc. One will have to delegate all <cite>FILE</cite> related functions to the
system-libc.</p>
</div>

<div id="build-bots">
<h2><a href="#id8">Build Bots</a><a href="#build-bots" title="Permalink to this headline">¶</a></h2>
<p>Once the development starts, there will be llvm-libc focused builders added to
the LLVM BuildBot.</p>
</div>
</div>


          </div>
        </div>
      </div>
      
    </div></div>
  </body>
</html>
