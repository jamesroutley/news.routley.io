<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sequin.io/events-not-webhooks">Original</a>
    <h1>Give me /events, not webhooks</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>We&#39;re <a href="http://sequin.io/">Sequin</a> and we help developers skip API integrations. We sync data from third-party APIs like Airtable and Stripe right to your Postgres database in real-time. It&#39;s like having row-level access to your data in <code>stripe_prod</code>. Setup takes <a href="https://app.sequin.io/signup" target="_blank">just two minutes</a>.</p><p>Webhooks are a supplement to many APIs. With a webhook system in place, System B can register to receive notifications about certain changes to System A. When a change occurs, System A <em>pushes</em> the change to System B, usually in the form of making an HTTP POST request.</p><p>Webhooks are intended to eliminate or reduce the need to constantly poll for data. But in my experience, webhooks come with a few challenges.</p><p>In general, <strong>you can&#39;t rely on webhooks alone to keep two systems consistent</strong>. Every integration I&#39;ve ever worked on has realized this fact by eventually augmenting webhooks with polling. This is due to a few problem areas.</p><p>First, <strong>there are risks when you go down</strong>. Yes, senders typically retry undelivered webhooks with some exponential back-off. But the guarantees are often loose or unclear. And the last thing your system probably needs after recovering from a disaster is a deluge of backed-up webhooks to handle.</p><p>Second, <strong>webhooks are ephemeral</strong>. They are too easy to mishandle or lose. If you realize after deploying a code change that you fat-fingered a JSON field and are inserting <code>null</code>s into your database, there is no way to play the webhooks back. Or, you might handle part of the webhook processing pipeline out-of-band with the webhook request â€“ like the database insert. But then you risk that failing and you losing the webhook.</p><p>To mitigate both of these issues, many developers end up buffering webhooks onto a message bus system like Kafka, which feels like a cumbersome compromise.</p><p>Consider the architecture for a sophisticated webhook pipeline between two parties:</p><p><img src="https://blog.sequin.io/events-not-webhooks/producer-consumer-pipeline.png" alt="arch of producer pushing events to a consumer"/></p><p>We have two message buses, one on the sending end and one on the receiving end. The complexity is apparent and the stages where things can go wrong are many. For example: On the receiving end, even if your system is tight you&#39;re still subject to sender deliverability failure. If the sender&#39;s queue starts to experience back-pressure, webhook events will be delayed, and it may be very difficult for you to know that this slippage is occurring.</p><p>Adding to the complexity, the security layer between the two is usually some HTTP request signing protocol, like HMAC. This is robust and alleviates managing a secret. But it&#39;s also far less familiar to your average developer and therefore more prone to headache and error. (HTTP request signing and verification is one of those tasks I feel one does <em>just infrequently enough</em> to never fully commit to memory.)</p><p>So, not only do webhooks leave you open to eventual <em>inconsistency</em>, they&#39;re also a lot more work for everybody.</p><p>What else can we use to keep two systems in sync, then?</p><h3>The <code>/events</code> endpoint</h3><p>For inspiration on keeping two data sets in harmony, we need look no further than databases. Consider Postgres&#39; replication slots: you create a replication slot for each follower database, and the followers subscribe to that replication slot for updates.</p><p>The two key components are:</p><ul><li>The primary database keeps a log of everything that&#39;s changed recently and</li><li>The primary database keeps a cursor that tracks the position in the changelog for each follower database</li></ul><p>If the follower goes down, when it comes back it can page through the history at its leisure. There is no queue, nor workers on each end trying to pass events along as a bucket brigade.</p><p>APIs can follow from this model as well. Take Stripe. They have an <code>/events</code> endpoint that contains all creates, updates, and deletes to a Stripe account over the last 30 days. Each event object contains the full payload of the entity that was acted upon. Here&#39;s an example of an event for a <code>subscription</code> object:</p><pre><p><span>{</span><span></span></p><p><span>  </span><span>&#34;id&#34;</span><span>:</span><span> </span><span>&#34;evt_1J7rE6DXGuvRIWUJM7m6q5ds&#34;</span><span>,</span><span></span></p><p><span>  </span><span>&#34;object&#34;</span><span>:</span><span> </span><span>&#34;event&#34;</span><span>,</span><span></span></p><p><span>  </span><span>&#34;created&#34;</span><span>:</span><span> </span><span>1625012666</span><span>,</span><span></span></p><p><span>  </span><span>&#34;data&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>&#34;object&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>&#34;id&#34;</span><span>:</span><span> </span><span>&#34;sub_JgFEscIjO0YEHN&#34;</span><span>,</span><span></span></p><p><span>      </span><span>&#34;object&#34;</span><span>:</span><span> </span><span>&#34;subscription&#34;</span><span>,</span><span></span></p><p><span>      </span><span>&#34;canceled_at&#34;</span><span>:</span><span> </span><span>1625012666</span><span>,</span><span></span></p><p><span>      </span><span>&#34;customer&#34;</span><span>:</span><span> </span><span>&#34;cus_Jff7uEN4dVIeMQ&#34;</span><span>,</span><span></span></p><p><span>      </span><span>&#34;items&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>&#34;object&#34;</span><span>:</span><span> </span><span>&#34;list&#34;</span><span>,</span><span></span></p><p><span>        </span><span>&#34;data&#34;</span><span>:</span><span> </span><span>[</span><span></span></p><p><span>        </span><span>]</span><span>,</span><span></span></p><p><span>        </span><span>&#34;url&#34;</span><span>:</span><span> </span><span>&#34;/v1/subscription_items?subscription=sub_JgFEscIjO0YEHN&#34;</span><span></span></p><p><span>      </span><span>}</span><span>,</span><span></span></p><p><span>      </span><span>&#34;start_date&#34;</span><span>:</span><span> </span><span>1623826800</span><span>,</span><span></span></p><p><span>      </span><span>&#34;status&#34;</span><span>:</span><span> </span><span>&#34;canceled&#34;</span><span>,</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>  </span><span>}</span><span>,</span><span></span></p><p><span>  </span><span>&#34;type&#34;</span><span>:</span><span> </span><span>&#34;customer.subscription.deleted&#34;</span><span></span></p><p><span></span><span>}</span><span>,</span><span></span></p></pre><p>Some important qualities:</p><ul><li>Each event has a <code>type</code> which tells us what this event is. In this case, we see that a customer&#39;s subscription has been deleted. Because the full subscription payload is included, we can update our database to reflect fields like <code>canceled_at</code> and its new <code>status</code> of <code>canceled</code>.</li><li>Every embedded object contains an <code>object</code> field, so we can easily extract and parse them.</li><li>The event object liberally embeds child objects, giving us a full view of everything that changed without needing to poll the API.</li></ul><p>So, instead of listening to webhooks to keep things up-to-date, we can poll <code>/events</code>. We just need to keep a cursor locally, which we use in our requests to indicate to Stripe which events we&#39;ve already seen.</p><p>The advantages:</p><ul><li>If we go down, we don&#39;t have to worry about missing webhooks. And when we come back up, we can catch up at our own pace.</li><li>If we deploy a bug that mishandles events, no sweat. We can deploy a fix and rewind the cursor for <code>/events</code>, which will play them back.</li><li>No need for a message bus on our end.</li><li>We don&#39;t have to worry about Stripe&#39;s webhook senders delaying delivery. Speed is in our hands. The only thing between us and the freshest data is any caching at the API layer that Stripe is doing (which appears to be none.)</li><li>We&#39;re using a simple token-based authentication scheme.</li><li>The way we pull and process events looks the same as how we process any other endpoint. We can reuse a lot of the same API request/processing code.</li></ul><p>On the producer side, to support <code>/events</code> you need to add the same ceremony around monitoring creates/updates/deletes as you&#39;d use for webhooks. Except, instead of needing to build a delivery pipeline, you just have to insert records into an append-only database table.</p><p>On the consumer side, you&#39;ll need to setup some polling infrastructure. This is more legwork than, say, a rudimentary webhook handling endpoint that processes everything in-band. But, I bet a decent polling system is no more difficult to build than a robust webhook handling system with, for instance, a message bus. And you get a much better consistency guarantee.</p><h3>Making <code>/events</code> even better</h3><p>There is one glaring inefficiency to the <code>/events</code> endpoint: to keep things as real-time as possible, you have to poll very frequently. <a href="https://blog.sequin.io/stripe-sync-process">We poll the Stripe <code>/events</code> endpoint every 500ms per account</a>, and have considered halving that.</p><p>These requests are light, as for all but the most active Stripe accounts the responses will often be empty. But as programmers, we can&#39;t help but reach for a way to make this more efficient.</p><p>One idea for Stripe and other API platforms: support long-polling!</p><p>In the lost art of long-polling, the client makes a standard HTTP request. If there is nothing new for the server to deliver to the client, the server <em>holds the request open</em> until there is new information to deliver.</p><p>In our integration with Stripe, it would be neat if we could request <code>/events</code> with a parameter indicating we wanted to long-poll. Given the cursor we send, if there were new events Stripe would return those immediately. But if there wasn&#39;t, Stripe could hold the request open until new events were created. When the request completes, we simply re-open it and repeat the cycle. This would not only mean we could get events as fast as possible, but would also reduce overall network traffic.</p><p>The advantage of long-polling over websockets is code reuse and simplicity. Most integrations involve some form of polling anyway, whether you are backfilling data or replaying mishandled events. The ability to switch from eg backfilling to listening for new events in real-time with a single parameter tweak is a huge win.</p><h3>Which should I use?</h3><p>For API consumers, if you&#39;re lucky enough to have the choice between polling <code>/events</code> or using webhooks, the question of which to use boils down to your consistency needs. Webhooks can be faster for getting started, especially if you only care about a few API objects. And for some workflows, it&#39;s OK if webhooks get dropped, like if you&#39;re posting a &#34;new subscriber&#34; announcement to a Slack channel.</p><p>But as an integration grows in importance and as the need to ensure nothing gets dropped emerges, we think polling <code>/events</code> is hard to beat.</p><p>For API producers, supporting <code>/events</code> is not only a great gift to your API consumers. <code>/events</code> can easily be a stepping stone on the way to providing webhooks. Your <code>events</code> table can serve as a &#34;queue&#34; for outbound work for your webhook senders. In fact, <code>events</code> can unlock much-needed webhook features, like allowing your webhook consumers to replay or reset the position of their webhook subscription.</p></div></div><p><b>Skip the API. Access your data from SaaS platforms like Airtable or Stripe without leaving your database. Syncs to Postgres in real-time.</b> <a href="https://sequin.io">Get started free</a>.</p></div>
  </body>
</html>
