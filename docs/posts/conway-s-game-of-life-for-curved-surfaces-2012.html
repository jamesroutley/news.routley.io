<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://0fps.net/2012/11/19/conways-game-of-life-for-curved-surfaces-part-1/">Original</a>
    <h1>Conway&#39;s Game of Life for curved surfaces (2012)</h1>
    
    <div id="readability-page-1" class="page"><article id="post-856">
	<!-- .entry-header -->

	
	
	<div>
		<p>Conway’s <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a> is one of the most popular and iconic <a href="http://en.wikipedia.org/wiki/Cellular_automaton">cellular automata</a>.  It is so famous that <a href="https://www.google.com/search?q=conway%27s+game+of+life">googling it</a> loads up a working simulation right in your browser!  The rules for the Game of Life (GoL) can be stated in a few lines:</p>
<ol>
<li>The world is an infinite rectangular array of cells, each of which can be in one of two states: alive or dead; and the neighborhood of each cell is a 3×3 grid centered on the cell.</li>
<li>The state of the world advances in discrete synchronous time steps according to the following two rules:</li>
<li>Cells which are alive remain alive if and only if they have between 2 and 3 neighbors; otherwise they die.</li>
<li>Cells which are dead become alive if they have exactly 3 neighbors; or else they stay dead.</li>
</ol>
<p>Despite the superficial simplicity of these rules, the Game of Life can produce many unexpected and fascinating recurring patterns; like the glider soliton:</p>
<figure><a href="http://en.wikipedia.org/wiki/File:Game_of_life_animated_glider_2.gif"><img title="Glider Animation" alt="" src="https://i0.wp.com/upload.wikimedia.org/wikipedia/en/d/d0/Game_of_life_animated_glider_2.gif" height="202" width="202"/></a><figcaption>A 3×3 glider in Conway’s Game of Life. Black represents a live cell; white represents dead. (c) 2008, Wikipedia. Author: Dhatfield</figcaption></figure>
<p>The fact that the rules for the Game of Life are so short and clear makes it a great project for initiating novice programmers.  Since Life was invented by <a href="http://en.wikipedia.org/wiki/John_Horton_Conway">John Conway</a> in 1970, it has distracted many amateur and recreational mathematicians, leading to the discovery of many interesting patterns.  For example, <a href="http://www.igblan.free-online.co.uk/igblan/ca/index.html">Paul Chapman</a> showed that Life is <a href="http://en.wikipedia.org/wiki/Turing_completeness">Turing complete</a>, and so it is in principle possible to translate any computer into a set of initial conditions.     As an amusing example of this concept, <a href="http://www.youtube.com/watch?v=xP5-iIeKXE8">here is an implementation of Conway’s Game of Life in the Game of Life</a> created by <a href="http://www.conwaylife.com/wiki/Brice_Due">Brice Due</a>.  Another cool pattern is the famous <a href="http://www.conwaylife.com/wiki/index.php?title=Gemini">Gemini spaceship</a> which is a complex self replicating system, and is perhaps the first true `organism’ to be discovered in life!  If any of this sounds interesting to you, you can play around with the Game of Life (and some other cellular automata) and look at a large and interesting library of patterns collected in the community developed <a href="http://golly.sourceforge.net/">Golly software package</a>.</p>
<h2>SmoothLife</h2>
<p>Now, if you’ve been programming for any reasonable length of time you’ve probably come across the Game of Life at least a couple of times before and so all the stuff above is nothing new.  However, a few weeks ago I saw an incredibly awesome video on reddit which inspired me to write this post:</p>
<p><span><iframe width="840" height="473" src="https://www.youtube.com/embed/KJe9H6qS82I?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation allow-popups-to-escape-sandbox"></iframe></span></p>
<p>This video is of a certain generalization of Conway’s Game of Life to smooth spaces proposed by Stephan Rafler:</p>
<p>S. Rafler, “<a href="http://arxiv.org/abs/1111.1567">Generalization of Conway’s “Game of Life” to a continuous domain – SmoothLife</a>” (2011) Arxiv: 1111.1567</p>
<p>You can read this paper for yourself, but I’ll also summarize the key concepts here.  Basically, there are two main ideas in Rafler’s generalization:  First, the infinite grid of cells is replaced with an `effective grid’ that is obtained by averaging over a disk.  Second, the transition functions are replaced by a series of differential equations derived from a smooth interpolation of the rules for the discrete Game of Life.</p>
<h3>Effective Grids</h3>
<p>To explain how an `effective grid’ works, first consider what would happen if we replaced the infinite discrete grid in the game of life with a time-dependent continuous real scalar field, <img src="https://s0.wp.com/latex.php?latex=f+%3A+%5Cmathbb%7BR%7D%5E2+%5Ctimes+%5Cmathbb%7BR%7D+%5Cto+%5Cmathbb%7BR%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=f+%3A+%5Cmathbb%7BR%7D%5E2+%5Ctimes+%5Cmathbb%7BR%7D+%5Cto+%5Cmathbb%7BR%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=f+%3A+%5Cmathbb%7BR%7D%5E2+%5Ctimes+%5Cmathbb%7BR%7D+%5Cto+%5Cmathbb%7BR%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="f : \mathbb{R}^2 \times \mathbb{R} \to \mathbb{R}"/> on the plane.  Now here is the trick:  Instead of thinking of this is an infinite grid of infinitesimal cells, we give the cells a small — but finite! — length.  To do this, pick any small positive real number <em>h</em> which will act as the radius of a single cell (ie “the Planck length” for the simulation).  Then we define the state of the `<em>effective cell</em>‘ at a point <em>x</em> as the average of the field over a radius <em>h</em> neighborhood around x, (which we call M<em>(x,t)</em> following the conventions in Rafler’s paper):</p>
<p><img src="https://s0.wp.com/latex.php?latex=M%28x%2C+t%29+%3D+%5Cfrac%7B1%7D%7B%5Cpi+h%5E2%7D+%5Cint+%5Climits_%7B0+%5Cleq+%7Cy%7C+%5Cleq+h%7D+f%28x-y%2Ct%29+dy&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M%28x%2C+t%29+%3D+%5Cfrac%7B1%7D%7B%5Cpi+h%5E2%7D+%5Cint+%5Climits_%7B0+%5Cleq+%7Cy%7C+%5Cleq+h%7D+f%28x-y%2Ct%29+dy&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=M%28x%2C+t%29+%3D+%5Cfrac%7B1%7D%7B%5Cpi+h%5E2%7D+%5Cint+%5Climits_%7B0+%5Cleq+%7Cy%7C+%5Cleq+h%7D+f%28x-y%2Ct%29+dy&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="M(x, t) = \frac{1}{\pi h^2} \int \limits_{0 \leq |y| \leq h} f(x-y,t) dy"/></p>
<p>Now for each cell, we also want to compute the effective “number of cells” in its neighborhood.  To do this, we use the same averaging process, only over a larger annulus centered at <em>x</em>. By analogy to the rules in the original GoL, a reasonable value for the outer radius is about 3<em>h. </em>Again, following Rafler’s conventions we call this quantity N<em>(x,t)</em>:</p>
<p><img src="https://s0.wp.com/latex.php?latex=N%28x%2C+t%29+%3D+%5Cfrac%7B1%7D%7B8+%5Cpi+h%5E2%7D+%5Cint+%5Climits_%7Bh+%5Cleq+%7Cy%7C+%5Cleq+3+h%7D+f%28x-y%2Ct%29+dy&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=N%28x%2C+t%29+%3D+%5Cfrac%7B1%7D%7B8+%5Cpi+h%5E2%7D+%5Cint+%5Climits_%7Bh+%5Cleq+%7Cy%7C+%5Cleq+3+h%7D+f%28x-y%2Ct%29+dy&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=N%28x%2C+t%29+%3D+%5Cfrac%7B1%7D%7B8+%5Cpi+h%5E2%7D+%5Cint+%5Climits_%7Bh+%5Cleq+%7Cy%7C+%5Cleq+3+h%7D+f%28x-y%2Ct%29+dy&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="N(x, t) = \frac{1}{8 \pi h^2} \int \limits_{h \leq |y| \leq 3 h} f(x-y,t) dy"/></p>
<p>To illustrate how these neighborhoods fit together, I made a small figure:</p>
<p><a href="https://0fps.net/wp-content/uploads/2012/11/neighborhoods1.png"><img data-attachment-id="879" data-permalink="https://0fps.net/2012/11/19/conways-game-of-life-for-curved-surfaces-part-1/neighborhoods-2/" data-orig-file="https://0fps.net/wp-content/uploads/2012/11/neighborhoods1.png" data-orig-size="221,221" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;}" data-image-title="neighborhoods" data-image-description="" data-image-caption="" data-medium-file="https://0fps.net/wp-content/uploads/2012/11/neighborhoods1.png?w=221" data-large-file="https://0fps.net/wp-content/uploads/2012/11/neighborhoods1.png?w=221" tabindex="0" role="button" title="neighborhoods" alt="" src="https://0fps.net/wp-content/uploads/2012/11/neighborhoods1.png?w=221&amp;h=221" height="221" width="221" srcset="https://0fps.net/wp-content/uploads/2012/11/neighborhoods1.png 221w, https://0fps.net/wp-content/uploads/2012/11/neighborhoods1.png?w=150&amp;h=150 150w" sizes="(max-width: 221px) 85vw, 221px"/></a></p>
<p>Now there are two things to notice about <em>M</em> and <em>N</em>:</p>
<ol>
<li>They are invariant under continuous shifts.</li>
<li>They are invariant under rotations.</li>
</ol>
<p>This means that if we define the state of our system in terms of these quantities, the resulting dynamics should also be invariant under rotations and shifts!  (Note:  These quantities are NOT invariant under scaling, since they are dependent on the choice of <em>h</em>.)</p>
<h3>Smooth Transition Functions</h3>
<p>Of course getting rid of the grid is only the first step towards a smooth version of Life.  The second (and more difficult) part is that we also need to come up with a generalization of the rules for the game of life that works for continuous values.  There are of course many ways to do this, and if you’ve taken a course on real analysis you may <a href="http://en.wikipedia.org/wiki/Mollifier">already have some idea on how to do this.</a>  However, for the sake of exposition, let’s try to follow along Rafler’s original derivation.</p>
<p>As a starting point, let’s first write the rules for the regular discrete Game of Life in a different way.  By some abuse of notation, suppose that our field <em>f </em> was a discrete grid (ie <img src="https://s0.wp.com/latex.php?latex=f%3A+%5Cmathbb%7BZ%7D%5E3+%5Cto+%5C%7B+0%2C+1+%5C%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=f%3A+%5Cmathbb%7BZ%7D%5E3+%5Cto+%5C%7B+0%2C+1+%5C%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=f%3A+%5Cmathbb%7BZ%7D%5E3+%5Cto+%5C%7B+0%2C+1+%5C%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="f: \mathbb{Z}^3 \to \{ 0, 1 \}"/>) and that <em>N, M, </em>give the state of each cell and the number of live cells in the 1-radius <a href="http://en.wikipedia.org/wiki/Moore_neighborhood">Moore neighborhood</a>.  Then we could describe the rules of Conway’s Game of Life using the equation:</p>
<p><img src="https://s0.wp.com/latex.php?latex=f%28x%2C+t%2B1%29+%3D+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=f%28x%2C+t%2B1%29+%3D+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=f%28x%2C+t%2B1%29+%3D+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="f(x, t+1) = S(N(x,t), M(x,t))"/></p>
<p>Where <em>S </em>represents the <a href="http://en.wikipedia.org/wiki/Cellular_automaton">transition function</a> of the Game of Life, and is defined to be:</p>
<p><img src="https://s0.wp.com/latex.php?latex=S%28N%2CM%29+%3D+%5Cleft+%5C%7B+%5Cbegin%7Barray%7D%7Bcc%7D+1+%26+%5Cmathrm%7Bif+%7D+%5C%3A+3+-+M+%5Cleq+N+%5C%3A+%5Cmathrm%7B+and+%7D%5C%3A+N+%5Cleq+3+%5C%5C+0+%26+%5Cmathrm%7Botherwise%7D+%5Cend%7Barray%7D+%5Cright.&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=S%28N%2CM%29+%3D+%5Cleft+%5C%7B+%5Cbegin%7Barray%7D%7Bcc%7D+1+%26+%5Cmathrm%7Bif+%7D+%5C%3A+3+-+M+%5Cleq+N+%5C%3A+%5Cmathrm%7B+and+%7D%5C%3A+N+%5Cleq+3+%5C%5C+0+%26+%5Cmathrm%7Botherwise%7D+%5Cend%7Barray%7D+%5Cright.&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=S%28N%2CM%29+%3D+%5Cleft+%5C%7B+%5Cbegin%7Barray%7D%7Bcc%7D+1+%26+%5Cmathrm%7Bif+%7D+%5C%3A+3+-+M+%5Cleq+N+%5C%3A+%5Cmathrm%7B+and+%7D%5C%3A+N+%5Cleq+3+%5C%5C+0+%26+%5Cmathrm%7Botherwise%7D+%5Cend%7Barray%7D+%5Cright.&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="S(N,M) = \left \{ \begin{array}{cc} 1 &amp; \mathrm{if } \: 3 - M \leq N \: \mathrm{ and }\: N \leq 3 \\ 0 &amp; \mathrm{otherwise} \end{array} \right."/></p>
<p>Since <em>S </em>is a function of two variables, we can graph it by letting the x-axis be the number cells in the neighborhood and the y-axis be the state of the cell:</p>
<figure data-shortcode="caption" id="attachment_878" aria-describedby="caption-attachment-878"><a href="https://0fps.net/wp-content/uploads/2012/11/discrete_transition.png"><img data-attachment-id="878" data-permalink="https://0fps.net/2012/11/19/conways-game-of-life-for-curved-surfaces-part-1/discrete_transition/" data-orig-file="https://0fps.net/wp-content/uploads/2012/11/discrete_transition.png" data-orig-size="1119,284" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;}" data-image-title="discrete_transition" data-image-description="" data-image-caption="&lt;p&gt;Plot of state transition for GoL. Y-axis is N, X-axis is M, red=alive, blue=dead.&lt;/p&gt;
" data-medium-file="https://0fps.net/wp-content/uploads/2012/11/discrete_transition.png?w=300" data-large-file="https://0fps.net/wp-content/uploads/2012/11/discrete_transition.png?w=840" tabindex="0" role="button" title="discrete_transition" alt="" src="https://0fps.net/wp-content/uploads/2012/11/discrete_transition.png?w=840" srcset="https://0fps.net/wp-content/uploads/2012/11/discrete_transition.png?w=496&amp;h=126 496w, https://0fps.net/wp-content/uploads/2012/11/discrete_transition.png?w=993&amp;h=252 993w, https://0fps.net/wp-content/uploads/2012/11/discrete_transition.png?w=150&amp;h=38 150w, https://0fps.net/wp-content/uploads/2012/11/discrete_transition.png?w=300&amp;h=76 300w, https://0fps.net/wp-content/uploads/2012/11/discrete_transition.png?w=768&amp;h=195 768w" sizes="(max-width: 500px) 85vw, 500px"/></a><figcaption id="caption-attachment-878">Plot of state transition for GoL. Y-axis is N, X-axis is M, red=alive, blue=dead.</figcaption></figure>
<p>Now given such a representation, our task is to `smooth out’ <em>S</em> somehow.  Again to make things consistent with Rafler, we first linearly rescale <em>N, M</em> so that they are in the range [0,1] (instead of from [0,9), [0,2) respectively).  Our goal is to build up a smooth approximation to <em>S </em>using <a href="http://en.wikipedia.org/wiki/Sigmoid_function">sigmoid functions</a> to represent state transitions and thresholding (this is kind of like how <a href="http://en.wikipedia.org/wiki/Artificial_neuron#Types_of_transfer_functions">artificial neural networks</a> approximate discrete logical functions).  Of course the term `sigmoid’ is not very precise since a sigmoid can be any function which is the integral of a <a href="http://en.wikipedia.org/wiki/Bump_function">bump</a>.   Therefore, to make things concrete (and again stay consistent with Rafler’s paper) we will use the logistic sigmoid:</p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Csigma%28x%2Ca%29+%3D+%5Cfrac%7B1%7D%7B1+%2B+%5Cexp%28-%5Cfrac%7B4%7D%7B%5Calpha%7D+%28x-a%29%29%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Csigma%28x%2Ca%29+%3D+%5Cfrac%7B1%7D%7B1+%2B+%5Cexp%28-%5Cfrac%7B4%7D%7B%5Calpha%7D+%28x-a%29%29%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Csigma%28x%2Ca%29+%3D+%5Cfrac%7B1%7D%7B1+%2B+%5Cexp%28-%5Cfrac%7B4%7D%7B%5Calpha%7D+%28x-a%29%29%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\sigma(x,a) = \frac{1}{1 + \exp(-\frac{4}{\alpha} (x-a))}"/></p>
<p>It is a bit easier to understand what <img src="https://s0.wp.com/latex.php?latex=%5Csigma%28x%2Ca%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Csigma%28x%2Ca%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Csigma%28x%2Ca%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\sigma(x,a)"/> does if we plot it, taking <img src="https://s0.wp.com/latex.php?latex=%5Calpha%3D4%2C+a%3D1&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Calpha%3D4%2C+a%3D1&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Calpha%3D4%2C+a%3D1&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\alpha=4, a=1"/>:</p>
<figure><a href="http://en.wikipedia.org/wiki/File:Logistic-curve.svg"><img title="Logistic curve" alt="Sigmoid function" src="https://i0.wp.com/upload.wikimedia.org/wikipedia/commons/thumb/8/88/Logistic-curve.svg/600px-Logistic-curve.svg.png" height="240" width="360"/></a><figcaption>Plot of the logistic sigmoid <img src="https://s0.wp.com/latex.php?latex=%5Csigma%28x%2C0%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" alt="\sigma(x,0)"/> from x = -6 to 6. Image (c) Wikipedia 2008. Author Geoff Richards.</figcaption></figure>
<p>Intuitively, <img src="https://s0.wp.com/latex.php?latex=%5Csigma%28x%2Ca%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Csigma%28x%2Ca%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Csigma%28x%2Ca%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\sigma(x,a)"/> smoothly goes to 0 if <em>x </em>is less than <em>a</em>, and goes to 1 if <em>x </em> is greater than <em>a</em>.  The parameter <img src="https://s0.wp.com/latex.php?latex=%5Calpha&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Calpha&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Calpha&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\alpha"/> determines how quickly the sigmoid `steps’ from 0 to 1, while the parameter <em>a</em> shifts the sigmoid. Using a sigmoid, we can represent 0/1, alive/dead state of a cell in the effective field by thresholding:</p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Cmathrm%7Balive%7D%28x%2Ct%29+%5Capprox+%5Csigma%28M%28x%2Ct%29%2C+0.5%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cmathrm%7Balive%7D%28x%2Ct%29+%5Capprox+%5Csigma%28M%28x%2Ct%29%2C+0.5%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cmathrm%7Balive%7D%28x%2Ct%29+%5Capprox+%5Csigma%28M%28x%2Ct%29%2C+0.5%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\mathrm{alive}(x,t) \approx \sigma(M(x,t), 0.5)"/></p>
<p>The idea is that we think of effective field values greater than 0.5 as a live, and those less than 0.5 as dead.  We can also adapt this idea to smoothly switch between any two different values depending on whether a cell is alive or dead:</p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Csigma_m%28a%2Cb%29+%3D+a+%281+-+%5Csigma%28m%2C0.5%29%29+%2B+b+%5Csigma%28m%2C0.5%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Csigma_m%28a%2Cb%29+%3D+a+%281+-+%5Csigma%28m%2C0.5%29%29+%2B+b+%5Csigma%28m%2C0.5%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Csigma_m%28a%2Cb%29+%3D+a+%281+-+%5Csigma%28m%2C0.5%29%29+%2B+b+%5Csigma%28m%2C0.5%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\sigma_m(a,b) = a (1 - \sigma(m,0.5)) + b \sigma(m,0.5)"/></p>
<p>The idea is that <img src="https://s0.wp.com/latex.php?latex=%5Csigma_m&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Csigma_m&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Csigma_m&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\sigma_m"/> selects between <em>a</em> and <em>b</em> depending on whether the cell is dead or alive respectively.  The other thing we will need is a way to smoothly threshold an interval.  Fortunately, we can also do this using <img src="https://s0.wp.com/latex.php?latex=%5Csigma&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Csigma&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Csigma&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\sigma"/>.  For example, we could define:</p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Csigma_n%28a%2C+b%29+%3D+%5Csigma%28n%2Ca%29+%281+-+%5Csigma%28n%2Cb%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Csigma_n%28a%2C+b%29+%3D+%5Csigma%28n%2Ca%29+%281+-+%5Csigma%28n%2Cb%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Csigma_n%28a%2C+b%29+%3D+%5Csigma%28n%2Ca%29+%281+-+%5Csigma%28n%2Cb%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\sigma_n(a, b) = \sigma(n,a) (1 - \sigma(n,b))"/></p>
<figure data-shortcode="caption" id="attachment_876" aria-describedby="caption-attachment-876"><a href="https://0fps.net/wp-content/uploads/2012/11/bisigmoid.png"><img data-attachment-id="876" data-permalink="https://0fps.net/2012/11/19/conways-game-of-life-for-curved-surfaces-part-1/bisigmoid/" data-orig-file="https://0fps.net/wp-content/uploads/2012/11/bisigmoid.png" data-orig-size="812,612" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;}" data-image-title="bisigmoid" data-image-description="" data-image-caption="&lt;p&gt;Plot of sigmoid interval [0.25, 0.75]&lt;/p&gt;
" data-medium-file="https://0fps.net/wp-content/uploads/2012/11/bisigmoid.png?w=300" data-large-file="https://0fps.net/wp-content/uploads/2012/11/bisigmoid.png?w=812" tabindex="0" role="button" title="bisigmoid" alt="" src="https://0fps.net/wp-content/uploads/2012/11/bisigmoid.png?w=300&amp;h=226" height="226" width="300" srcset="https://0fps.net/wp-content/uploads/2012/11/bisigmoid.png?w=300 300w, https://0fps.net/wp-content/uploads/2012/11/bisigmoid.png?w=600 600w, https://0fps.net/wp-content/uploads/2012/11/bisigmoid.png?w=150 150w" sizes="(max-width: 300px) 85vw, 300px"/></a><figcaption id="caption-attachment-876">Plot of <img src="https://s0.wp.com/latex.php?latex=%5Csigma_n%280.25%2C+0.75%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" alt="\sigma_n(0.25, 0.75)"/> for <em>n</em>=0 to 1</figcaption></figure>
<p>Putting it all together, let’s now make a state transition function which selects the corresponding interval based on whether the state of the cell is currently alive or dead:</p>
<p><img src="https://s0.wp.com/latex.php?latex=S%28n%2C+m%29+%3D+%5Csigma_n%28%5Csigma_m%28b_1%2C+b_2%29%2C+%5Csigma_m%28d_1%2C+d_2%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=S%28n%2C+m%29+%3D+%5Csigma_n%28%5Csigma_m%28b_1%2C+b_2%29%2C+%5Csigma_m%28d_1%2C+d_2%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=S%28n%2C+m%29+%3D+%5Csigma_n%28%5Csigma_m%28b_1%2C+b_2%29%2C+%5Csigma_m%28d_1%2C+d_2%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="S(n, m) = \sigma_n(\sigma_m(b_1, b_2), \sigma_m(d_1, d_2))"/></p>
<p>Where <img src="https://s0.wp.com/latex.php?latex=%5Bb_1%2C+d_1%5D%2C+%5Bb_2%2C+d_2%5D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Bb_1%2C+d_1%5D%2C+%5Bb_2%2C+d_2%5D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Bb_1%2C+d_1%5D%2C+%5Bb_2%2C+d_2%5D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="[b_1, d_1], [b_2, d_2]"/> are a pair of intervals which are selected based on user specified parameters.  Based on the game of life, a reasonable set of choices should be <img src="https://s0.wp.com/latex.php?latex=b_1+%5Capprox+%5Cfrac%7B2%7D%7B8%7D%2C+b_2+%5Capprox+d_1+%5Capprox+d_2+%5Capprox+%5Cfrac%7B3%7D%7B8%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=b_1+%5Capprox+%5Cfrac%7B2%7D%7B8%7D%2C+b_2+%5Capprox+d_1+%5Capprox+d_2+%5Capprox+%5Cfrac%7B3%7D%7B8%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=b_1+%5Capprox+%5Cfrac%7B2%7D%7B8%7D%2C+b_2+%5Capprox+d_1+%5Capprox+d_2+%5Capprox+%5Cfrac%7B3%7D%7B8%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="b_1 \approx \frac{2}{8}, b_2 \approx d_1 \approx d_2 \approx \frac{3}{8}"/>, which if plotted gives a chart that looks something like this:</p>
<p><a href="https://0fps.net/wp-content/uploads/2012/11/smoothlife.png"><img data-attachment-id="882" data-permalink="https://0fps.net/2012/11/19/conways-game-of-life-for-curved-surfaces-part-1/smoothlife/" data-orig-file="https://0fps.net/wp-content/uploads/2012/11/smoothlife.png" data-orig-size="812,612" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;}" data-image-title="smoothlife" data-image-description="" data-image-caption="" data-medium-file="https://0fps.net/wp-content/uploads/2012/11/smoothlife.png?w=300" data-large-file="https://0fps.net/wp-content/uploads/2012/11/smoothlife.png?w=812" tabindex="0" role="button" loading="lazy" title="smoothlife" alt="" src="https://0fps.net/wp-content/uploads/2012/11/smoothlife.png?w=840" srcset="https://0fps.net/wp-content/uploads/2012/11/smoothlife.png?w=500&amp;h=376 500w, https://0fps.net/wp-content/uploads/2012/11/smoothlife.png?w=150&amp;h=113 150w, https://0fps.net/wp-content/uploads/2012/11/smoothlife.png?w=300&amp;h=226 300w, https://0fps.net/wp-content/uploads/2012/11/smoothlife.png?w=768&amp;h=579 768w, https://0fps.net/wp-content/uploads/2012/11/smoothlife.png 812w" sizes="(max-width: 500px) 85vw, 500px"/></a></p>
<p>This is the transition function for SmoothLife as defined by Rafler.  The squishing of this plot relative to the original plot is just a side effect of rescaling the axes to the unit interval, but even so the similarity is unmistakable.  The only thing left is to pick the value of <img src="https://s0.wp.com/latex.php?latex=%5Calpha&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Calpha&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Calpha&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\alpha"/>.  In the original paper on SmoothLife, Rafler allows for two different values of <img src="https://s0.wp.com/latex.php?latex=%5Calpha&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Calpha&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Calpha&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\alpha"/>; <img src="https://s0.wp.com/latex.php?latex=%5Calpha_n%2C+%5Calpha_m&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Calpha_n%2C+%5Calpha_m&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Calpha_n%2C+%5Calpha_m&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\alpha_n, \alpha_m"/> for their appearance in <img src="https://s0.wp.com/latex.php?latex=%5Csigma_n%2C+%5Csigma_m&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Csigma_n%2C+%5Csigma_m&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Csigma_n%2C+%5Csigma_m&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\sigma_n, \sigma_m"/> respectively.  Along with the bounds for the the life/death intervals <img src="https://s0.wp.com/latex.php?latex=b_1%2C+b_2%2C+d_1%2C+d_2&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=b_1%2C+b_2%2C+d_1%2C+d_2&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=b_1%2C+b_2%2C+d_1%2C+d_2&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="b_1, b_2, d_1, d_2"/>, there are 6 total parameters to choose from in building a cellular automaton for SmoothLife.</p>
<h3>Timestepping</h3>
<p>Now, there is still one nagging detail.  I have not yet told you how the time works in this new version of life.  In Rafler’s paper he gives a couple of possibilities.  One simple option is to just do discrete time stepping, for example:</p>
<p><img src="https://s0.wp.com/latex.php?latex=f%28x%2Ct%2B1%29+%3D+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=f%28x%2Ct%2B1%29+%3D+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=f%28x%2Ct%2B1%29+%3D+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="f(x,t+1) = S(N(x,t), M(x,t))"/></p>
<p>However, this has the disadvantage that the time stepping is now discretized, and so it violates the spirit of SmoothLife somewhat.  Another possibility (advocated in Rafler’s paper) is to rewrite this as a differential equation, giving the following smooth update rule:</p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Cfrac%7Bd+f%28x%2Ct%29%7D%7Bdt%7D+%3D+2+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29-1&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cfrac%7Bd+f%28x%2Ct%29%7D%7Bdt%7D+%3D+2+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29-1&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cfrac%7Bd+f%28x%2Ct%29%7D%7Bdt%7D+%3D+2+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29-1&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\frac{d f(x,t)}{dt} = 2 S(N(x,t), M(x,t))-1"/></p>
<p>I found this scheme to give poor results since it tends to diverge whenever the state of a cell is relatively stable (leading to field values outside the range [0,1]). (<strong>UPDATE: </strong>I just got an email from Stephan Rafler, apparently the equation I wrote earlier was wrong.  Also, he recommends that the field values be clamped to [0,1] to keep them from going out of bounds.)  A slightly better method which I extracted from the source code of SmoothLife is the following technique that pushes the state of the effective field towards S exponentially:</p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Cfrac%7Bd+f%28x%2Ct%29%7D%7Bdt%7D%3D+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29-f%28x%2Ct%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cfrac%7Bd+f%28x%2Ct%29%7D%7Bdt%7D%3D+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29-f%28x%2Ct%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cfrac%7Bd+f%28x%2Ct%29%7D%7Bdt%7D%3D+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29-f%28x%2Ct%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\frac{d f(x,t)}{dt}= S(N(x,t), M(x,t))-f(x,t)"/></p>
<p>It is also possible to replace <em>f(x,t)</em> with<em> M(x,t)</em> on the right hand side of the above equations and get similar results.  It is claimed that each of these rules can produce interesting patterns, though personally I’ve only observed the first and last choices actually working…</p>
<h2>Discretizing SmoothLife</h2>
<p>Now that we have the rules for SmoothLife, we need to figure out how to actually implement it, and to do this we need to discretize the field <em>f</em> somehow.  One common way to do this is to apply the <a href="http://en.wikipedia.org/wiki/Galerkin_method">Galerkin method</a>.  The general idea is that for a fixed <em>t,</em> we write <em>f</em> as a weighted sum of simpler basis functions <img src="https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\phi_i"/> (which I will deliberately leave unspecified for now):</p>
<p><img src="https://s0.wp.com/latex.php?latex=f%28x%2Ct%29+%3D+%5Csum+%5Climits_i+w_i+%5Cphi_i%28x%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=f%28x%2Ct%29+%3D+%5Csum+%5Climits_i+w_i+%5Cphi_i%28x%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=f%28x%2Ct%29+%3D+%5Csum+%5Climits_i+w_i+%5Cphi_i%28x%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="f(x,t) = \sum \limits_i w_i \phi_i(x)"/></p>
<p>The undetermined weights <img src="https://s0.wp.com/latex.php?latex=w_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=w_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=w_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="w_i"/> are the degrees of freedom we use to represent <img src="https://s0.wp.com/latex.php?latex=f%28x%2Ct%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=f%28x%2Ct%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=f%28x%2Ct%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="f(x,t)"/>.  For example, we could represent f as a polynomial series expansion, in which case <img src="https://s0.wp.com/latex.php?latex=%5Cphi_i%28x%29+%3D+x%5Ei&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cphi_i%28x%29+%3D+x%5Ei&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cphi_i%28x%29+%3D+x%5Ei&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\phi_i(x) = x^i"/> and the weights would just be the coefficients, <img src="https://s0.wp.com/latex.php?latex=d%5Ei+f%28x%2Ct%29+%2F+d+x%5Ei&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=d%5Ei+f%28x%2Ct%29+%2F+d+x%5Ei&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=d%5Ei+f%28x%2Ct%29+%2F+d+x%5Ei&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="d^i f(x,t) / d x^i"/>.  But there is no reason to stop at polynomials, we could approximate f by whatever functions we find convenient (and later on we’ll discuss a few reasonable choices.)  What does this buy us?  Well if we use a finite number of basis elements, <img src="https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\phi_i"/>, then we can represent our field <em>f</em> as a finite collection of numbers <img src="https://s0.wp.com/latex.php?latex=w_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=w_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=w_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="w_i"/>!  Cool!  So, how do we use this in our simulation?</p>
<p>Well given that <img src="https://s0.wp.com/latex.php?latex=f%28x%2Ct%29+%3D+%5Csum+w_i+%5Cphi_i%28x%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=f%28x%2Ct%29+%3D+%5Csum+w_i+%5Cphi_i%28x%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=f%28x%2Ct%29+%3D+%5Csum+w_i+%5Cphi_i%28x%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="f(x,t) = \sum w_i \phi_i(x)"/> at time <em>t</em>, and supposing that at time <em>t</em>+1 we have <img src="https://s0.wp.com/latex.php?latex=f%28x%2Ct%2B1%29+%3D+%5Csum+v_i+%5Cphi_i%28x%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=f%28x%2Ct%2B1%29+%3D+%5Csum+v_i+%5Cphi_i%28x%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=f%28x%2Ct%2B1%29+%3D+%5Csum+v_i+%5Cphi_i%28x%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="f(x,t+1) = \sum v_i \phi_i(x)"/>, all we need to do is solve for the coefficients <img src="https://s0.wp.com/latex.php?latex=v_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=v_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=v_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="v_i"/>.  This could be done (hypothetically) by just plugging in f(x,t), f(x,t+1) into both sides of Rafler’s SmoothLife update equation:</p>
<p><img src="https://s0.wp.com/latex.php?latex=f%28x%2Ct%2B1%29+%3D+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=f%28x%2Ct%2B1%29+%3D+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=f%28x%2Ct%2B1%29+%3D+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="f(x,t+1) = S(N(x,t), M(x,t))"/></p>
<p>To compute <em>M</em> we just plug in <em>f(x,t)</em>:</p>
<p><img src="https://s0.wp.com/latex.php?latex=M%28x%2Ct%29+%3D+%5Cint+%5Climits_%7B%7Cx-y%7C+%5Cleq+h%7D+%5Csum+%5Climits_i+w_i+%5Cphi_i%28x-y%29+dy&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M%28x%2Ct%29+%3D+%5Cint+%5Climits_%7B%7Cx-y%7C+%5Cleq+h%7D+%5Csum+%5Climits_i+w_i+%5Cphi_i%28x-y%29+dy&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=M%28x%2Ct%29+%3D+%5Cint+%5Climits_%7B%7Cx-y%7C+%5Cleq+h%7D+%5Csum+%5Climits_i+w_i+%5Cphi_i%28x-y%29+dy&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="M(x,t) = \int \limits_{|x-y| \leq h} \sum \limits_i w_i \phi_i(x-y) dy"/></p>
<p><img src="https://s0.wp.com/latex.php?latex=%3D+%5Csum+%5Climits_i+w_i+%5Cint+%5Climits_%7B%7Cx-y%7C+%5Cleq+h%7D+%5Cphi_i%28x-y%29+dy&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%3D+%5Csum+%5Climits_i+w_i+%5Cint+%5Climits_%7B%7Cx-y%7C+%5Cleq+h%7D+%5Cphi_i%28x-y%29+dy&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%3D+%5Csum+%5Climits_i+w_i+%5Cint+%5Climits_%7B%7Cx-y%7C+%5Cleq+h%7D+%5Cphi_i%28x-y%29+dy&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="= \sum \limits_i w_i \int \limits_{|x-y| \leq h} \phi_i(x-y) dy"/></p>
<p>And a similar formula holds for <em>N</em> as well.  Therefore, we have the equation:</p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Csum+%5Climits_i+v_i+%5Cphi_i%28x%29+%3D+S+%5Cleft+%28+%5Csum+%5Climits_i+w_i+%5Cint+%5Climits_%7B%7Cy%7C+%5Cleq+h%7D+%5Cphi_i%28x-y%29+dy%2C+%5Csum+%5Climits_i+w_i+%5Cint+%5Climits_%7Bh+%5Cleq+%7Cy%7C+%5Cleq+3h%7D+%5Cphi_i%28x-y%29+dy+%5Cright%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Csum+%5Climits_i+v_i+%5Cphi_i%28x%29+%3D+S+%5Cleft+%28+%5Csum+%5Climits_i+w_i+%5Cint+%5Climits_%7B%7Cy%7C+%5Cleq+h%7D+%5Cphi_i%28x-y%29+dy%2C+%5Csum+%5Climits_i+w_i+%5Cint+%5Climits_%7Bh+%5Cleq+%7Cy%7C+%5Cleq+3h%7D+%5Cphi_i%28x-y%29+dy+%5Cright%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Csum+%5Climits_i+v_i+%5Cphi_i%28x%29+%3D+S+%5Cleft+%28+%5Csum+%5Climits_i+w_i+%5Cint+%5Climits_%7B%7Cy%7C+%5Cleq+h%7D+%5Cphi_i%28x-y%29+dy%2C+%5Csum+%5Climits_i+w_i+%5Cint+%5Climits_%7Bh+%5Cleq+%7Cy%7C+%5Cleq+3h%7D+%5Cphi_i%28x-y%29+dy+%5Cright%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\sum \limits_i v_i \phi_i(x) = S \left ( \sum \limits_i w_i \int \limits_{|y| \leq h} \phi_i(x-y) dy, \sum \limits_i w_i \int \limits_{h \leq |y| \leq 3h} \phi_i(x-y) dy \right)"/></p>
<p>Unfortunately, it is usually not the case that there is an exact solution to this equation.  The underlying reason the above idea may fail is that it might not be possible to represent our solution in the basis functions <img src="https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\phi_i"/> exactly.  So we have to modify the equation somewhat.  Instead of trying to get a perfect solution (which is generally impossible for arbitrary nonlinear PDEs or crazy boundary conditions), we’ll settle for approximating the solution as best as possible.  The way we do this that we seek to find a choice of <img src="https://s0.wp.com/latex.php?latex=w_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=w_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=w_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="w_i"/> which minimizes an <img src="https://s0.wp.com/latex.php?latex=L%5E2&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=L%5E2&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=L%5E2&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="L^2"/> error in some suitable metric.  For example, we could try to solve the following the following optimization problem instead:</p>
<p>Minimize <img src="https://s0.wp.com/latex.php?latex=%5Cint+%28f%28x%2Ct%2B1%29+-+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29%29%5E2+dx&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cint+%28f%28x%2Ct%2B1%29+-+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29%29%5E2+dx&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cint+%28f%28x%2Ct%2B1%29+-+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29%29%5E2+dx&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\int (f(x,t+1) - S(N(x,t), M(x,t)))^2 dx"/></p>
<p>This type of system is sometimes called the <a href="http://en.wikipedia.org/wiki/Weak_formulation">weak formulation</a> of the boundary value problem, and by standard linear algebra arguments finding the solution amounts to doing a <a href="http://en.wikipedia.org/wiki/Projection_%28linear_algebra%29">subspace projection</a>.  In general this could be pretty annoying, but if we suppose that each of our <img src="https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\phi_i"/> were <a href="http://en.wikipedia.org/wiki/Orthonormal_basis">orthonormal</a> — that is,</p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Cint+%5Cphi_i%28x%29+%5Cphi_j%28x%29+dx+%3D+%5Cleft+%5C%7B+%5Cbegin%7Barray%7D%7Bcc%7D+1+%26+%5Cmathrm%7Bif%7D+%5C%3A+i%3Dj+%5C%5C+0+%26+%5Cmathrm%7Botherwise%7D+%5Cend%7Barray%7D+%5Cright.&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cint+%5Cphi_i%28x%29+%5Cphi_j%28x%29+dx+%3D+%5Cleft+%5C%7B+%5Cbegin%7Barray%7D%7Bcc%7D+1+%26+%5Cmathrm%7Bif%7D+%5C%3A+i%3Dj+%5C%5C+0+%26+%5Cmathrm%7Botherwise%7D+%5Cend%7Barray%7D+%5Cright.&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cint+%5Cphi_i%28x%29+%5Cphi_j%28x%29+dx+%3D+%5Cleft+%5C%7B+%5Cbegin%7Barray%7D%7Bcc%7D+1+%26+%5Cmathrm%7Bif%7D+%5C%3A+i%3Dj+%5C%5C+0+%26+%5Cmathrm%7Botherwise%7D+%5Cend%7Barray%7D+%5Cright.&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\int \phi_i(x) \phi_j(x) dx = \left \{ \begin{array}{cc} 1 &amp; \mathrm{if} \: i=j \\ 0 &amp; \mathrm{otherwise} \end{array} \right."/></p>
<p>Then we know that,</p>
<p><img src="https://s0.wp.com/latex.php?latex=v_i+%3D+%5Cint+%5Cphi_i%28x%29+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29+dx&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=v_i+%3D+%5Cint+%5Cphi_i%28x%29+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29+dx&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=v_i+%3D+%5Cint+%5Cphi_i%28x%29+S%28N%28x%2Ct%29%2C+M%28x%2Ct%29%29+dx&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="v_i = \int \phi_i(x) S(N(x,t), M(x,t)) dx"/></p>
<p>and so all we have to do to compute the next state is integrate <em>S(N,M)</em> against each <img src="https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\phi_i"/>.  A similar derivation applies for the smooth time stepping rules as well (modulo a <a href="http://en.wikipedia.org/wiki/Sobolev_space">small technical condition</a> of <img src="https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\phi_i"/> that they must be differentiable).</p>
<h3>Boundary Conditions</h3>
<p>Ok, so we know (at least theoretically) what must be done to discretize the system.  But how can we possibly hope to represent an infinite space using a finite number of basis functions?  One simple solution is that we can make the space finite again by adding a periodicity condition.  That is, let us require that for all <em>x,y</em>:</p>
<p><img src="https://s0.wp.com/latex.php?latex=f%28x%2Cy%29+%3D+f%28+2%5Cpi+%2B+x%2C+2+%5Cpi+%2By%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=f%28x%2Cy%29+%3D+f%28+2%5Cpi+%2B+x%2C+2+%5Cpi+%2By%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=f%28x%2Cy%29+%3D+f%28+2%5Cpi+%2B+x%2C+2+%5Cpi+%2By%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="f(x,y) = f( 2\pi + x, 2 \pi +y)"/></p>
<p>This means that we can parameterize the state of the infinite grid by just describing what happens within the region <img src="https://s0.wp.com/latex.php?latex=%5B0%2C2+%5Cpi%29%5E2&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5B0%2C2+%5Cpi%29%5E2&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5B0%2C2+%5Cpi%29%5E2&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="[0,2 \pi)^2"/>.  This square is compact and so we have at least some hope of being able to approximate a periodic <em>f</em> by some finite number of functions covering this square.</p>
<h3>Sinc Interpolation</h3>
<p>Finally, we come to the point where we must pick a basis in order to go any further.  There is some level at which the particular choice of representative functions <img src="https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cphi_i&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\phi_i"/> is arbitrary and so one could reasonably justify almost any decision.  For example, I could use B-splines, polynomials, sine waves, fractals or whatever I felt like (at least as long as I can integrate it to compute <em>N</em> and <em>M</em>).  What I am going to describe here is by no means the only way to proceed.  For example, in his paper Rafler uses a very simple bilinear expansion in terms of quadrilateral elements to get a decent discretization.  (And if you want the details scroll up and read his write up).</p>
<p>However, because our system is periodic and translationally invariant (although not linear) there is one basis which has at least a somewhat more special status, and that is the Dirichlet or <a href="https://ccrma.stanford.edu/~jos/sasp/Rectangular_Window.html">aliased sinc</a> basis.  Let <em>R</em> be the resolution of a uniform grid, and define:</p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Cmathrm%7Basinc%7D_%7BR%7D%28+x+%29+%3D+%5Cfrac%7B+%5Csin%28+R+x+%2F+2%29+%7D%7B+R+%5Csin%28x+%2F+w%29+%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cmathrm%7Basinc%7D_%7BR%7D%28+x+%29+%3D+%5Cfrac%7B+%5Csin%28+R+x+%2F+2%29+%7D%7B+R+%5Csin%28x+%2F+w%29+%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cmathrm%7Basinc%7D_%7BR%7D%28+x+%29+%3D+%5Cfrac%7B+%5Csin%28+R+x+%2F+2%29+%7D%7B+R+%5Csin%28x+%2F+w%29+%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\mathrm{asinc}_{R}( x ) = \frac{ \sin( R x / 2) }{ R \sin(x / w) }"/></p>
<p>Then we index our basis functions by a pair of indices <img src="https://s0.wp.com/latex.php?latex=0+%5Cleq+i%2Cj+%3C+R&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=0+%5Cleq+i%2Cj+%3C+R&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=0+%5Cleq+i%2Cj+%3C+R&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="0 \leq i,j &lt; R"/> with:</p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Cphi_%7Bi%2Cj%7D%28x%2Cy%29%3D%5Cmathrm%7Basinc%7D_%7BR%7D+%28x-%5Cfrac%7B2%5Cpi+i%7D%7BR%7D%29%5Cmathrm%7Basinc%7D_%7BR%7D%28y-%5Cfrac%7B2%5Cpi+j%7D%7BR%7D%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cphi_%7Bi%2Cj%7D%28x%2Cy%29%3D%5Cmathrm%7Basinc%7D_%7BR%7D+%28x-%5Cfrac%7B2%5Cpi+i%7D%7BR%7D%29%5Cmathrm%7Basinc%7D_%7BR%7D%28y-%5Cfrac%7B2%5Cpi+j%7D%7BR%7D%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cphi_%7Bi%2Cj%7D%28x%2Cy%29%3D%5Cmathrm%7Basinc%7D_%7BR%7D+%28x-%5Cfrac%7B2%5Cpi+i%7D%7BR%7D%29%5Cmathrm%7Basinc%7D_%7BR%7D%28y-%5Cfrac%7B2%5Cpi+j%7D%7BR%7D%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\phi_{i,j}(x,y)=\mathrm{asinc}_{R} (x-\frac{2\pi i}{R})\mathrm{asinc}_{R}(y-\frac{2\pi j}{R})"/>.</p>
<p>It may seem surprising at first, but these basis functions are actually orthogonal.  If you’ve never seen something like this before, please don’t be alarmed!  That definition (which seemed to come out of left field) is really a manifestation of the famous (and often misunderstood) <a href="http://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem">Nyquist sampling theorem</a>.  It basically says that if we write any periodic, band limited function as a sum of sincs:</p>
<p><img src="https://s0.wp.com/latex.php?latex=f%28x%2Cy%29+%3D+%5Csum_%7Bi%3D0%7D%5ER+%5Csum_%7Bj%3D0%7D%5ER+w_%7Bi%2Cj%7D+%5Cphi_%7Bi%2Cj%7D%28x%2Cy%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=f%28x%2Cy%29+%3D+%5Csum_%7Bi%3D0%7D%5ER+%5Csum_%7Bj%3D0%7D%5ER+w_%7Bi%2Cj%7D+%5Cphi_%7Bi%2Cj%7D%28x%2Cy%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=f%28x%2Cy%29+%3D+%5Csum_%7Bi%3D0%7D%5ER+%5Csum_%7Bj%3D0%7D%5ER+w_%7Bi%2Cj%7D+%5Cphi_%7Bi%2Cj%7D%28x%2Cy%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="f(x,y) = \sum_{i=0}^R \sum_{j=0}^R w_{i,j} \phi_{i,j}(x,y)"/></p>
<p>Then the weights <img src="https://s0.wp.com/latex.php?latex=w_%7Bi%2Cj%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=w_%7Bi%2Cj%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=w_%7Bi%2Cj%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="w_{i,j}"/> are just the values of the function at the grid points:</p>
<p><img src="https://s0.wp.com/latex.php?latex=f%28%5Cfrac%7B2+%5Cpi+%7D%7BR%7D+i%2C+%5Cfrac%7B2+%5Cpi%7D%7BR%7D+j%29+%3D+w_%7Bi%2Cj%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=f%28%5Cfrac%7B2+%5Cpi+%7D%7BR%7D+i%2C+%5Cfrac%7B2+%5Cpi%7D%7BR%7D+j%29+%3D+w_%7Bi%2Cj%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=f%28%5Cfrac%7B2+%5Cpi+%7D%7BR%7D+i%2C+%5Cfrac%7B2+%5Cpi%7D%7BR%7D+j%29+%3D+w_%7Bi%2Cj%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="f(\frac{2 \pi }{R} i, \frac{2 \pi}{R} j) = w_{i,j}"/></p>
<p>This means that for any suitably smooth f, we can project it to our basis by just sampling it:</p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Cint+f%28x%2Cy%29+%5Cphi_%7Bi%2Cj%7D%28x%2Cy%29+dx+dy+%5Capprox+f%28i%2Cj%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cint+f%28x%2Cy%29+%5Cphi_%7Bi%2Cj%7D%28x%2Cy%29+dx+dy+%5Capprox+f%28i%2Cj%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cint+f%28x%2Cy%29+%5Cphi_%7Bi%2Cj%7D%28x%2Cy%29+dx+dy+%5Capprox+f%28i%2Cj%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\int f(x,y) \phi_{i,j}(x,y) dx dy \approx f(i,j)"/></p>
<p>This makes our code way simpler, since we can avoid doing some messy numerical integration to get the weights.  Assuming that <em>S(N,M)</em> is smooth enough (which in practice it is), then all we have to do to perform a discrete update is figure out how to compute <em>M(x,y), N(x,y) </em>for any given sinc expansion of <em>f.  </em>In other words, we want to compute:</p>
<p><img src="https://s0.wp.com/latex.php?latex=M%28x%2Cy%29+%3D+%5Cint_%7B%7Cp%5E2+%2B+q%5E2%7C+%5Cleq+h%5E2%7D+f%28x-p%2C+y-q%29+dp+dq&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M%28x%2Cy%29+%3D+%5Cint_%7B%7Cp%5E2+%2B+q%5E2%7C+%5Cleq+h%5E2%7D+f%28x-p%2C+y-q%29+dp+dq&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=M%28x%2Cy%29+%3D+%5Cint_%7B%7Cp%5E2+%2B+q%5E2%7C+%5Cleq+h%5E2%7D+f%28x-p%2C+y-q%29+dp+dq&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="M(x,y) = \int_{|p^2 + q^2| \leq h^2} f(x-p, y-q) dp dq"/></p>
<p>But this is just a convolution <a href="http://en.wikipedia.org/wiki/Convolution">convolution</a> with the <a href="http://en.wikipedia.org/wiki/Indicator_function">indicator function</a> of the <a href="http://en.wikipedia.org/wiki/Unit_sphere#Unit_balls_in_normed_vector_spaces">unit disk</a>:</p>
<p><img src="https://s0.wp.com/latex.php?latex=M%28x%2Cy%2Ct%29+%3D+%5Cint_%7B0%7D%5E%7B2+%5Cpi%7D+%5Cint_%7B0%7D%5E%7B2+%5Cpi%7D+1_%7BB_h%7D%28p%2Cq%29+f%28x-p%2C+y-q%2C+t%29+dp+dq&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M%28x%2Cy%2Ct%29+%3D+%5Cint_%7B0%7D%5E%7B2+%5Cpi%7D+%5Cint_%7B0%7D%5E%7B2+%5Cpi%7D+1_%7BB_h%7D%28p%2Cq%29+f%28x-p%2C+y-q%2C+t%29+dp+dq&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=M%28x%2Cy%2Ct%29+%3D+%5Cint_%7B0%7D%5E%7B2+%5Cpi%7D+%5Cint_%7B0%7D%5E%7B2+%5Cpi%7D+1_%7BB_h%7D%28p%2Cq%29+f%28x-p%2C+y-q%2C+t%29+dp+dq&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="M(x,y,t) = \int_{0}^{2 \pi} \int_{0}^{2 \pi} 1_{B_h}(p,q) f(x-p, y-q, t) dp dq"/></p>
<p>If you know a bit of Fourier analysis, you should know what comes next.  Just take a <a href="http://en.wikipedia.org/wiki/Fourier_transform">Fourier transform</a> and apply the <a href="http://en.wikipedia.org/wiki/Convolution_theorem">convolution theorem</a> to both sides, giving:</p>
<p><img src="https://s0.wp.com/latex.php?latex=%5Chat%7BM%7D%28%5Comega_x%2C%5Comega_y%2Ct%29%3D%5Chat%7B1_%7BB_h%7D%7D%28%5Comega_x%2C%5Comega_y%29%5Chat%7Bf%7D%28%5Comega_x%2C%5Comega_y%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Chat%7BM%7D%28%5Comega_x%2C%5Comega_y%2Ct%29%3D%5Chat%7B1_%7BB_h%7D%7D%28%5Comega_x%2C%5Comega_y%29%5Chat%7Bf%7D%28%5Comega_x%2C%5Comega_y%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Chat%7BM%7D%28%5Comega_x%2C%5Comega_y%2Ct%29%3D%5Chat%7B1_%7BB_h%7D%7D%28%5Comega_x%2C%5Comega_y%29%5Chat%7Bf%7D%28%5Comega_x%2C%5Comega_y%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\hat{M}(\omega_x,\omega_y,t)=\hat{1_{B_h}}(\omega_x,\omega_y)\hat{f}(\omega_x,\omega_y)"/></p>
<p>Which we can actually solve exactly, since the Nyquist theorem implies that <img src="https://s0.wp.com/latex.php?latex=%5Chat%7Bf%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Chat%7Bf%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Chat%7Bf%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\hat{f}"/> is a finite sum. Therefore:</p>
<p><img src="https://s0.wp.com/latex.php?latex=M%28x%2Cy%29%3D%5Csum+%5Climits_%7Bi%3D0%7D%5E%7BR%7D%5Csum+%5Climits_%7Bj%3D0%7D%5E%7BR%7D%5Chat%7B1_%7BB_h%7D%7D%28i%2Cj%29%5Chat%7Bf%7D%28i%2Cj%29e%5E%7B2%5Cpi%5Csqrt%7B-1%7D%28ix%2Bjy%29%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M%28x%2Cy%29%3D%5Csum+%5Climits_%7Bi%3D0%7D%5E%7BR%7D%5Csum+%5Climits_%7Bj%3D0%7D%5E%7BR%7D%5Chat%7B1_%7BB_h%7D%7D%28i%2Cj%29%5Chat%7Bf%7D%28i%2Cj%29e%5E%7B2%5Cpi%5Csqrt%7B-1%7D%28ix%2Bjy%29%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=M%28x%2Cy%29%3D%5Csum+%5Climits_%7Bi%3D0%7D%5E%7BR%7D%5Csum+%5Climits_%7Bj%3D0%7D%5E%7BR%7D%5Chat%7B1_%7BB_h%7D%7D%28i%2Cj%29%5Chat%7Bf%7D%28i%2Cj%29e%5E%7B2%5Cpi%5Csqrt%7B-1%7D%28ix%2Bjy%29%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="M(x,y)=\sum \limits_{i=0}^{R}\sum \limits_{j=0}^{R}\hat{1_{B_h}}(i,j)\hat{f}(i,j)e^{2\pi\sqrt{-1}(ix+jy)}"/></p>
<p>And <a href="http://isi.ssl.berkeley.edu/~tatebe/whitepapers/FT%20of%20Uniform%20Disk.pdf">by a bit of calculus</a>, the Fourier transform of <img src="https://s0.wp.com/latex.php?latex=1_%7BB_h%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=1_%7BB_h%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=1_%7BB_h%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="1_{B_h}"/> can be computed in closed form using Bessel functions.  This means that:</p>
<p><img src="https://s0.wp.com/latex.php?latex=M%28x%2Cy%29%3D%5Csum+%5Climits_%7Bi%2Cj%3D0%7D%5ER+%5Cfrac%7B%5Csqrt%7B3+h%7D%7D%7B4+%5Csqrt%7Bi%5E2%2Bj%5E2%7D%7D+J_1%282+%5Cpi+h+%5Csqrt%7Bi%5E2%2Bj%5E2%7D%29+e%5E%7B2+%5Cpi+%5Csqrt%7B-1%7D%28ix%2Bjy%29%7D%5Cwidehat%7Bf%7D%28i%2Cj%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M%28x%2Cy%29%3D%5Csum+%5Climits_%7Bi%2Cj%3D0%7D%5ER+%5Cfrac%7B%5Csqrt%7B3+h%7D%7D%7B4+%5Csqrt%7Bi%5E2%2Bj%5E2%7D%7D+J_1%282+%5Cpi+h+%5Csqrt%7Bi%5E2%2Bj%5E2%7D%29+e%5E%7B2+%5Cpi+%5Csqrt%7B-1%7D%28ix%2Bjy%29%7D%5Cwidehat%7Bf%7D%28i%2Cj%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=M%28x%2Cy%29%3D%5Csum+%5Climits_%7Bi%2Cj%3D0%7D%5ER+%5Cfrac%7B%5Csqrt%7B3+h%7D%7D%7B4+%5Csqrt%7Bi%5E2%2Bj%5E2%7D%7D+J_1%282+%5Cpi+h+%5Csqrt%7Bi%5E2%2Bj%5E2%7D%29+e%5E%7B2+%5Cpi+%5Csqrt%7B-1%7D%28ix%2Bjy%29%7D%5Cwidehat%7Bf%7D%28i%2Cj%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="M(x,y)=\sum \limits_{i,j=0}^R \frac{\sqrt{3 h}}{4 \sqrt{i^2+j^2}} J_1(2 \pi h \sqrt{i^2+j^2}) e^{2 \pi \sqrt{-1}(ix+jy)}\widehat{f}(i,j)"/></p>
<p>A similar formula for <em>N(x,y,t)</em> can be obtained by writing:</p>
<p><img src="https://s0.wp.com/latex.php?latex=N%28x%2Cy%29+%3D+%5Cint+%281_%7BB_%7B3h%7D%7D+-+1_%7BB_%7Bh%7D%7D%29%28p%2Cq%29+f%28x-p%2Cy-q%2Ct%29+dp+dq&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=N%28x%2Cy%29+%3D+%5Cint+%281_%7BB_%7B3h%7D%7D+-+1_%7BB_%7Bh%7D%7D%29%28p%2Cq%29+f%28x-p%2Cy-q%2Ct%29+dp+dq&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=N%28x%2Cy%29+%3D+%5Cint+%281_%7BB_%7B3h%7D%7D+-+1_%7BB_%7Bh%7D%7D%29%28p%2Cq%29+f%28x-p%2Cy-q%2Ct%29+dp+dq&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="N(x,y) = \int (1_{B_{3h}} - 1_{B_{h}})(p,q) f(x-p,y-q,t) dp dq"/></p>
<p>Putting it all together, let <img src="https://s0.wp.com/latex.php?latex=w%27_%7Bi%2Cj%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=w%27_%7Bi%2Cj%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=w%27_%7Bi%2Cj%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="w&#39;_{i,j}"/> be the new weights for <em>f</em> at time <em>t</em>+1.  Then to do a discrete time step we just set:</p>
<p><img src="https://s0.wp.com/latex.php?latex=S%28N%282+%5Cpi+i+%2FR%2C+2+%5Cpi+j%2FR%29%2C+M%282+%5Cpi+i%2FR%2C+2+%5Cpi+j+%2F+R%29%29+%5Cmapsto+w%27_%7Bi%2Cj%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=S%28N%282+%5Cpi+i+%2FR%2C+2+%5Cpi+j%2FR%29%2C+M%282+%5Cpi+i%2FR%2C+2+%5Cpi+j+%2F+R%29%29+%5Cmapsto+w%27_%7Bi%2Cj%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=S%28N%282+%5Cpi+i+%2FR%2C+2+%5Cpi+j%2FR%29%2C+M%282+%5Cpi+i%2FR%2C+2+%5Cpi+j+%2F+R%29%29+%5Cmapsto+w%27_%7Bi%2Cj%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="S(N(2 \pi i /R, 2 \pi j/R), M(2 \pi i/R, 2 \pi j / R)) \mapsto w&#39;_{i,j}"/></p>
<p>I’ll leave it as an exercise to work out the update rules for the continuous time steps.</p>
<h2>Implementation Details</h2>
<p>Great, so we have some formulas for computing the next time step, but if we do it in a dumb way it is going to be pretty slow.  The reason is that each of the above steps requires summing up all the coefficients of <em>f</em> to calculate <em>M</em> and <em>N</em> at each point, which is going to take linear work with respect to the number of terms in our summation.  Spread out over all the points in the grid, this makes the total update <img src="https://s0.wp.com/latex.php?latex=O%28n%5E2%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=O%28n%5E2%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=O%28n%5E2%29&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="O(n^2)"/>.  However, because the above sums are all Fourier series we can speed this up a lot using a fast Fourier transform.  Basically we precalculate the weights by evaluating the Bessel function at each frequency, then at each time step we Fourier transform f, multiply by the weights, inverse transform and repeat.  Here is what it looks like:</p>
<ul>
<li>Initialize f</li>
<li>Precalculate <img src="https://s0.wp.com/latex.php?latex=%5Cwidehat%7B1_%7BB_h%7D%7D%2C+%5Cwidehat%7B1_%7BB_%7B3h%7D%7D%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cwidehat%7B1_%7BB_h%7D%7D%2C+%5Cwidehat%7B1_%7BB_%7B3h%7D%7D%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cwidehat%7B1_%7BB_h%7D%7D%2C+%5Cwidehat%7B1_%7BB_%7B3h%7D%7D%7D&amp;bg=ffffff&amp;fg=1a1a1a&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\widehat{1_{B_h}}, \widehat{1_{B_{3h}}}"/></li>
<li>For t=1 to n

</li>
</ul>
<p>And that’s it!</p>
<h2>Demo</h2>
<p>If you want to try out SmoothLife yourself in your browser, I made a few jsFiddles which illustrate the basic principle.  Here is a Fourier based implementation that follows the discussion in this article pretty closely:</p>
<p><a href="http://jsfiddle.net/mikola/aj2vq/">http://jsfiddle.net/mikola/aj2vq/</a></p>
<p>I also made a second WebGL/GPU based implementation that uses a discretization similar to that proposed in Rafler’s original paper:</p>
<p><a href="http://jsfiddle.net/mikola/2jenR/">http://jsfiddle.net/mikola/2jenR/</a></p>
<p>You can run either of them in  your browser and try changing the parameters.</p>
<h2>Next Time…</h2>
<p>The stuff in this article is basically background material, and most of it can be found in Rafler’s paper or is already more-or-less documented in the source code for the <a href="http://sourceforge.net/projects/smoothlife/">SmoothLife project on SourceForge</a>.  However, in the sequel I plan to go a bit farther than the basic rules for SmoothLife and tell you how to make a version of SmoothLife for curved surfaces!</p>
	</div><!-- .entry-content -->

	<!-- .entry-footer -->
</article></div>
  </body>
</html>
