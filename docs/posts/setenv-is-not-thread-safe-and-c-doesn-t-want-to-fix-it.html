<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.evanjones.ca/setenv-is-not-thread-safe.html">Original</a>
    <h1>Setenv Is Not Thread Safe and C Doesn&#39;t Want to Fix It</h1>
    
    <div id="readability-page-1" class="page"><div>

<h3>[ 2023-November-19 09:13 ]</h3>
<p>You can&#39;t safely use the C <code>setenv()</code> or <code>unsetenv()</code> functions in a program that uses threads. Those functions modify global state, and can cause other threads calling <code>getenv()</code> to crash. This also causes crashes in other languages that use those C standard library functions, such as Go&#39;s <code>os.Setenv</code> (<a href="https://github.com/golang/go/issues/63567">Go issue</a>) and Rust&#39;s <code>std::env::set_var()</code> (<a href="https://github.com/rust-lang/rust/issues/27970">Rust issue</a>). I ran into this in a Go program, because Go&#39;s built-in DNS resolver can call C&#39;s <code>getaddrinfo()</code>, which uses environment variables. This cost me 2 days to track down and <a href="https://github.com/golang/go/issues/63567">file the Go bug</a>. Sadly, this problem has been known for decades. For example, <a href="https://rachelbythebay.com/w/2017/01/30/env/">an article from January 2017</a> said: &#34;None of this is new, but we do re-discover it roughly every five years. See you in 2022.&#34; This was only one year off! (She wrote <a href="https://rachelbythebay.com/w/2023/10/16/env/">an update in October 2023 after I emailed her about my Go bug.</a>)</p>

<p>This is a flaw in the POSIX standard, which extends the C Standard to allow modifying environment varibles. The most infuriating part is that many people who could influence the standard or maintain the C libraries don&#39;t see this as a problem. The argument is that the specification clearly documents that <code>setenv()</code> cannot be used with threads. Therefore, if someone does this, the crashes are their fault. We should apparently read every function&#39;s specification carefully, not use software written by others, and not use threads. These are unrealistic assumptions in modern software. I think we should instead strive to create APIs that are hard to screw up, and evolve as the ecosystem changes. The C language and standard library continue to play an important role at the base of most software. We either need to figure out how to improve it, or we need to figure out how to abandon it.</p>


<h2>Why is setenv() not thread-safe?</h2>

<p>The biggest problem is that <code>getenv()</code> returns a <code>char*</code>, with no need for applications to free it later. One thread could be using this pointer when another thread changes the same environment variable using <code>setenv()</code> or <code>unsetenv()</code>. The <code>getenv()</code> function is perfect if environment variables never change. For example, for accessing a process&#39;s initial table of environment variables (see the <a href="https://gitlab.com/x86-psABIs/x86-64-ABI">System V ABI: AMD64 Section 3.4.1</a>). It turns out the C Standard only includes <code>getenv()</code>, so according to C, that is exactly how this should work. However, most implementations also follow the POSIX standard (e.g. <a href="https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/">POSIX.1-2017</a>), which extends C to include functions that modify the environment. This means the current <code>getenv()</code> API is problematic.</p>

<p>Even worse, <code>putenv()</code> adds a <code>char*</code> to the set of environment variables. It is explicitly required that if the application modifies the memory after <code>putenv()</code> returns, it modifies the environment variables. This means applications can modify the value passed to <code>putenv()</code> at any time, without any synchronization. FreeBSD used to implement <code>putenv()</code> by copying the value, but it changed it with FreeBSD 7 in 2008, which suggests some programs really do depend on modifying the environment in this fashion (see <a href="https://man.freebsd.org/cgi/man.cgi?query=putenv&amp;sektion=3&amp;format=html">FreeBSD putenv man page</a>).</p>

<p>As a final problem, <code>environ</code> is a NULL-terminated array of pointers (<code>char**</code>) that an application can read and assign to (see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/environ.html">definition in POSIX.1-2017</a>). This is how applications can iterate over all environment variables. Accesses to this array are not thread-safe. However, in my experience many fewer applications use this than <code>getenv()</code> and <code>setenv()</code>. However, this does cause some libraries to not maintain the set of environment variables in a thread-safe way, since they directly update this table.</p>


<h2>Environment variable implementations</h2>

<p>Implementations need to choose what do do when an application overwrites an existing variable. I looked at glibc, musl, Solaris/Illumos, and FreeBSD/Apple&#39;s C standard libraries, and they make the following choices:</p>

<ul>
<li><em>Never free environment variables</em> (glibc, Solaris/Illumos): Calling <code>setenv()</code> repeatedly is effectively a memory leak. However, once a value is returned from <code>getenv()</code>, it is immutable and can be used by threads safely.</li>
<li><em>Free the environment variables</em> (musl, FreeBSD/Apple): Using the pointer returned by <code>getenv()</code> after another thread calls <code>setenv()</code> can crash.</li>
</ul>

<p>A second problem is ensuring the set of environment variables is updated in a thread-safe fashion. This is what causes crashes in glibc. glibc uses an array to hold pointers to the <code>&#34;NAME=value&#34;</code> strings. It holds a lock in <code>setenv()</code> when changing this array, but not in <code>getenv()</code>. If a thread calling <code>setenv()</code> needs to resize the array of pointers, it copies the values to a new array and frees the previous one. This can cause other threads executing <code>getenv()</code> to crash, since they are now iterating deallocated memory. This is particularly annoying since glibc already leaks environment variables, and holds a lock in <code>setenv()</code>. All it needs to do is hold the lock inside <code>getenv()</code>, and it would no longer crash. This would make <code>getenv()</code> slightly slower. However, <code>getenv()</code> already uses a linear search of the array, so performance does not appear to be a concern. More sophisticated implementations are possible if this is a problem, such as <a href="https://src.illumos.org/source/xref/illumos-gate/usr/src/lib/libc/port/gen/getenv.c">Solaris/Illumos&#39;s lock-free implementation</a>.</p>


<h2>Why do programs use environment variables?</h2>

<p>Environment variables useful for configuring shared libraries or language runtimes that are included in other programs. This allows users to change the configuration, without program authors needing to explicitly pass the configuration in. One alternative is command line flags, which requires programs to parse them and pass them in to the libraries. Another alternative are configuration files, which then need some <em>other</em> way to disable or configure, to be able to test new configurations. Environment variables are a simple solution. AS a result, <em>many</em> libraries call getenv() (see a partial list below).</p>

<p>Since many libraries are configured through environment variables, a program may need to change these variables to configure the libraries it uses. This is common at application startup. This causes programs to need to call <code>setenv()</code>. Given this issue, it seems like libraries should also provide a way to explicitly configure any settings, and avoid using environment variables.</p>


<h2>We should fix this problem, and we can</h2>

<p>In my opinion, it is rediculous that this has been a known problem for so long. It has wasted thousands of hours of people&#39;s time, either debugging the problems, or debating what to do about it. We know how to fix the problem. First, we can make a thread-safe implementation, like Illumos/Solaris. This has some limitations: it leaks memory in <code>setenv()</code>, and is still unsafe if a program uses <code>putenv()</code> or the <code>environ</code> variable. However, this is an improvement over the current Linux and Apple implementations. The second solution is to add new APIs to get one and get all environment variables that are thread-safe by design, like Microsoft&#39;s <code><a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/getenv-s-wgetenv-s?view=msvc-170">getenv_s()</a></code> (see below for the controversy around C11&#39;s &#34;Annex K&#34;). My preferred solution would be to do both. This would reduce the chances of hitting this problem for existing programs and libraries, and also provide a path to avoid the problems entirely for new code or languages like Go and Rust. My rough idea would be the following:</p>

<ul>
<li>Add a function to copy one single environment variable to a user-specified buffer, similar to <code>getenv_s()</code>.</li>
<li>Add a thread-safe API to iterate over all environment variables, or to copy all variables out.</li>
<li>Mark <code>getenv()</code> as deprecated, recommending the new thread-safe <code>getenv()</code> function instead.</li>
<li>Mark <code>putenv()</code> as deprecated, recommending <code>setenv()</code> instead.</li>
<li>Mark <code>environ</code> as deprecated, recommending environment variable functions instead.</li>
<li>Update the implementation of environment varibles to be thread-safe. This requires leaking memory if <code>getenv()</code> is used on a variable, but we can detect if the old functions are used, and only leak memory in that case. This means programs written in other languages will avoid these problems as soon as their runtimes are updated.</li>
<li>Update the C and POSIX standards to require the above changes.</li>
</ul>

<p>This would be progress.</p>


<h2>The getenv_s / C Standard Annex K controversy</h2>

<p>Microsoft provides <code><a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/getenv-s-wgetenv-s?view=msvc-170">getenv_s()</a></code>, which copies the environment variable into a caller-provided buffer. This is easy to make thread-safe by holding a read lock while copying the variable. After the function returns, future changes to the environment have no effect. This is included in the C11 Standard as Annex K &#34;Bounds Checking Interfaces&#34;. The C standard Annexes are optional features. This Annex includes new functions intended to make it harder to make mistakes with buffers that are the wrong size. The first draft of this extension was published in 2003. This is when Microsoft was focusing on <a href="https://en.wikipedia.org/wiki/Trustworthy_computing">&#34;Trustworthy Computing&#34; after a January 2002 memo from Bill Gates</a>. Basically, Windows wasn&#39;t designed to be connected to the Internet, and now that it was, people were finding many security problems. Lots of them were caused by buffer handling mistakes. Microsoft developed new versions of a number of problematic functions, and added checks to the Visual C++ compiler to warn about using the old ones. They then attempted to standardize these functions. My understanding is the people responsible for the Unix POSIX standards did not like the design of these functions, so they refused to implement them. For more details, see <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1967.htm">Field Experience With Annex K published in September 2015</a>, <a href="https://stackoverflow.com/a/50724865/413438">Stack Overflow: Why didn&#39;t glibc implement _s functions? updated March 2023</a>, and <a href="https://www.openwall.com/lists/musl/2019/02/27/15">Rich Felker of musl on both technical and social reasons for not implementing Annex K from February 2019</a>.</p>

<p>I haven&#39;t looked at the rest of the functions, but having spent way too long looking at <code>getenv()</code>, the general idea of <code>getenv_s()</code> seems like a good idea to me. Standardizing this would help avoid this problem.</p>


<h2>Incomplete list of common environment variables</h2>

<p>This is a list of some uses of environment variables from fairly widely used libraries and services. This shows that environment variables are pretty widely used.</p>

<h3>Cloud Provider Credentials and Services</h3>

<ul>
<li><a href="https://github.com/aws/aws-sdk-cpp/blob/main/docs/Credentials_Providers.md">AWS&#39;s SDKs for credentials (e.g. AWS_ACCESS_KEY_ID)</a></li>
<li><a href="https://cloud.google.com/docs/authentication/application-default-credentials">Google Cloud Application Default Credentials (e.g. GOOGLE_APPLICATION_CREDENTIALS)</a></li>
<li><a href="https://learn.microsoft.com/en-us/azure/developer/java/sdk/identity-azure-hosted-auth#default-azure-credential">Microsoft Azure Default Azure Credential (e.g. AZURE_CLIENT_ID)</a></li>
<li><a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-runtime">AWS&#39;s Lambda serverless product</a>: sets a large number of variables like AWS_REGION, AWS_LAMBDA_FUNCTION_NAME, and credentials like AWS_SECRET_ACCESS_KEY</li>
<li><a href="https://cloud.google.com/run/docs/container-contract#env-vars">Google Cloud Run serverless product</a>: configuration like PORT, K_SERVICE, K_REVISION</li>
<li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#discovering-services">Kubernetes service discovery:</a> Defines variables SERVICE_NAME_HOST and SERVICE_NAME_PORT.</li>
</ul>



<h3>Third-party C/C++ Libraries</h3>

<ul>
<li><a href="https://opentelemetry.io/docs/specs/otel/configuration/sdk-environment-variables/">OpenTelemetry</a>: Metrics and tracing. Many environment variables like OTEL_SERVICE_NAME and OTEL_RESOURCE_ATTRIBUTES.</li>
<li><a href="https://www.openssl.org/docs/man3.0/man7/openssl-env.html">OpenSSL</a>: many configurable variables like HTTPS_PROXY, OPENSSL_CONF, OPENSSL_ENGINES.</li>
<li><a href="https://boringssl.googlesource.com/boringssl/+/refs/heads/master/tool/server.cc#247">BoringSSL</a>: Google&#39;s fork of OpenSSL used in Chrome and others. It reads SSLKEYLOGFILE just like OpenSSL for logging TLS keys for debugging.</li>
<li><a href="https://curl.se/libcurl/c/libcurl-env.html">Libcurl</a>: proxies, SSL/TLS configuration and debugging like HTTPS_PROXY, CURL_SSL_BACKEND, CURL_DEBUG.</li>
<li><a href="https://www.postgresql.org/docs/current/libpq-envars.html">Libpq Postgres client library</a>: connection parameters including credentials like PGHOSTADDR, PGDATABASE, and PGPASSWORD.</li>
</ul>



<h3>Rust Standard Library</h3>

<ul>
<li><a href="https://doc.rust-lang.org/std/thread/">std::thread RUST_MIN_STACK</a>: Calls std::env::var() on the first call to spawn() a new thread. It is cached in a static atomic variable and never read again. <a href="https://github.com/rust-lang/rust/blob/master/library/std/src/sys_common/thread.rs">See implementation in thread::min_stack()</a>.</li>
<li><a href="https://doc.rust-lang.org/std/backtrace/">std::backtrace RUST_LIB_BACKTRACE</a>: Calls std::env::var() on the first call to capture a backtrace. It is cached in a static atomic variable and never read again. <a href="https://github.com/rust-lang/rust/blob/master/library/std/src/backtrace.rs">See implementation in Backtrace::enabled()</a>.</li>
</ul>

</div></div>
  </body>
</html>
