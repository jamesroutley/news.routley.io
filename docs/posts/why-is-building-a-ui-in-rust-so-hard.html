<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.warp.dev/blog/why-is-building-a-ui-in-rust-so-hard">Original</a>
    <h1>Why is building a UI in Rust so hard?</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><a href="#what-makes-rust-unique">What Makes Rust Unique?</a></p><p><a href="#why-is-ui-in-rust-so-hard">Why is UI in Rust So Hard?</a></p><p><a href="#functional-ui-to-the-rescue">Functional UI to the Rescue</a></p><p>‍</p><p>If you’ve read Hacker News recently, it’s hard to not think that Rust is the future: it’s being used in the <a href="https://en.wikipedia.org/wiki/Rust_for_Linux" target="_blank">Linux kernel</a> and in the <a href="https://security.googleblog.com/2021/05/integrating-rust-into-android-open.html" target="_blank">Android</a> OS, by <a href="https://aws.amazon.com/blogs/opensource/why-aws-loves-rust-and-how-wed-like-to-help/" target="_blank">AWS</a> for critical infrastructure, and in <a href="https://chromium.googlesource.com/chromiumos/docs/+/HEAD/rust_on_cros.md" target="_blank">ChromeOS</a> and <a href="https://wiki.mozilla.org/Oxidation" target="_blank">Firefox</a>. However, as wonderful as Rust is–it has yet to take off as a general language for building UI. In 2019, “GUI” was the<a href="https://blog.rust-lang.org/2020/04/17/Rust-survey-2019.html#rust-adoption---a-closer-look" target="_blank"> 6th most highly requested feature</a> that was preventing adoption of Rust. This is fundamentally a limitation in Rust: the design of the language itself makes modeling common approaches to building UI difficult.</p><p>‍</p><p>
At <a href="https://www.warp.dev/">Warp</a>, we’ve been building a custom UI framework<sup><a href="#footnote-one">1</a></sup> in Rust that we use to render on the GPU. Building this framework has been very tricky and was a big investment, but it has served us well in building a terminal that has rich UI elements and is <a href="https://www.warp.dev/blog/how-warp-works">as fast as any other terminal</a> on the planet. This level of performance would have been virtually impossible had we used a UI library like Electron or Flutter.
</p><p>‍</p><p>In this post, I’ll discuss why Rust’s unique memory management model and lack of inheritance makes traditional techniques to build a UI framework difficult and a few of the ways we’ve been working around it. I believe one of these approaches, or some combination of them, will ultimately lead to a stable cross-platform UI toolkit for high-performance UI rendering that everyone can use.</p><p>‍</p><p><h2 id="what-makes-rust-unique">What Makes Rust Unique?</h2></p><p>‍</p><p>Rust handles memory management through a concept called “ownership” that is enforced at compilation time. This differs from other languages that offer automatic memory management through the use of a <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank">garbage collector</a> to remove unused objects at runtime.</p><p>‍</p><p>Rust ownership works by enforcing the following rules:</p><p>‍</p><ul role="list"><li>Values are owned by variables</li><li>Values can be <em>referenced</em> by other variables (with some caveats mentioned below)</li><li>When the owning variables go out of scope, the memory the value is occupying is deallocated</li></ul><p>‍</p><div><pre><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> <span>mut</span> original_owner = <span>format!</span>(<span>&#34;Hello world&#34;</span>);
    
    
    <span>let</span> new_owner = original_owner;
    
    
    
    <span>println!</span>(<span>&#34;{}&#34;</span>, original_owner)
}
error[E0382]: borrow of moved value: `original_owner`
</pre></div><p>‍</p><p>
 Taking the example above, the Rust compiler enforces that there is only a single owner of 
 a given value at any given time. Rust prevents us from assigning <code>new_owner</code> to the 
 value of <code>original_owner</code>, because there would be two owners of the value at the same 
 time.
</p><p>‍</p><p>Rust also protects against data races at compile time through rules on when a value can be referenced mutably and immutably. In tandem, these rules enforce that there are no data races caused by two threads updating the same value at the same time: </p><p>‍</p><ul role="list"><li>At any given time, you can have either one mutable reference or any number of immutable references.</li><li>References must always be valid.</li><li>The value can not be mutated while there are valid references.</li></ul><p>‍</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6221c6f68d6664279c408870/63ec3e2dcdcda61719e20431_0ofWiT6aWdHl7J-t5PQhZg96xVuQA2K63LoeMbgWH6eeAksZulYznlKap6OuDNjrzNRYnRfnDg3f-0qP2RCRzI0Do-XZJtovSPBJelPA9niL5aTzD163LEZy_tBMHJoVj6m763pn793oHgmp_chM1To.png" alt=""/></p><figcaption>Source: https://rufflewind.com/2017-02-15/rust-move-copy-borrow</figcaption></figure><p>‍</p><p>Rust is also not an object oriented language like Java, C++, or Javascript–it does not support class inheritance or abstract classes. This was an intentional design decision: Rust is designed for <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance" target="_blank">composition over inheritance</a>.</p><p>‍</p><p>Thankfully, it’s still possible to achieve polymorphism in Rust with the use of <a href="https://doc.rust-lang.org/book/ch10-02-traits.html" target="_blank">traits</a> (Rust’s versions of an interface) and trait objects.</p><p>‍</p><p> Let’s say we wanted to build a UI library<sup><a href="#footnote-two">2</a></sup> that draws different UI components (such as a <code>Button</code>, <code>Text</code> and <code>Image</code>) onto a screen. In a traditional OOP language you would probably do this by starting 
with a base <code>Component</code> class with a <code>draw</code> method. Each of these 
components would inherit from the base <code>Component</code> class, and 
we would use the common <code>draw</code> method to draw each component onto the screen. 
</p><p>‍</p><p>In Rust, we can achieve something very simple with the use of a trait and a trait object.</p><p>‍</p><p>We can add a common trait called Draw to our library:</p><p>‍</p><div><pre><span>pub</span> <span><span>trait</span> <span>Draw</span></span> {
    <span><span>fn</span> <span>draw</span></span>(&amp;<span>self</span>);
}</pre></div><p>‍</p><p>Components in our UI framework would all implement this trait and define their own logic for drawing the contents of the component onto the screen. </p><p>‍</p><p>To render all of the components onto the screen, we want to be able to reference all the components in an abstract way that is agnostic of the type of component.</p><p>‍</p><p>
 In Rust, we would do this using a trait object (<code>Box<dyn draw=""></dyn></code>):
</p><p>‍</p><div><pre><span>pub</span> <span><span>struct</span> <span>Screen</span></span> {
    <span>pub</span> components: <span>Vec</span>&lt;<span>Box</span>&lt;dyn Draw&gt;&gt;,
}</pre></div><p>‍</p><p>
The key piece here is that we can reference our list of components 
as a vector of type <code>Box<dyn draw=""></dyn></code> --any object that implements the <code>Draw</code> trait. 
We have to use a <code>Box</code> (a pointer to an object on the heap) here because 
we don’t know the size of the actual object that implements Draw at 
compile time. This lets us interact with these components using the functions 
on the trait (in this case <code>draw</code>) without knowing the type of each object. In our 
case, we can call <code>draw</code> on each component to actually paint the screen:
</p><p>‍</p><div><pre><span>impl</span> Screen {
    <span>pub</span> <span><span>fn</span> <span>run</span></span>(&amp;<span>self</span>) {
        <span>for</span> component <span>in</span> <span>self</span>.components.iter() {
            component.draw();
        }
    }
}</pre></div><p>‍</p><p>This approach works as an adequate solution to achieve polymorphism without inheritance. However, it doesn’t give us all of the features of OOP or inheritance generally: we can’t define a common class and extend its functionality while continuing to reference the fields or methods of the base class.</p><p>‍</p><p>
Traits just define a set of common functionality (a list of functions), 
but don’t specify any of the data defined within each 
implementation of the trait. In this case, there’s nothing 
stopping us from implementing the <code>Draw</code> trait on a random 
object that has nothing to do with a UI component. For example, we 
could implement it on this random struct named Foo that definitely 
isn’t a valid UI component:
</p><p>‍</p><div><pre><span><span>struct</span> <span>Foo</span></span>;

<span>impl</span> Draw <span>for</span> Foo {
    <span><span>fn</span> <span>draw</span></span>(&amp;<span>self</span>) {}
}</pre></div><p>‍</p><p><h2 id="why-is-ui-in-rust-so-hard">Why is UI in Rust So Hard?</h2></p><p>Pretty much all UI can be modeled as a tree–or more abstractly as a graph. A tree is a natural way to model UI: it makes it easy to compose different components together to build something that is visually complicated. It’s also been one of most common ways to model UI programming since at least the existence of HTML, if not earlier.</p><p>‍</p><p>UI in Rust is difficult because it&#39;s hard to share data across this component tree without inheritance. Additionally, in a normal UI framework there are all sorts of spots where you need to mutate the element tree, but because of Rust’s mutability rules, this &#34;alter the tree however you want&#34; approach doesn&#39;t work. </p><p>‍</p><p>In most UI frameworks, the concept of a component tree is built into the framework. The framework holds the root component and each component inherits from a common base component that keeps track of all of its children and how to traverse the children. Traversing the tree is critical for event handling: the framework needs to be able to walk the tree to determine which component(s) should receive an event. An example of this is event bubbling and capturing in the DOM API: with event bubbling (the default) events are handled by the deepest component in the tree and then “bubbled” up to parent elements.</p><p>‍</p><p>
A framework that does this well is Flutter–there’s a 
<code>Widget</code> abstract class–and additional abstract classes that 
extend from <code>Widget</code>  for the cases where a widget has 
no children (`<a target="_blank" href="https://github.com/flutter/flutter/blob/7bf1e99ea8076956d0b3733a88324e15948f93df/packages/flutter/lib/src/widgets/framework.dart#L6295">LeafRenderObjectElement</a>`), one 
child (`<a target="_blank" href="https://github.com/flutter/flutter/blob/7bf1e99ea8076956d0b3733a88324e15948f93df/packages/flutter/lib/src/widgets/framework.dart#L6333">SingleChildRenderObjectElement</a>`)  and many 
children (`<a target="_blank" href="https://github.com/flutter/flutter/blob/7bf1e99ea8076956d0b3733a88324e15948f93df/packages/flutter/lib/src/widgets/framework.dart#L6403">MultiChildRenderObjectElement</a>`). These extra layers of inheritance 
ensure that leaf components don’t need to deal with any logic 
around walking a component tree since 
it’s all handled by a superclass.
</p><p>‍</p><p>Let’s use a timer, one of the tasks from <a href="https://eugenkiss.github.io/7guis/tasks" target="_blank">7GUIs</a>, as an example of how this tree structure would be useful. Our timer will have a progress bar to show the elapsed time, a slider to adjust the duration, and a button to reset the timer.</p><p>‍</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6221c6f68d6664279c408870/63ec42fff5a60a2e2f6b8993_ZozIBDtYBj__fiJ9l7pPY5ATkWezDGhzdqYQQHwFZRoGHASfCGaC4bMDmhRR1cj8w5oe5mcYciDH2pZhgBrfTyrUF7AUmX3_MwfrctRvmlEgnGKyr5sCiq8iV43M-KetOds07EFpvVm9l99Vn1Ex374.png" alt=""/></p></figure><p>‍</p><p>We can model this tree like so:</p><p>‍</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6221c6f68d6664279c408870/63ec9d0c8a40f4349eb3a529_Tree%20Diagram%20UI%20Framework%20Blog%20Post.png" loading="lazy" alt=""/></p></figure><p>This tree approach does not map cleanly to Rust. The lack of OOP makes it harder to design a component that can have <em>n</em> number of children like in the structure above. Using our trait example from above, it’s not as simple as adding an additional function to our trait:</p><p>‍</p><div><pre><span>pub</span> <span><span>trait</span> <span>Draw</span></span> {
    <span><span>fn</span> <span>draw</span></span>(&amp;<span>self</span>);

    <span><span>fn</span> <span>children</span></span>(&amp;<span>self</span>) -&gt; <span>Vec</span>&lt;<span>Box</span>&lt;dyn Draw&gt;&gt;;
}</pre></div><p>‍</p><p>
Since traits don’t hold data, this requires each component to individually store its children. Since we’ve just added on a <code>children</code> function–there’s nothing stopping a poorly-written component from returning an empty vector here even though the component stores, and draws, multiple components. These inconsistencies make it much harder to walk the tree–in an object-oriented language all of this logic would be abstracted away into a super class that could walk the tree using the source-of-truth of any of its children (the field itself).
</p><p>‍</p><p>Rust’s constraints around mutability here also makes trees hard to model if you want to be able to mutate the tree (which is a must since we’ll need to add and remove components as well as mutate the actual components themselves). Rust’s rules that prevent multiple mutable references to a single value discourages the use of shared mutable state–but that is often necessary in a tree where the tree owns and mutates the nodes but other app logic also needs to mutate each node in the tree.</p><p>‍</p><p>Dealing with shared mutable state is also an issue when handling events. Most UI frameworks handle user interactions through the use of an event loop that polls for input. The framework can mutate any number of components at any time upon receiving an event.</p><p>‍</p><p>There are ways to workaround with shared mutable state in Rust, but it produces non-ergonomic code that defers many of these checks to runtime.</p><p>‍</p><p>
A common solution to this is to use <a target="_blank" href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">interior mutability</a> using the <code>RefCell</code> type that is provided in the Rust standard library. <code>RefCell</code> works by moving Rust ownership checks to runtime instead of compile time. To get a mutable reference to an object, you can call <a target="_blank" href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.get_mut">borrow_mut</a>:
</p><p>‍</p><div><pre><span>pub</span> <span><span>fn</span> <span>borrow_mut</span></span>(&amp;<span>self</span>) -&gt; RefMut&lt;<span>&#39;_</span>, T&gt;</pre></div><p>‍</p><p>
If there is already an existing mutable reference to the underlying object– <code>borrow_mut</code> will panic to ensure that ownership guarantees aren’t violated.
</p><p>‍</p><p>
Using <code>RefCell</code> mostly works, but is by no means ergonomic. It also has safety concerns–by deferring ownership checks to runtime the app can panic if there are ever two calls to <code>borrow_mut</code>.
</p><p>‍</p><p><h2 id="functional-ui-to-the-rescue">Functional UI to the Rescue</h2></p><p>Now that we have enough context on some of the difficulties with building a UI framework in Rust, let’s quickly touch on some approaches that have worked well in Rust.</p><p>‍</p><p>
The short answer is that there are many different solutions to these problems, which is why the UI landscape in Rust <a target="_blank" href="https://www.areweguiyet.com/">is so fractured</a> and there isn’t a clear one-size-fits-all UI framework solution in Rust.

</p><p>‍</p><p>One of the most common solutions to these issues in Rust is to avoid using these object oriented patterns at all. Even though most UI frameworks were designed for Object-Oriented Programming, UI programming does not inherently need to be object oriented.</p><p>‍</p><p>
A good example of this is the <a target="_blank" href="https://guide.elm-lang.org/architecture/">Elm architecture</a>, which makes heavy use of functional, reactive programming. <a target="_blank" href="https://github.com/iced-rs/iced">Iced</a> is the most popular Rust framework inspired by this architecture. This architecture separates the UI program into three high-level components: a Model type, a <code>view</code> function, and an <code>update</code> function.

</p><p>‍</p><p>
The model is a simple dumb-data-object that holds all of the state for the view. At render time, <code>view</code> is responsible for converting the model into something that is displayed on the screen (in this case, by outputting HTML). <code>update</code> is responsible for mutating the model using programmer-defined <code>Msg</code>s . When a user interacts with the app, the programmer specifies which <code>Msg</code> should be used to update the model. The framework knows it needs to re-render (by calling <code>view</code>) since the Model has changed.
</p><p>‍</p><p>The Elm model works very well in Rust for a few reasons:</p><p>‍</p><div><ol>
<li><b>Functional and immutable:</b> there’s no need to deal with mutability issues since everything flows through <code>update</code>,  where you take an owned value to a model and return a new owned value of the model. This maps well to Rust’s ownership model since there is a single owner of the Model.
</li>
<li>
<b>Messages can be cleanly expressed with Rust enums:</b> Rust has very expressive enum support, which lets you model messages with different data types very easily. This ends up producing clear and declarative code where you can pattern match on each variant.
</li>
</ol>
</div><p>‍</p><p>
A good example how cleanly messages can be mapped to Rust enums is <a target="_blank" href="https://github.com/iced-rs/iced/blob/master/examples/component/src/main.rs#L48">iced’s</a> example for a numeric input where a user can either specify a number using an input or increment and decrement the number using buttons.
</p><p>‍</p><p>Messages can be defined as:</p><p>‍</p><div><pre>

pub <span><span>enum</span> <span>Event</span> {</span>
    InputChanged(String),
    IncrementPressed,
    DecrementPressed,
}</pre></div><p>‍</p><p>
And we would derive <code>update</code> as follows:
</p><p>‍</p><div><pre><span><span>fn</span> <span>update</span></span>(
    &amp;<span>mut</span> <span>self</span>,
    _state: &amp;<span>mut</span> Self::State,
    event: Event,
) -&gt; <span>Option</span>&lt;Message&gt; {
    <span>match</span> event {
        Event::IncrementPressed =&gt; <span>Some</span>((<span>self</span>.on_change)(<span>Some</span>(
            <span>self</span>.value.unwrap_or_default().saturating_add(<span>1</span>),
        ))),
        Event::DecrementPressed =&gt; <span>Some</span>((<span>self</span>.on_change)(<span>Some</span>(
            <span>self</span>.value.unwrap_or_default().saturating_sub(<span>1</span>),
        ))),
        Event::InputChanged(value) =&gt; {
            <span>if</span> value.is_empty() {
                <span>Some</span>((<span>self</span>.on_change)(<span>None</span>))
            } <span>else</span> {
                value
                    .parse()
                    .ok()
                    .map(<span>Some</span>)
                    .map(<span>self</span>.on_change.as_ref())
            }
        }
    }
}
</pre></div><p>‍</p><p>
If Elm reminds you of Redux, then you are on the right path. Redux was inspired by Elm–you can think of <a target="_blank" href="https://redux.js.org/usage/structuring-reducers/basic-reducer-structure">Redux resolvers</a> as analogous to updaters in Elm.
</p><p>‍</p><p>
This architecture does have some downsides: componentizing components is not as intuitive as it is in other frameworks. In fact, the Elm docs <a target="_blank" href="https://guide.elm-lang.org/webapps/structure.html">explicitly discourage</a> componentizing. Instead of creating new components that have their own Model, Elm encourages adding helper view and update functions that take in specific parameters from the model. For example, you could add a <code>header_view</code> function that takes specific parameters needed to render a header. This approach works just fine, but is not as intuitive as componentizing based on the visual structure of your application like you would in React or Flutter.
</p><p>‍</p><p>An Elm-like approach is by no means the only approach that seems to be getting traction. An Entity-Component-System (ECS) architecture also works well in Rust to avoid issues around shared mutable state.</p><p>‍</p><p>In ECS, the framework owns all of the components. Components continue to be responsible for holding their own state, responding to user input, and painting onto the screen but the framework is responsible for storing the relationship between the components (the tree we mentioned above) and for any interaction between the components. This helps solve a lot of the issues in the Rust compiler around mutability: the single owner for all of the components is the framework. This approach isn’t perfect–the system now needs to track when to remove old components. It also litters references to this central store throughout your codebase since that is the only way to read out the state from any component.</p><p>‍</p><p>
This is roughly the approach we chose to take at Warp: we represent each component (what we call a <code>View</code>) with a unique ID called an <code>EntityId</code>. Each window stores a mapping of the <code>EntityId</code> to the actual View that is identified by the ID:
</p><p>‍</p><div><pre>


<span>#[derive(Default)]</span>
<span>pub</span>(<span>super</span>) <span><span>struct</span> <span>Window</span></span> {
    
    <span><span>pub</span> views: HashMap&lt;EntityId, <span>Box</span>&lt;dyn AnyView&gt;&gt;,</span>

    
    <span>pub</span> root_view: <span>Option</span>&lt;AnyViewHandle&gt;,

    
    <span>pub</span> focused_view: <span>Option</span>&lt;EntityId&gt;,
}</pre></div><p>‍</p><p>
We use this <code>EntityID</code> as the key to store any state that references the view. For example, we store a mapping of each view to its parent view  (see the <code>parents</code> field) so that we can traverse the view tree upwards. We also store a mapping of what each view rendered onto the screen in the last frame (see the <code>rendered_views</code> field).
</p><p>‍</p><div><pre><span>pub</span> <span><span>struct</span> <span>Presenter</span></span> {
    window_id: WindowId,
    scene: <span>Option</span>&lt;Rc&lt;Scene&gt;&gt;,
    <span>rendered_views: HashMap&lt;EntityId, <span>Box</span>&lt;dyn Element&gt;&gt;,</span>
    <span>parents: HashMap&lt;EntityId, EntityId&gt;,</span>
    font_cache: Arc&lt;FontCache&gt;,
    asset_cache: Arc&lt;assets::Cache&gt;,
    text_layout_cache: LayoutCache,
    stack_context: StackContext,
}</pre></div><p>‍</p><p>
In an object oriented world, all of the state for each of these components would be encoded <em>within</em> the component. In ECS, this data is denormalized into a series of maps and lists owned by the system. We use this <code>EntityID</code> as the key across any structure that holds state for a view. In this screenshot below of Warp we have three different views, each of which have unique <code>EntityID</code>s:
</p><p>‍</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6221c6f68d6664279c408870/63eca91cab68909af3ee1292_Screen%20Shot%202023-02-15%20at%201.42.05%20AM.png" loading="lazy" alt=""/></p></figure><p>‍</p><p>
The use of these <code>EntityIds</code> allow us to encode a component tree structure without inheritance. The actual view tree for the screenshot above would look something like:
</p><p>‍</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6221c6f68d6664279c408870/63ed02e5744efab846bb7caa_Warp%20Hierarchy%20Blog%20Post.png" loading="lazy" alt=""/></p></figure><p>‍</p><p>
Entity-Component-Systems and Elm are not the only two approaches to solve this by any means. Others have investigated using <a target="_blank" href="https://en.wikipedia.org/wiki/Immediate_mode_GUI">immediate mode GUI</a>, or even using the DOM to render while keeping application logic in Rust (see <a target="_blank" href="https://tauri.app/">Tauri</a>).
</p><p>‍</p><p><h2 id="looking-forward">Looking Forward</h2></p><p>Building a proper UI framework in Rust is hard and often unintuitive. It’s also not yet set up for a great developer experience when using a framework: it doesn’t support hot reloading which can lead to a slow and clunky experience of recompiling code to make the smallest of UI changes.</p><p>‍</p><p>Rust’s strong commitments to portability and performance, and active ecosystem still makes it a compelling choice for UI programming: especially for cases where high performance is critical.</p><p>‍</p><p>
In our case, our UI framework has served us well to achieve our performance goals and is not a major source of velocity issues for our developers. It has its shortcomings though–some of which are shortcomings with its design and others because of Rust. For example, we don’t have an easy way to traverse the tree of elements we paint onto the screen in any order of direction–this makes event handling more difficult. We also use a <code>RefCell</code> to handle shared mutability when receiving platform events from the event loop–though it’s rare, we’ve had a few crashes from users in the wild due to concurrent calls to <code>borrow_mut</code>. 
</p><p>‍</p><p>
The future of UI in Rust will likely continue to be innovative yet fragmented as the community experiments with many different approaches. We don’t yet have a one-size-fits-all framework, but I have no doubt that one, if not many, will succeed in the coming years. As hardware advances, Rust will be a good choice to build a buttery-smooth UI in a way that is cross-platform. And if you’re curious in trying our Rust-based UI, you can download Warp here:
</p><p>‍</p><p>‍</p><p>‍</p><p>
 
<sub>
We built this framework in collaboration with <a target="_blank" href="https://github.com/nathansobo">Nathan Sobo</a>, the co-founder of Atom and <a target="_blank" href="https://zed.dev/">zed.dev</a>.
</sub>
</p><p>‍</p><p>
 
<sub>
Example from https://doc.rust-lang.org/book/ch17-02-trait-objects.html
</sub>
</p></div></div></div></div>
  </body>
</html>
