<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jakelazaroff.com/words/building-a-single-page-app-with-htmx/">Original</a>
    <h1>Building a Single-Page App with htmx</h1>
    
    <div id="readability-page-1" class="page"><div data-content="" data-astro-cid-onuac4el=""> <p>People talk about htmx as though it’s saving the web from single-page apps.
React has mired developers in complexity (so the story goes) and htmx is offering a desperately-needed lifeline.</p>
<p>htmx creator Carson Gross wryly explains the dynamic <a href="https://twitter.com/htmx_org/status/1736849183112360293" data-astro-cid-bi7aps5f="">like this</a><a data-tooltip="" href="https://twitter.com/htmx_org/status/1736849183112360293" data-astro-cid-bi7aps5f=""> <img src="https://pbs.twimg.com/profile_images/1841320711912300544/g_9Zdyv2_200x200.jpg" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">htmx.org / CEO of Delete Your Account (same thing) (@htmx_org) on X</span> <span data-astro-cid-bi7aps5f="">@iamjohndorn @flaviocopes no, this is a Hegelian dialectic:

- thesis: traditional MPAs
- antithesis: SPAs
- synthesis (higher form): hypermedia-driven applications w/ islands of intereactivity</span> <span data-astro-cid-bi7aps5f=""> <img src="https://abs.twimg.com/favicons/twitter.3.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">twitter.com/htmx_org/status/1736849183112360293</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>:</p>
<blockquote>
<p>no, this is a Hegelian dialectic:</p>
<ul>
<li>thesis: traditional MPAs</li>
<li>antithesis: SPAs</li>
<li>synthesis (higher form): hypermedia-driven applications w/ islands of intereactivity</li>
</ul>
</blockquote>
<p>Well, I guess I missed the memo, because <a href="https://jakelazaroff.github.io/htmx-spa/" data-astro-cid-bi7aps5f="">I used htmx to build a single-page app</a><a data-tooltip="" href="https://jakelazaroff.github.io/htmx-spa/" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">htmx spa</span>  <span data-astro-cid-bi7aps5f=""> <img src="https://jakelazaroff.github.io/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">jakelazaroff.github.io/htmx-spa/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>.</p>
<p>It’s a simple proof of concept todo list.
Once the page is loaded, there is <em>no additional communication with a server</em>.
Everything happens locally on the client.</p>
<p>How does that work, given that htmx is focused on managing hypermedia exchanges over the network?</p>
<p>With one simple trick:<sup><a href="#user-content-fn-clickbait" id="user-content-fnref-clickbait" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">1</a></sup> the “server-side” code runs in a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" data-astro-cid-bi7aps5f="">service worker</a><a data-tooltip="" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" data-astro-cid-bi7aps5f=""> <img src="https://developer.mozilla.org/mdn-social-share.d893525a4fb5fb1f67a2.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Service Worker API - Web APIs | MDN</span> <span data-astro-cid-bi7aps5f="">Service workers essentially act as proxy servers that sit between web applications, the browser, and the network (when available). They are intended, among other things, to enable the creation of effective offline experiences, intercept network requests, and take appropriate action based on whether the network is available, and update assets residing on the server. They will also allow access to push notifications and background sync APIs.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://developer.mozilla.org/favicon-48x48.bc390275e955dacb2e65.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>.</p>
<p>Briefly, a service worker acts as a proxy between a webpage and the wider Internet.
It intercepts network requests and allows you to manipulate them.
You can alter requests, cache responses to be served offline or even create new responses out of whole cloth without ever sending the request beyond the browser.</p>
<p>That last capability is what powers this single-page app.
When htmx makes a network request, the service worker intercepts it.
The service worker then runs the business logic and generates new HTML, which htmx then swaps into the DOM.</p>
<p>There are a couple of advantages over a traditional single-page app built with something like React, too.
Service workers must use <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" data-astro-cid-bi7aps5f="">IndexedDB</a><a data-tooltip="" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" data-astro-cid-bi7aps5f=""> <img src="https://developer.mozilla.org/mdn-social-share.d893525a4fb5fb1f67a2.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">IndexedDB API - Web APIs | MDN</span> <span data-astro-cid-bi7aps5f="">IndexedDB is a low-level API for client-side storage of significant amounts of structured data, including files/blobs. This API uses indexes to enable high-performance searches of this data. While Web Storage is useful for storing smaller amounts of data, it is less useful for storing larger amounts of structured data. IndexedDB provides a solution. This is the main landing page for MDN&#39;s IndexedDB coverage — here we provide links to the full API reference and usage guides, browser support details, and some explanation of key concepts.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://developer.mozilla.org/favicon-48x48.bc390275e955dacb2e65.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> for storage, which is stateful between page loads.
If you close the page and then come back, the app retains your data — this happens “for free”, a <a href="https://blog.codinghorror.com/falling-into-the-pit-of-success/" data-astro-cid-bi7aps5f="">pit of success</a><a data-tooltip="" href="https://blog.codinghorror.com/falling-into-the-pit-of-success/" data-astro-cid-bi7aps5f=""> <img src="https://blog.codinghorror.com/assets/images/codinghorror-app-icon.png?v=f6a88d682f" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Falling Into The Pit of Success</span> <span data-astro-cid-bi7aps5f="">Eric Lippert notes the perils of programming in C++:





I often think of C++ as my own personal Pit of Despair Programming Language. Unmanaged C++ makes it so easy to fall into traps. Think buffer overruns, memory leaks, double frees, mismatch between allocator and deallocator, using freed memory, umpteen dozen</span> <span data-astro-cid-bi7aps5f=""> <img src="https://blog.codinghorror.com/content/images/size/w256h256/2020/06/3cffc4b347c3587f19fe222caaac69f63b9a5e73.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">blog.codinghorror.com/falling-into-the-pit-of-success/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> consequence of choosing this architecture.
The app also works offline, which doesn’t come for free but is pretty easy to add once the service worker is set up already.</p>
<p>Of course, service workers have a bunch of pitfalls as well.
One is the absolutely abysmal support in developer tools, which seem to intermittently swallow <code>console.log</code> and unreliably report when a service worker is installed.
Another is the lack of support for ES modules in Firefox, which forced me to put all my code (including a vendored version of <a href="https://github.com/jakearchibald/idb-keyval" data-astro-cid-bi7aps5f="">IDB Keyval</a><a data-tooltip="" href="https://github.com/jakearchibald/idb-keyval" data-astro-cid-bi7aps5f=""> <img src="https://opengraph.githubassets.com/07f16bf35606046a6b0ae984536d6b4ffad2233d997114e353456a3b1973fe8b/jakearchibald/idb-keyval" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">GitHub - jakearchibald/idb-keyval: A super-simple-small promise-based keyval store implemented with IndexedDB</span> <span data-astro-cid-bi7aps5f="">A super-simple-small promise-based keyval store implemented with IndexedDB - jakearchibald/idb-keyval</span> <span data-astro-cid-bi7aps5f=""> <img src="https://github.githubassets.com/favicons/favicon.svg" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">github.com/jakearchibald/idb-keyval</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>, which I included because IndexedDB is similarly annoying) in a single file.</p>
<p>This is not an exhaustive list!
I would describe the general experience of working with service workers as “not fun”.</p>
<p>But!
In spite of all that, the htmx single-page app works.
Let’s dive in!</p>
<h3 id="behind-the-scenes">Behind The Scenes</h3>
<p>Let’s start with the HTML:</p>
<pre><code is:raw=""><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>&gt;</span></span>
<span><span><span>&lt;</span>html</span><span>&gt;</span></span>
  <span><span><span>&lt;</span>head</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>title</span><span>&gt;</span></span>htmx spa<span><span><span>&lt;/</span>title</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>&#34;</span>utf-8<span>&#34;</span></span> <span>/&gt;</span></span>
    <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>&#34;</span>stylesheet<span>&#34;</span></span> <span>href</span><span><span>=</span><span>&#34;</span>./style.css<span>&#34;</span></span> <span>/&gt;</span></span>
    <span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>&#34;</span>./htmx.js<span>&#34;</span></span><span>&gt;</span></span><span></span><span><span><span>&lt;/</span>script</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>&#34;</span>module<span>&#34;</span></span><span>&gt;</span></span><span><span>
      <span>async</span> <span>function</span> <span>load</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
          <span>const</span> registration <span>=</span> <span>await</span> navigator<span>.</span>serviceWorker<span>.</span><span>register</span><span>(</span><span>&#34;./sw.js&#34;</span><span>)</span><span>;</span>
          <span>if</span> <span>(</span>registration<span>.</span>active<span>)</span> <span>return</span><span>;</span>

          <span>const</span> worker <span>=</span> registration<span>.</span>installing <span>||</span> registration<span>.</span>waiting<span>;</span>
          <span>if</span> <span>(</span><span>!</span>worker<span>)</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>&#34;No worker found&#34;</span><span>)</span><span>;</span>

          worker<span>.</span><span>addEventListener</span><span>(</span><span>&#34;statechange&#34;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
            <span>if</span> <span>(</span>registration<span>.</span>active<span>)</span> location<span>.</span><span>reload</span><span>(</span><span>)</span><span>;</span>
          <span>}</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span>err<span>)</span> <span>{</span>
          console<span>.</span><span>error</span><span>(</span><span><span>`</span><span>Registration failed with </span><span><span>${</span>err<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
        <span>}</span>
      <span>}</span>

      <span>if</span> <span>(</span><span>&#34;serviceWorker&#34;</span> <span>in</span> navigator<span>)</span> <span>load</span><span>(</span><span>)</span><span>;</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>&#34;</span>htmx-config<span>&#34;</span></span> <span>content</span><span><span>=</span><span>&#39;</span>{&#34;scrollIntoViewOnBoost&#34;: false}<span>&#39;</span></span> <span>/&gt;</span></span>
  <span><span><span>&lt;/</span>head</span><span>&gt;</span></span>
  <span><span><span>&lt;</span>body</span> <span>hx-boost</span><span><span>=</span><span>&#34;</span>true<span>&#34;</span></span> <span>hx-push-url</span><span><span>=</span><span>&#34;</span>false<span>&#34;</span></span> <span>hx-get</span><span><span>=</span><span>&#34;</span>./ui<span>&#34;</span></span> <span>hx-target</span><span><span>=</span><span>&#34;</span>body<span>&#34;</span></span> <span>hx-trigger</span><span><span>=</span><span>&#34;</span>load<span>&#34;</span></span><span>&gt;</span></span><span><span><span>&lt;/</span>body</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>html</span><span>&gt;</span></span></code></pre>
<p>This should look familiar if you’ve ever built a single-page app: the empty husk of an HTML document, waiting to be filled in by JavaScript.
That long inline <code>&lt;script&gt;</code> tag just sets up the service worker and is <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers" data-astro-cid-bi7aps5f="">mostly stolen from MDN</a><a data-tooltip="" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers" data-astro-cid-bi7aps5f=""> <img src="https://developer.mozilla.org/mdn-social-share.d893525a4fb5fb1f67a2.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Using Service Workers - Web APIs | MDN</span> <span data-astro-cid-bi7aps5f="">This article provides information on getting started with service workers, including basic architecture, registering a service worker, the installation and activation process for a new service worker, updating your service worker, cache control and custom responses, all in the context of a simple app with offline functionality.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://developer.mozilla.org/favicon-48x48.bc390275e955dacb2e65.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>.</p>
<p>The interesting bit here is the <code>&lt;body&gt;</code> tag, which uses htmx to set up the meat of the app:</p>
<ul>
<li><code>hx-boost=&#34;true&#34;</code> tells htmx to use Ajax to swap in the responses of link clicks and form submissions without a full page navigation</li>
<li><code>hx-push-url=&#34;false&#34;</code> prevents htmx from updating the URL in response to said link clicks and form submissions</li>
<li><code>hx-get=&#34;./ui&#34;</code> tells htmx to load the page at <code>/ui</code> and swap it in</li>
<li><code>hx-target=&#34;body&#34;</code> tells htmx to swap the results into the <code>&lt;body&gt;</code> element</li>
<li><code>hx-trigger=&#34;load&#34;</code> tells htmx that it should do all this when the page loads</li>
</ul>
<p>So basically: <code>/ui</code> returns the actual markup for the app, at which point htmx takes over any links and forms to make it interactive.</p>
<p>What’s at <code>/ui</code>?
Enter the service worker!
It uses a small home-brewed Express-like “library” to handle boilerplate around routing requests and returning responses.
How that library actually works is beyond the scope of this post, but it’s used like this:</p>
<pre><code is:raw="">spa<span>.</span><span>get</span><span>(</span><span>&#34;/ui&#34;</span><span>,</span> <span>async</span> <span>(</span><span>_request<span>,</span> <span>{</span> query <span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>{</span> filter <span>=</span> <span>&#34;all&#34;</span> <span>}</span> <span>=</span> query<span>;</span>
  <span>await</span> <span>setFilter</span><span>(</span>filter<span>)</span><span>;</span>

  <span>const</span> headers <span>=</span> <span>{</span><span>}</span><span>;</span>
  <span>if</span> <span>(</span>filter <span>===</span> <span>&#34;all&#34;</span><span>)</span> headers<span>[</span><span>&#34;hx-replace-url&#34;</span><span>]</span> <span>=</span> <span>&#34;./&#34;</span><span>;</span>
  <span>else</span> headers<span>[</span><span>&#34;hx-replace-url&#34;</span><span>]</span> <span>=</span> <span>&#34;./?filter=&#34;</span> <span>+</span> filter<span>;</span>

  <span>const</span> html <span>=</span> <span>App</span><span>(</span><span>{</span> filter<span>,</span> <span>todos</span><span>:</span> <span>await</span> <span>listTodos</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span>
  <span>return</span> <span>new</span> <span>Response</span><span>(</span>html<span>,</span> <span>{</span> headers <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span></code></pre>
<p>When a <code>GET</code> request is made to <code>/ui</code>, this code…</p>
<ol>
<li>grabs the query string for the filter</li>
<li>saves the filter in IndexedDB</li>
<li>tells htmx to update the URL accordingly</li>
<li>renders the <code>App</code> “component” to HTML with the active filter and list of todos</li>
<li>returns the rendered HTML to the browser</li>
</ol>
<p><code>setFilter</code> and <code>listTodos</code> are pretty simple functions that wrap IDB Keyval:</p>
<pre><code is:raw=""><span>async</span> <span>function</span> <span>setFilter</span><span>(</span><span>filter</span><span>)</span> <span>{</span>
  <span>await</span> <span>set</span><span>(</span><span>&#34;filter&#34;</span><span>,</span> filter<span>)</span><span>;</span>
<span>}</span>

<span>async</span> <span>function</span> <span>getFilter</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>get</span><span>(</span><span>&#34;filter&#34;</span><span>)</span><span>;</span>
<span>}</span>

<span>async</span> <span>function</span> <span>listTodos</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> todos <span>=</span> <span>(</span><span>await</span> <span>get</span><span>(</span><span>&#34;todos&#34;</span><span>)</span><span>)</span> <span>||</span> <span>[</span><span>]</span><span>;</span>
  <span>const</span> filter <span>=</span> <span>await</span> <span>getFilter</span><span>(</span><span>)</span><span>;</span>

  <span>switch</span> <span>(</span>filter<span>)</span> <span>{</span>
    <span>case</span> <span>&#34;done&#34;</span><span>:</span>
      <span>return</span> todos<span>.</span><span>filter</span><span>(</span><span>todo</span> <span>=&gt;</span> todo<span>.</span>done<span>)</span><span>;</span>
    <span>case</span> <span>&#34;left&#34;</span><span>:</span>
      <span>return</span> todos<span>.</span><span>filter</span><span>(</span><span>todo</span> <span>=&gt;</span> <span>!</span>todo<span>.</span>done<span>)</span><span>;</span>
    <span>default</span><span>:</span>
      <span>return</span> todos<span>;</span>
  <span>}</span>
<span>}</span></code></pre>
<p>The <code>App</code> component looks like this:</p>
<pre><code is:raw=""><span>function</span> <span>App</span><span>(</span><span>{</span> filter <span>=</span> <span>&#34;all&#34;</span><span>,</span> todos <span>=</span> <span>[</span><span>]</span> <span>}</span> <span>=</span> <span>{</span><span>}</span><span>)</span> <span>{</span>
  <span>return</span> html<span><span>`</span><span>
    &lt;div class=&#34;app&#34;&gt;
      &lt;header class=&#34;header&#34;&gt;
        &lt;h1&gt;Todos&lt;/h1&gt;
        &lt;form class=&#34;filters&#34; action=&#34;./ui&#34;&gt;
          &lt;label class=&#34;filter&#34;&gt;
            All
            &lt;input
              type=&#34;radio&#34;
              name=&#34;filter&#34;
              value=&#34;all&#34;
              oninput=&#34;this.form.requestSubmit()&#34;
              </span><span><span>${</span>filter <span>===</span> <span>&#34;all&#34;</span> <span>&amp;&amp;</span> <span>&#34;checked&#34;</span><span>}</span></span><span>
            /&gt;
          &lt;/label&gt;
          &lt;label class=&#34;filter&#34;&gt;
            Active
            &lt;input
              type=&#34;radio&#34;
              name=&#34;filter&#34;
              value=&#34;left&#34;
              oninput=&#34;this.form.requestSubmit()&#34;
              </span><span><span>${</span>filter <span>===</span> <span>&#34;left&#34;</span> <span>&amp;&amp;</span> <span>&#34;checked&#34;</span><span>}</span></span><span>
            /&gt;
          &lt;/label&gt;
          &lt;label class=&#34;filter&#34;&gt;
            Completed
            &lt;input
              type=&#34;radio&#34;
              name=&#34;filter&#34;
              value=&#34;done&#34;
              oninput=&#34;this.form.requestSubmit()&#34;
              </span><span><span>${</span>filter <span>===</span> <span>&#34;done&#34;</span> <span>&amp;&amp;</span> <span>&#34;checked&#34;</span><span>}</span></span><span>
            /&gt;
          &lt;/label&gt;
        &lt;/form&gt;
      &lt;/header&gt;
      &lt;ul class=&#34;todos&#34;&gt;
        </span><span><span>${</span>todos<span>.</span><span>map</span><span>(</span><span>todo</span> <span>=&gt;</span> <span>Todo</span><span>(</span>todo<span>)</span><span>)</span><span>}</span></span><span>
      &lt;/ul&gt;
      &lt;form
        class=&#34;submit&#34;
        action=&#34;./todos/add&#34;
        method=&#34;get&#34;
        hx-select=&#34;.todos&#34;
        hx-target=&#34;.todos&#34;
        hx-swap=&#34;outerHTML&#34;
        hx-on::before-request=&#34;this.reset()&#34;
      &gt;
        &lt;input
          type=&#34;text&#34;
          name=&#34;text&#34;
          placeholder=&#34;What needs to be done?&#34;
          hx-on::after-request=&#34;this.focus()&#34;
        /&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  </span><span>`</span></span><span>.</span><span>trim</span><span>(</span><span>)</span><span>;</span>
<span>}</span></code></pre>
<p>(As before, we’ll skip some of the utility functions like <code>html</code>, which just provides some small conveniences when interpolating values.)</p>
<p><code>App</code> can be broken down into roughly three sections:</p>
<ul>
<li>The filters form.
This renders a radio button for each filter.
When a radio button changes, it submits the form to <code>/ui</code>, which re-renders the app using the steps described above.
The<code>hx-boost</code> attribute from before intercepts the form submission and swaps the response back into the <code>&lt;body&gt;</code> without refreshing the page.</li>
<li>The todos list.
This loops over all the todos matching the current filter, rendering each using the <code>Todo</code> component.</li>
<li>The add todo form.
This is a form with an input that submits the value to <code>/todos/add</code>.<sup><a href="#user-content-fn-get" id="user-content-fnref-get" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">2</a></sup>
<code>hx-target=&#34;.todos&#34;</code> tells htmx to replace an element on the page with class <code>todos</code>; <code>hx-select=&#34;.todos&#34;</code> tells htmx that rather than using the <em>entire</em> response, it should just use an element with class <code>todos</code>.</li>
</ul>
<p>Let’s take a look at that <code>/todos/add</code> route:</p>
<pre><code is:raw=""><span>async</span> <span>function</span> <span>addTodo</span><span>(</span><span>text</span><span>)</span> <span>{</span>
  <span>const</span> id <span>=</span> crypto<span>.</span><span>randomUUID</span><span>(</span><span>)</span><span>;</span>
  <span>await</span> <span>update</span><span>(</span><span>&#34;todos&#34;</span><span>,</span> <span>(</span><span>todos <span>=</span> <span>[</span><span>]</span></span><span>)</span> <span>=&gt;</span> <span>[</span><span>...</span>todos<span>,</span> <span>{</span> id<span>,</span> text<span>,</span> <span>done</span><span>:</span> <span>false</span> <span>}</span><span>]</span><span>)</span><span>;</span>
<span>}</span>

spa<span>.</span><span>get</span><span>(</span><span>&#34;/todos/add&#34;</span><span>,</span> <span>async</span> <span>(</span><span>_request<span>,</span> <span>{</span> query <span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>if</span> <span>(</span>query<span>.</span>text<span>)</span> <span>await</span> <span>addTodo</span><span>(</span>query<span>.</span>text<span>)</span><span>;</span>

  <span>const</span> html <span>=</span> <span>App</span><span>(</span><span>{</span> <span>filter</span><span>:</span> <span>await</span> <span>getFilter</span><span>(</span><span>)</span><span>,</span> <span>todos</span><span>:</span> <span>await</span> <span>listTodos</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span>
  <span>return</span> <span>new</span> <span>Response</span><span>(</span>html<span>,</span> <span>{</span><span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span></code></pre>
<p>Pretty simple!
It just saves the todo and returns a response with the re-rendered UI, which htmx thens swap into the DOM.</p>
<p>Now, let’s look at that <code>Todo</code> component from before:</p>
<pre><code is:raw=""><span>function</span> <span>Icon</span><span>(</span><span><span>{</span> name <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> html<span><span>`</span><span>
    &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; width=&#34;12&#34; height=&#34;12&#34; viewBox=&#34;0 0 12 12&#34;&gt;
      &lt;use href=&#34;./icons.svg#</span><span><span>${</span>name<span>}</span></span><span>&#34; /&gt;
    &lt;/svg&gt;
  </span><span>`</span></span><span>;</span>
<span>}</span>

<span>function</span> <span>Todo</span><span>(</span><span><span>{</span> id<span>,</span> text<span>,</span> done<span>,</span> editable <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> html<span><span>`</span><span>
    &lt;li class=&#34;todo&#34;&gt;
      &lt;input
        type=&#34;checkbox&#34;
        name=&#34;done&#34;
        value=&#34;true&#34;
        hx-get=&#34;./todos/</span><span><span>${</span>id<span>}</span></span><span>/update&#34;
        hx-vals=&#34;js:{done: event.target.checked}&#34;
        </span><span><span>${</span>done <span>&amp;&amp;</span> <span>&#34;checked&#34;</span><span>}</span></span><span>
      /&gt;
      </span><span><span>${</span>editable
        <span>?</span> html<span><span>`</span><span>&lt;input
            type=&#34;text&#34;
            name=&#34;text&#34;
            value=&#34;</span><span><span>${</span>text<span>}</span></span><span>&#34;
            hx-get=&#34;./todos/</span><span><span>${</span>id<span>}</span></span><span>/update&#34;
            hx-trigger=&#34;change,blur&#34;
            autofocus
          /&gt;</span><span>`</span></span>
        <span>:</span> html<span><span>`</span><span>&lt;span
            class=&#34;preview&#34;
            hx-get=&#34;./ui/todos/</span><span><span>${</span>id<span>}</span></span><span>?editable=true&#34;
            hx-trigger=&#34;dblclick&#34;
            hx-target=&#34;closest .todo&#34;
            hx-swap=&#34;outerHTML&#34;
          &gt;
            </span><span><span>${</span>text<span>}</span></span><span>
          &lt;/span&gt;</span><span>`</span></span><span>}</span></span><span>
      &lt;button class=&#34;delete&#34; hx-delete=&#34;./todos/</span><span><span>${</span>id<span>}</span></span><span>&#34;&gt;</span><span><span>${</span><span>Icon</span><span>(</span><span>{</span> <span>name</span><span>:</span> <span>&#34;ex&#34;</span> <span>}</span><span>)</span><span>}</span></span><span>&lt;/button&gt;
    &lt;/li&gt;
  </span><span>`</span></span><span>;</span>
<span>}</span></code></pre>
<p>There are three main parts here: the checkbox, the delete button and the todo text.</p>
<p>First, the checkbox.
It triggers a <code>GET</code> request to <code>/todos/${id}/update</code> every time it’s checked or unchecked, with a query string <code>done</code> matching its current state; htmx swaps the full response into the <code>&lt;body&gt;</code>.</p>
<p>Here’s the code for that route:</p>
<pre><code is:raw=""><span>async</span> <span>function</span> <span>updateTodo</span><span>(</span><span>id<span>,</span> <span>{</span> text<span>,</span> done <span>}</span></span><span>)</span> <span>{</span>
  <span>await</span> <span>update</span><span>(</span><span>&#34;todos&#34;</span><span>,</span> <span>(</span><span>todos <span>=</span> <span>[</span><span>]</span></span><span>)</span> <span>=&gt;</span>
    todos<span>.</span><span>map</span><span>(</span><span>todo</span> <span>=&gt;</span> <span>{</span>
      <span>if</span> <span>(</span>todo<span>.</span>id <span>!==</span> id<span>)</span> <span>return</span> todo<span>;</span>
      <span>return</span> <span>{</span> <span>...</span>todo<span>,</span> <span>text</span><span>:</span> text <span>||</span> todo<span>.</span>text<span>,</span> <span>done</span><span>:</span> done <span>??</span> todo<span>.</span>done <span>}</span><span>;</span>
    <span>}</span><span>)</span>
  <span>)</span><span>;</span>
<span>}</span>

spa<span>.</span><span>get</span><span>(</span><span>&#34;/todos/:id/update&#34;</span><span>,</span> <span>async</span> <span>(</span><span>_request<span>,</span> <span>{</span> params<span>,</span> query <span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> updates <span>=</span> <span>{</span><span>}</span><span>;</span>
  <span>if</span> <span>(</span>query<span>.</span>text<span>)</span> updates<span>.</span>text <span>=</span> query<span>.</span>text<span>;</span>
  <span>if</span> <span>(</span>query<span>.</span>done<span>)</span> updates<span>.</span>done <span>=</span> query<span>.</span>done <span>===</span> <span>&#34;true&#34;</span><span>;</span>

  <span>await</span> <span>updateTodo</span><span>(</span>params<span>.</span>id<span>,</span> updates<span>)</span><span>;</span>

  <span>const</span> html <span>=</span> <span>App</span><span>(</span><span>{</span> <span>filter</span><span>:</span> <span>await</span> <span>getFilter</span><span>(</span><span>)</span><span>,</span> <span>todos</span><span>:</span> <span>await</span> <span>listTodos</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span>
  <span>return</span> <span>new</span> <span>Response</span><span>(</span>html<span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span></code></pre>
<p>(Notice that the route also supports changing the todo text. We’ll get to that in a minute.)</p>
<p>The delete button is even simpler: it makes a <code>DELETE</code> request to <code>/todos/${id}</code>.
As with the checkbox, htmx swaps the full response into the <code>&lt;body&gt;</code>.</p>
<p>Here’s that route:</p>
<pre><code is:raw=""><span>async</span> <span>function</span> <span>deleteTodo</span><span>(</span><span>id</span><span>)</span> <span>{</span>
  <span>await</span> <span>update</span><span>(</span><span>&#34;todos&#34;</span><span>,</span> <span>(</span><span>todos <span>=</span> <span>[</span><span>]</span></span><span>)</span> <span>=&gt;</span> todos<span>.</span><span>filter</span><span>(</span><span>todo</span> <span>=&gt;</span> todo<span>.</span>id <span>!==</span> id<span>)</span><span>)</span><span>;</span>
<span>}</span>

spa<span>.</span><span>delete</span><span>(</span><span>&#34;/todos/:id&#34;</span><span>,</span> <span>async</span> <span>(</span><span>_request<span>,</span> <span>{</span> params <span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>await</span> <span>deleteTodo</span><span>(</span>params<span>.</span>id<span>)</span><span>;</span>

  <span>const</span> html <span>=</span> <span>App</span><span>(</span><span>{</span> <span>filter</span><span>:</span> <span>await</span> <span>getFilter</span><span>(</span><span>)</span><span>,</span> <span>todos</span><span>:</span> <span>await</span> <span>listTodos</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span>
  <span>return</span> <span>new</span> <span>Response</span><span>(</span>html<span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span></code></pre>
<p>The final part is the todo text, which is made more complicated by the support for editing the text.
There are two possible states: “normal”, which just displays a simple <code>&lt;span&gt;</code> with the todo text (I’m sorry that this isn’t accessible!) and “editing”, which displays an <code>&lt;input&gt;</code> that allows the user to edit it.
The <code>Todo</code> component uses the <code>editing</code> “prop” to determine which state to render.</p>
<p>Unlike in a client-side framework like React, though, we can’t just toggle state somewhere and have it make the necessary DOM changes.
htmx makes a network request for the new UI, and we need to return a hypermedia response that it can then swap into the DOM.</p>
<p>Here’s the route:</p>
<pre><code is:raw=""><span>async</span> <span>function</span> <span>getTodo</span><span>(</span><span>id</span><span>)</span> <span>{</span>
  <span>const</span> todos <span>=</span> <span>await</span> <span>listTodos</span><span>(</span><span>)</span><span>;</span>
  <span>return</span> todos<span>.</span><span>find</span><span>(</span><span>todo</span> <span>=&gt;</span> todo<span>.</span>id <span>===</span> id<span>)</span><span>;</span>
<span>}</span>

spa<span>.</span><span>get</span><span>(</span><span>&#34;/ui/todos/:id&#34;</span><span>,</span> <span>async</span> <span>(</span><span>_request<span>,</span> <span>{</span> params<span>,</span> query <span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> todo <span>=</span> <span>await</span> <span>getTodo</span><span>(</span>params<span>.</span>id<span>)</span><span>;</span>
  <span>if</span> <span>(</span><span>!</span>todo<span>)</span> <span>return</span> <span>new</span> <span>Response</span><span>(</span><span>&#34;&#34;</span><span>,</span> <span>{</span> <span>status</span><span>:</span> <span>404</span> <span>}</span><span>)</span><span>;</span>

  <span>const</span> editable <span>=</span> query<span>.</span>editable <span>===</span> <span>&#34;true&#34;</span><span>;</span>

  <span>const</span> html <span>=</span> <span>Todo</span><span>(</span><span>{</span> <span>...</span>todo<span>,</span> editable <span>}</span><span>)</span><span>;</span>
  <span>return</span> <span>new</span> <span>Response</span><span>(</span>html<span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span></code></pre>
<p>At a high level, the coordination between webpage and service worker looks something like this:</p>
<ol>
<li>htmx listens for double-click events on todo text <code>&lt;span&gt;</code>s</li>
<li>htmx makes a request to <code>/ui/todos/${id}?editable=true</code></li>
<li>The service worker returns the HTML for the <code>Todo</code> component that includes the <code>&lt;input&gt;</code> rather than the <code>&lt;span&gt;</code></li>
<li>htmx swaps the current todo list item with the HTML from the response</li>
</ol>
<p>When the user changes the input, a similar process happens, calling the <code>/todos/${id}/update</code> endpoint instead and swapping the whole <code>&lt;body&gt;</code>.
If you’ve used htmx, this should be a pretty familiar pattern.</p>
<p>That’s it!
We now have a single-page app built with htmx (and service workers) that doesn’t rely on a remote web server.
The code I omitted for brevity is available <a href="https://github.com/jakelazaroff/htmx-spa" data-astro-cid-bi7aps5f="">on GitHub</a><a data-tooltip="" href="https://github.com/jakelazaroff/htmx-spa" data-astro-cid-bi7aps5f=""> <img src="https://opengraph.githubassets.com/94ef73a40c4bb7e207bf004946c9b849faf5e9d6512853537e0506f0735e42d9/jakelazaroff/htmx-spa" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">GitHub - jakelazaroff/htmx-spa: A proof of concept fully client-side single-page app using htmx and service workers.</span> <span data-astro-cid-bi7aps5f="">A proof of concept fully client-side single-page app using htmx and service workers. - jakelazaroff/htmx-spa</span> <span data-astro-cid-bi7aps5f=""> <img src="https://github.githubassets.com/favicons/favicon.svg" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">github.com/jakelazaroff/htmx-spa</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>.</p>
<h3 id="takeaways">Takeaways</h3>
<p>So, this technically works.
Is it a good idea?
Is it the <em>apotheosis</em> of hypermedia-based applications?
Should we abandon React and build apps like this?</p>
<p>htmx works by adding indirection to the UI, loading new HTML from across a network boundary.
That can make sense in a client-server app, because it reduces indirection with regard to the <em>database</em> by colocating it with rendering.
On the other hand, the client-server story in a framework like React can be painful, requiring careful coordination between clients and servers via an awkward data exchange channel.</p>
<p>When all interactions are local, though, the rendering and data are <em>already</em> colocated (in memory) and updating them in tandem with a framework like React is easy and synchronous.
In this case, the indirection that htmx requires starts to feel more burdensome than liberatory.<sup><a href="#user-content-fn-nojs" id="user-content-fnref-nojs" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">3</a></sup>
For fully local apps, I don’t think juice is worth the squeeze.</p>
<p>Of course, most apps aren’t <em>fully</em> local — usually, there’s a mix of local interactions and network requests.
My sense is that even in that case, <a href="https://www.patterns.dev/vanilla/islands-architecture/" data-astro-cid-bi7aps5f="">islands of interactivity</a><a data-tooltip="" href="https://www.patterns.dev/vanilla/islands-architecture/" data-astro-cid-bi7aps5f=""> <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/f_auto/v1633286240/patterns.dev/islandsarchitecture.jpg" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Islands Architecture</span> <span data-astro-cid-bi7aps5f="">The islands architecture encourages small, focused chunks of interactivity within server-rendered web pages</span> <span data-astro-cid-bi7aps5f=""> <img src="https://www.patterns.dev/img/favicon/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">www.patterns.dev/vanilla/islands-architecture/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> is a better pattern than splitting your “server-side” code between the service worker and the actual server.</p>
<p>In any event, this was mostly an exercise to see what it might look like to build a fully local single-page app using hypermedia, rather than imperative or functional programming.</p>
<p>Note that hypermedia is a technique rather than a specific tool.
I chose htmx because it’s the hypermedia <del>library</del> <a href="https://htmx.org/essays/is-htmx-another-javascript-framework/" data-astro-cid-bi7aps5f="">framework</a><a data-tooltip="" href="https://htmx.org/essays/is-htmx-another-javascript-framework/" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">&lt;/&gt; htmx ~ Is htmx Just Another JavaScript Framework?</span> <span data-astro-cid-bi7aps5f="">htmx gives you access to AJAX, CSS Transitions, WebSockets and Server Sent Events directly in HTML, using attributes, so you can build modern user interfaces with the simplicity and power of hypertext

    htmx is small (~14k min.gz’d), dependency-free, extendable, IE11 compatible &amp; has reduced code base sizes by 67% when compared with react</span> <span data-astro-cid-bi7aps5f=""> <img src="https://htmx.org/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">htmx.org/essays/is-htmx-another-javascript-framework/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> <em>du jour</em>, and I wanted to stretch it as far as I could.
There are other tools like <a href="https://mavo.io" data-astro-cid-bi7aps5f="">Mavo</a><a data-tooltip="" href="https://mavo.io" data-astro-cid-bi7aps5f=""> <img src="https://mavo.io/logo.svg" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Mavo: A new, approachable way to create Web applications</span>  <span data-astro-cid-bi7aps5f=""> <img src="https://mavo.io/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">mavo.io</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> that explicitly focus on this use case, and indeed you can see that the <a href="https://mavo.io/demos/todo/" data-astro-cid-bi7aps5f="">Mavo implementation of TodoMVC</a><a data-tooltip="" href="https://mavo.io/demos/todo/" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">To-Do List</span>  <span data-astro-cid-bi7aps5f=""> <img src="https://mavo.io/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">mavo.io/demos/todo/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> is far simpler than what I’ve built here.
Better still would be some sort of HyperCard-esque app in which you could build the whole thing visually.</p>
<p>All in all, my little single-page htmx todo app was fun to build.
If nothing else, take this as a reminder that you can and should occasionally try using your tools in weird and unexpected ways!</p>

<section data-footnotes="">
<ol>
<li id="user-content-fn-clickbait">
<p>React developers hate him! <a href="#user-content-fnref-clickbait" data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-get">
<p>You might notice that the form method is <code>GET</code> rather than <code>POST</code>. That’s because service workers in Firefox don’t seem to support request bodies, which means we need to include any relevant data in the URL. <a href="#user-content-fnref-get" data-footnote-backref="" aria-label="Back to reference 2" class="data-footnote-backref" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-nojs">
<p>htmx isn’t actually a required component of this architecture.
You could, in theory, build a fully client-side single-page app with no JavaScript at all (outside of the service worker) by simply wrapping every button in a <code>&lt;form&gt;</code> tag and replacing the full page on every action.
Since the responses all come from the service worker, it would still be lightning fast; you could probably even add in some slick animations using <a href="https://developer.chrome.com/docs/web-platform/view-transitions#cross-document_view_transitions" data-astro-cid-bi7aps5f="">cross-document view transitions</a><a data-tooltip="" href="https://developer.chrome.com/docs/web-platform/view-transitions#cross-document_view_transitions" data-astro-cid-bi7aps5f=""> <img src="https://www.gstatic.com/devrel-devsite/prod/vfebef541c9fc0d1ace8dfdb0f441925a06e1d514c8d869e9f136cb4460077d33/chrome/images/lockup.svg" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Smooth transitions with the View Transition API  |  View Transitions  |  Chrome for Developers</span> <span data-astro-cid-bi7aps5f="">The View Transition API lets you add transitions between views of a website.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://www.gstatic.com/devrel-devsite/prod/vfebef541c9fc0d1ace8dfdb0f441925a06e1d514c8d869e9f136cb4460077d33/chrome/images/favicon.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">developer.chrome.com/docs/web-platform/view-transitions#cross-document_view_transitions</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>. <a href="#user-content-fnref-nojs" data-footnote-backref="" aria-label="Back to reference 3" class="data-footnote-backref" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
</ol>
</section> </div></div>
  </body>
</html>
