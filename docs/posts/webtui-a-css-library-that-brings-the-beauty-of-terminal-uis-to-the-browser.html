<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://webtui.ironclad.sh">Original</a>
    <h1>WebTUI â€“ A CSS Library That Brings the Beauty of Terminal UIs to the Browser</h1>
    
    <div id="readability-page-1" class="page"><div><section><p>A few years ago, when I was in university, I designed a single-board computer for fun. It was based on the Motorola 68000 CPU, and I wanted it to be kind of like the TRS-80 Model 100. This meant it had a built in keyboard and a 240x64 LCD screen.</p><p>This computer technically worked, but it had lots of problems. Most of these problems related to the stability of the machine, but there were also a few other minor bugs that were annoying. This project sat in my basement for a few years until I dug it out last Christmas and started playing with it again. I was able to solve some bugs (like the debug circuitry not working properly) but determined other problems would need a full respin of the board.</p><p>Fast forward to late January and I decided I was going to design a new one from scratch. This new board would fix the bugs on the original. I also decided to remove the onboard keyboard, and replace the glue logic with a CPLD. I&#39;ve never used a CPLD before, so I was excited to learn about that.</p></section><h2>The Board</h2><section><p><a href="https://www.scd31.com/img/sbc/mainboard.png"><img src="https://www.scd31.com/thumb/sbc/mainboard.png"/></a></p><p>I designed this board in about a day. It&#39;s much smaller than my first design; the lack of a keyboard and 7400-series glue logic saves a lot of space. It sports the following features:</p><ul><li><p>M68k CPU (of course!)</p></li><li><p>1MB RAM</p></li><li><p>64K of ROM</p></li><li><p>2 RS-232 serial ports</p></li><li><p>2 Expansion slots</p></li><li><p>240x64 LCD display</p></li><li><p>IDE hard drive support</p></li><li><p>ATX power supply for power</p></li><li><p>Single-stepping debug logic (i.e. step one memory access at a time)</p></li><li><p>LEDs to view address/data bus status</p></li></ul><p>From left to right, there&#39;s the following:</p><ul><li><p>IDE connector</p></li><li><p>CPLD</p></li><li><p>M68k CPU</p></li><li><p>RAM chips</p></li><li><p>ROM chips</p></li><li><p>68681 serial chip</p></li></ul><p>Due to my own incompetence it took about a month to get all the parts to assemble the board. Once everything I arrived, I slowly started populating the board and testing things out. I started with the CPLD, because it&#39;s critical to the whole system and also what I knew the least about.</p></section><h2>The CPLD</h2><section><p>I chose to go with the ATF15xx series of CPLDs, for one simple reason: they&#39;re the only CPLDs that support 5V and are still in production. Unfortunately, they&#39;re also quite old, and getting the toolchain running was a bit of a challenge. I followed the guides in <a href="https://github.com/peterzieba/5Vpld">this GitHub repository</a> and got something that worked. I had to write the firmware in an HDL called WinCUPL. It sucks even more than most HDLs, plus there&#39;s no syntax highlighting for it in Emacs. I also found that certain code errors would cause the firmware to not get synthesized but it wouldn&#39;t throw a compiler error. I wasted a bunch of time trying to figure out why my code changes weren&#39;t causing behaviour changes before I figured this out. Shortly after, I updated my Makefile to blow away previous artifacts on every build, so that at least I&#39;d know if an artifact wasn&#39;t created.</p><p>Aside from the software, the hardware was also challenging. Turns out my board&#39;s JTAG pinout is completely wrong (oops! Friendly reminder to always verify your footprints). I used jumpers to remedy this, but then I found out my JTAG programmer didn&#39;t work either. I ended up going through three programmers before I realized the stock firmware doesn&#39;t work properly. I was able to flash some <a href="https://github.com/dougg3/CH55x-USB-Blaster">open source firmware onto mine</a> and then they both worked flawlessly! I say &#34;both&#34; and not &#34;all&#34; because the third programmer I bought was an FTDI232H which worked out-of-the-box.</p><p>I probably wasted around a week and a half getting all of this working. Eventually, though, I was able to blink an LED by dividing an 8MHz clock signal using a bunch of D flip-flops in the CPLD. I don&#39;t think I&#39;ve been this excited by a blinking LED in years!</p><p>Once I got the CPLD working, it was a pretty straightforward, but tedious, process of bringing up the rest of the board. I gradually soldered more parts on, and verified everything worked correctly. Soon, I was able to write some simple software.</p></section><h2>Board rework</h2><section><p>Fairly early on I found 2 major problems with the board. Due to a misunderstanding of KiCad I connected the wrong address pins to the CPLD, meaning there was no way for the address decoder to function. I also neglected to connect any data pins to the CPLD. I would need these to handle interrupts properly.</p><p>Luckily, the CPLD had enough free pins that I could just run a bunch of jumpers. It was tedious getting everything soldered, but overall it wasn&#39;t too bad.</p><p><a href="https://www.scd31.com/img/sbc/rework.jpg"><img src="https://www.scd31.com/thumb/sbc/rework.jpg"/></a></p><p>After everything was attached, I applied a generous amount of hot glue to protect everything.</p></section><h2>Software Development</h2><section><p>As with my first SBC, one of the first programs I wrote was designed to blink the address lights.</p><pre><span>
</span><span>     .global _start
</span><span> 	
</span><span>     .long 0x1</span><span>40500</span><span>        /* stack pointer</span><span> */
</span><span>     .long _start
</span><span> 
</span><span>     .org 0x4</span><span>00
</span><span> 
</span><span> _start:
</span><span>     /* Disable interrupts</span><span> */
</span><span>     </span><span>ORI.W</span><span> #0x7</span><span>00</span><span>, %sr
</span><span>     </span><span>JMP</span><span> LOWER_LOOP
</span><span> 
</span><span>     .org 0x1</span><span>000
</span><span> LOWER_LOOP:
</span><span>     </span><span>ADD.L</span><span> #</span><span>1</span><span>, %</span><span>d0
</span><span>     </span><span>CMP.L</span><span> #</span><span>200000</span><span>, %</span><span>d0
</span><span>     JNE LOWER_LOOP
</span><span>     </span><span>EOR.L</span><span> %</span><span>d0</span><span>, %</span><span>d0
</span><span>     </span><span>JMP</span><span> UPPER_LOOP
</span><span> 	
</span><span>     .org 0x2</span><span>000
</span><span> UPPER_LOOP:
</span><span>     </span><span>ADD.L</span><span> #</span><span>1</span><span>, %</span><span>d0
</span><span>     </span><span>CMP.L</span><span> #</span><span>200000</span><span>, %</span><span>d0
</span><span>     JNE UPPER_LOOP
</span><span>     </span><span>EOR.L</span><span> %</span><span>d0</span><span>, %</span><span>d0
</span><span>     </span><span>JMP</span><span> LOWER_LOOP
</span><span>
</span></pre>
<p>I didn&#39;t have working interrupts when I wrote this, so I&#39;m using busy loops to keep track of time. The idea is to flip-flop between a loop at 0x1000 and 0x2000, such that the address lights toggle back and forth. And it worked great:</p>
</section><h2>Improving development UX</h2><section><p>The development process was very tedious. I would need to pop out the ROM chips from the board and reprogram them every time I wanted to change the code. This was also putting quite a bit of strain on the chip holders; they were rapidly falling apart.</p><p>I decided to write a memory monitor, so that I could write programs directly to RAM over serial. I called it Meowmon; its interface is similar to Wozmon. It lives <a href="https://gitlab.scd31.com/stephen/m68k-computer/-/tree/master/software/meowmon">here</a>. I wrote it entirely in M68k assembler, largely while falling asleep on the subway late at night.</p><p>A memory monitor allows me to peek at sections of memory, poke bytes, and jump to a specific location. It allows me to write in a program and then execute it in RAM, without needing to physically remove anything from the board. I gave the computer the ability to write to its own ROM, so you can even use Meowmon to change itself.</p><p>I also wrote a flasher program, located <a href="https://gitlab.scd31.com/stephen/m68k-computer/-/tree/master/meowmon-flasher">here</a>. This allows taking a binary file and uploading it to Meowmon over serial. Then it&#39;s just a matter of typing &#39;R&#39; to jump to the new code.</p><p>With these new programs, my development cycle had gone from a tedious few minutes to a very easy few seconds. I was ready to start tackling some more complex software.</p></section><h2>Mandelbrot</h2><section><p>I was really getting into the flow at this point so I decided to write a Mandelbrot generator. I was still working in assembler, of course, plus the M68k doesn&#39;t have hardware floating point support, so I did everything with integers. I also keep track of everything in registers for additional speed. The result is I was able to generate the following in just a few seconds:</p><pre><span>
</span><span>                                                           @
</span><span>                                                        @@@@@@
</span><span>                                                        @@@@@@
</span><span>                                            @            @@@@
</span><span>                                              @@    @@@@@@@@@@@@@@@
</span><span>                                               @@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                                            @@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                                          @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                                          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                           @@   @         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                           @@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                          @@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                      @@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span> @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                      @  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                          @@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                           @@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                           @@ @ @         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                                          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                                          @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                                              @@@@@@@@@@@@@@@@@@@@@@@@@@@
</span><span>                                              @@    @@@@@@@@@@@@@@@
</span><span>                                                         @@@@
</span><span>                                                        @@@@@@@
</span><span>                                                        @@@@@@
</span><span>                                                           @
</span><span>
</span></pre>
<p>Once satisfied with the ASCII Mandelbrot, I wrote a display driver and rendered it there instead:</p><p><a href="https://www.scd31.com/img/sbc/mandelbrot.jpg"><img src="https://www.scd31.com/thumb/sbc/mandelbrot.jpg"/></a></p><p>The Mandelbrot code lives <a href="https://gitlab.scd31.com/stephen/m68k-computer/-/blob/master/software/debug/mandelbrot.s">here</a>.</p></section><h2>Cross-compiling</h2><section><p>Now happy that the computer works well, I decided to upgrade to a high-level language: C! I&#39;d need a cross-compiler that runs on x86 and spits out M68k binaries.</p><p>Getting the cross-compiler running should have been straightforward - I&#39;m on NixOS so it should have just been a matter of installing it. There are some bugs here though, which required some changes to nixpkgs (thanks K900!). I&#39;m installing the cross-compiler from their nixpkgs fork, as you can see <a href="https://gitlab.scd31.com/stephen/m68k-computer/-/blob/master/software/flake.nix#L4">here</a>.</p><p>I was unable to get the cross-compiler working properly. The binary it spits out is almost valid, but some of the helper functions use Motorola 68030 instructions. The most glaring example is spitting out jumps with 32-bit offsets, which the Motorola 68000 doesn&#39;t support. Again, this only affects helper functions, not my code. My theory is that the helper functions are pre-compiled and default to the 68030.</p><p>Even though I wasn&#39;t able to get this working, I made a huge amount of progress thanks to Won at RC, and K900 in the NixOS support channels on Matrix. Thanks to the both of you for tolerating my excessive questions and helping me get close to the bottom of this!</p></section><h2>Next Steps</h2><section><p>I have many more plans for this board. Getting the cross-compiler working is pretty high on the priority list. I also want to get the board booting off an IDE hard drive. This would involve writing a simple driver and some firmware that runs in ROM.</p><p>Aside from that, I should probably do a board respin. I need to fix the interrupts properly and fix the pinout of the JTAG connector. I&#39;d also like to make the LEDs dimmer - they&#39;re distractingly bright. I&#39;m debating putting Ethernet on the board as well. Initially I was going to make this an expansion card, but if I&#39;m respinning the board anyway, maybe I should just add it.</p><p>Everything related to this project lives in a single <a href="https://gitlab.scd31.com/stephen/m68k-computer">monorepo</a>.</p></section></div></div>
  </body>
</html>
