<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.backslasher.net/1.5GB-string.html">Original</a>
    <h1>A 1.5GB String</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    

    

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          4 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        
        <p>In my previous role, I supported a Java service that operated similarly to RDP or Citrix by enabling remote UI functionality. This service relied on sessions, which consisted of interconnected Java objects that were supposed to be cleaned up either when a user logged out or after a predetermined timeout period.</p>

<p>During the course of our capacity planning, we discovered a significant memory waste that I wanted to share with you.</p>

<h2 id="capacity-planning">Capacity Planning</h2>
<p>Part of my routine work with the team included capacity planning for the next year.
By analyzing our usage metrics, growth patterns, and population research, our data scientists were able to predict <em>how many users we could expect to have in the coming year</em>.</p>

<p>To determine the necessary infrastructure required to support this anticipated user base, we employed a sophisticated formula:</p>

\[\text{Number of Servers} = { \text{Number of Users} \over \text{Users per Server} } * \text{Safety Buffer}\]

<p>To know how many <em>servers</em> we need to have for next year.</p>

<p>One of our capacity planning sessions revealed that, due to the immense popularity of our service, we were anticipating a significant growth in the number of users in the coming year. Our calculations indicated that we would require more servers than we had available to accommodate this increased demand. Consequently, we were faced with the challenge of figuring out how to fit more users onto each individual server in order to support the projected user base.</p>

<h2 id="what-are-we-bound-on">What are we bound on?</h2>
<p>With capacity measurement, we can pinpoint the bottleneck in our system, and in this case, it is the memory. As more users are added to the server, the system begins to falter under the increased load, ultimately running out of memory. Understanding we are <em>memory-bound</em> is crucial, as it directs our efforts towards reducing memory consumption in order to accommodate more users on the server.</p>

<h2 id="investigating-memory-usage">Investigating memory usage</h2>
<p>We had a crude estimation of our per-user memory consumption using this:</p>

\[\text{Per User Memory} = { \text{Server Memory} \over \text{User Capacity} }\]

<p>Using imaginary numbers, we can say something like:</p>

\[\text{Per User Memory} = \text{300MB} = { \text{90 GB} \over \text{300} }\]

<p>So we can approxiamte per-user memory requirement as 300MB.
In order to understand how to reduce this number, we went into more serious memory measurement.</p>

<p>We began analyzing the Java memory dump of our servers to identify potential areas for improvement. Initially, we reviewed the dumps manually, but due to the sheer number of servers, we developed a custom script to automate the process. Using this script, we were able to identify memory-wasting objects that were attributed to specific sessions. By pinpointing these issues, we can effectively eliminate the waste and optimize our system’s memory usage.</p>

<p>I might cover the script and analysis in another post, but for now I want to focus on a specific quick win the memory analysis gave us.</p>

<h2 id="a-very-big-string">A very big string</h2>
<p>We started with going over our thousands of memdumps and looking for very big objects. Our biggest whale was a 1.5GB string. It looked something like this:</p>

<p><img src="https://blog.backslasher.net/assets/1.5GB-string/quote.png" alt="\\\\\\\\\\\\\\\\\\\&#34;"/></p>

<p>In case the picture didn’t convey the message, the string contained many many backslashes. We found similar smaller ones, but this one was the biggest.</p>

<p>Investigating what the purpose of the string was, I saw that we had classes that looked like this:</p>

<div><div><pre><code>
<span>class</span> <span>Screen</span> <span>{</span>
  <span>//...</span>
  <span>private</span> <span>Screen</span> <span>previous</span><span>;</span>

  <span>public</span> <span>String</span> <span>toJson</span><span>()</span> <span>{</span>
    <span>JSONObject</span> <span>jo</span> <span>=</span> <span>new</span> <span>JSONObject</span><span>();</span>
    <span>//...</span>
    <span>if</span> <span>(</span><span>previous</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
      <span>jo</span><span>.</span><span>put</span><span>(</span><span>&#34;previous&#34;</span><span>,</span> <span>previous</span><span>.</span><span>toJson</span><span>());</span>
    <span>}</span>
    <span>//...</span>
    <span>return</span> <span>jo</span><span>.</span><span>toString</span><span>();</span>
  <span>}</span>
<span>}</span>

<span>class</span> <span>Session</span> <span>{</span>
  <span>//...</span>
  <span>String</span> <span>currentScreen</span><span>;</span>

  <span>public</span> <span>void</span> <span>setUrl</span><span>(</span><span>Screen</span> <span>s</span><span>)</span> <span>{</span>
    <span>currentScreen</span> <span>=</span> <span>s</span><span>.</span><span>toJson</span><span>();</span>
  <span>}</span>
<span>}</span>

</code></pre></div></div>

<p>So each screen has the previous screen the user visited, to allow the user to go “back” and get the exact screen they were in before (state, scrolling position, validation notices etc). The user session also has the current screen the user is in, so if the user reconnects to an existing session, we can return to where they were.</p>

<p>There are two design problems here:</p>
<ol>
  <li>The “back” stack is unlimited, meaning we’re saving more and more state until we explode</li>
  <li>by running <code>jo.put(&#34;previous&#34;, previous.toJson());</code>, we’re converting the JSON dictionary to a string. Since JSON fields have quotes, and those quotes need to be escaped when stored in a string, they are stored as <code>\&#34;</code>.
That backslash needs to be escaped when this string is stored inside another string, compouding into <code>\\\&#34;</code>. A couple more rounds of this, and we get <code>\\\\\\\\\\\\\\\\&#34;</code></li>
</ol>

<p>It turns out that a user with a session with lots of screens produced a <code>currentScreen</code> String of gigantic proportions.</p>

<h2 id="handling-and-followup">Handling and followup</h2>
<p>We divided the problem into a quick fix and a long-term one:</p>

<p>The quick fix was truncating the “previous” string if it goes over a specific char amount (e.g. not letting it go over 100MB).
While this is not a complete solution and might impact the user experience, it was very quick to implement and easy to test, boosting our reliability (preventing a specific session from inflating and bringing the server down).</p>

<p>The long-term fix was rewriting the “previous” stack solution completely, creating a dedicated real stack with self-imposed size limits and reporting.
It took a long time to write, and longer to test and slowly release, but it really prevented memory waste, rather than only hide away whale-strings as another form of memory (e.g. very deep JSON objects).</p>

<h2 id="epilogue">Epilogue</h2>
<p>We continued to use the memory-dump analysis tool and found more nonsense we killed, but nothing as easy as this.</p>

<p>My main takeway from this story is that sometimes, checking the details of how your program uses resources (e.g. examining a memdump rather than just measuring overall memory utilization) is crucial for success and produces quick wins from the start.</p>

        
      </section>

      

      

      
  

    </div></div>
  </body>
</html>
