<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://quuxplusone.github.io/blog/2020/05/28/oo-antipattern/">Original</a>
    <h1>The use of ‘class’ for things that should be simple free functions (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>For those who only read above the fold: I <em>don’t</em> say that all object-orientation is bad!
OOP, especially classical polymorphic OOP, has a well-deserved place in real code.
I’m going to talk about a very specific antipattern that I see with some frequency:
the use of <code>class</code> for things that should be simple free functions.</p>

<p>I originally wrote about this specific piece of code
<a href="https://codereview.stackexchange.com/questions/188300/counting-the-number-of-domino-tilings-for-a-rectangular-grid">on Code Review StackExchange</a>
(February 2018). I gave an unrecorded lightning talk based on the same material in April 2018.</p>

<p>If this kind of thing appeals to you, I recommend with the highest possible recommendation
that you get yourself a copy of Kernighan and Plauger’s <a href="https://amzn.to/2X5W1H0"><em>The Elements of Programming Style</em></a>
(1974, reissued 1978).</p>

<h2 id="the-original-code">The original code</h2>

<p>Students who’ve learned C++ in a particular kind of academic setting often approach
it with the “everything is an object” mindset. Suppose they’re given a task to compute
some value; then their first step is to create a <code>ValueComputer</code> object with a
member function <code>vc.computeResult()</code>.</p>

<p>For example: A student is asked to use <a href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a>
to count the number of distinct <a href="https://en.wikipedia.org/wiki/Domino_tiling">domino tilings</a>
of a \(w\times h\) rectangle. The student writes:</p>

<div><div><pre><code>int main()
{
    DominoTilingCounter tc(4, 7);  // in a 4x7 rectangle
    std::cout &lt;&lt; tc.count() &lt;&lt; &#39;\n&#39;;
}
</code></pre></div></div>

<p>Having framed the problem, they go on to implement the <code>DominoTilingCounter</code> class.
The clever student even adds memoization, so that the <code>count()</code> member function won’t be
so slow the second time it’s called:</p>

<div><div><pre><code>class DominoTilingCounter {
    int height, width;
    bool done = false;
    int tilingCount;
    int computeCount(int h, int w, std::string_view prevRow, int rowIdx) {
        [...recursive solution omitted...]
    }
public:
    explicit DominoTilingCounter(int h, int w) : height(h), width(w) {
        if (h == 0 || w == 0 || (w*h) % 2 != 0) {
            tilingCount = 0;
            done = true;
        }
    }
    int count() {
        if (!done) {
            tilingCount = computeCount(height, width, &#34;&#34;, 0);
            done = true;
        }
        return tilingCount;
    }
};
</code></pre></div></div>

<p>(Experienced programmers may be cringing, here. That’s the point.)</p>

<p>Unfortunately, this code fails the <a href="https://quuxplusone.github.io/blog/2019/01/03/const-is-a-contract/">const-correctness</a> test:
the <code>count()</code> member function sounds like it should be non-modifying, but in fact
it needs to update member data and thus cannot be const.</p>

<div><div><pre><code>std::cout &lt;&lt; DominoTilingCounter(4, 7).count() &lt;&lt; &#39;\n&#39;;
    // Fails to compile!
</code></pre></div></div>

<p>(Hacker News points out that this <em>does</em> compile; class prvalues are not const
the way scalar prvalues are. Oops.)
Anyway, we can fix this issue incidentally, just by applying a little more logic.</p>

<h2 id="the-logical-leap">The logical leap</h2>

<p>Look: when you construct a <code>DominoTilingCounter</code> object <code>tc</code>,
it is <em>specifically for the purpose</em> of computing <code>tc.count()</code>, right?
There’s no other purpose that <code>tc</code> could serve?</p>

<p>Again: When you <b>construct</b> a <code>DominoTilingCounter</code> object, it is specifically
for the purpose of <b>computing</b> <code>tc.count()</code>.</p>

<p>So put the <b>computation</b> in the <b>constructor!</b></p>

<div><div><pre><code>class DominoTilingCounter {
    int height, width;
    int tilingCount;
    int computeCount(int h, int w, std::string_view prevRow, int rowIdx) {
        [...recursive solution omitted...]
    }
public:
    explicit DominoTilingCounter(int h, int w) : height(h), width(w) {
        if (h == 0 || w == 0 || (w*h) % 2 != 0) {
            tilingCount = 0;
        } else {
            tilingCount = computeCount(height, width, &#34;&#34;, 0);
        }
    }
    int count() const {
        return tilingCount;
    }
};
</code></pre></div></div>

<p>This refactoring does several things:</p>

<ul>
  <li>
    <p>It permits <code>count()</code> to be a const member function.</p>
  </li>
  <li>
    <p>It eliminates the “empty, uncomputed” state from your program.</p>
  </li>
  <li>
    <p>It eliminates the data member <code>done</code>, whose whole purpose was to track that empty state.
  (In C++17 we might use a <code>std::optional</code> for that purpose; but look, now we don’t have to!)</p>
  </li>
</ul>

<p>In fact, the private data members <code>height</code> and <code>width</code> are now unused as well. It turns out
that we were using them only to pass data from the constructor to the computation in
the <code>count()</code> method; and now that the computation is taking place in the constructor, we
don’t need those data members anymore. Our code shrinks drastically.</p>

<h2 id="the-final-leap">The final leap</h2>

<p>In the original code, the student’s <code>computeCount</code> member function happened to take <code>w</code> and <code>h</code>
as function parameters, rather than reading them from the <code>height</code> and <code>width</code> data members.
That was a fortunate accident: <code>computeCount</code> doesn’t use any of the
data members of the <code>DominoTilingCounter</code> object, and so we can mark it <code>static</code>.
Our code is now something like this:</p>

<div><div><pre><code>class DominoTilingCounter {
    int tilingCount;
    static int computeCount(int h, int w, std::string_view prevRow, int rowIdx) {
        if (h == 0 || w == 0 || (w*h) % 2 != 0) {
            return 0;
        }
        [...recursive solution omitted...]
    }
public:
    explicit DominoTilingCounter(int h, int w) {
        tilingCount = computeCount(h, w, &#34;&#34;, 0);
    }
    int count() const {
        return tilingCount;
    }
};
</code></pre></div></div>

<p>The final leap is to observe that this entire class does nothing but wrap an assignment to an <code>int</code>!</p>

<blockquote>
  <p>Avoid classes that are tantamount to <code>int</code>.</p>
</blockquote>

<p>What we <em>should</em> write is a simple free function <code>countDominoTilings(w, h)</code>:</p>

<div><div><pre><code>int countDominoTilingsImpl(int h, int w, std::string_view prevRow, int rowIdx) {
    if (h == 0 || w == 0 || (w*h) % 2 != 0) {
        return 0;
    }
    [...recursive solution omitted...]
}

int countDominoTilings(int h, int w) {
    return countDominoTilingsImpl(h, w, &#34;&#34;, 0);
}

int main() {
    int tc = countDominoTilings(4, 7);  // in a 4x7 rectangle
    std::cout &lt;&lt; tc &lt;&lt; &#39;\n&#39;;
}
</code></pre></div></div>

<p>No more <code>class</code>, no more worrying about const, no more worrying about memoization (it becomes the
caller’s problem, for better or worse). Our original <code>DominoTilingCounter</code> object wasn’t thread-safe,
but now we don’t have to worry about that, either. And our code is about a dozen lines shorter.</p>

<hr/>

<p>Again, this is not to say that all classes are bad! In fact, the antipattern discussed here is
very close to the <a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder pattern</a>,
and there’s nothing wrong with the Builder pattern — when it’s needed, that is.
All I’m saying is:</p>

<p>When you have to compute a value, don’t write a <code>ValueComputer</code> class.</p>

<hr/>

<p>For other takes on this topic, see:</p>

<ul>
  <li>
    <p><a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">“Execution in the Kingdom of Nouns”</a> (Steve Yegge, March 2006)</p>
  </li>
  <li>
    <p><a href="https://www.youtube.com/watch?v=o9pEzgHorH0">“Stop Writing Classes”</a> (Jack Diederich, PyCon 2012)</p>
  </li>
</ul>

  </div></div>
  </body>
</html>
