<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wassimulator.com/blog/programming/programming_vehicles_in_games.html">Original</a>
    <h1>Programming vehicles in games</h1>
    
    <div id="readability-page-1" class="page"><div>



        <!-- <div style="text-align:center;"><i>Sunday, Apr 17, 2022</i></div> -->
        
        <p>The fundamental principles needed to get a functional vehicle in your game.</p>
<p>
  From my talk at the 
  <a href="https://bettersoftwareconference.com/" target="_blank">Better Software Conference</a> 
  on July the 13th, 2025.
  </p><p><i>est. reading time: 45 minutes</i></p>
  

    <p>Watch the video of the talk here:</p>
        

      <h2>Table of Contents</h2>
      <ul>
        <li>
          <a href="#introduction">The special case of cars</a>
          <ul>
            <li><a href="#av_racer">Chasing the Feel: The Iterative Path to AV-Racer</a></li>
          </ul>
        </li>
      
        <li>
          <a href="#conceptual_model">A Conceptual Model of Vehicle Simulation</a>
          <ul>
            <li>
              <a href="#engine">The Engine</a>
              <ul>
                <li><a href="#gearbox">The Gearbox</a></li>
                <li>
                  <a href="#implement_engine">Implementing the engine and drivetrain: From Curve to Code</a>
                  <ul>
                    <li><a href="#engine_equation">The engine&#39;s equation</a></li>
                    <li><a href="#wheel_equation">The driven wheel&#39;s equation</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          
            <li>
              <a href="#tire">The Tire Model</a>
              <ul>
                <li>
                  <a href="#longitudinal">Longitudinal Tire Forces</a>
                  <ul>
                    <li><a href="#sr">The Slip Ratio</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#lateral">Lateral Tire Forces</a>
                  <ul>
                    <li><a href="#sa">The Slip Angle</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#combine">Combining the longitudinal and lateral components</a>
                  <ul>
                    <li><a href="#circle">The Friction Circle</a></li>
                    <li><a href="#driver">From a driver&#39;s point of view</a></li>
                  </ul>
                </li>
              </ul>
            </li><li><a href="#chassis">Integration onto the chassis</a></li>
            
          </ul>
        </li>
      </ul>

      <hr/>
        <p>Cars are everywhere in games. They&#39;re a staple element of many genres, even in games that aren&#39;t strictly about cars. If a game world involves any sort of traversal, chances are there&#39;s a vehicle in it (unless you&#39;re deep in the realm of fantasy where you are riding a horse. The following will not cover programming horses, I apologize).</p>

        
        <p><img src="https://wassimulator.com/data/images/bsc_4.png" alt="Many car games" width="100%"/></p><p>The range of experiences that games offer through vehicles is massive. And that&#39;s what makes them fascinating to work with. Ever since I was a kid, I&#39;ve played a variety of racing and vehicle games. I&#39;d always chase the next racing title as soon as it hit the platform I had. But what struck me over time wasn&#39;t just the excitement of new cars or tracks; it was how different each experience felt, even though they all had cars at their core.</p>
        
        <p>And here&#39;s the key insight: games are not physics engines. They are experiences. And racing games, more than many others, deliberately manipulate reality to deliver those experiences. With shooting games, for example, we expect certain behavior; bullets flying in straight lines, recoil, reloads. If those expectations aren&#39;t met, the game feels “off.” But with vehicles? There&#39;s an incredible amount of wiggle room.</p>
        
        <p>Take Mario Kart. It&#39;s about as far from realistic driving as you can get; you&#39;re drifting on sand, tossing shells at your friends, and racing in a mushroom-powered go-kart that&#39;s all squashed proportions and cartoon physics. And yet it&#39;s beloved. It sells the fantasy of driving.</p>
        <p>On the opposite end, you have full-blown simulators like iRacing or Assetto Corsa. Here, the experience is carefully crafted to reflect the nuance and challenge of real-life motorsport. People sink thousands of dollars into rigs just to replicate the feeling of being behind the wheel. And yet; both these games are programming cars at their core. They just prioritize different aspects of that experience.</p>
        
        <p>So why the variability? Why can games get away with such a broad spectrum of driving models?</p>

        <p>It&#39;s because when it comes to cars, we derive our expectations of them not just from first hand experience. Our understanding of what “driving fast” feels like is often built from second-hand sources; films, games, pop culture. We&#39;ve all seen the hero of a movie shift gears a dozen times in a straight-line drag race. It&#39;s absurd, has nothing to do with reality, but it communicates something. It sells the feeling of acceleration, intensity, control. So kids get it; they want to “shift up” because it feels like doing something meaningful. It&#39;s the visceral feeling of controling something large and heavy at break-neck speeds.</p>

        <p><i>So the key question for anyone implementing vehicles in a game isn&#39;t “what are the real physics I need to simulate?”, it&#39;s “what experience do I want to convey?”. From there you get to the question of “how do I implement that?”.</i></p>

        <p>I&#39;ve come to realize that the challenge of simulating vehicles in games lies in bridging two complex worlds: the experience and the machine. You need to understand both. Only then can you decide how and where to bend the rules; because game design isn&#39;t about simulating reality, it&#39;s about shaping it to fit your vision.</p>

        <h2 id="av_racer">Chasing the Feel: The Iterative Path to AV-Racer</h2>

        <p>My first attempt at simulating a vehicle in a game was AV Racer, and it began as a simple top-down sprite using a basic Newtonian model. I controlled the car&#39;s movement with acceleration and braking, tied angular velocity to speed (so it wouldn&#39;t rotate on the spot), and called it a day.</p>
        <p>Did it look like a car? Sort of. Did it feel like one? Not at all. It was more like a robotic puck skating around on invisible rails. So, iterating on that, I started hacking in some nonlinear curves and smoothing functions to mimic a behavior of a sliding car, trying to push away from the rigid feel. I faked the trail, exaggerated the drift, tweaked the angular momentum. It was all hacks, but it worked, somewhat. At least until Casey Muratori tried it and pointed out it looked like a car on ice, a spaceship. And he was right. It floated rather than gripped.</p>
        <p>So I went back to the drawing board, already sunk in the hacky method, I added more magical numbers, created a parameter for “slidiness,” and kept tuning the system until it felt snappy, responsive, and fun. That final version is <a href="https://store.steampowered.com/app/1978850/AVRacer/">what I shipped on Steam</a>. and you can read the technical breakdown of it in the devlog on my website <a href="https://wassimulator.com/blog/programming/av-racer/ ">here</a>.</p>
        
        

        <p>But here&#39;s the point: that car never really was a car. It was a clever trick, a cheat, an attempt to evoke the feeling of driving without simulating anything resembling the real thing. And that was okay, to a point, and it broke on edge cases. And if you give it to a racing driver or a sim driver they would immediately list all the things that are wrong with it.</p>

        <p>What I learned from AV Racer is this:
        </p><blockquote>If your goal is to capture the experience, you can get a long way without the real physics, but you&#39;ll always hit a wall.</blockquote>

        <h3>Back to the drawing board</h3>

        <p>So after AV Racer, I decided to take a different path. I wanted to try doing it “right”; or at least understand what “right” even looked like. That meant diving deeper. I started researching actual vehicle dynamics, reading up on how cars behave in motion, and just as importantly, how drivers experience that behavior.</p>

        <p>That shift; from faking to understanding changed everything. It became the basis for my next project, and it&#39;s what this talk (and this article) is really about: the intersection between how things work and how things feel, and what things you should care about to get a car in your game.</p>

       <p>Throughout my journey trying to write this next engine, I was constantly stumped trying to tune out the noise between physics books and large repositories; what are the simplest high level concepts I need to understand and implement to get a simple vehicle on solid physical foundation? The goal of this talk, and article, is to help you, a developer interested in programming a car in their game, figure out where to start. And to give you the basic principles and list of things to care about while doing so.</p> 
        
        <hr/>

        

        <p>At the core of it, a car in a game (at least one that behaves like a car) can be broken down into three main conceptual components:</p>
               
        <p><img src="https://wassimulator.com/data/images/bsc_31.jpg" alt="Physics diagram" width="100%"/></p><h3>1. The Engine (and Gearbox)</h3>

        <p>This is the logical starting point. When most people think of what “moves” a car, they think of the engine.</p>
        
        <h3>2. The Wheels and Tires</h3>
        <p>This is where the physics gets juicy.</p>
        
        <h3>3. The Chassis</h3>
        <p>The chassis is the simplest part to describe. It isn&#39;t a special problem to car physics to solve.</p>
            
        <table>
  <thead>
    <tr>
      <th>Component</th>
      <th>Inputs</th>
      <th>Outputs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>The Engine</td>
      <td>
        <ul>
          <li>Gas and shifter</li>
          <li>Wheel speed</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Sync. wheels to engine</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>The tire(s)</td>
      <td>
        <ul>
          <li>Engine speed &amp; torque</li>
          <li>Brakes</li>
          <li>Steering</li>
          <li>Weight load</li>
          <li>Friction with road</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Forces on the chassis</li>
          <li>Sync. engine to wheels</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>The chassis</td>
      <td>
        <ul>
          <li>Forces from wheels</li>
          <li>Aerodynamics</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Weight on wheels</li>
          <li>Everything moves with it</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

        <p>This all sounds complex, and it is. But the truth is, no game simulates all of this at full fidelity. Not even the most advanced racing simulators. Why? Because it&#39;s just not practical. You&#39;d need full CFD (computational fluid dynamics) for air and fuel intake, real-time thermodynamics of tire rubber compounds, suspension dynamics, etc. No one&#39;s doing that except maybe a handful of automotive engineers locked in a lab at Porsche in Stuttgart. 
        So in game development, even with a physics driven model, we cut corners.</p>

        <blockquote>Some parts of the system are treated as black boxes: formulas that spit out plausible outputs based on reasonable inputs. Even in high-end racing sims, there&#39;s abstraction going on under the hood. There has to be.</blockquote>
        
        <p>So, ultimately there&#39;s no single “correct” way to implement vehicle physics. There is no Bible. No open-source silver bullet. Every game, every engine, every developer ends up carving their own path. So as a developer, you&#39;ll need to make choices, deliberate ones, about what to simulate, what to fake, and where to cheat. You won&#39;t get to say “I got the simulation right,” because there is no one right simulation. You&#39;ll have to design the system around what matters for your game.</p><p>

        Here is the general algorithm of how you would go through this in a physics loop in pesudocode:
        
        </p></div><div>

        
        <p>So let&#39;s zoom into the first and perhaps most conceptually overloaded part:</p>
        <hr/>
        

        <p>Interestingly, while the engine has the most moving parts in real life, in code, it&#39;s the simplest piece of the entire car simulation. Because at its core, the engine is just a torque calculator. It&#39;s concerned with producing a single output: rotational torque, from a set of inputs. It is essentially a blackbox.</p>

        <p>But to get this right, and to make it feel right, we have to understand the mechanics behind the numbers.</p>

        <p>Let&#39;s look at a simple example: </p>

        <p><img src="https://wassimulator.com/data/images/bsc_34.jpg" alt="Drivetrain diagram" width="100%"/></p><table>
  <thead>
    <tr>
      <th>Stage</th>
      <th>RPM</th>
      <th>Torque (Nm)</th>
      <th>Power (kW)</th>
      <th>Force (N)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Engine</td>
      <td>5000</td>
      <td>200</td>
      <td>100</td>
      <td>n.a.</td>
    </tr>
    <tr>
      <td>Transmission (1:3.5)</td>
      <td>1428</td>
      <td>700</td>
      <td>100</td>
      <td>n.a.</td>
    </tr>
    <tr>
      <td>Differential (1:4.1)</td>
      <td>380</td>
      <td>2870</td>
      <td>100</td>
      <td>n.a.</td>
    </tr>
    <tr>
      <td>Wheels (r = 0.3m)</td>
      <td>380</td>
      <td>2870</td>
      <td>100</td>
      <td>9566</td>
    </tr>
  </tbody>
</table>


        <p>suppose we have an engine producing a flat 100 kW of power at 5000 RPM. That translates to about 200 Nm of torque. But that speed is way too fast for the wheels to handle directly. So, enter the gearbox and differential, which scale down the speed while boosting the torque. By the time the force reaches the wheels, after a gear ratio of 4.2 and a differential ratio of 3.8, you would end up with something like 9500 N of linear force (after converting torque through wheel radius). That&#39;s a lot of grunt at the contact patch. Understanding this is essential because torque is not fixed. It changes based on the engine&#39;s RPM, and how that engine is connected to the drivetrain.</p>

        <p>Now if you&#39;re into tuning cars you will recognize this iconic image:</p>
        <p><img src="https://wassimulator.com/data/images/bsc_35.jpg" alt="Torque and power diagram" width="100%"/></p><p>A torque curve rising and falling next to a similarly shaped power curve. These two hills represent the output characteristics of an engine across its RPM range. Torque tells you how strong the engine is at any moment. Power is the result of torque times RPM (with some constants in between). Each engine has its own &#34;personality&#34;: some peak early and drop off, others ramp up slowly and scream at high revs. These shapes affect how a car feels to drive. A snappy, torquey low-RPM engine feels wildly different from a peaky high-RPM screamer, even if both cars hit the same top speed.</p>

        <p>Key take is this: The engine&#39;s power output is variable at different speeds.</p>

        <p>Ok, good, now how do you simulate that? How do I put it into code?
        You don&#39;t need to simulate combustion cycles or real torque output. What you need is a curve that gives believable values based on RPM. So here&#39;s what I did: I opened up Desmos, sat there for an hour, and built an abomination:</p>
<p>
  \[ y = (a - b) \cdot e^{\frac{-(c(x - d))^2}{f^2}} + b \]
</p>
        <blockquote>
        </blockquote>
        
        <p>I reverse-engineered a torque curve formula; not from real data, but from visual tinkering. I created parameters I could play with.</p>
         

        <h2>The Gearbox</h2>

        <p>The gearbox is dead simple: it&#39;s a lookup-table of ratios. Each gear multiplies the engine&#39;s output torque and divides the RPM. The player shifts gears, and you look up the current ratio. That&#39;s it. But the result of this mechanic is huge in terms of how a car accelerates. It defines your acceleration profile, top speed, and how much freedom you give the player to manage the engine&#39;s sweet spot.</p>

        <div>

        <!-- Paragraph Text -->
        <p><strong>The gearbox is dead simple:</strong> it&#39;s a lookup-table of ratios.</p>

        <!-- Gear Ratio Table -->
        <table>
          <thead>
            <tr>
              <th>Gear</th>
              <th>Ratio</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>R</td><td>-2.92</td></tr>
            <tr><td>N</td><td>0</td></tr>
            <tr><td>1</td><td>2.50</td></tr>
            <tr><td>2</td><td>1.61</td></tr>
            <tr><td>3</td><td>1.10</td></tr>
            <tr><td>4</td><td>0.81</td></tr>
            <tr><td>5</td><td>0.68</td></tr>
          </tbody>
        </table>
    
    </div>
        <!-- Centered and Enlarged Equation -->
  

  <!-- Explanation Table -->
  

        

    

  <!-- Explanation Table -->
  
        

        

        
        
        

        

        

        

        
        
        
        

         
        

        
        
        <!-- JavaScript -->
        

        
        

        

        
        
        

        
        
        

        

        
        
        

        
        
        
        
        

          
        
        
        
        
        
        
        
        

        

        
        

        
        
        

        

        
        

        

        

        

         

        
        
        
        

        
        
        
        

        
        
        
        
        

        
        
        
        

        

        

        

        
        
        
        

        

        

        

        
        

        

       

        
        
        
        

        
        
        
        

        
        

        
        
        
        
        

        
        

        

        

        

        
        
        

        
        
        
        <!-- Explanation Table -->
        
        
        <!-- Integration Explanation -->
        
        

        
        
        

        
        

        

        
<!-- <hr> -->






</div></div>
  </body>
</html>
