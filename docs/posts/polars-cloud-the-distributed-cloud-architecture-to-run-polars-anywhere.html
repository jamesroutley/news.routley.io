<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pola.rs/posts/polars-cloud-what-we-are-building/">Original</a>
    <h1>Polars Cloud: The Distributed Cloud Architecture to Run Polars Anywhere</h1>
    
    <div id="readability-page-1" class="page"><section> <div> <div> <div> <h2 id="1-the-dataframe-scale-gap">1. The DataFrame scale gap</h2>
<p>When I started working on Polars, I was surprised how much DataFrame implementations differed from SQL and databases. SQL could run anywhere <sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>. It could run embedded, on a client server model, or on full OLAP data warehouses.</p>
<p>Whereas for dataframes, the API was different per use case and performance was drastically lacking behind SQL solutions. Locally, pandas was dominant, and remotely/distributed, it was PySpark. For end-users, pandas was very easy to get up and running, but it seems to have ignored what databases have learned over decades, there was no query optimization, poor data type implementation, many needless materializations, it offloaded memory handling to NumPy, and a few other design decisions that led to poor scaling and inconsistent behavior. PySpark was much closer to databases, it follows the relational model, has optimization, a distributed query engine and scaled properly. However PySpark is written in Scala, requires the JVM to run locally, has very poor unpythonic UX (java backtraces for one), and is very sensitive to OOMs. It also was designed for commodity hardware a decade ago and row-based OLAP execution has proven to be suboptimal.</p>
<p>With Polars we want to unify those two worlds under <strong>one flexible DataFrame API, backed by high performant compute</strong>. Our initial (and achieved) goal was offering an alternative for pandas with a flexible API that does enable query optimization, and parallel streaming execution. Second we want to make running DataFrame code remotely easy. Just like SQL, a Polars <code>LazyFrame</code> is a description of a query, and it can be sent to a server to be executed remotely. This should be dead easy. In the cloud dominant era, you should not be limited to the boundaries of your laptop.</p>
<h2 id="2-run-polars-everywhere">2. Run Polars everywhere</h2>
<p>Our goal is to enable <strong>Scalable data processing with all the flexibility and expressiveness of Polars’ API</strong>.
We are working on two things; <strong>Polars Cloud</strong> and a completely novel <strong>Streaming Engine</strong> design. We will explain more about the streaming engine in later posts; Today we want to share what are building with Polars Cloud.</p>
<p>The features we will offer:</p>
<ul>
<li>Distributed Polars; one API for all high performant DataFrame needs;</li>
<li>Serverless compute;</li>
<li>Configurable hardware, both GPU and CPU;</li>
<li>Diagonal scaling; scaling both horizontally and vertically;</li>
<li>Bring your own cloud; AWS, Azure and GCP;</li>
<li>On premise licensing;</li>
<li>Fault tolerance;</li>
<li>Data lineage;</li>
<li>Observability;</li>
</ul>
<p>It will be very seamless to spin up hardware and run Polars queries remotely, either in batch mode for production ETL jobs, or interactively doing data exploration. The rest of the post, we want to explore this through a few code examples.</p>
<h2 id="3-a-remote-query">3. A remote query.</h2>
<p>It’s important for us that starting a remote query feels native and seamless for the end user. Running a query remotely will be available from within Polars’ native API.</p>
<p>Note that we are agnostic of where you call this code. You can start a remote query from a notebook on your machine, an Airflow dag, an AWS Lambda, your server etc. The compute needed for data-processing is often much higher than the compute needed for orchestration in Airflow or Prefect. By not constraining you to a platform where you need to run your queries, we give you the flexibility to embed Polars Cloud in any environment.</p>
<p>In the query below we start our first query.</p>
<pre tabindex="0" data-language="python"><code><span><span>import</span><span> polars </span><span>as</span><span> pl</span></span>
<span><span>import</span><span> polars_cloud </span><span>as</span><span> pc</span></span>
<span><span>from</span><span> datetime </span><span>import</span><span> date</span></span>
<span></span>
<span><span>query </span><span>=</span><span> (pl</span><span>.</span><span>scan_parquet</span><span>(</span><span>&#34;s3://my-dataset/&#34;</span><span>)</span></span>
<span><span>   .</span><span>filter</span><span>(pl.</span><span>col</span><span>(</span><span>&#34;l_shipdate&#34;</span><span>) </span><span>&lt;=</span><span> date</span><span>(</span><span>1998</span><span>, </span><span>9</span><span>, </span><span>2</span><span>))</span></span>
<span><span>      .</span><span>group_by</span><span>(</span><span>&#34;l_returnflag&#34;</span><span>, </span><span>&#34;l_linestatus&#34;</span><span>)</span></span>
<span><span>       .</span><span>agg</span><span>(</span></span>
<span><span>            avg_price</span><span>=</span><span>pl.</span><span>mean</span><span>(</span><span>&#34;l_extendedprice&#34;</span><span>),</span></span>
<span><span>            avg_disc</span><span>=</span><span>pl.</span><span>mean</span><span>(</span><span>&#34;l_discount&#34;</span><span>),</span></span>
<span><span>            count_order</span><span>=</span><span>pl.</span><span>len</span><span>()</span></span>
<span><span>        )</span></span>
<span><span> )</span></span>
<span></span>
<span><span>in_progress </span><span>=</span><span> (</span></span>
<span><span>    query</span></span>
<span><span>    .</span><span>remote</span><span>(pc.</span><span>ComputeContext</span><span>(cpus</span><span>=</span><span>16</span><span>, memory</span><span>=</span><span>64</span><span>))</span></span>
<span><span>    .</span><span>sink_parquet</span><span>(</span><span>&#34;s3://my-dst/&#34;</span><span>)</span></span>
<span><span>)</span></span>
<span></span></code></pre>
<p>We create a <code>LazyFrame</code> and instead of collecting it locally, we can call <code>.remote()</code>, which tells Polars to run this query remotely with the given <code>pc.ComputeContext</code>. The <code>ComputeContext</code>
tells use what kind of hardware to spin up, and the <code>sink_parquet</code> call fires the query. We’ll get back an <code>InProgressQueryRemote</code> object indicating that our query runs remotely. In the mean time we can asynchronously
work on other stuff, or we can block and await the result. Finally, the <code>InProgressQueryRemote</code> can be turned into a <code>LazyFrame</code> again to continue working on the result of the remote query. Let’s do that.</p>
<pre tabindex="0" data-language="python"><code><span><span>result </span><span>=</span><span> in_progress</span><span>.</span><span>await_result</span><span>()</span></span>
<span><span>print</span><span>(result)</span></span>
<span></span>
<span><span>new_lf</span><span>:</span><span> pl</span><span>.</span><span>LazyFrame </span><span>=</span><span> result</span><span>.</span><span>lazy</span><span>()</span></span>
<span></span></code></pre>
<pre tabindex="0" data-language="plaintext"><code><span><span>shape: (4, 5)</span></span>
<span><span>┌──────────────┬──────────────┬──────────────┬──────────┬─────────────┐</span></span>
<span><span>│ l_returnflag ┆ l_linestatus ┆ avg_price    ┆ avg_disc ┆ count_order │</span></span>
<span><span>│ ---          ┆ ---          ┆ ---          ┆ ---      ┆ ---         │</span></span>
<span><span>│ str          ┆ str          ┆ f64          ┆ f64      ┆ u32         │</span></span>
<span><span>╞══════════════╪══════════════╪══════════════╪══════════╪═════════════╡</span></span>
<span><span>│ A            ┆ F            ┆ 38273.129735 ┆ 0.049985 ┆ 1478493     │</span></span>
<span><span>│ N            ┆ O            ┆ 38249.117989 ┆ 0.049997 ┆ 2920374     │</span></span>
<span><span>│ R            ┆ F            ┆ 38250.854626 ┆ 0.050009 ┆ 1478870     │</span></span>
<span><span>│ N            ┆ F            ┆ 38284.467761 ┆ 0.050093 ┆ 38854       │</span></span>
<span><span>└──────────────┴──────────────┴──────────────┴──────────┴─────────────┘</span></span>
<span><span></span></span></code></pre>
<h2 id="4-scaling-strategies">4. Scaling strategies</h2>
<p>Polars can run these queries remotely differently than you would expect for Python libraries. We don’t require serialization via Pickle because we build a DSL tree natively in Rust. This DSL is send to the server to be analyzed and run.
Cluster side, we have built a distributed scheduler-worker architecture in Rust that can analyze these queries, runs an adapted Polars optimizer and, depending on the query, comes up with a physical plan that scales horizontally or vertically.
Polars is very strong in vertical scaling and we recognize that many queries will be most cost effective on a single machine. It however, is also very common that queries start with a set of operations that reduce the dataset size (think of group-by’s and filters).
When querying large data sizes from cloud storage, you are bound to the IO limit of a single node. With horizontal scaling we can drastically increase those download limits and after the size reductions finish off on a single machine.
We are building an architecture that shines in both horizontally and vertically scaling, dubbed diagonal scaling, choosing the optimal strategy dynamically.</p>
<h2 id="5-engines-cpu-and-gpu">5. Engines (CPU and GPU)</h2>
<p>Besides multiple scaling strategies, we are committed to run open source Polars as our engine on the worker nodes. This ensures our incentives are aligned and that the semantics of Polars cloud will not deviate. Polars will allow you to run all engines. That means
there will also be <strong>GPU</strong> support. You will be able to spin up a machine with a high end GPU and connect locally in interactive mode. Our new <strong>Streaming Engine</strong> has an <strong>out-of-core</strong> design, and will be able to spill to disk in an efficient manner. Together with distributed queries, this will truly scale Polars to any dataset. We already have the first preliminary results and on the PDS-H<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup> Benchmark and they look very promising. We already beat our in-memory engine by a factor of ~3 (and there are still a lot of performance opportunities) and it goes without saying that the memory charachteristics are much better.</p>
<h2 id="6-distributions-strategies">6. Distributions strategies</h2>
<h3 id="distributed">Distributed</h3>
<p>As mentioned, you can spin up a cluster of machines. This allows you to run a query in distributed mode.</p>
<pre tabindex="0" data-language="python"><code><span><span>lf</span><span>:</span><span> LazyFrame</span></span>
<span></span>
<span><span>result </span><span>=</span><span> (</span></span>
<span><span>      lf</span><span>.</span><span>remote</span><span>()</span></span>
<span><span>      .</span><span>distributed</span><span>()</span></span>
<span><span>      .</span><span>collect</span><span>()</span></span>
<span><span>      .</span><span>await_result</span><span>()</span></span>
<span><span>)</span></span>
<span></span></code></pre>
<p>The semantics of a distributed query don’t change, it only tells Polars cloud it can use multiple nodes to finish the query if it needs to. Not every Polars operation is supported yet, but this will still be beneficial as distributed queries can reduce the dataset size until a single node can finish it on the streaming engine. Operations that are currently supported are all streamable operations, such as <code>filter</code>, <code>explode</code>, <code>map</code>, and partitionable operations such as <code>group-by</code> and <code>equi-joins</code>.</p>
<h3 id="partitioned">Partitioned</h3>
<p>Furthermore, we have partitioned queries, which partitions the query on a given <code>key</code> on the available nodes in the cluster. This will semantically change the query as you will get a result for every unique key, meaning that a single query will have <code>n_unique(key)</code> results:</p>
<pre tabindex="0" data-language="python"><code><span><span>lf</span><span>:</span><span> LazyFrame</span></span>
<span></span>
<span><span>result </span><span>=</span><span> (</span></span>
<span><span>      lf</span><span>.</span><span>remote</span><span>(pc.</span><span>ComputeContext</span><span>(cpus</span><span>=</span><span>16</span><span>, memory</span><span>=</span><span>64</span><span>, cluster_size</span><span>=</span><span>32</span><span>))</span></span>
<span><span>      .</span><span>partition_by</span><span>(</span><span>&#34;day&#34;</span><span>)</span></span>
<span><span>      .</span><span>collect</span><span>()</span></span>
<span><span>      .</span><span>await_result</span><span>()</span></span>
<span><span>)</span></span>
<span></span></code></pre>
<p>This can be very useful for timeseries where you want to run a query at a given time interval, e.g. daily, weekly, monthly etc.</p>
<h3 id="spawn-many-queries-in-parallel">Spawn many queries in parallel</h3>
<p>Finally we make it easy to run many queries remotely. We provide a function <code>spawn_many</code> which takes a list of <code>LazyFrame</code>’s, which will run on the cluster.</p>
<pre tabindex="0" data-language="python"><code><span><span>import</span><span> polars_cloud </span><span>as</span><span> pc</span></span>
<span></span>
<span><span>lazy_frames</span><span>:</span><span> list</span><span>[</span><span>LazyFrame</span><span>]</span></span>
<span><span>results </span><span>=</span><span> pc</span><span>.</span><span>spawn_many</span><span>(lazy_frames, partition_by</span><span>=</span><span>&#34;day&#34;</span><span>, dst</span><span>=</span><span>&#34;s3://result_dst/&#34;</span><span>).</span><span>await_result</span><span>()</span></span>
<span></span></code></pre>
<h2 id="7-fault-tolerance">7. Fault tolerance</h2>
<p>Once you start dealing with multiple workers and hardware, things will fail, disks will drop, machines will disconnect etc. This has to be completely hidden from the user and this complexity will be handled by us. We will reschedule tasks if workers failed and ensure a query finishes independent of hardware failure.</p>
<h2 id="apply-for-early-access">Apply for early access</h2>
<p>End of this month we are onboarding our first clients. Soon after we want to scale up and invite individuals that have their cloud stack on AWS. After that we will work on other cloud vendors and Kubernetes. Do you want have early access, reach out to us!</p>

 </div> </div> </div> </section></div>
  </body>
</html>
