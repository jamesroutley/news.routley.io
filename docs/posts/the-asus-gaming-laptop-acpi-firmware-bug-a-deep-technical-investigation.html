<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/Zephkek/Asus-ROG-Aml-Deep-Dive">Original</a>
    <h1>The Asus Gaming Laptop ACPI Firmware Bug: A Deep Technical Investigation</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<div dir="auto"><h2 tabindex="-1" dir="auto">If You&#39;re Here, You Know The Pain</h2><a id="user-content-if-youre-here-you-know-the-pain" aria-label="Permalink: If You&#39;re Here, You Know The Pain" href="#if-youre-here-you-know-the-pain"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">You own a high-end ASUS ROG laptop perhaps a Strix, Scar, or Zephyrus. It&#39;s specifications are impressive: an RTX 30/40 series GPU, a top-tier Intel processor, and plenty of RAM. Yet, it stutters during basic tasks like watching a YouTube video, audio crackles and pops on Discord calls, the mouse cursor freezes for a split second, just long enough to be infuriating.</p>
<p dir="auto">You&#39;ve likely tried all the conventional fixes:</p>
<ul dir="auto">
<li>Updating every driver imaginable, multiple times.</li>
<li>Performing a &#34;clean&#34; reinstallation of Windows.</li>
<li>Disabling every conceivable power-saving option.</li>
<li>Manually tweaking processor interrupt affinities.</li>
<li>Following convoluted multi-step guides from Reddit threads.</li>
<li>Even installing Linux, only to find the problem persists.</li>
</ul>
<p dir="auto">If none of that worked, it&#39;s because the issue isn&#39;t with the operating system or a driver. The problem is far deeper, embedded in the machine&#39;s firmware, the BIOS.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Initial Symptoms and Measurement</h2><a id="user-content-initial-symptoms-and-measurement" aria-label="Permalink: Initial Symptoms and Measurement" href="#initial-symptoms-and-measurement"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>

<p dir="auto">The first tool in any performance investigator&#39;s toolkit for these symptoms is LatencyMon. It acts as a canary in the coal mine for system-wide latency issues. On an affected ASUS Zephyrus M16, the results are immediate and damning:</p>
<div data-snippet-clipboard-copy-content="CONCLUSION
Your system appears to be having trouble handling real-time audio and other tasks. 
You are likely to experience buffer underruns appearing as drop outs, clicks or pops.

HIGHEST MEASURED INTERRUPT TO PROCESS LATENCY
Highest measured interrupt to process latency (μs):   65,816.60
Average measured interrupt to process latency (μs):   23.29

HIGHEST REPORTED ISR ROUTINE EXECUTION TIME
Highest ISR routine execution time (μs):              536.80
Driver with highest ISR routine execution time:       ACPI.sys

HIGHEST REPORTED DPC ROUTINE EXECUTION TIME  
Highest DPC routine execution time (μs):              5,998.83
Driver with highest DPC routine execution time:       ACPI.sys"><pre><code>CONCLUSION
Your system appears to be having trouble handling real-time audio and other tasks. 
You are likely to experience buffer underruns appearing as drop outs, clicks or pops.

HIGHEST MEASURED INTERRUPT TO PROCESS LATENCY
Highest measured interrupt to process latency (μs):   65,816.60
Average measured interrupt to process latency (μs):   23.29

HIGHEST REPORTED ISR ROUTINE EXECUTION TIME
Highest ISR routine execution time (μs):              536.80
Driver with highest ISR routine execution time:       ACPI.sys

HIGHEST REPORTED DPC ROUTINE EXECUTION TIME  
Highest DPC routine execution time (μs):              5,998.83
Driver with highest DPC routine execution time:       ACPI.sys
</code></pre></div>
<p dir="auto">The data clearly implicates <code>ACPI.sys</code>. However, the per-CPU data reveals a more specific pattern:</p>
<div data-snippet-clipboard-copy-content="CPU 0 Interrupt cycle time (s):                       208.470124
CPU 0 ISR highest execution time (μs):                536.804674
CPU 0 DPC highest execution time (μs):                5,998.834725
CPU 0 DPC total execution time (s):                   90.558238"><pre><code>CPU 0 Interrupt cycle time (s):                       208.470124
CPU 0 ISR highest execution time (μs):                536.804674
CPU 0 DPC highest execution time (μs):                5,998.834725
CPU 0 DPC total execution time (s):                   90.558238
</code></pre></div>
<p dir="auto">CPU 0 is taking the brunt of the impact, spending over 90 seconds processing interrupts while other cores remain largely unaffected. This isn&#39;t a failure of load balancing; it&#39;s a process locked to a single core.</p>
<p dir="auto">A similar test on a Scar 15 from 2022 shows the exact same culprit: high DPC latency originating from <code>ACPI.sys</code>.</p>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/76183331/490271011-fdf6f26a-dda8-4561-82c7-349fc8c298ab.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NTgxMTU5MDksIm5iZiI6MTc1ODExNTYwOSwicGF0aCI6Ii83NjE4MzMzMS80OTAyNzEwMTEtZmRmNmYyNmEtZGRhOC00NTYxLTgyYzctMzQ5ZmM4YzI5OGFiLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA5MTclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwOTE3VDEzMjY0OVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWIyY2FhY2Q4MWYzYTU5YTZlMjNlOTU5OWJiNzdiZGMzMmI0ZWU4MzhiMmU5MTY1NWViOGU1ZjIyYTc1NzRiOTkmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.AgMKFrllqwmdQyKwFnHuf_8JMT59KChvM2dU8kfPjgU"><img width="974" height="511" alt="latencymon" src="https://private-user-images.githubusercontent.com/76183331/490271011-fdf6f26a-dda8-4561-82c7-349fc8c298ab.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NTgxMTU5MDksIm5iZiI6MTc1ODExNTYwOSwicGF0aCI6Ii83NjE4MzMzMS80OTAyNzEwMTEtZmRmNmYyNmEtZGRhOC00NTYxLTgyYzctMzQ5ZmM4YzI5OGFiLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA5MTclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwOTE3VDEzMjY0OVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWIyY2FhY2Q4MWYzYTU5YTZlMjNlOTU5OWJiNzdiZGMzMmI0ZWU4MzhiMmU5MTY1NWViOGU1ZjIyYTc1NzRiOTkmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.AgMKFrllqwmdQyKwFnHuf_8JMT59KChvM2dU8kfPjgU"/></a>
<p dir="auto">It&#39;s easy to blame a Windows driver, but <code>ACPI.sys</code> is not a typical driver. It primarily functions as an interpreter for ACPI Machine Language (AML), the code provided by the laptop&#39;s firmware (BIOS). If <code>ACPI.sys</code> is slow, it&#39;s because the firmware is feeding it inefficient or flawed AML code to execute. These slowdowns are often triggered by General Purpose Events (GPEs) and traffic from the Embedded Controller (EC). To find the true source, we must dig deeper.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Capturing the Problem in More Detail: ETW Tracing</h2><a id="user-content-capturing-the-problem-in-more-detail-etw-tracing" aria-label="Permalink: Capturing the Problem in More Detail: ETW Tracing" href="#capturing-the-problem-in-more-detail-etw-tracing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Setting Up Advanced ACPI Tracing</h3><a id="user-content-setting-up-advanced-acpi-tracing" aria-label="Permalink: Setting Up Advanced ACPI Tracing" href="#setting-up-advanced-acpi-tracing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To understand what <code>ACPI.sys</code> is doing during these latency spikes, we can use Event Tracing for Windows (ETW) to capture detailed logs from the ACPI providers.</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Find the relevant ACPI ETW providers
logman query providers | findstr /i acpi
# This returns two key providers:
# Microsoft-Windows-Kernel-Acpi {C514638F-7723-485B-BCFC-96565D735D4A}
# Microsoft-ACPI-Provider {DAB01D4D-2D48-477D-B1C3-DAAD0CE6F06B}

# Start a comprehensive trace session
logman start ACPITrace -p {DAB01D4D-2D48-477D-B1C3-DAAD0CE6F06B} 0xFFFFFFFF 5 -o C:\Temp\acpi.etl -ets
logman update ACPITrace -p {C514638F-7723-485B-BCFC-96565D735D4A} 0xFFFFFFFF 5 -ets

# Then once we&#39;re done we can stop the trace and check the etl file and save the data in csv format aswell.
logman stop ACPITrace -ets
tracerpt C:\Temp\acpi_providers.etl -o C:\Temp\acpi_events.csv -of CSV"><pre><span><span>#</span> Find the relevant ACPI ETW providers</span>
logman query providers <span>|</span> findstr <span>/</span>i acpi
<span><span>#</span> This returns two key providers:</span>
<span><span>#</span> Microsoft-Windows-Kernel-Acpi {C514638F-7723-485B-BCFC-96565D735D4A}</span>
<span><span>#</span> Microsoft-ACPI-Provider {DAB01D4D-2D48-477D-B1C3-DAAD0CE6F06B}</span>

<span><span>#</span> Start a comprehensive trace session</span>
logman start ACPITrace <span>-</span>p {DAB01D4D<span>-</span>2D48<span>-</span><span>477D</span><span>-</span>B1C3<span>-</span>DAAD0CE6F06B} <span>0xFFFFFFFF</span> <span>5</span> <span>-</span>o C:\Temp\acpi.etl <span>-</span>ets
logman update ACPITrace <span>-</span>p {C514638F<span>-</span><span>7723</span><span>-</span>485B<span>-</span>BCFC<span>-</span>96565D735D4A} <span>0xFFFFFFFF</span> <span>5</span> <span>-</span>ets

<span><span>#</span> Then once we&#39;re done we can stop the trace and check the etl file and save the data in csv format aswell.</span>
logman stop ACPITrace <span>-</span>ets
tracerpt C:\Temp\acpi_providers.etl <span>-</span>o C:\Temp\acpi_events.csv <span>-</span>of CSV</pre></div>

<p dir="auto">Analyzing the resulting trace file in the Windows Performance Analyzer reveals a crucial insight. The spikes aren&#39;t random; they are periodic, occurring like clockwork every 30 to 60 seconds.</p>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/76183331/490271181-2aac7320-3e06-4025-841c-86129f9d5b62.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NTgxMTU5MDksIm5iZiI6MTc1ODExNTYwOSwicGF0aCI6Ii83NjE4MzMzMS80OTAyNzExODEtMmFhYzczMjAtM2UwNi00MDI1LTg0MWMtODYxMjlmOWQ1YjYyLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA5MTclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwOTE3VDEzMjY0OVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTIyN2ZjOTg0MDgwZGE4NDc0NTcxZjdkYjFiN2IyZWI1MzAzMzk2ZWM2Zjg1NjRmYWEyNzgyMjQ2NWJhNzZiYzEmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.rOSBlQvMkLV_vbYXRLA9y97veWUclngBkPGQ_92nLnY"><img width="1673" height="516" alt="61c7abb1-d7aa-4b69-9a88-22cca7352f00" src="https://private-user-images.githubusercontent.com/76183331/490271181-2aac7320-3e06-4025-841c-86129f9d5b62.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NTgxMTU5MDksIm5iZiI6MTc1ODExNTYwOSwicGF0aCI6Ii83NjE4MzMzMS80OTAyNzExODEtMmFhYzczMjAtM2UwNi00MDI1LTg0MWMtODYxMjlmOWQ1YjYyLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA5MTclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwOTE3VDEzMjY0OVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTIyN2ZjOTg0MDgwZGE4NDc0NTcxZjdkYjFiN2IyZWI1MzAzMzk2ZWM2Zjg1NjRmYWEyNzgyMjQ2NWJhNzZiYzEmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.rOSBlQvMkLV_vbYXRLA9y97veWUclngBkPGQ_92nLnY"/></a>
<p dir="auto">Random interruptions often suggest hardware faults or thermal throttling. A perfectly repeating pattern points to a systemic issue, a timer or a scheduled event baked into the system&#39;s logic.</p>
<p dir="auto">The raw event data confirms this pattern:</p>
<div data-snippet-clipboard-copy-content="Clock-Time (100ns),        Event,                      Kernel(ms), CPU
134024027290917802,       _GPE._L02 started,          13.613820,  0
134024027290927629,       _SB...BAT0._STA started,    0.000000,   4
134024027290932512,       _GPE._L02 finished,         -,          6"><pre lang="csv"><code>Clock-Time (100ns),        Event,                      Kernel(ms), CPU
134024027290917802,       _GPE._L02 started,          13.613820,  0
134024027290927629,       _SB...BAT0._STA started,    0.000000,   4
134024027290932512,       _GPE._L02 finished,         -,          6
</code></pre></div>
<p dir="auto">The first event, <code>_GPE._L02</code>, is an interrupt handler that takes <strong>13.6 milliseconds</strong> to execute. For a high-priority interrupt, this is an eternity and is catastrophic for real-time system performance.</p>
<p dir="auto">Deeper in the trace, another bizarre behavior emerges; the system repeatedly attempts to power the discrete GPU on and off, even when it&#39;s supposed to be permanently active.</p>
<div data-snippet-clipboard-copy-content="Clock-Time,                Event,                    Duration
134024027315051227,       _SB.PC00.GFX0._PS0 start, 278μs     # GPU Power On
134024027315155404,       _SB.PC00.GFX0._DOS start, 894μs     # Display Output Switch
134024027330733719,       _SB.PC00.GFX0._PS3 start, 1364μs    # GPU Power Off
[~15 seconds later]
134024027607550064,       _SB.PC00.GFX0._PS0 start, 439μs     # Power On Again!
134024027607657368,       _SB.PC00.GFX0._DOS start, 1079μs    # Display Output Switch
134024027623134006,       _SB.PC00.GFX0._PS3 start, 394μs     # Power Off Again!
..."><pre lang="csv"><code>Clock-Time,                Event,                    Duration
134024027315051227,       _SB.PC00.GFX0._PS0 start, 278μs     # GPU Power On
134024027315155404,       _SB.PC00.GFX0._DOS start, 894μs     # Display Output Switch
134024027330733719,       _SB.PC00.GFX0._PS3 start, 1364μs    # GPU Power Off
[~15 seconds later]
134024027607550064,       _SB.PC00.GFX0._PS0 start, 439μs     # Power On Again!
134024027607657368,       _SB.PC00.GFX0._DOS start, 1079μs    # Display Output Switch
134024027623134006,       _SB.PC00.GFX0._PS3 start, 394μs     # Power Off Again!
...
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Why This Behavior is Fundamentally Incorrect</h3><a id="user-content-why-this-behavior-is-fundamentally-incorrect" aria-label="Permalink: Why This Behavior is Fundamentally Incorrect" href="#why-this-behavior-is-fundamentally-incorrect"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This power cycling is nonsensical because the laptop is configured for a scenario where it is impossible: <strong>The system is in Ultimate Mode (via a MUX switch) with an external display connected.</strong></p>
<p dir="auto">In this mode:</p>
<ul dir="auto">
<li>The discrete NVIDIA GPU (dGPU) is the <strong>only</strong> active graphics processor.</li>
<li>The integrated Intel GPU (iGPU) is completely powered down and bypassed.</li>
<li>The dGPU is wired directly to the internal and external displays.</li>
<li>There is no mechanism for switching between GPUs.</li>
</ul>
<p dir="auto">Yet, the firmware is relentlessly trying to power cycle the dGPU every 15-30 seconds. The dGPU in mux mode isn&#39;t just &#34;preferred&#34; - it&#39;s the ONLY path to the display. There&#39;s no fallback, and no alternative. When the firmware sends <code>_PS3</code> (power off), it&#39;s attempting something architecturally impossible.</p>
<p dir="auto">Most of the time, hardware sanity checks refuse these nonsensical commands, but even failed attempts introduce latency spikes causing audio dropouts, input lag, and accumulating performance degradation. Games freeze mid-session, videos buffer indefinitely, system responsiveness deteriorates until restart.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">The Catastrophic Edge Case</h4><a id="user-content-the-catastrophic-edge-case" aria-label="Permalink: The Catastrophic Edge Case" href="#the-catastrophic-edge-case"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Sometimes, under specific thermal conditions or race conditions, the power-down actually succeeds. When the firmware manages to power down the GPU that&#39;s driving the display, the sequence is predictable and catastrophic:</p>
<ol dir="auto">
<li><strong>Firmware executes <code>_PS3</code></strong> - GPU power off command</li>
<li><strong>Hardware complies</strong> - safety checks fail or timing aligns</li>
<li><strong>Display signal cuts</strong> - monitors go black</li>
<li><strong>User input triggers wake</strong> - mouse/keyboard activity</li>
<li><strong>Windows calls <code>PowerOnMonitor()</code></strong> - attempt display recovery</li>
<li><strong>NVIDIA driver executes <code>_PS0</code></strong> - GPU power on command</li>
<li><strong>GPU enters impossible state</strong> - firmware insists OFF, Windows needs ON</li>
<li><strong>Driver thread blocks indefinitely</strong> - waiting for GPU response</li>
<li><strong>30-second watchdog expires</strong> - Windows gives up</li>
<li><strong>System crashes with BSOD</strong></li>
</ol>
<div data-snippet-clipboard-copy-content="5: kd&gt; !analyze -v
*******************************************************************************
*                                                                             *
*                        Bugcheck Analysis                                    *
*                                                                             *
*******************************************************************************

WIN32K_POWER_WATCHDOG_TIMEOUT (19c)
Win32k did not turn the monitor on in a timely manner.
Arguments:
Arg1: 0000000000000050, Calling monitor driver to power on.
Arg2: ffff8685b1463080, Pointer to the power request worker thread.
Arg3: 0000000000000000
Arg4: 0000000000000000
...
STACK_TEXT:  
fffff685`3a767130 fffff800`94767be0     : 00000000`00000047 00000000`00000000 00000000`00000000 00000000`00000000 : nt!KiSwapContext+0x76
fffff685`3a767270 fffff800`94726051     : ffff8685`b1463080 00000027`00008b94 fffff685`3a767458 fffff800`00000000 : nt!KiSwapThread+0x6a0
fffff685`3a767340 fffff800`94724ed3     : fffff685`00000000 00000000`00000043 00000000`00000002 0000008a`fbf50968 : nt!KiCommitThreadWait+0x271
fffff685`3a7673e0 fffff800`9471baf2     : fffff685`3a7675d0 02000000`0000001b 00000000`00000000 fffff800`94724500 : nt!KeWaitForSingleObject+0x773
fffff685`3a7674d0 fffff800`9471b7d5     : ffff8685`9cbec810 fffff685`3a7675b8 00000000`00010224 fffff800`00000003 : nt!ExpWaitForFastResource+0x92
fffff685`3a767580 fffff800`9471b49d     : 00000000`00000000 ffff8685`9cbec850 ffff8685`b1463080 00000000`00000000 : nt!ExpAcquireFastResourceExclusiveSlow+0x1e5
fffff685`3a767630 fffff800`28faca9b     : fffff800`262ee9c8 00000000`00000003 ffff8685`9cbec810 02000000`00000065 : nt!ExAcquireFastResourceExclusive+0x1bd
fffff685`3a767690 fffff800`28facbe5     : ffff8685`b31de000 00000000`00000000 ffffd31d`9a05244f 00000000`00000000 : win32kbase!&lt;lambda_63b61c2369133a205197eda5bd671ee7&gt;::&lt;lambda_invoker_cdecl&gt;+0x2b
fffff685`3a7676c0 fffff800`28e5f864     : ffffad0c`94d10878 fffff685`3a767769 ffffad0c`94d10830 ffff8685`b31de000 : win32kbase!UserCritInternal::`anonymous namespace&#39;::EnterCritInternalEx+0x4d
fffff685`3a7676f0 fffff800`28e5f4ef     : 00000000`00000000 00000000`00000000 fffff800`262ee9c8 00000000`00000000 : win32kbase!DrvSetWddmDeviceMonitorPowerState+0x354
fffff685`3a7677d0 fffff800`28e2abab     : ffff8685`b31de000 00000000`00000000 ffff8685`b31de000 00000000`00000000 : win32kbase!DrvSetMonitorPowerState+0x2f
fffff685`3a767800 fffff800`28ef22fa     : 00000000`00000000 fffff685`3a7678d9 00000000`00000001 00000000`00000001 : win32kbase!PowerOnMonitor+0x19b
fffff685`3a767870 fffff800`28ef13dd     : ffff8685`94a40700 ffff8685`a2eb31d0 00000000`00000001 00000000`00000020 : win32kbase!xxxUserPowerEventCalloutWorker+0xaaa
fffff685`3a767940 fffff800`4bab21c2     : ffff8685`b1463080 fffff685`3a767aa0 00000000`00000000 00000000`00000020 : win32kbase!xxxUserPowerCalloutWorker+0x13d
fffff685`3a7679c0 fffff800`26217f3a     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : win32kfull!NtUserUserPowerCalloutWorker+0x22
fffff685`3a7679f0 fffff800`94ab8d55     : 00000000`000005bc 00000000`00000104 ffff8685`b1463080 00000000`00000000 : win32k!NtUserUserPowerCalloutWorker+0x2e
fffff685`3a767a20 00007ff8`ee71ca24     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : nt!KiSystemServiceCopyEnd+0x25
000000cc`d11ffbc8 00000000`00000000     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : 0x00007ff8`ee71ca24

..."><pre><code>5: kd&gt; !analyze -v
*******************************************************************************
*                                                                             *
*                        Bugcheck Analysis                                    *
*                                                                             *
*******************************************************************************

WIN32K_POWER_WATCHDOG_TIMEOUT (19c)
Win32k did not turn the monitor on in a timely manner.
Arguments:
Arg1: 0000000000000050, Calling monitor driver to power on.
Arg2: ffff8685b1463080, Pointer to the power request worker thread.
Arg3: 0000000000000000
Arg4: 0000000000000000
...
STACK_TEXT:  
fffff685`3a767130 fffff800`94767be0     : 00000000`00000047 00000000`00000000 00000000`00000000 00000000`00000000 : nt!KiSwapContext+0x76
fffff685`3a767270 fffff800`94726051     : ffff8685`b1463080 00000027`00008b94 fffff685`3a767458 fffff800`00000000 : nt!KiSwapThread+0x6a0
fffff685`3a767340 fffff800`94724ed3     : fffff685`00000000 00000000`00000043 00000000`00000002 0000008a`fbf50968 : nt!KiCommitThreadWait+0x271
fffff685`3a7673e0 fffff800`9471baf2     : fffff685`3a7675d0 02000000`0000001b 00000000`00000000 fffff800`94724500 : nt!KeWaitForSingleObject+0x773
fffff685`3a7674d0 fffff800`9471b7d5     : ffff8685`9cbec810 fffff685`3a7675b8 00000000`00010224 fffff800`00000003 : nt!ExpWaitForFastResource+0x92
fffff685`3a767580 fffff800`9471b49d     : 00000000`00000000 ffff8685`9cbec850 ffff8685`b1463080 00000000`00000000 : nt!ExpAcquireFastResourceExclusiveSlow+0x1e5
fffff685`3a767630 fffff800`28faca9b     : fffff800`262ee9c8 00000000`00000003 ffff8685`9cbec810 02000000`00000065 : nt!ExAcquireFastResourceExclusive+0x1bd
fffff685`3a767690 fffff800`28facbe5     : ffff8685`b31de000 00000000`00000000 ffffd31d`9a05244f 00000000`00000000 : win32kbase!&lt;lambda_63b61c2369133a205197eda5bd671ee7&gt;::&lt;lambda_invoker_cdecl&gt;+0x2b
fffff685`3a7676c0 fffff800`28e5f864     : ffffad0c`94d10878 fffff685`3a767769 ffffad0c`94d10830 ffff8685`b31de000 : win32kbase!UserCritInternal::`anonymous namespace&#39;::EnterCritInternalEx+0x4d
fffff685`3a7676f0 fffff800`28e5f4ef     : 00000000`00000000 00000000`00000000 fffff800`262ee9c8 00000000`00000000 : win32kbase!DrvSetWddmDeviceMonitorPowerState+0x354
fffff685`3a7677d0 fffff800`28e2abab     : ffff8685`b31de000 00000000`00000000 ffff8685`b31de000 00000000`00000000 : win32kbase!DrvSetMonitorPowerState+0x2f
fffff685`3a767800 fffff800`28ef22fa     : 00000000`00000000 fffff685`3a7678d9 00000000`00000001 00000000`00000001 : win32kbase!PowerOnMonitor+0x19b
fffff685`3a767870 fffff800`28ef13dd     : ffff8685`94a40700 ffff8685`a2eb31d0 00000000`00000001 00000000`00000020 : win32kbase!xxxUserPowerEventCalloutWorker+0xaaa
fffff685`3a767940 fffff800`4bab21c2     : ffff8685`b1463080 fffff685`3a767aa0 00000000`00000000 00000000`00000020 : win32kbase!xxxUserPowerCalloutWorker+0x13d
fffff685`3a7679c0 fffff800`26217f3a     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : win32kfull!NtUserUserPowerCalloutWorker+0x22
fffff685`3a7679f0 fffff800`94ab8d55     : 00000000`000005bc 00000000`00000104 ffff8685`b1463080 00000000`00000000 : win32k!NtUserUserPowerCalloutWorker+0x2e
fffff685`3a767a20 00007ff8`ee71ca24     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : nt!KiSystemServiceCopyEnd+0x25
000000cc`d11ffbc8 00000000`00000000     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : 0x00007ff8`ee71ca24

...
</code></pre></div>
<p dir="auto">The crash dump confirms the thread is stuck in <code>win32kbase!DrvSetWddmDeviceMonitorPowerState</code>, waiting for the NVIDIA driver to respond. It can&#39;t because it&#39;s caught between a confused power state, windows wanting to turn on the GPU while the firmware is arming the GPU cut off.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Understanding General Purpose Events</h3><a id="user-content-understanding-general-purpose-events" aria-label="Permalink: Understanding General Purpose Events" href="#understanding-general-purpose-events"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">GPEs are the firmware&#39;s mechanism for signaling hardware events to the operating system. They are essentially hardware interrupts that trigger the execution of ACPI code. The trace data points squarely at <code>_GPE._L02</code> as the source of our latency.</p>
<p dir="auto">A closer look at the timing reveals a consistent and problematic pattern:</p>
<div data-snippet-clipboard-copy-content="_GPE._L02 Event Analysis from ROG Strix Trace:

Event 1 @ Clock 134024027290917802
  Duration: 13,613,820 ns (13.61ms)
  Triggered: Battery and AC adapter status checks

Event 2 @ Clock 134024027654496591  
  Duration: 13,647,255 ns (13.65ms)
  Triggered: Battery and AC adapter status checks
  
Event 3 @ Clock 134024028048493318
  Duration: 13,684,515 ns (13.68ms)  
  Triggered: Battery and AC adapter status checks

Interval between events: ~36-39 seconds
Consistency: The duration is remarkably stable and the interval is periodic."><pre><code>_GPE._L02 Event Analysis from ROG Strix Trace:

Event 1 @ Clock 134024027290917802
  Duration: 13,613,820 ns (13.61ms)
  Triggered: Battery and AC adapter status checks

Event 2 @ Clock 134024027654496591  
  Duration: 13,647,255 ns (13.65ms)
  Triggered: Battery and AC adapter status checks
  
Event 3 @ Clock 134024028048493318
  Duration: 13,684,515 ns (13.68ms)  
  Triggered: Battery and AC adapter status checks

Interval between events: ~36-39 seconds
Consistency: The duration is remarkably stable and the interval is periodic.
</code></pre></div>

<p dir="auto">Every single time the lengthy <code>_GPE._L02</code> event fires, it triggers the exact same sequence of ACPI method calls.</p>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/76183331/490271340-01326c61-b7a2-4c12-a907-8433f43a6a72.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NTgxMTU5MDksIm5iZiI6MTc1ODExNTYwOSwicGF0aCI6Ii83NjE4MzMzMS80OTAyNzEzNDAtMDEzMjZjNjEtYjdhMi00YzEyLWE5MDctODQzM2Y0M2E2YTcyLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA5MTclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwOTE3VDEzMjY0OVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTA4ZDNiNWJhNzE1OGFiNDUzNjY3YjRiYTllODUxNGY5NjZmODUyNDcyMzI3YTgzNzExNzBmY2JlNDM1OGJkZDkmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.iXbfi1J0nQD_5KVHZRmsAkoFQ3XmFTqr7leMlYrMLiA"><img width="589" height="589" alt="64921999-7614-4706-a5ac-54c39c38fd0b" src="https://private-user-images.githubusercontent.com/76183331/490271340-01326c61-b7a2-4c12-a907-8433f43a6a72.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NTgxMTU5MDksIm5iZiI6MTc1ODExNTYwOSwicGF0aCI6Ii83NjE4MzMzMS80OTAyNzEzNDAtMDEzMjZjNjEtYjdhMi00YzEyLWE5MDctODQzM2Y0M2E2YTcyLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA5MTclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwOTE3VDEzMjY0OVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTA4ZDNiNWJhNzE1OGFiNDUzNjY3YjRiYTllODUxNGY5NjZmODUyNDcyMzI3YTgzNzExNzBmY2JlNDM1OGJkZDkmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.iXbfi1J0nQD_5KVHZRmsAkoFQ3XmFTqr7leMlYrMLiA"/></a>
<p dir="auto">The pattern is undeniable:</p>
<ol dir="auto">
<li>A hardware interrupt fires <code>_GPE._L02</code>.</li>
<li>The handler executes methods to check battery status.</li>
<li>Shortly thereafter, the firmware attempts to change the GPU&#39;s power state.</li>
<li>The system runs normally for about 30-60 seconds.</li>
<li>The cycle repeats.</li>
</ol>
<div dir="auto"><h2 tabindex="-1" dir="auto">Extracting and Decompiling the Firmware Code</h2><a id="user-content-extracting-and-decompiling-the-firmware-code" aria-label="Permalink: Extracting and Decompiling the Firmware Code" href="#extracting-and-decompiling-the-firmware-code"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>

<p dir="auto">To analyze the code responsible for this behavior, we must extract and decompile the ACPI tables provided by the BIOS to the operating system.</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Extract all ACPI tables into binary .dat files
acpidump -b

# Output includes:
# DSDT.dat - The main Differentiated System Description Table
# SSDT1.dat ... SSDT17.dat - Secondary System Description Tables

# Decompile the main table into human-readable ACPI Source Language (.dsl)
iasl -d DSDT.dsl"><pre><span><span>#</span> Extract all ACPI tables into binary .dat files</span>
acpidump -b

<span><span>#</span> Output includes:</span>
<span><span>#</span> DSDT.dat - The main Differentiated System Description Table</span>
<span><span>#</span> SSDT1.dat ... SSDT17.dat - Secondary System Description Tables</span>

<span><span>#</span> Decompile the main table into human-readable ACPI Source Language (.dsl)</span>
iasl -d DSDT.dsl</pre></div>
<p dir="auto">This decompiled ASL provides a direct view into the firmware&#39;s executable logic. It is a precise representation of the exact instructions that the ACPI.sys driver is fed by the firmware and executes at the highest privilege level within the Windows kernel. Any logical flaws found in this code are the direct cause of the system&#39;s behavior.</p>

<p dir="auto">Searching the decompiled <code>DSDT.dsl</code> file, we find the definition for our problematic GPE handler:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Scope (_GPE)
{
    Method (_L02, 0, NotSerialized)  // _Lxx: Level-Triggered GPE
    {
        \_SB.PC00.LPCB.ECLV ()
    }
}"><pre><span>Scope</span> (<span>_GPE</span>)
{
    <span>Method</span> (<span>_L02</span>, <span>0</span>, <span>NotSerialized</span>)  <span>// _Lxx: Level-Triggered GPE</span>
    {
        \<span>_SB</span>.PC00.LPCB.ECLV ()
    }
}</pre></div>
<p dir="auto">This code is simple: when the <code>_L02</code> interrupt occurs, it calls a single method, <code>ECLV</code>. The &#34;L&#34; prefix in <code>_L02</code> signifies that this is a <strong>level-triggered</strong> interrupt, meaning it will continue to fire as long as the underlying hardware condition is active. This is a critical detail.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">The Catastrophic <code>ECLV</code> Implementation</h3><a id="user-content-the-catastrophic-eclv-implementation" aria-label="Permalink: The Catastrophic ECLV Implementation" href="#the-catastrophic-eclv-implementation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Following the call to <code>ECLV()</code>, we uncover a deeply flawed implementation that is the direct cause of the system-wide stuttering.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Method (ECLV, 0, NotSerialized)  // Starting at line 099244
{
    // Main loop - continues while events exist OR sleep events are pending
    // AND we haven&#39;t exceeded our time budget (TI3S &lt; 0x78)
    While (((CKEV() != Zero) || (SLEC != Zero)) &amp;&amp; (TI3S &lt; 0x78))
    {
        Local1 = One
        While (Local1 != Zero)
        {
            Local1 = GEVT()    // Get next event from queue
            LEVN (Local1)      // Process the event
            TIMC += 0x19       // Increment time counter by 25
            
            // This is where it gets really bad
            If ((SLEC != Zero) &amp;&amp; (Local1 == Zero))
            {
                // No events but sleep events pending
                If (TIMC == 0x19)
                {
                    Sleep (0x64)    // Sleep for 100 milliseconds!!!
                    TIMC = 0x64     // Set time counter to 100
                    TI3S += 0x04    // Increment major counter by 4
                }
                Else
                {
                    Sleep (0x19)    // Sleep for 25 milliseconds!!!
                    TI3S++          // Increment major counter by 1
                }
            }
        }
    }
    
    // Here&#39;s where it gets even worse
    If (TI3S &gt;= 0x78)  // If we hit our time budget (120)
    {
        TI3S = Zero
        If (EEV0 == Zero)
        {
            EEV0 = 0xFF    // Force another event to be pending!
        }
    }
}"><pre><span>Method</span> (ECLV, <span>0</span>, <span>NotSerialized</span>)  <span>// Starting at line 099244</span>
{
    <span>// Main loop - continues while events exist OR sleep events are pending</span>
    <span>// AND we haven&#39;t exceeded our time budget (TI3S &lt; 0x78)</span>
    <span>While</span> (((CKEV() != <span>Zero</span>) || (SLEC != <span>Zero</span>)) &amp;&amp; (TI3S &lt; <span>0x78</span>))
    {
        <span>Local1</span> = <span>One</span>
        <span>While</span> (<span>Local1</span> != <span>Zero</span>)
        {
            <span>Local1</span> = GEVT()    <span>// Get next event from queue</span>
            LEVN (<span>Local1</span>)      <span>// Process the event</span>
            TIMC += <span>0x19</span>       <span>// Increment time counter by 25</span>
            
            <span>// This is where it gets really bad</span>
            <span>If</span> ((SLEC != <span>Zero</span>) &amp;&amp; (<span>Local1</span> == <span>Zero</span>))
            {
                <span>// No events but sleep events pending</span>
                <span>If</span> (TIMC == <span>0x19</span>)
                {
                    <span>Sleep</span> (<span>0x64</span>)    <span>// Sleep for 100 milliseconds!!!</span>
                    TIMC = <span>0x64</span>     <span>// Set time counter to 100</span>
                    TI3S += <span>0x04</span>    <span>// Increment major counter by 4</span>
                }
                <span>Else</span>
                {
                    <span>Sleep</span> (<span>0x19</span>)    <span>// Sleep for 25 milliseconds!!!</span>
                    TI3S++          <span>// Increment major counter by 1</span>
                }
            }
        }
    }
    
    <span>// Here&#39;s where it gets even worse</span>
    <span>If</span> (TI3S &gt;= <span>0x78</span>)  <span>// If we hit our time budget (120)</span>
    {
        TI3S = <span>Zero</span>
        <span>If</span> (EEV0 == <span>Zero</span>)
        {
            EEV0 = <span>0xFF</span>    <span>// Force another event to be pending!</span>
        }
    }
}</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Breaking Down this monstrosity</h3><a id="user-content-breaking-down-this-monstrosity" aria-label="Permalink: Breaking Down this monstrosity" href="#breaking-down-this-monstrosity"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This short block of code violates several fundamental principles of firmware and kernel programming.</p>
<p dir="auto"><strong>Wtf 1: Sleeping in an Interrupt Context</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="Sleep (0x64)    // 100ms sleep
Sleep (0x19)    // 25ms sleep"><pre><span>Sleep</span> (<span>0x64</span>)    <span>// 100ms sleep</span>
<span>Sleep</span> (<span>0x19</span>)    <span>// 25ms sleep</span></pre></div>
<p dir="auto">An interrupt handler runs at a very high priority to service hardware requests quickly. The <code>Sleep()</code> function completely halts the execution of the CPU core it is running on (CPU 0 in this case). While CPU 0 is sleeping, it cannot:</p>
<ul dir="auto">
<li>Process any other hardware interrupts.</li>
<li>Allow the kernel to schedule other threads.</li>
<li>Update system timers.</li>
</ul>
<blockquote>
<p dir="auto">Clarification: These Sleep() calls live in the ACPI GPE handling path for the GPE L02, these calls get executed at PASSIVE_LEVEL after the SCI/GPE is acknowledged so it&#39;s not a raw ISR (because i don&#39;t think windows will even allow that) but analyzing this further while the control method runs the GPE stays masked  and the ACPI/EC work is serialized. With the Sleep() calls inside that path and the self rearm it seems to have the effect of making ACPI.sys get tied up in long periodic bursts (often on CPU 0) which still have the same effect on the system.</p>
</blockquote>
<p dir="auto"><strong>Wtf 2: Time-Sliced Interrupt Processing</strong>
The entire loop is designed to run for an extended period, processing events in batches. It&#39;s effectively a poorly designed task scheduler running inside an interrupt handler, capable of holding a CPU core hostage for potentially seconds at a time.</p>
<p dir="auto"><strong>Wtf 3: Self-Rearming Interrupt</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="If (EEV0 == Zero)
{
    EEV0 = 0xFF    // Forces all EC event bits on
}"><pre><span>If</span> (EEV0 == <span>Zero</span>)
{
    EEV0 = <span>0xFF</span>    <span>// Forces all EC event bits on</span>
}</pre></div>
<p dir="auto">This logic ensures that even if the Embedded Controller&#39;s event queue is empty, the code will create a new, artificial event. This guarantees that another interrupt will fire shortly after, creating the perfectly periodic pattern of ACPI spikes observed in the traces.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">The Event Dispatch System</h2><a id="user-content-the-event-dispatch-system" aria-label="Permalink: The Event Dispatch System" href="#the-event-dispatch-system"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">How Events Route to Actions</h3><a id="user-content-how-events-route-to-actions" aria-label="Permalink: How Events Route to Actions" href="#how-events-route-to-actions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The LEVN() method takes an event and routes it:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Method (LEVN, 1, NotSerialized)
  {
      If ((Arg0 != Zero))
      {
          MBF0 = Arg0
          P80B = Arg0
          Local6 = Match (LEGA, MEQ, Arg0, MTR, Zero, Zero)
          If ((Local6 != Ones))
          {
              LGPA (Local6)
          }
      }
  }
"><pre><span>Method</span> (LEVN, <span>1</span>, <span>NotSerialized</span>)
  {
      <span>If</span> ((<span>Arg0</span> != <span>Zero</span>))
      {
          MBF0 = <span>Arg0</span>
          P80B = <span>Arg0</span>
          <span>Local6</span> = <span>Match</span> (LEGA, <span>MEQ</span>, <span>Arg0</span>, <span>MTR</span>, <span>Zero</span>, <span>Zero</span>)
          <span>If</span> ((<span>Local6</span> != <span>Ones</span>))
          {
              LGPA (<span>Local6</span>)
          }
      }
  }
</pre></div>

<p dir="auto">The LGPA() method is a giant switch statement handling different events:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Method (LGPA, 1, Serialized)  // Line 098862
{
    Switch (ToInteger (Arg0))
    {
        Case (Zero)  // Most common case - power event
        {
            DGD2 ()       // GPU-related function
            ^EC0._QA0 ()  // EC query method
            PWCG ()       // Power change - this is our battery polling
        }
        
        Case (0x18)  // GPU-specific event
        {
            If (M6EF == One)
            {
                Local0 = 0xD2
            }
            Else
            {
                Local0 = 0xD1
            }
            NOD2 (Local0)  // Notify GPU driver
        }
        
        Case (0x1E)  // Another GPU event
        {
            Notify (^^PEG1.PEGP, 0xD5)  // Direct GPU notification
            ROCT = 0x55                  // Sets flag for follow-up
        }
       
    }
}"><pre><span>Method</span> (LGPA, <span>1</span>, <span>Serialized</span>)  <span>// Line 098862</span>
{
    <span>Switch</span> (<span>ToInteger</span> (<span>Arg0</span>))
    {
        <span>Case</span> (<span>Zero</span>)  <span>// Most common case - power event</span>
        {
            DGD2 ()       <span>// GPU-related function</span>
            ^EC0._QA0 ()  <span>// EC query method</span>
            PWCG ()       <span>// Power change - this is our battery polling</span>
        }
        
        <span>Case</span> (<span>0x18</span>)  <span>// GPU-specific event</span>
        {
            <span>If</span> (M6EF == <span>One</span>)
            {
                <span>Local0</span> = <span>0xD2</span>
            }
            <span>Else</span>
            {
                <span>Local0</span> = <span>0xD1</span>
            }
            NOD2 (<span>Local0</span>)  <span>// Notify GPU driver</span>
        }
        
        <span>Case</span> (<span>0x1E</span>)  <span>// Another GPU event</span>
        {
            <span>Notify</span> (^^PEG1.PEGP, <span>0xD5</span>)  <span>// Direct GPU notification</span>
            ROCT = <span>0x55</span>                  <span>// Sets flag for follow-up</span>
        }
       
    }
}</pre></div>
<p dir="auto">This shows a direct link: a GPE fires, and the dispatch logic calls functions related to battery polling and GPU notifications.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">The Battery Polling Function</h2><a id="user-content-the-battery-polling-function" aria-label="Permalink: The Battery Polling Function" href="#the-battery-polling-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <code>PWCG()</code> method, called by multiple event types, is responsible for polling the battery and AC adapter status.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Method (PWCG, 0, NotSerialized)
{
    Notify (ADP0, Zero)      // Tell OS to check the AC adapter
    ^BAT0._BST ()            // Execute the Battery Status method
    Notify (BAT0, 0x80)      // Tell OS the battery status has changed
    ^BAT0._BIF ()            // Execute the Battery Information method  
    Notify (BAT0, 0x81)      // Tell OS the battery info has changed
}"><pre><span>Method</span> (PWCG, <span>0</span>, <span>NotSerialized</span>)
{
    <span>Notify</span> (ADP0, <span>Zero</span>)      <span>// Tell OS to check the AC adapter</span>
    ^BAT0.<span>_BST</span> ()            <span>// Execute the Battery Status method</span>
    <span>Notify</span> (BAT0, <span>0x80</span>)      <span>// Tell OS the battery status has changed</span>
    ^BAT0.<span>_BIF</span> ()            <span>// Execute the Battery Information method  </span>
    <span>Notify</span> (BAT0, <span>0x81</span>)      <span>// Tell OS the battery info has changed</span>
}</pre></div>
<p dir="auto">Which we can see here:</p>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/76183331/490271565-f6c62050-b470-49bd-ad55-35def0fff893.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NTgxMTU5MDksIm5iZiI6MTc1ODExNTYwOSwicGF0aCI6Ii83NjE4MzMzMS80OTAyNzE1NjUtZjZjNjIwNTAtYjQ3MC00OWJkLWFkNTUtMzVkZWYwZmZmODkzLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA5MTclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwOTE3VDEzMjY0OVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTExMjllODA1N2EwNmUyMTZiODgyOWNjNTRkYzIwNzVkZWVjZTAyMDFiMTg1NmExYzY2ODZhOTFhYjU3MGRjNmEmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.LjfSV1CkAxrycjnRP1r2XlWXTz4WIzIrcqzC9WUc22Q"><img width="1043" height="315" alt="image" src="https://private-user-images.githubusercontent.com/76183331/490271565-f6c62050-b470-49bd-ad55-35def0fff893.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NTgxMTU5MDksIm5iZiI6MTc1ODExNTYwOSwicGF0aCI6Ii83NjE4MzMzMS80OTAyNzE1NjUtZjZjNjIwNTAtYjQ3MC00OWJkLWFkNTUtMzVkZWYwZmZmODkzLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA5MTclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwOTE3VDEzMjY0OVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTExMjllODA1N2EwNmUyMTZiODgyOWNjNTRkYzIwNzVkZWVjZTAyMDFiMTg1NmExYzY2ODZhOTFhYjU3MGRjNmEmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.LjfSV1CkAxrycjnRP1r2XlWXTz4WIzIrcqzC9WUc22Q"/></a>
<p dir="auto">Each of these operations requires communication with the Embedded Controller, adding to the workload inside the already-stalled interrupt handler.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">The GPU Notification System</h3><a id="user-content-the-gpu-notification-system" aria-label="Permalink: The GPU Notification System" href="#the-gpu-notification-system"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <code>NOD2()</code> method sends notifications to the GPU driver.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Method (NOD2, 1, Serialized)
{
    If ((Arg0 != DNOT))
    {
        DNOT = Arg0
        Notify (^^PEG1.PEGP, Arg0)
    }

    If ((ROCT == 0x55))
    {
        ROCT = Zero
        Notify (^^PEG1.PEGP, 0xD1) // Hardware-Specific
    }
}"><pre><span>Method</span> (NOD2, <span>1</span>, <span>Serialized</span>)
{
    <span>If</span> ((<span>Arg0</span> != DNOT))
    {
        DNOT = <span>Arg0</span>
        <span>Notify</span> (^^PEG1.PEGP, <span>Arg0</span>)
    }

    <span>If</span> ((ROCT == <span>0x55</span>))
    {
        ROCT = <span>Zero</span>
        <span>Notify</span> (^^PEG1.PEGP, <span>0xD1</span>) <span>// Hardware-Specific</span>
    }
}</pre></div>
<p dir="auto">These notifications (<code>0xD1</code>, <code>0xD2</code>, etc.) are hardware-specific signals that tell the NVIDIA driver to re-evaluate its power state, which is what triggers the futile <code>_PS0/_DOS/_PS3</code> power-cycling sequence seen in the traces.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">The Mux Mode Confusion: A Firmware with a Split Personality</h2><a id="user-content-the-mux-mode-confusion-a-firmware-with-a-split-personality" aria-label="Permalink: The Mux Mode Confusion: A Firmware with a Split Personality" href="#the-mux-mode-confusion-a-firmware-with-a-split-personality"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Here&#39;s where a simple but catastrophic oversight in the firmware&#39;s logic causes system-wide failure. High-end ASUS gaming laptops feature a MUX (Multiplexer) switch, a piece of hardware that lets the user choose between two distinct graphics modes:</p>
<ol dir="auto">
<li><strong>Optimus Mode:</strong> The power-saving default. The integrated Intel GPU (iGPU) is physically connected to the display. The powerful NVIDIA GPU (dGPU) only renders demanding applications when needed, passing finished frames to the iGPU to be drawn on screen.</li>
<li><strong>Ultimate/Mux Mode:</strong> The high-performance mode. The MUX switch physically rewires the display connections, bypassing the iGPU entirely and wiring the NVIDIA dGPU directly to the screen. In this mode, the dGPU is not optional; it is the <strong>only</strong> graphics processor capable of outputting an image.</li>
</ol>
<p dir="auto">Any firmware managing this hardware <strong>must</strong> be aware of which mode the system is in. Sending a command intended for one GPU to the other is futile and, in some cases, dangerous. Deep within the ACPI code, a hardware status flag named <code>HGMD</code> is used to track this state. To understand the flaw, we first need to decipher what <code>HGMD</code> means, and the firmware itself gives us the key.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto"><strong>Decoding the Firmware&#39;s Logic with the Brightness Method</strong></h4><a id="user-content-decoding-the-firmwares-logic-with-the-brightness-method" aria-label="Permalink: Decoding the Firmware&#39;s Logic with the Brightness Method" href="#decoding-the-firmwares-logic-with-the-brightness-method"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">For screen brightness to work, the command must be sent to the GPU that is physically controlling the display backlight. A command sent to the wrong GPU will simply do nothing. Therefore, the brightness control method (<code>BRTN</code>) <em>must</em> be aware of the MUX switch state to function at all. It is the firmware&#39;s own Rosetta Stone.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Brightness control - CORRECTLY checks for mux mode
Method (BRTN, 1, Serialized)  // Line 034003
{
    If (((DIDX &amp; 0x0F0F) == 0x0400))
    {
        If (HGMD == 0x03)  // 0x03 = Ultimate/Mux mode
        {
            // In mux mode, notify discrete GPU
            Notify (\_SB.PC00.PEG1.PEGP.EDP1, Arg0)
        }
        Else
        {
            // In Optimus, notify integrated GPU
            Notify (\_SB.PC00.GFX0.DD1F, Arg0)
        }
    }
}"><pre><span>// Brightness control - CORRECTLY checks for mux mode</span>
<span>Method</span> (BRTN, <span>1</span>, <span>Serialized</span>)  <span>// Line 034003</span>
{
    <span>If</span> (((DIDX &amp; <span>0x0F0F</span>) == <span>0x0400</span>))
    {
        <span>If</span> (HGMD == <span>0x03</span>)  <span>// 0x03 = Ultimate/Mux mode</span>
        {
            <span>// In mux mode, notify discrete GPU</span>
            <span>Notify</span> (\<span>_SB</span>.PC00.PEG1.PEGP.EDP1, <span>Arg0</span>)
        }
        <span>Else</span>
        {
            <span>// In Optimus, notify integrated GPU</span>
            <span>Notify</span> (\<span>_SB</span>.PC00.GFX0.DD1F, <span>Arg0</span>)
        }
    }
}</pre></div>
<p dir="auto">The logic here is flawless and revealing. The code uses the <code>HGMD</code> flag to make a binary decision. If <code>HGMD</code> is <code>0x03</code>, it sends the command to the NVIDIA GPU. If not, it sends it to the Intel GPU. The firmware itself, through this correct implementation, provides the undeniable definition: <strong><code>HGMD == 0x03</code> means the system is in Ultimate/Mux Mode.</strong></p>
<div dir="auto"><h4 tabindex="-1" dir="auto"><strong>The Logical Contradiction: Unconditional Power Cycling in a Conditional Hardware State</strong></h4><a id="user-content-the-logical-contradiction-unconditional-power-cycling-in-a-conditional-hardware-state" aria-label="Permalink: The Logical Contradiction: Unconditional Power Cycling in a Conditional Hardware State" href="#the-logical-contradiction-unconditional-power-cycling-in-a-conditional-hardware-state"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This perfect, platform-aware logic is completely abandoned in the critical code paths responsible for power management. The <code>LGPA</code> method, which is called by the stutter-inducing interrupt, dispatches power-related commands to the GPU <em>without ever checking the MUX mode</em>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// GPU power notification - NO MUX CHECK!
Case (0x18)
{
    // This SHOULD have: If (HGMD != 0x03)
    // But it doesn&#39;t, so it runs even in mux mode
    If (M6EF == One)
    {
        Local0 = 0xD2
    }
    Else
    {
        Local0 = 0xD1
    }
    NOD2 (Local0)  // Notifies GPU regardless of mode
}"><pre><span>// GPU power notification - NO MUX CHECK!</span>
<span>Case</span> (<span>0x18</span>)
{
    <span>// This SHOULD have: If (HGMD != 0x03)</span>
    <span>// But it doesn&#39;t, so it runs even in mux mode</span>
    <span>If</span> (M6EF == <span>One</span>)
    {
        <span>Local0</span> = <span>0xD2</span>
    }
    <span>Else</span>
    {
        <span>Local0</span> = <span>0xD1</span>
    }
    NOD2 (<span>Local0</span>)  <span>// Notifies GPU regardless of mode</span>
}</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Another Path to the Same Problem: The Platform Power Management DSM</h3><a id="user-content-another-path-to-the-same-problem-the-platform-power-management-dsm" aria-label="Permalink: Another Path to the Same Problem: The Platform Power Management DSM" href="#another-path-to-the-same-problem-the-platform-power-management-dsm"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This is not a single typo. A second, parallel power management system in the firmware exhibits the exact same flaw. The Platform Extension Plug-in Device (<code>PEPD</code>) is used by Windows to manage system-wide power states, such as turning off displays during modern standby.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Device (PEPD)  // Line 071206
{
    Name (_HID, &#34;INT33A1&#34;)  // Intel Power Engine Plugin
    
    Method (_DSM, 4, Serialized)  // Device Specific Method
    {
        // ... lots of setup code ...
        
        // Arg2 == 0x05: &#34;All displays have been turned off&#34;
        If ((Arg2 == 0x05))
        {
            // Prepare for aggressive power saving
            If (CondRefOf (\_SB.PC00.PEG1.DHDW))
            {
                ^^PC00.PEG1.DHDW ()         // GPU pre-shutdown work
                ^^PC00.PEG1.DGCE = One      // Set &#34;GPU Cut Enable&#34; flag
            }
            
            If (S0ID == One)  // If system supports S0 idle
            {
                GUAM (One)    // Enter low power mode
            }
            
            ^^PC00.DPOF = One  // Display power off flag
            
            // Tell USB controller about display state
            If (CondRefOf (\_SB.PC00.XHCI.PSLI))
            {
                ^^PC00.XHCI.PSLI (0x05)
            }
        }
        
        // Arg2 == 0x06: &#34;A display has been turned on&#34;
        If ((Arg2 == 0x06))
        {
            // Wake everything back up
            If (CondRefOf (\_SB.PC00.PEG1.DGCE))
            {
                ^^PC00.PEG1.DGCE = Zero     // Clear &#34;GPU Cut Enable&#34;
            }
            
            If (S0ID == One)
            {
                GUAM (Zero)   // Exit low power mode
            }
            
            ^^PC00.DPOF = Zero  // Display power on flag
            
            If (CondRefOf (\_SB.PC00.XHCI.PSLI))
            {
                ^^PC00.XHCI.PSLI (0x06)
            }
        }
    }
}"><pre><span>Device</span> (PEPD)  <span>// Line 071206</span>
{
    <span>Name</span> (<span>_HID</span>, <span>&#34;INT33A1&#34;</span>)  <span>// Intel Power Engine Plugin</span>
    
    <span>Method</span> (<span>_DSM</span>, <span>4</span>, <span>Serialized</span>)  <span>// Device Specific Method</span>
    {
        <span>// ... lots of setup code ...</span>
        
        <span>// Arg2 == 0x05: &#34;All displays have been turned off&#34;</span>
        <span>If</span> ((<span>Arg2</span> == <span>0x05</span>))
        {
            <span>// Prepare for aggressive power saving</span>
            <span>If</span> (<span>CondRefOf</span> (\<span>_SB</span>.PC00.PEG1.DHDW))
            {
                ^^PC00.PEG1.DHDW ()         <span>// GPU pre-shutdown work</span>
                ^^PC00.PEG1.DGCE = <span>One</span>      <span>// Set &#34;GPU Cut Enable&#34; flag</span>
            }
            
            <span>If</span> (S0ID == <span>One</span>)  <span>// If system supports S0 idle</span>
            {
                GUAM (<span>One</span>)    <span>// Enter low power mode</span>
            }
            
            ^^PC00.DPOF = <span>One</span>  <span>// Display power off flag</span>
            
            <span>// Tell USB controller about display state</span>
            <span>If</span> (<span>CondRefOf</span> (\<span>_SB</span>.PC00.XHCI.PSLI))
            {
                ^^PC00.XHCI.PSLI (<span>0x05</span>)
            }
        }
        
        <span>// Arg2 == 0x06: &#34;A display has been turned on&#34;</span>
        <span>If</span> ((<span>Arg2</span> == <span>0x06</span>))
        {
            <span>// Wake everything back up</span>
            <span>If</span> (<span>CondRefOf</span> (\<span>_SB</span>.PC00.PEG1.DGCE))
            {
                ^^PC00.PEG1.DGCE = <span>Zero</span>     <span>// Clear &#34;GPU Cut Enable&#34;</span>
            }
            
            <span>If</span> (S0ID == <span>One</span>)
            {
                GUAM (<span>Zero</span>)   <span>// Exit low power mode</span>
            }
            
            ^^PC00.DPOF = <span>Zero</span>  <span>// Display power on flag</span>
            
            <span>If</span> (<span>CondRefOf</span> (\<span>_SB</span>.PC00.XHCI.PSLI))
            {
                ^^PC00.XHCI.PSLI (<span>0x06</span>)
            }
        }
    }
}</pre></div>
<p dir="auto">Once again, the firmware prepares to cut power to the discrete GPU without first checking if it&#39;s the only GPU driving the displays. This demonstrates that the Mux Mode Confusion is a systemic design flaw. The firmware is internally inconsistent, leading it to issue self-destructive commands that try to cripple the system.</p>

<p dir="auto">Traces from multiple ASUS gaming laptop models confirm this is not an isolated issue.</p>

<ul dir="auto">
<li><strong>Trace Duration:</strong> 4.1 minutes</li>
<li><strong><code>_GPE._L02</code> Events:</strong> 7</li>
<li><strong>Avg. GPE Duration:</strong> 1.56ms (lower, but still unacceptably high)</li>
<li><strong>Avg. Interval:</strong> 39.4 seconds (nearly identical periodic nature)</li>
<li><strong>GPU Power Cycles:</strong> 8</li>
</ul>

<ul dir="auto">
<li><strong>Trace Duration:</strong> 19.9 minutes</li>
<li><strong><code>_GPE._L02</code> Events:</strong> 3</li>
<li><strong>Avg. GPE Duration:</strong> 2.94ms</li>
<li><strong>GPU Power Cycles:</strong> 197 (far more frequent)</li>
<li><strong>ASUS WMI Calls:</strong> 2,370 (a massive number, indicating software amplification)</li>
</ul>
<p dir="auto">Microsoft has a built-in &#34;smooth video&#34; check. It plays HD video in full screen and watches for hiccups. If the PC drops frames, crackles, or any driver pauses for more than a few milliseconds, it fails. That’s Microsoft’s baseline for what &#34;smooth&#34; should look like.</p>
<p dir="auto">Why it matters here:</p>
<p dir="auto">ASUS firmware is causing millisecond-long pauses. Those pauses are exactly the kind that make this test fail i.e., the same stutters and audio pops regular users notice on YouTube/Netflix and games; this firmware violates fundemental standards.</p>

<p dir="auto">Despite being different models, all affected systems exhibit the same core flaws:</p>
<ol dir="auto">
<li><code>_GPE._L02</code> handlers take milliseconds to execute instead of microseconds.</li>
<li>The GPEs trigger unnecessary battery polling.</li>
<li>The firmware attempts to power cycle the GPU while in a fixed MUX mode.</li>
<li>The entire process is driven by a periodic, timer-like trigger.</li>
</ol>

<p dir="auto">This bug is a cascade of firmware design failures.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Root Cause 1: The Misunderstanding of Interrupt Context</h3><a id="user-content-root-cause-1-the-misunderstanding-of-interrupt-context" aria-label="Permalink: Root Cause 1: The Misunderstanding of Interrupt Context" href="#root-cause-1-the-misunderstanding-of-interrupt-context"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">On windows, the LXX / EXX run at PASSIVE_LEVEL via ACPI.sys but while a GPE control method runs <strong>the firing GPE stays masked</strong> and ACPI/EC work is <strong>serialized</strong>. ASUS&#39;s dispatch from GPE._L02 to ECLV loops, calls Sleep(25/100ms) and re-arms the EC stretching that masked window into tens of milliseconds (which would explain the 13ms CPU time in ETW (Kernel ms) delay for GPE Events) and producing a periodic ACPI.sys burst that causes the latency problems on the system.The correct behavior is to latch or clear the event, exit the method, and signal a driver with Notify for any heavy work; do not self-rearm or sleep in this path at all.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Root Cause 2: Flawed Interrupt Handling</h3><a id="user-content-root-cause-2-flawed-interrupt-handling" aria-label="Permalink: Root Cause 2: Flawed Interrupt Handling" href="#root-cause-2-flawed-interrupt-handling"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The firmware artificially re-arms the interrupt, creating an endless loop of GPEs instead of clearing the source and waiting for the next legitimate hardware event. This transforms a hardware notification system into a disruptive, periodic timer.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Root Cause 3: Lack of Platform Awareness</h3><a id="user-content-root-cause-3-lack-of-platform-awareness" aria-label="Permalink: Root Cause 3: Lack of Platform Awareness" href="#root-cause-3-lack-of-platform-awareness"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The code that sends GPU power notifications does not check if the system is in MUX mode, a critical state check that is correctly performed in other parts of the firmware. This demonstrates inconsistency and a lack of quality control.</p>


<p dir="auto">This issue is not new or isolated. User reports documenting identical symptoms with high ACPI.sys DPC latency, periodic stuttering, and audio crackling have been accumulating since at least 2021 across ASUS&#39;s entire gaming laptop lineup.</p>
<p dir="auto"><strong>August 2021: The First Major Reports</strong></p>
<p dir="auto">Reddit users simultaneously report <a href="https://www.reddit.com/r/ASUS/comments/odprtv/high_dpc_latency_from_acpisys_can_be_caused_by/" rel="nofollow">identical ACPI.sys latency problems</a> alongside NVIDIA driver issues; the exact symptoms described in this investigation.</p>
<p dir="auto"><strong>2021-2023: Spreading Across Models</strong></p>
<ul dir="auto">
<li><a href="https://www.reddit.com/r/techsupport/comments/mxtm86/i_need_help_high_acpisys_latency_and_microstutters/" rel="nofollow">ROG Strix models experience micro-stutters</a></li>
<li><a href="https://www.reddit.com/r/Asustuf/comments/1m2e40v/my_laptop_throttling_for_few_seconds/" rel="nofollow">TUF Gaming series reports throttling for seconds at a time</a></li>
<li><a href="https://www.reddit.com/r/techsupport/comments/17rqfq5/new_laptop_started_stuttering_every_45_seconds/" rel="nofollow">G18 models exhibit the characteristic 45-second periodic stuttering</a></li>
</ul>
<p dir="auto"><strong>2023-2024: The Problem Persists in New Models</strong></p>
<ul dir="auto">
<li><a href="https://www.reddit.com/r/ZephyrusM16/comments/1j33ld6/this_machine_has_been_nothing_but_problems_no/" rel="nofollow">2023 Zephyrus G16 owners report persistent audio issues</a></li>
<li><a href="https://www.reddit.com/r/ZephyrusG14/comments/1l4jb13/audio_popscrackles_on_zephyrus_g16_2023/" rel="nofollow">2023 G16 models continue experiencing audio pops/crackles</a></li>
<li><a href="https://www.reddit.com/r/ZephyrusG14/comments/1i2w9ah/resolving_audio_popsstuttering_on_2024_intel_g16/" rel="nofollow">2024 Intel G16 models require workarounds for audio stuttering</a></li>
</ul>

<p dir="auto">The evidence is undeniable:</p>
<ul dir="auto">
<li><strong>Measured Proof:</strong> GPE handlers are measured blocking a CPU core for over 13 milliseconds.</li>
<li><strong>Code Proof:</strong> The decompiled firmware explicitly contains <code>Sleep()</code> calls within an interrupt handler.</li>
<li><strong>Logical Proof:</strong> The code lacks critical checks for the laptop&#39;s hardware state (MUX mode).</li>
<li><strong>Systemic Proof:</strong> The issue is reproducible across different models and BIOS versions.</li>
</ul>
<p dir="auto">Until a fix is implemented, millions of buyers of Asus laptops from approx. 2021 to present day are facing stutters on the simplest of tasks, such as watching YouTube, for the simple mistake of using a sleep call inside of an inefficient interrupt handler and not checking the GPU environment properly.</p>
<p dir="auto">The code is there. The traces prove it. ASUS must fix its firmware.</p>
<blockquote>
<p dir="auto">ASUS has not responded to this investigation or the documented firmware issues at the time of publication, will update this if anything changes.</p>
</blockquote>
<hr/>
<p dir="auto"><em>Investigation conducted using the Windows Performance Toolkit, ACPI table extraction tools, and Intel ACPI Component Architecture utilities. All code excerpts are from official ASUS firmware. Traces were captured on multiple affected systems, all showing consistent behavior. I used an LLM for wording. The research, traces, and AML decomp are mine. Every claim is verified and reproducible if you follow the steps in the article; logs and commands are in the repo. If you think something&#39;s wrong, cite the exact timestamp/method/line. &#34;AI wrote it&#34; is not an argument.</em></p>
</article></div></div>
  </body>
</html>
