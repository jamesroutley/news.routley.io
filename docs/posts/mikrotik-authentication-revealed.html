<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://margin.re/blog/mikrotik-authentication-revealed.aspx">Original</a>
    <h1>MikroTik authentication revealed</h1>
    
    <div id="readability-page-1" class="page"><div id="content">



<section id="home">
<div>
<div>

<article id="text">
<h2>MikroTik Authentication Revealed</h2>
<div>
<p><time><i aria-hidden="true"></i> February 10, 2022</time>

<span><i aria-hidden="true"></i> Posted in: </span>
</p></div>

<h2 id="docs-internal-guid-4f04f2bf-7fff-f66b-f64a-334f919cbb7c">MikroTik Authentication Revealed</h2>
<p>In August 2019, MikroTik issued a RouterOS software update to version 6.45.1 which removed plaintext password storage on all routers that upgraded to the new firmware. While enhancing router security, this came as a blow for researchers, network administrators, and tinkerers who used customized tooling with MikroTik proprietary protocols such as MAC Telnet and Winbox. MikroTik has since failed to detail the new authentication procedure <a href="https://forum.mikrotik.com/viewtopic.php?t=150989">despite user requests for assistance</a>. Margin Research is excited to illuminate the authentication procedure and offer Python <a href="https://github.com/MarginResearch/mikrotik_authentication">proof of concept (POC) implementations</a> for Winbox and MAC Telnet authentication.</p>
<h2>SRP Overview</h2>
<p>MikroTik&#39;s new authentication process uses a variation of Secure Remote Password (SRP). SRP is a type of Password Authentication Key Exchange protocol which incorporates the password within key exchange calculations. Knowledge of the correct password is required to compute the shared secret, so identical secrets indicate successful authentication. The SRP specification dates back over two decades and mainstream use gained traction in the recent past, highlighted by its use in OpenSSL. However, MikroTik does not implement this SRP protocol. Rather, RouterOS employs elliptic curve SRP (EC-SRP), specifically EC-SRP5. This protocol, which is much less prevalent, is defined by the following sequence:</p>
<h4>User registration</h4>
<ol>
<li>A user registers with the system, providing a <code>username</code> and <code>password</code></li>
<li>The router generates a 16-byte user <code>salt</code> and calculates the user’s password verifier, <code>v</code>, according to the equation <code>v = ECDH(SHA2(salt | SHA2(username | “:” | password)))</code><a href="#fn1" id="r1"><sup>[1]</sup></a></li>
<li>The router stores <code>username</code>, <code>salt</code>, and <code>v</code>’s x coordinate, <code>v<sub>x</sub></code>, in memory in <code>/rw/store/user.dat</code></li>
</ol>
<figure>
<img alt="Mikrotik Registration Exchange" src="https://margin.re/attachments/mikrotik_registration.png"/></figure>
<h4>Client Authentication</h4>
<ol>
<li>The client generates an ephemeral private key, <code>Tc</code>, and computes its ephemeral public key point <code>Wc = ECDH(Tc)</code>. The client sends an authentication request including <code>username</code> and the point’s x coordinate, <code>Wc<sub>x</sub></code>, as its ephemeral public key
<ul>
<li>Since each elliptic curve x coordinate has two y solutions, <code>(x, y)</code> and <code>(x, -y)</code>, the client also transmits the parity of the generated point’s y coordinate, <code>Wc<sub>y</sub></code>, to ensure the server calculates the identical point and not its negation</li>
</ul>
</li>
<li>The server retrieves the associated client’s <code>salt</code> and <code>v<sub>x</sub></code>. The server then generates an ephemeral private key, <code>Ts</code>, and computes a password-entangled public key point, <code>Ws = ECDH(Ts) + plot(SHA2(v<sub>x</sub>))</code><a href="#fn2" id="r2"><sup>[2]</sup></a>. Finally, the server responds with <code>Ws<sub>x</sub></code> and <code>salt</code>
<ul>
<li>The server similarly calculates and transmits the parity of its public point’s y coordinate, <code>Ws<sub>y</sub></code></li>
</ul>
</li>
</ol>
<figure>
<img alt="Mikrotik Registration Exchange" src="https://margin.re/attachments/mikrotik_key_exchange.png"/></figure>
<ol start="3">
<li role="presentation">The client, now knowing the user’s <code>salt</code> and the server’s public key, can compute the shared secret and confirmation code as follows:
<ul>
<li role="presentation">Calculates <code>v</code>&#39;s private key, <code>vp = SHA2(salt | SHA2(username | “:” | password))</code></li>
<li role="presentation">Plots <code>v</code> as the server did during registration and retrieves the x coordinate, <code>v<sub>x</sub></code></li>
<li role="presentation">Calculates pseudo-random point <code>e = plot(SHA2(v<sub>x</sub>))</code>, as the server computed in the preceding step</li>
<li role="presentation">Computes the server public point <code>Ws</code> using <code>plot(Ws<sub>x</sub>)</code></li>
<li role="presentation">Performs point subtraction to disentangle the password, calculating <code>u = Ws - e </code></li>
<li role="presentation">Calculates hash <code>h = SHA2(Wc + Ws)</code></li>
<li role="presentation">Performs scalar addition and multiplication to compute <code>Tc + h.v<sub>p</sub></code></li>
<li role="presentation">Calculates the shared point, <code>z</code>, using elliptic curve multiplication with the previously calculated <code>u</code> point to find <code>z = u(Tc + h.v)</code></li>
<li role="presentation">Computes a client-side confirmation code, <code>Cc = SHA2(h + z<sub>x</sub>)</code></li>
</ul>
</li>
</ol>
<p role="presentation">The client completes this handshake step by transmitting <code>Cc</code>.</p>
<ol start="4">
<li role="presentation">The server computes the shared secret point, <code>z</code>, as follows:
<ul>
<li role="presentation">Calculates hash <code>h = SHA2(Wc + Ws)</code></li>
<li role="presentation">Multiplies <code>h.v</code> over the elliptic curve</li>
<li role="presentation">Computes <code>plot(Wc<sub>x</sub>)</code> on the elliptic curve, generating <code>Wc</code></li>
<li role="presentation">Adds <code>Wc + h.v</code> over the elliptic curve</li>
<li role="presentation">Performs a final elliptic curve scalar multiplication using the server’s private key to yield <code>z = Ts(Wc + h.v)</code></li>
</ul>
</li>
</ol>
<p>The server validates the username and password by similarly calculating <code>Cc</code> and checking against the client provided value.<a href="#fn3" id="r3"><sup>[3]</sup></a></p>
<figure>
<img alt="Mikrotik Authentication Exchange" src="https://margin.re/attachments/mikrotik_auth_flow.png"/></figure>
<h4>Encryption</h4>
<p>The server and client can encrypt data once confirming an equivalent shared secret. MikroTik employs a MAC-then-encrypt strategy, leveraging AES-CBC as the encryption algorithm and HMAC as the authentication algorithm. RouterOS also uses separate send and receive keys for both HMAC and AES, labeled below as <code>AES<sub>s</sub>, AES<sub>r</sub>, HMAC<sub>s</sub>, HMAC<sub>r</sub></code>. Both server and client generate these keys using “magic” strings and the HMAC key derivation function, HKDF. Messages prepend encrypted data with the unique random initialization vector, <code>IV</code>, used in AES-CBC mode.</p>
<figure>
<img alt="MikroTik Encryption" src="https://margin.re/attachments/mikrotik_encrypt.png"/>

</figure>
<p>A representative Winbox packet is shown below.</p>
<figure>
<img alt="MikroTik Encrypted Message" src="https://margin.re/attachments/mikrotik_message.png"/>

</figure>
<h2>MikroTik Intricacies</h2>
<p>This is undoubtedly a complicated procedure, and involves many more steps than standard elliptic curve Diffie Hellman or previous RouterOS protocols that simply checked password hashes. But the difficulty does not end there; this protocol is additionally complicated by MikroTik’s elliptic curve choices. RouterOS authentication uses a standard Montgomery curve, such as the popular donna25519 library, for some calculations, <i>but not all</i>. And it unfortunately does not use the NaCl/libsodium default Ed25519 Edwards curve. Rather, for either added efficiency or obscurity (or a bit of both), RouterOS performs most calculations over the standard Weierstrass curve: <code>Y<sup>2</sup>=X<sup>3</sup>+aX+b</code>. Furthermore, it calculates points in weighted projective space <code>P(2,3,1)</code> for even greater computation efficiency. This yields the Weierstrass equation: <code>y<sup>2</sup>=x<sup>3</sup>+axz<sup>4</sup>+bz<sup>6</sup></code>, where <code>Y=y/z<sup>3</sup></code> and <code>X=x/z<sup>2</sup></code>.</p>
<figure>
<img alt="3-D plot of affine space" src="https://margin.re/attachments/mikrotik_affine.png"/> <figcaption>
<p><b>Figure 1:</b> A Montgomery elliptic curve plotted in affine form where <code>Z=1</code><sup><a href="#fn4" id="r4">[4]</a></sup></p>
</figcaption></figure>
<figure>
<img alt="3-D plot showing projective transformation" src="https://margin.re/attachments/mikrotik_projective.png"/> <figcaption>
<p><b>Figure 2:</b> Three-dimensional space which includes the projective plane at <code>Z=1</code>. <code>(x, y, z)</code> points are “projected” into affine form <code>(X, Y)</code> by calculating the intersection between the <code>Z=1</code> plane and a line passing through the origin and point <code>(x, y, z)</code><a href="#fn4" id="r4"><sup>[4]</sup></a></p>
</figcaption></figure>
<p role="presentation">Confused? Understandably so. The result of everything previously detailed is an authentication protocol with copious elliptic curve calculations across three different curve varieties: Montgomery curves, Weierstrass curves in affine form (<code>Z=1</code>), and Weierstrass curves in weighted projective space. This requires conversions to and from different curves and projective spaces, which makes following the authentication flow extremely difficult. The <a href="https://github.com/MarginResearch/mikrotik_authentication">Python POC examples</a> detail the sequence specifically, though the following high-level overview might be better suited for some interested readers:</p>
<ul>
<li role="presentation">The <code>ECDH()</code> equation generates a public key, <code>pub</code>, by multiplying private key, <code>priv</code>, by base point <code>g</code> on the Weierstrass curve in <b>weighted projective space</b>. This returns the point <code>(xw : yw : zw)</code>. The function then converts the point to Weierstrass affine form and further converts to Montgomery form; specifically, the function calculates the Weierstrass affine coordinate  <code>X=x/z<sup>2</sup></code> and converts <code>X</code> to Montgomery form
<ul>
<li role="presentation">This is odd because the private key is multiplied over the Weierstrass curve, but the public key returned is the x coordinate in Montgomery form</li>
</ul>
</li>
<li role="presentation">The <code>plot()</code> function plots a given x coordinate on the Weierstrass curve in affine form. Therefore, it returns a Weierstrass point <code>(X : Y : 1)</code>
<ul>
<li role="presentation">Interestingly, it actually performs this operation by first plotting the point on the Montgomery curve and converting the x coordinate by adding constant <code>a/3</code> (where <code>a</code> is the Montgomery curve constant from the curve’s equation <code>Y<sup>2</sup>=X<sup>3</sup>+aX<sup>2</sup>+X</code>)</li>
</ul>
</li>
<li role="presentation">All point multiplication and addition over the Weierstrass curve are performed in weighted projective space. Thus, any returned parameters (e.g., shared secret point <code>z</code>, public keys <code>Wc</code> and <code>Ws</code>) must be converted to Weierstrass affine form</li>
</ul>
<p>The picture becomes a bit clearer with those considerations in mind. The subtle choice of using Weierstrass curves for public key calculations makes an obscure protocol even more challenging to replicate. Considering all the intricacies outlined, it is no surprise that this authentication scheme was not reproduced in a public implementation until now.</p>
<h2>Still With Us?</h2>
<p>We hope so. This cryptographic reverse engineering effort had a little bit of everything: an obscure protocol, multiple elliptic curve definitions, and conversions from weighted projective space. If you are hungry for more, or want to put yourself through further technical torture, please see the source code and additional commentary in our <a href="https://github.com/MarginResearch/mikrotik_authentication">GitHub repo</a>. But wait! For those who are truly insatiable, there&#39;s more. The single best resource we used in reverse engineering was an unfinished <a href="https://web.archive.org/web/20131228182531/http://grouper.ieee.org/groups/1363/passwdPK/submissions/p1363ecsrp.pdf">IEEE submission draft</a> courtesy of the WayBack Machine. In fact, MikroTik&#39;s implementation is <em>nearly </em>identical to the draft&#39;s proposed protocol. See if you can spot the minor nuances and marvel (as we did) that the shared secret remains the same.</p>

<p id="fn1"><a href="#r1">[1]</a> <code>ECDH()</code> accepts a private key as input and returns the associated elliptic curve public key, as in elliptic curve Diffie Hellman. This is replicated by the <code>gen_public_key</code> method in <code>elliptic_curves.py</code>’s <code>WCurve</code> class</p>
<p id="fn2"><a href="#r2">[2]</a> <code>plot()</code> accepts an x coordinate and returns the corresponding point on the elliptic curve. This is replicated by the <code>lift_x</code> method in <code>elliptic_curves.py</code>’s <code>WCurve</code> class</p>
<p id="fn3"><a href="#r3">[3]</a> The server may complete the authentication handshake by sending a server confirmation code, <code>Cs</code>, for the client to validate the server’s authenticity. In the case of the Winbox protocol, <code>Cs = SHA2(h + Cc + zx)</code></p>
<p id="fn4"><a href="#r4">[4]</a> source: <a href="https://crypto.stackexchange.com/questions/40947/what-is-the-projective-space">https://crypto.stackexchange.com/questions/40947/what-is-the-projective-space</a></p>

<p><a href="https://margin.re/blog/">‹ Return to Blog</a></p>
</article>




</div>
</div>
</section>

</div></div>
  </body>
</html>
