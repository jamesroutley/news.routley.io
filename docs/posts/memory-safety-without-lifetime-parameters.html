<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3444r0.html">Original</a>
    <h1>Memory Safety Without Lifetime Parameters</h1>
    
    <div id="readability-page-1" class="page"><div>

<div>

<p>This proposal describes the implementation of a memory-safe reference
type that does not use lifetime annotations. The goal of the proposal is
to:</p>
<ol type="1">
<li>Explore the viability of memory safety without lifetime
parameters.</li>
<li>Explain the infeasibility of making legacy lvalue- and
rvalue-references memory safe.</li>
<li>Address common objections to safety models that use lifetime
annotations.</li>
</ol>

<p>“Safe C++”<span data-cites="safecpp">[<a href="https://safecpp.org/draft.html" role="doc-biblioref">safecpp</a>]</span> introduced a comprehensive
design for compile-time memory safety in C++. The borrow checking model
in Safe C++ requires lifetime parameters, a feature that increases
expressiveness but complicates the language’s type system. This proposal
describes an alternative style of borrow checking, guaranteeing lifetime
safety without the involvement of lifetime annotations.</p>
<p>First let’s recap how lifetime parameters are declared and used.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/lifetimes/lifetimes1.cxx"><strong>lifetimes1.cxx</strong></a>
– <a href="https://godbolt.org/z/5s9qG1h4E">(Compiler Explorer)</a></p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>#</span><span>feature on safety</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span>// Function parameters have different lifetime parameters. </span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span>// Return type is constrained by x&#39;s lifetime.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span>auto</span> f1<span>/(</span>a, b<span>)(</span><span>int</span><span>^/</span>a x, <span>int</span><span>^/</span>b y, <span>bool</span> pred<span>)</span> safe <span>-&gt;</span> <span>int</span><span>^/</span>a <span>{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span>// Error:</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span>// function auto f1/(a, b)(int^/a, int^/b) -&gt; int^/a returns</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span>// object with lifetime b, but b doesn&#39;t outlive a</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span>// return y;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span>return</span> pred <span>?</span> x <span>:</span> y;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span>// Function parameters have a common lifetime parameter.</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span>auto</span> f2<span>/(</span>a<span>)(</span><span>int</span><span>^/</span>a x, <span>int</span><span>^/</span>a y, <span>bool</span> pred<span>)</span> safe <span>-&gt;</span> <span>int</span><span>^/</span>a <span>{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span>// Ok</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span>return</span> pred <span>?</span> x <span>:</span> y;</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span>// Error:</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span>// cannot use lifetime elision for return type int^ </span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span>auto</span> f3<span>(</span><span>int</span><span>^</span> x, <span>int</span><span>^</span> y<span>)</span> safe <span>-&gt;</span> <span>int</span><span>^</span>;</span></code></pre></div>
<p>In Safe C++, occurrences of the borrow type
<code>T<span>^</span></code> in
function declarations and in data members require specialization with
<em>lifetime arguments</em>. Lifetime arguments name
<em>lifetime-parameters</em> declared as part of the function
declaration. Borrow types without lifetime arguments have <em>unbound
lifetimes</em> and borrows with lifetime arguments have <em>bound
lifetimes</em>. These are treated as different entities by the
language’s type system, and there are subtle rules on how bound
lifetimes decay to unbound lifetimes and how unbound lifetimes become
bound. Lifetime annotations greatly improve the capability of safe
references, but extend an already complicated type system.</p>
<p>The above code declares functions
<code>f1</code>,
<code>f2</code> and
<code>f3</code> with
<em>lifetime-parameter-lists</em>. Borrows in function return types must
be constrained by the lifetimes of one or more function parameters.
Failure to match lifetime arguments between function parameters and
return types will cause a borrow checker failure.
<code>f1</code> fails to borrow check because the
returned parameter <code>y</code> does not
outlive the lifetime
<code><span>/</span>a</code> on the
return type.</p>
<p>Elision rules make lifetime annotations implicit in some cases. But
elision can fail, requiring users to intervene with annotations. In the
example above, the declaration of <code>f3</code>
fails because the elision rules cannot determine the lifetime argument
on the returned borrow.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/lifetimes/lifetimes2.cxx"><strong>lifetimes2.cxx</strong></a>
– <a href="https://godbolt.org/z/G6TWx83M9">(Compiler Explorer)</a></p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>#</span><span>feature on safety</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span>// New elision rules:</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span>// All parameters are constrained by a common lifetime.</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span>// The common lifetime constrains the return type.</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span>int</span><span>%</span> f4<span>(</span><span>int</span><span>%</span> x, <span>int</span><span>%</span> y, <span>bool</span> pred<span>)</span> safe <span>{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span>// Can return either x or y, because they outlive the common lifetime</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span>// and the common lifetime outlives the result object.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span>return</span> pred <span>?</span> x <span>:</span> y;</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>This proposal introduces a new <em>safe reference</em> marked by the
reference declarator
<code>T<span>%</span></code>. Safe
references do not take lifetime arguments and there is no notion of
<em>bound</em> or <em>unbound</em> lifetimes. The lifetime
parameterization is determined by the formation of the function type.
For a free function, all function parameters outlive a single invented
lifetime that extends through the duration of the function call. For a
non-static member function with the
<code><span>%</span></code>
<em>ref-qualifier</em>, the implicit object parameter outlives the
invented lifetime. In turn, this invented lifetime outlives the returned
safe reference.</p>
<h2 data-number="2.1" id="exclusivity"> Exclusivity<a href="#exclusivity"></a></h2>
<ul>
<li><code>T<span>%</span></code> is a
<em>mutable safe reference</em>. It cannot alias other references to
overlapping places.</li>
<li><code><span>const</span> T<span>%</span></code>
is a <em>shared safe reference</em>. It may alias shared safe references
to overlapping places, but may never overlap a mutable reference.</li>
</ul>
<p>If lifetime safety can be guaranteed without lifetime parameters, why
involve a new reference type
<code>T<span>%</span></code> at all?
Why not perform this form of borrow checking on the existing lvalue- and
rvalue-references
<code>T<span>&amp;</span></code> and
<code>T<span>&amp;&amp;</span></code>?
The answer is that safe references enforce <em>exclusivity</em> and
legacy references do not. There may be one mutable reference to a place,
or any number of shared (constant) references, but not both at the same
time. This is the universal invariant of borrow checking. Borrow
checking legacy reference types would break all existing code, because
that code was written without upholding the exclusivity invariant.</p>
<p>Exclusivity is a program-wide invariant. It doesn’t hinge on the
safeness of a function.</p>
<ul>
<li>A safe function is sound for all valid inputs.</li>
<li>An unsafe function has preconditions and may be unsound for some
valid inputs.</li>
</ul>
<p>“Valid” borrow and safe reference inputs don’t mutably alias. This is
something a function can just <em>assume</em>; it doesn’t need to check
and there’s no way to check. Borrow checking upholds exclusivity even
for unsafe functions (when compiled under the <code><span>[</span>safety<span>]</span></code>
feature). There are other assumptions C++ programmers already make about
the validity of inputs: for instance, references never hold null
addresses. Non-valid inputs are implicated in undefined behavior.</p>
<p>With a desire to simplify, you may suggest “rather than adding a new
safe reference type, just enforce exclusivity on lvalue- and
rvalue-references when compiled under the <code><span>[</span>safety<span>]</span></code>
feature.” But that makes the soundness problem worse. New code will
<em>assume</em> legacy references don’t mutably alias, but existing code
doesn’t uphold that invariant because it was written without considering
exclusivity.</p>
<p>If safe code calls legacy code that returns a struct with a pair of
references, do those references alias? Of course they may alias, but the
parsimonious treatment claims that mutable references don’t alias under
the <code><span>[</span>safety<span>]</span></code>
feature. We’ve already stumbled on a soundness bug.</p>
<p>Coming from the other direction, it may be necessary to form aliasing
references just to use the APIs for existing code. Consider a call to
<code>vec<span>.</span>push_back<span>(</span>vec<span>[</span><span>0</span><span>])</span></code>.
This is <em>impossible to express</em> without mutable aliasing: we form
a mutable lvalue reference to <code>vec</code>
and a const lvalue reference to one of
<code>vec</code>’s elements. If safe code can’t
even form aliased lvalue references, it won’t be able to use this API at
all.</p>
<p>Exclusivity is a program-wide invariant on safe references. We need
separate safe and unsafe reference types for both soundness and
expressiveness.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/lifetimes/vector1.cxx"><strong>vector1.cxx</strong></a>
– <a href="https://godbolt.org/z/KTEWEdEsM">(Compiler Explorer)</a></p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;vector&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span>void</span> f1<span>(</span>std<span>::</span>vector<span>&lt;</span><span>float</span><span>&gt;&amp;</span> vec, <span>float</span><span>&amp;</span> x<span>)</span> <span>{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span>// Do vec and x alias? If so, the push_back may invalidate x.</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  vec<span>.</span>push_back<span>(</span><span>6</span><span>)</span>;</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span>// Potential UB: x may have been invalidated by the push_back.</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  x <span>=</span> <span>6</span>;</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  std<span>::</span>vector<span>&lt;</span><span>float</span><span>&gt;</span> vec <span>{</span> <span>1.0</span><span>f</span> <span>}</span>;</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  <span>// Legacy references permit aliasing.</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  f1<span>(</span>vec, vec<span>[</span><span>0</span><span>])</span>;</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>This example demonstrates how perilous mutable aliasing in C++ is. In
<code>f1</code>, the compiler doesn’t know if
<code>vec</code> and
<code>x</code> alias. Pushing to the vector may
cause a buffer resize and copy its data into a new allocation,
invalidating existing references or pointers into the container. As C++
doesn’t enforce exclusivity on legacy references, the code in
<code>main</code> is legal, even though it leads
to a use-after-free defect.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/lifetimes/vector2.cxx"><strong>vector2.cxx</strong></a>
– <a href="https://godbolt.org/z/ETenGYK8n">(Compiler Explorer)</a></p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>#</span><span>feature on safety</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;cstdint&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> T<span>&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span>class</span> Vec <span>{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span>public</span><span>:</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span>void</span> push_back<span>(</span>T value<span>)</span> <span>%</span> safe;</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span>const</span> T<span>%</span> <span>operator</span><span>[](</span><span>size_t</span> idx<span>)</span> <span>const</span> <span>%</span> safe;</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        T<span>%</span> <span>operator</span><span>[](</span><span>size_t</span> idx<span>)</span>       <span>%</span> safe;</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span>}</span>;</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span>void</span> f2<span>(</span>Vec<span>&lt;</span><span>float</span><span>&gt;%</span> vec, <span>float</span><span>%</span> x<span>)</span> safe <span>{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span>// Does push_back potentially invalidate x? </span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span>// No! Exclusivity prevents vec and x from aliasing.</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  vec<span>.</span>push_back<span>(</span><span>7</span><span>)</span>;</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  <span>// Okay to store to x, because it doesn&#39;t point into vec&#39;s data.</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  <span>*</span>x <span>=</span> <span>7</span>;</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> safe <span>{</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>  Vec<span>&lt;</span><span>float</span><span>&gt;</span> vec <span>{</span> <span>}</span>;</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>  mut vec<span>.</span>push_back<span>(</span><span>1</span><span>)</span>;</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>  <span>// Ill-formed: mutable borrow of vec between its mutable borrow and its use</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>  f2<span>(</span>mut vec, mut vec<span>[</span><span>0</span><span>])</span>;</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>$ circle vector2.cxx</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>safety: during safety checking of int main() safe</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  borrow checking: vector2.cxx:27:19</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    f2(mut vec, mut vec[0]); </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>                    ^</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  mutable borrow of vec between its mutable borrow and its use</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  loan created at vector2.cxx:27:10</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    f2(mut vec, mut vec[0]); </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>           ^</span></code></pre></div>
<p>Rewrite the example using our simplified safe references. In
<code>main</code>, the user attempts to pass a
safe reference to <code>vec</code> and a safe
reference to one of its elements. This violates exclusivity, causing the
program to be ill-formed.</p>
<p>Mutable safe references are prohibited from aliasing. Exclusivity is
enforced by the same MIR analysis that polices Safe C++’s more general
borrow type
<code>T<span>^</span></code>. While
enforcing exclusivity involves more complicated tooling, it simplifies
reasoning about your functions. Since safe reference parameters don’t
alias, users don’t even have to think about aliasing bugs. You’re free
to store to references without worrying about iterator invalidation or
other side effects leading to use-after-free defects.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/lifetimes/exclusive1.cxx"><strong>exclusive1.cxx</strong></a>
– <a href="https://godbolt.org/z/xEh9arYK4">(Compiler Explorer)</a></p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>#</span><span>feature on safety</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span>void</span> f<span>(</span><span>int</span><span>%</span> x, <span>int</span><span>%</span> y<span>)</span> safe;</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span>void</span> g<span>(</span><span>int</span><span>&amp;</span> x, <span>int</span><span>&amp;</span> y<span>)</span> safe <span>{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  unsafe <span>{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span>// Enter an unsafe block to dereference legacy references.</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span>// The precondition to the unsafe-block is that the legacy</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span>// references *do not alias* and *do not dangle*.</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    f<span>(%*</span>x, <span>%*</span>y<span>)</span>;</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span>void</span> f<span>(</span><span>int</span><span>%</span> x, <span>int</span><span>%</span> y<span>)</span> safe <span>{</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  <span>// We can demote safe references to legacy references without </span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  <span>// an unsafe block. The are no preconditions to enforce.</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>  g<span>(&amp;*</span>x, <span>&amp;*</span>y<span>)</span>;</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>While safe references and legacy references are different types,
they’re inter-convertible. Converting a safe reference to legacy
reference can be done safely, because it doesn’t involve any
preconditions. Function <code>f</code> converts a
safe reference <code>x</code> to an lvalue
reference with a dereference and reference-of:
<code><span>&amp;*</span>x</code>.
Going the other way is unsafe: the precondition of the
<em>unsafe-block</em> is that the legacy references <em>do not
alias</em> and <em>do not dangle</em>:
<code><span>%*</span>x</code>.</p>
<h2 data-number="2.2" id="constraint-rules"> Constraint rules<a href="#constraint-rules"></a></h2>
<p>This proposal implements two sets of constraint rules. Free functions
constrain return references by the shortest of the argument lifetimes.
Non-static member functions constrain return references by the implicit
object lifetime.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/lifetimes/lifetimes3.cxx"><strong>lifetimes3.cxx</strong></a>
– <a href="https://godbolt.org/z/Yb6EoMMb6">(Compiler Explorer)</a></p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>#</span><span>feature on safety</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span>const</span> <span>int</span><span>%</span> f1<span>(</span><span>const</span> <span>int</span><span>%</span> x, <span>const</span> <span>int</span><span>%</span> y, <span>bool</span> pred<span>)</span> safe <span>{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span>// The return reference is constrained by all reference parameters: x and y.</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span>return</span> pred <span>?</span> x <span>:</span> y;</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span>struct</span> Obj <span>{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span>const</span> <span>int</span><span>%</span> f2<span>(</span><span>const</span> <span>int</span><span>%</span> arg<span>)</span> <span>const</span> <span>%</span> safe <span>{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span>// Non-static member functions are constrained by the implicit </span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span>// object lifetime.</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span>// It&#39;s OK to return `x`, because self outlives the return.</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>%</span>x;</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  <span>const</span> <span>int</span><span>%</span> f3<span>(</span><span>const</span> <span>int</span><span>%</span> arg<span>)</span> <span>const</span> <span>%</span> safe <span>{</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span>// Error: arg does not outlive the return reference.</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span>return</span> arg;</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>  <span>const</span> <span>int</span><span>%</span> f4<span>(</span><span>const</span> self<span>%</span>, <span>const</span> <span>int</span><span>%</span> arg<span>)</span> safe <span>{</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span>// OK - f4 is a free function with an explicit self parameter.</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span>return</span> arg;</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>  <span>int</span> x;</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span>}</span>;</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>  <span>int</span> x <span>=</span> <span>1</span>, y <span>=</span> <span>2</span>;</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>  f1<span>(</span>x, y, <span>true</span><span>)</span>; <span>// OK</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>  Obj obj <span>{</span> <span>}</span>;</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>  obj<span>.</span>f2<span>(</span>x<span>)</span>;  <span>// OK</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>  obj<span>.</span>f3<span>(</span>x<span>)</span>;  <span>// Error</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>  obj<span>.</span>f4<span>(</span>x<span>)</span>;  <span>// OK.</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>$ circle lifetimes3.cxx </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>safety: during safety checking of const int% Obj::f3(const int%) const % safe</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  error: lifetimes3.cxx:18:12</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>      return arg; </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>             ^</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  function const int% Obj::f3(const int%) const % safe returns object with lifetime SCC-ref-1, but SCC-ref-1 doesn&#39;t outlive SCC-ref-0</span></code></pre></div>
<p>The definitions of free function
<code>f1</code> and non-static member function
<code>f2</code> compile, because they return
function parameters that constrain the return type: the returned
parameter <em>outlives</em> the returned reference. The non-static
member function <code>f3</code> fails to compile,
because the returned parameter <em>does not outlive</em> the the return
type. In a non-static member function, only the implicit object
parameter outlives the return type.
<code>f4</code> returns a function parameter but
compiles; it uses the explicit object syntax to gain the ergonomics of a
non-static member function, but retains the constraint rules of a free
function.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/lifetimes/vector3.cxx"><strong>vector3.cxx</strong></a>
– <a href="https://godbolt.org/z/KEr1chMac">(Compiler Explorer)</a></p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>#</span><span>feature on safety</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> Key, <span>typename</span> Value<span>&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span>class</span> Map <span>{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span>public</span><span>:</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span>// Non-static member functions do not constrain the result object to</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span>// the function parameters.</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span>auto</span> get1<span>(</span><span>const</span> Key<span>%</span> key<span>)</span> <span>%</span> safe <span>-&gt;</span> Value<span>%</span>;</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  <span>// Free function do constrain the result object to the function parameters.</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  <span>auto</span> get2<span>(</span>self<span>%</span>, <span>const</span> Key<span>%</span> key<span>)</span> safe <span>-&gt;</span> Value<span>%</span>;</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span>}</span>;</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> safe <span>{</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  Map<span>&lt;</span><span>float</span>, <span>long</span><span>&gt;</span> map <span>{</span> <span>}</span>;</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>  <span>// Bind the key reference to a materialized temporary.</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>  <span>// The temporary expires at the end of this statement.</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>  <span>long</span><span>%</span> value1 <span>=</span> mut map<span>.</span>get1<span>(</span><span>3.14</span><span>f</span><span>)</span>;</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>  <span>// We can still access value, because it&#39;s not constrained on the </span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>  <span>// key argument.</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>  <span>*</span>value1 <span>=</span> <span>1001</span>;</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>  <span>// The call to get2 constrains the returned reference to the lifetime</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>  <span>// of the key temporary.</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>  <span>long</span><span>%</span> value2 <span>=</span> mut map<span>.</span>get2<span>(</span><span>1.6186</span><span>f</span><span>)</span>;</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>  <span>// This is ill-formed, because get2&#39;s key argument is out of scope.</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>  <span>*</span>value2 <span>=</span> <span>1002</span>;</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>$ circle vector3.cxx </span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>safety: during safety checking of int main() safe</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  borrow checking: vector3.cxx:30:4</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    *value2 = 1002; </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>     ^</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  use of value2 depends on expired loan</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  drop of temporary object float between its shared borrow and its use</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  loan created at vector3.cxx:27:31</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    long% value2 = mut map.get2(1.6186f); </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>                                ^</span></code></pre></div>
<p>The constraint rules for non-static member functions reflect the idea
that resources are owned by class objects. Consider a map data structure
that associates values with keys. The map may be specialized a key type
that’s expensive to copy, such as a string or another map. We don’t want
to compel the user to pass the key by value, because that may require
copying this expensive type. Naturally, we pass by const reference.</p>
<p>However, the accessor only needs the key inside the body of the
function. Once it locates the value, it should return a reference to
that, unconstrained by the lifetime of the key argument. Consider
passing a materialized temporary for a key: it goes out of scope at the
end of the full expression. <code>get1</code>
uses the non-static member function constraint rules. The caller can use
the returned reference even after the key temporary goes out of scope.
<code>get2</code> uses the free function
constraint rules, which constrains the return type to all of its
function parameters. This leaves the program ill-formed when the
returned reference is used after the expiration of the key
temporary.</p>
<p>In this model, lifetime constraints are not generally programmable,
but that design still provides a degree of freedom in the form of
non-static member functions.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/lifetimes/vector4.cxx"><strong>vector4.cxx</strong></a>
– <a href="https://godbolt.org/z/hdMr5G3j1">(Compiler Explorer)</a></p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>#</span><span>feature on safety</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> Key, <span>typename</span> Value<span>&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span>class</span> Map <span>{</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span>public</span><span>:</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span>// Lifetime elision rules constrain the return by self.</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span>auto</span> get1<span>(</span>self<span>^</span>, <span>const</span> Key<span>^</span> key<span>)</span> safe <span>-&gt;</span> Value<span>^</span>;</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span>// Use explicit parameterizations for alternate constraints.</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  <span>auto</span> get2<span>/(</span>a<span>)(</span>self<span>^/</span>a, <span>const</span> Key<span>^/</span>a key<span>)</span> safe <span>-&gt;</span> Value<span>^/</span>a;</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span>}</span>;</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> safe <span>{</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>  Map<span>&lt;</span><span>float</span>, <span>long</span><span>&gt;</span> map <span>{</span> <span>}</span>;</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  <span>// Bind the key reference to a materialized temporary.</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>  <span>// The temporary expires at the end of this statement.</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>  <span>long</span><span>^</span> value1 <span>=</span> mut map<span>.</span>get1<span>(</span><span>3.14</span><span>f</span><span>)</span>;</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  <span>// We can still access value, because it&#39;s not constrained on the </span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>  <span>// key argument.</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>  <span>*</span>value1 <span>=</span> <span>1001</span>;</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>  <span>// The call to get2 constrains the returned reference to the lifetime</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>  <span>// of the key temporary.</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>  <span>long</span><span>^</span> value2 <span>=</span> mut map<span>.</span>get2<span>(</span><span>1.6186</span><span>f</span><span>)</span>;</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>  <span>// This is ill-formed, because get2&#39;s key argument is out of scope.</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>  <span>*</span>value2 <span>=</span> <span>1002</span>;</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>$ circle vector4.cxx </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>safety: during safety checking of int main() safe</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  borrow checking: vector4.cxx:29:4</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    *value2 = 1002; </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>     ^</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  use of value2 depends on expired loan</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  drop of temporary object float between its shared borrow and its use</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  loan created at vector4.cxx:26:31</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    long^ value2 = mut map.get2(1.6186f); </span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>                                ^</span></code></pre></div>
<p>The general borrow type
<code>T<span>^</span></code> has
programmable constraints. The map above declares accessor functions.
<code>get1</code> relies on lifetime elision to
constrain the result object by the
<code>self</code> parameter. This is equivalent
to the non-static member function constraint rule. We can call
<code>get1</code> and use the returned reference
even after the key temporary goes out of scope.</p>
<p><code>get2</code> includes lifetime
annotations to constrain the returned reference by both the
<code>self</code> and
<code>key</code> parameters. This is like the
free function constraint rules. The program fails borrow checking when
the returned reference <code>value2</code> is
used after the expiration of its key temporary.</p>

<p>References can be taxonimized into two classes:<span data-cites="second-class">[<a href="https://borretti.me/article/second-class-references" role="doc-biblioref">second-class</a>]</span></p>
<ul>
<li>First-class references can pass data into functions, be returned
from functions, made into objects and be stored in structures.</li>
<li>Second-class references can pass data into functions but cannot be
returned from functions, made into objects or stored in structures.</li>
</ul>
<p><em>Parameter-passing directives</em> like
<code>in</code> and
<code>inout</code> are equivalent to second-class
references. The <em>mutable value semantics</em><span data-cites="mutable-value-semantics">[<a href="https://www.jot.fm/issues/issue_2022_02/article2.pdf" role="doc-biblioref">mutable-value-semantics</a>]</span> model uses
parameter-passing directives to pass objects to functions by reference
without involving the complexity of a borrow checker.</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>void</span> func<span>(</span>Vec<span>&lt;</span><span>float</span><span>&gt;%</span> vec, <span>float</span><span>%</span> x<span>)</span> safe;</span></code></pre></div>
<p>In this fragment, the reference parameters
<code>vec</code> and
<code>x</code> serve as <em>second-class
references</em>. The compiler can achieve memory safety without
involving the complexity of borrow checking. Both references point at
data that outlives the duration of the call to
<code>func</code>. Exclusivity is enforced at the
point of the call, which prevents
<code>vec</code> and
<code>x</code> from aliasing. Since
<code>vec</code> and
<code>x</code> don’t alias, resizing or clearing
<code>vec</code> cannot invalidate the
<code>x</code> reference.</p>
<p>The safe references presented here are more powerful than
second-class references. While they don’t support all the capabilities
of borrows, they can be returned from functions and made into objects.
The compiler must implement borrow checking to support this additional
capability.</p>
<p>Borrow checking operates on a function lowering called mid-level IR
(MIR). A fresh region variable is provisioned for each local variable
with a safe reference type. Dataflow analysis populates each region
variable with the liveness of its reference. Assignments and function
calls involving references generate <em>lifetime constraints</em>. The
compiler <em>solves the constraint equation</em> to find the liveness of
each <em>loan</em>. All instructions in the MIR are scanned for
<em>conflicting actions</em> with any of the loans in scope at that
point. Examples of conflicting actions are stores to places with live
shared borrows or loads from places with live mutable borrows.
Conflicting actions raise borrow checker errors.</p>
<p>The Hylo<span data-cites="hylo">[<a href="https://2023.splashcon.org/details/iwaco-2023-papers/5/Borrow-checking-Hylo" role="doc-biblioref">hylo</a>]</span> model is largely equivalent to
this model and it requires borrow checking technology.
<code>let</code> and
<code>inout</code> parameter directives use
mutable value semantics to ensure memory safety for objects passed by
reference into functions. But Hylo also supports returning references in
the form of subscripts:</p>
<p><a href="https://github.com/hylo-lang/hylo/blob/main/StandardLibrary/Sources/Array.hylo"><strong>Array.hylo</strong></a></p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>public</span> conformance Array<span>:</span> Collection <span>{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span>...</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span>public</span> subscript<span>(</span>_ position<span>:</span> Int<span>):</span> Element <span>{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span>let</span> {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span>precondition</span><span>((</span>position <span>&gt;=</span> <span>0</span><span>)</span> <span>&amp;&amp;</span> <span>(</span>position <span>&lt;</span> count<span>()),</span> <span>&#34;position is out of bounds&#34;</span><span>)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      yield pointer_to_element<span>(</span>at<span>:</span> position<span>).</span>unsafe<span>[]</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span>inout</span> <span>{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>      precondition<span>((</span>position <span>&gt;=</span> <span>0</span><span>)</span> <span>&amp;&amp;</span> <span>(</span>position <span>&lt;</span> count<span>()),</span> <span>&#34;position is out of bounds&#34;</span><span>)</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      yield <span>&amp;(</span>pointer_to_element<span>(</span>at<span>:</span> position<span>).</span>unsafe<span>[])</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Subscripts are reference-returning <em>coroutines</em>. Coroutines
with a single yield point are split into two normal functions: a ramp
function that starts at the top and returns the expression of the yield
statement, and a continuation function which resumes after the yield and
runs to the end. Local state that’s live over the yield point must live
in a <em>coroutine frame</em> so that it’s available to the continuation
function. These <code>Array</code> subscripts
don’t have instructions after the yield, so the continuation function is
empty and hopefully optimized away.</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> T<span>&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>struct</span> Vec <span>{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span>const</span> T<span>%</span> <span>operator</span><span>[](</span><span>size_t</span> idx<span>)</span> <span>const</span> <span>%</span> safe;</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        T<span>%</span> <span>operator</span><span>[](</span><span>size_t</span> idx<span>)</span>       <span>%</span> safe;</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span>}</span>;</span></code></pre></div>
<p>The Hylo <code>Array</code> subscripts are
lowered to reference-returning ramp functions exactly like their C++
<code>Vec</code> counterparts. For both
languages, the borrow checker relates lifetimes through the function
arguments and out the result object. This isn’t the simple safety of
second-class references/mutable value semantics. This is full-fat live
analysis.</p>
<p>Safe references without lifetime annotations shields users from
dealing with a new degree of freedom, but it doesn’t simplify the static
analysis that upholds lifetime safety. To prevent use-after-free
defects, compilers must still lower functions to mid-level IR, compute
non-lexical lifetimes<span data-cites="nll">[<a href="https://rust-lang.github.io/rfcs/2094-nll.html" role="doc-biblioref">nll</a>]</span> and solve the constraint equation.
When it comes to returning references, in for a penny, in for a
pound.</p>
<p>Since Circle has already made the investment in borrow checking,
adding simplified safe references was an easy extension. If the
community is able to fill in our gaps in knowledge around this sort of
reference, the compiler could accommodate those advances as well.</p>

<p>As detailed in the Safe C++<span data-cites="safecpp">[<a href="https://safecpp.org/draft.html" role="doc-biblioref">safecpp</a>]</span> proposal, there are four
categories of memory safety:</p>
<ol type="1">
<li><strong>Lifetime safety</strong> - This proposal advances a simpler
form of safe references that provides safety against use-after-free
defects. The feature is complementary with borrow types
<code>T<span>^</span></code> that take
lifetime arguments. Both types can be used in the same translation unit,
and even the same function, without conflict.</li>
<li><strong>Type safety</strong> - Relocation must replace move
semantics to eliminate unsafe null pointer exposure. Choice types and
pattern matching must be included for safe modeling of optional
types.</li>
<li><strong>Thread safety</strong> - The
<code>send</code> and
<code>sync</code> interfaces account for which
types can be copied and shared between threads.</li>
<li><strong>Runtime checks</strong> - The compiler automatically emits
runtime bounds checks on array and slice subscripts. It emits checks for
integer divide-by-zero and INT_MIN / -1, which are undefined behavior.
Conforming safe library functions must panic to prevent out-of-bounds
access to heap allocations.</li>
</ol>
<p>Most critically, the <em>safe-specifier</em> is added to a function’s
type. Inside a safe function, only safe operations may be used, unless
escaped by an <em>unsafe-block</em>.</p>
<p>C++ must adopt a new standard library with a safe API, which observes
all four categories of safety. We need new tooling. <em>But it’s not the
case that we have to rewrite all C++ code</em>. Time has already shaken
out most of the vulnerabilities in old code. As demonstrated by the
recent Android study on memory safety<span data-cites="android">[<a href="https://security.googleblog.com/2024/09/eliminating-memory-safety-vulnerabilities-Android.html?m=1" role="doc-biblioref">android</a>]</span>, the benefits of rewriting are
often not worth the costs. What we have to prioritize is the transition
to safe coding practices<span data-cites="safe-coding">[<a href="https://blog.google/technology/safety-security/tackling-cybersecurity-vulnerabilities-through-secure-by-design/" role="doc-biblioref">safe-coding</a>]</span> for new code.</p>

<p>The presented design is as far as I could go to address the goal of
“memory safety without lifetime parameters.” But safe references aren’t
yet powerful enough to replace all the unsafe mechanisms necessary for
productivity in C++. We need support for safe versions of idioms that
are central to the C++ experience, such as:</p>
<ul>
<li>Iterators.</li>
<li>Views like <code>string_view</code> and
<code>span</code>.</li>
<li>RAII types with reference semantics.</li>
</ul>
<p>Let’s consider RAII types with reference semantics. An example is
<code>std<span>::</span>lock_guard</code>,
which keeps a reference to a mutex. When the
<code>lock_guard</code> goes out of scope its
destructor calls <code>unlock</code> on the
mutex. This is a challenge for safe references, because safe reference
data members aren’t supported. Normally those would require lifetime
parameters on the containing class.</p>
<p>Robust support for user-defined types with reference data members
isn’t just a convenience in a safe C++ system. It’s a necessary part of
<em>interior mutability</em>, the core design pattern for implementing
shared ownership of mutable state (think safe versions of
<code>shared_ptr</code>).</p>
<p>What are some options for RAII reference semantics?</p>
<ul>
<li><strong>Coroutines</strong>. This is the Hylo strategy. The ramp
function locks a mutex and returns a safe reference to the data within.
The continuation unlocks the mutex. The reference to the mutex is kept
in the coroutine frame. But this still reduces to supporting structs
with reference data members. In this case it’s not a user-defined type,
but a compiler-defined coroutine frame. The coroutine solution is an
unidiomatic fit for C++ for several reasons: static allocation of the
coroutine frame requires exposing the definition of the coroutine to the
caller, which breaks C++’s approach to modularity; the continuation is
called immediately after the last use of the yielded reference, which
runs counter to expectation that cleanup runs at the end of the
enclosing scope; and since the continuation is called implicitly,
there’s nothing textual on the caller side to indicate an unlock.</li>
<li><strong>Defer expressions</strong>. Some garbage-collected languages
include <em>defer</em> expressions, which run after some condition is
met. We could defer a call to the mutex unlock until the end of the
enclosing lexical scope. This has the benefit of being explicit to the
caller and not requiring computation of a coroutine frame. But it
introduces a fundamental new control flow mechanism to the language with
applicability that almost perfectly overlaps with destructors.</li>
<li><strong>Destructors</strong>. This is the idiomatic C++ choice. A
local object is destroyed when it goes out of scope (or is dropped, with
the Safe C++ <code>drop</code> keyword). The
destructor calls the mutex unlock.</li>
</ul>
<p>It makes sense to strengthen safe references to support current RAII
practice. How do we support safe references as data members? A
reasonable starting point is to declare a class as having <em>safe
reference semantics</em>. <code><span>class</span> name <span>%</span>;</code>
is a possible syntax. Inside these classes, you can declare data members
and base classes with safe reference semantics: that includes both safe
references and other classes with safe reference semantics.</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>class</span> lock_guard <span>%</span> <span>{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span>// Permitted because the containing class has safe reference semantics.</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  std2<span>::</span>mutex<span>%</span> mutex;</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span>public</span><span>:</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span>~</span>lock_guard<span>()</span> safe <span>{</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    mutex<span>.</span>unlock<span>()</span>;</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span>}</span>;</span></code></pre></div>
<p>The constraint rules can apply to the new
<code>lock_guard</code> class exactly as it
applies to safe references. Returning a
<code>lock_guard</code> constrains its lifetime
by the lifetimes of the function arguments. Transitively, the lifetimes
of the data members are constrained by the lifetime of the containing
class.</p>
<p>Unfortunately, we run into problems immediately upon declaring member
functions that take safe reference objects or safe reference parameter
types.</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>class</span> string_view <span>%</span>;</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> T<span>&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span>class</span> info <span>%</span> <span>{</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span>// Has reference semantics, but that&#39;s okay because the containing class does.</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  string_view sv;</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span>public</span><span>:</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  <span>void</span> swap<span>(</span>info<span>%</span> rhs<span>)</span> <span>%</span> safe;</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span>}</span>;</span></code></pre></div>
<p>Consider an <code>info</code> class that has
<em>safe reference semantics</em> and keeps a
<code>string_view</code> as a data member. The
<code>string_view</code> also has reference
semantics, so it constrains the underlying string that owns the data.
Declare a non-static member function that binds the implicit object with
the <code><span>%</span></code>
<em>ref-qualifier</em> and also takes an
<code>info</code> by safe reference. This is
uncharted water. The implicit object type
<code>info</code> has reference semantics, yet
we’re taking a reference to that with
<code>swap</code> call. We’re also taking a
reference to <code>info</code> in the function
parameter. How do we deal with references to references? The existing
constraint rules only invent a single lifetime: if we used those, we’d
be clobbering the lifetime of the inner
<code>string_view</code> member.</p>
<p>There’s a big weakness with the safe reference type
<code>T<span>%</span></code>: it’s
under-specified when dealing with references to references. We need a
fix that respects the lifetimes on the class’s data members.</p>
<p><a href="https://github.com/cppalliance/safe-cpp/blob/master/lifetimes/lifetimes5.cxx"><strong>lifetimes5.cxx</strong></a>
– <a href="https://godbolt.org/z/Gj7zoq343">(Compiler Explorer)</a></p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>#</span><span>feature on safety</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span>class</span> string_view<span>/(</span>a<span>)</span> <span>{</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span>// Keep a borrow to a slice over the string data.</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span>const</span> <span>[</span><span>char</span>; dyn<span>]^/</span>a p_;</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span>public</span><span>:</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span>}</span>;</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span>class</span> info<span>/(</span>a<span>)</span> <span>{</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  <span>// The handle has lifetime /a.</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  string_view<span>/</span>a sv;</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span>public</span><span>:</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>  <span>void</span> swap<span>(</span>self<span>^</span>, info<span>^</span> rhs<span>)</span> safe <span>{</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    string_view temp <span>=</span> self<span>-&gt;</span>sv;</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    self<span>-&gt;</span>sv <span>=</span> rhs<span>-&gt;</span>sv;</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    rhs<span>-&gt;</span>sv <span>=</span> temp;</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span>}</span>;</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a><span>void</span> func<span>/(</span>a<span>)(</span>info<span>/</span>a<span>^</span> lhs, info<span>/</span>a<span>^</span> rhs<span>)</span> safe <span>{</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>  lhs<span>.</span>swap<span>(</span>rhs<span>)</span>;</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a><span>void</span> func2<span>(</span>info<span>^</span> lhs, info<span>^</span> rhs<span>)</span> safe <span>{</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>  lhs<span>.</span>swap<span>(</span>rhs<span>)</span>;</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Rust and Safe C++ have a way to keep the lifetime of the
<code>string_view</code> member distinct from the
lifetimes of the <code>self</code> and
<code>rhs</code> references: lifetime parameters.
<code>func</code> assumes that the
<code>string_view</code>s of its parameters come
from sources with overlapping lifetimes, so it declares a lifetime
parameter <code><span>/</span>a</code>
that’s common to both parameters. The lifetimes on the two references
are created implicitly by elision, as they don’t have to be related in
the <code>swap</code> call.
<code>func</code> compiles and doesn’t clobber
the lifetimes of the contained
<code>string_view</code>s.</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>safety: during safety checking of void func2(info^, info^) safe</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  error: lifetimes5.cxx:26:12</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    lhs.swap(rhs); </span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>             ^</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  function void func2(info^, info^) safe returns object with lifetime #0, but #0 doesn&#39;t outlive #2</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  error: lifetimes5.cxx:26:3</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    lhs.swap(rhs); </span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    ^</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  function void func2(info^, info^) safe returns object with lifetime #2, but #2 doesn&#39;t outlive #0</span></code></pre></div>
<p>Compiling <code>func2</code> raises borrow
checker errors. Instead of providing explicit lifetime annotations that
relate the lifetimes of the <code>lhs</code> and
<code>rhs</code>
<code>info</code> types, lifetime elision create
four distinct lifetimes:
<code><span>#0</span></code> for the
<code>lhs</code>
<code>info</code>,
<code><span>#1</span></code> for the
<code>lhs</code>
<code>info<span>^</span></code>,
<code><span>#2</span></code> for the
<code>rhs</code>
<code>info</code> and
<code><span>#3</span></code> for the
<code>rhs</code>
<code>info<span>^</span></code>. The
<code>lhs<span>.</span>swap<span>(</span>rhs<span>)</span></code>
call relates the lifetimes of the operands through the common lifetime
<code><span>/</span>a</code>. But
these lifetimes aren’t related! The compiler has no information whether
<code><span>#0</span></code> outlives
<code><span>#2</span></code> or vice
versa. Since the lifetimes aren’t related in
<code>func2</code>’s declaration, the program is
rejected as ill-formed.</p>
<p>This contrasts with the safe reference constraint rules, which would
assign the same lifetime to all four lifetime binders and clobber the
<code>string_view</code> lifetimes, causing a
borrow checker failure further from the source and leaving the developer
without the possibility of a fix.</p>

<p>If there’s a community-wide research effort among compiler experts to
evolve safe references it may be possible to get them into a state to
support the abstractions most important for C++. But soundness reasoning
is very subtle work. As you increase the indirection capabilty of safe
references, you invite networks of dependencies of implied constraints
and variances. This increases complexity for the compiler implementation
and puts a mental burden on the authors of unsafe code to properly
uphold the invariants assumed by safe references. A research project
must produce <em>soundness doctrine</em>, which is essential guidance on
how to interface safe and unsafe systems while upholding the soundness
invariants of the program.</p>
<p>But we don’t have to do the research. There’s already a solution
that’s been deployed in a successful production toolchain for a decade:
<em>lifetime parameters</em> as used in Rust. The soundness doctrine for
writing unsafe code that upholds the invariants established by lifetime
parameters is described in the Rustnomicon<span data-cites="rustnomicon">[<a href="https://doc.rust-lang.org/nomicon/intro.html" role="doc-biblioref">rustnomicon</a>]</span>.</p>
<p>This is the only known viable solution for first-class safe
references without garbage collection. It’s a critical lifeline that
addresses an existential problem facing C++. By adopting lifetime
parameters, C++ can achieve safety parity with the security community’s
favored languages.</p>
<p>Consider common objections to Rust’s lifetime-annotation flavor of
borrow checking:</p>
<ol type="1">
<li><strong>You need heavy annotations.</strong> This concern is
misplaced. Are you intrigued by mutable value semantics,
parameter-passing directives or second-class references? Borrow checking
gives you those, without ever having to write lifetime arguments. If
your function only uses references as parameters, elision implicitly
annotates them in a way that can’t fail. You only have to involve
lifetime arguments when going beyond the capabilities of second-class
references or mutable value semantics. More advanced usages such as the
implementation of iterators, views and RAII wrappers with reference
semantics are where annotations most often appear, because those designs
deal with multiple levels of references.</li>
<li><strong>Borrow checking doesn’t permit patterns such as
self-references.</strong> It’s true that checked references are less
flexible than unsafe references or pointers, but this objection is at
odds with the claim that lifetime parameters are too burdensome.
Lifetime parameters <em>increase</em> the expressiveness of safe
references. Additionally, they can reference things important to C++
users that a garbage collection can’t, such as variables on the stack.
Do we want more expressive references at the cost of annotations, or do
we want to get rid of lifetime parameters to make a simpler language?
Those are opposing goals.</li>
<li><strong>Borrow checking with lifetimes is too different from normal
C++.</strong> Borrow checking is the safety technology most similar to
current C++ practice. This model replaces unchecked references with
checked references. Other safety models get rid of reference types
entirely or replace them with garbage collection which is incompatible
with C++’s manual memory management and RAII. The design philosophy of
borrow checking is to take normal references but constrain them to uses
that can be checked for soundness by the compiler.</li>
</ol>
<p>It’s not surprising that the C++ community hasn’t discovered a better
way to approach safe references than the lifetime parameter model. After
all, there isn’t a well-funded effort to advance C++ language-level
lifetime safety. But there is in the Rust community. Rust has made
valuable improvements to its lifetime safety design. Lots of effort goes
into making borrow checking more permissive: The integration of
mid-level IR and non-lexical lifetimes in 2016 revitalized the
toolchain. Polonius<span data-cites="polonius">[<a href="https://smallcultfollowing.com/babysteps/blog/2023/09/22/polonius-part-1/" role="doc-biblioref">polonius</a>]</span> approaches dataflow analysis
from the opposite direction, hoping to shake loose more improvements.
Ideas like view types<span data-cites="view-types">[<a href="https://smallcultfollowing.com/babysteps/blog/2021/11/05/view-types/" role="doc-biblioref">view-types</a>]</span> and the sentinel
pattern<span data-cites="sentinel-pattern">[<a href="https://smallcultfollowing.com/babysteps/blog/2018/11/10/after-nll-moving-from-borrowed-data-and-the-sentinel-pattern/" role="doc-biblioref">sentinel-pattern</a>]</span> are being
investigated. But all this activity has not discovered a mechanism
that’s superior to lifetime parameters for specifying constraints. If
something had been discovered, it would be integrated into the Rust
language and I’d be proposing to adopt <em>that</em> into C++. For now,
lifetime parameters are the best solution that the world has to
offer.</p>
<p>The US government and major players in tech including Google<span data-cites="secure-by-design">[<a href="https://research.google/pubs/secure-by-design-googles-perspective-on-memory-safety/" role="doc-biblioref">secure-by-design</a>]</span> and Microsoft<span data-cites="ms-vulnerabilities">[<a href="https://msrc.microsoft.com/blog/2019/07/we-need-a-safer-systems-programming-language\" role="doc-biblioref">ms-vulnerabilities</a>]</span> are telling industry
to transition to memory-safe languages because C++ is too unsafe to use.
There’s already a proven safety technology compatible with C++’s goals
of performance and manual memory management. If the C++ community
rejects this robust safety solution on the grounds of slightly
inconvenient lifetime annotations, and allows C++ to limp forward as a
memory-unsafe language, can it still claim to care about software
quality? If the lifetime model is good enough for a Rust, a safe
language that is enjoying snowballing investment in industry, why is it
it not good enough for C++?</p>
<p>Finally, adoption of this feature brings a major benefit even if you
personally want to get off C++: It’s critical for <strong>improving
C++/Rust interop</strong>. Your C++ project is generating revenue and
there’s scant economic incentive to rewrite it. But there is an
incentive to pivot to a memory-safe language for new development,
because new code is how vulnerabilities get introduced.<span data-cites="android">[<a href="https://security.googleblog.com/2024/09/eliminating-memory-safety-vulnerabilities-Android.html?m=1" role="doc-biblioref">android</a>]</span> Bringing C++ closer to Rust
with the inclusion of <em>safe-specifier</em>, relocation, choice types,
and, importantly, lifetime parameters, reduces the friction of
interfacing the two languages. The easier it is to interoperate with
Rust, the more options and freedom companies have to fulfill with their
security mandate.<span data-cites="rust-interop">[<a href="https://security.googleblog.com/2024/02/improving-interoperability-between-rust-and-c.html" role="doc-biblioref">rust-interop</a>]</span></p>

<div id="refs" data-entry-spacing="1" role="doc-bibliography">



<div id="ref-mutable-value-semantics" role="doc-biblioentry"><p>
[mutable-value-semantics] Implementation Strategies for Mutable Value
Semantics. </p><a href="https://www.jot.fm/issues/issue_2022_02/article2.pdf"><p>https://www.jot.fm/issues/issue_2022_02/article2.pdf</p></a>
</div>
<div id="ref-nll" role="doc-biblioentry"><p>
[nll] The Rust RFC Book - Non-lexical lifetimes. </p><a href="https://rust-lang.github.io/rfcs/2094-nll.html"><p>https://rust-lang.github.io/rfcs/2094-nll.html</p></a>
</div>


<div id="ref-rustnomicon" role="doc-biblioentry"><p>
[rustnomicon] Rustnomicon – The Dark Arts of Unsafe Rust. </p><a href="https://doc.rust-lang.org/nomicon/intro.html"><p>https://doc.rust-lang.org/nomicon/intro.html</p></a>
</div>

<div id="ref-safecpp" role="doc-biblioentry"><p>
[safecpp] P3390 – Safe C++. </p><a href="https://safecpp.org/draft.html"><p>https://safecpp.org/draft.html</p></a>
</div>




</div>
</div>
</div></div>
  </body>
</html>
