<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mliezun.github.io/2023/12/25/favourite-advent-of-code-2023.html">Original</a>
    <h1>Day 20: My favourite problem from Advent of Code 2023</h1>
    
    <div id="readability-page-1" class="page"><article><h2>Day 20
</h2><div><p>Im gonna briefly describe the problem here, but if you want to see the real thing go check it out <a target="_blank" href="https://adventofcode.com/2023/day/20">https://adventofcode.com/2023/day/20</a>.
</p><p>I like it because it involves some simple electronic devices that are wired together and send pulses/signals to each other. In this problem you have to make sure to correctly propagate the signals and simulate the behaviour of the devices.
</p><p>There are two devices that have a very distinct behaviour:
</p><li><strong>Flip flops</strong>: similar to a <a target="_blank" href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)#T_flip-flop">T flip-flop</a> electronic device.
</li><li><strong>Conjunctions</strong>: similar to a <a target="_blank" href="https://en.wikipedia.org/wiki/NAND_gate">NAND gate</a> with memory on its inputs.
<p>In this problem, <strong>Flip flops</strong> are initially off and whenever they reiceve a <em>low</em> pulse they toggle between on/off. Each time it toggles state it sends a pulse as an output. When turned off sends a <em>low</em> pulse, when turned on sends a <em>high</em> pulse.
</p><p><strong>Conjunction</strong> modules remember the most recent pulse on each input. By default it remembers a low pulse for all inputs. When a pulse is received it updates the memory for that input. Then, if it remembers <em>high</em> pulses for all inputs, it sends a <em>low</em> pulse; otherwise, it sends a <em>high</em> pulse.
</p><p>There is also some &#34;dummy&#34; modules:
</p></li><li><strong>Broadcaster</strong>: has 1 input and N outputs. It replicates the input in all it&#39;s outputs.
</li><li><strong>Button</strong>: when pressed sends a <em>low</em> pulse. The button is always connected as the broadcaster input. This is similar to a <a target="_blank" href="https://instrumentationtools.com/basics-of-switches/">normally closed switch</a>.
</li><li><strong>Test module</strong>: module that receive and process inputs but has no output.
<p>One important thing to have in mind is that modules only send output pulses when they receive a pulse as input.
</p></li></div><h3>Problem input
</h3><div><p>The example input looks something like this:
</p><pre>broadcaster -&gt; a, b, c
%a -&gt; b
%b -&gt; c
%c -&gt; inv
&amp;inv -&gt; a
</pre>
<p>There will always be just one Broadcaster module called &#34;broadcaster&#34; that has the Button connected as input. In this case it has module&#39;s &#34;a&#34;, &#34;b&#34; and &#34;c&#34; connected to it&#39;s output.
</p><p>The arrow <span>-&gt;</span> indicates what modules are connected to the output of the module to the left.
</p><p>Lines that start with <span>%</span> means the module is a <strong>Flip flop</strong>, for example: <span>%a -&gt; b</span> indicates that there&#39;s a flip flop called &#34;a&#34; whose output is connected to module&#39;s &#34;b&#34; input.
</p><p>Lines that start with <span>&amp;</span> means the module is a <strong>Conjunction</strong>, for example: <span>&amp;inv -&gt; a</span> indicates that there&#39;s a conjunction called &#34;inv&#34; whose output is connected to module&#39;s &#34;a&#34; input.
</p><p>Let&#39;s analyze how this circuit behaves once the button is pushed:
</p><pre>button -0-&gt; broadcaster
broadcaster -0-&gt; a
broadcaster -0-&gt; b
broadcaster -0-&gt; c
a -1-&gt; b
b -1-&gt; c
c -1-&gt; inv
inv -0-&gt; a
a -0-&gt; b
b -0-&gt; c
c -0-&gt; inv
inv -1-&gt; a
</pre><p>
In this example 8 <em>low</em> (<span>0</span>) pulses and 4 <em>high</em> (<span>1</span>) pulses are sent.
</p></div><h3>Part 1
</h3><div><p>To solve the first part we need to calculate the multiplication between <em>high</em> and <em>low</em> pulses sent between devices.
</p><p>In the previous example that would be 8*4=32.
</p><p>But this time we don&#39;t push the button only once, but we push it a <span>1000</span> times. Each time we push the button we wait until all signals propagate and the circuit settles into a state before pushing the button again.
</p></div><h3>Solution
</h3><div><p>First I started by modelling the devices as objects. Starting with a single base class that has most of the common behaviour.
</p><pre>from abc import ABC
measure_pulses = {0: 0, 1: 0}
class Module(ABC):
    def __init__(self, name: str):
        self.name = name
        self.outputs = []

    def receive_pulse(self, mod: &#34;Module&#34;, pulse: int) -&gt; list[tuple[&#34;Module&#34;, int]]:
        measure_pulses[pulse] += 1
        print(f&#34;{mod and mod.name} -{pulse}-&gt; {self.name}&#34;)
        return self.process_pulse(mod, pulse)

    def connect_output(self, mod: &#34;Module&#34;):
        self.outputs.append(mod)

    def propagate_pulse(self, pulse: int):
        mods = []
        for m in self.outputs:
            mods.append((m, pulse))
        return mods

    def process_pulse(self, mod: &#34;Module&#34;, pulse: int):
        raise NotImplementedError()

    def __str__(self) -&gt; str:
        return f&#34;{self.__class__.__name__}(name={self.name})&#34;

    def __repr__(self) -&gt; str:
        return str(self)
</pre>
<p>What we see here is that we expect all modules to have a <span>name</span> and <span>outputs</span>. See <span>__init__()</span>, <span>__str__()</span>, <span>__repr__()</span> and <span>connect_output()</span>.
</p><p>Each module can receive a pulse <span>0</span> or  <span>1</span> from another module. See <span>receive_pulse()</span>. Each time we process a pulse we record it in a global dict called <span>measure_pulses</span>.
</p><p>Also we leave <span>process_pulse()</span> to be defined by each particular module type.
</p><p>We have a method that returns a list of all modules to which signals should be propagated. See <span>propagate_pulse()</span>.
</p><p>Let&#39;s start by the easiest module type:
</p><pre>class TestModule(Module):
    def process_pulse(self, mod: &#34;Module&#34;, pulse: int):
        return []
</pre><p>
Give that it&#39;s a dummy module, it doesn&#39;t do anything when it receives an input.
</p><pre>class Broadcaster(Module):
    def process_pulse(self, mod: &#34;Module&#34;, pulse: int):
        return super().propagate_pulse(pulse)
</pre><p>
As expected the Broadcaster always propagates the received input to all its outputs.
</p><pre>class FlipFlop(Module):
    def __init__(self, name: str):
        super().__init__(name)
        self.state = 0

    def process_pulse(self, mod: &#34;Module&#34;, pulse: int):
        if pulse == 0:
            self.state = (self.state + 1) % 2
            return super().propagate_pulse(self.state)
        return []
</pre>
<p>The flip flop start initially turned off. See <span>self.state = 0</span> in <span>__init__()</span>.
</p><p>In <span>process_pulse()</span> we implement the behaviour:
</p><li>If receives a <em>low</em> pulse, toggles the state and sends a pulse equals to the state to all it&#39;s outputs.
</li><li>Otherwise it doesn&#39;t do anything.
<pre>class Conjunction(Module):
    def __init__(self, name: str):
        super().__init__(name)
        self.memory = {}

    def remember_input(self, mod: Module):
        self.memory[mod.name] = 0

    def process_pulse(self, mod: Module, pulse: int):
        self.memory[mod.name] = pulse
        if all(self.memory.values()):
            return self.propagate_pulse(0)
        return self.propagate_pulse(1)
</pre>
<p>The conjunction initializes it&#39;s memory as empty. See <span>__init__()</span>.
</p><p>Each time a module is plugged in as an input it remembers it as OFF (<span>0</span>). See <span>remember_input()</span>.
</p><p>The way it processes pulses is by first recording the pulse for the input in it&#39;s memory. Then if all inputs are <span>1</span>s it sends a <span>0</span> pulse to all it&#39;s outputs.
</p><p>Otherwise it sends a <span>1</span> pulse to all it&#39;s outputs.
</p><p>At this point we have all our building blocks for solving this problem. We only need to parse the input and something that pushes the button and makes sure signals are propagated to the end.
</p>Parsing modules is straightforward:
<pre>def parse_modules(modules: list) -&gt; dict[str, Module]:
    modules_by_name = {}
    outputs_by_name = {}

    # Parse all modules into their correspondig class and store
    # them in a dict.
    for m in modules:
        module_type = m[0]
        module_outputs = [o.strip() for o in m[1].split(&#34;,&#34;) if o.strip()]
        if module_type.startswith(&#34;broadcaster&#34;):
            modules_by_name[module_type] = Broadcaster(module_type)
            outputs_by_name[module_type] = module_outputs
        elif module_type.startswith(&#34;%&#34;):
            modules_by_name[module_type[1:]] = FlipFlop(module_type[1:])
            outputs_by_name[module_type[1:]] = module_outputs
        elif module_type.startswith(&#34;&amp;&#34;):
            modules_by_name[module_type[1:]] = Conjunction(module_type[1:])
            outputs_by_name[module_type[1:]] = module_outputs
    # Once all the modules are parsed use connect their outputs.

    # If the module doesn&#39;t exist at this point is a TestModule.
    # If the module is a Conjunction, call <span>remember_input()</span>.
    for name, outputs in outputs_by_name.items():
        for mod_name in outputs:
            mod = modules_by_name.get(mod_name, TestModule(mod_name))
            modules_by_name[name].connect_output(mod)
            if isinstance(mod, Conjunction):
                mod.remember_input(modules_by_name[name])

    return modules_by_name
</pre>
<p>If we parse our example using that function we will receive a dictionary as it&#39;s output. Keys are module names and values are the objects representing the module.
</p><p>If we parse the example we get something like this:
</p><pre>example = &#34;&#34;&#34;broadcaster -&gt; a, b, c
%a -&gt; b
%b -&gt; c
%c -&gt; inv
&amp;inv -&gt; a&#34;&#34;&#34;
example_modules = [m.split(&#34; -&gt; &#34;) for m in example.splitlines() if m.strip()]
print(parse_modules(example_modules))

# Output
{
    &#39;broadcaster&#39;: Broadcaster(name=broadcaster),
    &#39;a&#39;: FlipFlop(name=a),
    &#39;b&#39;: FlipFlop(name=b),
    &#39;c&#39;: FlipFlop(name=c),
    &#39;inv&#39;: Conjunction(name=inv)
}
</pre>
Then we need a function that pushes the button and makes sure all signals are propagated:
<pre>def push_button(modules_by_name: dict[str, Module]):
    broad = modules_by_name[&#34;broadcaster&#34;]
    queue = [(broad, broad.receive_pulse(None, 0))]
    while queue:
        current, signals = queue.pop(0)
        for mod, pulse in signals:
            queue.append((mod, mod.receive_pulse(current, pulse)))
</pre>
<p>Here, we lookup the broadcaster module by name. And send a pulse (note that we pass <span>None</span> as the module because we didn&#39;t implement a button class) to the broadcaster.
</p><p>We store the current module (broadcaster) along with all the propagated signals (return value from <span>receive_pulse()</span>) in a queue to be processed.
</p><p>While the signal queue to be processed is not empty we do the following:
</p></li><li>Extract the first element of the queue.
</li><li>Go trough all the signals that this element is sending.
</li><li>Send the pulses to each corresponding module and store them in the queue to be processed.
<p>This process will stop when all responses from <span>receive_pulse()</span> are empty and there are no more signals added to the queue.
</p><p>If we run this for our example:
</p><pre>example_modules = parse_modules(example_modules)
push_button(example_modules)

# Output
None -0-&gt; broadcaster
broadcaster -0-&gt; a
broadcaster -0-&gt; b
broadcaster -0-&gt; c
a -1-&gt; b
b -1-&gt; c
c -1-&gt; inv
inv -0-&gt; a
a -0-&gt; b
b -0-&gt; c
c -0-&gt; inv
inv -1-&gt; a
</pre>
<p>It looks the same as when we analyzed the example above!! 
</p><p>We&#39;re ready for processing our problems input. (Remeber to comment out the print statement inside <span>receive_pulse()</span>).
</p><pre>modules = open(&#34;input.txt&#34;, &#34;r&#34;).read().strip()
modules = [m.split(&#34; -&gt; &#34;) for m in modules.splitlines() if m.strip()]
modules = parse_modules(modules)

for _ in range(1000):
    push_button(modules)

print(&#34;result:&#34;, measure_pulses[0] * measure_pulses[1])

# Output
result: x
</pre>
Based on your problem input <span>x</span> will be the solution.
</li></div><h3>Part 2
</h3><div><p>This part as always is much trickier than the first part. It doesn&#39;t involve much code changes, just figuring out a way of avoiding large computations.
</p><p>For this part, the problem tells us that there&#39;s a module called <span>rx</span>. And we need to find out the lowest amount of button pulses that will make the <span>rx</span> module receive a <em>low</em> pulse.
</p><p>As I have learned troughout this entire challenge, just nahively letting it run and see when the <span>rx</span> module gets a <em>low</em> signal will get me nowhere. It will run forever.
</p><p>So, taking a look at the input and see what the <span>rx</span> module is actually connected to might provide some guidance.
</p><p>Following is for my case (I don&#39;t know if all problem inputs are the same). Looking up &#34;rx&#34; in the input I find a single line:
</p><pre>...
&amp;lv -&gt; rx
...
</pre>
<p>That means <span>rx</span> is a <span>TestModule</span> (a dummy module that has nothing connected to it&#39;s output). And that has only one input: a Conjunction called <span>lv</span>.
</p><p>Ok, that feels like progress. Let&#39;s see what lv is connected to:
</p><pre>...
&amp;st -&gt; lv
&amp;tn -&gt; lv
&amp;hh -&gt; lv
&amp;dt -&gt; lv
...
</pre>
<p>Other 4 Conjunctions are connected as inputs of lv. That&#39;s interesting. Because <span>lv</span> is a Conjuction it means that to send the <em>low</em> pulse required by <span>rx</span> it should receive all <em>high</em> pulses from it&#39;s inputs.
</p><p>The solution from here is kind of intuitive at this point. If we figure out how many button pulses does it take for each of the input devices to send a 1 signal we can multiply them together and get the result.
</p><p>I&#39;ll explain better. Let&#39;s say <span>st</span> sends a 1 on every button push, <span>tn</span> sends a 1 every second button push (this means you have to press the button twice to get <span>tn</span> to send a 1 as an output), <span>hh</span> sends a 1 every fourth button push and <span>dt</span> sends a 1 every eighth button push.
</p><p>So it looks like this:
</p><pre>module | pushes
---------------
  st   |   1
  tn   |   2
  hh   |   4
  dt   |   8
</pre>
<p>In this example, if we push the button 8 times. They are all gonna send a <em>high</em> pulse. Because 8 is divisible by 1, 2, 4 and 8.
</p><p>If the table were different:
</p><pre>module | pushes
---------------
  st   |   1
  tn   |   3
  hh   |   5
  dt   |   7
</pre>
<p>In this case there&#39;s no obvious number of times we should push the button. But if we multiply the numbers together we get a number that is divisible by every number in the table. Pushing the button 1 * 3 * 5 * 7 = 105 times will make all the outputs send a 1, and consequently <span>rx</span> will receive a 0.
</p></div><h3>Solution
</h3><div><p>What we need to do then is to figure after out how many button presses we get a 1 on each of those modules.
</p><pre>from collections import defaultdict

# Store number of button presses in a global variable
ITERATIONS = 0
# Store <em>high</em> pulses for target modules
OUT_PULSES = defaultdict(list)

class Conjunction(Module):
    def __init__(self, name: str):
        super().__init__(name)
        self.memory = {}

    def remember_input(self, mod: Module):
        self.memory[mod.name] = 0

    def start_recording(self):
        self.recording = True

    def record(self):
        if hasattr(self, &#34;recording&#34;):
            OUT_PULSES[self.name].append(ITERATIONS)

    def process_pulse(self, mod: Module, pulse: int):
        self.memory[mod.name] = pulse
        if all(self.memory.values()):
            return self.propagate_pulse(0)
        self.record()
        return self.propagate_pulse(1)
</pre>
<p>We introduced 2 new methods to the conjunction module: <span>start_recording()</span> and <span>record()</span>. The first just initializes a bool attribute. And the second makes sure to only record <em>high</em> pulses for objects that have been initialized (method <span>start_recording()</span> called).
</p><p>Also introduced 2 global variables: <span>ITERATIONS</span> to keep track of button pushes and <span>OUT_SIGNALS</span> to track each time one of the modules outputs a <em>high</em> pulse.
</p><p>Now we need to make those specific modules record their outputs:
</p><pre># Get the &#34;lv&#34; module by name
lv = modules[&#34;lv&#34;]
lv_inputs = [modules[k] for k in lv.memory.keys()]
for m in lv_inputs:
    m.start_recording()
</pre><p>
I wasn&#39;t sure if the cycle was always going to be the same, so just to be sure I did <span>100_000</span> button pushes and recorded all the &#34;1&#34; outputs for those modules.
</p><pre>for i in range(100_000):
    ITERATIONS += 1
    push_button(modules)
print(OUT_PULSES)

# Output
{&#39;hh&#39;: [3769, 7538, 11307, 15076, 18845, 22614, 26383, 30152, 33921, 37690, 41459, 45228, 48997, 52766, 56535, 60304, 64073, 67842, 71611, 75380, 79149, 82918, 86687, 90456, 94225, 97994], &#39;tn&#39;: [3863, 7726, 11589, 15452, 19315, 23178, 27041, 30904, 34767, 38630, 42493, 46356, 50219, 54082, 57945, 61808, 65671, 69534, 73397, 77260, 81123, 84986, 88849, 92712, 96575], &#39;st&#39;: [3929, 7858, 11787, 15716, 19645, 23574, 27503, 31432, 35361, 39290, 43219, 47148, 51077, 55006, 58935, 62864, 66793, 70722, 74651, 78580, 82509, 86438, 90367, 94296, 98225], &#39;dt&#39;: [4079, 8158, 12237, 16316, 20395, 24474, 28553, 32632, 36711, 40790, 44869, 48948, 53027, 57106, 61185, 65264, 69343, 73422, 77501, 81580, 85659, 89738, 93817, 97896]}
</pre><p>
We can observe that for each module we have a periodicity given by:
</p><pre>hh = n*3769
tn = n*3863
st = n*3929
dt = n*4079
</pre>
<p>This means we can just multiply the first element of each list for each module and we&#39;ll get our result.
</p><p>In my case it was:
</p><pre>accum = 1
for name, pulses in OUT_PULSES.items():
    accum *= pulses[0]
print(&#34;result:&#34;, accum)

# Output
result: 233338595643977
</pre>
</div><h2>Closing words
</h2><div><p>This problem is my favourite because it has a few characteristics that I personally enjoy:
</p><li>It&#39;s based on real world stuff. In this case electronic devices (which is also a plus because they&#39;re fun).
</li><li>It can be easily translated to an OOP approach which makes it easy to implement and understand.
</li><li>To solve the second part you need to look at the data and make a solution for your particular input.
</li><li>It doesn&#39;t involve any Graph traversal or specific Math, Calculus or Algebra knowledge. Or any obscure CS algorithm.
<p>In the end this is one of my favourites because to solve it you just have to understand the problem and understand the data.
</p><p>Link to my github project with the solutions <a target="_blank" href="https://github.com/mliezun/aoc">https://github.com/mliezun/aoc</a>.
</p></li></div></article></div>
  </body>
</html>
