<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.carehart.org/blog/2023/10/1/testing_port_reachability_with_other_than_telnet">Original</a>
    <h1>Testing if a port can be reached, using built-in tools other than ol&#39; telnet</h1>
    
    <div id="readability-page-1" class="page"><div><p>
			

			
			Have you ever wanted to test (from the command line) whether a port on another machine can be reached from yours? When some app of your can&#39;t seem to connect to a given port, you may want to test things from the command line. (The problem may be that the service using that port has stopped or is blocked by a firewall--it may be that you&#39;re mistaken in the port you are trying to use, or perhaps even the ip address, domain name, or machine name.)    </p><p>
There are in fact many tools which can help with this task, some of which will be familiar to those on *nix systems, but Windows users who&#39;ve been around a while (or who learned from such folks) may try to rely on the good ol&#39; telnet command (as in <i>telnet <machine> <port></port></machine></i>). Unfortunately, they often find out how <b>Microsoft has disabled that tool by default for over a decade</b> (since Windows Vista), and while it <a href="https://www.makeuseof.com/enable-telnet-windows/">can be easily enabled</a>, they may be prevented or understandably reluctant to do that.    </p><p>
In this post, I want to show a couple of command-line alternatives which can do the job easily, <b>one best suited for powershell users (Test-NetConnection)</b>, and and two of which would suit those who prefer the command line (cmd) and which are now built-into Windows (the past few years): <b>ssh and curl</b>. No, this is not their primary job but they will suit for this task and it may surprise some to learn they&#39;re even built-in options. I&#39;ll conclude with still other options available to those on *nix environments (who of course can also use ssh and curl), especially nc (netcat). </p><p> Topics:  </p><ul>  <li><a href="https://www.carehart.org/blog/2023/10/1/ps">Option 1) Powershell&#39;s nifty Test-NetConnection</a></li><a href="https://www.carehart.org/blog/2023/10/1/ps">  </a><li><a href="https://www.carehart.org/blog/2023/10/1/ps"></a><a href="#win">Yes, Windows has included ssh and curl for a few years!</a></li>  <li><a href="#curl">Option 2) Using curl to test connectivity to a port</a>, including how the curl command responds if the port CANNOT or CAN be reached</li>  <li><a href="#ssh">Option 3) Using ssh to test connectivity to a port</a>, including how that command responds in those cases</li>  <li><a href="#other">Using other cli tools on Linux, Unix, MacOS</a></li>  <li><a href="#why">On understanding WHY the port being checked could not be reached</a></li>  </ul>        <p>
<b>Update:</b> this first section has been added since my original post. Thanks to Mark Gregory for <a href="https://www.carehart.org/blog/2023/10/1/testing_port_reachability_with_other_than_telnet#c3D1D347A-C432-43A4-B9FC06F0CDF4EB1A">his kind comment suggesting it</a>.    </p><p>
If you&#39;re a powershell user (or are ok using it, even if you favor still using the traditional Windows CMD for the command line), there&#39;s a nice cmdlet that can do this task of testing a connection to a port, Test-NetConnection, as in:    </p><p>Test-NetConnection <span>&lt;machine&gt;</span> -port <span>&lt;port&gt;</span></p>    <p>
Of course, <i>machine</i> can be an ip address, domain name, machine name, etc., and it need not be a machine other than yours: it can be your own.      </p><p>
So for instance, someone might test if their SQL Server was reachable on the machine &#34;dbserver&#34; at port 1433 using:    </p><p>Test-NetConnection dbserver -port 1433</p>    <p>
The UI of the tool will appear as it tries to connect, and regardless of its results, in the end it will report true or false, as in:  </p><p>Response includes TcpTestSucceeded: True</p>    <p>
For some readers, that&#39;s really all you need to hear and you can stop. For those interested to learn more (who may want to propose other alternatives), please do read on.    </p><h2>What about the long delay if the port is NOT open</h2>    <p>
You may notice that this Test-NetConnection cmdlet will hang if the port on the machine trying to be reached is not available. That hang-time is as much about your a TCP timeout set at the OS level for your machine (from which you&#39;re running the test.) I discuss this more later with regard to curl and ssh (which offer options to override that timeout).    </p><p>
Sadly, at this writing, there&#39;s no option to override that timeout for Test-NetConnection. (Others have noticed and raised the concern. See <a href="https://copdips.com/2019/09/fast-tcp-port-check-in-powershell.html">this post</a> for a couple of powershell approaches addressing this issue.)    </p><h2>Other ways do exist to test connectivity to such specific apps</h2>    <p>
<b>Update:</b> I previously had these few paragraphs in the next section, but I am moving them up to here because they&#39;re natural questions following the example I&#39;ve offered, which I also use for the other variants below.    </p><p>
And yes, I&#39;m well aware that there are other means by which one could test connectivity to something like SQL Server (or mysql or redis, etc.) from the commandline, using dedicated tools offered for each. The point of this post was to present approaches that works with ANY service whose port accessibility you&#39;re checking.    </p><p>
Finally, I&#39;m also aware that there are other ways to find what ports are open on a given machine (port scanning tools) as well as whether and what ports are open on your machine, such as via good ol&#39; netstat or UI tools like curports, to the more modern tool built into Windows (since Vista) called Resource Monitor. The focus here is again on a cli approach to test the accessibility of a port on any machine--versus finding if its one of many open ports, valuable though that info may be.    </p><p>
Anyway, moving on, for those who may still favor CMD (the command prompt) over powershell, you won&#39;t find it offering that nifty Test-NetConnection (though again you can call powershell commands from cmd). Instead, you may find some comfort in using curl or ssh, instead, which are covered in the remainder of this post.     </p>    <p>
So as for ssh and curl, let me point out first some news which may have been missed by many (including those who try to help others or who write about IT matters). You don&#39;t NEED to &#34;install putty&#34; anymore: <b><u>Windows has included ssh (an openssh client) for a few years, since later versions of Windows 10 and Server 2019</u></b>.  And the same is true of curl (a command-line browser).    </p><p>
If you want to confirm this, just open a Windows command prompt and type ssh (it should be found within your Windows path, and so should run), which will return brief help for the command. Same with curl!    </p><p>
Now granted, I realize that using curl or ssh to test the availability of a port (especially on another server) is not the real purpose of those tools--any more than it was the purpose of telnet. But the point is that these generally do &#34;work&#34; well, so they&#39;re  tools to consider for one&#39;s arsenal. And again, I&#39;ll cover other tools that you may be able to obtain or find in some Linux distros (or MacOS or Unix) at the end of this post.    </p><p>
Considering also that you find either curl or ssh to suit you better for some situations, I will discuss them both. And I could have presented either one first. I offer curl first as some may be more comfortable with that, if they don&#39;t have much experience with ssh. Again the key point is that both these tools should be available to everyone reading this, unless they&#39;re on very old deployments of Windows.    </p>    <p>
So let&#39;s look first at using curl to test if a port can be reached (though really, I&#39;d recommend option 1 above or option 3 below, for reasons which will become clear):    </p><p>curl <span>&lt;machine&gt;</span>:<span>&lt;port&gt;</span></p>    <p>
Note there&#39;s a colon between the machine and the port.  Again, <i>machine</i> could be an ip address, domain name, machine name, etc.     </p><p>
So for instance, someone might test if their SQL Server was reachable on the machine &#34;dbserver&#34; at port 1433 using:    </p><p>curl dbserver:1433</p>    <p>
So let&#39;s talk about what one may see depending on whether the connection via curl can or cannot be made. Of course, normally one uses curl to visit a given page on a given site, but again we&#39;re just &#34;hacking&#34; it to have it try to merely connect.     </p><h2>How the curl command responds if the port CANNOT be reached, and dealing with hang time</h2>    <p>
If somehow that machine (or ip address or domain name) cannot be reached, the request will hang (more on that in a moment) and then the curl command will respond with this error:    </p><p>curl: (<span>28</span>) Failed to connect to <span>&lt;machine&gt;</span>: <span>&lt;port&gt;</span> after <span>&lt;duration&gt;</span>: ms: Couldn&#39;t connect to server</p>    <p>
The key is that this tells us that that the port could not be reached. (As for &#34;why not&#34;, neither curl nor ssh can help with that. I discuss that at the end.)    </p><p>
As for this &#34;hang time&#34; waiting to connect, this is something telnet did also. The amount of time it will wait is technically defined by your OS, and is known generically as the TCP timeout time.  A difference with curl versus telnet is that you CAN control how long you&#39;re willing for the curl command to await using the command&#39;s optional <i>connect-timeout</i> flag, as in the following example to set a 1-second timeout:    </p><p>curl --connect-timeout 1 <span>&lt;machine&gt;</span>:<span>&lt;port&gt;</span></p>    <p>
Finally, if you find it does not stop trying to connect within the number of seconds indicated, do beware that the curl tool may be attempting different additional connections than you may realize. Add the -v arg to the command, to see more verbose output, including details of the connections it&#39;s attempting.    </p><p>curl -v --connect-timeout 1 <span>&lt;machine&gt;</span>:<span>&lt;port&gt;</span></p>    <p>
So that&#39;s how the tool can tell us (or be tweaked regarding) the failure to connect. Let&#39;s move on to what it may show if it CAN connect.    </p><h2>How the curl command responds if the port CAN be reached</h2>    <p>
Remembering that curl is first and foremost a command-line http client, if the connection is successful AND there&#39;s a web server on the other end (with a default web page to satisfy this request), <b>the command will respond showing us the output of the page</b>, whatever it is. :-) Or if it does not exist, it will perhaps show the content returned in the form of some sort of 404 error page. (And yes, there are ways to pipe its output to a file or the bit bucket, but I leave you to check out the docs for that.)    </p><p>
If instead the port being tested could be reached but it is NOT for a web server (which may be more common for folks seeking to &#34;test a port&#39;s accessibility&#34;), then the curl command will respond (immediately) with an error:    </p><p>curl: (<span>52</span>) Empty reply from server</p>    <p>
And <b>given that our goal again is just to know if the port can be reached, there&#39;s value in getting that immediate error: the port CAN be reached.</b>    </p><p>
(Another beneficial difference of this over the old telnet approach is that with that, a successful connection would show a blank screen if the connection, awaiting commands. You&#39;d have to know telnet keystrokes and commands to break out of that, or you might close the terminal window if testing the port was your only reason for opening it.)    </p><p>
But maybe you feel itchy about using curl for this task. Well, if you can be persuaded, there is again the alternative of using ssh...    </p>    <p>
As for using ssh to test if a port can be reached, you could do something like this:  </p><p>ssh -p <span>&lt;port&gt;</span> <span>&lt;machine&gt;</span></p>    <p>
Again, <i>machine</i> could be an ip address, domain name, machine name, etc.  (And those two values of machine and port are indeed the reverse order of both the curl above and the traditional telnet.)      </p><h2>How the ssh command responds if the port CANNOT be reached, and dealing with hang time</h2>    <p>
If the port CANNOT be reached, then (like with curl and telnet) the command will hang for an extended period of time before failing with an error like:  </p><p>ssh: connect to host <span>&lt;machine&gt;</span>  port <span>&lt;port&gt;</span>: Connection timed out</p>    <p>
So with my example above, I&#39;d receive this if SQL Server was not listening or inaccessible:  </p><p>ssh: connect to host dbserver port 1433: Connection timed out</p>    <p>
And as in the case of curl, if you want to override that long TCP timeout time for your OS, you can do that with the command&#39;s optional ConnectTimeout flag. The following to set a 1-second timeout:    </p><p>ssh -o ConnectTimeout=1  -p <span>&lt;port&gt;</span> <span>&lt;machine&gt;</span></p>    <p>
(And as with curl, if you find it does not stop trying to connect within the number of seconds indicated, do beware that the ssh tool may be attempting different connections than you realize. add the -v arg to the command, to see more details of the connections it&#39;s attempting.)    </p><p>
Again, as for &#34;why&#34; it can&#39;t be reached, see the end of this port for ideas to consider.    </p><h2>How the ssh command responds if the port CAN be reached</h2>    <p>
If on the other hand the port CAN be reached, the ssh command <b>will respond immediately</b>, which is nice. And that&#39;s what makes this (like curl) indeed a helpful tool (.     </p><p>
That said, note that if the port you&#39;re checking is technically not an ssh port, the command will also report an &#34;error&#34;:   </p><p>kex_exchange_identification: Connection closed by remote host</p>    <p>
In the case of using the command for this test of port connectivity, we can ignore that error. Again, <b>at least this confirms that the port could be reached, which was our primary goal.</b>    </p>    <p>
Before wrapping up this post, I mentioned at the open how this this technique may appeal to Windows users more than those on *nix OS&#39;s, as they not only already have long had the two tools above, but they have still other tools they can use for this task of testing for whether a port can be reached, such as  netcat/nc, which could handle this just as simply:    </p><p>nc -zv <span>&lt;machine&gt;</span> <span>&lt;port&gt;</span></p>    <p>
And as for port-scanning (the broader process of determining what ports are open on a given machine), there is the classic (and powerful) nmap command, but it&#39;s beyond the scope of this post (as its related tool ncat, which is not the same as netcat above).    </p>    <p>
Finally, I realize some may wonder how to know WHY a port can&#39;t be reached, but neither of these tools can help with that: they merely respond one way if the port CAN be reached and another if it cannot.     </p><p>
As I noted at the opening, the reach a port may not be open is that the service you&#39;re trying to reach is not enabled. Or maybe there&#39;s a firewall blocking access to it (which blocking could be specific to your machine from you are attempting to make the connection). There may be a firewall in the OS of the machine you&#39;re talking to, or one that&#39;s been installed there as software, or there may be one on the network you&#39;re connecting to, etc.    </p><p>
Or you may simply have the wrong value for the port you are testing, or the ip address, domain name, machine name, etc.     </p><p>
Before we wrap up, note that sometimes you may find that a given machine can be identified any of many different ways--such that a port may be &#34;open&#34; to you if you try a way that&#39;s different from what you&#39;re trying (so try an ip address if you have a domain name, or vice-versa, or perhaps try a subdomain if you know of one, and so on).    </p><p>
Often, you will need to get on the server itself (which you can&#39;t reach) and attempt these or other tools THERE, to find out if the port is correct in the first place.    </p>    <p>
I hope I&#39;ve helped you see how curl and ssh (and nc) can be handy tools to have in your arsenal, when you just want to quickly test port accessibility from the commandline. For those on Windows, you can stop trying to install telnet to do a quick port test: just use curl or ssh! :-) That was really the primary motivation of my post here.    </p><p>
And let me know how it goes.    </p><p>
Indeed, this is one of those topics where there may be dark corners, edge cases, and unexpected situations where results differ. I&#39;m sure some people have more experience to share, whether other gotchas or tips, or still other tools that may be built-in to Windows or *nix. As for other tools one might obtain, those are less interesting as again the post here is about built-in tools, because often people are working in environments (especially on servers or containers) where they&#39;re not necessarily free to/wanting to install software.    </p><p>
As always I welcome comments. </p><blockquote>
				For more content like this from Charlie Arehart:
				<ul>
					<li>Signup to get his blog posts by email: 
					</li>
					<li>Follow <a href="https://www.carehart.org/blog/client/rss.cfm">his blog RSS feed</a></li>
					<li>View <a href="https://www.carehart.org/blog">the rest of his blog posts</a></li>
					<li>View <a href="https://coldfusion.adobe.com/profile/Charlie%20Arehart">his blog posts on the Adobe CF portal</a></li>
				</ul>
				Need more help with problems?
				<ul>
				<li>If you may prefer direct help, rather than digging around here/elsewhere or via comments, he can help via his online <a href="https://www.carehart.org/consulting">consulting services</a></li>
				<li>See that page for more on how he can help a) over the web, safely and <b>securely</b>, b) usually very <b>quickly</b>, c) <b>teaching</b> you along the way, and d) with <b>satisfaction guaranteed</b></li>
				</ul>
				</blockquote>		
			
			</div></div>
  </body>
</html>
