<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jitsi.org/blog/enhanced-noise-suppression-in-jitsi-meet/">Original</a>
    <h1>Enhanced noise suppression in Jitsi Meet</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p><span><strong>Blog</strong></span></p>
				
				<p>For a while now <a href="https://jitsi.org/jitsi-meet/">Jitsi Meet</a> has been using the <a href="https://jmvalin.ca/demo/rnnoise/">RNNoise</a> library to calculate voice audio detection scores for audio input tracks and leveraging those to implement functionality such as “talk while muted” and “noisy mic detection”. However, RNnoise also has the capability to denoise audio.</p>
<p>In this article we’ll briefly go through the steps taken to implement noise suppression using RNnoise in Jitsi Meet.</p>

<p><b>What’s RNNoise anyway?</b></p>
<p>RNNoise, as the authors <a href="https://hacks.mozilla.org/2017/09/rnnoise-deep-learning-noise-suppression/">describe it</a>, “​​combines classic signal processing with deep learning, but it’s small and fast”, this makes it perfect for real time audio and does a good job at denoising.</p>
<p>It’s written in C which allows us to (relatively) easily use it on the Web by compiling it as a <a href="https://en.wikipedia.org/wiki/WebAssembly">WASM</a> module, that combined with a couple of optimizations gets us noise suppression functionality with very little added latency.</p>
<p><b>Working with Audio Worklets</b></p>
<p>Previously Jitsi Meet processed audio using <a href="https://developer.mozilla.org/en-US/docs/Web/API/ScriptProcessorNode">ScriptProcessorNode</a> which handles audio samples on the main UI thread. Because the audio track wasn’t altered and we simply extracted some information from a copy of the track, performance issues weren’t apparent. With noise suppression the track gets modified, so latency is noticeable, not to mention that any interference on the main UI thread will impact the audio quality, so we switched to audio worklets.</p>
<p>Audio worklets run in a separate thread from the main UI thread, so samples can be processed without interference. We won’t go into the specifics of implementing one as there are plenty of awesome resources on the web such as: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Using_AudioWorklet">this</a> and <a href="https://googlechromelabs.github.io/web-audio-samples/audio-worklet/">this.</a> Our worklet implementation can be found <a href="https://github.com/jitsi/jitsi-meet/blob/master/react/features/stream-effects/noise-suppression/NoiseSuppressorWorklet.ts">here</a>.</p>
<p><b>Webpack integration</b></p>
<p>Even though using an audio worklet looks fairly straightforward there were a couple of bumps along the road.</p>
<p>First off, and probably the most frustrating part was making them work with webpack’s<a href="https://webpack.js.org/configuration/dev-server/"> dev server</a>.</p>
<p>Long story short, the dev server has some neat features such as hot module replacement and live reloading, these rely on some bootstrap code added to the output JavaScript bundle. The issue here is that audio worklet code runs under the <em>AudioWorkletGlobalScope</em>’s context which doesn’t know anything about constructs like <em>window</em>, <em>this</em> or <em>self</em>, however the aforementioned boilerplate code makes ample use of them and there doesn’t seem to be a way to tell it that the context in which it’s running is a worklet.</p>
<p>We tried several approaches but the solution that worked for us was to ignore the dev server bootstrap code altogether for the worklet’s entry point, which can be configured in webpack config as follows:</p>
<pre><i>module: { rules: [ ...config.module.rules,</i>
<i>            { test: resolve(__dirname, &#39;node_modules/webpack-dev-server/client&#39;),</i>
<i>              loader: &#39;null-loader&#39; </i><i>} ] }</i></pre>
<p>That took care of the dev server, however production webpack bundling also introduced boilerplate which made use of the “forbidden” worklet objects, but in this case it’s easily configurable by specifying the following output options:<i></i></p>
<pre><i>output: { ...config.output, </i><i>globalObject: &#39;AudioWorkletGlobalScope&#39; }</i></pre>
<p>At this point we had a working worklet (pun intended) that didn’t break our development environment.</p>
<p><b>WASM in audio worklets.</b></p>
<p>Next came adding in the RNnoise WASM module. Jitisi uses RNnoise compiled with emscripten (more details in the project: <a href="https://github.com/jitsi/rnnoise-wasm">https://github.com/jitsi/rnnoise-wasm</a>). With the default settings the WASM module will load and compile asynchronously, however because the worklet loads without waiting for the resolution of promises we need to make everything synchronous, so we inline the WASM file by passing in  <em>-s SINGLE_FILE=1</em> to emscripten and we also tell it to synchronously compile it with <em>-s WASM_ASYNC_COMPILATION=0</em>. With that in place everything will be loaded and ready to go when audio samples start coming in.</p>
<p><b>Efficient audio processing.</b></p>
<p>Audio processing in worklets happens on the <em>process()</em> callback method in the <em>AudioWorkletProcessor</em> implementation at a fixed rate of 128 samples (this can’t be configured as with <em>ScriptProcessorNodes</em>), however RNnoise expects 480 samples for each call to it’s denoise method<em> rnnoise_process_frame</em>.</p>
<p>To make this work we implemented a <a href="https://en.wikipedia.org/wiki/Circular_buffer">circular buffer</a> that minimizes copy operations for optimal performance. It works by having both the buffered samples and the ones that have already been denoised on the same <em>Float32Array</em> with a roll over policy. The full implementation can be found <a href="https://github.com/jitsi/jitsi-meet/blob/master/react/features/stream-effects/noise-suppression/NoiseSuppressorWorklet.ts">here</a>.</p>
<p>To summarize, we keep track of how many audio samples we have buffered, once we have enough of them (480 to be precise) we send a view of that data to RNnoise where it gets denoised in-place (i.e. no additional copies are required). At this point the circular buffer has a denoised part and possibly some residue samples that didn’t fit in the initial 480, which will get processed in the next iteration. The process repeats until we reach the end of the circular buffer at which point we simply start from the beginning and overwrite “stale” samples; we consider them stale because at this point they have already been denoised and sent.</p>
<p>The worklet code gets compiled as a separate .js bundle and lazy loaded as needed.</p>
<p><strong>Use it in JaaS / using the iframe API<br/>
</strong></p>
<p>If you are a <a href="https://jaas.8x8.vc">JaaS</a> customer (or are using Jitsi Meet through the <a href="https://jitsi.github.io/handbook/docs/dev-guide/dev-guide-iframe">iframe API</a>) we have added an API command to turn this on programmatically too! <a href="https://jitsi.github.io/handbook/docs/dev-guide/dev-guide-iframe-commands#setnoisesuppressionenabled">Check it out</a>.</p>
<p><b>Check it out!</b></p>
<p>In Jitsi Meet this feature can be activated by simply clicking on the <em>Noise Suppression</em> button.</p>
<p><img alt="" width="150" height="150" data-srcset="https://jitsi.org/wp-content/uploads/2022/07/Screenshot-2022-09-23-at-12.07.34-150x150.png 150w, https://jitsi.org/wp-content/uploads/2022/07/Screenshot-2022-09-23-at-12.07.34-50x50.png 50w, https://jitsi.org/wp-content/uploads/2022/07/Screenshot-2022-09-23-at-12.07.34-284x284.png 284w" data-src="https://jitsi.org/wp-content/uploads/2022/07/Screenshot-2022-09-23-at-12.07.34-150x150.png" data-sizes="(max-width: 150px) 100vw, 150px" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/></p>
<p>Since in this case a sound file is probably worth more than 1000 words, here is an audio sample  demonstrating the denoising:</p>
<p>Original audio:</p>

<p>Denoised audio:</p>
<p><audio id="audio-2335-2" preload="none" controls="controls"><source type="audio/mpeg" src="https://jitsi.org/wp-content/uploads/2022/07/denoised-audio.mp3?_=2"/><a href="https://jitsi.org/wp-content/uploads/2022/07/denoised-audio.mp3">https://jitsi.org/wp-content/uploads/2022/07/denoised-audio.mp3</a></audio></p>
<hr/>
<p>❤️  Your personal meetings team.</p>
<p>Author: <a href="https://github.com/andrei-gavrilescu">Andrei Gavrilescu</a></p>

							</div></div>
  </body>
</html>
