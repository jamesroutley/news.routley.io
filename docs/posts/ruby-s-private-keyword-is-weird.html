<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jez.io/ruby-private/">Original</a>
    <h1>Ruby&#39;s private keyword is weird</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Ruby’s <code>private</code> keyword means something different
compared to basically all other object-oriented languages. Most other
languages don’t even have a feature matching what Ruby calls
<code>private</code>, but incredibly, Scala does, which it calls
<code>protected[this]</code> (meaning “object-protected”, as opposed to
the normal <code>protected</code> keyword which is called
“class-protected”).</p>
<p>First let’s review what <code>private</code> normally means, and then
discuss what <code>private</code> in Ruby means (which will also amount
to an explanation of what <code>protected[this]</code> means in
Scala).</p>

<p>Conventionally, <code>private</code> means “only code contained
inside my class’s body can access this member,” for example in Java:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1"></a><span>class</span> Parent <span>{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span>private</span> <span>int</span> x<span>;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span>Parent</span><span>(</span><span>int</span> x<span>)</span> <span>{</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>        <span>this</span><span>.</span><span>x</span> <span>=</span> x<span>;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>        <span>//   └── (1) allowed ✅</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span>}</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span>boolean</span> <span>equals</span><span>(</span>Parent other<span>)</span> <span>{</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>        <span>return</span> <span>this</span><span>.</span><span>x</span> <span>==</span> other<span>.</span><span>x</span><span>;</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>        <span>//          │          └── (2) allowed ✅</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>        <span>//          └── (1) allowed ✅</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>    <span>}</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span>}</span></span>
<span id="cb1-15"><a href="#cb1-15"></a></span>
<span id="cb1-16"><a href="#cb1-16"></a><span>class</span> Child <span>extends</span> Parent <span>{</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span>Child</span><span>(</span><span>int</span> x<span>)</span> <span>{</span> <span>super</span><span>(</span>x<span>);</span> <span>}</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>    <span>int</span> <span>example</span><span>()</span> <span>{</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>        <span>return</span> <span>this</span><span>.</span><span>x</span><span>;</span> <span>// (3) not allowed ⛔️</span></span>
<span id="cb1-20"><a href="#cb1-20"></a>    <span>}</span></span>
<span id="cb1-21"><a href="#cb1-21"></a><span>}</span></span>
<span id="cb1-22"><a href="#cb1-22"></a></span>
<span id="cb1-23"><a href="#cb1-23"></a>Parent parent <span>=</span> <span>new</span> <span>Parent</span><span>(</span><span>0</span><span>);</span></span>
<span id="cb1-24"><a href="#cb1-24"></a>parent<span>.</span><span>x</span><span>;</span> <span>// (4) not allowed ⛔️</span></span></code></pre></div>
<p>In this example we see a member <code>x</code> marked private. In
summary:</p>
<ol type="1">
<li>✅ The member <code>x</code> can be accessed as <code>this.x</code>
inside methods within the class body of <code>Parent</code></li>
<li>✅ The member <code>x</code> can also be accessed on other instances
of <code>Parent</code> within the class body of <code>Parent</code>,
like <code>other.x</code></li>
<li>⛔️ The member <code>x</code> cannot be accessed in subclasses of
<code>Parent</code>, like <code>Child</code></li>
<li>⛔️ The member <code>x</code> cannot be accessed outside of the
inheritance hierarchy of <code>Parent</code></li>
</ol>
<p>Now let’s translate this example to Ruby to see what restrictions the
<code>private</code> keyword in Ruby brings.</p>

<p>Here’s the same Java example, converted to Ruby. What we see is that
points (2) and (3) flip!</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1"></a><span>class</span> <span>Parent</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span>attr_accessor</span> <span>:x</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span>private</span> <span>:x</span>, <span>:x=</span></span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a>  <span>def</span> initialize(x)</span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span>self</span><span>.x</span> <span>=</span> x</span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span>#    └── (1) allowed ✅</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>  <span>end</span></span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a>  <span>def</span> <span>==</span>(other)</span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span>self</span><span>.x</span> <span>==</span> other<span>.x</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>    <span>#    │         └── (2) not allowed ⛔️</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>    <span>#    └── (1) allowed ✅</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>  <span>end</span></span>
<span id="cb2-15"><a href="#cb2-15"></a><span>end</span></span>
<span id="cb2-16"><a href="#cb2-16"></a></span>
<span id="cb2-17"><a href="#cb2-17"></a><span>class</span> <span>Child</span> <span>&lt;</span> <span>Parent</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>  <span>def</span> example</span>
<span id="cb2-19"><a href="#cb2-19"></a>    <span>self</span><span>.x</span> <span># (3) allowed ✅</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>  <span>end</span></span>
<span id="cb2-21"><a href="#cb2-21"></a><span>end</span></span>
<span id="cb2-22"><a href="#cb2-22"></a></span>
<span id="cb2-23"><a href="#cb2-23"></a>parent <span>=</span> <span>Parent</span><span>.new</span>(<span>0</span>)</span>
<span id="cb2-24"><a href="#cb2-24"></a>parent<span>.x</span> <span># (4) not allowed ⛔️</span></span></code></pre></div>
<p>Here’s what Ruby’s <code>private</code> keyword allows:</p>
<ol type="1">
<li>✅ The member <code>x</code> can be accessed as <code>self.x</code>
inside methods within the class body of <code>Parent</code></li>
<li>⛔️ The member <code>x</code> cannot be accessed on other instances
of <code>Parent</code> within the class body of <code>Parent</code>,
like <code>other.x</code></li>
<li>✅ The member <code>x</code> cannot be accessed in subclasses of
<code>Parent</code>, like <code>Child</code></li>
<li>⛔️ The member <code>x</code> cannot be accessed outside of the
inheritance hierarchy of <code>Parent</code></li>
</ol>

<p>Most other object-oriented languages rely on type checking to report
visibility errors before the program runs. Ruby doesn’t have a type
checker and also is quite dynamic. Classes can be reopened and extended
basically at whim, and the notion of “within the class body” barely
exists in Ruby because of how easy it is to dynamically define methods
from anywhere:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>module</span> <span>MyDSL</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span>def</span> make_method</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    define_method(<span>:get_x</span>) <span>do</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>      <span>MyDSL</span><span>.internal_helper</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>      <span>#     └── should this be allowed? 🤔</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>      <span># (technically inside the class body of MyDSL)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>      <span>self</span><span>.x</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>      <span>#    └── should this be allowed? 🤔</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>      <span># (technically not inside the class body of Parent)</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span>end</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  <span>private_class_method</span> <span>def</span> <span>self</span><span>.internal_helper</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span># ...</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span>end</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span>class</span> <span>Parent</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>  <span>extend</span> <span>MyDSL</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>  make_method</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span>end</span></span></code></pre></div>
<p>Real-world Ruby code tends to toss away conventional notions of
“defined inside the class body,” and even if it didn’t, it wouldn’t have
a type checker to easily check visibility.</p>
<p>Instead, Ruby picks a simpler way to enforce visibility: a private
call is allowed anywhere that the receiver is either omitted or is
<code>self</code>, <strong>syntactically</strong>.<span><label for="sn-0">⊕</label><span>The receiver is the <code>x</code> in
<code>x.foo</code>. When a method call’s receiver is omitted like
<code>foo()</code>, Ruby implicitly assumes that it had been called like
<code>self.foo()</code>.</span></span> That syntactic restriction means that things like this
are not allowed:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>class</span> A</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span>private</span> <span>def</span> foo; <span>end</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span>end</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span>def</span> identity(<span>self</span>); <span>self</span>; <span>end</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>identity(<span>self</span>)<span>.foo</span> <span># ⛔️ not syntactically `self.foo`</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span>self</span><span>.itself.foo</span>    <span># ⛔️ not syntactically `self.foo`</span></span></code></pre></div>
<p>By using local syntax to determine when it’s okay to call private
methods, Ruby ends up allowing access via inherited classes and denying
access via something like <code>other.x</code>. This mechanism is very
simple to check: it just a matter of remembering a bit like
<code>isPrivateOk</code> per method call and a bit per method def like
<code>isPrivate</code>, which can be done without any sort of
non-local/static analysis.</p>

<p>For a while, I thought that Ruby was unique in having a visibility
modifier that worked like this, but recently I learned that Scala
actually has a similar feature: <code>protected[this]</code>. The name
wasn’t immediately obvious to me, but it’s actually kind of
sensible:</p>
<ul>
<li>Like the <code>protected</code> visibility modifier,
<code>protected[this]</code> allows (certain kinds of) member access
from subclasses.</li>
<li>The <code>[this]</code> portion is called an “access qualifier”
which limits all access to happen via the <code>this</code>
keyword.</li>
</ul>
<p>It seems that Scala allows other things to appear inside the
<code>[...]</code>, but I stopped short of wrapping my head around what.
I learned about this feature from this page:</p>
<p><a href="https://scala-lang.org/files/archive/spec/2.13/05-classes-and-objects.html#modifiers">→
Scala Language Specification, Version 2.13, Chapter 5 Classes and
Objects, Section 5.2 Modifiers</a></p>
<p>Maybe worth a skim if you’re more curious than I was.</p>
<p>Scala also has <code>private[this]</code>, which excludes access via
subclasses (leaving only access via <code>this</code> inside the parent
class). Ruby doesn’t have a visibility level matching this, which means
that Ruby has no means to hide a member from subclasses.</p>

<p>Despite not being declared with the <code>private</code> keyword,
instance variables in Ruby behave exactly like <code>private</code>
methods!</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1"></a><span>class</span> <span>Parent</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span>def</span> initialize(x)</span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span>@x</span> <span>=</span> x</span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span>#└── &#34;declares&#34; an instance variable</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span>#    (automatically private)</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>  <span>end</span></span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a>  <span>def</span> <span>==</span>(other)</span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span>@x</span> <span>==</span> other<span>.</span><span>@x</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>    <span>#│           └── (2) syntax error ⛔️</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>    <span>#└── (1) allowed ✅</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>  <span>end</span></span>
<span id="cb5-13"><a href="#cb5-13"></a><span>end</span></span>
<span id="cb5-14"><a href="#cb5-14"></a></span>
<span id="cb5-15"><a href="#cb5-15"></a><span>class</span> <span>Child</span> <span>&lt;</span> <span>Parent</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>  <span>def</span> example</span>
<span id="cb5-17"><a href="#cb5-17"></a>    <span>@x</span> <span># (3) allowed ✅</span></span>
<span id="cb5-18"><a href="#cb5-18"></a>  <span>end</span></span>
<span id="cb5-19"><a href="#cb5-19"></a><span>end</span></span>
<span id="cb5-20"><a href="#cb5-20"></a></span>
<span id="cb5-21"><a href="#cb5-21"></a>parent <span>=</span> <span>Parent</span><span>.new</span>(<span>0</span>)</span>
<span id="cb5-22"><a href="#cb5-22"></a>parent<span>.</span><span>@x</span> <span># (4) syntax error ⛔️</span></span></code></pre></div>
<p>So you might next ask, “would it make sense to have ‘public’ instance
variables?” I can see arguments both ways:</p>
<h3 id="pros">Pros</h3>
<ul>
<li>Maybe it scratches a burning itch for symmetry?</li>
<li>It could be used to resolve problems that arise in Sorbet’s control
flow-sensitive typing, which I <a href="https://blog.jez.io/syntactic-control-flow/#properties-and-attributes-in-other-languages">discussed
in a previous post</a>.
<ul>
<li>Counter point, also raised in the post above: you could imagine
solving this another way, by treating <code>x.foo</code> and
<code>x.foo()</code> differently (despite both meaning the same thing in
the Ruby VM).</li>
</ul></li>
<li>Maybe (<em>maybe</em>) it could be optimized more easily by the Ruby
VM?
<ul>
<li>Counter point, the VM already has a lot of special cases for
<code>attr_reader</code>-defined methods, so I’m not actually certain
whether this point is valid.</li>
</ul></li>
</ul>
<h3 id="cons">Cons</h3>
<ul>
<li>In order to keep backwards compatibility, it wouldn’t even be all
that symmetric.
<ul>
<li>Methods would default to public visibility and have a
<code>private</code> keyword, but instance variables would default to
private and have some sort of <code>public</code> keyword.</li>
</ul></li>
<li>Instance variables in Ruby represent encapsulated state. They
shouldn’t leak into the public API, and should instead be exposed by
proper methods.</li>
</ul>
<p>It’s not a fight I want to start (nor one I feel strongly about). But
I will at least point out that nearly all other languages expose a
(syntactic) difference between calling a method and accessing an
attribute.</p>

<p>So far, I’m only aware of Ruby’s <code>private</code> modifier and
Scala’s <code>protected[this]</code> which behave like this. If you know
of any other languages, please email me! I’d love to hear about
them.</p>



<ul>
<li><p>Question 1: why does Scala have both
<code>private</code>/<code>protected</code> and
<code>private[this]</code>/<code>protected[this]</code>?</p>
<p>I don’t know of the history there, but I do know that the latter is
useful especially in generic classes with covariant and/or contravariant
type members. More on that in another post (maybe). I will say though,
it’s actually quite lucky that Ruby works the way it does, or Sorbet
would not be able to provide generic, co-/contravariant classes with <a href="https://github.com/sorbet/sorbet/pull/6721">as few changes as
this!</a></p></li>
<li><p>Question 2: what’s up with Ruby’s <code>protected</code>
keyword?</p>
<p>A great question, but one that I’ll have to save for another
post!</p></li>
</ul>
</div></div>
  </body>
</html>
