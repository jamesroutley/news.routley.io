<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.infoq.com/news/2023/05/gcc13-c2x-features/">Original</a>
    <h1>GCC 13 Supports New C2x Features, Including Nullptr, Enhanced Enumerations</h1>
    
    <div id="readability-page-1" class="page"><div>
								<p>The <a href="https://www.gnu.org/software/gcc/gcc-13/">latest release of GCC</a>, GCC 13.1, <a href="https://gcc.gnu.org/gcc-13/changes.html">adds support for a number of new features and improvements</a> to the C language defined in the upcoming C2x standard, including <code>nullptr</code>, enhanced enumerations, <code>auto</code> type inference, and more.</p>

<p>C2x is adopting a number of changes to the language that first made their appearance in C++, to make it easier for the two languages to coexist in the same codebase. Such changes include <code>nullptr</code>, enhanced enumerations, <code>auto</code> type inference, <code>constexpr</code> specifier, and others.</p>

<p>The new <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3042.htm"><code>nullptr</code></a> constant will attempt to remove one of the issues with the old <code>NULL</code> macro, whose definition is implementation-dependent. This leads to a number of potential shortcomings when using it with type-generic macros, with conditional expression such as <code>(true ? 0 : NULL)</code> (since <code>NULL</code> could be defined as <code>(void*)0</code>), with vararg functions where <code>NULL</code> is used as a sentinel, and in other cases.</p>

<p>To improve this, <code>nullptr</code> will have its own type <code>nullptr_t</code>; will not have a scalar value, so it cannot be used in arithmetic expressions; will be convertible to any pointer type; and will always convert to a boolean with <code>false</code> value.</p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2963.htm">Enhanced enumerations</a> is another change to the language that tries to fix a case of under-specification of the previous standard, in this case concerning the underlying type associated to <code>enum</code>s. In fact, while C normally uses <code>int</code> for enumerations, this is not always the case, which can cause portability issues. Additionally, when <code>int</code>s are effectively used, this rules out the possibility of using enumerations at bitfield level. The new standard thus allows developers to state the enumeration type, as in the following example:</p>

<pre><code>enum a : unsigned long long {
    a0 = 0xFFFFFFFFFFFFFFFFULL
    // ^ not a constraint violation with a 64-bit unsigned long long
};
</code></pre>

<p>C2x also tries to make it away with <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2975.pdf">some restrictions to variadic</a> functions that are considered leaky or dictated by outdated assumptions concerning their requirements on the argument list. Specifically, the new standard is going to permit that a function declaration&#39;s parameter list may just consist of an ellipsis not preceded by a named argument, e.g. <code>int a_variadic_function(...)</code>. This change is considered safe as it does not break any existing code.</p>

<p>Another new C feature inspired by C++ is the use of the <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3007.htm"><code>auto</code> keyword</a> to leave the definition of a variable type implicit. This is possible when the definition includes an initializer from which the variable type can be derived. It is worth noting that C <code>auto</code> is a much more limited feature than C++ <code>auto</code>, which relies on C++ template type deduction rules, and can be used less generally.</p>

<p>The introduction of <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3018.htm"><code>constexpr</code></a> in C2x responds to the goal of improving initialization of object with static storage duration, which require the use of constant expressions or macros evaluating to constant expressions. Thanks to this, the following definition, valid in C17:</p>

<pre><code>static size_t const bignum = 0x100000000;
</code></pre>

<p>can be replaced by</p>

<pre><code>constexpr size_t bignum = 0x100000000;
</code></pre>

<p>which has the added property of ensuring the constant is checked at compile time.</p>

<p>Other new C2x features that are supported by GCC 13 are <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3038.htm">storage-class specifiers for compound literals</a>, <code>typeof</code> and <code>typeof_unqual</code>, the <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2764.pdf"><code>noreturn</code></a> attribute, support for empty initializer braces, removal of trigraphs and unprototyped functions, the <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2836.pdf">adoption of the Unicode Identifier and Pattern Syntax</a>, and more.</p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2086.htm">C2x</a> is the upcoming C language standard revision, expected to be <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2984.pdf">approved this year</a>, thus getting the official C23 denomination.</p>

								









  
    

							</div></div>
  </body>
</html>
