<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.gripdev.xyz/2026/01/10/actions-terminal-on-failure-for-debugging/">Original</a>
    <h1>Launch a Debugging Terminal into GitHub Actions</h1>
    
    <div id="readability-page-1" class="page"><div>
    <main aria-label="Content">
        <article>
            
            
            <div>
                <p><strong>Spoiler:</strong> I made a free and open-source way to get an interactive web terminal to your GitHub Action when it fails. Try it out here: <a href="https://actions-term.gripdev.xyz/">https://actions-term.gripdev.xyz/</a> (<a href="https://github.com/lawrencegripper/actions-term-on-fail">code ğŸ”—</a>) <sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></p>
<video preload="metadata" controls="">
    <source src="/2026/01/10/actions-terminal-on-failure-for-debugging/termdemo.mp4" type="video/mp4"/>
    Your browser does not support the video element.
  </video>
<h2 id="building-it">Building it</h2>
<p>I think weâ€™ve all been there, <strong>your build fails in Actions, but the script works fine locally.</strong> You now settle into a slow loop of:</p>
<ol>
<li>Push speculative change</li>
<li>See if it worked</li>
</ol>
<p>It was in the middle of one of these when I started thinking about how to make it better.</p>
<p>A Terminal would be great, thatâ€™s obvious, but how to make it happen? How could I make it free, and open to anyone, without costing me lots of money?</p>
<p>Operating a service that forward traffic between a user and the Actions VM would stack up data transfer costs and take some work to scale.</p>
<p>What about a Peer-to-Peer connection? Iâ€™d recently been going deeper on how <a href="https://tailscale.com/blog/how-tailscale-works">Tailscale</a>, <a href="https://github.com/n0-computer/iroh">iroh</a> and <a href="https://webrtc.org/">WebRTC</a> use <a href="https://tailscale.com/blog/how-nat-traversal-works">UDP Hole Punching to create Peer-to-Peer (P2P) connections</a> between nodes without relaying traffic. <sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p>
<p>If that worked then my server would only need to exchange a tiny bit of information per session and hopefully cost me very little ğŸ¤</p>
<p>Could I use P2P and funnel a terminal session over it? Well the Actions VM is on the internet and allows UDP outbound, so it should work!</p>
<p>A simple bit of scripting proved it did ğŸ¥³ With WebRTC, if the Actions VM and my local machine exchange information about their connectivity (<a href="https://webrtc.org/getting-started/peer-connections#ice_candidates">ICE Candidates</a>), then I could form a connection.<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></p>
<h2 id="security-and-identities">Security and Identities</h2>
<p>The next problem is, <strong>how do you prove each end of the P2P connection is who they say they are?</strong></p>
<p>Itâ€™s important. I want to ensure that <code>lawrencegripper</code> can only access terminals for Actions triggered by <code>lawrencegripper</code>.</p>
<p>The browser side is relatively easy, we can use OAuth to login via GitHub and get a verified username âœ…</p>
<p>On the Actions VM <a href="https://docs.github.com/en/actions/concepts/security/openid-connect">we have OIDC</a>, commonly used to auth from Actions to cloud providers.</p>
<p>Anyone can use it though, it gives us the ability to issue a signed OIDC token from within our Action which proves:</p>
<ol>
<li>The repo itâ€™s running on</li>
<li>The user account that triggered it</li>
<li>The audience it is intended for</li>
</ol>
<p>To enable this feature you set the following permissions in the workflow</p>

<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>    </span><span>permissions</span><span>:</span><span>
</span></span></span><span><span><span>      </span><span>id-token</span><span>:</span><span> </span><span>write</span></span></span></code></pre></div>

<p>You request a token via a REST request in the action, for example:</p>

<div><pre tabindex="0"><code data-lang="typescript"><span><span>    <span>const</span> <span>requestURL</span> <span>=</span> <span>process</span><span>.</span><span>env</span><span>.</span><span>ACTIONS_ID_TOKEN_REQUEST_URL</span><span>;</span>
</span></span><span><span>    <span>const</span> <span>requestToken</span> <span>=</span> <span>process</span><span>.</span><span>env</span><span>.</span><span>ACTIONS_ID_TOKEN_REQUEST_TOKEN</span><span>;</span>
</span></span><span><span>    <span>const</span> <span>SERVER_URL</span> <span>=</span> <span>&#39;https://actions-term.gripdev.xyz&#39;</span><span>;</span>
</span></span><span><span>    <span>const</span> <span>url</span> <span>=</span> <span>new</span> <span>URL</span><span>(</span><span>requestURL</span><span>);</span>
</span></span><span><span>    <span>url</span><span>.</span><span>searchParams</span><span>.</span><span>set</span><span>(</span><span>&#39;audience&#39;</span><span>,</span> <span>SERVER_URL</span><span>);</span>
</span></span><span><span>
</span></span><span><span>    <span>const</span> <span>resp</span> <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span>url</span><span>.</span><span>toString</span><span>(),</span> <span>{</span>
</span></span><span><span>        <span>headers</span><span>:</span> <span>{</span>
</span></span><span><span>        <span>Authorization</span><span>:</span> <span>`Bearer </span><span>${</span><span>requestToken</span><span>}</span><span>`</span><span>,</span>
</span></span><span><span>        <span>Accept</span><span>:</span> <span>&#39;application/json&#39;</span><span>,</span>
</span></span><span><span>        <span>},</span>
</span></span><span><span>    <span>});</span></span></span></code></pre></div>

<blockquote>
<p><a href="https://github.com/lawrencegripper/actions-term-on-fail/blob/21c8350bc33a4bf4451473eabecc9d7b2eedc716/client/src/index.ts#L35-L70">ğŸ”— code</a></p>
</blockquote>
<p>Then, when the Action calls our server, it can include this token. We can then validate it cryptographically via JWKS:</p>

<div><pre tabindex="0"><code data-lang="golang"><span><span><span>    </span><span>const</span><span> </span><span>githubOIDCIssuer</span><span> </span><span>=</span><span> </span><span>&#34;https://token.actions.githubusercontent.com&#34;</span><span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span><span>githubJWKSURL</span><span> </span><span>=</span><span> </span><span>&#34;https://token.actions.githubusercontent.com/.well-known/jwks&#34;</span><span>
</span></span></span><span><span><span>    </span><span>// Fetch JWKS</span><span>
</span></span></span><span><span><span>	</span><span>keySet</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>jwkCache</span><span>.</span><span>Get</span><span>(</span><span>ctx</span><span>,</span><span> </span><span>githubJWKSURL</span><span>)</span><span>
</span></span></span><span><span><span>	</span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>		</span><span>return</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;failed to fetch JWKS: %w&#34;</span><span>,</span><span> </span><span>err</span><span>)</span><span>
</span></span></span><span><span><span>	</span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>	</span><span>// Parse and validate token with clock skew tolerance</span><span>
</span></span></span><span><span><span>	</span><span>parseOpts</span><span> </span><span>:=</span><span> </span><span>[]</span><span>jwtx</span><span>.</span><span>ParseOption</span><span>{</span><span>
</span></span></span><span><span><span>		</span><span>jwtx</span><span>.</span><span>WithKeySet</span><span>(</span><span>keySet</span><span>),</span><span>
</span></span></span><span><span><span>		</span><span>jwtx</span><span>.</span><span>WithIssuer</span><span>(</span><span>githubOIDCIssuer</span><span>),</span><span>
</span></span></span><span><span><span>		</span><span>jwtx</span><span>.</span><span>WithValidate</span><span>(</span><span>true</span><span>),</span><span>
</span></span></span><span><span><span>		</span><span>jwtx</span><span>.</span><span>WithAcceptableSkew</span><span>(</span><span>2</span><span> </span><span>*</span><span> </span><span>time</span><span>.</span><span>Minute</span><span>),</span><span>
</span></span></span><span><span><span>		</span><span>jwtx</span><span>.</span><span>WithAudience</span><span>(</span><span>oidcExpectedAudience</span><span>),</span><span>
</span></span></span><span><span><span>	</span><span>}</span><span>
</span></span></span><span><span><span>	</span><span>token</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>jwtx</span><span>.</span><span>Parse</span><span>([]</span><span>byte</span><span>(</span><span>tokenStr</span><span>),</span><span> </span><span>parseOpts</span><span>...</span><span>)</span><span>
</span></span></span><span><span><span>	</span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>		</span><span>return</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;token validation failed: %w&#34;</span><span>,</span><span> </span><span>err</span><span>)</span><span>
</span></span></span><span><span><span>	</span><span>}</span></span></span></code></pre></div>

<blockquote>
<p><a href="https://github.com/lawrencegripper/actions-term-on-fail/blob/main/server/main.go#L173-L221">ğŸ”— code</a></p>
</blockquote>
<h2 id="connecting-the-peers-ie-signaling-server">Connecting the Peers (ie. <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Connectivity#signaling">Signaling Server</a>)</h2>
<p>At this point we know:</p>
<ol>
<li>We can create a connection between two peers (Actions VM &lt;-&gt; Users Browser) with WebRTC</li>
<li>We have a way to validate the identity of both ends of the connection (OAuth and OIDC)</li>
</ol>
<p>Whatâ€™s left is the server to introduce the two peers ğŸ¤ Letâ€™s build a server to do that.</p>
<p>The server doesnâ€™t need to handle the terminal data, that goes between the two peers directly, itâ€™s only doing introductions.</p>
<p>When the VM and Browser are connected to the server it should send each one the connection details for the other.</p>
<p>To do this, the browser and the VM both create <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">Server-sent events (SSE)</a> connections, allowing the signaling server to push events to them. They prove their identities by providing their OAuth credentials or OIDC to prove their identity.</p>
<p>The server then stores:</p>

<div><pre tabindex="0"><code data-lang="golang"><span><span><span>	</span><span>runIdToSessions</span><span>            </span><span>=</span><span> </span><span>make</span><span>(</span><span>map</span><span>[</span><span>string</span><span>]</span><span>*</span><span>Session</span><span>)</span><span> </span><span>// runId -&gt; session</span><span>
</span></span></span><span><span><span>	</span><span>runIdToSessionsMu</span><span>          </span><span>sync</span><span>.</span><span>RWMutex</span><span>
</span></span></span><span><span><span>	</span><span>runIdRunnerSseClient</span><span>       </span><span>=</span><span> </span><span>make</span><span>(</span><span>map</span><span>[</span><span>string</span><span>]</span><span>*</span><span>SSEClient</span><span>)</span><span> </span><span>// runId -&gt; SSE client (Actions VM)</span><span>
</span></span></span><span><span><span>	</span><span>runIdRunnerSseClientsMu</span><span>    </span><span>sync</span><span>.</span><span>RWMutex</span><span>
</span></span></span><span><span><span>	</span><span>actorToBrowserSseClients</span><span>   </span><span>=</span><span> </span><span>make</span><span>(</span><span>map</span><span>[</span><span>string</span><span>][]</span><span>*</span><span>SSEClient</span><span>)</span><span> </span><span>// actor -&gt; list of browser SSE clients</span><span>
</span></span></span><span><span><span>	</span><span>actorToBrowserSseClientsMu</span><span> </span><span>sync</span><span>.</span><span>RWMutex</span></span></span></code></pre></div>

<p>The server then, via SSE, sends the Actions VM connectivity details to the browser and the Browserâ€™s connectivity details to the Actions VM.</p>
<p>At this point they establish the Peer-to-Peer connection ğŸ¥³</p>
<p>For bonus points, when a new Actions VM connects, I can see if a browser is open waiting and send them a notification.</p>

<div><pre tabindex="0"><code data-lang="golang"><span><span><span>	</span><span>runIdRunnerSseClientsMu</span><span>.</span><span>Lock</span><span>()</span><span>
</span></span></span><span><span><span>	</span><span>runIdRunnerSseClient</span><span>[</span><span>runId</span><span>]</span><span> </span><span>=</span><span> </span><span>client</span><span>
</span></span></span><span><span><span>	</span><span>log</span><span>.</span><span>Printf</span><span>(</span><span>&#34;SSE: Runner connected for actor %s (total clients: %d)&#34;</span><span>,</span><span> </span><span>actor</span><span>,</span><span> </span><span>len</span><span>(</span><span>runIdRunnerSseClient</span><span>))</span><span>
</span></span></span><span><span><span>	</span><span>runIdRunnerSseClientsMu</span><span>.</span><span>Unlock</span><span>()</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>	</span><span>// Notify browser subscribers about new session</span><span>
</span></span></span><span><span><span>	</span><span>sess</span><span>,</span><span> </span><span>ok</span><span> </span><span>:=</span><span> </span><span>runIdToSessions</span><span>[</span><span>runId</span><span>]</span><span>
</span></span></span><span><span><span>	</span><span>if</span><span> </span><span>ok</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>		</span><span>notifyNewSession</span><span>(</span><span>sess</span><span>)</span><span>
</span></span></span><span><span><span>	</span><span>}</span></span></span></code></pre></div>

<blockquote>
<p><a href="https://github.com/lawrencegripper/actions-term-on-fail/blob/255c79feee7d2cbb854144409a93bdd3a03fcdb4/server/main.go#L262-L271">ğŸ”— Code</a></p>
</blockquote>
<h2 id="displaying-the-terminal">Displaying the Terminal</h2>
<p>Ok, weâ€™re close now. We have the signaling server to exchange details and then the peers have a p2p connection.</p>
<p>What about creating a terminal and streaming the data?</p>
<p>WebRTC has a <code>datachannel</code> which you push arbitrary data through.</p>
<p>On the Actions VM side we create a <code>pty.Shell</code> and stream that data over our <code>datachannel (dc)</code></p>

<div><pre tabindex="0"><code data-lang="javascript"><span><span>    <span>shell</span> <span>=</span> <span>pty</span><span>.</span><span>spawn</span><span>(</span><span>SHELL</span><span>,</span> <span>[],</span> <span>{</span>
</span></span><span><span>        <span>name</span><span>:</span> <span>&#39;xterm-256color&#39;</span><span>,</span>
</span></span><span><span>        <span>cwd</span><span>:</span> <span>process</span><span>.</span><span>env</span><span>.</span><span>GITHUB_WORKSPACE</span> <span>||</span> <span>process</span><span>.</span><span>cwd</span><span>(),</span>
</span></span><span><span>        <span>env</span><span>:</span> <span>process</span><span>.</span><span>env</span> <span>as</span> <span>Record</span><span>&lt;</span><span>string</span><span>,</span> <span>string</span><span>&gt;</span><span>,</span>
</span></span><span><span>    <span>});</span>
</span></span><span><span>
</span></span><span><span>    <span>shell</span><span>.</span><span>onData</span><span>((</span><span>shellData</span><span>)</span> <span>=&gt;</span> <span>{</span>
</span></span><span><span>        <span>dc</span><span>.</span><span>sendMessage</span><span>(</span><span>shellData</span><span>);</span>
</span></span><span><span>    <span>});</span></span></span></code></pre></div>

<blockquote>
<p><a href="https://github.com/lawrencegripper/actions-term-on-fail/blob/6f46d09ac86757f72e74fe070bb4c7f745ea09c6/client/src/index.ts#L417-L423">code ğŸ”—</a></p>
</blockquote>
<p>In the browser we then need to display an interactive terminal.</p>
<p>Reading around, I found the this awesome <a href="https://github.com/coder/ghostty-web">Ghostty library</a>. It has an xterm.js compatible implementation, I hooked this up and it worked first time ğŸ¥°</p>
<p>Well it did.. and it didnâ€™t, the Terminal spawned via PTY doesnâ€™t have any idea how big our terminal in the browser (Lines and Columns) so we get some horrible rendering in the terminal.</p>
<p>With a bit of poking, googling and some Opus 4.5, I created a method which estimates the size of terminal, via font sizing, and converts this to a rough column / rows. Then, on establishing the P2P connection I can send a <code>setup</code> JSON message which the Actions VM uses to start <code>pty.spawn</code> with the right sizing for the terminal.</p>
<h2 id="were-done-right">Weâ€™re done, right?</h2>
<p>Not quite, at this point we have ğŸ‘‡</p>

<pre tabindex="0"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  GitHub Runner  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚    Browser      â”‚
â”‚  (TypeScript)   â”‚      Direct P2P (WebRTC)     â”‚  (ghostty-web)  â”‚
â”‚                 â”‚                              â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                                                â”‚
         â”‚ Register session                               â”‚ Get sessions
         â”‚ (OIDC Token Auth)                              â”‚ (GitHub OAuth)
         â–¼                                                â–¼
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚     Server      â”‚
                         â”‚   (Go - Auth    â”‚
                         â”‚   &amp; Discovery)  â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

<p>There is a lot of trust placed in the signaling server. It has to do the right thing, or it could provide access to someone elseâ€™s Actions VM.</p>
<p>Letâ€™s do better.</p>
<h2 id="trust-vs-zero-trust">Trust vs Zero-Trust</h2>
<p>Iâ€™ve mentioned already <strong>the signaling server should only connect up users with actions theyâ€™ve started</strong>.</p>
<p>That relies on explicit trust, from users, that Iâ€™m going to do the right thing.</p>
<p>What if Iâ€™ve got a bug? What if someone compromises the signaling server? What if they steal the domain and run their own server on it?</p>
<p>Well, then they could hook up peers that shouldnâ€™t be connected and â€¦ do mean things.</p>
<p>That sounds bad, lets work out how to fix that.</p>
<p>What if the <code>user</code> provided the Actions VM with a secret, that only they know?</p>
<p>When the P2P connection is made, the Actions VM could refuse to talk to the browser until it provides the right secret.</p>
<p>Secrets are cool and everything but if theyâ€™re intercepted theyâ€™re reusable, could we use a One-Time-Password (OTP) commonly used for 2FA on sites? Sure thing! Even better tools like 1Password will autofill it for you.</p>
<p>What does this flow look like? Roughly itâ€™s ğŸ‘‡</p>

<div><pre tabindex="0"><code data-lang="text"><span><span>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
</span></span><span><span>â”‚  GitHub Runner  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚    Browser      â”‚
</span></span><span><span>â”‚  (TypeScript)   â”‚      Direct P2P (WebRTC)     â”‚  (ghostty-web)  â”‚
</span></span><span><span>â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</span></span><span><span>         â”‚                                                â”‚
</span></span><span><span>         â”‚â—„â”€â”€â”€â”€â”€ 1. WebRTC Connection Established â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
</span></span><span><span>         â”‚                                                â”‚
</span></span><span><span>         â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 2. Browser sends OTP â”€â”€â”€â”€â”€â”€ â”€â”€â”€â”€â”€â”€â”€â”‚
</span></span><span><span>         â”‚                                                â”‚
</span></span><span><span>         â”‚  3. Runner validates OTP against secret        â”‚
</span></span><span><span>         â”‚                                                â”‚
</span></span><span><span>         â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
</span></span><span><span>         â”‚              â”‚  If OTP Valid:   â”‚              â”‚
</span></span><span><span>         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  4. Terminal     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
</span></span><span><span>                        â”‚     access       â”‚
</span></span><span><span>                        â”‚     granted      â”‚
</span></span><span><span>                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span></span></code></pre></div>

<p>Even if the signaling server is manipulated, to hook up two peers which shouldnâ€™t be connected, the user wonâ€™t be able to execute commands unless they can provide a valid OTP.</p>
<p>Better still the Signaling server (which I run) is never sent either the OTP or the OTP Secret used to validate each OTP.</p>
<p>This validation happens between two peers you own (Actions VM and your Browser).</p>
<h2 id="so-now-were-done">So now weâ€™re done?</h2>
<p>One last thingâ€¦ make the signaling server cheap to host.</p>
<p>I want to offer this for free for anyone to use. Itâ€™s a simple <code>go</code> binary in a docker image (to make it easy to self-hosting and test locally) but it needs to live on the internet.</p>
<p>A while ago Iâ€™d started poking at <a href="https://railway.com/">railway.com</a>, itâ€™s cloud with a big billing twist, <strong>you only pay for the CPU and Memory you actually use</strong>. This felt like a great time to try it out.</p>
<p>How is the billing different, wellâ€¦</p>
<ul>
<li>In Azure/AWS I have to say â€œI want 2 CPUs and 8GBâ€ and I pay for that regardless of what I use.</li>
<li>On <a href="https://railway.com/">railway.com</a> I say â€œUse <strong>up to</strong> x CPUs and y GBâ€ then you only pay for what the service actually consumes.</li>
</ul>
<blockquote>
<p>Note: In either Azure/AWS or Railway you still pay network egress.</p>
</blockquote>
<p>How does this work out for the signaling server?</p>
<p><strong>Really well</strong> itâ€™s peak memory usage so far is 20MB, racking up a mean $0.00000â€¦ you get the point. Itâ€™s not costing much, as Iâ€™m not reserving a small machine with GBs of mem to run a service needing 20MB</p>
<p><img src="https://blog.gripdev.xyz/2026/01/10/actions-terminal-on-failure-for-debugging/memory-usage.png" alt="Graph showing 20mb of memory"/></p>
<p>Even then it feels a bit wasteful running it all the time. There will be chunks of time when folks arenâ€™t using it.</p>
<p>This was where I found a platform feature called <a href="https://docs.railway.com/reference/app-sleeping">sleeping</a>, itâ€™s serverless but without the pain of moving away from the docker model to some proprietary runtime.</p>
<p>When the service isnâ€™t doing anything, Railway spin down the service. If someone turns up, they hold the connection for a moment while restoring the container, then send the request through.</p>
<p>What does a cold start look like on our simple signalling server? Itâ€™s hardly recognizable.</p>
<p>Here is a recording, on the left you see the server is sleeping and on the right I hit the domain, there is a slight pause before the page renders âœ¨</p>
<video preload="metadata" controls="">
    <source src="/2026/01/10/actions-terminal-on-failure-for-debugging/sleep.mp4" type="video/mp4"/>
    Your browser does not support the video element.
  </video>



            </div>
        </article></main>
</div></div>
  </body>
</html>
