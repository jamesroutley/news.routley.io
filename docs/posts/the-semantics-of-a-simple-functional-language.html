<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lawrencecpaulson.github.io/2023/03/08/Fun_Semantics.html">Original</a>
    <h1>The semantics of a simple functional language</h1>
    
    <div id="readability-page-1" class="page"><section>

      
<p>08 Mar 2023</p>

<span>[
  
    
    <a href="https://lawrencecpaulson.github.io/tag/examples"><code><nobr>examples</nobr></code> </a>
  
    
    <a href="https://lawrencecpaulson.github.io/tag/Isabelle"><code><nobr>Isabelle</nobr></code> </a>
  
    
    <a href="https://lawrencecpaulson.github.io/tag/inductive_definitions"><code><nobr>inductive definitions</nobr></code> </a>
  
]</span>

<p>The simplest way to precisely specify the meanings of programming language expressions
is through an <a href="https://en.wikipedia.org/wiki/Operational_semantics">operational semantics</a>.
Such a definition consists of a set of what look like the inference rules
of a logic, stating the conditions under which a given expression
can be reduced to a value, or at least evaluated one step more.
Formally, this sort of specification is an <em>inductive definition</em>,
equipped with an induction principle for proving that a property
holds for all executions.
Such proofs are conceptually trivial—they involve checking
that the property holds
initially and that it is preserved 
by each execution step—but are extremely tedious to write out by hand.
Fortunately, they are often trivial with the help of a little automation.
Let’s prove a <a href="https://en.wikipedia.org/wiki/Church–Rosser_theorem">Church–Rosser property</a>:
that expression evaluation always leads to a unique final result.</p>

<h3 id="a-simple-functional-language">A simple functional language</h3>

<p>Our language is insufficient to write an airline reservation system—it isn’t even
Turing-complete—but it is sufficient to illustrate some of the core themes of operational semantics.</p>

<p>Let’s begin with the syntax. An expression can be a Boolean
(true or false), or a natural number given by zero or successor,
or a conditional expression, or an equality test:</p>

<pre><span>datatype</span> exp <span>=</span> T <span>|</span> F <span>|</span> Zero <span>|</span> Succ <span>exp</span> <span>|</span> IF <span>exp</span> <span>exp</span> <span>exp</span> <span>|</span> EQ <span>exp</span> <span>exp</span>
</pre>

<p>Next we define the operational semantics itself, which takes the form
of a reduction relation (⇛). We use an Isabelle/HOL inductive definition.
The first two rules cover the true and false cases of a conditional expression,
while the third case takes care of a single reduction within the condition.
The fourth rule covers the evaluation of the argument of <code>Succ</code>.
So this is a <a href="https://en.wikipedia.org/wiki/Operational_semantics#Small-step_semantics">small-step semantics</a>; 
in a big-step semantics, every rule would be formulated
to deliver the final result.</p>

<pre><span>inductive</span> <span>Eval</span> <span>::</span> <span><span><span>&#34;</span>exp</span> <span>⇒</span> exp</span> <span>⇒</span> bool<span>&#34;</span> <span>(</span><span>infix</span> <span><span>&#34;</span><span>⇛</span><span>&#34;</span></span> 50<span>)</span> <span>where</span><span>
    </span>IF_T<span>:</span>    <span><span><span>&#34;</span>IF</span> T</span> <span>x</span> <span>y</span> <span>⇛</span> <span>x</span><span>&#34;</span><span>
  </span><span>|</span> IF_F<span>:</span>    <span><span><span>&#34;</span>IF</span> F</span> <span>x</span> <span>y</span> <span>⇛</span> <span>y</span><span>&#34;</span><span>
  </span><span>|</span> IF_Eval<span>:</span> <span><span><span>&#34;</span><span>p</span> <span>⇛</span> <span>q</span> <span>⟹</span> IF</span> <span>p</span> <span>x</span> <span>y</span> <span>⇛</span> IF</span> <span>q</span> <span>x</span> <span>y</span><span>&#34;</span><span>
  </span><span>|</span> Succ_Eval<span>:</span> <span><span><span>&#34;</span><span>x</span> <span>⇛</span> <span>y</span> <span>⟹</span> Succ</span> <span>x</span> <span>⇛</span> Succ</span> <span>y</span><span>&#34;</span><span>
  </span><span>|</span> EQ_same<span>:</span> <span><span><span>&#34;</span>EQ</span> <span>x</span> <span>x</span> <span>⇛</span> T</span><span>&#34;</span><span>
  </span><span>|</span> EQ_S0<span>:</span>   <span><span><span>&#34;</span>EQ</span> <span>(</span>Succ</span> <span>x</span><span>)</span> Zero <span>⇛</span> F<span>&#34;</span><span>
  </span><span>|</span> EQ_0S<span>:</span>   <span><span><span>&#34;</span>EQ</span> Zero</span> <span>(</span>Succ <span>y</span><span>)</span> <span>⇛</span> F<span>&#34;</span><span>
  </span><span>|</span> EQ_SS<span>:</span>   <span><span><span>&#34;</span>EQ</span> <span>(</span>Succ</span> <span>x</span><span>)</span> <span>(</span>Succ <span>y</span><span>)</span> <span>⇛</span> EQ <span>x</span> <span>y</span><span>&#34;</span><span>
  </span><span>|</span> EQ_Eval1<span>:</span> <span><span><span>&#34;</span><span>x</span> <span>⇛</span> <span>z</span> <span>⟹</span> EQ</span> <span>x</span> <span>y</span> <span>⇛</span> EQ</span> <span>z</span> <span>y</span><span>&#34;</span><span>
  </span><span>|</span> EQ_Eval2<span>:</span> <span><span><span>&#34;</span><span>y</span> <span>⇛</span> <span>z</span> <span>⟹</span> EQ</span> <span>x</span> <span>y</span> <span>⇛</span> EQ</span> <span>x</span> <span>z</span><span>&#34;</span>
</pre>

<p>The remaining six rules concern the evaluation of equality tests.
I specifically designed them to be messy.</p>

<h3 id="rule-inversion">Rule inversion</h3>

<p>The language admits nonsensical terms such as <code>Succ T</code>, which cannot be reduced to anything.
How do we know that? Intuitively, it’s because there is only one rule for evaluating<code>Succ</code>; 
that rule evaluates the argument, and there is no rule for evaluating <code>T</code>.
This straightforward reasoning can fortunately be automated.
The following declarations inform Isabelle’s simplifier about the possibilities of
various reductions occurring. In particular, the first three
generate theorems stating that the quoted reductions are impossible.
In other cases, the resulting theorems state conditions under which the reduction can take place,
 e.g.</p>

<blockquote>
  <p><code>(Succ ?x ⇛ ?z) = (∃y. ?z = Succ y ∧ ?x ⇛ y)</code></p>
</blockquote>

<pre><span>inductive_simps</span> T_simp <span>[</span><span>simp</span><span>]</span><span>:</span> <span><span><span>&#34;</span>T</span> <span>⇛</span></span> <span>z</span><span>&#34;</span><span>
</span><span>inductive_simps</span> F_simp <span>[</span><span>simp</span><span>]</span><span>:</span> <span><span><span>&#34;</span>F</span> <span>⇛</span></span> <span>z</span><span>&#34;</span><span>
</span><span>inductive_simps</span> Zero_simp <span>[</span><span>simp</span><span>]</span><span>:</span> <span><span><span>&#34;</span>Zero</span> <span>⇛</span></span> <span>z</span><span>&#34;</span><span>
</span><span>inductive_simps</span> Succ_simp <span>[</span><span>simp</span><span>]</span><span>:</span> <span><span><span>&#34;</span>Succ</span> <span>x</span> <span>⇛</span></span> <span>z</span><span>&#34;</span><span>
</span><span>inductive_simps</span> IF_simp <span>[</span><span>simp</span><span>]</span><span>:</span> <span><span><span>&#34;</span>IF</span> <span>p</span> <span>x</span> <span>y</span> <span>⇛</span></span>  <span>z</span><span>&#34;</span><span>
</span><span>inductive_simps</span> EQ_simp <span>[</span><span>simp</span><span>]</span><span>:</span> <span><span><span>&#34;</span>EQ</span> <span>x</span> <span>y</span> <span>⇛</span></span> <span>z</span><span>&#34;</span>
</pre>

<p>Such declarations are useful in any inductive definition where the conclusions of the rules
allow most of the cases to be excluded on syntactic grounds.
If your proofs seem to require a lot of explicit case analysis, 
see whether this sort of declaration could help you.</p>

<h3 id="types-and-type-preservation">Types and type preservation</h3>

<p>Our language has Booleans and natural numbers, so let’s define the corresponding type system.
(It will be simpler than Martin-Löf type theory.)</p>

<pre><span>datatype</span> tp <span>=</span> bool <span>|</span> num
</pre>

<p>The great thing about operational semantics is its flexibility.
Above, we defined the evaluation of expressions, which is their dynamic behaviour;
now we can define their typing relation, which is static behaviour.
The same techniques work for both.</p>

<p>True and false have the Boolean type, while zero is a number.
<code>Succ</code> yields a number if its argument does.
For conditional expressions and equality, the use of types has to be consistent.</p>

<pre><span>inductive</span> <span>TP</span> <span>::</span> <span><span><span>&#34;</span>exp</span> <span>⇒</span> tp</span> <span>⇒</span> bool<span>&#34;</span> <span>where</span><span>
  </span>T<span>:</span>    <span><span><span>&#34;</span><span>TP</span> T</span> bool</span><span>&#34;</span><span>
</span><span>|</span> F<span>:</span>    <span><span><span>&#34;</span><span>TP</span> F</span> bool</span><span>&#34;</span><span>
</span><span>|</span> Zero<span>:</span> <span><span><span>&#34;</span><span>TP</span> Zero</span> num</span><span>&#34;</span><span>
</span><span>|</span> IF<span>:</span>   <span><span><span>&#34;</span><span>⟦</span><span>TP</span> <span>p</span> bool</span><span>;</span> <span>TP</span> <span>x</span> <span>t</span><span>;</span> <span>TP</span> <span>y</span> <span>t</span><span>⟧</span> <span>⟹</span> <span>TP</span> <span>(</span>IF</span> <span>p</span> <span>x</span> <span>y</span><span>)</span> <span>t</span><span>&#34;</span><span>
</span><span>|</span> Succ<span>:</span> <span><span><span>&#34;</span><span>TP</span> <span>x</span> num</span> <span>⟹</span> <span>TP</span> <span>(</span>Succ</span> <span>x</span><span>)</span> num<span>&#34;</span><span>
</span><span>|</span> EQ<span>:</span>   <span><span><span>&#34;</span><span>⟦</span><span>TP</span> <span>x</span> <span>t</span><span>;</span> <span>TP</span> <span>y</span> <span>t</span><span>⟧</span> <span>⟹</span> <span>TP</span> <span>(</span>EQ</span> <span>x</span> <span>y</span><span>)</span> bool</span><span>&#34;</span>
</pre>

<p>Rule inversion for the above lets us reason easility about
the type-checking possibilities for expressions.</p>

<pre><span>inductive_simps</span> TP_IF <span>[</span><span>simp</span><span>]</span><span>:</span> <span><span><span>&#34;</span>TP</span> <span>(</span>IF</span> <span>p</span> <span>x</span> <span>y</span><span>)</span> <span>t</span><span>&#34;</span><span>
</span><span>inductive_simps</span> TP_Succ <span>[</span><span>simp</span><span>]</span><span>:</span> <span><span><span>&#34;</span>TP</span> <span>(</span>Succ</span> <span>x</span><span>)</span> <span>t</span><span>&#34;</span><span>
</span><span>inductive_simps</span> TP_EQ <span>[</span><span>simp</span><span>]</span><span>:</span> <span><span><span>&#34;</span>TP</span> <span>(</span>EQ</span> <span>x</span> <span>y</span><span>)</span> <span>t</span><span>&#34;</span>
</pre>

<p><a href="https://en.wikipedia.org/wiki/Subject_reduction"><em>Type preservation</em></a> 
claims that the evaluation of an expression does not change its type.
Formally, we state that if <code>x ⇛ y</code> and <code>x</code> has some type <code>T</code>, then <code>y</code> will have the same type.
Induction on the assumption <code>x ⇛ y</code> produces 10 gruesome-looking subgoals:</p>

<blockquote>
  <p><code>1. ⋀x y t. TP (IF T x y) t ⟹ TP x t</code></p>
</blockquote>

<blockquote>
  <p><code>2. ⋀x y t. TP (IF F x y) t ⟹ TP y t</code></p>
</blockquote>

<blockquote>
  <p><code>3. ⋀p q x y t. ⟦p ⇛ q; ⋀t. TP p t ⟹ TP q t; TP (IF p x y) t⟧ ⟹ TP (IF q x y) t</code></p>
</blockquote>

<blockquote>
  <p><code>4. ⋀x y t. ⟦x ⇛ y; ⋀t. TP x t ⟹ TP y t; TP (Succ x) t⟧ ⟹ TP (Succ y) t</code></p>
</blockquote>

<blockquote>
  <p><code>5. ⋀x t. TP (EQ x x) t ⟹ TP T t</code></p>
</blockquote>

<blockquote>
  <p><code>6. ⋀x t. TP (EQ (Succ x) Zero) t ⟹ TP F t</code></p>
</blockquote>

<blockquote>
  <p><code>7. ⋀y t. TP (EQ Zero (Succ y)) t ⟹ TP F t</code></p>
</blockquote>

<blockquote>
  <p><code>8. ⋀x y t. TP (EQ (Succ x) (Succ y)) t ⟹ TP (EQ x y) t</code></p>
</blockquote>

<blockquote>
  <p><code>9. ⋀x z y t. ⟦x ⇛ z; ⋀t. TP x t ⟹ TP z t; TP (EQ x y) t⟧ ⟹ TP (EQ z y) t</code></p>
</blockquote>

<blockquote>
  <p><code>10. ⋀y z x t. ⟦y ⇛ z; ⋀t. TP y t ⟹ TP z t; TP (EQ x y) t⟧ ⟹ TP (EQ x z) t</code></p>
</blockquote>

<p>Some courses in operational semantics expect students to be able to carry out 
such proofs by hand. But even writing out the subgoals perfectly by hand is next to impossible.
Fortunately they are trivial to prove, with the help of rule inversion.
The Isabelle/HOL proof takes a single line, which executes instantly:</p>

<pre><span>proposition</span> type_preservation<span>:</span><span>
  </span><span>assumes</span> <span><span><span>&#34;</span><span>x</span> <span>⇛</span></span> <span>y</span><span>&#34;</span></span> <span><span><span>&#34;</span>TP</span> <span>x</span> <span>t</span><span>&#34;</span></span> <span>shows</span> <span><span><span>&#34;</span>TP</span> <span>y</span> <span>t</span><span>&#34;</span></span><span>
  </span><span>using</span> assms<span>
  </span><span>by</span> <span>(</span><span>induction</span> <span>x</span> <span>y</span> <span>arbitrary</span><span>:</span> <span>t</span> <span>rule</span><span>:</span> Eval.induct<span>)</span> <span>(</span><span>auto</span> <span>simp</span><span>:</span> TP.intros<span>)</span>
</pre>

<p>A couple of fine points in the proof:</p>

<ul>
  <li>designating the variable <code>t</code> as arbitrary allows for the type of subexpressions to differ from the type of the top expression</li>
  <li>you can give two proof methods to the <span>by</span> command</li>
</ul>

<h3 id="values-and-value-preservation">Values and value preservation</h3>

<p>We can interpret the operators of our simple language in terms of the natural numbers.
In particular, true and false denote 1 and zero, respectively. We can also give the semantics
of conditional expressions and equality tests. 
This is a trivial example of a <a href="https://en.wikipedia.org/wiki/Denotational_semantics">denotational semantics</a>.</p>

<pre><span>fun</span> <span>evl</span> <span>::</span> <span><span><span>&#34;</span>exp</span> <span>⇒</span> nat</span><span>&#34;</span><span>
  </span><span>where</span><span>
    </span><span><span><span>&#34;</span><span>evl</span> T</span> <span>=</span></span> <span>1</span><span>&#34;</span><span>
  </span><span>|</span> <span><span><span>&#34;</span><span>evl</span> F</span> <span>=</span></span> <span>0</span><span>&#34;</span><span>
  </span><span>|</span> <span><span><span>&#34;</span><span>evl</span> Zero</span> <span>=</span></span> <span>0</span><span>&#34;</span><span>
  </span><span>|</span> <span><span><span>&#34;</span><span>evl</span> <span>(</span>Succ</span> <span>x</span><span>)</span> <span>=</span></span> <span>evl</span> <span>x</span> <span>+</span> <span>1</span><span>&#34;</span><span>
  </span><span>|</span> <span><span><span>&#34;</span><span>evl</span> <span>(</span>IF</span> <span>x</span> <span>y</span> <span>z</span><span>)</span> <span>=</span></span> <span>(</span><span>if</span> <span>evl</span> <span>x</span> <span>=</span> <span>1</span> <span>then</span> <span>evl</span> <span>y</span> <span>else</span> <span>evl</span> <span>z</span><span>)</span><span>&#34;</span><span>
  </span><span>|</span> <span><span><span>&#34;</span><span>evl</span> <span>(</span>EQ</span> <span>x</span> <span>y</span><span>)</span> <span>=</span></span> <span>(</span><span>if</span> <span>evl</span> <span>x</span> <span>=</span> <span>evl</span> <span>y</span> <span>then</span> <span>1</span> <span>else</span> <span>0</span><span>)</span><span>&#34;</span>
</pre>

<p>Value preservation is the claim that the evaluation of an expression does not change its value.</p>

<pre><span>proposition</span> value_preservation<span>:</span><span>
  </span><span>assumes</span> <span><span><span>&#34;</span><span>x</span> <span>⇛</span></span> <span>y</span><span>&#34;</span></span> <span>shows</span> <span><span><span>&#34;</span>evl</span> <span>x</span> <span>=</span></span> evl <span>y</span><span>&#34;</span><span>
  </span><span>using</span> assms <span>by</span> <span>(</span><span>induction</span> <span>x</span> <span>y</span><span>;</span> <span>force</span><span>)</span>
</pre>

<p>Here we relate types and values. The value of a Boolean expression is less than 2.</p>

<pre><span>lemma</span><span>
  </span><span>assumes</span> <span><span><span>&#34;</span>TP</span> <span>x</span> <span>t</span><span>&#34;</span></span> <span><span><span>&#34;</span><span>t</span> <span>=</span></span> bool</span><span>&#34;</span> <span>shows</span> <span><span><span>&#34;</span>evl</span> <span>x</span> <span>&lt;</span></span> <span>2</span><span>&#34;</span><span>
  </span><span>using</span> assms <span>by</span> <span>(</span><span>induction</span> <span>x</span> <span>t</span><span>;</span> <span>force</span><span>)</span>
</pre>

<h3 id="proving-a-churchrosser-property">Proving a Church–Rosser property</h3>

<p>The Church–Rosser theorem concerns the λ-calculus and in effect states that multiple
evaluation routes cannot yield multiple final values. It’s necessary because
in the λ-calculus it’s possible to reduce some expressions in more than one way.
Our language has the same problem. For example, four different rules are applicable
to some expressions of the form <code>EQ (Succ x) (Succ y)</code>.</p>

<p>Some care is needed when expressing a Church–Rosser property.
The following does not hold:</p>

<pre><span>lemma</span><span>
  </span><span>assumes</span> <span><span><span>&#34;</span><span>x</span> <span>⇛</span></span> <span>y</span><span>&#34;</span></span> <span><span><span>&#34;</span><span>x</span> <span>⇛</span></span> <span>z</span><span>&#34;</span></span> <span>shows</span> <span><span><span>&#34;</span><span>∃</span></span><span>u</span><span>.</span></span> <span>y</span> <span>⇛</span> <span>u</span> <span>∧</span> <span>z</span> <span>⇛</span> <span>u</span><span>&#34;</span><span>
  </span><span>nitpick</span>
</pre>

<p>The counterexample returned by <span>nitpick</span> is <code>IF F F F</code>.
The property fails simply because <code>F</code> cannot reduce, which is not really what we are worried about here.
To express Church–Rosser properly, we need the transitive closure of the reduction relation.
(We could also have used the built-in transitive closure operator.)</p>

<pre><span>inductive</span> <span>EvalStar</span> <span>::</span> <span><span><span>&#34;</span>exp</span> <span>⇒</span> exp</span> <span>⇒</span> bool<span>&#34;</span> <span>(</span><span>infix</span> <span><span>&#34;</span><span>⇛*</span><span>&#34;</span></span> 50<span>)</span> <span>where</span><span>
    </span>Id<span>:</span> <span><span>&#34;</span><span>x</span> <span>⇛*</span> <span>x</span><span>&#34;</span></span><span>
  </span><span>|</span> Step<span>:</span> <span><span><span>&#34;</span><span>x</span> <span>⇛</span></span> <span>y</span> <span>⟹</span> <span>y</span> <span>⇛*</span> <span>z</span> <span>⟹</span> <span>x</span> <span>⇛*</span> <span>z</span><span>&#34;</span></span>
</pre>

<p>The following lemma is just a warmup.
We show that the type is preserved even over a string of evaluation steps.</p>

<pre><span>proposition</span> type_preservation_Star<span>:</span><span>
  </span><span>assumes</span> <span><span><span>&#34;</span><span>x</span> <span>⇛*</span></span> <span>y</span><span>&#34;</span></span> <span><span><span>&#34;</span>TP</span> <span>x</span> <span>t</span><span>&#34;</span></span> <span>shows</span> <span><span><span>&#34;</span>TP</span> <span>y</span> <span>t</span><span>&#34;</span></span><span>
  </span><span>using</span> assms<span>
  </span><span>by</span> <span>(</span><span>induction</span> <span>x</span> <span>y</span><span>)</span> <span>(</span><span>auto</span> <span>simp</span><span>:</span> type_preservation<span>)</span>
</pre>

<p>On the other hand, the following four lemmas are essential.
Each of them transforms a string of evaluation steps into the analogous string of steps
within an argument of some function.
All these proofs are trivial inductions.</p>

<pre><span>lemma</span> Succ_EvalStar<span>:</span><span>
  </span><span>assumes</span> <span><span><span>&#34;</span><span>x</span> <span>⇛*</span></span> <span>y</span><span>&#34;</span></span> <span>shows</span> <span><span><span>&#34;</span>Succ</span> <span>x</span> <span>⇛*</span></span> Succ <span>y</span><span>&#34;</span><span>
  </span><span>using</span> assms <span>by</span> <span>induction</span> <span>(</span><span>auto</span> <span>intro</span><span>:</span> Succ_Eval EvalStar.intros<span>)</span>
</pre>

<pre><span>lemma</span> IF_EvalStar<span>:</span><span>
  </span><span>assumes</span> <span><span><span>&#34;</span><span>p</span> <span>⇛*</span></span> <span>q</span><span>&#34;</span></span> <span>shows</span> <span><span><span>&#34;</span>IF</span> <span>p</span> <span>x</span> <span>y</span> <span>⇛*</span></span> IF <span>q</span> <span>x</span> <span>y</span><span>&#34;</span><span>
  </span><span>using</span> assms <span>by</span> <span>induction</span> <span>(</span><span>auto</span> <span>intro</span><span>:</span> IF_Eval EvalStar.intros<span>)</span>
</pre>

<pre><span>lemma</span> EQ_EvalStar1<span>:</span><span>
  </span><span>assumes</span> <span><span><span>&#34;</span><span>x</span> <span>⇛*</span></span> <span>z</span><span>&#34;</span></span> <span>shows</span> <span><span><span>&#34;</span>EQ</span> <span>x</span> <span>y</span> <span>⇛*</span></span> EQ <span>z</span> <span>y</span><span>&#34;</span><span>
  </span><span>using</span> assms <span>by</span> <span>induction</span> <span>(</span><span>auto</span> <span>intro</span><span>:</span> EQ_Eval1 EvalStar.intros<span>)</span>
</pre>

<pre><span>lemma</span> EQ_EvalStar2<span>:</span><span>
  </span><span>assumes</span> <span><span><span>&#34;</span><span>y</span> <span>⇛*</span></span> <span>z</span><span>&#34;</span></span> <span>shows</span> <span><span><span>&#34;</span>EQ</span> <span>x</span> <span>y</span> <span>⇛*</span></span> EQ <span>x</span> <span>z</span> <span>&#34;</span><span>
  </span><span>using</span> assms <span>by</span> <span>induction</span> <span>(</span><span>auto</span> <span>intro</span><span>:</span> EQ_Eval2 EvalStar.intros<span>)</span>
</pre>

<p>Finally we reach our destination. The diamond property is not the full
Church–Rosser claim, but it captures the main point:
that if some <code>x</code> can be reduced either to <code>y</code> or <code>z</code> in a single step,
then the evaluation strings can be extended to reunite at some common <code>u</code>.</p>

<pre><span>proposition</span> diamond<span>:</span><span>
  </span><span>assumes</span> <span><span><span>&#34;</span><span>x</span> <span>⇛</span></span> <span>y</span><span>&#34;</span></span> <span><span><span>&#34;</span><span>x</span> <span>⇛</span></span> <span>z</span><span>&#34;</span></span> <span>shows</span> <span><span><span>&#34;</span><span>∃</span></span><span>u</span><span>.</span></span> <span>y</span> <span>⇛*</span> <span>u</span> <span>∧</span> <span>z</span> <span>⇛*</span> <span>u</span><span>&#34;</span><span>
  </span><span>using</span> assms<span>
</span><span>proof</span> <span>(</span><span>induction</span> <span>x</span> <span>y</span> <span>arbitrary</span><span>:</span> <span>z</span><span>)</span><span>
  </span><span>case</span> <span>(</span>IF_Eval <span>p</span> <span>q</span> <span>x</span> <span>y</span><span>)</span><span>
  </span><span>then</span> <span>show</span> <span>?case</span><span>
    </span><span>by</span> <span>simp</span><span>;</span> <span>meson</span> F_simp IF_EvalStar T_simp<span>)</span><span>
</span><span>next</span><span>
  </span><span>case</span> <span>(</span>EQ_SS <span>x</span> <span>y</span><span>)</span><span>
  </span><span>then</span> <span>show</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>simp</span><span>;</span> <span>meson</span> Eval.intros EvalStar.intros<span>)</span><span>
</span><span>next</span><span>
  </span><span>case</span> <span>(</span>EQ_Eval1 <span>x</span> <span>u</span> <span>y</span><span>)</span><span>
  </span><span>then</span> <span>show</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>auto</span><span>;</span> <span>meson</span> EQ_EvalStar1 Eval.intros EvalStar.intros<span>)</span><span>+</span><span>
</span><span>next</span><span>
    </span><span>case</span> <span>(</span>EQ_Eval2 <span>y</span> <span>u</span> <span>x</span><span>)</span><span>
  </span><span>then</span> <span>show</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>auto</span><span>;</span> <span>meson</span> EQ_EvalStar2 Eval.intros EvalStar.intros<span>)</span><span>+</span><span>
</span><span>qed</span> <span>(</span><span>force</span> <span>intro</span><span>:</span> Succ_EvalStar Eval.intros EvalStar.intros<span>)</span><span>+</span>
</pre>

<p>Finally, a nontrivial proof! I’ve tried to make it neat, but it’s 
a mess. You could download the
<a href="https://lawrencecpaulson.github.io/Isabelle-Examples/Fun_Semantics.thy">Isabelle theory file</a>
and see if you can do it better.</p>

<h3 id="postscript">Postscript</h3>

<p>There is a myth that you need dependent types to do semantics.
This is ridiculous; the heyday of denotational semantics was the 1970s,
before most people had even heard of dependent types.
Tobias Nipkow and Gerwin Klein have written an entire book,
<a href="http://www.concrete-semantics.org"><em>Concrete Semantics</em></a>,
on how to do semantics in Isabelle/HOL. It has many advanced examples.
You can either <a href="https://link.springer.com/book/10.1007/978-3-319-10542-0">buy a copy</a> 
or download it for free.</p>

<p>This is another example from my old MPhil course, <a href="https://www.cl.cam.ac.uk/teaching/2122/L21/">Interactive Formal Verification</a>.</p>






      


    </section></div>
  </body>
</html>
