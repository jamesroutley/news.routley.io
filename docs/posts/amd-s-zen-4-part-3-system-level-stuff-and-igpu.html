<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chipsandcheese.com/2023/01/05/amds-zen-4-part-3-system-level-stuff-and-igpu/">Original</a>
    <h1>AMD’s Zen 4, Part 3: System Level Stuff, and iGPU</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>We covered Zen 4’s core architecture in depth in two articles. This one will focus on anything we didn’t manage to get to. Some of these details may be specific to the particular CPU sample we have, and many of them won’t have a significant effect on application performance. However, we’ve seen enough online discussion on some of these topics to warrant further investigation. Thanks to everyone involved for participating in the discussion.</p>
<p>As an aside, my goal with these articles is to deep dive aspects of processor architectures that other sites aren’t covering. Between real life work and sleep, I don’t have much spare time. Putting hours into benchmark runs doesn’t make sense when dozens of sites and content creators already have benchmark charts. Similarly, all-core clock speeds under sustained load were covered by <a href="https://youtu.be/QjrkWRTMu64?t=192">Hardware Unboxed</a>. Results there are roughly in agreement with those from <a href="https://youtu.be/nRaJXZMOMPU?t=345">Gamers Nexus</a>, so I didn’t dive into it. This article will try to cover anything that I’ve found interesting, but wasn’t covered in a batch of other places. There’s no real order to this, so feel free to skip around.</p>
<h2>Boost Clock Behavior</h2>
<p>AMD <a href="https://www.amd.com/en/products/cpu/amd-ryzen-9-7950x">advertises a boost clock of 5.7 GHz</a> for the Ryzen 7950X. We’ve heard that the CPU’s maximum frequency<a href="https://twitter.com/9550pro/status/1589997417000480769"> is supposed to be 5.85 GHz</a>, but we were unable to achieve that clock speed. Here, we’ll present the test data and discuss other aspects of the 7950X’s design. Keep in mind that the behavior seen here is likely sample specific.</p>
<p>First, we went through all of the 7950X’s cores one by one, and determined what clock speed they boosted to. To measure clock speed, we measured the latency of register to register integer addition instructions. Like prior 16 core AMD desktop parts, not all cores will boost to the CPU’s maximum clock. On our sample of the 7950X, we saw the highest clock frequencies from cores 0, 3, and 4. All three of these cores were located on the first CCD.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=13856"><img data-attachment-id="13856" data-permalink="https://chipsandcheese.com/2023/01/05/amds-zen-4-part-3-system-level-stuff-and-igpu/zen4_boostclk/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/12/zen4_boostclk.png?fit=1037%2C514&amp;ssl=1" data-orig-size="1037,514" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_boostclk" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/12/zen4_boostclk.png?fit=1037%2C514&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/12/zen4_boostclk.png?fit=688%2C341&amp;ssl=1" decoding="async" width="688" height="341" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/12/zen4_boostclk.png?resize=688%2C341&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/12/zen4_boostclk.png?w=1037&amp;ssl=1 1037w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/12/zen4_boostclk.png?resize=768%2C381&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/12/zen4_boostclk.png?resize=688%2C341&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Note – didn’t start the axis at 0 to make clock speed differences more visible</figcaption></figure></div>
<p>All of the cores on the second CCD clocked lower than cores on the first. They ranged from 5.54 GHz to 5.51 GHz, which is 100-200 MHz lower than what we saw on the first CCD. Curiously, prior generations show exactly the same pattern. Cheese’s 5950X hit its highest clocks on cores 1 and 4. Both are located on the first CCD. My 3950X clocked highest on cores 4 and 5. Both are also on the first CCD. This is a curious pattern. Perhaps AMD is only binning one CCD to hit the maximum boost clocks on 16 core parts.</p>
<p>Our Zen 4 and Zen 3 chips also see less clock speed variation than our Zen 2 chip.</p>
<figure><table><tbody><tr><td></td><td>Max Boost Clock</td><td>Average Clock Across Worst CCD</td><td>Difference</td></tr><tr><td>AMD Ryzen 7950X</td><td>5.714 GHz</td><td>5.52 GHz</td><td>3.5%</td></tr><tr><td>AMD Ryzen 5950X</td><td>5.05 GHz</td><td>4.87 GHz</td><td>3.8%</td></tr><tr><td>AMD Ryzen 3950X</td><td>4.68 GHz</td><td>4.36 GHz</td><td>7.4%</td></tr></tbody></table><figcaption>Again, these measurements are sample specific and may not be widely applicable. Maybe TSMC’s 7 nm process was simply more mature by the time Cheese bought his 5950X. Who knows…</figcaption></figure>
<p>If your operating system’s scheduler doesn’t prioritize scheduling low-threaded tasks on the best cores, the 3950X’s performance could see quite a bit of variability. The Ryzen 5950X and 7950X are much better in this respect. While the clock speed difference is measurable, feeling a 3-4% performance difference will be much harder than feeling a 7-8% one.</p>
<h3> (Very) Short Duration Boost Behavior</h3>
<p>I also wondered if Zen 4 was momentarily hitting higher clock speeds, then dropping back down within the measurement interval of the previous test. That test generally takes a couple seconds to determine clock speed, in order to give any tested CPU a reasonable amount of time to ramp clocks. To see if clocks changed at a very fine granularity, I used the clock ramp test with more iterations per sample. That test uses RDTSC to take samples with better than millisecond precision. Increasing iteration count per sample lets the test cover a longer duration to capture quick clock speed shifts, but without creating a gigantic spreadsheet of doom. I also ran the test on every core. Results were consistent on the same core, but not across cores.</p>
<p>Let’s take things one CCD at a time, because there’s a lot of data. Depending on the core, we saw clocks slightly higher than 5.71 GHz within a 700 ms time window. However, results varied wildly. Some cores, like core 0 and 2, boosted up to 5.74 GHz for less than 50 ms, and then dropped to 5.71 GHz. Core 2 held 5.74 GHz for almost half a second, and then showed erratic behavior.</p>
<div>
<figure><a href="https://chipsandcheese.com/zen4_ccd1_boost/"><img data-attachment-id="11891" data-permalink="https://chipsandcheese.com/zen4_ccd1_boost/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccd1_boost.png?fit=1448%2C732&amp;ssl=1" data-orig-size="1448,732" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_ccd1_boost" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccd1_boost.png?fit=1448%2C732&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccd1_boost.png?fit=688%2C348&amp;ssl=1" decoding="async" width="688" height="348" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccd1_boost.png?resize=688%2C348&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccd1_boost.png?w=1448&amp;ssl=1 1448w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccd1_boost.png?resize=768%2C388&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccd1_boost.png?resize=1200%2C607&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccd1_boost.png?resize=1320%2C667&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccd1_boost.png?w=1376&amp;ssl=1 1376w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccd1_boost.png?resize=688%2C348&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Test also uses integer addition latency to measure clock speed. Methodology described in a <a href="https://chipsandcheese.com/2022/09/15/how-quickly-do-cpus-change-clock-speeds/">previous article</a></figcaption></figure></div>
<p>The second CCD shows similar characteristics. However, the cores on that CCD actually start closer to 5.6 GHz. They hold that speed for a very short time interval, and then clock down slightly.</p>
<div>
<figure><a href="https://chipsandcheese.com/zen4_shitccd_boost/"><img data-attachment-id="11893" data-permalink="https://chipsandcheese.com/zen4_shitccd_boost/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_shitccd_boost.png?fit=1454%2C733&amp;ssl=1" data-orig-size="1454,733" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_shitccd_boost" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_shitccd_boost.png?fit=1454%2C733&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_shitccd_boost.png?fit=688%2C347&amp;ssl=1" decoding="async" width="688" height="347" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_shitccd_boost.png?resize=688%2C347&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_shitccd_boost.png?w=1454&amp;ssl=1 1454w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_shitccd_boost.png?resize=768%2C387&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_shitccd_boost.png?resize=1200%2C605&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_shitccd_boost.png?resize=1320%2C665&amp;ssl=1 1320w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_shitccd_boost.png?w=1376&amp;ssl=1 1376w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_shitccd_boost.png?resize=688%2C347&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>This is interesting behavior, though irrelevant to most users. Short and long term boost clocks rarely differ by more than 50 MHz. If you traveled back in time and ran a 266 MHz Pentium II, 50 MHz would be significant. Today, a 50 MHz difference is laughably small. At the clock speeds that Zen 4 runs at, 50 MHz accounts for less than 1% of difference. The biggest takeaway from this test is that Zen 4 adjusts clock speeds in very small timeslices, and that users should not expect a perfectly steady clock speed.</p>
<h2>Not So Infinite Fabric?</h2>
<p>Like Zen 2 and Zen 3, each Zen 4 core complex has a 32B/cycle read link from fabric, and a 16B/cycle write link. Last article, we noted that write bandwidth to DDR5-6000 was likely limited by the 16B/cycle links from the two CCDs. We see a similar read bandwidth limitation from one CCD. We ran our memory bandwidth test with the 3 GB test size and scaled thread counts to hit all physical cores. CCXes and CCDs were filled one before another. On the 3950X, that meant filling both CCXes on a CCD first. From the results, we see clear signs that a single 7950X CCD is restricted by its 32B/cycle link to fabric. </p>
<div>
<figure><img data-attachment-id="11912" data-permalink="https://chipsandcheese.com/2023/01/05/amds-zen-4-part-3-system-level-stuff-and-igpu/zen4_ccx_by_ccx_read-1/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccx_by_ccx_read-1.png?fit=1193%2C565&amp;ssl=1" data-orig-size="1193,565" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_ccx_by_ccx_read-1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccx_by_ccx_read-1.png?fit=1193%2C565&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccx_by_ccx_read-1.png?fit=688%2C326&amp;ssl=1" decoding="async" width="688" height="326" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccx_by_ccx_read-1.png?resize=688%2C326&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccx_by_ccx_read-1.png?w=1193&amp;ssl=1 1193w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccx_by_ccx_read-1.png?resize=768%2C364&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccx_by_ccx_read-1.png?resize=688%2C326&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>DDR5-6000 used in the Ryzen 7950X, and DDR4-3333 in the Ryzen 3950X. Memory bandwidth test was run at the 3 GB test size</figcaption></figure></div>
<p>On Zen 2 and Zen 3, the Infinity Fabric interconnect can generally be run at DDR clock, or one half the DDR transfer rate. Fabric bandwidth available from a single CCD therefore wasn’t an issue. At matched clocks, a single 32 byte per cycle, or 256-bit link offered the same theoretical bandwidth as a 16 byte per cycle, or 128-bit DDR setup. Zen 2 does see a slight increase in measured memory bandwidth as the second CCD becomes active, but the difference is quite small. For Zen 4, this raises an interesting question about whether fast DDR5 is worthwhile for designs with a single CCD. The Genoa (Zen 4 server variant) Processor Programming Reference manual<a href="https://chipsandcheese.com/2021/08/23/details-on-the-gigabyte-leak/"> leaked by the Gigabyte hack</a> suggests that each CCD can have two links to fabric. Depending on how they’re configured, pairing fast DDR5 with single CCD parts might not be worth it, especially if the primary goal is to improve performance in memory bandwidth bound applications.</p>
<p>On the Ryzen 3950X, each CCD’s narrower write link meant single CCD write bandwidth limitations could show up under contrived tests. However, both CCDs together can just about saturate a DDR4 setup when writing. As noted in part 2 of our Zen 4 coverage, the 7950X’s write bandwidth appears to be limited by the the 16 byte/cycle links from the CCDs to the Infinity Fabric interconnect. If we repeat the test above with non-temporal writes, we can clearly see similar bandwidth limitations when a single CCD is active.</p>
<div>
<figure><img data-attachment-id="11908" data-permalink="https://chipsandcheese.com/zen4_ccx_by_ccx_ntwrite/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccx_by_ccx_ntwrite.png?fit=1192%2C488&amp;ssl=1" data-orig-size="1192,488" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_ccx_by_ccx_ntwrite" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccx_by_ccx_ntwrite.png?fit=1192%2C488&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccx_by_ccx_ntwrite.png?fit=688%2C282&amp;ssl=1" decoding="async" width="688" height="282" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccx_by_ccx_ntwrite.png?resize=688%2C282&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccx_by_ccx_ntwrite.png?w=1192&amp;ssl=1 1192w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccx_by_ccx_ntwrite.png?resize=768%2C314&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_ccx_by_ccx_ntwrite.png?resize=688%2C282&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>
<p>Both tests, and both tested CPUs, curiously show that we can achieve higher bandwidth by not loading all cores.</p>
<h3>Fewer Threads, More Bandwidth?</h3>
<p>When we test memory bandwidth, each thread is given its own array, and the total data across all threads adds up to the test size. That strategy prevents the memory controller from opportunistically combining accesses from different threads. Then, we spawn as many software threads as there are hardware threads. How bandwidth scales with increasing thread count is an interesting topic, but I don’t always have the time and energy to get around it. As you can see above though, this case was well worth checking out. </p>
<div>
<figure><img data-attachment-id="11932" data-permalink="https://chipsandcheese.com/2023/01/05/amds-zen-4-part-3-system-level-stuff-and-igpu/zen4_bw_with_22/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_with_22.png?fit=649%2C372&amp;ssl=1" data-orig-size="649,372" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_bw_with_22" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_with_22.png?fit=649%2C372&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_with_22.png?fit=649%2C372&amp;ssl=1" decoding="async" width="649" height="372" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_with_22.png?resize=649%2C372&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_with_22.png?resize=649%2C372&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>Run at 2000 MHz FCLK. How deep does the memory bandwidth rabbit hole go?</figcaption></figure></div>
<p>With further testing, I got the highest memory bandwidth with four threads, pinned to two cores in each CCD. Further investigation showed similar behavior from the 3950X. I also checked performance counters for CCX to Infinity Fabric requests, memory bandwidth, and L3 hitrate to ensure that write combining or cache shenanigans weren’t at play.</p>
<div>
<figure><img data-attachment-id="11935" data-permalink="https://chipsandcheese.com/2023/01/05/amds-zen-4-part-3-system-level-stuff-and-igpu/zen2_bw_with_22-1/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_bw_with_22-1.png?fit=649%2C371&amp;ssl=1" data-orig-size="649,371" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen2_bw_with_22-1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_bw_with_22-1.png?fit=649%2C371&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_bw_with_22-1.png?fit=649%2C371&amp;ssl=1" decoding="async" width="649" height="371" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_bw_with_22-1.png?resize=649%2C371&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_bw_with_22-1.png?resize=649%2C371&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>32B/cycle fabric link bandwidth is equal to available DDR4 bandwidth</figcaption></figure></div>
<p>One explanation for this behavior is that a 32-thread workload is harsher on the memory controller than a 4-thread one. Exposing more parallelism is not a good thing if that makes the access pattern more scattered. The memory controller would have a harder time trying to schedule accesses to maximize page hits while not stalling any access for long enough to make some queues back up.</p>
<p>We can also look at the same data in terms of how effectively the memory controller was able to utilize theoretical bandwidth. Obviously, higher is better, even though we never expect to hit theoretical bandwidth. Page misses, read to write turnarounds, and refreshes will cause lost memory bus cycles, and there’s no way to avoid that.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=11939"><img data-attachment-id="11939" data-permalink="https://chipsandcheese.com/2023/01/05/amds-zen-4-part-3-system-level-stuff-and-igpu/zen4_bw_efficiency/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_efficiency.png?fit=649%2C371&amp;ssl=1" data-orig-size="649,371" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_bw_efficiency" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_efficiency.png?fit=649%2C371&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_efficiency.png?fit=649%2C371&amp;ssl=1" decoding="async" width="649" height="371" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_efficiency.png?resize=649%2C371&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_bw_efficiency.png?resize=649%2C371&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>With two threads per CCD, bandwidth efficiency is quite decent. 81% of theoretical is not bad at all. AMD’s older DDR4 controller is still better at utilizing available bandwidth:</p>
<div>
<figure><img data-attachment-id="11943" data-permalink="https://chipsandcheese.com/2023/01/05/amds-zen-4-part-3-system-level-stuff-and-igpu/zen2_bw_efficiency/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_bw_efficiency.png?fit=649%2C371&amp;ssl=1" data-orig-size="649,371" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen2_bw_efficiency" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_bw_efficiency.png?fit=649%2C371&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_bw_efficiency.png?fit=649%2C371&amp;ssl=1" decoding="async" width="649" height="371" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_bw_efficiency.png?resize=649%2C371&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen2_bw_efficiency.png?resize=649%2C371&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>
<p>But that doesn’t tell the whole story. If we look at the other access patterns, Zen 4 makes progress in areas besides maximum achievable bandwidth. Zen 2 didn’t know how to avoid read-for-ownership accesses in the REP STOSB case, but Zen 4 does. Zen 4’s DDR5 controller also handles the read-modify-write access pattern better, perhaps indicating that it takes less of a penalty when reads and writes are mixed. With plain AVX writes and all threads loaded, Zen 4 also achieves better bandwidth efficiency. In an absolute sense, Zen 4’s DDR5 controller also provides much higher bandwidth than the older DDR4 one.</p>
<h3>FCLK Effect?</h3>
<p>We also tested with a lower 1.6 GHz Infinity Fabric clock, or FCLK. Results provide further evidence that write bandwidth is restricted by Infinity Fabric bandwidth. Specifically, we see a sharp reduction in write bandwidth. That reduction aligns very well with the bandwidth loss we’d expect to see if we’re restricted by the two 16 byte per cycle CCD to IO die links.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=13851"><img data-attachment-id="13851" data-permalink="https://chipsandcheese.com/2023/01/05/amds-zen-4-part-3-system-level-stuff-and-igpu/zen4_1600_fclk_bw/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/12/zen4_1600_fclk_bw.png?fit=649%2C528&amp;ssl=1" data-orig-size="649,528" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_1600_fclk_bw" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/12/zen4_1600_fclk_bw.png?fit=649%2C528&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/12/zen4_1600_fclk_bw.png?fit=649%2C528&amp;ssl=1" decoding="async" width="649" height="528" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/12/zen4_1600_fclk_bw.png?resize=649%2C528&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/12/zen4_1600_fclk_bw.png?resize=649%2C528&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>Read bandwidth is clearly not restricted by Infinity Fabric bandwidth. We’re well above 32 bytes per cycle at FCLK. Furthermore the drop in bandwidth does not correspond to the decrease in FCLK. Specifically, a 20% FCLK decrease only brought down maximum read bandwidth by 5.8%. However, it’s certainly interesting that we got a measurable decrease in read bandwidth at lower FCLK.</p>
<h2>Integrated GPU</h2>
<p>AMD’s desktop Zen 4 platform, Raphael, is the first high performance AMD platform in recent memory to have an integrated GPU. In prior generations, AMD had a split lineup. Desktop chips offered the highest performance CPU configurations, with more cache, more cores, and higher clocks than their mobile counterparts. “APUs” on the other hand, offered a relatively powerful integrated GPU capable of taking on light gaming. They also continued to use a monolithic die to save power, even as their desktop counterparts switched to a chiplet setup to offer higher core counts at reasonable cost.</p>
<p>But Zen 4’s IO die moves to the TSMC 6 nm process, which offers a large density improvement compared to the GlobalFoundries 12nm process used in previous IO dies. IO interfaces typically don’t scale well with process node shrinks, but a die shot of the previous IO die shows a lot of area was occupied by IO controller logic and supporting SRAM. Those blocks probably did scale well with a die shrink, giving AMD room to add a small iGPU.</p>
<p>Raphael’s integrated GPU does not have the performance ambitions of AMD’s APUs, and seems intended to drive a display when no dedicated GPU is available. It features AMD’s modern RDNA2 graphics architecture, but implements it in the smallest configuration possible with just one WGP. Since we’ve been talking about memory and fabric bandwidth, let’s start with a bandwidth test. The Raphael iGPU does give us an extra way to hit the DDR5 controller after all.</p>
<div>
<figure><img data-attachment-id="12156" data-permalink="https://chipsandcheese.com/2023/01/05/amds-zen-4-part-3-system-level-stuff-and-igpu/raphael_igpu_1wgp/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/raphael_igpu_1wgp.png?fit=1369%2C706&amp;ssl=1" data-orig-size="1369,706" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="raphael_igpu_1wgp" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/raphael_igpu_1wgp.png?fit=1369%2C706&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/raphael_igpu_1wgp.png?fit=688%2C355&amp;ssl=1" decoding="async" width="688" height="355" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/raphael_igpu_1wgp.png?resize=688%2C355&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/raphael_igpu_1wgp.png?w=1369&amp;ssl=1 1369w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/raphael_igpu_1wgp.png?resize=768%2C396&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/raphael_igpu_1wgp.png?resize=1200%2C619&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/raphael_igpu_1wgp.png?resize=1320%2C681&amp;ssl=1 1320w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/raphael_igpu_1wgp.png?resize=688%2C355&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>Testing with a single workgroup because there’s only one WGP to hit, and adding more workgroups actually lowers DRAM bandwidth, possibly because of contention and less linear access patterns</figcaption></figure></div>
<p>Unfortunately, testing bandwidth doesn’t tell us much about any possible fabric limitations. We get just over 60 GB/s from DRAM sized regions. Data from another RDNA2 implementation suggests that a single WGP can’t pull much more than 60 GB/s from DRAM anyway. If the iGPU had a 32 byte/cycle link to fabric, a 2 GHz fabric clock would provide 64 GB/s of bandwidth. That’s more than enough to feed a single WGP.</p>
<p>The bandwidth test also shows signs that we’re dealing with a very small caching configuration. Previously, <a href="https://chipsandcheese.com/2022/05/21/igpu-cache-setups-compared-including-m1/">we looked at several iGPUs</a>, and noted AMD Renoir’s iGPU used a relatively large 1 MB L2 cache, in order to compensate for sharing a relatively low bandwidth DDR4 bus with the CPU. Raphael’s iGPU has no aspirations for competing with even low end graphics cards, and L2 size drops to 256 KB. Interestingly, AMD has also dropped L1 cache size to 64 KB. All RDNA(2) implementations we’ve seen so far have used 128 KB L1 caches. But it looks like RDNA2’s L1 can be configured down to half that size. Unlike discrete RDNA2 GPUs, Raphael’s iGPU doesn’t have an Infinity Cache. L2 misses go straight out to memory.</p>
<p>We can confirm the cache setup details with a latency test. Recently, we discovered that our simple latency test implementation was hitting AMD’s scalar datapath on GCN and RDNA GPUs. Looking at the compiled assembly showed that s_load_dword instructions were generated because the compiler realized that loaded values would be uniform across a wavefront. s_load_dword accesses the scalar cache instead of the vector cache, and these caches are separate on GCN and RDNA. Applying a hack to prevent the compiler from being able to determine whether loaded values would be uniform results in global_load_dword instructions, and higher measured latency. On recent Nvidia and Intel architectures, this hack has no effect because the same caches are used even if the whole wavefront or warp is loading the same value. This complicates GPU benchmarking, because going forward we’ll have to present two sets of latency results for modern AMD GPUs. Let’s start with latency from the scalar side.</p>
<div>
<figure><img data-attachment-id="12181" data-permalink="https://chipsandcheese.com/2023/01/05/amds-zen-4-part-3-system-level-stuff-and-igpu/image-65/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image.png?fit=1215%2C618&amp;ssl=1" data-orig-size="1215,618" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image.png?fit=1215%2C618&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image.png?fit=688%2C350&amp;ssl=1" decoding="async" width="688" height="350" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image.png?resize=688%2C350&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image.png?w=1215&amp;ssl=1 1215w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image.png?resize=768%2C391&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image.png?resize=1200%2C610&amp;ssl=1 1200w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image.png?resize=688%2C350&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>
<p>We see confirmation that Raphael’s iGPU has a 64 KB L1, backed by a 256 KB L2. It seems to clock slightly lower than desktop RDNA2, leading to higher L1 scalar and shared L1 latencies. However, Raphael’s tiny L2 has better latency than the 6900 XT’s. Like its desktop counterpart, Raphael’s iGPU enjoys lower scalar load latencies than the older GCN architecture used in Renoir. However, Renoir has a much larger L2 cache to help insulate the iGPU from memory bandwidth bottlenecks.</p>
<p>Raphael’s iGPU also enjoys much better DRAM access latency than Renoir. The Ryzen 4800H tested here does suffer from higher memory latency, hitting 84.7 ns at the 1 GB test size compared to the 7950X’s 73.35 ns. However, that relatively small gap doesn’t explain the large discrepancy in GPU-side DRAM latency. The jumps in latency after exceeding L2 capacity suggest the test is spilling out of GCN’s TLB levels. After 128 MB, we’re probably seeing outright TLB misses.</p>
<p>DRAM access latency on Raphael’s iGPU also compares well to that of desktop RDNA2. Desktop RDNA2 sees over 250 ns of DRAM access latency, while Raphael’s iGPU can hit DRAM in just over 191 ns. That advantage is likely because the iGPU is very small, meaning that it doesn’t have to traverse a very complex interconnect and large caches on its way to DRAM. The iGPU also sits right on the IO die, which also has the memory controller.</p>
<p>AMD suffers a lot of additional latency when we exercise the vector load path. AMD probably put a lot of effort into optimizing latency to the scalar cache, and expects latency sensitive operations to take place there. The vector path is optimized more for bandwidth than latency, and the latency penalty there is especially obvious on GCN. RDNA2 is a dramatic improvement. Unfortunately, we didn’t get vector cache latency tested on Raphael, but here’s a preview of the difference between GCN and RDNA2:</p>
<div>
<figure><img data-attachment-id="12889" data-permalink="https://chipsandcheese.com/2023/01/05/amds-zen-4-part-3-system-level-stuff-and-igpu/image-1-21/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image-1.png?fit=1073%2C582&amp;ssl=1" data-orig-size="1073,582" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image-1.png?fit=1073%2C582&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image-1.png?fit=688%2C373&amp;ssl=1" decoding="async" width="688" height="373" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image-1.png?resize=688%2C373&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image-1.png?w=1073&amp;ssl=1 1073w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image-1.png?resize=768%2C417&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/image-1.png?resize=688%2C373&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>
<p>While iGPUs are typically smaller than their discrete cousins and have access to less memory bandwidth, they do enjoy faster communication with the host CPU. In some cases, data can be moved between the CPU and GPU without actually copying it, by mapping the same physical memory into both the CPU and GPU’s page tables. Here, we’re testing what happens if copying is required.</p>
<div>
<figure><img data-attachment-id="12176" data-permalink="https://chipsandcheese.com/2023/01/05/amds-zen-4-part-3-system-level-stuff-and-igpu/zen4_igpu_link/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_igpu_link.png?fit=1367%2C706&amp;ssl=1" data-orig-size="1367,706" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zen4_igpu_link" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_igpu_link.png?fit=1367%2C706&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_igpu_link.png?fit=688%2C355&amp;ssl=1" decoding="async" width="688" height="355" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_igpu_link.png?resize=688%2C355&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_igpu_link.png?w=1367&amp;ssl=1 1367w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_igpu_link.png?resize=768%2C397&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_igpu_link.png?resize=1200%2C620&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_igpu_link.png?resize=1320%2C682&amp;ssl=1 1320w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/11/zen4_igpu_link.png?resize=688%2C355&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure></div>
<p>Intel shares a L3 cache between the CPU and GPU, allowing very fast copies between the GPU and host. AMD doesn’t have this, but AMD iGPUs still benefit from sharing a DDR bus. DDR4 or DDR5 might not offer the bandwidth of a GDDR setup, but copying data through a DDR bus is still faster than going through PCIe. At larger copy sizes where Intel’s L3 cache doesn’t help, Raphael’s higher bandwidth DDR5 setup comes into play, and lets the Raphael iGPU edge out Tiger Lake’s.</p>
<p>Raphael’s iGPU is a very interesting look at an extremely small RDNA2 implementation. It shows how RDNA2 can scale down to very small setups by cutting back on the L1 cache size, while retaining the low latency cache behavior of larger RDNA2 implementations.</p>
<p>If you like our articles and journalism and you want to support us in our endeavors then consider heading over to our <a href="https://www.patreon.com/ChipsandCheese">Patreon</a> or our <a href="https://www.paypal.com/donate/?hosted_button_id=4EMPH66SBGVSQ">PayPal</a> if you want to toss a few bucks our way or if you would like to talk with the Chips and Cheese staff and the people behind the scenes then consider joining our <a href="https://discord.gg/TwVnRhxgY2">Discord</a>.</p>
<div>

<ul>
<li>
<p><img alt="clamchowder" src="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=80&amp;d=identicon&amp;r=g" height="80" width="80" decoding="async" data-lazy-srcset="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=160&amp;d=identicon&amp;r=g 2x" data-lazy-src="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=80&amp;is-pending-load=1#038;d=identicon&amp;r=g" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>
</p>

</li>
</ul>
</div>



</div></div>
  </body>
</html>
