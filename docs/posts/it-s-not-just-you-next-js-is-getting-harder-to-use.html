<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.propelauth.com/post/nextjs-challenges">Original</a>
    <h1>It&#39;s not just you, Next.js is getting harder to use</h1>
    
    <div id="readability-page-1" class="page"><section>
        <p>I wrote a blog post the other day about how Next.js Middleware can be useful for working around some of the <a href="https://www.propelauth.com/post/getting-url-in-next-server-components?ref=propelauth.com">restrictions imposed by server components</a>. This led to some fun discussions in the world about whether this was a reasonable approach or if Next.js DX was just... <a href="https://github.com/vercel/next.js/discussions/65385?ref=propelauth.com">bad</a>.</p><figure><img src="https://cdn.getmidnight.com/a1241f0fcb8d83a4c0387f234e241914/2024/05/Screen-Shot-2024-05-14-at-9.02.53-AM.png" alt="" loading="lazy" width="916" height="498"/></figure><p>From my perspective, Next.js’ App Router has two major problems that make it difficult to adopt:</p><ul><li>You need to understand a lot about the internals to do seemingly basic tasks.</li><li>There are many ways to shoot yourself in the foot that are opt-out instead of opt-in.</li></ul><p>To understand this better, let’s look at its predecessor, the Pages Router.</p><h2 id="a-quick-look-at-the-pages-router">A quick look at the Pages Router</h2><p>When I first learned about Next.js, the main “competitor” was Create React App (CRA). I was using CRA for all my projects, but I switched to Next.js for two reasons:</p><ul><li>I liked file-based routing because it allowed me to write less boilerplate code.</li><li>Whenever I ran the dev server, CRA would open <a href="http://localhost:3000/?ref=propelauth.com">http://localhost:3000</a> (which gets annoying fast), and Next.js didn’t.</li></ul><p>The second one is maybe a little silly, but to me, Next.js was:</p><p><strong>React with better defaults.</strong></p><p>And that’s all I really wanted. It wasn’t until later that I discovered the other features Next.js had. API routes were exciting as they gave me a serverless function without setting up any extra infra - super handy for things like “Contact Us” forms on a marketing site. <code>getServerSideProps</code> allowed me to run basic functions on the server before the page loaded.</p><p>Those concepts were powerful, but they were also <strong>simple</strong>.</p><p>An API route looked and acted a lot like every other route handler. If you had used Express or Cloudflare Workers, you can squint at a route handler and all the concepts you already knew translated. <code>getServerSideProps</code> was a little different, but once you understood how to get a <code>request</code> and the format of the response, it turned out to be pretty straightforward too.</p><h2 id="the-app-router-release">The App Router release</h2><p>The Next 13 release introduced the <a href="https://nextjs.org/docs/app?ref=propelauth.com">App Router</a>, adding many new features. You had <a href="https://nextjs.org/docs/app/building-your-application/rendering/server-components?ref=propelauth.com">Server Components</a> which allowed you to render your React components on the server and reduce the amount of data you needed to send to your client.</p><p>You had <a href="https://nextjs.org/docs/app/building-your-application/routing/layouts-and-templates?ref=propelauth.com">Layouts</a>, which allowed you to define aspects of your UI shared by multiple routes and didn’t need to be re-rendered on every navigation.</p><p>Caching got… <a href="https://nextjs.org/docs/app/building-your-application/caching?ref=propelauth.com">more sophisticated</a>.</p><p>And while these features were interesting, the biggest loss was <strong>simplicity</strong>.</p><h2 id="when-a-framework-doesn%E2%80%99t-do-what-you-think-it-will-do">When a framework doesn’t do what you think it will do</h2><p>A fairly universal experience as a developer is banging your head against the wall and yelling, “Why does this not work?”</p><p>Everyone’s been there, and it always sucks. For me, it’s even more painful if it feels like it’s not a bug in my code but a misunderstanding of how things are supposed to work.</p><p>You are no longer yelling, “Why does this not work?” but rather, “Why does this work… like <em>that</em>?”</p><p>The App Router, unfortunately, is full of these kinds of subtleties.</p><p>Let’s look back at my original issue: I just want to get the URL in a Server Component. <a href="https://github.com/vercel/next.js/issues/43704?ref=propelauth.com#issuecomment-2090798307">Here’s an answer</a> to a popular Github issue about the topic, and I’ll post part of it here:</p><blockquote>If we take a step back, the question &#34;Why can&#39;t I access <code>pathname</code> or current URL?&#34; is part of a bigger question: &#34;Why can&#39;t I access the complete <strong>request and response objects</strong>?&#34;</blockquote><p>For what it’s worth, this response is incredible. It’s well written, it helps me understand a lot of the underlying issues, and it gives me insight into the tradeoffs associated with different approaches that I absolutely didn’t think about.</p><p>That being said, if you are a developer and all you are trying to do is get the URL in a Server Component, you probably read this and left with 5 more things to Google before realizing you probably have to restructure your code.</p><p>This post summarizes my feelings about it:</p><figure><img src="https://cdn.getmidnight.com/a1241f0fcb8d83a4c0387f234e241914/2024/05/Screen-Shot-2024-05-14-at-1.42.51-AM.png" alt="" loading="lazy" width="860" height="124"/></figure><p>It’s not that it’s necessarily incorrect - it’s unexpected.</p><p>That original post also mentioned a few other subtleties. One common footgun is in how <a href="https://www.propelauth.com/post/cookies-in-next-js?ref=propelauth.com">cookies are handled</a>. You can call <code>cookies().set(&#34;key&#34;, &#34;value&#34;)</code> anywhere and it will type-check, but in some cases it will fail at runtime.</p><p>Compare these to the “old” way of doing things where you got a big <code>request</code> object and could do anything you wanted on the server, and it’s fair to say that there’s been a jump in complexity.</p><p>I also need to point out that the “on-by-default” aggressive caching is a rough experience. I’d argue that way more people expect to opt-in to caching rather than dig through a lot of documentation to figure out how to opt-out.</p><p>I’m sure other companies had similar issues to us, but at <a href="https://www.propelauth.com/?ref=propelauth.com">PropelAuth</a> we often got bug reports that weren’t bugs but amounted to “You thought you made an API call, but you didn’t, and you are just reading a cached result.”</p><p>And all of this begs the question, who are these features and optimizations for?</p><h2 id="it%E2%80%99s-very-hard-to-build-a-one-size-fits-all-product">It’s very hard to build a one-size-fits-all product</h2><p>All of these features that I’m painting as overly complex do matter for some people. If you are building an e-commerce platform, for example, there are some great features here.</p><p>Your pages load faster because you send less data to the client. Your pages load faster because everything is aggressively cached. Your pages load faster because only parts of the page need to re-render when the user navigates to a new page. And in the e-commerce world, faster page loads means more money, so you would absolutely take the tradeoff of a more complex framework for them.</p><p>But if I’m building a dashboard for my SaaS application… I don’t really care about any of that. I care way more about the speed at which I ship features, and all that complexity becomes a burden on my dev team.</p><p>My personal experience and frustrations with the App Router will be different than another person’s because we have different products, different use cases, and different resources. Speaking specifically as a person who spends a lot of time writing and helping other people write B2B SaaS applications, the App Router DX is a big step down from the Pages Router.</p><h2 id="is-this-inevitable-for-frameworks-as-they-grow">Is this inevitable for frameworks as they grow?</h2><p>As products/frameworks grow, they tend to get more complicated. Customers ask for more things. Bigger customers ask for more specific things. Bigger customers pay more so you prioritize and build those more specific things.</p><p>Customers who previously loved the simplicity of it all get annoyed at how complicated things feel and… oh, look at that, a new framework has popped up that’s way simpler. We should all switch to that!</p><p>It’s challenging to avoid this, but one way to mitigate it is to not make everyone deal with the complexity that only some people need.</p><h2 id="just-because-something-is-recommended-doesn%E2%80%99t-mean-it%E2%80%99s-right-for-you">Just because something is recommended, doesn’t mean it’s right for you</h2><p>One of my biggest issues with the App Router was just this:</p><figure><img src="https://cdn.getmidnight.com/a1241f0fcb8d83a4c0387f234e241914/2024/05/Untitled-design--15---1-.png" alt="" loading="lazy" width="598" height="148"/></figure><p>Next.js has officially recommended that you use the App Router since before it was honestly ready for production use. Next.js doesn’t have a recommendation on whether TypeScript, ESLint, or Tailwind are right for your project (despite providing defaults of Yes on TS/ESLint, No to Tailwind - sorry Tailwind fans), but absolutely believes you should be using the App Router.</p><p>The <a href="https://react.dev/learn/start-a-new-react-project?ref=propelauth.com">official React docs</a> don’t share the same sentiment. They currently recommend the Pages Router and describe the App Router as a “Bleeding-edge React Framework.”</p><p>When you look at the App Router through that lens, it makes way more sense. Instead of thinking of it as the recommended default for React, you can think of it more <a href="https://twitter.com/dan_abramov2/status/1752721357614301690?ref=propelauth.com">like a beta release</a>. The experience is more complicated and <a href="https://github.com/vercel/next.js/discussions/41934?ref=propelauth.com">some things that were easy are now hard/impossible</a>, but what else would you expect from something that’s still “Bleeding-edge?”</p><p>So when you are picking a framework for your next project, it’s worth recognizing that there are still many rough edges in the App Router. You might have better luck reaching for a different tool that’s more suited to your use case.</p>
    </section></div>
  </body>
</html>
