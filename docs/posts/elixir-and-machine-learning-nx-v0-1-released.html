<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dashbit.co/blog/elixir-and-machine-learning-nx-v0.1">Original</a>
    <h1>Elixir and Machine Learning: Nx v0.1 released</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    
<ul>
  <li>
    <i></i> José Valim
  </li>
  <li>
    <i></i> January 6th, 2022
  </li>
  <li>
    <i></i><a href="http://mattambrogi.bearblog.dev/blog/tags/nx">nx</a>, <a href="http://mattambrogi.bearblog.dev/blog/tags/torchx">torchx</a>, <a href="http://mattambrogi.bearblog.dev/blog/tags/exla">exla</a>, <a href="http://mattambrogi.bearblog.dev/blog/tags/gpu">gpu</a>, <a href="http://mattambrogi.bearblog.dev/blog/tags/livebook">livebook</a>, <a href="http://mattambrogi.bearblog.dev/blog/tags/axon">axon</a>, <a href="http://mattambrogi.bearblog.dev/blog/tags/nerves">nerves</a>
  </li>
</ul>
<p><img src="http://mattambrogi.bearblog.dev/images/posts/2021/nx.png" alt="Nx" width="400"/></p>
<p>
We are glad to announce <a href="https://github.com/elixir-nx/nx/tree/main/nx">Nx</a> (Numerical Elixir) v0.1 has been released!</p>
<p>
For those unfamiliar, <a href="https://elixir-lang.org/">Elixir</a> is a dynamic, functional language for building scalable and maintainable applications. Elixir leverages the <a href="https://www.erlang.org/">Erlang VM</a>, known for running low-latency, distributed, and fault-tolerant systems. </p>
<p>
Numerical Elixir is an effort, <a href="https://dashbit.co/blog/nx-numerical-elixir-is-now-publicly-available">publicly unveiled almost a year ago</a>, to bring Elixir to the world of numerical computing and machine learning. The foundation of this effort is a library called <a href="https://github.com/elixir-nx/nx/tree/main/nx">Nx</a>, that brings multi-dimensional arrays (tensors) and just-in-time compilation of numerical Elixir to both CPU and GPU. As we will see, the mixture of functional programming and tensor compilers provide an elegant and powerful abstraction for emitting highly specialized code.</p>
<p>
In this blog post, we will discuss the current state of Nx, some of its upcoming features, and take a look at its growing ecosystem.</p>
<blockquote>
  <p>
Nx’s mascot is the Numbat, a marsupial native to southern Australia. Unfortunately the Numbat are endangered and it is estimated to be fewer than 1000 left. If you are excited about Nx, consider donating to Numbat conservation efforts, such as <a href="https://www.numbat.org.au/">Project Numbat</a> and <a href="https://www.australianwildlife.org/">Australian Wildlife Conservancy</a>.  </p>
</blockquote>
<h2>
Nx 101</h2>
<p>
Let’s start with a very quick introduction to Nx. Let’s create a two-dimensional tensor:</p>
<pre><code><span>iex&gt; </span><span>t</span><span> </span><span>=</span><span> </span><span>Nx</span><span>.</span><span>tensor</span><span data-group-id="2803935416-1">(</span><span data-group-id="2803935416-2">[</span><span data-group-id="2803935416-3">[</span><span>1</span><span>,</span><span> </span><span>2</span><span data-group-id="2803935416-3">]</span><span>,</span><span> </span><span data-group-id="2803935416-4">[</span><span>3</span><span>,</span><span> </span><span>4</span><span data-group-id="2803935416-4">]</span><span data-group-id="2803935416-2">]</span><span data-group-id="2803935416-1">)</span><span>
</span><span data-group-id="2803935416-5">#</span><span data-group-id="2803935416-5">Nx.Tensor</span><span data-group-id="2803935416-5">&lt;</span><span>
  </span><span>s64</span><span data-group-id="2803935416-6">[</span><span>2</span><span data-group-id="2803935416-6">]</span><span data-group-id="2803935416-7">[</span><span>2</span><span data-group-id="2803935416-7">]</span><span>
  </span><span data-group-id="2803935416-8">[</span><span>
    </span><span data-group-id="2803935416-9">[</span><span>1</span><span>,</span><span> </span><span>2</span><span data-group-id="2803935416-9">]</span><span>,</span><span>
    </span><span data-group-id="2803935416-10">[</span><span>3</span><span>,</span><span> </span><span>4</span><span data-group-id="2803935416-10">]</span><span>
  </span><span data-group-id="2803935416-8">]</span><span>
</span><span data-group-id="2803935416-5">&gt;</span></code></pre>
<p>
Tensors can be unsigned integers (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>), signed integers (<code>s8</code>, <code>s16</code>, <code>s32</code>, <code>s64</code>), floats (<code>f16</code>, <code>f32</code>, <code>f64</code>), and brain floats (<code>bf16</code>). Each dimension of a tensor can be optionally named.</p>
<p>
To implement <a href="https://en.wikipedia.org/wiki/Softmax_function">a numerically stable version of the Softmax function</a> using Nx:</p>
<pre><code><span>iex&gt; </span><span>t</span><span> </span><span>=</span><span> </span><span>Nx</span><span>.</span><span>tensor</span><span data-group-id="6983923363-1">(</span><span data-group-id="6983923363-2">[</span><span data-group-id="6983923363-3">[</span><span>1</span><span>,</span><span> </span><span>2</span><span data-group-id="6983923363-3">]</span><span>,</span><span> </span><span data-group-id="6983923363-4">[</span><span>3</span><span>,</span><span> </span><span>4</span><span data-group-id="6983923363-4">]</span><span data-group-id="6983923363-2">]</span><span data-group-id="6983923363-1">)</span><span>
</span><span>iex&gt; </span><span>normalized</span><span> </span><span>=</span><span> </span><span>Nx</span><span>.</span><span>subtract</span><span data-group-id="6983923363-5">(</span><span>t</span><span>,</span><span> </span><span>Nx</span><span>.</span><span>max</span><span data-group-id="6983923363-6">(</span><span>t</span><span data-group-id="6983923363-6">)</span><span data-group-id="6983923363-5">)</span><span>
</span><span>iex&gt; </span><span>Nx</span><span>.</span><span>divide</span><span data-group-id="6983923363-7">(</span><span>Nx</span><span>.</span><span>exp</span><span data-group-id="6983923363-8">(</span><span>normalized</span><span data-group-id="6983923363-8">)</span><span>,</span><span> </span><span>Nx</span><span>.</span><span>sum</span><span data-group-id="6983923363-9">(</span><span>Nx</span><span>.</span><span>exp</span><span data-group-id="6983923363-10">(</span><span>normalized</span><span data-group-id="6983923363-10">)</span><span data-group-id="6983923363-9">)</span><span data-group-id="6983923363-7">)</span><span>
</span><span data-group-id="6983923363-11">#</span><span data-group-id="6983923363-11">Nx.Tensor</span><span data-group-id="6983923363-11">&lt;</span><span>
  </span><span>f32</span><span data-group-id="6983923363-12">[</span><span>2</span><span data-group-id="6983923363-12">]</span><span data-group-id="6983923363-13">[</span><span>2</span><span data-group-id="6983923363-13">]</span><span>
  </span><span data-group-id="6983923363-14">[</span><span>
    </span><span data-group-id="6983923363-15">[</span><span>0.032058604061603546</span><span>,</span><span> </span><span>0.08714432269334793</span><span data-group-id="6983923363-15">]</span><span>,</span><span>
    </span><span data-group-id="6983923363-16">[</span><span>0.23688282072544098</span><span>,</span><span> </span><span>0.6439142227172852</span><span data-group-id="6983923363-16">]</span><span>
  </span><span data-group-id="6983923363-14">]</span><span>
</span><span data-group-id="6983923363-11">&gt;</span></code></pre>
<p>
The computations above are happening in pure Elixir. However, you can plug a custom backend, such as <a href="https://github.com/elixir-nx/nx/tree/main/torchx">Torchx</a>, and have the computation be performed by state-of-the-art libraries such as LibTorch, on both CPU and GPU:</p>
<pre><code><span>iex&gt; </span><span>Nx</span><span>.</span><span>default_backend</span><span data-group-id="3419071535-1">(</span><span>Torchx.Backend</span><span data-group-id="3419071535-1">)</span><span>
</span><span>iex&gt; </span><span>t</span><span> </span><span>=</span><span> </span><span>Nx</span><span>.</span><span>tensor</span><span data-group-id="3419071535-2">(</span><span data-group-id="3419071535-3">[</span><span data-group-id="3419071535-4">[</span><span>1</span><span>,</span><span> </span><span>2</span><span data-group-id="3419071535-4">]</span><span>,</span><span> </span><span data-group-id="3419071535-5">[</span><span>3</span><span>,</span><span> </span><span>4</span><span data-group-id="3419071535-5">]</span><span data-group-id="3419071535-3">]</span><span data-group-id="3419071535-2">)</span><span>
</span><span>iex&gt; </span><span>normalized</span><span> </span><span>=</span><span> </span><span>Nx</span><span>.</span><span>subtract</span><span data-group-id="3419071535-6">(</span><span>t</span><span>,</span><span> </span><span>Nx</span><span>.</span><span>max</span><span data-group-id="3419071535-7">(</span><span>t</span><span data-group-id="3419071535-7">)</span><span data-group-id="3419071535-6">)</span><span>
</span><span>iex&gt; </span><span>Nx</span><span>.</span><span>divide</span><span data-group-id="3419071535-8">(</span><span>Nx</span><span>.</span><span>exp</span><span data-group-id="3419071535-9">(</span><span>t</span><span data-group-id="3419071535-9">)</span><span>,</span><span> </span><span>Nx</span><span>.</span><span>sum</span><span data-group-id="3419071535-10">(</span><span>Nx</span><span>.</span><span>exp</span><span data-group-id="3419071535-11">(</span><span>t</span><span data-group-id="3419071535-11">)</span><span data-group-id="3419071535-10">)</span><span data-group-id="3419071535-8">)</span><span>
</span><span data-group-id="3419071535-12">#</span><span data-group-id="3419071535-12">Nx.Tensor</span><span data-group-id="3419071535-12">&lt;</span><span>
  </span><span>Torchx.Backend</span><span>
  </span><span>f32</span><span data-group-id="3419071535-13">[</span><span>2</span><span data-group-id="3419071535-13">]</span><span data-group-id="3419071535-14">[</span><span>2</span><span data-group-id="3419071535-14">]</span><span>
  </span><span data-group-id="3419071535-15">[</span><span>
    </span><span data-group-id="3419071535-16">[</span><span>0.032058604061603546</span><span>,</span><span> </span><span>0.08714432269334793</span><span data-group-id="3419071535-16">]</span><span>,</span><span>
    </span><span data-group-id="3419071535-17">[</span><span>0.23688282072544098</span><span>,</span><span> </span><span>0.6439142227172852</span><span data-group-id="3419071535-17">]</span><span>
  </span><span data-group-id="3419071535-15">]</span><span>
</span><span data-group-id="3419071535-12">&gt;</span></code></pre>
<p>
The full power of Nx comes from <code>defn</code>, which stands for numerical definitions. Numerical definitions are a subset of Elixir tailored for numerical computing:</p>
<pre><code><span>defmodule</span><span> </span><span>MyModule</span><span> </span><span data-group-id="0638043994-1">do</span><span>
  </span><span>import</span><span> </span><span>Nx.Defn</span><span>

  </span><span>defn</span><span> </span><span>softmax</span><span data-group-id="0638043994-2">(</span><span>t</span><span data-group-id="0638043994-2">)</span><span> </span><span data-group-id="0638043994-3">do</span><span>
    </span><span>normalized</span><span> </span><span>=</span><span> </span><span>t</span><span> </span><span>-</span><span> </span><span>Nx</span><span>.</span><span>max</span><span data-group-id="0638043994-4">(</span><span>t</span><span data-group-id="0638043994-4">)</span><span>
    </span><span>Nx</span><span>.</span><span>exp</span><span data-group-id="0638043994-5">(</span><span>normalized</span><span data-group-id="0638043994-5">)</span><span> </span><span>/</span><span> </span><span>Nx</span><span>.</span><span>sum</span><span data-group-id="0638043994-6">(</span><span>Nx</span><span>.</span><span>exp</span><span data-group-id="0638043994-7">(</span><span>normalized</span><span data-group-id="0638043994-7">)</span><span data-group-id="0638043994-6">)</span><span>
  </span><span data-group-id="0638043994-3">end</span><span>
</span><span data-group-id="0638043994-1">end</span></code></pre>
<p>
Inside <code>defn</code> we can use Elixir regular operators and they are all translated to their equivalent tensor operations. You have access to many of the language features and data types, such as macros, the beloved pipe operator, pattern-matching, maps, and more.</p>
<p>
When invoked, the code above takes the types and shapes of the arguments and compiles them to highly optimized code to run on the CPU, the GPU, or even <a href="https://cloud.google.com/tpu/">Cloud TPUs</a>. For example, we can use Google’s XLA compiler via <a href="https://github.com/elixir-nx/nx/tree/main/exla">EXLA</a>:</p>
<pre><code><span>iex&gt; </span><span>Nx.Defn</span><span>.</span><span>default_options</span><span data-group-id="2805166452-1">(</span><span>compiler</span><span>:</span><span> </span><span>EXLA</span><span>,</span><span> </span><span>client</span><span>:</span><span> </span><span>:cuda</span><span data-group-id="2805166452-1">)</span><span>
</span><span>iex&gt; </span><span>MyModule</span><span>.</span><span>softmax</span><span data-group-id="2805166452-2">(</span><span>Nx</span><span>.</span><span>tensor</span><span data-group-id="2805166452-3">(</span><span data-group-id="2805166452-4">[</span><span data-group-id="2805166452-5">[</span><span>1</span><span>,</span><span> </span><span>2</span><span data-group-id="2805166452-5">]</span><span>,</span><span> </span><span data-group-id="2805166452-6">[</span><span>3</span><span>,</span><span> </span><span>4</span><span data-group-id="2805166452-6">]</span><span data-group-id="2805166452-4">]</span><span data-group-id="2805166452-3">)</span><span data-group-id="2805166452-2">)</span><span>
</span><span data-group-id="2805166452-7">#</span><span data-group-id="2805166452-7">Nx.Tensor</span><span data-group-id="2805166452-7">&lt;</span><span>
  </span><span>f32</span><span data-group-id="2805166452-8">[</span><span>2</span><span data-group-id="2805166452-8">]</span><span data-group-id="2805166452-9">[</span><span>2</span><span data-group-id="2805166452-9">]</span><span>
  </span><span>Torchx.Backend</span><span data-group-id="2805166452-10">(</span><span>cpu</span><span data-group-id="2805166452-10">)</span><span>
  </span><span data-group-id="2805166452-11">[</span><span>
    </span><span data-group-id="2805166452-12">[</span><span>0.032058604061603546</span><span>,</span><span> </span><span>0.08714432269334793</span><span data-group-id="2805166452-12">]</span><span>,</span><span>
    </span><span data-group-id="2805166452-13">[</span><span>0.23688282072544098</span><span>,</span><span> </span><span>0.6439142227172852</span><span data-group-id="2805166452-13">]</span><span>
  </span><span data-group-id="2805166452-11">]</span><span>
</span><span data-group-id="2805166452-7">&gt;</span></code></pre>
<p>
For reference, here are some benchmarks of the function above when called with a tensor of one million random float values:</p>
<pre><code>Name                       ips        average  deviation         median         99th %
xla gpu f32 keep      15308.14      0.0653 ms    ±29.01%      0.0638 ms      0.0758 ms
xla gpu f64 keep       4550.59        0.22 ms     ±7.54%        0.22 ms        0.33 ms
xla cpu f32             434.21        2.30 ms     ±7.04%        2.26 ms        2.69 ms
xla gpu f32             398.45        2.51 ms     ±2.28%        2.50 ms        2.69 ms
xla gpu f64             190.27        5.26 ms     ±2.16%        5.23 ms        5.56 ms
xla cpu f64             168.25        5.94 ms     ±5.64%        5.88 ms        7.35 ms
elixir f32                3.22      311.01 ms     ±1.88%      309.69 ms      340.27 ms
elixir f64                3.11      321.70 ms     ±1.44%      322.10 ms      328.98 ms

Comparison:
xla gpu f32 keep      15308.14
xla gpu f64 keep       4550.59 - 3.36x slower +0.154 ms
xla cpu f32             434.21 - 35.26x slower +2.24 ms
xla gpu f32             398.45 - 38.42x slower +2.44 ms
xla gpu f64             190.27 - 80.46x slower +5.19 ms
xla cpu f64             168.25 - 90.98x slower +5.88 ms
elixir f32                3.22 - 4760.93x slower +310.94 ms
elixir f64                3.11 - 4924.56x slower +321.63 ms</code></pre>
<h2>
Nx and Machine learning</h2>
<p>
We have spent the last months maturing Nx towards Machine Learning and production use cases. Sean Moriarity has developed <a href="https://github.com/elixir-nx/axon">Axon</a>, which we used to battle-test Nx and its <a href="https://hexdocs.pm/nx/Nx.Defn.html#grad/2">automatic differentiation engine</a> against several traditional and non-traditional neural networks.</p>
<p>
For example, here is a Convolutional Neural Network model to train and classify the CIFAR-10 dataset implemented with Axon:</p>
<pre><code><span>Axon</span><span>.</span><span>input</span><span data-group-id="4493979999-1">(</span><span>input_shape</span><span data-group-id="4493979999-1">)</span><span>
</span><span>|&gt;</span><span> </span><span>Axon</span><span>.</span><span>conv</span><span data-group-id="4493979999-2">(</span><span>32</span><span>,</span><span> </span><span>kernel_size</span><span>:</span><span> </span><span data-group-id="4493979999-3">{</span><span>3</span><span>,</span><span> </span><span>3</span><span data-group-id="4493979999-3">}</span><span>,</span><span> </span><span>activation</span><span>:</span><span> </span><span>:relu</span><span data-group-id="4493979999-2">)</span><span>
</span><span>|&gt;</span><span> </span><span>Axon</span><span>.</span><span>batch_norm</span><span data-group-id="4493979999-4">(</span><span data-group-id="4493979999-4">)</span><span>
</span><span>|&gt;</span><span> </span><span>Axon</span><span>.</span><span>max_pool</span><span data-group-id="4493979999-5">(</span><span>kernel_size</span><span>:</span><span> </span><span data-group-id="4493979999-6">{</span><span>2</span><span>,</span><span> </span><span>2</span><span data-group-id="4493979999-6">}</span><span data-group-id="4493979999-5">)</span><span>
</span><span>|&gt;</span><span> </span><span>Axon</span><span>.</span><span>conv</span><span data-group-id="4493979999-7">(</span><span>64</span><span>,</span><span> </span><span>kernel_size</span><span>:</span><span> </span><span data-group-id="4493979999-8">{</span><span>3</span><span>,</span><span> </span><span>3</span><span data-group-id="4493979999-8">}</span><span>,</span><span> </span><span>activation</span><span>:</span><span> </span><span>:relu</span><span data-group-id="4493979999-7">)</span><span>
</span><span>|&gt;</span><span> </span><span>Axon</span><span>.</span><span>batch_norm</span><span data-group-id="4493979999-9">(</span><span data-group-id="4493979999-9">)</span><span>
</span><span>|&gt;</span><span> </span><span>Axon</span><span>.</span><span>max_pool</span><span data-group-id="4493979999-10">(</span><span>kernel_size</span><span>:</span><span> </span><span data-group-id="4493979999-11">{</span><span>2</span><span>,</span><span> </span><span>2</span><span data-group-id="4493979999-11">}</span><span data-group-id="4493979999-10">)</span><span>
</span><span>|&gt;</span><span> </span><span>Axon</span><span>.</span><span>flatten</span><span data-group-id="4493979999-12">(</span><span data-group-id="4493979999-12">)</span><span>
</span><span>|&gt;</span><span> </span><span>Axon</span><span>.</span><span>dense</span><span data-group-id="4493979999-13">(</span><span>64</span><span>,</span><span> </span><span>activation</span><span>:</span><span> </span><span>:relu</span><span data-group-id="4493979999-13">)</span><span>
</span><span>|&gt;</span><span> </span><span>Axon</span><span>.</span><span>dropout</span><span data-group-id="4493979999-14">(</span><span>rate</span><span>:</span><span> </span><span>0.5</span><span data-group-id="4493979999-14">)</span><span>
</span><span>|&gt;</span><span> </span><span>Axon</span><span>.</span><span>dense</span><span data-group-id="4493979999-15">(</span><span>10</span><span>,</span><span> </span><span>activation</span><span>:</span><span> </span><span>:softmax</span><span data-group-id="4493979999-15">)</span></code></pre>
<p>
You can find the whole example, including downloading, training, and inference of the dataset <a href="https://github.com/elixir-nx/axon/blob/main/examples/vision/cifar10.exs">here</a>. You can also find examples for <a href="https://github.com/elixir-nx/axon/tree/main/examples/generative">generative</a>, <a href="https://github.com/elixir-nx/axon/tree/main/examples/structured">structured</a>, and other <a href="https://github.com/elixir-nx/axon/tree/main/examples/vision">vision-related</a> neural networks.</p>
<p>
To power the existing and upcoming functionality, we have brought many features to Nx. In particular:</p>
<ul>
  <li>
    <p>
We implemented <a href="https://hexdocs.pm/nx/Nx.Defn.html#stream/3">streaming capabilities</a>, which allows a program to be loaded into GPUs/TPUs, while we stream batches of inputs to it. This can be useful for distributed learning and also running inference efficiently in production.    </p>
  </li>
  <li>
    <p>
We started working on a series of functions related to Linear Algebra under the <a href="https://hexdocs.pm/nx/Nx.LinAlg.html"><code>Nx.LinAlg</code></a> module, which are relevant for models that rely on matrix factorization.    </p>
  </li>
  <li>
    <p>
We introduced <a href="https://hexdocs.pm/nx/Nx.Defn.Kernel.html#while/3"><code>while</code></a> loops into numerical definitions, to support both static and dynamic unrolling of loops, which are handy in <a href="https://stanford.edu/~shervine/teaching/cs-230/cheatsheet-recurrent-neural-networks">recurrent models</a> (speech recognition, semantic parsing, sign language translation, etc).    </p>
  </li>
  <li>
    <p>
We added <a href="https://hexdocs.pm/nx/Nx.Defn.Kernel.html#hook/3">hooks to numerical definitions</a>, which allow developers to stream data out of GPUs/TPUs as computation happens. With this, you can debug system, monitoring the performance of models during training (think <a href="https://www.tensorflow.org/tensorboard">TensorBoard</a> integration) and inference, and more.    </p>
  </li>
</ul>
<p>
There is still a lot of work ahead of us and you can follow the issues tracker for both <a href="https://github.com/elixir-nx/nx/issues">Nx</a> and <a href="https://github.com/elixir-nx/axon/issues">Axon</a> projects for more information.</p>
<h2>
The future of Nx</h2>
<p>
Over the last 10 months we have put a huge amount of work on making Nx the building block for numerical computing and machine learning in Elixir. The path we chose was not the only option available to us. For example, we could have:</p>
<ul>
  <li>
    <p>
<a href="https://github.com/Pyrlang/Pyrlang">interfaced directly with Python</a> and its ecosystem    </p>
  </li>
  <li>
    <p>
implemented bindings for high-level libraries, such as <a href="https://pytorch.org/vision/stable/index.html">torchvision</a> and <a href="https://pytorch.org/text/stable/index.html">torchtext</a>, instead of <a href="https://pytorch.org/cppdocs/">libtorch</a>    </p>
  </li>
</ul>
<p>
The options above are extremely useful, especially if you want to quickly put a system in production. However, our goals are also to:</p>
<ul>
  <li>
    <p>
make Elixir a suitable platform for <em>new</em> Machine Learning developments    </p>
  </li>
  <li>
    <p>
fully leverage the power provided by the platform Elixir runs on, the Erlang VM    </p>
  </li>
  <li>
    <p>
provide consistency and stability, especially when working on a domain that is still actively evolving    </p>
  </li>
</ul>
<p>
For those reasons, we chose to invest on Nx as its own foundation, agnostic to any particular framework. The road is definitely longer but we also believe the pay-off will be higher too!</p>
<p>
Plus, we are not alone! Many folks have joined the <a href="https://erlef.org/wg/machine-learning">Machine Learning Working Group from the Erlang Ecosystem Foundation</a> to bring other important projects to life, such as:</p>
<ul>
  <li>
    <p>
<a href="https://github.com/elixir-nx/axon/">Axon</a> - Nx-powered Neural Networks for Elixir, shown in the previous section    </p>
  </li>
  <li>
    <p>
<a href="https://github.com/elixir-nx/explorer">Explorer</a> - dataframes (series and tabular data) for Elixir. It runs on Rust’s <a href="https://docs.rs/polars/latest/polars/">Polars</a> for amazing performance    </p>
  </li>
  <li>
    <p>
<a href="https://livebook.dev">Livebook</a> - interactive and collaborative code notebooks for Elixir. Once you install Livebook, there are several example notebooks available. We are also planning to port many of Axon examples to notebooks, <a href="https://github.com/elixir-nx/axon/tree/main/notebooks">you can track them in the notebooks directory</a>    </p>
  </li>
  <li>
    <p>
<a href="https://github.com/elixir-nx/scidata/">Scidata</a> - download and normalize datasets related to science    </p>
  </li>
</ul>
<p>
There are also exciting projects being developed outside of the working group, such as OpenCV bindings via <a href="https://github.com/cocoa-xu/evision/">evision</a> and others.</p>
<p>
Here is a peek at what we expect to see in the near future, within Elixir’s Machine Learning ecosystem:</p>
<ul>
  <li>
    <p>
Integration between <a href="https://onnx.ai/">ONNX</a> and Axon, allowing developers to bring trained models from other platforms into Elixir and vice-versa    </p>
  </li>
  <li>
    <p>
Precompiled Explorer bindings, so developers can get started with Dataframes in Elixir without a need to have the Rust toolchain installed on their machines    </p>
  </li>
  <li>
    <p>
Desktop app versions of Livebook, making it easier than ever for any developer to get Elixir code up and running on their machines    </p>
  </li>
  <li>
    <p>
Support for checkpointing in Nx’ automatic differentiation system. Checkpoints reduce the memory usage at the cost of increased computation when calculating gradients, which is helpful when training large models    </p>
  </li>
</ul>
<p>
This is barely scratching the surface of what is possible. Here are some ideas to explore in the long term:</p>
<ul>
  <li>
    <p>
Support for other compilers and backends. Our bindings for <a href="https://github.com/elixir-nx/nx/tree/main/exla">Google XLA</a> are quite complete and there is <a href="https://github.com/elixir-nx/nx/tree/main/torchx">work in progress on LibTorch</a> (<a href="https://github.com/elixir-nx/nx/issues/504">contributions are welcome</a>). We are also interested in exploring other options, such as <a href="https://tvm.apache.org/">Apache TVM</a>.    </p>
  </li>
  <li>
    <p>
Distributed training: in Machine Learning, “distributed” often stands for training across multiple GPUs. With Nx, we can mix the “distributed” meaning of Machine Learning with the “distributed” meaning of the Erlang VM, which is across multiple nodes.    </p>
  </li>
  <li>
    <p>
<a href="https://en.wikipedia.org/wiki/Federated_learning">Federated learning</a> is a technique for training an algorithm across multiple edge devices. Federated training comes in different shapes, such as centralized - when there is a central server responsible for aggregating and coordinating devices - and decentralized. Elixir and the Erlang VM can shine under several scenarios, thanks to its orchestrating capabilities born from telecommunication and thanks to projects like <a href="https://www.nerves-project.org/">Nerves</a>.    </p>
  </li>
</ul>
<p>
And there are definitely other possibilities we haven’t even considered yet. I hope this shares some of our vision, ideas, and goals. If you are excited about these new possibilities, we welcome you to use, enjoy, and contribute to many of the projects above, or perhaps even start your own!</p>
<p>
Happy coding!</p>

  </article>
</div></div>
  </body>
</html>
