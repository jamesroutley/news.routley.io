<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vercel.com/blog/how-google-handles-javascript-throughout-the-indexing-process">Original</a>
    <h1>How Google handles JavaScript throughout the indexing process</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Understanding how search engines crawl, render, and index web pages is crucial for optimizing sites for search engines. Over the years, as search engines like Google change their processes, it’s tough to keep track of what works and doesn’t—especially with client-side JavaScript.</p><p>We’ve noticed that a number of old beliefs have stuck around and kept the community unsure about best practices for application SEO:</p><ol><li>“Google can’t render client-side JavaScript.”</li><li>“Google treats JavaScript pages differently.”</li><li>“Rendering queue and timing significantly impact SEO.”</li><li>“JavaScript-heavy sites have slower page discovery.”</li></ol><p>To address these beliefs, we’ve partnered with <a href="https://merj.com/" rel="noopener" target="_blank">MERJ</a>, a leading SEO &amp; data engineering consultancy, to conduct new experiments on Google’s crawling behavior. We analyzed over 100,000 Googlebot fetches across various sites to test and validate Google’s SEO capabilities.</p><p>Let&#39;s look at how Google&#39;s rendering has evolved. Then, we&#39;ll explore our findings and their real-world impact on modern web apps.</p><hr/><p><b>Article contents:</b></p><ul><li><a href="https://vercel.com/blog/how-google-handles-javascript-throughout-the-indexing-process#the-evolution-of-google%E2%80%99s-rendering-capabilities">The evolution of Google&#39;s rendering capabilities</a></li><li><a href="https://vercel.com/blog/how-google-handles-javascript-throughout-the-indexing-process#methodology">Methodology</a></li><li><a href="https://vercel.com/blog/how-google-handles-javascript-throughout-the-indexing-process#myth-1-%E2%80%9Cgoogle-can%E2%80%99t-render-javascript-content%E2%80%9D">Myth 1: &#34;Google can&#39;t render JavaScript content&#34;</a></li><li><a href="https://vercel.com/blog/how-google-handles-javascript-throughout-the-indexing-process#myth-2-%E2%80%9Cgoogle-treats-javascript-pages-differently%E2%80%9D">Myth 2: &#34;Google treats JavaScript pages differently&#34;</a></li><li><a href="https://vercel.com/blog/how-google-handles-javascript-throughout-the-indexing-process#myth-3-%E2%80%9Crendering-queue-and-timing-significantly-impact-seo">Myth 3: &#34;Rendering queue and timing significantly impact SEO&#34;</a></li><li><a href="https://vercel.com/blog/how-google-handles-javascript-throughout-the-indexing-process#myth-4-%E2%80%9Cjavascript-heavy-sites-have-slower-page-discovery%E2%80%9D">Myth 4: &#34;JavaScript-heavy sites have slower page discovery&#34;</a></li><li><a href="https://vercel.com/blog/how-google-handles-javascript-throughout-the-indexing-process#overall-implications-and-recommendations">Overall implications and recommendations</a></li><li><a href="https://vercel.com/blog/how-google-handles-javascript-throughout-the-indexing-process#moving-forward-with-new-information">Moving forward with new information</a></li><li><a href="https://vercel.com/blog/how-google-handles-javascript-throughout-the-indexing-process#about-merj">About MERJ</a></li></ul><h2><span id="the-evolution-of-google’s-rendering-capabilities"></span><a href="#the-evolution-of-google’s-rendering-capabilities">The evolution of Google’s rendering capabilities</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h2><p>Over the years, Google’s ability to crawl and index web content has significantly changed. Seeing this evolution is important to understand the current state of SEO for modern web applications.</p><h3><span id="pre-2009-limited-javascript-support"></span><a href="#pre-2009-limited-javascript-support"><b>Pre-2009: Limited JavaScript support</b></a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><p>In the early days of search, Google primarily indexed static HTML content. JavaScript-generated content was largely invisible to search engines, leading to the widespread use of static HTML for SEO purposes.</p><h3><span id="2009–2015-ajax-crawling-scheme"></span><a href="#2009–2015-ajax-crawling-scheme"><b>2009–2015: AJAX crawling scheme</b></a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><p>Google introduced the AJAX crawling scheme, allowing websites to provide HTML snapshots of dynamically generated content. This was a stopgap solution that required developers to create separate, crawlable versions of their pages.</p><h3><span id="2015–2018-early-javascript-rendering"></span><a href="#2015–2018-early-javascript-rendering"><b>2015–2018: Early JavaScript rendering</b></a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><p>Google began rendering pages using a headless Chrome browser, marking a significant step forward. However, this older browser version still had limitations in processing modern JS features.</p><h3><span id="2018–present-modern-rendering-capabilities"></span><a href="#2018–present-modern-rendering-capabilities"><b>2018–present: Modern rendering capabilities</b></a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><p>Today, Google uses an up-to-date version of Chrome for rendering, keeping pace with the latest web technologies. Key aspects of the current system include:</p><ol><li><b>Universal rendering:</b> Google now attempts to render all HTML pages, not just a subset.</li><li><b>Up-to-date browser:</b> Googlebot uses the latest stable version of Chrome/Chromium, supporting modern JS features.</li><li><b>Stateless rendering:</b> Each page render occurs in a fresh browser session, without retaining cookies or state from previous renders. Google will generally not click on items on the page, <a href="https://merj.com/blog/12-experiments-for-tabbed-content-seo" rel="noopener" target="_blank">such as tabbed content</a> or cookie banners.</li><li><b>Cloaking</b>: Google prohibits showing different content to users and search engines to manipulate rankings. Avoid code that alters content based on <code>User-Agent</code>. Instead, optimize your app&#39;s stateless rendering for Google, and implement personalization through stateful methods.</li><li><b>Asset caching:</b> Google speeds up webpage rendering by caching assets, which is useful for pages sharing resources and for repeated renderings of the same page. Instead of using HTTP <code>Cache-Control</code> headers, <a href="https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics#caching" rel="noopener" target="_blank">Google&#39;s Web Rendering Service employs its own internal heuristics</a> to determine when cached assets are still fresh and when they need to be downloaded again.</li></ol><div><div><figure data-vercel-edit-target="true"><p><img data-version="v1" alt="Today, Google&#39;s indexing process looks something like this." loading="lazy" width="960" height="689" decoding="async" data-nimg="1" srcset="/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F1hIDIxDIvmIV0mdeNSojg2%2F672ae68da3daf2f33256504bf9501d8c%2Fgoogles-indexing-processing.png&amp;w=1080&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 1x, /_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F1hIDIxDIvmIV0mdeNSojg2%2F672ae68da3daf2f33256504bf9501d8c%2Fgoogles-indexing-processing.png&amp;w=1920&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 2x" src="https://vercel.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F1hIDIxDIvmIV0mdeNSojg2%2F672ae68da3daf2f33256504bf9501d8c%2Fgoogles-indexing-processing.png&amp;w=1920&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD"/></p><figcaption>Today, Google&#39;s indexing process looks something like this.</figcaption></figure></div><div><figure data-vercel-edit-target="true"><p><img data-version="v1" alt="Today, Google&#39;s indexing process looks something like this." loading="lazy" width="960" height="689" decoding="async" data-nimg="1" srcset="/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2FmKTNjYMhgD0B1iu2Lsab5%2F90611c45bf249e862e158df50a998b8d%2Fgoogles-indexing-process-dark.png&amp;w=1080&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 1x, /_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2FmKTNjYMhgD0B1iu2Lsab5%2F90611c45bf249e862e158df50a998b8d%2Fgoogles-indexing-process-dark.png&amp;w=1920&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 2x" src="https://vercel.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2FmKTNjYMhgD0B1iu2Lsab5%2F90611c45bf249e862e158df50a998b8d%2Fgoogles-indexing-process-dark.png&amp;w=1920&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD"/></p><figcaption>Today, Google&#39;s indexing process looks something like this.</figcaption></figure></div></div><div><div><figure data-vercel-edit-target="true"><p><img data-version="v1" alt="Today, Google&#39;s indexing process looks something like this." loading="lazy" width="414" height="659" decoding="async" data-nimg="1" srcset="/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F7duidzzChYk4wMmEA48tmt%2F3d1d25f224ab2d2eb4a2ea082555de0d%2Fgoogles-indexing-process.png&amp;w=640&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 1x, /_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F7duidzzChYk4wMmEA48tmt%2F3d1d25f224ab2d2eb4a2ea082555de0d%2Fgoogles-indexing-process.png&amp;w=828&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 2x" src="https://vercel.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F7duidzzChYk4wMmEA48tmt%2F3d1d25f224ab2d2eb4a2ea082555de0d%2Fgoogles-indexing-process.png&amp;w=828&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD"/></p><figcaption>Today, Google&#39;s indexing process looks something like this.</figcaption></figure></div><div><figure data-vercel-edit-target="true"><p><img data-version="v1" alt="Today, Google&#39;s indexing process looks something like this." loading="lazy" width="414" height="659" decoding="async" data-nimg="1" srcset="/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F2Jq4cSZbHcbPU1DpAcKMX0%2F396a465393a41973425fb45b09c617aa%2Fgoogles-indexing-process-dark-mobile.png&amp;w=640&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 1x, /_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F2Jq4cSZbHcbPU1DpAcKMX0%2F396a465393a41973425fb45b09c617aa%2Fgoogles-indexing-process-dark-mobile.png&amp;w=828&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 2x" src="https://vercel.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F2Jq4cSZbHcbPU1DpAcKMX0%2F396a465393a41973425fb45b09c617aa%2Fgoogles-indexing-process-dark-mobile.png&amp;w=828&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD"/></p><figcaption>Today, Google&#39;s indexing process looks something like this.</figcaption></figure></div></div><hr/><p>With a better understanding of what Google is capable of, let&#39;s look at some common myths and how they impact SEO.</p><h2><span id="methodology"></span><a href="#methodology">Methodology</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h2><p>To investigate the following myths, we conducted a study using Vercel’s infrastructure and MERJ’s Web Rendering Monitor (WRM) technology. Our research focused on <a href="http://nextjs.org" rel="noopener" target="_blank"><code>nextjs.org</code></a>, with supplemental data from <a href="http://monogram.io" rel="noopener" target="_blank"><code>monogram.io</code></a> and <a href="http://basement.io" rel="noopener" target="_blank"><code>basement.io</code></a>, spanning from April 1 to April 30, 2024.</p><h3><span id="data-collection"></span><a href="#data-collection">Data collection</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><p>We placed a custom <a href="https://vercel.com/docs/functions/edge-middleware" rel="noopener" target="_blank">Edge Middleware</a> on these sites to intercept and analyze requests from search engine bots. This middleware allowed us to:</p><ol><li>Identify and track requests from various search engines and AI crawlers. (No user data was included in this query.)</li><li>Inject a <a href="https://github.com/merj/wrm-research-vercel" rel="noopener" target="_blank">lightweight JavaScript library</a> in HTML responses for bots.</li></ol><p>The JavaScript library, triggered when a page finished rendering, sent data back to a long-running server, including:</p><ul><li>The page URL.</li><li>The unique request identifier (to match the page rendering against regular server access logs).</li><li>The timestamp of the rendering completion (this is calculated using the JavaScript Library request reception time on the server).</li></ul><h3><span id="data-analysis"></span><a href="#data-analysis">Data analysis</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><p>By comparing the initial request present in server access logs with the data sent from our middleware to an external beacon server, we could:</p><ol><li>Confirm which pages were successfully rendered by search engines.</li><li>Calculate the time difference between the initial crawl and the completed render.</li><li>Analyze patterns in how different types of content and URLs were processed.</li></ol><h3><span id="data-scope"></span><a href="#data-scope">Data scope</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><p>For this article, we primarily focused on data from Googlebot, which provided the largest and most reliable dataset. Our analysis included over 37,000 rendered HTML pages matched with server-beacon pairs, giving us a robust sample from which to draw conclusions.</p><p>We are still gathering data about other search engines, including AI providers like OpenAI and Anthropic, and hope to talk more about our findings in the future.</p><p>In the following sections, we’ll dive into each myth, providing more relevant methodology as necessary.</p><h2><span id="myth-1-“google-can’t-render-javascript-content”"></span><a href="#myth-1-“google-can’t-render-javascript-content”">Myth 1: “Google can’t render JavaScript content”</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h2><p>This myth has led many developers to avoid JS frameworks or resort to complex workarounds for SEO.</p><h3><span id="the-test"></span><a href="#the-test">The test</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><p>To test Google’s ability to render JavaScript content, we focused on three key aspects:</p><ol><li><b>JS framework compatibility:</b> We analyzed Googlebot&#39;s interactions with Next.js using data from <code>nextjs.org</code>, which uses a mix of static prerendering, server-side rendering, and client-side rendering.</li><li><b>Dynamic content indexing</b>: We examined pages on <code>nextjs.org</code> that load content asynchronously via API calls. This allowed us to determine if Googlebot could process and index content not present in the initial HTML response.</li><li><b>Streamed content via React Server Components (RSCs):</b> Similar to the above, much of <code>nextjs.org</code> is built with the <a href="https://nextjs.org/docs/app" rel="noopener" target="_blank">Next.js App Router</a> and <a href="https://vercel.com/blog/understanding-react-server-components?nxtPslug=understanding-react-server-components" rel="noopener" target="_blank">RSCs</a>. We could see how Googlebot processed and indexed content incrementally streamed to the page.</li><li><b>Rendering success rate</b>: We compared the number of Googlebot requests in our server logs to the number of successful rendering beacons received. This gave us insight into what percentage of crawled pages were fully rendered.</li></ol><h3><span id="our-findings"></span><a href="#our-findings">Our findings</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><ol><li>Out of over 100,000 Googlebot fetches analyzed on <code>nextjs.org</code>, excluding status code errors and non-indexable pages, <b>100% of HTML pages resulted in full-page renders, including pages with complex JS interactions.</b></li><li>All content loaded asynchronously via API calls was successfully indexed, demonstrating Googlebot&#39;s ability to process dynamically loaded content.</li><li>Next.js, a React-based framework, was fully rendered by Googlebot, confirming compatibility with modern JavaScript frameworks.</li><li>Streamed content via RSCs was also fully rendered, confirming that <a href="https://vercel.com/guides/does-streaming-affect-seo" rel="noopener" target="_blank">streaming does not adversely impact SEO</a>.</li><li>Google attempts to render virtually all HTML pages it crawls, not just a subset of JavaScript-heavy pages.</li></ol><h2><span id="myth-2-“google-treats-javascript-pages-differently”"></span><a href="#myth-2-“google-treats-javascript-pages-differently”">Myth 2: “Google treats JavaScript pages differently”</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h2><p>A common misconception is that Google has a separate process or criteria for JavaScript-heavy pages. Our research, combined with <a href="https://www.youtube.com/watch?v=XBT_DUzUbOI" rel="noopener" target="_blank">official statements from Google</a>, debunks this myth.</p><h3><span id="the-test"></span><a href="#the-test">The test</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><p>To test where Google treats JS-heavy pages differently, we took several targeted approaches:</p><ol><li><b>CSS </b><b><code>@import</code></b><b> test:</b> We created a test page <i>without</i> JavaScript, but <i>with</i> a CSS file that <code>@imports</code> a second CSS file (which would only be downloaded and present in server logs upon rendering the first CSS file). By comparing this behavior to JS-enabled paged, we could verify if Google’s renderer processes CSS any differently with and without JS enabled.</li><li><b>Status code and meta tag handling:</b> We developed a Next.js application with middleware to test various HTTP status codes with Google. Our analysis focused on how Google processes pages with different status codes (200, 304, 3xx, 4xx, 5xx) and those with <code>noindex</code> meta tags. This helped us understand if JavaScript-heavy pages are treated differently in these scenarios.</li><li><b>JavaScript complexity analysis</b>: We compared Google&#39;s rendering behavior across pages with varying levels of JS complexity on <a href="http://nextjs.org/" rel="noopener" target="_blank">nextjs.org</a>. This included pages with minimal JS, those with moderate interactivity, and highly dynamic pages with extensive client-side rendering. We also calculated and compared the time between the initial crawl and the completed render to see if more complex JS led to longer rendering queues or processing times.</li></ol><h3><span id="our-findings"></span><a href="#our-findings">Our findings</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><ol><li>Our CSS <code>@import</code> test confirmed that Google successfully renders pages with or without JS.</li><li>Google renders <i>all</i> 200 status HTML pages, regardless of JS content. Pages with 304 status are rendered using the content of the original 200 status page. Pages with other 3xx, 4xx, and 5xx errors were not rendered.</li><li>Pages with <code>noindex</code> meta tags in the initial HTML response were not rendered, regardless of JS content. <b>Client-side removal of </b><b><code>noindex</code></b><b> tags is </b><b><i>not</i></b><b> effective for SEO purposes;</b> if a page contains the <code>noindex</code> tag in the initial HTML response, it won&#39;t be rendered, and the JavaScript that removes the tag won&#39;t be executed.</li><li>We found no significant difference in Google’s success rate in rendering pages with varying levels of JS complexity. At <code>nextjs.org</code>&#39;s scale, we also found no correlation between JavaScript complexity and rendering delay. However, more complex JS on a much larger site <a href="https://developers.google.com/search/docs/crawling-indexing/large-site-managing-crawl-budget" rel="noopener" target="_blank">can impact crawl efficiency</a>.</li></ol><h2><span id="myth-3-“rendering-queue-and-timing-significantly-impact-seo"></span><a href="#myth-3-“rendering-queue-and-timing-significantly-impact-seo">Myth 3: “Rendering queue and timing significantly impact SEO</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h2><p>Many SEO practitioners believe that JavaScript-heavy pages face significant delays in indexing due to a rendering queue. Our research provides a clearer view of this process.</p><h3><span id="the-test"></span><a href="#the-test">The test</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><p>To address the impact of rendering queue and timing on SEO, we investigated:</p><ol><li><b>Rendering delays:</b> We examined the time difference between Google&#39;s initial crawl of a page and its completion of rendering, using data from over 37,000 matched server-beacon pairs on <code>nextjs.org</code>.</li><li><b>URL types:</b> We analyzed rendering times for URLs with and without query strings, as well as for different sections of <code>nextjs.org</code> (e.g., <code>/docs</code>, <code>/learn</code>, <code>/showcase</code>).</li><li><b>Frequency patterns:</b> We looked at how often Google re-renders pages and if there were patterns in rendering frequency for different types of content.</li></ol><h3><span id="our-findings"></span><a href="#our-findings">Our findings</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><p>The rendering delay distribution was as follows:</p><ul><li>50th percentile (median): 10 seconds.</li><li>75th percentile: 26 seconds</li><li>90th percentile: ~3 hours</li><li>95th percentile: ~6 hours</li><li>99th percentile: ~18 hours</li></ul><div><div><figure data-vercel-edit-target="true"><p><img data-version="v1" alt="The exact rendering delay distribution we found across over 37,000 matched server-beacon pairs." loading="lazy" width="960" height="508" decoding="async" data-nimg="1" srcset="/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F3FOTu0jm94k7GHzNi54qaO%2Fc24c6c57d49f43b629d2b04f92d9b5d0%2Frendering-data-timeline-light.png&amp;w=1080&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 1x, /_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F3FOTu0jm94k7GHzNi54qaO%2Fc24c6c57d49f43b629d2b04f92d9b5d0%2Frendering-data-timeline-light.png&amp;w=1920&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 2x" src="https://vercel.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F3FOTu0jm94k7GHzNi54qaO%2Fc24c6c57d49f43b629d2b04f92d9b5d0%2Frendering-data-timeline-light.png&amp;w=1920&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD"/></p><figcaption>The exact rendering delay distribution we found across over 37,000 matched server-beacon pairs.</figcaption></figure></div><div><figure data-vercel-edit-target="true"><p><img data-version="v1" alt="The exact rendering delay distribution we found across over 37,000 matched server-beacon pairs." loading="lazy" width="1920" height="1017" decoding="async" data-nimg="1" srcset="/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F3lIUNrfUsBrJhMuVlAoBL8%2F9767703b3c0f1c8ec4a8cfa723194c48%2Frendering-data-timeline-dark.png&amp;w=1920&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 1x, /_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F3lIUNrfUsBrJhMuVlAoBL8%2F9767703b3c0f1c8ec4a8cfa723194c48%2Frendering-data-timeline-dark.png&amp;w=3840&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 2x" src="https://vercel.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F3lIUNrfUsBrJhMuVlAoBL8%2F9767703b3c0f1c8ec4a8cfa723194c48%2Frendering-data-timeline-dark.png&amp;w=3840&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD"/></p><figcaption>The exact rendering delay distribution we found across over 37,000 matched server-beacon pairs.</figcaption></figure></div></div><div><div><figure data-vercel-edit-target="true"><p><img data-version="v1" alt="The exact rendering delay distribution we found across over 37,000 matched server-beacon pairs." loading="lazy" width="414" height="343" decoding="async" data-nimg="1" srcset="/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F6STtXr8BNkHdNLFCVKkLKB%2F26b87d2fa4fa0a0d1aa728c86b33846b%2Frendering-data-timeline-light-mobile.png&amp;w=640&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 1x, /_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F6STtXr8BNkHdNLFCVKkLKB%2F26b87d2fa4fa0a0d1aa728c86b33846b%2Frendering-data-timeline-light-mobile.png&amp;w=828&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 2x" src="https://vercel.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F6STtXr8BNkHdNLFCVKkLKB%2F26b87d2fa4fa0a0d1aa728c86b33846b%2Frendering-data-timeline-light-mobile.png&amp;w=828&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD"/></p><figcaption>The exact rendering delay distribution we found across over 37,000 matched server-beacon pairs.</figcaption></figure></div><div><figure data-vercel-edit-target="true"><p><img data-version="v1" alt="The exact rendering delay distribution we found across over 37,000 matched server-beacon pairs." loading="lazy" width="414" height="343" decoding="async" data-nimg="1" srcset="/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F23MPD6W68WjfHOjKzxffJp%2Fbf6f7e81b5b5145cf133e31845ba7799%2Frendering-data-timeline-dark-mobile.png&amp;w=640&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 1x, /_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F23MPD6W68WjfHOjKzxffJp%2Fbf6f7e81b5b5145cf133e31845ba7799%2Frendering-data-timeline-dark-mobile.png&amp;w=828&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD 2x" src="https://vercel.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F23MPD6W68WjfHOjKzxffJp%2Fbf6f7e81b5b5145cf133e31845ba7799%2Frendering-data-timeline-dark-mobile.png&amp;w=828&amp;q=75&amp;dpl=dpl_5grPmPrjfNtHfPnAz8Lf2XnrjqmD"/></p><figcaption>The exact rendering delay distribution we found across over 37,000 matched server-beacon pairs.</figcaption></figure></div></div><p>Surprisingly, the 25th percentile of pages were rendered within 4 seconds of the initial crawl, challenging the notion of a long “queue.”</p><p>While some pages faced significant delays (up to ~18 hours at the 99th percentile), these were the exception and not the rule.</p><hr/><p>We also observed interesting patterns related to how quickly Google renders URLs with query strings (?param=xyz):</p><table><tbody><tr><th><p><b>URL Type</b></p></th><th><p><b>50th Percentile</b></p></th><th><p><b>75th Percentile</b></p></th><th><p><b>90th Percentile</b></p></th></tr><tr><td><p><b>All URLs</b></p></td><td><p>10 seconds</p></td><td><p>26 seconds</p></td><td><p>~3 hours</p></td></tr><tr><td><p><b>URLs without Query String</b></p></td><td><p>10 seconds</p></td><td><p>22 seconds</p></td><td><p>~2.5 hours</p></td></tr><tr><td><p><b>URLs with Query String</b></p></td><td><p>13 seconds</p></td><td><p>31 minutes</p></td><td><p>~8.5 hours</p></td></tr></tbody></table><p>This data suggests that Google treats URLs differently if they have query strings that don&#39;t affect the content. For example, on <code>nextjs.org</code>, pages with <code>?ref=</code> parameters experienced longer rendering delays, especially at higher percentiles.</p><p>Additionally, we noticed that frequently updated sections like <code>/docs</code> had shorter median rendering times compared to more static sections. For example, the <code>/showcase</code> page, despite being frequently linked, showed longer rendering times, suggesting that Google may slow down re-rendering for pages that don&#39;t change significantly.</p><h2><span id="myth-4-“javascript-heavy-sites-have-slower-page-discovery”"></span><a href="#myth-4-“javascript-heavy-sites-have-slower-page-discovery”">Myth 4: “JavaScript-heavy sites have slower page discovery”</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h2><p>A persistent belief in the SEO community is that JavaScript-heavy sites, especially those relying on client-side rendering (CSR) like Single Page Applications (SPAs), suffer from slower page discovery by Google. Our research provides new insights here.</p><h3><span id="the-test"></span><a href="#the-test">The test</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><p>To investigate the impact of JavaScript on page discovery, we:</p><ol><li><b>Analyzed link discovery in different rendering scenarios:</b> We compared how quickly Google discovered and crawled links in server-rendered, statically generated, and client-side rendered pages on <a href="http://nextjs.org/" rel="noopener" target="_blank">nextjs.org</a>.</li><li><b>Tested non-rendered JavaScript payloads:</b> We added a JSON object similar to a React Server Component (RSC) payload to the <code>/showcase</code> page of <a href="http://nextjs.org/" rel="noopener" target="_blank">nextjs.org</a>, containing links to new, previously undiscovered pages. This allowed us to test if Google could discover links in JavaScript data that wasn’t rendered.</li><li><b>Compared discovery times:</b> We monitored how quickly Google discovered and crawled new pages linked in different ways: standard HTML links, links in client-side rendered content, and links in non-rendered JavaScript payloads.</li></ol><h3><span id="our-findings"></span><a href="#our-findings">Our findings</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><ol><li>Google successfully discovered and crawled links in fully rendered pages, regardless of rendering method.</li><li>Google can discover links in non-rendered JavaScript payloads on the page, such as those in React Server Components or similar structures.</li><li>In both initial and rendered HTML, Google processes content by identifying strings that look like URLs, using the current host and port as a base for relative URLs. (Google did <i>not</i> discover an encoded URL—i.e., <code>https%3A%2F%2Fwebsite.com</code>—in our RSC-like payload, suggesting its link parsing is very strict.)</li><li>The source and format of a link (e.g., in an <code>&lt;a&gt;</code> tag or embedded in a JSON payload) did not impact how Google prioritized its crawl. Crawl priority remained consistent regardless of whether a URL was found in the initial crawl or post-rendering.</li><li>While Google successfully discovers links in CSR pages, these pages do need to be rendered first. Server-rendered pages or partially pre-rendered pages have a slight advantage in immediate link discovery.</li><li>Google differentiates between link discovery and link value assessment. The evaluation of a link&#39;s value for site architecture and crawl prioritization occurs after full-page rendering.</li><li>Having an updated <code>sitemap.xml</code> significantly reduces, if not eliminates, the time-to-discovery differences between different rendering patterns.</li></ol><h2><span id="overall-implications-and-recommendations"></span><a href="#overall-implications-and-recommendations">Overall implications and recommendations</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h2><p>Our research has debunked several common myths about Google&#39;s handling of JavaScript-heavy websites. Here are the key takeaways and actionable recommendations:</p><h3><span id="implications"></span><a href="#implications">Implications</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><ol><li><b>JavaScript compatibility:</b> Google can effectively render and index JavaScript content, including complex SPAs, dynamically loaded content, and streamed content.</li><li><b>Rendering parity:</b> There&#39;s no fundamental difference in how Google processes JavaScript-heavy pages compared to static HTML pages. All pages are rendered.</li><li><b>Rendering queue reality:</b> While a rendering queue exists, its impact is less significant than previously thought. Most pages are rendered within minutes, not days or weeks.</li><li><b>Page discovery:</b> JavaScript-heavy sites, including SPAs, are not inherently disadvantaged in page discovery by Google.</li><li><b>Content timing:</b> When certain elements (like <code>noindex</code> tags) are added to the page is crucial, as Google may not process client-side changes.</li><li><b>Link value assessment:</b> Google differentiates between link discovery and link value assessment. The latter occurs after full-page rendering.</li><li><b>Rendering prioritization:</b> Google&#39;s rendering process isn&#39;t strictly first-in-first-out. Factors like content freshness and update frequency influence prioritization more than JavaScript complexity.</li><li><b>Rendering performance and crawl budget:</b> While Google can effectively render JS-heavy pages, the process is more resource-intensive compared to static HTML, both for you and Google. For large sites (10,000+ unique and frequently changing pages), this can <a href="https://developers.google.com/search/docs/crawling-indexing/large-site-managing-crawl-budget" rel="noopener" target="_blank">impact the site’s crawl budget</a>. Optimizing application performance and minimizing unnecessary JS can help speed up the rendering process, improve crawl efficiency, and potentially allow more of your pages to be crawled, rendered, and indexed.</li></ol><h3><span id="recommendations"></span><a href="#recommendations">Recommendations</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><ol><li><b>Embrace JavaScript:</b> Leverage JavaScript frameworks freely for enhanced user and developer experiences, but prioritize performance and adhere to <a href="https://developers.google.com/search/docs/crawling-indexing/javascript/lazy-loading" rel="noopener" target="_blank">Google&#39;s best practices for lazy-loading</a>.</li><li><b>Error handling:</b> Implement <a href="https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary" rel="noopener" target="_blank">error boundaries</a> in React applications to prevent total render failures due to individual component errors.</li><li><b>Critical SEO elements:</b> Use server-side rendering or static generation for critical SEO tags and important content to ensure they&#39;re present in the initial HTML response.</li><li><b>Resource management:</b> Ensure <a href="https://merj.com/blog/managing-webpages-resources-for-efficient-crawling-and-rendering" rel="noopener" target="_blank">critical resources for rendering</a> (APIs, JavaScript files, CSS files) are not blocked by <code>robots.txt</code>.</li><li><b>Content updates:</b> For content that needs to be quickly re-indexed, ensure changes are reflected in the server-rendered HTML, not just in client-side JavaScript. Consider strategies like <a href="https://vercel.com/docs/incremental-static-regeneration#differences-between-isr-and-cache-control-headers" rel="noopener" target="_blank">Incremental Static Regeneration</a> to balance content freshness with SEO and performance.</li><li><b>Internal linking and URL structure:</b> Create a clear, logical internal linking structure. Implement important navigational links as real HTML anchor tags (<code>&lt;a href=&#34;...&#34;&gt;</code>) rather than JavaScript-based navigation. This approach aids both user navigation and search engine crawling efficiency while potentially reducing rendering delays.</li><li><b>Sitemaps:</b> <a href="https://developers.google.com/search/docs/crawling-indexing/sitemaps/overview" rel="noopener" target="_blank">Use and regularly update sitemaps</a>. For large sites or those with frequent updates, use the <code>&lt;lastmod&gt;</code> tag in XML sitemaps to guide Google&#39;s crawling and indexing processes. Remember to update the <code>&lt;lastmod&gt;</code> only when a significant content update occurs.</li><li><b>Monitoring:</b> Use Google Search Console&#39;s <a href="https://support.google.com/webmasters/answer/9012289?hl=en" rel="noopener" target="_blank">URL Inspection Tool</a> or <a href="https://search.google.com/test/rich-results" rel="noopener" target="_blank">Rich Results Tool</a> to verify how Googlebot sees your pages. Monitor crawl stats to ensure your chosen rendering strategy isn&#39;t causing unexpected issues.</li></ol><h2><span id="moving-forward-with-new-information"></span><a href="#moving-forward-with-new-information">Moving forward with new information</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h2><p>As we’ve explored, there are some differences between <a href="https://vercel.com/blog/how-to-choose-the-best-rendering-strategy-for-your-app" rel="noopener" target="_blank">rendering strategies</a> when it comes to Google’s abilities:</p><table><tbody><tr><th><p><b>Feature</b></p></th><th><p><b>Static Site Generation (SSG)</b></p></th><th><p><b>Incremental Static Regeneration (ISR)</b></p></th><th><p><b>Server-Side Rendering (SSR)</b></p></th><th><p><b>Client-Side Rendering (CSR)</b></p></th></tr><tr><td><p><b>Crawl efficiency: </b>How quickly and effectively Google can access, render, and retrieve webpages.</p></td><td><p>Excellent</p></td><td><p>Excellent</p></td><td><p>Very Good</p></td><td><p>Poor</p></td></tr><tr><td><p><b>Discovery:</b> The process of finding new URLs to crawl.*</p></td><td><p>Excellent</p></td><td><p>Excellent</p></td><td><p>Excellent</p></td><td><p>Average</p></td></tr><tr><td><p><b>Rendering completeness (errors, failures, etc):</b> How accurately and completely Google can load and process your web pages without errors.</p></td><td><p>Robust</p></td><td><p>Robust</p></td><td><p>Robust</p></td><td><p>Might fail**</p></td></tr><tr><td><p><b>Rendering time:</b> How long Google takes to fully render and process web pages.</p></td><td><p>Excellent</p></td><td><p>Excellent</p></td><td><p>Excellent</p></td><td><p>Poor</p></td></tr><tr><td><p><b>Link structure evaluation:</b> How Google assesses links to understand the website architecture and pages&#39; importance.</p></td><td><p>After rendering</p></td><td><p>After rendering</p></td><td><p>After rendering</p></td><td><p>After rendering, links might be missing if rendering fails</p></td></tr><tr><td><p><b>Indexing:</b> The process by which Google stores and organizes your site&#39;s content.</p></td><td><p>Robust</p></td><td><p>Robust</p></td><td><p>Robust</p></td><td><p>Might not be indexed if rendering fails</p></td></tr></tbody></table><p>* Having an updated <code>sitemap.xml</code> significantly reduces, if not eliminates, the time-to-discovery differences between different rendering patterns.</p><p>** Rendering in Google usually doesn&#39;t fail, as proven in our research; when it does, it&#39;s often due to blocked resources in <code>robots.txt</code> or specific edge cases.</p><hr/><p>These fine-grained differences exist, but Google will quickly discover and index your site regardless of rendering strategy. Focus on creating performant web applications that benefit users more than worrying about special accommodations for Google&#39;s rendering process.</p><p>After all, <b>page speed is still a ranking factor,</b> since Google’s page experience ranking system evaluates the performance of your site based on Google’s <a href="https://developers.google.com/search/docs/appearance/core-web-vitals" rel="noopener" target="_blank">Core Web Vitals</a> metrics.</p><p>Plus, page speed is linked to good user experience—with every 100ms of load time saved <a href="https://www2.deloitte.com/content/dam/Deloitte/ie/Documents/Consulting/Milliseconds_Make_Millions_report.pdf" rel="noopener" target="_blank">correlated to an 8% uptick in website conversion</a>. Fewer users bouncing off your page means Google treats it as more relevant. Performance compounds; milliseconds matter.</p><h3><span id="further-resources"></span><a href="#further-resources">Further resources</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h3><p>To learn more about these topics, we recommend:</p><ul><li><b></b><a href="https://vercel.com/blog/how-core-web-vitals-affect-seo-giuMUCEQOZjD5Q1z65gix" rel="noopener" target="_blank"><b>How Core Web Vitals affect your SEO</b></a><b>:</b> Provides a comprehensive overview of how Core Web Vitals (CWVs) affect SEO, explaining Google&#39;s page experience ranking system and the difference between field data (used for ranking) and lab data (Lighthouse scores).</li><li><b></b><a href="https://vercel.com/blog/how-to-choose-the-best-rendering-strategy-for-your-app" rel="noopener" target="_blank"><b>How to choose the right rendering strategy</b></a><b>:</b> Guides developers in choosing optimal rendering strategies for web applications, explaining various methods like SSG, ISR, SSR, and CSR, their use cases, and implementation considerations using Next.js.</li><li><b></b><a href="https://vercel.com/blog/the-user-experience-of-the-frontend-cloud-43fi9hfOeVbRkJN0nZiik7?__vercel_draft=1" rel="noopener" target="_blank"><b>The user experience of the Frontend Cloud</b></a><b>:</b> Explains how Vercel&#39;s Frontend Cloud enables fast, personalized web experiences by combining advanced caching strategies, Edge Network capabilities, and flexible rendering options to optimize both user experience and developer productivity.</li></ul><div data-vercel-edit-target="true"><div data-version="v1"><p data-version="v1">Trusted by performance-critical applications.</p><p data-version="v1">Next.js and Vercel automatically optimize the performance of your application to meet today’s high standards. We can walk you through how it works for your application.</p></div><p><a role="link" tabindex="0" href="https://vercel.com/contact/sales" target="_blank" type="submit" data-geist-button="" data-prefix="false" data-suffix="false" data-version="v1"><span>Contact Us</span></a></p></div><h2><span id="about-merj"></span><a href="#about-merj">About MERJ</a><span><svg data-testid="geist-icon" fill="none" height="24" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 24 24" width="24" style="color:currentColor;width:0.75em;height:0.75em"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"></path></svg></span></h2><p>MERJ is a leading SEO and data engineering consultancy specializing in technical SEO and performance optimization for complex web applications.</p><p>With a track record of success across various industries, MERJ brings cutting-edge expertise to help businesses navigate the ever-evolving landscape of search engine optimization.</p><p>If you need assistance with any of the SEO topics raised in this research, or if you&#39;re looking to optimize your web application for better search visibility and performance, don&#39;t hesitate to <a href="https://merj.com/" rel="noopener" target="_blank">contact MERJ</a>.</p></div></div></div>
  </body>
</html>
