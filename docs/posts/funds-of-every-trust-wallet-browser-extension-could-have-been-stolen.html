<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.ledger.com/Funds-of-every-wallet-created-with-the-Trust-Wallet-browser-extension-could-have-been-stolen/">Original</a>
    <h1>Funds of every Trust Wallet browser extension could have been stolen</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main" role="main">
    <div>

        <article>

            

            
            <figure>
            </figure>
            

            <section>
                <div>
                    <h2 id="key-takeaways">Key Takeaways:</h2>
<ul>
  <li>Seed generation of Trust Wallet was flawed, the total entropy was only 32 bits. We have created a file containing all possible seeds.</li>
  <li>Fortunately, the Ledger Donjon discovered the vulnerability very quickly and likely avoided one of the biggest hack in the crypto ecosystem.</li>
</ul>

<p>On November 14th 2022, Trust Wallet, a widely used software wallet, announced the release of its browser extension. It allows access to digital assets on several blockchains directly from the browser, and is a long-awaited addition to the existing iOS and Android apps.</p>

<p>The Ledger Donjon has recently discovered a critical vulnerability in this browser extension, allowing an attacker to steal all the assets of any wallet created with this extension, without any user interaction. By knowing the address of an account, it is possible to immediately compute its private key, then access all its funds.
Below are details of the vulnerability, how the Ledger Donjon discovered it,  its impact over time, an estimation of the vulnerable assets, and how Trust Wallet responded to fix it. But let’s start with recalling the basics.</p>

<h2 id="how-wallets-are-created">How wallets are created</h2>

<p>Entropy generation is tricky. As scientists, we like reproducibility and being able to explain phenomena with cause-and-effect principles. So, generally speaking it’s hard to generate randomness. Moreover, it’s tough to demonstrate that random numbers are correct, and a bad but not terminally flawed random number generator can easily fool the observer. For good randomness, we need uniform distribution of bits and bytes (and even all chunks size), and unpredictability. For an observer of a sequence, it must be impossible to have any information on the next part of the sequence to be generated.</p>

<p>As these properties are incredibly difficult to achieve, the cryptocurrency space tries to avoid relying on randomness as much as possible - but we still need it at one stage: when we create a new wallet.</p>

<p>You’re probably already familiar with your mnemonic, the 12 to 24 english words that allow you to backup your wallet (if not, you can check <a href="https://www.ledger.com/academy/bip-39-the-low-key-guardian-of-your-crypto-freedom">Ledger Academy</a> article on this very topic).</p>

<p>This mnemonic encodes 16 to 32 bytes of entropy, according to the <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP 39 standard</a> - the quality of this entropy is critical, since it’ll be the seed of all keys used by your wallet on all chains, following a deterministic derivation process defined by the <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32</a> and <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP 44</a> standards.</p>

<center>
  <figure>
    <img src="https://blog.ledger.com/assets/funds-of-every-wallet-could-have-been-stolen/derivation.png"/>
  </figure>
</center>
<center><i><small> <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">Summary of HD Wallets</a></small></i></center>


<p>This Hierarchical Deterministic scheme is pretty much ubiquitous today, considering how easy it makes it for users to create a backup of an infinity of keys and its portability (despite BIP 39 being “unanimously discouraged for implementation”). Signer roaming is a powerful feature - when your favorite wallet fails or disappoints, you can just take your mnemonic with you (or even better, your Ledger device), switch to another one, keep your financial freedom and limit any impact of its downtime.</p>

<p>But again, it requires a flawless entropy source.</p>

<h2 id="overview-of-the-vulnerability">Overview of the Vulnerability</h2>

<p>Trust Wallet relies on <a href="https://github.com/trustwallet/wallet-core">Trust Wallet Core</a>, a cross-platform library that implements low-level cryptographic wallet functionality for many blockchains. It was mobile-focused, but it also targets Wasm since April 2022 (see <a href="https://github.com/trustwallet/wallet-core/pull/2132">#2132</a>).</p>

<p>While most of the Trust Wallet Core is portable, a few modules and functions are very specific to  a target. This is notably the case for the secure random generation part, used to create cryptographic material such as private keys, and mnemonic for HD wallets. Each implementation leverages the pseudorandom number generator (PRNG) offered by the operating system:</p>

<ul>
  <li>For iOS, <code>SecRandomCopyBytes</code> is used.</li>
  <li>For Android, the entropy is provided by an instance of <code>java.security.SecureRandom</code>.</li>
</ul>

<p>This is usually a good practice, as such primitives are supposed to be safe.</p>

<h3 id="wasm-backend">Wasm backend</h3>

<p>There is a difference with the Wasm target. This module can run on several environments, like any browser supporting Wasm, or Node.js. These platforms do not provide a common strong PRNG, and one cannot get access to the “classic” system interfaces from these environments. For example, a Wasm module running in Chrome for Linux could not directly read <code>/dev/urandom</code>.</p>

<p>To tackle this, a dedicated so-called “secure random generator” has been implemented in <a href="https://github.com/trustwallet/wallet-core/pull/2240">#2240</a>. It is based on a PR made in emscripten (see PR <a href="https://github.com/emscripten-core/emscripten/pull/12240">#12240</a> in emscripten) written precisely to avoid reading <code>/dev/urandom</code>.</p>

<p>According to the author:</p>

<blockquote>
  <p>What we do here is simple, we wrap <code>std::random_device</code> with <code>std::mt19937</code> and return a random uint32 value, inspired by <a href="https://github.com/emscripten-core/emscripten/pull/12240">emscripten-core/emscripten#12240</a>.</p>
</blockquote>

<p><strong>There is an important problem here, which leads to a critical vulnerability for wallet-core for Wasm and for any product relying on it: the PRNG used is a Mersenne Twister, and it should not be used for cryptographic purposes. Moreover, the specialized version mt19937 takes a single 32-bit value as input seed.</strong></p>

<p>What are the consequences here? The custom Random module for Wasm implements two functions: <code>random32</code> which outputs a 32-bit random value, and <code>random_buffer</code> which fills a buffer of arbitrary size with random data. In the Wallet Core project, these functions are exclusively used by trezor-crypto, the cryptographic library developed by Trezor to ensure secure cryptography on their hardware wallets.</p>

<p>Now, let’s see how are generated HD wallets:</p>

<ul>
  <li>Entrypoint is HDWallet. It takes a strength, and a passphrase to protect it later:</li>
</ul>

<div><div><pre><code><span>HDWallet</span><span>::</span><span>HDWallet</span><span>(</span><span>int</span> <span>strength</span><span>,</span> <span>const</span> <span>std</span><span>::</span><span>string</span><span>&amp;</span> <span>passphrase</span><span>)</span>
    <span>:</span> <span>passphrase</span><span>(</span><span>passphrase</span><span>)</span> <span>{</span>
    <span>char</span> <span>buf</span><span>[</span><span>MnemonicBufLength</span><span>];</span>
    <span>const</span> <span>char</span><span>*</span> <span>mnemonic_chars</span> <span>=</span> <span>mnemonic_generate</span><span>(</span><span>strength</span><span>,</span> <span>buf</span><span>,</span> <span>MnemonicBufLength</span><span>);</span>
    <span>if</span> <span>(</span><span>mnemonic_chars</span> <span>==</span> <span>nullptr</span><span>)</span> <span>{</span>
        <span>throw</span> <span>std</span><span>::</span><span>invalid_argument</span><span>(</span><span>&#34;Invalid strength&#34;</span><span>);</span>
    <span>}</span>
    <span>mnemonic</span> <span>=</span> <span>mnemonic_chars</span><span>;</span>
    <span>TW</span><span>::</span><span>memzero</span><span>(</span><span>buf</span><span>,</span> <span>MnemonicBufLength</span><span>);</span>
    <span>updateSeedAndEntropy</span><span>();</span>
<span>}</span>
</code></pre></div></div>
<p><i><small><a href="https://github.com/trustwallet/wallet-core/blob/3.1.0/src/HDWallet.cpp#L45">https://github.com/trustwallet/wallet-core/blob/3.1.0/src/HDWallet.cpp#L45</a></small></i></p>

<ul>
  <li>This functions then calls <code>mnemonic_generate</code> to create a BIP-39 mnemonic:</li>
</ul>

<div><div><pre><code><span>const</span> <span>char</span> <span>*</span><span>mnemonic_generate</span><span>(</span><span>int</span> <span>strength</span><span>,</span> <span>char</span> <span>*</span><span>buf</span><span>,</span> <span>int</span> <span>buflen</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>strength</span> <span>%</span> <span>32</span> <span>||</span> <span>strength</span> <span>&lt;</span> <span>128</span> <span>||</span> <span>strength</span> <span>&gt;</span> <span>256</span><span>)</span> <span>{</span>
    <span>return</span> <span>0</span><span>;</span>
  <span>}</span>
  <span>uint8_t</span> <span>data</span><span>[</span><span>32</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
  <span>random_buffer</span><span>(</span><span>data</span><span>,</span> <span>32</span><span>);</span>
  <span>const</span> <span>char</span> <span>*</span><span>r</span> <span>=</span> <span>mnemonic_from_data</span><span>(</span><span>data</span><span>,</span> <span>strength</span> <span>/</span> <span>8</span><span>,</span> <span>buf</span><span>,</span> <span>buflen</span><span>);</span>
  <span>memzero</span><span>(</span><span>data</span><span>,</span> <span>sizeof</span><span>(</span><span>data</span><span>));</span>
  <span>return</span> <span>r</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p><i><small><a href="https://github.com/trustwallet/wallet-core/blob/3.1.0/trezor-crypto/crypto/bip39.c#L55">https://github.com/trustwallet/wallet-core/blob/3.1.0/trezor-crypto/crypto/bip39.c#L55</a></small></i></p>

<ul>
  <li><code>mnemonic_generate</code> calls <code>random_buffer</code>, which outputs a random buffer filled using a Mersenne twister PRNG, whose instance has just been seeded:</li>
</ul>

<div><div><pre><code><span>void</span> <span>random_buffer</span><span>(</span><span>uint8_t</span><span>*</span> <span>buf</span><span>,</span> <span>size_t</span> <span>len</span><span>)</span> <span>{</span>
    <span>std</span><span>::</span><span>mt19937</span> <span>rng</span><span>(</span><span>std</span><span>::</span><span>random_device</span><span>{}());</span>
    <span>std</span><span>::</span><span>generate_n</span><span>(</span><span>buf</span><span>,</span> <span>len</span><span>,</span> <span>[</span><span>&amp;</span><span>rng</span><span>]()</span> <span>-&gt;</span> <span>uint8_t</span> <span>{</span> <span>return</span> <span>rng</span><span>()</span> <span>&amp;</span> <span>0x000000ff</span><span>;</span> <span>});</span>
    <span>return</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p><i><small><a href="https://github.com/trustwallet/wallet-core/blob/3.1.0/wasm/src/Random.cpp#L19">https://github.com/trustwallet/wallet-core/blob/3.1.0/wasm/src/Random.cpp#L19</a></small></i></p>

<p>As the seed is just 32 bits, the Wasm version of wallet-core allows to create only 2^32 (~4 billion) possible mnemonics. All these mnemonics can be generated in a couple of hours in a single computer.</p>

<p>From there, an attacker is able to:</p>
<ul>
  <li>Compute all the seeds, private keys, then addresses of every cryptocurrency handled by Trust Wallet.</li>
  <li>Scan the related blockchains to extract all the used addresses.</li>
  <li>Compute the intersection to get all the addresses of wallets created by Trust Wallet for Wasm, and steal their funds.</li>
</ul>

<p>Running such attack takes much more than a couple of hours, but is doable with a few GPUs in less than a day (see <a href="https://medium.com/@johncantrell97/how-i-checked-over-1-trillion-mnemonics-in-30-hours-to-win-a-bitcoin-635fe051a752">medium.com/@johncantrell97/how-i-checked-over-1-trillion-mnemonics-in-30-hours-to-win-a-bitcoin</a> for a cost estimation. Attack is 256 times easier here).</p>

<h3 id="application-to-trust-wallet-browser-extension">Application to Trust Wallet browser extension</h3>

<p>The <a href="https://trustwallet.com/browser-extension/">Trust Wallet browser extension</a> is an extension for Chromium-based browsers. It is clearly a MetaMask competitor, and is branded as a “secure multi-chain crypto wallet and gateway to thousands of Web3 decentralized applications (dApps).”</p>

<p>Extension is closed-source, but its code can be easily analyzed. It relies on the vulnerable Wasm implementation of Trust Wallet Core.</p>

<p>When a wallet is created, extension creates a 12-word mnemonic from a random 128-bit seed. Mnemonic is generated this way:</p>

<div><div><pre><code><span>generateMnemonicWallet</span><span>(</span><span>e</span><span>){</span>
<span>return</span> <span>e</span><span>||</span><span>ct</span><span>.</span><span>error</span><span>(</span><span>&#34;Trying to generate wallet without password&#34;</span><span>),</span>
<span>this</span><span>.</span><span>walletCore</span><span>.</span><span>HDWallet</span><span>.</span><span>create</span><span>(</span><span>Js</span><span>.</span><span>DEFAULT_STRENGTH</span><span>,</span><span>e</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p><code>HDWallet.create</code> is the auto-generated Wasm wrapper for the HDWallet constructor described above. That means the vulnerable <code>random_buffer</code> function is used, so mnemonics can be retrieved from the user  address with a brute force attack.</p>

<p>This extension handles the following assets: AVAX, BNB, ETH, MATIC, SOL and TWT.</p>
<ul>
  <li>Addresses are identical for ETH, BNB, MATIC, AVAX and TWT. These are standard Ethereum addresses, sharing the same derivation path (m/44’/60’/0’/0/0).</li>
  <li>Solana uses a different derivation path: m/44’/501’/0’/0’.</li>
</ul>

<p>To drain the funds of all the Trust Wallet extension users, attacker can:</p>
<ul>
  <li>Compute and store every possible mnemonic, then Ethereum private key and Ethereum address, that can be generated by this extension.</li>
  <li>Gather all the used Ethereum addresses created since the first release of the Trust Wallet browser extension, and store them locally.</li>
  <li>Perform a lookup in the address database.</li>
  <li>Empty wallet with the private key, if the address has been used.</li>
</ul>

<p>These steps can be reproduced for every chain. We detail now how the Ledger Donjon implemented this attack on Ethereum and Binance Smart Chain, without, of course, draining the wallets.</p>

<h2 id="attacking-trust-wallet">Attacking Trust Wallet</h2>

<p>The vulnerability allows an attacker to compute mnemonic from any address of a wallet created by the browser extension. For that, one needs to compute a mapping between the possible mnemonics and the resulting address.</p>

<h3 id="generating-all-the-addresses-the-trust-wallet-extension-can-create">Generating all the addresses the Trust Wallet extension can create</h3>

<p>Based on the vulnerability in the PRNG previously explained, it is possible to enumerate all the addresses (and the related private keys) the Trust Wallet extension can create. My idea was to store every possible address in a big table. Then, from a list of addresses extracted from the Ethereum blockchain, one can check if some addresses are present in this table. If so, its private key can be computed.</p>

<p>Derivation from entropy to mnemonic then to Ethereum address uses the standard derivation mechanism <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP-32</a>, <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP-39</a>, and the <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP-44</a> account hierarchy.</p>

<p>First difficulty was to enumerate all these addresses. Transformation from PRNG seed to address requires the following steps:</p>
<ul>
  <li><strong>Entropy generation</strong>: initialize the Mersenne Twister with the seed, and  call it 16 times to gather the initial entropy.</li>
  <li><strong>Entropy to mnemonic</strong>: one SHA-256 to compute the final checksum embedded in the last word.</li>
  <li><strong>Mnemonic to seed</strong>: mnemonic are converted into a 512-bit seed using PKBDF2-HMAC-SHA512 with 2048 iterations. There are 2 SHA-512 computations per iteration, so total cost is 4096 SHA-512 computations.</li>
  <li><strong>Seed to BIP-32 master key</strong>: 1 HMAC SHA-512 costing 2 SHA-512 computations.</li>
  <li><strong>Master key to Ethereum private key</strong>: master key is derived on m/44’/60’/0’/0/0. This requires 3 hardened child private key derivations and 2 normal child key derivations.
    <ul>
      <li>Each hardened child private key derivation requires one HMAC SHA-512 (2 SHA-512) calculation and one addition on secp256k1.</li>
      <li>Each normal child private key derivation requires a child private key derivation, and a scalar multiplication on secp256k1 to convert the private key provided in input to a public key.</li>
    </ul>
  </li>
  <li><strong>Ethereum private key to address</strong>: this last step requires a private to public key conversion, so another scalar multiplication, and one Keccak-256 hash.</li>
</ul>

<p>Total cost for all these steps is then:</p>
<ul>
  <li>Initialization and 16 calls to Mersenne Twister</li>
  <li>1 SHA-256</li>
  <li>4108 SHA-512</li>
  <li>5 point additions</li>
  <li>2 scalar multiplications on secp256k1</li>
</ul>

<p>The most expensive steps are the SHA-512 computations and the scalar multiplications. To make it short, the overall process to transform the PRNG seed to an Ethereum address is slow. Running such computation on a single CPU would take months, and probably several weeks on the CPUs that were available in the Donjon. So, we implemented it using OpenCL (based on <a href="https://github.com/johncantrell97/bip39-solver-gpu">BIP39 Solver GPU</a>) and ran it on 2 NVIDIA GeForce GTX 1080 Ti GPUs.</p>

<p>The output of this tool is a big file containing all the Ethereum addresses that the extension can generate. As there are 2^32 possible seeds, and each address is 20-bytes long, this table takes 80 Gb.</p>

<p>From there, table lookups are slow: to match an address, it would require iterating through all this big table.</p>

<p>To speed up these lookups, we split the table into 256 smaller tables, according to the first byte of the Ethereum address. Each table contains pairs of PRNG seeds, and their resulting Ethereum address.</p>

<p>Finally, to be able to perform fast lookups in each table, we sorted them according to the Ethereum address. It is now possible to do binary searches on these tables: lookups on these sorted tables are very cheap.</p>

<p>To save some disk space, we stored PRNG seed and only the first 8 bytes of each Ethereum address. The last 12 bytes are not necessary, as collisions are negligible in my use-case. Each entry takes then 12 bytes. Whole tables then take 48 Gb.</p>

<p>Here are the timings for each step:</p>

<table>
  <tbody>
    <tr>
      <td>Generate Generate all the Ethereum addresses</td>
      <td>18 hours 24 minutes</td>
    </tr>
    <tr>
      <td>Split into 256 tables</td>
      <td>44 minutes</td>
    </tr>
    <tr>
      <td>Sort the 256 tables</td>
      <td>1 hours 40 minutes</td>
    </tr>
  </tbody>
</table>

<p>Using these tables, it is possible to immediately retrieve the mnemonics used to generate an address.
To assess the impact of the vulnerability, Binance asked me the mnemonic of 3 test addresses they provided. Here is the result:</p>

<div><div><pre><code><span>$</span> <span>time</span> <span>.</span><span>/</span><span>crack_address</span><span>.</span><span>py</span> <span>--</span><span>table</span><span>-</span><span>dir</span> <span>/</span><span>mnt</span><span>/</span><span>traces</span><span>/</span><span>tw</span><span>/</span> <span>0xdf6D9547e163D5E7eafBe2FeB24Bfa12A4C913C0</span> <span>0xE1E0580cb5eA0c0FD034FF2cdfc872ce4493676C</span> <span>0x02b2Ae981b138F066344774A2AD75225A046c377</span>

<span>Address</span><span>:</span> <span>0xdf6D9547e163D5E7eafBe2FeB24Bfa12A4C913C0</span>
<span>RNG</span> <span>seed</span><span>:</span> <span>0xc92b023d</span>
<span>Mnemonic</span><span>:</span> <span>stick</span> <span>bench</span> <span>smart</span> <span>report</span> <span>motor</span> <span>arrive</span> <span>enter</span> <span>river</span> <span>scale</span> <span>manage</span> <span>viable</span> <span>squeeze</span>
<span>Private</span> <span>key</span><span>:</span> <span>84117778e20</span><span>a98f488234c89b6386b4175bb66ccf2fc77d14203f72a5a22686a</span>

<span>Address</span><span>:</span> <span>0xE1E0580cb5eA0c0FD034FF2cdfc872ce4493676C</span>
<span>RNG</span> <span>seed</span><span>:</span> <span>0x1ae841e9</span>
<span>Mnemonic</span><span>:</span> <span>install</span> <span>issue</span> <span>guilt</span> <span>rescue</span> <span>slight</span> <span>barrel</span> <span>gasp</span> <span>vendor</span> <span>glimpse</span> <span>avocado</span> <span>cart</span> <span>frequent</span>
<span>Private</span> <span>key</span><span>:</span> <span>3</span><span>b0df65fe03a210661101172ca2a3e38fd75fdcc580248a2f28587c2ece0bba8</span>

<span>Address</span><span>:</span> <span>0x02b2Ae981b138F066344774A2AD75225A046c377</span>
<span>RNG</span> <span>seed</span><span>:</span> <span>0x2ed51a57</span>
<span>Mnemonic</span><span>:</span> <span>ginger</span> <span>pave</span> <span>slight</span> <span>million</span> <span>pencil</span> <span>flame</span> <span>monkey</span> <span>detect</span> <span>power</span> <span>protect</span> <span>soft</span> <span>derive</span>
<span>Private</span> <span>key</span><span>:</span> <span>95</span><span>a3be70efe04a7c06df98d68c4ccd7d453b0f39f6a097b24f2f2ac48d02494e</span>

<span>real</span>    <span>0</span><span>m0</span><span>,</span><span>207</span><span>s</span>
<span>user</span>    <span>0</span><span>m0</span><span>,</span><span>179</span><span>s</span>
<span>sys</span>     <span>0</span><span>m0</span><span>,</span><span>028</span><span>s</span>
</code></pre></div></div>

<p>Retrieving the 3 mnemonics and private keys took a few hundred milliseconds. According to our tests, <strong>the process is actually fast enough to process in real time all the transactions on the Ethereum blockchain and to break all the vulnerable addresses as soon as they are used</strong>. By caching addresses already tested, the same applies for other blockchains such as BSC.
In this attack scenario, one could monitor transactions when they reach the mempool, and compute sender or recipient private keys in real time.</p>

<h3 id="listing-all-the-used-ethereum-addresses">Listing all the used Ethereum addresses</h3>

<p>What we would like is to estimate the real number of vulnerable wallets, and their balance. This sounds easy, as all the transactions are public, hence all the addresses are available on the blockchain. However, there is no way to directly retrieve the list of the used addresses.</p>

<p>We implemented a method that iterates through every block of the Ethereum blockchain. We extracted the sender and recipient addresses of all the transactions, and the address parameters of every call to ERC-20 contracts.</p>

<p>Note that with this method, only used wallets can be detected: some vulnerable wallets that did not receive assets have never interacted with the blockchain.</p>

<p>We scanned the Ethereum blockchain between blocks 14820000 and 16096000. Block 14820000 was created on May 21 2022, hence just before the pull request that added the vulnerable code in Trust Wallet Core. 16096000 was the latest block when I wrote this post.</p>

<p>Public nodes seem to have a rate limit, so I queried several public nodes in parallel to gather a total of 147,910,120 addresses during several dozen hours. After duplicates are removed, we obtain a list of 32,613,317 unique addresses.</p>

<p>The same method has been used for Binance Smart Chain. Public BSC nodes have been scanned.</p>

<h3 id="estimating-the-number-of-vulnerable-accounts">Estimating the number of vulnerable accounts</h3>

<p>Finally, a tool to test if an address has been created by the Trust Wallet extension has been written. It makes a lookup in the generated tables, gets the PRNG seed, and from there compute the mnemonic, the Ethereum private key and the associated address.</p>

<p>Computation is very fast. Candidate addresses were sorted beforehand to minimize I/O and to perform a nested binary search.
Lookups on the 32 million of addresses take a few minutes using a simple Python script.</p>

<p>Here is an example with an address taken from a <a href="https://twitter.com/NajmulHafej/status/1592316198834036738">public tweet</a> replying to the announcement of the Trust Wallet extension. I took this one as an example as this address has <a href="https://etherscan.io/address/0xE17282BBbD0f32cA98683933382633ab6d9778B0">never been used</a>, so user funds are not at risk.</p>

<div><div><pre><code><span>$</span> <span>time</span> <span>python3</span> <span>pwn_address</span><span>.</span><span>py</span> <span>0xE17282BBbD0f32cA98683933382633ab6d9778B0</span>
<span>RNG</span> <span>seed</span><span>:</span> <span>0x8ec170a8</span>
<span>Mnemonic</span><span>:</span> <span>sorry</span> <span>slush</span> <span>already</span> <span>pass</span> <span>garden</span> <span>decade</span> <span>grid</span> <span>drip</span> <span>machine</span> <span>cradle</span> <span>call</span> <span>put</span>
<span>Private</span> <span>key</span><span>:</span> <span>b9168c1fab55f840a5e04d96f7a38cb8803b67ec7c41f720fb6c487c08f3d536</span>
<span>​</span>
<span>real</span>   <span>0</span><span>m0</span><span>,</span><span>194</span><span>s</span>
<span>user</span>   <span>0</span><span>m0</span><span>,</span><span>170</span><span>s</span>
<span>sys</span>     <span>0</span><span>m0</span><span>,</span><span>024</span><span>s</span>
</code></pre></div></div>

<p>Tool has been run on the dataset of 1,873,720 detailed above. Testing all the addresses and computing the private keys of vulnerable accounts took 4 min 22s, so it is very cheap.</p>

<p>With this list of vulnerable private keys, it’s possible to list all the corresponding addresses, their balances and obviously to drain them… During our investigations, around $30 millions were at risk at some point, but we didn’t monitor all chains and tokens overtime.</p>



<h3 id="2022-november-the-17th">2022, November the 17th</h3>

<p>Vulnerability has been reported to Binance using their <a href="https://bugcrowd.com/binance">bug bounty program</a> on 2022, November the 17th.</p>

<p>To confirm the vulnerability, Binance sent us 3 addresses and asked them to provide mnemonics:</p>

<blockquote>
  <p>Can you please try to run your tool and provide mnemonics for these 3 addresses?</p>

  <p>Wallet 1 - 0xdf6D9547e163D5E7eafBe2FeB24Bfa12A4C913C0 </p>

  <p>Thanks! </p>
</blockquote>

<p>Once all the possible addresses have been precomputed, retrieving the mnemonic from an address is as simple as a lookup in a 4-billion entries table. The three mnemonics have been retrieved in 0.2s:</p>

<div><div><pre><code><span>$</span> <span>time</span> <span>.</span><span>/</span><span>pwn_address</span><span>.</span><span>py</span> <span>0xdf6D9547e163D5E7eafBe2FeB24Bfa12A4C913C0</span> <span>0xE1E0580cb5eA0c0FD034FF2cdfc872ce4493676C</span> <span>0x02b2Ae981b138F066344774A2AD75225A046c377</span>
<span>Address</span><span>:</span> <span>0xdf6D9547e163D5E7eafBe2FeB24Bfa12A4C913C0</span>
<span>RNG</span> <span>seed</span><span>:</span> <span>0xc92b023d</span>
<span>Mnemonic</span><span>:</span> <span>stick</span> <span>bench</span> <span>smart</span> <span>report</span> <span>motor</span> <span>arrive</span> <span>enter</span> <span>river</span> <span>scale</span> <span>manage</span> <span>viable</span> <span>squeeze</span>
<span>Private</span> <span>key</span><span>:</span> <span>84117778e20</span><span>a98f488234c89b6386b4175bb66ccf2fc77d14203f72a5a22686a</span>
<span>​</span>
<span>Address</span><span>:</span> <span>0xE1E0580cb5eA0c0FD034FF2cdfc872ce4493676C</span>
<span>RNG</span> <span>seed</span><span>:</span> <span>0x1ae841e9</span>
<span>Mnemonic</span><span>:</span> <span>install</span> <span>issue</span> <span>guilt</span> <span>rescue</span> <span>slight</span> <span>barrel</span> <span>gasp</span> <span>vendor</span> <span>glimpse</span> <span>avocado</span> <span>cart</span> <span>frequent</span>
<span>Private</span> <span>key</span><span>:</span> <span>3</span><span>b0df65fe03a210661101172ca2a3e38fd75fdcc580248a2f28587c2ece0bba8</span>
<span>​</span>
<span>Address</span><span>:</span> <span>0x02b2Ae981b138F066344774A2AD75225A046c377</span>
<span>RNG</span> <span>seed</span><span>:</span> <span>0x2ed51a57</span>
<span>Mnemonic</span><span>:</span> <span>ginger</span> <span>pave</span> <span>slight</span> <span>million</span> <span>pencil</span> <span>flame</span> <span>monkey</span> <span>detect</span> <span>power</span> <span>protect</span> <span>soft</span> <span>derive</span>
<span>Private</span> <span>key</span><span>:</span> <span>95</span><span>a3be70efe04a7c06df98d68c4ccd7d453b0f39f6a097b24f2f2ac48d02494e</span>
<span>​</span>
<span>real</span>    <span>0</span><span>m0</span><span>,</span><span>229</span><span>s</span>
<span>user</span>    <span>0</span><span>m0</span><span>,</span><span>194</span><span>s</span>
<span>sys</span>     <span>0</span><span>m0</span><span>,</span><span>021</span><span>s</span>
</code></pre></div></div>

<h3 id="2022-november-the-21st">2022, November the 21st</h3>

<p>A few days after, on November the 21st, Trustwallet team <a href="https://github.com/trustwallet/wallet-core/commit/d3c2eee16b154cbb69e8959b01e5e71fbabb1212">publicly committed</a> on Github the fix avoiding the generation of new flawed seeds. We were quite worried someone would notice it and exploit the vulnerability.</p>

<h3 id="2022-november">2022, November</h3>

<p>Trustwallet team updated the app to warn their users, prevent them from generating new flawed seeds and removed the receiving flows.</p>

<p>From there, we monitored the situation and the funds at risk. Only a few days after the release of this vulnerable wallets, around $30 millions were at risk.</p>

<h3 id="2023-march">2023, March </h3>

<p>Trustwallet team granted us the highest bounty they offer : $100k</p>

<h3 id="2023-april-the-22nd">2023, April the 22nd</h3>

<p>After months waiting for users to migrate their funds, Trustwallet team disclosed the vulnerability and wrote a <a href="https://community.trustwallet.com/t/browser-extension-wasm-vulnerability-postmortem/750787">postmortem</a>. As of now, there are still  wallets with remaining funds that can be stolen (~$100k). Trust Wallet promised the reimbursement of stolen funds.</p>

<center>
  <figure>
    <img src="https://blog.ledger.com/assets/funds-of-every-wallet-could-have-been-stolen/tweet.png"/>
  </figure>
</center>

<h2 id="conclusion">Conclusion</h2>

<p>This vulnerability illustrates the worst case scenario of a crypto bug - compromised accounts forever.</p>

<p>Creating good randomness is a daunting task - Ledger devices rely on dedicated silicon logic in our certified smartcard chips that have been the gold standard of secure industries for the past 40 years to guarantee high quality randomness and tamper resistance.</p>

<p>Given the complexity of contacting the owners of those accounts and the possibility to use those compromised accounts on all kinds of different software and hardware wallets, TrustWallet did a pretty fine job reducing the risk for their users.</p>

<p>In the (very) (near) future it’s likely that bots will fight to be the first to steal funds deposited to those addresses, similar to <a href="https://github.com/ryancdotorg/brainflayer">what happened with brain wallets in the past</a>.</p>

<p>Special thanks to Jean-Baptiste Bédrune for saving the world. Only a few days after the release of the Trust Wallet extension, almost $30 millions were at risk. A nightmare scenario could have occurred if an attacker found the vulnerability after a couple of months.</p>

<p>During our investigations, we also noticed that a few addresses were vulnerable while they had been generated a long time before the Trust Wallet release. That probably means this vulnerability exists in some other wallet implementations which is concerning…</p>

                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            

            

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            

        </article>

    </div>
</div></div>
  </body>
</html>
