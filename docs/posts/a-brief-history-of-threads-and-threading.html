<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eclecticlight.co/2025/09/20/a-brief-history-of-threads-and-threading/">Original</a>
    <h1>A brief history of threads and threading</h1>
    
    <div id="readability-page-1" class="page"><article id="post-88506">
	
	<!-- .entry-header -->

	
		<div data-first_letter="T">
		<p>The original 128K Mac from 1984 came with a single Motorola 68000 processor running at 8 MHz that could only run one app at a time. Yet today’s Macs come with multiple CPU cores that can comfortably run several substantial apps simultaneously, while running a Time Machine backup and other tasks in the background. This brief history outlines the journey between them.</p>
<p>A processor with a single core and no support for multi-tasking runs one sequence of instructions at a time. When those call for an operating system function to be performed, the running app is interrupted to hand control over to the system, and once that has completed, control is passed back to the app. That’s what the first Macs did until Andy Hertzfeld wrote <em>Switcher,</em> released by Apple in April 1985. This allowed the user to switch between running more than one app, but was still limited to running just one of them at a time.</p>
<h4>Multitasking</h4>
<p>Over the next couple of years, some third-party utilities were produced to go further than Switcher, but it wasn’t until 1987 that <em>MultiFinder</em> replaced Switcher, and was integrated into System 7 in 1991. Developed by Erich Ringewald and Phil Goldman, this brought cooperative multitasking, which was to become the mainstay of classic Mac OS.</p>
<p>In computers with a single processor core, multitasking is a way of cheating to give the impression that the processor is doing several things at once, when in fact all it’s doing is switching rapidly between two or more different programs. There are two fundamental models for doing that:</p>
<ul>
<li><em>cooperative multitasking,</em> in which individual tasks yield to give others processing time;</li>
<li><em>preemptive multitasking,</em> in which a scheduler switches between tasks at regular intervals.</li>
</ul>
<p>When a processor switches from one task to the next, the current task state must be saved so it can be resumed later. Once that’s complete, the next task is loaded to complete the context switch. That incurs overhead, both in terms of processing and in memory storage, which are less when switching between lightweight tasks. Different strategies have been adopted to determine the optimum size of tasks and overhead imposed by context switching, and terminology differs between them, variously using words such as <em>processes, threads</em> and even <em>fibres,</em> which can prove thoroughly confusing.</p>
<p>Classic Mac OS thus has a Process Manager that launches apps in cooperative multitasking. This works well much of the time, but lets badly behaved tasks hog the processor and block other tasks from getting their fair share. It’s greatly aided by the <em>main event loop</em> at the heart of Mac apps that waits for control input to direct the app to perform work for the user. But when an app charges off to spend many seconds tackling a demanding task without polling its main event loop, that app could lock the user out for what seems like an age.</p>
<p>In February 1988 Apple released the first Unix for Macintosh, <a href="https://en.wikipedia.org/wiki/A/UX" target="_blank" rel="noopener">A/UX</a>, which came with preemptive multitasking. That was added to Mac OS in 1996 in System 7.5.3, in <em>Multiprocessing Services,</em> and further enhanced in Mac OS 8.6 three years later. Cooperative multitasking was also supported by the <em>Thread Manager.</em></p>
<h4>Threads</h4>
<p>In 2000 Apple’s hardware and software changed radically. Its first Macs with dual processors came in PowerPC 7400 (G4) chips in Power Mac G4 desktop systems, and Mac OS X brought several types of thread that could be used to manage processing on multiple processors or CPU cores, together with preemptive multitasking. Thread types include low-level Mach threads, higher-level POSIX threads or Pthreads that replaced Multiprocessing Services, Java Threads, Cocoa’s NSThreads, and cooperatively scheduled threads using the <em>Carbon Thread Manager.</em> The following diagram summarises Apple’s current terminology.</p>
<p><span><img data-attachment-id="81034" data-permalink="https://eclecticlight.co/multiterms1/" data-orig-file="https://eclecticlight.co/wp-content/uploads/2024/06/multiterms1.png" data-orig-size="996,934" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="multiterms1" data-image-description="" data-image-caption="" data-medium-file="https://eclecticlight.co/wp-content/uploads/2024/06/multiterms1.png?w=300" data-large-file="https://eclecticlight.co/wp-content/uploads/2024/06/multiterms1.png?w=940" src="https://eclecticlight.co/wp-content/uploads/2024/06/multiterms1.png" alt="multiterms1" width="996" height="934" srcset="https://eclecticlight.co/wp-content/uploads/2024/06/multiterms1.png 996w, https://eclecticlight.co/wp-content/uploads/2024/06/multiterms1.png?w=150&amp;h=141 150w, https://eclecticlight.co/wp-content/uploads/2024/06/multiterms1.png?w=300&amp;h=281 300w, https://eclecticlight.co/wp-content/uploads/2024/06/multiterms1.png?w=768&amp;h=720 768w" sizes="(max-width: 996px) 100vw, 996px"/></span></p>
<p>In most cases, we’re considering <strong>applications</strong> with a GUI, normally run from a bundle structure. These can in turn run their own code, such as privileged helper apps used to perform work that requires elevated privileges. In recent years, there has been a proliferation of additional executable code associated with many apps.</p>
<p>When that app is run, there’s a single runtime instance created from its single executable code, and given its own virtual memory and access to system resources that it needs. This is a <strong>process</strong>, and listed as such in Activity Monitor, for example.</p>
<p>Each process has a main <strong>thread</strong>, a single flow of code execution, and may create additional threads, perhaps to run in the background. Threads don’t get their own virtual memory, but share that allocated to the process, although they have their own stack. On Apple silicon Macs they’re easy to tell apart as they can only run on a single core, although they may be moved between cores, sometimes rapidly.</p>
<p>Within each thread are individual <strong>tasks</strong>, each a quantity of work to be performed. These can be brief sections of code and are more interdependent than threads. They’re often divided into synchronous and asynchronous tasks, depending on whether they need to be run as part of a strict sequence.</p>
<p>In 2005 the Power Mac G5 was the first Mac to use dual-core PowerPC G5 processors, then the iMac 17-inch of the following year used Apple’s first Intel Core Duo processor with two cores.</p>
<h4>Grand Central Dispatch</h4>
<p>In 2009 Mac OS X 10.6 Snow Leopard introduced a new dispatcher, named <em>Grand Central Dispatch</em> (GCD) after Grand Central Terminal in New York City, and that was enhanced in macOS Sierra a decade later. More recently it has been referred to simply as <em>Dispatch.</em></p>
<p>At its heart, GCD is a dispatcher managing queues of tasks, activating those that need most to be run, and leaving the less pressing to wait a bit longer. It has its own queues, as well as those assembled by apps. Some are run as simple queues with a first in first out rule, others using sophisticated heuristics to determine relative priorities. There’s a detailed account of GCD internals in Jonathan Levin’s book <em>*OS Internals</em> volume 1, and Apple’s current developer documentation <a href="https://developer.apple.com/documentation/dispatch" target="_blank" rel="noopener">is here</a>.</p>
<p>GCD was introduced for Macs with multiple identical cores, to support their symmetric multiprocessing (SMP), and with the release of the first Apple silicon Macs in November 2020 it has managed queues of threads to be dispatched for execution on two CPU core types, Performance and Efficiency. Core allocation is now managed according to the Quality of Service (QoS) assigned to each thread. When used on SMP processors with no contention for core availability, QoS has limited effects on thread performance, but performance on P and E cores may differ by a factor of 10.</p>
<p>Over the last 41 years, macOS has gained thorough support for getting the best performance from multiple tasks, threads, and processes in chips that contain up to 32 CPU cores of two types – a far cry from that single 68000 processor.</p>
	</div><!-- .entry-content -->

	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
