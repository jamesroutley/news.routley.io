<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.burntsushi.net/regex-internals/">Original</a>
    <h1>Regex engine internals as a library</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <div role="main">
    <div>
      

      <article>
      <p>Over the last several years, I’ve rewritten <a href="https://github.com/rust-lang/regex/">Rust’s <code>regex</code>
crate</a> to enable better internal composition, and to make it
easier to add optimizations while maintaining correctness. In the course of
this rewrite I created a new crate, <a href="https://github.com/rust-lang/regex/tree/master/regex-automata"><code>regex-automata</code></a>, which exposes much
of the <code>regex</code> crate internals as their own APIs for others to use. To my
knowledge, this is the first regex library to expose its internals to the
degree done in <code>regex-automata</code> as a separately versioned library.</p>
<p>This blog post discusses the problems that led to the rewrite, how the rewrite
solved them and a guided tour of <code>regex-automata</code>’s API.</p>
<p><strong>Target audience</strong>: Rust programmers and anyone with an interest in how one
particular finite automata regex engine is implemented. Prior experience with
regular expressions is assumed.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#brief-history">Brief history</a></li>
<li><a href="#the-problems">The problems</a>
<ul>
<li><a href="#problem-composition-was-difficult">Problem: composition was difficult</a></li>
<li><a href="#problem-testing-was-difficult">Problem: testing was difficult</a></li>
<li><a href="#problem-requests-for-niche-apis">Problem: requests for niche APIs</a></li>
<li><a href="#problem-fully-compiled-dfas">Problem: fully compiled DFAs</a></li>
</ul>
</li>
<li><a href="#follow-along-with-regex-cli">Follow along with regex-cli</a></li>
<li><a href="#flow-of-data">Flow of data</a></li>
<li><a href="#literal-optimizations">Literal optimizations</a>
<ul>
<li><a href="#motivating-literal-optimizations">Motivating literal optimizations</a></li>
<li><a href="#literal-extraction">Literal extraction</a></li>
<li><a href="#searching-for-literals">Searching for literals</a></li>
</ul>
</li>
<li><a href="#the-nfa-data-type">The NFA data type</a>
<ul>
<li><a href="#a-simple-nfa-example">A simple NFA example</a></li>
<li><a href="#nfa-optimization-sparse-states">NFA optimization: sparse states</a></li>
<li><a href="#nfa-optimization-minimal-utf-8-automata">NFA optimization: minimal UTF-8 automata</a></li>
<li><a href="#nfa-optimization-literal-trie">NFA optimization: literal trie</a></li>
<li><a href="#nfa-future-work">NFA future work</a></li>
</ul>
</li>
<li><a href="#regex-engines">Regex engines</a>
<ul>
<li><a href="#common-elements-among-regex-engines">Common elements among regex engines</a></li>
<li><a href="#engine-pike-vm">Engine: Pike VM</a></li>
<li><a href="#engine-bounded-backtracker">Engine: bounded backtracker</a></li>
<li><a href="#engine-one-pass-dfa">Engine: one-pass DFA</a></li>
<li><a href="#engine-dfa">Engine: DFA</a></li>
<li><a href="#engine-hybrid-nfadfa">Engine: hybrid NFA/DFA</a></li>
<li><a href="#the-meta-regex-engine">The meta regex engine</a></li>
</ul>
</li>
<li><a href="#differences-with-re2">Differences with RE2</a></li>
<li><a href="#testing-strategy">Testing strategy</a></li>
<li><a href="#benchmarking">Benchmarking</a></li>
<li><a href="#costs">Costs</a></li>
<li><a href="#wrap-up">Wrap up</a></li>
</ul>
<h2 id="brief-history">Brief history</h2>
<p>In September 2012, an <a href="https://github.com/rust-lang/rust/issues/3591">issue was filed on the Rust
repository</a> requesting that a regex library be added to the
Rust Distribution. Graydon Hoare later <a href="https://github.com/rust-lang/rust/issues/3591#issuecomment-17009497">commented in that thread</a>
that they preferred RE2. For those that don’t know, <a href="https://github.com/google/re2">RE2</a> is a regex engine
that uses finite automata to guarantee <code>O(m * n)</code> worst case search time
while providing a Perl-like syntax that excludes features that are not known
how to implement efficiently. RE2’s design is described by its author, Russ
Cox, in a <a href="https://swtch.com/~rsc/regexp/">series of articles on implementing a regex engine using finite
automata</a>.</p>
<p>In April 2014, I <a href="https://github.com/rust-lang/rust/issues/3591#issuecomment-39582811">showed up and said I was working on a regex engine inspired
by RE2</a>. I treated Cox’s articles as a blueprint for how to
build a regex library. Soon there after, I <a href="https://github.com/rust-lang/rfcs/pull/42">published an RFC to add a regex
library to the “Rust Distribution.”</a> This was before Rust 1.0
and Cargo (the second version, not <a href="https://github.com/rust-lang/rust/pull/1149">the first</a>), and the “Rust
Distribution” referred to <code>rustc</code>, <code>std</code> and several “supporting” libraries
that were all bundled together. This RFC proposed adding a <code>regex</code> crate to
that list of supporting libraries.</p>
<p>Ten days later, <a href="https://github.com/rust-lang/rfcs/pull/42#issuecomment-41104032">the RFC was approved</a>. The next
day, I <a href="https://github.com/rust-lang/rust/pull/13700">submitted a pull request to <code>rust-lang/rust</code></a>,
adding it to the Rust distribution. Things moved fast back then. Notice also
that I had originally called the crate <code>regexp</code>. The PR to Rust involved a
discussion about naming that eventually resulted in it being called <code>regex</code>
instead.</p>
<p>Two years later in May 2016, I <a href="https://github.com/rust-lang/rfcs/pull/1620">wrote an RFC to release <code>regex 1.0</code></a>. That took a few months to be approved, but it wasn’t
until a couple years later in May 2018 that I <a href="https://github.com/rust-lang/regex/pull/471">actually released <code>regex 1.0</code></a>.</p>
<p>Before <code>regex 1.0</code> was released, I had been steadily working on a complete
re-imagining of the crate internals. From a <a href="https://github.com/rust-lang/regex/commit/715a8072890af65d2095d39f534b4b3dc4caeae2">commit message in March
2018</a>:</p>
<blockquote>
<p>The [regex-syntax] rewrite is intended to be the first phase in an effort to
overhaul the entire regex crate.</p>
</blockquote>
<p>I didn’t know exactly where I was going at that point in time, but in
March 2020, I started work in earnest on rewriting the actual matching
engines. A little more than three years later, <a href="https://github.com/rust-lang/regex/blob/master/CHANGELOG.md#190-2023-07-05"><code>regex 1.9</code> has been
released</a> with the completed rewrite.</p>
<h2 id="the-problems">The problems</h2>
<p>What kinds of problems were facing the <code>regex</code> crate that warranted a full
rewrite? And moreover, why publish the rewritten internals as its own crate?</p>
<p>There are a host of things to discuss here.</p>
<h3 id="problem-composition-was-difficult">Problem: composition was difficult</h3>
<p>Following in the <a href="https://swtch.com/~rsc/regexp/">tradition of RE2</a>, the <code>regex</code> crate contains a
number of different strategies that it can use to implement a search. Sometimes
<em>multiple</em> strategies are used in a single search call.</p>
<p>There are generally two dimensions, often at odds with one another, to each
strategy: performance and functionality. Faster strategies tend to be more
limited in functionality. For example, a fast strategy might be able to report
the start and end of a match but not the offsets for each capture group in the
regex. Conversely, a slower strategy might be needed to report the offsets of
each capture group.</p>
<p>When I originally wrote the <code>regex</code> crate, I implemented a single strategy
(the <code>PikeVM</code>) and didn’t do any thoughtful design work for how to incorporate
alternative strategies. Eventually, new strategies were added organically:</p>
<ul>
<li>A <code>BoundedBacktracker</code> that can report capture group offsets like the
<code>PikeVM</code>, but does so using a backtracking strategy. Its main limitation is the
memory used to ensure its backtracking is bounded to <code>O(m * n)</code>, so it can only
be used for small haystacks/regexes. Its main upside is that its usually faster
than the <code>PikeVM</code>.</li>
<li>A hybrid NFA/DFA (also know as a “lazy DFA”) that can execute very quickly,
but can only report the start and end of a match. It ignores capture groups
completely.</li>
<li>A literal strategy where a regex corresponds to a language that is both
finite and small. Examples: <code>foo</code>, <code>foo{2}</code>, <code>foo|bar</code>, <code>foo[1-3]</code>. In this
case, we could just use a single or multi-substring search algorithm without
any kind of regex engine at all.</li>
</ul>
<p>(We’ll get into why these strategies have these trade offs in more detail later
in the blog.)</p>
<p>And with the above strategies came the composition of them:</p>
<ul>
<li>When the caller requests capture group offsets, it is usually faster to
run the lazy DFA first to find the bounds of a match, and then only run the
<code>PikeVM</code> or <code>BoundedBacktracker</code> to find the capture group offsets. In this
way, especially for cases where matches are somewhat rare, most of the work is
done by the much faster lazy DFA.</li>
<li>When a regex begins with a prefix that corresponds to a small finite
language, we can implement a <em>prefilter</em> that searches for occurrences of
that language. Each occurrence corresponds to a <em>candidate match</em> for the
overall regex. For each such candidate match, we run the full regex engine to
confirm whether it’s an actual match or not. So for example, <code>foo\w+</code> would
look for occurrences of <code>foo</code> in a haystack, and then run the regex <code>foo\w+</code>
at the offset at which the occurrence of <code>foo</code> began. If there’s a match, stop
and report it. Otherwise, restart the search for <code>foo</code> after the previous
occurrence of <code>foo</code>.</li>
</ul>
<p>Over time, I wanted to add both more strategies <em>and</em> add more ways of
composing them. But in an organically grown infrastructure, the <code>regex</code>
crate was beginning to buckle under its weight. Loosely speaking, all of the
following were problems:</p>
<ul>
<li>Not all strategies were necessarily designed to be composed with others.
The <code>PikeVM</code>, for example, was the first strategy and it suffered from this.
Specifically, it could not deal with starting and stopping a search in a
subsequence of a slice, which is necessary in order to compose it with the lazy
DFA. For example, at one point, the <code>PikeVM</code> would say that <code>\babc\b</code> matched
in <code>abcxyz</code> if its search started at offset <code>0</code> and ended at offset <code>3</code>. But
the trailing <code>\b</code> should not match after <code>c</code> because a <code>x</code> follows it.</li>
<li>It was difficult to reason about which strategy would be used for any given
regex.</li>
<li>There were repeated <code>match</code> expressions re-implementing various logic that
was easy to go out of sync.</li>
<li>The construction of a regex did not holistically account for the fact that
some strategies don’t need to be constructed at all. For example, I at one
point added an optimization to the <code>regex</code> crate (prior to the rewrite) that
just used <a href="https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm">Aho-Corasick</a> for regexes like <code>foo1|foo2|...|fooN</code>, but it was
extremely hacky to do that in a way that didn’t <em>also</em> result in a <a href="https://en.wikipedia.org/wiki/Thompson%27s_construction">Thompson
NFA</a> being unnecessarily built that would never actually be used.</li>
</ul>
<p>Basically, at the very least, many of the strategies needed a makeover and the
infrastructure that composes them probably needed to be rewritten.</p>
<h3 id="problem-testing-was-difficult">Problem: testing was difficult</h3>
<p>While the <code>regex</code> crate exposes a public interface that acts as a single regex
engine, as we just discussed, it uses multiple strategies internally depending
on the situation. Many of these strategies are regex engines themselves, and it
is absolutely critical that they behave the same on the same inputs.</p>
<p>As one example, a common case is when the caller requests the offsets of each
capture group in a match. The way this usually works is to run the lazy DFA
to find the bounds of the match, and then a slower regex engine like the
<code>PikeVM</code> or the <code>BoundedBacktracker</code> on the bounds of the match to report the
capture group offsets. What happens then, if the lazy DFA finds a match where
the other engines don’t? Oops. It’s a bug.</p>
<p>The problem here is that prior to <code>regex 1.9</code>, all of the strategies used
internally are not part of any public API, and that makes them difficult to
independently test. One can of course test the public API, but the logic for
selecting which internal regex engines to use is complicated enough that there
isn’t always a clear and obvious mapping between the pattern itself and which
regex engine will be used internally. Moreover, that mapping can change as the
logic evolves. So writing tests just against the public API is not something
that gives us clear coverage over all of the internal engines. And even if one
could do it, it would make debugging test failures more annoying than necessary
because you have to reason through the logic for which strategies are selected.</p>
<p>One approach to this is to put all tests inside the crate so that tests have
access to internal APIs. But you really want to leverage the same tests
across all of the engines, so doing this requires defining the tests in some
structured format, looping over them and running them on each engine. Since the
test infrastructure was not written with testing each individual strategy in
mind, I ended up not going this route.</p>
<p>Instead, I did some unholy hacks to make the existing test suite work:</p>
<ul>
<li>I exposed <a href="https://github.com/rust-lang/regex/blob/5a34a39b72d85730065d3ffe4ce3715f2731e49a/src/lib.rs#L790-L801">some internal APIs</a> to make it possible
to configure and build the internal strategies from outside the crate.</li>
<li>I made it so one could actually build the main <code>Regex</code> type from those
internal APIs using an <a href="https://github.com/rust-lang/regex/blob/5a34a39b72d85730065d3ffe4ce3715f2731e49a/src/re_unicode.rs#L174-L179">undocumented <code>From</code> implementation</a>.</li>
<li>I wrote the tests using <a href="https://github.com/rust-lang/regex/blob/5a34a39b72d85730065d3ffe4ce3715f2731e49a/tests/fowler.rs#L5">macros</a>.</li>
<li>I created test targets for each internal regex engine I wanted to test,
and each test target was responsible for <a href="https://github.com/rust-lang/regex/blob/5a34a39b72d85730065d3ffe4ce3715f2731e49a/tests/test_backtrack.rs#L3-L11">defining the aforementioned
macros</a> in a way that used the regex engine I wanted to
test.</li>
</ul>
<p>This was overall a hacky mess and it really needed a rethink. Exposing the
internal engines in their own public API was not strictly a requirement to
improve the situation, but it does make it possible to run a test suite across
all engines without either relying on undocumented APIs or putting the tests
inside the crate itself.</p>
<h3 id="problem-requests-for-niche-apis">Problem: requests for niche APIs</h3>
<p>Over the years, there were several requests for additional APIs to the <code>regex</code>
crate, but were ones I considered too niche to be worth expanding the API
surface, or where I wasn’t totally clear on what the API ought to be.</p>
<p>One of the most popular such requests was better multi-pattern support. Namely,
the <code>regex</code> crate provides a <a href="https://docs.rs/regex/latest/regex/struct.RegexSet.html"><code>RegexSet</code></a> API that permits one to search for
possibly overlapping matches of zero or more regexes. The catch is that the API
only reports which patterns matched anywhere in the haystack. One cannot use
the API to get either the match offsets or the offsets of capture groups. While
useful, it isn’t as useful as it could be if it supported the full <code>Regex</code> API.</p>
<p>As with adding multiple internal regex engines and the testing strategy, the
<code>RegexSet</code> API was bolted on to the existing implementation in a fairly hacky
way. Making it capable of reporting match offsets would require either a major
refactoring of all existing engines or a rewrite.</p>
<p>But separately from that, it wasn’t totally clear to me how to expose APIs that
report match offsets in the context of the overlapping search done by the
<code>RegexSet</code> APIs. Having more room to experiment with alternative APIs, for
example, a <code>RegexSet</code> that does non-overlapping searches and reports match
offsets, would be something that others could use without needing to complicate
the <code>regex</code> crate API.</p>
<p>There have been other requests for additional APIs too:</p>
<ul>
<li>The ability to execute an anchored search without needing to put a <code>^</code> in the
pattern. This is especially useful in the context of running a regex on a
<em>part</em> of the haystack that you know matches, but where you want to extract
capture groups. It’s also useful in the context of an iterator that only
reports adjacent matches. The <code>regex</code> crate could be augmented to support this,
but there’s no easy way of extending existing APIs without either duplicating
all of the search routines, or unnecessarily making “anchored mode” an option
that one can pass to the regex. (Which, at that point, you might as well just
put <code>^</code> at the beginning of the pattern.)</li>
<li>The ability to run a regex search without it doing synchronization internally
to get mutable scratch spaced used for a search. One might want to do this
to avoid those synchronization costs in some cases. But to do it would in turn
also require duplicating search APIs and exposing a new type that represents
the “mutable scratch space.”</li>
<li>Executing a <a href="https://github.com/rust-lang/regex/issues/425">regex on streams and/or non-contiguous
haystacks</a>. This is especially useful for running a regex on
data structures like ropes, which are often found in text editors. This is a
big topic and not a problem I’ve even attempted to approach, but my hope is
that with more of the <code>regex</code> crate internals exposed, it might be tractable
for others to more easily experiment with solutions to this problem.</li>
</ul>
<p>By publishing a new separately versioned crate that contains much of the
<code>regex</code> crate internals, it provides “breathing room” for more APIs that folks
want without needing to clutter up the general purpose regex API that services
the vast majority of all regex use cases. Namely, by targeting the crate toward
“expert” use cases, we make no show of trying to keep the API small and simple.
Indeed, as we’ll see, the API of <code>regex-automata</code> is sprawling and complex. And
by making it separately versioned, we can put out breaking change releases at a
much faster cadence than what we do for the <code>regex</code> crate.</p>
<p>This line of reasoning is not too dissimilar from the line of reasoning that
led to the publication of the <a href="https://docs.rs/regex-syntax"><code>regex-syntax</code></a> crate. Namely, folks (including
myself) wanted access to a regex parser for their own projects. I certainly
didn’t want to expose a parser in the <code>regex</code> crate itself because of the added
complexity and the fact that I wanted to be able to evolve the parser and its
data types independently of the <code>regex</code> crate. (That is, <code>regex-syntax</code> has
breaking change releases more frequently than <code>regex</code> itself.) By putting it
into a separate crate, I could simultaneously use it as an implementation
detail of the <code>regex</code> crate while also making it available for others to use.</p>
<h3 id="problem-fully-compiled-dfas">Problem: fully compiled DFAs</h3>
<p>The birth of <code>regex-automata</code> was not actually the result of my crusade to
rewrite the regex crate. Its birth coincided with a desire to build fully
compiled DFAs, serialize them and then provide a barebones search runtime that
could zero-copy deserialize those DFAs and use them for a search. I used the
original version of <code>regex-automata</code> to <a href="https://github.com/BurntSushi/bstr/tree/b3cab1905c46ad7de78a032a61eef0437ed7fb58/src/unicode/fsm">build DFAs</a> for implementing
various Unicode algorithms inside of <a href="https://github.com/BurntSushi/bstr"><code>bstr</code></a>.</p>
<p>In the course of building the initial version of <code>regex-automata</code>, I realized
that I needed to rebuild an NFA data structure and a compiler for it that was
very similar to one found in the <code>regex</code> crate. At a certain point, I began
wondering whether it might be possible to share that code since it is quite
non-trivial and a place where a lot of interesting optimizations occur.</p>
<p>I had briefly considered building a new crate like <code>regex-nfa</code> that both the
<code>regex</code> crate and <code>regex-automata</code> could depend upon. But after more thought,
it became apparent that there was more code that could be shared between
<code>regex-automata</code> and <code>regex</code>. For example, a lot of the <a href="https://en.wikipedia.org/wiki/Powerset_construction">determinization</a>
process can be written generically such that it works for both fully compiled
DFAs and for lazy DFAs.</p>
<p>At that point, the right abstraction boundary seemed like it was closer to
“regex engine” than it was “an NFA.” So I reframed <code>regex-automata</code> as less
about <em>just</em> DFAs and more about a menagerie of regex engines. The plan at that
point was, roughly, to put all of the regex engines in <code>regex-automata</code> and
make the <code>regex</code> crate itself just a thin wrapper around <code>regex-automata</code>. By
setting things up this way, it should reduce the friction from migrating from
the <code>regex</code> crate to <code>regex-automata</code> if one should need access to the lower
level APIs.</p>
<p>In this way, we can build fully compiled DFAs using precisely the same code
that the <code>regex</code> crate uses for its lazy DFA. And precisely the same code that
the <code>regex</code> crate uses to convert the parsed representation of a regex pattern
into an NFA. Heck, this even makes it possible to use fully compiled DFAs in
the <code>regex</code> crate in some cases. (This is normally a big no-no in a general
purpose regex engine because fully compiled DFAs are not only quite bloated,
but they take worst case exponential time to build. That is very inappropriate
for a regex engine you might use to compile untrusted patterns, or even in
cases where you just need compilation time of a regex to be “reasonable.”
Building a DFA may not be reasonable, especially when Unicode is involved.)</p>
<h2 id="follow-along-with-regex-cli">Follow along with regex-cli</h2>
<p><code>regex-cli</code> is a program maintained as part of <code>regex</code> crate that provides
convenient command line access to many of the APIs exposed in <code>regex-syntax</code>,
<code>regex-automata</code> and <code>regex</code>. It also includes some useful utilities, such as
serializing fully compiled DFAs to a file and generating Rust code to read
them.</p>
<p>I will use <code>regex-cli</code> at points thoughout this blog post, so if you’d like to
follow along, you can install it straight from the <code>regex</code> crate repository:</p>
<pre tabindex="0"><code>$ cargo install regex-cli
</code></pre><p>Here’s a pair of examples that shows the impact that Unicode has on the
<code>.</code> regex. First, the version with Unicode enabled:</p>
<pre tabindex="0"><code>$ regex-cli debug thompson &#39;.&#39; --no-table

thompson::NFA(
&gt;000000: binary-union(2, 1)
 000001: \x00-\xFF =&gt; 0
^000002: capture(pid=0, group=0, slot=0) =&gt; 10
 000003: \x80-\xBF =&gt; 11
 000004: \xA0-\xBF =&gt; 3
 000005: \x80-\xBF =&gt; 3
 000006: \x80-\x9F =&gt; 3
 000007: \x90-\xBF =&gt; 5
 000008: \x80-\xBF =&gt; 5
 000009: \x80-\x8F =&gt; 5
 000010: sparse(\x00-\t =&gt; 11, \x0B-\x7F =&gt; 11, \xC2-\xDF =&gt; 3, \xE0 =&gt; 4, \xE1-\xEC =&gt; 5, \xED =&gt; 6, \xEE-\xEF =&gt; 5, \xF0 =&gt; 7, \xF1-\xF3 =&gt; 8, \xF4 =&gt; 9)
 000011: capture(pid=0, group=0, slot=1) =&gt; 12
 000012: MATCH(0)

transition equivalence classes: ByteClasses(0 =&gt; [\x00-\t], 1 =&gt; [\n], 2 =&gt; [\x0B-\x7F], 3 =&gt; [\x80-\x8F], 4 =&gt; [\x90-\x9F], 5 =&gt; [\xA0-\xBF], 6 =&gt; [\xC0-\xC1], 7 =&gt; [\xC2-\xDF], 8 =&gt; [\xE0], 9 =&gt; [\xE1-\xEC], 10 =&gt; [\xED], 11 =&gt; [\xEE-\xEF], 12 =&gt; [\xF0], 13 =&gt; [\xF1-\xF3], 14 =&gt; [\xF4], 15 =&gt; [\xF5-\xFF], 16 =&gt; [EOI])
)
</code></pre><p>And now the version with Unicode disabled:</p>
<pre tabindex="0"><code>$ regex-cli debug thompson &#39;(?-u:.)&#39; --no-table --no-utf8-syntax

thompson::NFA(
&gt;000000: binary-union(2, 1)
 000001: \x00-\xFF =&gt; 0
^000002: capture(pid=0, group=0, slot=0) =&gt; 3
 000003: sparse(\x00-\t =&gt; 4, \x0B-\xFF =&gt; 4)
 000004: capture(pid=0, group=0, slot=1) =&gt; 5
 000005: MATCH(0)

transition equivalence classes: ByteClasses(0 =&gt; [\x00-\t], 1 =&gt; [\n], 2 =&gt; [\x0B-\xFF], 3 =&gt; [EOI])
)
</code></pre><p>The output here shows the Thompson NFA compiled by <code>regex-automata</code> for the
regex pattern given. The <code>regex-cli debug</code> command can print lots of different
data types from the regex crate ecosystem:</p>
<pre tabindex="0"><code>$ regex-cli debug
Prints the debug representation of various things from regex-automata and
regex-syntax.

This is useful for ad hoc interactions with objects on the command line. In
general, most objects support the full suite of configuration available in code
via the crate.

USAGE:
    regex-cli debug &lt;command&gt; ...

COMMANDS:
    ast        Print the debug representation of an AST.
    dense      Print the debug representation of a dense DFA.
    hir        Print the debug representation of an HIR.
    literal    Print the debug representation of extracted literals.
    onepass    Print the debug representation of a one-pass DFA.
    sparse     Print the debug representation of a sparse DFA.
    thompson   Print the debug representation of a Thompson NFA.
</code></pre><p>There is also a <code>regex-cli find</code> command that can run ad hoc searches. For
example, to run a multi-pattern search with capture groups using the meta regex
engine:</p>
<pre tabindex="0"><code>$ regex-cli find capture meta \
   -p &#39;(?&lt;email&gt;[.\w]+@(?&lt;domain&gt;[.\w]+))&#39; \
   -p &#39;(?&lt;phone&gt;(?&lt;areacode&gt;[0-9]{3})-[0-9]{3}-[0-9]{4})&#39; \
   -y &#39;foo@example.com, 111-867-5309&#39;
     parse time:  20.713µs
 translate time:  22.116µs
build meta time:  834.731µs
    search time:  142.537µs
  total matches:  2
0:{ 0: 0..15/foo@example.com, 1/email: 0..15/foo@example.com, 2/domain: 4..15/example.com }
1:{ 0: 17..29/111-867-5309, 1/phone: 17..29/111-867-5309, 2/areacode: 17..20/111 }
</code></pre><p>See the <a href="https://github.com/rust-lang/regex/blob/4f47b14d60e82e85a880513833362d5fb485ffa8/regex-cli/README.md"><code>regex-cli</code> README</a> for a few other examples.</p>
<h2 id="flow-of-data">Flow of data</h2>
<p>Before diving into details, it’s worth pausing for a moment first to introduce
some terms and briefly describe the flow of data through the regex engine.
That is, when you call <code>Regex::new</code> with a pattern string, we’ll trace the
transformations done on the pattern string that turn it into something that can
search haystacks.</p>
<ul>
<li>A pattern string is first parsed into an <a href="https://docs.rs/regex-syntax/0.7.*/regex_syntax/ast/enum.Ast.html"><code>Ast</code></a>. An <code>Ast</code> is a structured
representation of the pattern.</li>
<li>An <code>Ast</code> is translated into an <a href="https://docs.rs/regex-syntax/0.7.*/regex_syntax/hir/struct.Hir.html"><code>Hir</code></a>. An <code>Hir</code> is another structured
representation of the pattern, but contains a lot less detail than an <code>Ast</code>.
Things like Unicode case folding and Unicode character class references are
all expanded as part of translation.</li>
<li>An <code>Hir</code> is then used to build two things. First is a <a href="https://docs.rs/regex-syntax/0.7.2/regex_syntax/hir/literal/struct.Seq.html">literal sequence</a>,
which corresponds to a sequence of literals extracted from the pattern that
are used to optimize regex searches in some cases. If possible, a literal
sequence is used to build a <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/util/prefilter/struct.Prefilter.html"><code>Prefilter</code></a>. Secondly, an <code>Hir</code> is used to
construct an <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/nfa/thompson/struct.NFA.html"><code>NFA</code></a>.</li>
<li>At this point, an <code>NFA</code> is used to build a variety of regex engines:
<ul>
<li>A <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/nfa/thompson/pikevm/struct.PikeVM.html"><code>PikeVM</code></a> can handle all possible regexes that are supported by parsing.
A <code>PikeVM</code> can also report offsets for matching capture groups.</li>
<li>A <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/nfa/thompson/backtrack/struct.BoundedBacktracker.html"><code>BoundedBacktracker</code></a> uses backtracking but explicitly bounds itself
to avoid repeating work. Like the <code>PikeVM</code>, it can report offsets for
matching capture groups.</li>
<li>A <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/dfa/onepass/struct.DFA.html">one-pass DFA</a> that supports a very limited subset of regexes, but can
report offsets for matching capture groups very quickly.</li>
<li>A fully compiled <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/dfa/dense/struct.DFA.html">dense DFA</a>. It can only report the overall start and end
of a match (when combined with a second reverse DFA), but is very fast. The
main downside is that its construction algorithm has worst case <code>O(2^m)</code>
time and space complexity.</li>
<li>A <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/hybrid/dfa/struct.DFA.html">lazy DFA</a> that builds itself during a search from an <code>NFA</code>. In some
cases it can be slower than a <code>PikeVM</code>, but in most cases is as fast as
a fully compiled <code>DFA</code> and lacks the downside of <code>O(2^m)</code> worst case
construction time/space.</li>
</ul>
</li>
<li>All of the above regex engines, including a <code>Prefilter</code> if one was
constructed, are composed into a single <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/meta/struct.Regex.html">meta regex engine</a>.</li>
<li>The <code>regex</code> crate itself is a thin wrapper around the meta regex engine from
the <code>regex-automata</code> crate.</li>
</ul>
<p>We’ll discuss each of these things in more detail throughout the blog, but
it’s difficult to avoid referencing some of these things before they get a
full treatment. For that reason, the above is meant to give you a very general
blueprint of <code>regex</code> crate internals.</p>
<h2 id="literal-optimizations">Literal optimizations</h2>
<p>In this section, we will begin our journey into the <code>regex</code> crate internals
by talking about a critical optimization technique that it uses: literal
extraction from regexes. For example, the regex <code>(foo|bar|quux)(\s+\w+)</code>
describes a regular language where all elements in the language start with one
of <code>foo</code>, <code>bar</code> or <code>quux</code>. That is, every match of that regex is guaranteed to
begin with one of those three literals.</p>
<h3 id="motivating-literal-optimizations">Motivating literal optimizations</h3>
<p>Why does this matter? Why do we care about literals at all? We care about them
because of the following two observations:</p>
<ol>
<li>There exist algorithms for searching for one or a small number of literals
that are extremely fast. Speed is usually obtained by exploiting the
“simplicity” of searching for plain literals and using <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">vector instructions</a> to
process many bytes in a haystack in a single step.</li>
<li>In <em>very</em> broad strokes, general algorithms for searching for matches of a
regular expression cannot be accelerated easily.</li>
</ol>
<p>The key observation is that while there are certainly many different techniques
to implementing a regex engine (which we will cover a subset of in more depth
later), none of them can consistently be as fast as a well optimized substring
search implementation that uses vector instructions. In practice, I’ve often
found that the difference is at least one order of magnitude, and sometimes
more.</p>

<p>Let’s show some examples. For this, we can utilize <code>regex-cli</code>, as it exposes
a <code>regex-cli debug literal</code> sub-command for extracting literals from regexes.
Let’s start simple:</p>
<pre tabindex="0"><code>$ regex-cli debug literal &#39;bar&#39;
           parse time:  13.967µs
       translate time:  7.008µs
      extraction time:  405ns
    optimization time:  1.479µs
                  len:  Some(1)
           is finite?:  true
            is exact?:  true
      min literal len:  Some(3)
      max literal len:  Some(3)
longest common prefix:  Some(&#34;bar&#34;)
longest common suffix:  Some(&#34;bar&#34;)

E(&#34;bar&#34;)
</code></pre><p>In the future, I’ll trim the output since there is a lot of extra information
shown. But let’s go through them:</p>
<ul>
<li>Parse time refers to the time it takes to turn the <code>bar</code> pattern into a
structured <a href="https://docs.rs/regex-syntax/0.7.*/regex_syntax/ast/enum.Ast.html"><code>Ast</code></a> value.</li>
<li>Translate time refers to the time it takes to turn the <code>Ast</code> value into
an <a href="https://docs.rs/regex-syntax/0.7.*/regex_syntax/hir/struct.Hir.html"><code>Hir</code></a> value.</li>
<li>Extraction time refers to the time it takes to turn the <code>Hir</code> value into
a <a href="https://docs.rs/regex-syntax/0.7.2/regex_syntax/hir/literal/struct.Seq.html">literal sequence</a>.</li>
<li>Optimization time refers to the time it takes to “optimize” the literal
sequence. This might be as simple as removing duplicate literals and as
aggressive as shrinking the sequence in various ways based on heuristics. We’ll
see more examples of this later.</li>
<li><code>len</code> is the number of literals in the sequence extracted.</li>
<li>Finite refers to whether the sequence has a finite number of elements. An
infinite sequence represents the sequence of all possible literals, and usually
means that literal optimizations aren’t possible or aren’t believed to be
fruitful.</li>
<li>Exact refers to whether every element in the literal sequence is exact or
not. An exact literal refers to a literal that reached a match state from the
place where literal extraction began. Since this command extracts prefixes, an
exact literal corresponds to an overall match of the regex. If a literal is
not exact, then it is said to be inexact.</li>
<li>Minimum literal length refers to the length, in bytes, of the shortest
literal in the sequence.</li>
<li>Maximum literal length refers to the length, in bytes, of the longest
literal in the sequence.</li>
<li>Longest common prefix represents a single literal that is a prefix of all
elements in the sequence. Infinite sequences and finite sequences containing
zero elements lack a common prefix. All other sequences have a common prefix of
at least the empty string.</li>
<li>Longest common suffix represents a single literal that is a suffix of all
elements in the sequence. Infinite sequences and finite sequences containing
zero elements lack a common suffix. All other sequences have a common suffix of
at least the empty string.</li>
</ul>
<p>Finally, after the above meta data, the extracted sequence is shown. Since the
regex is just the literal <code>bar</code>, the sequence contains a single exact element
corresponding to <code>bar</code>. If <code>bar</code> were a strict prefix, then the sequence would
be the same but <code>bar</code> will be inexact:</p>
<pre tabindex="0"><code>$ regex-cli debug literal --no-table &#39;bar+&#39;
I(&#34;bar&#34;)
</code></pre><p>In this case, <code>bar</code> is inexact because the <code>r</code> at the end can match one or more
times. In fact, because of the unbounded repetition operator being applied
to a non-empty string, the language described by this regex is infinite. It
therefore follows that one cannot enumerate all literals and that at least some
of them extracted must be inexact (if any are extracted at all).</p>
<p>But one does not need to write a regex that describes an infinite language
in order to get an inexact literal. Here’s an example of a regex that describes
a finite language, but for which only inexact literals are extracted:</p>
<pre tabindex="0"><code>$ regex-cli debug literal --no-table &#39;bar[a-z]&#39;
I(&#34;bar&#34;)
</code></pre><p>Literal extraction <em>could</em> have enumerated every literal, for example,
<code>bara</code>, <code>barb</code>, <code>barc</code>, …, <code>barz</code>. But instead it didn’t. Why? It turns out
that literal extraction is one big heuristic. A dark art, if you will. We have
to go back to <em>why</em> we’re doing literal extraction at all in the first place:
to identify candidate matches in a haystack very quickly before using a slower
regex engine to confirm whether a match exists at that location.</p>
<p>The trick here is that the choice of <em>what</em> literals to search for might be
just as important as choosing <em>how</em> to search for them. The algorithm with the
highest throughput in the world isn’t going to help you if your haystack is
1,000,000 <code>a</code>s and your regex is just the literal <code>a</code>. The key here is that a
good literal optimization achieves both of the following things:</p>
<ul>
<li>Minimizes the false positive rate of candidates. That is, most candidates it
reports lead to a match.</li>
<li>Minimizes its impact on the latency of the search. That is, when a prefilter
is active, it ideally results in running the regex engine on only a small
portion of the haystack. If a prefilter reports candidates frequently, then
even if it has a 0% false positive rate, its impact on latency is likely to be
hurting overall search times.</li>
</ul>
<p>The reason why I called literal optimizations a <em>dark art</em> is because it is
impossible to know, before a search begins, how to optimally choose the above
two things. The reason is because they both depend on the haystack itself, and
scanning the haystack to “study” it is almost certainly going to result in a
net negative for overall search times. Therefore, we have to guess at how to
minimize the false positive rate while reducing our impact on latency. That’s
why it’s a dark art.</p>
<p>Thankfully, there are some guidelines we can follow that usually give us a good
result:</p>
<ul>
<li>A smaller sequence of literals is usually better than a larger sequence,
but not if this results in elements that are extremely short. That is, 1 or 2
bytes in length. Short elements are likely to match much more frequently, and
so we’d rather not have them. For example, if we had 5,000 literals that were
all limited to lowercase ASCII letters, we could trivially shrink the number of
literals to at most 26 by taking the first byte of each literal. But this new
sequence of literals is likely to match a lot more frequently, and thus result
in a higher hit to latency and a higher false positive rate. It would be better
to shrink the sequence while retaining longer literals that are less likely to
match.</li>
<li>Longer literals are generally better than short literals, but not if it would
result in a large sequence. Longer literals are usually more discriminative,
that is, they lead to a lower false positive rate since they are less likely to
match by chance. But one doesn’t want to prioritize long literals arbitrarily.
For example, you might have a sequence containing the literals <code>foobar</code>,
<code>foobaz</code>, <code>fooquux</code>, but a better sequence would probably be <code>foo</code> even though
it’s shorter than all three literals in the sequence. A single element sequence
is nice because it means we can potentially use a single-substring search
algorithm (which is probably fast).</li>
</ul>
<p>Literal extraction tries to adhere to the above guidelines as much as possible,
but there are some other heuristics that often come into play. For example, the
ASCII space character, <code>U+0020</code>, is unusually common. If a sequence would
otherwise contain a space, then the sequence is made infinite when optimized,
and this effectively disables literal optimizations. For example, this regex
has three prefix literals extracted:</p>
<pre tabindex="0"><code>$ regex-cli debug literal --no-table &#39;(?:foo|z|bar)[a-z]+&#39;
I(&#34;foo&#34;)
I(&#34;z&#34;)
I(&#34;bar&#34;)
</code></pre><p>But this one doesn’t. The only difference is that the <code>z</code> was replaced with a
space:</p>
<pre tabindex="0"><code>$ regex-cli debug literal --no-table &#39;(?:foo| |bar)[a-z]+&#39;
Seq[∞]
</code></pre><p>This heuristic takes place during the “optimization” pass of a literal
sequence. The heuristic notices that one of the literals is just a space
character, assumes this will lead to a high false positive rate and makes the
sequence infinite. When a sequence is infinite, it communicates that there
is no small set of finite literals that would (likely) serve as a good
prefilter. If we disable optimization, we can see that the space character is
included:</p>
<pre tabindex="0"><code>$ regex-cli debug literal --no-table --no-optimize &#39;(?:foo| |bar)[a-z]+&#39;
I(&#34;foo&#34;)
I(&#34; &#34;)
I(&#34;bar&#34;)
</code></pre><p>To make matters more complicated, if we use a different regex that leads to
a small finite sequence of literals that are all exact, then the literal
containing the space character doesn’t result in the overall sequence being
made infinite:</p>
<pre tabindex="0"><code>$ regex-cli debug literal --no-table &#39;foo| |bar&#39;
E(&#34;foo&#34;)
E(&#34; &#34;)
E(&#34;bar&#34;)
</code></pre><p>This is useful because when all the literals are exact, the regex engine can
be skipped completely. In this case, there doesn’t have to be any prefilter
at all. One can just use the multi-substring algorithm directly to report
matches. Therefore, the concern about a high false positive rate is irrelevant,
because every match produced by searching for the literals is a real match.</p>
<p>At this point, we should cover why I’m using the term literal <em>sequence</em>
instead of literal <em>set</em>. Namely, the order of the literals extracted matters.
It matters because the <code>regex</code> crate tries to simulate Perl-like semantics.
That is, that the matches reported are done <em>as if</em> employing a backtracking
search. This is also called leftmost-first matching, and in this context, the
<code>|</code> operator is not commutative. For example:</p>
<pre tabindex="0"><code>$ regex-cli debug literal --no-table &#39;sam|samwise&#39;
E(&#34;sam&#34;)

$ regex-cli debug literal --no-table &#39;samwise|sam&#39;
E(&#34;samwise&#34;)
E(&#34;sam&#34;)
</code></pre><p>These are two different sequences. Both are minimal with respect to the
corresponding regexes. In the first case, <code>sam|samwise</code> will only ever match
<code>sam</code>, since <code>sam</code> is a prefix of <code>samwise</code> and comes before <code>samwise</code> in the
pattern. Therefore, a literal sequence consisting of just <code>sam</code> is correct,
since <code>samwise</code> can never match. In the second case, <code>samwise|sam</code> can match
either branch. Even though <code>sam</code> is a prefix of <code>samwise</code>, since <code>samwise</code>
appears first, it will be preferred when <code>samwise</code> is in the haystack.</p>
<p>(Note: POSIX regex engines don’t implement regexes this way. Instead, they have
leftmost-longest semantics, where the longest possible match always wins. In
this case, <code>|</code> is a commutative operator. Some other regex engines, such as
<a href="https://github.com/intel/hyperscan">Hyperscan</a>, implement “report all matches” or “earliest match” semantics. In
that case, <code>abc|a</code> would match both <code>a</code> and <code>abc</code> in the haystack <code>abc</code>.)</p>
<p>Our last examples show that literal extraction is somewhat intelligent. For
example:</p>
<pre tabindex="0"><code>$ regex-cli debug literal --no-table &#39;abc?de?[x-z]ghi&#39;
I(&#34;abcde&#34;)
I(&#34;abcdx&#34;)
I(&#34;abcdy&#34;)
I(&#34;abcdz&#34;)
I(&#34;abdex&#34;)
I(&#34;abdey&#34;)
I(&#34;abdez&#34;)
I(&#34;abdxg&#34;)
I(&#34;abdyg&#34;)
I(&#34;abdzg&#34;)
</code></pre><p>That is, literal extraction knows how to expand things like <code>?</code> and even small
character classes. This works as long as the literal sequence size stays
under <a href="https://docs.rs/regex-syntax/latest/regex_syntax/hir/literal/struct.Extractor.html">several different heuristic limits</a>. (Notice also
that literal extraction could have enumerated every element in the language
described by this regex, in full, but optimization chose to shrink it in
accordance with its heuristics.)</p>
<p>Another example of “intelligence” is that case insensitivity, including
Unicode awareness, is taken into account as well:</p>
<pre tabindex="0"><code>$ regex-cli debug literal --no-table &#39;(?i)She&#39;
E(&#34;SHE&#34;)
E(&#34;SHe&#34;)
E(&#34;ShE&#34;)
E(&#34;She&#34;)
E(&#34;sHE&#34;)
E(&#34;sHe&#34;)
E(&#34;shE&#34;)
E(&#34;she&#34;)
E(&#34;ſHE&#34;)
E(&#34;ſHe&#34;)
E(&#34;ſhE&#34;)
E(&#34;ſhe&#34;)
</code></pre><p>This actually isn’t a result of literal extraction implementing Unicode case
folding, but rather due to the translation from an <code>Ast</code> to an <code>Hir</code> doing the
case folding for us:</p>
<pre tabindex="0"><code>$ regex-cli debug hir --no-table &#39;(?i)She&#39;
Concat(
    [
        Class(
            {
                &#39;S&#39;..=&#39;S&#39;,
                &#39;s&#39;..=&#39;s&#39;,
                &#39;ſ&#39;..=&#39;ſ&#39;,
            },
        ),
        Class(
            {
                &#39;H&#39;..=&#39;H&#39;,
                &#39;h&#39;..=&#39;h&#39;,
            },
        ),
        Class(
            {
                &#39;E&#39;..=&#39;E&#39;,
                &#39;e&#39;..=&#39;e&#39;,
            },
        ),
    ],
)
</code></pre><p>That is, literal extraction sees this regex as one that is equivalent to
<code>[Ssſ][Hh][Ee]</code>. All it does is expand the classes as it would any other regex.</p>
<h3 id="searching-for-literals">Searching for literals</h3>
<p>Once you’ve extracted some literals, you now need to figure out how to search
for them.</p>
<p>The single substring case is somewhat easy: you pick the fastest algorithm
you can for finding a substring in a haystack. There’s not much more to it.
You don’t need to care about the order of literals at this point since there
is only one of them. For this case, the <code>regex</code> crate uses the
<a href="https://docs.rs/memchr/2.*/memchr/memmem/index.html"><code>memmem</code></a> module from the <a href="https://docs.rs/memchr/2.*/memchr/"><code>memchr</code></a> crate.</p>
<p>There are several different aspects to the algorithm used in <code>memchr::memmem</code>:</p>
<ul>
<li>Its principal algorithm is <a href="https://en.wikipedia.org/wiki/Two-way_string-matching_algorithm">Two-Way</a>, which runs in <code>O(n)</code> worst case time
and constant space.</li>
<li>In cases where the needle and haystack are both very short, <a href="https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm">Rabin-Karp</a>
is used in an effort to minimize latency.</li>
<li>On <code>x86_64</code>, a variant of the “<a href="http://0x80.pl/articles/simd-strfind.html">generic SIMD</a>” algorithm is used. Basically,
two bytes are chosen from the needle, and occurrences for those two bytes in
their proper positions are searched for using vector instructions. When a
match of those two bytes is found, then a full match of the needle is checked.
(Notice that this is just another variant of the prefilter mechanism. We pick
an operation that can quickly find candidates and then perform a more expensive
verification step.)</li>
</ul>
<p>For the generic SIMD algorithm, instead of always choosing the first and last
bytes in the needle, we choose two bytes that we believe are “rare” according
to a background frequency distribution of bytes. That is, we assume that bytes
like <code>Z</code> are far less common than bytes like <code>a</code>. It isn’t always true, but
we’re in heuristic-land here. It’s true commonly enough that it works well in
practice. By choosing bytes that are probably rarely occurring from the needle,
we hope to maximize the amount of time spent in the vector operations that
detect candidates, and minimize the number of verifications we need to perform.</p>
<p>The multi-substring case is a bit trickier. Here, we need to make sure we
treat the literals as a sequence and prioritize matches for literals earlier
in the sequence over literals that come later. It’s also typically true that
multi-substring search will be slower than single-substring case, because
there’s just generally more work to be done. Here, the principal algorithm
employed is <a href="https://github.com/BurntSushi/aho-corasick/tree/97e48b6dbdf9ebd50168540276fa3f14f403d42b/src/packed/teddy">Teddy</a>, which is an algorithm that I ported out of <a href="https://github.com/intel/hyperscan">Hyperscan</a>.
At a high level, it uses vector instructions to detect candidates quickly and
then a verification step to confirm those candidates as a match.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm">Aho-Corasick</a> algorithm is also used in some cases, although usually the
regex engine will just prefer to construct a lazy DFA since performance is
similar. Aho-Corasick can still help as a prefilter when the lazy DFA cannot be
used though. Aho-Corasick will also typically do better than a lazy DFA when
the number of literals is extremely large (around tens of thousands).</p>
<p>There is a lot more work I hope to do in the multi-substring case going
forward.</p>
<h2 id="the-nfa-data-type">The NFA data type</h2>
<p>If there was a central data type inside the <code>regex</code> crate, it would probably be
the <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/nfa/thompson/struct.NFA.html"><code>NFA</code></a>. More specifically, it is a Thompson NFA, which means it was built
by an algorithm similar to <a href="https://en.wikipedia.org/wiki/Thompson%27s_construction">Thompson’s construction</a>. Thompson’s construction
builds an NFA from a structured representation of a regex in <code>O(m)</code> time, where
<code>m</code> is proportional to the size of the regex after counted repetitions have
been expanded. (For example, <code>a{5}</code> is <code>aaaaa</code>.) The algorithm works by mapping
each type of regex expression to a mini NFA unto itself, and then defining
rules for composing those mini NFAs into one big NFA.</p>
<p>NFAs are a central data type because they can be used directly, as-is,
to implement a regex engine. But they can also be transformed into other
types (such as DFAs) which are in turn used to implement different regex
engines. Basically, at present, if you want to build a regex engine with
<code>regex-automata</code>, then you have to start with a Thompson NFA.</p>
<p>Before exploring NFAs in more detail, let’s look at a simple example.</p>
<h3 id="a-simple-nfa-example">A simple NFA example</h3>
<p>As with literal extraction, <code>regex-cli</code> can be helpful here by letting us print
a debug representation of an NFA when given a regex:</p>
<pre tabindex="0"><code>$ regex-cli debug thompson &#39;a&#39;
        parse time:  9.856µs
    translate time:  3.005µs
  compile nfa time:  18.51µs
            memory:  700
            states:  6
       pattern len:  1
       capture len:  1
        has empty?:  false
          is utf8?:  true
       is reverse?:  false
   line terminator:  &#34;\n&#34;
       lookset any:  ∅
lookset prefix any:  ∅
lookset prefix all:  ∅

thompson::NFA(
&gt;000000: binary-union(2, 1)
 000001: \x00-\xFF =&gt; 0
^000002: capture(pid=0, group=0, slot=0) =&gt; 3
 000003: a =&gt; 4
 000004: capture(pid=0, group=0, slot=1) =&gt; 5
 000005: MATCH(0)

transition equivalence classes: ByteClasses(0 =&gt; [\x00-`], 1 =&gt; [a], 2 =&gt; [b-\xFF], 3 =&gt; [EOI])
)
</code></pre><p>In the future, I’ll trim the output to just the NFA itself. So let’s explain
what the rest of the output means here:</p>
<ul>
<li>The parse and translate timings are the same as they were for literal
extraction. That is, the time to build <code>Ast</code> and <code>Hir</code> values, respectively.</li>
<li>Compilation time refers to the time it takes to compile an <code>Hir</code> value into
an <code>NFA</code>.</li>
<li>Memory refers to the number of bytes of heap memory used by the NFA.</li>
<li>States is the number of states in the NFA.</li>
<li>Pattern length is the number of patterns in the NFA.</li>
<li>Capture length is the number of capture groups compiled into the NFA. When
capture groups are enabled (they are by default), then there is always at least
1 group corresponding to the overall match.</li>
<li>“has empty” refers to whether the NFA can match the empty string or not.</li>
<li>“is utf8” refers to whether the NFA is guaranteed to never match any
invalid UTF-8. This includes <em>not</em> matching the empty string between code
units in a UTF-8 encoded codepoint. For example, <code>💩</code> is UTF-8 encoded as
<code>\xF0\x9F\x92\xA9</code>. While the empty regex will match at every position, when
the NFA is in UTF-8 mode, the only matches it would report are immediately
before the <code>\xF0</code> and immediately after <code>\xA9</code>.</li>
<li>“is reverse” refers to whether the NFA matches the regex in reverse. This
means that it matches the language described by the original regex, but with the
elements in the language reversed.</li>
<li>Line terminator refers to the line terminator used for the <code>(?m:^)</code>, <code>(?m:$)</code>
and <code>.</code> regexes.</li>
<li>“lookset any” is the set of all look-around assertions in the regex.</li>
<li>“lookset prefix any” is the set of all look-around assertions that occur in
the prefix of the regex. Every match may match zero or more of these.</li>
<li>At the end, the “transition equivalence classes” refers to a partitioning of
all possible byte values into sets of equivalence class. The rule is that each
byte in an equivalence class can be treated as equivalent to one another with
respect to whether a match occurs.</li>
</ul>
<p>Other than that, the main output is the NFA itself. Let’s walk through it:</p>
<pre tabindex="0"><code>&gt;000000: binary-union(2, 1)
 000001: \x00-\xFF =&gt; 0
^000002: capture(pid=0, group=0, slot=0) =&gt; 3
 000003: a =&gt; 4
 000004: capture(pid=0, group=0, slot=1) =&gt; 5
 000005: MATCH(0)
</code></pre><p>The <code>^</code> before state <code>2</code> indicates that it is the “anchored” starting state,
while the <code>&gt;</code> before state <code>0</code> indicates that it is the “unanchored” starting
state. The former is used when running an anchored search and the latter is
used for an unanchored search.</p>
<p>An unanchored search starts with <code>binary-union(2, 1)</code>. This indicates that
NFA traversal should first go to state <code>2</code> (a <code>capture</code> state), and only if
that path fails should it try going to state <code>1</code>. In this case, state <code>1</code>
matches any byte and loops back around to state <code>2</code>. In effect, states <code>0</code> and
<code>1</code> represent an implicit <code>(?s-u:.)*?</code> prefix at the beginning of the regex,
effectively making it possible for it to match anywhere in the haystack.</p>
<p>A <code>capture</code> state is an unconditional epsilon transition that only exists to
cause a side effect: it instructs the virtual machine executing the NFA to
store the current offset in the slot included in the <code>capture</code> state. If one is
doing NFA traversal outside the context of a virtual machine (or something else
that cares about capture groups), the <code>capture</code> states are effectively ignored
by treating them as unconditional epsilon transitions with no side effects. For
example, this is how they are handled during <a href="https://en.wikipedia.org/wiki/Powerset_construction">determinization</a> (the process of
converting an NFA to a DFA).</p>
<p>Once at state <code>3</code>, one must check whether the byte at the current position is
equivalent to <code>a</code>, and if so, moves to state <code>4</code>, which is another <code>capture</code>
state. Traversal finally moves to state <code>5</code>, which is a match state for the
pattern with identifier <code>0</code>.</p>
<h3 id="nfa-optimization-sparse-states">NFA optimization: sparse states</h3>
<p>One of the main problems with a Thompson NFA comes from the thing that makes it
a decent choice for a general purpose regex engine: its construction time is
worst case <code>O(m)</code>, but this is achieved through liberal use of <em>epsilon
transitions</em>. Epsilon transitions are transitions in the NFA that are taken
without consuming any input. They are one of two ways that a search via an NFA
simulation can wind up in multiple states simultaneously. (The other way is for
a single NFA state to have multiple outgoing transitions for the same haystack
symbol.)</p>
<p>Why are espilon transitions a problem? Well, when performing an NFA traversal
(whether it’s for a search or for building some other object such as a DFA), an
epsilon transition represents an added cost you must pay whenever one is found.
In particular, every NFA state has something called an epsilon closure, which
is the set of states reachable via following epsilon transitions recursively.
Depending on where it occurs in the NFA, an epsilon closure may be re-computed
many times. The epsilon closure for a particular state may change during
traversal because some epsilon transitions may be conditional, such as the ones
corresponding to anchor assertions like <code>^</code>, <code>$</code> and <code>\b</code>.</p>
<p>Let’s take a look at one relatively simple optimization that I made in the
new NFA compiler. First, let’s see how <code>regex &lt;1.9</code> compiled the regex
<code>[A-Za-z0-9]</code>:</p>
<pre tabindex="0"><code>$ regex-debug compile --bytes &#39;[A-Za-z0-9]&#39;
0000 Save(0) (start)
0001 Split(2, 3)
0002 Bytes(0, 9) (goto: 6)
0003 Split(4, 5)
0004 Bytes(A, Z) (goto: 6)
0005 Bytes(a, z)
0006 Save(1)
0007 Match(0)
</code></pre><p>(Note: <code>regex-debug</code> is an older hacky version of a command line tool for
interacting with the <code>regex</code> crate. It is no longer available, although you can
always check out an older tag in the <code>regex</code> crate repository and build it.)</p>
<p>The <code>Split</code> instruction corresponds to an NFA state with two unconditional
epsilon transitions (it’s the same as the <code>binary-union</code> instruction in the
previous section). The <code>Save</code> instruction is for capture groups and <code>Bytes</code>
is for checking whether a single byte or a contiguous ranges of bytes matches
the current haystack symbol. In this case, the character class is implemented
with multiple <code>Split</code> instructions. Notice, for example, that the epsilon
closure of state <code>0</code> is <code>{1, 2, 3, 4, 5}</code>.</p>
<p>Now let’s see what the new NFA compiler does:</p>
<pre tabindex="0"><code>$ regex-cli debug thompson --no-table &#39;[A-Za-z0-9]&#39;
thompson::NFA(
&gt;000000: binary-union(2, 1)
 000001: \x00-\xFF =&gt; 0
^000002: capture(pid=0, group=0, slot=0) =&gt; 3
 000003: sparse(0-9 =&gt; 4, A-Z =&gt; 4, a-z =&gt; 4)
 000004: capture(pid=0, group=0, slot=1) =&gt; 5
 000005: MATCH(0)
)
</code></pre><p>(We can ignore states <code>0</code> and <code>1</code>, the old NFA doesn’t have an equivalent
prefix for unrelated reasons.)</p>
<p>Here, instead of epsilon transitions, we just have a single <code>sparse</code> NFA
state. The name <code>sparse</code> refers to the fact that the state contains more
than one contiguous range of bytes, with each range potentially pointing to
a different state. <code>sparse</code> is used because the representation used doesn’t
permit a constant time determination of whether a particular haystack symbol
has a matching transition. (i.e., One has to use a linear or binary search.)
It accomplishes the same thing as the <code>Split</code> instructions in the old NFA,
but without any explicit epsilon transitions. This results in less overhead
because there’s no need to compute an epsilon closure through multiple <code>Split</code>
instructions. There’s just one state, and finding the next transition requires
looking up which range, if any, the current haystack symbol matches.</p>
<p>The main downside of this particular optimization is that the <code>sparse</code> state
(in the current representation of the NFA) uses indirection to support this. So
it may have harmful cache effects and may result in more heap memory used in
some cases. But the overhead of dealing with all of the epsilon transitions, in
practice, tends to trump that. It’s possible this indirection will be removed
in the future.</p>
<h3 id="nfa-optimization-minimal-utf-8-automata">NFA optimization: minimal UTF-8 automata</h3>
<p>One interesting aspect of the old NFA compiler is that it could produce two
different kinds of NFAs: an NFA whose alphabet was defined over Unicode code
points and an NFA whose alphabet was defined over arbitrary bytes. (Not just
UTF-8 code units. Even bytes that can never be a valid UTF-8 code unit,
like <code>\xFF</code>, are permitted in this byte oriented NFA.) The Unicode NFA is
principally used when using an NFA regex engine (the PikeVM or the bounded
backtracker, we’ll get to those later), where as the byte oriented NFA is
used whenever the lazy DFA engine is used. A byte oriented NFA is required
for use with the lazy DFA because a lazy DFA really wants its alphabet to be
defined over bytes. Otherwise, you wind up with difficult to solve performance
problems. (A byte oriented NFA can be used with the NFA regex engines, but this
only occurs when the regex can match invalid UTF-8. In this case, a Unicode
alphabet cannot be used.)</p>
<p>This led to at least three problems. First is that the byte oriented NFA was
often slower, primarily because of the epsilon transition problem we talked
about in the previous section. That is, a byte oriented NFA usually had more
<code>Split</code> instructions where as the Unicode NFA would look more like the <code>sparse</code>
state in the new NFA compiler. For example:</p>
<pre tabindex="0"><code>$ regex-debug compile &#39;[A-Za-z0-9]&#39;
0000 Save(0) (start)
0001 &#39;0&#39;-&#39;9&#39;, &#39;A&#39;-&#39;Z&#39;, &#39;a&#39;-&#39;z&#39;
0002 Save(1)
0003 Match(0)
</code></pre><p>Notice that there are no <code>Split</code> instructions at all.</p>
<p>The second problem follows from the first. Since the byte oriented NFA is
usually slower, we would actually compile both a Unicode NFA and a byte
oriented NFA. That way, we could use the Unicode NFA with the NFA regex engines
and the byte oriented NFA with the lazy DFA. It works, but it’s wasteful.</p>
<p>The third problem is that the NFA regex engines need to work on both the
Unicode and byte oriented versions of the NFA. This complicates things and has
been the reason for bugs. This problem could likely be mitigated to an extent
with better design, but it’s a complication.</p>
<p>So what does this have to do with UTF-8 automata? Well, a byte oriented NFA
still needs to be able to deal with Unicode classes. But if the alphabet is
bytes and not codepoints, how does it do it? It does it by building UTF-8
automata into the NFA. For example, here’s an NFA (from the new compiler) that
can match the UTF-8 encoding of any Unicode scalar value:</p>
<pre tabindex="0"><code>$ regex-cli debug thompson --no-table &#39;(?s:.)&#39;
thompson::NFA(
&gt;000000: binary-union(2, 1)
 000001: \x00-\xFF =&gt; 0
^000002: capture(pid=0, group=0, slot=0) =&gt; 10
 000003: \x80-\xBF =&gt; 11
 000004: \xA0-\xBF =&gt; 3
 000005: \x80-\xBF =&gt; 3
 000006: \x80-\x9F =&gt; 3
 000007: \x90-\xBF =&gt; 5
 000008: \x80-\xBF =&gt; 5
 000009: \x80-\x8F =&gt; 5
 000010: sparse(\x00-\x7F =&gt; 11, \xC2-\xDF =&gt; 3, \xE0 =&gt; 4, \xE1-\xEC =&gt; 5, \xED =&gt; 6, \xEE-\xEF =&gt; 5, \xF0 =&gt; 7, \xF1-\xF3 =&gt; 8, \xF4 =&gt; 9)
 000011: capture(pid=0, group=0, slot=1) =&gt; 12
 000012: MATCH(0)
)
</code></pre><p>The way this is achieved is by starting from a contiguous range of Unicode
codepoints and then generating a sequence of byte oriented character classes
that match the UTF-8 encoding of that range of codepoints. This functionality
is provided by <a href="https://docs.rs/regex-syntax/0.7.*/regex_syntax/utf8/index.html"><code>regex-syntax</code>’s <code>utf8</code> module</a>. So for example,
<code>(?s:.)</code> would look like this:</p>
<pre tabindex="0"><code>[0-7F]
[C2-DF][80-BF]
[E0][A0-BF][80-BF]
[E1-EC][80-BF][80-BF]
[ED][80-9F][80-BF]
[EE-EF][80-BF][80-BF]
[F0][90-BF][80-BF][80-BF]
[F1-F3][80-BF][80-BF][80-BF]
[F4][80-8F][80-BF][80-BF]
</code></pre><p>Translating that into an NFA can be done by just treating it as an alternation,
like this:</p>
<pre tabindex="0"><code>[0-7F]|[C2-DF][80-BF]|...|[F4][80-8F][80-BF][80-BF]
</code></pre><p>And that will work and it’s correct. The problem is that it will generate
very large NFAs for some very common cases. See, the problem with Unicode is
that it tends to introduce extremely large character classes into a regex.
Classes like <code>\w</code>, for example, match 139,612 distinct codepoints (at time of
writing). The ASCII version of <code>\w</code> only matches 63 codepoints. This is a
categorical difference, and there are plenty of tricks that will work for a
small number like 63 that just won’t scale to numbers like 139,612.</p>
<p>The old regex crate did not naively compile UTF-8 automata like the approach
above. Indeed, there is a lot of redundant structure in the classes produced
by the <code>utf8</code> module above. The old regex crate noticed this and tried to factor
out common suffixes so that they were shared whenever possible. But this still
led to extremely large NFAs:</p>
<pre tabindex="0"><code>$ regex-debug compile --bytes &#39;\w&#39; | tail -n20
3545 Bytes(\xb0, \xb0) (goto: 3466)
3546 Bytes(\xf0, \xf0) (goto: 3545)
3547 Split(3550, 3551)
3548 Bytes(\x80, \x8c) (goto: 28)
3549 Bytes(\xb1, \xb1) (goto: 3548)
3550 Bytes(\xf0, \xf0) (goto: 3549)
3551 Split(3554, 3555)
3552 Bytes(\x8d, \x8d) (goto: 2431)
3553 Bytes(\xb1, \xb1) (goto: 3552)
3554 Bytes(\xf0, \xf0) (goto: 3553)
3555 Split(3558, 3562)
3556 Bytes(\x84, \x86) (goto: 28)
3557 Bytes(\xa0, \xa0) (goto: 3556)
3558 Bytes(\xf3, \xf3) (goto: 3557)
3559 Bytes(\x80, \xaf) (goto: 3563)
3560 Bytes(\x87, \x87) (goto: 3559)
3561 Bytes(\xa0, \xa0) (goto: 3560)
3562 Bytes(\xf3, \xf3) (goto: 3561)
3563 Save(1)
3564 Match(0)
</code></pre><p>Notice here that we’re only showing the last 20 lines of output. But the NFA
produced has 3,564 states. Wow. And there are epsilon transitions everywhere.
It’s truly a mess, and the only reason why the old regex crate does as well as
it does is because the lazy DFA usually bails it out by compiling some subset
of what is actually used into a DFA.</p>
<p>Now let’s look at what the new NFA compiler does:</p>
<pre tabindex="0"><code>$ regex-cli debug thompson --no-table &#39;\w&#39; | tail -n20
 000292: \xB0-\xB9 =&gt; 310
 000293: sparse(\x84 =&gt; 115, \x85 =&gt; 291, \x86 =&gt; 210, \xAF =&gt; 292)
 000294: \x80-\x9F =&gt; 310
 000295: sparse(\x80-\x9A =&gt; 5, \x9B =&gt; 294, \x9C-\xBF =&gt; 5)
 000296: sparse(\x80-\x9B =&gt; 5, \x9C =&gt; 282, \x9D-\x9F =&gt; 5, \xA0 =&gt; 55, \xA1-\xBF =&gt; 5)
 000297: sparse(\x80-\xA1 =&gt; 310, \xB0-\xBF =&gt; 310)
 000298: sparse(\x80-\xB9 =&gt; 5, \xBA =&gt; 297, \xBB-\xBF =&gt; 5)
 000299: \x80-\xA0 =&gt; 310
 000300: sparse(\x80-\xAE =&gt; 5, \xAF =&gt; 299)
 000301: \x80-\x9D =&gt; 310
 000302: sparse(\xA0-\xA7 =&gt; 5, \xA8 =&gt; 301)
 000303: sparse(\x80-\x8A =&gt; 310, \x90-\xBF =&gt; 310)
 000304: sparse(\x80-\x8C =&gt; 5, \x8D =&gt; 303, \x8E-\xBF =&gt; 5)
 000305: sparse(\x80-\x8D =&gt; 5, \x8E =&gt; 236)
 000306: sparse(\x90 =&gt; 193, \x91 =&gt; 231, \x92 =&gt; 235, \x93 =&gt; 238, \x94 =&gt; 239, \x96 =&gt; 247, \x97 =&gt; 118, \x98 =&gt; 248, \x9A =&gt; 250, \x9B =&gt; 256, \x9C =&gt; 257, \x9D =&gt; 276, \x9E =&gt; 290, \x9F =&gt; 293, \xA0-\xA9 =&gt; 118, \xAA =&gt; 295, \xAB =&gt; 296, \xAC =&gt; 298, \xAD =&gt; 118, \xAE =&gt; 300, \xAF =&gt; 302, \xB0 =&gt; 118, \xB1 =&gt; 304, \xB2 =&gt; 305)
 000307: sparse(\x84-\x86 =&gt; 5, \x87 =&gt; 236)
 000308: \xA0 =&gt; 307
 000309: sparse(0-9 =&gt; 310, A-Z =&gt; 310, _ =&gt; 310, a-z =&gt; 310, \xC2 =&gt; 3, \xC3 =&gt; 4, \xC4-\xCA =&gt; 5, \xCB =&gt; 6, \xCC =&gt; 5, \xCD =&gt; 7, \xCE =&gt; 8, \xCF =&gt; 9, \xD0-\xD1 =&gt; 5, \xD2 =&gt; 10, \xD3 =&gt; 5, \xD4 =&gt; 11, \xD5 =&gt; 12, \xD6 =&gt; 13, \xD7 =&gt; 14, \xD8 =&gt; 15, \xD9 =&gt; 16, \xDA =&gt; 5, \xDB =&gt; 17, \xDC =&gt; 18, \xDD =&gt; 19, \xDE =&gt; 20, \xDF =&gt; 21, \xE0 =&gt; 53, \xE1 =&gt; 93, \xE2 =&gt; 109, \xE3 =&gt; 116, \xE4 =&gt; 117, \xE5-\xE9 =&gt; 118, \xEA =&gt; 137, \xEB-\xEC =&gt; 118, \xED =&gt; 140, \xEF =&gt; 155, \xF0 =&gt; 306, \xF3 =&gt; 308)
 000310: capture(pid=0, group=0, slot=1) =&gt; 311
 000311: MATCH(0)
</code></pre><p>There are not only far fewer states, but there are <em>zero</em> epsilon transitions.
While this is due in part to the use of the <code>sparse</code> state optimization
described in the previous section, it does not account for all of it.</p>
<p>The new NFA compiler achieves this by using <a href="https://blog.burntsushi.net/transducers/#references">Daciuk’s algorithm</a> for computing
minimal DFAs from a sorted sequence of non-overlapping elements. That’s exactly
what we get from the <code>utf8</code> module. In practice, we don’t necessarily generate
minimal DFAs because of the memory usage required, but instead sacrifice strict
minimality in favor of using a bounded amount of memory. But it’s usually close
enough.</p>
<p>The reverse case is not as easy. The reverse case cannot be handled so easily
because there is no simple way to reverse sort the output of the <code>utf8</code> module
in a way that works with Daciuk’s algorithm (as far as I know). To work around
this, I built a bespoke data structure called a <a href="https://github.com/rust-lang/regex/blob/4f47b14d60e82e85a880513833362d5fb485ffa8/regex-automata/src/nfa/thompson/range_trie.rs">range trie</a> that re-partitions
the output of the <code>utf8</code> module in reverse such that it’s sorted and non-overlapping.
Once this is done, we can use Daciuk’s algorithm just like we do for forward
case. The problem, though, is that this can increase the time it takes to build
an NFA quite a bit. Because of that, one needs to opt into it. First, without
the reverse shrinkng:</p>
<pre tabindex="0"><code>$ regex-cli debug thompson --no-table --no-captures &#39;\w&#39; -r | tail -n20
 001367: \xB1 =&gt; 722
 001368: \x80-\x8C =&gt; 1367
 001369: \x80-\xBF =&gt; 1368
 001370: \x8D =&gt; 1367
 001371: \x80-\x8A =&gt; 1370
 001372: \x90-\xBF =&gt; 1370
 001373: \x8E-\xBF =&gt; 1367
 001374: \x80-\xBF =&gt; 1373
 001375: \xB2 =&gt; 722
 001376: \x80-\x8D =&gt; 1375
 001377: \x80-\xBF =&gt; 1376
 001378: \x8E =&gt; 1375
 001379: \x80-\xAF =&gt; 1378
 001380: \xF3 =&gt; 1386
 001381: \xA0 =&gt; 1380
 001382: \x84-\x86 =&gt; 1381
 001383: \x80-\xBF =&gt; 1382
 001384: \x87 =&gt; 1381
 001385: \x80-\xAF =&gt; 1384
 001386: MATCH(0)
</code></pre><p>And now with it:</p>
<pre tabindex="0"><code>$ regex-cli debug thompson --no-table --no-captures &#39;\w&#39; -r --shrink | tail -n20
 000469: sparse(\x90 =&gt; 2, \x92 =&gt; 2, \x97 =&gt; 2, \xA0-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \xE3 =&gt; 488, \xE4 =&gt; 488, \xE5-\xE9 =&gt; 488, \xEA =&gt; 488,
 \xEB-\xEC =&gt; 488, \xEF =&gt; 488)
 000470: sparse(\x97 =&gt; 2, \x9A =&gt; 2, \xA0-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \xE3 =&gt; 488, \xE4 =&gt; 488, \xE5-\xE9 =&gt; 488, \xEA =&gt; 488, \xEB-\xEC
=&gt; 488)
 000471: sparse(\x80 =&gt; 3, \x81 =&gt; 387, \x82 =&gt; 6, \x83 =&gt; 387, \x84 =&gt; 397, \x85 =&gt; 451, \x86 =&gt; 174, \x87 =&gt; 6, \x88 =&gt; 100, \x89 =&gt; 100, \x8A =&gt; 13, \x8B =&gt; 348, \x8C =&gt; 14, \x8D =&gt; 45
2, \x8E =&gt; 16, \x8F =&gt; 88, \x90 =&gt; 19, \x91 =&gt; 62, \x92 =&gt; 20, \x93 =&gt; 343, \x94 =&gt; 21, \x95 =&gt; 62, \x96 =&gt; 23, \x97 =&gt; 61, \x98 =&gt; 179, \x99 =&gt; 27, \x9A =&gt; 27, \x9B =&gt; 441, \x9C =&gt; 446,
\x9D =&gt; 236, \x9E =&gt; 28, \x9F =&gt; 461, \xA0 =&gt; 454, \xA1 =&gt; 442, \xA2 =&gt; 31, \xA3 =&gt; 428, \xA4 =&gt; 33, \xA5 =&gt; 467, \xA6 =&gt; 35, \xA7 =&gt; 330, \xA8 =&gt; 455, \xA9 =&gt; 468, \xAA =&gt; 388, \xAB =&gt; 4
43, \xAC =&gt; 43, \xAD =&gt; 414, \xAE =&gt; 84, \xAF =&gt; 447, \xB0 =&gt; 438, \xB1 =&gt; 416, \xB2 =&gt; 363, \xB3 =&gt; 457, \xB4 =&gt; 67, \xB5 =&gt; 340, \xB6 =&gt; 199, \xB7 =&gt; 141, \xB8 =&gt; 465, \xB9 =&gt; 374, \xBA
 =&gt; 53, \xBB =&gt; 417, \xBC =&gt; 459, \xBD =&gt; 56, \xBE =&gt; 469, \xBF =&gt; 470, \xC3 =&gt; 488, \xC4-\xCA =&gt; 488, \xCC =&gt; 488, \xCD =&gt; 488, \xCE =&gt; 488, \xCF =&gt; 488, \xD0-\xD1 =&gt; 488, \xD2 =&gt; 488, \
xD3 =&gt; 488, \xD4 =&gt; 488, \xD5 =&gt; 488, \xD6 =&gt; 488, \xD8 =&gt; 488, \xD9 =&gt; 488, \xDA =&gt; 488, \xDC =&gt; 488, \xDD =&gt; 488, \xDF =&gt; 488)
 000472: sparse(\x91 =&gt; 2, \x92 =&gt; 2, \x93 =&gt; 2, \x97 =&gt; 2, \x98 =&gt; 2, \x9F =&gt; 2, \xA0 =&gt; 7, \xA1-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xAE =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \
xB2 =&gt; 2, \xE1 =&gt; 488, \xE2 =&gt; 488, \xE3 =&gt; 488, \xE4 =&gt; 488, \xE5-\xE9 =&gt; 488, \xEA =&gt; 488, \xEB-\xEC =&gt; 488, \xED =&gt; 488)
 000473: sparse(\x92 =&gt; 2, \x94 =&gt; 2, \x97 =&gt; 2, \x98 =&gt; 2, \x9D =&gt; 2, \xA0-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xAE =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \xE1 =&gt; 488, \xE3 =&gt; 48
8, \xE4 =&gt; 488, \xE5-\xE9 =&gt; 488, \xEB-\xEC =&gt; 488, \xED =&gt; 488)
 000474: sparse(\x91 =&gt; 2, \x97 =&gt; 2, \x98 =&gt; 2, \xA0-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \xE2 =&gt; 488, \xE3 =&gt; 488, \xE4 =&gt; 488, \xE5-\xE9 =&gt; 488,
 \xEA =&gt; 488, \xEB-\xEC =&gt; 488, \xEF =&gt; 488)
 000475: sparse(\x90 =&gt; 2, \x91 =&gt; 2, \x96 =&gt; 2, \x97 =&gt; 2, \x9C =&gt; 2, \xA0-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \xE0 =&gt; 488, \xE1 =&gt; 488, \xE3 =&gt;
488, \xE4 =&gt; 488, \xE5-\xE9 =&gt; 488, \xEA =&gt; 488, \xEB-\xEC =&gt; 488)
 000476: sparse(\x90 =&gt; 2, \x96 =&gt; 2, \x97 =&gt; 2, \xA0-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \xE0 =&gt; 488, \xE3 =&gt; 488, \xE4 =&gt; 488, \xE5-\xE9 =&gt; 488,
 \xEA =&gt; 488, \xEB-\xEC =&gt; 488, \xEF =&gt; 488)
 000477: sparse(\x80 =&gt; 218, \x81 =&gt; 387, \x82 =&gt; 6, \x83 =&gt; 387, \x84 =&gt; 472, \x85 =&gt; 451, \x86 =&gt; 174, \x87 =&gt; 387, \x88 =&gt; 12, \x89 =&gt; 100, \x8A =&gt; 13, \x8B =&gt; 348, \x8C =&gt; 14, \x8D =&gt;
 452, \x8E =&gt; 16, \x8F =&gt; 426, \x90 =&gt; 19, \x91 =&gt; 62, \x92 =&gt; 20, \x93 =&gt; 473, \x94 =&gt; 21, \x95 =&gt; 62, \x96 =&gt; 23, \x97 =&gt; 61, \x98 =&gt; 179, \x99 =&gt; 157, \x9A =&gt; 27, \x9B =&gt; 441, \x9C =&gt;
446, \x9D =&gt; 236, \x9E =&gt; 28, \x9F =&gt; 461, \xA0 =&gt; 454, \xA1 =&gt; 442, \xA2 =&gt; 31, \xA3 =&gt; 428, \xA4 =&gt; 33, \xA5 =&gt; 467, \xA6 =&gt; 305, \xA7 =&gt; 317, \xA8 =&gt; 463, \xA9 =&gt; 468, \xAA =&gt; 388, \xA
B =&gt; 443, \xAC =&gt; 223, \xAD =&gt; 414, \xAE =&gt; 43, \xAF =&gt; 447, \xB0 =&gt; 438, \xB1 =&gt; 474, \xB2 =&gt; 363, \xB3 =&gt; 457, \xB4 =&gt; 140, \xB5 =&gt; 340, \xB6 =&gt; 266, \xB7 =&gt; 141, \xB8 =&gt; 465, \xB9 =&gt; 2
01, \xBA =&gt; 108, \xBB =&gt; 417, \xBC =&gt; 475, \xBD =&gt; 476, \xBE =&gt; 77, \xBF =&gt; 470, \xC3 =&gt; 488, \xC4-\xCA =&gt; 488, \xCC =&gt; 488, \xCE =&gt; 488, \xCF =&gt; 488, \xD0-\xD1 =&gt; 488, \xD2 =&gt; 488, \xD3
=&gt; 488, \xD4 =&gt; 488, \xD5 =&gt; 488, \xD8 =&gt; 488, \xD9 =&gt; 488, \xDA =&gt; 488, \xDC =&gt; 488, \xDD =&gt; 488)
 000478: sparse(\x97 =&gt; 2, \x9D =&gt; 2, \xA0-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xAE =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \xE3 =&gt; 488, \xE4 =&gt; 488, \xE5-\xE9 =&gt; 488, \xEA =&gt; 488,
 \xEB-\xEC =&gt; 488)
 000479: sparse(\x91 =&gt; 2, \x96 =&gt; 2, \x97 =&gt; 2, \x98 =&gt; 2, \xA0-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xAE =&gt; 2, \xAF =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \xE0 =&gt; 488, \xE3 =&gt; 48
8, \xE4 =&gt; 488, \xE5-\xE9 =&gt; 488, \xEA =&gt; 488, \xEB-\xEC =&gt; 488)
 000480: sparse(\x96 =&gt; 2, \x97 =&gt; 2, \x98 =&gt; 2, \xA0-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xAE =&gt; 2, \xAF =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \xE3 =&gt; 488, \xE4 =&gt; 488, \xE5-\xE
9 =&gt; 488, \xEB-\xEC =&gt; 488, \xEF =&gt; 488)
 000481: sparse(\x90 =&gt; 2, \x97 =&gt; 2, \x98 =&gt; 2, \x9D =&gt; 2, \xA0-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xAE =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \xE0 =&gt; 488, \xE1 =&gt; 488, \xE3 =&gt;
488, \xE4 =&gt; 488, \xE5-\xE9 =&gt; 488, \xEB-\xEC =&gt; 488, \xEF =&gt; 488)
 000482: sparse(\x91 =&gt; 2, \x97 =&gt; 2, \x98 =&gt; 2, \xA0-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xAE =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \xE0 =&gt; 488, \xE1 =&gt; 488, \xE3 =&gt; 488, \xE4 =
&gt; 488, \xE5-\xE9 =&gt; 488, \xEA =&gt; 488, \xEB-\xEC =&gt; 488, \xEF =&gt; 488)
 000483: sparse(\x91 =&gt; 2, \x97 =&gt; 2, \xA0-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \xE0 =&gt; 488, \xE1 =&gt; 488, \xE2 =&gt; 488, \xE3 =&gt; 488, \xE4 =&gt; 488, \x
E5-\xE9 =&gt; 488, \xEA =&gt; 488, \xEB-\xEC =&gt; 488)
 000484: sparse(\x91 =&gt; 2, \x97 =&gt; 2, \xA0-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \xE0 =&gt; 488, \xE1 =&gt; 488, \xE2 =&gt; 488, \xE3 =&gt; 488, \xE4 =&gt; 488, \x
E5-\xE9 =&gt; 488, \xEA =&gt; 488, \xEB-\xEC =&gt; 488, \xEF =&gt; 488)
 000485: sparse(\x97 =&gt; 2, \xA0-\xA9 =&gt; 2, \xAA =&gt; 2, \xAB =&gt; 2, \xAC =&gt; 2, \xAD =&gt; 2, \xB0 =&gt; 2, \xB1 =&gt; 2, \xE3 =&gt; 488, \xE4 =&gt; 488, \xE5-\xE9 =&gt; 488, \xEA =&gt; 488, \xEB-\xEC =&gt; 488)
 000486: sparse(\x80 =&gt; 4, \x81 =&gt; 396, \x82 =&gt; 6, \x83 =&gt; 387, \x84 =&gt; 472, \x85 =&gt; 451, \x86 =&gt; 174, \x87 =&gt; 387, \x88 =&gt; 12, \x89 =&gt; 100, \x8A =&gt; 195, \x8B =&gt; 348, \x8C =&gt; 14, \x8D =&gt;
452, \x8E =&gt; 16, \x8F =&gt; 426, \x90 =&gt; 19, \x91 =&gt; 62, \x92 =&gt; 20, \x93 =&gt; 473, \x94 =&gt; 114, \x95 =&gt; 62, \x96 =&gt; 23, \x97 =&gt; 61, \x98 =&gt; 179, \x99 =&gt; 27, \x9A =&gt; 27, \x9B =&gt; 441, \x9C =&gt; 4
46, \x9D =&gt; 236, \x9E =&gt; 28, \x9F =&gt; 478, \xA0 =&gt; 462, \xA1 =&gt; 442, \xA2 =&gt; 31, \xA3 =&gt; 479, \xA4 =&gt; 33, \xA5 =&gt; 467, \xA6 =&gt; 305, \xA7 =&gt; 480, \xA8 =&gt; 481, \xA9 =&gt; 399, \xAA =&gt; 482, \xAB
 =&gt; 443, \xAC =&gt; 43, \xAD =&gt; 414, \xAE =&gt; 43, \xAF =&gt; 447, \xB0 =&gt; 438, \xB1 =&gt; 474, \xB2 =&gt; 363, \xB3 =&gt; 457, \xB4 =&gt; 483, \xB5 =&gt; 484, \xB6 =&gt; 108, \xB7 =&gt; 141, \xB8 =&gt; 465, \xB9 =&gt; 374
, \xBA =&gt; 108, \xBB =&gt; 417, \xBC =&gt; 71, \xBD =&gt; 476, \xBE =&gt; 57, \xBF =&gt; 485, \xC3 =&gt; 488, \xC4-\xCA =&gt; 488, \xCC =&gt; 488, \xCD =&gt; 488, \xCE =&gt; 488, \xCF =&gt; 488, \xD0-\xD1 =&gt; 488, \xD2 =&gt;
488, \xD3 =&gt; 488, \xD4 =&gt; 488, \xD5 =&gt; 488, \xD6 =&gt; 488, \xD8 =&gt; 488, \xD9 =&gt; 488, \xDA =&gt; 488, \xDB =&gt; 488, \xDC =&gt; 488, \xDD =&gt; 488)
^000487: sparse(0-9 =&gt; 488, A-Z =&gt; 488, _ =&gt; 488, a-z =&gt; 488, \x80 =&gt; 58, \x81 =&gt; 72, \x82 =&gt; 78, \x83 =&gt; 86, \x84 =&gt; 96, \x85 =&gt; 111, \x86 =&gt; 123, \x87 =&gt; 136, \x88 =&gt; 143, \x89 =&gt; 153,
\x8A =&gt; 165, \x8B =&gt; 172, \x8C =&gt; 177, \x8D =&gt; 186, \x8E =&gt; 194, \x8F =&gt; 202, \x90 =&gt; 217, \x91 =&gt; 222, \x92 =&gt; 224, \x93 =&gt; 227, \x94 =&gt; 233, \x95 =&gt; 238, \x96 =&gt; 244, \x97 =&gt; 251, \x98
=&gt; 257, \x99 =&gt; 258, \x9A =&gt; 269, \x9B =&gt; 274, \x9C =&gt; 279, \x9D =&gt; 285, \x9E =&gt; 295, \x9F =&gt; 298, \xA0 =&gt; 312, \xA1 =&gt; 315, \xA2 =&gt; 320, \xA3 =&gt; 322, \xA4 =&gt; 328, \xA5 =&gt; 333, \xA6 =&gt; 33
8, \xA7 =&gt; 341, \xA8 =&gt; 345, \xA9 =&gt; 351, \xAA =&gt; 360, \xAB =&gt; 365, \xAC =&gt; 368, \xAD =&gt; 375, \xAE =&gt; 383, \xAF =&gt; 385, \xB0 =&gt; 395, \xB1 =&gt; 402, \xB2 =&gt; 408, \xB3 =&gt; 411, \xB4 =&gt; 418, \x
B5 =&gt; 425, \xB6 =&gt; 429, \xB7 =&gt; 435, \xB8 =&gt; 440, \xB9 =&gt; 444, \xBA =&gt; 450, \xBB =&gt; 460, \xBC =&gt; 466, \xBD =&gt; 471, \xBE =&gt; 477, \xBF =&gt; 486)
 000488: MATCH(0)
</code></pre><p>So shrinking in the reverse case still helps quite a bit in terms of generating
tighter NFAs with fewer states. But because of the extra compile time hit,
it is currently disabled by default. Therefore, the minimal UTF-8 automata
optimization only applies to forward NFAs. (Reverse NFAs are created for use
with DFAs, since a DFA requires a reverse scan to find the start of each
match.) However, we do still look for redundant suffixes and share them in the
reverse case when this extra NFA shrinking isn’t enabled.</p>
<h3 id="nfa-optimization-literal-trie">NFA optimization: literal trie</h3>
<p>If you haven’t noticed a theme by now, one of the biggest problems with a
Thompson NFA is its epsilon transitions. It is really the critical thing about
a Thompson NFA that makes it scale poorly with respect to the size of a regex.
This is why, when using Thompson based regex engines, increasing the size
of the regex can impact search times. Because of that, Thompson based regex
engines often (but not always) have alternative engines that mitigate this
weakness in one way or another. For example, by using a lazy DFA. However, a
lazy DFA cannot be used in every circumstance, and even a lazy DFA can become
overwhelmed by a large enough regex.</p>
<p>So in this section, we’ll talk about another NFA optimization that works to
reduce epsilon transitions. In this case, we’re going to be limiting ourselves
to an alternation of literals. Let’s take a look at an example using the old
NFA compiler:</p>
<pre tabindex="0"><code>$ regex-debug compile &#39;zap|z|zapper&#39;
0000 Save(0) (start)
0001 Split(2, 5)
0002 &#39;z&#39;
0003 &#39;a&#39;
0004 &#39;p&#39; (goto: 13)
0005 Split(6, 7)
0006 &#39;z&#39; (goto: 13)
0007 &#39;z&#39;
0008 &#39;a&#39;
0009 &#39;p&#39;
0010 &#39;p&#39;
0011 &#39;e&#39;
0012 &#39;r&#39;
0013 Save(1)
0014 Match(0)
</code></pre><p>Here, we’re building an NFA for the regex <code>zap|z|zapper</code>. The way it’s compiled
is with nested <code>Split</code> instructions. It starts with a <code>Split(2, 5)</code> that points
to the beginning of <code>zap</code> and another <code>Split(6, 7)</code> instruction. This second
instruction then points to the beginning of <code>z</code> and <code>zapper</code>. So for this
regex, when looking for a match, the epsilon closure of all these splits is
enumerated for every character in the haystack.</p>
<p>In contrast, let’s look at what the new NFA compiler does:</p>
<pre tabindex="0"><code>$ regex-cli debug thompson --no-table &#39;zap|z|zapper&#39;
thompson::NFA(
&gt;000000: binary-union(2, 1)
 000001: \x00-\xFF =&gt; 0
^000002: capture(pid=0, group=0, slot=0) =&gt; 11
 000003: p =&gt; 12
 000004: a =&gt; 3
 000005: r =&gt; 12
 000006: e =&gt; 5
 000007: p =&gt; 6
 000008: p =&gt; 7
 000009: a =&gt; 8
 000010: union(4, 12, 9)
 000011: z =&gt; 10
 000012: capture(pid=0, group=0, slot=1) =&gt; 13
 000013: MATCH(0)
</code></pre><p>(Again, ignore states <code>0</code> and <code>1</code>, which correspond to the optional unanchored
<code>(?s-u:.)*?</code> prefix. The old NFA compiler doesn’t emit those states for
unrelated reasons.)</p>
<p>Here, before an epsilon transition is seen at all, a <code>z</code> must first be matched
in state <code>11</code>. Only after that is the <code>union(4, 12, 9)</code> state seen. (This
<code>union</code> is equivalent to the nested <code>Split</code> instructions in the old NFA
compiler, but combines them all into one state.) If this NFA were used for a
search, one wouldn’t need to compute a beefy epsilon closure for every byte in
the haystack. One would only need to do it after a <code>z</code> byte is seen, which is
much more rare. In effect, the regex was rewritten to <code>z(?:ap||apper)</code>.</p>
<p>So what’s going on here? In this particular case, it almost looks like a common
prefix has been factored out. But the optimization at work here is a bit more
general than that. Consider the regex <code>abc|xyz</code>. There are no common prefixes
here. First, let’s see what the old NFA compiler does:</p>
<pre tabindex="0"><code>$ regex-debug compile &#39;abc|xyz&#39;
0000 Save(0) (start)
0001 Split(2, 5)
0002 &#39;a&#39;
0003 &#39;b&#39;
0004 &#39;c&#39; (goto: 8)
0005 &#39;x&#39;
0006 &#39;y&#39;
0007 &#39;z&#39;
0008 Save(1)
0009 Match(0)
</code></pre><p>Here, we see a <code>Split</code> instruction again that forks out to the start of <code>abc</code>
and then <code>xyz</code>.</p>
<p>Now the new NFA compiler:</p>
<pre tabindex="0"><code>$ regex-cli debug thompson --no-table &#39;abc|xyz&#39;
thompson::NFA(
&gt;000000: binary-union(2, 1)
 000001: \x00-\xFF =&gt; 0
^000002: capture(pid=0, group=0, slot=0) =&gt; 7
 000003: c =&gt; 8
 000004: b =&gt; 3
 000005: z =&gt; 8
 000006: y =&gt; 5
 000007: sparse(a =&gt; 4, x =&gt; 6)
 000008: capture(pid=0, group=0, slot=1) =&gt; 9
 000009: MATCH(0)
)
</code></pre><p>Here there are no epsilon transitions at all. The <code>a</code> and <code>x</code> have been lifted
out into the same sparse state, with each them forking off to their respective
suffixes, <code>bc</code> and <code>yz</code>.</p>
<p>What’s happening here is that the NFA compiler is recognizing an alternation
of literals, <a href="https://github.com/rust-lang/regex/blob/4f47b14d60e82e85a880513833362d5fb485ffa8/regex-automata/src/nfa/thompson/literal_trie.rs">compiling it into a trie</a>, and then converting
that trie to an NFA directly in a way that minimizes epsilon transitions. The
key trick to this optimization is ensuring that leftmost-first semantics are
preserved. For example, in the <code>zap|z|zapper</code> example above, one might be
tempted to rewrite it as <code>z(?:ap(?:per)?)?</code>. But this does not have the same
matches! This regex will match <code>zapper</code> in the haystack <code>zapper</code>, but the
original <code>zap|z|zapper</code> will match <code>zap</code>. The literal trie achieves this by
partitioning the transitions in each trie state into chunks, where a chunk is
created whenever a match (of one of the literals) is seen. If a normal trie was
created, then the preference order required by leftmost-first semantics would
be lost when translating the trie back to an NFA.</p>
<h3 id="nfa-future-work">NFA future work</h3>
<p>There are two aspects I’d like to explore for future work on NFAs.</p>
<p>First is the <a href="https://en.wikipedia.org/wiki/Glushkov%27s_construction_algorithm">Glushkov NFA</a>. A Glushkov NFA has a worse time complexity
for compilation, but it comes with the advantage of not having any epsilon
transitions. (Instead, it is an NFA by virtue of permitting a state to have
multiple transitions defined for the same haystack symbol.) Because of the
worse compilation time complexity, a Glushkov NFA probably can’t be used in
every case, but it’s certainly plausible to use it for a subset of smaller
regexes. A Glushkov NFA is possibly more amenable to bit-parallel techniques
that are sadly underused in the <code>regex</code> crate at present. One of the big
questions marks for me here is how well a Glushkov NFA will fair with big
Unicode classes. (Perhaps such things will be a disqualifiying criterion.)</p>
<p>Second is storing an NFA in a single contiguous allocation. This might make
access patterns faster and more cache friendly, but perhaps more importantly,
it could permit zero-copy serialization and deserialization. The downside of
doing this is code complexity and potentially more use of <code>unsafe</code>, but there
are some potentially nice benefits too.</p>
<h2 id="regex-engines">Regex engines</h2>
<p>Like <a href="https://github.com/google/re2">RE2</a>, the <code>regex</code> crate is internally composed of several different regex
engines. Most of them have already been mentioned so far. In this section, we
will do a bit of a deeper dive on each of them and explain why they exist.
Finally, we’ll wrap up by exploring the meta regex engine, which combines all
of the regex engines into a single engine.</p>
<p>But why have so many regex engines? The reason is essentially engineering: the
implementation of regex engines with more functionality tends to search more
slowly than regex engines that have less functionality. We could use only a
single regex engine that supports all the functionality we want, namely the
<a href="https://docs.rs/regex-automata/0.3.*/regex_automata/nfa/thompson/pikevm/struct.PikeVM.html"><code>PikeVM</code></a>, but the search performance would likely be disappointing to a lot
of users. This fundamentally drives the addition of other engines. None of
the other engines can support the full range of functionality provided by the
<code>regex</code> crate, and so buck stops with the <code>PikeVM</code>.</p>
<p>In addition to using <code>regex-cli</code> to show how to run each regex engine, we’ll
also look at short example Rust programs. To follow along with the Rust
program examples, you’ll want to setup a Cargo project and add <code>regex-automata</code>
as a dependency:</p>
<pre tabindex="0"><code>$ cargo init --bin
$ cargo add &#39;regex-automata@0.3&#39;
</code></pre><p>Then you can edit <code>src/main.rs</code> to add source code and run the program with
<code>cargo run</code>.</p>
<h3 id="common-elements-among-regex-engines">Common elements among regex engines</h3>
<p>While there are many regex engines in the <code>regex-automata</code> crate, all of them
share very similar APIs. Because of that, it’s worth covering a few of those
common elements first.</p>
<p>The three most important types are <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/struct.Input.html"><code>Input</code></a>, <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/struct.Match.html"><code>Match</code></a> and <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/struct.MatchError.html"><code>MatchError</code></a>.</p>
<p><code>Input</code> is a small abstraction for setting the parameters of a single search.
Its only required parameter is a haystack, that is, the sequence of bytes to
search. Most search APIs accept anything that implements the <code>Into&lt;Input&gt;</code>
trait, and both <code>&amp;[u8]</code> and <code>&amp;str</code> implement <code>Into&lt;Input&gt;</code>. Optional parameters
consist of the span of the haystack to search, whether to execute an anchored
search and whether to stop the search early as soon as a match is found instead
of greedily trying to match as much as possible.</p>
<p><code>Match</code> represents the data reported whenever a match is found in a
haystack. The data consists of two elements. The first is the span of
byte offsets in the haystack where the match was found. The second is the
<a href="https://docs.rs/regex-automata/0.3.*/regex_automata/struct.PatternID.html"><code>PatternID</code></a> corresponding to the pattern that matched. (Every regex engine
in <code>regex-automata</code> has first class multi-pattern support. Pattern IDs are
assigned, starting from zero, in an auto-incrementing fashion based on the
order of the patterns given to the regex engine constructor.)</p>
<p><code>MatchError</code> represents an error that occurred during a search. When an error
occurs, it is not possible to determine whether a match exists or not. That is,
the result is indeterminate. For this reason, many of the basic search APIs
have a return type of <code>Result&lt;Option&lt;Match&gt;, MatchError&gt;</code>. Errors can occur
during a search for a variety of reasons. For example, a DFA can be configured
to quit immediately whenever a certain byte is seen. Another example is the
<a href="https://docs.rs/regex-automata/0.3.*/regex_automata/nfa/thompson/backtrack/struct.BoundedBacktracker.html"><code>BoundedBacktracker</code></a>, which will fail if the length of the haystack exceeds a
configured limit. One of the main features of the <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/meta/struct.Regex.html">meta regex engine</a>, as we’ll
discuss later, is providing a facade on top of a composition of regex engines
that never results in an error being returned to the caller.</p>
<p>There are some other themes common to most regex engines. For example, the
construction of most engines is done by a <code>Builder</code> and configured by one or
more <code>Config</code> values. We’ll talk about these more as they come up. See also the
<a href="https://docs.rs/regex-automata/0.3.*/regex_automata/#api-themes">API themes</a> section in the <code>regex-automata</code> crate documentation.</p>
<h3 id="engine-pike-vm">Engine: Pike VM</h3>
<p>As mentioned above, the buck stops with the <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/nfa/thompson/pikevm/struct.PikeVM.html"><code>PikeVM</code></a>. That is, the <code>PikeVM</code>
supports the full suite of regex functionality that one can parse with
<code>regex-syntax</code>, and it supports this for any haystack of any length. Other
regex engines have various limitations. For example:</p>
<ul>
<li>The <code>BoundedBacktracker</code> only works in cases where <code>len(haystack) * len(regex)</code> is below a configured limit. In practice, this often means one can
only use it with short haystacks.</li>
<li>The one-pass DFA only works a small subset of NFAs that satisfy the
“one-pass” criterion.</li>
<li>The lazy DFA and full DFA cannot match Unicode word boundaries. Both have
heuristics for treating a Unicode word boundary as an ASCII word boundary when
the haystack only consists of ASCII, but if a non-ASCII byte is seen, both can
quit and return an error instead of completing the search.</li>
</ul>
<p>Other than a <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/nfa/thompson/pikevm/struct.Cache.html"><code>Cache</code></a> value, a <code>PikeVM</code> can be built directly
from an NFA without any additional work. That is, its search works by a
“simulation” of the NFA itself. (Confusingly, this is sometimes referred to
as the “DFA algorithm.”) The actual implementation is structured similarly to
a virtual machine, with each NFA state acting as an instruction. The <code>PikeVM</code>
works by moving from NFA state to the next, and computing epsilon closures
on the fly. Since it’s possible to be in multiple NFA states simultaneously,
the <code>PikeVM</code> keeps track of every active state. The transition function then
applies to each of those states. The <code>PikeVM</code> also keeps track of capture group
positions.</p>
<p>The main problem with the <code>PikeVM</code> is performance, and its poor performance is
primarily rooted in having to keep track of so much state. The capture group
positions are required to report the start and end match offsets, while the
currently active states must be tracked in order to guarantee worst case
<code>O(m * n)</code> time. That is, in contrast to a backtracking approach, the <code>PikeVM</code>
visits each byte in the haystack at most a constant number of times, and it
does so by computing all possible active states in lock-step. This adds quite
a bit of overhead, and it can be exacerbated by regexes with a lot of epsilon
transitions. (This is one of the reasons why, earlier in this blog, we spent so
much time talking about optimizations in the NFA to elide epsilon transitions.)</p>
<p>Now that we’ve talked a little about how the <code>PikeVM</code> works, let’s look at a
few examples. Here’s a lightly annotated Rust program showing how to use it for
a search:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>regex_automata</span>::<span>{</span><span>nfa</span>::<span>thompson</span>::<span>pikevm</span>::<span>PikeVM</span><span>,</span><span> </span><span>Match</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// This creates a PikeVM directly from a pattern string. But one can also
</span></span></span><span><span><span></span><span>    </span><span>// build a PikeVM directly from an NFA using `PikeVM::builder()`.
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>PikeVM</span>::<span>new</span><span>(</span><span>r</span><span>&#34;\b\w+\b&#34;</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>// Most regex engines in regex-automata require some kind of mutable
</span></span></span><span><span><span></span><span>    </span><span>// scratch space that can be written to during a search. The meta regex
</span></span></span><span><span><span></span><span>    </span><span>// engine has APIs that hide this fact from you, but when you use the
</span></span></span><span><span><span></span><span>    </span><span>// underlying regex engines directly, you must create and pass around these
</span></span></span><span><span><span></span><span>    </span><span>// cache values explicitly.
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>cache</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>create_cache</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>it</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>find_iter</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>cache</span><span>,</span><span> </span><span>&#34;Σέρλοκ Χολμς&#34;</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>Some</span><span>(</span><span>Match</span>::<span>must</span><span>(</span><span>0</span><span>,</span><span> </span><span>0</span><span>..</span><span>12</span><span>)),</span><span> </span><span>it</span><span>.</span><span>next</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>Some</span><span>(</span><span>Match</span>::<span>must</span><span>(</span><span>0</span><span>,</span><span> </span><span>13</span><span>..</span><span>23</span><span>)),</span><span> </span><span>it</span><span>.</span><span>next</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>None</span><span>,</span><span> </span><span>it</span><span>.</span><span>next</span><span>());</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>And the equivalent <code>regex-cli</code> command:</p>
<pre tabindex="0"><code>$ regex-cli find match pikevm --no-table -p &#39;\b\w+\b&#39; -y &#39;Σέρλοκ Χολμς&#39;
0:0:12:Σέρλοκ
0:13:23:Χολμς
</code></pre><p>Notice the use of Unicode word boundaries on a non-ASCII haystack. Only the
<code>PikeVM</code>, <code>BoundedBacktracker</code> and one-pass DFA support this. The lazy DFA
and fully compiled DFA would return an error in this case.</p>
<p>The other important thing to notice here is that the search APIs do not
return an error. Indeed, the <code>PikeVM</code> can never return an error under any
circumstances (nor will it ever panic). This is actually a unique property
among the regex engines in <code>regex-automata</code>. Every other regex engine can
return an error during a search for one reason or another.</p>
<p>We can also make use of multi-pattern support with capture groups
simultaneously. (This is something that the <code>regex</code> crate cannot do, and many
have requested this support from its <code>RegexSet</code> API. That still doesn’t exist,
but you can now at least drop down to <code>regex-automata</code> and do it. This same
example also works with the meta regex engine.)</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>regex_automata</span>::<span>nfa</span>::<span>thompson</span>::<span>pikevm</span>::<span>PikeVM</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>PikeVM</span>::<span>new_many</span><span>(</span><span>&amp;</span><span>[</span><span>
</span></span></span><span><span><span>        </span><span>r</span><span>&#34;(?&lt;email&gt;[.\w]+@(?&lt;domain&gt;[.\w]+))&#34;</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>r</span><span>&#34;(?&lt;phone&gt;(?&lt;areacode&gt;[0-9]{3})-[0-9]{3}-[0-9]{4})&#34;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>])</span><span>
</span></span></span><span><span><span>    </span><span>.</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>cache</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>create_cache</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>hay</span><span> </span><span>=</span><span> </span><span>&#34;foo@example.com, 111-867-5309&#34;</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>it</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>captures_iter</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>cache</span><span>,</span><span> </span><span>hay</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>caps</span><span> </span><span>=</span><span> </span><span>it</span><span>.</span><span>next</span><span>().</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>0</span><span>,</span><span> </span><span>caps</span><span>.</span><span>pattern</span><span>().</span><span>unwrap</span><span>().</span><span>as_usize</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>&#34;example.com&#34;</span><span>,</span><span> </span><span>&amp;</span><span>hay</span><span>[</span><span>caps</span><span>.</span><span>get_group_by_name</span><span>(</span><span>&#34;domain&#34;</span><span>).</span><span>unwrap</span><span>()]);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>caps</span><span> </span><span>=</span><span> </span><span>it</span><span>.</span><span>next</span><span>().</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>1</span><span>,</span><span> </span><span>caps</span><span>.</span><span>pattern</span><span>().</span><span>unwrap</span><span>().</span><span>as_usize</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>&#34;111&#34;</span><span>,</span><span> </span><span>&amp;</span><span>hay</span><span>[</span><span>caps</span><span>.</span><span>get_group_by_name</span><span>(</span><span>&#34;areacode&#34;</span><span>).</span><span>unwrap</span><span>()]);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>assert!</span><span>(</span><span>it</span><span>.</span><span>next</span><span>().</span><span>is_none</span><span>());</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>And the equivalent <code>regex-cli</code> command:</p>
<pre tabindex="0"><code>$ regex-cli find capture pikevm --no-table \
   -p &#39;(?&lt;email&gt;[.\w]+@(?&lt;domain&gt;[.\w]+))&#39; \
   -p &#39;(?&lt;phone&gt;(?&lt;areacode&gt;[0-9]{3})-[0-9]{3}-[0-9]{4})&#39; \
   -y &#39;foo@example.com, 111-867-5309&#39;
0:{ 0: 0..15/foo@example.com, 1/email: 0..15/foo@example.com, 2/domain: 4..15/example.com }
1:{ 0: 17..29/111-867-5309, 1/phone: 17..29/111-867-5309, 2/areacode: 17..20/111 }
</code></pre><p>Notice how the capture groups are different for each pattern. The caller is
responsible for using the correct capture group name based on which pattern
matches.</p>
<h3 id="engine-bounded-backtracker">Engine: bounded backtracker</h3>
<p>The <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/nfa/thompson/backtrack/struct.BoundedBacktracker.html"><code>BoundedBacktracker</code></a> uses a backtracking algorithm to execute a search
using a Thompson NFA directly. This is sometimes also (confusingly) referred
to as the “NFA algorithm.” The key difference between the backtracking
implementation in <code>regex-automata</code> and most other implementations is that
it uses additional state to avoid re-tracing steps already taken during
backtracking. This allows us to guarantee worst case <code>O(m * n)</code> time, but at
the expense of <code>O(m * n)</code> space.</p>
<p>(Classical backtracking is also technically bounded theoretically, but the
“bounded” in the name “bounded backtracker” refers to the explicit bound used
in the implementation to guarantee worst case <code>O(m * n)</code> time.)</p>
<p>The benefit of a the bounded backtracker is purely that it is usually faster
than the <code>PikeVM</code>. In rough experiments, it’s usually about twice as fast.</p>
<p>Here’s a quick example, like the <code>PikeVM</code> example previously, but using the
bounded backtracker:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>regex_automata</span>::<span>{</span><span>nfa</span>::<span>thompson</span>::<span>backtrack</span>::<span>BoundedBacktracker</span><span>,</span><span> </span><span>Match</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>BoundedBacktracker</span>::<span>new</span><span>(</span><span>r</span><span>&#34;\b\w+\b&#34;</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>// A bounded backtracker needs a cache just like the PikeVM. The Cache
</span></span></span><span><span><span></span><span>    </span><span>// keeps track of work already done, and also contains scratch space for
</span></span></span><span><span><span></span><span>    </span><span>// backtracking&#39;s call stack, which is stored on the heap.
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>cache</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>create_cache</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Unlike the PikeVM, the bounded backtracker can fail to run a search.
</span></span></span><span><span><span></span><span>    </span><span>// This occurs when `len(regex) * len(haystack)` exceeds the configured
</span></span></span><span><span><span></span><span>    </span><span>// visited capacity. We&#39;ll see an example of this below.
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>it</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>try_find_iter</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>cache</span><span>,</span><span> </span><span>&#34;Σέρλοκ Χολμς&#34;</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>Some</span><span>(</span><span>Ok</span><span>(</span><span>Match</span>::<span>must</span><span>(</span><span>0</span><span>,</span><span> </span><span>0</span><span>..</span><span>12</span><span>))),</span><span> </span><span>it</span><span>.</span><span>next</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>Some</span><span>(</span><span>Ok</span><span>(</span><span>Match</span>::<span>must</span><span>(</span><span>0</span><span>,</span><span> </span><span>13</span><span>..</span><span>23</span><span>))),</span><span> </span><span>it</span><span>.</span><span>next</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>None</span><span>,</span><span> </span><span>it</span><span>.</span><span>next</span><span>());</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>And the equivalent <code>regex-cli</code> command:</p>
<pre tabindex="0"><code>$ regex-cli find match backtrack --no-table -p &#39;\b\w+\b&#39; -y &#39;Σέρλοκ Χολμς&#39;
0:0:12:Σέρλοκ
0:13:23:Χολμς
</code></pre><p>This exame should look almost identical to the <code>PikeVM</code> example. One important
difference is that instead of calling <code>re.find_iter(..)</code>, we instead called
<code>re.try_find_iter(..)</code>. Namely, as mentioned above, the bounded backtracker can
return an error when a search would require more memory than what is configured.
The relevant configuration knob is <a href="https://docs.rs/regex-automata/0.3.*/regex/regex_automata/nfa/thompson/backtrack/struct.Config.html#method.visited_capacity"><code>Config::visited_capacity</code></a>. We can also
query just how big of a haystack a bounded backtracker can search without
failing:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>regex_automata</span>::<span>nfa</span>::<span>thompson</span>::<span>backtrack</span>::<span>BoundedBacktracker</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>BoundedBacktracker</span>::<span>new</span><span>(</span><span>r</span><span>&#34;\b\w+\b&#34;</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34;</span><span>{:?}</span><span>&#34;</span><span>,</span><span> </span><span>re</span><span>.</span><span>max_haystack_len</span><span>());</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>At the time of writing, the output of this program on my machine is <code>6635</code>.
That might seem pretty short, and that’s because the regex is perhaps bigger
than you might think it is. Namely, since <code>\w</code> is Unicode-aware by default,
<code>\w</code> matches over 100,000 distinct codepoints. While we could increase the
maximum haystack length that we could search by setting a bigger value for
<code>Config::visited_capacity</code>, we can <em>also</em> increase it by decreasing the size of
our regex by disabling Unicode mode:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>regex_automata</span>::<span>nfa</span>::<span>thompson</span>::<span>backtrack</span>::<span>BoundedBacktracker</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>BoundedBacktracker</span>::<span>new</span><span>(</span><span>r</span><span>&#34;\b\w+\b&#34;</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34;</span><span>{:?}</span><span>&#34;</span><span>,</span><span> </span><span>re</span><span>.</span><span>max_haystack_len</span><span>());</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The output of this program on my machine is now <code>233015</code>. That’s nearly two
orders of magnitude difference!</p>
<p>Overall, when possible, one should prefer using the bounded backtracker over
the <code>PikeVM</code>. They both have the same time complexity guarantees, but the
bounded backtracker tends to be faster in practice.</p>
<h3 id="engine-one-pass-dfa">Engine: one-pass DFA</h3>
<p>Before talking about the <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/dfa/onepass/struct.DFA.html">one-pass DFA</a>, it makes sense to motivate its
existence in a bit more detail. Namely, one important aspect of both the
<code>PikeVM</code> and the bounded backtracker is that they support reporting the offsets
of matching capture groups in the pattern. For example, using the <code>PikeVM</code> with
<code>regex-cli</code>:</p>
<pre tabindex="0"><code>$ regex-cli find capture pikevm --no-table \
   -p &#39;(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})&#39; \
   -y &#39;2023-07-02&#39;
0:{ 0: 0..10/2023-07-02, 1/year: 0..4/2023, 2/month: 5..7/07, 3/day: 8..10/02 }
</code></pre><p>Capture groups are quite useful because they permit de-composing a regex match
down into constituent parts that are independently useful. As in the above
example, we didn’t <em>just</em> match a date, we matched the individual components
of that date and made each of those components easily available via APIs. For
example, using the <code>regex</code> crate itself:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>regex</span>::<span>Regex</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>pat</span><span> </span><span>=</span><span> </span><span>r</span><span>&#34;(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})&#34;</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>Regex</span>::<span>new</span><span>(</span><span>pat</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>Some</span><span>(</span><span>caps</span><span>)</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>captures</span><span>(</span><span>&#34;2023-07-02&#34;</span><span>)</span><span> </span><span>else</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>};</span><span>
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34; year: </span><span>{:?}</span><span>&#34;</span><span>,</span><span> </span><span>&amp;</span><span>caps</span><span>[</span><span>&#34;year&#34;</span><span>]);</span><span>
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34;month: </span><span>{:?}</span><span>&#34;</span><span>,</span><span> </span><span>&amp;</span><span>caps</span><span>[</span><span>&#34;month&#34;</span><span>]);</span><span>
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34;  day: </span><span>{:?}</span><span>&#34;</span><span>,</span><span> </span><span>&amp;</span><span>caps</span><span>[</span><span>&#34;day&#34;</span><span>]);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Without capture groups, regexes become a lot less convenient.</p>
<p>The problem with capture groups is that they aren’t something that cleanly fit
into the theoretical model of regular languages and finite automata. (They
require something more expressive known as <a href="https://arxiv.org/abs/1907.08837">tagged finite automata</a>.) As a
result, capture groups are bolted on to the classical NFA simulation, and
the result is named <code>PikeVM</code>. Capture groups are also part of the classic
“NFA algorithm” or backtracking, as the matching offsets of each group can be
recorded as the backtracking search progresses through the haystack.</p>
<p>But that’s generally where capture groups stop being supported. DFAs simply
do not support them, and there is no obvious way to make them support capture
groups in general without evolving to something like tagged finite automata.</p>
<p>However, there is one case where we can bolt capture groups into something that
executes like a DFA: a one-pass NFA. One can think of a one-pass NFA as an NFA
that can be converted into a DFA where each DFA state maps to at most one NFA
state. That is, when performing a search using an NFA simulation, then at each
possible character in the haystack there is at most one NFA state to transition
to.</p>
<p>The intuition behind this special case is that only one copy of the matching
capture groups needs to be kept. (In the <code>PikeVM</code>, there are up to <code>len(regex)</code>
copies of capture groups kept, as there is no way to know which capture groups
will wind up being part of the final match.) If one can detect this case, then
a new DFA can be constructed from the NFA in the linear time, and this DFA can
execute a search such that a constant number of CPU instructions are used to
process each character in the haystack.</p>
<p>The end result of this is a <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/dfa/onepass/struct.DFA.html">one-pass DFA</a> and it generally runs quite a bit
faster than either the <code>PikeVM</code> or the bounded backtracker. In other words, it
represents the fastest way to report the offsets of matching capture groups in
the <code>regex</code> crate.</p>
<p>The problem with a one-pass DFA is that, as a DFA, it uses a lot more memory.
(The memory problem is mitigated by giving one-pass DFA construction a
configurable fixed budget of memory, and if it’s exceeded, one-pass DFA
construction fails.) Additionally, many regexes are not one-pass. For example,
all unanchored searches in the <code>regex</code> crate are done by adding an implicit
<code>(?s-u:.)*?</code> prefix to the beginning of the regex. That prefix is itself not
one-pass when followed by any non-empty regex. Therefore, a one-pass DFA only
supports anchored searches.</p>
<p>The “only anchored” search limitation might make it seem like the one-pass
DFA has very limited utility, but as we’ll see in more detail, the meta regex
engine uses anchored searches quite a bit even if the original regex itself
isn’t anchored. This can occur when the caller asked for the offsets of
matching capture groups. The meta regex engine starts by looking for an overall
match using a DFA engine, and then once a match is found, an anchored search
is used on only the matched part of the haystack to report offsets for each
matching capture group. In this way, the utility of the one-pass DFA is quite
high.</p>
<p>Using the one-pass DFA directly is possible, and it looks similar to past
examples but with some small deviations because of the one-pass DFA’s more
limited API:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>regex_automata</span>::<span>{</span><span>dfa</span>::<span>onepass</span>::<span>DFA</span><span>,</span><span> </span><span>Match</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>DFA</span>::<span>new</span><span>(</span><span>r</span><span>&#34;\b\w+\b&#34;</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>cache</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>create_cache</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// A one-pass DFA doesn&#39;t expose any iterator APIs directly because it only
</span></span></span><span><span><span></span><span>    </span><span>// supports anchored matches. Thus, any iterator that would be returned
</span></span></span><span><span><span></span><span>    </span><span>// would only support adjacent matches. Such a thing is a valid use case,
</span></span></span><span><span><span></span><span>    </span><span>// but it wouldn&#39;t match the semantics of every other iterator in
</span></span></span><span><span><span></span><span>    </span><span>// regex-automata.
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>Some</span><span>(</span><span>m</span><span>)</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>find</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>cache</span><span>,</span><span> </span><span>&#34;Σέρλοκ Χολμς&#34;</span><span>)</span><span> </span><span>else</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>};</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>Match</span>::<span>must</span><span>(</span><span>0</span><span>,</span><span> </span><span>0</span><span>..</span><span>12</span><span>),</span><span> </span><span>m</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>And the equivalent <code>regex-cli</code> command:</p>
<pre tabindex="0"><code>$ regex-cli find match onepass --no-table --anchored \
   -p &#39;\b\w+\b&#39; \
   -y &#39;Σέρλοκ Χολμς&#39;
0:0:12:Σέρλοκ
</code></pre><p>Notice how we pass the <code>--anchored</code> flag to <code>regex-cli</code>. Without it, the
one-pass DFA search would return an error.</p>
<p>We can execute multiple searches as well. Even though the regex itself isn’t
anchored, we don’t have to limit ourselves to searches beginning at offset <code>0</code>:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>regex_automata</span>::<span>{</span><span>dfa</span>::<span>onepass</span>::<span>DFA</span><span>,</span><span> </span><span>Input</span><span>,</span><span> </span><span>Match</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>hay</span><span> </span><span>=</span><span> </span><span>&#34;Σέρλοκ Χολμς&#34;</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>DFA</span>::<span>new</span><span>(</span><span>r</span><span>&#34;\b\w+\b&#34;</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>cache</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>create_cache</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>Some</span><span>(</span><span>m</span><span>)</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>find</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>cache</span><span>,</span><span> </span><span>hay</span><span>)</span><span> </span><span>else</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>};</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>Match</span>::<span>must</span><span>(</span><span>0</span><span>,</span><span> </span><span>0</span><span>..</span><span>12</span><span>),</span><span> </span><span>m</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>input</span><span> </span><span>=</span><span> </span><span>Input</span>::<span>new</span><span>(</span><span>hay</span><span>).</span><span>range</span><span>(</span><span>13</span><span>..</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>Some</span><span>(</span><span>m</span><span>)</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>find</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>cache</span><span>,</span><span> </span><span>input</span><span>)</span><span> </span><span>else</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>};</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>Match</span>::<span>must</span><span>(</span><span>0</span><span>,</span><span> </span><span>13</span><span>..</span><span>23</span><span>),</span><span> </span><span>m</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The <code>Input</code> abstraction can be used in the same way with any other regex engine
as well.</p>
<p>It can be quite tricky to reason about whether a particular regex is one-pass
or not. For example, a regex can be one-pass when Unicode is disabled and not
one-pass when Unicode is enabled. For example:</p>
<pre tabindex="0"><code>$ regex-cli find match onepass --no-table --anchored \
   -p &#39;\w+\s+\w+&#39; \
   -y &#39;Σέρλοκ Χολμς&#39;
failed to compile onepass DFA: one-pass DFA could not be built because pattern is not one-pass: conflicting transition
</code></pre><p>But if we disable Unicode mode, then the regex becomes one-pass:</p>
<pre tabindex="0"><code>$ regex-cli find match onepass --no-table --anchored \
   -p &#39;(?-u)\w+\s+\w+&#39; \
   -y &#39;Sherlock Holmes&#39;
0:0:15:Sherlock\x20Holmes
</code></pre><p>This happens because, when Unicode mode is enabled, <code>\w</code> and <code>\s</code> partially
overlap. They of course do not overlap <em>logically</em>, as taking the codepoint
sets from each of <code>\w</code> and <code>\s</code> and intersecting them would produce the empty
set:</p>
<pre tabindex="0"><code>$ regex-cli debug hir --no-table &#39;[\w&amp;&amp;\s]&#39;
Class(
    {},
)
</code></pre><p>The overlap is actually at the byte level, and the byte level is how the
transitions in a one-pass DFA are defined. This overlap means that the DFA for
<code>\w+\s+\w+</code> when Unicode mode is enabled doesn’t satisfy the property that
every state in the DFA maps to at most one NFA state. That is, there exists
codepoints in both <code>\w</code> and <code>\s</code> which start with the same leading UTF-8 code
units.</p>
<p>But when Unicode mode is disabled, not only do the codepoint sets not have any
overlap, but they don’t have any overlap at the byte level either. Why? Because
the codepoints in <code>\w</code> and <code>\s</code> when Unicode is disabled are limited to ASCII
codepoints, and each ASCII codepoint is always encoded as a single UTF-8 code
unit corresponding to the ASCII codepoint number.</p>
<p>One should prefer a one-pass DFA over both the <code>PikeVM</code> and the bounded
backtracker because it is faster, although it can take longer to build and may
use more memory. However, because it can only be built from a very limited set
of regexes, one must be ready to deal with construction failing and falling
back to a different engine.</p>
<h3 id="engine-dfa">Engine: DFA</h3>
<p>The <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/dfa/regex/struct.Regex.html">DFA regex engine</a> is made up of two <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/dfa/dense/struct.DFA.html">dense DFAs</a>. One DFA is
responsible for a forward scan that finds the end of a match and the other DFA
is used to perform an anchored scan backwards from the end of a match to find
the start of a match. (This second DFA is built by reversing the concatenations
in an <a href="https://docs.rs/regex-syntax/0.7.*/regex_syntax/hir/struct.Hir.html"><code>Hir</code></a>, building an NFA from that and then determinizing that reverse
NFA into a DFA.) We call these DFAs “dense” to distinguish them from <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/dfa/sparse/struct.DFA.html">sparse
DFAs</a>. A dense DFA uses a representation that optimizes for
search speed at the expense of more memory usage, while a sparse DFA uses a
representation that optimizes for less memory usage at the expense of search
speed.</p>
<p>Fully compiled DFAs are usually not found in general purpose regex engines
because building them has worst case <code>O(2^m)</code> time and space (where <code>m</code> is
proportional to <code>len(regex)</code>). For example, <code>[01]*1[01]{N}</code> compiles to an NFA
with approximately <code>N</code> states, and as <code>N</code> grows, the NFA grows linearly. But
the corresponding DFA has approximately <code>2^N</code> states, and as the DFA grows, the
number of states grows exponentially.</p>
<p>But the problem with a DFA is not just limited to its theoretical worst case
behavior. DFAs, especially dense DFAs, tend to use a lot of memory because each
state supports computing the next transition for any byte in constant time.
This fundamentally requires more memory to provide constant time random access.
When you combine this with large Unicode character classes, the result can be
disastrous. For example, let’s compare some sizes for the regex <code>\w</code>. First
up is the NFA (which, remember, can be used directly as a regex engine in the
case of the <code>PikeVM</code> and bounded backtracker):</p>
<pre tabindex="0"><code>$ regex-cli debug thompson &#39;\w&#39; -q
[.. snip ..]
            memory:  17668
[.. snip ..]
</code></pre><p>So here, the NFA uses 17KB. That’s not exactly small, but watch what happens
when we determinize the NFA into a DFA:</p>
<pre tabindex="0"><code>$ regex-cli debug dense dfa &#39;\w&#39; --start-kind unanchored -q
[.. snip ..]
          memory:  159296
[.. snip ..]
</code></pre><p>Memory balloons to about 160KB! (I’ve limited the DFA to just an unanchored
DFA. If one used <code>--start-kind both</code> instead, the default, then memory usage
would double.) And spending extra time to minimize the DFA doesn’t help:</p>
<pre tabindex="0"><code>$ regex-cli debug dense dfa &#39;\w&#39; --start-kind unanchored --minimize -q
[.. snip ..]
          memory:  159296
[.. snip ..]
</code></pre><p>Sometimes minimization helps, but in this case, since we used <a href="https://blog.burntsushi.net/transducers/#references">Daciuk’s
algorithm</a> to build a minimal UTF-8 automaton into the NFA for <code>\w</code>, it follows
that determinizing that NFA into a DFA itself already results in a minimal DFA.
The real problem here is a result of our dense representation and the fact that
our alphabet is defined over bytes. We can make it a little better by switching
to a sparse representation:</p>
<pre tabindex="0"><code>$ regex-cli debug sparse dfa &#39;\w&#39; --start-kind unanchored -q
[.. snip ..]
          memory:  102257
[.. snip ..]
</code></pre><p>But we’re still at over 100KB. Unicode character classes and fully compiled
DFAs just don’t mix well. And in practice, it’s often the case that one doesn’t
need the full class compiled since it’s somewhat rare to search haystacks with
a lot of difference scripts. More to the point, most searches are probably fine
with just the ASCII definition of <code>\w</code>, which is much smaller:</p>
<pre tabindex="0"><code>$ regex-cli debug thompson &#39;(?-u)\w&#39; -q
[.. snip ..]
            memory:  732
[.. snip ..]

$ regex-cli debug dense dfa &#39;(?-u)\w&#39; --start-kind unanchored -q
[.. snip ..]
          memory:  384
[.. snip ..]
</code></pre><p>In this case, the dense DFA is actually smaller than the corresponding NFA.</p>
<p>So with all of that said, why does a general purpose regex engine like
the <code>regex</code> crate have a DFA engine with such huge downsides? Doesn’t the
exorbitant memory usage make it a non-starter? There are two angles to this.</p>
<p>First is that the DFA engine is actually disabled by default. One must opt
into it by enabling the <code>perf-dfa-full</code> feature. I did this because fully
compiled DFAs don’t carry a ton of weight in the <code>regex</code> crate, since the lazy
DFA (discussed in the next section) is a better choice in the vast majority of
cases. However, fully compiled DFAs do provide some optimization opportunities
that are difficult for a lazy DFA to take advantage of. For example, in
the regex <code>(?m)^.*$</code>, a fully compiled DFA will notice that <code>.</code> doesn’t
match a <code>\n</code>. It knows this by looking for states where most transitions are
self-transitions (transitions that loop back to the same state). It follows
that there are only a limited number of ways to leave that state. The DFA finds
these states and “accelerates” them by running <code>memchr</code> to find the bytes
in the haystack corresponding to non-self-transitions. You can see this in
practice with <code>regex-cli</code> with a little ad hoc benchmarking. First we’ll start
with DFA state acceleration enabled (it’s enabled by default):</p>
<pre tabindex="0"><code>$ regex-cli find match dense -bB -q --repeat 1000000 \
   -p &#39;(?m-u)^.*$&#39; \
   -y &#39;this is a long line about the quick brown fox that jumped over the lazy dog&#39;
[.. snip ..]
                 search time:  56.600473ms
[.. snip ..]
</code></pre><p>And now with DFA state acceleration disabled:</p>
<pre tabindex="0"><code>$ regex-cli find match dense -bB -q --repeat 1000000 --no-accelerate \
   -p &#39;(?m-u)^.*$&#39; \
   -y &#39;this is a long line about the quick brown fox that jumped over the lazy dog&#39;
[.. snip ..]
                 search time:  199.044059ms
[.. snip ..]
</code></pre><p>The search time with acceleration enabled is quite a bit faster. Notice
also that we’ve disabled Unicode. When Unicode is enabled, <code>.</code> matches the
UTF-8 encoding of any Unicode scalar value. This in turn makes the DFA more
complicated and inhibits the acceleration optimization in this case:</p>
<pre tabindex="0"><code>$ regex-cli find match dense -q --repeat 1000000 \
   -p &#39;(?m)^.*$&#39; \
   -y &#39;this is a long line about the quick brown fox that jumped over the lazy dog&#39;
[.. snip ..]
                 search time:  204.897593ms
[.. snip ..]
</code></pre><p>While this form of DFA state acceleration is quite useful, it is somewhat
limited in the regexes it can be applied to in part because of Unicode. It is
also limited because the meta regex engine only chooses to use the DFA engine
when the regex is very small. Otherwise we open ourselves up to exorbitant
memory usage and exponentials while building a regex. The <code>regex</code> crate isn’t
the fastest at compiling a regex, but taking exponential time is a big no-no.</p>
<p>Because of its somewhat limited utility and since the DFA engine adds a lot of
code that in turn increases compile times and binary size substantially, full
DFAs are disabled by default.</p>
<p>The second angle as to why full DFAs exist at all is because their search
runtime is extremely basic. They are the only regex engine in <code>regex-automata</code>
to not require any mutable <code>Cache</code> space while executing a search. Indeed,
let’s take a look at an example:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>regex_automata</span>::<span>{</span><span>
</span></span></span><span><span><span>    </span><span>dfa</span>::<span>{</span><span>dense</span><span>,</span><span> </span><span>regex</span>::<span>Regex</span><span>},</span><span>
</span></span></span><span><span><span>    </span><span>Match</span><span>,</span><span>
</span></span></span><span><span><span></span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>Regex</span>::<span>builder</span><span>()</span><span>
</span></span></span><span><span><span>        </span><span>// We need to enable heuristic Unicode word boundary support,
</span></span></span><span><span><span></span><span>        </span><span>// or else the regex below will fail to compile. Why? Because
</span></span></span><span><span><span></span><span>        </span><span>// \b is Unicode-aware by default, and the DFA engines don&#39;t
</span></span></span><span><span><span></span><span>        </span><span>// support it on haystacks with non-ASCII Unicode codepoints.
</span></span></span><span><span><span></span><span>        </span><span>// Enabling this comes with the downside of making it possible
</span></span></span><span><span><span></span><span>        </span><span>// for a search to return an error. Namely, when the DFA sees
</span></span></span><span><span><span></span><span>        </span><span>// a non-ASCII byte, it transitions to a special sentinel quit
</span></span></span><span><span><span></span><span>        </span><span>// state, which in turn causes the search to stop and return an
</span></span></span><span><span><span></span><span>        </span><span>// error.
</span></span></span><span><span><span></span><span>        </span><span>.</span><span>dense</span><span>(</span><span>dense</span>::<span>Config</span>::<span>new</span><span>().</span><span>unicode_word_boundary</span><span>(</span><span>true</span><span>))</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>build</span><span>(</span><span>r</span><span>&#34;\b\w+\b&#34;</span><span>)</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Note that `find_iter` will panic if the underyling search returns
</span></span></span><span><span><span></span><span>    </span><span>// an error! You can handle the error by using fallible APIs such as
</span></span></span><span><span><span></span><span>    </span><span>// Regex::try_search.
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>it</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>find_iter</span><span>(</span><span>&#34;Sherlock Holmes&#34;</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>Some</span><span>(</span><span>Match</span>::<span>must</span><span>(</span><span>0</span><span>,</span><span> </span><span>0</span><span>..</span><span>8</span><span>)),</span><span> </span><span>it</span><span>.</span><span>next</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>Some</span><span>(</span><span>Match</span>::<span>must</span><span>(</span><span>0</span><span>,</span><span> </span><span>9</span><span>..</span><span>15</span><span>)),</span><span> </span><span>it</span><span>.</span><span>next</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>None</span><span>,</span><span> </span><span>it</span><span>.</span><span>next</span><span>());</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>And the equivalent <code>regex-cli</code> command:</p>
<pre tabindex="0"><code>$ regex-cli find match dense --no-table --unicode-word-boundary \
   -p &#39;\b\w+\b&#39; \
   -y &#39;Sherlock Holmes&#39;
0:0:8:Sherlock
0:9:15:Holmes
</code></pre><p>Notice that no <code>Cache</code> is required. Indeed, because of how simple the search
runtime is for a DFA, and because the DFA internals were designed with this use
case in mind, a DFA can be <a href="https://github.com/rust-lang/regex/tree/ag/regex-automata/regex-cli#example-serialize-a-dfa">serialized to raw bytes</a>. That
same DFA can be deserialized and used to execute a search in a free-standing
environment. That is, you don’t need Rust’s <code>std</code> or <code>alloc</code> libraries. Only
<code>core</code> is needed.</p>
<p>(The DFA serialization use case was what motivated the initial <code>regex-automata 0.1</code> release. It’s currently used in the <a href="https://github.com/BurntSushi/bstr"><code>bstr</code></a> crate for implementing some
of the Unicode segmentation algorithms.)</p>
<p>Fully compiled DFAs are most useful when your regexes don’t make use of Unicode
features, or if you need access to lower level APIs. For example, this shows
how one can compute the transitions manually on a DFA:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>regex_automata</span>::<span>{</span><span>
</span></span></span><span><span><span>    </span><span>dfa</span>::<span>{</span><span>dense</span>::<span>DFA</span><span>,</span><span> </span><span>Automaton</span><span>},</span><span>
</span></span></span><span><span><span>    </span><span>Anchored</span><span>,</span><span>
</span></span></span><span><span><span></span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>DFA</span>::<span>new</span><span>(</span><span>r</span><span>&#34;\W&#34;</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// DFAs can have multiple start states, but only when there are look-around
</span></span></span><span><span><span></span><span>    </span><span>// assertions. When there aren&#39;t any look-around assertions, as in this
</span></span></span><span><span><span></span><span>    </span><span>// case, we can ask for a start state without providing any of the
</span></span></span><span><span><span></span><span>    </span><span>// haystack.
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>sid</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>universal_start_state</span><span>(</span><span>Anchored</span>::<span>No</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>// The UTF-8 encoding of 💩 is \xF0\x9F\x92\xA9.
</span></span></span><span><span><span></span><span>    </span><span>sid</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>next_state</span><span>(</span><span>sid</span><span>,</span><span> </span><span>0xF0</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>sid</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>next_state</span><span>(</span><span>sid</span><span>,</span><span> </span><span>0x9F</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>sid</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>next_state</span><span>(</span><span>sid</span><span>,</span><span> </span><span>0x92</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>sid</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>next_state</span><span>(</span><span>sid</span><span>,</span><span> </span><span>0xA9</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>sid</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>next_eoi_state</span><span>(</span><span>sid</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>assert!</span><span>(</span><span>re</span><span>.</span><span>is_match_state</span><span>(</span><span>sid</span><span>));</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>In this example, we walked the DFA manually and fed the DFA one byte at a time.
This example is a little contrived, but it demonstrates some of the APIs that
provide low level control. There are many more examples documented on the
<a href="https://docs.rs/regex-automata/0.3.*/regex_automata/dfa/trait.Automaton.html"><code>Automaton</code></a> trait, which defines all of the lower level DFA routines that
dense and sparse DFAs implement.</p>
<h3 id="engine-hybrid-nfadfa">Engine: hybrid NFA/DFA</h3>
<p>The hybrid NFA/DFA or <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/hybrid/regex/struct.Regex.html">“lazy DFA” regex engine</a> is
exactly like the DFA engine, except its transition table is built at search
time. In other words, while a full DFA is “ahead-of-time compiled,” the lazy
DFA is “just-in-time compiled.”</p>
<p>(Calling it a JIT would be somewhat misleading. In this domain, a JIT usually
refers to compiling a regex into machine code at runtime, such as the JIT in
PCRE2. That is not what’s happening here.)</p>
<p>The lazy DFA generally has the same API as the fully compiled DFA, except that,
like the other regex engines, you need to pass a mutable <code>Cache</code> argument. The
<code>Cache</code> is where the transition table (among other things) is stored:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>regex_automata</span>::<span>{</span><span>
</span></span></span><span><span><span>    </span><span>hybrid</span>::<span>{</span><span>dfa</span><span>,</span><span> </span><span>regex</span>::<span>Regex</span><span>},</span><span>
</span></span></span><span><span><span>    </span><span>Match</span><span>,</span><span>
</span></span></span><span><span><span></span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>Regex</span>::<span>builder</span><span>()</span><span>
</span></span></span><span><span><span>        </span><span>// As with the fully compiled DFA, we need to enable heuristic
</span></span></span><span><span><span></span><span>        </span><span>// Unicode word boundary support for the lazy DFA as well. It
</span></span></span><span><span><span></span><span>        </span><span>// will return an error if a non-ASCII codepoint is seen when
</span></span></span><span><span><span></span><span>        </span><span>// the regex contains a Unicode word boundary, just like the
</span></span></span><span><span><span></span><span>        </span><span>// full DFA.
</span></span></span><span><span><span></span><span>        </span><span>.</span><span>dfa</span><span>(</span><span>dfa</span>::<span>Config</span>::<span>new</span><span>().</span><span>unicode_word_boundary</span><span>(</span><span>true</span><span>))</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>build</span><span>(</span><span>r</span><span>&#34;\b\w+\b&#34;</span><span>)</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>cache</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>create_cache</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Note that find_iter will panic if the underyling search returns
</span></span></span><span><span><span></span><span>    </span><span>// an error! You can handle the error by using fallible APIs such
</span></span></span><span><span><span></span><span>    </span><span>// as Regex::try_search.
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>it</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>find_iter</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>cache</span><span>,</span><span> </span><span>&#34;Sherlock Holmes&#34;</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>Some</span><span>(</span><span>Match</span>::<span>must</span><span>(</span><span>0</span><span>,</span><span> </span><span>0</span><span>..</span><span>8</span><span>)),</span><span> </span><span>it</span><span>.</span><span>next</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>Some</span><span>(</span><span>Match</span>::<span>must</span><span>(</span><span>0</span><span>,</span><span> </span><span>9</span><span>..</span><span>15</span><span>)),</span><span> </span><span>it</span><span>.</span><span>next</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>None</span><span>,</span><span> </span><span>it</span><span>.</span><span>next</span><span>());</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>And the equivalent <code>regex-cli</code> command:</p>
<pre tabindex="0"><code>$ regex-cli find match hybrid --no-table --unicode-word-boundary \
   -p &#39;\b\w+\b&#39; \
   -y &#39;Sherlock Holmes&#39;
0:0:8:Sherlock
0:9:15:Holmes
</code></pre><p>This example is nearly identical to the full DFA, but with a <code>Cache</code> parameter.
The similarities extend to lower level APIs as well:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>regex_automata</span>::<span>{</span><span>hybrid</span>::<span>dfa</span>::<span>DFA</span><span>,</span><span> </span><span>Input</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>re</span><span> </span><span>=</span><span> </span><span>DFA</span>::<span>new</span><span>(</span><span>r</span><span>&#34;\W&#34;</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>cache</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>create_cache</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// DFAs can have multiple start states, but only when there are
</span></span></span><span><span><span></span><span>    </span><span>// look-around assertions. When there aren&#39;t any look-around
</span></span></span><span><span><span></span><span>    </span><span>// assertions, as in this case, we can ask for a start state
</span></span></span><span><span><span></span><span>    </span><span>// without providing any of the haystack. Full DFAs have a
</span></span></span><span><span><span></span><span>    </span><span>// dedicated routine for this because the universality can be
</span></span></span><span><span><span></span><span>    </span><span>// checked for us. But lazy DFAs don&#39;t compute all of their start
</span></span></span><span><span><span></span><span>    </span><span>// states up front. So we just kind of fake it and ask for a start
</span></span></span><span><span><span></span><span>    </span><span>// state given some dummy haystack.
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>sid</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>start_state_forward</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>cache</span><span>,</span><span> </span><span>&amp;</span><span>Input</span>::<span>new</span><span>(</span><span>&#34;&#34;</span><span>)).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>// The UTF-8 encoding of 💩 is \xF0\x9F\x92\xA9.
</span></span></span><span><span><span></span><span>    </span><span>sid</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>next_state</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>cache</span><span>,</span><span> </span><span>sid</span><span>,</span><span> </span><span>0xF0</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>sid</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>next_state</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>cache</span><span>,</span><span> </span><span>sid</span><span>,</span><span> </span><span>0x9F</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>sid</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>next_state</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>cache</span><span>,</span><span> </span><span>sid</span><span>,</span><span> </span><span>0x92</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>sid</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>next_state</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>cache</span><span>,</span><span> </span><span>sid</span><span>,</span><span> </span><span>0xA9</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>sid</span><span> </span><span>=</span><span> </span><span>re</span><span>.</span><span>next_eoi_state</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>cache</span><span>,</span><span> </span><span>sid</span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>assert!</span><span>(</span><span>sid</span><span>.</span><span>is_match</span><span>());</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Other than passing a <code>Cache</code> explicitly, these APIs are almost the same. The
main difference is that each of the operations might fail. Namely, depending on
the method, they can return either a <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/struct.MatchError.html"><code>MatchError</code></a> or a <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/hybrid/struct.CacheError.html"><code>CacheError</code></a>. A
<code>MatchError</code> occurs when the start state can’t be computed because it enters
a quit state. (Which means the search must terminate with an error. This, for
example, occurs when heuristic Unicode word boundary support is enabled and a
non-ASCII byte is seen when computing the start state.) A <code>CacheError</code> occurs
when the <code>Cache</code> provided exhausts its capacity.</p>
<p>At this point, it’s worth talking a little more about the <code>Cache</code> because it is
both the lazy DFA’s greatest strength and its greatest weakness. The lazy DFA,
as mentioned, works by building its transition table during a search. More
specifically, the following happens:</p>
<ol>
<li>A maximum cache capacity is configured at construction time. The capacity is
not fully allocated up front. It’s just a number establishing an upper bound on
how much heap memory can be used.</li>
<li>When the caller asks to compute the transition for the current state and
character from the haystack, the lazy DFA consults its <code>Cache</code>. If the transition
has already been computed and stored in the <code>Cache</code>, then it is returned as-is
immediately. Otherwise, the transition—and only that transition—is computed
by doing NFA powerset construction. This process takes worst case <code>O(m)</code> time.</li>
<li>If the cache fills up, it is cleared and thus transitions previously computed
will need to be-recomputed.</li>
<li>Optional configuration can be set to cause the lazy DFA to return an error
if the <code>Cache</code> is being used inefficiently. Efficiency is measured in terms
of how many bytes are searched per each DFA state computed. If few bytes are
searched compared to the number of DFA states in the <code>Cache</code>, then it’s likely
that even the <code>PikeVM</code> would execute the search more quickly. (Other heuristics
are used here as well, such as the total number of times the <code>Cache</code> has been
cleared.)</li>
</ol>
<p>In this way, at most one DFA state and transition is created for each byte of
haystack searched. Thus, the worst case search time for the lazy DFA is
<code>O(m * n)</code> and its worst case space usage is the fixed capacity set at
construction time. Since building a lazy DFA itself does not require the
construction of any DFA states (except for a few basic sentinel states), it
follows that the lazy DFA mitigates the theoretical worst case time and space
complexities for full DFAs. That is, we avoid the exponential construction
time. In the common case, most states/transitions are cached, and so the lazy
DFA runs in average case <code>O(n)</code> time. In practice, for most regexes, the lazy
DFA and the fully compiled DFA have the same search performance.</p>
<p>The lazy DFA also mitigates the exorbitant space usage for large Unicode
character classes. Since a lazy DFA only computes what it needs based on the
actual bytes searched, searching for a Unicode-aware <code>\w</code> in an ASCII-only
haystack only requires building the ASCII portion of <code>\w</code> into a DFA. This ends
up working amazingly well in practice.</p>
<p>The lazy DFA tends to do poorly for regexes that fill up its cache and cause
it to be cleared repeatedly. This might just be a result of the regex being
large or even a result of the haystack forcing a large portion of the DFA to
be constructed. (A regex can easily become large through counted repetitions
or even by adding a lot of patterns. A single lazy DFA gets built for a
multi-pattern regex.) In these cases, heuristics usually detect it and force
the lazy DFA to return an error. At this point, in the context of the meta
regex engine, the search will be retried with a different engine (usually the
<code>PikeVM</code>).</p>
<h3 id="the-meta-regex-engine">The meta regex engine</h3>
<p>The <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/meta/struct.Regex.html">meta regex engine</a> brings all of the aforementioned regex engines together
and exposes one single infallible API that tries to do the best possible thing
in any given situation. The API it exposes also absolves the caller of needing
to explicitly create and pass <code>Cache</code> values to each search call. Instead, the
meta regex engine handles this for you by keeping an internal thread safe pool
of <code>Cache</code> values. (The meta regex engine does expose lower level APIs that
permit passing a <code>Cache</code> explicitly. These are useful if one wants to avoid
the synchronization costs of the thread safe pool used internally.)</p>
<p>The end result here is that the meta regex engine very closely corresponds
to the top-level API in the <code>regex</code> crate. Indeed, <code>regex::Regex</code>,
<code>regex::RegexSet</code>, <code>regex::bytes::Regex</code> and <code>regex::bytes::RegexSet</code> are all
very thin wrappers around the meta regex engine. This is by design, because it
makes it easier to drop down from the high level convenience API that serves
99% of use cases to the lower level API that exposes a lot more knobs.</p>
<p>Internally, the meta regex engine implements roughly the following logic:</p>
<ul>
<li>If a regex engine isn’t needed at all and the search can be performed using
single or multi-substring search algorithms directly, then the construction of
a regex (including an <code>NFA</code>) is avoided entirely.</li>
<li>If possible, extract a small literal sequence from the prefix of the regex
that can be used as a <a href="https://docs.rs/regex-automata/0.3.*/regex_automata/util/prefilter/struct.Prefilter.html"><code>Prefilter</code></a>.</li>
<li>If possible, choose a “reverse” optimization:
<ul>
<li>If a regex is anchored at the end via <code>$</code>, then a search can proceed by
doing a reverse scan from the end of the haystack. This is called the
“reverse anchored” optimization.</li>
<li>If no suitable <code>Prefilter</code> has been found and a literal sequence can be
extracted from the suffix of the regex, then we can scan for occurrences of
that literal sequence and match the regex in reverse from each candidate
position. This is called the “reverse suffix” optimization.</li>
<li>If no suitable prefix or suffix literal sequence could be found but a
literal sequence could be extracted from an inner part of the regex that
cleanly partitions the regex, then we can scan for occurrences of that
inner literal sequence. We split the regex in half at the point where the
inner literal sequence was extracted. The first half gets compiled into a
reverse regex and the second half gets compiled into a forward regex. When
a candidate is found, we can look for the start of the match by scanning
backwards with the first half, and then look for the end of the match by
scanning forwards with the second half.</li>
</ul>
</li>
<li>Otherwise, fall back to the “core” search strategy. The core strategy makes
use of all available regex engines: the <code>PikeVM</code>, the bounded backtracker, the
one-pass DFA, the lazy DFA and the full DFA. Only the <code>PikeVM</code> is required. The
way these engines compose together is roughly as follows:
<ul>
<li>Whenever possible, use the lazy DFA (or full DFA if available) to find
the overall bounds of the match. If the DFA fails, then we fall back to
either the <code>PikeVM</code>, the bounded backtracker or the one-pass DFA. The DFA
can fail either because the regex contained a Unicode word boundary and the
haystack contained a non-ASCII codepoint, or because the the lazy DFA was
used and its <code>Cache</code> usage was inefficient according to some heuristic.</li>
<li>When capture groups are requested, then after the full match is found,
either the <code>PikeVM</code>, bounded backtracker or one-pass DFA is used to report
the offsets of each matching capture group. The order of preference is:
one-pass DFA, bounded backtracker and then the <code>PikeVM</code>.</li>
</ul>
</li>
</ul>
<p>If one were to summarize the overall strategy, it can probably be distilled
down to these two points:</p>
<ul>
<li>Search for literals whenever possible.</li>
<li>Avoid the <code>PikeVM</code> as much as possible.</li>
</ul>
<p>That’s pretty much it. In general, the more time we can spend in substring
search algorithms, the better. And the less time we can spend in specifically
the <code>PikeVM</code>, the better.</p>
<p>Many regex engines do some kind of literal optimization, and indeed, most
popular production grade regex engines spend a fair bit of effort in doing
so. <a href="https://github.com/intel/hyperscan">Hyperscan</a> is the gold standard here, but as far as I’m aware, most
other general purpose regex engines don’t go to the lengths described above.
(One could argue about whether Hyperscan is a “general purpose” regex engine
or not. One of my own personal arguments against considering it one is its
match semantics. For example, <code>\w+</code> matches <code>abc</code> 3 times because Hyperscan
reports matches as they’re seen. An undoubtedly correct choice given its
target domain.) The reverse suffix and reverse inner optimizations are
particularly tricky. They look easy, but there’s a subtle performance problem
with them: they open you up to worst case quadratic behavior (in the size of
the haystack).</p>
<p>Consider the regex <code>[A-Z].*bcdefghijklmnopq</code> on a haystack of
<code>bcdefghijklmnopq</code> repeated over and over. There is no “good” prefix literal
sequence that can be extracted from this, so according to the logic above,
the meta regex engine will try the “reverse suffix” optimization by using
<code>bcdefghijklmnopq</code> as the suffix. This particular benchmark was devised to have
a worst case false positive rate: candidates are reported frequently and none
of them lead to a match. But that’s just a bad heuristic. It doesn’t in and of
itself lead to violating our time complexitiy guarantee (which is <code>O(m * n)</code>).
The problem here is that each time the suffix matches, a reverse scan includes
the <code>.*</code>, and that in turn scans all the way back to the beginning of the
haystack. So each candidate reported by the suffix match results in a complete
re-scan of the haystack back to the beginning. This changes our search routine
to have worst case <code>O(m * n^2)</code> time complexity. That’s bad.</p>
<p>While it is possible to do syntactic analysis on a regex to determine whether
this quadratic behavior is possible, it doesn’t predict it perfectly. For
example, one can clearly see that the suffix <code>bcdefghijklmnopq</code> overlaps with
the expression immediately before it, <code>.*</code>. That in turn means some kind of
quadratic behavior might be possible. But that doesn’t mean it is inevitable.</p>
<p>Instead, the meta regex engine mitigates this by defining its own bespoke regex
search routines based on the DFA engines. Namely, it defines its own search
routine that will stop its reverse scan if it gets to a certain offset in the
haystack. That offset corresponds to the end of the last suffix match. So if
the search would otherwise exceed that offset, then we’re exposed to quadratic
behavior. The meta regex engine detects this error case and falls back to the
“core” strategy described above, thus abandoning the optimization when it would
otherwise sacrifice our time complexity guarantees.</p>
<p>Roughly the same logic applies to the “reverse inner” optimization as well.</p>
<p>In summary, if you don’t need low level access to individual regex engines but
you do want control over the many knobs exposed by the regex engine or want
to do multi-pattern matching, then the meta regex engine is a good choice.
Namely, all of the regex engines described before this each have their own
little caveats that make them less than ideal for general use in every case.</p>
<h2 id="differences-with-re2">Differences with RE2</h2>
<p>If you’ve read <a href="https://swtch.com/~rsc/regexp/">Russ Cox’s article series on regular expressions</a>,
then some portion of the previous section is likely to sound familiar.
Namely, RE2 has a <a href="https://github.com/google/re2/blob/2d39b703d02645076fead8fa409a1711f0e84381/re2/nfa.cc">PikeVM</a> (called just an “NFA”), a <a href="https://github.com/google/re2/blob/2d39b703d02645076fead8fa409a1711f0e84381/re2/bitstate.cc">bounded
backtracker</a> (called a “bitstate backtracker” in RE2), a
<a href="https://github.com/google/re2/blob/2d39b703d02645076fead8fa409a1711f0e84381/re2/onepass.cc">one-pass DFA</a> (called a “one-pass NFA” in RE2) and a <a href="https://github.com/google/re2/blob/2d39b703d02645076fead8fa409a1711f0e84381/re2/dfa.cc">lazy
DFA</a>. It also has a <a href="https://github.com/google/re2/blob/2d39b703d02645076fead8fa409a1711f0e84381/re2/re2.cc#L648-L906">meta regex engine</a> (although that term
isn’t used) that composes its internal regex engines in a similar fashion as
described above. The only engine described above that RE2 doesn’t have is a
fully compiled DFA.</p>
<p>So what, if any, are the differences between RE2 and the <code>regex</code> crate?</p>
<p>The similarities between them are much greater than the differences, but here’s
a high level list of differences:</p>
<ul>
<li>RE2 supports leftmost-longest semantics as an option in addition to
leftmost-first. Leftmost-longest semantics are what POSIX regex engines use.</li>
<li>RE2 has less support for Unicode. A full accounting of this is tricky
because RE2 does permit linking with <a href="https://icu.unicode.org/">ICU</a> to add support for more Unicode
properties. However, RE2 does not have an option to make <code>\w</code>, <code>\s</code>, <code>\d</code> and
<code>\b</code> use Unicode definitions. RE2 also does not support character class set
operations beyond union. For example, it’s harder to write something like
<code>[\pL&amp;&amp;\p{Greek}]</code> in RE2, which corresponds to the subset of codepoints
considered letters that are also in the Greek script. (Character class set
operations other than union aren’t strictly Unicode specific features, but they
are most useful in the context of large Unicode character classes.)</li>
<li>RE2 has a likely more memory efficient version of the PikeVM.</li>
<li>RE2 has some limited support for literal optimizations, but overall does
a lot less here than what the <code>regex</code> crate does. RE2 does have a <a href="https://github.com/google/re2/blob/2d39b703d02645076fead8fa409a1711f0e84381/re2/filtered_re2.h">Filtered
RE2</a> which permits the caller to do a limited form of their own literal
optimizations.</li>
<li>RE2 uses the same transition cache across multiple threads for the lazy DFA
engine, which requires synchronization. Conversely, the <code>regex</code> crate requires
a distinct cache for each thread, which requires more memory.</li>
<li>The <code>regex</code> crate now exposes both <code>regex-syntax</code> and <code>regex-automata</code> as
separately versioned libraries that provide access to its internals. RE2 does
not support this.</li>
<li>The <code>regex-automata</code> library has first class support for multi-pattern
regexes in all engines. RE2 does have a “regex set,” but it only reports which
patterns match in a haystack. <code>regex-automata</code>, on the other hand, can also
report match and capture group offsets for each matching pattern.</li>
</ul>
<p>In the future, I hope to add more engines to <code>regex-automata</code>. Specifically,
I’d like to explore <a href="https://en.wikipedia.org/wiki/Glushkov%27s_construction_algorithm">Glushkov NFAs</a> and a bit parallel regex
engine. I’d also like to explore <a href="https://gist.github.com/pervognsen/218ea17743e1442e59bb60d29b1aa725">shift DFAs</a>.</p>
<h2 id="testing-strategy">Testing strategy</h2>
<p>As described near the opening of this blog, testing had become a problem for
the <code>regex</code> crate. The macro hacks used to test each internal engine were
growing quite strained and they were generally difficult to work with and, more
importantly, understand.</p>
<p>My idea for revamping how the regex crate was tested was tied with the idea
that each internal engine would have its own first class API that could be
tested independently from the “main” regex engine. I also wanted to make the
tests consumable from any context instead of burying them in macros or Rust
source code. To that end, this is the strategy I settled upon:</p>
<ul>
<li>All regex tests are specified in TOML files.</li>
<li>I published a crate, <a href="https://docs.rs/regex-test/0.1.*/regex_test/"><code>regex-test</code></a>, that knows how to read these TOML files
into a structured representation.</li>
<li>I defined a single Rust unit test for each configuration of each regex engine
that I wanted to test. Inside this single unit test, all of the tests from
the TOML files that are applicable to the engine being tested are executed.</li>
</ul>
<p>A little extra infrastructure was required in order to make this nice to use
because Rust’s unit testing framework is not currently extensible. That means
I had to define my own environment variables for filtering on which tests to
run. (For example, if you’re working on a single bug that causes many tests to
fail, it’s often useful to just have one of those tests run.)</p>
<p>There are also oodles of other kinds of tests as well. For example, there are
over 450 documentation tests in <code>regex-automata</code> alone.</p>
<p>Finally, in the run up to the <code>regex 1.9</code>, I added a lot of additional fuzz
testing targets. I had a <strong>ton</strong> of help from <a href="https://github.com/addisoncrump">Addison Crump</a> and there were
at least a few bugs I wouldn’t have found if it weren’t for him.</p>
<h2 id="benchmarking">Benchmarking</h2>
<p>At this point, this blog is already my longest one ever, and I haven’t even
begun to discuss benchmarking. While I originally wanted to spend more time
on this topic in this blog—particularly given all of the talk about
optimizations—it just wasn’t practical to do so.</p>
<p>Instead, I’ve published a regex barometer called <a href="https://github.com/BurntSushi/rebar">rebar</a>. It isn’t just limited
to benchmarking the <code>regex</code> crate. It also benchmarks many other regex engines
as well. I believe it is the most comprehensive regex benchmark published to
date.</p>
<p>Across 242 benchmarks, <code>regex 1.9</code> is on average 1.5 times faster than <code>regex 1.7.3</code> for search times. (I compared with <code>1.7</code> instead of <code>1.8</code> because <code>1.8</code>
reflects a transition release that has some of the work described in this blog
post included. The <code>1.9</code> release just completes the transition.)</p>
<pre tabindex="0"><code>$ rebar rank record/all/2023-07-02/*.csv \
   --intersection \
   -M compile \
   -e &#39;^(rust/regex|rust/regexold)$&#39;
Engine         Version  Geometric mean of speed ratios  Benchmark count
------         -------  ------------------------------  ---------------
rust/regex     1.8.4    1.08                            242
rust/regexold  1.7.3    2.61                            242
</code></pre><p>But the time it takes to build a regex has regressed somewhat:</p>
<pre tabindex="0"><code>$ rebar rank record/all/2023-07-02/*.csv \
   --intersection \
   -m compile \
   -e &#39;^(rust/regex|rust/regexold)$&#39;
Engine         Version  Geometric mean of speed ratios  Benchmark count
------         -------  ------------------------------  ---------------
rust/regexold  1.7.3    1.07                            28
rust/regex     1.8.4    1.46                            28
</code></pre><p>The geometric mean reported above is a very crude aggregate statistic. I’m not
sure it really captures the extent of the improvements here. If you want to look
at individual benchmark differences, one can replace <code>rebar rank</code> with <code>rebar cmp</code>
in the above command. (And run it from the root of a checkout of the <a href="https://github.com/BurntSushi/rebar">rebar</a>
repository.)</p>
<pre tabindex="0"><code>$ rebar cmp record/all/2023-07-02/*.csv \
   --threshold-min 2 \
   --intersection \
   -M compile \
   -e &#39;^(rust/regex|rust/regexold)$&#39;
</code></pre><p>I’ve added <code>--threshold-min 2</code> to the above command to limit the comparisons
to ones where there is at least a 2x difference.</p>
<h2 id="costs">Costs</h2>
<p>No good deed goes unpunished. What has this rewrite cost me?</p>
<p>First and foremost, it has used up the vast majority of my free time for the
past several years. Compounding the problem, I have <a href="https://github.com/BurntSushi/blog/commit/8ea55788f2eb8226343fdbefaaee189412bd3c1c">a lot less of that free
time than I used to</a>. So projects like ripgrep haven’t seen a release
for quite some time.</p>
<p>Secondly, this has introduced a fair bit more code. Building reusable abstractions
for others to use is a different beast than internal abstractions that only
<code>regex</code> crate hackers need to worry about. It usually results in more code,
which means bigger binary sizes and higher compile times.</p>
<p>Thirdly, those abstractions are now published and separately versioned. That
means I can’t just break the APIs of those internal engines without publishing
an appropriate breaking change release of <code>regex-automata</code>. I won’t be nearly
as conservative as doing so as I am with the <code>regex</code> crate, but it isn’t free
to do. This will also impact contributors. Instead of just being able to
refactor code as necessary, one must now contend with the pressures of public
API design.</p>
<p>Because the <code>regex</code> crate already had a reputation for less-than-ideal binary
sizes and compile times, and since these changes were going to make that
<em>worse</em>, I decided on two different mitigations:</p>
<ol>
<li>As discussed above, I made the fully compiled DFA regex engine opt-in. This
engine brings in quite a bit of code, but its impact on search performance is
modest.</li>
<li>I published a new crate, <a href="https://docs.rs/regex-lite"><code>regex-lite</code></a>, that acts <em>nearly</em> as a drop-in
replacement for the <code>regex</code> crate. Its design is based on optimizing almost
exclusively for binary size and compile time, at the expense of functionality
(namely, Unicode) and performance. You still get the <code>O(m * n)</code> time complexity
guarantee, but you don’t get any of the fancy Unicode support and you don’t get
fast search times. But the binary size and compile times are a lot better.
<code>regex-lite</code> has zero dependencies. It shares zero code—including rolling its
own regex parser—with the <code>regex</code> crate.</li>
</ol>
<p>The <code>regex-lite</code> mitigation is still somewhat of an experiment, but it just
goes to show that making code artbitrarily reducible is difficult. Even though
the <code>regex</code> crate has a bunch of features for disabling both optimizations and
Unicode functionality, it still can’t get anywhere close to the binary size
and compile times of <code>regex-lite</code>.</p>
<h2 id="wrap-up">Wrap up</h2>
<p>In this blog, I tried to focus on telling a story about the biggest components
of the <code>regex</code> crate internals. This higher level description can be difficult
to get from just reading the API documentation. With that said, this blog is
still just scratch the surface. I encourage you to peruse the <a href="https://docs.rs/regex-automata/0.3.*/"><code>regex-automata</code>
API documentation</a> for a lot more details and tons of code examples.</p>
<p>I encourage any and all questions on <a href="https://github.com/rust-lang/regex/discussions">GitHub Discussions</a>.</p>
      </article>

      

    </div>
  </div>
</div></div>
  </body>
</html>
