<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ubicloud.com/blog/improving-network-performance-with-linux-flowtables">Original</a>
    <h1>Improving Network Performance with Linux Flowtables</h1>
    
    <div id="readability-page-1" class="page"><div data-animation="default" data-collapse="medium" data-duration="400" data-easing="ease" data-easing2="ease" data-doc-height="1" role="banner"><div><div><p><a href="https://ntietz.com/"><img src="https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/64fe48116c52fe1a51e17279_ubicolud%20logo.png" loading="lazy" alt=""/></a></p></div></div></div><section><div><div><div id="w-node-decdb48f-56e8-4c35-c577-932285e9b439-32a26126"><h2>Improving Network Performance with Linux Flowtables</h2><p>March 4, 2024 · 5 min read</p><div><p><img src="https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e39641837eb115bbff4328_Furkan%20Sahin%20Picture.jpeg" loading="lazy" sizes="40px" srcset="https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e39641837eb115bbff4328_Furkan%20Sahin%20Picture-p-500.jpeg 500w, https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e39641837eb115bbff4328_Furkan%20Sahin%20Picture.jpeg 792w" alt=""/></p><div><p>Furkan Sahin</p><p>Senior Software Engineer</p></div></div><p>We’re building an opensource alternative to AWS. Among other things, that means running a ton of VMs,which we do on Linux. We rely on Linux KVM for virtualization, and keep each VM in a separate namespace for isolation.</p><div id="sign-up-and-sign-in"><h3>Background</h3><p>Ubicloud uses an established pattern in building public cloud services. A control plane manages a data plane, where the data plane usually uses open source software. The control plane holds the data model, responds to web requests, and coordinates changes to the data plane (nodes).</p><p><img src="https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/6508570535d13621d3449e84_architecture%20design.jpg" loading="lazy" sizes="(max-width: 479px) 65vw, (max-width: 767px) 64vw, (max-width: 991px) 65vw, (max-width: 1439px) 50vw, 604.796875px" srcset="https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/6508570535d13621d3449e84_architecture%20design-p-500.jpg 500w, https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/6508570535d13621d3449e84_architecture%20design-p-800.jpg 800w, https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/6508570535d13621d3449e84_architecture%20design-p-1080.jpg 1080w, https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/6508570535d13621d3449e84_architecture%20design-p-1600.jpg 1600w, https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/6508570535d13621d3449e84_architecture%20design.jpg 2286w" alt=""/></p><p>To reprogram the host OS, Ubicloud uses the Netfilter project. Netfilter is a framework inside the Linux kernel that provides hooks for features like packet filtering, connection tracking, and network address translation (NAT). For firewall rules, we use Netfilter’s packet filtering feature. (For assigning IPv4 addresses to VMs, we use the NAT feature.) Let’s look at how firewall rules work in a bit more detail.<br/></p></div><div id="sign-up-and-sign-in"><h3>An Example: Implementing Firewall Rules</h3><p><img src="https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e384bbde896d9f2c34c235_Linux%20kernel%20packet%20forwarding%20path.png" loading="lazy" sizes="(max-width: 479px) 93vw, (max-width: 767px) 92vw, (max-width: 991px) 94vw, (max-width: 1439px) 72vw, 864px" srcset="https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e384bbde896d9f2c34c235_Linux%20kernel%20packet%20forwarding%20path-p-500.png 500w, https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e384bbde896d9f2c34c235_Linux%20kernel%20packet%20forwarding%20path-p-800.png 800w, https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e384bbde896d9f2c34c235_Linux%20kernel%20packet%20forwarding%20path.png 964w" alt=""/></p><p>Classic forwarding path for a packet. Please see Acknowledgements, CC BY-SA 4.0 license</p><p>The above diagram displays the classic packet forwarding path within the Linux kernel, also identifying the Netfilter hooks. To make things more concrete, let’s consider an example where we implement firewall rules in Ubicloud. In this example, on a VM, we want to allow incoming TCP connections on port 5432 for all IP addresses, and reject other traffic.</p><ol role="list"><li>Source address: 11.11.11.11</li><li>Destination address: 12.12.12.12</li><li>Destination port: 5432</li><li>Protocol: TCP</li></ol></div><p>The routing lookup on the host detects  that the packet isn’t for itself and needs to be forwarded to the VM. As a result, the packet traverses the Netfilter forward hook. The forward stage then has the following filter (which we configured) that needs to be applied:</p><div><pre><code>
  ip saddr 0.0.0.0/0 tcp dport 5432 ip daddr 12.12.12.12 accept
</code>
</pre></div><p>This rule says if the packet is coming from any address, using the TCP protocol, with destination port 5432 and destination IPv4 address 12.12.12.12, accept it. So, the forward hook simply passes the packet to the post-routing hook to be sent to the destination address. If the destination port or any of these fields doesn’t match this rule, Nftables checks for any other rules in the chain. If no other rules exist, Nftables follows the table policy to take the appropriate action.</p><div id="enter-billing"><h3><strong>Flowtables: Optimizing Network Traffic Handling</strong></h3><p>Flowtables is an optimization to improve network packet throughput. By remembering and reusing the connection based packet processing decisions, flowtables reduces the number of repetitive processing steps for each packet. This further reduces CPU utilization and improves network latency and throughput.</p><p><img src="https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e38bc2b0108aa9f3d8ea2c_Linux%20kernel%20forwarding%20with%20flowtables.png" loading="lazy" sizes="(max-width: 479px) 93vw, (max-width: 767px) 92vw, (max-width: 991px) 94vw, (max-width: 1439px) 72vw, 864px" srcset="https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e38bc2b0108aa9f3d8ea2c_Linux%20kernel%20forwarding%20with%20flowtables-p-500.png 500w, https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e38bc2b0108aa9f3d8ea2c_Linux%20kernel%20forwarding%20with%20flowtables-p-800.png 800w, https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e38bc2b0108aa9f3d8ea2c_Linux%20kernel%20forwarding%20with%20flowtables.png 964w" alt=""/></p><p>Adding flowtables into a packet&#39;s forwarding path. Please see Acknowledgements, CC BY-SA 4.0 license</p></div><p>The previous diagram shows how Netfilter / Nftables work when flowtables are applied. Further, since flowtables integrate nicely with Netfilter, enabling them is straightforward. In Ubicloud’s case, enabling flowtables just took <a href="https://github.com/ubicloud/ubicloud/pull/1009">seven lines of code!</a></p><p><img src="https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e38cc8b0108aa9f3d96722_Ubicloud%20networking%20flowtables%20code.png" loading="lazy" sizes="(max-width: 479px) 93vw, (max-width: 767px) 92vw, (max-width: 991px) 94vw, (max-width: 1439px) 72vw, 864px" srcset="https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e38cc8b0108aa9f3d96722_Ubicloud%20networking%20flowtables%20code-p-500.png 500w, https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e38cc8b0108aa9f3d96722_Ubicloud%20networking%20flowtables%20code-p-800.png 800w, https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e38cc8b0108aa9f3d96722_Ubicloud%20networking%20flowtables%20code-p-1080.png 1080w, https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e38cc8b0108aa9f3d96722_Ubicloud%20networking%20flowtables%20code-p-1600.png 1600w, https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e38cc8b0108aa9f3d96722_Ubicloud%20networking%20flowtables%20code-p-2000.png 2000w, https://assets-global.website-files.com/64f9d9b4e737e7b37d4e39a4/65e38cc8b0108aa9f3d96722_Ubicloud%20networking%20flowtables%20code.png 2200w" alt=""/></p><div id="enter-billing"><h3><strong>Simple Latency Benchmarks with PostgreSQL</strong></h3><p>We designed a simple benchmark to measure our networking stack’s latency at the host level. For this, we created a <a href="https://www.ubicloud.com/docs/managed-postgresql/quickstart">Ubicloud PostgreSQL</a> instance and installed pgbench on the host machine. pgbench is a simple benchmarking tool provided by PostgreSQL; it’s a nice fit for simple benchmarking because we can tweak pgbench’s parameters to focus on the networking overhead.</p><div><pre><code>
  pgbench -i -s 100 demo-pg.postgresql.ubicloud.com

  pgbench -c 1 -j 1 -T 60 -P 1 -S demo-pg.postgresql.ubicloud.com
</code>
</pre></div><p>By keeping the client and thread counts at one, we could better isolate flowtable optimization’s impact. Additionally, we ran pgbench directly from the host against Ubicloud’s managed PostgreSQL. This way, we could remove any variance associated with taking an actual network hope; and only measure the end-to-end latency for one pgbench SELECT query.</p><ul role="list"><li>Without flowtables (our original Netfilter / Nftables implementation), the average latency was 0.127ms.<br/></li><li>With flowtables, the average latency decreased to 0.118ms. This showed a latency improvement of 7.5%.</li><li>There are two ways to think about these improvements. First, we didn’t take network latency into account in this benchmark. So, we’d expect real life latency benefits to be lower.</li><li>Second, and on the flip side, most of the end-to-end latency was associated with the pgbench client sending a query to PostgreSQL and receiving the reply. We didn’t work to measure this latency. Intuitively, we’d expect flowtable’s throughput benefits (shaved off CPU cycles) to be more important than its latency benefits.</li></ul></div><div id="create-vm"><h3>Conclusion</h3><p>We use Netfilter / Nftables on our data plane bare metal instances to provide cloud networking services. These Linux kernel features are reliable and portable. Recently, we introduced flowtables into our networking setup at Ubicloud. The change took seven lines of code and improved latency by 7.5% in a simple application benchmark.</p></div><div id="create-vm"><h3>Acknowledgements</h3><p>As we worked to introduce flowtables into Ubicloud’s networking stack, a significant portion of our understanding came from the blog post, <a href="https://thermalcircle.de/doku.php?id=blog:linux:flowtables_1_a_netfilter_nftables_fastpath">&#34;Flowtables: A Netfilter nftables Fastpath&#34;</a>. Andrej&#39;s post provides an in-depth look into flowtables and their benefits. We’d like to thank its author Andrej Stender for that comprehensive work!</p></div></div></div></div></section></div>
  </body>
</html>
