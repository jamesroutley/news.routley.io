<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eclecticlight.co/2024/01/15/why-the-m2-is-more-advanced-that-it-seemed/">Original</a>
    <h1>The M2 is more advanced that it seemed</h1>
    
    <div id="readability-page-1" class="page"><article id="post-77864">
	
	<!-- .entry-header -->

	
		<div data-first_letter="W">
		<p>When Apple launched its M2 chip at WWDC 18 months ago, in June 2022, pretty well everyone saw it as evolutionary, significantly faster than its predecessor the M1, but offering little real change in capability. In this article, which follows on from last week’s about <a href="https://eclecticlight.co/2024/01/13/how-m1-macs-may-lag-behind/">changed support for AI</a>, I take a deeper dive inside Apple silicon to discover whether the M2 is more than we thought at the time. The clues come in the instruction set supported by CPU cores inside the chips.</p>
<p>When comparing chips, emphasis is laid on performance, particularly benchmark tests that are the equivalent of sprint performance of an athlete in that they tell you how quickly the chip can run today’s tasks. If you intend keeping your Mac for longer than a year, you should also be interested in how its chip will perform when running the tasks of the future, or for our track athlete whether they’re also good enough at field events to be a good decathlete, their capability.</p>
<h4>Changes in instructions since the M1</h4>
<p>For CPUs, capability is primarily determined by the instructions they run. Today you may not be interested in whether your Mac’s chip can perform ray-tracing very quickly, but in a couple of year’s time the hardware-accelerated ray-tracing in the GPU of an M3 could make all the difference. While Apple adds plenty of its own hardware, including GPU, a neural engine, and its legendary matrix co-processor the AMX, the capability of CPU cores remains central to many of the tasks performed by its chips. Those are defined by Arm, and licensed to Apple, in its Instruction Set Architecture (ISA), documented in a manual currently well over 5,000 pages long.</p>
<p>Mercifully, Arm defines its ISA in versions. CPU cores in M1 chips use ARMv8.5-A, while those in M2 and M3 chips use ARMv8.6-A, and Arm helpfully explains their main differences in <a href="https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/arm-architecture-developments-armv8-6-a" target="_blank">this list of changes</a> in ARMv8.6-A of 2019:</p>
<ul>
<li>General Matrix Multiply (AI and others)</li>
<li>bfloat16 data type and arithmetic instructions (AI and others)</li>
<li>Finer-grained traps for virtualisation (virtualisation)</li>
<li>Wait-for-event traps for virtualisation (virtualisation)</li>
<li>High precision time (1 GHz, general)</li>
<li>Extended Pointer Authentication (security).</li>
</ul>
<p>Of those, support for bfloat16 and General Matrix Multiply are likely to have the most impact on the user.</p>
<p>Although Macs based on the M1 chip weren’t released until November 2020, a year after the introduction of ARMv8.6-A, the lead time in design and development is such that there would have been no time to incorporate changes from 2019, the year after bfloat16 first appeared.</p>
<h4>bfloat16</h4>
<p>As I <a href="https://eclecticlight.co/2024/01/13/how-m1-macs-may-lag-behind/">explained before</a>, we’re dealing here with three different floating-point number formats, each expressed using a <em>sign</em> (+ or -), a <em>fraction</em> whose length determines its precision, and an <em>exponent</em> that determines the overall range of numbers that can be represented in that format. Before the introduction of bfloat16, the choice for AI and some other computation came down to two formats:</p>
<ul>
<li><em>float32</em> (single-precision), with a range of about +/- 1.2 x 10^-38 to 3.4 x 10^38, occupying 32 bits</li>
<li><em>float16</em> (half-precision), with a range of about +/- 6.1 x 10^-5 to 65,504, occupying 16 bits.</li>
</ul>
<p>float32 has been almost universally used in AI and other applications where double-precision (float64) isn’t required.</p>
<p>bfloat16 adds to those an intermediate, with the <a href="https://en.wikipedia.org/wiki/Bfloat16_floating-point_format" target="_blank">same range as float32</a>, of about +/- 1.2 x 10^-38 to 3.4 x 10^38, but only occupying half the space, at lower precision. It’s designed for easy conversion with float32, as its sign and exponent remain unchanged, only the fraction (significand, or mantissa) has to be extended or truncated, depending on which direction you’re going in. Converting between float32 and float16 is more involved, and most importantly, as the range allowed for float16 is far smaller, numbers outside its range would lose their numeric value. That means any floating-point number larger than 65,504, which is a severe limitation for many applications.</p>
<p>A number format that is half the length of float32 numbers isn’t only important when storing large amounts of data, but has substantial effects on the performance of operations. Those are usually accelerated using ‘single instruction, multiple data’ (SIMD) techniques, where <a href="https://eclecticlight.co/2021/08/23/code-in-arm-assembly-lanes-and-loads-in-neon/">a register is packed</a> with two or more values, and the core then executes instructions on them in parallel. In the CPU cores of M-series chips, that’s normally done using 128-bit registers, which can hold four float32 values, or eight bfloat16 values. For tasks involving thousands of arithmetic operations, packing registers with twice the number of values can almost double the throughput, as <a href="https://community.arm.com/arm-community-blogs/b/ai-and-ml-blog/posts/bfloat16-processing-for-neural-networks-on-armv8_2d00_a" target="_blank">reported in tests</a> on Arm processors.</p>
<p>In applications where its reduced precision can be accepted, the bfloat16 format thus offers the same range as float32, simple and quick conversion with float32, occupies half the storage, and delivers up to double the performance in SIMD execution.</p>
<h4>But my Mac isn’t training AI models</h4>
<p>When Google’s AI researchers <a href="https://cloud.google.com/blog/products/ai-machine-learning/bfloat16-the-secret-to-high-performance-on-cloud-tpus" target="_blank">first made the claim</a> that bfloat16 is “the secret to high performance”, they were of course referring to those developing AI models, rather than ordinary users. That article was published in August 2019, less than a year before Apple announced the M1, explaining why none of the hardware in the M1 could have supported bfloat16, and that support wasn’t added by Arm until ARMv8.6-A.</p>
<p>Both Arm and Apple recognise the importance of performing as much AI training as possible in-device rather than in the cloud. The case for this has been <a href="https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/ai-vs-ml-whats-the-difference" target="_blank">argued eloquently by Hellen Norman</a> of Arm, independently of Apple.</p>
<p>It doesn’t take much imagination to come up with local training tasks that could improve commonplace features in macOS. Many of us disable spell-checking because of its seeming inability to recognise when we should be using similar words like <em>their, there</em> and <em>they’re.</em> Wouldn’t it be so much better if suggested corrections were based on grammar, usage and context? While that’s already starting to improve, and Sonoma’s auto-completion is getting smarter, there’s ample room for improvement. That depends in part at least on your Mac learning your writing style using in-device training.</p>
<p>At the start of this article, I explained how this isn’t about the performance of current tasks, but the capability to accomplish the tasks our apps and macOS will be doing in the future, when some of those will involve the sort of training that’s currently left to specialised or dedicated systems.</p>
<p>CPU cores aren’t the only hardware in Apple silicon to support AI: depending on the task, macOS may use their GPU, Apple’s specialised neural engine, or its legendary AMX. Given the fact that those in the M1 were designed and developed over the same timescale as the CPU cores, it seems improbable that they would have bfloat16 support, and Apple has only just <a href="https://developer.apple.com/documentation/metalperformanceshaders/mpsdatatype/bfloat16?changes=l_8_6" target="_blank">added that number type</a> to Metal Performance Shaders in Sonoma.</p>
<h4>Does my Mac support it?</h4>
<p>If you’re unconvinced whether your Apple silicon Mac supports bfloat16 in its CPU cores, then there’s an easy way to check. In Terminal, run the command</p>
<p>If that file contains the line</p>
<p>Not having bfloat16 support in hardware isn’t the end of the world, nor does it mean your M1 Mac is already obsolete. What it does mean, though, is that as more and heavier AI is rolled out in the coming years, some of those features will run noticeably more slowly on it. Spare a thought, though, for Intel Macs, for no matter how fast their CPUs might be, or how many cores they have, they will never have any equivalent hardware support for AI.</p>
	</div><!-- .entry-content -->

	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
