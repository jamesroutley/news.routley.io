<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ar-nelson/spartan-schema">Original</a>
    <h1>Ultra-minimal JSON schemas with TypeScript inference</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">An ultra-minimal, Typescript-compatible alternative to <a href="https://json-schema.org" rel="nofollow">JSON
Schema</a>, designed as part of <a href="https://github.com/ar-nelson/osmosis-js">Osmosis</a>.</p>
<p dir="auto"><strong>Spartan Schema is...</strong></p>
<ul dir="auto">
<li>
<p dir="auto"><strong>Clear</strong>: Spartan Schemas are singificantly simpler than comparable JSON
schemas. Here&#39;s a schema that will match objects like
<code>{ name: { first: &#34;Al&#34;, last: &#34;Yankovic&#34; }, age: 62 }</code>:</p>
<div data-snippet-clipboard-copy-content="{
  &#34;schema&#34;: {
    &#34;name&#34;: {
      &#34;first&#34;: &#34;string&#34;,
      &#34;middle&#34;: [&#34;optional&#34;, &#34;string&#34;],
      &#34;last&#34;: &#34;string&#34;
    },
    &#34;age&#34;: &#34;integer&#34;
  }
}"><pre>{
  <span>&#34;schema&#34;</span>: {
    <span>&#34;name&#34;</span>: {
      <span>&#34;first&#34;</span>: <span><span>&#34;</span>string<span>&#34;</span></span>,
      <span>&#34;middle&#34;</span>: [<span><span>&#34;</span>optional<span>&#34;</span></span>, <span><span>&#34;</span>string<span>&#34;</span></span>],
      <span>&#34;last&#34;</span>: <span><span>&#34;</span>string<span>&#34;</span></span>
    },
    <span>&#34;age&#34;</span>: <span><span>&#34;</span>integer<span>&#34;</span></span>
  }
}</pre></div>
</li>
<li>
<p dir="auto"><strong>Compatible</strong>: Spartan Schema includes <code>binary</code> and <code>date</code> types, for
languages like YAML and MessagePack that support more data types than JSON.
The parser expects a JavaScript object, which can be parsed from any JSON-like
format, or written directly in JS/TS source.</p>
</li>
<li>
<p dir="auto"><strong>Minimal</strong>: The entire specification fits on a single page. Spartan Schema
can describe itself in 20 lines of YAML:</p>
<div data-snippet-clipboard-copy-content="spartan: 1
let:
  EnumValue: [oneof, null, boolean, number, string]
  Type:
  - oneof
  - [enum, null, &#39;null&#39;, boolean, integer, float, number, string, date, binary]
  - [array, [enum, enum], [ref, EnumValue], [ref, EnumValue]]
  - [array, [enum, oneof], [ref, Type], [ref, Type]]
  - [array, [enum, tuple], [ref, Type], [ref, Type]]
  - [array, [enum, array], [ref, Type], [ref, Type]]
  - [tuple, [enum, dictionary], [ref, Type]]
  - [tuple, [enum, ref], string]
  - - dictionary
    - - oneof
      - [tuple, [enum, optional], [ref, Type]]
      - [ref, Type]
schema:
  spartan: [optional, [enum, 1]]
  let: [optional, [dictionary, [ref, Type]]]
  schema: [ref, Type]"><pre><span>spartan</span>: <span>1</span>
<span>let</span>:
  <span>EnumValue</span>: <span>[oneof, null, boolean, number, string]</span>
  <span>Type</span>:
  - <span>oneof</span>
  - <span>[enum, null, &#39;null&#39;, boolean, integer, float, number, string, date, binary]</span>
  - <span>[array, [enum, enum], [ref, EnumValue], [ref, EnumValue]]</span>
  - <span>[array, [enum, oneof], [ref, Type], [ref, Type]]</span>
  - <span>[array, [enum, tuple], [ref, Type], [ref, Type]]</span>
  - <span>[array, [enum, array], [ref, Type], [ref, Type]]</span>
  - <span>[tuple, [enum, dictionary], [ref, Type]]</span>
  - <span>[tuple, [enum, ref], string]</span>
  - <span>- dictionary</span>
    - <span>- oneof</span>
      - <span>[tuple, [enum, optional], [ref, Type]]</span>
      - <span>[ref, Type]</span>
<span>schema</span>:
  <span>spartan</span>: <span>[optional, [enum, 1]]</span>
  <span>let</span>: <span>[optional, [dictionary, [ref, Type]]]</span>
  <span>schema</span>: <span>[ref, Type]</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Statically typed</strong>: Spartan Schema uses <a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="nofollow">Typescript 4.1 recursive
conditional types</a> to convert schemas into Typescript type definitions.
A schema written directly in source code can be a single source of truth for
both compile-time and runtime typechecking.</p>
<div data-snippet-clipboard-copy-content="import { matchesSchema } from &#39;spartan-schema&#39;;

// Schemas should be defined with &#39;as const&#39;, for typechecking.
const personSchema = {
  schema: {
    name: {
      first: &#39;string&#39;,
      middle: [&#39;optional&#39;, &#39;string&#39;],
      last: &#39;string&#39;
    },
    age: &#39;integer&#39;
  }
} as const;

const isPerson = matchesSchema(personSchema);

function loadPerson(json: string) {
  const data = JSON.parse(json);
  if (!isPerson(data)) {
    throw new Error(&#34;JSON data does not match schema&#34;);
  }

  // The type of `data` is now:
  //
  // { name: { first: string, middle?: string, last: string }, age: number }
  //
  // This type was derived from `personSchema`!

  console.log(`Hello, ${data.name.first} ${data.name.last}!`);
}"><pre><span>import</span> <span>{</span> <span>matchesSchema</span> <span>}</span> <span>from</span> <span>&#39;spartan-schema&#39;</span><span>;</span>

<span>// Schemas should be defined with &#39;as const&#39;, for typechecking.</span>
<span>const</span> <span>personSchema</span> <span>=</span> <span>{</span>
  <span>schema</span>: <span>{</span>
    <span>name</span>: <span>{</span>
      <span>first</span>: <span>&#39;string&#39;</span><span>,</span>
      <span>middle</span>: <span>[</span><span>&#39;optional&#39;</span><span>,</span> <span>&#39;string&#39;</span><span>]</span><span>,</span>
      <span>last</span>: <span>&#39;string&#39;</span>
    <span>}</span><span>,</span>
    <span>age</span>: <span>&#39;integer&#39;</span>
  <span>}</span>
<span>}</span> <span>as</span> <span>const</span><span>;</span>

<span>const</span> <span>isPerson</span> <span>=</span> <span>matchesSchema</span><span>(</span><span>personSchema</span><span>)</span><span>;</span>

<span>function</span> <span>loadPerson</span><span>(</span><span>json</span>: <span>string</span><span>)</span> <span>{</span>
  <span>const</span> <span>data</span> <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>json</span><span>)</span><span>;</span>
  <span>if</span> <span>(</span><span>!</span><span>isPerson</span><span>(</span><span>data</span><span>)</span><span>)</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>&#34;JSON data does not match schema&#34;</span><span>)</span><span>;</span>
  <span>}</span>

  <span>// The type of `data` is now:</span>
  <span>//</span>
  <span>// { name: { first: string, middle?: string, last: string }, age: number }</span>
  <span>//</span>
  <span>// This type was derived from `personSchema`!</span>

  <span>console</span><span>.</span><span>log</span><span>(</span><span>`Hello, <span><span>${</span><span>data</span><span>.</span><span>name</span><span>.</span><span>first</span><span>}</span></span> <span><span>${</span><span>data</span><span>.</span><span>name</span><span>.</span><span>last</span><span>}</span></span>!`</span><span>)</span><span>;</span>
<span>}</span></pre></div>
</li>
</ul>
<h2 dir="auto"><a id="user-content-usage" aria-hidden="true" href="#usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p dir="auto">Spartan Schema is compatible with both Node and Deno, and has no dependencies.</p>
<p dir="auto">The repository is written in Deno-compatible Typescript. <code>mod.ts</code> can be
imported directly:</p>
<div data-snippet-clipboard-copy-content="import {
  Schema,
  matchesSchema
} from &#39;https://raw.githubusercontent.com/ar-nelson/spartan-schema/v1.0.0/mod.ts&#39;;"><pre><span>import</span> <span>{</span>
  <span>Schema</span><span>,</span>
  <span>matchesSchema</span>
<span>}</span> <span>from</span> <span>&#39;https://raw.githubusercontent.com/ar-nelson/spartan-schema/v1.0.0/mod.ts&#39;</span><span>;</span></pre></div>
<p dir="auto">The Node module is built with <a href="https://github.com/denoland/dnt"><code>dnt</code></a>, and is available on NPM as
<code>spartan-schema</code>:</p>
<div data-snippet-clipboard-copy-content="import {
  Schema,
  matchesSchema
} from &#39;spartan-schema&#39;;"><pre><span>import</span> <span>{</span>
  <span>Schema</span><span>,</span>
  <span>matchesSchema</span>
<span>}</span> <span>from</span> <span>&#39;spartan-schema&#39;</span><span>;</span></pre></div>
<p dir="auto">All <code>deno</code> build commands are documented in the Makefile. To run the test suite
and build the Node module, just run <code>make</code> (requires Deno).</p>
<h2 dir="auto"><a id="user-content-the-schema-language" aria-hidden="true" href="#the-schema-language"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The Schema Language</h2>
<h3 dir="auto"><a id="user-content-the-root-object" aria-hidden="true" href="#the-root-object"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The Root Object</h3>
<p dir="auto">The root of a Spartan Schema is an object. This object must contain a <code>&#34;schema&#34;</code>
property, and may optionally contain <code>&#34;spartan&#34;</code> and <code>&#34;let&#34;</code> properties. Other
properties are allowed, and will be ignored.</p>
<ul dir="auto">
<li><code>&#34;schema&#34;</code>: The schema itself. A single schema type.</li>
<li><code>&#34;let&#34;</code>: An object whose values are schema types. Its properties are defined
as <em>reference types</em>, which can be accessed with the <code>&#34;ref&#34;</code> directive type.
<ul dir="auto">
<li>For example, <code>{ &#34;let&#34;: { &#34;Foo&#34;: &#34;string&#34; }, { &#34;schema&#34;: [&#34;ref&#34;, &#34;Foo&#34;] } }</code>
is equivalent to <code>{ &#34;schema&#34;: &#34;string&#34; }</code>.</li>
</ul>
</li>
<li><code>&#34;spartan&#34;</code>: The Spartan Schema major version of this schema. If present, it
must be <code>1</code>.</li>
</ul>
<h3 dir="auto"><a id="user-content-schema-types" aria-hidden="true" href="#schema-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Schema Types</h3>
<ul dir="auto">
<li>Primitive types: <code>&#34;string&#34;</code>, <code>&#34;integer&#34;</code>, <code>&#34;float&#34;</code>, <code>&#34;number&#34;</code>, <code>&#34;binary&#34;</code>, <code>&#34;date&#34;</code>,
<code>&#34;boolean&#34;</code>, <code>null</code>.
<ul dir="auto">
<li><code>&#34;float&#34;</code> is an alias for <code>&#34;number&#34;</code>.</li>
<li><code>&#34;null&#34;</code> can also be written as the literal value <code>null</code>.</li>
</ul>
</li>
<li>Object type: An object whose keys are schema types. Matches an object with
all of the included keys, if those keys&#39; values match their schema types.
<ul dir="auto">
<li>Unspecified keys are allowed, and will not be checked.</li>
<li>Keys are required by default. To make a key optional, use the directive type
<code>&#34;optional&#34;</code>: <code>{ &#34;optionalKey&#34;: [&#34;optional&#34;, &lt;value type&gt;] }</code></li>
</ul>
</li>
<li>Directive types: Arrays whose first element is a string. The string is the
<em>name</em> of the directive, and the rest of the array is the directive&#39;s
<em>arguments</em>.
<ul dir="auto">
<li><code>&#34;enum&#34;</code> takes an argument list of primitive values (strings, numbers,
<code>true</code>, <code>false</code>, <code>null</code>) and matches only those exact values.</li>
<li><code>&#34;oneof&#34;</code> takes an argument list of schema types and matches anything that
matches at least one of those types.</li>
<li><code>&#34;tuple&#34;</code> takes an argument list of schema types and matches an array with
that exact length, with each element matching the argument at the same
index.</li>
<li><code>&#34;array&#34;</code> takes an argument list of schema types.
<ul dir="auto">
<li>If it has one argument, it matches an array of any length whose elements
all match that argument.</li>
<li>If it has more than one argument, it behaves like <code>&#34;tuple&#34;</code> with
a variable-length suffix: given <em>N</em> arguments, <code>&#34;array&#34;</code> matches an array
with at least <em>N - 1</em> elements, where each of these elements matches the
argument of the same index, followed by 0 or more additional elements
which match the last argument.</li>
</ul>
</li>
<li><code>&#34;dictionary&#34;</code> takes one schema type argument, and matches an object whose
values all match this argument.</li>
<li><code>&#34;ref&#34;</code> takes one string argument. Its argument must be a key in the root
object&#39;s <code>&#34;let&#34;</code> property. A <code>&#34;ref&#34;</code> is substituted with the value of the
<code>&#34;let&#34;</code> property that it names.
<ul dir="auto">
<li>Recursion is allowed, and <code>&#34;ref&#34;</code>s can be used inside of <code>&#34;let&#34;</code> to create
infinite types.</li>
</ul>
</li>
<li><code>&#34;optional&#34;</code> is only allowed as a value of an object type. It takes one
schema type argument. It makes its key in the object type optional, with
its argument as the value type.</li>
</ul>
</li>
</ul>
<h2 dir="auto"><a id="user-content-comparison-to-json-schema" aria-hidden="true" href="#comparison-to-json-schema"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Comparison to JSON Schema</h2>
<p dir="auto">Spartan Schema is <em>much less verbose</em> than JSON Schema, but has more limited
features.</p>
<p dir="auto">(Examples taken from <a href="https://json-schema.org/learn/miscellaneous-examples.html" rel="nofollow">https://json-schema.org/learn/miscellaneous-examples.html</a>)</p>
<table>
<tbody><tr><th>JSON Schema</th><th>Spartan Schema</th></tr>
<tr>
<td>
<div data-snippet-clipboard-copy-content="{
  &#34;$id&#34;: &#34;https://example.com/person.schema.json&#34;,
  &#34;$schema&#34;: &#34;https://json-schema.org/draft/2020-12/schema&#34;,
  &#34;title&#34;: &#34;Person&#34;,
  &#34;type&#34;: &#34;object&#34;,
  &#34;properties&#34;: {
    &#34;firstName&#34;: {
      &#34;type&#34;: &#34;string&#34;,
      &#34;description&#34;: &#34;The person&#39;s first name.&#34;
    },
    &#34;lastName&#34;: {
      &#34;type&#34;: &#34;string&#34;,
      &#34;description&#34;: &#34;The person&#39;s last name.&#34;
    },
    &#34;age&#34;: {
      &#34;description&#34;: &#34;Age in years.&#34;,
      &#34;type&#34;: &#34;integer&#34;,
      &#34;minimum&#34;: 0
    }
  }
}"><pre>{
  <span>&#34;$id&#34;</span>: <span><span>&#34;</span>https://example.com/person.schema.json<span>&#34;</span></span>,
  <span>&#34;$schema&#34;</span>: <span><span>&#34;</span>https://json-schema.org/draft/2020-12/schema<span>&#34;</span></span>,
  <span>&#34;title&#34;</span>: <span><span>&#34;</span>Person<span>&#34;</span></span>,
  <span>&#34;type&#34;</span>: <span><span>&#34;</span>object<span>&#34;</span></span>,
  <span>&#34;properties&#34;</span>: {
    <span>&#34;firstName&#34;</span>: {
      <span>&#34;type&#34;</span>: <span><span>&#34;</span>string<span>&#34;</span></span>,
      <span>&#34;description&#34;</span>: <span><span>&#34;</span>The person&#39;s first name.<span>&#34;</span></span>
    },
    <span>&#34;lastName&#34;</span>: {
      <span>&#34;type&#34;</span>: <span><span>&#34;</span>string<span>&#34;</span></span>,
      <span>&#34;description&#34;</span>: <span><span>&#34;</span>The person&#39;s last name.<span>&#34;</span></span>
    },
    <span>&#34;age&#34;</span>: {
      <span>&#34;description&#34;</span>: <span><span>&#34;</span>Age in years.<span>&#34;</span></span>,
      <span>&#34;type&#34;</span>: <span><span>&#34;</span>integer<span>&#34;</span></span>,
      <span>&#34;minimum&#34;</span>: <span>0</span>
    }
  }
}</pre></div>
</td><td>
<div data-snippet-clipboard-copy-content="{
  &#34;schema&#34;: {
    &#34;firstName&#34;: &#34;string&#34;,
    &#34;lastName&#34;: &#34;string&#34;,
    &#34;age&#34;: &#34;integer&#34;
  }
}"><pre>{
  <span>&#34;schema&#34;</span>: {
    <span>&#34;firstName&#34;</span>: <span><span>&#34;</span>string<span>&#34;</span></span>,
    <span>&#34;lastName&#34;</span>: <span><span>&#34;</span>string<span>&#34;</span></span>,
    <span>&#34;age&#34;</span>: <span><span>&#34;</span>integer<span>&#34;</span></span>
  }
}</pre></div>
<p dir="auto">This schema is much shorter, but does not include names, URLs, or field
descriptions, and cannot specify a minimum for <code>age</code>.</p>
</td></tr><tr><td>
<div data-snippet-clipboard-copy-content="{
  &#34;$id&#34;: &#34;https://example.com/arrays.schema.json&#34;,
  &#34;$schema&#34;: &#34;https://json-schema.org/draft/2020-12/schema&#34;,
  &#34;type&#34;: &#34;object&#34;,
  &#34;properties&#34;: {
    &#34;fruits&#34;: {
      &#34;type&#34;: &#34;array&#34;,
      &#34;items&#34;: {
        &#34;type&#34;: &#34;string&#34;
      }
    },
    &#34;vegetables&#34;: {
      &#34;type&#34;: &#34;array&#34;,
      &#34;items&#34;: { &#34;$ref&#34;: &#34;#/$defs/veggie&#34; }
    }
  },
  &#34;$defs&#34;: {
    &#34;veggie&#34;: {
      &#34;type&#34;: &#34;object&#34;,
      &#34;required&#34;: [ &#34;veggieName&#34;, &#34;veggieLike&#34; ],
      &#34;properties&#34;: {
        &#34;veggieName&#34;: {
          &#34;type&#34;: &#34;string&#34;,
          &#34;description&#34;: &#34;The name of the vegetable.&#34;
        },
        &#34;veggieLike&#34;: {
          &#34;type&#34;: &#34;boolean&#34;,
          &#34;description&#34;: &#34;Do I like this vegetable?&#34;
        }
      }
    }
  }
}"><pre>{
  <span>&#34;$id&#34;</span>: <span><span>&#34;</span>https://example.com/arrays.schema.json<span>&#34;</span></span>,
  <span>&#34;$schema&#34;</span>: <span><span>&#34;</span>https://json-schema.org/draft/2020-12/schema<span>&#34;</span></span>,
  <span>&#34;type&#34;</span>: <span><span>&#34;</span>object<span>&#34;</span></span>,
  <span>&#34;properties&#34;</span>: {
    <span>&#34;fruits&#34;</span>: {
      <span>&#34;type&#34;</span>: <span><span>&#34;</span>array<span>&#34;</span></span>,
      <span>&#34;items&#34;</span>: {
        <span>&#34;type&#34;</span>: <span><span>&#34;</span>string<span>&#34;</span></span>
      }
    },
    <span>&#34;vegetables&#34;</span>: {
      <span>&#34;type&#34;</span>: <span><span>&#34;</span>array<span>&#34;</span></span>,
      <span>&#34;items&#34;</span>: { <span>&#34;$ref&#34;</span>: <span><span>&#34;</span>#/$defs/veggie<span>&#34;</span></span> }
    }
  },
  <span>&#34;$defs&#34;</span>: {
    <span>&#34;veggie&#34;</span>: {
      <span>&#34;type&#34;</span>: <span><span>&#34;</span>object<span>&#34;</span></span>,
      <span>&#34;required&#34;</span>: [ <span><span>&#34;</span>veggieName<span>&#34;</span></span>, <span><span>&#34;</span>veggieLike<span>&#34;</span></span> ],
      <span>&#34;properties&#34;</span>: {
        <span>&#34;veggieName&#34;</span>: {
          <span>&#34;type&#34;</span>: <span><span>&#34;</span>string<span>&#34;</span></span>,
          <span>&#34;description&#34;</span>: <span><span>&#34;</span>The name of the vegetable.<span>&#34;</span></span>
        },
        <span>&#34;veggieLike&#34;</span>: {
          <span>&#34;type&#34;</span>: <span><span>&#34;</span>boolean<span>&#34;</span></span>,
          <span>&#34;description&#34;</span>: <span><span>&#34;</span>Do I like this vegetable?<span>&#34;</span></span>
        }
      }
    }
  }
}</pre></div>
</td><td>
<div data-snippet-clipboard-copy-content="{
  &#34;let&#34;: {
    &#34;Veggie&#34;: {
      &#34;veggieName&#34;: &#34;string&#34;,
      &#34;veggieLike&#34;: &#34;boolean&#34;
    }
  },
  &#34;schema&#34;: {
    &#34;fruits&#34;: [&#34;array&#34;, &#34;string&#34;],
    &#34;vegetables&#34;: [&#34;array&#34;, [&#34;ref&#34;, &#34;Veggie&#34;]]
  }
}"><pre>{
  <span>&#34;let&#34;</span>: {
    <span>&#34;Veggie&#34;</span>: {
      <span>&#34;veggieName&#34;</span>: <span><span>&#34;</span>string<span>&#34;</span></span>,
      <span>&#34;veggieLike&#34;</span>: <span><span>&#34;</span>boolean<span>&#34;</span></span>
    }
  },
  <span>&#34;schema&#34;</span>: {
    <span>&#34;fruits&#34;</span>: [<span><span>&#34;</span>array<span>&#34;</span></span>, <span><span>&#34;</span>string<span>&#34;</span></span>],
    <span>&#34;vegetables&#34;</span>: [<span><span>&#34;</span>array<span>&#34;</span></span>, [<span><span>&#34;</span>ref<span>&#34;</span></span>, <span><span>&#34;</span>Veggie<span>&#34;</span></span>]]
  }
}</pre></div>
<p dir="auto">Spartan Schema supports references, using <code>&#34;let&#34;</code> and <code>&#34;ref&#34;</code>. All fields are
required unless marked <code>&#34;optional&#34;</code>.</p>
</td></tr></tbody></table>
<h2 dir="auto"><a id="user-content-api" aria-hidden="true" href="#api"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>API</h2>
<p dir="auto">Spartan Schema defines only a few functions that operate on schema objects.
A schema object is made up of plain JavaScript objects and arrays that match the
Spartan Schema spec.</p>
<h3 dir="auto"><a id="user-content-type-schema" aria-hidden="true" href="#type-schema"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>type <code>Schema</code></h3>
<p dir="auto">The type of valid Spartan Schemas.</p>
<p dir="auto">When writing schemas directly in Typescript code, you should not use this type;
instead, use <code>as const</code> and let Typescript infer the exact type of the schema.</p>
<h3 dir="auto"><a id="user-content-type-matchesschemas-extends-schema" aria-hidden="true" href="#type-matchesschemas-extends-schema"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>type <code>MatchesSchema&lt;S extends Schema&gt;</code></h3>
<p dir="auto">Given a type <code>S</code> that describes the exact shape of a <code>Schema</code>,
<code>MatchesSchema&lt;S&gt;</code> is the type of values that match that schema.</p>
<p dir="auto">For example, <code>MatchesSchema&lt;{ schema: { foo: &#34;string&#34; } }&gt;</code> is
<code>{ foo: string }</code>.</p>
<p dir="auto"><code>MatchesSchema</code> is a complex recursive type, and can easily cause the Typescript
compiler to fail with a &#34;Type instantiation is excessively deep and possibly
infinite&#34; error. It should only be used on schema types that are 100% statically
known.</p>
<h3 dir="auto"><a id="user-content-type-patharray" aria-hidden="true" href="#type-patharray"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>type <code>PathArray</code></h3>
<p dir="auto"><code>type PathArray = readonly (string | number)[]</code></p>
<p dir="auto">A path to a specific location in a JSON document.</p>
<h3 dir="auto"><a id="user-content-function-isschemaschema-errors" aria-hidden="true" href="#function-isschemaschema-errors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>function <code>isSchema(schema, errors?)</code></h3>
<p dir="auto">A type predicate that checks whether <code>schema</code> is a valid Spartan Schema.</p>
<p dir="auto"><code>errors</code> is a mutable array of <code>{ message, location }</code> pairs; if it is present
and <code>isSchema</code> returns false, it will be populated with a list of parsing
errors.</p>
<h3 dir="auto"><a id="user-content-function-matchesschemaschemavalue" aria-hidden="true" href="#function-matchesschemaschemavalue"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>function <code>matchesSchema(schema)(value)</code></h3>
<p dir="auto">A curried function that checks whether <code>value</code> matches <code>schema</code> and returns
a boolean.</p>
<p dir="auto">If <code>schema</code> is statically known at typechecking type (defined with <code>as const</code>),
then the function returned by <code>matchesSchema(schema)</code> will be a type predicate.</p>
<h3 dir="auto"><a id="user-content-function-zerovalueschema" aria-hidden="true" href="#function-zerovalueschema"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>function <code>zeroValue(schema)</code></h3>
<p dir="auto">Returns the <em>zero value</em> of this schema&#39;s root type.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Zero value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>null</code></td>
<td><code>null</code></td>
</tr>
<tr>
<td>boolean</td>
<td><code>false</code></td>
</tr>
<tr>
<td>integer, float</td>
<td><code>0</code></td>
</tr>
<tr>
<td>string</td>
<td><code>&#34;&#34;</code></td>
</tr>
<tr>
<td>binary</td>
<td><code>0</code>-length <code>Uint8Array</code></td>
</tr>
<tr>
<td>date</td>
<td><code>new Date(0)</code> (Jan 1, 1970)</td>
</tr>
<tr>
<td>object</td>
<td>object populated with properties&#39; zero values</td>
</tr>
<tr>
<td><code>oneof</code></td>
<td>zero value of first type</td>
</tr>
<tr>
<td><code>enum</code></td>
<td>first enum value</td>
</tr>
<tr>
<td><code>array</code></td>
<td><code>[]</code></td>
</tr>
<tr>
<td><code>tuple</code></td>
<td>array populated with elements&#39; zero values</td>
</tr>
<tr>
<td><code>dictionary</code></td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
<p dir="auto">This function typechecks the schema it receives. If it is passed a known schema
type <code>S</code> (defined <code>as const</code> in a Typescript file), then its return type will
be <code>MatchesSchema&lt;S&gt;</code>.</p>
<p dir="auto">May throw an exception if the schema type is infinitely recursive.</p>
<h2 dir="auto"><a id="user-content-license" aria-hidden="true" href="#license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>License</h2>
<p dir="auto">Copyright Â© 2021-2022 Adam Nelson</p>
<p dir="auto">Spartan Schema is distributed under the <a href="https://blueoakcouncil.org/license/1.0.0" rel="nofollow">Blue Oak Model License</a>. It
is a MIT/BSD-style license, but with <a href="https://writing.kemitchell.com/2019/03/09/Deprecation-Notice.html" rel="nofollow">some clarifying
improvements</a> around patents, attribution, and multiple
contributors.</p>
</article>
          </div></div>
  </body>
</html>
