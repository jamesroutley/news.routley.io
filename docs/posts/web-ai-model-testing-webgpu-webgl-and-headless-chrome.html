<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developer.chrome.com/blog/supercharge-web-ai-testing">Original</a>
    <h1>Web AI Model Testing: WebGPU, WebGL, and Headless Chrome</h1>
    
    <div id="readability-page-1" class="page"><div>

  
    




<div>
  
    
    
      
    
  
    
    
      <div>
        
          <p><img alt="FranÃ§ois Beaufort" src="https://web.dev/images/authors/beaufortfrancois.jpg" decoding="async" height="64" loading="lazy" width="64"/></p>
      </div>
    
  
</div>

<p>Great news! You&#39;ve built a cool <a href="https://goo.gle/made-with-tfjs">Web AI application</a> 
that runs machine learning models directly on a user&#39;s device. It runs entirely
on the client-side web browser, without relying on the cloud. This on-device
design enhances user privacy, boosts performance, and reduces costs
significantly.</p>

<p>However, there&#39;s a hurdle. Your
<a href="https://www.tensorflow.org/js">TensorFlow.js</a> model can operate on
both CPUs (WebAssembly) and more powerful GPUs (through
<a href="https://developer.mozilla.org/docs/Web/API/WebGL_API">WebGL</a> and
<a href="https://developer.chrome.com/blog/webgpu-release">WebGPU</a>). The question is:
<strong>how can you consistently automate browser testing with the selected hardware?</strong></p>

<p>Maintaining consistency is crucial for comparing machine learning model
performance over time as you iterate and improve them, prior to deployment for
real-world users to use on their device.</p>

<p>Setting up a consistent testing environment with GPUs can be harder than
expected. In this blog post, we&#39;ll share the problems we faced and how we solved
them, so you can improve your application&#39;s performance.</p>

<p>This isn&#39;t just for Web AI developers! If you&#39;re working on web gaming or
graphics, this post is valuable for you, too.</p>

<h2 id="what&#39;s-automation" data-text="What&#39;s in our automation toolbox" tabindex="-1">What&#39;s in our automation toolbox</h2>

<p>Here is what we are using:</p>

<ul>
<li><strong>Environment</strong>: A Linux-based Google Colab
<a href="https://colab.google/notebooks/">notebook</a> connected to an NVIDIA
T4 or V100 GPU. You can use other cloud platforms, such as Google Cloud
(GCP), if preferred.</li>
<li><strong>Browser</strong>: Chrome supports <a href="https://developer.chrome.com/docs/web-platform/webgpu">WebGPU</a>,
a powerful <a href="https://developer.chrome.com/blog/from-webgl-to-webgpu">successor to WebGL</a>, that
brings the advancements of modern GPU APIs to the web.</li>
<li><strong>Automation</strong>: <a href="https://developer.chrome.com/docs/puppeteer">Puppeteer</a> is a Node.js library that lets
you control browsers programmatically with JavaScript. With Puppeteer, we can
automate Chrome in headless mode, which means the browser runs without a
visible interface, on a server. We are using the improved
<a href="https://developer.chrome.com/docs/chromium/new-headless">new headless mode</a>, not the
<a href="https://developer.chrome.com/blog/headless-chrome">legacy</a> form.</li>
</ul>



<h2 id="verify-environment" data-text="Verify the environment" tabindex="-1">Verify the environment</h2>

<p>The best way to check whether hardware acceleration is turned on in Chrome is to
type <code translate="no" dir="ltr">chrome://gpu</code> into the address bar. You can
programmatically <a href="https://github.com/jasonmayes/headless-chrome-nvidia-t4-gpu-support/blob/main/examples/puppeteer/jPuppet.js">perform the equivalent with Puppeteer</a> 
with <code translate="no" dir="ltr">console.log</code> or save the full report as PDF to check manually:</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">/* Incomplete example.js */
import puppeteer from &#39;puppeteer&#39;;

// Configure launch parameters: Expands later
const browser = await puppeteer.launch({
  headless: &#39;new&#39;,
  args:  [&#39;--no-sandbox&#39;]
});

const page = await browser.newPage();
await page.goto(&#39;chrome://gpu&#39;);

// Verify: log the WebGPU status or save the GPU report as PDF
const txt = await page.waitForSelector(&#39;text/WebGPU&#39;);
const status = await txt.evaluate(g =&gt; g.parentElement.textContent);
console.log(status);
await page.pdf({ path: &#39;./gpu.pdf&#39; });

await browser.close();
</code></pre>
<p>Open <code translate="no" dir="ltr">chrome://gpu</code> and you should have the following results:</p>

<table>
  <tbody><tr>
    <th colspan="2">Graphics feature status</th>
  </tr>
  <tr>
    <td>OpenGL:</td>
    <td><span>Disabled</span></td>
  </tr>
  <tr>
    <td>Vulkan:</td>
    <td><span>Disabled</span></td>
  </tr>
  <tr>
    <td>WebGL:</td>
    <td><span>Software only, hardware acceleration unavailable.</span></td>
  </tr>
  <tr>
    <td>WebGL2:</td>
    <td><span>Software only, hardware acceleration unavailable.</span></td>
  </tr>
  <tr>
    <td>WebGPU:</td>
    <td><span>Disabled</span></td>
  </tr>
  <tr>
    <td colspan="2">
      <p><b>Problems detected.</b></p>
    </td>
  </tr>
</tbody></table>

<p>Not a great start. It&#39;s fairly clear that hardware detection was failing.
<strong>WebGL, WebGL2, and WebGPU are essentially disabled or software only</strong>. We
aren&#39;t alone in this problem - there are numerous discussions online of people
in a similar situation, including on the official Chrome support channels
(<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1459930">1</a>),
(<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=765284">2</a>).</p>

<h2 id="enable-webgpu" data-text="Enable WebGPU and WebGL support" tabindex="-1">Enable WebGPU and WebGL support</h2>

<p>By default, Headless Chrome
<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1416283">disables GPU</a>.
To enable it on Linux, apply all of the following flags when launching Headless
Chrome:</p>

<ul>
<li><strong><code translate="no" dir="ltr">--no-sandbox</code></strong> flag disables <a href="https://developer.chrome.com/docs/puppeteer/troubleshooting#set_up_a_chrome_linux_sandbox">Chrome&#39;s security sandbox</a>, which isolates the
browser process from the rest of the system. Running Chrome as root without
this sandbox is not supported.</li>
<li><strong><code translate="no" dir="ltr">--headless=new</code></strong> flag runs Chrome with the new and improved
<a href="https://developer.chrome.com/docs/chromium/new-headless">headless mode</a>, without any visible UI.</li>
<li><strong><code translate="no" dir="ltr">--use-angle=vulkan</code></strong> flag tells Chrome to use the
<a href="https://chromium.googlesource.com/angle/angle/+/HEAD/src/libANGLE/renderer/vulkan/README.md">Vulkan backend</a> 
for <a href="https://chromium.googlesource.com/angle/angle/">ANGLE</a>, which
translates OpenGL ES 2/3 calls to Vulkan API calls.</li>
<li><strong><code translate="no" dir="ltr">--enable-features=Vulkan</code></strong> flag enables Vulkan graphics backend for
compositing and rasterization in Chrome.</li>
<li><strong><code translate="no" dir="ltr">--disable-vulkan-surface</code></strong> flag disables the <code translate="no" dir="ltr">VK_KHR_surface</code> vulkan
instance extension. Instead of using a swapchain,
<a href="https://en.wikipedia.org/wiki/Bit_blit">Bit blit</a> is used for the
present render result on screen.</li>
<li><strong><code translate="no" dir="ltr">--enable-unsafe-webgpu</code></strong> flag enables the experimental WebGPU API in
Chrome on Linux and disables the adapters blocklist.</li>
</ul>

<p>Now we combine all the changes we have made so far. Here is the complete script.</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">/* Complete example.js */
import puppeteer from &#39;puppeteer&#39;;

// Configure launch parameters
const browser = await puppeteer.launch({
  headless: &#39;new&#39;,
  args: [
    &#39;--no-sandbox&#39;,
    &#39;--headless=new&#39;,
    &#39;--use-angle=vulkan&#39;,
    &#39;--enable-features=Vulkan&#39;,
    &#39;--disable-vulkan-surface&#39;,
    &#39;--enable-unsafe-webgpu&#39;,
  ]
});

const page = await browser.newPage();
await page.goto(&#39;chrome://gpu&#39;);

// Verify: log the WebGPU status or save the GPU report as PDF
const txt = await page.waitForSelector(&#39;text/WebGPU&#39;);
const status = await txt.evaluate(g =&gt; g.parentElement.textContent);
console.log(status);
await page.pdf({path: &#39;./gpu.pdf&#39;});

await browser.close();
</code></pre>
<p>Run the script again. No WebGPU problems are detected and the value changes from
disabled to software only.</p>

<table>
  <tbody><tr>
    <th colspan="2">Graphics feature status</th>
  </tr>
  <tr>
    <td>OpenGL:</td>
    <td><span>Disabled</span></td>
  </tr>
  <tr>
    <td>Vulkan:</td>
    <td><span>Disabled</span></td>
  </tr>
  <tr>
    <td>WebGL:</td>
    <td><span>Software only, hardware acceleration unavailable.</span></td>
  </tr>
  <tr>
    <td>WebGL2:</td>
    <td><span>Software only, hardware acceleration unavailable.</span></td>
  </tr>
  <tr>
    <td>WebGPU:</td>
    <td><span>Software only, hardware acceleration unavailable.</span></td>
  </tr>
</tbody></table>

<p>However, hardware acceleration is still unavailable, the NVIDIA T4 GPU isn&#39;t
detected.</p>

<h2 id="install-drivers" data-text="Install the correct GPU drivers" tabindex="-1">Install the correct GPU drivers</h2>

<p>We investigated more closely the output of <code translate="no" dir="ltr">chrome://gpu</code>, with some GPU experts
on the Chrome team. We found issues with the <a href="https://github.com/googlecolab/colabtools/issues/3556#issuecomment-1499397023">default drivers installed on the
Linux Colab</a> 
instance, causing issues with Vulkan, leading to Chrome unable to detect the
NVIDIA T4 GPU at the <code translate="no" dir="ltr">GL_RENDERER</code> level as shown in the following output. This
causes problems with Headless Chrome.</p>

<table>
  <caption>The default output doesn&#39;t detect NVIDIA T4 GPU.</caption>
  <tbody><tr>
    <th colspan="2">Driver information</th>
  </tr>
  <tr>
    <td>GL_RENDERER</td>
    <td>ANGLE (Google, Vulkan 1.3.0 (SwiftShader Device (Subzero) (0x0000C0DE)), SwiftShader driver-5.0.0)</td>
  </tr>
</tbody></table>

<p>Installing the correct drivers that were compatible therefore fixes the issue.</p>

<table>
  <caption>Updated output after drivers are installed.</caption>
  <tbody><tr>
    <th colspan="2">Driver information</th>
  </tr>
  <tr>
    <td>GL_RENDERER</td>
    <td>ANGLE (NVIDIA Corporation, Tesla T4/PCIe/SSE2, OpenGL ES 3.2 NVIDIA 525.105.17)</td>
  </tr>
</tbody></table>

<p>To install the correct drivers, run the following commands during setup. The
last two lines help you to log the outputs of what NVIDIA drivers detects along
with <code translate="no" dir="ltr">vulkaninfo</code>.</p>

<pre translate="no" dir="ltr"><code translate="no" dir="ltr">apt-get install -y vulkan-tools libnvidia-gl-525
</code>
<code translate="no" dir="ltr">// Verify the NVIDIA drivers detects along with vulkaninfo</code>
<code translate="no" dir="ltr">nvidia-smi</code>
<code translate="no" dir="ltr">vulkaninfo --summary</code>
</pre>

<p>Now run the script again and we get the following result. ðŸŽ‰</p>

<table>
  <tbody><tr>
    <th colspan="2">Graphics feature status</th>
  </tr>
  <tr>
    <td>OpenGL:</td>
    <td><span>Enabled</span></td>
  </tr>
  <tr>
    <td>Vulkan:</td>
    <td><span>Enabled</span></td>
  </tr>
  <tr>
    <td>WebGL:</td>
    <td><span>Hardware accelerated but at reduced performance.</span></td>
  </tr>
  <tr>
    <td>WebGL2:</td>
    <td><span>Hardware accelerated but at reduced performance.</span></td>
  </tr>
  <tr>
    <td>WebGPU:</td>
    <td><span>Hardware accelerated but at reduced performance.</span></td>
  </tr>
</tbody></table>

<p>By using the correct drivers and flags when running Chrome, we now have WebGPU
and WebGL support using the shiny, new headless mode.</p>

<h2 id="investigation" data-text="Behind the scenes: Our team&#39;s investigation" tabindex="-1">Behind the scenes: Our team&#39;s investigation</h2>

<p>After much research, we didn&#39;t find working methods for the environment we
needed to execute in Google Colab, although there were some
<a href="https://mirzabilal.com/how-to-enable-hardware-acceleration-on-chrome-chromium-puppeteer-on-aws-in-headless-mode">hopeful posts</a> 
that worked in other environments, which was promising. Ultimately, we weren&#39;t
able to replicate their success in the Colab NVIDIA T4 environment, as we had 2
key issues:</p>

<ol>
<li>Some combinations of flags allow detection of the GPU, but don&#39;t allow you to
actually use the GPU.</li>
<li>Examples of working solutions by third parties used the old Chrome headless
version, which at some point will be deprecated in favor of the
<a href="https://developer.chrome.com/docs/chromium/new-headless">new version</a>. We needed a solution
that worked with the new Headless Chrome to be better future proofed.</li>
</ol>

<p>We confirmed the under utilization of the GPU by running an
<a href="https://tensorflowjs-fashion-mnist-classifier.glitch.me/">example TensorFlow.js web page for image recognition</a>,
whereby we trained a model to recognize clothing samples (sort of like a &#34;hello
world&#34; of machine learning).</p>

<p>On a regular machine, 50 training cycles (known as epochs) should run in less
than 1 second each. Calling Headless Chrome in its default state, we could log
the JavaScript console output to the Node.js server-side command line to see how
fast these training cycles were actually taking.</p>

<p>As expected, each training epoch took much longer than expected (several
seconds), which suggests Chrome has fallen back to plain old JS CPU execution
instead of utilizing the GPU:</p>

<figure>
  <img src="https://developer.chrome.com/blog/supercharge-web-ai-testing/image/initial_epoch_timing.gif" alt="The training epochs move at a slower cadence."/>
  <figcaption><b>Figure 1</b>: Real-time capture showing how long each training epoch took to execute (seconds).</figcaption>
</figure>

<p>After fixing the drivers and using the right combination of flags for Headless
Chrome, rerunning the TensorFlow.js training example results in much faster
training epochs.</p>

<figure>
  <img src="https://developer.chrome.com/blog/supercharge-web-ai-testing/image/epoch_timing_with_headless.gif" alt="There&#39;s an increase in speed for epochs.."/>
  <figcaption><b>Figure 2</b>: Real-time capture showing the speed up of epochs.</figcaption>
</figure>

<h2 id="summary" data-text="Summary" tabindex="-1">Summary</h2>

<p><a href="https://www.youtube.com/watch?v=r7hOoCY6uGo">Web AI has grown exponentially</a> 
since its creation in 2017. With browser technologies such as WebGPU, WebGL, and
<a href="https://webassembly.org/">WebAssembly</a>, a machine learning model&#39;s
mathematical operations can be further accelerated on the client side.</p>

<p>As of 2023 TensorFlow.js and MediaPipe Web crossed over 1 billion downloads of
models and librariesâ€”a historic milestone and a sign of how web
developers and engineers are shifting to embrace <a href="https://goo.gle/made-with-tfjs">AI in their next generation
web apps to make some truly incredible solutions</a>.</p>

<p>With great success in usage comes great responsibility. At this level of usage
in production systems, the need arises for testing client-side, browser-based AI
models in a true browser environment, while also being scalable, automatable,
and within a known standardized hardware setup.</p>



<p>By harnessing the combined power of the new Headless Chrome and Puppeteer, you
can confidently test such workloads in a standardized and replicable
environment, ensuring consistent and reliable results.</p>

<h2 id="wrap" data-text="Wrap up" tabindex="-1">Wrap up</h2>

<p>A <a href="https://developer.chrome.com/docs/web-platform/webgpu/colab-headless">step-by-step guide</a> is available in
our documentation, so you can try out the complete setup yourself.</p>

<p>If you found this useful, drop a shout out over on
<a href="https://www.linkedin.com/in/WebAI">LinkedIn</a>,
<a href="https://twitter.com/jason_mayes">X (formerly Twitter)</a>, or whatever
social network you use using hashtag <strong>#WebAI</strong>. It would be great to hear any
feedback you have so we know to write more stuff like this in the future.</p>

<p><a href="https://github.com/jasonmayes/headless-chrome-nvidia-t4-gpu-support">Add a star on the Github repo</a> 
to receive any future updates.</p>

<h2 id="acknowledgements" data-text="Acknowledgements" tabindex="-1">Acknowledgements</h2>

<p>A huge thank you to everyone on the Chrome team who helped debug the driver and
WebGPU issues we faced in this solution, with a special thanks to
<a href="https://jec.fish/">Jecelyn Yeen</a> and
<a href="https://heyawhite.com">Alexandra White</a> for helping to wordsmith
this blog post. Thanks to Yuly Novikov, Andrey Kosyakov, and
<a href="https://mastodon.online/@orkon">Alex Rudenko</a> who were instrumental
in creating the final, working solution.</p>

  

  
</div></div>
  </body>
</html>
