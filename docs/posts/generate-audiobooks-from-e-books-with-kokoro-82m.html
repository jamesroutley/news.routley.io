<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://claudio.uk/posts/epub-to-audiobook.html">Original</a>
    <h1>Generate audiobooks from E-books with Kokoro-82M</h1>
    
    <div id="readability-page-1" class="page"><div>
    <header>

        
        <nav>
            <a href="https://kracekumar.com/">üôã‚Äç‚ôÇÔ∏èÔ∏èAbout</a>
            <!--        <a href="/call.html">Book a call</a>-->
            <a href="https://kracekumar.com/posts.html">üìñ Writings</a>
        </nav>
    </header>
    


<p>Posted on 14 Jan 2025 by Claudio Santini</p>
<p><a href="https://huggingface.co/hexgrad/Kokoro-82M">Kokoro v0.19</a> is a recently published text-to-speech model with just 82M params and very high-quality output.
It&#39;s released under Apache licence and was trained on &lt;100 hours of audio.
It currently supports american, british english, french, korean, japanese and mandarin, in a bunch of very good voices.</p>
<p>An example of the quality:</p>

<p>I&#39;ve always dreamed of converting my ebook library into audiobooks. Especially for those niche books that you cannot find in audiobook format.
Since Kokoro is pretty fast, I thought this may finally be
doable. I&#39;ve created a small tool called Audiblez (in honor of the popular audiobook platform) that parses .epub files and converts the
body of the book into nicely narrated audio files.</p>
<p>On my M2 MacBook Pro, <strong>it takes about 2 hours to convert to mp3 the Selfish Gene by Richard Dawkins</strong>, which is about 100,000 words (or 600,000 characters),
at a rate of about 80 characters per second.</p>
<h2>How to install and run</h2>
<p>If you have Python 3 on your computer, you can install it with pip.
Be aware that it won&#39;t work with Python 3.13.</p>
<p>Then you also need to download a couple of additional files in the same folder, which are about ~360MB:</p>
<pre><code>pip install audiblez
wget https://github.com/thewh1teagle/kokoro-onnx/releases/download/model-files/kokoro-v0_19.onnx
wget https://github.com/thewh1teagle/kokoro-onnx/releases/download/model-files/voices.json
</code></pre>
<p>Then, to convert an epub file into an audiobook, just run:</p>
<pre><code>audiblez book.epub -l en-gb -v af_sky
</code></pre>
<p>It will first create a bunch of <code>book_chapter_1.wav</code>, <code>book_chapter_2.wav</code>, etc. files in the same directory,
and at the end it will produce a <code>book.m4b</code> file with the whole book you can listen with VLC or any
audiobook player.
It will only produce the <code>.m4b</code> file if you have <code>ffmpeg</code> installed on your machine.</p>
<h2>Supported Languages</h2>
<p>Use <code>-l</code> option to specify the language, available language codes are:
üá∫üá∏ <code>en-us</code>, üá¨üáß <code>en-gb</code>, üá´üá∑ <code>fr-fr</code>, üáØüáµ <code>ja</code>, üá∞üá∑ <code>kr</code> and üá®üá≥ <code>cmn</code>.</p>
<h2>Supported Voices</h2>
<p>Use <code>-v</code> option to specify the voice:
available voices are <code>af</code>, <code>af_bella</code>, <code>af_nicole</code>, <code>af_sarah</code>, <code>af_sky</code>, <code>am_adam</code>, <code>am_michael</code>, <code>bf_emma</code>, <code>bf_isabella</code>, <code>bm_george</code>, <code>bm_lewis</code>.
You can try them here: <a href="https://huggingface.co/spaces/hexgrad/Kokoro-TTS">https://huggingface.co/spaces/hexgrad/Kokoro-TTS</a></p>
<h2>Chapter Detection</h2>
<p>Chapter detection is a bit janky, but it manages to find the core chapters in most .epub I tried, skipping
the cover, index, appendix etc.</p>
<h2>Source</h2>
<p>See <a href="https://github.com/santinic/audiblez">Audiblez project on GitHub</a>.</p>
<p>There are still some rough edges, but it works well enough for me. Future improvements could include:</p>
<ul>
<li>Better chapter detection, or allow users to include/exclude chapters.</li>
<li>Add chapter navigation to m4b file (that looks hard, cause ffmpeg doesn&#39;t do it)</li>
<li>Add narration for images using some image-to-text model</li>
</ul>
<p>Code is short enough to be included here:</p>
<pre><code>#!/usr/bin/env python3
# audiblez - A program to convert e-books into audiobooks using
# Kokoro-82M model for high-quality text-to-speech synthesis.
# by Claudio Santini 2025 - https://claudio.uk

import argparse
import sys
import time
import shutil
import subprocess
import soundfile as sf
import ebooklib
import warnings
import re
from pathlib import Path
from string import Formatter
from bs4 import BeautifulSoup
from kokoro_onnx import Kokoro
from ebooklib import epub
from pydub import AudioSegment


def main(kokoro, file_path, lang, voice):
    filename = Path(file_path).name
    with warnings.catch_warnings():
        book = epub.read_epub(file_path)
    title = book.get_metadata(&#39;DC&#39;, &#39;title&#39;)[0][0]
    creator = book.get_metadata(&#39;DC&#39;, &#39;creator&#39;)[0][0]
    intro = f&#39;{title} by {creator}&#39;
    print(intro)
    chapters = find_chapters(book)
    print(&#39;Found chapters:&#39;, [c.get_name() for c in chapters])
    texts = extract_texts(chapters)
    has_ffmpeg = shutil.which(&#39;ffmpeg&#39;) is not None
    if not has_ffmpeg:
        print(&#39;\033[91m&#39; + &#39;ffmpeg not found. Please install ffmpeg to create mp3 and m4b audiobook files.&#39; + &#39;\033[0m&#39;)
    total_chars = sum([len(t) for t in texts])
    print(&#39;Started at:&#39;, time.strftime(&#39;%H:%M:%S&#39;))
    print(f&#39;Total characters: {total_chars:,}&#39;)
    print(&#39;Total words:&#39;, len(&#39; &#39;.join(texts).split(&#39; &#39;)))

    i = 1
    chapter_mp3_files = []
    for text in texts:
        chapter_filename = filename.replace(&#39;.epub&#39;, f&#39;_chapter_{i}.wav&#39;)
        chapter_mp3_files.append(chapter_filename)
        if Path(chapter_filename).exists():
            print(f&#39;File for chapter {i} already exists. Skipping&#39;)
            i += 1
            continue
        print(f&#39;Reading chapter {i} ({len(text):,} characters)...&#39;)
        if i == 1:
            text = intro + &#39;.\n\n&#39; + text
        start_time = time.time()
        samples, sample_rate = kokoro.create(text, voice=voice, speed=1.0, lang=lang)
        sf.write(f&#39;{chapter_filename}&#39;, samples, sample_rate)
        end_time = time.time()
        delta_seconds = end_time - start_time
        chars_per_sec = len(text) / delta_seconds
        remaining_chars = sum([len(t) for t in texts[i - 1:]])
        remaining_time = remaining_chars / chars_per_sec
        print(f&#39;Estimated time remaining: {strfdelta(remaining_time)}&#39;)
        print(&#39;Chapter written to&#39;, chapter_filename)
        print(f&#39;Chapter {i} read in {delta_seconds:.2f} seconds ({chars_per_sec:.0f} characters per second)&#39;)
        progress = int((total_chars - remaining_chars) / total_chars * 100)
        print(&#39;Progress:&#39;, f&#39;{progress}%&#39;)
        i += 1
    if has_ffmpeg:
        create_m4b(chapter_mp3_files, filename)


def extract_texts(chapters):
    texts = []
    for chapter in chapters:
        xml = chapter.get_body_content()
        soup = BeautifulSoup(xml, features=&#39;lxml&#39;)
        chapter_text = &#39;&#39;
        html_content_tags = [&#39;title&#39;, &#39;p&#39;, &#39;h1&#39;, &#39;h2&#39;, &#39;h3&#39;, &#39;h4&#39;]
        for child in soup.find_all(html_content_tags):
            inner_text = child.text.strip() if child.text else &#34;&#34;
            if inner_text:
                chapter_text += inner_text + &#39;\n&#39;
        texts.append(chapter_text)
    return texts


def is_chapter(c):
    name = c.get_name().lower()
    part = r&#34;part\d{1,3}&#34;
    if re.search(part, name):
        return True
    ch = r&#34;ch\d{1,3}&#34;
    if re.search(ch, name):
        return True
    if &#39;chapter&#39; in name:
        return True


def find_chapters(book, verbose=True):
    chapters = [c for c in book.get_items() if c.get_type() == ebooklib.ITEM_DOCUMENT and is_chapter(c)]
    if verbose:
        for item in book.get_items():
            if item.get_type() == ebooklib.ITEM_DOCUMENT:
                # print(f&#34;&#39;{item.get_name()}&#39;&#34; + &#39;, #&#39; + str(len(item.get_body_content())))
                print(f&#39;{item.get_name()}&#39;.ljust(60), str(len(item.get_body_content())).ljust(15), &#39;X&#39; if item in chapters else &#39;-&#39;)
    if len(chapters) == 0:
        print(&#39;Not easy to find the chapters, defaulting to all available documents.&#39;)
        chapters = [c for c in book.get_items() if c.get_type() == ebooklib.ITEM_DOCUMENT]
    return chapters


def strfdelta(tdelta, fmt=&#39;{D:02}d {H:02}h {M:02}m {S:02}s&#39;):
    remainder = int(tdelta)
    f = Formatter()
    desired_fields = [field_tuple[1] for field_tuple in f.parse(fmt)]
    possible_fields = (&#39;W&#39;, &#39;D&#39;, &#39;H&#39;, &#39;M&#39;, &#39;S&#39;)
    constants = {&#39;W&#39;: 604800, &#39;D&#39;: 86400, &#39;H&#39;: 3600, &#39;M&#39;: 60, &#39;S&#39;: 1}
    values = {}
    for field in possible_fields:
        if field in desired_fields and field in constants:
            values[field], remainder = divmod(remainder, constants[field])
    return f.format(fmt, **values)


def create_m4b(chaptfer_files, filename):
    tmp_filename = filename.replace(&#39;.epub&#39;, &#39;.tmp.m4a&#39;)
    if not Path(tmp_filename).exists():
        combined_audio = AudioSegment.empty()
        for wav_file in chaptfer_files:
            audio = AudioSegment.from_wav(wav_file)
            combined_audio += audio
        print(&#39;Converting to Mp4...&#39;)
        combined_audio.export(tmp_filename, format=&#34;mp4&#34;, codec=&#34;aac&#34;, bitrate=&#34;64k&#34;)
    final_filename = filename.replace(&#39;.epub&#39;, &#39;.m4b&#39;)
    print(&#39;Creating M4B file...&#39;)
    proc = subprocess.run([&#39;ffmpeg&#39;, &#39;-i&#39;, f&#39;{tmp_filename}&#39;, &#39;-c&#39;, &#39;copy&#39;, &#39;-f&#39;, &#39;mp4&#39;, f&#39;{final_filename}&#39;])
    Path(tmp_filename).unlink()
    if proc.returncode == 0:
        print(f&#39;{final_filename} created. Enjoy your audiobook.&#39;)
        print(&#39;Feel free to delete the intermediary .wav chapter files, the .m4b is all you need.&#39;)


def cli_main():
    if not Path(&#39;kokoro-v0_19.onnx&#39;).exists() or not Path(&#39;voices.json&#39;).exists():
        print(&#39;Error: kokoro-v0_19.onnx and voices.json must be in the current directory. Please download them with:&#39;)
        print(&#39;wget https://github.com/thewh1teagle/kokoro-onnx/releases/download/model-files/kokoro-v0_19.onnx&#39;)
        print(&#39;wget https://github.com/thewh1teagle/kokoro-onnx/releases/download/model-files/voices.json&#39;)
        sys.exit(1)
    kokoro = Kokoro(&#39;kokoro-v0_19.onnx&#39;, &#39;voices.json&#39;)
    voices = list(kokoro.get_voices())
    voices_str = &#39;, &#39;.join(voices)
    epilog = &#39;example:\n&#39; + \
             &#39;  audiblez book.epub -l en-us -v af_sky&#39;
    default_voice = &#39;af_sky&#39; if &#39;af_sky&#39; in voices else voices[0]
    parser = argparse.ArgumentParser(epilog=epilog, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument(&#39;epub_file_path&#39;, help=&#39;Path to the epub file&#39;)
    parser.add_argument(&#39;-l&#39;, &#39;--lang&#39;, default=&#39;en-gb&#39;, help=&#39;Language code: en-gb, en-us, fr-fr, ja, ko, cmn&#39;)
    parser.add_argument(&#39;-v&#39;, &#39;--voice&#39;, default=default_voice, help=f&#39;Choose narrating voice: {voices_str}&#39;)
    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)
    args = parser.parse_args()
    main(kokoro, args.epub_file_path, args.lang, args.voice)


if __name__ == &#39;__main__&#39;:
    cli_main()
</code></pre>

<br/>



    
</div></div>
  </body>
</html>
