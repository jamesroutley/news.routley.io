<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/oldnewthing/20250606-00/?p=111254">Original</a>
    <h1>Why does C&#43;&#43; think my class is copy-constructible when it can&#39;t be?</h1>
    
    <div id="readability-page-1" class="page"><div id="single-wrapper">
    
    <article data-clarity-region="article" id="post-111254">
        <div data-bi-area="body_article" data-bi-id="post_page_body_article">
            <p>Consider the following scenario:</p>
<pre>template&lt;typename T&gt;
struct Base
{
    // Default-constructible
    Base() = default;

    // Not copy-constructible
    Base(Base const &amp;) = delete;
};

template&lt;typename T&gt;
struct Derived : Base&lt;T&gt;
{
    Derived() = default;
    Derived(Derived const&amp; d) : Base<a title="Why can&#39;t I find the injected name of a templated class&#39;s templated base class?" href="https://devblogs.microsoft.com/oldnewthing/20240517-00/?p=109774">&lt;T&gt;</a>(d) {}
};

// This assertion passes?
static_assert(
    std::is_copy_constructible_v&lt;Derived&lt;int&gt;&gt;);
</pre>
<p>Why does this assertion pass? It is plainly evident that you cannot copy a <code>Derived&lt;int&gt;</code> because doing so will try to copy the <code>Base&lt;int&gt;</code>, which is not copyable. Indeed, if you try to copy it, you get an error:</p>
<pre>void example(Derived&lt;int&gt;&amp; d)
{
    Derived&lt;int&gt; d2(d);
    // msvc: error C2280: &#39;Base&lt;T&gt;::Base(const Base&lt;T&gt; &amp;)&#39;:
    //       attempting to reference a deleted function
    // gcc:  error: use of deleted function &#39;Base&lt;T&gt;::Base(const Base&lt;T&gt;&amp;)
    //       [with T = int]&#39;
    // clang: error: call to deleted constructor of &#39;Base&lt;int&gt;&#39;
}
</pre>
<p>Okay, so the compiler thinks that <code>Derived&lt;int&gt;</code> is copy-constructible, but then when we try to do it, we find out that it isn’t!</p>
<p>What’s going on is that the compiler is determining copy-constructibility by checking whether the class has a non-deleted copy constructor. And in the case of <code>Derived&lt;T&gt;</code> it does haev a non-deleted copy constructor. You declared it yourself!</p>
<pre>    Derived(Derived const&amp; d) : Base&lt;T&gt;(d) {}
</pre>
<p>So yes, there is a copy constructor. It can’t be instantiated, but the compiler doesn’t care. It is going based on what you tell it, and you told it that you can copy it.</p>
<p>After all, another possibly copy constructor would have been</p>
<pre>    Derived(Derived const&amp; d) : Base&lt;T&gt;() {}
</pre>
<p>and this one instantiates successfully. Copying a <code>Derived</code> default-constructs the <code>Base</code> base class rather than copy-constructing it.</p>
<p>Imagine that we moved the definition out of line.</p>
<pre>template&lt;typename T&gt;
struct Derived : Base&lt;T&gt;
{
    Derived() = default;
    Derived(Derived const&amp; d);
};
</pre>
<p>What should the answer to the question “Is this copy-constructible?” be? You don’t know what the definition is, only its declaration. Should the compiler halt compilation with the error message “Unable to predict the future”? But what if you didn’t want the expose the implementation of the copy constructor in the header file?</p>
<p>The rule for determining copy constructibility is whether a non-deleted copy constructor is present. In the case of <code>Derived</code>, it is present. It may not be instantiatable, but that’s not what <code>is_<wbr/>copy_<wbr/>constructible</code> looks for.¹</p>
<p>Now, non-copyability inherits by default, so we could have just allowed the copy constructor to be defaulted:</p>
<pre>template&lt;typename T&gt;
struct Derived : Base&lt;T&gt;
{
    Derived() = default;
    Derived(Derived const&amp; d) <span>= default</span>;
};
</pre>
<p>The implicitly-defined or explicitly-defaulted copy constructor is defined as deleted if any base class is not copy-constructible, in which case the declaration is treated as if it had said <code>= delete</code>. That <code>= delete</code> can be detected by <code>is_<wbr/>copy_<wbr/>constructible</code> and result in the assertion failing.</p>
<p>But if you come out and make a custom copy constructor that is not deleted, the compiler assumes you will make good on your promise.</p>
<p><b>Related reading</b>: <a title="Why does std::is_copy_constructible report that a vector of move-only objects is copy constructible?" href="https://devblogs.microsoft.com/oldnewthing/20190926-00/?p=102924"> Why does <code>std::<wbr/>is_<wbr/>copy_<wbr/>constructible</code> report that a vector of move-only objects is copy constructible</a>?</p>
<p>¹ Requiring that the type be complete <i>and all members defined</i> is not a reasonable requirement because that would require definitions of all class methods to be present in header files. Your entire program has been reduced to a header-only project.</p>
        </div><!-- .entry-content -->

        <!-- AI Disclaimer -->
            </article>
    
</div></div>
  </body>
</html>
