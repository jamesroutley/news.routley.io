<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2025/11/09/error-ABI.html">Original</a>
    <h1>Error ABI</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        <header>
          
          <time datetime="2025-11-09">Nov 9, 2025</time>
        </header>
        <p>
          A follow-up on the
          <a href="https://matklad.github.io/2025/11/06/error-codes-for-control-flow.html">“strongly typed error codes”</a>
          article.
        </p>
        <p>
          One common argument about using algebraic data types for errors is
          that:
        </p>
        <ol type="A">
          <li>
            Error information is only filled in when an error occurs,
          </li>
          <li>
            And errors happen rarely, on the cold path,
          </li>
          <li>
            Therefore, filling in the diagnostic information is essentially
            free, a zero cost abstraction.
          </li>
        </ol>
        <p>
          This argument is not entirely correct. Naively composing errors out of
          ADTs does pessimize the happy path. Error objects recursively composed
          out of enums tend to be big, which inflates
          <code>size_of&lt;Result&lt;T, E&gt;&gt;</code>, which pushes functions
          throughout the call stack to “return large structs through memory”
          ABI. Error virality is key here — just a single large error on however
          rare code path leads to worse code everywhere.
        </p>
        <p>
          That is the reason why mature error handling libraries hide the error
          behind a thin pointer, approached pioneered in Rust by
          <a href="https://github.com/rust-lang-deprecated/failure/blob/0.1.3/src/small_error.rs#L27-L31"><code>failure</code></a>
          and deployed across the ecosystem in
          <a href="https://github.com/dtolnay/anyhow/blob/3d65a7849c79b3faf9e731eda553cadcc98985a2/src/error.rs#L367-L374"><code>anyhow</code></a>. But this requires global allocator, which is
          also not entirely zero cost.
        </p>
        <section id="Choices">
          <h2><a href="#Choices">Choices</a></h2>
          <p>
            How would you even return a result? The default option is to treat
            <code>-&gt; Result&lt;T, E&gt;</code> as any other user-defined data
            type: goes to registers if small, goes to the stack memory if large.
            As described above, this is suboptimal, as it spills small hot
            values to memory because of large cold errors.
          </p>
          <p>
            A smarter way to do this is to say that the ABI of <code>-&gt;
              Result&lt;T, E&gt;</code> is exactly the same as <code>T</code>,
            except that a single register is reserved for <code>E</code> (this
            requires the errors to be register-sized). On architectures with
            status flags, one can even signal a presence of error via, e.g., the
            overflow flag.
          </p>
          <p>
            Finally, another option is to say that <code>-&gt; Result&lt;T,
              E&gt;</code> behaves <em>exactly</em> as <code>-&gt; T</code>
            ABI-wise, no error affordances whatsoever. Instead, when <em>returning</em> an error, rather than jumping to the return address,
            we look it up in the side table to find a corresponding error
            recovery address, and jump to
            <em>that</em>. Stack unwinding!
          </p>
          <p>
            The bold claim is that unwinding is the optimal thing to do! I don’t
            know of a good set of reproducible benchmarks, but I find these two
            sources believable:
          </p>
          <ul>
            <li>
              <a href="https://joeduffyblog.com/2015/12/19/safe-native-code/#error-model">https://joeduffyblog.com/2015/12/19/safe-native-code/#error-model</a>
            </li>
            <li>
              <a href="https://youtu.be/LorcxyJ9zr4?si=HESn1LfHek5Qlfi0">https://youtu.be/LorcxyJ9zr4?si=HESn1LfHek5Qlfi0</a>
            </li>
          </ul>
          <p>
            As with async, keep visible programming model and internal
            implementation details separate!
            <code>Result&lt;T, E&gt;</code> can be implemented via stack
            unwinding, and exceptions can be implemented via checking the return
            value.
          </p>
        </section>
        <section id="Conclusion">
          <h2><a href="#Conclusion">Conclusion</a></h2>
          <p>
            Your error ABI probably wants to be special, so the compiler needs
            to know about errors. If your language is exceptional in supporting
            flexible user-defined types and control flow, you probably want to
            special case only in the backend, and otherwise use a plain
            user-defined type. If your language is at most medium in abstraction
            capabilities, it probably makes sense to make errors first-class in
            the surface semantics as well.
          </p>
        </section>
      </article>
    </div></div>
  </body>
</html>
