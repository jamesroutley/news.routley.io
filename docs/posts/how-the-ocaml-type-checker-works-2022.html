<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://okmij.org/ftp/ML/generalization.html">Original</a>
    <h1>How the OCaml type checker works (2022)</h1>
    
    <div id="readability-page-1" class="page"><div>This section continues the exposition of the ideas behind Rémy&#39;s
algorithm and presents <code>sound_lazy</code>: an optimized version of
<code>sound_eager</code> from the previous section. The <code>sound_lazy</code> algorithm
eschews repeated, unnecessary traversals of a type during unification,
generalization and instantiation, and avoids copying the parts
that do not contain variables to generalize or instantiate, thus
improving sharing. The algorithm delays the occurs check and the level
updates, so that the unification with a free type variable takes
constant time. Levels are updated incrementally and on demand. All in
all, <code>sound_lazy</code> embodies the main ideas of Rémy&#39;s algorithm. Some of
these ideas are implemented in the OCaml type checker.
<p>To carry on the optimizations, we change the syntax of types. Recall
that in <code>sound_eager</code>, types were comprised of free or bound type
variables <code>TVar</code>, (implicitly universally) quantified type variables
<code>QVar</code> and function types <code>TArrow</code>. The first, seemingly unprincipled
change, is to eliminate <code>QVar</code> as a distinct alternative and dedicate
a very large positive integer -- which should be treated as the
inaccessible ordinal ω -- as a <code>generic_level</code>.  A free type variable
<code>TVar</code> at <code>generic_level</code> is taken to be a quantified type
variable. More substantially, all types, not only free type variables,
have levels now. The level of a composite type (<code>TArrow</code> in our case)
is an upper, not necessarily exact, bound on the levels of its
components. In other words, if a type belongs to an alive region, all
its components should be alive.  It immediately follows that if a
(composite) type is at <code>generic_level</code>, it may contain quantified type
variables.  Contrapositively, if a type is not at <code>generic_level</code>, it
does not contain any quantified variable. Therefore, instantiating
such a type should return the type as it is without traversing
it. Likewise, if the level of a type is greater than the current
level, it may contain free type variables to generalize. On the other
hand, the generalization function should not even bother traversing a
type whose level is equal or less than the current. This is the first
example of how levels help eliminate excessive traversals and
rebuildings of a type, improving sharing.
</p><p>Unifying a type with a free type variable should update the type&#39;s level
to the level of the type variable if the latter level is smaller. For a
composite type, such an update means recursively updating the 
levels of all components of the type. To postpone costly traversals, we 
give composite types two levels: <code>level_old</code> is an upper
bound on the levels of type&#39;s components; <code>level_new</code>, which is less or
equal to <code>level_old</code>, is the level the type should have after the update.
If <code>level_new &lt; level_old</code>, the type has pending level updates. The
syntax of types in <code>sound_lazy</code> is thus

</p><pre>    type level = int
    let generic_level = 100000000           (* as in OCaml typing/btype.ml *)
    let marked_level  = -1                  (* for marking a node, to check*)
                                            (* for cycles                  *)
    type typ = 
      | TVar of tv ref
      | TArrow of typ * typ * levels
    and tv = Unbound of string * level | Link of typ
    and levels = {mutable level_old : level; mutable level_new : level}
</pre>
<p>We have not explained <code>marked_level</code>. The occurs check on each
unification with a free type variable is expensive, raising the
algorithmic complexity of the unification and type checking. We now
postpone this check, until the whole expression is type checked. In
the meanwhile, unification may create cycles in types. Type traversals
have to check for cycles, or risk divergence. The <code>marked_level</code> is
assigned temporarily to <code>level_new</code> of a composite type to indicate
the type is being traversed. Encountering <code>marked_level</code> during a
traversal means detecting a cycle, which raises the occurs check
error. Incidentally, in OCaml types are generally cyclic:
(equi-)recursive types arise when type checking objects and
polymorphic variants, and when the <code>-rectypes</code> compiler option is set.  The
OCaml type checker uses a similar marked-level trick to detect cycles
and avoid divergence.
</p><p>The <code>sound_lazy</code> unification has several important differences 
from <code>sound_eager</code>:

</p><pre>    let rec unify : typ -&gt; typ -&gt; unit = fun t1 t2 -&gt;
      if t1 == t2 then ()                   (* t1 and t2 are physically the same *)
      else match (repr t1,repr t2) with
      | (TVar ({contents = Unbound (_,l1)} as tv1) as t1,      (* unify two free vars *)
        (TVar ({contents = Unbound (_,l2)} as tv2) as t2)) -&gt;
         if tv1 == tv2 then ()             (* the same variable *)
         else
           if l1 &gt; l2 then tv1 := Link t2 else tv2 := Link t1  (* bind the higher-level var *)
      | (TVar ({contents = Unbound (_,l)} as tv),t&#39;)
      | (t&#39;,TVar ({contents = Unbound (_,l)} as tv)) -&gt; 
          update_level l t&#39;;
          tv := Link t&#39;
      | (TArrow (tyl1,tyl2,ll), TArrow (tyr1,tyr2,lr)) -&gt;
          if ll.level_new = marked_level || lr.level_new = marked_level then
            failwith &#34;cycle: occurs check&#34;;
          let min_level = min ll.level_new lr.level_new in
          ll.level_new &lt;- marked_level; lr.level_new &lt;- marked_level;
          unify_lev min_level tyl1 tyr1;
          unify_lev min_level tyl2 tyr2;
          ll.level_new &lt;- min_level; lr.level_new &lt;- min_level
      (* everything else is the unification error *)
   
    and unify_lev l ty1 ty2 =
      let ty1 = repr ty1 in
      update_level l ty1;
      unify ty1 ty2
</pre>where the auxiliary <code>repr</code>, like OCaml&#39;s <code>Btype.repr</code>, chases links of
bound variables returning a free variable or a constructed type.
Unlike OCaml, we do path compression.  The unification function no
longer does the occurs check; therefore, it has to make an effort to
detect accidentally created cycles. Unifying with a free variable now
takes constant time, to bind the variable after a shallow
<code>update_level</code>.
<p>The function <code>update_level</code> is one of the key parts of the optimized
algorithm. Often, it merely promises to update the level of a type to 
the given level. It works in
constant time and maintains the invariant that a type level may
only decrease. The level of a type variable is updated immediately.
For a composite type, <code>level_new</code> is
set to the desired new level if the latter is smaller. In
addition, if previously <code>level_new</code> and <code>level_old</code> were the same, the
type is put into the <code>to_be_level_adjusted</code> queue for later 
update of the levels of the components. This work queue is akin to
the list of assignments into the old generation from the young
maintained by a generational garbage collector (such as the one in
OCaml). 

</p><pre>    let to_be_level_adjusted = ref []
   
    let update_level : level -&gt; typ -&gt; unit = fun l -&gt; function
      | TVar ({contents = Unbound (n,l&#39;)} as tvr) -&gt; 
          assert (not (l&#39; = generic_level));
          if l &lt; l&#39; then
            tvr := Unbound (n,l)
      | TArrow (_,_,ls) as ty -&gt; 
          assert (not (ls.level_new = generic_level));
          if ls.level_new = marked_level then failwith &#34;occurs check&#34;;
          if l &lt; ls.level_new then begin
            if ls.level_new = ls.level_old then
              to_be_level_adjusted := ty :: !to_be_level_adjusted;
            ls.level_new &lt;- l
          end
      | _ -&gt; assert false
</pre>
<p>The pending level updates must be performed before generalization:
After all, a pending update may decrease the level of a type variable,
promoting it to a wider region and hence saving it from
quantification. Not all pending updates have to be forced however --
only of those types whose <code>level_old &gt; current_level</code>. Otherwise, a
type contains no variables generalizable at the present point, and the
level update may be delayed further. The described forcing algorithm
is implemented by <code>force_delayed_adjustments</code>, see the source
code. Incidentally, if a level update of a composite type (<code>TArrow</code>)
has to be really performed, the type has to be traversed.  Unification
of two <code>TArrow</code> types also has to traverse them. Therefore,
unification could, in principle, also update the levels along the
way. That optimization is not currently implemented, however.
</p><p>The generalization function searches for free <code>TVar</code>s that belong to a
dead region (that is, whose level is greater than the current) and
sets their level to <code>generic_level</code>, hence quantifying the
variables. The function traverses only those parts of the type that
may contain type variables to generalize. If a type has the (new)
level of <code>current_level</code> or smaller, all its components belong to live
regions and hence the type has nothing to generalize.  After the
generalization, a composite type receives <code>generic_level</code> if it
contains a quantified type variable. Later on, the instantiation
function will, therefore, only look through those types whose
level is <code>generic_level</code>.

</p><pre>    let gen : typ -&gt; unit = fun ty -&gt;
      force_delayed_adjustments ();
      let rec loop ty =
        match repr ty with
        | TVar ({contents = Unbound (name,l)} as tvr)
               when l &gt; !current_level -&gt;
          tvr := Unbound (name,generic_level)
        | TArrow (ty1,ty2,ls) when ls.level_new &gt; !current_level -&gt;
          let ty1 = repr ty1 and ty2 = repr ty2 in
          loop ty1; loop ty2;
          let l = max (get_level ty1) (get_level ty2) in
          ls.level_old &lt;- l; ls.level_new &lt;- l   (* set the exact level upper bound *)
        | _ -&gt; ()
      in loop ty
</pre>
<p>The type checker <code>typeof</code> remains the same, entering a new region when
type checking a <code>let</code> expression. Please see the source code for details.
</p><p>We have presented the optimized <code>sound_lazy</code> type generalization algorithm
that avoids not only scanning the whole type environment on each
generalization, but also the occurs check on each
unification with a free type variable. In the result, unification takes
constant time. The algorithm eliminates unnecessary type traversals
and copying, saving time and memory.  Two ideas underlie the
optimizations, besides the type levels for free type variables. First
is the assigning of levels to composite types, to give us an idea what
a type may contain without looking though it. The second principle is
delaying expensive actions (type traversals) with the hope they will
get done in the future alongside of something else. In other words, if
dealing with a problem is postponed long enough, it may go away:
procrastination sometimes helps.</p></div></div>
  </body>
</html>
