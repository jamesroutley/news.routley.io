<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.righto.com/2023/03/8086-register-codes.html">Original</a>
    <h1>Reverse-engineering the register codes for the 8086 processor&#39;s microcode</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-276186601431337636" itemprop="description articleBody">



<p>Like most processors, the Intel 8086 (1978) provides registers that are faster than main memory.
As well as the registers that are visible to the programmer, the 8086 has a handful of internal registers that are hidden from the user.
Internally, the 8086 has a complicated scheme to select which register to use, with a combination of microcode and hardware.
Registers are assigned a 5-bit identifying number, either from the machine instruction or from the microcode.
In this blog post, I explain how this register system works.</p>
<p>My analysis is based on reverse-engineering the 8086 from die photos. The die photo below shows the chip under a microscope.
For this die photo, I removed the the metal and polysilicon layers, revealing the silicon underneath.
I&#39;ve labeled the key functional blocks; the ones that are important to this post are darker.
In particular, the registers and the Arithmetic/Logic Unit (ALU) are at the left and the microcode ROM is in the lower right.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top and an Execution Unit (EU) below.
The BIU handles bus and memory activity as well as instruction prefetching, while the Execution Unit (EU) executes the instructions.</p>
<p><a href="https://static.righto.com/images/8086-registers/die-labeled2.jpg"><img alt="The 8086 die under a microscope, with main functional blocks labeled.  Click on this image (or any other) for a larger version." height="634" src="https://static.righto.com/images/8086-registers/die-labeled2-w600.jpg" title="The 8086 die under a microscope, with main functional blocks labeled.  Click on this image (or any other) for a larger version." width="600"/></a></p><p>The 8086 die under a microscope, with main functional blocks labeled.  Click on this image (or any other) for a larger version.</p>
<h2>Microcode</h2>
<p>Most people think of machine instructions as the basic steps that a computer performs.
However, many processors (including the 8086) have another layer of software underneath: microcode.
With microcode, instead of building the control circuitry from complex logic gates, the control logic is largely replaced with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.</p>
<p>The 8086 uses a hybrid approach: although it uses microcode, much of the instruction functionality is implemented with gate logic.
This approach removed duplication from the microcode and kept the microcode small enough for 1978 technology.
In a sense, the microcode is parameterized.
For instance, the microcode can specify a generic Arithmetic/Logic Unit (ALU) operation and a generic register.
The gate logic examines the instruction to determine which specific operation to perform and the appropriate register.</p>
<p>A micro-instruction in the 8086 is encoded into 21 bits as shown below.
Every micro-instruction has a move from a source register to a destination register, each specified with 5 bits; this encoding is the
main topic of this blog post.
The meaning of the remaining bits depends on the type field and can be anything from an ALU operation to a memory read or write to
a change of microcode control flow.
For more about 8086 microcode, see my <a href="https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html">microcode blog post</a>.</p>
<p><a href="https://static.righto.com/images/8086-registers/microcode-format.jpg"><img alt="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" height="203" src="https://static.righto.com/images/8086-registers/microcode-format-w700.jpg" title="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" width="700"/></a></p>
<p>Let&#39;s look at how the machine instruction <code>XCHG AX,reg</code> is implemented in microcode. This instruction exchanges <code>AX</code> with the register specified in the low 3 bits
of the instruction.<span id="fnref:nop"><a href="#fn:nop">1</a></span>
The microcode for this instruction consists of three micro-instructions, so the instruction takes three clock cycles.
Each micro-instruction contains a move, which is the interesting part.<span id="fnref:action"><a href="#fn:action">2</a></span>
The specified register is moved to the ALU&#39;s temporary B register, the <code>AX</code> register is moved to the specified register, and finally
the temporary B is moved to <code>AX</code>, completing the swap.</p>
<pre> move       action
M → tmpB           <span><b>XCHG AX,rw</b>: move reg to tmpB</span>
AX → M      NXT     <span>move AX to reg, Next to last</span>
tmpB → AX   RNI     <span>move tmpB to AX, Run Next Instruction</span>
</pre>

<p>The key part for this discussion is how <code>M</code> indicates the desired register.
Suppose the instruction is <code>XCHG AX,DX</code>. The bottom three bits of the instruction are <code>010</code>, indicating <code>DX</code>.
During the first clock cycle of instruction execution, the opcode byte is transferred from the prefetch queue over the queue bus.
The <code>M</code> register is loaded with the <code>DX</code> number (which happens to be 26), based on the bottom three bits of the instruction.
After a second clock cycle, the microcode starts.
The first micro-instruction puts <code>M</code>&#39;s value (26) onto the source bus and the number for <code>tmpB</code> (13) on the destination bus, causing the transfer from
<code>DX</code> to <code>tmpB</code>.
The second micro-instruction puts the <code>AX</code> number (24) onto the source bus and the <code>M</code> value (26) onto the destination bus, causing the transfer from <code>AX</code> to <code>DX</code>.
The third micro-instruction puts <code>tmpB</code> number (13) onto the source bus and the <code>AX</code> number (24) onto the destination bus, causing the transfer from <code>tmpB</code> to <code>AX</code>.</p>
<p>Thus, the values on the source and destination bus control the data transfer during each micro-instruction. Microcode can either specify these values explicitly
(as for <code>AX</code> and <code>tmpB</code>) or can specify the <code>M</code> register to use the register defined in the instruction.
Thus, the same microcode implements all the <code>XCHG</code> instructions and the microcode doesn&#39;t need to know which register is involved.</p>
<h2>The register encoding</h2>
<p>The microcode above illustrated how different numbers specified different registers.
The table below shows how the number 0-31 maps onto a register.
Some numbers have a different meaning for a source register or a destination register; a slash separates these entries.</p>


<table id="src">
<tbody><tr><td>0</td><td>ES</td><td>8</td><td>AL</td><td>16</td><td>AH</td><td></td><td>24</td><td>AX</td>
</tr><tr><td>1</td><td>CS</td><td>9</td><td>CL</td><td>17</td><td>CH</td><td></td><td>25</td><td>CX</td>
</tr><tr><td>2</td><td>SS</td><td>10</td><td>DL</td><td>18</td><td>DH</td><td>(M)</td><td>26</td><td>DX</td>
</tr><tr><td>3</td><td>DS</td><td>11</td><td>BL</td><td>19</td><td>BH</td><td>(N)</td><td>27</td><td>BX</td>
</tr><tr><td>4</td><td>PC</td><td>12</td><td>tmpA</td><td>20</td><td colspan="2">Σ/tmpAL</td><td>28</td><td>SP</td>
</tr><tr><td>5</td><td>IND</td><td>13</td><td>tmpB</td><td>21</td><td colspan="2">ONES/tmpBL</td><td>29</td><td>BP</td>
</tr><tr><td>6</td><td>OPR</td><td>14</td><td>tmpC</td><td>22</td><td colspan="2">CR/tmpAH</td><td>30</td><td>SI</td>
</tr><tr><td>7</td><td>Q/-</td><td>15</td><td>F</td><td>23</td><td colspan="2">ZERO/tmpBH</td><td>31</td><td>DI</td>
</tr></tbody></table>

<p>Most of these entries are programmer-visible registers: the segment registers are in green, the 8-bit registers in blue, and the 16-bit registers
in red.
Some internal registers and pseudo-registers are also accessible:
<code>IND</code> (Indirect register), holding the memory address for a read or write;
<code>OPR</code> (Operand register), holding the data for a read or write;
<code>Q</code> (Queue), reading a byte from the instruction prefetch queue;
ALU temporary registers A, B, and C, along with low (L) and (H) bytes;
<code>F</code>, Flags register;
<code>Σ</code>, the ALU output;
<code>ONES</code>, all ones;
<code>CR</code>, the three low bits of the microcode address;
and <code>ZERO</code>, the value zero. The <code>M</code> and <code>N</code> entries can only be specified from microcode, taking the place of <code>DH</code> and <code>BH</code>.</p>
<p>The table is kind of complicated, but there are reasons for its structure.
First, machine instructions in the 8086 encode registers according to the system below.
The 5-bit register number above is essentially an extension of the instruction encoding.
Moreover, the AX/CX/DX/BX registers (red) are lined up with their upper-byte and lower-byte versions (blue).
This simplifies the hardware since
the low three bits of the register number select the register, while the upper two bits perform the byte versus word selection.<span id="fnref:conflict"><a href="#fn:conflict">3</a></span>
The internal registers fit into available spots in the table.</p>
<p><a href="https://static.righto.com/images/8086-registers/reg-assignments.jpg"><img alt="The register assignments, from MCS-86 Assembly Language Reference Guide." height="189" src="https://static.righto.com/images/8086-registers/reg-assignments-w400.jpg" title="The register assignments, from MCS-86 Assembly Language Reference Guide." width="400"/></a></p>
<h2>The ModR/M byte</h2>
<p>Many of the 8086 instructions use a second byte called the ModR/M byte to specify the addressing modes.<span id="fnref:modrm"><a href="#fn:modrm">4</a></span>
The ModR/M byte gives the 8086 a lot of flexibility in how an instruction accesses its operands.
The byte specifies a register for one operand and either a register or memory for the other operand.
The diagram below shows how the byte is split into three fields:
<code>mod</code> selects the overall mode, <code>reg</code> selects a register, and <code>r/m</code> selects either a register or memory mode.
For a ModR/M byte, the <code>reg</code> and the <code>r/m</code> fields are read into the <code>N</code> and <code>M</code> registers respectively, so the registers specified in the ModR/M byte
can be accessed by the microcode.</p>


<table>
<tbody><tr><th colspan="2">mod</th><th colspan="3">reg</th><th colspan="3">r/m</th></tr><tr>
</tr><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</tbody></table>

<p>Let&#39;s look at the instruction <code>SUB AX,BX</code> which subtracts <code>BX</code> from <code>AX</code>.
In the 8086, some important processing steps take place before the microcode starts.
In particular, the &#34;Group Decode ROM&#34; categorizes the instruction into over a dozen categories that affect how it is processed, such as
instructions that are implemented without microcode, one-byte instructions, or instructions with a ModR/M byte.
The Group Decode ROM also indicates the structure of instructions, such as instructions that have a <code>W</code> bit selecting byte versus word operations, or
a <code>D</code> bit reversing the direction of the operands.
In this case, the Group Decode ROM classifies the instruction as 
containing a <code>D</code> bit, a <code>W</code> bit, an ALU operation, and a ModR/M byte.</p>
<p>Based on the Group Decode ROM&#39;s signals, fields from the opcode and ModR/M bytes are extracted and stored in various internal registers.
The ALU operation type (<code>SUB</code>) is stored in the <code>ALU opr</code> register.
The ModR/M byte specifies <code>BX</code> in the <code>reg</code> field and <code>AX</code> in the <code>r/m</code> field so
the <code>reg</code> register number (<code>BX</code>, 27) is stored in the <code>N</code> register, and the <code>r/m</code> register number
(<code>AX</code>, 24) is stored in the <code>M</code> register.</p>
<p>Once the preliminary decoding is done, the microcode below for this ALU instruction is executed.<span id="fnref:microcode"><a href="#fn:microcode">5</a></span>
There are three micro-instructions, so the instruction takes three clock cycles.
First, the register specified by <code>M</code> (i.e. <code>AX</code>) is moved to the ALU&#39;s temporary A register (<code>tmpA</code>).
Meanwhile, <code>XI</code> configures the ALU to perform the operation specified by the instruction bits, i.e. <code>SUB</code>.
The second micro-instruction moves the register specified by <code>N</code> (i.e. <code>BX</code>) to the ALU&#39;s <code>tmpB</code> register.
The last micro-instruction stores the ALU&#39;s result (<code>Σ</code>, number 20) in the register indicated by <code>M</code> (i.e. <code>AX</code>).</p>
<pre>  move       action
M → tmpA     XI tmpA   <span><b>ALU rm↔r</b>: AX to tmpA</span>
N → tmpB     NXT       <span>BX to tmpB</span>
Σ → M        RNI F     <span>result to AX, update flags</span>
</pre>

<p>One of the interesting features of the 8086 is that many instructions contain a <code>D</code> bit that reverses the direction of the operation,
swapping the source and the destination. If we keep the ModR/M byte but use the <code>SUB</code> instruction with the <code>D</code> bit set, the
instruction becomes <code>SUB BX,AX</code>, subtracting <code>AX</code> from <code>BX</code>, the opposite of before.
(Swapping the source and destination is more useful when one argument is in memory. But I&#39;ll use an example with two registers to keep it simple.)
This instruction runs exactly the same microcode as before. The difference is that when the microcode accesses <code>M</code>, due to the direction bit it
gets the value in <code>N</code>, i.e. <code>BX</code> instead of <code>AX</code>. The access to <code>N</code> is similarly swapped.
The result is that <code>AX</code> is subtracted from <code>BX</code>, and the change of direction is transparent to the microcode.</p>
<h2>The M and N registers</h2>
<p>Now let&#39;s take a closer look at how the <code>M</code> and <code>N</code> registers are implemented.
Each register holds a 5-bit register number, expanded from the three bits of the instruction.
The M register is loaded from the three least significant bits of the instruction or ModR/M byte,
while the N register is loaded with bits three through five.
Most commonly, the registers are specified by the ModR/M byte, but some instructions specify the register in the opcode.<span id="fnref:format"><a href="#fn:format">6</a></span></p>


<p>The table below shows how the bits in the instruction&#39;s opcode or ModR/M byte (<code>i5</code>, <code>i4</code>, <code>i3</code>) are converted to a 5-bit number for the N register.
There are three cases: a 16-bit register, an 8-bit register, and a segment register.
The mappings below may seem random, but they result in the entries shown in the 5-bit register encoding table earlier.
I&#39;ve colored the entries so you can see the correspondence.</p>
<table>
<tbody><tr><th> Mode</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr>
<tr><th>16-bit reg</th><td>1</td><td>1</td><td>i5</td><td>i4</td><td>i3</td></tr>
<tr><th>8-bit reg</th><td>i5</td><td>i5&#39;</td><td>0</td><td>i4</td><td>i3</td></tr>
<tr><th>segment reg</th><td>0</td><td>0</td><td>0</td><td>i4</td><td>i3</td></tr>
</tbody></table>

<p>I&#39;ll go through the three cases in more detail.
Many 8086 instructions have two versions, one that acts on bytes and one that acts on words, distinguished by the <code>W</code> bit (bit 0) in the instruction.
If the Group Decode ROM indicates that the instruction has a <code>W</code> bit and the <code>W</code> bit is 0, then the instruction is a byte instruction.<span id="fnref:byte"><a href="#fn:byte">7</a></span>
If the instruction has a ModR/M byte and the instruction operates on a byte, the <code>N</code> register is loaded with the 5-bit number for the specified
byte register.
This happens during &#34;Second Clock&#34;, the clock cycle when the ModR/M byte is fetched from the instruction queue.
The second case is similar; if the instruction operates on a word, the <code>N</code> register is loaded with the number for the word register specified in the
ModR/M byte.</p>
<p>The third case handles a segment register.
The <code>N</code> register is loaded with a segment register number during Second Clock if the Group Decode ROM indicates the instruction has a ModR/M byte with a segment-register field (specifically the segment register <code>MOV</code> instructions).
A bit surprisingly, a segment register number is also loaded during First Clock.
This supports the <code>PUSH</code> and <code>POP</code> segment register instructions, which have the segment register encoded in bits 3 and 4 of the opcode.<span id="fnref:prefix"><a href="#fn:prefix">8</a></span></p>
<!--
N-reg-load-seg: FC or SC and SR group
N-reg-load-reg
N-reg-load-reg8
-->

<p>The table below shows how the bits are assigned in the M register, which uses instruction bits <code>i2</code>, <code>i1</code>, and <code>i0</code>.
The cases are a bit more complicated than the <code>N</code> register.
First, a 16-bit register number is loaded from the opcode byte during First Clock to support instructions that specify the register in the low bits.
During Second Clock, this value may be replaced.</p>
<p>For a ModR/M byte using register mode, the <code>M</code> register is reloaded with the specified
8-bit or a 16-bit register, depending on the byte mode signal described earlier.
However, for a ModR/M byte that uses a memory mode, the <code>M</code> register is loaded with <code>OPR</code> (Operand), the internal register that holds the word that is read or written to memory.</p>
<table>
<tbody><tr><th>Mode</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr>
<tr><th>16-bit reg</th><td>1</td><td>1</td><td>i2</td><td>i1</td><td>i0</td></tr>
<tr><th>8-bit reg</th><td>i2</td><td>i2&#39;</td><td>0</td><td>i1</td><td>i0</td></tr>
<tr><th>OPR</th><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
<tr><th>AX/AL</th><td>byte&#39;</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><th>convert to 8-bit</th><td>m2</td><td>m2&#39;</td><td>0</td><td>m1</td><td>m0</td></tr>
</tbody></table>

<p>Many instructions use the AX or AL register, such as the ALU immediate instructions,
the input and output instructions, and string instructions. For these, the Group Decode ROM triggers the <code>AX</code> or <code>AL</code> register number
specifically to be loaded into the M register during Second Clock. The top bit is set for a word operation and cleared for a byte operation providing
<code>AX</code> or <code>AL</code> as appropriate.</p>
<p>The final <code>M</code> register case is a bit tricky. For an immediate move instruction such as <code>MOV BX,imm</code>, bit 3 switches between a byte and a word move (rather than bit 0), because bits 2-0 specify the register.
Unfortunately, the Group Decode ROM outputs aren&#39;t available during First Clock to indicate this case.
Instead, <code>M</code> is loaded during First Clock with the assumption of a 16-bit register. If that turns out to be wrong, the <code>M</code> register is converted
to an 8-bit register number during Second Clock by shuffling a few bits.</p>
<h2>Producing the source and destination values</h2>
<p>There are three cases for the number that goes on the source or destination buses:
the register number can come from the micro-instruction, the value can come from the <code>M</code> or <code>N</code> register as specified in the micro-instruction,
or the value can come from the <code>M</code> and <code>N</code> register with the roles swapped by the <code>D</code> bit.
(Note that the source and destination can be different cases and are selected with separate circuitry.)</p>
<p>The first case is the default case, where the 5 bits from the micro-instruction source or destination specify the register directly.
For instance, in the micro-instruction <code>tmpB→AX</code>, the microcode knows which registers are being used and specifies them directly.</p>
<p>The second and third cases involve more logic. Consider the source in <code>M→tmpB</code>. 
For an instruction without a <code>D</code> bit, the register number is taken from <code>M</code>. Likewise if the <code>D</code> bit is 0. But if the instruction uses a <code>D</code> bit
and the <code>D</code> bit is 1, then the register number is taken from <code>N</code>.
Multiplexers between the <code>M</code> and <code>N</code> registers select the appropriate register to put on the bus.</p>
<p><a href="https://static.righto.com/images/8086-registers/mn-diagram.jpg"><img alt="The M and N registers as they appear on the die. The metal layer has been removed from this image to show the silicon and polysilicon underneath." height="507" src="https://static.righto.com/images/8086-registers/mn-diagram-w350.jpg" title="The M and N registers as they appear on the die. The metal layer has been removed from this image to show the silicon and polysilicon underneath." width="350"/></a></p><p>The M and N registers as they appear on the die. The metal layer has been removed from this image to show the silicon and polysilicon underneath.</p>
<p>The diagram above shows how the <code>M</code> and <code>N</code> register circuitry is implemented on the die, with the <code>N</code> register at the top and the <code>M</code> register below.
Each register has an input multiplexer that implements the tables above, selecting the appropriate 5 bits depending on the mode. The registers themselves are implemented as
dynamic latches driven by the clock. In the middle, a crossover multiplexer drives the source and destination buses, selecting the <code>M</code> and <code>N</code> registers
as appropriate and amplifying the signals with relatively large transistors. The third output from the multiplexer, the bits from the micro-instruction, is implemented in circuitry
physically separated and closer to the microcode ROM.</p>
<!--

The 8086 has multiple internal buses that connect its functional units.
The ALU (Arithmetic/Logic Unit) is a key part of the processor, as it performs arithmetic and logical operations on 16-bit values.
The ALU bus connects the registers to the ALU for these operations.
The ALU does not receive values directly from the bus, though. The ALU has three temporary registers to provide inputs: temporary A, B, and C.
Any of the temporary registers can provide the first operand, while the second operand always comes from the temporary B register.
The ALU's result is accessed over the ALU bus.
After performing an operation, the ALU updates the status flags directly. Conditional operations also access the flags directly.
However, the flags can also be read and written over the ALU bus, for instructions such as pushing and popping the flags.
-->

<h2>The register selection hardware</h2>
<p>How does the 5-bit number select a register?
The 8086 has a bunch of logic that turns a register number into a control line that enables reading or writing of the register.
For the most part, this logic is implemented with NOR gates that match a particular register number and generate a select signal.
The signal goes through a special <a href="https://www.righto.com/2022/11/the-unusual-bootstrap-drivers-inside.html">bootstrap driver</a>
to boost its voltage since it needs to control 16 register bits.</p>
<p>The 8086 registers are separated into two main groups. The &#34;upper registers&#34; are in the upper left of the chip, in the Bus Interface Unit.
These are the registers that are directly involved with memory accesses.
The &#34;lower registers&#34; are in the lower left of the chip, in the Execution Unit.
From bottom to top, they are <code>AX</code>, <code>CX</code>, <code>DX</code>, <code>BX</code>, <code>SP</code>, <code>BP</code>, <code>SI</code>, and <code>DI</code>; their physical order matches their order in the instruction set.<span id="fnref:bx"><a href="#fn:bx">9</a></span>
A separate PLA (Programmable Logic Array) selects the ALU temporary registers or flags as destination.
Just below it, a PLA selects the source from ALU temporary registers, flags, or the ALU result (<code>Σ</code>).<span id="fnref:ones"><a href="#fn:ones">10</a></span>
I&#39;ve written about the 8086&#39;s registers and their low-level implementation <a href="https://www.righto.com/2020/07/the-intel-8086-processors-registers.html">here</a> if you want more information.</p>
<h2>Some history</h2>
<p>The 8086&#39;s system of selecting registers with 3-bit codes originates with the Datapoint 2200,<span id="fnref:360"><a href="#fn:360">11</a></span>
a desktop computer announced in 1970.
The processor of the Datapoint 2200 was implemented with a board of TTL integrated circuits, since this was before microprocessors.
Many of the Datapoint&#39;s instructions used a 3-bit code to select a register, with a destination register specification in bits 5-3 of the
instruction and a source register in bits 2-0. (This layout is essentially the same as in 8086 instructions and the ModR/M byte.)<span id="fnref:octal"><a href="#fn:octal">12</a></span>
The eight values of this code selected one of 7 registers, with the eighth value indicating a memory access.
Intel copied the Datapoint 2200 architecture for the 8008<span id="fnref:datapoint"><a href="#fn:datapoint">13</a></span> microprocessor (1972) and cleaned it up for the 8080 (1974),
but kept the basic instruction layout and register/memory selection bits.</p>
<!--
Microcode was part of the motivation,
but other microcoded systems generally don't do this.
For example, the IBM System/360 Model 50 uses microcode (which I discuss [here](https://www.righto.com/2022/01/ibm360model50.html)),
but registers are selected in an ad hoc manner; each field in the micro-instruction uses a different numbering scheme, selecting just the
registers needed for that purpose. (Part of the reason is that the processor has a multitude of special-purpose buses, each with different
register connections.)
-->

<p>The 8086&#39;s use of a numbering system for all the registers goes considerably beyond this pattern, partly because its registers
function both as general-purpose registers and special-purpose registers.<span id="fnref:general-purpose"><a href="#fn:general-purpose">14</a></span>
Many instructions can act on the AX, BX, etc. registers interchangeably, treating them as general-purpose registers.
But these registers each have their own special purposes for other instructions, so the microcode must be able to access them specifically.
This motivates the 8086&#39;s approach where registers can be treated as general-purpose registers that are selected
from instruction bits, or as special-purpose registers selected by the microcode.</p>
<!--
A look at some other processsors shows the variety of approaches that can be taken for register selection.
The Zilog Z80 (1976) shows how register selection can be done in a non-microcoded processor.
The Z80 is an extension of the Intel 8080 but more complicated, with two register banks, each containing a larger number of registers.
Like the earlier Intel chips, the Z80 uses three-bit register codes in instructions with a decoder generating the appropriate register select line from these bits.
For the register banks, a bank-select flip-flop determine which register bank to use.
The Z80 also allowed some registers to be exchanged. This wasn't implemented by physically moving the values between registers,
but by renaming the registers by toggling a flip-flop.
I wrote more about Z80 registers [here](https://www.righto.com/2014/10/how-z80s-registers-are-implemented-down.html).
-->

<p>The Motorola 68000 (1979) makes an interesting comparison to the 8086 since they were competitors.
The 68000 uses much wider microcode (85-bit microinstructions compared to 21 bits in the 8086).
It has two main internal buses, but instead of providing generic source and destination transfers like the 8086, the 68000 has a
much more complicated system: about two dozen microcode fields that connect registers and other components to the bus in various ways.<span id="fnref:horizontal"><a href="#fn:horizontal">15</a></span></p>
<!--
The general source-to-destination pattern used in the 8086 seems like it should be very common, but I had a hard time finding other systems
tht used it.
One system is the [RCA Spectra 70](https://en.wikipedia.org/wiki/RCA_Spectra_70),
a mostly forgotten mainframe from 1966 that used microcode.[spectra70]
A 56-bit microinstruction included the transfer of a source register to a destination register with six-bit codes specifying the registers, including numerous internal
registers.


[spectra70]: The microcode of the Spectra 70/45 is described in detail in the book [Microprogramming: principles and practices](https://amzn.to/3JfrE9j), chapter 9.


-->

<h2>Conclusions</h2>
<p>Internally, the 8086 represents registers with a 5-bit number. This is unusual compared to previous microprocessors, which usually
selected registers directly from the instruction or control circuitry.
Three factors motivated this design in the 8086. First, it used microcode, so a uniform method of specifying registers (both programmer-visible
and internal) was useful.
Second, being able to swap the source and destination in an instruction motivated a level of indirection in register specification, provided by the
<code>M</code> and <code>N</code> registers.
Finally, the flexibility of the ModR/M byte, in particular supporting byte, word, and segment registers, meant that the register specification
needed 5 bits.</p>
<p>I&#39;ve written multiple <a href="https://www.righto.com/search/label/8086">posts on the 8086</a> so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter <a href="https://twitter.com/kenshirriff">@kenshirriff</a> or <a href="http://www.righto.com/feeds/posts/default">RSS</a> for updates.
I&#39;ve also started experimenting with Mastodon recently as <a href="https://oldbytes.space/@kenshirriff">@<span data-cfemail="94fbf8f0f6ede0f1e7bae7e4f5f7f1d4fff1fae7fcfde6e6fdf2f2">[email protected]</span></a>.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
