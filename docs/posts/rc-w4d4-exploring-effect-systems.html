<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://payments.posthaven.com/rc-w4d4-exploring-effect-systems">Original</a>
    <h1>RC W4D4 - Exploring effect systems</h1>
    
    <div id="readability-page-1" class="page"><div id="post_body_1951431">
    
      <div><p>The topic that got most votes at functional programming study group was effect systems. I was a little unsure if a seemingly-advanced topic would get people talking. In the true spirit of RC, what ensued was a group exploration.</p><p>Prior to SICP, I thought about programming languages as being static vs dynamic, compiled vs interpreted, with vs without garbage collection. Reading SICP I was (more formally) introduced to functional vs imperative, eager vs lazy evaluation.</p><p>With functional vs imperative, I thought about the latter as allowing functions to have side effects. Since pure functions in the former don’t allow for side effects, enabling side effects (like reading a file or printing to the screen) in a language like Haskell requires a little bit of ‘ceremony’ through monads.</p><p>I’m still wrapping my head around monads. My understanding is monads allows side effects in a controlled way, performed when explicitly triggered rather than being triggered automatically by the evaluation of a function.</p><p>The problem with monads is composability, as the composition of two monads may not be a monad. In other words, <a href="https://www.reddit.com/r/haskell/comments/111y0vy/monads_doesnt_compose_well_why/">care</a> is needed when monads are composed together as the desired effect may be different vs what was intended when considering about each monad individually.</p><p>Having an effect system offers an alternative to using monads. Koka is an experimental language that introduces effect types and handlers. Reading about the different <a href="https://koka-lang.github.io/koka/doc/book.html#why-effects">effect types</a>, there’s a ‘continuum’ and thus not simply a pure vs effectful function distinction.</p><p>Why bother? This beginner-friendly <a href="https://overreacted.io/algebraic-effects-for-the-rest-of-us/#learn-more">post</a> has examples of allowing for a more flexible or generalized form of try-except. Instead of simply catching the error, we could perform arbitrary operations and then ‘go back’ to the function that raised the error. It’s also worth nothing that having handlers allows for this in an ergonomic way (which also avoids having to <a href="https://overreacted.io/algebraic-effects-for-the-rest-of-us/#learn-more">‘color’</a> your functions).</p><p>Haskell has the `freer-simple` <a href="https://github.com/lexi-lambda/freer-simple">library</a> that enables an extensible effect system. Where effects can have a major impact is enabling ergonomic concurrency in OCaml (c.f. Haskell which has better multicore primitives). This has been in the works for close to a decade and is currently an <a href="https://discuss.ocaml.org/t/ocaml-5-effects-syntax/10206/2">experimental feature</a> in OCaml 5.</p><p>The discussion is timely. Earlier in the week we watched Simon Peyton-Jones present on the Verse language. Verse has an effect system instead of using monads, slide 6 <a href="https://discuss.ocaml.org/t/ocaml-5-effects-syntax/10206/2">here</a>. The study group got curious about logic programming (Verse is a functional logic language) so we’ll be discussing this next week!</p><p>Special thanks to <a href="https://twitter.com/sgeisenh">Sam Eisenhandler</a> for seeding the discussion on effect systems.</p></div>
    
  </div></div>
  </body>
</html>
