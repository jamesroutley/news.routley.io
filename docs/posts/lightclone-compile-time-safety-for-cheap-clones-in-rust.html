<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hamy.xyz/blog/2026-02_announcing-lightclone">Original</a>
    <h1>LightClone - Compile-Time Safety for Cheap Clones in Rust</h1>
    
    <div id="readability-page-1" class="page"><p>DISCLOSURE: If you buy through affiliate links, I may earn a small commission. <a href="https://hamy.xyz/blog/disclosures">(disclosures)</a></p><div><p>I&#39;ve been writing <a href="https://hamy.xyz/blog/2026-01_high-level-rust">High Level Rust</a> with immutable data, functional pipelines, and liberal cloning. This approach has helped me get acquainted with the language using patterns I enjoy while sidestepping a lot of the issues around ownership, lifetimes, and async. The approach works, but it has a subtle gotcha - cheap and expensive clones look identical in Rust. You can accidentally add a <code>String</code> field to a struct you&#39;re cloning in a hot loop and tank your performance with zero compiler warnings.</p>
<p>I built <a href="https://github.com/SIRHAMY/light-clone">LightClone</a> to fix this. It&#39;s a derive macro that enforces cheap clones at compile time - if any field is expensive to clone, your code won&#39;t compile.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/jqgjsmKwA90?si=ojmVebrxe_5iUo3E" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<h2 id="the-problem-with-clones-in-rust">The Problem with Clones in Rust</h2>
<p>In Rust, both cheap and expensive clones use the same <code>.clone()</code> method:</p>
<pre><code>cheap_arc.clone()         // ~10ns refcount bump
expensive_string.clone()  // ~500ns heap allocation + copy
</code></pre>
<p>The <a href="https://hamy.xyz/blog/2026-02_the-problem-with-clones-in-rust">fix for expensive clones</a> is to use <code>Arc&lt;str&gt;</code> instead of <code>String</code>, <code>imbl::Vector</code> instead of <code>Vec</code>, and so on. This gets you 7-150x speedups on clone-heavy code.</p>
<p>But nothing stops you from accidentally introducing an expensive field during refactoring and there&#39;s no way to tell if a clone is expensive or cheap from the clone site. You change one field from <code>Arc&lt;str&gt;</code> to <code>String</code> and your performance regresses silently.</p>
<h2 id="how-lightclone-works">How LightClone Works</h2>
<p>LightClone is a trait that only allows cheap-to-clone types:</p>
<ul>
<li><strong>Copy types</strong> - primitives, bitwise copies</li>
<li><strong>Refcounted</strong> - <code>Arc&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> - just bump a counter</li>
<li><strong>Persistent collections</strong> - <code>imbl</code>, <code>rpds</code> - structural sharing, O(1) clone</li>
</ul>
<p><img src="https://cdn.hamy.xyz/labs/posts/2026/2026-02_announcing-lightclone/2026-02_announcing-lightclone_type-filter.png" alt="How LightClone works"/></p>
<p>The derive macro enforces all fields implement LightClone:</p>
<pre><code>// This won&#39;t compile - String is expensive
#[derive(Clone, LightClone)]
struct Person {
    id: i64,
    name: String,  // ERROR: String doesn&#39;t implement LightClone
}

// This compiles - all fields are cheap
#[derive(Clone, LightClone)]
struct Person {
    id: i64,
    name: Arc&lt;str&gt;,  // OK: Arc is cheap
}
</code></pre>
<p>Call <code>.light_clone()</code> or <code>.lc()</code> instead of <code>.clone()</code> when you want to assert cheapness:</p>
<pre><code>let p2 = person.light_clone();  // Guaranteed cheap
</code></pre>
<h2 id="usage">Usage</h2>
<p>Add the dependency with feature flags for the crates you use:</p>
<pre><code>[dependencies]
light_clone = { version = &#34;0.4&#34;, features = [&#34;imbl&#34;, &#34;uuid&#34;, &#34;chrono&#34;] }
</code></pre>
<p>Then derive and use:</p>
<pre><code>use light_clone::LightClone;
use std::sync::Arc;

#[derive(Clone, LightClone)]
struct Config {
    name: Arc&lt;str&gt;,
    max_connections: u32,
    timeout_ms: u64,
    tags: imbl::Vector&lt;Arc&lt;str&gt;&gt;,
}

let config = Config { /* ... */ };
let clone = config.light_clone();  // Compile-time guarantee this is cheap
</code></pre>
<p>LightClone also provides <code>LightStr</code> as an ergonomic alias for <code>Arc&lt;str&gt;</code>:</p>
<pre><code>use light_clone::{LightStr, IntoLightStr};

let name: LightStr = &#34;Alice&#34;.into_light_str();
let clone = name.light_clone();  // O(1) - just bumps refcount
</code></pre>
<p>Available feature flags:</p>
<ul>
<li><code>bytes</code> - for <code>Bytes</code> type</li>
<li><code>smol_str</code> - for <code>SmolStr</code></li>
<li><code>uuid</code>, <code>chrono</code>, <code>time</code> - common utilities</li>
<li><code>im</code>, <code>imbl</code>, <code>rpds</code> - persistent collections</li>
<li><code>rust_decimal</code>, <code>ordered-float</code> - numeric types</li>
<li><code>full</code> - enable all integrations</li>
</ul>
<h2 id="prior-art-dupe">Prior Art: Dupe</h2>
<p>I&#39;ll be honest: I didn&#39;t know Dupe existed when I started building LightClone. Facebook&#39;s <a href="https://github.com/facebookincubator/gazebo">Gazebo library</a> has a <code>Dupe</code> trait that solves the same problem - marking types that are cheap to clone. It&#39;s mature with 1M+ downloads.</p>
<p>LightClone uses the same approach as Dupe: a marker trait that requires <code>Clone</code>, a derive macro that validates fields at compile time, and a method (<code>.dupe()</code> vs <code>.lc()</code> / <code>light_clone()</code>) that delegates to <code>.clone()</code>. The trait provides compile-time safety while the actual cloning uses the standard <code>Clone</code> implementation.</p>
<p>The meaningful difference is library support. Dupe only covers standard library types. If you&#39;re using <code>imbl</code>, <code>rpds</code>, <code>bytes</code>, <code>smol_str</code>, <code>uuid</code>, or <code>chrono</code> - there&#39;s no Dupe support.</p>
<table>
<thead>
<tr>
<th>Crate</th>
<th>Dupe</th>
<th>LightClone</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Arc&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><code>im</code>, <code>imbl</code> (persistent collections)</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><code>rpds</code> (persistent collections)</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><code>bytes</code></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><code>smol_str</code></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><code>uuid</code>, <code>chrono</code>, <code>time</code></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><code>rust_decimal</code>, <code>ordered-float</code></td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>If you&#39;re using standard library types only, Dupe is battle-tested and a solid choice. If you need ecosystem support for immutable data structures - which you do for <a href="https://hamy.xyz/blog/2026-01_high-level-rust">High Level Rust</a> patterns - LightClone fills that gap.</p>
<p>There&#39;s also <code>implicit-clone</code> from the Yew project, but it&#39;s focused on UI framework patterns rather than general-purpose use.</p>
<h2 id="the-tradeoff">The Tradeoff</h2>
<p>LightClone adds friction. You have to convert types at boundaries (<code>String</code> -&gt; <code>Arc&lt;str&gt;</code>) and your team needs to understand the pattern.</p>
<p>But this trades runtime performance bugs for compile-time errors. That&#39;s a trade I&#39;m happy to make - it aligns with Rust&#39;s philosophy of paying upfront rather than later and keeps me from accidentally making perf mistakes I didn&#39;t intend.</p>
<p>And for anything actually performance critical, you&#39;ll likely want to use mutations instead of heavy cloning anyway.</p>
<h2 id="next">Next</h2>
<p>LightClone turns invisible performance footguns into compiler errors. If you&#39;re writing functional Rust and want confidence that your clones stay cheap, give it a try.</p>
<p>I&#39;m still learning Rust, so feedback is welcome. Star it on <a href="https://github.com/SIRHAMY/light-clone">GitHub</a> if you want to support development, and open issues or PRs if you hit problems.</p>
<p>If you liked this post you might also like:</p>
<ul>
<li><a href="https://hamy.xyz/blog/2026-02_the-problem-with-clones-in-rust">The Problem with Clones in Rust</a> - deep dive on why Rust clones are expensive</li>
<li><a href="https://hamy.xyz/blog/2026-01_high-level-rust">High Level Rust</a> - the approach that led to building LightClone</li>
<li><a href="https://hamy.xyz/blog/2026-01_missing-programming-language">The Missing Programming Language</a> - why I&#39;m exploring Rust in the first place</li>
</ul>
</div></div>
  </body>
</html>
