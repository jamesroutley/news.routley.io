<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gilmi.me/blog/post/2023/10/05/haskell-alternative-frontend">Original</a>
    <h1>An alternative front end for Haskell?</h1>
    
    <div id="readability-page-1" class="page"><div><p>In CppCon 2022, Herb Sutter gave a talk titled
<a href="https://www.youtube.com/watch?v=ELeZAKCN4tY">Can C++ be 10x Simpler &amp; Safer?</a>
where he described an alterntive syntax that compiles to C++ (which he calls CppFront or Cpp2)
that could remove much of the existing issues with C++ - reduce complexity, increase safety, and more.
If you haven&#39;t seen it yet, it&#39;s worth a watch!</p><p>With recent events and discussions in the Haskell community, my mind went back to that talk,
thinking whether we can we do the same with Haskell.</p><p>Honestly, it does not sound like a terrible idea.</p><p>In this post I&#39;ll explore 11 ideas I would pursue if I were to build an alternative syntax for Haskell
(a new compiler frontend for a modified language that compiles to GHC Haskell source code)
to solve some of the most repeated complaints about Haskell.</p><p>Not everything here is fully fleshed out, but I hope you&#39;ll get the general idea.</p><p>Edit to clarify: I&#39;m not attempting anything more here than writing down some thoughts!</p><h2 id="1.-interoperability-with-haskell">1. Interoperability with Haskell</h2><p>Since our new syntax will be compiled to GHC Haskell source code,
interoperability should be seemless, and everything that is expressible in the new syntax should
be expressible in Haskell. This way our language can tap into
the existing Haskell ecosystem including all of the facilities, and the compilation scheme
should be straightforward. Building a new syntax won&#39;t mean starting from scratch.</p><h2 id="2.-language-extensions-and-stability">2. Language extensions and stability</h2><p>GHC Haskell is a big language with many configurable knobs in the form of language extensions.
There are pros to that approach: some people like to experiment with shiny new features.</p><p>However, others don&#39;t like the idea of Haskell being a moving target, don&#39;t like inconsistency
between codebases, and don&#39;t like the idea that they need to enable so many language extensions
to do common things.</p><p>The solution: no more customization, no more extensions. In the new syntax, the following features (and those only) are always on:
GHC2021, LambdaCase, DerivingStrategies/Via, BlockArguments, TypeApplications, ForeignFunctionInterface
(and Maybe even StrictData?), and each module will be compiled with these extensions at the top.</p><p>Sorry fancier type extensions and fancy types enthusiasts, if you really want them, you probably want to
stick to Haskell.</p><p>This will give users of the new syntax the stability they are craving, and will let researchers continue evolve
Haskell and try new ideas without butting heads (as much) with the first group.</p><h2 id="3.-standard-library-re-energized">3. Standard library re-energized</h2><p>The new syntax can provide a clean cut from Haskell and base and make many desired changes to the standard library.
Such as:</p><ol><li>Clean up prelude and remove footguns such as partial functions like <code>head</code>, slow functions like <code>foldl</code>,
excessive polymorphism, etc. And export some useful but missing functions such as <code>for</code> and <code>for_</code>.</li><li>Rename common operators such as <code>$</code>, <code>&amp;</code>, <code>.</code>, to <code>&lt;|</code>, <code>|&gt;</code>, <code>&lt;.</code>, and <code>.&gt;</code>, (you&#39;ll see why soon).</li><li>Include containers in the standard library.</li><li>Remove <code>type String = [Char]</code> and promote strict <code>Text</code> to be the one true string type in its stead.</li><li>Provide a better API around IO than lazy IO.</li></ol><h2 id="4.-modules">4. Modules</h2><p>A few things that I sorely miss from the Haskell module system is the ability to export modules
qualified, have easy access to mutually dependent modules, and defining multiple modules in one source file.</p><p>We can define a compilation scheme that allows us to have all that using a new syntax.</p><ol><li>We can make all module imports qualified by default, and use an <code>expose</code> keyword instead to import unqualified.</li><li>We can compile qualified module exports to multiple module imports.</li><li>We can split and merge source files to single or multiple source files to achieve what we want.</li></ol><h2 id="5.-records">5. Records</h2><ol><li>We ignore existing record syntax in Haskell and instead formulate a new syntax that is translated
to raw product types.</li><li>We revamp record update syntax so nested updates are easy, we use dot syntax for access
(this is why <code>.</code> for compose has been renamed), and we base everything on lenses so we get row polymorphism for free.</li><li><p>Records are anonymous and are generated as data types with a canonical representation.
Writing</p><pre><code>data Person = Person { name : String, age : Int }</code></pre><p>is translated to something like:</p><pre><code>newtype Person = Person PersonRecord
data PersonRecord = PersonRecord { _personRecordAge : Int, _personRecordName : String }
makeFields &#39;&#39;PersonRecord</code></pre></li><li>We can no longer mix records with sum types and get partial accessors or updaters.</li></ol><h2 id="6.-syntax-changes">6. Syntax changes</h2><p>We can change or get rid of a bunch of syntax that is rarely in use or just isn&#39;t great:</p><ol><li>Remove custom list syntax and instead use <code>List</code>, <code>Cons</code> and <code>Nil</code>.</li><li>Use <code>:</code> for types.</li><li>No more overloaded literals (strings or numbers).
Additional suffix can be provided for literals or explicit conversions.
Next time you ask newcomers to do <code>:t 17</code> it will say <code>Int64</code>.</li><li>Operators can either only be defined in Haskell land, or must be aliases to existing named functions
(I&#39;d vote for the former).</li><li>Add multiline strings syntax</li><li>Remove arrow syntax</li><li>Remove multiple value declarations and patterns outside of case or <code>\cases</code>.</li><li>Remove tuples - use records instead.</li><li>Provide an official autoformatter out of the box and end formatting arguments.</li></ol><p>(I&#39;ll go even further and suggest some ideas that might be a bit controversial):</p><p>We can even remove the <code>data</code> and <code>type</code> keywords and reclaim them as value names. I would suggest this
as the new syntax for data types:</p><pre><code>Tree a =
  | Nil
  | Node { value : a, left : Tree a, right : Tree a }</code></pre><p>where:</p><ol><li>Each constructor gets 0 or 1 argument, for multiple arguments, use a record, its better to have named arguments anyway.</li><li>Data types with a single constructor and value are automatically promoted to a <code>newtype</code>.</li><li>type aliases are no longer possible.</li></ol><p>But again, we don&#39;t have to do majorly controversial things if we don&#39;t want to.</p><h2 id="7.-polymorphic-variants">7. Polymorphic variants</h2><p>There are encoding that lets you implement
polymorphic variants <a href="https://cdn.fosstodon.org/media_attachments/files/110/414/521/516/096/955/original/c5a38d0dd6f5f15b.png">using row polymorphism</a>.
Now we can implement a <code>Result</code> type with errors that can compose. You welcome.</p><h2 id="8.-debugging">8. Debugging</h2><p>Create a new Debug typeclass that is automatically derived for all data types.
This typeclass could provide the ability to pretty print values anywhere in the program.</p><p>Additional step debugging tooling can be created by injecting haskell function calls that will
halt execution and provide runtime information.</p><h2 id="9.-docstrings">9. Docstrings</h2><p>Create a new docstring tooling with standard markdown format that compiles to haddock comments.</p><h2 id="10.-warnings-and-errors">10. Warnings and Errors</h2><p>Enable some warnings like <code>-Wall</code>, and even make some of them, especially those around introducing
partial functions and non-exhaustive pattern matching, errors by default.</p><h2 id="11.-a-different-macro-system">11. A different macro system?</h2><p>Since we are generating Haskell source code, we could potentially introduce a different kind of macro system.</p><p>This seems the most difficult thing to do on this list by-far, and I don&#39;t have a lot of experience with this topic,
but it seems like a good opportunity to think about it.</p><h2 id="conclusion">Conclusion</h2><p>While I believe many of these changes are things that many (most?) Haskellers would want, making them in Haskell
would significantly alter the language to the point that
all existing code would break. That&#39;s a tough sell
for a well-established language. But a new frontend - essentially
a new language, could make it work.</p><p>I think there could be a lot of merit to splitting the Haskell language by providing an alternative front-end
that will allow many people to have a Haskell that better aligns to their needs - both for those who want
stability, and those who want to experiment, in a way that benefits both.
And this way does not require forking GHC, or starting from scratch.</p><p>Of course, the most difficult part of such ideas is to get concensus from a wide group of people,
and to be careful not to step on too many toes. I will probably not attempt to implement such an idea,
mostly because I really dislike writing parsers.</p></div></div>
  </body>
</html>
