<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mkennedy.codes/posts/python-numbers-every-programmer-should-know/">Original</a>
    <h1>Python Numbers Every Programmer Should Know</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p><strong>There are numbers every Python programmer should know</strong>. For example, how fast or slow is it to add an item to a list in Python? What about opening a file? Is that less than a millisecond? Is there something that makes that slower than you might have guessed? If you have a performance sensitive algorithm, which data structure should you use? How much memory does a floating point number use? What about a single character or the empty string? How fast is FastAPI compared to Django?</p>
<p>I wanted to take a moment and write down performance numbers specifically focused on Python developers. Below you will find an extensive table of such values. They are grouped by category. And I provided a couple of graphs for the more significant analysis below the table.</p>
<h3 id="source-code-for-the-benchmarks">Source code for the benchmarks</h3>
<p>This article is posted without any code. I encourage you to dig into the benchmarks. The code is available on GitHub at:</p>
<p><a href="https://github.com/mikeckennedy/python-numbers-everyone-should-know">https://github.com/mikeckennedy/python-numbers-everyone-should-know</a></p>
<h3 id="-system-information">üìä System Information</h3>
<p>The benchmarks were run on the sytem described in this table. While yours may be faster or slower, the most important thing to consider is relative comparisons.</p>
<table>
  <thead>
      <tr>
          <th>Property</th>
          <th>Value</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Python Version</strong></td>
          <td>CPython 3.14.2</td>
      </tr>
      <tr>
          <td><strong>Hardware</strong></td>
          <td>Mac Mini M4 Pro</td>
      </tr>
      <tr>
          <td><strong>Platform</strong></td>
          <td>macOS Tahoe (26.2)</td>
      </tr>
      <tr>
          <td><strong>Processor</strong></td>
          <td>ARM</td>
      </tr>
      <tr>
          <td><strong>CPU Cores</strong></td>
          <td>14 physical / 14 logical</td>
      </tr>
      <tr>
          <td><strong>RAM</strong></td>
          <td>24 GB</td>
      </tr>
      <tr>
          <td><strong>Timestamp</strong></td>
          <td>2025-12-30</td>
      </tr>
  </tbody>
</table>
<hr/>
<h2 id="python-numbers-you-should-know">Python numbers you should know</h2>
<p>More analysis and graphs by category below the table.</p>
<table>
  <thead>
      <tr>
          <th>Category</th>
          <th>Operation</th>
          <th>Time</th>
          <th>Memory</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="#memory-costs"><strong>üíæ Memory</strong></a></td>
          <td>Empty Python process</td>
          <td>‚Äî</td>
          <td>15.73 MB</td>
      </tr>
      <tr>
          <td></td>
          <td>Empty string</td>
          <td>‚Äî</td>
          <td>41 bytes</td>
      </tr>
      <tr>
          <td></td>
          <td>100-char string</td>
          <td>‚Äî</td>
          <td>141 bytes</td>
      </tr>
      <tr>
          <td></td>
          <td>Small int (0-256)</td>
          <td>‚Äî</td>
          <td>28 bytes</td>
      </tr>
      <tr>
          <td></td>
          <td>Large int</td>
          <td>‚Äî</td>
          <td>28 bytes</td>
      </tr>
      <tr>
          <td></td>
          <td>Float</td>
          <td>‚Äî</td>
          <td>24 bytes</td>
      </tr>
      <tr>
          <td></td>
          <td>Empty list</td>
          <td>‚Äî</td>
          <td>56 bytes</td>
      </tr>
      <tr>
          <td></td>
          <td>List with 1,000 ints</td>
          <td>‚Äî</td>
          <td>7.87 KB</td>
      </tr>
      <tr>
          <td></td>
          <td>List with 1,000 floats</td>
          <td>‚Äî</td>
          <td>8.65 KB</td>
      </tr>
      <tr>
          <td></td>
          <td>Empty dict</td>
          <td>‚Äî</td>
          <td>64 bytes</td>
      </tr>
      <tr>
          <td></td>
          <td>Dict with 1,000 items</td>
          <td>‚Äî</td>
          <td>36.1 KB</td>
      </tr>
      <tr>
          <td></td>
          <td>Empty set</td>
          <td>‚Äî</td>
          <td>216 bytes</td>
      </tr>
      <tr>
          <td></td>
          <td>Set with 1,000 items</td>
          <td>‚Äî</td>
          <td>32.2 KB</td>
      </tr>
      <tr>
          <td></td>
          <td>Regular class instance (5 attrs)</td>
          <td>‚Äî</td>
          <td>48 bytes</td>
      </tr>
      <tr>
          <td></td>
          <td><code>__slots__</code> class instance (5 attrs)</td>
          <td>‚Äî</td>
          <td>72 bytes</td>
      </tr>
      <tr>
          <td></td>
          <td>List of 1,000 regular class instances</td>
          <td>‚Äî</td>
          <td>165.2 KB</td>
      </tr>
      <tr>
          <td></td>
          <td>List of 1,000 <code>__slots__</code> class instances</td>
          <td>‚Äî</td>
          <td>79.1 KB</td>
      </tr>
      <tr>
          <td></td>
          <td>dataclass instance</td>
          <td>‚Äî</td>
          <td>48 bytes</td>
      </tr>
      <tr>
          <td></td>
          <td>namedtuple instance</td>
          <td>‚Äî</td>
          <td>88 bytes</td>
      </tr>
      <tr>
          <td><a href="#basic-operations"><strong>‚öôÔ∏è Basic Ops</strong></a></td>
          <td>Add two integers</td>
          <td>19.0 ns (52.7M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Add two floats</td>
          <td>18.4 ns (54.4M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>String concatenation (small)</td>
          <td>39.1 ns (25.6M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>f-string formatting</td>
          <td>64.9 ns (15.4M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>.format()</code></td>
          <td>103 ns (9.7M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>%</code> formatting</td>
          <td>89.8 ns (11.1M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>List append</td>
          <td>28.7 ns (34.8M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>List comprehension (1,000 items)</td>
          <td>9.45 Œºs (105.8k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Equivalent for-loop (1,000 items)</td>
          <td>11.9 Œºs (83.9k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td><a href="#collection-access-and-iteration"><strong>üì¶ Collections</strong></a></td>
          <td>Dict lookup by key</td>
          <td>21.9 ns (45.7M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Set membership check</td>
          <td>19.0 ns (52.7M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>List index access</td>
          <td>17.6 ns (56.8M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>List membership check (1,000 items)</td>
          <td>3.85 Œºs (259.6k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>len()</code> on list</td>
          <td>18.8 ns (53.3M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Iterate 1,000-item list</td>
          <td>7.87 Œºs (127.0k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Iterate 1,000-item dict</td>
          <td>8.74 Œºs (114.5k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>sum()</code> of 1,000 ints</td>
          <td>1.87 Œºs (534.8k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td><a href="#class-and-object-attributes"><strong>üè∑Ô∏è Attributes</strong></a></td>
          <td>Read from regular class</td>
          <td>14.1 ns (70.9M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Write to regular class</td>
          <td>15.7 ns (63.6M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Read from <code>__slots__</code> class</td>
          <td>14.1 ns (70.7M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Write to <code>__slots__</code> class</td>
          <td>16.4 ns (60.8M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Read from <code>@property</code></td>
          <td>19.0 ns (52.8M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>getattr()</code></td>
          <td>13.8 ns (72.7M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>hasattr()</code></td>
          <td>23.8 ns (41.9M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td><a href="#json-and-serialization"><strong>üìÑ JSON</strong></a></td>
          <td><code>json.dumps()</code> (simple)</td>
          <td>708 ns (1.4M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>json.loads()</code> (simple)</td>
          <td>714 ns (1.4M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>json.dumps()</code> (complex)</td>
          <td>2.65 Œºs (376.8k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>json.loads()</code> (complex)</td>
          <td>2.22 Œºs (449.9k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>orjson.dumps()</code> (complex)</td>
          <td>310 ns (3.2M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>orjson.loads()</code> (complex)</td>
          <td>839 ns (1.2M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>ujson.dumps()</code> (complex)</td>
          <td>1.64 Œºs (611.2k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>msgspec</code> encode (complex)</td>
          <td>445 ns (2.2M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Pydantic <code>model_dump_json()</code></td>
          <td>1.54 Œºs (647.8k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Pydantic <code>model_validate_json()</code></td>
          <td>2.99 Œºs (334.7k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td><a href="#web-frameworks"><strong>üåê Web Frameworks</strong></a></td>
          <td>Flask (return JSON)</td>
          <td>16.5 Œºs (60.7k req/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Django (return JSON)</td>
          <td>18.1 Œºs (55.4k req/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>FastAPI (return JSON)</td>
          <td>8.63 Œºs (115.9k req/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Starlette (return JSON)</td>
          <td>8.01 Œºs (124.8k req/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Litestar (return JSON)</td>
          <td>8.19 Œºs (122.1k req/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td><a href="#file-io"><strong>üìÅ File I/O</strong></a></td>
          <td>Open and close file</td>
          <td>9.05 Œºs (110.5k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Read 1KB file</td>
          <td>10.0 Œºs (99.5k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Write 1KB file</td>
          <td>35.1 Œºs (28.5k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Write 1MB file</td>
          <td>207 Œºs (4.8k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>pickle.dumps()</code></td>
          <td>1.30 Œºs (769.6k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>pickle.loads()</code></td>
          <td>1.44 Œºs (695.2k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td><a href="#database-and-persistence"><strong>üóÑÔ∏è Database</strong></a></td>
          <td>SQLite insert (JSON blob)</td>
          <td>192 Œºs (5.2k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>SQLite select by PK</td>
          <td>3.57 Œºs (280.3k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>SQLite update one field</td>
          <td>5.22 Œºs (191.7k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>diskcache set</td>
          <td>23.9 Œºs (41.8k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>diskcache get</td>
          <td>4.25 Œºs (235.5k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>MongoDB insert_one</td>
          <td>119 Œºs (8.4k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>MongoDB find_one by _id</td>
          <td>121 Œºs (8.2k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>MongoDB find_one by nested field</td>
          <td>124 Œºs (8.1k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td><a href="#function-and-call-overhead"><strong>üìû Functions</strong></a></td>
          <td>Empty function call</td>
          <td>22.4 ns (44.6M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Function with 5 args</td>
          <td>24.0 ns (41.7M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Method call</td>
          <td>23.3 ns (42.9M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>Lambda call</td>
          <td>19.7 ns (50.9M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>try/except (no exception)</td>
          <td>21.5 ns (46.5M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td>try/except (exception raised)</td>
          <td>139 ns (7.2M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>isinstance()</code> check</td>
          <td>18.3 ns (54.7M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td><a href="#async-overhead"><strong>‚è±Ô∏è Async</strong></a></td>
          <td>Create coroutine object</td>
          <td>47.0 ns (21.3M ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>run_until_complete(empty)</code></td>
          <td>27.6 Œºs (36.2k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>asyncio.sleep(0)</code></td>
          <td>39.4 Œºs (25.4k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>gather()</code> 10 coroutines</td>
          <td>55.0 Œºs (18.2k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>create_task()</code> + await</td>
          <td>52.8 Œºs (18.9k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
      <tr>
          <td></td>
          <td><code>async with</code> (context manager)</td>
          <td>29.5 Œºs (33.9k ops/sec)</td>
          <td>‚Äî</td>
      </tr>
  </tbody>
</table>
<hr/>
<h2 id="memory-costs">Memory Costs</h2>
<p>Understanding how much memory different Python objects consume.</p>
<h3 id="an-empty-python-process-uses-1573-mb">An empty Python process uses 15.73 MB</h3>
<hr/>
<h3 id="strings">Strings</h3>
<p>The rule of thumb for strings is the core string object takes 41 bytes. Each additional character is 1 byte.</p>
<table>
  <thead>
      <tr>
          <th>String</th>
          <th>Size</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Empty string <code>&#34;&#34;</code></td>
          <td>41 bytes</td>
      </tr>
      <tr>
          <td>1-char string <code>&#34;a&#34;</code></td>
          <td>42 bytes</td>
      </tr>
      <tr>
          <td>100-char string</td>
          <td>141 bytes</td>
      </tr>
  </tbody>
</table>
<p><img src="https://cdn.mkennedy.codes/posts/python-numbers-every-programmer-should-know/string-memory-usage-by-size.png" alt=""/></p>
<hr/>
<h3 id="numbers">Numbers</h3>
<p><strong>Numbers are surprisingly large in Python</strong>. They have to derive from CPython‚Äôs <code>PyObject</code> and are subject to reference counting for garabage collection, they exceed our typical mental model many of:</p>
<ul>
<li>2 bytes = short int</li>
<li>4 bytes = long int</li>
<li>etc.</li>
</ul>
<table>
  <thead>
      <tr>
          <th>Type</th>
          <th>Size</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Small int (0-256, cached)</td>
          <td>28 bytes</td>
      </tr>
      <tr>
          <td>Large int (1000)</td>
          <td>28 bytes</td>
      </tr>
      <tr>
          <td>Very large int (10**100)</td>
          <td>72 bytes</td>
      </tr>
      <tr>
          <td>Float</td>
          <td>24 bytes</td>
      </tr>
  </tbody>
</table>
<p><img src="https://cdn.mkennedy.codes/posts/python-numbers-every-programmer-should-know/individual-integer-and-float-memory-usage.png" alt=""/></p>
<hr/>
<h3 id="collections">Collections</h3>
<p>Collections are amazing in Python. Dynamically growing lists. Ultra high-perf dictionaries and sets. Here is the empty and ‚Äúfull‚Äù overhead of each.</p>
<table>
  <thead>
      <tr>
          <th>Collection</th>
          <th>Empty</th>
          <th>1,000 items</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>List (ints)</td>
          <td>56 bytes</td>
          <td>7.87 KB</td>
      </tr>
      <tr>
          <td>List (floats)</td>
          <td>56 bytes</td>
          <td>8.65 KB</td>
      </tr>
      <tr>
          <td>Dict</td>
          <td>64 bytes</td>
          <td>36.1 KB</td>
      </tr>
      <tr>
          <td>Set</td>
          <td>216 bytes</td>
          <td>32.2 KB</td>
      </tr>
  </tbody>
</table>
<p><img src="https://cdn.mkennedy.codes/posts/python-numbers-every-programmer-should-know/empty-collection-memory-overhead.png" alt=""/></p>
<hr/>
<h3 id="classes-and-instances">Classes and Instances</h3>
<p>Slots are an interesting addition to Python classes. They remove the entire concept of a <code>__dict__</code> for tracking fields and other values. This does not significantly matter for a single instance, with the slots instance actually <strong>larger</strong>. But if you are holding a large number of them in memory for a list or cache, the memory savings of a slots class is very dramatic. Luckily for most use-cases, just adding a slots entry saves a ton of memory with minimal effort.</p>
<table>
  <thead>
      <tr>
          <th>Type</th>
          <th>Empty</th>
          <th>5 attributes</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Regular class</td>
          <td>48 bytes</td>
          <td>48 bytes</td>
      </tr>
      <tr>
          <td><code>__slots__</code> class</td>
          <td>32 bytes</td>
          <td>72 bytes</td>
      </tr>
      <tr>
          <td>dataclass</td>
          <td>‚Äî</td>
          <td>48 bytes</td>
      </tr>
      <tr>
          <td><code>@dataclass(slots=True)</code></td>
          <td>‚Äî</td>
          <td>72 bytes</td>
      </tr>
      <tr>
          <td>namedtuple</td>
          <td>‚Äî</td>
          <td>88 bytes</td>
      </tr>
  </tbody>
</table>
<p><strong>Aggregate Memory Usage (1,000 instances):</strong></p>
<table>
  <thead>
      <tr>
          <th>Type</th>
          <th>Total Memory</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>List of 1,000 regular class instances</td>
          <td>165.2 KB</td>
      </tr>
      <tr>
          <td>List of 1,000 <code>__slots__</code> class instances</td>
          <td>79.1 KB</td>
      </tr>
  </tbody>
</table>
<p><img src="https://cdn.mkennedy.codes/posts/python-numbers-every-programmer-should-know/memory-for-1-000-class-instances.png" alt=""/></p>
<hr/>
<h2 id="basic-operations">Basic Operations</h2>
<p>The cost of fundamental Python operations: Way slower than C/C++/C# but still quite fast.</p>
<h3 id="arithmetic">Arithmetic</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Add two integers</td>
          <td>19.0 ns (52.7M ops/sec)</td>
      </tr>
      <tr>
          <td>Add two floats</td>
          <td>18.4 ns (54.4M ops/sec)</td>
      </tr>
      <tr>
          <td>Multiply two integers</td>
          <td>19.4 ns (51.6M ops/sec)</td>
      </tr>
  </tbody>
</table>
<p><img src="https://cdn.mkennedy.codes/posts/python-numbers-every-programmer-should-know/arithmetic-operation-speed.png" alt=""/></p>
<hr/>
<h3 id="string-operations">String Operations</h3>
<p>String operations in Python are fast as well. f-strings are the fastest formatting style, while even the slowest style is still measured in just nano-seconds.</p>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Concatenation (<code>+</code>)</td>
          <td>39.1 ns (25.6M ops/sec)</td>
      </tr>
      <tr>
          <td>f-string</td>
          <td>64.9 ns (15.4M ops/sec)</td>
      </tr>
      <tr>
          <td><code>.format()</code></td>
          <td>103 ns (9.7M ops/sec)</td>
      </tr>
      <tr>
          <td><code>%</code> formatting</td>
          <td>89.8 ns (11.1M ops/sec)</td>
      </tr>
  </tbody>
</table>
<p><img src="https://cdn.mkennedy.codes/posts/python-numbers-every-programmer-should-know/string-formatting-speed-comparison.png" alt=""/></p>
<hr/>
<h3 id="list-operations">List Operations</h3>
<p>List operations are very fast in Python. Adding a single item <em>usually</em> requires 28ns. Said another way, you can do 35M appends per second. This is unless the list has to expand using something like a doubling algorithm. You can see this in the ops/sec for 1,000 items.</p>
<p>Surprisingly, <strong>list comprehensions are 20% faster than the equivalent for loops</strong> with append statements.</p>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>list.append()</code></td>
          <td>28.7 ns (34.8M ops/sec)</td>
      </tr>
      <tr>
          <td>List comprehension (1,000 items)</td>
          <td>9.45 Œºs (105.8k ops/sec)</td>
      </tr>
      <tr>
          <td>Equivalent for-loop (1,000 items)</td>
          <td>11.9 Œºs (83.9k ops/sec)</td>
      </tr>
  </tbody>
</table>
<p><img src="https://cdn.mkennedy.codes/posts/python-numbers-every-programmer-should-know/list-comprehension-vs-for-loop.png" alt=""/></p>
<hr/>
<h2 id="collection-access-and-iteration">Collection Access and Iteration</h2>
<p>How fast can you get data out of Python‚Äôs built-in collections? Here is a dramatic example of how much faster the correct data structure is. <code>item in set</code> or <code>item in dict</code> is <strong>200x faster</strong> than <code>item in list</code> for just 1,000 items!</p>
<p>The graph below is non-linear in the x-axis.</p>
<h3 id="access-by-keyindex">Access by Key/Index</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Dict lookup by key</td>
          <td>21.9 ns (45.7M ops/sec)</td>
      </tr>
      <tr>
          <td>Set membership (<code>in</code>)</td>
          <td>19.0 ns (52.7M ops/sec)</td>
      </tr>
      <tr>
          <td>List index access</td>
          <td>17.6 ns (56.8M ops/sec)</td>
      </tr>
      <tr>
          <td>List membership (<code>in</code>, 1,000 items)</td>
          <td>3.85 Œºs (259.6k ops/sec)</td>
      </tr>
  </tbody>
</table>
<p><img src="https://cdn.mkennedy.codes/posts/python-numbers-every-programmer-should-know/collection-access-speed.png" alt=""/></p>
<hr/>
<h3 id="length">Length</h3>
<p><code>len()</code> is very fast. Maybe we don‚Äôt have to optimize it out of the test condition on a while loop looping 100 times after all.</p>
<table>
  <thead>
      <tr>
          <th>Collection</th>
          <th><code>len()</code> time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>List (1,000 items)</td>
          <td>18.8 ns (53.3M ops/sec)</td>
      </tr>
      <tr>
          <td>Dict (1,000 items)</td>
          <td>17.6 ns (56.9M ops/sec)</td>
      </tr>
      <tr>
          <td>Set (1,000 items)</td>
          <td>18.0 ns (55.5M ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h3 id="iteration">Iteration</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Iterate 1,000-item list</td>
          <td>7.87 Œºs (127.0k ops/sec)</td>
      </tr>
      <tr>
          <td>Iterate 1,000-item dict (keys)</td>
          <td>8.74 Œºs (114.5k ops/sec)</td>
      </tr>
      <tr>
          <td><code>sum()</code> of 1,000 integers</td>
          <td>1.87 Œºs (534.8k ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h2 id="class-and-object-attributes">Class and Object Attributes</h2>
<p>The cost of reading and writing attributes, and how <code>__slots__</code> changes things. <strong>Slots is a tiny bit slower but easily saves over 2x the memory usage on large collections</strong>.</p>
<h3 id="attribute-access">Attribute Access</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Regular Class</th>
          <th><code>__slots__</code> Class</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Read attribute</td>
          <td>14.1 ns (70.9M ops/sec)</td>
          <td>14.1 ns (70.7M ops/sec)</td>
      </tr>
      <tr>
          <td>Write attribute</td>
          <td>15.7 ns (63.6M ops/sec)</td>
          <td>16.4 ns (60.8M ops/sec)</td>
      </tr>
  </tbody>
</table>
<p><img src="https://cdn.mkennedy.codes/posts/python-numbers-every-programmer-should-know/attribute-access-regular-vs-slots-classes.png" alt=""/></p>
<hr/>
<h3 id="other-attribute-operations">Other Attribute Operations</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Read <code>@property</code></td>
          <td>19.0 ns (52.8M ops/sec)</td>
      </tr>
      <tr>
          <td><code>getattr(obj, &#39;attr&#39;)</code></td>
          <td>13.8 ns (72.7M ops/sec)</td>
      </tr>
      <tr>
          <td><code>hasattr(obj, &#39;attr&#39;)</code></td>
          <td>23.8 ns (41.9M ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h2 id="json-and-serialization">JSON and Serialization</h2>
<p>Comparing standard library JSON with optimized alternatives. <code>orjson</code> <strong>handles more data types and is over 11x faster than standard lib</strong> <code>json</code>. Impressive!</p>
<h3 id="serialization-dumps">Serialization (dumps)</h3>
<table>
  <thead>
      <tr>
          <th>Library</th>
          <th>Simple Object</th>
          <th>Complex Object</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>json</code> (stdlib)</td>
          <td>708 ns (1.4M ops/sec)</td>
          <td>2.65 Œºs (376.8k ops/sec)</td>
      </tr>
      <tr>
          <td><code>orjson</code></td>
          <td>60.9 ns (16.4M ops/sec)</td>
          <td>310 ns (3.2M ops/sec)</td>
      </tr>
      <tr>
          <td><code>ujson</code></td>
          <td>264 ns (3.8M ops/sec)</td>
          <td>1.64 Œºs (611.2k ops/sec)</td>
      </tr>
      <tr>
          <td><code>msgspec</code></td>
          <td>92.3 ns (10.8M ops/sec)</td>
          <td>445 ns (2.2M ops/sec)</td>
      </tr>
  </tbody>
</table>
<p><img src="https://cdn.mkennedy.codes/posts/python-numbers-every-programmer-should-know/json-serialization-speed-complex-object.png" alt=""/></p>
<hr/>
<h3 id="deserialization-loads">Deserialization (loads)</h3>
<table>
  <thead>
      <tr>
          <th>Library</th>
          <th>Simple Object</th>
          <th>Complex Object</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>json</code> (stdlib)</td>
          <td>714 ns (1.4M ops/sec)</td>
          <td>2.22 Œºs (449.9k ops/sec)</td>
      </tr>
      <tr>
          <td><code>orjson</code></td>
          <td>106 ns (9.4M ops/sec)</td>
          <td>839 ns (1.2M ops/sec)</td>
      </tr>
      <tr>
          <td><code>ujson</code></td>
          <td>268 ns (3.7M ops/sec)</td>
          <td>1.46 Œºs (682.8k ops/sec)</td>
      </tr>
      <tr>
          <td><code>msgspec</code></td>
          <td>101 ns (9.9M ops/sec)</td>
          <td>850 ns (1.2M ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h3 id="pydantic">Pydantic</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>model_dump_json()</code></td>
          <td>1.54 Œºs (647.8k ops/sec)</td>
      </tr>
      <tr>
          <td><code>model_validate_json()</code></td>
          <td>2.99 Œºs (334.7k ops/sec)</td>
      </tr>
      <tr>
          <td><code>model_dump()</code> (to dict)</td>
          <td>1.71 Œºs (585.2k ops/sec)</td>
      </tr>
      <tr>
          <td><code>model_validate()</code> (from dict)</td>
          <td>2.30 Œºs (435.5k ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h2 id="web-frameworks">Web Frameworks</h2>
<p>Returning a simple JSON response. Benchmarked with <code>wrk</code> against localhost running 4 works in Granian. Each framework returns the same JSON payload from a minimal endpoint. No database access or that sort of thing. This is just how much overhead/perf do we get from each framework itself. The code we write that runs within those view methods is largely the same.</p>
<h3 id="results">Results</h3>
<table>
  <thead>
      <tr>
          <th>Framework</th>
          <th>Requests/sec</th>
          <th>Latency (p99)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Flask</td>
          <td>16.5 Œºs (60.7k req/sec)</td>
          <td>20.85 ms (48.0 ops/sec)</td>
      </tr>
      <tr>
          <td>Django</td>
          <td>18.1 Œºs (55.4k req/sec)</td>
          <td>170.3 ms (5.9 ops/sec)</td>
      </tr>
      <tr>
          <td>FastAPI</td>
          <td>8.63 Œºs (115.9k req/sec)</td>
          <td>1.530 ms (653.6 ops/sec)</td>
      </tr>
      <tr>
          <td>Starlette</td>
          <td>8.01 Œºs (124.8k req/sec)</td>
          <td>930 Œºs (1.1k ops/sec)</td>
      </tr>
      <tr>
          <td>Litestar</td>
          <td>8.19 Œºs (122.1k req/sec)</td>
          <td>1.010 ms (990.1 ops/sec)</td>
      </tr>
  </tbody>
</table>
<p><img src="https://cdn.mkennedy.codes/posts/python-numbers-every-programmer-should-know/web-framework-throughput.png" alt=""/></p>
<hr/>
<h2 id="file-io">File I/O</h2>
<p>Reading and writing files of various sizes. Note that the graph is non-linear in y-axis.</p>
<h3 id="basic-operations-1">Basic Operations</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Open and close (no read)</td>
          <td>9.05 Œºs (110.5k ops/sec)</td>
      </tr>
      <tr>
          <td>Read 1KB file</td>
          <td>10.0 Œºs (99.5k ops/sec)</td>
      </tr>
      <tr>
          <td>Read 1MB file</td>
          <td>33.6 Œºs (29.8k ops/sec)</td>
      </tr>
      <tr>
          <td>Write 1KB file</td>
          <td>35.1 Œºs (28.5k ops/sec)</td>
      </tr>
      <tr>
          <td>Write 1MB file</td>
          <td>207 Œºs (4.8k ops/sec)</td>
      </tr>
  </tbody>
</table>
<p><img src="https://cdn.mkennedy.codes/posts/python-numbers-every-programmer-should-know/file-io-performance.png" alt=""/></p>
<hr/>
<h3 id="pickle-vs-json-to-disk">Pickle vs JSON to Disk</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>pickle.dumps()</code> (complex obj)</td>
          <td>1.30 Œºs (769.6k ops/sec)</td>
      </tr>
      <tr>
          <td><code>pickle.loads()</code> (complex obj)</td>
          <td>1.44 Œºs (695.2k ops/sec)</td>
      </tr>
      <tr>
          <td><code>json.dumps()</code> (complex obj)</td>
          <td>2.72 Œºs (367.1k ops/sec)</td>
      </tr>
      <tr>
          <td><code>json.loads()</code> (complex obj)</td>
          <td>2.35 Œºs (425.9k ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h2 id="database-and-persistence">Database and Persistence</h2>
<p>Comparing SQLite, diskcache, and MongoDB using the same complex object.</p>
<h3 id="test-object">Test Object</h3>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>user_data</span> <span>=</span> <span>{</span>
</span></span><span><span>    <span>&#34;id&#34;</span><span>:</span> <span>12345</span><span>,</span>
</span></span><span><span>    <span>&#34;username&#34;</span><span>:</span> <span>&#34;alice_dev&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;email&#34;</span><span>:</span> <span>&#34;alice@example.com&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;profile&#34;</span><span>:</span> <span>{</span>
</span></span><span><span>        <span>&#34;bio&#34;</span><span>:</span> <span>&#34;Software engineer who loves Python&#34;</span><span>,</span>
</span></span><span><span>        <span>&#34;location&#34;</span><span>:</span> <span>&#34;Portland, OR&#34;</span><span>,</span>
</span></span><span><span>        <span>&#34;website&#34;</span><span>:</span> <span>&#34;https://alice.dev&#34;</span><span>,</span>
</span></span><span><span>        <span>&#34;joined&#34;</span><span>:</span> <span>&#34;2020-03-15T08:30:00Z&#34;</span>
</span></span><span><span>    <span>},</span>
</span></span><span><span>    <span>&#34;posts&#34;</span><span>:</span> <span>[</span>
</span></span><span><span>        <span>{</span><span>&#34;id&#34;</span><span>:</span> <span>1</span><span>,</span> <span>&#34;title&#34;</span><span>:</span> <span>&#34;First Post&#34;</span><span>,</span> <span>&#34;tags&#34;</span><span>:</span> <span>[</span><span>&#34;python&#34;</span><span>,</span> <span>&#34;tutorial&#34;</span><span>],</span> <span>&#34;views&#34;</span><span>:</span> <span>1520</span><span>},</span>
</span></span><span><span>        <span>{</span><span>&#34;id&#34;</span><span>:</span> <span>2</span><span>,</span> <span>&#34;title&#34;</span><span>:</span> <span>&#34;Second Post&#34;</span><span>,</span> <span>&#34;tags&#34;</span><span>:</span> <span>[</span><span>&#34;rust&#34;</span><span>,</span> <span>&#34;wasm&#34;</span><span>],</span> <span>&#34;views&#34;</span><span>:</span> <span>843</span><span>},</span>
</span></span><span><span>        <span>{</span><span>&#34;id&#34;</span><span>:</span> <span>3</span><span>,</span> <span>&#34;title&#34;</span><span>:</span> <span>&#34;Third Post&#34;</span><span>,</span> <span>&#34;tags&#34;</span><span>:</span> <span>[</span><span>&#34;python&#34;</span><span>,</span> <span>&#34;async&#34;</span><span>],</span> <span>&#34;views&#34;</span><span>:</span> <span>2341</span><span>},</span>
</span></span><span><span>    <span>],</span>
</span></span><span><span>    <span>&#34;settings&#34;</span><span>:</span> <span>{</span>
</span></span><span><span>        <span>&#34;theme&#34;</span><span>:</span> <span>&#34;dark&#34;</span><span>,</span>
</span></span><span><span>        <span>&#34;notifications&#34;</span><span>:</span> <span>True</span><span>,</span>
</span></span><span><span>        <span>&#34;email_frequency&#34;</span><span>:</span> <span>&#34;weekly&#34;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><h3 id="sqlite-json-blob-approach">SQLite (JSON blob approach)</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Insert one object</td>
          <td>192 Œºs (5.2k ops/sec)</td>
      </tr>
      <tr>
          <td>Select by primary key</td>
          <td>3.57 Œºs (280.3k ops/sec)</td>
      </tr>
      <tr>
          <td>Update one field</td>
          <td>5.22 Œºs (191.7k ops/sec)</td>
      </tr>
      <tr>
          <td>Delete</td>
          <td>191 Œºs (5.2k ops/sec)</td>
      </tr>
      <tr>
          <td>Select with <code>json_extract()</code></td>
          <td>4.27 Œºs (234.2k ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h3 id="diskcache">diskcache</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>cache.set(key, obj)</code></td>
          <td>23.9 Œºs (41.8k ops/sec)</td>
      </tr>
      <tr>
          <td><code>cache.get(key)</code></td>
          <td>4.25 Œºs (235.5k ops/sec)</td>
      </tr>
      <tr>
          <td><code>cache.delete(key)</code></td>
          <td>51.9 Œºs (19.3k ops/sec)</td>
      </tr>
      <tr>
          <td>Check key exists</td>
          <td>1.91 Œºs (523.2k ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h3 id="mongodb">MongoDB</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>insert_one()</code></td>
          <td>119 Œºs (8.4k ops/sec)</td>
      </tr>
      <tr>
          <td><code>find_one()</code> by <code>_id</code></td>
          <td>121 Œºs (8.2k ops/sec)</td>
      </tr>
      <tr>
          <td><code>find_one()</code> by nested field</td>
          <td>124 Œºs (8.1k ops/sec)</td>
      </tr>
      <tr>
          <td><code>update_one()</code></td>
          <td>115 Œºs (8.7k ops/sec)</td>
      </tr>
      <tr>
          <td><code>delete_one()</code></td>
          <td>30.4 ns (32.9M ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h3 id="comparison-table">Comparison Table</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>SQLite</th>
          <th>diskcache</th>
          <th>MongoDB</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Write one object</td>
          <td>192 Œºs (5.2k ops/sec)</td>
          <td>23.9 Œºs (41.8k ops/sec)</td>
          <td>119 Œºs (8.4k ops/sec)</td>
      </tr>
      <tr>
          <td>Read by key/id</td>
          <td>3.57 Œºs (280.3k ops/sec)</td>
          <td>4.25 Œºs (235.5k ops/sec)</td>
          <td>121 Œºs (8.2k ops/sec)</td>
      </tr>
      <tr>
          <td>Read by nested field</td>
          <td>4.27 Œºs (234.2k ops/sec)</td>
          <td>N/A</td>
          <td>124 Œºs (8.1k ops/sec)</td>
      </tr>
      <tr>
          <td>Update one field</td>
          <td>5.22 Œºs (191.7k ops/sec)</td>
          <td>23.9 Œºs (41.8k ops/sec)</td>
          <td>115 Œºs (8.7k ops/sec)</td>
      </tr>
      <tr>
          <td>Delete</td>
          <td>191 Œºs (5.2k ops/sec)</td>
          <td>51.9 Œºs (19.3k ops/sec)</td>
          <td>30.4 ns (32.9M ops/sec)</td>
      </tr>
  </tbody>
</table>
<p>Note: MongoDB is a victim of network access version in-process access.</p>
<p><img src="https://cdn.mkennedy.codes/posts/python-numbers-every-programmer-should-know/database-performance-sqlite-vs-diskcache-vs-mongodb.png" alt=""/></p>
<hr/>
<h2 id="function-and-call-overhead">Function and Call Overhead</h2>
<p>The hidden cost of function calls, exceptions, and async.</p>
<h3 id="function-calls">Function Calls</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Empty function call</td>
          <td>22.4 ns (44.6M ops/sec)</td>
      </tr>
      <tr>
          <td>Function with 5 arguments</td>
          <td>24.0 ns (41.7M ops/sec)</td>
      </tr>
      <tr>
          <td>Method call on object</td>
          <td>23.3 ns (42.9M ops/sec)</td>
      </tr>
      <tr>
          <td>Lambda call</td>
          <td>19.7 ns (50.9M ops/sec)</td>
      </tr>
      <tr>
          <td>Built-in function (<code>len()</code>)</td>
          <td>17.1 ns (58.4M ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h3 id="exceptions">Exceptions</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>try/except</code> (no exception raised)</td>
          <td>21.5 ns (46.5M ops/sec)</td>
      </tr>
      <tr>
          <td><code>try/except</code> (exception raised)</td>
          <td>139 ns (7.2M ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h3 id="type-checking">Type Checking</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>isinstance()</code></td>
          <td>18.3 ns (54.7M ops/sec)</td>
      </tr>
      <tr>
          <td><code>type() == type</code></td>
          <td>21.8 ns (46.0M ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h2 id="async-overhead">Async Overhead</h2>
<p>The cost of async machinery.</p>
<h3 id="coroutine-creation">Coroutine Creation</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Create coroutine object (no await)</td>
          <td>47.0 ns (21.3M ops/sec)</td>
      </tr>
      <tr>
          <td>Create coroutine (with return value)</td>
          <td>45.3 ns (22.1M ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h3 id="running-coroutines">Running Coroutines</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>run_until_complete(empty)</code></td>
          <td>27.6 Œºs (36.2k ops/sec)</td>
      </tr>
      <tr>
          <td><code>run_until_complete(return value)</code></td>
          <td>26.6 Œºs (37.5k ops/sec)</td>
      </tr>
      <tr>
          <td>Run nested await</td>
          <td>28.9 Œºs (34.6k ops/sec)</td>
      </tr>
      <tr>
          <td>Run 3 sequential awaits</td>
          <td>27.9 Œºs (35.8k ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h3 id="asynciosleep">asyncio.sleep()</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>asyncio.sleep(0)</code></td>
          <td>39.4 Œºs (25.4k ops/sec)</td>
      </tr>
      <tr>
          <td>Coroutine with <code>sleep(0)</code></td>
          <td>41.8 Œºs (23.9k ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h3 id="asynciogather">asyncio.gather()</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>gather()</code> 5 coroutines</td>
          <td>49.7 Œºs (20.1k ops/sec)</td>
      </tr>
      <tr>
          <td><code>gather()</code> 10 coroutines</td>
          <td>55.0 Œºs (18.2k ops/sec)</td>
      </tr>
      <tr>
          <td><code>gather()</code> 100 coroutines</td>
          <td>155 Œºs (6.5k ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h3 id="task-creation">Task Creation</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>create_task()</code> + await</td>
          <td>52.8 Œºs (18.9k ops/sec)</td>
      </tr>
      <tr>
          <td>Create 10 tasks + gather</td>
          <td>85.5 Œºs (11.7k ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h3 id="async-context-managers--iteration">Async Context Managers &amp; Iteration</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>async with</code> (context manager)</td>
          <td>29.5 Œºs (33.9k ops/sec)</td>
      </tr>
      <tr>
          <td><code>async for</code> (5 items)</td>
          <td>30.0 Œºs (33.3k ops/sec)</td>
      </tr>
      <tr>
          <td><code>async for</code> (100 items)</td>
          <td>36.4 Œºs (27.5k ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h3 id="sync-vs-async-comparison">Sync vs Async Comparison</h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Time</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Sync function call</td>
          <td>20.3 ns (49.2M ops/sec)</td>
      </tr>
      <tr>
          <td>Async equivalent (<code>run_until_complete</code>)</td>
          <td>28.2 Œºs (35.5k ops/sec)</td>
      </tr>
  </tbody>
</table>
<hr/>
<h2 id="methodology">Methodology</h2>
<h3 id="benchmarking-approach">Benchmarking Approach</h3>
<ul>
<li>All benchmarks run multiple times and with warmup not timed</li>
<li>Timing uses <code>timeit</code> or <code>perf_counter_ns</code> as appropriate</li>
<li>Memory measured with <code>sys.getsizeof()</code> and <code>tracemalloc</code></li>
<li>Results are median of N runs</li>
</ul>
<h3 id="environment">Environment</h3>
<ul>
<li><strong>OS:</strong> macOS 26.2</li>
<li><strong>Python:</strong> 3.14.2 (CPython)</li>
<li><strong>CPU:</strong> ARM - 14 cores (14 logical)</li>
<li><strong>RAM:</strong> 24.0 GB</li>
</ul>
<h3 id="code-repository">Code Repository</h3>
<p>All benchmark code available at: <a href="https://github.com/mkennedy/python-numbers-everyone-should-know">https://github.com/mkennedy/python-numbers-everyone-should-know</a></p>
<hr/>
<h2 id="key-takeaways">Key Takeaways</h2>
<ol>
<li><strong>Memory overhead</strong>: Python objects have significant memory overhead - even an empty list is 56 bytes</li>
<li><strong>Dict/set speed</strong>: Dictionary and set lookups are extremely fast (O(1) average case) compared to list membership checks (O(n))</li>
<li><strong>JSON performance</strong>: Alternative JSON libraries like <code>orjson</code> and <code>msgspec</code> are 3-11x faster than stdlib <code>json</code></li>
<li><strong>Async overhead</strong>: Creating and awaiting coroutines has measurable overhead - only use async when you need concurrency</li>
<li><strong><code>__slots__</code> tradeoff</strong>: While <code>__slots__</code> saves memory, the difference for attribute access speed is minimal</li>
</ol>
<hr/>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>Inspired by <a href="https://gist.github.com/jboner/2841832">Latency Numbers Every Programmer Should Know</a> and similar resources.</p>
<hr/>
<p>*Last updated: 2025-12-31</p>


</div></div>
  </body>
</html>
