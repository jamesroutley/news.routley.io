<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zverok.space/blog/2024-10-21-global_functions.html">Original</a>
    <h1>There is no such thing as a global method (in Ruby)</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p><strong>What Ruby‚Äôs top-level methods actually are, who they belong to and how they are namespaced.</strong></p>

<p>A few days ago, a curious question <a href="https://www.reddit.com/r/ruby/comments/1g5ma34/question_about_kernelrand/">was asked</a> on /r/ruby, which can be boiled down to this: <strong>How are the methods of the <a href="https://docs.ruby-lang.org/en/3.3/Kernel.html">Kernel</a> module available in the top-level scope?</strong></p>

<p>The question was dedicated to <code>rand</code> method, but (as the author correctly suggests) it also applies to many seemingly ‚Äútop-level‚Äù methods documented as belonging to the <code>Kernel</code> module, even as base as <code>puts</code> (print a string), <code>require</code> (load code from another file), or <code>raise</code> (an exception).</p>

<p>We know that in Ruby, all methods belong to some objects and are defined in their classes or modules. The documentation suggests that all of those ‚Äúglobal‚Äù methods are coming from the <code>Kernel</code> module, yet you typically call them without referring to any module, object, or any other ceremonies (like loading some namespace or adding it to the current scope). So, <strong>how to understand this working?</strong></p>



<h2 id="it-is-always-a-method-of-self">It is always a method of <code>self</code></h2>

<p>In Ruby (unlike most other OO languages), the bare lowercase identifier <code>foo</code> always refers to either a local variable or (if there is no such variable in the current scope) <em>the method of the current object</em> (the one that <code>self</code> refers to in the current scope).</p>

<p>So,</p>

<p>is always<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup> the same as</p>


<p>What is the <code>self</code> in the top-level scope? It is a special object, which is called <code>main</code> (though you can‚Äôt access it by this identifier, so ‚Äúmain‚Äù is just a representation thing):</p>
<div><div><pre><code><span>self</span>                 <span>#=&gt; main</span>
<span>self</span><span>.</span><span>class</span>           <span>#=&gt; Object</span>
<span>self</span><span>.</span><span>class</span><span>.</span><span>ancestors</span> <span>#=&gt; [Object, Kernel, BasicObject]</span>
</code></pre></div></div>

<p>So, we can see that it is just an instance of the generic <code>Object</code>, available as a top-level scope, and as such, it includes the module <code>Kernel</code> and all methods from it, therefore making <code>puts</code> available:</p>

<div><div><pre><code><span>m</span> <span>=</span> <span>method</span><span>(</span><span>:puts</span><span>)</span>  <span>#=&gt; #&lt;Method: Object(Kernel)#puts(*)&gt;</span>
<span>m</span><span>.</span><span>owner</span>            <span>#=&gt; Kernel -- who defined it</span>
<span>m</span><span>.</span><span>receiver</span>         <span>#=&gt; main -- object which will receive the call</span>
</code></pre></div></div>

<p>But‚Ä¶ What‚Äôs the deal with this <code>Kernel</code> module anyway?</p>

<h3 id="confusing-legacy-quirk-kernel-vs-object">Confusing legacy quirk: <code>Kernel</code> vs <code>Object</code></h3>

<p><em>Ideologically</em>, it was intended for <code>Kernel</code> module to be a storage for those ‚Äúglobal‚Äù methods, available everywhere. All of them are private<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup>, i.e., available only to call on the current object from inside this object, thus making them look global:</p>
<div><div><pre><code><span>self</span><span>.</span><span>private_methods</span><span>.</span><span>include?</span><span>(</span><span>:puts</span><span>)</span> <span>#=&gt; true</span>

<span>ref</span> <span>=</span> <span>self</span>
<span>ref</span><span>.</span><span>puts</span> <span>&#34;Something&#34;</span>
<span># NoMethodError: private method `puts&#39; called for main:Object</span>
</code></pre></div></div>

<p>At the same time, methods defined in a base <a href="https://docs.ruby-lang.org/en/3.3/Object.html">Object</a> class, the common ancestor of all other classes<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup>, are <em>public</em> methods that are available on every object for other objects, like <code>#inspect</code>, <code>#to_s</code>, <code>#respond_to?(method)</code>, <code>#is_a?(some_class)</code>, and so on.</p>

<p>But that‚Äôs how it was <em>meant to be</em>. In fact, <em>most</em> of the above public methods are also defined in <code>Kernel</code>, which is easy to check:</p>

<div><div><pre><code><span>Object</span><span>.</span><span>instance_method</span><span>(</span><span>:is_a?</span><span>)</span>       <span>#=&gt; #&lt;UnboundMethod: Kernel#is_a?(_)&gt;</span>
<span>Object</span><span>.</span><span>instance_method</span><span>(</span><span>:is_a?</span><span>).</span><span>owner</span> <span>#=&gt; Kernel</span>
<span>Object</span><span>.</span><span>instance_methods</span> <span>-</span> <span>Kernel</span><span>.</span><span>instance_methods</span>
<span>#=&gt; [:!, :equal?, :__id__, :__send__, :==, :!=, :instance_eval, :instance_exec]</span>
</code></pre></div></div>
<p>As you can see, a very small batch of what is ‚Äúideologically‚Äù public methods of every object are actually defined in <code>Object</code> class.</p>

<p><strong>But</strong>, looking at the <a href="https://docs.ruby-lang.org/en/3.3/Object.html"><code>Object</code>‚Äôs docs</a>, you‚Äôll see much more of them. This is literally a hack in RDoc (Ruby‚Äôs documentation system) to make it <em>look</em> like it is meant to be.</p>

<p><strong>But</strong>, this hack is old and unaware of core methods being defined with Ruby (not C) code, and some of the public (ideologically <code>Object</code>‚Äôs) methods ‚Äúslip‚Äù back into <code>Kernel</code>, like <a href="https://docs.ruby-lang.org/en/3.3/Kernel.html#method-i-then">#then</a> or even <a href="https://docs.ruby-lang.org/en/3.3/Kernel.html#method-i-class">#class</a> (e.g. <code>obj.class</code>). There is a <a href="https://bugs.ruby-lang.org/issues/19304">long discussion</a> about handling it in a saner way (which includes some explanation for how it happened), but it hasn‚Äôt moved much yet.</p>

<h2 id="when-you-puts-inside-an-object">When you <code>puts</code> inside an object</h2>

<p>So, if <code>puts</code> is actually not a ‚Äúglobal‚Äù method, but a private method which is included from <code>Kernel</code> in every object, then‚Ä¶ When you call <code>puts</code> from inside some other class‚Äô method, <em>whose</em> <code>puts</code> is this?</p>

<p>Of the object that calls it!</p>

<div><div><pre><code><span>class</span> <span>A</span>
  <span>def</span> <span>test</span>
    <span>p</span> <span>method</span><span>(</span><span>:puts</span><span>)</span>          <span>#=&gt; #&lt;Method: A(Kernel)#puts(*)&gt;</span>
    <span>#                                      ^ who owns the method actually</span>
    <span>p</span> <span>method</span><span>(</span><span>:puts</span><span>).</span><span>receiver</span> <span>#=&gt; #&lt;A:0x00...&gt;</span>
  <span>end</span>
<span>end</span>

<span>A</span><span>.</span><span>new</span><span>.</span><span>test</span>
</code></pre></div></div>

<p>This is <em>different</em> from most other languages (and, therefore, probably, from the default intuition of many developers), where ‚Äúglobal‚Äù methods really do belong to some ‚Äúglobal‚Äù scope and not to the current object.</p>

<p>This might be considered just an esoteric internal quirk, but understanding this fact may be useful sometimes. Say, in testing some Text UI class, one might want to write test code that checks that some class prints elements of the UI on a method call. (There are special <a href="https://rspec.info/features/3-13/rspec-expectations/built-in-matchers/output/">RSpec matchers</a> to check that, but let‚Äôs use this example for simplicity; there are many other Kernel methods that one might want to stub/expect in tests):</p>

<div><div><pre><code><span>class</span> <span>MyUI</span>
  <span>def</span> <span>header</span>
    <span>puts</span> <span>&#34;-----&#34;</span>
  <span>end</span>
<span>end</span>

<span>RSpec</span><span>.</span><span>describe</span> <span>MyUI</span> <span>do</span>
  <span>let</span><span>(</span><span>:instance</span><span>)</span> <span>{</span> <span>described_class</span><span>.</span><span>new</span> <span>}</span>

  <span>describe</span> <span>&#39;#header&#39;</span> <span>do</span>
    <span>it</span> <span>&#34;outputs header (would fail)&#34;</span> <span>do</span>
      <span># No, that `puts` from inside the class wouldn‚Äôt call Kernel.puts</span>
      <span>expect</span><span>(</span><span>Kernel</span><span>).</span><span>to</span> <span>receive</span><span>(</span><span>:puts</span><span>).</span><span>with</span><span>(</span><span>&#39;-----&#39;</span><span>)</span>
      <span>instance</span><span>.</span><span>header</span>
    <span>end</span>

    <span>it</span> <span>&#34;outputs header (correct way)&#34;</span> <span>do</span>
      <span># because it owns its `puts`!</span>
      <span>expect</span><span>(</span><span>instance</span><span>).</span><span>to</span> <span>receive</span><span>(</span><span>:puts</span><span>).</span><span>with</span><span>(</span><span>&#39;-----&#39;</span><span>)</span>
      <span>instance</span><span>.</span><span>header</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<div>
  <h3>A postcard from üá∫üá¶</h3>

  <p><em><strong>Please stop here for a moment.</strong> This is your regular mid-text reminder that I am a living person from Ukraine, with the Russian invasion still ongoing. Please read it.</em></p>

  <p><strong>One news item.</strong> There are reliable reports that soldiers from North Korea (as many as 12000) <a href="https://x.com/KhaterDiana/status/1847253931203670365">are currently training in Russia to participate in the war in Ukraine</a>.</p>

  <p><strong>One piece of context.</strong> A year ago, on Oct 21, 2023, my best friend from the army training camp was killed in the front line. I wrote a bit about him in a mid-text ‚Äúpostcard‚Äù <a href="https://zverok.space/blog/2023-11-03-syntax-sugar2-pattern-matching-fin.html">here</a>. Here is a small <a href="https://x.com/zverok/status/1848284613048729777">memorial Twitter thread</a> about him.</p>

  <p><strong>One fundraiser.</strong> Please help <a href="https://x.com/zverok/status/1845118020110139857">raise money</a> for a volunteer, Olena Samoilenko, who helps the elderly, disabled, and other disadvantaged inhabitants of the Kherson region.</p>
</div>

<h2 id="what-about-custom-top-level-methods">What about custom top-level methods?</h2>

<p>So, if all that looks like ‚Äústandard global methods‚Äù are actually methods of the current object (included from <code>Kernel</code>), what about <em>user-defined global methods</em>?</p>

<div><div><pre><code><span>def</span> <span>my_method</span>
  <span>puts</span> <span>&#34;who am i? </span><span>#{</span><span>self</span><span>}</span><span>&#34;</span>
<span>end</span>
</code></pre></div></div>

<p>The situation is almost exactly the same: such methods become <em>private instance methods</em> of the <code>Object</code> class, and as such, <em>they are available in every object</em>:</p>

<div><div><pre><code><span>method</span><span>(</span><span>:my_method</span><span>)</span> <span>#=&gt; #&lt;Method: Object#my_method() test.rb:1&gt;</span>

<span>my_method</span> <span># called in the context of the main object</span>
<span># prints: &#34;who am i? main&#34;</span>

<span>class</span> <span>A</span>
  <span>def</span> <span>test</span>
    <span>my_method</span>
  <span>end</span>
<span>end</span>

<span>a</span> <span>=</span> <span>A</span><span>.</span><span>new</span>
<span>a</span><span>.</span><span>method</span><span>(</span><span>:my_method</span><span>)</span> <span>#=&gt; #&lt;Method: A(Object)#my_method() test.rb:1&gt;</span>
<span>a</span><span>.</span><span>test</span> <span># invokes my_method that belongs to A</span>
<span># prints: who am i? #&lt;A:0x0...&gt;</span>
</code></pre></div></div>

<p>So, once again: <strong>all top-level methods are actually present in every object</strong>.</p>

<p>This is a clear and consistent system‚Ä¶ Which might sometimes lead to extremely weird quirks with the metaprogramming code, which checks for some method‚Äôs presence by name and changes the behavior depending on it.</p>

<p>We actually caught one just last week: deep in Rails insides, there was serialization code that relied on whether the current object <code>respond_to?(:avatar_url)</code>‚Äîand in some completely unrelated place, a helper module was included into the global scope, which made <em>all</em> objects to have <code>avatar_url</code> method‚Ä¶ But not the one that would be expected there in the serialization code. Extremely funny to debug!</p>

<p>The outtake is: <em>keep your top-level scope clean of random methods, especially those with generic names, and including those that might come from included modules.</em></p>

<blockquote>
  <p><strong>How others do it:</strong> To the best of my knowledge, there is no other languages (at least amongst relatively mainstream ones) with such an approach to ‚Äúglobal‚Äù methods. Most of the OO languages either fully prohibit those (Java/C#, you only can have <code>SomeClass.static_method</code>); or there is no object context (no <code>this</code>/<code>self</code>) in those methods (Kotlin, Python, PHP), or the methods are truly global, and <code>this</code> in them consistently refers to some global object (JS with its <code>globalThis</code>, Scala). But I might miss something!</p>
</blockquote>

<h2 id="is-the-main-scope-special">Is the main scope special?</h2>

<p>The ‚Äúmain scope is special, everything there goes directly into the <code>Object</code> class‚Äù is a good enough heuristic to remember, but one might be interested to observe that the top-level code behaves like <em>any method body</em>: as if it is all performed in a method of an instance of the <code>Object</code> class. In Ruby, you can have nested method definitions, but they don‚Äôt define local methods and instead go to the parent class:</p>

<div><div><pre><code><span>class</span> <span>A</span>
  <span>def</span> <span>outer</span>
    <span># See, we are defining helper inner method!</span>
    <span>def</span> <span>inner</span><span>(</span><span>i</span><span>)</span> <span>=</span> <span>print</span><span>(</span><span>&#34;iteration </span><span>#{</span><span>i</span><span>}</span><span>&#34;</span><span>)</span>

    <span>5</span><span>.</span><span>times</span> <span>{</span> <span>inner</span><span>(</span><span>_1</span><span>)</span> <span>}</span>
  <span>end</span>
<span>end</span>

<span>a</span> <span>=</span> <span>A</span><span>.</span><span>new</span>
<span>a</span><span>.</span><span>outer</span> <span># prints &#34;iteration 0&#34;, &#34;iteration 1&#34;, etc.</span>
<span>a</span><span>.</span><span>inner</span><span>(</span><span>1000</span><span>)</span> <span># prints &#34;iteration 1000&#34; -- the method is now defined in a!</span>
<span># ...and moreover</span>
<span>A</span><span>.</span><span>new</span><span>.</span><span>inner</span><span>(</span><span>2000</span><span>)</span> <span># prints &#34;iteration 2000&#34; -- it belongs to the A class</span>
</code></pre></div></div>

<p>Like many things in Ruby, it is ‚Äúunlike most of other languages, but self-consistent.‚Äù</p>

<p>With this knowledge, we can model <code>main</code> method and its definitions behavior this way:</p>

<div><div><pre><code><span>my_main</span> <span>=</span> <span>Object</span><span>.</span><span>new</span>

<span>def</span> <span>my_main</span><span>.</span><span>implicit_top_level</span>
  <span># that&#39;s where all your top-level code go</span>
  <span>def</span> <span>other_method</span>
    <span>puts</span> <span>&#34;OK!&#34;</span>
  <span>end</span>
<span>end</span>

<span>my_main</span><span>.</span><span>implicit_top_level</span>
<span># `my_main` is an instance of object,</span>
<span># so `other_method` is now defined in object</span>
<span># Let‚Äôs check:</span>
<span>Object</span><span>.</span><span>new</span><span>.</span><span>other_method</span>
<span># prints &#34;OK!&#34;</span>

<span># And as everything, including the top-level scope, inherits from Object,</span>
<span># we have it here:</span>
<span>other_method</span>
<span># prints &#34;OK!&#34;</span>
</code></pre></div></div>

<p>Here is Ruby for you, keeping on its ‚Äúslightly peculiar yet consistent‚Äù side for most of the time.</p>

<blockquote>
  <p>This equivalence breaks when we talk about constants. All constants (including classes and modules) in the main scope are nested into the <code>Object</code>, too; but it wouldn‚Äôt work in our <code>main_scope_method</code>. So‚Ä¶ It is a bit special thing, after all! Or, rather, it behaves consistently with a method body for everything other than constants; and consistently with class/module body for constants.</p>
</blockquote>

<h2 id="summarizing-it">Summarizing it</h2>

<p>Just to reiterate:</p>

<ul>
  <li>In Ruby, there is no such thing as a top-level/global method; the method without an explicit receiver (the core one or user-defined one) is always a <strong>method of the current object</strong>;</li>
  <li>Methods defined on the top level become <strong>instance methods of every object</strong>; modules <code>include</code>d into the top-level scope, are included into the <code>Object</code>;</li>
  <li>This distinction‚Äîthat methods are never really ‚Äúglobal‚Äù‚Äîcan be mostly ignored, but it is useful to have an accurate mental model when using metaprogramming or debugging large codebases;</li>
  <li>Everything is inspectable and should be inspected;</li>
  <li>Many things are peculiar yet self-consistent.</li>
</ul>

<p>Hope this helps :)</p>

<hr/>

<p><strong>Thank you for reading. Please support Ukraine with your donations and lobbying for military and humanitarian help. <a href="https://war.ukraine.ua/">Here</a>, you‚Äôll find a comprehensive information source and many links to state and private funds accepting donations.</strong></p>

<p><strong>If you don‚Äôt have time to process it all, donating to <a href="https://savelife.in.ua/en/">Come Back Alive</a> foundation is always a good choice.</strong></p>




  </div></div>
  </body>
</html>
