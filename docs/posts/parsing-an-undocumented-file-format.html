<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.vivekpanyam.com/parsing-an-undocumented-file-format">Original</a>
    <h1>Parsing an Undocumented File Format</h1>
    
    <div id="readability-page-1" class="page"><div><dl><p><dt>Published on</dt><dd><time datetime="2023-12-28T00:00:00.000Z">December 28, 2023</time></dd></p></dl></div><div><p>A year or two ago, I wrote a parser for an undocumented file format as part of a larger project. This was somewhat challenging and I wanted to share my approach because I thought it was a neat idea that worked well.</p><h2 id="cuda-binary-formats"><a href="#cuda-binary-formats" aria-hidden="true" tabindex="-1"><span></span></a>CUDA binary formats</h2><p>I needed to write a parser for <a target="_blank" rel="noopener noreferrer" href="https://docs.nvidia.com/cuda/cuda-binary-utilities/index.html#what-is-a-cuda-binary">CUDA binary</a> files. These are GPU executable files generated from compiling CUDA code and are often embedded within other applications.</p><p>The detailed format of these files is unfortunately not publicly available.</p><p>Thankfully, NVIDIA provides tools like <a target="_blank" rel="noopener noreferrer" href="https://docs.nvidia.com/cuda/cuda-binary-utilities/index.html#cuobjdump"><code>cuobjdump</code></a> that can parse and display the information they contain.</p><p>As an example, we can look at a snippet of the <code>cuobjdump</code> output for a CUDA binary file within PyTorch:</p><div><pre><code><span><span>.</span><span>nv</span><span>.</span><span>info</span><span>.</span><span>_ZN2at6native13reduce_kernelILi512ELi1ENS0_8ReduceOpIN3c107complexIfEENS0_7NormOpsIS5_fEEjfLi4EEEEEvT1_</span>
</span><span>        
</span><span>        <span>&lt;</span><span>0x3</span><span>&gt;</span>
</span><span>        <span>Attribute</span><span>:</span>      <span>EIATTR_KPARAM_INFO</span>
</span><span>        <span>Format</span><span>:</span> <span>EIFMT_SVAL</span>
</span><span>        <span>Value</span><span>:</span>  <span>Index</span> <span>:</span> <span>0x0</span>     <span>Ordinal</span> <span>:</span> <span>0x0</span>   <span>Offset</span>  <span>:</span> <span>0x0</span>   <span>Size</span>    <span>:</span> <span>0x418</span>
</span><span>                <span>Pointee</span>&#39;s logAlignment <span>:</span> <span>0x0</span>    <span>Space</span> <span>:</span> <span>0x0</span>     <span>cbank</span> <span>:</span> <span>0x1f</span>    <span>Parameter</span> <span>Space</span> <span>:</span> <span>CBANK</span>
</span><span>        
</span><span>        <span>&lt;</span><span>0x8</span><span>&gt;</span>
</span><span>        <span>Attribute</span><span>:</span>      <span>EIATTR_MAX_THREADS</span>
</span><span>        <span>Format</span><span>:</span> <span>EIFMT_SVAL</span>
</span><span>        <span>Value</span><span>:</span>  <span>0x200</span> <span>0x1</span> <span>0x1</span>
</span><span>        <span>&lt;</span><span>0x9</span><span>&gt;</span>
</span><span>        <span>Attribute</span><span>:</span>      <span>EIATTR_CRS_STACK_SIZE</span>
</span><span>        <span>Format</span><span>:</span> <span>EIFMT_SVAL</span>
</span><span>        <span>Value</span><span>:</span>  <span>0x0</span>
</span></code></pre></div><p>The output above shows information about a specific CUDA kernel (&#34;a GPU function&#34;) including its parameters and layout in memory.</p><p>My goal was to build a library that could directly parse and extract this information from CUDA binary files.</p><h2 id="building-a-parser"><a href="#building-a-parser" aria-hidden="true" tabindex="-1"><span></span></a>Building a parser</h2><p>The core insight I had was that if I could reimplement the <code>cuobjdump</code> tool on top of my library, I could then compare the output of my <code>cuobjdump</code> to the output of the real <code>cuobjdump</code> to validate my parser.</p><p><img alt="Overview" src="https://blog.vivekpanyam.com/static/images/2023/parsing/cuda_process2.png" width="1632" height="559"/></p><p>By testing my reimplementation in this way on thousands of CUDA binaries from several major libraries, I could be pretty confident that my parsing library was correct (or correct enough for my needs).</p><p>This worked for a few reasons:</p><ul><li>The text output format of <code>cuobjdump</code> is relatively clear and straightforward to implement given the output of a parser</li><li>We can get several thousand test files. In fact, if we extract all the CUDA binary files in PyTorch, we get ~3830 files!</li><li><code>cuobjdump</code> can print out all the information in a CUDA binary (i.e. it can be used to validate a complete parser)</li></ul><p>This approach also made it straightforward to incrementally implement the parser. For example, if my implementation only parsed one field, I could modify the comparison step to only validate that piece of the output. This let me check a subset of the parsing logic across thousands of files without needing to understand the whole file format.</p><p>By highlighting specific differences between the output of the real <code>cuobjdump</code> and my implementation, it became easy to find and fix bugs. This also made it easy to add support for new versions of CUDA and new GPU architectures.</p><p>Concretely, if I was trying to parse a byte sequence like <code>0x04 0x17 ...</code>, I could look at a bunch of examples and come up with a hypothesis like &#34;If the first byte is <code>0x04</code>, the format is <code>EIFMT_SVAL</code>.&#34; By testing hypotheses like this one across all the sample files, I could build the parser piece by piece. This was fairly efficient because the test process was automated and displayed clear diffs when the outputs didn&#39;t match.</p><p>Here&#39;s the byte sequence that corresponds to the first section of the <code>cuobjdump</code> output above:</p><div><pre><code><span><span>0x04</span> 
</span><span><span>0x17</span> 
</span><span>
</span><span><span>0x0c</span> <span>0x00</span> 
</span><span>
</span><span><span>0x00</span> <span>0x00</span> <span>0x00</span> <span>0x00</span> 
</span><span><span>0x00</span> <span>0x00</span> 
</span><span><span>0x00</span> <span>0x00</span> 
</span><span><span>0x00</span> 
</span><span>
</span><span>
</span><span><span>0xf0</span> <span>0x61</span> <span>0x10</span>
</span></code></pre></div><h2 id="open-source"><a href="#open-source" aria-hidden="true" tabindex="-1"><span></span></a>Open source</h2><p>The parser and test suite are now open source at <a target="_blank" rel="noopener noreferrer" href="https://github.com/VivekPanyam/cudaparsers">https://github.com/VivekPanyam/cudaparsers</a>. Feel free to check out the repo if you&#39;re curious about the details.</p><h2 id="other-uses-of-this-technique"><a href="#other-uses-of-this-technique" aria-hidden="true" tabindex="-1"><span></span></a>Other uses of this technique</h2><p>This general approach works well when building and testing alternate implementations of things.</p><p>The overall idea is that if you have a way of getting the &#34;right&#34; answer for a lot of sample inputs, you can use it to test and incrementally build your own implementation of something.</p><p><img alt="Overview" src="https://blog.vivekpanyam.com/static/images/2023/parsing/overview.png" width="1250" height="518"/></p><p>By automating and scaling this process to lots of inputs, you can have high confidence in your implementation. It&#39;s especially useful if the output format lets you do fine-grained comparisons that provide useful information about what is incorrect<sup><a href="#user-content-fn-1" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-1">1</a></sup>.</p><p>There are probably several examples of this technique in practice, but here&#39;s one that comes to mind at the time of writing:</p><ul><li>When implementing <a target="_blank" rel="noopener noreferrer" href="https://github.com/facebook/yoga">Yoga</a> (a flexbox layout engine), the team behind it used a browser as the reference implementation and built a test suite that compared the output of Yoga and the browser</li></ul><p>If you have interesting examples of this approach or any other thoughts, feel free to <a href="https://blog.vivekpanyam.com/contact">send me an email</a>!</p></div></div>
  </body>
</html>
