<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mathetake.github.io/posts/runtime-code-generation-in-go-part-1/">Original</a>
    <h1>Runtime code generation and execution in Go</h1>
    
    <div id="readability-page-1" class="page"><div><p><strong>Disclaimer: I won’t expand on why/when you want to do this kind of hack, and you should not do this unless you know exactly what you are doing.
Everything I talk about here is completely unsafe and might not be accurate for the future Go versions. This is not a recommendation, but more of a fun story.</strong></p><p>A few days ago, I posted about the idea of a blog post on runtime code generation and execution in Go:</p><blockquote><p lang="en" dir="ltr">feel like i should write a blog post about how to write JIT engine in pure Go and really weird bugs I encountered in the development of wazero&#39;s compiler if anyone wants to read</p>— Takeshi Yoneda(マスタケ) (@mathetake) <a href="https://twitter.com/mathetake/status/1791699003467542569?ref_src=twsrc%5Etfw">May 18, 2024</a></blockquote><p>And it got a lot of attention way more than I expected, so I decided to do it. I don’t think single post is enough to cover all I want to share,
so I’ll split it into multiple posts (please hope I won’t die before I finish it).</p><p>First of all, who am I? In case you don’t know me, which is likely the case for most of you,
I’m an open source software engineer working for a startup called <a href="https://tetrate.io/">Tetrate.io</a>.
In the last few years, I was knee-deep in the space of WebAssembly and its ecosystem,
and service mesh related software like Envoy and Istio(<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>,<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>). I’ve mostly written Go/C++ at work, but also like to use Rust and Zig<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> in side projects.</p><p>More importantly, I am the creator of <a href="https:://github.com/tetratelabs/wazero">wazero</a> WebAssembly runtime, and that’s
where I learned tons of things about runtime code generation and execution in Go.
wazero was once a part of my hobby project, but luckily it became a part of my job in the last 2.5 years thanks to the support by my employer.</p><p>wazero is an extremely unique and rare piece of production software out there in the Go ecosystem in the sense that
it generates semantically equivalent x86-64 and AArch64 machine code from WebAssembly bytecode at runtime,
and then provides the API to execute and interact with it <strong>with zero dependency, hence without CGo</strong>. At the GopherCon 2022, I gave a talk on wazero, so if you are more curious
about wazero itself, please take a look at my talk<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> as well as the wazero’s <a href="https://wazero.io">website</a>. It has a neat documentation about
how its optimizing compiler works<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>.</p><p>This post is decoupled from wazero itself, and I’ll focus on the general concept of runtime code generation and execution in Go.
In the subsequent posts, if I have enough time and energy, I’ll dive into quirky bugs I encountered in the development of wazero’s compiler.
Hope you can enjoy the post, and feel free to ask me anything on <a href="https://twitter.com/mathetake">X/Twitter</a>.
I spend more of spare time on hacking weird low-level stuff you can find on my <a href="https://github.com/mathetake">GitHub</a>, so check it out if you are interested.</p><p>From here, I assume readers have the basic understanding of Go as well as the concepts of stack and function calls in the low-level programming.</p><h2 id="terminology-runtime-code-generation-and-execution-vs-jit-aot">Terminology: Runtime Code Generation and Execution vs (JIT, AOT)</h2><p>Okay, the first things first, let me clarify wtf I meant by “runtime code generation and execution”.
I intentionally stick to use the phrase “runtime code generation and execution” instead of the simple “JIT” (Just-In-Time) or “AOT” (Ahead-Of-Time) compilation, where
the latter two are more common terms in general. But I find them confusing and misused sometimes<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>.</p><p><strong>AOT</strong> generally refers to the process of compiling the source code into machine code <strong>before</strong> the execution of the program.
In contrast, <strong>JIT</strong> refers to the process of compiling the source code into machine code <strong>during</strong> the execution of the program.</p><p>But this creates a confusion: What if we compile a piece of source program <em>in a process</em> and then execute it <em>in the same process</em>,
do you call it AOT or JIT? Sure, it is clear that that is not JIT in the same sense as the JIT in the JVMs because
it doesn’t compile during the execution, but on the other hand, it does “compilation during execution (of the host program)”.
In WebAssembly community in general, people sometimes mistakenly call this kind of “runtime code generation and execution” as JIT.
Actually, wazero used to call itself as JIT runtime, but later we decided to avoid the term. As far as I understand, most of the “WebAssembly runtime”
out there are <em>not</em> JIT in the sense of JVMs<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup>, but they are more like AOT.</p><p>So anyway, I stick to use the term “runtime code generation and execution” to avoid the confusion, though it is not a standard term and verbose.
In other words, what I am going to talk about is <strong>a pure Go program that generates a machine code and executes it in the same process</strong>. I might call the
generated machine code as “JITed code”, but it’s the only exception.</p><h2 id="prior-art">Prior art</h2><p>So I guess the “runtime code generation and execution” sounds terrible and pretty crazy to you and normal Go developers.
I was also one of you until I started to work on wazero. But actually, there are some prior art in the Go ecosystem that do similar things,
or at least there have been some attempts to do so. Basically, I am definitely not the only crazy person who wanted to do this kind of stuff in Go.
With the quick search on the web, I found the following projects besides wazero:</p><ul><li><a href="https://github.com/nelhage/gojit">https://github.com/nelhage/gojit</a></li><li><a href="https://github.com/bspaans/jit-compiler">https://github.com/bspaans/jit-compiler</a></li><li><a href="https://www.quasilyte.dev/blog/post/call-go-from-jit/">https://www.quasilyte.dev/blog/post/call-go-from-jit/</a></li><li><a href="https://github.com/quasilyte/go-jdk">https://github.com/quasilyte/go-jdk</a></li><li><a href="https://github.com/bytedance/sonic">https://github.com/bytedance/sonic</a></li></ul><p>Note that all of them were trying to do it without CGo since it’s clearly possible to do runtime code generation and execution with CGo.
You can do whatever you want with CGo, but you know that’s not what we want.</p><h2 id="overview">Overview</h2><p>Basically, the runtime code generation and execution in Go can be broken down into the following steps:</p><ol><li>Generate Machine code represented as <code>[]byte</code> slice which contains the architecture-specific machine code.</li><li>Mark the machine code as executable and readable, usually using <code>mmap</code> on Unix-like systems.</li><li>Take the first address of the machine code as <code>unsafe.Pointer(&amp;slice[0])</code>.</li><li>Call the “trampoline” Go Asm function with the address of the machine code as an argument.<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup></li><li>Jump to the machine code from the trampoline function.</li></ol><p>where the step 1 and 2 are the “code generation” part, and the rest is the “execution” part. To be clear, these will be
almost the same for any language, but in the case of pure Go, we <strong>really really really</strong> need to be careful about the Go runtime behavior
and its implementation details in order to ensure the execution won’t piss off the runtime.
That affects the design of the code generation part as well as the execution part.</p><p>How serious is it? Well, let me give you some terrifying example of what can happen if you make a bug in the code generation part:
If you make this kind of bug like the following</p><div><pre tabindex="0"><code data-lang="diff"><span><span><span>diff --git a/internal/engine/wazevo/backend/isa/arm64/abi.go b/internal/engine/wazevo/backend/isa/arm64/abi.go
</span></span></span><span><span><span>index 6615471c..1747eafa 100644
</span></span></span><span><span><span></span><span>--- a/internal/engine/wazevo/backend/isa/arm64/abi.go
</span></span></span><span><span><span></span><span>+++ b/internal/engine/wazevo/backend/isa/arm64/abi.go
</span></span></span><span><span><span></span><span>@@ -19,9 +19,8 @@ var regInfo = &amp;regalloc.RegisterInfo{
</span></span></span><span><span><span></span>        AllocatableRegisters: [regalloc.NumRegType][]regalloc.RealReg{
</span></span><span><span>                // We don&#39;t allocate:
</span></span><span><span>                // - x18: Reserved by the macOS: https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms#Respect-the-purpose-of-specific-CPU-registers
</span></span><span><span><span>-               // - x28: Reserved by Go runtime.
</span></span></span><span><span><span></span>                // - x27(=tmpReg): because of the reason described on tmpReg.
</span></span><span><span><span>-               regalloc.RegTypeInt: {
</span></span></span><span><span><span></span><span>+               regalloc.RegTypeInt: {x28,
</span></span></span><span><span><span></span>                        x8, x9, x10, x11, x12, x13, x14, x15,
</span></span><span><span>                        x16, x17, x19, x20, x21, x22, x23, x24, x25,
</span></span><span><span>                        x26, x29, x30,
</span></span></code></pre></div><p>where I mistakenly allows the use of AArch64’s <code>x28</code> register in the generated machine code in wazero. The register is reserved and the value must
be the same across the execution to play nicely with the Go runtime.<sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup> If you run the test, you would get errors like the following (it really depends on the kind of bug you made and the platform you are on):</p><div><pre tabindex="0"><code data-lang="shell"><span><span>traceback: unexpected SPWRITE <span>function</span> runtime.morestack
</span></span><span><span>fatal error: traceback
</span></span><span><span>
</span></span><span><span>runtime stack:
</span></span><span><span>runtime.throw<span>({</span>0x100ecb49d?, 0x100d05fa0?<span>})</span>
</span></span><span><span>	/usr/local/go/src/runtime/panic.go:1023 +0x40 <span>fp</span><span>=</span>0x1729aed40 <span>sp</span><span>=</span>0x1729aed10 <span>pc</span><span>=</span>0x100ccd1b0
</span></span><span><span>runtime.<span>(</span>*unwinder<span>)</span>.resolveInternal<span>(</span>0x1729aee90, 0x0?, 0xee?<span>)</span>
</span></span><span><span>	/usr/local/go/src/runtime/traceback.go:364 +0x318 <span>fp</span><span>=</span>0x1729aedc0 <span>sp</span><span>=</span>0x1729aed40 <span>pc</span><span>=</span>0x100cfa108
</span></span><span><span>runtime.<span>(</span>*unwinder<span>)</span>.next<span>(</span>0x1729aee90<span>)</span>
</span></span><span><span>	/usr/local/go/src/runtime/traceback.go:512 +0x160 <span>fp</span><span>=</span>0x1729aee50 <span>sp</span><span>=</span>0x1729aedc0 <span>pc</span><span>=</span>0x100cfa2b0
</span></span><span><span>runtime.<span>(</span>*_panic<span>)</span>.nextFrame.func1<span>()</span>
</span></span><span><span>	/usr/local/go/src/runtime/panic.go:938 +0x8c <span>fp</span><span>=</span>0x1729aef10 <span>sp</span><span>=</span>0x1729aee50 <span>pc</span><span>=</span>0x100cccddc
</span></span><span><span>runtime.systemstack<span>(</span>0x7ff000<span>)</span>
</span></span><span><span>	/usr/local/go/src/runtime/asm_arm64.s:243 +0x6c <span>fp</span><span>=</span>0x1729aef20 <span>sp</span><span>=</span>0x1729aef10 <span>pc</span><span>=</span>0x100d05f0c
</span></span></code></pre></div><p>which is totally cryptic and hard to debug. This is just one example, and there are many other ways to make the Go runtime angry.
So in other words, the generated machine code must be tailored to the Go runtime behavior,
and that’s the most challenging part of the runtime code generation and execution in Go.</p><h2 id="tiny-demo">Tiny demo</h2><p>The following is the tiny demo of the runtime code generation and execution in Go. I assume you are on a Unix-like system like Linux or macOS on an AArch64 machine,
and you have Go installed on your machine.</p><p>First, we prepare two source codes:</p><div><pre tabindex="0"><code data-lang="shell"><span><span>$ ls
</span></span><span><span>go.mod          main.go         main_arm64.s
</span></span></code></pre></div><p>The main.go is the main Go source code, and the main_arm64.s is the Go Assembly source code.
The main.go is the following:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// main.go
</span></span></span><span><span><span></span><span>package</span> main
</span></span><span><span>
</span></span><span><span><span>import</span> (
</span></span><span><span>	<span>&#34;fmt&#34;</span>
</span></span><span><span>	<span>&#34;syscall&#34;</span>
</span></span><span><span>	<span>&#34;unsafe&#34;</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>// exec is implemented as a Go Assembly function in main_arm64.s
</span></span></span><span><span><span>// entrypoint is the initial address of the machine code.
</span></span></span><span><span><span></span><span>func</span> <span>exec</span>(entrypoint <span>uintptr</span>)
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span>() {
</span></span><span><span>	<span>// 1. Allocate memory for machine code via mmap. At this point, the memory is not executable, but read-writable.
</span></span></span><span><span><span></span>	machineCodeBuf <span>:=</span> <span>mustAllocateByMMap</span>()
</span></span><span><span>
</span></span><span><span>	<span>// 2. TODO: Write machine code to machineCodeBuf.
</span></span></span><span><span><span></span>
</span></span><span><span>	<span>// 3. Mark the memory region as executable. This marks the memory region as read-executable.
</span></span></span><span><span><span></span>	<span>mustMarkAsExecutable</span>(machineCodeBuf)
</span></span><span><span>
</span></span><span><span>	<span>// 4. Execute the machine code.
</span></span></span><span><span><span></span>	entrypoint <span>:=</span> <span>uintptr</span>(unsafe.<span>Pointer</span>(<span>&amp;</span>machineCodeBuf[<span>0</span>]))
</span></span><span><span>	fmt.<span>Printf</span>(<span>&#34;entrypoint: %#x\n&#34;</span>, entrypoint)
</span></span><span><span>	<span>exec</span>(entrypoint)
</span></span><span><span>
</span></span><span><span>	fmt.<span>Println</span>(<span>&#34;ok&#34;</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// mustAllocateByMMap returns a memory region that is read-writable via mmap.
</span></span></span><span><span><span></span><span>func</span> <span>mustAllocateByMMap</span>() []<span>byte</span> {
</span></span><span><span>	machineCodes, err <span>:=</span> syscall.<span>Mmap</span>(<span>-</span><span>1</span>, <span>0</span>,
</span></span><span><span>		<span>// For the purpose of blog post, we allocate 10 pages of memory. That should be enough.
</span></span></span><span><span><span></span>		syscall.<span>Getpagesize</span>()<span>*</span><span>10</span>,
</span></span><span><span>		syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_ANON|syscall.MAP_PRIVATE,
</span></span><span><span>	)
</span></span><span><span>	<span>if</span> err <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>panic</span>(err)
</span></span><span><span>	}
</span></span><span><span>	<span>return</span> machineCodes
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// mustMarkAsExecutable marks the memory region as read-executable via mprotect.
</span></span></span><span><span><span></span><span>func</span> <span>mustMarkAsExecutable</span>(machineCodes []<span>byte</span>) {
</span></span><span><span>	<span>if</span> err <span>:=</span> syscall.<span>Mprotect</span>(machineCodes, syscall.PROT_READ|syscall.PROT_EXEC); err <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>panic</span>(err)
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>where what the <code>main</code> function is supposed to do is the following:</p><ol><li>Allocate memory for machine code via <code>mmap</code>. At this point, the memory is not executable, but read-writable.</li><li>Write machine code to the allocated memory region. At this point, I left it as TODO.</li><li>Mark the memory region as executable. This marks the memory region as read-executable.</li><li>Execute the machine code.</li></ol><p>For the purpose of mmap and how they work in general, please refer to the wonderful article by <a href="https://x.com/elibendersky">@elibendersky</a>: <a href="https://eli.thegreenplace.net/2013/11/05/how-to-jit-an-introduction">How to JIT - an introduction</a>.
In my blog posts, I won’t go into the details on that, and focus on the code generation and execution part.<sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup></p><p>The <code>exec</code> function is implemented as a Go Assembly function in <code>main_arm64.s</code> as follows<sup id="fnref:11"><a href="#fn:11" role="doc-noteref">11</a></sup>:</p><pre tabindex="0"><code>// main_arm64.s
#include &#34;funcdata.h&#34;
#include &#34;textflag.h&#34;

TEXT ·exec(SB), NOSPLIT|NOFRAME, $0-8
    // Load the entry point of the executable into R27.
    MOVD entrypoint+0(FP), R27 
    // Jump to the entry point of the executable stored in R27.
    JMP  (R27)
</code></pre><p>That’s it. Let’s compile and run the program:</p><pre tabindex="0"><code>$ go run .
entrypoint: 0x1051c4000
SIGILL: illegal instruction
PC=0x1051c4000 m=0 sigcode=2
instruction bytes: 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0

goroutine 1 gp=0x140000021c0 m=0 mp=0x104e3a4c0 [running]:
runtime: g 1 gp=0x140000021c0: unknown pc 0x1051c4000
stack: frame={sp:0x1400010aec0, fp:0x0} stack=[0x1400010a000,0x1400010b000)
</code></pre><p>The error you are observing is something that you would <strong>never</strong> encounter in the normal Go program (if you encounter this with normal Go code, that is highly like a bug in the Go compiler!).
But fear not, this is the expected behavior. If you take a closer look at the error message, you can see
that the program tried to execute the machine code at the address <code>0x1051c4000</code>,
which is the address of the machine code we allocated via <code>mmap</code>. But the machine code is not written yet,
so the CPU tried to execute the zero-filled memory region, and that’s why you got the <code>SIGILL</code> error since
the AArch64 instruction encoded as <code>0x00000000</code> is <a href="https://developer.arm.com/documentation/ddi0596/2020-12/Base-Instructions/UDF--Permanently-Undefined-">“Undefined/UDF” instruction</a>.</p><p>One thing you also notice is that the error says <code>unknown pc 0x1051c4000</code>. This is because the Go runtime is not aware of the machine code you generated,
and it doesn’t have the debug information for the machine code.</p><p>Okay, how can we fix this? One of the tiniest functions is the one just that returns, so let’s write the machine code for that:</p><div><pre tabindex="0"><code data-lang="diff"><span><span><span>--- a/codes/runtime_code_generation_in_go/main.go
</span></span></span><span><span><span></span><span>+++ b/codes/runtime_code_generation_in_go/main.go
</span></span></span><span><span><span></span><span>@@ -1,6 +1,7 @@
</span></span></span><span><span><span></span> package main
</span></span><span><span> 
</span></span><span><span> import (
</span></span><span><span><span>+       &#34;encoding/binary&#34;
</span></span></span><span><span><span></span>        &#34;fmt&#34;
</span></span><span><span>        &#34;syscall&#34;
</span></span><span><span>        &#34;unsafe&#34;
</span></span><span><span><span>@@ -14,7 +15,8 @@ func main() {
</span></span></span><span><span><span></span>        // 1. Allocate memory for machine code via mmap. At this point, the memory is not executable, but read-writable.
</span></span><span><span>        machineCodeBuf := mustAllocateByMMap()
</span></span><span><span> 
</span></span><span><span><span>-       // 2. TODO: Write machine code to machineCodeBuf.
</span></span></span><span><span><span></span><span>+       // 2. Write machine code to machineCodeBuf that just returns.
</span></span></span><span><span><span>+       binary.LittleEndian.PutUint32(machineCodeBuf, 0xd6_5f_03_c0)
</span></span></span><span><span><span></span> 
</span></span><span><span>        // 3. Mark the memory region as executable. This marks the memory region as read-executable.
</span></span><span><span>        mustMarkAsExecutable(machineCodeBuf)
</span></span></code></pre></div><p>this patch writes the AArch64 machine code for the <code>RET</code> instruction to the allocated memory region.
The machine code <code>0xd6_5f_03_c0</code> is its encoding as described in the <a href="https://developer.arm.com/documentation/ddi0596/2020-12/Base-Instructions/RET--Return-from-subroutine-">AArch64 manual</a>.
Note that AArch64 is a little-endian architecture, and each instruction is encoded as a 32-bit word.</p><p>Let’s run the program again:</p><div><pre tabindex="0"><code data-lang="shell"><span><span>$ go run .
</span></span><span><span>entrypoint: 0x1050dc000
</span></span><span><span>ok
</span></span></code></pre></div><p>Cool innit? The program successfully executed the machine code that just returns, and the program prints <code>ok</code> as expected from the <code>main</code> function.</p><p>You can browse the whole source code <a href="https://github.com/mathetake/mathetake.github.io/tree/main/codes/runtime_code_generation_in_go_part_1">here</a>.</p><h2 id="conclusion">Conclusion</h2><p>In this post, I introduced the concept of runtime code generation and execution in Go, and showed the tiny demo of it.
The demo is really simple, so I hope readers can understand the basic idea of runtime code generation and execution in Go, but at the same time
I guess you still have no idea on how to write the machine code for the real function or program. In other words, I didn’t explain how to perform function calls just like
any normal Go program does as well as how to return the results from the JITed code to the caller in the Go world. That’s what I am going to cover in the next series of posts.</p><p>If you have any questions, feedback, requests, please let me know on <a href="https://twitter.com/mathetake">X/Twitter</a>. I am happy to answer any questions you have.
Also, I am always looking for an exciting project/problem to work on, so if you have anything in mind and think I can help with it, please let me know as well, I would love to chat.</p><p>See you in the next post!</p></div></div>
  </body>
</html>
