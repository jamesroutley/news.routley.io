<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neon.tech/blog/hello-world/">Original</a>
    <h1>Select ’Hello, World’: Serverless Postgres Built for the Cloud</h1>
    
    <div id="readability-page-1" class="page"><div id="container"><div><p>We have just launched Neon to provide you with the best Postgres experience in the cloud. You can <a href="https://neon.tech/early-access/">sign up to our waitlist</a> right now and experience serverless Postgres enabled by the separation of storage and compute. The service is still gated by the waitlist as we are onboarding more and more users every day, and we expect to open it up for everyone soon.</p><p>Our website <a href="https://news.ycombinator.com/item?id=31536827">showed up on HackerNews</a> a few weeks ago, sooner than we expected and before we officially launched the company. While there was a great deal of discussion there, it’s important for us to talk in detail about the motivation for the project.</p><h2 id="why-neon"><a href="#why-neon" tabindex="-1" aria-hidden="true"><svg viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.813 11.313 15.5 12 21 6.5 15.5 1 10 6.5l.688.688M11.313 14.813 12 15.5 6.5 21 1 15.5 6.5 10l.688.688M8 14l6-6" stroke="#1A1A1A" stroke-width="2" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"></path></svg></a>Why Neon?</h2><p>As we are looking at the world it’s clear to us that database workloads are shifting into the cloud — no one wants to manage a database themselves. We are a team of Postgres hackers, systems and cloud engineers and we are all huge fans of Postgres. We believe that in the ever-changing technology stack Postgres is here to stay. Just like Linux operating system or Git version control Postgres is the default choice for a relational database system.</p><p>That’s why lots of platforms such as AWS, Azure, Google Cloud Platform, Digital Ocean, Heroku, as well as newcomers like Fly.io (we are big fans) offer Postgres as a service.</p><h2 id="built-for-the-cloud"><a href="#built-for-the-cloud" tabindex="-1" aria-hidden="true"><svg viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.813 11.313 15.5 12 21 6.5 15.5 1 10 6.5l.688.688M11.313 14.813 12 15.5 6.5 21 1 15.5 6.5 10l.688.688M8 14l6-6" stroke="#1A1A1A" stroke-width="2" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"></path></svg></a>Built for the Cloud</h2><p>If you look at the architecture of Postgres deployments, be that self-hosted, managed or cloud, often it looks like this:</p><p><span>
      <a href="https://neon.tech/static/a1e782b7c162d1ead925fb1ddc15c497/2b73a/typical_postgres_setups.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/a1e782b7c162d1ead925fb1ddc15c497/bd025/typical_postgres_setups.webp 215w,/static/a1e782b7c162d1ead925fb1ddc15c497/1afa8/typical_postgres_setups.webp 430w,/static/a1e782b7c162d1ead925fb1ddc15c497/2a5e8/typical_postgres_setups.webp 860w,/static/a1e782b7c162d1ead925fb1ddc15c497/32062/typical_postgres_setups.webp 1290w,/static/a1e782b7c162d1ead925fb1ddc15c497/da0ef/typical_postgres_setups.webp 1720w,/static/a1e782b7c162d1ead925fb1ddc15c497/c58b7/typical_postgres_setups.webp 1920w" sizes="(max-width: 860px) 100vw, 860px" type="image/webp"/>
          <source srcset="/static/a1e782b7c162d1ead925fb1ddc15c497/11fb1/typical_postgres_setups.png 215w,/static/a1e782b7c162d1ead925fb1ddc15c497/b8a92/typical_postgres_setups.png 430w,/static/a1e782b7c162d1ead925fb1ddc15c497/22296/typical_postgres_setups.png 860w,/static/a1e782b7c162d1ead925fb1ddc15c497/64578/typical_postgres_setups.png 1290w,/static/a1e782b7c162d1ead925fb1ddc15c497/ae692/typical_postgres_setups.png 1720w,/static/a1e782b7c162d1ead925fb1ddc15c497/2b73a/typical_postgres_setups.png 1920w" sizes="(max-width: 860px) 100vw, 860px" type="image/png"/>
          <img src="https://neon.tech/static/a1e782b7c162d1ead925fb1ddc15c497/22296/typical_postgres_setups.png" alt="Typical Postgres Setups" title="Typical Postgres Setups" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></p><p>As the diagram illustrates, in order to get more throughput or storage, a user has to migrate to bigger host machines, and the service provider needs to explicitly manage the migration procedure to avoid downtimes. Due to the monolith architecture of Postgres, you end up overprovisioning either storage or compute which also has a direct implication on the cost of running the service in the cloud. Another problem is that since you have to handle failover you are paying triple for storage and compute. Amazon EBS volumes provide you with yet another level of redundancy, but they also charge for it. EBS volumes are very expensive, they throttle your throughput unless you pay for provisioned IOPs in which case your costs balloon even further.</p><p>We realized that a modern Postgres service can be designed differently in order to be cheaper and more efficient in cloud environments, but it will require some real systems engineering. We call this approach <strong>separation of storage and compute</strong>. It allows us to architect the service around performance, reliability, manageability, and cost. Cost is particularly important when you design a system for the cloud. Any cloud service has an infrastructure bill that it has to pass on to the end user. If you don’t account for cost at the architecture level running a service can get very expensive. That’s why when you build for the cloud you have to make the cost of running the service an important design consideration on par with manageability, reliability, and performance. One of the immediate implications of designing for cost was to never use EBS volumes and use a combination of local storage and S3 instead. Local storage for hot and S3 for cold data.</p><p>We built our distributed, multi-tenant storage from the ground up. It integrates into Postgres without the need of forking Postgres itself (it does require small changes in the engine that we are aiming to commit upstream). You can read more on the details of this architecture in our next posts.</p><p><span>
      <a href="https://neon.tech/static/4ff93293fb6b2b77a1c138ec084cd30e/2b73a/neon_architecture.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/4ff93293fb6b2b77a1c138ec084cd30e/bd025/neon_architecture.webp 215w,/static/4ff93293fb6b2b77a1c138ec084cd30e/1afa8/neon_architecture.webp 430w,/static/4ff93293fb6b2b77a1c138ec084cd30e/2a5e8/neon_architecture.webp 860w,/static/4ff93293fb6b2b77a1c138ec084cd30e/32062/neon_architecture.webp 1290w,/static/4ff93293fb6b2b77a1c138ec084cd30e/da0ef/neon_architecture.webp 1720w,/static/4ff93293fb6b2b77a1c138ec084cd30e/c58b7/neon_architecture.webp 1920w" sizes="(max-width: 860px) 100vw, 860px" type="image/webp"/>
          <source srcset="/static/4ff93293fb6b2b77a1c138ec084cd30e/11fb1/neon_architecture.png 215w,/static/4ff93293fb6b2b77a1c138ec084cd30e/b8a92/neon_architecture.png 430w,/static/4ff93293fb6b2b77a1c138ec084cd30e/22296/neon_architecture.png 860w,/static/4ff93293fb6b2b77a1c138ec084cd30e/64578/neon_architecture.png 1290w,/static/4ff93293fb6b2b77a1c138ec084cd30e/ae692/neon_architecture.png 1720w,/static/4ff93293fb6b2b77a1c138ec084cd30e/2b73a/neon_architecture.png 1920w" sizes="(max-width: 860px) 100vw, 860px" type="image/png"/>
          <img src="https://neon.tech/static/4ff93293fb6b2b77a1c138ec084cd30e/22296/neon_architecture.png" alt="Neon Architecure" title="Neon Architecure" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span></p><p>Each user gets a dedicated Postgres that we run in a container, while the data is safely stored in our multi-tenant storage system written in Rust. Storage consists of two services: Safekeepers and Pageservers. Safekeepers implement a consensus protocol. The combination of Safekeepers and S3 provide the system of record. Pageservers serve database pages with low latency and provide “scratch space” for updates. Pageservers are not part of the system of record – you can lose all the pageservers and won’t lose any data.</p><h2 id="architecture-benefits"><a href="#architecture-benefits" tabindex="-1" aria-hidden="true"><svg viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.813 11.313 15.5 12 21 6.5 15.5 1 10 6.5l.688.688M11.313 14.813 12 15.5 6.5 21 1 15.5 6.5 10l.688.688M8 14l6-6" stroke="#1A1A1A" stroke-width="2" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"></path></svg></a>Architecture Benefits</h2><p>This architecture provides a surprising number of benefits. Compared to the “naive” approach the most obvious are cost and elasticity of storage (bottomless). Compute and storage are separated, so you don’t overprovision either. Storage is backed up by a reliable and cost effective S3, so we do not have to triple the cost of storing the data. Safekeepers only have to store a small window of the most recent data which is not yet saved in S3. Moreover, Safekeepers and Pageservers can be shared between users, so the end user does not pay triple for the compute either. Backups and restores are integrated seamlessly as they are all built into the storage architecture. And most importantly this design allows us to deliver on a better developer experience (DevX), with elasticity, branching, and time machine. All these are enabled by our ability to transparently serve a Postgres instance any version of any page from our storage system.</p><h2 id="serverless"><a href="#serverless" tabindex="-1" aria-hidden="true"><svg viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.813 11.313 15.5 12 21 6.5 15.5 1 10 6.5l.688.688M11.313 14.813 12 15.5 6.5 21 1 15.5 6.5 10l.688.688M8 14l6-6" stroke="#1A1A1A" stroke-width="2" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"></path></svg></a>Serverless</h2><p>Since storage is separate, compute, which is a Postgres process, becomes stateless (barring the buffer cache). This allows dynamically rescheduling compute and moving it from one node to another. And this opens up the possibility to run a compute layer that scales in response to changes in traffic, including the scale down to 0 when the database is not in use. You don’t need to specify the size of the compute instance. You push a button and get Postgres in under 3 seconds. Your only interface to it is a connection string and we will handle the rest.</p><p>Here is an example of spinning up Postgres in 3 seconds.</p><p><img src="https://neon.tech/55755616b20c1d689f5ea1f4da12b123/create_project.gif" alt="Start Neon Project"/></p><h2 id="branching"><a href="#branching" tabindex="-1" aria-hidden="true"><svg viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.813 11.313 15.5 12 21 6.5 15.5 1 10 6.5l.688.688M11.313 14.813 12 15.5 6.5 21 1 15.5 6.5 10l.688.688M8 14l6-6" stroke="#1A1A1A" stroke-width="2" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"></path></svg></a>Branching</h2><p>Today everyone who is following modern app development practices needs to easily create dev, stage, and test environments. Modern developer workflow includes GitLab CI/CD, GitHub actions and other various CI/CD tools. Developers send pull requests and have platforms like <a href="https://vercel.com/">Vercel</a> to compile, test, and deploy their code. Databases today don’t support this workflow very well and the key missing feature for this is branching – the ability to create a branch of the whole database similar to how Git does it.</p><p>Neon allows instantly branching your Postgres database to support a modern development workflow. You can create a branch for your test environments for every code deployment in your CI/CD pipeline. You can test migrations against a recent production snapshot without affecting the production. Branches are created instantly and implemented using the &#34;copy on write&#34; technique. In the current version, you have to contact us separately if you want to try branching after receiving an invitation. We will open it up for everyone as we build the UI support.</p><h2 id="open-source"><a href="#open-source" tabindex="-1" aria-hidden="true"><svg viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.813 11.313 15.5 12 21 6.5 15.5 1 10 6.5l.688.688M11.313 14.813 12 15.5 6.5 21 1 15.5 6.5 10l.688.688M8 14l6-6" stroke="#1A1A1A" stroke-width="2" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"></path></svg></a>Open Source</h2><p>We are not the first to offer separation of storage and compute for Postgres. AWS Aurora is probably the most famous example, however it is proprietary and tied to AWS&#39;s internal infrastructure.</p><p>We think we have an opportunity to define the standard for cloud Postgres. We carefully designed our storage focusing on cloud independence, performance, manageability, DevX, and cost. We chose the most permissive open source license: Apache 2.0 and invited the world to participate. You can already build and run your own fully-featured instance of Neon.</p><h2 id="hello-world"><a href="#hello-world" tabindex="-1" aria-hidden="true"><svg viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.813 11.313 15.5 12 21 6.5 15.5 1 10 6.5l.688.688M11.313 14.813 12 15.5 6.5 21 1 15.5 6.5 10l.688.688M8 14l6-6" stroke="#1A1A1A" stroke-width="2" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"></path></svg></a>Hello, World</h2><p>Please welcome Neon to the world. Follow @neondatabase on <a href="https://twitter.com/Neondatabase">Twitter</a> or <a href="https://github.com/neondatabase/">GitHub</a> and be on the lookout for exciting new features we will be continuously shipping.</p></div></div></div>
  </body>
</html>
