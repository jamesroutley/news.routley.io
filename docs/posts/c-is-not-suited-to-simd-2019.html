<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://blog.vmchale.com/article/notes-c-simd">Original</a>
    <h1>C Is Not Suited to SIMD (2019)</h1>
    
    <div id="readability-page-1" class="page"><div><p>C (C++) is used to write performant software, however it is ill-suited to
SIMD. In particular, its <a href="https://www.humprog.org/~stephen/research/papers/kell17some-preprint.pdf">compilation</a> of <a href="http://blog.vmchale.com/article/intuitionist-c">stepped reduction with lexical scoping</a> opposes parallel execution.</p><p>As an example, consider the sigmoid,</p><p>\( x \mapsto \displaystyle \frac{1}{1+e^{-x}} \)</p><p>In <a href="https://github.com/vmchale/apple">Apple</a>, one can map over an array with</p><pre><code><p>λxs. [1%(1+e:(_x))]`{0} xs</p></code></pre><p>One might want to compute \(e^x\) with the system function <code>exp</code>. Arm and x86
have vector instructions for addition, division, &amp;c. but calling a function
entails switching the (single) thread of execution, so function calls cannot be
vectorized<sup><a href="#footnote-1">[1]</a></sup>. C functions are no longer
composable.</p><!-- https://www.modular.com/blog/understanding-simd-infinite-complexity-of-trivial-problems can't package output, CPU-specific --><p><code>λx. x*2</code> and <code>λx. if x≥1 then sqrt x else x</code> are both functions in structured
and functional programming but must be handled differently when compiling.
The elegance of C&#39;s compilation model falls down.</p><p>In C, one writes a function, and it is exported in an object file. To appreciate why
this is special, <a href="http://blog.vmchale.com/article/ffi">consider <code>sum :: Num a =&gt; [a] -&gt; a</code> in Haskell</a>. This function exists
only in the context of GHC. One could export this as a function taking taking a
record of functions as an argument, viz.</p><pre><code><p>sum ::
    { (+) :: ∀ a. a -&gt; a -&gt; a
    , (-) :: ∀ a. a -&gt; a -&gt; a
    ...
    } -&gt;
    -&gt; [a]
    -&gt; a</p></code></pre><p>However, this is less efficient than inlining <code>(+)</code>, so really one still depends
on <code>sum</code> as it exists in the context of the compiler. Moreover, this discards
type instance resolution information.</p><p>Returning to SIMD: <code>map (*2)</code> cannot depend on <code>(*2)</code> as a sequence of assembly
instructions. Rather, it must treat <code>(*2)</code> like Haskell handles <code>sum</code>, an entity
that exists only in the context of the compiler.</p><p>To some extent this percolates compilers textbooks. Array languages naturally
express SIMD calculations; perhaps there are more fluent methods for compilation (and better data structures for export à la object files).</p><pre><code><pre><code> vFloat vexpf(vFloat x);
 ⋮
 void vvexp(double *y, const double *x, const int *n);</code></pre></code></pre><p>to address this.</p></div></div>
  </body>
</html>
