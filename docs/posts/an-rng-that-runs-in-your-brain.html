<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hillelwayne.com/post/randomness/">Original</a>
    <h1>An RNG that runs in your brain</h1>
    
    <div id="readability-page-1" class="page"><article lang="en">
    

    
    

    <div>
  

<p>Humans are notoriously bad at coming up with random numbers. I wanted to be able to quickly generate “random enough” numbers. I’m not looking for anything that great, I just want to be able to come up with the random digits in half a minute. Some looking around brought me to <a href="https://groups.google.com/g/sci.math/c/6BIYd0cafQo/m/Ucipn_5T_TMJ?hl=en">an old usenet post</a> by George Marsaglia:</p>

<blockquote>
<p>Choose a 2-digit number, say 23, your “seed”.</p>

<p>Form a new 2-digit number:
the 10’s digit plus 6 times the units digit.</p>

<p>The example sequence is
23 –&gt; 20 –&gt; 02 –&gt; 12 –&gt; 13 –&gt; 19 –&gt; 55 –&gt; 35 –&gt; …</p>

<p>and its period is the order of the multiplier, 6, in the group of
residues relatively prime to the modulus, 10. (59 in this case).</p>

<p>The “random digits” are the units digits of the 2-digit numbers,
ie, 3,0,2,2,3,9,5,… the sequence mod 10.</p>
</blockquote>

<p>Marsaglia is most famous for the <a href="https://en.wikipedia.org/wiki/Diehard_tests">diehard suite</a> of RNG tests, so he knows his stuff. I’m curious why this works and why he chose 6.</p>

<p>We’re going to use <a href="https://www.raku.org">Raku</a>, the <a href="https://buttondown.email/hillelwayne/archive/raku-a-language-for-gremlins/">language for gremlins</a>. I’ll be explaining all the weird features I use in dropdowns in case you’re a bit of a gremlin, too.</p>



<p>The sequence is periodic, meaning that if we iteratively apply it we’ll eventually get the same element. Let’s start with a function (“subroutine”) that produces the whole sequence:</p>
<div><pre><code data-lang="raku"><span></span><span>my</span> <span>sub</span> <span>next-rng</span>(<span>Int</span> <span>$start</span>, <span>Int</span> <span>$unitmult</span> = <span>6</span>, --&gt; <span>List</span>) {
    <span>my</span> <span>@out</span>;
    <span>my</span> <span>$next</span> = <span>$start</span>;
    <span>repeat</span> <span>while</span> <span>$next</span> !(<span>elem</span>) <span>@out</span> {
        <span>@out</span>.<span>append</span>(<span>$next</span>);
        <span>$next</span> = <span>sum</span>(<span>$next</span>.<span>polymod</span>(<span>10</span>) <span>Z</span>* <span>$unitmult</span>,<span>1</span>);
    };
    <span>return</span> <span>@out</span>;
}
</code></pre></div>

<details>

  <summary>
    Explanation
  </summary>
  <p>Raku is an extremely weird language but I’ll keep it as straightforward as I can.</p>

<ul>
<li><code>@</code> and <code>$</code> are <a href="https://docs.raku.org/language/variables#Sigils">sigils</a> for “positional” (listlike) and “scalar” respectively. Defining a positional without assigning anything defaults it to the empty array.</li>
<li><code>(elem)</code> checks for membership, and <code>!</code> can be applied to negate any infix operator. <code>(elem)</code> is the ASCII version— Raku also accepts ∈.</li>
<li><a href="https://docs.raku.org/type/Int#method_polymod">polymod</a> splits a number into a remainder and dividend, ie <code>346.polymod(10) = (6 34)</code>. It takes multiple parameters, so you can do things like <code>num.polymod(60, 60, 24)</code> to get hours-minutes-seconds.</li>
<li><a href="https://docs.raku.org/language/operators#Zip_metaoperator">Z</a> is the “zip” metaoperator, applying a infix op elementwise between two lists. <code>(4, 6) Z* (6, 1)</code> = <code>(4*6, 6*1)</code>.</li>
</ul>

</details>




<p>Once we have a sequence we can print it with the <code>put</code> or <code>say</code> commands, which have <a href="https://docs.raku.org/language/faq#How_and_why_do_say,_put_and_print_differ%3F">subtly different behaviors</a> I’m not going to get into.</p>


<pre><code>01 06 36 39 57 47 46 40 04 24 26 38 51 11 07 42 16 
37 45 34 27 44 28 50 05 30 03 18 49 58 53 23 20 02 
12 13 19 55 35 33 21 08 48 52 17 43 22 14 25 32 15 
31 09 54 29 56 41 10 01
</code></pre>

<p>Remember, the random numbers are the <em>last</em> digit. So the RNG goes 1 -&gt; 6 -&gt; 6 -&gt; 9 -&gt; 7 -&gt; 7 -&gt; …</p>

<h2 id="investigating-properties">Investigating Properties</h2>

<p>If the RNG is uniform then each digit should appear in the sequence the same number of times. We can check this by casting the last digits to a multiset, or “bag”.</p>

<pre><code>say bag(next-rng(1) &lt;&lt;%&gt;&gt; 10);
</code></pre>

<details>

  <summary>
    Explanation
  </summary>
  <ul>
<li><code>&lt;&lt;op&gt;&gt;</code> is the <a href="https://docs.raku.org/language/operators#Hyper_operators">hyper metaoperator</a> and “maps” the inside operator across both lists, <em>recursively going into list of lists too</em>. IE <code>((1, 2), 3) &lt;&lt;+&gt;&gt; 10</code> is <code>((11, 12), 13)</code>! Hyperoperators have a lot of other weird properties that make them both useful and confusing.</li>
<li>Bags count the number of elements in something. <code>bag((4, 5, 4)){4} = 2</code>. Confusingly though they can only contain scalars, not arrays or lists or the like.</li>
</ul>

</details>




<pre><code>Bag(0(5) 1(6) 2(6) 3(6) 4(6) 5(6) 6(6) 7(6) 8(6) 9(5))
</code></pre>

<p>That seems to be a uniform-enough distribution, though I’m a bit less likely to get a 0 or a 9.</p>

<p>My next idea comes from the diehard tests. From <a href="https://en.wikipedia.org/wiki/Diehard_tests#Test_overview">the wiki</a>:</p>

<blockquote>
<p><strong>Overlapping permutations</strong>: Analyze sequences of five consecutive random numbers. The 120 possible orderings should occur with statistically equal probability.</p>
</blockquote>

<p>There are only 54 5-number sequences in the dataset, so I’ll instead apply this to 2-number “transitions”. I’ll do this by outputting a 10-by-10 grid where the (i, j)th index (from 0) is the number of transitions from last-digit <code>i</code> to <code>j</code>. For example, the sequence includes the transition <code>28 -&gt; 50</code>, and no other transitions of form <code>X8 -&gt; Y0</code>, so cell (8, 0) should be a <code>1</code>.</p>
<div><pre><code data-lang="raku"><span></span><span>sub</span> <span>successions-grid</span>(<span>@orbit</span>) {
  <span>my</span> <span>@pairs</span> = (|<span>@orbit</span> , <span>@orbit</span>[<span>0</span>]).<span>map</span>(* % <span>10</span>).<span>rotor</span>(<span>2</span> =&gt; -<span>1</span>);
  <span>for</span> ^<span>10</span> -&gt; <span>$x</span> {<span>put</span> (<span>$x</span> <span>X</span> ^<span>10</span>).<span>map</span>({<span>@pairs</span>.<span>grep</span>(<span>$_</span>).<span>elems</span>})}
}
</code></pre></div>

<details>

  <summary>
    Explanation
  </summary>
  <ul>
<li><code>| @f, $x</code> concats <code>$x</code> directly onto <code>@f</code>. Without the <code>|</code> it’d be a two-element list instead.</li>
<li>The <code>*</code> in <code>`* % 10`</code> is a <a href="https://docs.raku.org/type/Whatever">whatever</a>, a weird little operator that does a lot of things in a lot of different contexts, but usually in this case lifts the expression into a closure. <em>Usually</em>. It’s the same as writing <code>map({$_ % 10})</code>.</li>
<li><a href="https://docs.raku.org/type/List#routine_rotor">rotor</a><code>(2 =&gt; -1)</code> gets two elements, then goes one element back, then gets two more, etc. <code>[1, 2, 3, 4].rotor(2 =&gt; -1)</code> is <code>[(1, 2), (2, 3), (3, 4)]</code>. You could also do <code>rotor(2)</code> to get <code>[(1, 2), (3, 4)]</code>, or <code>rotor(1 =&gt; 1)</code> to get <code>[1, 3]</code>. Rotor is really cool.</li>
<li><code>^10</code> is just <code>0..9</code>. For once something easy!</li>
<li><a href="https://docs.raku.org/language/operators#Cross_metaoperators">X</a> is the cross product <a href="https://docs.raku.org/language/operators#Metaoperators">metaoperator</a>. So if <code>$x = 2</code>, then <code>$x X ^4</code> would be <code>((2 0), (2 1), (2 2), (2 3))</code>. And yes, the operator can get much, much stranger.</li>
<li><code>grep(foo)</code> returns a list of all elements <a href="https://docs.raku.org/language/operators#infix_~~">smart-matching</a> <code>foo</code>, and <code>.elems</code> is the number of elements in a list. So <code>@pairs.grep($_).elems</code> is the number of elements of the list matching <code>$_</code>. This took me <em>way</em> too long to figure out</li>
</ul>


</details>




<pre><code>&gt; successions-grid(next-rng(1, 6))

0 1 1 1 1 1 0 0 0 0
1 1 0 0 0 0 1 1 1 1
0 0 1 1 1 1 1 1 0 0
1 1 1 1 0 0 0 0 1 1
0 0 0 0 1 1 1 1 1 1
1 1 1 1 1 1 0 0 0 0
1 1 0 0 0 0 1 1 1 1
0 0 1 1 1 1 1 1 0 0
1 1 1 1 0 0 0 0 1 1
0 0 0 0 1 1 1 1 1 0
</code></pre>

<p>We can see from this table that some transitions are impossible. If I generate a 0, I can’t get a 6 right after. Obviously not a great RNG, but my expectations were pretty low anyway.</p>

<h2 id="why-6">Why 6?</h2>

<p>What if instead of multiplying the last digit by 6, I multiply by 4?</p>

<pre><code>&gt; say next-rng(1, 4);
01 04 16 25 22 10 
</code></pre>

<p>I dunno, I kinda like an RNG that never gives me 3. The distinct sequences are called <dfn>orbits</dfn> and their lengths are called <dfn>periods</dfn>. Let’s see all the possible orbits we can get by using 4 as the multiplier:</p>
<div><pre><code data-lang="raku"><span></span><span>sub</span> <span>orbits-for-mod</span>(<span>int</span> <span>$mult</span>, <span>$top</span> = <span>20</span>) {
  <span>my</span> <span>&amp;f</span> = <span>&amp;next-rng</span>.<span>assuming</span>(*, <span>$mult</span>);
  (<span>1</span>..<span>$top</span>).<span>map</span>(<span>&amp;f</span>).<span>unique</span>(<span>as</span> =&gt; <span>&amp;set</span>)
}
</code></pre></div>

<details>

  <summary>
    Explanation
  </summary>
  <ul>
<li><code>&amp;</code> is the <a href="https://docs.raku.org/language/variables#Sigils">sigil</a> for “callable” or <del>function</del> subroutine. The <code>.assuming</code> method does a partial function application, and passing a <code>*</code> makes it partially apply the <em>second</em> parameter.</li>

<li><p>The <code>map</code> returns a sequence of lists, which we pass to <a href="https://docs.raku.org/type/independent-routines#routine_unique"><code>unique</code></a>. <code>as =&gt; &amp;set</code> converts every sequence in the <code>map</code> to a set and compares <em>those</em> for uniqueness, instead of the original lists. But the final result uses the elements prior to conversion.</p>

<p>If that’s confusing, a simpler example is that <code>[-1, 1].unique(as =&gt; &amp;abs)</code> returns <code>[-1]</code>, while <code>[1, -1].unique(as =&gt; &amp;abs)</code> is <code>[1]</code>.</p></li>
</ul>


</details>




<pre><code>&gt; say orbits-for-mod(4, 38).map(*.gist).join(&#34;\n&#34;);
[1 4 16 25 22 10]
[2 8 32 11 5 20]
[3 12 9 36 27 30]
[6 24 18 33 15 21]
[7 28 34 19 37 31]
[13]
[14 17 29 38 35 23]
[26]
</code></pre>

<details>

  <summary>
    Explanation
  </summary>
  <p>Quoting <a href="https://www.codesections.com/">Daniel Sockwell</a>:</p>

<blockquote>
<p>The <code>.map(*.gist).join(&#34;\n&#34;)</code> is just there to prettify the output. <code>cycles-for-mod</code> returns a <code>Seq</code> of <code>Array</code>s; mapping over each <code>Array</code> with <code>.gist</code> converts it into a string surrounded by square brackets and <code>.join(&#34;\n&#34;)</code> puts a newline between each of these strings.</p>
</blockquote>

</details>




<p>If you picked 13 as your starting value, your random digits would be 3, 3, 3, 3, 3, 3.</p>

<center>
<figure>
  <img src="https://www.hillelwayne.com/post/randomness/img/random_number.png" title="That xkcd where `getrandomnumber` always returns 4"/>
  <figcaption>Preempting 50,000 emails<a href="https://xkcd.com/221/">(source)</a></figcaption>
</figure>
</center>

<p>For obvious reasons, 4 should never be our multiplier. In fact for a multiplier to give a “good” RNG, it needs to have exactly one orbit.</p>
<div><pre><code data-lang="raku"><span></span>&gt; <span>say</span> (<span>1</span><span>..</span><span>30</span>).<span>grep</span>(*.<span>&amp;orbits-for-mod</span> == <span>1</span>)
(<span>3</span> <span>6</span> <span>11</span> <span>15</span> <span>18</span> <span>23</span> <span>27</span>)
</code></pre></div>

<details>

  <summary>
    Explanation
  </summary>
  <ul>
<li><code>.&amp;</code> applies a top-level routine as a method. <code>grep(*.&amp;f)</code> is the equivalent of <code>grep({f($_)})</code>.</li>
<li><code>&amp;orbits-for-mod</code> returns a list. <code>==</code> coerces both inputs to numbers, and coercing a list to a number returns the number of elements. So we’re testing if the returned list has one element, ie there’s exactly one orbit. (If you don’t want to compare without coercion, use either <a href="https://docs.raku.org/language/operators#infix_===,_infix_%E2%A9%B6">===</a> or <a href="https://docs.raku.org/language/operators#infix_eqv">eqv</a>.)</li>
</ul>

<p>This way of doing things is pretty slow and also only looks for orbits that <em>start with</em> a number up to 20. So it would miss the <code>26 -&gt; 26</code> orbit for <code>x=4</code>. We’ll fix both of these issues later.</p>

</details>




<p>So some “good” choices for <code>n</code> are 6, 11, and 18.</p>

<p>Note that if you end up with a three digit number, you treat the first two digits as a single number. For <code>n=11</code>, <code>162</code> leads to <code>16 + 22</code>, not <code>6 + 22</code> (or <code>6 + 1 + 22</code>).</p>

<h2 id="why-does-this-work">Why does this work?</h2>

<p>Here’s a part of the explanation that really confused me:</p>

<blockquote>
<p>and its period is the order of the multiplier, 6, in the group of
residues relatively prime to the modulus, 10. (59 in this case).</p>
</blockquote>

<p>After talking with some friends and a lot of reading Wiki articles, it started making more sense. I’m mentally computing a “<a href="https://en.wikipedia.org/wiki/Multiply-with-carry_pseudorandom_number_generator">multiply with carry</a>” RNG with constants <code>a=x</code> and <code>c=10</code>. This choice has a cool property: if <code>MWC(x) = y</code>, then <code>10y mod (10n-1) = x</code>!</p>

<pre><code>MWC:    01 -&gt; 06 -&gt; 36 -&gt; ... -&gt; 41 -&gt; 10 -&gt; 01
10y%59: 01 -&gt; 10 -&gt; 41 -&gt; ... -&gt; 36 -&gt; 06 -&gt; 01
</code></pre>

<p>That’s pretty neat! It’s easier for me to mathematically reason about <code>10y mod 59</code> than “multiply the last digit by six and add the first digit”. For example, it’s clear why the RNG generates 0 and 9 slightly less often than the other digits: no matter which multiplier we pick, the generated sequence will go from 1 to 10n-2, “leaving out” 10n-1 (which ends with 9) and 10n (ends with 0).</p>

<p>“Multiply and modulo” is also known as the <a href="https://en.m.wikipedia.org/wiki/Lehmer_random_number_generator">Lehmer RNG</a>.</p>

<h2 id="finding-better-rngs">Finding better RNGs</h2>

<p>So what other numbers work? We already know that a good multiplier will produce only one orbit, and I showed some code above for calculating that. Unfortunately, it’s an O(n²) worst-case algorithm. Thinking about the MWC algorithm as “Lehmer in reverse” gives us a better method: if <code>n</code> is a good multiplier, then the period of the orbit starting from 1 should be <code>10n-2</code>.</p>

<p>The Lehmer approach also gives us a faster way of computing the orbit:</p>
<div><pre><code data-lang="raku"><span></span><span>sub</span> <span>oneorbit</span>(\<span>x</span>) {
  <span>10</span>, * *<span>10</span>% (<span>10</span><span>*</span><span>x</span> - <span>1</span>) … <span>1</span>
}
</code></pre></div>

<details>

  <summary>
    Explanation
  </summary>
  <center>
<figure>
  <img src="https://www.hillelwayne.com/post/randomness/img/fault-tolerance.png" title="GREMLINS"/>
  <figcaption><a href="http://howfuckedismydatabase.com/nosql/">(source)</a></figcaption>
</figure>
</center>

<details>

  <summary>
    Real Explanation
  </summary>
  <ul>
<li>Writing <code>\x</code> instead of <code>$x</code> as a param lets use use <code>x</code> instead of <code>$x</code> in the body.</li>
<li><code>...</code> is the <a href="https://docs.raku.org/language/operators#infix_...">sequence operator</a>. It can do a <em>lot</em> of different things, but the important one for us is that if you write <code>10, &amp;f … 1</code>, it will start with 10 and then keep applying <code>&amp;f</code> until it eventually generates <code>1</code>.</li>
<li>In <code>* *10%[etc]</code>, the first <code>*</code> is a Whatever and the second <code>*</code> is regular multiply. This then lifts into the function <code>-&gt; $a {$a * 10 % (10*x - 1)}</code>.</li>
</ul>

<p>This actually produces the orbit in reverse but we’re only interested in the period so nbd.</p>

</details>


</details>




<p>Then we check the period using the same “<code>==</code> coerces lists to lengths” trick as before.</p>
<div><pre><code data-lang="raku"><span></span>&gt; <span>say</span> (<span>1</span><span>..</span><span>100</span>).<span>grep</span>({<span>oneorbit</span>(<span>$_</span>) == <span>10</span>*<span>$_-2</span>});

(<span>2</span> <span>3</span> <span>6</span> <span>11</span> <span>15</span> <span>18</span> <span>23</span> <span>27</span> <span>38</span> <span>39</span> <span>42</span> <span>50</span> <span>51</span> <span>62</span> <span>66</span> <span>71</span>)
</code></pre></div>

<p>I can see why Marsaglia chose 6: most programmers know their 6 times-table and it never returns a 3-digit number, so the addition step is real easy. The orbit has only 58 numbers and you won’t get some digit sequences, but if you need to pull out a few random digits quickly it’s totally fine.</p>

<p>If you want more randomness, I see a couple of candidates. 50 has a period of 498 and is incredibly easy to compute. If the final digit is even then you don’t need to do any carries: <strong>23</strong>8 -&gt; 4<strong>23</strong>!</p>

<p>That said, the 50-sequence doesn’t <em>seem</em> as random as other sequences. There’s a point where it generates 9 even numbers followed by 8 odd ones. Don’t use it to simulate coin flips.</p>

<p>The last interesting number is 18. It has a respectable period of 178 and has every possible digit transition:</p>

<pre><code>&gt; successions-grid(next-rng(1, 18))

1 2 2 2 2 2 2 2 1 1
2 2 2 2 2 2 1 1 2 2
2 2 2 2 1 1 2 2 2 2
2 2 1 1 2 2 2 2 2 2
1 1 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 1 1
2 2 2 2 2 2 1 1 2 2
2 2 2 2 1 1 2 2 2 2
2 2 1 1 2 2 2 2 2 2
1 1 2 2 2 2 2 2 2 1
</code></pre>

<p>The downside is that you have to learn the 18 times-table. This isn’t too bad: I internalized it with maybe 10 minutes of practice. I’m still not <em>great</em> at doing the whole MWC step but I can consistently produce another random digit every five seconds or so. That’s good enough for me.</p>

<p>You can see the Raku code I used to research this <a href="https://www.hillelwayne.com/post/randomness/src/rng.raku">here</a>. It’s set up <a href="https://buttondown.email/hillelwayne/archive/raku-is-surprisingly-good-for-clis/">as a CLI</a> so you can use it in a few different ways; see the file for more info.</p>

<p><em>Thanks to <a href="https://www.codesections.com/">Codesections</a> for feedback and <a href="https://twitter.com/wilton_quinn">Quinn Wilton</a> and <a href="https://jeremykun.com/">Jeremy Kun</a> for helping me understand the math.</em></p>


</div>

    



  </article></div>
  </body>
</html>
