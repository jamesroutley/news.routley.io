<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ianthehenry.com/posts/generalized-macros/">Original</a>
    <h1>Generalized Macros</h1>
    
    <div id="readability-page-1" class="page"><article>

<div><p>I’ve been <a href="https://ianthehenry.com/posts/janet-for-mortals/">writing</a> a <a href="https://ianthehenry.com/posts/why-janet/">lot</a> of <a href="https://janet-lang.org/">Janet</a> lately, and I’ve been especially enjoying my time with <a href="https://ianthehenry.com/posts/janet-game/the-problem-with-macros/">the macro system</a>.</p>
<p>Janet macros are Common Lisp-flavored unhygienic <code>gensym</code>-style macros. They are extremely powerful, and very easy to write, but they can be <a href="https://janet.guide/macro-mischief/">pretty tricky to get right</a>. It’s easy to make mistakes that lead to unwanted variable capture, or to write macros that only work if they’re expanded in particular contexts, and it can be pretty difficult to detect these problems ahead of time.</p>
<p>So people have spent a lot of time thinking about ways to write macros more safely – sometimes at the cost of expressiveness or simplicity – and almost all recent languages use some sort of hygienic macro system that defaults to doing the right thing.</p>
<p>But as far as I know, no one has approached macro systems from the other direction. No one looked at Common Lisp’s macros and said “What if these macros <em>aren’t dangerous enough?</em> What if we could make them even <em>harder</em> to write correctly, in order to <em>marginally</em> increase their power and expressiveness?”</p>
<p>So welcome to my blog post.</p>
<p>I want to show you an idea for a new kind of macro. A macro that can not only rewrite <em>itself</em>, but actually rewrite <em>any</em> form in your entire program.</p>
<p>I think that “what, no, why on earth” is an entirely reasonable response to that statement, so let’s take a look at a motivating example together.</p>
<p>Lots of languages have something like <code>defer</code> that will run an expression at the end of a block, whether or not the rest of the code raises an exception. <code>defer</code> is just like wrapping the rest of the function in a try-finally block, except that, well, you don’t actually have to do any wrapping. Which means no indentation increase, and no extra nested parentheses.</p>
<p>Here’s an example of what <code>defer</code> might look in Janet:</p>
<pre tabindex="0"><code data-lang="janet">(do
  (def f (file/open &#34;foo.txt&#34;))
  (defer (file/close f))
  (def contents (file/read f))
  (do-something-dangerous-with contents))
</code></pre><p>Now, we can’t implement <code>defer</code> as a traditional macro, because a traditional macro can only rewrite <em>itself</em>. But what we really want to do is rewrite the parent form that the <code>defer</code> appears in, to wrap its <em>siblings</em> in a finally expression:</p>
<pre tabindex="0"><code data-lang="janet">(do
  (def f (file/open &#34;foo.txt&#34;))
  (finally
    (do
      (def contents (file/read f))
      (do-something-dangerous-with contents))
    (file/close f)))
</code></pre><p>So generalized macros let us write exactly this.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></p>
<p>I want to start at the punchline and work backwards, because my favorite part is how <em>simple</em> it is to write this. So although I don’t actually expect this to make any sense yet, let’s go ahead and look at the implementation of this <code>defer</code> macro:</p>
<pre tabindex="0"><code data-lang="janet">(defmacro defer [] [expr]
  (macro lefts rights
    ~(,;lefts (finally (do ,;rights) ,expr))))
</code></pre><p>Pretty tame, right?</p>
<p>So in order to do understand how this works, we’ll have to change three things about macros:</p>
<ol>
<li>Macros no longer have to appear at the head of the form; they can appear anywhere within a form.</li>
<li>Macros now have two argument lists: the forms “to the left” of the macro, and the forms “to the right” of the macro.</li>
<li>Macros can either return new abstract syntax trees – like a traditional macro – or they can return new, anonymous <em>macros</em> as first-class values.</li>
</ol>
<p>Let’s go through these ideas one at a time in slightly more detail, and then we’ll circle back to the definition of <code>defer</code>.</p>

<p>Scheme already has something called “identifier macros,” which can appear anywhere within a form. You can use them to say that <code>foo</code> is a macro, and it can appear in any expression context, and then make <code>(+ 1 foo)</code> expand to something like <code>(+ 1 (some complicated expression))</code>.</p>
<p>But identifier macros can still only rewrite <em>themselves</em>. In order to do anything interesting with this, we need to add…</p>

<p>On the face of it this might sound like I’m trying to introduce “infix macros,” so that you could write something like <code>(1 + 2)</code> and rewrite that to the traditional <code>(+ 1 2)</code> syntax. And, to be clear, that <em>is</em> a thing you can do:</p>
<pre tabindex="0"><code data-lang="janet">(defmacro + [left] [right]
  [+ left right])
</code></pre><p>I think that infix macros could be very useful – we’ll talk more about that in a bit – even if infix <em>math</em> is not particularly compelling to someone practiced in the prefixual arts.</p>
<p>But the real reason to support “infix” macros is for cases like <code>defer</code>, where the <code>(defer ...)</code> expression occurs in the middle of a form, and acts as sort of an “infix” expansion point. But in order for that to work, we need to add…</p>

<p>I think this is the trickiest part to wrap your head around, but it’s the most important. This is the trick that allows macros to rewrite not only themselves, but also the forms around themselves – their parents, their grandparents, their… cousins? I guess? Any other form in your program, actually.</p>
<p>So the idea is that we can create first-class anonymous macros, and return them from our macro implementations. And then those macros will get expanded <em>in the context of the parent form</em> that they now appear in.</p>
<p>This is a lot like returning an anonymous function, except that functions are perfectly reasonable values to put in your abstract syntax trees… so it’s like returning a <em>special</em> function, a function with a little tag attached that says “hey, I’m not a real runtime value, I’m a macro, so you should call me before you finish macro expansion.”</p>
<p>And just to be super explicit: this is different from a macro returning a <em>syntax tree</em> that contains another macro invocation. You can already write “recursive macros,” or macros that return <em>invocations of</em> other macros. But by creating actual new first-class macros at expansion time, you can close over macro arguments and reference them during the next phase of expansion.</p>
<p>So with these changes in mind, let’s come back to the implementation of <code>defer</code>:</p>
<pre tabindex="0"><code data-lang="janet">(defmacro defer [] [expr]
  (macro lefts rights
    ~(,;lefts (finally (do ,;rights) ,expr))))
</code></pre><p>Our <code>defer</code> macro takes two binding forms: <code>[]</code> and <code>[expr]</code>. So it expects no arguments to the left – the word <code>defer</code> has to appear at the beginning of its form – and it expects exactly one argument to its right. In other words, it looks like a normal, traditional prefix macro of one argument.</p>
<p>But then it returns an anonymous macro that closes over its <code>expr</code> argument. So if we just look at one step of the expansion, we’ll see an abstract syntax tree that looks like this:</p>
<pre tabindex="0"><code>(do
  (def f (file/open &#34;foo.txt&#34;))
  &lt;macro&gt;
  (def contents (file/read f))
  (do-something-dangerous-with contents))
</code></pre><p>But macro expansion isn’t over. After expanding the <code>(defer ...)</code> form, the macro expander will notice that it expanded to another macro, so it will expand <em>that</em>. Which winds up invoking our anonymous macro, passing it <code>[&#39;do &#39;(def f ...)]</code> as its “left” arguments and <code>[&#39;(def contents ...) &#39;(do-something...)]</code> as its “right” arguments.</p>
<p>And then that will return a replacement for the entire <code>(do ...)</code> form, giving us our final result:</p>
<pre tabindex="0"><code data-lang="janet">(do
  (def f (file/open &#34;foo.txt&#34;))
  (finally
    (do
      (def contents (file/read f))
      (do-something-dangerous-with contents))
    (file/close f)))
</code></pre><p>Neat, right?</p>
<p>This type of macro gives us a lot more freedom to decide how we want our code to look. I’m honestly not really sure <em>how much</em> more freedom, because I haven’t spent very much time with the idea yet. But I’ve been thinking about it for a while, and I’ve come up with a few examples of things that we can do with this – some much dumber than others.</p>
<p>Let’s take a look at a few of them.</p>

<p>I think that reducing the number of nested parentheses and general indentation might be the most compelling use case for this sort of macro. I mean, really this is all <code>defer</code> does: it lets you write <code>finally</code> with a little less nesting, and with the expressions in a slightly different order.</p>
<p>I spend most of my programming time writing OCaml. OCaml doesn’t have “block scope” or “function scope” like most languages – it has <em>expression scope</em>. You introduce new “variables” (they can’t actually <em>vary</em>; all OCaml bindings are “<code>const</code>&#34;) using <code>let ... in</code>, and the binding only exists on the right-hand side of that particular expression.</p>
<p>If you think about the nesting of the OCaml abstract syntax tree, it looks something like this:</p>
<div><pre tabindex="0"><code data-lang="ocaml"><span>(</span><span>let</span> <span>x</span> <span>=</span> <span>10</span> <span>in</span> 
  <span>(</span><span>let</span> <span>y</span> <span>=</span> <span>20</span> <span>in</span>
    <span>(</span><span>x</span> <span>+</span> <span>y</span><span>)))</span>
</code></pre></div><p>But of course you don’t write OCaml like that. For one thing, the parentheses are redundant:</p>
<div><pre tabindex="0"><code data-lang="ocaml"><span>let</span> <span>x</span> <span>=</span> <span>10</span> <span>in</span> 
  <span>let</span> <span>y</span> <span>=</span> <span>20</span> <span>in</span>
    <span>x</span> <span>+</span> <span>y</span>
</code></pre></div><p>For another thing, this triangular indentation is really annoying. So you actually write it like this:</p>
<div><pre tabindex="0"><code data-lang="ocaml"><span>let</span> <span>x</span> <span>=</span> <span>10</span> <span>in</span> 
<span>let</span> <span>y</span> <span>=</span> <span>20</span> <span>in</span>
<span>x</span> <span>+</span> <span>y</span>
</code></pre></div><p>The parse tree for that expression is still nested, but it doesn’t <em>look</em> nested – you always format your code linearly.</p>
<p>So lisps also have <code>let</code>, but lisps don’t have the luxury of leaving off the parentheses, so we’re back to the first example:</p>
<pre tabindex="0"><code data-lang="janet">(let [x 10]
  (let [y 20]
    (+ x y)))
</code></pre><p>And if we tried to write that without indentation, then…</p>
<pre tabindex="0"><code data-lang="janet">(let [x 10]
(let [y 20]
(+ x y)))
</code></pre><p>Immediate aneurysm.</p>
<p>Fortunately, every lisp dialect that I know of mitigates this problem substantially by allowing <code>let</code> to introduce multiple bindings in a single form:</p>
<pre tabindex="0"><code data-lang="janet">(let [x 10
      y 20]
  (+ x y))
</code></pre><p>Which means that we only have to increase the nesting by one level in the very common case that we have a series of <code>let</code> expressions. But by using generalized macros instead, we can write a version of <code>let</code> that doesn’t increase indentation at all. I’ll call it <code>def</code>:</p>
<pre tabindex="0"><code data-lang="janet">(defmacro def [] [name value]
  (macro lefts rights
    ~(,;lefts (let [,name ,value] ,;rights))))
</code></pre><p><code>def</code> lets us write code like this:</p>
<pre tabindex="0"><code data-lang="janet">(def x 10)
(def y 20)
(+ x y)
</code></pre><p>Which gets transformed into code like this:</p>
<pre tabindex="0"><code data-lang="janet">(let [x 10]
  (let [y 20]
    (+ x y)))
</code></pre><p>Of course Janet – and most lisps – have a “linear assignment” form like this built into the language. In Janet it’s called – <em>coincidentally enough</em> – <code>def</code>.</p>
<p>In fact in Janet, <code>def</code> is actually the <em>primitive</em> way to create new bindings, and <code>let</code> is a macro that just desugars to <code>do</code> + <code>def</code>, which is very reasonable and pragmatic, but feels <em>weird</em> to me.</p>
<p>It feels weird to me because, in my mind, <code>let</code> should be syntax sugar for <code>fn</code> – Janet’s word for <code>lambda</code>. Because, after all, these two expressions are equivalent:<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p>
<pre tabindex="0"><code data-lang="janet">(let [x 10] (+ x 1))

((fn [x] (+ x 1)) 10)
</code></pre><p><code>let</code> allows us to write the expression in a much more natural order, but we can introduce new bindings without any <code>let</code>s at all.</p>
<p>This might sound like weird mathematical lambda calculus trivia, but it’s not: it’s important to understand introducing new variables as a special-case of function application, even if this <em>particular</em> function application happens to be trivial.</p>
<p>Because we can apply the same technique that we just used – rewriting <code>def</code> to <code>let</code>, and rewriting <code>let</code> to <code>fn</code> – to do something much more interesting.</p>
<h2 id="generalized-function-application">Generalized function application</h2>
<p>So Haskell has something called <code>do</code> notation. You’ve probably seen something like this before:</p>
<div><pre tabindex="0"><code data-lang="haskell"><span>addAll</span> <span>::</span> <span>[</span><span>Int</span><span>]</span> <span>-&gt;</span> <span>[</span><span>Int</span><span>]</span> <span>-&gt;</span> <span>[</span><span>Int</span><span>]</span>
<span>addAll</span> <span>xs</span> <span>ys</span> <span>=</span> <span>do</span>
  <span>x</span> <span>&lt;-</span> <span>xs</span>
  <span>y</span> <span>&lt;-</span> <span>ys</span>
  <span>return</span> <span>(</span><span>x</span> <span>+</span> <span>y</span><span>)</span>
</code></pre></div><pre tabindex="0"><code>ghci&gt; addAll [1, 2] [10, 20]
[11,21,12,22]
</code></pre><p>This is equivalent to the following Janet code:</p>
<pre tabindex="0"><code data-lang="janet">(defn add-all [xs ys]
  (mapcat (fn [x]
    (mapcat (fn [y]
      [(+ x y)])
      ys))
    xs))
</code></pre><p>But I think the Haskell code is easier to read. Partly that’s because the argument order to Janet’s <code>mapcat</code> function makes the values we’re traversing appear in reverse order in our source code, and we could fix this by redefining <code>mapcat</code> with a argument different order:</p>
<pre tabindex="0"><code data-lang="janet">(defn add-all [xs ys]
  (mapcat xs (fn [x]
    (mapcat ys (fn [y]
      [(+ x y)])))))
</code></pre><p>This reminds me a lot like the transformation we did when we changed <code>((fn [x] (+ x 1)) 10)</code> into <code>(let [x 10] (+ x 1))</code>. So what if we take it one step further, and do the same thing we did to get <code>def</code>?</p>
<pre tabindex="0"><code data-lang="janet">(defn add-all [xs ys]
  (as x mapcat xs)
  (as y mapcat ys)
  [(+ x y)])
</code></pre><p>It’s not quite as concise as Haskell’s <code>do</code> notation: Haskell is able to use the type of the expression to determine what <code>&lt;-</code> means, so there’s no need to specify the <code>mapcat</code> bit: it’s implied from the fact that we gave it a list.</p>
<p>Janet doesn’t have an analog for <a href="https://en.wikipedia.org/wiki/Type_class">type classes</a>, so we have to be a little more explicit, but this means that we can do more than just “bind” with the <code>as</code> macro. We can also <code>map</code>:</p>
<pre tabindex="0"><code data-lang="janet">(defn add-all [xs ys]
  (as x mapcat xs)
  (as y map ys)
  (+ x y))
</code></pre><p>Implementing <code>as</code> is just as easy as implementing <code>def</code>:</p>
<pre tabindex="0"><code data-lang="janet">(defmacro as [] [name f arg]
  (macro lefts rights
    ~(,;lefts (,f (fn [,name] ,;rights) ,arg))))
</code></pre><p>If you haven’t programmed in a language like Haskell, this particular syntax sugar might seem a little odd at first. But a specialized notation for generalized function application is extremely useful – we have it in OCaml too, through a syntax extension called <a href="https://github.com/janestreet/ppx_let"><code>ppx_let</code></a>:</p>
<div><pre tabindex="0"><code data-lang="ocaml"><span>let</span><span>%</span><span>bind</span> <span>x</span> <span>=</span> <span>xs</span> <span>in</span>
<span>let</span><span>%</span><span>bind</span> <span>y</span> <span>=</span> <span>ys</span> <span>in</span>
<span>return</span> <span>(</span><span>x</span> <span>+</span> <span>y</span><span>)</span>
</code></pre></div><p>I think OCaml’s notation is actually more clear than Haskell’s – it highlights the symmetry between “ordinary” let bindings and “fancy” let bindings like these. And because it can do more than just <code>bind</code>, we can also avoid the explicit <code>return</code> in OCaml:</p>
<div><pre tabindex="0"><code data-lang="ocaml"><span>let</span><span>%</span><span>bind</span> <span>x</span> <span>=</span> <span>xs</span> <span>in</span>
<span>let</span><span>%</span><span>map</span> <span>y</span> <span>=</span> <span>ys</span> <span>in</span>
<span>x</span> <span>+</span> <span>y</span>
</code></pre></div><p><code>map</code> and <code>bind</code> aren’t the only functions of this variety, either. Although monads are ubiquitous in OCaml, I spend a lot of my time <a href="https://opensource.janestreet.com/bonsai/">working with arrows</a> as well. And arrows have yet another notation: <code>let%sub</code> and <code>let%arr</code>.</p>
<p>All of these are generalizations of regular function application. Without worrying about what any of this means, just look at how similar the <em>shape</em> of these different type signatures are:</p>
<pre tabindex="0"><code>val (@@) : &#39;a   -&gt; (&#39;a   -&gt; &#39;b)   -&gt; &#39;b
val map  : &#39;a f -&gt; (&#39;a   -&gt; &#39;b)   -&gt; &#39;b f
val bind : &#39;a f -&gt; (&#39;a   -&gt; &#39;b f) -&gt; &#39;b f
val sub  : &#39;a s -&gt; (&#39;a r -&gt; &#39;b s) -&gt; &#39;b s
val arr  : &#39;a r -&gt; (&#39;a   -&gt; &#39;b)   -&gt; &#39;b s
</code></pre><p>Okay, I know; this isn’t supposed to be a blog post about monads or arrows. Let’s get back to macros.</p>

<p>So Janet has some very useful “threading” macros that allow you to write code in a more “linear” fashion than you could without them. They’re useful when you’re performing a series of transformations to a value:</p>
<pre tabindex="0"><code data-lang="janet">(filter |(string/has-prefix? &#34;a&#34; $)
  (map string/ascii-lower
    (map |($ :name) 
      people)))
</code></pre><p>With the power of threading macros, you could write that like this instead:</p>
<pre tabindex="0"><code data-lang="janet">(-&gt;&gt; people
  (map |($ :name))
  (map string/ascii-lower)
  (filter |(string/has-prefix? &#34;a&#34; $)))
</code></pre><p>This is a lot like “method chaining” in other languages:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>people</span>
<span>.</span><span>map</span><span>(</span><span>person</span> <span>=&gt;</span> <span>person</span><span>.</span><span>name</span><span>)</span>
<span>.</span><span>map</span><span>(</span><span>name</span> <span>=&gt;</span> <span>name</span><span>.</span><span>toLowerCase</span><span>())</span>
<span>.</span><span>filter</span><span>(</span><span>name</span> <span>=&gt;</span> <span>name</span><span>.</span><span>startsWith</span><span>(</span><span>&#34;a&#34;</span><span>))</span>
</code></pre></div><p>It’s easier for me to read the linear notation that uses the threading macro. But it’s not actually any easier to <em>write</em> it.</p>
<p>I like that method chaining allows me to write the code in the order of the operations: “Start with people, get the name, lowercase it, filter it to names that start with ‘a.&#39;”</p>
<p>When writing the threading macro, though, the way you <em>type</em> this is “start with people, okay wait, go back, surround it in parentheses, add a <code>-&gt;&gt;</code> at the beginning, now move the cursor to the end of the form, and then get the name…”</p>
<p>I don’t like that. And I know that there are <em>fancy</em> editors that allow you to easily wrap expressions in threading macros or any other without repositioning the cursor, but I’d rather use a syntax that doesn’t require a structural editor to work with comfortably.</p>
<p>So here’s another way to write this:</p>
<pre tabindex="0"><code data-lang="janet">(people
@ (map |($ :name))
@ (map string/ascii-lower)
@ (filter |(string/has-prefix? &#34;a&#34; name)))
</code></pre><p>This uses <code>@</code> as an infix function application macro. I prefer <code>|</code> myself, and that’s the notation that I chose for <a href="https://bauble.studio/">Bauble</a>, but <code>|</code> is how you create short anonymous functions in Janet, so I don’t want to step on that.</p>
<p>The main reason I prefer this notation is that it’s easier for me to <em>type</em>. I don’t know that it’s any easier to <em>read</em> than <code>-&gt;</code>, but it allows me to write code in the order that I think it, and I like being able to choose a syntax that maps neatly onto my brain.</p>
<p>Another infix macro that I like is <code>.</code>. <code>.</code> is a convenient macro for looking up a keyword in a struct or table, so that you can write <code>struct.key</code> instead of <code>(get struct :key)</code>.</p>
<p>In Janet <code>struct.key</code> parses as a single symbol, so we can’t actually implement this as a generalized macro without a separate preprocessing step to split it into three symbols. But we <em>can</em> use it as <code>struct . key</code>, which parses as three separate symbols:</p>
<pre tabindex="0"><code data-lang="janet">(defmacro . lefts [key &amp; rights]
  ~(,;(drop-last lefts)
    (get ,(last lefts) ,(keyword key))
    ,;rights))
</code></pre><p>Which we can then use like this:</p>
<pre tabindex="0"><code data-lang="janet">(print foo . bar)
</code></pre><pre tabindex="0"><code data-lang="janet">(print (get foo :bar))
</code></pre><p>This is very goofy looking, but you could imagine a language where <code>.</code> always parsed as its own symbol, so that we could just write <code>foo.bar</code> and have that expand to <code>(get foo :bar)</code> automatically.</p>
<p>Another infix macro that I think could be interesting is <code>:</code>, to create a pair.</p>
<p>Janet already uses <code>:</code> as a leader character for declaring <em>keywords</em>, so this won’t work in Janet. But you could imagine, again, a different language where <code>:</code> is used as a short way to create a pair of two elements. So:</p>
<pre><code>foo:bar
</code></pre>
<p>Would become:</p>
<pre><code>(foo bar)
</code></pre>
<p>This might be useful in languages that use wrapped <code>let</code>s, where you have to write:</p>
<pre tabindex="0"><code data-lang="janet">(let ((x 10)
      (y 20))
  (+ x y))
</code></pre><p>Instead, you could write that as:</p>
<pre tabindex="0"><code data-lang="janet">(let (x:10 y:20)
  (+ x y))
</code></pre><p>But have it parse in exactly the same way.</p>
<p>You could imagine it in <code>cond</code> as well:</p>
<pre tabindex="0"><code data-lang="janet">(cond
  (&gt; x 0): &#34;positive&#34;
  (&lt; x 0): &#34;negative&#34;
  (= x 0): &#34;zero&#34;
  true: &#34;nan&#34;)
</code></pre><p>Of course Janet doesn’t require wrapping each entry in a <code>cond</code> expression in parentheses, so this isn’t as compelling in Janet.</p>
<p>For a slight variation on this, imagine a macro called <code>::</code>. It’s just like <code>:</code> – it creates a pair – but the pair appears in reverse order from how you write it. We’re well off the Janet path now, but we could use this as a concise notation for adding type annotations without an explosion of parentheses.</p>
<p>Let’s say we have a – function? macro? – <em>something</em> called <code>Int</code> that provides a type annotation to our compiler. We’d normally write the type of an expression like this:</p>
<pre tabindex="0"><code data-lang="janet">(def x (Int (compute-thing)))
</code></pre><p>But look all those close parens! I don’t want to balance those. So instead, we could write:</p>
<pre tabindex="0"><code data-lang="janet">(def x (compute-thing) :: Int)
</code></pre><p>Which is equivalent to the less intuitive (to me):</p>
<pre tabindex="0"><code data-lang="janet">(def x Int:(compute-thing))
</code></pre><p><code>::</code> doesn’t mean “type annotation,” though, it just means “wrap in parentheses.” We could use it to do dumber things:</p>
<pre tabindex="0"><code data-lang="janet">&#34;hello&#34; :: print
</code></pre><p>Which would expand, of course, to <code>(print &#34;hello&#34;)</code>. But… I don’t know why you would want to do that.</p>

<p>Something that I occasionally wish for is a <code>(comment ...)</code> macro that lets me ignore code.</p>
<p>You can’t actually write such a macro in Janet. Janet <em>has</em> a macro called <code>comment</code> in the standard library, but <code>comment</code> always expands to <em>nil</em>, and <code>nil</code> is not <em>nothing</em>. This means there are lots of places you can’t use <code>(comment ...)</code>:</p>
<pre tabindex="0"><code data-lang="janet">(defn foo [a (comment this is a comment)]
  (print a))
</code></pre><p>If you tried to compile that, you’d get an error:</p>
<pre tabindex="0"><code>compile error: unexpected type in destruction, got nil
</code></pre><p>Because after macro expansion, the compiler actually sees:</p>
<pre tabindex="0"><code data-lang="janet">(defn foo [a nil]
  (print a))
</code></pre><p>Which is not valid.</p>
<p>With generalized macros, though, you can write a comment that actually disappears:</p>
<pre tabindex="0"><code data-lang="janet">(defmacro comment [] [&amp;]
  (macro lefts rights [;lefts ;rights]))

(defn foo [a (comment this is a comment)]
  (print a))
</code></pre><p>After expansion, that will just be:</p>
<pre tabindex="0"><code data-lang="janet">(defn foo [a]
  (print a))
</code></pre><p>Like it never happened.</p>

<p>One thing that sometimes trips me up when I’m writing Janet is <code>if</code>.</p>
<p><code>if</code> takes three forms: a boolean expression, an expression to evaluate if it’s truthy, and an expression to evaluate if it’s falsy. Which is nice and concise, but it’s different enough from other languages that I use – languages with explicit <code>else</code>s – that sometimes I’ll write code like this by mistake:</p>
<pre tabindex="0"><code data-lang="janet">(if should-do-something-important
  (print &#34;okay, performing important work:&#34;)
  (perform-important-work))
</code></pre><p>That actually <em>doesn’t</em> perform important work – <code>(perform-important-work)</code> is the “else” section of that conditional. In order to do more than one thing in the “then” branch, we have to wrap all of the statements in <code>do</code>.</p>
<p>And of course Janet has a <code>when</code> macro that does exactly what I want:</p>
<pre tabindex="0"><code data-lang="janet">(when should-do-something-important
  (print &#34;okay, performing important work:&#34;)
  (perform-important-work))
</code></pre><p>Which doesn’t have an <code>else</code> branch, and usually when I’m writing an <code>if</code> without an <code>else</code> I should just use <code>when</code> in the first place.</p>
<p>But.</p>
<p>Generalized macros actually let us write <code>if</code> with an explicit <code>else</code>. I’m not saying this is a <em>good idea</em>, but they let us write something like:</p>
<pre tabindex="0"><code data-lang="janet">(if (empty? name)
  (print &#34;you must provide a valid name&#34;))
(else
  (print &#34;okay i think it checks out&#34;))
</code></pre><p>This example is a little weird because, in order for this to work nicely, we’ll have to rename the built-in <code>if</code>. I’ll call the ternary version <code>if-then-else</code> for this example, and say that <code>if</code> now means the same thing as Janet’s <code>when</code>.</p>
<pre tabindex="0"><code data-lang="janet">(defmacro else [] [else-exprs]
  (macro lefts rights
    (match (last lefts)
      [&#39;if &amp; then-exprs]
        ~(,;(drop-last lefts)
          (if-then-else (do ,;then-exprs) (do ,;else-exprs))
          ,;rights)
      (error &#34;else must come immediately after if&#34;))))
</code></pre><p>This is interesting because the <code>else</code> macro actually rewrites the form <em>before</em> itself, changing the <code>if</code> to an <code>if-then-else</code> and then fussing with its arguments.</p>

<p>I could keep going, but, as you have probably noticed, this is already a very long blog post. There’s a lot more that you can do with generalized macros – some of it useful, some of it unhinged, and we don’t have time to talk about all of it.</p>
<p>So far we’ve only seen macros that rewrite their parents or immediate siblings, but you can write macros that return macros that return macros, and use them to rewrite arbitrary forms anywhere in your program. You could write a macro that rewrites “the nearest enclosing function definition,” recursively accumulating first-class macros until finally expanding all of them.</p>
<p>You can write actual left- and right-associative infix operators, and I think that if you tried hard enough, you could even use dynamic variables and controlled macro expansion to implement infix operator precedence (although I don’t think you <em>should</em>).</p>
<p>You could implement (a weaker version of) Janet’s <code>splice</code> built-in as a generalized macro. You could implement “identifier macros” that look around themselves and expand to something different when they appear as the first argument to a <code>(set ...)</code> form. You could, you could…</p>
<p>You could do a lot of things, but I’m going to have to leave these as exercises to the reader, because it’s time to switch gears and talk about why you <em>shouldn’t</em> do this.</p>

<p>The main reason that this seems like a bad idea is that macros like this don’t work at the top level.</p>
<p>If you’re just using the repl, and you type <code>(defer (file/close f))</code>, what happens? One of the arguments to that macro is “everything to the right.” But there isn’t anything to the right! At least, not yet. And it won’t be able to supply <em>everything</em> to the right until you stop typing altogether.</p>
<p>This might not seem like a big deal for <code>defer</code> – just don’t use <code>defer</code> at the repl – but it is a big deal for, say, <code>def</code>. And I don’t know an elegant way to solve this problem: in the general case, macros could look arbitrarily far ahead, so we’d have to wait until we closed the repl session to be able to expand them. And that’s kinda gross.</p>

<p>All of the examples that we’ve seen so far play nicely together, but it’s possible to write generalized macros that don’t compose with one another.</p>
<p>The problem is that macro behavior can depend on expansion order. Regular macros always get a chance to run <em>before</em> their arguments get expanded, which is very convenient. Generalized macros don’t have that luxury – because macros can see the forms around them, the order that you expand those forms matters.</p>
<p>In my implementation I chose to expand macros in a depth-first, left-to-right order. So macros always see the arguments “to the left” of themselves fully expanded, and the arguments “to the right” completely unexpanded.</p>
<p>And this can be problematic. For example, let’s say we make an infix alias for <code>set</code>, called <code>:=</code>:</p>
<pre tabindex="0"><code data-lang="janet">(var x 0)
(x := 1)
</code></pre><p>Which expands to:</p>
<pre tabindex="0"><code data-lang="janet">(var x 0)
(set x 1)
</code></pre><p>This is a trivial generalized macro to write.</p>
<p>Now let’s say we have <em>another</em> macro, which looks at the form to its left to see if it immediately follows <code>set</code>. When it does, it rewrites that <code>set</code> to something else. We could use this to implement some kind of custom associative data structure:</p>
<pre tabindex="0"><code data-lang="janet">(defmacro at [] [dict key]
  (macro lefts rights
    (if (= lefts [&#39;set])
      ~(assign ,dict ,key ,;rights)
      ~(,;lefts (lookup ,dict ,key) ,;rights))))
</code></pre><p>So that macro lets us write:</p>
<pre tabindex="0"><code data-lang="janet">(set (at dict key) 10)
</code></pre><p>And have that expand to:</p>
<pre tabindex="0"><code data-lang="janet">(assign dict key 10)
</code></pre><p>Meanwhile, if we write <code>(print (at dict key))</code>, that will expand to <code>(print (lookup dict key))</code>.</p>
<p>Each of these generalized macros make sense on their own. But if we try to use them together, they just don’t work:</p>
<pre tabindex="0"><code data-lang="janet">((at dict key) := 1)
</code></pre><p>Because <code>(at dict key)</code> expands first. It looks at the forms to its left, sees that there aren’t any, so after one step of expansion we have:</p>
<pre tabindex="0"><code data-lang="janet">((lookup dict key) := 1)
</code></pre><p>Then we expand <code>:=</code>, and finish with:</p>
<pre tabindex="0"><code data-lang="janet">(set (lookup dict key) 1)
</code></pre><p>Which of course was not what we wanted.</p>
<p>I think that using generalized macros safely requires really understanding the effect that they have on the syntax tree of your program. They’re more like <code>-&gt;&gt;</code> and friends – explicit syntax re-arrangers – than they are like other kinds of macros.</p>

<p>ugh not again</p>

<p>I feel like this approach is so simple that it must have been done before, but I can’t find any references to it. That said, I have no idea how to search for it effectively! So if you’ve seen this technique before, or if you’ve heard of it being used in the past, I’d love to hear about it.</p>

<p>I implemented this macro system in Janet, in order to play around with it and test out my macro implementations.</p>
<p>It was pretty easy to write! It really is a very modest generalization of a traditional macro system. I didn’t actually write a custom module loader that would let you <em>use</em> this as your default macro system in Janet code, but I wrote (the equivalent of) <code>macex</code>, and adding the custom module loader would be pretty easy if you wanted to use it “for real.”</p>
<p>You can look at the code here: <a href="https://github.com/ianthehenry/macaroni">https://github.com/ianthehenry/macaroni</a></p>
<p>Or <a href="https://github.com/ianthehenry/macaroni/tree/master/test">take a peek at some of the tests</a>, to see the examples in this post in action, as well as some weirder things that <a href="https://github.com/ianthehenry/macaroni/blob/master/test/grandparent.janet">didn’t make the cut</a>.</p>
</div>
</article></div>
  </body>
</html>
