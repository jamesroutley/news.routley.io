<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.onsclom.net/posts/javascript-tco">Original</a>
    <h1>Bun, JavaScript, and TCO</h1>
    
    <div id="readability-page-1" class="page"><div> <main data-astro-cid-egg7nqdx=""><p><a href="https://bun.sh/">Bun</a> is a JavaScript runtime that just released version 1.0! Now you have three
choices for running JavaScript outside of the browser: Node, Deno, and Bun. One of Bun’s selling
points is speed! It makes some interesting decisions to acheive this.</p>
<p>For one, Bun is programmed using <a href="https://ziglang.org/">Zig</a>. This results in an exciting universe:
Node is made with <strong>C++</strong>, Deno is made with <strong>Rust</strong>, and Bun is made with <strong>Zig</strong>. Isn’t this an
exciting battle of system languages?! We will actually focus on something else however.</p>
<p>Node and Deno are built on V8, while Bun is built on JavaScriptCore. You might know V8 as the
JavaScript engine of Chrome. JavaScriptCore is the engine for Safari. They have lots of interesting
differences, but we will be focusing on a niche optimization which JavaScriptCore implements and V8
does not: <strong>Tail Call Optimization</strong>.</p>
<p>Let’s dive in by writing some real code! Imagine you need to implement the following function:</p>
<pre tabindex="0"><code><span><span>/*</span></span>
<span><span>  Returns an array of numbers counting from 1 to amount.</span></span>
<span></span>
<span><span>  Examples:</span></span>
<span><span>    count(3) =&gt; [1, 2, 3]</span></span>
<span><span>    count(5) =&gt; [1, 2, 3, 4, 5]</span></span>
<span><span>    count(-1) =&gt; []</span></span>
<span><span>*/</span></span>
<span><span>function</span><span> count</span><span>(</span><span>amount</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span>[];</span></span></code></pre>
<p>Give it a try yourself if you want! I imagine most people will come up with a solution like:</p>
<pre tabindex="0"><code><span><span>function</span><span> count</span><span>(</span><span>amount</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span>[] {</span></span>
<span><span>	let</span><span> nums</span><span>:</span><span> number</span><span>[] </span><span>=</span><span> [];</span></span>
<span><span>	for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 1</span><span>; i </span><span>&lt;=</span><span> amount; i</span><span>++</span><span>) nums.</span><span>push</span><span>(i);</span></span>
<span><span>	return</span><span> nums;</span></span>
<span><span>}</span></span></code></pre>
<p>This is a great solution that works totally fine! But now, I will present an arbitrary challenge to
introduce tail call optimization. Can you represent this as a recursive function? Give it a try.
After a bit of thinking, you might come up with this:</p>
<pre tabindex="0"><code><span><span>const</span><span> count</span><span> =</span><span> (</span><span>amount</span><span>:</span><span> number</span><span>) </span><span>=&gt;</span><span> (amount </span><span>&gt;</span><span> 0</span><span> ?</span><span> [</span><span>...</span><span>count</span><span>(amount </span><span>-</span><span> 1</span><span>), amount] </span><span>:</span><span> []);</span></span></code></pre>
<p>Its a succinct solution! It might look familiar to recurrence relations from math class. You might
be thinking, “It looks like loops can be expressed more elegantly with recursion!” But, now I have
something sad to share. Try doing <code>count(100000)</code> (Deno and Bun allow running TypeScript directly).
You will get the error <code>Maximum call stack size exceeded</code>.</p>
<p>Recursion takes up precious memory on the call stack! There may be commands to increase the call
stack size for your program, but there is only so much the OS will allow. Memory on the heap is much
less restricted. How can we use recursion without fear of exceeding the call stack? The answer: hope
your JavaScript engine implements TCO and write your recursion in a way that can be optimized!</p>
<p>The process of rewriting a function to be tail call optmized generally involves moving state to
arguments. The recursive call needs to be the last thing in the function’s AST. The TCO version of
our recursive function looks like:</p>
<pre tabindex="0"><code><span><span>const</span><span> count</span><span> =</span><span> (</span><span>amount</span><span>:</span><span> number</span><span>, </span><span>cur</span><span>:</span><span> number</span><span>[] </span><span>=</span><span> []) </span><span>=&gt;</span></span>
<span><span>	cur.</span><span>length</span><span> &gt;=</span><span> amount </span><span>?</span><span> cur </span><span>:</span><span> count</span><span>(amount, [</span><span>...</span><span>cur, cur.</span><span>length</span><span> +</span><span> 1</span><span>]);</span></span></code></pre>
<p>Its slightly less succint and elegant, but it can be tail call optimized now! If we run
<code>count(100000)</code> with Deno, we still get
<code>error: Uncaught RangeError: Maximum call stack size exceeded</code>. With Bun, the program now
successfully runs! But there’s still one more problem… This solution is really slow.</p>
<p><code>count(100000)</code> with this TCO solution takes 7 seconds with bun. The original for loop solution
takes <code>.01s</code>. How can we get similar performance to the for loop solution while still using
recursion? We use mutation:</p>
<pre tabindex="0"><code><span><span>function</span><span> count</span><span>(</span><span>amount</span><span>:</span><span> number</span><span>, </span><span>cur</span><span>:</span><span> number</span><span>[] </span><span>=</span><span> []) {</span></span>
<span><span>	if</span><span> (cur.</span><span>length</span><span> &gt;=</span><span> amount) </span><span>return</span><span> cur;</span></span>
<span><span>	cur.</span><span>push</span><span>(cur.</span><span>length</span><span> +</span><span> 1</span><span>);</span></span>
<span><span>	return</span><span> count</span><span>(amount, cur);</span></span>
<span><span>}</span></span></code></pre>
<p>This function is starting to look a lot like the orignal for loop solution. It’s not very succinct
or elegant anymore. But, it runs <code>count(100000)</code> at <code>.01s</code> as well. Nice!</p>
<p>The minimalist part of me really enjoys TCO. It enables a language to express complex and efficient
programs without imperative loops. In the case of JavaScript, it means a smaller subset of the
language can express all programs. Most beginners are taught loop statements as if they are
fundamental or required in every language. But that’s not true. With TCO, you can express any loop
statement using recursion and get similar performance.</p>
<p>Languages that rely on recursion like LISPs often specify that TCO must be implemented in their
language spec. Sadly, TCO is only implemented in JavaScriptCore. Thankfully, Bun and Safari use
JavaScriptCore!</p></main> </div></div>
  </body>
</html>
