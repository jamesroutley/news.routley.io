<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nkantar.com/blog/2025/08/static-python-uv-caddy-docker/">Original</a>
    <h1>Static sites with Python, uv, Caddy, and Docker</h1>
    
    <div id="readability-page-1" class="page"><div>

      


      

      



<p>Wednesday, August 20, 2025</p>



<p>My preferred deployment stack for Python-built static sites.</p>

<p>I’ve largely switched to <a href="https://docs.astral.sh/uv/" title="uv">uv</a> at this point and it’s been pretty great. I use it for everything I can, from little scripts with <code>uv run</code>, to <a href="https://github.com/nkantar/Parsenvy" title="nkantar/Parsenvy: Enviously Elegant Environment Variable Parsing">libraries</a>, to applications. It’s so fast it <em>does</em> actually matter, the workflow side of things works well enough for me, and—perhaps most valuably—it manages <a href="https://www.python.org/" title="Welcome to Python.org">Python</a> executables for me beautifully.</p>
<p>As we’re all familiar with by now, I’m a static site aficionado, and have a number out in the wild. Some are purely static—hand-crafted artisanal HTML and CSS—and others are built with Python. I like serving them all with <a href="https://caddyserver.com/" title="Caddy - The Ultimate Server with Automatic HTTPS">Caddy</a> inside a <a href="https://docs.docker.com/build/building/multi-stage/" title="Multi-stage | Docker Docs">multi-stage</a> build <a href="https://www.docker.com/" title="Docker: Accelerated Container Application Development">Docker</a> container, which has been working quite well for me so far.</p>
<p>In this post I want to explain the fairly simple setup I use to build and serve a number of websites using the above stack.</p>
<h2>Example</h2>
<p>For our main example we can use my personal deployment of <a href="https://github.com/nkantar/sus" title="nkantar/sus: Really simple static website URL shortener">sus</a>, a static site based URL shortener I wrote and have been using for years.</p>
<h3>Dockerfile</h3>
<p>Let’s start with the <code>Dockerfile</code> and then we’ll go through it line by line:</p>
<div><pre><span></span><span># use Debian image with uv, no need for system Python</span>
<span>FROM</span><span> </span><span>ghcr.io/astral-sh/uv:debian</span><span> </span><span>AS</span><span> </span><span>build</span>

<span># explicit work dir is important</span>
<span>WORKDIR</span><span> </span><span>/src</span>

<span># copy all files</span>
<span>COPY</span><span> </span>.<span> </span>.

<span># install Python with uv</span>
<span>RUN</span><span> </span>uv<span> </span>python<span> </span>install<span> </span><span>3</span>.13

<span># run build process</span>
<span>RUN</span><span> </span>uv<span> </span>run<span> </span>--no-dev<span> </span>sus

<span># serve with Caddy</span>
<span>FROM</span><span> </span><span>caddy:alpine</span>

<span># copy Caddy config</span>
<span>COPY</span><span> </span>Caddyfile<span> </span>/etc/caddy/Caddyfile

<span># copy generated static site</span>
<span>COPY</span><span> </span>--from<span>=</span>build<span> </span>/src/output<span> </span>/srv/
</pre></div>
<p>The first line is our starting image:</p>
<div><pre><span></span><span># use Debian image with uv, no need for system Python</span>
<span>FROM</span><span> </span><span>ghcr.io/astral-sh/uv:debian</span><span> </span><span>AS</span><span> </span><span>build</span>
</pre></div>
<p>It uses an image built by <a href="https://astral.sh/" title="Astral: High-performance Python tooling">Astral</a>, the makers of uv, that’s based on <a href="https://www.debian.org/" title="Debian -- The Universal Operating System">Debian</a>. It also names it <code>build</code>, since we’re only using the image in the first step, and are actually not relying on it by the end of the process.</p>
<p>The second line defines our working directory inside the container:</p>
<div><pre><span></span><span># explicit work dir is important</span>
<span>WORKDIR</span><span> </span><span>/src</span>
</pre></div>
<p>I habitually choose <code>/src</code> as it makes sense given what I’m trying to accomplish. In theory this doesn’t matter much and you can use something else if you prefer.</p>
<p>The third line copies the repo into the container:</p>
<div><pre><span></span><span># copy all files</span>
<span>COPY</span><span> </span>.<span> </span>.
</pre></div>
<p>The first <code>.</code> refers to the path on the host machine, and in this case that’s the repo root. The second <code>.</code> refers to the working directory we set above, so it would be <code>/src</code> in this case.</p>
<p>After this is when the magic starts:</p>
<div><pre><span></span><span># install Python with uv</span>
<span>RUN</span><span> </span>uv<span> </span>python<span> </span>install<span> </span><span>3</span>.13
</pre></div>
<p>Remember how I said uv can manage Python executables? This is one way to achieve this, and has been a bulletproof, fast way of doing so. It also mirrors what I do locally on my personal machine, maintaining some consistency.</p>
<p>Once we have the Python version we want, we can run the build step, which also installs dependencies:</p>
<div><pre><span></span><span># run build process</span>
<span>RUN</span><span> </span>uv<span> </span>run<span> </span>--no-dev<span> </span>sus
</pre></div>
<p>uv will automatically sync the virtual environment, and thus in our case install dependencies. The <code>--no-dev</code> flag skips any dependencies defined as dev-only. In this case I don’t have any, but in other projects I use tools like <a href="https://docs.pytest.org/en/stable/" title="pytest documentation">pytest</a> and <a href="https://github.com/pdbpp/pdbpp" title="pdbpp/pdbpp: pdb++, a drop-in replacement for pdb (the Python debugger)">pdbpp</a>, for example. Note that you probably want to omit this flag if you’re using this container in <a href="https://en.wikipedia.org/wiki/Continuous_integration" title="Continuous integration - Wikipedia">CI</a>. sus builds the site in <code>/output</code> upon invocation of the eponymous command, which is consistent with with my other projects. (Some day I’ll standardize all my projects using <a href="https://github.com/casey/just" title="casey/just: 🤖 Just a command runner">just</a> and <code>Justfile</code>s, and will be able to do something like <code>RUN uv just build</code>, but that day hasn’t yet arrived.)</p>
<p>With the site built in <code>/src/output</code>, it’s time to leave uv and Python behind and move onto Caddy:</p>
<div><pre><span></span><span># serve with Caddy</span>
<span>FROM</span><span> </span><span>caddy:alpine</span>
</pre></div>
<p>It’s generally a good idea to specify the desired version, but I guess I like to live dangerously. This directive tells Docker to start building using a different image, whilst keeping the previous one around for reference.</p>
<p>The only Caddy config we need is copying the <code>Caddyfile</code> to the default destination:</p>
<div><pre><span></span><span># copy Caddy config</span>
<span>COPY</span><span> </span>Caddyfile<span> </span>/etc/caddy/Caddyfile
</pre></div>
<p>This allows the automatically started Caddy process to pick up the config without having to tell it where to look.</p>
<p>And our final step is to copy the output we generated with uv and Python into the location where Caddy expects to find the files to serve:</p>
<div><pre><span></span><span># copy generated static site</span>
<span>COPY</span><span> </span>--from<span>=</span>build<span> </span>/src/output<span> </span>/srv/
</pre></div>
<p>This time we specify the source location as that first builder image we used with <code>--from=build</code>, reference the path where the contents of the built site were placed, and drop it all into the location specified in the <code>Caddyfile</code> below.</p>
<p>All this above results in a Caddy-based image with our files in <code>/srv</code> and our Caddy config in <code>/etc/caddy/Caddyfile</code>, ready to be served.</p>
<h2>Caddy</h2>
<p>The <code>Caddyfile</code> is a human-readable configuration file for Caddy, with JSON being the other option. Here is this one in all its glory, and we’ll go through all its parts:</p>
<div><pre>mwokss00s84sg0okwoggg8s0.5.78.24.144.sslip.io:80,
mwokss00s84sg0okwoggg8s0.5.78.24.144.sslip.io:443,
link.pileof.tools:80,
link.pileof.tools:443,
l.pileof.tools:80,
l.pileof.tools:443 {
    root * /srv
    file_server

    @plausible path /js/script.js /api/event
    handle @plausible {
        rewrite /js/script.js /js/script.js
        reverse_proxy https://plausible.io {
            header_up Host {http.reverse_proxy.upstream.hostport}
            transport http {
                tls
            }
        }
    }
}
</pre></div><p><code>Caddyfile</code>s can contain multiple site configurations, and I habitually structure mine as such even if they only have one. The first six lines define which domains and ports the section configures:</p>
<div><pre>mwokss00s84sg0okwoggg8s0.5.78.24.144.sslip.io:80,
mwokss00s84sg0okwoggg8s0.5.78.24.144.sslip.io:443,
link.pileof.tools:80,
link.pileof.tools:443,
l.pileof.tools:80,
l.pileof.tools:443 {
</pre></div><p>The first domain is the default one <a href="https://coolify.io/cloud/" title="Coolify Cloud">Coolify Cloud</a> generated for this site when I configured it, the second is the actual domain I tend to use, and the third saves me a whopping three characters…or would, if I ever used it. For each domain I want to serve content on port 80 (http) and 443 (https).</p>
<p>The following two lines tell Caddy to serve content from <code>/srv</code>:</p>
<p>The <code>root</code> directive defines which files to serve and from which path in the container, and the <code>file_server</code> directive tells it to serve them up. Caddy can do many other things, but I’ve only ever used it in this capacity.</p>
<p>The remainder of the file is pretty specific to my setup, and is the rewrite for <a href="https://plausible.io/" title="Plausible Analytics | Simple, privacy-friendly Google Analytics alternative">Plausible Analytics</a>, a privacy-friendly analytics service I use:</p>
<div><pre>    @plausible path /js/script.js /api/event
    handle @plausible {
        rewrite /js/script.js /js/script.js
        reverse_proxy https://plausible.io {
            header_up Host {http.reverse_proxy.upstream.hostport}
            transport http {
                tls
            }
        }
    }
}
</pre></div><p>What it lets me to is pretend I’m hosting the actual JS files required for Plausible to work, invisibly proxying the requests to their manager instance. This helps a bit with some content blockers, which I’m fine with given Plausible’s privacy-friendly <em>raison dêtre</em>. The actual code can be broken down as such:</p>
<ul>
<li><code>@plausible path /js/script.js /api/event</code> registers the two paths under the <code>@plausible</code> named matcher, letting us tie functionality to them.</li>
<li><code>handle @plausible</code> defines the config for said paths.</li>
<li><code>rewrite /js/script.js /js/script.js</code> “redirects” the first path on my domain to the second path on the target domain, which just happen to be identical here.</li>
<li><code>reverse_proxy https://plausible.io {</code> sets up a reverse proxy to the Plausible domain.</li>
<li><code>header_up Host {http.reverse_proxy.upstream.hostport}</code> replaces the host in the request header.</li>
<li><code>transport http { tls }</code> enables TLS for the rewrite</li>
</ul>
<p>All my sites have nearly identical configuration.</p>
<h2>Notes</h2>
<h3>Error Pages</h3>
<p>Another site of mine uses this snippet to provide custom error pages:</p>
<div><pre>handle_errors {
    rewrite * /{err.status_code}.html
    file_server
}
</pre></div><p>This would result in Caddy serving a file named <code>404.html</code> in the case of a 404 error, etc.</p>
<h3>Content Type</h3>
<p>The same site also needs to provide a specific content type for a few paths:</p>
<div><pre>@feed {
    path /feed/*
    path /blog/feed/*
}
handle @feed {
    header Content-Type application/atom+xml
}
</pre></div><h3>Redirect</h3>
<p>Another site is just a redirect to an entirely different page:</p>
<div><pre>redir https://example.com/foobar
</pre></div><h2>Conclusion</h2>
<p>This stack has been serving me quite well for the month or so since I migrated things to it. I want to standardize my projects to rely on <code>just build</code> as the only command I need to specify in the <code>Dockerfile</code> to get things to work, but that’s the only change I’d like to make at the moment.</p>
<p>Hope this was helpful, or at least interesting!</p>


<hr/>





<hr/>



<p>
    <em>
        Thanks for reading! You can keep up with my writing via the <a href="https://nkantar.com/feed" title="Feed">feed</a>
        or <a href="https://nkantar.com/newsletter" title="Newsletter">newsletter</a>,
        or you can get in touch via <a href="mailto:nik@nkantar.com" title="Email">email</a> or
        <a href="https://nkantar.social/@nik" title="Nik Kantar (@nik@nkantar.social) - nkantar.social">Mastodon</a>.
    </em>
</p>



    <hr/>

    
    
    

    
    
    

    





      


    </div></div>
  </body>
</html>
