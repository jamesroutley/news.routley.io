<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://openjdk.java.net/jeps/405">Original</a>
    <h1>Java record pattern matching in JDK 19</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="Summary">Summary</h2>
<p>Enhance the Java programming language with <em>record patterns</em> to deconstruct record
values. Record patterns and type patterns can be nested to
enable a powerful, declarative, and composable form of data navigation and
processing.  This is a <a href="https://openjdk.java.net/jeps/12">preview language feature</a>.</p>
<h2 id="Goals">Goals</h2>
<ul>
<li>
<p>Extend pattern matching to express more sophisticated, composable data queries.</p>
</li>
<li>
<p>Do not change the syntax or semantics of type patterns.</p>
</li>
</ul>
<h2 id="Motivation">Motivation</h2>
<p>In JDK 16, <a href="https://openjdk.java.net/jeps/394">JEP 394</a> extended the <code>instanceof</code> operator to take a <em>type
pattern</em> and perform <em>pattern matching</em>. This modest extension allows the
familiar instanceof-and-cast idiom to be simplified:</p>
<pre><code>// Old code
if (o instanceof String) {
    String s = (String)o;
    ... use s ...
}

// New code
if (o instanceof String s) {
    ... use s ...
}</code></pre>
<p>In the new code, <code>o</code> matches the type pattern <code>String s</code> if, at run time, the
value of <code>o</code> is an instance of <code>String</code>. If the pattern matches then the
<code>instanceof</code> expression is <code>true</code> and the pattern variable <code>s</code> is initialized to
the value of <code>o</code> cast to <code>String</code>, which can then be used in the contained block.</p>
<p>In JDK 17 and JDK 18 we extended the use of type patterns to <code>switch</code> case
labels as well, via <a href="https://openjdk.java.net/jeps/406">JEP 406</a> and <a href="https://openjdk.java.net/jeps/420">JEP 420</a>.</p>
<p>Type patterns remove many occurrences of casting at a stroke. However, they are
only the first step towards a more declarative, data-focused style of programming.
As Java supports new and more expressive ways of modeling data, pattern matching
can streamline the use of such data by enabling developers to express the semantic
intent of their models.</p>
<h3 id="Pattern-matching-and-record-classes">Pattern matching and record classes</h3>
<p>Record classes (<a href="https://openjdk.java.net/jeps/395">JEP 395</a>) are transparent carriers for data. Code that
receives an instance of a record class will typically extract the data, known as
the <em>components</em>. For example, we can use a type pattern to test whether a value
is an instance of the record class <code>Point</code> and, if so, extract the <code>x</code> and <code>y</code>
components from the value:</p>
<pre><code>record Point(int x, int y) {}

static void printSum(Object o) {
    if (o instanceof Point p) {
        int x = p.x();
        int y = p.y();
        System.out.println(x+y);
    }
}</code></pre>
<p>The pattern variable <code>p</code> is used here solely to invoke the
accessor methods <code>x()</code> and <code>y()</code>, which return the values of the components <code>x</code>
and <code>y</code>. (In every record class there is a one-to-one correspondence between its
accessor methods and its components.)  It would be better if the pattern could
not only test whether a value is an instance of <code>Point</code>, but also extract the <code>x</code>
and <code>y</code> components from the value directly, invoking the accessor methods on
our behalf. In other words:</p>
<pre><code>record Point(int x, int y) {}

void printSum(Object o) {
    if (o instanceof Point(int x, int y)) {
        System.out.println(x+y);
    }
}</code></pre>
<p><code>Point(int x, int y)</code> is a <em>record pattern</em>. It lifts the declaration of local
variables for extracted components into the pattern itself, and initializes those
variables by invoking the accessor methods when a value is matched against the
pattern. In effect, a record pattern disaggregates an instance of a record into
its components.</p>
<p>The true power of pattern matching is that it scales elegantly to match more
complicated object graphs. For example, consider the following declarations:</p>
<pre><code>record Point(int x, int y) {}
enum Color { RED, GREEN, BLUE }
record ColoredPoint(Point p, Color c) {}
record Rectangle(ColoredPoint upperLeft, ColoredPoint lowerRight) {}</code></pre>
<p>We have already seen that we can extract the components of an object with a
record pattern.  If we want to extract the color from the upper-left point, we
could write:</p>
<pre><code>static void printUpperLeftColoredPoint(Rectangle r) {
    if (r instanceof Rectangle(ColoredPoint ul, ColoredPoint lr)) {
         System.out.println(ul.c());
    }
}</code></pre>
<p>But our <code>ColoredPoint</code> is itself a record, which we might want to decompose
further.  Record patterns therefore support <em>nesting</em>, which allows the record
component to be further matched against, and decomposed by, a nested pattern.  We
can nest another pattern inside the record pattern, and decompose both the outer
and inner records at once:</p>
<pre><code>static void printColorOfUpperLeftPoint(Rectangle r) {
    if (r instanceof Rectangle(ColoredPoint(Point p, Color c),
                               ColoredPoint lr)) {
        System.out.println(c);
    }
}</code></pre>
<p>Nested patterns allow us, further, to take apart an aggregate with code that is as
clear and concise as the code that puts it together. If we were creating a
rectangle, for example, we would likely nest the constructors in a single
expression:</p>
<pre><code>Rectangle r = new Rectangle(new ColoredPoint(new Point(x1, y1), c1), 
                            new ColoredPoint(new Point(x2, y2), c2));</code></pre>
<p>With nested patterns we can deconstruct such a rectangle with code that echoes the
structure of the nested constructors:</p>
<pre><code>static void printXCoordOfUpperLeftPointWithPatterns(Rectangle r) {
    if (r instanceof Rectangle(ColoredPoint(Point(var x, var y), var c),
                               var lr)) {
        System.out.println(&#34;Upper-left corner: &#34; + x);
    }
}</code></pre>
<p>In summary, nested patterns elide the accidental complexity of navigating objects
so that we can focus on the data expressed by those objects.</p>
<h2 id="Description">Description</h2>
<p>We extend the Java programming language with nestable record patterns.</p>
<p>The grammar for patterns will become:</p>
<pre><code>Pattern:
  TypePattern
  ParenthesizedPattern
  RecordPattern

TypePattern:
  LocalVariableDeclaration

ParenthesizedPattern:
  ( Pattern )

RecordPattern:
  ReferenceType RecordStructurePattern [ Identifier ]

RecordStructurePattern:
  ( [ RecordComponentPatternList ] )

RecordComponentPatternList : 
  Pattern { , Pattern }</code></pre>
<h3 id="Record-patterns">Record patterns</h3>
<p>A <em>record pattern</em> consists of a type, a (possibly empty) record component
pattern list which is used to match against the corresponding record components,
and an optional identifier. A record pattern with an identifier is called a
<em>named</em> record pattern, and the variable is referred to as the <em>record pattern
variable</em>.</p>
<p>For example, given the declaration</p>
<pre><code>record Point(int i, int j) {}</code></pre>
<p>a value <code>v</code> matches the record pattern <code>Point(int i, int j) p</code> if it is an instance of
the record type <code>Point</code>; if so, the pattern variable <code>i</code> is initialized with the
result of invoking the accessor method corresponding to <code>i</code> on the value, and
the pattern variable <code>j</code> is initialized to the result of invoking the accessor
method corresponding to <code>j</code> on the value. (The names of the pattern
variables do not need to be the same as the names of the record components; i.e.,
the record pattern <code>Point(int x, int y)</code> acts identically except that the
pattern variables <code>x</code> and <code>y</code> are initialized.) The record pattern variable <code>p</code>
is initialized to the value of <code>v</code> cast to <code>Point</code>.</p>
<p>The <code>null</code> value does not match any record pattern.</p>
<p>A record pattern can use <code>var</code> to match against a record component without
stating the type of the component. In that case the compiler infers the type of
the pattern variable introduced by the <code>var</code> pattern. For example, the pattern
<code>Point(var a, var b)</code> is shorthand for the pattern <code>Point(int a, int b)</code>.</p>
<p>The set of pattern variables declared by a record pattern includes all of the
pattern variables declared in the record component pattern list and, if the
record pattern is a named record pattern, the record pattern variable.</p>
<p>An expression is compatible with a record pattern if it could be cast to the
record type in the pattern without requiring an unchecked conversion.</p>
<p>If a record class is generic, then any record pattern that names this record
class must use a generic type. For example, given the declaration:</p>
<pre><code>record Box&lt;T&gt;(T t) {}</code></pre>
<p>The following methods are correct:</p>
<pre><code>static void test1(Box&lt;Object&gt; bo) {
    if (bo instanceof Box&lt;Object&gt;(String s)) {
        System.out.println(&#34;String &#34; + s);
    }
}
static void test2(Box&lt;Object&gt; bo) {
    if (bo instanceof Box&lt;String&gt;(var s)) {
        System.out.println(&#34;String &#34; + s);
    }
}</code></pre>
<p>whereas both of the following result in compile-time errors:</p>
<pre><code>static void erroneousTest1(Box&lt;Object&gt; bo) {
    if (bo instanceof Box(var s)) {                 // Error
        System.out.println(&#34;I&#39;m a box&#34;);
    }
}
static void erroneousTest2(Box b) {
    if (b instanceof Box(var t)) {                  // Error
        System.out.println(&#34;I&#39;m a box&#34;);
    }
}</code></pre>
<p>In the future we may extend inference to infer the type arguments of generic
record patterns.</p>
<h3 id="Record-patterns-and-exhaustive-switch">Record patterns and exhaustive <code>switch</code></h3>
<p><a href="https://openjdk.java.net/jeps/420">JEP 420</a> enhanced both <code>switch</code> expressions and <code>switch</code> statements
to support labels that include patterns, including record patterns. Both <code>switch</code>
expressions and pattern <code>switch</code> statements must be <em>exhaustive:</em> The switch block
must have clauses that deal with all possible values of the selector
expression. For pattern labels this is determined by analysis of the types of the
patterns; for example, the case label <code>case Bar b</code> matches values of type <code>Bar</code>
and all possible subtypes of <code>Bar</code>.</p>
<p>With pattern labels involving record patterns, the analysis is more complex since
we must consider the types of the component patterns and make allowances for
<code>sealed</code> hierarchies. For example, consider the declarations:</p>
<pre><code>class A {}
class B extends A {}
sealed interface I permits C, D {}
final class C implements I {}
final class D implements I {}
record Pair&lt;T&gt;(T x, T y) {}

Pair&lt;A&gt; p1;
Pair&lt;I&gt; p2;</code></pre>
<p>The following <code>switch</code> is not exhaustive, since there is no match for a pair
containing two values both of type <code>A</code>:</p>
<pre><code>switch (p1) {                 // Error!
    case Pair&lt;A&gt;(A a, B b) -&gt; ...
    case Pair&lt;A&gt;(B b, A a) -&gt; ...
}</code></pre>
<p>These two switches are exhaustive, as the interface <code>I</code> is <code>sealed</code> and so
the types <code>C</code> and <code>D</code> cover all possible instances:</p>
<pre><code>switch (p2) {
    case Pair&lt;I&gt;(I i, C c) -&gt; ...
    case Pair&lt;I&gt;(I i, D d) -&gt; ...
}

switch (p2) {
    case Pair&lt;I&gt;(C c, I i) -&gt; ...
    case Pair&lt;I&gt;(D d, C c) -&gt; ...
    case Pair&lt;I&gt;(D d, D d) -&gt; ...
}</code></pre>
<p>In contrast, this <code>switch</code> is not exhaustive as there is no match for a pair
containing two values both of type <code>D</code>:</p>
<pre><code>switch (p2) {                        // Error!
    case Pair&lt;I&gt;(C fst, D snd) -&gt; ...
    case Pair&lt;I&gt;(D fst, C snd) -&gt; ...
    case Pair&lt;I&gt;(I fst, C snd) -&gt; ...
}</code></pre>
<h2 id="Future-Work">Future Work</h2>
<p>There are many directions in which the record patterns described here could be
extended:</p>
<ul>
<li>Array patterns, whose subpatterns match individual array elements;</li>
<li>Varargs patterns, when the record is a varargs record;</li>
<li>Inference for type arguments in generic record patterns, possibly using a
diamond form (<code>&lt;&gt;</code>);</li>
<li>Do-not-care patterns, which can appear as an element in a record component
pattern list but do not declare a pattern variable; and</li>
<li>Patterns based upon arbitrary classes rather than only record classes.</li>
</ul>
<p>We may consider some of these in future JEPs.</p>
<h2 id="Dependencies">Dependencies</h2>
<p>This JEP builds on <a href="https://openjdk.java.net/jeps/394">JEP 394</a> (Pattern Matching for <code>instanceof</code>),
delivered in JDK 16.</p>
</div></div>
  </body>
</html>
