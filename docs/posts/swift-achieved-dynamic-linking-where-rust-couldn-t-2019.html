<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://faultlore.com/blah/swift-abi/">Original</a>
    <h1>Swift Achieved Dynamic Linking Where Rust Couldn&#39;t (2019)</h1>
    
    <div id="readability-page-1" class="page"><article>

    
    <header>
    
    <p>November 7th, 2019</p>
<nav id="TOC"><ul>
<li><a href="#background">1 Background</a><ul>
<li><a href="#swift-tldr">1.1 Swift TLDR</a><ul></ul></li>
<li><a href="#what-is-abi-stability-and-dynamic-linking">1.2 What Is ABI Stability and Dynamic Linking</a><ul></ul></li>
<li><a href="#swifts-stable-abi">1.3 Swift‚Äôs Stable ABI</a><ul></ul></li>
<li><a href="#resilience-and-library-evolution">1.4 Resilience and Library Evolution</a><ul></ul></li></ul></li>
<li><a href="#details">2 Details</a><ul>
<li><a href="#resilient-type-layout">2.1 Resilient Type Layout</a><ul></ul></li>
<li><a href="#polymorphic-generics">2.2 Polymorphic Generics</a><ul></ul></li>
<li><a href="#reabstraction">2.3 Reabstraction</a><ul></ul></li>
<li><a href="#materialization">2.4 Materialization</a><ul></ul></li>
<li><a href="#ownership">2.5 Ownership</a><ul></ul></li>
<li><a href="#opting-out-of-resilience">2.6 Opting Out of Resilience</a><ul></ul></li>
<li><a href="#esoterica">2.7 Esoterica</a><ul></ul></li></ul></li></ul></nav></header>
<p>For those who don‚Äôt follow Swift‚Äôs development, ABI stability has been one of its most ambitious projects and possibly it‚Äôs defining feature, <a href="https://swift.org/blog/abi-stability-and-more/">and it finally shipped in Swift 5</a>. The result is something I find endlessly fascinating, because I think Swift has pushed the notion of ABI stability farther than any language without much compromise.</p>
<p>So I decided to write up a bunch of the interesting high-level details of Swift‚Äôs ABI. This <strong>is not</strong> a complete reference for Swift‚Äôs ABI, but rather an abstract look at its implementation strategy. If you really want to know exactly how it allocates registers or mangles names, look somewhere else.</p>
<p>Also for context on why I‚Äôm writing this, I‚Äôm just naturally inclined to compare the design of Swift to Rust, because those are the two languages I have helped develop. Also some folks like to complain that Rust doesn‚Äôt bother with ABI stability, and I think looking at how Swift <em>does</em> helps elucidate why that is.</p>
<p>This article is broken up into two sections: background and details. Feel free to skip to the details if you‚Äôre very comfortable with the problems inherent to producing a robust dynamically linked system interface.</p>
<p>If you aren‚Äôt comfortable with the basic concepts of type layouts, ABIs, and calling conventions, I recommend reading the article I wrote on <a href="https://gankra.github.io/blah/rust-layouts-and-abis/">the basic concepts of type layout and ABI as they pertain to Rust</a>.</p>
<p>Also huge thanks to the Swift devs for answering all of the questions I had and correcting my misunderstandings!</p>
<h2 id="swift-tldr"><a href="#swift-tldr">1.1 Swift TLDR</a></h2>
<p>I know a lot of people don‚Äôt really follow Swift, and it can be hard to understand what they‚Äôve really accomplished without some context of what the language is like, so here‚Äôs a TL;DR of the language‚Äôs shape:</p>
<ul>
<li>Exists to replace Objective-C on Apple‚Äôs platforms, oriented at application development
<ul>
<li>natively interoperates with Objective-C</li>
<li>has actual classes and inheritance</li>
</ul>
</li>
<li>At a distance, very similar to Rust (but ‚Äúhigher-level‚Äù)
<ul>
<li>interfaces, generics, closures, enums with payloads, unsafe escape hatch</li>
<li>no lifetimes; Automatic Reference Counting (ARC) used for complex cases</li>
<li>simple function-scoped mutable borrows (inout)</li>
<li>Ahead-Of-Time (AOT) compiled</li>
</ul>
</li>
<li>An emphasis on ‚Äúvalue semantics‚Äù
<ul>
<li>structs/primitives (‚Äúvalues‚Äù) are ‚Äúmutable xor shared‚Äù, stored inline</li>
<li>collections implement value semantics by being Copy-On-Write (CoW) (using ARC)</li>
<li>classes are mutably shared and boxed (using ARC), undermining value semantics (can even cause data races)</li>
</ul>
</li>
<li>An emphasis on things Just Working
<ul>
<li>language may freely allocate to make things Work</li>
<li>generic code may be polymorphically compiled</li>
<li>fields may secretly be getter-setter pairs</li>
<li>ARC and CoW can easily result in surprising performance cliffs</li>
<li>tons of overloading and syntactic sugar</li>
</ul>
</li>
</ul>
<p>Don‚Äôt worry about fully understanding all of these, we‚Äôll dig into the really important ones and their implications as we go on.</p>
<h2 id="what-is-abi-stability-and-dynamic-linking"><a href="#what-is-abi-stability-and-dynamic-linking">1.2 What Is ABI Stability and Dynamic Linking</a></h2>
<p>When the Swift developers talk about ‚ÄúABI Stability‚Äù they have exactly one thing in mind: they want native system APIs for MacOS and iOS to be written in Swift, and for you to dynamically link to them. This includes dynamically linking to a single system-wide copy of the Swift Standard Library.</p>
<p>Ok so what‚Äôs dynamic linking? For our purposes it‚Äôs a system where you can compile an application against some abstract <em>description</em> of an interface without providing an actual implementation of it. This produces an application that on its own will not work properly, as part of its implementation is missing.</p>
<p>To run properly, it must tell the system‚Äôs <em>dynamic linker</em> about all of the interfaces it needs implementations for, which we call <em>dynamic libraries</em> (dylibs). Assuming everything goes right, those implementations get hooked up to the application and everything Just Works.</p>
<p>Dynamic linking is very important to system APIs because it‚Äôs what allows the system‚Äôs implementation to be updated without also rebuilding all the applications that run on it. The applications don‚Äôt care about what implementation they get, as long as it conforms to the interface they were built against.</p>
<p>It can also significantly reduce a system‚Äôs memory footprint by making every application share the same implementation of a library (Apple cares about this a lot on its mobile devices).</p>
<p>Since Swift is AOT compiled, the application and the dylib both have to make a bunch of assumptions on how to communicate with the other side long before they‚Äôre linked together. These assumptions are what we call ABI (an Application‚Äôs <em>Binary</em> Interface), and since it needs to be consistent over a long period of time, that ABI better be stable.</p>
<p>So dynamic linking is our goal, and ABI stability is just a means to that end.</p>
<p>For our purposes, an ABI can be regarded as 3 things:</p>
<ol>
<li><a href="https://gankra.github.io/blah/rust-layouts-and-abis/#layout">The layout of types</a></li>
<li><a href="https://gankra.github.io/blah/rust-layouts-and-abis/#calling-conventions">The calling convention of functions</a></li>
<li><a href="https://en.wikipedia.org/wiki/Name_mangling">The names of symbols</a></li>
</ol>
<p>If you can define these details and never break them, you have a stable ABI, and dynamic linking can be performed. (Ignoring trivial cases where both the dylib and application were built together and ABI stability is irrelevant.)</p>
<p>Now to be clear, ABI stability isn‚Äôt technically a property of a programming language. It‚Äôs really a property of a system and its toolchain. To understand this, let‚Äôs look at history‚Äôs greatest champion of ABI stability and dynamic linking: C.</p>
<p>All the major OSes make use of C for their dynamically linked system APIs. From this we can conclude that C ‚Äúhas‚Äù a stable ABI. But here‚Äôs the catch: if you compile some C code for dynamic linking on Ubuntu, that compiled artifact won‚Äôt work on MacOS or Windows. Heck, even if you compile it for 64-bit Windows it won‚Äôt work on 32-bit Windows!</p>
<p>Why? Because ABI is something defined by the <em>platform</em>. It‚Äôs not even something that necessarily needs to be documented. The platform vendor can just require you to use a particular compiler toolchain that happens to implement their stable ABI.</p>
<p>(As it turns out, this is actually the reality of Swift‚Äôs Stabilized ABIs on Apple platforms. They‚Äôre not actually properly documented, xcode just implements it and the devs will do their best not to break it. They‚Äôre not opposed to documenting it, it‚Äôs just a lot of work and shipping was understandably higher-priority. Thankfully I don‚Äôt really care about the details, or the difference between the ABIs on MacOS and iOS, or implementations other than Apple‚Äôs, so I can keep saying ‚ÄúSwift‚Äôs ABI‚Äù and it won‚Äôt be a problem.)</p>
<p>But if that‚Äôs the case, why don‚Äôt platform vendors provide stable ABIs for lots of other languages? Well it turns out that the language isn‚Äôt completely irrelevant here. Although ABI isn‚Äôt ‚Äúpart‚Äù of C itself, it <em>is</em> relatively friendly to the concept. Many other languages aren‚Äôt.</p>
<p>To understand why C is friendly to ABI stability, let‚Äôs look at its much less friendly big brother, C++.</p>
<p>Templated C++ functions cannot have their implementations dynamically linked. If I provide you with a system header that provides the following declaration, you simply can‚Äôt use it:</p>
<div><pre><code>template &lt;typename T&gt;
bool process(T value);</code></pre></div>
<p>This is because <em>it has no symbol</em>. C++ templates are monomorphically compiled, which is a fancy way of saying that the way to use them is to copy-paste the implementation with all the templates replaced with a particular value.</p>
<p>So if I want to call <code>process&lt;int&gt;(0)</code>, I need to have the implementation available to copy-paste it with <code>int</code> replacing <code>T</code>. Needing to have the implementation available at compile-time completely undermines the concept of dynamic linking.</p>
<p>Now perhaps the platform could make a promise that it has precompiled several monomorphic instances, so say symbols for <code>process&lt;int&gt;</code> and <code>process&lt;bool&gt;</code> are available. You could make that work, but then the function wouldn‚Äôt really be meaningfully templated anymore, as only those two explicitly blessed substitutions would be valid.</p>
<p>There would be little difference from simply providing a header containing:</p>
<div><pre><code>bool process(int value);
bool process(bool value);</code></pre></div>
<p>Now a header <em>could</em> just include the template‚Äôs implementation, but what that would really be guaranteeing is that that particular implementation will <em>always</em> be valid. Future versions of the header could introduce new implementations, but a robust system would have to assume applications could using either, or perhaps even both at the same time.</p>
<p>This is no different from a C macro or <code>inline</code> function, but I think it‚Äôs fair to say that templates are a little more important in C++.</p>
<p>For comparison, most platforms provide a dynamically linked version of the C standard library, and everyone uses it. On the other hand, C++‚Äôs standard library isn‚Äôt very useful to dynamically link to; it‚Äôs literally called the Standard <em>Template</em> Library!</p>
<p>In spite of this issue (and many others), C++ <em>can</em> be dynamically linked and used in an ABI-stable way! It‚Äôs just that it ends up looking a lot more like a C interface due to the limitations.</p>
<p>Idiomatic Rust is similarly hostile to dynamic linking (it also uses monomorphization), and so an ABI-stable Rust would also end up only really supporting C-like interfaces. Rust has largely just embraced that fact, focusing its attention on other concerns.</p>
<h2 id="swifts-stable-abi"><a href="#swifts-stable-abi">1.3 Swift‚Äôs Stable ABI</a></h2>
<p>I have now made some seemingly contradictory claims:</p>
<ul>
<li>Swift has similar features to Rust</li>
<li>Rust‚Äôs features make it hostile to dynamic linking</li>
<li>Swift is great at dynamic linking</li>
</ul>
<p>The secret lies in where the two languages diverge: dynamism. Rust is a <em>very</em> static and explicit language, reflecting the sensibilities of its developers and early adopters. Swift‚Äôs developers preferred a much more dynamic and implicit design, and so that‚Äôs what they made.</p>
<p>As it turns out, hiding implementation details and doing more work at runtime is <em>really</em> friendly to dynamic linking. Who‚Äôd‚Äôve thought dynamic linking was dynamic?</p>
<p>But what‚Äôs really interesting about Swift is the ways it‚Äôs <em>not</em> dynamic.</p>
<p>It‚Äôs actually fairly trivial to dynamically link a system where all the implementation details are hidden behind uniformity and dynamism. In the extreme case, we could make a system where everything is an opaque pointer and there‚Äôs only one function that just sends things strings containing commands. Such a system would have a very simple ABI!</p>
<p>And indeed, in the 90‚Äôs there was a big push in this direction with Microsoft embracing <a href="https://en.wikipedia.org/wiki/Component_Object_Model">COM</a> and Apple embracing <a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend">Objective-C</a> as ways to build system interfaces with simple and robust ABIs.</p>
<p>But Swift didn‚Äôt do this. Swift tries its hardest to generate code comparable to what you would expect from Rust or C++, and how it accomplishes that is what makes its ABI so interesting.</p>
<p>It‚Äôs worth noting that the Swift devs disagree with the Rust and C++ codegen orthodoxy in one major way: they care much more about code sizes (as in the amount of executable code produced). More specifically, they care a lot more about making efficient usage of the cpu‚Äôs instruction cache, because they believe it‚Äôs better for system-wide power usage. Apple championing this concern makes a lot of sense, given their suite of battery-powered devices.</p>
<p>It‚Äôs harder for third party developers to care about this, as they will naturally only control some small part of the software running on a device, and typical benchmarking strategies don‚Äôt really capture ‚Äúthis change made your application run faster but is making some background services less responsive and hurting battery life‚Äù. Hence C++ and Rust inevitably pushing towards ‚Äúmore code, more fast‚Äù.</p>
<p>This is all to say that some things which seem like compromises made for ABI stability‚Äôs sake are genuinely just regarded as desirable.</p>
<p>I never got any great concrete numbers on this concern from the Swift or Foundation folks, would definitely love to see some! <em>Waves at the Apple employees reading this</em>.</p>
<h2 id="resilience-and-library-evolution"><a href="#resilience-and-library-evolution">1.4 Resilience and Library Evolution</a></h2>
<p><a href="https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst">The Swift developers cover this topic fairly well in their documentation</a>. I‚Äôll just be giving a simplified version, focusing on the basic motivation.</p>
<p>Resilience is the core concept behind Swift‚Äôs dynamic linking story. It means that things default to having ABIs that are <em>resilient</em> to breaking when the implementation changes in an API-preserving way (nothing can save API-breaking changes). This allows developers to create dynamically linked and idiomatic-feeling libraries that can still easily evolve their implementations.</p>
<p>This is in contrast to C, which only makes it <em>possible</em> to create a stable ABI with proper vigilance and foresight. This is because C requires you to commit to many of the ABI details of your interface upfront, even if you‚Äôre uncertain about them. If you don‚Äôt want to commit to those details, you‚Äôll have to change the shape of your API to hide them.</p>
<p>When compiled as a dylib, Swift defaults to implicitly hiding as many details as possible, requiring you to opt into guarantees by adding annotations. Crucially, these annotations don‚Äôt affect the shape of an API, they‚Äôre ‚Äúonly‚Äù for optimizing the ABI, at the cost of resilience.</p>
<p>Additionally, <em>some</em> ABI annotations can be added after a library has been published without breaking the old ABI. Applications compiled against new annotations are able to use that information to run faster, at the cost of compatibility with older versions of the library.</p>
<p>(It seems the Swift devs ran out of time/resources and quite reasonably cut a few corners in this department. Several annotations which plausibly could be done in a backwards-compatible way are ultimately breaking to add. Ah well, pobody‚Äôs nerfect.)</p>
<p>This is all very abstract, let‚Äôs look at a simple library evolution example.</p>
<p>Let‚Äôs say we draft up a simple FileMetadata interface in C:</p>

<div><pre><code>
<span>typedef</span> <span>struct</span> {
    <span>int64_t</span> <span>size</span>;
} <span>FileMetadata</span>;

<span>bool</span> <span>get_file_metadata</span>(<span>char</span><span>*</span> <span>path</span>, <span>FileMetadata</span><span>*</span> <span>output</span>);</code></pre></div>
<p>Which would be called as:</p>

<div><pre><code><span>FileMetadata</span> <span>metadata</span>;
<span>if</span> (<span>!</span><span>get_file_metadata</span>(<span>&#34;/my/sweet/file.txt&#34;</span>, <span>&amp;</span><span>metadata</span>) {
    <span>printf</span>(<span>&#34;error!&#34;</span>);
    <span>return</span>;
}
<span>printf</span>(<span>&#34;file size %lld&#34;</span>, <span>metadata</span>.<span>size</span>);</code></pre></div>
<p>Now let‚Äôs say we realize that this function should also provide info on when it was last modified:</p>

<div><pre><code>
<span>typedef</span> <span>struct</span> {
    <span>int64_t</span> <span>last_modified_time</span>; 
    <span>int64_t</span> <span>size</span>;
} <span>FileMetadata</span>;

<span>bool</span> <span>get_file_metadata</span>(<span>char</span><span>*</span> <span>path</span>, <span>FileMetadata</span><span>*</span> <span>output</span>);</code></pre></div>
<p>Oops, we‚Äôve messed up our ABI! Our hypothetical caller is stack allocating a FileMetadata, so they‚Äôre assuming it has a particular size and alignment. Additionally, they‚Äôre directly accessing the <code>size</code> field, which they assume is at a particular offset in the struct.</p>
<p>Both of those assumptions were violated by our change. This didn‚Äôt necessarily have to happen. There‚Äôs a few common approaches we could have taken to allow for this change. For instance we could have:</p>
<ul>
<li>Reserved space in our struct for future use</li>
<li>Made FileMetadata an opaque type, requiring function calls to get the fields</li>
<li>Given FileMetadata a pointer to its ‚Äúversion 2‚Äù data (opaque in ‚Äúversion 1‚Äù)</li>
</ul>
<p>Unfortunately, all of these require us to have the foresight to do them while also changing the way users make use of our API. In some sense, the API becomes less ‚Äúidiomatic‚Äù to accommodate future changes. Additionally, we will forever be burdened with this complexity even if we eventually determine that the API is complete enough to guarantee its details.</p>
<p>Swift doesn‚Äôt require you to make this compromise.</p>
<p>The following two designs are totally ABI compatible while remaining perfectly idiomatic to use:</p>

<div><pre><code>
<span>public</span> <span>struct</span> <span>FileMetadata</span> {
    <span>public</span> <span>var</span> <span>size</span>: <span>Int64</span>
}

<span>public</span> <span>func</span> <span>getFileMetadata</span>(<span>_</span> <span>path</span>: <span>String</span>) -&gt; <span>FileMetadata</span><span>?</span></code></pre></div>

<div><pre><code>
<span>public</span> <span>struct</span> <span>FileMetadata</span> {
    <span>public</span> <span>var</span> <span>lastModifiedTime</span>: <span>Int64</span> 
    <span>public</span> <span>var</span> <span>size</span>: <span>Int64</span>
}

<span>public</span> <span>func</span> <span>getFileMetadata</span>(<span>_</span> <span>path</span>: <span>String</span>) -&gt; <span>FileMetadata</span><span>?</span></code></pre></div>
<p>Unfortunately, guaranteeing the layout of FileMetadata using the <code>@frozen</code> attribute in future versions <em>would</em> be an ABI breaking change under the current design. Hopefully it will be clear why by the end of this document.</p>

<p>Ok! Now for the details, where I will in fact be ignoring the <em>actual</em> details and instead discussing the high level ideas behind them.</p>
<p>Once again, feel free to check out <a href="https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst">Swift‚Äôs documentation of the annotations that are used to manage abi resilience</a>. That covers a lot of motivation and the fine-grain details of what you can and can‚Äôt do.</p>
<h2 id="resilient-type-layout"><a href="#resilient-type-layout">2.1 Resilient Type Layout</a></h2>
<p>By default, a type that is defined by a dylib has a <em>resilient</em> layout. This means that the size, alignment, <a href="https://developer.apple.com/documentation/swift/memorylayout">stride</a>, and <a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md#enums">extra inhabitants</a> of that type aren‚Äôt statically known to the application. To get that information, it must ask the dylib for that type‚Äôs <em>value witness table</em> at runtime.</p>
<p>‚ÄúWitness tables‚Äù are Swift‚Äôs term for what are ultimately vtables. The details of how these tables are acquired and laid out don‚Äôt really interest me, so I won‚Äôt discuss that.</p>
<blockquote>
<p>Ok actually it is Interesting that Swift needs to be able to generate witness tables at runtime to deal with the fact that generic type substitutions can‚Äôt be statically predicted in the face of dynamic linking of generic code, but that‚Äôs getting way ahead of ourselves.</p>
</blockquote>
<p>The <em>value</em> witness table is just the ‚Äúvtable of basic stuff you might want to know about any type‚Äù, much like how Java‚Äôs <code>Object</code> type is used. So it has all the stuff like size, alignment, stride, extra inhabitants, move/copy constructors (for ARC), and destructors.</p>
<p>At this point those with experience in language design probably suspect this results in resilient types having to be boxed and passed around as a pointer. And those suspicions are indeed correct‚Ä¶ but not quite.</p>
<p>See what‚Äôs really interesting about resilient layout is that it‚Äôs only something that the application is forced to deal with, and only in a very limited way. Inside the boundaries of the dylib where all of its own implementation details are statically known, the type is handled as if it wasn‚Äôt resilient.</p>
<p>Inside the dylib a resilient struct is stored inline, stored on the stack, passed around by value, and even scalarized. But once we move outside the dylib something else must be done.</p>
<p>We could potentially accomplish this with expensive type layout conversion at the boundaries, but we don‚Äôt! Type layouts are always the same on both sides of the resilience boundary!</p>
<p>Type layouts are always the same on both sides of the resilience boundary!?!?</p>
<p>Yes!</p>
<p>The key insight here is that laying out things inline can actually be done dynamically with relative ease. Memory allocators and pointers don‚Äôt care about static layouts, they just work with completely untyped sizes, alignments, and offsets. So as long as you have all the relevant value witness tables, everything works basically fine, just with more dynamic values than usual.</p>
<p>The real major problem is stack allocations. llvm really doesn‚Äôt like dynamic stack allocations. Yes, <a href="https://llvm.org/docs/LangRef.html#alloca-instruction">alloca</a> does exist, but it‚Äôs a bit messy. I believe the Swift devs managed to get it working all the time for resilient layout, but not for some of its cousins we‚Äôll see in the next section. In the general case, local variables need to actually be boxed up onto the heap. For convenience, I‚Äôll just generically refer to these dynamic stack allocations as ‚Äúboxed‚Äù.</p>
<p><strong>Crucially</strong> this boxing this doesn‚Äôt change layouts, just where local variables are stored and how they‚Äôre passed in the calling convention (more on that later). Also, once there is <em>some</em> indirection everything is still stored inline. So types which already come with indirection like <code>Array&lt;MyResilientStruct&gt;</code> or <code>MyResilientClass</code> require <em>no</em> additional allocation, and consequently no ABI changes.</p>
<p>I‚Äôve left out some key details, but let‚Äôs address them while looking at polymorphic generics, since it turns out those are quite similar, but also more interesting!</p>
<h2 id="polymorphic-generics"><a href="#polymorphic-generics">2.2 Polymorphic Generics</a></h2>
<p>Unlike Rust and C++ which must monomorphize (copy+paste) implementations for each generic/template substitution, Swift is able to compile a generic function into a single implementation that can handle every substitution dynamically.</p>
<p>This has several benefits:</p>
<ul>
<li>Massively reducing code size</li>
<li>Massively reducing the amount of code that must be compiled</li>
<li>Allowing generic code to be dynamically linked</li>
</ul>
<p>A polymorphic implementation can‚Äôt be inlined or optimized as well as a monomorphic one (without a JIT), so the Swift compiler still monomorphizes things when it‚Äôs possible and seems profitable. But we‚Äôre making a dylib, so it‚Äôs not possible for our public API.</p>
<p>As it turns out, polymorphically compiled generic code is really quite similar to code that handles resilient types. In both cases the basic value-witnessy properties of the type aren‚Äôt statically known, and so stack values need boxing. The generic code just needs to be able to find the generic type‚Äôs protocol implementations too. We can get that from the type‚Äôs <em>protocol witness tables</em> which can be acquired using the same machinery we use for the value witness tables.</p>
<p>So really this is basically the same problem!</p>
<hr/>
<p>üíÉ Brief Aside About Existentials üíÉ</p>
<p>The resilient/polymorphic type machinery solves a big chunk of <a href="http://huonw.github.io/blog/2015/01/object-safety/">the Object Safety problem</a> that heavily limits Rust‚Äôs trait objects. Swift calls these <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#ID275">Protocols as Types</a> or just <em>existentials</em>, depending on who you ask. Generic code actually having symbols means there‚Äôs no problem with it being stuffed in a vtable. Resilient layout eliminates the problems that come with dynamic ‚Äúby value‚Äù manipulation of Self and any of its associated types.</p>
<p>Existentials are the really tricky case for stack allocations, because they can prevent the caller from knowing the size of the return value before making the call, and that really messes up alloca. So once existentials get involved, alloca goes out the window and actual boxing needs to happen.</p>
<p>Also associated types in function signatures still prevent existentials from being created because that creates fundamental type system problems unrelated to ABI. Every instance of MyProtocol could have a different associated type, and you can‚Äôt let them get mixed up. No I‚Äôm not going to get into how Swift could use path-dependent types to deal with this.</p>
<p>Associated types are fine for normal polymorphic code, since generics enforce that every instance has the <em>same</em> type, which is the only issue with them in existentials.</p>
<hr/>
<p>Now, what does the presence of resilient/polymorphic types do to calling conventions?</p>
<p>Well first off, we have the witness tables. In the resilient case all the types are statically known, and so the implementation theoretically has all the information it needs to look up witness tables for itself. Polymorphic code has no such luxury.</p>
<p>Polymorphic code needs to work with any type, and structs don‚Äôt contain any identifying runtime information. Worse yet, polymorphic code can be called without providing any values of that type! So the <em>caller</em> needs to pass in type information. Abstractly, we <em>could</em> pass in minimal information and have the polymorphic code look up all the witness tables, but that‚Äôs really wasteful (consider calling the function in a loop). So instead Swift‚Äôs actual implementation has the caller pass in pointers to every required witness table as extra arguments (automatically handled by the compiler).</p>
<p>With the witness tables handled, we just have the problem of passing/returning actual values. The main thing is that storing these kinds of values in registers is totally off limits; we really need to pass them around as pointers. That‚Äôs sometimes a bit slower, but not a terribly huge deal given we‚Äôre already signed up for dynamic linking and polymorphic compilation.</p>
<p>But to really understand passing these values, we need to talk about <em>reabstraction</em>.</p>
<h2 id="reabstraction"><a href="#reabstraction">2.3 Reabstraction</a></h2>
<p>Resilient compilation forces us to use a particular calling convention that‚Äôs different from what we would use statically. For instance, in the <a href="https://www.uclibc.org/docs/psABI-x86_64.pdf#section.3.2">x64 SysV ABI</a>, the following would have all of its fields passed in registers:</p>

<div><pre><code><span>struct</span> <span>Vec4</span> { <span>int32_t</span> <span>x</span>; <span>int32_t</span> <span>y</span>; <span>int32_t</span> <span>z</span>; <span>int32_t</span> <span>w</span>; }

<span>void</span> <span>process</span>(<span>Vec4</span> <span>vector</span>);</code></pre></div>
<p>If Vec4 were resilient, it would instead have to be passed by-reference. But remember, not all code that works with a type <em>needs</em> to handle it resiliently. For instance, if a dynamic library defines Vec4 resiliently, it should ideally still be able to handle it non-resiliently inside of itself.</p>
<p>Similarly, the polymorphicness (polymorphicity?) of things can be changed by their context. Consider the following Swift code that manipulates a closure:</p>

<div><pre><code>
<span>func</span> <span>map</span><span>&lt;</span><span>T</span>, <span>U</span><span>&gt;</span>(<span>_</span> <span>input</span>: <span>T</span>, <span>with</span> <span>mapper</span>: (<span>T</span>) -&gt; <span>U</span>) -&gt; <span>U</span> {
    <span>return</span> <span>mapper</span>(<span>input</span>)
}


<span>func</span> <span>mapInt</span><span>&lt;</span><span>U</span><span>&gt;</span>(<span>_</span> <span>input</span>: <span>Int</span>, <span>with</span> <span>mapper</span>: (<span>Int</span>) -&gt; <span>U</span>) -&gt; <span>U</span> {
    <span>return</span> <span>map</span>(<span>input</span>, <span>with</span>: <span>mapper</span>) 
}


<span>let</span> <span>result</span> <span>=</span> <span>mapInt</span>(<span>3</span>, <span>with</span>: { <span>return</span> $<span>0</span> <span>&gt;</span><span>=</span> <span>5</span> })</code></pre></div>
<p>Assuming <code>map</code> and <code>mapInt</code> are compiled polymorphically, the closure has 3 potentially different ABIs:</p>
<ul>
<li>(Int) -&gt; Bool</li>
<li>(Int) -&gt; U</li>
<li>(T) -&gt; U</li>
</ul>
<p>The <code>(Int) -&gt; Bool</code> ABI can potentially be ignored and discarded because we know we‚Äôre passing it to something that expects <code>(Int) -&gt; U</code>, but the <code>(T) -&gt; U</code> ABI is completely hidden from us!</p>
<p>This naively results in an unfortunate conclusion: closures (and function pointers) must have the maximally generic ABI just in case that‚Äôs needed. Thankfully, this conclusion is incorrect.</p>
<p>Instead Swift uses <em>reabstraction thunks</em>. These thunks simply wrap a function with the wrong ABI in a function with the right one. So what the compiler ‚Äúactually‚Äù generates is more like this:</p>
<p>(note: not real Swift code because you can‚Äôt explicitly talk about generics/conventions in this way)</p>

<div><pre><code>
<span>func</span> <span>map</span><span>&lt;</span><span>T</span>, <span>U</span><span>&gt;</span>(<span>_</span> <span>input</span>: <span>T</span>, <span>with</span> <span>mapper</span>: (<span>T</span>) -&gt; <span>U</span>) -&gt; <span>U</span> {
    <span>return</span> <span>mapper</span>(<span>input</span>)
}


<span>func</span> <span>mapInt</span><span>&lt;</span><span>U</span><span>&gt;</span>(<span>_</span> <span>input</span>: <span>Int</span>, <span>with</span> <span>mapper</span>: (<span>Int</span>) -&gt; <span>U</span>) -&gt; <span>U</span> {
    
    <span>let</span> <span>thunk</span>: <span>&lt;</span><span>T</span>,<span>U</span><span>&gt;</span>(<span>T</span>) -&gt; <span>U</span> <span>=</span> { <span>return</span> <span>mapper</span>($<span>0</span>) }

    <span>return</span> <span>map</span>(<span>input</span>, <span>with</span>: <span>thunk</span>) 
}


<span>let</span> <span>temp_closure</span>: (<span>Int</span>) -&gt; <span>Bool</span> <span>=</span> { <span>return</span> $<span>0</span> <span>&gt;</span><span>=</span> <span>5</span> }

<span>let</span> <span>thunk</span>: <span>&lt;</span><span>U</span><span>&gt;</span>(<span>Int</span>) -&gt; <span>U</span> <span>=</span> { <span>return</span> <span>temp_closure</span>($<span>0</span>) }

<span>let</span> <span>result</span> <span>=</span> <span>mapInt</span>(<span>3</span>, <span>with</span>: <span>thunk</span>);</code></pre></div>
<p>In this way everything can use the best possible calling convention while still allowing for more generic ones to be used in different contexts.</p>
<p>Even without this closure passing problem, reabstraction also allows a single implementation to be used in several different contexts without having to compile different versions of it. So for instance we can reabstract a concrete protocol implementation into a polymorphic one by just wrapping all the functions in reabstraction thunks. A nice code size win!</p>
<p>(I believe the Swift devs don‚Äôt technically call that one Reabstraction but it‚Äôs close enough that I‚Äôm happy to conflate the concepts. Thunk away ABI complexities!)</p>
<p>Now that we have a basic idea of how resilience and polymorphism affects calling conventions, it should hopefully be clear why it‚Äôs an ABI-breaking change to mark a type as <code>@frozen</code>, removing its resilient layout: it would change the way the type is passed to functions.</p>
<p>This could have potentially been ‚Äúfixed‚Äù by making resilience part of the name mangle and providing both the resilient and non-resilient versions, but that requires robust versioning info for every attribute and could lead to a huge combinatoric explosion in the number of symbols a dylib provides. Not necessarily a great idea.</p>
<h2 id="materialization"><a href="#materialization">2.4 Materialization</a></h2>
<p>Resilient layout could be generalized to provide the offsets to a resilient type‚Äôs public fields, but Swift actually takes this to another level: public fields don‚Äôt actually need to exist by default.</p>
<p>Resiliently exposed fields are only exposed as getters and setters!</p>
<p>Getters and setters are actually a first class feature of Swift that can be used explicitly, but for resilience the compiler will implicitly introduce those getters and setters just to hide the fact that the fields physically exist, in case you change your mind.</p>
<p>A computed field in Swift is manipulated in exactly the same way as a real one, and so even without resilience library authors are free to replace physical fields with computed ones without changing their A<strong>P</strong>I. Mandating computed access just makes it A<strong>B</strong>I stable as well.</p>
<p>But here‚Äôs the catch: you can take a mutable reference (inout) to a field. Even a computed one!</p>
<p><strong>Swift let‚Äôs you take references to things that don‚Äôt exist.</strong></p>
<p>The secret to this is <em>materialization</em>.</p>
<p>Inouts can only appear as arguments to a function, and so they‚Äôre naturally scoped to a function call. As such, we can ‚Äútake a reference‚Äù to a computed field by using a temporary with cleanup. So this code:</p>

<div><pre><code><span>struct</span> <span>MyStruct</span> {
    <span>public</span> <span>var</span> <span>myField</span>: <span>FieldTy</span>
}

<span>func</span> <span>doTheThing</span>(<span>x</span>: <span>inout</span> <span>FieldTy</span>)

<span>var</span> <span>myVal</span> <span>=</span> <span>MyStruct</span>(..)
<span>doTheThing</span>(<span>&amp;</span><span>myVal</span>.<span>myField</span>)</code></pre></div>
<p>is (very roughly) compiled to:</p>

<div><pre><code><span>var</span> <span>myVal</span> <span>=</span> <span>MyStruct</span>(..)

<span>var</span> <span>temp</span>: <span>FieldTy</span> <span>=</span> <span>myVal</span>.<span>get_myField</span>();
<span>doTheThing</span>(<span>&amp;</span><span>temp</span>)
<span>myVal</span>.<span>set_myField</span>(<span>temp</span>)</code></pre></div>
<p>Or to break that into steps:</p>
<ol>
<li>Allocate a temporary local variable (temp)</li>
<li>Initialize temp with the getter</li>
<li>Call the inout-using function with the address of temp</li>
<li>Feed the value of temp into the setter</li>
</ol>
<p>This creates a very interesting difference from references in Rust and C++: if you take a reference to a field, it may point to a temporary that‚Äôs only valid for the scope of the call it was passed to!</p>
<p>Another interesting consequence of this is that Swift‚Äôs mutable references all actually have a finalizer which must be executed for a write to ‚Äústick‚Äù. This means they cannot be returned or stored, as the finalizer would be lost and the referent would be deallocated.</p>
<p>This in turn creates a hilarious footgun many Swift developers run into where they think they‚Äôre clever and convert an inout into a raw pointer (using <a href="https://developer.apple.com/documentation/swift/2429788-withunsafemutablepointer">withUnsafeMutablePointer</a>) that they store for later and ‚Äì oops it‚Äôs dangling!</p>
<p>However you can overcome this limitation with callbacks, as follows:</p>

<div><pre><code><span>func</span> <span>doSomeWork</span>(<span>_</span> <span>callback</span>: (<span>inout</span> <span>Float</span>) -&gt; ()) {
    <span>var</span> <span>vec</span> <span>=</span> <span>Vec4</span>()
    

    
    <span>callback</span>(<span>&amp;</span><span>vec</span>.<span>x</span>)
    

    
}


<span>doSomeWork</span> { (<span>val</span>: <span>inout</span> <span>Float</span>) -&gt; ()
    <span>val</span> <span>*</span><span>=</span> <span>2</span>;
}</code></pre></div>
<p>Callbacks are of course very annoying and noisy, <a href="https://github.com/apple/swift/blob/master/docs/OwnershipManifesto.md#mutating-iteration">and so this was solved with the slayer of callbacks, coroutines</a>! The same code can be rewritten as:</p>

<div><pre><code>

<span>func</span> <span>doSomeWork</span>() -&gt; <span>inout</span> <span>Int</span> {
    <span>var</span> <span>vec</span> <span>=</span> <span>Vec4</span>()
    

    
    <span>yield</span> <span>&amp;</span><span>vec</span>.<span>x</span>
    

    
}

<span>doSomeWork</span>() <span>*</span><span>=</span> <span>2</span></code></pre></div>
<p>Nifty!</p>
<h2 id="ownership"><a href="#ownership">2.5 Ownership</a></h2>
<p>Swift makes extensive use of reference counting, and as it turns out it‚Äôs really expensive to constantly modify the count! Especially when you make all your collections copy-on-write (CoW), so an errant reference count bump can make an O(n) algorithm O(n<sup>2</sup>)! (I actually consider this a correctness error in the case of data structures and algorithms, but reasonable people may disagree.)</p>
<p>To help deal with this, Swift made ownership of reference-counted values (~classes) part of its calling convention. The most important aspect is ‚Äú+0‚Äù vs ‚Äú+1‚Äù, referring to how the caller should change the refcount:</p>
<ul>
<li>+1: callee has an ‚Äúowned‚Äù value it‚Äôs responsible for releasing (if it doesn‚Äôt escape)</li>
<li>+0: callee has a ‚Äúborrowed‚Äù value it‚Äôs responsible for retaining (if it escapes)</li>
</ul>
<p>Since we‚Äôre talking about ownership, I‚Äôm legally required to compare this system to Rust, and the comparison is pretty straight-forward:</p>
<ul>
<li>+1 is a move (<code>T</code>)</li>
<li>+0 is a shared immutable reference (<code>&amp;T</code>)</li>
<li>inout is a mutable exclusive reference  (<code>&amp;mut T</code>)</li>
</ul>
<p>But there‚Äôs a few key differences, due to ARC:</p>
<p>First and foremost, classes break ‚Äúshared xor mutable‚Äù reasoning, and are effectively like using <code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code> in Rust. This is why Swift‚Äôs collections provide CoW semantics, <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html#method.make_mut">which Rust‚Äôs Arc also safely provides</a>. Yes, you can indeed trivially introduce Data Races into Swift code with classes.</p>
<p>Second, all Swift types can always be implicitly cloned, so a +0 can always be upgraded to an owned value without ceremony. That said, cloning in Swift (they just call it copying) is always just bumping reference counts. Other non-trivial operations, like copying an array‚Äôs buffer to a new allocation, are only performed by mutations that trigger CoW. Note also that this means that if you trigger CoW on an array of arrays, you will get two independent outer arrays that still point to the same inner arrays (which are now primed to CoW if either side mutates them).</p>
<p>Third, +0 isn‚Äôt strictly bound to pass-by-reference, and can just be a trivial bitwise copy of the value. Unfortunately, <a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID52">weak references</a> require non-trivial moves because their locations are tracked for auto-nulling, so those <em>are</em> passed by reference when using +0 to keep it cheap. Yes, Swift has both copy and move constructors, although they‚Äôre currently entirely ARC and not user-defined. Swift <em>also</em> has unowned references which are the same as Rust‚Äôs Weak references, which have trivial moves.</p>
<p>In Swift‚Äôs current design, +0/+1 is mostly just something the compiler does internally to optimize different calling conventions, but I think more explicit annotations are theoretically on the road map.</p>
<p>There‚Äôs also a special path for field materialization, ‚Äúmodify‚Äù, which returns an inout. This handles the fact that getters are naively +1, which is especially nasty for nested array operations like <code>array[0][2] *= 2</code>, as they would always trigger a huge temporary copy of the inner array!</p>
<p>And indeed, the subscript operator of Array contains a modify implementation:</p>

<div><pre><code> <span>_modify</span> {
  <span>_makeMutableAndUnique</span>()
  <span>_checkSubscript_native</span>(<span>index</span>)
  <span>let</span> <span>address</span> <span>=</span> <span>_buffer</span>.<span>subscriptBaseAddress</span> <span>+</span> <span>index</span>
  <span>yield</span> <span>&amp;</span><span>address</span>.<span>pointee</span>
}</code></pre></div>
<p>(Interestingly, this implementation is marked as <code>inlineable</code>, and so it‚Äôs actually guaranteed to always work. Array‚Äôs ABI details were pretty aggressively guaranteed since it‚Äôs a <em>relatively</em> simple fundamental type whose performance matters a lot.)</p>
<p>There‚Äôs also a read-only version of modify, ‚Äúread‚Äù, which provides a +0 getter. That one isn‚Äôt as strongly motivated, but hey it‚Äôs a nice little optimization to avoid a needless retain+release.</p>
<h2 id="opting-out-of-resilience"><a href="#opting-out-of-resilience">2.6 Opting Out of Resilience</a></h2>
<p>Resilience is nifty but it clearly comes with some performance overhead. So of course Swift also provides special attributes to opt out of resilience. I had originally intended to write a whole bunch about this but it‚Äôs actually really complex and subtle, so I really need to <a href="https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst">punt to Swift‚Äôs actual docs</a>.</p>
<p>TL;DR you can mark things as having a frozen (non-resilient) layout, exhaustively matchable, inlineable, non-subclassable, non-escaping, and a bunch of other whacky stuff which variously affects API and ABI in subtle ways.</p>
<h2 id="esoterica"><a href="#esoterica">2.7 Esoterica</a></h2>
<p>This is already <s>17</s> <s>18</s> <s>19</s> <s>20</s> 21 pages and it was supposed to just be a warmup for something else I need to do and I NEED TO STOP SO BULLET POINTS:</p>
<ul>
<li>
<p>Swift reserves a callee-preserved register for a method‚Äôs <code>self</code> argument (pointer) to make repeated calls faster. Cool?</p>
</li>
<li>
<p>Swift‚Äôs exceptions (which are implemented more like Result and less like unwinding) have the error type always boxed. The caller initializes the ‚Äúswift error‚Äù register to 0, and if there‚Äôs an exception the callee sets that register to hold the boxed error‚Äôs pointer. This makes error propagation really fast (just don‚Äôt change the register), and also doesn‚Äôt require a Result to actually be materialized in the success case (avoid a ton of copies). Sadly this doesn‚Äôt transfer over to Rust well, so they can‚Äôt easily use the native Swift machinery that was added to llvm (swiftcc).</p>
</li>
<li>
<p>Swift‚Äôs implicit boxes don‚Äôt actually have to be pointers, I think? They can pack small values in there and just set a high bit to distinguish an <code>Int32</code> 0 from null or something? They spent a lot of time messing around with making really-not-pointer-sized things pointer-sized with whacky hacks, and also messed around with boxes being 3 pointers wide to make the ‚Äúsmall‚Äù box trick happen more, so I can never keep reality straight here.</p>
</li>
<li>
<p>Swift used to have copy-array-of-self and move-array-of-self entries in the value witness table to deal with the ‚Äúcalling a bunch of copy/move constructors which might do nothing interesting‚Äù problem that C++ has, but this was replaced by just adding a flag to the witness table for whether the type is trivial for copies/moves. Less bloaty.</p>
</li>
<li>
<p>Swift decouples size from stride to distinguish trailing padding from actual content. Trailing padding shows up in the stride so that arrays properly align their contents. Trailing padding doesn‚Äôt show up in size so that things like enum tags and neighboring fields can use that space. It‚Äôs really neat!</p>
</li>
<li>
<p>Swift actually does insert a bunch of magical layout conversions when bridging between Swift and Objective-C. Initially this bridging was lazy in the case of collections, and that was super whacky. Specifically if you had an <code>Array&lt;MySwiftType&gt;</code> it might have been an <code>NSArray</code> containing opaque pointers, with type conversion was performed when you accessed the element. They later moved to a more eager model because this was really nasty and expensive for heavily-accessed collections. Also object-identity was messy to deal with.</p>
</li>
<li>
<p>The main piece of complexity in the system for getting witness tables is that it provides a runtime reflection system for spidering through the type metadata of generic types and their associated types because you need to be able to get their witnesses too.</p>
</li>
<li>
<p>I think Swift technically stabilized the set of enum tag packing optimizations it can perform, but no clue what those are. Sorry eddyb.</p>
</li>
<li>
<p>Zero cost abstractions Really Aren‚Äôt if they ever need to be compiled polymorphically, watch out!</p>
</li>
<li>
<p>Pure Trivia: Rust actually originally tried a polymorphic design similar to Swift‚Äôs, but they eventually backed off from it once the difficulties became clear. Supporting both polymorphic <em>and</em> monomorphic compilation helped Swift a lot, but I think the key difference was ultimately just that Apple had a more significant motivation than Mozilla to pursue dynamic linking and <em>way</em> more resources to throw at this very hard problem.</p>
</li>
</ul>
<p><em>collapses</em></p>
<!--
https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md
https://github.com/apple/swift/blob/master/docs/ABI/TypeLayout.rst
https://github.com/apple/swift/blob/6bd3f117c6e5937d1ada2cc09aed00a179dfa972/docs/LibraryEvolutionManifesto.md
https://github.com/apple/swift/blob/master/docs/OwnershipManifesto.md
-->

    </article></div>
  </body>
</html>
