<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pwy.io/posts/marching-events/">Original</a>
    <h1>Marching Events: What does iCalendar have to do with ray marching?</h1>
    
    <div id="readability-page-1" class="page"><div id="post">
        

        <p>
          Recently I&#39;ve been <s>cursed</s> blessed with the opportunity of
          implementing a library for operating on iCalendar files. If you
          haven&#39;t heard of them, you probably have - it&#39;s the format used to
          transfer e-mail RSVPs, to name a thing:
        </p>

        <figure>
          <img src="https://pwy.io/posts/marching-events/assets/candles.png"/>
        </figure>

        <p>
          Despite iCal&#39;s age -
          <a href="https://www.rfc-editor.org/rfc/rfc2445">RFC 2245</a> is dated
          1998, same as the Clinton-Lewinsky scandal - I think it&#39;s a Pretty
          Good Formatâ„¢. It&#39;s reasonably easy to print and parse:
        </p>

        <div>
          <pre><span></span>BEGIN:VEVENT
UID:1234-1234-1234-1234
DTSTAMP:20250608T160000Z
DTSTART:20250628T160000Z
DTEND:20250628T190000Z
SUMMARY:Found some good candles in my neighbour&#39;s trash, gonna snort &#39;em.
CATEGORIES:BUSINESS
END:VEVENT
</pre>
        </div>

        <p>
          ... and supports a ton of things - today the limelight shines on
          <b>recurring events</b>.
        </p>

        <h2 id="its-a-date"><a href="#its-a-date"> It&#39;s a Date! </a></h2>

        <p>
          I&#39;m a simple boy - to me <i>recurring</i> means a simple thing like
          &#34;every day&#34; or &#34;every week&#34;; world ain&#39;t no simple place, though.
        </p>

        

        <p><span> every day </span>
          <span> every hour </span>
          <span> every week </span>
          <span> every second Monday </span>
          <span> every year starting from 2018-02-29 </span>
          <span> every last Wednesday of every third year </span>
          <span> every fourth Sunday every other January at 12:34:56 </span>
          <span>
            every last Tuesday every fifth month starting from 2018-03 at noon
          </span>
          <span>
            every last work day on each other month from 2018-04 onwards, unless
            it&#39;s 2018-01-01
          </span>
        </p>

        <p>How do we tame this? iCalendar proposes we define:</p>

        <ul>
          <li>
            <code>FREQ</code>, saying how an event repeats (hourly, daily,
            weekly, ...),
          </li>
          <li><code>DTSTART</code>, saying from when an event repeats,</li>
        </ul>

        <p>
          ... and that&#39;s basically it, at least when it comes to required
          properties:
        </p>

        <p>FREQ=HOURLY;DTSTART=20180101T120000</p>

        <div>
          <pre><span></span>-&gt; 2018-01-01 12:00:00
-&gt; 2018-01-01 13:00:00
-&gt; 2018-01-01 14:00:00
-&gt; [...]
</pre>
        </div>

        <p>
          We can also specify <code>INTERVAL</code>, which produces multiplies
          of the frequency:
        </p>

        <p>
          FREQ=DAILY;INTERVAL=3;DTSTART=20180101T120000
        </p>

        <div>
          <pre><span></span>-&gt; 2018-01-01 12:00:00
-&gt; 2018-01-04 12:00:00
-&gt; 2018-01-07 12:00:00
-&gt; [...]
</pre>
        </div>

        <p>
          But that&#39;s boring, that&#39;s something you could&#39;ve come up with on your
          own - here&#39;s something fun:
        </p>

        <p>
          FREQ=MONTHLY;INTERVAL=2;BYMONTHDAY=1,-1;BYDAY=MO;DTSTART=20180101
        </p>

        <div>
          <pre><span></span>starting from 2018-01, repeat every other month on its first and last day, but
only if that day is Monday:

-&gt; 2018-01-01
-&gt; 2019-07-01
-&gt; 2019-09-30
-&gt; 2020-11-30
</pre>
        </div>

        <p>... and here&#39;s something pragmatic:</p>

        <p>
          FREQ=MONTHLY;BYDAY=MO,TU,WE,TH,FR;BYSETPOS=-1;DTSTART=20180131
        </p>

        <div>
          <pre><span></span>starting from 2018-01, repeat every month on its last workday:

-&gt; 2018-01-31 (Wednesday)
-&gt; 2018-02-28 (Wednesday)
-&gt; 2018-03-30 (Friday)
-&gt; [...]
</pre>
        </div>

        <p>You might see where this is going:</p>

        <p>
          given an iCal formula, how do we figure out when it repeats?
        </p>

        <h2 id="computer-love">
          <a href="#computer-love"> Computer Liebe </a>
        </h2>

        <p>Sounds easy, right? Or maybe not easy-easy, but - like - doable.</p>

        <p>
          Even if you&#39;re aware of potential roadblocks (how&#39;s repeating defined
          across time zone transitions?), you might have this thought that
          <i>intuitively</i>
          this shouldn&#39;t be a terribly difficult thing to implement.
        </p>

        <p>And you&#39;d be right, somewhat.</p>

        <p>
          Most implementations tend to have some sort of hand-unrolled,
          frequency-specific logic:
        </p>

        <div>
          <pre><span></span><span>fn</span><span> </span><span>iter</span><span>(</span><span>recur</span><span>:</span><span> </span><span>&amp;</span><span>Recur</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>Iterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>DateTime</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>match</span><span> </span><span>recur</span><span>.</span><span>freq</span><span> </span><span>{</span>
<span>        </span><span>&#34;yearly&#34;</span><span> </span><span>=&gt;</span><span> </span><span>iter_yearly</span><span>(</span><span>recur</span><span>),</span>
<span>        </span><span>&#34;monthly&#34;</span><span> </span><span>=&gt;</span><span> </span><span>iter_monthly</span><span>(</span><span>recur</span><span>),</span>
<span>        </span><span>&#34;daily&#34;</span><span> </span><span>=&gt;</span><span> </span><span>iter_daily</span><span>(</span><span>recur</span><span>),</span>
<span>        </span><span>/* ... */</span>
<span>    </span><span>}</span>
<span>}</span>

<span>/* ... */</span>

<span>fn</span><span> </span><span>iter_monthly</span><span>(</span><span>recur</span><span>:</span><span> </span><span>&amp;</span><span>Recur</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>Iterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>DateTime</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>curr</span><span> </span><span>=</span><span> </span><span>recur</span><span>.</span><span>dtstart</span><span>;</span>

<span>    </span><span>loop</span><span> </span><span>{</span>
<span>        </span><span>if</span><span> </span><span>recur</span><span>.</span><span>by_month_day</span><span>.</span><span>is_empty</span><span>()</span><span> </span><span>{</span>
<span>            </span><span>// FREQ=MONTHLY;INTERVAL=3 simply repeats the DTSTART with</span>
<span>            </span><span>// consecutive freq-based increments</span>

<span>            </span><span>yield</span><span> </span><span>curr</span><span>;</span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>            </span><span>// FREQ=MONTHLY;BYMONTHDAY=10,20,30 creates *new* dates that are</span>
<span>            </span><span>// based on the currently iterated-over date</span>

<span>            </span><span>for</span><span> </span><span>day</span><span> </span><span>in</span><span> </span><span>recur</span><span>.</span><span>by_month_day</span><span> </span><span>{</span>
<span>                </span><span>yield</span><span> </span><span>curr</span><span>.</span><span>with_day</span><span>(</span><span>day</span><span>);</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>

<span>        </span><span>curr</span><span> </span><span>+=</span><span> </span><span>Span</span><span>::</span><span>Year</span><span> </span><span>*</span><span> </span><span>recur</span><span>.</span><span>interval</span><span>;</span>
<span>    </span><span>}</span><span> </span>
<span>}</span>

<span>/* ... */</span>
</pre>
        </div>

        <p>
          That&#39;s because depending on context, a parameter can function either
          as a filter:
        </p>

        <p>FREQ=DAILY;BYDAY=MO</p>

        <div>
          <pre><span></span><span>for</span><span> </span><span>day</span><span> </span><span>in</span><span> </span><span>days_since</span><span>(</span><span>dtstart</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>day</span><span>.</span><span>is</span><span>(</span><span>Monday</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>yield</span><span> </span><span>day</span><span>;</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>... or as a generator:</p>

        <p>FREQ=MONTHLY;BYDAY=MO</p>

        <div>
          <pre><span></span><span>for</span><span> </span><span>month</span><span> </span><span>in</span><span> </span><span>months_since</span><span>(</span><span>dtstart</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>for</span><span> </span><span>day</span><span> </span><span>in</span><span> </span><span>month</span><span>.</span><span>every</span><span>(</span><span>Monday</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>yield</span><span> </span><span>day</span><span>;</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          RFC collects all of those cases into a rather spooky-looking table:
        </p>

        <figure>
          <img src="https://pwy.io/posts/marching-events/assets/expand-limit.png"/>
        </figure>

        <p>
          ... whose apparent complexity is what causes libraries to implement
          iCal features just partially, like with
          <a href="https://github.com/libical/libical">libical</a> and the
          <a href="https://github.com/libical/libical/issues/795">BYSETPOS</a>
          rule - since it must be provided for each context in which it appears,
          it&#39;s naturally implemented only for the common use cases.
        </p>

        <p>
          (not a nitpick towards libical, it&#39;s just an example i&#39;m aware of.)
        </p>

        <p>
          That&#39;s the way I started my implementation as well, but something
          about it felt off to me - I had a feeling there must be a better way
          to approach this.
        </p>

        <p>I began to imagine those recurrence rules as SQL queries:</p>

        <p>FREQ=DAILY;BYDAY=MO;DTSTART=20180101</p>

        <div>
          <pre><span></span><span>select</span><span> </span><span>day</span>
<span>  </span><span>from</span><span> </span><span>dates</span><span>  </span><span>-- infinite table of all possible dates</span>
<span> </span><span>where</span><span> </span><span>day_of_week</span><span>(</span><span>day</span><span>)</span><span> </span><span>=</span><span> </span><span>&#39;Monday&#39;</span>
<span>   </span><span>and</span><span> </span><span>day</span><span> </span><span>&gt;=</span><span> </span><span>&#39;2018-01-01&#39;</span>
</pre>
        </div>

        <p>
          FREQ=DAILY;BYDAY=MO,TU;BYMONTHDAY=10;DTSTART=20180101
        </p>

        <div>
          <pre><span></span><span>select</span><span> </span><span>day</span>
<span>  </span><span>from</span><span> </span><span>dates</span>
<span> </span><span>where</span><span> </span><span>day_of_week</span><span>(</span><span>day</span><span>)</span><span> </span><span>=</span><span> </span><span>&#39;Monday&#39;</span><span> </span><span>or</span><span> </span><span>day_of_week</span><span>(</span><span>day</span><span>)</span><span> </span><span>=</span><span> </span><span>&#39;Tuesday&#39;</span>
<span>   </span><span>and</span><span> </span><span>day_of_month</span><span>(</span><span>day</span><span>)</span><span> </span><span>=</span><span> </span><span>10</span>
<span>   </span><span>and</span><span> </span><span>day</span><span> </span><span>&gt;=</span><span> </span><span>&#39;2018-01-01&#39;</span>
</pre>
        </div>

        <p>
          ... and then I realized that under this framework, the
          <code>FREQ</code> rule disappears - <code>FREQ=DAILY;BYDAY=MO</code>,
          <code>FREQ=WEEKLY;BYDAY=MO</code> and
          <code>FREQ=MONTHLY;BYDAY=MO</code> all correspond to the same query,
          even though in one case <code>BYDAY</code>
          functions as a filter, while in the others it&#39;s a generator:
        </p>

        <p>
          FREQ=DAILY/WEEKLY/MONTHLY;BYDAY=MO;DTSTART=20180101
        </p>

        <div>
          <pre><span></span><span>select</span><span> </span><span>day</span>
<span>  </span><span>from</span><span> </span><span>dates</span>
<span> </span><span>where</span><span> </span><span>day_of_week</span><span>(</span><span>day</span><span>)</span><span> </span><span>=</span><span> </span><span>&#39;Monday&#39;</span>
<span>   </span><span>and</span><span> </span><span>day</span><span> </span><span>&gt;=</span><span> </span><span>&#39;2018-01-01&#39;</span>
</pre>
        </div>

        <p>
          Having this, I started to think about how I would materialize this
          query - naively we could just iterate through all of the possible
          dates and check whether all conditions match (modulo the
          <code>&gt;= &#39;2018-01-01&#39;</code> part, since this hypothetical
          <code>dates</code> table is infinite). But maybe there&#39;s a better way?
        </p>

        <p>
          And then I realized there&#39;s a thing I can <s>steal</s> borrow from the
          rendering community.
        </p>

        <h2 id="love-triangles">
          <a href="#love-triangles"> The Math of Love Triangles </a>
        </h2>

        <p>Triangles are those pointy, pointy, sexy bois:</p>

        <figure>
          <img src="https://pwy.io/posts/marching-events/assets/triangles-1.svg"/>
        </figure>

        <p>
          ... whose life purpose is illustrating <s>Pytagorean</s>
          <s>Pythagoran</s> <s>Pytagoream</s> Pythagorean theorem - they also
          tend to be used for modelling stuff in computer graphics and
          whathaveyou:
        </p>

        <figure>
          <img src="https://pwy.io/posts/marching-events/assets/triangles-2.svg"/>

          <figcaption>
            <a href="https://commons.wikimedia.org/wiki/File:CG_WIKI.jpg">https://commons.wikimedia.org/wiki/File:CG_WIKI.jpg</a>
          </figcaption>
        </figure>

        <p>
          Triangles are cool, because GPUs can draw millions of them per second,
          but simplicity in rendering comes at a cost. Certain operations - like
          <a href="https://en.wikipedia.org/wiki/Constructive_solid_geometry">figuring out the difference of two shapes</a>:
        </p>

        <figure>
          <img src="https://pwy.io/posts/marching-events/assets/triangles-3.svg"/>
        </figure>

        <p>
          ... are rather awkward when operating on triangles (aka polygons).
        </p>

        <p>
          Another way of thinking about shapes is by describing them
          analytically, with the most popular approach (citation needed) being
          via <b>signed distance functions</b>.
        </p>

        <p>
          A signed distance function accepts a point and returns a distance from
          that point towards the nearest surface. You might think it sounds like
          a difficult kind of thing to implement, but it&#39;s actually quite
          straightforward - for instance the SDF of a sphere of radius=1
          centered at xyz=(0,0,0) is just:
        </p>

        <div>
          <pre><span></span><span>struct</span><span> </span><span>Vec3</span><span> </span><span>{</span>
<span>    </span><span>x</span><span>:</span><span> </span><span>f32</span><span>,</span>
<span>    </span><span>y</span><span>:</span><span> </span><span>f32</span><span>,</span>
<span>    </span><span>z</span><span>:</span><span> </span><span>f32</span><span>,</span>
<span>}</span>

<span>fn</span><span> </span><span>sphere</span><span>(</span><span>point</span><span>:</span><span> </span><span>Vec3</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>f32</span><span> </span><span>{</span>
<span>    </span><span>// Calculate distance from origin (0,0,0) to given point</span>
<span>    </span><span>let</span><span> </span><span>dist_to_origin</span><span> </span><span>=</span><span> </span><span>(</span>
<span>        </span><span>point</span><span>.</span><span>x</span><span> </span><span>*</span><span> </span><span>point</span><span>.</span><span>x</span>
<span>        </span><span>+</span><span> </span><span>point</span><span>.</span><span>y</span><span> </span><span>*</span><span> </span><span>point</span><span>.</span><span>y</span>
<span>        </span><span>+</span><span> </span><span>point</span><span>.</span><span>z</span><span> </span><span>*</span><span> </span><span>point</span><span>.</span><span>z</span>
<span>    </span><span>).</span><span>sqrt</span><span>();</span>

<span>    </span><span>dist_to_origin</span><span> </span><span>-</span><span> </span><span>1.0</span>
<span>}</span>
</pre>
        </div>

        <p>... because:</p>

        <div>
          <pre><span></span><span>sphere</span><span>(</span><span>vec3</span><span>(</span><span>2.0</span><span>,</span><span> </span><span>2.0</span><span>,</span><span> </span><span>2.0</span><span>))</span><span> </span><span>=~</span><span> </span><span>2.46</span>
<span>// ^ we&#39;re 2.46 units away from the nearest sphere</span>

<span>sphere</span><span>(</span><span>vec3</span><span>(</span><span>0.57</span><span>,</span><span> </span><span>0.57</span><span>,</span><span> </span><span>0.57</span><span>))</span><span> </span><span>=~</span><span> </span><span>0.0</span>
<span>// ^ we&#39;re exactly *at* the sphere (0.57 = 1/sqrt(3))</span>

<span>sphere</span><span>(</span><span>vec3</span><span>(</span><span>0.0</span><span>,</span><span> </span><span>0.0</span><span>,</span><span> </span><span>0.0</span><span>))</span><span> </span><span>=</span><span> </span><span>-</span><span>1.0</span>
<span>// ^ we&#39;re -1.0 units past the surface of sphere (we&#39;re inside of the shape)</span>
</pre>
        </div>

        <p>
          Notably, an SDF returns zero when given point is located directly on
          the surface represented by the function - so if we wanted to render
          this surface, we&#39;d take a camera:
        </p>

        <figure>
          <img src="https://pwy.io/posts/marching-events/assets/camera-1.svg"/>
        </figure>

        <p>
          ... and a viewport (a canvas onto which we&#39;re projecting the image):
        </p>

        <figure>
          <img src="https://pwy.io/posts/marching-events/assets/camera-2.svg"/>
        </figure>

        <p>
          ... and then for each pixel of this viewport we&#39;d shoot a ray from the
          camera, through the viewport, outward towards the world:
        </p>

        <figure>
          <img src="https://pwy.io/posts/marching-events/assets/camera-3.svg"/>
        </figure>

        <p>
          ... and we&#39;d slowly march through each of those rays, looking for
          places where SDF returns zero, indicating that the particular ray has
          reached a surface:
        </p>

        <div>
          <pre><span></span><span>fn</span><span> </span><span>render_image</span><span>(</span>
<span>    </span><span>sdf</span><span>:</span><span> </span><span>fn</span><span>(</span><span>Vec3</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>f32</span><span>,</span>
<span>    </span><span>camera</span><span>:</span><span> </span><span>Camera</span><span>,</span>
<span>)</span><span> </span><span>-&gt;</span><span> </span><span>Image</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>image</span><span> </span><span>=</span><span> </span><span>Image</span><span>::</span><span>new</span><span>(</span><span>width</span><span>,</span><span> </span><span>height</span><span>);</span>

<span>    </span><span>for</span><span> </span><span>x</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>width</span><span> </span><span>{</span>
<span>        </span><span>for</span><span> </span><span>y</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>height</span><span> </span><span>{</span>
<span>            </span><span>let</span><span> </span><span>mut</span><span> </span><span>curr</span><span> </span><span>=</span><span> </span><span>camera</span><span>.</span><span>origin</span><span>;</span>
<span>            </span><span>let</span><span> </span><span>dir</span><span> </span><span>=</span><span> </span><span>camera</span><span>.</span><span>ray</span><span>((</span><span>x</span><span>,</span><span> </span><span>y</span><span>));</span>

<span>            </span><span>for</span><span> </span><span>_iter</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>128</span><span> </span><span>{</span>
<span>                </span><span>if</span><span> </span><span>sdf</span><span>(</span><span>curr</span><span>)</span><span> </span><span>==</span><span> </span><span>0.0</span><span> </span><span>{</span>
<span>                    </span><span>// Yay, reached the surface!</span>
<span>                    </span><span>image</span><span>.</span><span>set_color</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>,</span><span> </span><span>Color</span><span>::</span><span>Green</span><span>);</span>
<span>                    </span><span>break</span><span>;</span>
<span>                </span><span>}</span>

<span>                </span><span>// Nay, not yet - make a small step forward!</span>
<span>                </span><span>curr</span><span> </span><span>+=</span><span> </span><span>0.01</span><span> </span><span>*</span><span> </span><span>dir</span><span>;</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>image</span>
<span>}</span>
</pre>
        </div>

        <p>
          Marching in constant steps is inefficient, though - it doesn&#39;t make a
          good use of the SDF, because it treats it as a binary function (<code>0 =&gt; yay</code>, <code>!= 0 =&gt; nay</code>), while in reality the SDF tells us much
          more.
        </p>

        <p>
          Instead of taking constant-length steps, we can use the value returned
          from the SDF as a guide of how long step we can make - this is known
          as <b>sphere tracing</b>:
        </p>

        <div>
          <pre><span></span><span>for</span><span> </span><span>_iter</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>128</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>step</span><span> </span><span>=</span><span> </span><span>sdf</span><span>(</span><span>point</span><span>);</span>

<span>    </span><span>if</span><span> </span><span>step</span><span> </span><span>==</span><span> </span><span>0.0</span><span> </span><span>{</span>
<span>        </span><span>image</span><span>.</span><span>set_color</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>,</span><span> </span><span>Color</span><span>::</span><span>White</span><span>);</span>
<span>        </span><span>break</span><span>;</span>
<span>    </span><span>}</span>

<span>    </span><span>curr</span><span> </span><span>+=</span><span> </span><span>step</span><span> </span><span>*</span><span> </span><span>dir</span><span>;</span>
<span>}</span>
</pre>
        </div>

        <p>You might think:</p>

        <blockquote>
          <p>
            but since the function tells us where the closest surface is, can&#39;t
            we do it in <code>O(1)</code> by simply calling the function once,
            why the loop ??
          </p>
        </blockquote>

        <p>
          Unfortunately, we have to call the SDF multiple times, because this
          function only tells us about the distance to the closest surface, not
          about distance to the closest surface that coincides with the
          direction we&#39;re walking towards:
        </p>

        <figure>
          <img src="https://pwy.io/posts/marching-events/assets/camera-4.svg"/>
        </figure>

        <p>
          So the specific property is that an SDF returns zero when we&#39;re at the
          surface and otherwise it returns a distance to the nearest surface, or
          at most an underapproximation of this distance.
        </p>

        <h2 id="marching-events">
          <a href="#marching-events"> Marching events </a>
        </h2>

        <p>Cool, but what all of that has to do with recurring events?</p>

        <p>
          I&#39;ve found a way of describing occurrences through distance functions.
          This means that instead of implementing logic for all combinations of
          frequencies and parameters - as that spooky table from before suggests
          one might do - we can simply compose a couple of distance functions
          together.
        </p>

        <p>
          Instead of 7 (frequencies) * 9 (<code>BY*</code> parameters) code
          paths, we end up with 7 + 9.
        </p>

        <p>
          Similarly to SDFs, what we&#39;re looking for is a function that takes a
          date, returns a span (+1 hour, +2 days etc.), and satisfies the
          following properties:
        </p>

        <ul>
          <li>
            if <code>date</code> is an occurrence of the event, this function
            returns zero,
          </li>
          <li>
            otherwise this function returns a positive span that either points
            at the next occurrence or it&#39;s an underapproximation of it.
          </li>
        </ul>

        <p>
          Having those as the only requirements means we&#39;re given a lot of
          leeway when it comes to the implementation - in fact, coming up with a
          basic distance function takes just a couple lines of code:
        </p>

        <div>
          <pre><span></span><span>type</span><span> </span><span>DistFn</span><span> </span><span>=</span><span> </span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>Fn</span><span>(</span><span>Date</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Span</span><span>&gt;</span><span>;</span>

<span>fn</span><span> </span><span>compile_recur</span><span>(</span><span>recur</span><span>:</span><span> </span><span>&amp;</span><span>Recur</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>DistFn</span><span> </span><span>{</span>
<span>    </span><span>Box</span><span>::</span><span>new</span><span>(</span><span>move</span><span> </span><span>|</span><span>curr</span><span>:</span><span> </span><span>Date</span><span>|</span><span> </span><span>-&gt;</span><span> </span><span>Span</span><span> </span><span>{</span>
<span>        </span><span>// Check if `curr` matches any of the `BYDAY` rules</span>
<span>        </span><span>// (evaluates to `true` if `by_day` is empty)</span>
<span>        </span><span>let</span><span> </span><span>matches_by_day</span><span> </span><span>=</span><span> </span><span>recur</span><span>.</span><span>by_day</span><span>.</span><span>iter</span><span>().</span><span>any</span><span>(</span><span>|</span><span>wd</span><span>|</span><span> </span><span>{</span>
<span>            </span><span>curr</span><span>.</span><span>weekday</span><span>()</span><span> </span><span>==</span><span> </span><span>wd</span>
<span>        </span><span>});</span>

<span>        </span><span>// Check if `curr` matches any of the `BYMONTHDAY` rules</span>
<span>        </span><span>// (evaluates to `true` when `by_month_day` is empty)</span>
<span>        </span><span>let</span><span> </span><span>matches_by_month_day</span><span> </span><span>=</span><span> </span><span>recur</span><span>.</span><span>by_month_day</span><span>.</span><span>iter</span><span>().</span><span>any</span><span>(</span><span>|</span><span>md</span><span>|</span><span> </span><span>{</span>
<span>            </span><span>curr</span><span>.</span><span>month_day</span><span>()</span><span> </span><span>==</span><span> </span><span>md</span>
<span>        </span><span>});</span>

<span>        </span><span>/* ... */</span>

<span>        </span><span>let</span><span> </span><span>matches_all</span><span> </span><span>=</span>
<span>            </span><span>matches_by_day</span>
<span>            </span><span>&amp;&amp;</span><span> </span><span>matches_by_month_day</span>
<span>            </span><span>&amp;&amp;</span><span> </span><span>/* ... */</span><span>;</span>

<span>        </span><span>if</span><span> </span><span>matches_all</span><span> </span><span>{</span>
<span>            </span><span>// If all of the rules are satisfied, great! -- return zero, since</span>
<span>            </span><span>// this date must be an occurrence of the underlying event.</span>
<span>            </span><span>Span</span><span>::</span><span>zero</span><span>()</span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>            </span><span>// If any of the rules don&#39;t match, return a guess as to when the</span>
<span>            </span><span>// next occurrence might be. We can underapproximate, but we can&#39;t</span>
<span>            </span><span>// overshoot, so let&#39;s take an epsilon of one second - can&#39;t go</span>
<span>            </span><span>// wrong with it!</span>
<span>            </span><span>//</span>
<span>            </span><span>// (that&#39;s because recurrence rules don&#39;t support milliseconds - a</span>
<span>            </span><span>// second is the lowest unit.)</span>
<span>            </span><span>Span</span><span>::</span><span>seconds</span><span>(</span><span>1</span><span>)</span>
<span>        </span><span>}</span>
<span>    </span><span>})</span>
<span>}</span>
</pre>
        </div>

        <p>
          Now that we have this magical thing available, what can we do with it?
          We march!
        </p>

        <div>
          <pre><span></span><span>fn</span><span> </span><span>iter</span><span>(</span>
<span>    </span><span>dist</span><span>:</span><span> </span><span>DistFn</span><span>,</span>
<span>    </span><span>dtstart</span><span>:</span><span> </span><span>Date</span><span>,</span>
<span>)</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>Iterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>Date</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>// Start at the first date at which the event repeats</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>curr</span><span> </span><span>=</span><span> </span><span>dtstart</span><span>;</span>

<span>    </span><span>loop</span><span> </span><span>{</span>
<span>        </span><span>// Call the distance function and note down the step size</span>
<span>        </span><span>let</span><span> </span><span>step</span><span> </span><span>=</span><span> </span><span>dist</span><span>(</span><span>curr</span><span>);</span>

<span>        </span><span>// If step is zero, it means that `curr` is a repetition of `event` -</span>
<span>        </span><span>// in that case we can just yield it back to the caller.</span>
<span>        </span><span>//</span>
<span>        </span><span>// Conversely, a non-zero step tells us how we can get closer to the</span>
<span>        </span><span>// next occurrence; not necessarily directly at it, just closer.</span>
<span>        </span><span>if</span><span> </span><span>step</span><span>.</span><span>is_zero</span><span>()</span><span> </span><span>{</span>
<span>            </span><span>yield</span><span> </span><span>curr</span><span>;</span>

<span>            </span><span>// As compared to ray marching, in here we&#39;re interested not in</span>
<span>            </span><span>// the first occurrence, but in *all* of them - so having reached</span>
<span>            </span><span>// a `dist`s root, let&#39;s add an arbitrarily small span to get the</span>
<span>            </span><span>// ball rolling again in the next iteration.</span>
<span>            </span><span>//</span>
<span>            </span><span>// Without this, the next iteration would yield `curr` back again,</span>
<span>            </span><span>// forever, since `step` is zero.</span>
<span>            </span><span>curr</span><span> </span><span>+=</span><span> </span><span>Span</span><span>::</span><span>seconds</span><span>(</span><span>1</span><span>);</span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>            </span><span>curr</span><span> </span><span>+=</span><span> </span><span>step</span><span>;</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <blockquote>
          <p>
            hey, that&#39;s stupid, you&#39;re just iterating over all possible dates
          </p>
        </blockquote>

        <p>You&#39;re right! What we&#39;ve got so far is essentially:</p>

        <div>
          <pre><span></span><span>fn</span><span> </span><span>iter</span><span>(</span>
<span>    </span><span>recur</span><span>:</span><span> </span><span>&amp;</span><span>Recur</span><span>,</span>
<span>    </span><span>dtstart</span><span>:</span><span> </span><span>Date</span><span>,</span>
<span>)</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>Iterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>Date</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>curr</span><span> </span><span>=</span><span> </span><span>dtstart</span><span>;</span>

<span>    </span><span>loop</span><span> </span><span>{</span>
<span>        </span><span>if</span><span> </span><span>recur</span><span>.</span><span>matches</span><span>(</span><span>curr</span><span>)</span><span> </span><span>{</span>
<span>            </span><span>yield</span><span> </span><span>candidate</span><span>;</span>
<span>        </span><span>}</span>

<span>        </span><span>curr</span><span> </span><span>+=</span><span> </span><span>Span</span><span>::</span><span>seconds</span><span>(</span><span>1</span><span>);</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>... which <i>is</i> stupid - for instance given:</p>

        <div>
          <pre><span></span>FREQ=DAILY;BYSECOND=0,10,20;DTSTART=20180101T120000
</pre>
        </div>

        <p>... the algorithm will do:</p>

        <div>
          <pre><span></span>curr = 2018-01-01 12:00:00

iteration 1:
    # 12:00:00 matches BYSECOND=0,10,20
    yield curr
    curr += 1 second

iteration 2:
    # 12:00:01 doesn&#39;t match BYSECOND=0,10,20
    curr += 1 second

iteration 3:
    # 12:00:02 doesn&#39;t match BYSECOND=0,10,20
    curr += 1 second

iteration 4:
    # 12:00:03 doesn&#39;t match BYSECOND=0,10,20
    curr += 1 second

/* ... */

iteration 11:
    # 12:00:10 matches BYSECOND=0,10,20
    yield curr
    curr += 1 second
</pre>
        </div>

        <p>
          ... and that&#39;s a lot of iterations, I agree - but the important bit is
          that
          <b>the outcome is correct</b>.
        </p>

        <p>
          It&#39;s inefficient, yes - but correct. This means that our approach is
          sound, we just need to find a way to make it more efficient, more
          practical; we need to optimize it.
        </p>

        <p>
          Of course, we also have to implement more rules, e.g. conveniently
          enough we&#39;ve skipped how the <code>FREQ</code> rule is supposed to
          work, but no worries - we&#39;ll get there.
        </p>

        <h2 id="atoms"><a href="#atoms"> Atoms </a></h2>

        <p>
          Let&#39;s ignore time for a moment. Nooo time. Zero. Null. Bliss. Remember
          that time Jeff has said something mean to you? No, you don&#39;t, because
          there&#39;s no time.
        </p>

        <p>
          Uhm, anyway. Let&#39;s focus on day-dates, such as
          <code>2018-01-01</code> - say we&#39;re given the following rule:
        </p>

        <div>
          <pre><span></span>FREQ=DAILY;BYDAY=MO,TU;BYMONTHDAY=10;DTSTART=20180101
</pre>
        </div>

        <p>... which corresponds to this pseudo-SQL:</p>

        <div>
          <pre><span></span><span>select</span><span> </span><span>day</span>
<span>  </span><span>from</span><span> </span><span>dates</span>
<span> </span><span>where</span><span> </span><span>day_of_week</span><span>(</span><span>day</span><span>)</span><span> </span><span>=</span><span> </span><span>&#39;Monday&#39;</span><span> </span><span>or</span><span> </span><span>day_of_week</span><span>(</span><span>day</span><span>)</span><span> </span><span>=</span><span> </span><span>&#39;Tuesday&#39;</span>
<span>   </span><span>and</span><span> </span><span>day_of_month</span><span>(</span><span>day</span><span>)</span><span> </span><span>=</span><span> </span><span>10</span>
<span>   </span><span>and</span><span> </span><span>day</span><span> </span><span>&gt;=</span><span> </span><span>&#39;2018-01-01&#39;</span>
</pre>
        </div>

        <p>
          How do we get from here towards a good distance function? Piecewise.
          Let&#39;s tackle <code>day_of_week</code> first.
        </p>

        <p>
          Ignoring the context in which it appears, how would we <i>like</i> for
          an ideal <code>day-of-week</code> distance function to work? We can
          come up with a couple of examples:
        </p>

        <div>
          <pre><span></span>(day-of-week Monday 2018-01-01) = 0
// 2018-01-01 is Monday

(day-of-week Tuesday 2018-01-01) = +1d
// 2018-01-01 one day away from Tuesday

(day-of-week Friday 2018-01-01) = +5d
// 2018-01-01 five days away from Friday
</pre>
        </div>

        <p>
          Since we don&#39;t care about travelling back in time, we can also state
          that:
        </p>

        <div>
          <pre><span></span>(day-of-week Monday 2018-01-02) = +6d
// 2018-01-02 is technically -1d away from the nearest Monday (2018-01-01),
// but since we want for the returned spans to be positive, let&#39;s choose the
// next Monday (2018-01-08), which is +6d away from 2018-01-02
</pre>
        </div>

        

        <p>
          Now that we have a couple of examples, it&#39;s time to come up with an
          implementation - we&#39;ll use
          <a href="https://docs.rs/jiff/latest/jiff/">Jiff</a> as the base for
          our algorithm, since I&#39;ve already had a chance to play with it and
          it&#39;s very pleasant.
        </p>

        <p>
          Before we jump into the code, there&#39;s one thing we&#39;re going to
          simplify - instead of juggling <code>fn(Date) -&gt; Span</code>, we&#39;ll go
          ahead with <code>fn(Date) -&gt; Date</code>, where the
          <code>span.is_zero()</code> condition is encoded as the function
          returning the same date as the input one:
        </p>

        <div>
          <pre><span></span>(day-of-week Monday 2018-01-01) = 2018-01-01
(day-of-week Tuesday 2018-01-01) = 2018-01-02
(day-of-week Friday 2018-01-01) = 2018-01-05
</pre>
        </div>

        <p>
          This doesn&#39;t really change anything, we&#39;re just making our lives
          easier, because in practice working on dates tends to be easier than
          working on spans. Without further ado:
        </p>

        <div>
          <pre><span></span><span>use</span><span> </span><span>jiff</span><span>::</span><span>Span</span><span>;</span>
<span>use</span><span> </span><span>jiff</span><span>::</span><span>civil</span><span>::{</span><span>Date</span><span>,</span><span> </span><span>Weekday</span><span>};</span>

<span>enum</span><span> </span><span>Rule</span><span> </span><span>{</span>
<span>    </span><span>DayOfWeek</span><span>(</span><span>Weekday</span><span>),</span>
<span>}</span>

<span>impl</span><span> </span><span>Rule</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>next</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>curr</span><span>:</span><span> </span><span>Date</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Date</span><span> </span><span>{</span>
<span>        </span><span>match</span><span> </span><span>self</span><span> </span><span>{</span>
<span>            </span><span>Rule</span><span>::</span><span>DayOfWeek</span><span>(</span><span>wd</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>                </span><span>curr</span><span> </span><span>+</span><span> </span><span>Span</span><span>::</span><span>new</span><span>().</span><span>days</span><span>(</span><span>curr</span><span>.</span><span>weekday</span><span>().</span><span>until</span><span>(</span><span>*</span><span>wd</span><span>))</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          That wasn&#39;t so hard, was it? We can confirm it&#39;s working as intended:
        </p>

        

        <div>
          <pre><span></span><span>#[cfg(test)]</span>
<span>mod</span><span> </span><span>tests</span><span> </span><span>{</span>
<span>    </span><span>use</span><span> </span><span>super</span><span>::</span><span>*</span><span>;</span>

<span>    </span><span>#[track_caller]</span>
<span>    </span><span>fn</span><span> </span><span>date</span><span>(</span><span>s</span><span>:</span><span> </span><span>&amp;</span><span>str</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Date</span><span> </span><span>{</span>
<span>        </span><span>s</span><span>.</span><span>parse</span><span>().</span><span>unwrap</span><span>()</span>
<span>    </span><span>}</span>

<span>    </span><span>#[test]</span>
<span>    </span><span>fn</span><span> </span><span>day_of_week</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>assert_eq!</span><span>(</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-01-01&#34;</span><span>),</span>
<span>            </span><span>Rule</span><span>::</span><span>DayOfWeek</span><span>(</span><span>Weekday</span><span>::</span><span>Monday</span><span>)</span>
<span>                </span><span>.</span><span>next</span><span>(</span><span>date</span><span>(</span><span>&#34;2018-01-01&#34;</span><span>))</span>
<span>        </span><span>);</span>

<span>        </span><span>assert_eq!</span><span>(</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-01-02&#34;</span><span>),</span>
<span>            </span><span>Rule</span><span>::</span><span>DayOfWeek</span><span>(</span><span>Weekday</span><span>::</span><span>Tuesday</span><span>)</span>
<span>                </span><span>.</span><span>next</span><span>(</span><span>date</span><span>(</span><span>&#34;2018-01-01&#34;</span><span>))</span>
<span>        </span><span>);</span>

<span>        </span><span>assert_eq!</span><span>(</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-01-05&#34;</span><span>),</span>
<span>            </span><span>Rule</span><span>::</span><span>DayOfWeek</span><span>(</span><span>Weekday</span><span>::</span><span>Friday</span><span>)</span>
<span>                </span><span>.</span><span>next</span><span>(</span><span>date</span><span>(</span><span>&#34;2018-01-01&#34;</span><span>))</span>
<span>        </span><span>);</span>

<span>        </span><span>assert_eq!</span><span>(</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-01-08&#34;</span><span>),</span>
<span>            </span><span>Rule</span><span>::</span><span>DayOfWeek</span><span>(</span><span>Weekday</span><span>::</span><span>Monday</span><span>)</span>
<span>                </span><span>.</span><span>next</span><span>(</span><span>date</span><span>(</span><span>&#34;2018-01-02&#34;</span><span>))</span>
<span>        </span><span>);</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          Ok, so it seems distance functions are not as scary as they seem! Or
          at least this one isn&#39;t, but I can tell you that most of them will be
          similarly intuitive.
        </p>

        <p>
          Moving on to <code>day-of-month</code> - as before, first let&#39;s
          imagine how we&#39;d like for it to behave:
        </p>

        <div>
          <pre><span></span>(day-of-month 14 2018-01-14) = 2018-01-14
// 2018-01-14 is already the 14th day of month

(day-of-month 16 2018-01-14) = 2018-01-16
// 2018-01-16 is the closest 16th day of month starting from 2018-01-14 (+2d)

(day-of-month 12 2018-01-14) = 2018-02-14
// 2018-01-12 is the closest 12th day of month starting from 2018-01-14 (-2d),
// but that corresponds to a negative span, so we jump to the next month
</pre>
        </div>

        <p>
          Implementing this one is a bit more tricky, but not dangerously so -
          there are three edge cases:
        </p>

        <div>
          <pre><span></span><span>/* ... */</span>
<span>use</span><span> </span><span>std</span><span>::</span><span>cmp</span><span>::</span><span>Ordering</span><span>;</span>

<span>enum</span><span> </span><span>Rule</span><span> </span><span>{</span>
<span>    </span><span>/* ... */</span>
<span>    </span><span>DayOfMonth</span><span>(</span><span>i8</span><span>),</span>
<span>}</span>

<span>impl</span><span> </span><span>Rule</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>next</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>curr</span><span>:</span><span> </span><span>Date</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Date</span><span> </span><span>{</span>
<span>        </span><span>match</span><span> </span><span>self</span><span> </span><span>{</span>
<span>            </span><span>/* ... */</span>

<span>            </span><span>Rule</span><span>::</span><span>DayOfMonth</span><span>(</span><span>day</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>                </span><span>match</span><span> </span><span>curr</span><span>.</span><span>day</span><span>().</span><span>cmp</span><span>(</span><span>day</span><span>)</span><span> </span><span>{</span>
<span>                    </span><span>// E.g. curr=2018-01-14 and day=16</span>
<span>                    </span><span>Ordering</span><span>::</span><span>Less</span><span> </span><span>=&gt;</span><span> </span><span>todo!</span><span>(),</span>

<span>                    </span><span>// E.g. curr=2018-01-14 and day=14</span>
<span>                    </span><span>Ordering</span><span>::</span><span>Equal</span><span> </span><span>=&gt;</span><span> </span><span>todo!</span><span>(),</span>

<span>                    </span><span>// E.g. curr=2018-01-14 and day=12</span>
<span>                    </span><span>Ordering</span><span>::</span><span>Greater</span><span> </span><span>=&gt;</span><span> </span><span>todo!</span><span>(),</span>
<span>                </span><span>}</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          ... out of which the <code>Less</code> and <code>Equal</code> branches
          are pretty straightforward:
        </p>

        <div>
          <pre><span></span><span>match</span><span> </span><span>self</span><span> </span><span>{</span>
<span>    </span><span>/* ... */</span>

<span>    </span><span>Rule</span><span>::</span><span>DayOfMonth</span><span>(</span><span>day</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>        </span><span>match</span><span> </span><span>curr</span><span>.</span><span>day</span><span>().</span><span>cmp</span><span>(</span><span>day</span><span>)</span><span> </span><span>{</span>
<span>            </span><span>// E.g. curr=2018-01-14 and day=16</span>
<span>            </span><span>Ordering</span><span>::</span><span>Less</span><span> </span><span>=&gt;</span><span> </span><span>curr</span><span> </span><span>+</span><span> </span><span>Span</span><span>::</span><span>new</span><span>().</span><span>days</span><span>(</span><span>day</span><span> </span><span>-</span><span> </span><span>curr</span><span>.</span><span>day</span><span>()),</span>

<span>            </span><span>// E.g. curr=2018-01-14 and day=14</span>
<span>            </span><span>Ordering</span><span>::</span><span>Equal</span><span> </span><span>=&gt;</span><span> </span><span>curr</span><span>,</span>

<span>            </span><span>// E.g. curr=2018-01-14 and day=12</span>
<span>            </span><span>Ordering</span><span>::</span><span>Greater</span><span> </span><span>=&gt;</span><span> </span><span>todo!</span><span>(),</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          What about <code>=&gt; Ordering::Greater</code>? Well, we could provide
          an exact solution:
        </p>

        <div>
          <pre><span></span><span>// E.g. curr=2018-01-14 and day=12</span>
<span>Ordering</span><span>::</span><span>Greater</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>    </span><span>// 2018-01-14 -&gt; 2018-02-14</span>
<span>    </span><span>let</span><span> </span><span>dst</span><span> </span><span>=</span><span> </span><span>curr</span><span> </span><span>+</span><span> </span><span>Span</span><span>::</span><span>months</span><span>(</span><span>1</span><span>);</span>

<span>    </span><span>// 2018-02-14 -&gt; 2018-02-01</span>
<span>    </span><span>let</span><span> </span><span>dst</span><span> </span><span>=</span><span> </span><span>dst</span><span>.</span><span>first_of_month</span><span>().</span><span>unwrap</span><span>();</span>

<span>    </span><span>// 2018-02-01 -&gt; 2018-02-12</span>
<span>    </span><span>dst</span><span> </span><span>+</span><span> </span><span>Span</span><span>::</span><span>days</span><span>(</span><span>*</span><span>day</span><span> </span><span>-</span><span> </span><span>1</span><span>)</span>
<span>}</span>
</pre>
        </div>

        <p>
          ... but since it&#39;s legal to underapproximate, we might as well go the
          easier way:
        </p>

        <div>
          <pre><span></span><span>Ordering</span><span>::</span><span>Greater</span><span> </span><span>=&gt;</span><span> </span><span>curr</span><span>.</span><span>last_of_month</span><span>().</span><span>tomorrow</span><span>().</span><span>unwrap</span><span>(),</span>
</pre>
        </div>

        <p>
          Given <code>curr=2018-01-14</code> and <code>day=12</code>, the
          function will suggest jumping to <code>2018-02-01</code> and then, on
          the next iteration, we&#39;ll hit the <code>Less</code> branch to end up
          on <code>2018-02-12</code>. Somewhat inefficient, but legal.
        </p>

        

        <p>
          Ok, we&#39;ve got <code>day-of-week</code>, we&#39;ve got
          <code>day-of-month</code> - time for conditionals!
        </p>

        <h2 id="yield-me-maybe">
          <a href="#yield-me-maybe"> Yield Me Maybe </a>
        </h2>

        <p>
          There are two types of boolean operators we need to support,
          <code>or</code> and <code>and</code>. <code>or</code> is used for
          combining values for the same parameter, while
          <code>and</code> combines across parameters:
        </p>

        <p>
          FREQ=DAILY;BYDAY=MO,TU;BYMONTHDAY=10;DTSTART=20180101
        </p>

        <div>
          <pre><span></span>(and
  (or (day-of-week Monday) (day-of-week Tuesday))
  (day-of-month 10))
</pre>
        </div>

        <p>... or, a bit less LISP-y:</p>

        <p>
          FREQ=DAILY;BYDAY=MO,TU;BYMONTHDAY=10;DTSTART=20180101
        </p>

        <div>
          <pre><span></span>(day-of-week(Monday) or day-of-week(Tuesday)) and day-of-month(10)
</pre>
        </div>

        <p>
          What does it mean
          <code>day-of-week(Monday) or day-of-week(Tuesday)</code>, then?
          Pessimistically, it&#39;s like:
        </p>

        <div>
          <pre><span></span>if day-of-week(Monday) == 0 or day-of-week(Tuesday) == 0:
    return 0
else
    return +1s
</pre>
        </div>

        <p>
          ... i.e. we march, slowly, looking for any of the functions to return
          zero. We know that marching second-by-second is legal, just
          suboptimal, so now the question becomes - how do we do it better?
        </p>

        <p>Our functions have this nice property that:</p>

        <div>
          <pre><span></span>if:
    f(x) = y

then, for t &gt;= 0 &amp;&amp; x + t &lt;= y:
    f(x + t) = y
</pre>
        </div>

        

        <p>
          This means that <code>f(x) or g(x)</code> corresponds to
          <code>min(f(x), g(x))</code>, which we can eyeball by doing:
        </p>

        <p>FREQ=DAILY;BYDAY=MO,TU;DTSTART=20180103</p>

        <div>
          <pre><span></span>since 2018-01-03 is Wednesday, we&#39;d expect for the next ocurrences to be:

-&gt; 2018-01-08 (Monday, since it comes before the next Tuesday)
-&gt; 2018-01-09 (Tuesday, since it comes before the next Monday)
-&gt; 2018-01-15 (Monday, ...)
-&gt; [...]
</pre>
        </div>

        <p>This boils down to the following cute snippet:</p>

        <div>
          <pre><span></span><span>enum</span><span> </span><span>Rule</span><span> </span><span>{</span>
<span>    </span><span>/* ... */</span>
<span>    </span><span>Or</span><span>(</span><span>Vec</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>),</span>
<span>}</span>

<span>impl</span><span> </span><span>Rule</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>next</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>curr</span><span>:</span><span> </span><span>Date</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Date</span><span> </span><span>{</span>
<span>        </span><span>match</span><span> </span><span>self</span><span> </span><span>{</span>
<span>            </span><span>/* ... */</span>

<span>            </span><span>Rule</span><span>::</span><span>Or</span><span>(</span><span>rules</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>                </span><span>rules</span>
<span>                    </span><span>.</span><span>iter</span><span>()</span>
<span>                    </span><span>.</span><span>map</span><span>(</span><span>|</span><span>rule</span><span>|</span><span> </span><span>rule</span><span>.</span><span>next</span><span>(</span><span>curr</span><span>))</span>
<span>                    </span><span>.</span><span>min</span><span>()</span>
<span>                    </span><span>.</span><span>unwrap_or</span><span>(</span><span>curr</span><span>)</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          Conversely, <code>and = max</code>, for a similar reason: if
          <code>f(x)</code> says it won&#39;t be valid until some date
          <code>A</code> and <code>g(x)</code> says it won&#39;t be valid until some
          date <code>B</code>, then both won&#39;t be valid until at least
          <code>max(A, B)</code>.
        </p>

        <p>
          This doesn&#39;t necessarily mean that both rules <i>are</i> valid at
          <code>max(A, B)</code>, e.g.:
        </p>

        <p>
          FREQ=DAILY;BYDAY=MO;BYMONTHDAY=10;DTSTART=20180101
        </p>

        <div>
          <pre><span></span>(and
   (day-of-week Monday)
   (day-of-month 10))

Given 2018-01-03, we&#39;ll evaulate:

   (day-of-week Monday 2018-01-03)
   = 2018-01-08

   (day-of-month 10 2018-01-03)
   = 2018-01-10

   (and (day-of-week ...) (day-of-month ...))
   = (max 2018-01-08 2018-01-10)
   = 2018-01-10

2018-01-10 isn&#39;t Monday though, so we have to try again on the next iteration.
</pre>
        </div>

        <p>
          Still, <code>and = max</code> is alright, because it&#39;s legal to
          underapproximate:
        </p>

        <div>
          <pre><span></span><span>enum</span><span> </span><span>Rule</span><span> </span><span>{</span>
<span>    </span><span>/* ... */</span>
<span>    </span><span>And</span><span>(</span><span>Vec</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>),</span>
<span>}</span>

<span>impl</span><span> </span><span>Rule</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>next</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>curr</span><span>:</span><span> </span><span>Date</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Date</span><span> </span><span>{</span>
<span>        </span><span>match</span><span> </span><span>self</span><span> </span><span>{</span>
<span>            </span><span>/* ... */</span>

<span>            </span><span>Rule</span><span>::</span><span>And</span><span>(</span><span>rules</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>                </span><span>rules</span>
<span>                    </span><span>.</span><span>iter</span><span>()</span>
<span>                    </span><span>.</span><span>map</span><span>(</span><span>|</span><span>rule</span><span>|</span><span> </span><span>rule</span><span>.</span><span>next</span><span>(</span><span>curr</span><span>))</span>
<span>                    </span><span>.</span><span>max</span><span>()</span>
<span>                    </span><span>.</span><span>unwrap_or</span><span>(</span><span>curr</span><span>)</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        

        <h2 id="molecules"><a href="#molecules"> Molecules </a></h2>

        <p>
          We&#39;re still missing the <code>FREQ</code> rule, but what we&#39;ve got so
          far is sufficient to play with:
        </p>

        <div>
          <pre><span></span><span>/* ... */</span>
<span>use</span><span> </span><span>std</span><span>::</span><span>iter</span><span>;</span>

<span>struct</span><span> </span><span>Recur</span><span> </span><span>{</span>
<span>    </span><span>by_day</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>Weekday</span><span>&gt;</span><span>,</span>
<span>    </span><span>by_month_day</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>i8</span><span>&gt;</span><span>,</span>
<span>    </span><span>dtstart</span><span>:</span><span> </span><span>Date</span><span>,</span>
<span>}</span>

<span>impl</span><span> </span><span>Recur</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>as_rule</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Rule</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>rules</span><span> </span><span>=</span><span> </span><span>Vec</span><span>::</span><span>new</span><span>();</span>

<span>        </span><span>// If BYDAY paremeter is present, emit the DayOfWeek rule</span>
<span>        </span><span>if</span><span> </span><span>!</span><span>self</span><span>.</span><span>by_day</span><span>.</span><span>is_empty</span><span>()</span><span> </span><span>{</span>
<span>            </span><span>rules</span><span>.</span><span>push</span><span>(</span><span>Rule</span><span>::</span><span>Or</span><span>(</span>
<span>                </span><span>self</span><span>.</span><span>by_day</span>
<span>                    </span><span>.</span><span>iter</span><span>()</span>
<span>                    </span><span>.</span><span>copied</span><span>()</span>
<span>                    </span><span>.</span><span>map</span><span>(</span><span>Rule</span><span>::</span><span>DayOfWeek</span><span>)</span>
<span>                    </span><span>.</span><span>collect</span><span>(),</span>
<span>            </span><span>));</span>
<span>        </span><span>}</span>

<span>        </span><span>// If BYMONTHDAY parameter is present, emit the DayOfMonth rule</span>
<span>        </span><span>if</span><span> </span><span>!</span><span>self</span><span>.</span><span>by_month_day</span><span>.</span><span>is_empty</span><span>()</span><span> </span><span>{</span>
<span>            </span><span>rules</span><span>.</span><span>push</span><span>(</span><span>Rule</span><span>::</span><span>Or</span><span>(</span>
<span>                </span><span>self</span><span>.</span><span>by_month_day</span>
<span>                    </span><span>.</span><span>iter</span><span>()</span>
<span>                    </span><span>.</span><span>copied</span><span>()</span>
<span>                    </span><span>.</span><span>map</span><span>(</span><span>Rule</span><span>::</span><span>DayOfMonth</span><span>)</span>
<span>                    </span><span>.</span><span>collect</span><span>(),</span>
<span>            </span><span>));</span>
<span>        </span><span>}</span>

<span>        </span><span>Rule</span><span>::</span><span>And</span><span>(</span><span>rules</span><span>)</span>
<span>    </span><span>}</span>

<span>    </span><span>fn</span><span> </span><span>iter</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>impl</span><span> </span><span>Iterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>Date</span><span>&gt;</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>rule</span><span> </span><span>=</span><span> </span><span>self</span><span>.</span><span>as_rule</span><span>();</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>curr</span><span> </span><span>=</span><span> </span><span>self</span><span>.</span><span>dtstart</span><span>;</span>

<span>        </span><span>iter</span><span>::</span><span>from_fn</span><span>(</span><span>move</span><span> </span><span>||</span><span> </span><span>{</span>
<span>            </span><span>loop</span><span> </span><span>{</span>
<span>                </span><span>let</span><span> </span><span>next</span><span> </span><span>=</span><span> </span><span>rule</span><span>.</span><span>next</span><span>(</span><span>curr</span><span>);</span>

<span>                </span><span>if</span><span> </span><span>next</span><span> </span><span>==</span><span> </span><span>curr</span><span> </span><span>{</span>
<span>                    </span><span>curr</span><span> </span><span>+=</span><span> </span><span>Span</span><span>::</span><span>new</span><span>().</span><span>days</span><span>(</span><span>1</span><span>);</span>
<span>                    </span><span>break</span><span> </span><span>Some</span><span>(</span><span>next</span><span>);</span>
<span>                </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>                    </span><span>curr</span><span> </span><span>=</span><span> </span><span>next</span><span>;</span>
<span>                </span><span>}</span>
<span>            </span><span>}</span>
<span>        </span><span>})</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>... and voilÃ :</p>

        

        <div>
          <pre><span></span><span>#[cfg(test)]</span>
<span>mod</span><span> </span><span>tests</span><span> </span><span>{</span>
<span>    </span><span>/* ... */</span>

<span>    </span><span>#[test]</span>
<span>    </span><span>fn</span><span> </span><span>smoke</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>// FREQ=DAILY;BYDAY=MO,TU;BYMONTHDAY=10,20,30;DTSTART=20180101</span>
<span>        </span><span>let</span><span> </span><span>recur</span><span> </span><span>=</span><span> </span><span>Recur</span><span> </span><span>{</span>
<span>            </span><span>by_day</span><span>:</span><span> </span><span>vec</span><span>!</span><span>[</span><span>Weekday</span><span>::</span><span>Monday</span><span>,</span><span> </span><span>Weekday</span><span>::</span><span>Tuesday</span><span>],</span>
<span>            </span><span>by_month_day</span><span>:</span><span> </span><span>vec</span><span>!</span><span>[</span><span>10</span><span>,</span><span> </span><span>20</span><span>,</span><span> </span><span>30</span><span>],</span>
<span>            </span><span>dtstart</span><span>:</span><span> </span><span>date</span><span>(</span><span>&#34;20180101&#34;</span><span>),</span>
<span>        </span><span>};</span>

<span>        </span><span>let</span><span> </span><span>actual</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>recur</span><span>.</span><span>iter</span><span>().</span><span>take</span><span>(</span><span>5</span><span>).</span><span>collect</span><span>();</span>

<span>        </span><span>// Cross-checked with https://jkbrzt.github.io/rrule</span>
<span>        </span><span>let</span><span> </span><span>expected</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-01-30&#34;</span><span>),</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-02-20&#34;</span><span>),</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-03-20&#34;</span><span>),</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-04-10&#34;</span><span>),</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-04-30&#34;</span><span>),</span>
<span>        </span><span>];</span>

<span>        </span><span>assert_eq!</span><span>(</span><span>expected</span><span>,</span><span> </span><span>actual</span><span>);</span>
<span>    </span><span>}</span>

<span>    </span><span>/* ... */</span>
<span>}</span>
</pre>
        </div>

        <p>
          Now, I could go on and implement all of the other parameters, but for
          the most part they follow the outline showed here, nothing fancy - so
          instead let&#39;s wrap up by implementing the parameters that require a
          bit different approach,
          <code>FREQ</code> and <code>INTERVAL</code>.
        </p>

        <p>
          The simplest case is the default of <code>INTERVAL=1</code> - it feels
          quite intuitive, but what does it really mean?
        </p>

        <p>Let&#39;s analyze a specific example:</p>

        <p>
          FREQ=MONTHLY;INTERVAL=1;DTSTART=20180114
        </p>

        <div>
          <pre><span></span>-&gt; 2018-01-14
-&gt; 2018-02-14
-&gt; 2018-03-14
-&gt; 2018-04-14
-&gt; [...]
</pre>
        </div>

        <p>
          What&#39;s the pattern? Perhaps surprisingly, we can already encode it -
          that&#39;s just <code>(day-of-month 14)</code>!
        </p>

        <p>
          This means that
          <code>FREQ=MONTHLY;INTERVAL=1;DTSTART=201801014</code> is really
          <code>BYMONTHDAY=14;DTSTART=20180114</code> - and actually all forms
          of <code>FREQ=;INTERVAL=1</code> can be reduced to some combination of
          the <code>BY*</code> rules:
        </p>

        <div>
          <pre><span></span>FREQ=YEARLY;INTERVAL=1;DTSTART=20180114
-&gt; BYMONTH=1;BYMONTHDAY=14
-&gt; (and (month 1) (day-of-month 14))
</pre>
        </div>

        <div>
          <pre><span></span>FREQ=MONTHLY;INTERVAL=1;DTSTART=20180114
-&gt; BYMONTHDAY=14
-&gt; (day-of-month 14)
</pre>
        </div>

        <div>
          <pre><span></span>FREQ=WEEKLY;INTERVAL=1;DTSTART=20180114
-&gt; BYDAY=SU
-&gt; (weekday Sunday)
</pre>
        </div>

        <div>
          <pre><span></span>FREQ=DAILY;INTERVAL=1;DTSTART=20180114
-&gt; no-op
</pre>
        </div>

        

        <p>
          What about intervals larger than one? Once again, let&#39;s take an
          example:
        </p>

        <p>
          FREQ=MONTHLY;INTERVAL=5;DTSTART=20180114
        </p>

        <div>
          <pre><span></span>-&gt; 2018-01-14
-&gt; 2018-06-14
-&gt; 2018-11-14
-&gt; 2019-04-14
-&gt; [...]
</pre>
        </div>

        <p>... or two, to have a complete picture:</p>

        <p>
          FREQ=MONTHLY;INTERVAL=5;BYDAY=MO,TU;DTSTART=20180114
        </p>

        <div>
          <pre><span></span>-&gt; 2018-01-15
-&gt; 2018-01-16
-&gt; 2018-01-22
-&gt; 2018-01-23
-&gt; 2018-01-29
-&gt; 2018-01-30
-&gt; 2018-06-04
-&gt; 2018-06-05
-&gt; [...]
</pre>
        </div>

        <p>
          Alright, what&#39;s the pattern? Looking at the first example suggests:
        </p>

        <div>
          <pre><span></span>date = DTSTART + FREQ * INTERVAL * nth

-&gt; 2018-01-14 = 2018-01-14 + 5 months * 0
-&gt; 2018-06-14 = 2018-01-14 + 5 months * 1
-&gt; 2018-11-14 = 2018-01-14 + 5 months * 2
-&gt; 2019-04-14 = 2018-01-14 + 5 months * 3
</pre>
        </div>

        <p>
          ... but this falls apart over the second example where none of the
          dates are an exact repetition:
        </p>

        <div>
          <pre><span></span>-&gt; 2018-01-15 = 2018-01-14 + 1 day
-&gt; 2018-01-16 = 2018-01-14 + 2 days
-&gt; [...]
-&gt; 2018-06-04 = 2018-01-14 + 4 months and 21 days
-&gt; 2018-06-05 = 2018-01-14 + 4 months and 22 days
-&gt; [...]
</pre>
        </div>

        <p>
          In fact, <code>2018-06-04</code> isn&#39;t even 5 months apart from
          <code>2018-01-14</code>!
        </p>

        <p>
          If we&#39;re not literally repeating the starting date, then what&#39;s going
          on? Let&#39;s compare a correct and an incorrect occurrence, following the
          second example and ignoring <code>BYDAY=MO,TU</code> for a moment:
        </p>

        <div>
          <pre><span></span>correct:
-&gt; 2018-06-04 = 2018-01-14 + 4 months and 21 days

incorrect:
-&gt; 2018-05-31 = 2018-01-14 + 4 months and 17 days
</pre>
        </div>

        <p>
          Clearly we&#39;re doing something wrong by looking the distance between
          <code>DTSTART</code> and our candidate. In particular, we can see that
          <code>DTSTART</code>&#39;s day part doesn&#39;t affect anything, except for in
          the first month.
        </p>

        <p>
          That is, if we started on <code>DTSTART=20180120</code>, we&#39;d still go
          through <code>2018-06-04</code>, even though the distance between
          those two just got shorter - so for <code>FREQ=MONTHLY</code> we
          should have a way of comparing dates that ignores the day part.
        </p>

        <p>One approach could be:</p>

        <div>
          <pre><span></span><span>fn</span><span> </span><span>months_of</span><span>(</span><span>date</span><span>:</span><span> </span><span>Date</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>i16</span><span> </span><span>{</span>
<span>    </span><span>date</span><span>.</span><span>year</span><span>()</span><span> </span><span>*</span><span> </span><span>12</span><span> </span><span>+</span><span> </span><span>date</span><span>.</span><span>month</span><span>()</span>
<span>}</span>

<span>fn</span><span> </span><span>months_between</span><span>(</span><span>lhs</span><span>:</span><span> </span><span>Date</span><span>,</span><span> </span><span>rhs</span><span>:</span><span> </span><span>Date</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>i16</span><span> </span><span>{</span>
<span>     </span><span>months_of</span><span>(</span><span>lhs</span><span>)</span><span> </span><span>-</span><span> </span><span>months_of</span><span>(</span><span>rhs</span><span>)</span>
<span>}</span>

<span>// ... and then we make sure that months_between() is divisible by INTERVAL</span>
</pre>
        </div>

        <p>
          ... but Jiff&#39;s spans are more convenient to work with, and they
          generalize to other units as well:
        </p>

        <div>
          <pre><span></span><span>/* ... */</span>
<span>use</span><span> </span><span>jiff</span><span>::{</span><span>SpanRound</span><span>,</span><span> </span><span>Unit</span><span>};</span>

<span>/* ... */</span>

<span>enum</span><span> </span><span>Rule</span><span> </span><span>{</span>
<span>    </span><span>/* ... */</span>
<span>    </span><span>InstanceOf</span><span>(</span><span>Date</span><span>,</span><span> </span><span>Unit</span><span>,</span><span> </span><span>i32</span><span>),</span>
<span>    </span><span>/* ... */</span>
<span>}</span>

<span>impl</span><span> </span><span>Rule</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>next</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>curr</span><span>:</span><span> </span><span>Date</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Date</span><span> </span><span>{</span>
<span>        </span><span>match</span><span> </span><span>self</span><span> </span><span>{</span>
<span>            </span><span>/* ... */</span>

<span>            </span><span>Rule</span><span>::</span><span>InstanceOf</span><span>(</span><span>start</span><span>,</span><span> </span><span>unit</span><span>,</span><span> </span><span>interval</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>                </span><span>// Calculate the distance between `start` and our candidate</span>
<span>                </span><span>// date (`curr`).</span>
<span>                </span><span>//</span>
<span>                </span><span>// `start` is expected to be already snapped to the first day</span>
<span>                </span><span>// of month, first day of year etc.</span>
<span>                </span><span>let</span><span> </span><span>diff</span><span> </span><span>=</span><span> </span><span>curr</span><span>.</span><span>since</span><span>(</span><span>*</span><span>start</span><span>).</span><span>unwrap</span><span>();</span>

<span>                </span><span>// By default `.since()` returns span in days - for proper</span>
<span>                </span><span>// comparison we need to round it to months, years etc.</span>
<span>                </span><span>let</span><span> </span><span>diff</span><span> </span><span>=</span><span> </span><span>diff</span>
<span>                    </span><span>.</span><span>round</span><span>(</span>
<span>                        </span><span>SpanRound</span><span>::</span><span>new</span><span>()</span>
<span>                            </span><span>.</span><span>largest</span><span>(</span><span>*</span><span>unit</span><span>)</span>
<span>                            </span><span>.</span><span>relative</span><span>(</span><span>*</span><span>start</span><span>)</span>
<span>                    </span><span>)</span>
<span>                    </span><span>.</span><span>unwrap</span><span>();</span>

<span>                </span><span>// Now we&#39;ve got all the funny numbers we need!</span>
<span>                </span><span>match</span><span> </span><span>unit</span><span> </span><span>{</span>
<span>                    </span><span>Unit</span><span>::</span><span>Month</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>                        </span><span>let</span><span> </span><span>diff</span><span> </span><span>=</span><span> </span><span>diff</span><span>.</span><span>get_months</span><span>()</span><span> </span><span>%</span><span> </span><span>interval</span><span>;</span>

<span>                        </span><span>if</span><span> </span><span>diff</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span>
<span>                            </span><span>curr</span>
<span>                        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>                            </span><span>(</span><span>curr</span><span> </span><span>+</span><span> </span><span>Span</span><span>::</span><span>new</span><span>().</span><span>months</span><span>(</span><span>interval</span><span> </span><span>-</span><span> </span><span>diff</span><span>))</span>
<span>                                </span><span>.</span><span>first_of_month</span><span>()</span>
<span>                        </span><span>}</span>
<span>                    </span><span>}</span>

<span>                    </span><span>_</span><span> </span><span>=&gt;</span><span> </span><span>todo!</span><span>(),</span>
<span>                </span><span>}</span>
<span>            </span><span>}</span>

<span>            </span><span>/* ... */</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>This new rule integrates quite nicely with the existing code:</p>

        <div>
          <pre><span></span><span>enum</span><span> </span><span>Freq</span><span> </span><span>{</span>
<span>    </span><span>Daily</span><span>,</span>
<span>    </span><span>Monthly</span><span>,</span>
<span>    </span><span>Yearly</span><span>,</span>
<span>}</span>

<span>struct</span><span> </span><span>Recur</span><span> </span><span>{</span>
<span>    </span><span>freq</span><span>:</span><span> </span><span>Freq</span><span>,</span>
<span>    </span><span>interval</span><span>:</span><span> </span><span>i32</span><span>,</span>
<span>    </span><span>by_day</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>Weekday</span><span>&gt;</span><span>,</span>
<span>    </span><span>by_month_day</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>i8</span><span>&gt;</span><span>,</span>
<span>    </span><span>dtstart</span><span>:</span><span> </span><span>Date</span><span>,</span>
<span>}</span>

<span>impl</span><span> </span><span>Recur</span><span> </span><span>{</span>
<span>    </span><span>fn</span><span> </span><span>as_rule</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Rule</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>rules</span><span> </span><span>=</span><span> </span><span>Vec</span><span>::</span><span>new</span><span>();</span>

<span>        </span><span>// Create the `InstanceOf` rule</span>
<span>        </span><span>rules</span><span>.</span><span>push</span><span>({</span>
<span>            </span><span>// Snap `start` to the beginning of `FREQ`</span>
<span>            </span><span>let</span><span> </span><span>start</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>self</span><span>.</span><span>freq</span><span> </span><span>{</span>
<span>                </span><span>Freq</span><span>::</span><span>Daily</span><span> </span><span>=&gt;</span><span> </span><span>self</span><span>.</span><span>dtstart</span><span>,</span>
<span>                </span><span>Freq</span><span>::</span><span>Monthly</span><span> </span><span>=&gt;</span><span> </span><span>self</span><span>.</span><span>dtstart</span><span>.</span><span>first_of_month</span><span>(),</span>
<span>                </span><span>Freq</span><span>::</span><span>Yearly</span><span> </span><span>=&gt;</span><span> </span><span>todo!</span><span>(),</span>
<span>            </span><span>};</span>

<span>            </span><span>// Convert our `Freq` into Jiff&#39;s `Unit`</span>
<span>            </span><span>let</span><span> </span><span>unit</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>self</span><span>.</span><span>freq</span><span> </span><span>{</span>
<span>                </span><span>Freq</span><span>::</span><span>Daily</span><span> </span><span>=&gt;</span><span> </span><span>Unit</span><span>::</span><span>Day</span><span>,</span>
<span>                </span><span>Freq</span><span>::</span><span>Monthly</span><span> </span><span>=&gt;</span><span> </span><span>Unit</span><span>::</span><span>Month</span><span>,</span>
<span>                </span><span>Freq</span><span>::</span><span>Yearly</span><span> </span><span>=&gt;</span><span> </span><span>Unit</span><span>::</span><span>Year</span><span>,</span>
<span>            </span><span>};</span>

<span>            </span><span>Rule</span><span>::</span><span>InstanceOf</span><span>(</span><span>start</span><span>,</span><span> </span><span>unit</span><span>,</span><span> </span><span>self</span><span>.</span><span>interval</span><span>)</span>
<span>        </span><span>});</span>

<span>        </span><span>/* ... */</span>

<span>        </span><span>// Create implied rules</span>
<span>        </span><span>match</span><span> </span><span>self</span><span>.</span><span>freq</span><span> </span><span>{</span>
<span>            </span><span>Freq</span><span>::</span><span>Daily</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>                </span><span>// No extra rules required</span>
<span>            </span><span>}</span>

<span>            </span><span>Freq</span><span>::</span><span>Monthly</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>                </span><span>if</span><span> </span><span>self</span><span>.</span><span>by_day</span><span>.</span><span>is_empty</span><span>()</span><span> </span><span>&amp;&amp;</span><span> </span><span>self</span><span>.</span><span>by_month_day</span><span>.</span><span>is_empty</span><span>()</span><span> </span><span>{</span>
<span>                    </span><span>rules</span><span>.</span><span>push</span><span>(</span><span>Rule</span><span>::</span><span>DayOfMonth</span><span>(</span><span>self</span><span>.</span><span>dtstart</span><span>.</span><span>month</span><span>()));</span>
<span>                </span><span>}</span>
<span>            </span><span>}</span>

<span>            </span><span>Freq</span><span>::</span><span>Yearly</span><span> </span><span>=&gt;</span><span> </span><span>{</span>
<span>                </span><span>todo!</span><span>(</span><span>&#34;left as an exercise for the reader&#34;</span><span>);</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>

<span>        </span><span>Rule</span><span>::</span><span>And</span><span>(</span><span>rules</span><span>)</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>... and voilÃ :</p>

        

        <div>
          <pre><span></span><span>#[cfg(test)]</span>
<span>mod</span><span> </span><span>tests</span><span> </span><span>{</span>
<span>    </span><span>/* ... */</span>

<span>    </span><span>#[test]</span>
<span>    </span><span>fn</span><span> </span><span>smoke</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>// FREQ=MONTHLY;INTERVAL=5;BYDAY=FR;DTSTART=20180114</span>
<span>        </span><span>let</span><span> </span><span>recur</span><span> </span><span>=</span><span> </span><span>Recur</span><span> </span><span>{</span>
<span>            </span><span>freq</span><span>:</span><span> </span><span>Freq</span><span>::</span><span>Monthly</span><span>,</span>
<span>            </span><span>interval</span><span>:</span><span> </span><span>5</span><span>,</span>
<span>            </span><span>by_day</span><span>:</span><span> </span><span>vec</span><span>!</span><span>[</span><span>Weekday</span><span>::</span><span>Friday</span><span>],</span>
<span>            </span><span>by_month_day</span><span>:</span><span> </span><span>Vec</span><span>::</span><span>new</span><span>(),</span>
<span>            </span><span>dtstart</span><span>:</span><span> </span><span>date</span><span>(</span><span>&#34;20180119&#34;</span><span>),</span>
<span>        </span><span>};</span>

<span>        </span><span>// Cross-checked with https://jkbrzt.github.io/rrule</span>
<span>        </span><span>let</span><span> </span><span>actual</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>recur</span><span>.</span><span>iter</span><span>().</span><span>take</span><span>(</span><span>8</span><span>).</span><span>collect</span><span>();</span>

<span>        </span><span>let</span><span> </span><span>expected</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-01-19&#34;</span><span>),</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-01-26&#34;</span><span>),</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-06-01&#34;</span><span>),</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-06-08&#34;</span><span>),</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-06-15&#34;</span><span>),</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-06-22&#34;</span><span>),</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-06-29&#34;</span><span>),</span>
<span>            </span><span>date</span><span>(</span><span>&#34;2018-11-02&#34;</span><span>),</span>
<span>        </span><span>];</span>

<span>        </span><span>assert_eq!</span><span>(</span><span>expected</span><span>,</span><span> </span><span>actual</span><span>);</span>
<span>    </span><span>}</span>
<span>}</span>
</pre>
        </div>

        <p>
          As it turns out, spooky RFC tables don&#39;t have to always end up in
          spooky code!
        </p>

        <h2 id="closing-thoughts">
          <a href="#closing-thoughts"> Closing thoughts </a>
        </h2>

        <h3>Isn&#39;t it too complex?</h3>

        <p>
          I&#39;d argue that this distance-based approach is actually
          <i>simpler</i> than what other implementations do.
        </p>

        <p>
          That&#39;s because at every step you have something that&#39;s easy to reason
          about in isolation - you have one function that rounds date to the
          next week, you have another function that takes two values and returns
          the smallest one etc., and all of those functions make sense on their
          own.
        </p>

        <p>
          Not to mention that fast-forwarding - &#34;find me the next occurrence
          after xxx&#34; - is something that other implementations struggle with,
          while in this case you get it for free.
        </p>

        <h3>Isn&#39;t it too slow?</h3>

        <p>
          Seems to be okay - I&#39;ve benchmarked my reasonably optimized
          implementation (closed source for the time being) and iterating
          hundreds of times over complex rules happens under a millisecond.
        </p>

        <p>
          The beauty of going distancefunctionedâ„¢ is that you can optimize as
          much or as little as you want - after all, half of this article is
          actually spent talking about optimization.
        </p>

        <h3>Surely you can&#39;t be the first one to come up with this?</h3>

        <p>
          I hope I&#39;m not the first one! I couldn&#39;t find any existing
          implementation that works this way, though.
        </p>

        <p>
          The mathematical foundation also escapes me - surely this must&#39;ve been
          already discovered in one form or another, but I haven&#39;t found
          anything this specific.
        </p>

        <p>
          <a href="https://en.wikipedia.org/wiki/Proximal_operator">Proximal operator</a>
          sounds quite close;

          <a href="https://en.wikipedia.org/wiki/Frank%E2%80%93Wolfe_algorithm">Frank-Wolfe</a>
          maybe? If you have an idea, lemme know!
        </p>
      </div></div>
  </body>
</html>
