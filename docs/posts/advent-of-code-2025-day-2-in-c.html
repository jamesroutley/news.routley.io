<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hamy.xyz/blog/2025-12_aoc-2025-day2-csharp">Original</a>
    <h1>Advent of Code 2025 - Day 2 in C#</h1>
    
    <div id="readability-page-1" class="page"><p>DISCLOSURE: If you buy through affiliate links, I may earn a small commission. <a href="https://hamy.xyz/blog/disclosures">(disclosures)</a></p><div><p>In this post I&#39;ll walk through my solution to AOC 2025 Day 2 in C#.</p>
<h2 id="part-1">Part 1</h2>
<p>Utilities for Result and Option. I decided I wanted a few utilities to code more like I wanted so reached for OneOf and built a simple version of each.</p>
<ul>
<li>Result for Success / Failure - though I realized I didn&#39;t really need it</li>
<li>Option for Some / None - lighter weight for parsing the bad numbers</li>
</ul>
<p>I also realized I wanted some EnumerableExtensions in the process of solving these:</p>
<ul>
<li>LongRange - To get a range that works for longs (my inputs overflowed int)</li>
<li>RangeStep - Create a range with a stepping function</li>
</ul>
<pre><code>using OneOf;

public record Success&lt;T&gt;(T Value);
public record Failure&lt;T&gt;(T Error);

public class Result&lt;TSuccess, TError&gt; : OneOfBase&lt;Success&lt;TSuccess&gt;, Failure&lt;TError&gt;&gt;
{
    private Result(OneOf&lt;Success&lt;TSuccess&gt;, Failure&lt;TError&gt;&gt; input) : base(input) { }

    public static implicit operator Result&lt;TSuccess, TError&gt;(Success&lt;TSuccess&gt; success) =&gt; new(success);
    public static implicit operator Result&lt;TSuccess, TError&gt;(Failure&lt;TError&gt; failure) =&gt; new(failure);
}

public record Some&lt;T&gt;(T Value);
public record None;

public class Option&lt;T&gt; : OneOfBase&lt;Some&lt;T&gt;, None&gt;
{
    private Option(OneOf&lt;Some&lt;T&gt;, None&gt; input) : base(input) { }

    public static implicit operator Option&lt;T&gt;(Some&lt;T&gt; some) =&gt; new(some);
    public static implicit operator Option&lt;T&gt;(None none) =&gt; new(none);
}

public static class EnumerableExtensions
{
    public static IEnumerable&lt;long&gt; LongRange(long start, long count)
    {
        for (long i = 0; i &lt; count; i++)
            yield return start + i;
    }

    public static IEnumerable&lt;int&gt; RangeStep(int start, int end, int step)
    {
        for (int i = start; i &lt;= end; i += step)
            yield return i;
    }
}
</code></pre>
<p>The logic and my notes:</p>
<pre><code>Context: 
* Get a list of ranges that may contain bad product ids
    * START-END
* bad product ids can be identified by going through the range and finding numbers that are repeated 55, 6464

Goal: 
* Find the sum of all the bad numbers

Sub problems: 
* A: Identify bad numbers
    * 1: Turn int to string, use two pointers to see if same
        * if odd length -&gt; no
        * if even try
            * two pointers across
* B: How to iterate ranges
    * 1: Brute force
        * Turn start, end to ints
        * Iterate from start to end
        * See if numbers are bad or not

Solutions: 
* A: Iterate ranges, check for bad - O(ranges * range * check)
    * Iterate ranges - O(ranges)
    * go through range - O(range)
        * check number 
        * if bad, add to accumulator - O(check)
</code></pre>
<p>Code:</p>
<pre><code>public static long Day2Part1(string[] lines)
{
    return lines
        .Select(l =&gt; l.Split(&#34;-&#34;).Select(n =&gt; long.Parse(n)).ToList())
        .Select(numbers =&gt; new NumberRange(Start: numbers[0], End: numbers[1]))
        .Aggregate(0L, (acc, range) =&gt;
            acc + EnumerableExtensions.LongRange(range.Start, range.End - range.Start + 1)
                .Select(n =&gt; ParseBadNumber(n))
                .Select(option =&gt; option.Match(some =&gt; some.Value, none =&gt; 0))
                .Sum()
        );
}

public static Option&lt;long&gt; ParseBadNumber(long inputNumber)
{
    var numberString = inputNumber.ToString();
    if(numberString.Length % 2 != 0)
    {
        return new None();
    }

    var midIndex = numberString.Length / 2;
    for(var i = 0; i &lt; midIndex; i++)
    {
        var firstNumber = numberString[i];
        var secondNumber = numberString[i + midIndex];
        if(firstNumber != secondNumber)
        {
            return new None();
        }
    }

    return new Some&lt;long&gt;(inputNumber);
}
</code></pre>
<h2 id="part-2">Part 2</h2>
<p>My notes:</p>
<pre><code>Part 2: 
* Bad numbers are now any number where they are created from a sequence of digits repeated at least twice
* So parseBadNumber makes sense BUT it&#39;s not always split in half - it may be more

Subproblems: 
* A: Is this a bad number
    * 0: Brute force matching
        * Foreach substring - check if it matches the other substrings
            * length 1 to length n / 2 - grab substring
            * See if the rest matches it
        * Optimization - only do this if the length is divisible by this substring size - else can&#39;t work
    * 1: Loop over numbers the number is divisible by, check substrings against each other
</code></pre>
<p>Code:</p>
<pre><code>public static long Day2Part2(string[] lines)
{
    return lines
        .Select(l =&gt; l.Split(&#34;-&#34;).Select(n =&gt; long.Parse(n)).ToList())
        .Select(numbers =&gt; new NumberRange(Start: numbers[0], End: numbers[1]))
        .Aggregate(0L, (acc, range) =&gt;
            acc + EnumerableExtensions.LongRange(range.Start, range.End - range.Start + 1)
                .Select(n =&gt; ParseBadNumber2(n))
                .Select(option =&gt; option.Match(some =&gt; some.Value, none =&gt; 0))
                .Sum()
        );
}

public static Option&lt;long&gt; ParseBadNumber2(long inputNumber)
{
    var numberString = inputNumber.ToString();
    var length = numberString.Length;
    if(length &lt;= 1) return new None();

    var divisibleLengths = Enumerable.Range(1, length-1)
        .Where(n =&gt; length % n == 0 &amp;&amp; n &lt; length)
        .ToList();

    var isBad = divisibleLengths.Any(divisibleLength =&gt;
        EnumerableExtensions.RangeStep(0, length - 1, divisibleLength)
            .Select(start =&gt; numberString.Substring(start, divisibleLength))
            .Distinct()
            .Count() == 1
    );

    return isBad 
        ? new Some&lt;long&gt;(inputNumber)
        : new None();
}
</code></pre>
<h2 id="next">Next</h2>
<p>C# wasn&#39;t so bad. It was a little clunky and I had to build out some core primitives to code in the way I want but this code really isn&#39;t <em>that</em> different than what I might do in F#.</p>
<p>If you liked this post you might also like :</p>
<ul>
<li><a href="https://hamy.xyz/tags/advent-of-code">See my previous Advent of Code submissions</a></li>
<li><a href="https://hamy.xyz/blog/2025-11_why-im-moving-blog-fsharp-to-csharp">Why I&#39;m Moving my Blog from F# to C#</a></li>
<li><a href="https://hamy.xyz/blog/2025-07_csharp-errors-vs-exceptions-benchmark">C# Errors vs Exceptions Performance Benchmarks</a></li>
</ul>
</div></div>
  </body>
</html>
