<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.quantamagazine.org/to-move-fast-quantum-maze-solvers-must-forget-the-past-20230720/">Original</a>
    <h1>To move fast, quantum maze solvers must forget the past</h1>
    
    <div id="readability-page-1" class="page"><div><p>Because the interference has to work out just right, not every computational task is amenable to a quantum speedup, and indeed researchers are <a href="https://www.quantamagazine.org/after-a-classical-clobbering-a-quantum-advantage-remains-20221207/">still working out</a> where quantum algorithms can help, decades after quantum computing was first proposed. But they’ve had some notable successes. In 1994, Peter Shor developed a <a href="https://ieeexplore.ieee.org/document/365700">quantum algorithm</a> for factoring large numbers — a task whose apparent difficulty for classical computers underlies much of modern cryptography. Shor’s algorithm could rapidly factor numbers so large that all known classical algorithms would be practically useless.</p>
<p>In 1996, the computer scientist Lov Grover found a second potentially practical example: a <a href="https://arxiv.org/abs/quant-ph/9605043">quantum algorithm</a> for a very generic search problem, one akin to finding a single item hidden inside one of many identical boxes.</p>
<p>“Classically, what you could do is just randomly try one and see if it’s good, and then try again and see if it’s good, and you keep on trying until you find a good element,” Apers said. This approach takes time proportional to the number of boxes. Multiply that number by 100, and the search will be 100 times slower.</p>
<p>With a quantum algorithm, you can do better. Grover proved that if you set up a superposition of all the boxes, you can exploit interference to practically guarantee that the algorithm will select the right box at the end. The whole process takes time proportional to the square root of the number of boxes: Increasing that number by a factor of 100 only increases the runtime by a factor of 10.</p>

<p>Grover’s algorithm was a remarkably simple illustration of the value of quantum superposition, but the speedup it achieved was relatively modest — tasks that were far beyond the reach of the best classical algorithms would also stump Grover’s algorithm. Shor’s factoring algorithm had offered a glimpse of a dramatic gulf between the capabilities of quantum and classical computers. Was there a variant of Grover’s search problem that was like factoring — practically intractable for classical computers yet easy for quantum computers?</p>
<p>In the late 1990s, researchers began exploring this question by reformulating it as a question about graphs — networks of points, or nodes, connected by lines, called edges. Any search problem can be framed in the language of graph theory, with one node representing the starting point, another node representing the destination, and edges representing the possible choices at each step along the way</p>
<p>Grover’s problem, for example, corresponds to searching a graph in which every node is connected to every other node (because you can open boxes in any order). Different classical algorithms for a given search problem amount to different strategies for exploring the corresponding graph one node at a time, while quantum algorithms can move along multiple edges in superposition.</p>
<h2><strong>Branching Out </strong></h2>
<p>In 2002, a team of computer scientists finally <a href="https://arxiv.org/abs/quant-ph/0209131">identified</a> a classically intractable search problem that a quantum algorithm could solve easily. They started with a simple graph called a tree, in which each node sprouts two edges leading to two more nodes, which each split into two more branches, and so on. Starting from a single “root” node, a tree graph branches many times before ending in a final layer of nodes called “leaves.” The team imagined taking two identical trees and “welding” them together by positioning them with the leaves facing each other and then using a random process to connect each leaf on one tree to two leaves on the other. They then posed the following question: Starting at one root of the welded tree graph, can you find your way to the other?</p>

<p>Without a bird’s-eye view of the graph, any classical algorithm that attempts to solve this search problem will get hopelessly lost after reaching the middle layers of the graph — all the edges look identical, and there’s no way to distinguish those that point forward from those leading backward. An algorithm might stumble upon the exit node accidentally, but the average time it spends wandering around grows exponentially with the number of layers in the tree.</p>
<p>The authors of the 2002 paper proved that a simple quantum algorithm — a “quantum walk” that spreads through the graph evenly by taking many paths in superposition — can find its way to the exit much faster. That’s because the symmetric layout of the welded tree graph leads to interference between paths that concentrates flow in the forward direction. The exit node is “like a focus point of the algorithm,” said <a href="http://home.lu.lv/~belovs/">Alexander Belov</a>, a computer scientist at the University of Latvia.</p>

<p>There’s a good chance that this quantum walk algorithm converges on the exit in time that’s merely proportional to the number of layers. That makes it exponentially faster than any classical algorithm — a speedup comparable to that of Shor’s factoring algorithm. But the interference that causes the quantum speedup also wipes out all record of the paths the algorithm traverses on its way to the exit.</p>
<p>Researchers wondered if there was some way to get the best of both worlds — a fast algorithm that identifies a path from entrance to exit.</p>
<p>“If it’s just the basic quantum walk that somehow finds the exit, that’s not going to work,” said <a href="http://www.cs.umd.edu/~amchilds/">Andrew Childs</a>, a computer scientist at the University of Maryland, College Park who co-authored the 2002 paper as a graduate student and worked with Coudron on the new result. “But maybe you could soup it up in some way.”</p>
<h2><strong>Souping It Up</strong></h2>
<p>Among the first to approach the problem was <a href="https://profs.provost.nagoya-u.ac.jp/html/100011885_en.html">Ansis Rosmanis</a>, a computer scientist now at the Nagoya University Graduate School of Mathematics. In a 2010 paper, Rosmanis developed a <a href="http://arxiv.org/abs/1004.4054">class of algorithms</a> that he dubbed “quantum snake walks,” which supplement the standard quantum walk algorithm with a memory of where they’ve been.</p>
<p>As the standard quantum walk algorithm flows through the graph, its next step depends solely on where it is currently — how it got there doesn’t matter. In Rosmanis’ snake walks, by contrast, you need to know the past to predict the future. Specifically, the evolution of the snake walk is determined by “snakes,” strings of adjacent nodes that the walk has previously passed through. There are many varieties of snake walks, differing among other respects in how the length of those snakes changes over the course of the walk.</p>
<p>Rosmanis showed that quantum snake walks using superpositions of multiple snakes could still exhibit helpful interference, despite remembering their trajectories, and that some snake walks could in principle find a path to the exit. But he couldn’t find a specific snake walk algorithm that did so quickly, and he also couldn’t prove that such an algorithm didn’t exist. Snake walks, it seemed, were promising, but too slippery to pin down. Rosmanis’ work was the last word on the path-finding problem for nearly a decade.</p>
</div></div>
  </body>
</html>
