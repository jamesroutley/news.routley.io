<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.khronos.org/blog/mesh-shading-for-vulkan">Original</a>
    <h1>Mesh Shading for Vulkan</h1>
    
    <div id="readability-page-1" class="page"><div id="khronosMainContent">

    
    <section>
        

        <div>
            <div>
            <div>











<article itemscope="" itemtype="http://schema.org/BlogPosting">


    
    
    


    
    



	
    
    <p><time itemprop="dateCreated" datetime="2022-09-01T06:00:00-07:00"><i></i> September 1, 2022</time>
        by 
        <span itemtype="keywords"><i></i>
        
            <a href="https://www.khronos.org/news/tags/tag/vulkan" title="vulkan">vulkan</a>
        </span>
    </p>
    
	<div itemprop="description">
    <h2>Introduction</h2>
<p>With the release of the <a href="https://github.com/KhronosGroup/Vulkan-Docs/blob/main/proposals/VK_EXT_mesh_shader.adoc">VK_EXT_mesh_shader</a> extension Vulkan gets an alternative geometry rasterization pipeline. This extension brings cross-vendor mesh shading to Vulkan, with a focus on improving functional compatibility with DirectX 12.</p>
<p>Mesh and Task shaders follow the compute programming model and use threads cooperatively to generate meshes within a workgroup. The vertex and index data for these meshes are written similarly to shared memory in compute shaders. Mesh shader output is directly consumed by the rasterizer, as opposed to the previous approach of using a compute dispatch followed by an indirect draw. Therefore mesh shading applications can avoid preallocation of output buffers.</p>


<figure>
<img src="https://www.khronos.org/assets/uploads/blogs/2022-blog-vulkan-Pipeline-comparison.jpg"/>
Figure 1: Pipeline comparison</figure>

<p>The new mesh shading pipeline with the task and mesh shading stages provides an alternative to the traditional vertex, tessellation or geometry shader stages that feed into rasterization (see Figure 1). The use of the task shader (amplification shader in DirectX) is optional and provides a way to implement geometry amplification by creating variable mesh shader workgroups directly in the pipeline. Task shader workgroups can output an optional payload, which is visible as read-only input to all its child mesh shader workgroups.</p>
<p>Before deciding to use mesh shaders, developers should ensure they are a good fit for their application. The traditional pipeline may still be best suited to many use cases, and it may not be trivial to improve performance using the mesh shading pipeline given the long evolution and optimization efforts applied to the traditional pipeline stages.</p>
<p>Applications and games dealing with high geometric complexity can, however, benefit from the flexibility of the two-stage approach, which allows efficient culling, level-of-detail techniques as well as procedural generation. Compared to the traditional pipeline, the mesh shaders allow easy access to the topology of the generated primitives and developers are free to repurpose the threads to do both vertex shading and primitive shading work. This is in contrast to tessellation shaders, which, while fast, provide very limited control over the triangles created, and geometry shaders, which use a single thread programming model that is inefficient for modern streaming processors. In addition to improving graphics performance, using the task and mesh shader stages without feeding into rasterization can also perform simple nested compute operations.</p>
<h2>Geometry Representation</h2>


<figure>
<img src="https://www.khronos.org/assets/uploads/blogs/2022-blog-vulkan-Stanford-bunny-model.jpg"/>
Figure 1: Pipeline comparison</figure>


<p>Figure 2: The Stanford bunny model represented as triangle clusters</p>
<p>When rasterizing geometry, mesh shaders typically make use of pre-computed triangle clusters (see Figure 2) of an upper bound in the number of vertices and triangles, also sometimes referred to as meshlets. Because task and mesh shaders, like compute, have only workgroup and invocation indices as input, all data fetching is handled by the application directly, which entirely removes fixed-function vertex processing and input assembly. This allows developers to be flexible in the storage of mesh data in both vertex and primitive topology representations. Another very common technique is to leverage the task shader and let one local invocation test one cluster for visibility. Through the use of subgroup operations developers can compute and write out information about the visible clusters into the task shader payload.</p>
<h2>Portability</h2>
<p>Compatibility with DirectX 12 was very important for this extension, therefore it follows the same capabilities, minimum limitations and restrictions. While it shares a lot of commonality with the existing VK_NV_mesh_shader extension, changes were made and the table below compares key details of all three definitions of mesh shading.</p>
<table>
<thead>
<tr>
<th> </th>
<th>DirectX 12</th>
<th>VK_EXT_mesh_shader</th>
<th>VK_NV_mesh_shader</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Optional expansion stage</strong></td>
<td>Amplification shader</td>
<td>Task shader</td>
<td>Task shader</td>
</tr>
<tr>
<td><strong>Supported primitives</strong></td>
<td>triangles, lines</td>
<td>triangles, lines, points</td>
<td>triangles, lines, points</td>
</tr>
<tr>
<td><strong>Grid dimensions</strong></td>
<td>3D</td>
<td>3D</td>
<td>1D</td>
</tr>
<tr>
<td><strong>Task shader output</strong></td>
<td><span>groupshared Type variable;</span></td>
<td><span>taskPayloadSharedEXT Type variable;</span></td>
<td><span>out taskNV { … };</span></td>
</tr>
<tr>
<td><strong>Task shader dispatching mesh shader workgroups</strong></td>
<td>Single workgroup-uniform call to </td>
<td>Single workgroup-uniform call to</td>
<td>Uses value written to <span>gl_TaskCountNV</span> as task shader workgroup completes.</td>
</tr>
<tr>
<td><strong>Mesh shader input</strong></td>
<td><span>in payload Type variable</span></td>
<td><span>taskPayloadSharedEXT Type variable;</span></td>
<td><span>in taskNV { … };</span></td>
</tr>
<tr>
<td><strong>Mesh shader output maximum size</strong></td>
<td><span>out vertices Type vertices[ VERTS ],</span></td>
<td><span>layout(</span></td>
<td><span>layout(</span></td>
</tr>
<tr>
<td><strong>Mesh shader output counts</strong></td>
<td><span>SetMeshOutputCounts(</span></td>
<td><span>SetMeshOutputsEXT(</span></td>
<td>Vertex count always max_vertices, primitive count set by <span>gl_PrimitiveCountNV</span></td>
</tr>
<tr>
<td><strong>Mesh shader output attributes</strong></td>
<td>Write-only, after SetMeshOutputCounts </td>
<td>Write-only, after SetMeshOutputsEXT </td>
<td>Read/write at any point (allows to avoid shared memory)</td>
</tr>
<tr>
<td><strong>Mesh shader output primitive indices</strong></td>
<td>Indices are an array of vectors. Write entire primitive at once</td>
<td>Indices are an array of vectors. Write entire primitive at once</td>
<td>Indices are an array of flat values (uint). Can write partial primitives. </td>
</tr>
<tr>
<td><strong>Mesh shader per-primitive culling</strong></td>
<td><span>primitives[idx].SV_CullPrimitive</span></td>
<td><span>gl_MeshPrimitivesEXT[idx].gl_CullPrimitiveEXT</span></td>
<td>Not directly supported</td>
</tr>
<tr>
<td><strong>Basic function call</strong></td>
<td><span>DispatchMesh(x, y, z);</span></td>
<td><span>vkCmdDrawMeshTasksEXT(... x, y, z);</span></td>
<td><span>vkCmdDrawMeshTasksNV(... x, xOffset);</span></td>
</tr>
</tbody>
</table>
<p>It is important to note, that while portability between APIs can be achieved, portability in performance among vendors is much harder. This is one of the reasons why this extension has not been released as a ratified KHR extension and Khronos continues to investigate improvements to geometry rasterization.</p>
<p>To improve the situation a little bit, VK_EXT_mesh_shader introduces various preferences that can be queried through VkPhysicalDeviceMeshShaderPropertiesEXT, and developers are encouraged to respect these in order to generate optimal shader permutations.</p>
<table>
<thead>
<tr>
<th><strong>VkPhysicalDeviceMeshShaderPropertiesEXT members for vendor preferences</strong></th>
<th><strong>Description of mesh shader behavior</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><span>maxPreferredTaskWorkGroupInvocations</span></td>
<td>
<p>While the minimum for <span>maxTaskWorkGroupInvocations </span>and <span>maxMeshWorkGroupInvocations </span>does match DirectX 12, these values reflect the preferred sizing of the workgroup.</p>
</td>
</tr>
<tr>
<td><span>prefersLocalInvocationVertexOutput</span></td>
<td>If true, the vertex/primitive output arrays should be indexed by the gl_LocalInvocationIndex. This also implies that the mesh shader workgroup size should match the number of output vertices and primitives. </td>
</tr>
<tr>
<td><span>prefersCompactVertexOutput </span></td>
<td>Indicates that the vertex output array should be compact (without gaps between vertices). This way only as much output space may be reserved as needed, which may improve performance. </td>
</tr>
<tr>
<td><span>prefersCompactPrimitiveOutput</span></td>
<td>Similar to the above. Indicates whether the primitive output array should be compact (without gaps).</td>
</tr>
</tbody>
</table>
<p>There are further aspects that can influence the performance of mesh shaders in a vendor dependent way:</p>
<ul>
<li aria-level="1">The number of maximum output vertices and primitives that a mesh shader is compiled with.</li>
<li aria-level="1">The number of per-vertex and per-primitive output attributes that are passed to fragment shaders. For example, it may be beneficial to fetch additional attributes in the fragment shader and interpolate them via hardware barycentrics to reduce the output space of the mesh shader.</li>
<li aria-level="1">The complexity of the culling performed in the mesh shader. For example details regarding the per-vertex and/or per-primitive culling with compact outputs compared to letting the hardware perform culling.</li>
<li aria-level="1">The usage of additional shared memory. If possible developers should use subgroup operations (such as shuffle) instead.</li>
<li aria-level="1">The task payload size.</li>
<li aria-level="1">Task shaders may add overhead, use them only when they can cull a meaningful number of primitives or when actual geometry amplification is desired.</li>
<li aria-level="1">Do not try to reimplement the fixed-function pipeline, strive for simpler algorithms instead.</li>
</ul>
<p>The meshlet / primitive cluster dimensions can have an especially big impact for the developer, as when streaming it is ideal to store assets with a fixed clustering in advance. Vendors may have different performance recommendations and so we suggest the use of smaller cluster sizes that work equally well across multiple vendors and process multiple small clusters at once on implementations that perform better with larger clusters. In this area we advise developers to experiment and consult with their hardware vendors for recommendations.</p>
<p>The open source sample <a href="https://github.com/nvpro-samples/gl_vk_meshlet_cadscene">https://github.com/nvpro-samples/gl_vk_meshlet_cadscene</a> has been updated to support and showcase the <a href="https://github.com/KhronosGroup/Vulkan-Docs/blob/main/proposals/VK_EXT_mesh_shader.adoc">VK_EXT_mesh_shader</a> extension. Please note that the shaderc library in the Vulkan SDK may not be updated to the necessary version yet, but this is coming soon.</p>
<h2>Further reading</h2>
<ul>
<li><a href="https://developer.nvidia.com/blog/introduction-turing-mesh-shaders/">Introduction to Turing Mesh Shaders | NVIDIA Technical Blog</a></li>
<li><a href="https://developer.nvidia.com/blog/using-mesh-shaders-for-professional-graphics/">Using Mesh Shaders for Professional Graphics | NVIDIA Technical Blog</a></li>
<li><a href="https://gpuopen.com/wp-content/uploads/slides/AMD_RDNA2_DirectX12_Ultimate_SamplerFeedbackMeshShaders.pdf">AMD GPU Open SAMPLER FEEDBACK &amp; MESH SHADERS </a></li>
<li><a href="https://timur.hu/blog/2022/mesh-and-task-shaders">Mesh and task shader intro and basics | Timur&#39;s Blog</a></li>
</ul>




    </div>

    <a data-sumome-share-id="1a3f13c4-0a97-49b6-89e0-5023464d2a6d"></a>


    

    


    

</article>

<h2>Comments</h2>












	

			</div>

            

			</div>
		</div>
	</section>
</div></div>
  </body>
</html>
