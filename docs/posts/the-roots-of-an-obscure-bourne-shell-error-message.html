<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/BourneShellObscureErrorRoots">Original</a>
    <h1>The roots of an obscure Bourne shell error message</h1>
    
    <div id="readability-page-1" class="page"><div><h2>The roots of an obscure Bourne shell error message</h2>

	<p><small>September 10, 2023</small></p>
</div><div><p>Suppose that you&#39;re writing Bourne shell code that involves using
some commands in a subshell to capture some information into a shell
variable, &#39;AVAR=$(....)&#39;, but you accidentally write it with a space
after the &#39;=&#39;. Then you will get something like this:</p>

<blockquote><pre>$ AVAR= $(... | wc -l)
sh: 107: command not found
</pre>
</blockquote>

<p>So, why is this an error at all, and why do we get this weird and
obscure error message? In the traditional Unix and Bourne shell way,
this arises from a series of decisions that were each sensible in
isolation.</p>

<p>To start with, we can set shell variables and their grown up friends
environment variables with &#39;<code>AVAR=value</code>&#39; (note the lack of spaces).
You can erase the value of a shell variable (but not unset it) by
leaving the value out, &#39;<code>AVAR=</code>&#39;. Let&#39;s illustrate:</p>

<blockquote><pre>$ export FRED=value
$ printenv | fgrep FRED
FRED=value
$ FRED=
$ printenv | fgrep FRED
FRED=
$ unset FRED
$ printenv | fgrep FRED
$ # ie, no output from printenv
</pre>
</blockquote>

<p>Long ago, the Bourne shell recognized that you might want to only
temporarily set the value of an environment variable for a single
command. It was decided that this was a common enough thing that
there should be a special syntax for it:</p>

<blockquote><pre>$ PATH=/special/bin:$PATH FRED=value acommand
</pre>
</blockquote>

<p>This runs &#39;<code>acommand</code>&#39; with $PATH changed and $FRED set to a value,
without changing (or setting) either of them for anything else. We
have now armed one side of our obscure error, because if we write
&#39;_AVAR= ....&#39; (with the space), the Bourne shell will assume that
we&#39;re temporarily erasing the value of $AVAR (or setting it to a
blank value) for a single command.</p>

<p>The second part is that the Bourne shell allows commands to be
run to be named through indirection, instead of having to be
written out directly and literally. In Bourne shell, you can
do this:</p>

<blockquote><pre>$ cmd=echo; $cmd hello world
hello world
$ cmd=&#34;echo hi there&#34;; $cmd
hi there
</pre>
</blockquote>

<p>The Bourne shell doesn&#39;t restrict this indirection to direct expansion
of environment variables; any and all expansion operations can be
used to generate the command to be run and some or all of its
arguments.  This includes subshell expansion, which is written
either as <code>$(...)</code> in the modern way or as <code>`...`</code> in the old way
(those are backticks, which may be hard to see in some fonts).
Doing this even for &#39;$(...)&#39; is reasonably sensible, probably
sometimes useful, and definitely avoids making $(...) a special
case here.</p>

<p>So now we have our perfect storm. If you write &#39;<code>AVAR= $(....)</code>&#39;,
the Bourne shell first sees &#39;<code>AVAR= </code>&#39; (with the space) and interprets
it as you running some command with $AVAR set to a blank value.
Then it takes the &#39;$(...)&#39; and uses it to generate the command to
run (and its command line). When your subshell prints out its results,
for example the number of lines reported by &#39;<code>wc -l</code>&#39;, the Bourne shell
will try to use that as a command and fail, resulting in our weird and
obscure error message. What you&#39;ve accidentally written is similar to:</p>

<blockquote><pre>$ cmd=$(... | wc -l)
$ AVAR= $cmd
</pre>
</blockquote>

<p>(Assuming that the $(...) subshell doesn&#39;t do anything different
based on $AVAR, which it probably doesn&#39;t.)</p>

<p>It&#39;s hard to see any simple change in the Bourne shell that could
avoid this error, because each of the individual parts are sensible
in isolation. It&#39;s only when they combine together like this that a
simple mistake compounds into a weird error message.</p>

<p>(The good news is that <a href="https://www.shellcheck.net">shellcheck</a>
warns about both parts of this, in <a href="https://www.shellcheck.net/wiki/SC1007">SC1007</a> and <a href="https://www.shellcheck.net/wiki/SC2091">SC2091</a>.)</p>
</div></div>
  </body>
</html>
