<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://plf.inf.ethz.ch/research/pldi25-tree-borrows.html">Original</a>
    <h1>Tree Borrows</h1>
    
    <div id="readability-page-1" class="page"><div>
        <!-- header -->
        <header>
    

	


    

<!-- navigation -->
    
    
    
</header><!-- content -->
        <section id="content">
            <!-- breadcrumb -->
            
	
	    
	        <nav role="navigation" aria-label="Breadcrumb">
	            
	        </nav>
	    
	

<div id="contentContainer">
                <!-- START main content -->
                <section id="contentMain">
                    
<a id="mainContent"></a>

    <!-- lead -->
    <!-- page images -->
    <!-- children nav -->
    
<!-- parsys -->
    <div><div>


<div>




    




    
        
            
            
                <div>
                    <div>
                        <figure>
            <img alt="Fig.1 from the paper, showing the Tree Borrows state machine" src="https://plf.inf.ethz.ch/research/pldi25-tree-borrows/_jcr_content/par/image/image.imageformat.1286.615588779.svg"/>
			<figcaption>
			    <p>
			      The state machine at the heart of Tree Borrows.</p>
			  </figcaption>
			</figure>
    
                    </div>
                </div>
             
            
        
    
    




</div>
<div>


    
        <div>
            <div>
                
                
                <p>The Rust programming language is well known for its ownership-based type system, which offers strong guarantees like memory safety and data race freedom. However, Rust also provides <i>unsafe</i> escape hatches, for which safety is not guaranteed automatically and must instead be manually upheld by the programmer. This creates a tension. On the one hand, compilers would like to exploit the strong guarantees of the type system—particularly those pertaining to aliasing of pointers—in order to unlock powerful intraprocedural optimizations. On the other hand, those optimizations are easily invalidated by &#34;badly behaved&#34; unsafe code. To ensure correctness of such optimizations, it thus becomes necessary to clearly define what unsafe code is &#34;badly behaved.&#34; In prior work, <i><a href="https://plv.mpi-sws.org/rustbelt/stacked-borrows/"><span>external page </span>Stacked Borrows</a></i> defined a set of rules achieving this goal. However, Stacked Borrows rules out several patterns that turn out to be common in real-world unsafe Rust code, and it does not account for advanced features of the Rust borrow checker that were introduced more recently.</p> 
<p>To resolve these issues, we present <i>Tree Borrows</i>. As the name suggests, Tree Borrows is defined by replacing the stack at the heart of Stacked Borrows with a tree. This overcomes the aforementioned limitations: our evaluation on the 30 000 most widely used Rust crates shows that Tree Borrows rejects 54% fewer test cases than Stacked Borrows does. Additionally, we prove (in Rocq) that it retains most of the Stacked Borrows optimizations and also enables important new ones, notably read-read reorderings.</p>
            </div>
        </div>
    
    

</div>

<div>


    
        <div>
            <p>Received a <b>Distinguished Paper Award</b> at <b>PLDI&#39;25</b></p>
        </div>
    
    

</div>
</div></div>
<!-- Rightside Parsys -->
    </section>
                <!-- END main content -->           
            </div>        
        </section>

        
<!-- footer -->
        
</div></div>
  </body>
</html>
