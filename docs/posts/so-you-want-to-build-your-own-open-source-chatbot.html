<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hacks.mozilla.org/2023/07/so-you-want-to-build-your-own-open-source-chatbot/">Original</a>
    <h1>So you want to build your own open source chatbot</h1>
    
    <div id="readability-page-1" class="page"><article role="article">
    <p><i>(Expanded from </i><a href="https://sched.co/1O37L"><i>a talk</i></a><i> given at </i><a href="https://dwebcamp.org/"><i>DWeb Camp 2023</i></a><i>.)</i></p>
<p>Artificial intelligence may well prove one of the most impactful and disruptive technologies to come along in years. This impact isn’t theoretical: AI is already affecting real people in substantial ways, and it’s already changing the Web that we know and love. Acknowledging the potential for both benefit and harm, Mozilla has committed itself to the principles of <a href="https://foundation.mozilla.org/en/internet-health/trustworthy-artificial-intelligence/"><b>trustworthy AI</b></a>. To us, “trustworthy” means AI systems that are transparent about the data they use and the decisions they make, that respect user privacy, that prioritize user agency and safety, and that work to minimize bias and promote fairness.</p>
<h2>Where things stand</h2>
<p>Right now, the primary way that most people are experiencing the latest AI technology is through <b>generative AI chatbots</b>. These tools are exploding in popularity because they provide a lot of value to users, but the dominant offerings (like ChatGPT and Bard) are all operated by powerful tech companies, often utilizing technologies that are proprietary.</p>
<p>At Mozilla, we believe in the collaborative power of <b>open source</b> to empower users, drive transparency, and — perhaps most importantly — ensure that technology does not develop only according to the worldviews and financial motivations of a small group of corporations. Fortunately, there’s recently been rapid and exciting progress in the open source AI space, specifically around the <b>large language models</b> (LLMs) that power these chatbots and the tooling that enables their use. We want to understand, support, and contribute to these efforts because we believe that they offer one of the best ways to help ensure that the AI systems that emerge are truly trustworthy.</p>
<h2>Digging in</h2>
<p>With this goal in mind, a small team within Mozilla’s innovation group recently undertook a hackathon at our headquarters in San Francisco. Our objective: <b>build a Mozilla internal chatbot prototype</b>, one that’s…</p>
<ul>
<li aria-level="1">Completely <b>self-contained</b>, running entirely on Mozilla’s cloud infrastructure, without any dependence on third-party APIs or services.</li>
<li aria-level="1">Built with <b>free, open source</b> large language models and tooling.</li>
<li aria-level="1"><b>Imbued</b> with Mozilla’s beliefs, from trustworthy AI to the principles espoused by the <a href="https://www.mozilla.org/en-US/about/manifesto/">Mozilla Manifesto</a>.</li>
</ul>
<p>As a bonus, we set a stretch goal of integrating some amount of internal Mozilla-specific knowledge, so that the chatbot can answer employee questions about internal matters.</p>
<p>The Mozilla team that undertook this project — <a href="https://yetanotherjosh.com/">Josh Whiting</a>, <a href="https://www.rupertparry.com/">Rupert Parry</a>, and <a href="https://stephenhood.com">myself</a> — brought varying levels of machine learning knowledge to the table, but none of us had ever built a full-stack AI chatbot. And so, another goal of this project was simply to roll-up our sleeves and learn!</p>
<p><b>This post is about sharing that learning</b>, in the hope that it will help or inspire you in your own explorations with this technology. Assembling an open source LLM-powered chatbot turns out to be a complicated task, requiring many decisions at multiple layers of the technology stack. In this post, I’ll take you through each layer of that stack, the challenges we encountered, and the decisions we made to meet our own specific needs and deadlines. YMMV, of course.</p>
<p>Ready, then? Let’s begin, starting at the bottom of the stack…</p>
<p><a href="https://hacks.mozilla.org/files/2023/07/Mozilla-Assistant-diagram.png"><img decoding="async" src="https://hacks.mozilla.org/files/2023/07/Mozilla-Assistant-diagram-500x356.png" alt="A diagram depicting seven levels of functionality and decisions required to build an open source chatbot." width="500" height="356" srcset="https://hacks.mozilla.org/files/2023/07/Mozilla-Assistant-diagram-500x356.png 500w, https://hacks.mozilla.org/files/2023/07/Mozilla-Assistant-diagram-250x178.png 250w, https://hacks.mozilla.org/files/2023/07/Mozilla-Assistant-diagram-768x547.png 768w, https://hacks.mozilla.org/files/2023/07/Mozilla-Assistant-diagram-1536x1094.png 1536w, https://hacks.mozilla.org/files/2023/07/Mozilla-Assistant-diagram-2048x1459.png 2048w" sizes="(max-width: 500px) 100vw, 500px"/></a><i>A visual representation of our chatbot exploration.</i></p>
<h2>Deciding where and how to host</h2>
<p>The first question we faced was where to run our application. There’s no shortage of companies both large and small who are eager to host your machine learning app. They come in all shapes, sizes, levels of abstraction, and price points.</p>
<p>For many, these services are well worth the money. Machine learning ops (aka “MLOps”) is a growing discipline for a reason: deploying and managing these apps is <i>hard</i>. It requires specific knowledge and skills that many developers and ops folks don’t yet have. And the cost of failure is high: poorly configured AI apps can be slow, expensive, deliver a poor quality experience, or all of the above.</p>
<p><b>What we did</b>: Our explicit goal for this one-week project was to build a chatbot that was secure and fully-private to Mozilla, with no outside parties able to listen in, harvest user data, or otherwise peer into its usage. We also wanted to learn as much as we could about the state of open source AI technology. We therefore elected to forego any third-party AI SaaS hosting solutions, and instead <b>set up our own virtual server inside Mozilla’s existing Google Cloud Platform (GCP) account</b>. In doing so, we effectively committed to doing MLOps ourselves. But we could also move forward with confidence that our system would be private and fully under our control.</p>
<h2>Picking a runtime environment</h2>
<p>Using an LLM to power an application requires having a runtime engine for your model. There are a variety of ways to actually run LLMs, but due to time constraints we didn’t come close to investigating all of them on this project. Instead, we focused on two specific open source solutions: <i>llama.cpp</i> and the Hugging Face ecosystem.</p>
<p>For those who don’t know, <a href="http://huggingface.co/">Hugging Face</a> is an influential startup in the machine learning space that has played a significant role in popularizing the <a href="https://en.wikipedia.org/wiki/Transformer_(machine_learning_model)">transformer architecture</a> for machine learning. Hugging Face provides a complete platform for building machine learning applications, including a massive library of models, and extensive tutorials and documentation. They also provide <a href="https://huggingface.co/inference-endpoints">hosted APIs</a> for text inference (which is the formal name for what an LLM-powered chatbot is doing behind the scenes).</p>
<p>Because we wanted to avoid relying on anyone else’s hosted software, we elected to try out the open source version of Hugging Face’s hosted API, which is found at the <a href="https://github.com/huggingface/text-generation-inference"><i>text-generation-inference</i></a> project on GitHub. <i>text-generation-inference</i> is great because, like Hugging Face’s own <i>Transformers</i> library, it can support a wide variety of models and model architectures (more on this in the next section). It’s also optimized for supporting multiple users and is deployable via Docker.</p>
<p>Unfortunately, this is where we first started to run into the fun challenges of learning MLOps on the fly. We had a lot of trouble getting the server up and running. This was in part an environment issue: since Hugging Face’s tools are GPU-accelerated, our server needed a specific combination of OS, hardware, and drivers. It specifically needed NVIDIA’s <a href="https://developer.nvidia.com/cuda-toolkit">CUDA toolkit</a> installed (CUDA being the dominant API for GPU-accelerated machine learning applications). We struggled with this for much of a day before finally getting a model running live, but even then the output was slower than expected and the results were vexingly poor — both signs that something was still amiss somewhere in our stack.</p>
<p>Now, I’m not throwing shade at this project. Far from it! We love Hugging Face, and building on their stack offers a number of advantages. I’m certain that if we had a bit more time and/or hands-on experience we would have gotten things working. But time was a luxury we didn’t have in this case. Our intentionally-short project deadline meant that we couldn’t afford to get too deeply mired in matters of configuration and deployment. We needed to get something working quickly so that we could keep moving and keep learning.</p>
<p>It was at this point that we shifted our attention to <a href="https://github.com/ggerganov/llama.cpp"><i>llama.cpp</i></a>, an open source project started by <a href="https://ggerganov.com/">Georgi Gerganov</a>. <i>llama.cpp</i> accomplishes a rather neat trick: it makes it easy to run a certain class of LLMs on consumer grade hardware, relying on the CPU instead of requiring a high-end GPU. It turns out that modern CPUs (particularly Apple Silicon CPUs like the M1 and M2) can do this surprisingly well, at least for the latest generation of relatively-small open source models.</p>
<p><i>llama.cpp</i> is an amazing project, and a beautiful example of the power of open source to unleash creativity and innovation. I had already been using it in my own personal AI experiments and had even written-up <a href="https://uniquehazards.com/2023/05/06/the-complete-idiots.html">a blog post</a> showing how <i>anyone</i> can use it to run a high-quality model on their own MacBook. So it seemed like a natural thing for us to try next.</p>
<p>While <i>llama.cpp</i> itself is simply a command-line executable — the “cpp” stands for “C++” —  it can be dockerized and run like a service. Crucially, a set of <a href="https://github.com/abetlen/llama-cpp-python">Python bindings</a> are available which expose an implementation of the <a href="https://platform.openai.com/docs/api-reference">OpenAI API specification</a>. What does all that mean? Well, it means that <em>llama.cpp</em> makes it easy to slot-in <em>your own</em> LLM in place of ChatGPT. This matters because OpenAI’s API is being rapidly and widely adopted by machine learning developers. Emulating that API is a clever bit of Judo on the part of open source offerings like <em>llama.cpp.</em></p>
<p><b>What we did</b>: With these tools in hand, we were able to get <i>llama.cpp</i> up and running very quickly. Instead of worrying about CUDA toolkit versions and provisioning expensive hosted GPUs, we were able to spin up a simple AMD-powered multicore CPU virtual server and just… go.</p>
<h2>Choosing your model</h2>
<p>An emerging trend you’ll notice in this narrative is that every decision you make in building a chatbot interacts with every other decision. There are no easy choices, and there is no free lunch. The decisions you make <i>will</i> come back to haunt you.</p>
<p>In our case, choosing to run with <i>llama.cpp</i> introduced an important consequence: we were now limited in the list of models available to us.</p>
<p>Quick history lesson: in late 2022, <a href="https://ai.facebook.com/blog/large-language-model-llama-meta-ai/">Facebook announced LLaMa</a>, its own large language model. To grossly overgeneralize, LLaMa consists of two pieces: the model data itself, and the architecture upon which the model is built. Facebook open sourced the LLaMa architecture, but they didn’t open source the model data<i>.</i> Instead, people wishing to work with this data need to apply for permission to do so, and their use of the data is limited to non-commercial purposes.</p>
<p>Even so, LLaMa immediately fueled a Cambrian explosion of model innovation. Stanford released <a href="https://crfm.stanford.edu/2023/03/13/alpaca.html">Alpaca</a>, which they created by building on top of LLaMa via a process called <a href="https://en.wikipedia.org/wiki/Fine-tuning_(machine_learning)">fine-tuning</a>. A short time later, <a href="https://lmsys.org/about/">LMSYS</a> released <a href="https://lmsys.org/blog/2023-03-30-vicuna/">Vicuna</a>, an arguably even more impressive model. There are dozens more, if not hundreds.</p>
<p>So what’s the fine print? These models were all developed using Facebook’s model data — in machine learning parlance, the “weights.” Because of this, they inherit the legal restrictions Facebook imposed upon those original weights. This means that these otherwise-excellent models <b>can’t be used for commercial purposes</b>. And so, sadly, we had to strike them from our list.</p>
<p>But there’s good news: even if the LLaMa weights aren’t truly open, the underlying <i>architecture</i> is proper <a href="https://github.com/facebookresearch/llama">open source code</a>. This makes it possible to build new models that leverage the LLaMa architecture but do not rely on the LLaMa weights. Multiple groups have done just this, training their own models from scratch and releasing them as open source (via MIT, Apache 2.0, or Creative Commons licenses). Some recent examples include <a href="https://github.com/openlm-research/open_llama">OpenLLama</a>, and — just days ago — <a href="https://ai.meta.com/llama/">LLaMa 2</a>, a brand new version of Facebook’s LLaMa model, from Facebook themselves, but this time expressly licensed for commercial use (although its numerous other legal encumbrances raise serious questions of whether it is truly open source).</p>
<h2>Hello, consequences</h2>
<p>Remember <i>llama.cpp</i>? The name isn’t an accident. <i>llama.cpp</i> runs LLaMa architecture-based models. This means we were able to take advantage of the above models for our chatbot project. But it also meant that we could <i>only</i> use LLaMa architecture-based models.</p>
<p>You see, there are plenty of other model architectures out there, and many more models built atop them. The list is too long to enumerate here, but a few leading examples include <a href="https://www.mosaicml.com/blog/mpt-7b">MPT</a>, <a href="https://falconllm.tii.ae/">Falcon</a>, and <a href="https://github.com/LAION-AI/Open-Assistant">Open Assistant</a>. These models utilize different architectures than LLaMa and thus (for now) do not run on<i> llama.cpp</i>. That means we couldn’t use them in our chatbot, no matter how good they might be.</p>
<h2>Models, biases, safety, and you</h2>
<p>Now, you may have noticed that so far I’ve only been talking about model selection from the perspectives of licensing and compatibility. There’s a whole other set of considerations here, and they’re related to the qualities of the model itself.</p>
<p>Models are one of the focal points of Mozilla’s interest in the AI space. That’s because your choice of model is currently the biggest determiner of how “trustworthy” your resulting AI will be. Large language models are trained on vast quantities of data, and are then further fine-tuned with additional inputs to adjust their behavior and output to serve specific uses. The data used in these steps represents an inherent curatorial choice, and that choice carries with it <b>a raft of biases</b>.</p>
<p>Depending on which sources a model was trained on, it can exhibit wildly different characteristics. It’s well known that some models are prone to hallucinations (the machine learning term for what are essentially nonsensical responses invented by the model from whole cloth), but far more insidious are the many ways that models can choose to — or refuse to — answer user questions. These responses reflect the biases of the model itself. They can result in the sharing of toxic content, misinformation, and dangerous or harmful information. Models may exhibit biases against concepts, or groups of people. And, of course, the elephant in the room is that the vast majority of the training material available online today is in the English language, which has a predictable impact both on who can use these tools and the kinds of worldviews they’ll encounter.</p>
<p>While there are plenty of resources for assessing the raw power and “quality” of LLMs (one popular example being Hugging Face’s <a href="https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard">Open LLM leaderboard</a>), it is still challenging to evaluate and compare models in terms of sourcing and bias. This is an area in which Mozilla thinks open source models have the potential to shine, through the greater transparency they can offer versus commercial offerings.</p>
<p><b>What we did</b>: After limiting ourselves to commercially-usable open models running on the LLaMa architecture, we carried out a manual evaluation of several models. This evaluation consisted of asking each model a diverse set of questions to compare their resistance to toxicity, bias, misinformation, and dangerous content. Ultimately, <b>we settled on Facebook’s new LLaMa 2 model for now</b>. We recognize that our time-limited methodology may have been flawed, and we are not fully comfortable with the licensing terms of this model and what they may represent for open source models more generally, so don’t consider this an endorsement. We expect to reevaluate our model choice in the future as we continue to learn and develop our thinking.</p>
<h2>Using embedding and vector search to extend your chatbot’s knowledge</h2>
<p>As you may recall from the opening of this post, we set ourselves a stretch goal of integrating some amount of internal Mozilla-specific knowledge into our chatbot. The idea was simply to build a proof-of-concept using a small amount of internal Mozilla data — facts that employees would have access to themselves, but which LLMs ordinarily would not.</p>
<p>One popular approach for achieving such a goal is to use <b>vector search with embedding</b>. This is a technique for making custom external documents available to a chatbot, so that it can utilize them in formulating its answers. This technique is both powerful and useful, and in the months and years ahead there’s likely to be a lot of innovation and progress in this area. There are already a variety of open source and commercial tools and services available to support embedding and vector search.</p>
<p>In its simplest form, it works generally like this:</p>
<ul>
<li aria-level="1">The data you wish to make available must be retrieved from wherever it is normally stored and converted to <strong>embeddings</strong> using a separate model, called an <strong>embedding model</strong>. These embeddings are indexed in a place where the chatbot can access it, called a <strong>vector database</strong>.</li>
<li aria-level="1">When the user asks a question, the chatbot <strong>searches</strong> the vector database for any content that might be related to the user’s query.</li>
<li aria-level="1">The returned, relevant content is then passed into the primary model’s <strong>context window</strong> (more on this below) and is used in formulating a response.</li>
</ul>
<p><b>What we did</b>: Because we wanted to retain full control over all of our data, we declined to use any third-party embedding service or vector database. Instead, we coded up a manual solution in Python that utilizes the <a href="https://huggingface.co/sentence-transformers/all-mpnet-base-v2"><i>all-mpnet-base-v2</i></a> embedding model, the <a href="https://www.sbert.net/">SentenceTransformers</a> embedding library, <a href="https://python.langchain.com/docs/get_started/introduction.html">LangChain</a> (which we’ll talk about more below), and the <a href="https://github.com/facebookresearch/faiss">FAISS</a> vector database. We only fed in a handful of documents from our internal company wiki, so the scope was limited. But as a proof-of-concept, it did the trick.</p>
<h2>The importance of prompt engineering</h2>
<p>If you’ve been following the chatbot space at all you’ve probably heard the term “prompt engineering” bandied about. It’s not clear that this will be an enduring discipline as AI technology evolves, but for the time being <b>prompt engineering is a very real thing</b>. And it’s one of the most crucial problem areas in the whole stack.</p>
<p>You see, LLMs are fundamentally <b>empty-headed</b>. When you spin one up, it’s like a robot that’s just been powered on for the first time. It doesn’t have any memory of its life before that moment. It doesn’t remember you, and it certainly doesn’t remember your past conversations. It’s <i>tabula rasa</i>, every time, all the time.</p>
<p>In fact, it’s even worse than that. Because LLMs don’t even have <i>short-term</i> memory. Without specific action on the part of developers, chatbots can’t even remember the last thing they said to you. Memory doesn’t come naturally to LLMs; it has to be <i>managed</i>. This is where prompt engineering comes in. It’s one of the key jobs of a chatbot, and it’s a big reason why leading bots like ChatGPT are so good at keeping track of ongoing conversations.</p>
<p>The first place that prompt engineering rears its head is in the initial instructions you feed to the LLM. This <b>system prompt</b> is a way for you, in plain language, to tell the chatbot what its function is and how it should behave. We found that this step alone merits a significant investment of time and effort, because its impact is so keenly felt by the user.</p>
<p>In our case, we wanted our chatbot to follow the principles in the Mozilla Manifesto, as well as our company policies around respectful conduct and nondiscrimination. Our testing showed us in stark detail just how <span role="heading" aria-level="1">suggestible</span> these models are. In one example, we asked our bot to give us evidence that the Apollo moon landings were faked. When we instructed the bot to refuse to provide answers that are untrue or are misinformation, it would correctly insist that the moon landings were in fact <i>not</i> faked — a sign that the model seemingly “understands” at some level that claims to the contrary are conspiracy theories unsupported by the facts. And yet, when we updated the system prompt by removing this prohibition against misinformation, the very same bot was perfectly happy to recite a bulleted list of the typical Apollo denialism you can find in certain corners of the Web.</p>
<p>You are a helpful assistant named Mozilla Assistant.</p>
<p><i>The system prompt we designed for our chatbot.</i></p>
<p>Another important concept to understand is that every LLM has a maximum length to its “memory”. This is called its <b>context window</b>, and in most cases it is determined when the model is trained and cannot be changed later. The larger the context window, the longer the LLM’s memory about the current conversation. This means it can refer back to earlier questions and answers and use them to maintain a sense of the conversation’s context (hence the name). A larger context window also means that you can include larger chunks of content from vector searches, which is no small matter.</p>
<p>Managing the context window, then, is another critical aspect of prompt engineering. It’s important enough that there are solutions out there to help you do it (which we’ll talk about in the next section).</p>
<p><b>What we did</b>: Since our goal was to have our chatbot behave as much like a fellow Mozilian as possible, we ended up devising our own custom system prompt based on elements of our Manifesto, our participation policy, and other internal documents that guide employee behaviors and norms at Mozilla. We then massaged it repeatedly to reduce its length as much as possible, so as to preserve our context window. As for the context window itself, we were stuck with what our chosen model (LLaMa 2) gave us: 4096 tokens, or roughly 3000 words. In the future, we’ll definitely be looking at models that support larger windows.</p>
<h2>Orchestrating the whole dance</h2>
<p>I’ve now taken you through (*<i>checks notes*</i>) five whole layers of functionality and decisions. So what I say next probably won’t come as a surprise: there’s a lot to manage here, and you’ll need a way to manage it.</p>
<p>Some people have lately taken to calling that <b>orchestration</b>. I don’t personally love the term in this context because it already has a long history of other meanings in other contexts. But I don’t make the rules, I just blog about them.</p>
<p>The leading orchestration tool right now in the LLM space is <a href="https://python.langchain.com/docs/get_started/introduction.html">LangChain</a>, and it is a marvel. It has a feature list a mile long, it provides astonishing power and flexibility, and it enables you to build AI apps of all sizes and levels of sophistication. But with that power comes quite a bit of complexity. Learning LangChain isn’t necessarily an easy task, let alone harnessing its full power. You may be able to guess where this is going…</p>
<p><b>What we did</b>: We used LangChain only very minimally, to power our embedding and vector search solution. Otherwise, we ended up steering clear. Our project was simply too short and too constrained for us to commit to using this specific tool. Instead, we were able to accomplish most of our needs with a relatively small volume of Python code that we wrote ourselves. This code “orchestrated” everything going on the layers I’ve already discussed, from injecting the agent prompt, to managing the context window, to embedding private content, to feeding it all to the LLM and getting back a response. That said, given more time we most likely would <i>not</i> have done this all manually, as paradoxical as that might sound.</p>
<h2>Handling the user interface</h2>
<p>Last but far from least, we have reached the top layer of our chatbot cake: the user interface.</p>
<p>OpenAI set a high bar for chatbot UIs when they launched ChatGPT. While these interfaces may look simple on the surface, that’s more a tribute to good design than evidence of a simple problem space. Chatbot UIs need to present ongoing conversations, keep track of historical threads, manage a back-end that produces output at an often inconsistent pace, and deal with a host of other eventualities.</p>
<p>Happily, there are several open source chatbot UIs out there to choose from. One of the most popular is <a href="https://github.com/mckaywrigley/chatbot-ui"><i>chatbot-ui</i></a>. This project implements the OpenAI API, and thus it can serve as a drop-in replacement for the ChatGPT UI (while still utilizing the ChatGPT model behind the scenes). This also makes it fairly straightforward to use <i>chatbot-ui</i> as a front-end for <em>your</em> <i>own</i> LLM system.</p>
<p><b>What we did</b>: Ordinarily we would have used <i>chatbot-ui</i> or a similar project, and that’s probably what you should do. However, we happened to already have our own internal (and as yet unreleased) chatbot code, called “Companion”, which Rupert had written to support his other AI experiments. Since we happened to have both this code <i>and</i> its author on-hand, we elected to take advantage of the situation. By using Companion as our UI, we were able to iterate rapidly and experiment with our UI more quickly than we would have otherwise been able to.</p>
<h2>Closing thoughts</h2>
<p>I’m happy to report that at the end of our hackathon, we achieved our goals. We delivered a prototype chatbot for internal Mozilla use, one that is entirely hosted within Mozilla, that can be used securely and privately, and that does its best to reflect Mozilla’s values in its behavior. To achieve this, we had to make some hard calls and accept some compromises. But at every step, we were learning.</p>
<p><a href="https://hacks.mozilla.org/files/2023/07/Mozilla-Assistant-path.png"><img decoding="async" loading="lazy" src="https://hacks.mozilla.org/files/2023/07/Mozilla-Assistant-path-500x356.png" alt="A diagram depicting the specific path that we took through the chatbot &#34;stack.&#34;" width="500" height="356" srcset="https://hacks.mozilla.org/files/2023/07/Mozilla-Assistant-path-500x356.png 500w, https://hacks.mozilla.org/files/2023/07/Mozilla-Assistant-path-250x178.png 250w, https://hacks.mozilla.org/files/2023/07/Mozilla-Assistant-path-768x547.png 768w, https://hacks.mozilla.org/files/2023/07/Mozilla-Assistant-path-1536x1095.png 1536w, https://hacks.mozilla.org/files/2023/07/Mozilla-Assistant-path-2048x1460.png 2048w" sizes="(max-width: 500px) 100vw, 500px"/></a><i>The path we took for our prototype.</i></p>

<p>This learning extended beyond the technology itself. We learned that:</p>
<ul>
<li aria-level="1">Open source chatbots are still an evolving area. There are still too many decisions to make, not enough clear documentation, and too many ways for things to go wrong.</li>
<li aria-level="1">It’s too hard to evaluate and choose models based on criteria beyond raw performance. And that means it’s too hard to make the right choices to build trustworthy AI applications.</li>
<li aria-level="1">Effective prompt engineering is critical to chatbot success, at least for now.</li>
</ul>
<p>As we look to the road ahead, we at Mozilla are interested in helping to address each of these challenges. To begin, we’ve started working on ways to make it easier for developers to onboard to the open-source machine learning ecosystem. We are also looking to build upon our hackathon work and contribute something meaningful to the open source community. Stay tuned for more news very soon on this front and others!</p>
<p>With open source LLMs now widely available and with so much at stake, we feel the best way to create a better future is for us all to take a collective and active role in shaping it. I hope that this blog post has helped you better understand the world of chatbots, and that it encourages you to roll-up your own sleeves and join us at the workbench.</p>
    <section>
                                
                      <p>Stephen works in Mozilla&#39;s innovation group, where his current areas of focus are artificial intelligence and decentralized social media. He previously managed social bookmarking pioneer del.icio.us; co-founded Storium, Blockboard, and FairSpin; and worked on Yahoo Search and BEA WebLogic.</p>
                                <p><a href="https://hacks.mozilla.org/author/slangtonhoodmozilla-com/">More articles by Stephen Hood…</a></p>
                  </section>
  </article></div>
  </body>
</html>
