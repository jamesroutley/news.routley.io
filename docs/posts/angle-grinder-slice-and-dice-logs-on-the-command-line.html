<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/rcoh/angle-grinder">Original</a>
    <h1>Angle-grinder: Slice and dice logs on the command line</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Slice and dice log files on the command line.</p>
<p dir="auto">Angle-grinder allows you to parse, aggregate, sum, average, min/max, percentile, and sort your data. You can see it, live-updating, in your terminal. Angle grinder is designed for when, for whatever reason, you don&#39;t have your data in graphite/honeycomb/kibana/sumologic/splunk/etc. but still want to be able to do sophisticated analytics.</p>
<p dir="auto">Angle grinder can process well above 1M rows per second (simple pipelines as high as 5M), so it&#39;s usable for fairly meaty aggregation. The results will live update in your terminal as data is processed. Angle grinder is a bare bones functional programming language coupled with a pretty terminal UI.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://erikarow.land/rcoh/angle-grinder/blob/main/screen_shots/overview.gif"><img src="https://erikarow.land/rcoh/angle-grinder/raw/main/screen_shots/overview.gif" alt="overview gif" data-animated-image=""/></a></p>

<ul dir="auto">
<li><a href="#installation">Installation</a></li>
<li><a href="#query-syntax">Query Syntax Overview</a></li>
<li><a href="#operators">Operators</a>
<ul dir="auto">
<li>Parsers: <a href="#json">JSON</a> <a href="#logfmt">logfmt</a> <a href="#split">split</a> <a href="#parse">generic</a></li>
<li>Misc: <a href="#fields">Add/remove fields</a> <a href="#limit">limit</a> <a href="#timeslice">timeslice</a> <a href="#where">where</a></li>
<li>Aggregators: <a href="#count">count</a> <a href="#sum">sum</a> <a href="#min">min</a> <a href="#max">max</a> <a href="#percentile">percentile</a> <a href="#sort">sort</a> <a href="#total">total</a> <a href="#count-distinct">count distinct</a></li>
</ul>
</li>
<li><a href="#rendering">Output Control</a></li>
</ul>

<p dir="auto">Binaries are available for Linux and OSX. Many more platforms (including Windows) are available if you compile from source. In all of the commands below, the resulting binary will be called <code>agrind</code>. Starting with <code>v0.9.0</code>, <code>agrind</code> can self-update via the <code>--self-update</code> flag. Thanks to the many volunteers who maintain angle-grinder on different package managers &amp; environments!</p>

<p dir="auto"><strong>Brew</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="brew install angle-grinder"><pre>brew install angle-grinder</pre></div>
<p dir="auto"><strong>Macports</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="sudo port selfupdate
sudo port install angle-grinder"><pre>sudo port selfupdate
sudo port install angle-grinder</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="pkg install angle-grinder"><pre>pkg install angle-grinder</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Linux (any MUSL compatible variant)</h3><a id="user-content-linux-any-musl-compatible-variant" aria-label="Permalink: Linux (any MUSL compatible variant)" href="#linux-any-musl-compatible-variant"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="curl -L https://github.com/rcoh/angle-grinder/releases/download/v0.18.0/agrind-x86_64-unknown-linux-musl.tar.gz \
  | tar Ozxf - \
  | sudo tee /usr/local/bin/agrind &gt; /dev/null &amp;&amp; sudo chmod +x /usr/local/bin/agrind
  
agrind --self-update  "><pre>curl -L https://github.com/rcoh/angle-grinder/releases/download/v0.18.0/agrind-x86_64-unknown-linux-musl.tar.gz \
  <span>|</span> tar Ozxf - \
  <span>|</span> sudo tee /usr/local/bin/agrind <span>&gt;</span> /dev/null <span>&amp;&amp;</span> sudo chmod +x /usr/local/bin/agrind
  
agrind --self-update  </pre></div>

<p dir="auto">If you have Cargo installed, you can compile &amp; install from source: (Works with Stable Rust &gt;=1.26)</p>


<p dir="auto">An angle grinder query is composed of filters followed by a series of operators.
The filters select the lines from the input stream to be transformed by the operators.
Typically, the initial operators will transform the data in some way by parsing fields or JSON from the log line.
The subsequent operators can then aggregate or group the data via operators like <code>sum</code>, <code>average</code>, <code>percentile</code>, etc.</p>
<div dir="auto" data-snippet-clipboard-copy-content="agrind &#39;&lt;filter1&gt; [... &lt;filterN&gt;] | operator1 | operator2 | operator3 | ...&#39;"><pre>agrind <span><span>&#39;</span>&lt;filter1&gt; [... &lt;filterN&gt;] | operator1 | operator2 | operator3 | ...<span>&#39;</span></span></pre></div>
<p dir="auto">A simple query that operates on JSON logs and counts the number of logs per level could be:</p>
<div dir="auto" data-snippet-clipboard-copy-content="agrind &#39;* | json | count by log_level&#39;"><pre>agrind <span><span>&#39;</span>* | json | count by log_level<span>&#39;</span></span></pre></div>

<p dir="auto">Field names containing spaces, periods, or quotes must be escaped using <code>[&#34;&lt;FIELD&gt;&#34;]</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="agrind &#39;* | json | count by [&#34;date received&#34;], [&#34;grpc.method&#34;]"><pre>agrind <span><span>&#39;</span>* | json | count by [&#34;date received&#34;], [&#34;grpc.method&#34;]</span></pre></div>

<p dir="auto">There are three basic filters:</p>
<ul dir="auto">
<li><code>*</code>: Match all logs</li>
<li><code>filter-me*</code> (with no quotes) is a case-insensitive match that can include wildcards</li>
<li>&#34;filter-me&#34; (in quotes) is a case-sensitive match (no wildcards, <code>*</code> matches literal <code>*</code>
, <code>filter-me</code>, or <code>&#34;filter me!&#34;</code>.</li>
</ul>
<p dir="auto">Filters can be combined with <code>AND</code>, <code>OR</code> and <code>NOT</code></p>
<div data-snippet-clipboard-copy-content="(&#34;ERROR&#34; OR WARN*) AND NOT staging | count"><pre lang="agrind"><code>(&#34;ERROR&#34; OR WARN*) AND NOT staging | count
</code></pre></div>
<p dir="auto">Sub-expressions <em>must</em> be grouped in parenthesis. Only lines that match all filters will be passed to the subsequent operators.
<a target="_blank" rel="noopener noreferrer" href="https://erikarow.land/rcoh/angle-grinder/blob/main/screen_shots/filter.gif"><img src="https://erikarow.land/rcoh/angle-grinder/raw/main/screen_shots/filter.gif" alt="filter.gif" data-animated-image=""/></a></p>

<p dir="auto">Starting with v0.12.0, angle grinder supports aliases, pre-built pipelines do simplify common tasks or formats. The only alias currently defined is <code>apache</code>, which parses apache logs. Adding more <code>aliases</code> is one of the easiest ways to <a href="#contributing">contribute</a>!</p>
<p dir="auto"><em>Examples</em>:</p>
<div data-snippet-clipboard-copy-content="* | apache | count by status"><pre lang="agrind"><code>* | apache | count by status
</code></pre></div>


<p dir="auto">These operators have a 1 to 1 correspondence between input data and output data. 1 row in, 0 or 1 rows out.</p>

<p dir="auto"><code>json [from other_field]</code>: Extract json-serialized rows into fields for later use. If the row is <em>not</em> valid JSON, then it is dropped. Optionally, <code>from other_field</code> can be
specified. Nested JSON structures are supported out of the box. Simply access nested values with <code>.key[index]</code>, for example, <code>.servers[6]</code>. Negative indexing is also supported.</p>
<p dir="auto"><em>Examples</em>:</p>

<div data-snippet-clipboard-copy-content="* | parse &#34;INFO *&#34; as js | json from js"><pre lang="agrind"><code>* | parse &#34;INFO *&#34; as js | json from js
</code></pre></div>
<p dir="auto">Given input like:</p>
<div data-snippet-clipboard-copy-content="{&#34;key&#34;: &#34;blah&#34;, &#34;nested_key&#34;: {&#34;this&#34;: &#34;that&#34;}}"><pre><code>{&#34;key&#34;: &#34;blah&#34;, &#34;nested_key&#34;: {&#34;this&#34;: &#34;that&#34;}}
</code></pre></div>
<div data-snippet-clipboard-copy-content="* | json | count_distinct(nested_key.this)"><pre lang="agrind"><code>* | json | count_distinct(nested_key.this)
</code></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://erikarow.land/rcoh/angle-grinder/blob/main/screen_shots/json.gif"><img src="https://erikarow.land/rcoh/angle-grinder/raw/main/screen_shots/json.gif" alt="json.gif" data-animated-image=""/></a></p>

<p dir="auto"><code>logfmt [from other_field]</code>: Extract logfmt-serialized rows into fields for later use. If the row is <em>not</em> valid logfmt, then it is dropped. Optionally, <code>from other_field</code> can be specified. Logfmt is a an output format commonly used by Heroku and Splunk, described at <a href="https://www.brandur.org/logfmt" rel="nofollow">https://www.brandur.org/logfmt</a>.</p>
<p dir="auto"><em>Examples</em>:</p>

<p dir="auto">Given input like:</p>
<div data-snippet-clipboard-copy-content="{&#34;key&#34;: &#34;blah&#34;, &#34;nested_key&#34;: &#34;some=logfmt data=more&#34;}"><pre><code>{&#34;key&#34;: &#34;blah&#34;, &#34;nested_key&#34;: &#34;some=logfmt data=more&#34;}
</code></pre></div>
<div data-snippet-clipboard-copy-content="* | json | logfmt from nested_key | fields some"><pre lang="agrind"><code>* | json | logfmt from nested_key | fields some
</code></pre></div>

<p dir="auto"><code>split[(input_field)] [on separator] [as new_field]</code>: Split the input via the separator (default is <code>,</code>). Output is an array type. If no <code>input_field</code> or <code>new_field</code>, the contents will be put in the key <code>_split</code>.</p>
<p dir="auto"><em>Examples</em>:</p>

<p dir="auto">Given input like:</p>
<div data-snippet-clipboard-copy-content="INFO web-001 influxd[188053]: 127.0.0.1 &#34;POST /write HTTP/1.0&#34; 204"><pre><code>INFO web-001 influxd[188053]: 127.0.0.1 &#34;POST /write HTTP/1.0&#34; 204
</code></pre></div>
<p dir="auto">Output:</p>
<div data-snippet-clipboard-copy-content="[_split=[INFO, web-001, influxd[188053]:, 127.0.0.1, POST /write HTTP/1.0, 204]]"><pre><code>[_split=[INFO, web-001, influxd[188053]:, 127.0.0.1, POST /write HTTP/1.0, 204]]
</code></pre></div>
<p dir="auto">If <code>input_field</code> is used, and there is no <code>new_field</code> specified, then the <code>input_field</code> will be overridden with the split data-structure. For example:</p>
<div data-snippet-clipboard-copy-content="* | parse &#34;* *&#34; as level, csv | split(csv)"><pre lang="agrind"><code>* | parse &#34;* *&#34; as level, csv | split(csv)
</code></pre></div>
<p dir="auto">Given input like:</p>
<div data-snippet-clipboard-copy-content="INFO darren,hello,50
WARN jonathon,good-bye,100"><pre><code>INFO darren,hello,50
WARN jonathon,good-bye,100
</code></pre></div>
<p dir="auto">Will output:</p>
<div data-snippet-clipboard-copy-content="[csv=[darren, hello, 50]]        [level=INFO]
[csv=[jonathon, good-bye, 100]]        [level=WARN]"><pre><code>[csv=[darren, hello, 50]]        [level=INFO]
[csv=[jonathon, good-bye, 100]]        [level=WARN]
</code></pre></div>
<p dir="auto">Other examples:</p>
<div data-snippet-clipboard-copy-content="* | logfmt | split(raw) on &#34;blah&#34; as tokens | sum(tokens[1])"><pre lang="agrind"><code>* | logfmt | split(raw) on &#34;blah&#34; as tokens | sum(tokens[1])
</code></pre></div>

<p dir="auto"><code>parse &#34;* pattern * otherpattern *&#34; [from field] as a,b,c [nodrop]</code>: Parse text that matches the pattern into variables. Lines that don&#39;t match the pattern will be dropped unless <code>nodrop</code> is specified. <code>*</code> is equivalent to regular expression <code>.*</code> and is greedy.
By default, <code>parse</code> operates on the raw text of the message. With <code>from field_name</code>, parse will instead process input from a specific column. Any whitespace in the parse
expression will match <em>any</em> whitespace character in the input text (eg. a literal tab).</p>
<p dir="auto"><em>Examples</em>:</p>
<div data-snippet-clipboard-copy-content="* | parse &#34;[status_code=*]&#34; as status_code"><pre lang="agrind"><code>* | parse &#34;[status_code=*]&#34; as status_code
</code></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://erikarow.land/rcoh/angle-grinder/blob/main/screen_shots/parse.gif"><img src="https://erikarow.land/rcoh/angle-grinder/raw/main/screen_shots/parse.gif" alt="parse.gif" data-animated-image=""/></a></p>

<p dir="auto"><code>parse regex &#34;&lt;regex-with-named-captures&gt;&#34; [from field] [nodrop]</code>: Match the
input text against a regular expression and populate the record with the named
captures.  Lines that don&#39;t match the pattern will be dropped unless <code>nodrop</code> is
specified. By default, <code>parse</code> operates on the raw text of the message. With
<code>from field_name</code>, parse will instead process input from a specific column.</p>
<p dir="auto"><em>Notes</em>:</p>
<ul dir="auto">
<li>Only named captures are supported.  If the regular expression includes any
unnamed captures, an error will be raised.</li>
<li>The <a href="https://docs.rs/regex/latest/regex/#syntax" rel="nofollow">Rust regular expression syntax</a> is used.</li>
<li>Escape sequences do not require an extra backslash (i.e. <code>\w</code> works as-is).</li>
</ul>
<p dir="auto"><em>Examples</em>:
To parse the phrase &#34;Hello, ...!&#34; and capture the value of the &#34;...&#34; in the
name field:</p>
<div data-snippet-clipboard-copy-content="* | parse regex &#34;Hello, (?P&lt;name&gt;\w+)&#34;"><pre lang="agrind"><code>* | parse regex &#34;Hello, (?P&lt;name&gt;\w+)&#34;
</code></pre></div>

<p dir="auto"><code>fields [only|except|-|+] a, b</code>: Drop fields <code>a, b</code> or include only <code>a, b</code> depending on specified mode.</p>
<p dir="auto"><em>Examples</em>:
Drop all fields except <code>event</code> and <code>timestamp</code></p>
<div data-snippet-clipboard-copy-content="* | json | fields + event, timestamp"><pre lang="agrind"><code>* | json | fields + event, timestamp
</code></pre></div>
<p dir="auto">Drop only the <code>event</code> field</p>


<p dir="auto"><code>where &lt;bool-expr&gt;</code>: Drop rows where the condition is not met.
The condition must be an expression that returns a boolean value.
The expression can be as simple as a field name or a comparison (i.e. ==, !=, &lt;=, &gt;=, &lt;, &gt;)
between fields and literal values (i.e. numbers, strings).
The &#39;!&#39; operator can be used to negate the result of a sub-expression.
Note that <code>None == None</code>, so a row where both the left and right sides match a non-existent key will match.</p>
<p dir="auto"><em>Examples</em></p>
<div data-snippet-clipboard-copy-content="* | json | where status_code &gt;= 400"><pre lang="agrind"><code>* | json | where status_code &gt;= 400
</code></pre></div>
<div data-snippet-clipboard-copy-content="* | json | where user_id_a == user_id_b"><pre lang="agrind"><code>* | json | where user_id_a == user_id_b
</code></pre></div>
<div data-snippet-clipboard-copy-content="* | json | where url != &#34;/hostname&#34;"><pre lang="agrind"><code>* | json | where url != &#34;/hostname&#34;
</code></pre></div>

<p dir="auto"><code>limit #</code>: Limit the number of rows to the given amount.  If the number is positive, only the
first N rows are returned.  If the number is negative, the last N rows are returned.</p>
<p dir="auto"><em>Examples</em></p>



<p dir="auto"><code>&lt;expr&gt; as &lt;name&gt;</code>: The given expression is evaluated and the result is stored
in a field with the given name for the current row.  The expression can be
made up of the following:</p>
<ul dir="auto">
<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>: Mathematical operators with the normal precedence rules.
The operators work on numeric values and strings that can automatically be
converted to a number.  In addition, these operators work for date-time and
duration values when appropriate.  For example, you can take the difference
between two date-times, but cannot add them together.</li>
<li><code>==</code>, <code>!=</code> (or <code>&lt;&gt;</code>), <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code>: Boolean operators work
on most data types.</li>
<li><code>and</code>, <code>&amp;&amp;</code>, <code>or</code>, <code>||</code>: Short-circuiting logical operators.</li>
<li><code>&lt;field&gt;</code>: The name of a field in the current row.  If the row does not
contain the given field, an error will be reported.</li>
<li>Parentheses to group operations</li>
</ul>
<p dir="auto">The following functions are supported within expressions:</p>
<ul dir="auto">
<li>Mathematical functions: <code>abs()</code>, <code>acos()</code>, <code>asin()</code>, <code>atan()</code>, <code>atan2()</code>,
<code>cbrt(), ceil()</code>, <code>cos()</code>, <code>cosh()</code>, <code>exp()</code>, <code>expm1()</code>, <code>floor()</code>,
<code>hypot()</code>, <code>log()</code>, <code>log10(), log1p()</code>, <code>round()</code>, <code>sin()</code>, <code>sinh()</code>,
<code>sqrt()</code>, <code>tan()</code>, <code>tanh()</code>, <code>toDegrees()</code>,
<code>toRadians()</code></li>
<li><code>concat(arg0, ..., argN)</code> - Concatenate the arguments into a string</li>
<li><code>contains(haystack, needle)</code> - Return true if the haystack contains the needle.</li>
<li><code>length(str)</code> - Returns the number of characters in &#34;str&#34;.</li>
<li><code>now()</code> - Returns the current date and time.</li>
<li><code>num(value)</code> - Returns the given value as a number.</li>
<li><code>parseDate(str)</code> - Attempt to parse a date from the given string.</li>
<li><code>parseHex(str)</code> - Attempt to convert a hexadecimal string into an integer.</li>
<li><code>substring(str, startOffset, [endOffset])</code> - Returns the part of the string
specified by the given starting offset up to the end offset (if specified).</li>
<li><code>toLowerCase(str)</code> - Returns the lowercase version of the string.</li>
<li><code>toUpperCase(str)</code> - Returns the uppercase version of the string.</li>
<li><code>isNull(value)</code> - Returns true if value is <code>null</code>, false otherwise.</li>
<li><code>isEmpty(value)</code> - Returns true if value is <code>null</code> or an empty string, false
otherwise.</li>
<li><code>isBlank(value)</code> - Returns true if value is <code>null</code>, an empty string, or a
whitespace-only string, false otherwise.</li>
<li><code>isNumeric(str)</code> - Returns true if the given string is a number.</li>
</ul>
<p dir="auto"><em>Examples</em>
Multiply <code>value</code> by 100 to get the percentage</p>
<div data-snippet-clipboard-copy-content="* | json | value * 100 as percentage"><pre lang="agrind"><code>* | json | value * 100 as percentage
</code></pre></div>

<p dir="auto"><code>if(&lt;condition&gt;, &lt;value-if-true&gt;, &lt;value-if-false&gt;)</code>: Choose between two values
based on the provided condition.</p>
<p dir="auto"><em>Examples</em></p>
<p dir="auto">To get byte counts for successful requests:</p>
<div data-snippet-clipboard-copy-content="* | json | if(status == 200, sc_bytes, 0) as ok_bytes"><pre lang="agrind"><code>* | json | if(status == 200, sc_bytes, 0) as ok_bytes
</code></pre></div>

<p dir="auto">Aggregate operators group and combine your data by 0 or more key fields. The same query can include multiple aggregates.
The general syntax is:</p>
<div data-snippet-clipboard-copy-content="(operator [as renamed_column])+ [by key_col1, key_col2]"><pre lang="noformat"><code>(operator [as renamed_column])+ [by key_col1, key_col2]
</code></pre></div>
<p dir="auto">In the simplest form, key fields refer to columns, but they can also be generalized expressions (see examples)
<em>Examples</em>:</p>

<div data-snippet-clipboard-copy-content="* | json | count by status_code"><pre lang="agrind"><code>* | json | count by status_code
</code></pre></div>
<div data-snippet-clipboard-copy-content="* | json | count, p50(response_ms), p90(response_ms) by status_code"><pre lang="agrind"><code>* | json | count, p50(response_ms), p90(response_ms) by status_code
</code></pre></div>
<div data-snippet-clipboard-copy-content="* | json | count as num_requests, p50(response_ms), p90(response_ms) by status_code"><pre lang="agrind"><code>* | json | count as num_requests, p50(response_ms), p90(response_ms) by status_code
</code></pre></div>
<div data-snippet-clipboard-copy-content="* | json | count, p50(response_ms), p90(response_ms), count by status_code &gt;= 400, url"><pre lang="agrind"><code>* | json | count, p50(response_ms), p90(response_ms), count by status_code &gt;= 400, url
</code></pre></div>
<p dir="auto">There are several aggregate operators available.</p>

<p dir="auto"><code>count[(condition)] [as count_column]</code>: Counts the number of input rows. Output column defaults to <code>_count</code>. Optionally, you
can provide a condition -- this will count all rows for which the condition evaluates to true.</p>
<p dir="auto"><em>Examples</em>:</p>
<p dir="auto">Count number of rows by <code>source_host</code>:</p>

<p dir="auto">Count number of source_hosts:</p>
<div data-snippet-clipboard-copy-content="* | count by source_host | count"><pre lang="agrind"><code>* | count by source_host | count
</code></pre></div>
<p dir="auto">Count the number of info vs. error logs:</p>
<div data-snippet-clipboard-copy-content="* | json | count(level == &#34;info&#34;) as info_logs, count(level == &#34;error&#34;) as error_logs"><pre lang="agrind"><code>* | json | count(level == &#34;info&#34;) as info_logs, count(level == &#34;error&#34;) as error_logs
</code></pre></div>

<p dir="auto"><code>sum(column) [as sum_column]</code>: Sum values in <code>column</code>. If the value in <code>column</code> is non-numeric, the row will be ignored.
<em>Examples</em>:</p>
<div data-snippet-clipboard-copy-content="* | json | sum(num_records) by action"><pre lang="agrind"><code>* | json | sum(num_records) by action
</code></pre></div>

<p dir="auto"><code>min(column) [as min_column] [by a, b] </code>: Compute the min of values in <code>column</code>. If the value in <code>column</code> is non-numeric, the row will be ignored.</p>
<p dir="auto"><em>Examples</em>:</p>
<div data-snippet-clipboard-copy-content="* | json | min(response_time)"><pre lang="agrind"><code>* | json | min(response_time)
</code></pre></div>

<p dir="auto"><code>average(column) [as average_column] [by a, b] </code>: Average values in <code>column</code>. If the value in <code>column</code> is non-numeric, the row will be ignored.</p>
<p dir="auto"><em>Examples</em>:</p>
<div data-snippet-clipboard-copy-content="* | json | average(response_time)"><pre lang="agrind"><code>* | json | average(response_time)
</code></pre></div>

<p dir="auto"><code>max(column) [as max_column] [by a, b] </code>: Compute the max of values in <code>column</code>. If the value in <code>column</code> is non-numeric, the row will be ignored.</p>
<p dir="auto"><em>Examples</em>:</p>
<div data-snippet-clipboard-copy-content="* | json | max(response_time)"><pre lang="agrind"><code>* | json | max(response_time)
</code></pre></div>

<p dir="auto"><code>pXX(column)</code>: calculate the XXth percentile of <code>column</code></p>
<p dir="auto"><em>Examples</em>:</p>
<div data-snippet-clipboard-copy-content="* | json | p50(response_time), p90(response_time) by endpoint_url, status_code"><pre lang="agrind"><code>* | json | p50(response_time), p90(response_time) by endpoint_url, status_code
</code></pre></div>

<p dir="auto"><code>sort by a, [b, c] [asc|desc]</code>: Sort aggregate data by a collection of columns. Defaults to ascending.</p>
<p dir="auto"><em>Examples</em>:</p>
<div data-snippet-clipboard-copy-content="* | json | count by endpoint_url, status_code | sort by endpoint_url desc"><pre lang="agrind"><code>* | json | count by endpoint_url, status_code | sort by endpoint_url desc
</code></pre></div>
<p dir="auto">In addition to columns, <code>sort</code> can also sort an arbitrary expressions.</p>
<div data-snippet-clipboard-copy-content="* | json | sort by num_requests / num_responses"><pre lang="agrind"><code>* | json | sort by num_requests / num_responses
</code></pre></div>
<div data-snippet-clipboard-copy-content="* | json | sort by length(endpoint_url)"><pre lang="agrind"><code>* | json | sort by length(endpoint_url)
</code></pre></div>

<p dir="auto"><code>timeslice(&lt;timestamp&gt;) &lt;duration&gt; [as &lt;field&gt;]</code>: Truncates a timestamp to the
given duration to allow for partitioning messages into slices of time.  The
<code>timestamp</code> parameter must be a date value, such as that returned by the
<code>parseDate()</code> function.  The duration is an amount followed by one of the
following units:</p>
<ul dir="auto">
<li><code>ns</code> - nanoseconds</li>
<li><code>us</code> - microseconds</li>
<li><code>ms</code> - milliseconds</li>
<li><code>s</code> - seconds</li>
<li><code>m</code> - minutes</li>
<li><code>h</code> - hours</li>
<li><code>d</code> - days</li>
<li><code>w</code> - weeks</li>
</ul>
<p dir="auto">The resulting timestamp is placed in the <code>_timeslice</code> field by default or the
field specified after the <code>as</code> keyword.</p>
<p dir="auto"><em>Examples</em>:</p>
<div data-snippet-clipboard-copy-content="* | json | timeslice(parseDate(ts)) 5m"><pre lang="agrind"><code>* | json | timeslice(parseDate(ts)) 5m
</code></pre></div>

<p dir="auto"><code>total(a) [as renamed_total]</code>: Compute the running total of a given field. Total does not currently support grouping!</p>
<p dir="auto"><em>Examples</em>:</p>
<div data-snippet-clipboard-copy-content="* | json | total(num_requests) as tot_requests"><pre lang="agrind"><code>* | json | total(num_requests) as tot_requests
</code></pre></div>

<p dir="auto"><code>count_distinct(a)</code>: Count distinct values of column <code>a</code>. Warning: this is not fixed memory. Be careful about processing too many groups.</p>
<p dir="auto"><em>Examples</em>:</p>
<div data-snippet-clipboard-copy-content="* | json | count_distinct(ip_address)"><pre lang="agrind"><code>* | json | count_distinct(ip_address)
</code></pre></div>

<ul dir="auto">
<li>Count the number of downloads of angle-grinder by release (with special guest jq)</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="curl  https://api.github.com/repos/rcoh/angle-grinder/releases  | \
   jq &#39;.[] | .assets | .[]&#39; -c | \
   agrind &#39;* | json
         | parse &#34;download/*/&#34; from browser_download_url as version
         | sum(download_count) by version | sort by version desc&#39;"><pre>curl  https://api.github.com/repos/rcoh/angle-grinder/releases  <span>|</span> \
   jq <span><span>&#39;</span>.[] | .assets | .[]<span>&#39;</span></span> -c <span>|</span> \
   agrind <span><span>&#39;</span>* | json</span>
<span>         | parse &#34;download/*/&#34; from browser_download_url as version</span>
<span>         | sum(download_count) by version | sort by version desc<span>&#39;</span></span></pre></div>
<p dir="auto">Output:</p>
<div data-snippet-clipboard-copy-content="version       _sum
-----------------------
v0.6.2        0
v0.6.1        4
v0.6.0        5
v0.5.1        0
v0.5.0        4
v0.4.0        0
v0.3.3        0
v0.3.2        2
v0.3.1        9
v0.3.0        7
v0.2.1        0
v0.2.0        1"><pre lang="noformat"><code>version       _sum
-----------------------
v0.6.2        0
v0.6.1        4
v0.6.0        5
v0.5.1        0
v0.5.0        4
v0.4.0        0
v0.3.3        0
v0.3.2        2
v0.3.1        9
v0.3.0        7
v0.2.1        0
v0.2.0        1
</code></pre></div>
<ul dir="auto">
<li>Take the 50th percentile of response time by host:</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="tail -F my_json_logs | agrind &#39;* | json | pct50(response_time) by url&#39;"><pre>tail -F my_json_logs <span>|</span> agrind <span><span>&#39;</span>* | json | pct50(response_time) by url<span>&#39;</span></span></pre></div>
<ul dir="auto">
<li>Count the number of status codes by url:</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="tail -F  my_json_logs | agrind &#39;* | json | count status_code by url&#39;"><pre>tail -F  my_json_logs <span>|</span> agrind <span><span>&#39;</span>* | json | count status_code by url<span>&#39;</span></span></pre></div>
<p dir="auto">More example queries can be found in the <a href="https://erikarow.land/rcoh/angle-grinder/blob/main/tests/structured_tests">tests folder</a></p>

<p dir="auto">Non-aggregate data is simply written row-by-row to the terminal as it is received:</p>
<div data-snippet-clipboard-copy-content="tail -f live_pcap | agrind &#39;* | parse &#34;* &gt; *:&#34; as src, dest | parse &#34;length *&#34; as length&#39;
[dest=111.221.29.254.https]        [length=0]        [src=21:50:18.458331 IP 10.0.2.243.47152]
[dest=111.221.29.254.https]        [length=310]      [src=21:50:18.458527 IP 10.0.2.243.47152]"><pre lang="noformat"><code>tail -f live_pcap | agrind &#39;* | parse &#34;* &gt; *:&#34; as src, dest | parse &#34;length *&#34; as length&#39;
[dest=111.221.29.254.https]        [length=0]        [src=21:50:18.458331 IP 10.0.2.243.47152]
[dest=111.221.29.254.https]        [length=310]      [src=21:50:18.458527 IP 10.0.2.243.47152]
</code></pre></div>
<p dir="auto">Alternate rendering formats can be provided with the <code>--output</code> flag. Options:</p>
<ul dir="auto">
<li><code>--output json</code>: JSON output</li>
<li><code>--output logfmt</code>: logfmt style output (<code>k=v</code>)</li>
<li><code>--output format=&lt;rust formatter&gt;</code>: This flag uses <a href="https://doc.rust-lang.org/std/fmt/#syntax" rel="nofollow">rust string formatting syntax</a>. For example:
<div data-snippet-clipboard-copy-content="tail -f live_pcap | agrind --format &#39;{src} =&gt; {dst} | length={length}&#39; &#39;* | parse &#34;* &gt; *:&#34; as src, dest | parse &#34;length *&#34; as length&#39;
21:50:18.458331 IP 10.0.2.243.47152 =&gt; 111.221.29.254.https | length=0
21:50:18.458527 IP 10.0.2.243.47152 =&gt; 111.221.29.254.https | length=310"><pre lang="noformat"><code>tail -f live_pcap | agrind --format &#39;{src} =&gt; {dst} | length={length}&#39; &#39;* | parse &#34;* &gt; *:&#34; as src, dest | parse &#34;length *&#34; as length&#39;
21:50:18.458331 IP 10.0.2.243.47152 =&gt; 111.221.29.254.https | length=0
21:50:18.458527 IP 10.0.2.243.47152 =&gt; 111.221.29.254.https | length=310
</code></pre></div>
</li>
</ul>
<p dir="auto">Aggregate data is written to the terminal and will live-update until the stream ends:</p>
<div data-snippet-clipboard-copy-content="k2                  avg
--------------------------------
test longer test    500.50
test test           375.38
alternate input     4.00
hello               3.00
hello thanks        2.00"><pre lang="noformat"><code>k2                  avg
--------------------------------
test longer test    500.50
test test           375.38
alternate input     4.00
hello               3.00
hello thanks        2.00
</code></pre></div>
<p dir="auto">The renderer will do its best to keep the data nicely formatted as it changes and the number of output rows is limited to the length of your terminal. Currently,
it has a refresh rate of about 20hz.</p>
<p dir="auto">The renderer can detect whether or not the output is a tty -- if you write to a file, it will print once when the pipeline completes.</p>

<p dir="auto"><code>angle-grinder</code> builds with Rust &gt;= 1.26. <code>rustfmt</code> is required when submitting PRs (<code>rustup component add rustfmt</code>).</p>
<p dir="auto">There are a number of ways you can contribute:</p>
<ul dir="auto">
<li>Defining new aliases for common log formats or actions</li>
<li>Adding new special purpose operators</li>
<li>Improve documentation of existing operators + providing more usage examples</li>
<li>Provide more test cases of real queries on real world data</li>
<li>Tell more people about angle grinder!</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="cargo build
cargo test
cargo install --path .
agrind --help
... write some code!

cargo fmt

git commit ... etc."><pre>cargo build
cargo <span>test</span>
cargo install --path <span>.</span>
agrind --help
... write some code<span>!</span>

cargo fmt

git commit ... etc.</pre></div>
<p dir="auto"><strong>When submitting PRs, please run <code>cargo fmt</code> -- this is necessary for the CI suite to pass.</strong> You can install <code>cargo fmt</code> with: <code>rustup component add rustfmt</code> if it&#39;s not already in your toolchain.</p>
<p dir="auto">See the following projects and open issues for specific potential improvements/bugs.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Project: Improving Error Reporting</h4><a id="user-content-project-improving-error-reporting" aria-label="Permalink: Project: Improving Error Reporting" href="#project-improving-error-reporting"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Usability can be greatly improved by accurate and helpful error messages for query-related issues.
If you have struggled to figure out why a query is not working correctly and had a hard time
fixing the issue, that would be a good place to jump in and start making changes!</p>
<p dir="auto">First, you need to determine where the problem is occurring.
If the parser is rejecting a query, the grammar may need some tweaking to be more accepting of
some syntax.
For example, if the field names are not provided for the <code>parse</code> operator, the query can still
be parsed to produce a syntax tree and the error can be raised in the next phase.
If the query passes the parsing phase, the problem may lie in the semantic analysis phase where the
values in parse tree are verified for correctness.
Continuing with the <code>parse</code> example, if the number of captures in the pattern string does not
match the number of field names, the error would be raised here.
Finally, if the query has been valid up to this point, you might want to raise an error at
execution time.
For example, if a field name being accessed does not exist in the records being passed to an
operator, an error could be raised to tell the user that they might have mistyped the name.</p>
<p dir="auto">Once you have an idea of where the problem might lie, you can start to dig into the code.
The grammar is written using <a href="https://github.com/Geal/nom/">nom</a> and is contained in the
<a href="https://github.com/rcoh/angle-grinder/blob/main/src/lang.rs"><code>lang.rs</code></a> module.
The enums/structs that make up the parse tree are also in the <code>lang.rs</code> module.
To make error reporting easier, values in the parse tree are wrapped with a <code>Positioned</code> object
that records where the value came from in the query string.
The <code>Positioned</code> objects are produced by the <code>with_pos!()</code> parser combinator.
These objects can then be passed to the <code>SnippetBuilder</code> in the
<a href="https://github.com/rcoh/angle-grinder/blob/main/src/errors.rs"><code>errors.rs</code></a> module to highlight
portions of the query string in error messages.</p>
<p dir="auto">The semantic phase is contained in the
<a href="https://github.com/rcoh/angle-grinder/blob/main/src/typecheck.rs"><code>typecheck.rs</code></a> module and
is probably where most of the work will need to be done.
The <code>semantic_analysis()</code> methods in that module are passed an <code>ErrorBuilder</code> that can be used to
build and send error reports to the user.</p>
<p dir="auto">After adjusting the grammar and adding a check for the problem, it will be time to figure out how
to inform the user.
Ideally, any errors should explain the problem, point the user to the relevant part of the query
string, and lead the user to a solution.
Using the <code>ErrorBuilder</code>, you can call the <code>new_error_report_for()</code> method to construct a
<code>SnippetBuilder</code> for a given error.
To highlight a portion of the query string, use the <code>with_code_pointer()</code> method with the
<code>Positioned</code> object that refers to the relevant segment of the query string.
Finally, additional help/examples can be added by calling the <code>with_resolution()</code> method.</p>
<p dir="auto">Once you&#39;re all done, you should see a nicely formatted error message like the following:</p>
<div data-snippet-clipboard-copy-content="error: Expecting an expression to count
  |
1 | * | count_distinct
  |     ^^^^^^^^^^^^^^ No field argument given
  |
  = help: example: count_distinct(field_to_count)"><pre><code>error: Expecting an expression to count
  |
1 | * | count_distinct
  |     ^^^^^^^^^^^^^^ No field argument given
  |
  = help: example: count_distinct(field_to_count)
</code></pre></div>

<ul dir="auto">
<li>Angle Grinder is a rewrite of <a href="https://github.com/SumoLogic/sumoshell">Sumoshell</a> written to be easier to use, testable and a better platform for new features.</li>
<li><a href="http://lnav.org/" rel="nofollow">lnav</a> is a full featured log analysis platform in your terminal (with many more features than angle-grinder). It includes support for common log file formats out-of-the-box, generalized SQL queries on your logs, auto-coloring and a whole host of other features.</li>
<li><a href="http://visidata.org/" rel="nofollow">visidata</a> is a spreadsheets app in your terminal</li>
</ul>
</article></div></div>
  </body>
</html>
