<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://threedots.tech/post/distributed-transactions-in-go">Original</a>
    <h1>Distributed Transactions in Go: Read Before You Try</h1>
    
    <div id="readability-page-1" class="page"><div><p><em>In the <a href="https://threedots.tech/post/database-transactions-in-go/">previous post</a>, I looked into running transactions in a layered architecture.
Now, let’s consider transactions that need to span more than one service.</em></p><p>If you work with microservices, a time may come when you need a transaction running across them.
Especially if the way they are split was an afterthought (the unfortunate but likely scenario).
Service A calls service B, which calls service C, and if something goes wrong at the end, the system becomes inconsistent.
It would be helpful to have a way to roll back the changes in all the services.</p><p><img title="" loading="lazy" decoding="async" width="1396" height="301" src="https://threedots.tech/post/distributed-transactions-in-go/images/5-microservices_hub5f05658aab835b55e17359be976c631_39617_1396x301_resize_q80_h2_lanczos_3.webp" alt="Microservices" onerror="this.onerror=&#34;null&#34;,this.src=&#34;/post/distributed-transactions-in-go/images/5-microservices_hub5f05658aab835b55e17359be976c631_39617_1396x301_resize_lanczos_3.png&#34;"/></p><p>Now, you’re looking at <em>distributed transactions</em> or the <em>saga</em> pattern.
It’s a solved problem. Sometimes, there are good reasons to use them.
<strong>But more often, it’s overkill.
If you go down this path, your architecture quickly becomes much more complex than you’d like.</strong>
(I learned this the hard way.)</p><p>If you need things to be consistent, why split them in the first place? The whole idea of using microservices is to keep independent concepts separate.</p><p><strong>Let’s face it: your microservice boundaries are likely wrong if you consider using a distributed transaction.</strong>
This is super common and not easy to solve.
But it can get much worse if you apply the wrong pattern to the mess you already have.</p><p><strong>Before you try it, I want to show you an alternative that might be simpler.</strong>
It’s not a silver bullet, but consider it before committing to distributed transactions.</p><div><p>❌ Anti-pattern: Distributed Transactions</p><p>Stay away from transactions that span more than one service, except when there&#39;s no other way.</p></div><h2 id="the-example">The Example</h2><p>The snippets below continue the example from the <a href="https://threedots.tech/post/database-transactions-in-go/">previous post</a>.
Here’s a quick refresher: we work with an e-commerce web app where users get virtual points.
They can use these points as a discount for their next order.
The challenge is keeping the user’s points and the applied discount consistent.</p><p>Let’s assume we work with two services: <code>users</code> for authentication and <code>orders</code> for placing orders and tracking users’ discounts.
Initially, the split seemed like a good idea because they are separate areas.
Later, we realized we couldn’t update users and their discounts within one transaction.</p><p>The <code>orders</code> service exposes an HTTP endpoint for adding a discount.
In the <code>users</code> service, the handler for using points as a discount looks like this:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>(</span><span>h</span> <span>UsePointsAsDiscountHandler</span><span>)</span> <span>Handle</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>cmd</span> <span>UsePointsAsDiscount</span><span>)</span> <span>error</span> <span>{</span>
</span></span><span><span>	<span>err</span> <span>:=</span> <span>h</span><span>.</span><span>userRepository</span><span>.</span><span>UpdateByID</span><span>(</span><span>ctx</span><span>,</span> <span>cmd</span><span>.</span><span>UserID</span><span>,</span> <span>func</span><span>(</span><span>user</span> <span>*</span><span>User</span><span>)</span> <span>(</span><span>bool</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>		<span>err</span> <span>:=</span> <span>user</span><span>.</span><span>UsePoints</span><span>(</span><span>cmd</span><span>.</span><span>Points</span><span>)</span>
</span></span><span><span>		<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>			<span>return</span> <span>false</span><span>,</span> <span>err</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>
</span></span><span><span>		<span>return</span> <span>true</span><span>,</span> <span>nil</span>
</span></span><span><span>	<span>})</span>
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>		<span>return</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;could not update user: %w&#34;</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>err</span> <span>=</span> <span>h</span><span>.</span><span>ordersService</span><span>.</span><span>AddDiscount</span><span>(</span><span>ctx</span><span>,</span> <span>cmd</span><span>.</span><span>UserID</span><span>,</span> <span>cmd</span><span>.</span><span>Points</span><span>)</span>
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>		<span>return</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;could not add discount: %w&#34;</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>nil</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>We first take the user’s points. After committing the transaction, we call the <code>orders</code> service to add a discount.
It works well in a happy path scenario, but the HTTP call works outside the transaction.
If anything goes wrong, the points are gone, but we add no discount.
The best we can do is log the error and fire an alert so someone on-call can manually add the discount for the annoyed customer.</p><p>Welcome to the distributed monolith.</p><p><img title="" loading="lazy" decoding="async" width="1050" height="432" src="https://threedots.tech/post/distributed-transactions-in-go/images/1-distributed-monolith_hu9c541f083a1498e44f6a598271ebac34_61537_1050x432_resize_q80_h2_lanczos_3.webp" alt="Distributed Monolith" onerror="this.onerror=&#34;null&#34;,this.src=&#34;/post/distributed-transactions-in-go/images/1-distributed-monolith_hu9c541f083a1498e44f6a598271ebac34_61537_1050x432_resize_lanczos_3.png&#34;"/></p><div><p>❌ Anti-pattern: The Distributed Monolith</p><p>Be extra careful when designing the boundaries of microservices. What seems like a minor decision in the beginning can have terrible consequences in the future.
If in doubt, stick to a single service and decouple your code using modules — <a href="https://threedots.tech/post/microservices-or-monolith-its-detail/" target="_blank">the modular monolith approach</a>.</p></div><p>One way out of this mess is to accept past mistakes and merge the microservices into one service.
Depending on the approach used and the size of the services, it may not be a quick task.
And if your product backlog is full and people who designed the microservices are still around, it’s unlikely to happen.</p><p>If you see the problem as “we miss consistency between services”,
running a distributed transaction seems like a good solution.
But the real problem is “the boundaries are wrong”.
It’s easy to make the project much more complicated because of this misinterpretation.</p><p>One alternative is to <strong>embrace eventual consistency</strong>.</p><h2 id="eventual-consistency">Eventual Consistency</h2><p>The idea is that the data (the user’s points and applied discount in our example) stays consistent but no longer within a single transaction.
In practice, there’s a slight delay — usually milliseconds — during which the system is inconsistent but then catches up.</p><p>The system may become out of sync for longer if something goes wrong.
But the important part is that it <em>eventually</em> becomes consistent again.
<strong>We don’t accept inconsistency — we’re just okay with waiting for it to happen.</strong>
Think about sending a bank transfer.
The money disappears from your account immediately but isn’t visible on the other account right away.
You know it will eventually happen within a few hours or days, so it’s not an issue.</p><p>Whether it’s acceptable in a given scenario is often a business decision. Since business stakeholders generally don’t consider this, engineers must explain it and suggest solutions.</p><p>Having a transaction boundary sounds reasonable in the “using points as a discount” scenario.
But since we already have to work with a distributed monolith, choosing eventual consistency might be the next best thing instead of implementing a distributed transaction.</p><div><p>I could have picked another example that would be more fit for eventual consistency. In some cases, data doesn&#39;t need to be consistent at all.</p></div><h3 id="events">Events</h3><p>Eventual consistency usually means working with events.</p><p>Going this path, we no longer call the <code>orders</code> service directly.
We take the user’s points and <em>publish an event</em>, like <code>PointsUsedForDiscount</code>, to record that it happened.</p><p>The event is stored on a message queue (AKA a Pub/Sub), a reliable, highly-available infrastructure for messages.
The <code>orders</code> service receives this event and reacts by applying a discount for the next order.
We can then update the discount value on the website (for example, with <a href="https://threedots.tech/post/live-website-updates-go-sse-htmx/" target="_blank">Server-Sent Events</a>).
Most of the time, it takes milliseconds, and the customers can’t tell a difference.</p><p><img title="" loading="lazy" decoding="async" width="1029" height="925" src="https://threedots.tech/post/distributed-transactions-in-go/images/2-event-driven_hu5f9ac72418618ecf7b66abe49ef949d0_122934_1029x925_resize_q80_h2_lanczos_3.webp" alt="Event Driven" onerror="this.onerror=&#34;null&#34;,this.src=&#34;/post/distributed-transactions-in-go/images/2-event-driven_hu5f9ac72418618ecf7b66abe49ef949d0_122934_1029x925_resize_lanczos_3.png&#34;"/></p><p>It’s sometimes better to retry the operation internally instead of showing a scary error message to the user.
After all, the issue might be temporary, and retrying is often a good enough fix.
However, you need to consider it separately for each scenario.
It’s often crucial that the user knows an error has occurred.</p><p>If the <code>orders</code> service goes down, it won’t interrupt the process.
<strong>The event will be delivered again and again until it’s processed successfully.</strong>
Once the service comes up, the discount will be applied as expected.</p><p>It doesn’t fix all the issues.
For example, the customer won’t see the discount if the service is down for a few hours.
But it gives us a solid way of retrying the operation if it’s a short issue.
In many scenarios, retrying for a few hours is also acceptable (generating reports, issuing invoices, etc.).</p><p>In most cases, <strong>we don’t need to manually investigate what data needs to be backfilled, and no one needs to wake up in the middle of the night.</strong> The system auto-heals with time.</p><div><p>✅ Tactic: Embrace Eventual Consistency</p><p>Not all operations need to be strongly consistent, even if it initially seems like it.</p></div><h3 id="implementation">Implementation</h3><p>To start working with messages, you must pick a broker (the infrastructure part), just like when choosing a database.
You publish messages to the broker, which asynchronously pushes them to all subscribers.
In this post, I’m going to use Redis.</p><p><img title="" loading="lazy" decoding="async" width="1687" height="659" src="https://threedots.tech/post/distributed-transactions-in-go/images/7-pubsub_hua694b087d006714260b29106c5ca2ee6_101093_1687x659_resize_q80_h2_lanczos_3.webp" alt="Pub/Sub" onerror="this.onerror=&#34;null&#34;,this.src=&#34;/post/distributed-transactions-in-go/images/7-pubsub_hua694b087d006714260b29106c5ca2ee6_101093_1687x659_resize_lanczos_3.png&#34;"/></p><p>Most popular brokers (Pub/Subs) have a Go library (SDK) that lets you interact with it.
But they usually offer a low-level API.
As much as I like Go’s <code>net/http</code>, I still prefer using Echo or Chi for their high-level API. Similarly, I will use <a href="https://watermill.io" target="_blank">Watermill</a> to work with messages.</p><p>Watermill is a Go library we maintain.
I won’t explain how it works here in detail. See the <a href="https://watermill.io/docs/getting-started/" target="_blank">Getting Started page</a> for an overview.
It supports <a href="https://watermill.io/pubsubs/" target="_blank">many Pub/Sub backends</a>, like Kafka, AMQP, NATS, or Redis.</p><div><p>All the ideas below are universal and can be implemented with any other messaging library.</p></div><p>We’ll use the pair of <code>EventBus</code> and <code>EventProcessor</code> components from Watermill’s <code>cqrs</code> package.</p><p><img title="" loading="lazy" decoding="async" width="1324" height="716" src="https://threedots.tech/post/distributed-transactions-in-go/images/9-cqrs_hu416387cd7ea843a1e39f99730af141f4_95655_1324x716_resize_q80_h2_lanczos_3.webp" alt="CQRS" onerror="this.onerror=&#34;null&#34;,this.src=&#34;/post/distributed-transactions-in-go/images/9-cqrs_hu416387cd7ea843a1e39f99730af141f4_95655_1324x716_resize_lanczos_3.png&#34;"/></p><p>First, let’s replace the HTTP call with publishing an event.
The event bus lets us publish messages with a JSON payload.
The setup should be easy to grasp even if you don’t know Watermill yet.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>client</span> <span>:=</span> <span>redis</span><span>.</span><span>NewClient</span><span>(</span><span>&amp;</span><span>redis</span><span>.</span><span>Options</span><span>{</span>
</span></span><span><span>    <span>Addr</span><span>:</span> <span>redisAddr</span><span>,</span>
</span></span><span><span><span>})</span>
</span></span><span><span>
</span></span><span><span><span>logger</span> <span>:=</span> <span>watermill</span><span>.</span><span>NewStdLogger</span><span>(</span><span>false</span><span>,</span> <span>false</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>publisher</span><span>,</span> <span>err</span> <span>:=</span> <span>redisstream</span><span>.</span><span>NewPublisher</span><span>(</span>
</span></span><span><span>    <span>redisstream</span><span>.</span><span>PublisherConfig</span><span>{</span>
</span></span><span><span>        <span>Client</span><span>:</span> <span>client</span><span>,</span>
</span></span><span><span>    <span>},</span>
</span></span><span><span>    <span>logger</span><span>,</span>
</span></span><span><span><span>)</span>
</span></span><span><span><span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>nil</span><span>,</span> <span>err</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>eventBus</span><span>,</span> <span>err</span> <span>:=</span> <span>cqrs</span><span>.</span><span>NewEventBusWithConfig</span><span>(</span><span>publisher</span><span>,</span> <span>cqrs</span><span>.</span><span>EventBusConfig</span><span>{</span>
</span></span><span><span>    <span>GeneratePublishTopic</span><span>:</span> <span>func</span><span>(</span><span>params</span> <span>cqrs</span><span>.</span><span>GenerateEventPublishTopicParams</span><span>)</span> <span>(</span><span>string</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>params</span><span>.</span><span>EventName</span><span>,</span> <span>nil</span>
</span></span><span><span>    <span>},</span>
</span></span><span><span>    <span>Marshaler</span><span>:</span> <span>cqrs</span><span>.</span><span>JSONMarshaler</span><span>{},</span>
</span></span><span><span>    <span>Logger</span><span>:</span> <span>logger</span><span>,</span>
</span></span><span><span><span>})</span>
</span></span></code></pre></div><p>We create a Redis publisher and an <code>EventBus</code>. It’s going to use the event’s name as a topic. (A topic is what you subscribe to to receive messages.) It’s going to marshal events into JSON.</p><p>In the command handler, we replace the synchronous call with publishing an event.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>EventPublisher</span> <span>interface</span> <span>{</span>
</span></span><span><span>    <span>Publish</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>event</span> <span>any</span><span>)</span> <span>error</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>PointsUsedForDiscount</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>UserID</span> <span>int</span> <span>`json:&#34;user_id&#34;`</span>
</span></span><span><span>    <span>Points</span> <span>int</span> <span>`json:&#34;points&#34;`</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>h</span> <span>UsePointsAsDiscountHandler</span><span>)</span> <span>Handle</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>cmd</span> <span>UsePointsAsDiscount</span><span>)</span> <span>error</span> <span>{</span>
</span></span><span><span>	<span>err</span> <span>:=</span> <span>h</span><span>.</span><span>userRepository</span><span>.</span><span>UpdateByID</span><span>(</span><span>ctx</span><span>,</span> <span>cmd</span><span>.</span><span>UserID</span><span>,</span> <span>func</span><span>(</span><span>user</span> <span>*</span><span>User</span><span>)</span> <span>(</span><span>bool</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>		<span>err</span> <span>:=</span> <span>user</span><span>.</span><span>UsePoints</span><span>(</span><span>cmd</span><span>.</span><span>Points</span><span>)</span>
</span></span><span><span>		<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>			<span>return</span> <span>false</span><span>,</span> <span>err</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>
</span></span><span><span>		<span>return</span> <span>true</span><span>,</span> <span>nil</span>
</span></span><span><span>	<span>})</span>
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>		<span>return</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;could not update user: %w&#34;</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>event</span> <span>:=</span> <span>PointsUsedForDiscount</span><span>{</span>
</span></span><span><span>        <span>UserID</span><span>:</span> <span>cmd</span><span>.</span><span>UserID</span><span>,</span>
</span></span><span><span>        <span>Points</span><span>:</span> <span>cmd</span><span>.</span><span>Points</span><span>,</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>err</span> <span>=</span> <span>h</span><span>.</span><span>eventPublisher</span><span>.</span><span>Publish</span><span>(</span><span>ctx</span><span>,</span> <span>event</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;could not publish event: %w&#34;</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>nil</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>In the <code>orders</code> service, we replace the HTTP handler with an event handler.</p><p>Let’s set up an <code>EventProcessor</code> for subscribing, just like we set up the event bus for publishing.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>client</span> <span>:=</span> <span>redis</span><span>.</span><span>NewClient</span><span>(</span><span>&amp;</span><span>redis</span><span>.</span><span>Options</span><span>{</span>
</span></span><span><span>    <span>Addr</span><span>:</span> <span>redisAddr</span><span>,</span>
</span></span><span><span><span>})</span>
</span></span><span><span>
</span></span><span><span><span>logger</span> <span>:=</span> <span>watermill</span><span>.</span><span>NewStdLogger</span><span>(</span><span>false</span><span>,</span> <span>false</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>router</span> <span>:=</span> <span>message</span><span>.</span><span>NewDefaultRouter</span><span>(</span><span>logger</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>eventProcessor</span><span>,</span> <span>err</span> <span>:=</span> <span>cqrs</span><span>.</span><span>NewEventProcessorWithConfig</span><span>(</span><span>router</span><span>,</span> <span>cqrs</span><span>.</span><span>EventProcessorConfig</span><span>{</span>
</span></span><span><span>    <span>GenerateSubscribeTopic</span><span>:</span> <span>func</span><span>(</span><span>params</span> <span>cqrs</span><span>.</span><span>EventProcessorGenerateSubscribeTopicParams</span><span>)</span> <span>(</span><span>string</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>params</span><span>.</span><span>EventName</span><span>,</span> <span>nil</span>
</span></span><span><span>    <span>},</span>
</span></span><span><span>    <span>SubscriberConstructor</span><span>:</span> <span>func</span><span>(</span><span>params</span> <span>cqrs</span><span>.</span><span>EventProcessorSubscriberConstructorParams</span><span>)</span> <span>(</span><span>message</span><span>.</span><span>Subscriber</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>redisstream</span><span>.</span><span>NewSubscriber</span><span>(</span>
</span></span><span><span>            <span>redisstream</span><span>.</span><span>SubscriberConfig</span><span>{</span>
</span></span><span><span>                <span>Client</span><span>:</span>        <span>client</span><span>,</span>
</span></span><span><span>                <span>ConsumerGroup</span><span>:</span> <span>&#34;orders-svc&#34;</span><span>,</span>
</span></span><span><span>            <span>},</span>
</span></span><span><span>            <span>logger</span><span>,</span>
</span></span><span><span>        <span>)</span>
</span></span><span><span>    <span>},</span>
</span></span><span><span>    <span>Marshaler</span><span>:</span> <span>cqrs</span><span>.</span><span>JSONMarshaler</span><span>{},</span>
</span></span><span><span>    <span>Logger</span><span>:</span>    <span>logger</span><span>,</span>
</span></span><span><span><span>})</span>
</span></span></code></pre></div><p>The setup is almost identical to the publishing side.
The main difference is that we provide a constructor instead of a single subscriber.
I won’t dive into the reasons, as they are irrelevant to what we want to do.
To receive messages correctly, we must use the same marshaler and topic configuration as in the event bus config.</p><p>Next, we need an event handler. It simply maps the event payload to the command and executes it, just like the HTTP handler did.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>OnPointsUsedForDiscountHandler</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>addDiscountHandler</span> <span>AddDiscountHandler</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>h</span> <span>OnPointsUsedForDiscountHandler</span><span>)</span> <span>Handle</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>event</span> <span>*</span><span>PointsUsedForDiscount</span><span>)</span> <span>error</span> <span>{</span>
</span></span><span><span>    <span>cmd</span> <span>:=</span> <span>AddDiscount</span><span>{</span>
</span></span><span><span>        <span>UserID</span><span>:</span>   <span>event</span><span>.</span><span>UserID</span><span>,</span>
</span></span><span><span>        <span>Discount</span><span>:</span> <span>event</span><span>.</span><span>Points</span><span>,</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>h</span><span>.</span><span>addDiscountHandler</span><span>.</span><span>Handle</span><span>(</span><span>ctx</span><span>,</span> <span>cmd</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>We add it to the event processor.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>err</span> <span>=</span> <span>eventProcessor</span><span>.</span><span>AddHandlers</span><span>(</span>
</span></span><span><span>    <span>cqrs</span><span>.</span><span>NewEventHandler</span><span>(</span>
</span></span><span><span>        <span>&#34;OnPointsUsedForDiscountHandler&#34;</span><span>,</span>
</span></span><span><span>        <span>onPointsUsedForDiscountHandler</span><span>.</span><span>Handle</span><span>,</span>
</span></span><span><span>    <span>),</span>
</span></span><span><span><span>)</span>
</span></span></code></pre></div><p>The behavior is exactly the same as that of the HTTP endpoint.
The message is just another transport, and the handler is another entry point to the application.
The main difference is that it’s asynchronous, so no client waits for it to complete.</p><p><img title="" loading="lazy" decoding="async" width="1291" height="320" src="https://threedots.tech/post/distributed-transactions-in-go/images/4-message_hub2e1ab57fca11f9bff26d40cd16bd166_52376_1291x320_resize_q80_h2_lanczos_3.webp" alt="Message" onerror="this.onerror=&#34;null&#34;,this.src=&#34;/post/distributed-transactions-in-go/images/4-message_hub2e1ab57fca11f9bff26d40cd16bd166_52376_1291x320_resize_lanczos_3.png&#34;"/></p><p>That’s it!
With a few changes, we replaced the synchronous HTTP call with a message handler.</p><p>Of course, there’s the hard part of running a production-grade Pub/Sub.
I used Redis, but you can pick what you feel comfortable with or what your cloud provider offers.
You can even start with an SQL database if you don’t want to set up new infrastructure.</p><h2 id="the-outbox-pattern">The Outbox Pattern</h2><p>There’s still one scenario when things can go wrong.
Since publishing the message works over the network, it can fail, just like the HTTP call to another service.
Pub/Subs are usually highly available, but issues still happen (never assume the network is reliable!).
We could lose the messages after the transaction is committed.</p><p><img title="" loading="lazy" decoding="async" width="1154" height="476" src="https://threedots.tech/post/distributed-transactions-in-go/images/6-outbox_hud59d468c91eecd1c43714b738b9852b1_68591_1154x476_resize_q80_h2_lanczos_3.webp" alt="Outbox" onerror="this.onerror=&#34;null&#34;,this.src=&#34;/post/distributed-transactions-in-go/images/6-outbox_hud59d468c91eecd1c43714b738b9852b1_68591_1154x476_resize_lanczos_3.png&#34;"/></p><p><strong>It’s one of the most common mistakes we’ve seen: ignoring this scenario with the hope it will never happen.</strong>
It’s unlikely, sure, but you don’t want to take this risk. Imagine figuring out what events you lost and manually correcting the system’s state.</p><p>We need to store changes in the database and publish the event within the same transaction. Is this possible?</p><p><strong>Yes, we can use the outbox pattern</strong>.
The idea is to save the event in the same database as the regular data within the same transaction.
Then, <strong>we asynchronously publish it to the Pub/Sub.</strong>
This way, the event and the stored data will always be consistent, and we will not rely on the Pub/Sub to be around.
The events can be simply stored in a dedicated SQL table.</p><p>The main challenge is waiting for new events and moving them to the Pub/Sub.
Depending on the database, you can use some custom software, although configuring it is often quite complex.
You can implement it from scratch, but it’s not trivial.</p><p>In this example, I’ll use Watermill’s <a href="https://watermill.io/docs/forwarder/" target="_blank">Forwarder</a> component to achieve this.
Its behavior is straightforward, thanks to the heavy lifting done by the Pub/Sub implementation.
It listens to messages from the given Pub/Sub and publishes them to another Pub/Sub.</p><p><img title="" loading="lazy" decoding="async" width="1727" height="464" src="https://threedots.tech/post/distributed-transactions-in-go/images/8-forwarder_huc37b28c94bd820a36b7a45be5b620d9b_88702_1727x464_resize_q80_h2_lanczos_3.webp" alt="Forwarder" onerror="this.onerror=&#34;null&#34;,this.src=&#34;/post/distributed-transactions-in-go/images/8-forwarder_huc37b28c94bd820a36b7a45be5b620d9b_88702_1727x464_resize_lanczos_3.png&#34;"/></p><p>Watermill supports Postgres as one of the Pub/Sub implementations, so adding it to the existing setup is easy.
(Yes, you can simply use an SQL database as your messaging infrastructure.)</p><p><img title="" loading="lazy" decoding="async" width="1305" height="1235" src="https://threedots.tech/post/distributed-transactions-in-go/images/3-outbox_hu206b4751c136e729e48d74c36add6942_184047_1305x1235_resize_q80_h2_lanczos_3.webp" alt="Outbox" onerror="this.onerror=&#34;null&#34;,this.src=&#34;/post/distributed-transactions-in-go/images/3-outbox_hu206b4751c136e729e48d74c36add6942_184047_1305x1235_resize_lanczos_3.png&#34;"/></p><p>We face another design dilemma.
How can the publisher and repository work together without mixing the logic and the database code?</p><p><strong>We’ll extend the <code>UpdateFn</code> function so it decides what events should be published.</strong>
(For more on how this pattern works, see the <a href="https://threedots.tech/post/database-transactions-in-go/">post on database transactions</a>.)</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>(</span><span>h</span> <span>UsePointsAsDiscountHandler</span><span>)</span> <span>Handle</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>cmd</span> <span>UsePointsAsDiscount</span><span>)</span> <span>error</span> <span>{</span>
</span></span><span><span>	<span>return</span> <span>h</span><span>.</span><span>userRepository</span><span>.</span><span>UpdateByID</span><span>(</span><span>ctx</span><span>,</span> <span>cmd</span><span>.</span><span>UserID</span><span>,</span> <span>func</span><span>(</span><span>user</span> <span>*</span><span>User</span><span>)</span> <span>(</span><span>bool</span><span>,</span> <span>[]</span><span>any</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>		<span>err</span> <span>:=</span> <span>user</span><span>.</span><span>UsePoints</span><span>(</span><span>cmd</span><span>.</span><span>Points</span><span>)</span>
</span></span><span><span>		<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>			<span>return</span> <span>false</span><span>,</span> <span>nil</span><span>,</span> <span>err</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>
</span></span><span><span>		<span>event</span> <span>:=</span> <span>PointsUsedForDiscount</span><span>{</span>
</span></span><span><span>			<span>UserID</span><span>:</span> <span>cmd</span><span>.</span><span>UserID</span><span>,</span>
</span></span><span><span>			<span>Points</span><span>:</span> <span>cmd</span><span>.</span><span>Points</span><span>,</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>
</span></span><span><span>		<span>return</span> <span>true</span><span>,</span> <span>[]</span><span>any</span><span>{</span><span>event</span><span>},</span> <span>nil</span>
</span></span><span><span>	<span>})</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The repository publishes the returned events.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>updated</span><span>,</span> <span>events</span><span>,</span> <span>err</span> <span>:=</span> <span>updateFn</span><span>(</span><span>user</span><span>)</span>
</span></span><span><span><span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>err</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>!</span><span>updated</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>nil</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>_</span><span>,</span> <span>err</span> <span>=</span> <span>tx</span><span>.</span><span>ExecContext</span><span>(</span><span>ctx</span><span>,</span> <span>&#34;UPDATE users SET email = $1, points = $2 WHERE id = $3&#34;</span><span>,</span> <span>user</span><span>.</span><span>Email</span><span>(),</span> <span>user</span><span>.</span><span>Points</span><span>(),</span> <span>user</span><span>.</span><span>ID</span><span>())</span>
</span></span><span><span><span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>err</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>eventBus</span><span>,</span> <span>err</span> <span>:=</span> <span>NewWatermillEventBus</span><span>(</span><span>tx</span><span>)</span>
</span></span><span><span><span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>err</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>for</span> <span>_</span><span>,</span> <span>event</span> <span>:=</span> <span>range</span> <span>events</span> <span>{</span>
</span></span><span><span>    <span>err</span> <span>=</span> <span>eventBus</span><span>.</span><span>Publish</span><span>(</span><span>ctx</span><span>,</span> <span>event</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>err</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Note how a new event bus is created using the <code>tx</code> variable.
This is how we ensure publishing happens within the same transaction.</p><p>We must amend how the event bus is created in the <code>users</code> service.
We will no longer publish directly to Redis.
We need to change the original publisher from Redis to Postgres.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>publisher</span><span>,</span> <span>err</span> <span>=</span> <span>watermillSQL</span><span>.</span><span>NewPublisher</span><span>(</span>
</span></span><span><span>    <span>db</span><span>,</span>
</span></span><span><span>    <span>watermillSQL</span><span>.</span><span>PublisherConfig</span><span>{</span>
</span></span><span><span>        <span>SchemaAdapter</span><span>:</span> <span>watermillSQL</span><span>.</span><span>DefaultPostgreSQLSchema</span><span>{},</span>
</span></span><span><span>    <span>},</span>
</span></span><span><span>    <span>logger</span><span>,</span>
</span></span><span><span><span>)</span>
</span></span></code></pre></div><p>Next, we <em>wrap</em> this publisher with the forwarder’s <code>Publisher</code>.
It introduces an <em>envelope</em> around the message so the forwarder knows how to handle it. Its config is minimal.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>publisher</span> <span>=</span> <span>forwarder</span><span>.</span><span>NewPublisher</span><span>(</span>
</span></span><span><span>    <span>publisher</span><span>,</span>
</span></span><span><span>    <span>forwarder</span><span>.</span><span>PublisherConfig</span><span>{</span>
</span></span><span><span>        <span>ForwarderTopic</span><span>:</span> <span>forwarderTopic</span><span>,</span>
</span></span><span><span>    <span>},</span>
</span></span><span><span><span>)</span>
</span></span></code></pre></div><p>The last part is running the forwarder.
While it could be a standalone service, keeping it running as another goroutine within the <code>users</code> service is also fine.</p><p>We need an SQL subscriber to receive the stored events from the database,
and a Redis publisher to publish the messages where the <code>orders</code> service expects them.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>sqlSubscriber</span><span>,</span> <span>err</span> <span>:=</span> <span>watermillSQL</span><span>.</span><span>NewSubscriber</span><span>(</span>
</span></span><span><span>    <span>db</span><span>,</span>
</span></span><span><span>    <span>watermillSQL</span><span>.</span><span>SubscriberConfig</span><span>{</span>
</span></span><span><span>        <span>SchemaAdapter</span><span>:</span>    <span>watermillSQL</span><span>.</span><span>DefaultPostgreSQLSchema</span><span>{},</span>
</span></span><span><span>        <span>OffsetsAdapter</span><span>:</span>   <span>watermillSQL</span><span>.</span><span>DefaultPostgreSQLOffsetsAdapter</span><span>{},</span>
</span></span><span><span>        <span>InitializeSchema</span><span>:</span> <span>true</span><span>,</span>
</span></span><span><span>    <span>},</span>
</span></span><span><span>    <span>logger</span><span>,</span>
</span></span><span><span><span>)</span>
</span></span><span><span><span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>nil</span><span>,</span> <span>err</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>client</span> <span>:=</span> <span>redis</span><span>.</span><span>NewClient</span><span>(</span><span>&amp;</span><span>redis</span><span>.</span><span>Options</span><span>{</span>
</span></span><span><span>    <span>Addr</span><span>:</span> <span>redisAddr</span><span>,</span>
</span></span><span><span><span>})</span>
</span></span><span><span>
</span></span><span><span><span>redisPublisher</span><span>,</span> <span>err</span> <span>:=</span> <span>redisstream</span><span>.</span><span>NewPublisher</span><span>(</span>
</span></span><span><span>    <span>redisstream</span><span>.</span><span>PublisherConfig</span><span>{</span>
</span></span><span><span>        <span>Client</span><span>:</span> <span>client</span><span>,</span>
</span></span><span><span>    <span>},</span>
</span></span><span><span>    <span>logger</span><span>,</span>
</span></span><span><span><span>)</span>
</span></span><span><span><span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>nil</span><span>,</span> <span>err</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>fwd</span><span>,</span> <span>err</span> <span>:=</span> <span>forwarder</span><span>.</span><span>NewForwarder</span><span>(</span>
</span></span><span><span>    <span>sqlSubscriber</span><span>,</span>
</span></span><span><span>    <span>redisPublisher</span><span>,</span>
</span></span><span><span>    <span>logger</span><span>,</span>
</span></span><span><span>    <span>forwarder</span><span>.</span><span>Config</span><span>{</span>
</span></span><span><span>        <span>ForwarderTopic</span><span>:</span> <span>forwarderTopic</span><span>,</span>
</span></span><span><span>    <span>},</span>
</span></span><span><span><span>)</span>
</span></span></code></pre></div><p>Note that <strong>the forwarder topic needs to match between the forwarder publisher and the forwarder itself</strong>.
In this case, it’s the same <code>forwarderTopic</code> constant (can be any string).</p><p>Finally, we run the forwarder.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>go</span> <span>func</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>err</span> <span>:=</span> <span>forwarder</span><span>.</span><span>Run</span><span>(</span><span>context</span><span>.</span><span>Background</span><span>())</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>panic</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}()</span>
</span></span></code></pre></div><p>No changes are necessary on the <code>orders</code> service side.
As far as it’s concerned, it receives events from Redis, as it used to.</p><div><p>✅ Tactic: The Outbox Pattern</p><p>Use the Outbox pattern to publish events within a database transaction.
Don’t leave it to chance whether all events will be successfully published.</p></div><h2 id="simplifying-or-complicating">Simplifying or Complicating?</h2><p>There are many moving parts here.
Event-driven patterns are not trivial, and you need to understand what you’re doing to some degree.
If you never used these concepts before, it can seem complex.</p><p>I used to have these concerns as well.
The system seems simpler with just the synchronous APIs and a database.
Why complicate it with adding all this background processing?</p><p>As counterintuitive as it is, you can simplify your distributed system using these ideas.
Because you work with facts that happened (events), you don’t need to consider rollbacks, which terribly complicate your flow.</p><p>A rollback can interfere with other flows, so you need distributed locks to protect the state.
Rollbacks can also fail. What do you do when this happens?</p><p>As the snippets show, little code is needed to start working with events, and the handlers are also straightforward.
This is where Watermill helps by removing the low-level boilerplate.
You can focus on setting up the handlers and publishing messages
with an API that’s easier to use than HTTP endpoints.</p><p>Once you grasp the basics, your mental model will start changing, and eventually, it will click.
You’ll get the intuition on how to design event-driven systems.</p><h3 id="events--coupling">Events &amp; Coupling</h3><p>Make no mistake, events are still a form of a contract.
The fact you use them doesn’t magically make your services decoupled.
Incorrectly designed events are another trap you can fall into.</p><p>What I like about the pattern is that it limits what the services know about each other.
But it’s easy to fail at this.</p><p>The example above shows that the event is designed quite poorly.
The <code>UsePointsAsDiscount</code> name makes the <code>users</code> service aware of what happens in the <code>orders</code> service after it receives it.
It’s too late to escape this now, though.
The service boundaries are just wrong from the beginning.</p><p>Well-designed events state a fact that happened in this service’s domain.
The service publishing the event should not know or care what happens when another service consumes it.</p><h3 id="testing">Testing</h3><p>Testing event-driven services is not much different, but here are some tips.</p><p>Run your Pub/Sub locally in a Docker container and test against it.
Cloud-based Pub/Subs usually offer an emulator (but often with no feature parity, so watch out).</p><p>Testing the event handler code makes little sense.
Event handlers should just execute your application logic with the data from the event.
Instead, use <a href="https://threedots.tech/post/microservices-test-architecture/">component tests</a>
to test the behavior of the service using the public API.</p><p>A test scenario can be something like:</p><ul><li>Once this event is published, an entity read over HTTP should change.</li><li>Once this HTTP endpoint is called, an event should be published.</li><li>Once this event is published, another event should be published.</li></ul><p>If you use <code>testify</code>, the <code>Eventually</code> and <code>EventuallyWithT</code> functions are helpful.
(The second one allows using asserts inside).
They run the assert code periodically until it’s successful or until it times out.
Use these instead of plain sleeps, as they slow down your tests.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>assert</span><span>.</span><span>EventuallyWithT</span><span>(</span><span>t</span><span>,</span> <span>func</span><span>(</span><span>t</span> <span>*</span><span>assert</span><span>.</span><span>CollectT</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>row</span> <span>:=</span> <span>discountDB</span><span>.</span><span>QueryRowContext</span><span>(</span><span>context</span><span>.</span><span>Background</span><span>(),</span> <span>&#34;SELECT next_order_discount FROM user_discounts WHERE user_id = $1&#34;</span><span>,</span> <span>userID</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>var</span> <span>discount</span> <span>int</span>
</span></span><span><span>    <span>err</span> <span>:=</span> <span>row</span><span>.</span><span>Scan</span><span>(</span><span>&amp;</span><span>discount</span><span>)</span>
</span></span><span><span>    <span>require</span><span>.</span><span>NoError</span><span>(</span><span>t</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>assert</span><span>.</span><span>Equal</span><span>(</span><span>t</span><span>,</span> <span>expectedDiscount</span><span>,</span> <span>discount</span><span>)</span>
</span></span><span><span><span>},</span> <span>2</span><span>*</span><span>time</span><span>.</span><span>Second</span><span>,</span> <span>100</span><span>*</span><span>time</span><span>.</span><span>Millisecond</span><span>)</span>
</span></span></code></pre></div><p>When reading events, watch out for others that may interfere.
With many tests running in parallel, it’s common to have many events of the same type published.
You need to filter them based on the ID or some metadata.
Using UUIDs for this is best so your tests are completely independent.</p><p>Finally, run your tests in parallel to speed them up.
With lots of time spent on I/O and waiting, this quickly adds up.
There are some quirks to running Go tests in parallel, though.
Robert is currently working on an article on how to do it right —
<a href="https://threedots.tech/newsletter">join our newsletter</a>, and we’ll let you know once it’s ready.</p><h3 id="monitoring">Monitoring</h3><p>Observability is a long topic, and there’s much to be said about metrics and tracing for event-driven systems.
This is beyond the scope of this post, but I want to mention monitoring the queue of waiting messages.</p><p>If a message fails to be processed (i.e., the handler returns an error for whatever reason), it will be delivered again.
Depending on the Pub/Sub you picked and its configuration, it can block other messages from being delivered.</p><p>This is your key metric to monitor.
Having unprocessed messages for a long time usually means something went wrong, and it’s not a temporary issue.
You need manual intervention, or your system will be out of sync.</p><h2 id="more-examples">More Examples</h2><p>This scratches the surface of switching to eventual consistency, but it should be enough to get you started.
To learn about different use cases, check <a href="https://github.com/ThreeDotsLabs/watermill?tab=readme-ov-file#examples" target="_blank">Watermill examples</a>.
There are some basic ones, but also more advanced and interesting examples.</p><p>As with most programming topics, reading about something is rarely enough to fully get it.
For me, building something on my own is what makes me fully understand it.
But it’s often hard to come up with an idea for a project to build.
We wanted to recreate this way of learning, so we designed a hands-on <a href="https://threedots.tech/event-driven/?utm_source=distributed-transactions" target="_blank">event-driven training</a>.
Consider joining us if you like learning like this.</p></div></div>
  </body>
</html>
