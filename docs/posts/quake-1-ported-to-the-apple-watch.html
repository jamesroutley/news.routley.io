<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/MyOwnClone/quake_watch">Original</a>
    <h1>Show HN: Quake 1 ported to the Apple Watch</h1>
    
    <div id="readability-page-1" class="page"><div>
     

<p>Hello!</p>

<p>Recently I’ve been working on a project where I implement a bunch of tiny toy
working versions of computer networking protocols in Python without using any
libraries, as a way to explain how computer networking works.</p>

<p>I’m still working on writing up that project, but today I wanted to talk about
how to do the very first step: sending network packets in Python.</p>

<p>In this post we’re going to send a SYN packet (the first packet in a TCP
connection) from a tiny Python program, and get a reply from <code>example.com</code>. All the code from this post is in <a href="https://gist.github.com/jvns/552e6d5e6fec6c3ddf2fcd4ccdab45d5">this gist</a>.</p>

<h3 id="what-s-a-network-packet">what’s a network packet?</h3>

<p>A network packet is a byte string. For example, here’s the first packet in a TCP connection:</p>

<pre><code>b&#39;E\x00\x00,\x00\x01\x00\x00@\x06\x00\xc4\xc0\x00\x02\x02&#34;\xc2\x95Cx\x0c\x00P\xf4p\x98\x8b\x00\x00\x00\x00`\x02\xff\xff\x18\xc6\x00\x00\x02\x04\x05\xb4&#39;
</code></pre>

<p>I’m not going to talk about the structure of this byte string in this post
(though I’ll say that this particular byte string has two parts: the first 20
bytes are the IP address part and the rest is the TCP part)</p>

<p>The point is that to send network packets, we need to be able to send and
receive strings of bytes.</p>

<h3 id="why-tun-tap">why tun/tap?</h3>

<p>The problem with writing your own TCP implementation on Linux (or any operating
system) is – the Linux kernel already has a TCP implementation!</p>

<p>So if you send out a SYN packet on your normal network interface to a host like
example.com, here’s what will happen:</p>

<ol>
<li>you send a SYN packet to example.com</li>
<li>example.com replies with a SYN ACK (so far so good!)</li>
<li>the Linux kernel on your machine gets the SYN ACK, thinks “wtf?? I didn’t make this connection??”, and closes the connection</li>
<li>you’re sad. no TCP connection for you.</li>
</ol>

<p>I was talking to a friend about this problem a few years ago and he said “you
should use tun/tap!“. It took quite a few hours to figure out how to do that
though, which is why I’m writing this blog post :)</p>

<h3 id="tun-tap-gives-you-a-virtual-network-device">tun/tap gives you a “virtual network device”</h3>

<p>The way I like to think of <code>tun/tap</code> is – imagine I have a tiny computer in my
network which is sending and receiving network packets. But instead of it being
a real computer, it’s just a Python program I wrote.</p>

<p>That explanation is honestly worse than I would like. I wish I understood
exactly how tun/tap devices interfaced with the real Linux network stack but
unfortunately I do not, so “virtual network device” is what you’re getting.
Hopefully the code examples below will make all it a bit more clear.</p>

<h3 id="tun-vs-tap">tun vs tap</h3>

<p>The system called “tun/tap” lets you create two kinds of network interfaces:</p>

<ul>
<li>“tun”, which lets you set IP-layer packets</li>
<li>“tap”, which lets you set Ethernet-layer packets</li>
</ul>

<p>We’re going to be using <strong>tun</strong>, because that’s what I could figure out how to
get to work. It’s possible that tap would work too.</p>

<h3 id="how-to-create-a-tun-interface">how to create a tun interface</h3>

<p>Here’s how I created a tun interface with IP address 192.0.2.2.</p>

<pre><code>sudo ip tuntap add name tun0 mode tun user $USER
sudo ip link set tun0 up
sudo ip addr add 192.0.2.1 peer 192.0.2.2 dev tun0

sudo iptables -t nat -A POSTROUTING -s 192.0.2.2 -j MASQUERADE
sudo iptables -A FORWARD -i tun0 -s 192.0.2.2 -j ACCEPT
sudo iptables -A FORWARD -o tun0 -d 192.0.2.2 -j ACCEPT
</code></pre>

<p>These commands do two things:</p>

<ol>
<li>Create the <code>tun</code> device with the IP <code>192.0.2.2</code> (and give your user access to write to it)</li>
<li>set up <code>iptables</code> to proxy packets from that tun device to the internet using NAT</li>
</ol>

<p>The iptables part is very important because otherwise the packets would only
exist inside my computer and wouldn’t be sent to the internet, and what fun
would that be?</p>

<p>I’m not going to explain this <code>ip addr add</code> command because I don’t understand
it, I find <code>ip</code> to be very inscrutable and for now I’m resigned to just copying
and pasting <code>ip</code> commands without fully understanding them. It does work
though.</p>

<h3 id="how-to-connect-to-the-tun-interface-in-python">how to connect to the tun interface in Python</h3>

<p>Here’s a function to open a tun interface, you call it like <code>openTun(&#39;tun0&#39;)</code>.
I figured out how to write it by searching through the
<a href="https://scapy.net/">scapy</a> source code for “tun”.</p>

<pre><code>import struct
from fcntl import ioctl

def openTun(tunName):
    tun = open(&#34;/dev/net/tun&#34;, &#34;r+b&#34;, buffering=0)
    LINUX_IFF_TUN = 0x0001
    LINUX_IFF_NO_PI = 0x1000
    LINUX_TUNSETIFF = 0x400454CA
    flags = LINUX_IFF_TUN | LINUX_IFF_NO_PI
    ifs = struct.pack(&#34;16sH22s&#34;, tunName, flags, b&#34;&#34;)
    ioctl(tun, LINUX_TUNSETIFF, ifs)
    return tun
</code></pre>

<p>All this is doing is</p>

<ol>
<li>opening <code>/dev/net/tun</code> in binary mode</li>
<li>calling an <code>ioctl</code> to tell Linux that we want a <code>tun</code> device, and that the one we want is called <code>tun0</code> (or whatever <code>tunName</code> we’ve passed to the function).</li>
</ol>

<p>Once it’s open, we can <code>read</code> from and <code>write</code> to it like any other file in Python.</p>

<h3 id="let-s-send-a-syn-packet">let’s send a SYN packet!</h3>

<p>Now that we have the <code>openTun</code> function, we can send a SYN packet!</p>

<p>Here’s what the Python code looks like, using the <code>openTun</code> function.</p>

<pre><code>syn = b&#39;E\x00\x00,\x00\x01\x00\x00@\x06\x00\xc4\xc0\x00\x02\x02&#34;\xc2\x95Cx\x0c\x00P\xf4p\x98\x8b\x00\x00\x00\x00`\x02\xff\xff\x18\xc6\x00\x00\x02\x04\x05\xb4&#39;
tun = openTun(b&#34;tun0&#34;)
tun.write(syn)
reply = tun.read(1024)
print(repr(reply))
</code></pre>

<p>If I run this as <code>sudo python3 syn.py</code>, it prints out the reply from <code>example.com</code>:</p>

<pre><code>b&#39;E\x00\x00,\x00\x00@\x00&amp;\x06\xda\xc4&#34;\xc2\x95C\xc0\x00\x02\x02\x00Px\x0cyvL\x84\xf4p\x98\x8c`\x12\xfb\xe0W\xb5\x00\x00\x02\x04\x04\xd8&#39;
</code></pre>

<p>Obviously this is a pretty silly way to send a SYN packet – a real
implementation would have actual code to generate that byte string instead of
hardcoding it, and we would parse the reply instead of just printing out the
raw byte string. But I didn’t want to go into the structure of TCP in this post
so that’s what we’re doing.</p>

<h3 id="looking-at-these-packets-with-tcpdump">looking at these packets with tcpdump</h3>

<p>If we run tcpdump on the <code>tun0</code> interface, we can see the packet we sent and the answer from <code>example.com</code>:</p>

<pre><code>$ sudo tcpdump -ni tun0
12:51:01.905933 IP 192.0.2.2.30732 &gt; 34.194.149.67.80: Flags [S], seq 4101019787, win 65535, options [mss 1460], length 0
12:51:01.932178 IP 34.194.149.67.80 &gt; 192.0.2.2.30732: Flags [S.], seq 3300937416, ack 4101019788, win 64480, options [mss 1240], length 0
</code></pre>

<p><code>Flags [S]</code> is the SYN we sent, and <code>Flags [S.]</code> is the SYN ACK packet in
response! We successfully communicated! And the Linux network stack didn’t
interfere at all!</p>

<h3 id="tcpdump-also-shows-us-how-nat-is-working">tcpdump also shows us how NAT is working</h3>

<p>We can also run <code>tcpdump</code> on my real network interface (<code>wlp3so</code>, my wireless card), to see the packets being sent and received. We’ll pass <code>-i wlp3s0</code> instead of <code>-i tun0</code>.</p>

<pre><code>$ sudo tcpdump -ni wlp3s0 host 34.194.149.67
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on wlp3s0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
12:56:01.204382 IP 192.168.1.181.30732 &gt; 34.194.149.67.80: Flags [S], seq 4101019787, win 65535, options [mss 1460], length 0
12:56:01.228239 IP 34.194.149.67.80 &gt; 192.168.1.181.30732: Flags [S.], seq 144769955, ack 4101019788, win 64480, options [mss 1240], length 0
12:56:05.334427 IP 34.194.149.67.80 &gt; 192.168.1.181.30732: Flags [S.], seq 144769955, ack 4101019788, win 64480, options [mss 1240], length 0
12:56:13.524973 IP 34.194.149.67.80 &gt; 192.168.1.181.30732: Flags [S.], seq 144769955, ack 4101019788, win 64480, options [mss 1240], length 0
12:56:29.705007 IP 34.194.149.67.80 &gt; 192.168.1.181.30732: Flags [S.], seq 144769955, ack 4101019788, win 64480, options [mss 1240], length 0
</code></pre>

<p>A couple of things to notice here:</p>

<ul>
<li>The IP addresses are different – that IPtables rule from above has rewritten them from <code>192.0.2.2</code> to <code>192.168.1.181</code>. This rewriting is called “network address translation”, or “NAT”.</li>
<li>We’re getting a bunch of replies from <code>example.com</code> – it’s doing an
exponential backoff where it retries after 4 seconds, then 8 seconds, then 16
seconds. This is because we didn’t finish the TCP handshake – we just sent a
SYN and left it hanging! There’s actually a type of DDOS attack like this
called SYN flooding, but just sending one or two SYN packets isn’t a big
deal.</li>
<li>I had to add <code>host 34.194.149.67</code> because there are a lot of TCP packets being sent on my real wifi connection so I needed to ignore those</li>
</ul>

<p>I’m not totally sure why we see more SYN replies on <code>wlp3s0</code> than on <code>tun0</code>, my
guess is that it’s because we only read 1 reply in our Python program.</p>

<h3 id="this-is-pretty-easy-and-really-reliable">this is pretty easy and really reliable</h3>

<p>The last time I tried to implement TCP in Python I did it with something called
“ARP spoofing”. I won’t talk about that here (there are some posts about it on
this blog back in 2013), but this way is a lot more reliable.</p>

<p>And ARP spoofing is kind of a sketchy thing to do on a network you don’t own.</p>

<h3 id="here-s-the-code">here’s the code</h3>

<p>I put all the code from this blog post in <a href="https://gist.github.com/jvns/552e6d5e6fec6c3ddf2fcd4ccdab45d5">this gist</a>, if you want to try it yourself, you can run</p>

<pre><code>bash setup.sh # needs to run as root, has lots of `sudo` commands
python3 syn.py # runs as a regular user
</code></pre>

<p>It only works on Linux, but I think there’s a way to set up tun/tap on Mac too.</p>

<h3 id="a-plug-for-scapy">a plug for scapy</h3>

<p>I’ll close with a plug for <a href="https://scapy.net/">scapy</a> here: it’s a really
great Python networking library for doing this kind of experimentation without
writing all the code yourself.</p>

<p>This post is about writing all the code yourself though so I won’t say more
about it than that.</p>

</div></div>
  </body>
</html>
