<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://martinfowler.com/articles/patterns-of-distributed-systems/paxos.html">Original</a>
    <h1>Paxos</h1>
    
    <div id="readability-page-1" class="page"><div>
<section id="problem">
<h2>Problem</h2>

<p>When multiple nodes share state, they often need to agree between
      themselves on a particular value. 
      With <a href="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/leader-follower.html">Leader and Followers</a>, the leader decides and passes its value to the
      followers. But if there is no leader, then the nodes need to determine a
      value themselves. (Even with a leader-follower, they may need to do this to
      elect a leader.)</p>

<p>A leader can ensure replicas safely acquire an update by using
      <a href="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/two-phase-commit.html">Two Phase Commit</a>, but without a leader we can have competing nodes
      attempt to gather a <a href="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/quorum.html">Quorum</a>. This process is further
      complicated because any node may fail or disconnect. A node may achieve
      quorum on a value, but disconnect before it is able to communicate this
      value to the entire cluster.</p>
</section>

<section id="solution">
<h2>Solution</h2>



<p>The Paxos algorithm was developed by <a href="http://lamport.org">Leslie Lamport</a>,
        published in his 1998 paper <a href="http://lamport.azurewebsites.net/pubs/pubs.html#lamport-paxos">The
        Part-Time Parliament</a>. Paxos works in three phases to make sure
        multiple nodes agree on the same value in spite of partial network or
        node failures. The first two phases act to build consensus around a
        value, the last phase then communicates that consensus to the remaining
        replicas.</p>

<ul>
<li>Prepare phase: establish the latest <a href="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/generation.html">Generation Clock</a> 
                and gather any already accepted values.</li>

<li>Accept phase: propose a value for this generation for replicas
            to accept.</li>

<li>Commit Phase: let all the replicas know that a value has been chosen.</li>
</ul>

<p>In the first phase (called <b>prepare phase</b>), the node
        proposing a value (called a <b>proposer</b>) contacts all the nodes
        in the cluster (called <b>acceptors</b>) and asks them if they will
        promise to consider its value. Once a quorum of acceptors return such a
        promise, the proposer moves onto the second phase. In the second phase
        (called the <b>accept phase</b>) the proposer sends out a proposed
        value, if a quorum   of nodes accepts this value then the value is
        <b>chosen</b>. In the final phase (called the <b>commit
        phase</b>), the proposer can then commit the chosen value to all the
        nodes in the cluster.</p>

<section id="FlowOfTheProtocol">
<h3>Flow of the Protocol</h3>

<p>Paxos is a difficult protocol to understand. We&#39;ll start by showing
            an example of a typical flow of the protocol, and then dig into some of
            the details of how it works. We intend this explanation to provide an
            intuitive sense of how the protocol works, but not as a comprehensive
            description to base an implementation upon.</p>

<p>Here&#39;s a very brief summary of the protocol.</p>

<section>
<p>Proposer</p>

<p>Acceptor</p>

<p>Obtains the next generation number from a <a href="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/generation.html">Generation Clock</a>. Sends a prepare request with this generation
            number to all acceptors.</p>





<p>If the generation number of the prepare request is later than
            its promised generation variable, it updates its promise generation
            with this later value and returns a promise response. If it has already
            accepted a proposal it returns this proposal.</p>

<p>When it receives promises from quorum of acceptors, it looks to
            see if any of these responses contain accepted values. If so it changes its
            own proposed value to that of the returned proposal with the highest
            generation number. Sends accept requests to all acceptors with its generation number and
            proposed value.</p>





<p>If the generation number of the accept request is later than
            its promised generation variable it stores the proposal as its accepted
            proposal and responds that it has accepted the request.</p>

<p>When it receives a successful response from a quorum of
            acceptors, it records the value as chosen and sends commit messages to
            all nodes.</p>


</section>

<p>Those are basic rules for paxos, but it&#39;s very hard to understand how
            they combine for an effective behavior. So here&#39;s an example to show how
            this works.</p>

<div id="mfpaxos-initial-requests.png"><p><img src="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/mfpaxos-initial-requests.png"/></p>
</div>



<p>Consider a cluster of five nodes: Athens, Byzantium, Cyrene,
            Delphi, and Ephesus. A client contacts the Athens node, requesting to set
            the name to &#34;alice&#34;. The Athens node now needs to initiate a Paxos
            interaction to see if all the nodes will agree to this change. Athens is
            called the proposer, in that Athens will propose to all the other nodes that
            the name of the cluster become &#34;alice&#34;. All the nodes in the cluster
            (including Athens) are &#34;acceptors&#34;, meaning they are capable of accepting
            proposals. </p>

<p>At the same time that Athens is proposing
            &#34;alice&#34;, the node Ephesus gets a request to set the name to &#34;elanor&#34;. This
            makes Ephesus also be a proposer.</p>

<div id="mfpaxos-initial-prepare.png"><p><img src="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/mfpaxos-initial-prepare.png"/></p>
</div>



<p>In the prepare phase the proposers begin by sending some prepare
            requests, which all include a generation number. Since Paxos is intended to
            avoid single points of failure, we don&#39;t take this from a single generation
            clock. Instead each node maintains its own generation clock where it
            combines a generation number with a node ID. The node ID is used to break
            ties, so <code>[2,a] &gt; [1,e] &gt; [1,a]</code>. Each acceptor records the
            latest promise it&#39;s seen so far. </p>

<table>
<tbody>
<tr><td>Node</td><td>Athens</td><td>Byzantium</td><td>Cyrene</td><td>Delphi</td><td>Ephesus</td></tr>

<tr><td>promised generation</td><td>1,a</td><td>1,a</td><td>0</td><td>1,e</td><td>1,e</td></tr>

<tr><td>accepted value</td><td>none</td><td>none</td><td>none</td><td>none</td><td>none</td></tr>
</tbody>
</table>

<p>Since they haven&#39;t seen any requests before this, they all return a
            promise to the calling proposer. We call the returned value a &#34;promise&#34;
            because it indicates that the acceptor promises to not consider any messages
            with an earlier generation clock than the promised one.</p>

<div id="mfpaxos-a-prepare-c.png"><p><img src="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/mfpaxos-a-prepare-c.png"/></p>
</div>



<p>Athens sends its prepare message to Cyrene. When it receives a promise in
            return, this means it has now got promises from from three of the five nodes, which
            represents a <a href="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/quorum.html">Quorum</a>. Athens now shifts from sending
            prepare messages to sending accept messages.
            </p>

<p>
                It is possible that Athens fails to receive a promise 
                from a majority of the cluster nodes. In that case Athens 
                retries the prepare request by incrementing the generation clock.
            </p>

<table>
<tbody>
<tr><td>Node</td><td>Athens</td><td>Byzantium</td><td>Cyrene</td><td>Delphi</td><td>Ephesus</td></tr>

<tr><td>promised generation</td><td>1,a</td><td>1,a</td><td>1,a</td><td>1,e</td><td>1,e</td></tr>

<tr><td>accepted value</td><td>none</td><td>none</td><td>none</td><td>none</td><td>none</td></tr>
</tbody>
</table>

<div id="mfpaxos-accept-ac.png"><p><img src="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/mfpaxos-accept-ac.png"/></p>
</div>



<p>Athens now starts sending accept messages, containing the generation and
            the proposed value. Athens and Byzantium accept the proposal.</p>

<table>
<tbody>
<tr><td>Node</td><td>Athens</td><td>Byzantium</td><td>Cyrene</td><td>Delphi</td><td>Ephesus</td></tr>

<tr><td>promised generation</td><td>1,a</td><td>1,a</td><td>1,a</td><td>1,e</td><td>1,e</td></tr>

<tr><td>accepted value</td><td>alice</td><td>alice</td><td>none</td><td>none</td><td>none</td></tr>
</tbody>
</table>

<div id="mfpaxos-e-prepare-c.png"><p><img src="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/mfpaxos-e-prepare-c.png"/></p>
</div>



<p>Ephesus now sends a prepare message to Cyrene. Cyrene had sent a promise to
            Athens, but Ephesus&#39;s request has a higher generation, so it takes
            precedence. Cyrene sends back a promise to Ephesus.</p>

<div id="mfpaxos-c-refuses-a.png"><p><img src="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/mfpaxos-c-refuses-a.png"/></p>
</div>



<p>Cyrene now gets an accept request from Athens but rejects it as the
            generation number is behind its promise to Ephesus.</p>

<table>
<tbody>
<tr><td>Node</td><td>Athens</td><td>Byzantium</td><td>Cyrene</td><td>Delphi</td><td>Ephesus</td></tr>

<tr><td>promised generation</td><td>1,a</td><td>1,a</td><td>1,e</td><td>1,e</td><td>1,e</td></tr>

<tr><td>accepted value</td><td>alice</td><td>alice</td><td>none</td><td>none</td><td>none</td></tr>
</tbody>
</table>

<div id="mfpaxos-e-send-accepts.png"><p><img src="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/mfpaxos-e-send-accepts.png"/></p>
</div>



<p>Ephesus has now got a quorum from its prepare messages, so can move on to
            sending accepts. It sends accepts to itself and to Delphi but then crashes
            before it can send any more accepts.</p>

<table>
<tbody>
<tr><td>Node</td><td>Athens</td><td>Byzantium</td><td>Cyrene</td><td>Delphi</td><td>Ephesus</td></tr>

<tr><td>promised generation</td><td>1,a</td><td>1,a</td><td>1,e</td><td>1,e</td><td>1,e</td></tr>

<tr><td>accepted value</td><td>alice</td><td>alice</td><td>none</td><td>elanor</td><td>elanor</td></tr>
</tbody>
</table>

<p>Meanwhile, Athens has to deal with the rejection of its accept request from
            Cyrene. This indicates that its quorum is no longer promised to it and thus
            its proposal will fail. This will always happen to a proposer who loses its
            initial quorum like this; for another proposer to achieve quorum at least
            one member of the first proposer&#39;s quorum will defect.</p>

<p>In a situation with a simple two phase commit, we would then expect
            Ephesus to just go on and get its value chosen, but such a scheme would now
            be in trouble since Ephesus has crashed. If it had a lock on a quorum of
            acceptors, its crash would deadlock the whole proposal process. Paxos,
            however, expects this kind of thing to happen, so Athens will make another
            try, this time with a higher generation.</p>

<div id="mfpaxos-a-2nd-prep.png"><p><img src="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/mfpaxos-a-2nd-prep.png"/></p>
</div>



<p>It sends prepare messages again, but this time with a higher generation
            number. As with the first round, it gets back a trio of promises, but with
            an important difference. Athens already accepted &#34;alice&#34;
            earlier, and Delphi had accepted &#34;elanor&#34;. Both of these acceptors return a
            promise, but also the value that they already accepted, together with the
            generation number of that accepted proposal</p>

<table>
<tbody>
<tr><td>Node</td><td>Athens</td><td>Byzantium</td><td>Cyrene</td><td>Delphi</td><td>Ephesus</td></tr>

<tr><td>promised generation</td><td>2,a</td><td>1,a</td><td>2,a</td><td>2,a</td><td>1,e</td></tr>

<tr><td>accepted value</td><td>alice</td><td>alice</td><td>none</td><td>elanor</td><td>elanor</td></tr>
</tbody>
</table>

<p>Alice, with a quorum, must now move onto the accept phase, but
            it must propose the already-accepted value with the highest generation,
            which is &#34;elanor&#34;, who was accepted by Delphi with a generation of [1,e], which is
            greater than Athens&#39;s acceptance of &#34;alice&#34; with [1,a].</p>

<div id="mfpaxos-a-2nd-accept.png"><p><img src="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/mfpaxos-a-2nd-accept.png"/></p>
</div>



<p>Athens starts to send out accept requests, but now with &#34;elanor&#34; and its current
            generation. Athens sends an accept request to itself, which is accepted. This is a
            crucial acceptance because now there are three
            nodes accepting &#34;elanor&#34;, which is a quorum for &#34;elanor&#34;, therefore we can consider
            &#34;elanor&#34; to be the chosen value.
            </p>

<table>
<tbody>
<tr><td>Node</td><td>Athens</td><td>Byzantium</td><td>Cyrene</td><td>Delphi</td><td>Ephesus</td></tr>

<tr><td>promised generation</td><td>2,a</td><td>1,a</td><td>2,a</td><td>2,a</td><td>1,e</td></tr>

<tr><td>accepted value</td><td>elanor</td><td>alice</td><td>none</td><td>elanor</td><td>elanor</td></tr>
</tbody>
</table>

<p>But although &#34;elanor&#34; is now the chosen value, nobody is yet aware of it.
            Within the accept stage Athens only knows itself having &#34;elanor&#34; as the
            value, which isn&#39;t a quorum and Ephesus is offline. All Athens needs to do is
            have a couple more accept requests accepted and it will be able to commit.
            But now Athens crashes.</p>

<p>At this point Athens and Ephesus have now crashed. But the cluster still
            has a quorum of nodes operating, so they should be able to keep working, and
            indeed by following the protocol they can discover that &#34;elanor&#34; is the
            chosen value.</p>

<div id="mfpaxos-c-prepare.png"><p><img src="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/mfpaxos-c-prepare.png"/></p>
</div>



<p>Cyrene gets a request to set the name to &#34;carol&#34;, so it becomes a
            proposer. It&#39;s seen generation [2,a] so it kicks off a prepare phase with
            generation [3,c]. While it wishes to propose &#34;carol&#34; as the name, for
            the moment it&#39;s just issuing prepare requests.</p>

<p>Cyrene sends prepare messages to the remaining nodes in the cluster. As
            with Athens&#39;s earlier prepare phase, Cyrene gets accepted values back, so
            &#34;carol&#34; never gets proposed as a value. As before, Delphi&#39;s &#34;elanor&#34; is
            later than Byzantium&#39;s &#34;alice&#34;, so Cyrene starts an accept phase with
            &#34;elanor&#34; and [3,c].</p>

<table>
<tbody>
<tr><td>Node</td><td>Athens</td><td>Byzantium</td><td>Cyrene</td><td>Delphi</td><td>Ephesus</td></tr>

<tr><td>promised generation</td><td>2,a</td><td>3,c</td><td>3,c</td><td>3,c</td><td>1,e</td></tr>

<tr><td>accepted value</td><td>elanor</td><td>alice</td><td>none</td><td>elanor</td><td>elanor</td></tr>
</tbody>
</table>

<div id="mfpaxos-c-accept.png"><p><img src="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/mfpaxos-c-accept.png"/></p>
</div>



<p>While I could continue to crash and wake up nodes, it&#39;s clear now that
            &#34;elanor&#34; will win out. As long as a quorum of nodes are up, at least one of
            them will have &#34;elanor&#34; as its value, and any node attempting a prepare will
            have to contact one node that&#39;s accepted &#34;elanor&#34; in order to get a quorum
            for its prepare phase. So we&#39;ll finish with Cyrene sending out commits.</p>

<div id="mfpaxos-c-commit.png"><p><img src="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/mfpaxos-c-commit.png"/></p>
</div>



<p>At some point Athens and Ephesus will come back online and they will
            discover what the quorum has chosen.</p>
</section>

<section id="RequestsDontNeedToBeRejected">
<h3>Requests don&#39;t need to be rejected</h3>

<p>In the example above, we saw acceptors rejecting requests with an
            aged generation. But the protocol does not require an explicit rejection
            like this. As formulated, an acceptor may just ignore an out-of-date
            request. If this is the case, then the protocol will still converge on a
            single consensus value. This is an important feature of the protocol
            because, as this is a distributed system, connections can be lost at any
            time, so it&#39;s beneficial to not be dependent on rejections to ensure the
            safety of the protocol. (<i>Safety</i> here meaning that the protocol will
            choose only one value, and once chosen, it won&#39;t be overwritten.)</p>

<p>Sending rejections, however, is still useful as it improves
            performance. The quicker proposers find out they are old, the sooner
            they can start another round with a higher generation.</p>
</section>

<section id="CompetingProposersMayFailToChoose">
<h3>Competing proposers may fail to choose</h3>

<p>One way this protocol can go wrong is if two (or more) proposers get
            into a cycle.</p>

<ul>
<li>alice is accepted by athens and byzantium</li>

<li>elanor is prepared by all nodes, preventing alice from gaining quorum</li>

<li>elanor is accepted by delphi and ephesus</li>

<li>alice is prepared by all nodes, preventing elanor from gaining
            quorum.</li>

<li>alice is accepted by athens and byzantium</li>

<li>... and so on, a situation called a livelock</li>
</ul>

<p>The <a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf">FLP Impossibility Result</a>
            shows that even a single faulty node can stop a cluster from ever
            choosing a value.</p>

<p>We can reduce the chances of this livelock happening by ensuring that whenever
            a proposer needs to choose a new generation, it must wait a random
            period of time. This randomness makes it likely that one proposer will
            be able to get a quorum accepted before the other sends a prepare
            request to the full quorum.</p>

<p>But we can never ensure that livelock can&#39;t happen. This is a
            fundamental trade-off: we can either ensure safety or liveness, but not
            both. Paxos ensures safety first.</p>
</section>

<section id="AnExampleKey-valueStore">
<h3>An example key-value store</h3>

<p>
              The Paxos protocol explained here, builds consensus on a single value 
              (often called as single-decree Paxos).
              Most practical implementations used in mainstream products like 
              <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/introduction">Cosmos DB</a> or <a href="https://cloud.google.com/spanner">Spanner</a>
              use a modification of paxos called multi-paxos which is implemented 
              as a <a href="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/replicated-log.html">Replicated Log</a>.
            </p>

<p>
              But a simple key-value store can be built using basic Paxos. <a href="http://cassandra.apache.org/">[cassandra]</a> 
              uses basic Paxos in a similar way to implement it&#39;s light-weight transactions.              
            </p>

<p>
                The key-value store maintains Paxos instance per key.
               
</p><p>class PaxosPerKeyStore…
</p>

<pre>  int serverId;
  public PaxosPerKeyStore(int serverId) {
      this.serverId = serverId;
  }

  Map&lt;String, Acceptor&gt; key2Acceptors = new HashMap&lt;String, Acceptor&gt;();
  List&lt;PaxosPerKeyStore&gt; peers;</pre>


<p>
                The Acceptor stores the promisedGeneration, acceptedGeneration 
                and acceptedValue.
                
</p><p>class Acceptor…
</p>

<pre>  public class Acceptor {
      MonotonicId promisedGeneration = MonotonicId.empty();
  
      Optional&lt;MonotonicId&gt; acceptedGeneration = Optional.empty();
      Optional&lt;Command&gt; acceptedValue = Optional.empty();
  
      Optional&lt;Command&gt; committedValue = Optional.empty();
      Optional&lt;MonotonicId&gt; committedGeneration = Optional.empty();
  
      public AcceptorState state = AcceptorState.NEW;
      private BiConsumer&lt;Acceptor, Command&gt; kvStore;</pre>


<p>
                When the key and value is put in the kv store, it runs the Paxos protocol.                
               
</p><p>class PaxosPerKeyStore…
</p>

<pre>  int maxKnownPaxosRoundId = 1;
  int maxAttempts = 4;
  public void put(String key, String defaultProposal) {
      int attempts = 0;
      while(attempts &lt;= maxAttempts) {
          attempts++;
          MonotonicId requestId = new MonotonicId(maxKnownPaxosRoundId++, serverId);
          SetValueCommand setValueCommand = new SetValueCommand(key, defaultProposal);

          if (runPaxos(key, requestId, setValueCommand)) {
              return;
          }

          Uninterruptibles.sleepUninterruptibly(ThreadLocalRandom.current().nextInt(100), MILLISECONDS);
          logger.warn(&#34;Experienced Paxos contention. Attempting with higher generation&#34;);
      }
      throw new WriteTimeoutException(attempts);
  }

  private boolean runPaxos(String key, MonotonicId generation, Command initialValue) {
      List&lt;Acceptor&gt; allAcceptors = getAcceptorInstancesFor(key);
      List&lt;PrepareResponse&gt; prepareResponses = sendPrepare(generation, allAcceptors);
      if (isQuorumPrepared(prepareResponses)) {
          Command proposedValue = getValue(prepareResponses, initialValue);
          if (sendAccept(generation, proposedValue, allAcceptors)) {
              sendCommit(generation, proposedValue, allAcceptors);
          }
          if (proposedValue == initialValue) {
              return true;
          }
      }
      return false;
  }

  public Command getValue(List&lt;PrepareResponse&gt; prepareResponses, Command initialValue) {
      PrepareResponse mostRecentAcceptedValue = getMostRecentAcceptedValue(prepareResponses);
      Command proposedValue
              = mostRecentAcceptedValue.acceptedValue.isEmpty() ?
              initialValue : mostRecentAcceptedValue.acceptedValue.get();
      return proposedValue;
  }

  private PrepareResponse getMostRecentAcceptedValue(List&lt;PrepareResponse&gt; prepareResponses) {
      return prepareResponses.stream().max(Comparator.comparing(r -&gt; r.acceptedGeneration.orElse(MonotonicId.empty()))).get();
  }</pre>


<p>class Acceptor…
</p>

<pre>  public PrepareResponse prepare(MonotonicId generation) {

      if (promisedGeneration.isAfter(generation)) {
          return new PrepareResponse(false, acceptedValue, acceptedGeneration, committedGeneration, committedValue);
      }
      promisedGeneration = generation;
      state = AcceptorState.PROMISED;
      return new PrepareResponse(true, acceptedValue, acceptedGeneration, committedGeneration, committedValue);

  }</pre>

<p>class Acceptor…
</p>

<pre>  public boolean accept(MonotonicId generation, Command value) {
      if (generation.equals(promisedGeneration) || generation.isAfter(promisedGeneration)) {
          this.promisedGeneration = generation;
          this.acceptedGeneration = Optional.of(generation);
          this.acceptedValue = Optional.of(value);
          return true;
      }
      state = AcceptorState.ACCEPTED;
      return false;
  }</pre>


<p>
                The value is stored in the kvstore only when it can be successfully committed.
               
</p><p>class Acceptor…
</p>

<pre>  public void commit(MonotonicId generation, Command value) {
      committedGeneration = Optional.of(generation);
      committedValue = Optional.of(value);
      state = AcceptorState.COMMITTED;
      kvStore.accept(this, value);
  }</pre>

<p>class PaxosPerKeyStore…
</p>

<pre>  private void accept(Acceptor acceptor, Command command) {
      if (command instanceof SetValueCommand) {
          SetValueCommand setValueCommand = (SetValueCommand) command;
          kv.put(setValueCommand.getKey(), setValueCommand.getValue());
      }
      acceptor.resetPaxosState();
  }</pre>


<p>
                The paxos state needs to be persisted. 
                It can be easily done by using a <a href="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/wal.html">Write-Ahead Log</a>.
            </p>

<section id="HandlingMultipleValues.">
<h4>Handling multiple values.</h4>

<p>
                It is important to note that Paxos is specified and proven to work on single value. 
                So handling multiple values with the single value Paxos protocol needs to be done 
                outside of the protocol specification. One alternative is to reset the state, 
                and store committed values separately to make sure they are not lost.
                
</p><p>class Acceptor…
</p>

<pre>  public void resetPaxosState() {
      //This implementation has issues if committed values are not stored
      //and handled separately in the prepare phase.
      //See Cassandra implementation for details.
      //https://github.com/apache/cassandra/blob/trunk/src/java/org/apache/cassandra/db/SystemKeyspace.java#L1232
      promisedGeneration = MonotonicId.empty();
      acceptedGeneration = Optional.empty();
      acceptedValue = Optional.empty();
  }</pre>


<p>        
                There is an alternative, as suggested in <a href="https://github.com/gryadka/js">[gryadka]</a>, which slightly modifies the 
                basic Paxos to allow setting multiple values. 
                This need for executing steps beyond the basic algorithm 
                is the reason that in practice <a href="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/replicated-log.html">Replicated Log</a> is preferred.
            </p>
</section>

<section id="ReadingTheValues">
<h4>Reading the values</h4>

<p>
                   Paxos relies on the prepare phase to detect any uncommitted values. 
                   So if basic Paxos is used to implement a key-value store as shown above, 
                   the read operation also needs to run the full Paxos algorithm.
                   
</p><p>class PaxosPerKeyStore…
</p>

<pre>  public String get(String key) {
      int attempts = 0;
      while(attempts &lt;= maxAttempts) {
          attempts++;
          MonotonicId requestId = new MonotonicId(maxKnownPaxosRoundId++, serverId);
          Command getValueCommand = new NoOpCommand(key);
          if (runPaxos(key, requestId, getValueCommand)) {
              return kv.get(key);
          }

          Uninterruptibles.sleepUninterruptibly(ThreadLocalRandom.current().nextInt(100), MILLISECONDS);
          logger.warn(&#34;Experienced Paxos contention. Attempting with higher generation&#34;);

      }
      throw new WriteTimeoutException(attempts);
  }</pre>

</section>
</section>
</section>

<section id="examples">
<h2>Examples</h2>

<section>
<p><a href="http://cassandra.apache.org/">[cassandra]</a> uses Paxos to implement light-weight transaction.</p>
</section>

<section>
<p>All the consensus algorithms like <a href="https://raft.github.io/">Raft</a> 
        use basic concepts similar to the basic Paxos. 
        The use of <a href="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/two-phase-commit.html">Two Phase Commit</a>, 
        <a href="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/quorum.html">Quorum</a> and <a href="https://www.vrk.dev/2022/01/03/a-few-notes-on-vrks-2021/generation.html">Generation Clock</a> is used in a similar manner.
    </p>
</section>
</section>


</div></div>
  </body>
</html>
