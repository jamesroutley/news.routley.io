<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/coralblocks/CoralRing">Original</a>
    <h1>Ultra-low-latency, batching and concurrent queue for IPC in Java</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">CoralRing is an ultra-low-latency, lock-free, garbage-free, batching and concurrent circular queue (<em>ring</em>)
in off-heap shared memory for inter-process communication (IPC) in Java across different JVMs using memory-mapped files.
It uses memory barriers through <a href="https://github.com/coralblocks/CoralRing/blob/9d341629c330875c8c6d31559a670742c224e524/src/main/java/com/coralblocks/coralring/util/MemoryVolatileLong.java#L57">volatile operations</a> instead of locks to allow messages to be sent as fast as possible.</p>
<p dir="auto">An interesting characteristic of <em>memory-mapped files</em> is that <code>they allow your shared memory to exceed the size of your machine physical memory (RAM) by relying on the OS&#39;s virtual memory mechanism</code>. Therefore your shared memory is limited not by your RAM but by the size of your hard drive (HDD/SSD). The trade-off of a large memory-mapped file is performance as the OS needs to swap pages back and forth from hard drive to memory and vice-versa, in a process called <em>paging</em>.</p>
<p dir="auto">For maximum performance (lowest possible latency) you should place your memory-mapped file inside the Linux <code>/dev/shm/</code> folder so that the contents of your file are entirely kept in RAM memory. Of course by doing so you are back to being limited to your available RAM memory. CoralRing uses a <em>circular</em> queue (<em>ring</em>) in shared memory so even with a small piece of memory you can transmit an unlimited number of messages to the other process.</p>
<p dir="auto">For some performance numbers you can check <a href="https://www.coralblocks.com/index.php/inter-process-communication-with-coralqueue/" rel="nofollow">this link</a>.</p>

<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/coralblocks/CoralRing/blob/main/images/BlockingRing.png"><img src="https://github.com/coralblocks/CoralRing/raw/main/images/BlockingRing.png" alt="BlockingRing" width="50%" height="50%"/></a></p>
<p dir="auto">Because the ring is a <em>bounded</em> circular queue, the first approach is to have a <em>blocking</em> producer and consumer. In other words, the ring producer will block (<em>wait</em>) when the ring is full and the ring consumer will block (<em>wait</em>) when the ring is empty. Basically a slow consumer will cause the producer to block, waiting for space to become available in the ring. The consumer reads the messages (all the messages) in the same order that they were sent by the producer.</p>
<ul dir="auto">
<li>Click <a href="https://github.com/coralblocks/CoralRing/blob/main/src/main/java/com/coralblocks/coralring/example/ring/minimal/MinimalBlockingProducer.java">here</a> for a minimal example of using blocking ring producer</li>
<li>Click <a href="https://github.com/coralblocks/CoralRing/blob/main/src/main/java/com/coralblocks/coralring/example/ring/minimal/MinimalBlockingConsumer.java">here</a> for a minimal example of using blocking ring consumer
</li>
<li>Click <a href="https://github.com/coralblocks/CoralRing/blob/main/src/main/java/com/coralblocks/coralring/example/ring/BlockingProducer.java">here</a> for a basic example of using blocking ring producer</li>
<li>Click <a href="https://github.com/coralblocks/CoralRing/blob/main/src/main/java/com/coralblocks/coralring/example/ring/BlockingConsumer.java">here</a> for a basic example of using blocking ring consumer</li>
</ul>
<p dir="auto">Note that for maximum performance the producer and consumer should busy spin when blocking. However you can also choose to use a <em>wait strategy</em> from <a href="https://github.com/coralblocks/CoralQueue">CoralQueue</a>.</p>

<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/coralblocks/CoralRing/blob/main/images/BlockingMcastRing.png"><img src="https://github.com/coralblocks/CoralRing/raw/main/images/BlockingMcastRing.png" alt="BlockingMcastRing" width="50%" height="50%"/></a></p>
<p dir="auto">You can also have a single producer broadcasting messages to multiple consumers so that <code>each consumer gets all the messages in the same order that they were sent by the producer</code>. Any slow consumer can cause the ring to get full and the producer to block. As the slow consumer makes progress so will the producer.</p>
<ul dir="auto">
<li>Click <a href="https://github.com/coralblocks/CoralRing/blob/main/src/main/java/com/coralblocks/coralring/example/ring/minimal/MinimalBlockingBroadcastProducer.java">here</a> for a minimal example of using blocking broadcast ring producer</li>
<li>Click <a href="https://github.com/coralblocks/CoralRing/blob/main/src/main/java/com/coralblocks/coralring/example/ring/minimal/MinimalBlockingBroadcastConsumer.java">here</a> for a minimal example of using blocking broadcast ring consumer
</li>
<li>Click <a href="https://github.com/coralblocks/CoralRing/blob/main/src/main/java/com/coralblocks/coralring/example/ring/BlockingBroadcastProducer.java">here</a> for a basic example of using blocking broadcast ring producer</li>
<li>Click <a href="https://github.com/coralblocks/CoralRing/blob/main/src/main/java/com/coralblocks/coralring/example/ring/BlockingBroadcastConsumer.java">here</a> for a basic example of using blocking broadcast ring consumer</li>
</ul>
<p dir="auto">Note that for maximum performance the producer and consumers should busy spin when blocking. However you can also choose to use a <em>wait strategy</em> from <a href="https://github.com/coralblocks/CoralQueue">CoralQueue</a>.</p>

<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/coralblocks/CoralRing/blob/main/images/NonBlockingRing.png"><img src="https://github.com/coralblocks/CoralRing/raw/main/images/NonBlockingRing.png" alt="NonBlockingRing" width="50%" height="50%"/></a></p>
<p dir="auto">Things get more interesting when we allow the ring producer to write as fast as possible without ever blocking on a full ring. Because the ring is a <em>circular</em> queue, the producer can just keep writing forever, overwriting the oldest messages on the head of the queue with the newest ones. In this new scenario, a <em>lagging consumer</em> that falls behind and loses messages will simply disconnect (give up) <em>instead of causing the producer to block</em>. It has to disconnect because it must never skip messages from the producer.</p>
<div dir="auto" data-snippet-clipboard-copy-content="long avail = ringConsumer.availableToPoll();
			
if (avail == 0) continue; // busy spin as the ring is empty
			
if (avail == -1) throw new RuntimeException(&#34;The consumer fell behind too much! (ring wrapped)&#34;);"><pre><span>long</span> <span>avail</span> = <span>ringConsumer</span>.<span>availableToPoll</span>();
			
<span>if</span> (<span>avail</span> == <span>0</span>) <span>continue</span>; <span>// busy spin as the ring is empty</span>
			
<span>if</span> (<span>avail</span> == -<span>1</span>) <span>throw</span> <span>new</span> <span>RuntimeException</span>(<span>&#34;The consumer fell behind too much! (ring wrapped)&#34;</span>);</pre></div>
<p dir="auto">This lagging consumer problem can be mitigated by creating a large memory-mapped file so that your shared memory ring is big enough to give room for the consumer to fall behind and catch up. However there is a more important issue that we need to address with a non-blocking ring which is when the consumer falls behind so much that it hits the <em>edge</em> of the circular ring. When that happens there is a <em>small chance</em> that the consumer will be reading the oldest message in the ring at the same time that the producer is overwriting it with the newest message. In other words, the consumer can <em>trip over</em> the producer.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Using a <em>fall behind tolerance</em></h3><a id="user-content-using-a-fall-behind-tolerance" aria-label="Permalink: Using a fall behind tolerance" href="#using-a-fall-behind-tolerance"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <em>tripping over</em> problem will <em>only</em> happen when the consumer falls behind N messages, where N is equal to the capacity of the ring. If it falls behind a little more, it simply disconnects. If it falls behind a little less it <em>should</em> still be able to read the next message without any issues. <code>So the bigger the capacity of the ring the less likely it is for the consumer to trip over the producer</code> because the more room it has to fall behind safely. Therefore, to reduce the chances for the consumer to get close to the edge, we can introduce a <em>fall behind tolerance</em>, in other words, <code>we can make the consumer give up and disconnect early when it falls to a percentage P of the capacity of the ring</code>.</p>
<p dir="auto">The constructor of <code>NonBlockingConsumer</code> can take a <em>float</em> argument <code>fallBehindTolerance</code> to specify the percentage of the ring capacity to fall behind before disconnecting. When it falls below that threshold then its <code>availableToPoll()</code> method returns <code>-1</code>.</p>
<p dir="auto">Unfortantely, although this will further reduce the chances for the consumer to read a corrupt message, <strong>it does not make it zero</strong>. Theoretically, the slowness of the consumer is so <em>unpredictable</em> that while it is reading a message there will always be a small chance that the producer is overwriting it. If we really want to eliminate this possibility completely we must use a <em>checksum</em> for each message.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Using a <em>checksum</em> for each message</h3><a id="user-content-using-a-checksum-for-each-message" aria-label="Permalink: Using a checksum for each message" href="#using-a-checksum-for-each-message"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To completely solve the <em>corrupt message</em> consumer problem, we can make the producer write a <em>checksum</em> together with each message so that the consumer can check the integrity of the message after it reads it. Although we use a <em>fast</em> hash algorithm (<a href="https://github.com/apache/drill/blob/master/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/impl/XXHash.java%5D(https://xxhash.com/)"><em>xxHash</em></a>) to calculate the checksum, there is a small performance penalty to pay when you choose this approach.</p>
<p dir="auto">The constructor of <code>NonBlockingProducer</code> can take a <em>boolean</em> argument <code>writeChecksum</code> to tell the producer to write the <em>checksum</em>. The constructor of <code>NonBlockingConsumer</code> can take a <em>boolean</em> argument <code>checkChecksum</code> to tell the consumer to check the <em>checksum</em>. The consumer can check for a <em>checksum error</em> by checking for a <code>null</code> value returned from <code>poll()</code> or <code>peek()</code> :</p>
<div dir="auto" data-snippet-clipboard-copy-content="for(long i = 0; i &lt; avail; i++) {
      
    MutableLong ml = ringConsumer.poll();
      
    if (ml == null) {
        throw new RuntimeException(&#34;The consumer tripped over the producer! (checksum failed)&#34;);
    }
      
    // (...)
}"><pre><span>for</span>(<span>long</span> <span>i</span> = <span>0</span>; <span>i</span> &lt; <span>avail</span>; <span>i</span>++) {
      
    <span>MutableLong</span> <span>ml</span> = <span>ringConsumer</span>.<span>poll</span>();
      
    <span>if</span> (<span>ml</span> == <span>null</span>) {
        <span>throw</span> <span>new</span> <span>RuntimeException</span>(<span>&#34;The consumer tripped over the producer! (checksum failed)&#34;</span>);
    }
      
    <span>// (...)</span>
}</pre></div>
<p dir="auto">Note that when using the <em>checksum</em> approach there is no reason to also use a <em>fall behind tolerance</em>. You can catch the exception, assume that the consumer has fallen behind too much and disconnect (give up).</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Using a <em>very large</em> memory-mapped file</h3><a id="user-content-using-a-very-large-memory-mapped-file" aria-label="Permalink: Using a very large memory-mapped file" href="#using-a-very-large-memory-mapped-file"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">There is also another <em>simple</em> approach to solve the <em>tripping over</em> problem: <code>just allocate a very large memory-mapped file so that the producer never has to wrap around the ring</code>. For example, let&#39;s say you want to send <em>100 million</em> messages per day, with a maximum size of <em>1024 bytes</em>. If you do the math you will see that this is <em>only</em> 95 gigabytes of hard drive space. And as a bonus, as long as you don&#39;t go above your predicted maximum number of messages (no wrapping around the ring), you will also have all your messages persisted to disk at the end of your daily session. Then to begin a new session you can move the session file someplace else for archiving, reset the message sequence back to 1, and start over again.</p>
<ul dir="auto">
<li>Click <a href="https://github.com/coralblocks/CoralRing/blob/main/src/main/java/com/coralblocks/coralring/example/ring/minimal/MinimalNonBlockingProducer.java">here</a> for a minimal example of using non-blocking ring producer</li>
<li>Click <a href="https://github.com/coralblocks/CoralRing/blob/main/src/main/java/com/coralblocks/coralring/example/ring/minimal/MinimalNonBlockingConsumer.java">here</a> for a minimal example of using non-blocking ring consumer
</li>
<li>Click <a href="https://github.com/coralblocks/CoralRing/blob/main/src/main/java/com/coralblocks/coralring/example/ring/NonBlockingProducer.java">here</a> for a basic example of using non-blocking ring producer</li>
<li>Click <a href="https://github.com/coralblocks/CoralRing/blob/main/src/main/java/com/coralblocks/coralring/example/ring/NonBlockingConsumer.java">here</a> for a basic example of using non-blocking ring consumer</li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">Non-Blocking Multicast Ring</h2><a id="user-content-non-blocking-multicast-ring" aria-label="Permalink: Non-Blocking Multicast Ring" href="#non-blocking-multicast-ring"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A non-blocking ring can be used naturally to implement <em>multicast consumers</em>. That means that <code>you can have multiple non-blocking ring consumers reading from the same non-blocking ring producer</code>. All consumers will read all messages in the exact same order. A consumer can still fall behind and disconnect, but it will never miss a message or process a message out of order. It will also never block the producer which does not even know how many consumers it is multicasting to. In other words, <code>consumers can leave and join the ring at any moment</code> without impacting the producer.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/coralblocks/CoralRing/blob/main/images/NonBlockingMcastRing.png"><img src="https://github.com/coralblocks/CoralRing/raw/main/images/NonBlockingMcastRing.png" alt="NonBlockingMcastRing" width="50%" height="50%"/></a></p>
<p dir="auto">CoralRing is great for threads running in different JVMs. But how about threads running inside the <em>same JVM</em>? For that you can check our <a href="https://github.com/coralblocks/CoralQueue">CoralQueue</a> project which is a collection of circular data structures for inter-thread communication in Java.</p>
</article></div></div>
  </body>
</html>
