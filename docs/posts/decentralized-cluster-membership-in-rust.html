<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://quickwit.io/blog/chitchat/">Original</a>
    <h1>Decentralized cluster membership in Rust</h1>
    
    <div id="readability-page-1" class="page"><div><p>Even after 10 years of programming, I still have a relentless curiosity about new software algorithms, reading papers and blog posts, and learning from other engineers. The best part, however, really comes when you have the opportunity to implement one algorithm and even customize it for your specific use case. In this post, I will walk you through my journey from understanding cluster membership fundamentals to the implementation of <a href="https://github.com/quickwit-oss/chitchat" target="_blank" rel="noopener noreferrer">Chitchat</a>, our Rust implementation of the <a href="https://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf" target="_blank" rel="noopener noreferrer">Scuttlebutt</a> algorithm with a <a href="https://www.researchgate.net/publication/29682135_The_ph_accrual_failure_detector" target="_blank" rel="noopener noreferrer">phi accrual failure detector</a>.</p><p>I will first introduce the cluster membership subject and give some details about the current membership algorithm used in Quickwit (<a href="https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf" target="_blank" rel="noopener noreferrer">SWIM</a>). Why we decided to move away from it, despite being slightly faster conceptually than the successor. Then, I will explore in-depth how scuttlebutt and the failure detector algorithms work, how we have implemented them. Finally, I will describe a couple of real-world issues that we have encountered and how we solved them.</p><h3 id="what-is-cluster-membership">What is cluster membership?<a href="#what-is-cluster-membership" title="Direct link to heading">​</a></h3><p>Given a cluster of nodes, cluster membership is the sub-system that allows each node to know the list of its peers. It detects node failure and eventually, make all other nodes aware that a failed node is no longer a member of the cluster.</p><p>One common way to address this problem is to have a monitoring node in charge of checking the health of all the other nodes by running a heart-beating scheme. This approach works well for a few nodes but shows hot spots as the cluster gets larger. Another way is to put all the nodes in charge of monitoring. While this avoids hot spots, all existing heart-beating scheme offer different levels of scalability and accuracy. Some generate a lot of network traffic while others might take a bit of time to converge. All these issues combined make cluster membership a tricky engineering problem.</p><h3 id="what-is-swim-and-why-are-we-moving-away-from-swim">What is SWIM and why are we moving away from SWIM?<a href="#what-is-swim-and-why-are-we-moving-away-from-swim" title="Direct link to heading">​</a></h3><p>Since our first release, Quickwit has had a cluster membership feature in order to provide distributed search. SWIM is the algorithm currently used for this feature. It is based on a gossip style that is referred to as dissemination aka “rumor-mongering”. Scuttlebutt is different and is based on another gossip style called “anti-entropy”. <strong>Robbert et al</strong> in their <a href="https://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf" target="_blank" rel="noopener noreferrer">paper</a> explained the difference between both gossip approaches as follows:</p><blockquote><p>Anti-entropy protocols gossip information until it is made obsolete by newer information, and are useful for reliably sharing information among a group of participants. Rumor-mongering has participants gossip information for some amount of time chosen sufficiently high so that with high likelihood all participants receive the information.</p></blockquote><p>Next is a real-world example we like to use for explaining the differences between rumor-mongering and anti-entropy: </p><ul><li>Rumor-mongering: consider a piece of breaking news you just read from your local newspaper and decide to inform all your contacts. Those you inform also decide to inform their contacts. This style of gossiping spreads the news very quickly. However, there will be a time when people lose interest in the news, <strong>stop spreading it</strong>, and not everyone gets the chance to be informed.</li><li>Anti-entropy: let’s suppose everyone in town <strong>on regular basis</strong> talks to a few of his contacts (3 to 5) to keep up with any news in town. This type of information exchange is slower because of the number of selected contacts. However, since everyone does this perpetually, they are guaranteed to be informed about the <strong>latest news</strong> no matter what time it takes.</li></ul><p>The key difference here is that with SWIM, a node may miss some propagated messages within the cluster, which can lead to false-positive failure detection. <a href="https://www.hashicorp.com/" target="_blank" rel="noopener noreferrer">Hashicorp</a> for instance had to extend  their production-grade SWIM implementation <a href="https://www.serf.io/" target="_blank" rel="noopener noreferrer">Serf</a> with <a href="https://arxiv.org/abs/1707.00788" target="_blank" rel="noopener noreferrer">Lifeguard</a>. Lifeguard is a set of three extensions destined to reduce false positive failure detection.</p><p>We also struggled to find a suitable library-oriented implementation of SWIM in Rust. Though we found <a href="https://github.com/bastion-rs/artillery" target="_blank" rel="noopener noreferrer">Artillery</a> very useful to start with and want to thank all the contributors, we wanted a more battle-tested implementation like <a href="https://www.serf.io/" target="_blank" rel="noopener noreferrer">Serf</a> in Go. </p><p>Moreover, we found that scuttlebutt as an algorithm:</p><ul><li>Is easier to understand and implement correctly.</li><li>Allows nodes to share/advertise information about themselves (service ports, available ram/disk) without any special logic.</li><li>Is battle-tested in production-grade systems such as <a href="https://cassandra.apache.org" target="_blank" rel="noopener noreferrer">Apache Cassandra</a></li></ul><h3 id="how-scuttlebutt-works">How scuttlebutt works?<a href="#how-scuttlebutt-works" title="Direct link to heading">​</a></h3><p>Scuttlebutt is a gossip algorithm with a reconciliation technique fully described in this <a href="https://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf" target="_blank" rel="noopener noreferrer">paper</a>. In scuttlebutt, every node keeps a local copy of the cluster state which is a map of node ID to node state. Think of it as a key-value store namespaced by node ID in which a node is only allowed to modify (create/update/delete) its own namespace. A node can apply the changes it perceives from other nodes while gossiping. However, it cannot directly update the other node’s states. Because scuttlebutt employs the anti-entropy gossip technique, all the nodes in the cluster eventually get the latest cluster state at some point. Also, notice how the concept is based on key-value store, making it easy for nodes to share information. </p><p>The following is a JSON representation of node <code>node-1/1647537681</code> view of the cluster state. The number following <code>node-1</code> is a timestamp and you will soon understand why we added that number. Notice how each node advertises its own <code>grpc_address</code> and <code>heartbeat</code> counter.</p><div><div><pre tabindex="0"><code><span><span>{</span><span></span><br/></span><span><span>    </span><span>&#34;seed_nodes&#34;</span><span>:</span><span> </span><span>[</span><span></span><br/></span><span><span>      </span><span>&#34;127.0.0.1:7281&#34;</span><span></span><br/></span><span><span>    </span><span>]</span><span>,</span><span></span><br/></span><span><span>    </span><span>&#34;node_states&#34;</span><span>:</span><span> </span><span>{</span><span></span><br/></span><span><span>      </span><span>&#34;node-1/1647537681&#34;</span><span>:</span><span> </span><span>{</span><span></span><br/></span><span><span>        </span><span>&#34;key_values&#34;</span><span>:</span><span> </span><span>{</span><span></span><br/></span><span><span>          </span><span>&#34;grpc_address&#34;</span><span>:</span><span> </span><span>{</span><span></span><br/></span><span><span>            </span><span>&#34;value&#34;</span><span>:</span><span> </span><span>&#34;0.0.0.0:7282&#34;</span><span>,</span><span></span><br/></span><span><span>            </span><span>&#34;version&#34;</span><span>:</span><span> </span><span>2</span><span></span><br/></span><span><span>          </span><span>}</span><span>,</span><span></span><br/></span><span><span>          </span><span>&#34;heartbeat&#34;</span><span>:</span><span> </span><span>{</span><span></span><br/></span><span><span>            </span><span>&#34;value&#34;</span><span>:</span><span> </span><span>&#34;1002&#34;</span><span>,</span><span></span><br/></span><span><span>            </span><span>&#34;version&#34;</span><span>:</span><span> </span><span>1004</span><span></span><br/></span><span><span>          </span><span>}</span><span></span><br/></span><span><span>        </span><span>}</span><span>,</span><span></span><br/></span><span><span>        </span><span>&#34;max_version&#34;</span><span>:</span><span> </span><span>1004</span><span></span><br/></span><span><span>      </span><span>}</span><span>,</span><span></span><br/></span><span><span>      </span><span>&#34;node-2/1647537802&#34;</span><span>:</span><span> </span><span>{</span><span></span><br/></span><span><span>        </span><span>&#34;key_values&#34;</span><span>:</span><span> </span><span>{</span><span></span><br/></span><span><span>          </span><span>&#34;grpc_address&#34;</span><span>:</span><span> </span><span>{</span><span></span><br/></span><span><span>            </span><span>&#34;value&#34;</span><span>:</span><span> </span><span>&#34;0.0.0.0:8282&#34;</span><span>,</span><span></span><br/></span><span><span>            </span><span>&#34;version&#34;</span><span>:</span><span> </span><span>2</span><span></span><br/></span><span><span>          </span><span>}</span><span>,</span><span></span><br/></span><span><span>          </span><span>&#34;heartbeat&#34;</span><span>:</span><span> </span><span>{</span><span></span><br/></span><span><span>            </span><span>&#34;value&#34;</span><span>:</span><span> </span><span>&#34;991&#34;</span><span>,</span><span></span><br/></span><span><span>            </span><span>&#34;version&#34;</span><span>:</span><span> </span><span>993</span><span></span><br/></span><span><span>          </span><span>}</span><span></span><br/></span><span><span>        </span><span>}</span><span>,</span><span></span><br/></span><span><span>        </span><span>&#34;max_version&#34;</span><span>:</span><span> </span><span>993</span><span></span><br/></span><span><span>      </span><span>}</span><span>,</span><span></span><br/></span><span><span>      </span><span>&#34;node-3/1647538101&#34;</span><span>:</span><span> </span><span>{</span><span></span><br/></span><span><span>        </span><span>&#34;key_values&#34;</span><span>:</span><span> </span><span>{</span><span></span><br/></span><span><span>          </span><span>&#34;grpc_address&#34;</span><span>:</span><span> </span><span>{</span><span></span><br/></span><span><span>            </span><span>&#34;value&#34;</span><span>:</span><span> </span><span>&#34;0.0.0.0:9282&#34;</span><span>,</span><span></span><br/></span><span><span>            </span><span>&#34;version&#34;</span><span>:</span><span> </span><span>2</span><span></span><br/></span><span><span>          </span><span>}</span><span>,</span><span></span><br/></span><span><span>          </span><span>&#34;heartbeat&#34;</span><span>:</span><span> </span><span>{</span><span></span><br/></span><span><span>            </span><span>&#34;value&#34;</span><span>:</span><span> </span><span>&#34;92&#34;</span><span>,</span><span></span><br/></span><span><span>            </span><span>&#34;version&#34;</span><span>:</span><span> </span><span>94</span><span></span><br/></span><span><span>          </span><span>}</span><span></span><br/></span><span><span>        </span><span>}</span><span>,</span><span></span><br/></span><span><span>        </span><span>&#34;max_version&#34;</span><span>:</span><span> </span><span>94</span><span></span><br/></span><span><span>      </span><span>}</span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span>  </span><span>}</span><br/></span></code></pre></div></div><p>The gossip protocol works as follows:</p><ul><li>Every second, a node randomly selects a few (3 in our case) nodes to gossip with.</li><li>To make this node selection a bit smarter, we randomly include:<ul><li>A seed node if not selected already</li><li>A dead node (to determine whether it is back online)</li></ul></li></ul><div><p><h5><span><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></p><div><ul><li>The gossip frequency and the number of selected nodes are configurable as they directly affect the propagation speed of any cluster state change.</li><li>Seed nodes are nodes that are known to be highly available within our cluster.</li></ul></div></div><p>Let’s now describe the flow of a single gossip round between two nodes.</p><p><img loading="lazy" alt="gossip-round-flow.png" src="https://quickwit.io/assets/images/gossip-round-flow-84352f7db89f40e69901eb1072177fe8.png" width="1256" height="623"/></p><p>As you can see from the above figure, a gossip round is initiated by node A:</p><ol><li>Node A initiates a gossip round with Node B:<ol><li>Computes its digest (DigestA).</li><li>Sends a <code>Syn</code> message with DigestA to Node B.</li></ol></li><li>Node B upon receiving the <code>Syn</code> message:<ol><li>Computes a delta (AB) using DigestA: this delta (AB) contains what Node A is missing from Node B’s copy of the cluster state.</li><li>Computes its digest (DigestB).</li><li>Sends a <code>SynAck</code> reply with delta and DigestB</li></ol></li><li>Node A upon receiving the <code>SyncAck</code> reply:<ol><li>Applies the delta AB (changes) to its copy of the cluster state.</li><li>Computes delta (BA) using DigestB: delta (BA) is what Node B is missing from Node A’s copy of the cluster state.</li><li>Sends an <code>Ack</code> message with delta.</li></ol></li><li>Finally, Node B upon receiving the <code>Ack</code> message:<ol><li>Applies the delta BA (changes) to its copy of the cluster state.</li></ol></li></ol><div><p><h5><span><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></p><div><ul><li>Digest is a map of <code>node_id</code> to <code>max_version</code> that helps compute what keyspace is missing or outdated while reducing the amount of data that needs to be exchanged between nodes. This coupled with the fact that Scuttlebutt relies on UDP rather than TCP makes it a very resource-efficient algorithm.</li><li>The message types (<code>Syn</code>, <code>SynAck</code>, and <code>Ack</code>) follow the same pattern as the <a href="https://en.wikipedia.org/wiki/Handshaking#TCP_three-way_handshake" target="_blank" rel="noopener noreferrer">TCP 3-way handshake</a> message types.</li></ul></div></div><h4 id="a-side-note-about-heartbeats">A side note about heartbeats<a href="#a-side-note-about-heartbeats" title="Direct link to heading">​</a></h4><p>In most distributed systems, nodes get their presence noticed via heartbeats, and the scuttlebutt algorithm is no different. However, scuttlebutt provides heartbeat implicitly via state reconciliation in two ways:</p><ul><li>Direct heartbeat between node A and B: Node A gossips directly with Node B.</li><li>Indirect heartbeat between node B and C: Node A while gossiping with B shares node C&#39;s latest state.</li></ul><p>In scuttlebutt algorithm, rather than having a dedicated heartbeat message, every node maintains a heartbeat counter key in its own keyspace that gets updated continuously. This acts as a state change that needs to be propagated naturally like any other value a node wants to advertise or share with others.</p><h3 id="how-do-we-distinguish-between-dead-and-slow-nodes">How do we distinguish between dead and slow nodes?<a href="#how-do-we-distinguish-between-dead-and-slow-nodes" title="Direct link to heading">​</a></h3><p>In scuttlebutt, when a node stops sharing updates (stops heart-beating), its state is just left alone. So how can we confidently flag a node as dead or faulty? We could use a timeout but we can do better: using the <a href="https://www.researchgate.net/publication/29682135_The_ph_accrual_failure_detector" target="_blank" rel="noopener noreferrer">phi accrual error detection algorithm</a> plays nicely with scuttlebutt. This algorithm calculates the <code>phi</code> value based on a window of recently received heartbeat intervals which is a good approximation that takes into account network delays, packet loss, and app performance fluctuation. By default, we use a window size of 1,000 heartbeat intervals just like Apache Cassandra. The default phi threshold of <code>8.0</code> since the paper suggests a value between 8.0 and 12.0. In a real-world scenario, this is really about trading off between quick failure detection and accuracy. </p><p><img loading="lazy" alt="phi-accrual-detection.png" src="https://quickwit.io/assets/images/phi-accrual-detection-cf79be0eddb5f45241369004631b68fe.png" width="832" height="378"/></p><h3 id="filling-the-gap-between-chitchat-and-quickwit">Filling the gap between Chitchat and Quickwit<a href="#filling-the-gap-between-chitchat-and-quickwit" title="Direct link to heading">​</a></h3><p>So far we have explained scuttlebutt and the phi accrual failure detector, which are the core components of our cluster management library implementation (Chitchat). However, some of our requirements in Quickwit still represent challenges for fully integrating with Chitchat. </p><p>Some requirements of our practical use case in Quickwit include:</p><ul><li>We want a fresh local state for every run of a node.</li><li>We don’t want obsolete states to keep overwriting new states.</li><li>We want other running nodes to detect that a newly started node’s state prevails all its
previous state.</li><li>We want a node to advertise its own public gossip address. Useful for dynamic environments like Kubernetes where some configurations are only known at runtime.</li><li>We want a node id to be the same across subsequent runs for keeping cache data around as long as possible.</li></ul><p>As you may have noticed, simple to understand and implement correctly is one of our core guidelines when it comes to solving technical challenges at Quickwit. We refrained from adding more features to Chitchat by observing our needs and choosing the simpler solution along with some tradeoffs. Our solution consists of just leaving Chitchat as-is by defining what a Node Id is and requiring our client (i.e Quickwit) to provide their own customization on top of the Node Id.</p><h3 id="quickwit-node-id-implementation">Quickwit Node ID implementation<a href="#quickwit-node-id-implementation" title="Direct link to heading">​</a></h3><p>The following describes our Node Id solution:</p><ul><li>Make the id attribute (the node&#39;s unique identifier in a cluster)
dynamic on every run. That is, we use a different unique id for every run of a node.</li><li>Make the gossip_public_address required when setting up a node. Its value could be
extracted from a config item, an environment variable, or computed at runtime.</li><li>Make part of the node id attribute static and related to the physical node to solve the caching
requirement.</li></ul><div><div><pre tabindex="0"><code><span><span>pub</span><span> </span><span>struct</span><span> </span><span>NodeId</span><span> </span><span>{</span><span></span><br/></span><span><span>   id</span><span>:</span><span> </span><span>String</span><span>,</span><span> </span><span></span><br/></span><span><span>   gossip_public_address</span><span>:</span><span> </span><span>String</span><span>,</span><span> </span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><p>In Quickwit, this translates into drawing the id from a combination of <code>node_unique_id</code> and <code>node_generation</code>: <code>{node_unique_id}/{node_generation}</code></p><ul><li><code>node_unique_id</code>: a static unique id or name for the node. Helps in solving the caching requirement.</li><li><code>node_generation</code>: a monotonically increasing value. We decided to use the timestamp when the node is starting.</li></ul><div><div><pre tabindex="0"><code><span><span>pub</span><span> </span><span>struct</span><span> </span><span>Member</span><span> </span><span>{</span><span></span><br/></span><span><span>  node_unique_id</span><span>:</span><span> </span><span>String</span><span>,</span><span></span><br/></span><span><span>  generation</span><span>:</span><span> </span><span>i64</span><span>,</span><span></span><br/></span><span><span>  gossip_public_address</span><span>:</span><span> </span><span>SocketAddr</span><span>,</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><p>This solution comes with a few advantages namely:</p><ul><li>No extra measures are needed to avoid the old states from overwriting new states.</li><li>The algorithms (scuttlebutt, phi accrual failure detector) implementations in Chitchat stay close to their respective paper.</li><li>Using timestamp for generation in Quickwit helps keep the nodes stateless.</li></ul><div><p><h5><span><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></p><p>I hope by now you understand the weird-looking nodeId we saw earlier <code>node-1/1647537681</code>.</p></div><h3 id="some-more-issues-and-tradeoffs-to-be-aware-of">Some more issues and tradeoffs to be aware of:<a href="#some-more-issues-and-tradeoffs-to-be-aware-of" title="Direct link to heading">​</a></h3><ul><li><strong>Keeping node list under control:</strong> In Chitchat, every node restart introduces a brand new node. The list of nodes grows within the cluster. Though not critical, this can be undesirable in a highly dynamic environment. We mitigate this by periodically garbage collecting obsolete nodes.</li><li><strong>Timestamp:</strong> Using timestamp for node generation still has the potential of reusing a previously used node id due to clock issues. Cassandra solves this by ensuring only nodes within a certain clock range can join the cluster. In our case, since we use a combination of <code>node_unique_id</code> and <code>node_generation</code>, there is a very low probability of reusing the same combination. Also, one can completely or partially change the node id when a clock skews in the future and needs to be fixed.</li><li><strong>Avoid dead nodes from falsely resurrecting:</strong> When a node freshly joins the cluster, its state is populated with all existing node states including dead ones. Since receiving a node state is considered an indirect heartbeat, It can take a few seconds before the newly joined node sorts out dead nodes from live ones. Our solution to this is to avoid gossiping about dead nodes at all. A newly introduced node only cares about live ones moving forward. If a node comes back online, the new node will still notice it anyway. This is as simple as it gets and most importantly paved the way in easily implementing garbage collection on dead nodes.</li></ul><h3 id="wrapping-up">Wrapping up<a href="#wrapping-up" title="Direct link to heading">​</a></h3><p>In this post, we have explored Chitchat, our new cluster membership management implementation using scuttlebutt gossip reconciliation technique enhanced with the phi accrual failure detector. We first briefly introduced cluster membership, next highlighted the reasons that made us move away from our previous implementation based on SWIM. Then explored the new implementation and described how we have had to tackle some challenges not necessarily addressed in the papers. We believe this lays a great foundation to build on and extend in order to satisfy upcoming feature requirements for Quickwit cluster management functionality. Last but not the least, <a href="https://github.com/quickwit-oss/chitchat" target="_blank" rel="noopener noreferrer">Chitchat</a> is self-contained enough to be used in other projects.</p><h3 id="references">References<a href="#references" title="Direct link to heading">​</a></h3><ul><li><a href="https://github.com/quickwit-oss/chitchat" target="_blank" rel="noopener noreferrer">Chitchat</a></li><li><a href="https://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf" target="_blank" rel="noopener noreferrer">Scuttlebutt paper</a></li><li><a href="https://www.researchgate.net/publication/29682135_The_ph_accrual_failure_detector" target="_blank" rel="noopener noreferrer">Phi accrual error detection paper</a></li><li><a href="https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf" target="_blank" rel="noopener noreferrer">SWIM paper</a></li><li><a href="https://www.youtube.com/watch?v=FuP1Fvrv6ZQ" target="_blank" rel="noopener noreferrer">Cassandra details</a></li></ul></div></div>
  </body>
</html>
