<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developers.redhat.com/articles/2023/05/04/new-c-features-gcc-13">Original</a>
    <h1>New C features in GCC 13</h1>
    
    <div id="readability-page-1" class="page"><div>
			<div>
									<p>Article</p>
								
				
				
				<div>
      <p>Explore new C language features in the GNU Compiler Collection 13.1 release</p>
</div>
				
									
							</div>
					</div><div>
			<div>
									
								<div>
					<p>The latest major version of the<a href="https://gcc.gnu.org/"> GNU Compiler Collection</a> (GCC), 13.1, was released in April 2023. Like every major GCC release, this version will bring many<a href="https://gcc.gnu.org/gcc-13/changes.html"> additions, improvements, bug fixes, and new features</a>. GCC 13 is already the system compiler in<a href="https://fedoraproject.org/wiki/Changes/GNUToolchainF38"> Fedora 38</a>. <a href="https://developers.redhat.com/products/rhel/overview">Red Hat Enterprise Linux</a> (RHEL) users will get GCC 13 in the Red Hat GCC Toolset (RHEL 8 and RHEL 9). It&#39;s also possible to try GCC 13 on <a href="https://godbolt.org/">godbolt.org</a> and similar pages.</p>

<p>This article describes new features implemented in the C front end; it does not discuss developments in <a href="https://developers.redhat.com/topics/c">the C language</a> itself. It also doesn’t cover recent changes in the C library itself. If you’re interested in the C++ language and what&#39;s supported in recent GCC releases, check out <a href="https://developers.redhat.com/blog/2020/09/24/new-c-features-in-gcc-10">New C++ features in GCC 10</a> and <a href="https://developers.redhat.com/articles/2022/04/25/new-c-features-gcc-12">New C++ features in GCC 12</a>.</p>

<p>The default C dialect in GCC 13 is <code>-std=gnu17</code>. You can use the <code>-std=c2x</code> or <code>-std=gnu2x</code> command-line options to enable C2X features. We use C2X to refer to the next major C standard version; it is expected to become C23.</p>

<h2>C2X features</h2>

<p>GCC 13 has implemented a host of C2X proposals. This section describes the most interesting ones.</p>

<h3>nullptr</h3>

<p>The <code>nullptr</code> constant first appeared in C++11, described in proposal <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf">N2431</a> from 2007. Its purpose was to alleviate the problems with the definition of <code>NULL</code>, which can be defined in a variety of ways: <code>(void *)0</code> (a pointer constant), <code>0</code> (an integer), and so on. This posed problems for overload resolution, generic programming, etc. While C doesn’t have function overloading, the protean definition of <code>NULL</code> still causes headaches. Consider the interaction of <code>_Generic</code> with <code>NULL</code>: it’s not clear which function will be called because it depends on the definition of <code>NULL</code>:</p>

<pre>  _Generic (NULL,
            void *: handle_ptr (),
            int: crash (),
            default: nop ());
</pre>

<p>Unfortunately, there are less contrived problems in practice. For instance, issues occur with conditional operators or when passing <code>NULL</code> to a variadic function (taking <code>...</code>): in such a case, applying <code>va_arg</code> to the null argument may crash the program if an unexpected definition of <code>NULL</code> is encountered. GCC 13 implements <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3042.htm">N3042</a>, which brings <code>nullptr</code> to C. Its type is <code>nullptr_t</code> and is defined in <code>&lt;stddef.h&gt;</code>. In C2X, the following assert therefore passes:</p>

<pre>static_assert (_Generic (nullptr,
   nullptr_t: 1,
   void *: 2,
   default: 0) == 1,
   &#34;nullptr_t was selected&#34;);
</pre>

<h3>Enhanced enumerations</h3>

<p>Enhanced enumerations is another feature that first appeared in C++11 via <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf">N2347</a>. In C, the underlying type of an enum was not specified in the standard. In practice, the type would be determined based on the values of the enumerators. Typically, the type would be <code>unsigned int</code>, or, if any of the values is negative, <code>int</code>. In any case, the selected type must be capable of holding all of the values of the enum. Given this lacuna in the specification, enums have portability issues. To close this gap, C adopted <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2963.htm">N2963</a>, adopting the C++ syntax:</p>

<pre>enum E : long long { R, G, B } e;
static_assert (_Generic (e, long long: 1, default: 0) == 1, &#34;E type&#34;);</pre>

<p>It seems worth mentioning, however, that specifying the wrong underlying type may lead to subtle problems.  Consider the following:</p>

<pre>enum F : int { A = 0x8000 } f;
</pre>

<p>On most platforms, this code will work as expected. The precision of <code>int</code> isn’t guaranteed to be at least 32 bits, however; it can validly be 16 bits, in which case the previous example will not compile. Thus a better variant would be to use one of the types defined in <code>&lt;stdint.h&gt;</code>, for example:</p>

<pre>enum F : int_least32_t { A = 0x8000 } f;
</pre>

<h3>(...) function prototypes</h3>

<p>C, prior to C2X, required that a variable-argument function has a named argument before the ellipsis (<code>...</code>). This requirement was the result of historical baggage and is no longer necessary, so <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2975.pdf">N2975</a> did away with the requirement. (C++ has always allowed <code>foo(...)</code>.)</p>

<pre>void f(int, ...); // OK
void g(...); // OK in C2X
</pre>

<p>Note, however, that <code>fn(...)</code> is <em>not</em> an unprototyped function, so it is possible to use the <code>va_start</code> and <code>va_arg</code> mechanism to access its arguments. An unprototyped function has the form <code>void u();</code>.</p>

<p>Such functions were removed in C2X (see below).</p>

<h3>Type inference with auto</h3>

<p>Type deduction is another feature that first appeared in C++11 via <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf">N1984</a>. It is a convenient feature that allows the programmer to use the placeholder <code>auto</code> as the type in a declaration. The compiler will then deduce the variable’s type from the initializer:</p>

<pre>auto i = 42;
</pre>

<p>It is, however, more than just a convenience feature to save typing a few more characters. Consider:</p>

<pre>auto x = foo (y);
</pre>

<p>Here, the type of <code>foo (y)</code> may depend on <code>y</code> (<code>foo</code> could be a macro using <code>_Generic</code>), so changing <code>y</code> implies changing the type of <code>x</code>. Using <code>auto</code> in the example above means that the programmer doesn’t have to change the rest of the codebase when the type of <code>y</code> is updated. GCC has offered <code>__auto_type</code> since <a href="https://gcc.gnu.org/gcc-4.9/changes.html">GCC 4.9</a>, whose semantics is fairly close to C2X <code>auto</code>, though not exactly the same, and appears to have been used mostly in standard headers. Unlike C++, <code>auto</code> must be used plain: it cannot be combined with <code>*</code> or <code>[]</code> and similar. Moreover, <code>auto</code> also doesn’t support braces around the initializer. The <code>auto</code> feature is only enabled in C2X mode. In older modes, <code>auto</code> is a redundant storage class specifier which can only be used at block scope.</p>

<h3>The constexpr specifier</h3>

<p>Yet another feature that first appeared in C++ is the <code>constexpr</code> specifier (see for instance <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">N2235</a>, though C++ <code>constexpr</code> has been greatly expanded since). C <code>constexpr</code> was introduced in <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3018.htm">N3018</a>, with much more limited functionality. Declaring a variable as <code>constexpr</code> guarantees that the variable can be used in various constant-expression contexts. C requires that objects with static storage duration are initialized with constant expressions. It follows that <code>constexpr</code> variables can be used to initialize objects with static storage duration. Another great advantage of <code>constexpr</code> is that various semantic constraints are checked at compile time. Let’s demonstrate both points with an example (note that you must specify <code>-std=c2x</code> or <code>-std=gnu2x</code> to be able to use <code>constexpr</code>):</p>

<pre>constexpr int i = 12;
static_assert (i == 12);

struct X {
  int bf : i;
};

struct S {
  long l;
};

constexpr struct S s = { 1L };
static_assert (s.l == 1L);
constexpr unsigned char q = 0xff + i; // initializer not representable in type of object</pre>

<h3>Storage-class specifiers in compound literals</h3>

<p>A compound literal is a way to create unnamed objects that typically have automatic storage duration. Because they are lvalues, it is permitted to take their address:</p>

<pre>int *p = (int []){2, 4}; // p points to the first element of an array of two ints
const int *q = &amp;(const int){1};
</pre>

<p>Paper <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3038.htm">N3038</a> allows using certain storage-class specifiers (things like <code>constexpr</code>, <code>static</code>, <code>thread_local</code>) in compound literals in C2X mode. This is useful to change the lifetime of the compound literal, or to make it a <em>compound literal constant</em> with the <code>constexpr</code> keyword:</p>

<pre>struct S { int i; };
void
f (void)
{
  static struct S s = (constexpr struct S){ 42 };
}

int *
g (void)
{
  return &amp;(static int){ 42 };
}
</pre>

<p>Note that even though <code>typedef</code>, <code>extern</code>, and <code>auto</code> are storage-class specifiers, they are not allowed in compound literals.</p>

<h3>C2X typeof</h3>

<p>C2X standardized <code>typeof</code>, a feature that has been supported as a GNU extension for many years which allows the programmer to get the type of an expression as described <a href="https://gcc.gnu.org/onlinedocs/gcc/Typeof.html">here</a>. Along with <code>typeof</code>, C2X also adds <code>typeof_unqual</code>, which additionally removes all qualifiers and <code>_Atomic</code> from the resulting type:</p>

<pre>int i;
volatile int vi;
extern typeof (vi) vi; // OK, no conflict
extern typeof_unqual (vi) i; // OK, no conflict
</pre>

<p>A minor difference between the GNU version and the standard version is the treatment of the noreturn property of a function: the GNU variant of <code>typeof</code> takes noreturn as part of the type of a pointer to function, but the standard version does not.</p>

<p>Note that C++11 standardized a similar feature under the name <code>decltype</code>, so sadly we wound up with two names for a nearly identical feature.</p>

<h3>New keywords</h3>

<p>This proposal harmonizes C and C++ further by making <code>alignas</code>, <code>alignof</code>, <code>bool</code>, <code>false</code>, <code>static_assert</code>, <code>thread_local</code>, and <code>true</code> ordinary keywords in C2X mode. Therefore this translation unit will compile OK in C2X mode:</p>

<pre>static_assert (true, &#34;&#34;);
</pre>

<p>This change can break existing code, for example</p>

<pre>int alignof = 42;
</pre>

<p>will not compile in C2X mode.</p>

<h3>The noreturn attribute</h3>

<p>A further compatibility tweak to bring C and C++ closer together. C11 added the <code>_Noreturn</code> function specifier to signal to the compiler that a function never returns to its caller, but <code>_Noreturn</code> works in C only, so C2X <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2764.pdf">N2764</a> added a standard <code>[[noreturn]]</code> attribute while simultaneously marking <code>_Noreturn</code> as obsolescent.</p>

<pre>[[noreturn]] void exit (int);
</pre>

<h3>Empty initializer braces</h3>

<p>C2X standardized empty initializer braces (<code>{}</code>) and GCC 13 implements this proposal. Some cases were already supported as a GNU extension (e.g., initializing an array or a structure), but newly it’s possible to use <code>{}</code> to initialize a scalar variable or a variable-length array as well:</p>

<pre>int i = {};
int arr[10] = {};
struct S { int i; };
struct S s = {};

void
g (void)
{
  int n = 10;
  int vla[n] = {};
}
</pre>

<h3>unreachable macro</h3>

<p>C2X brings the <code>unreachable()</code> macro, defined in <code>&lt;stddef.h&gt;</code>, which is a convenient shorthand for the GCC built-in function <code>__builtin_unreachable()</code>:</p>

<pre>#include &lt;stddef.h&gt;

int foo (int x)
{
  if (x &lt; 0)
unreachable ();
  return x &amp; 1;
}
</pre>

<h3>Unprototyped functions removed</h3>

<p>Unprototyped functions in C were of the form <code>int foo()</code>, which is a function <code>foo</code> that returns an integer which takes an unspecified number of arguments of unspecified types. This is very dangerous because the compiler can’t perform any checking when such a function is used.</p>

<p>In C2X, <code>int foo()</code> is equivalent to <code>int foo(void)</code>, which is a function <code>foo</code> that returns an integer and takes no arguments.</p>

<h2>New warnings</h2>

<p>The C front end has gained some new warnings in GCC 13. For instance, <a href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wxor-used-as-pow">-Wxor-used-as-pow</a>, which was described in the C++ part of the GCC 13 blog post. There’s a new warning specific for the C front end.</p>

<h3>-Wenum-int-mismatch</h3>

<p>In C, an enumerated type is compatible with char, a signed integer type, or an unsigned integer type, so the following code compiles if the underlying type of <code>enum E</code> is <code>int</code>:</p>

<pre>enum E { l = -1, z = 0, g = 1 };
int foo(void);
enum E foo(void) { return z; }
</pre>

<p>However, as I previously noted, the choice of the underlying type of the enum is implementation-defined. Since the code above is likely a mistake and constitutes a portability problem (the code will not compile if a different type than <code>int</code> is chosen to be the underlying type), GCC 13 implements a new warning which warns about enum/integer type mismatches. For the code above the warning looks like the following:</p>

<pre>q.c:5:10: warning: conflicting types for ‘foo’ due to enum/integer mismatch; have ‘enum E(void)’ [-Wenum-int-mismatch]
5 |   enum E foo(void) { return z; }
  |         ^~~

q.c:4:7: note: previous declaration of ‘foo’ with type ‘int(void)’
4 |   int foo(void);
  |       ^~~
</pre>

<h2>Conclusion</h2>

<p>GCC 13 implements many C2X proposals. These proposals align the C and C++ languages a little bit closer to each other by entwining certain features, and make programming in C easier and more secure.</p>
					
															
				</div>
			</div>
		</div></div>
  </body>
</html>
