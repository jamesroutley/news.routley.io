<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danvk.github.io/2025/09/11/pybind11.html">Original</a>
    <h1>Python and C&#43;&#43; with pybind11: A Great Combination</h1>
    
    <div id="readability-page-1" class="page"><div id="post">
  <p>The original motivation to revisit my Boggle project <a href="https://www.danvk.org/2025/02/10/boggle34.html">back in January</a> was that I wanted to experiment with mixing Python and C++. This had the potential to be a best-of-both-worlds combination: the developer productivity and ergonomics of Python and the performance of C++ for the parts where it really matters.</p>

<p>(For an explainer on the Boggle project, check out my <a href="https://www.danvk.org/2025/04/23/boggle-solved.html">announcement post</a> or Ollie Roeder’s <a href="https://archive.ph/siaAO">Financial Times article</a> about it.)</p>

<p>Boggle is all about finding performance optimizations. I pretty quickly settled on a high-level strategy:</p>

<ol>
  <li>Prototype new ideas in pure Python to validate them and work out the bugs.</li>
  <li>Once an idea has shown promise, port it to C++ and expose an identical API using <a href="https://pybind11.readthedocs.io/en/stable/">pybind11</a>.</li>
</ol>

<p>Overall this worked extremely well, with a few interesting exceptions. This blog post walks through the details. I hope it will give you a sense for whether this is a combination you’d like to use and, if you do, to avoid some of the lessons I learned the hard way.</p>

<p><strong>TL;DR:</strong> pybind11 is great, it lets you mix Python and C++ with a minimum of fuss. But performance in Python is only loosely correlated with performance in C++. A refactor that gets a 5x speedup in Python may be neutral or negative in C++.</p>

<h2 id="why-c-why-pybind11">Why C++? Why pybind11?</h2>

<p>C++ is not a new language, nor is it fashionable in 2025. I’ve <a href="https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc">dabbled in Rust</a>, but C++ was my primary language from roughly 2006–2011. It’s familiar to me, and learning a new low-level language wasn’t my goal for this project. Plus, I had <a href="https://github.com/danvk/performance-boggle">lots of Boggle code from 2009</a> that was already written in C++, and I wanted to take advantage of that.</p>

<p>Why <a href="https://pybind11.readthedocs.io/en/stable/">pybind11</a>? I tried <a href="https://cython.readthedocs.io/en/latest/src/tutorial/cython_tutorial.html">Cython</a>, but I was able to get a toy project up and running more easily with pybind11. Cython seems more geared towards gradually adding C++ bits to a pure Python project, whereas I wanted to bring existing C++ code into a Python project.</p>

<p>There’s also <a href="https://nanobind.readthedocs.io/en/latest/why.html">nanobind</a>, a newer tool from the same developer. This is more opinionated than pybind11 and claims to be faster. One of <a href="https://nanobind.readthedocs.io/en/latest/building.html">those opinions</a> is that you should set up a C++ build system (such as CMake or bazel), and I didn’t want to do that.</p>

<h2 id="what-is-pybind11">What is pybind11?</h2>

<p><img alt="pybind11 logo" src="https://danvk.github.io/images/pybind11.png" width="50%"/></p>

<p>pybind11 is a descendent of <a href="https://www.boost.org/doc/libs/1_64_0/libs/python/doc/html">Boost.Python</a>. Despite the name, it works just fine with newer version of the standard (I used <code>-std=c++20</code>).</p>

<p>pybind11 automates the process of creating Python wrappers for your C++ functions using C++ template metaprogramming. In particular, it binds all the STL containers to their Python equivalents. Your C++ function returns a <code>set&lt;pair&lt;string, vector&lt;int&gt;&gt;&gt;</code>? No problem. You’ll get a <code>set[tuple[str, list[int]]]</code> in Python.</p>

<p>For example, here’s an (abridged) version of the <a href="https://github.com/danvk/hybrid-boggle/blob/76caf9d58aa895b227feeba5d6b2d6c04d9bc1af/cpp/boggler.h#L12">C++ Boggler class</a>, which takes a Trie (Prefix Tree) and a Boggle board and finds all the words on it:</p>

<div><div><pre><code><span>// trie.h</span>
<span>class</span> <span>Trie</span> <span>{</span>
 <span>public:</span>
  <span>Trie</span><span>();</span>
  <span>~</span><span>Trie</span><span>();</span>
  <span>static</span> <span>unique_ptr</span><span>&lt;</span><span>Trie</span><span>&gt;</span> <span>CreateFromFile</span><span>(</span><span>const</span> <span>char</span><span>*</span> <span>filename</span><span>);</span>
 <span>private:</span>
  <span>// ...</span>
<span>}</span>

<span>// boggler.h</span>
<span>class</span> <span>Boggler</span> <span>{</span>
 <span>public:</span>
  <span>Boggler</span><span>(</span><span>Trie</span><span>*</span> <span>t</span><span>);</span>
  <span>// Find the sum of the scores of all words on this board.</span>
  <span>int</span> <span>Score</span><span>(</span><span>const</span> <span>char</span><span>*</span> <span>lets</span><span>);</span>
  <span>// Find the paths to all words on this board (for the web UI).</span>
  <span>vector</span><span>&lt;</span><span>vector</span><span>&lt;</span><span>int</span><span>&gt;&gt;</span> <span>FindWords</span><span>(</span><span>const</span> <span>string</span><span>&amp;</span> <span>lets</span><span>);</span>
 <span>private:</span>
  <span>// ...</span>
<span>}</span>
</code></pre></div></div>

<p>(<a href="https://www.danvk.org/wp/2007-02-06/in-which-we-discover-that-tries-are-awesome/index.html">This 2007 post</a> explains how to use a Trie to find all the words on a Boggle board.)</p>

<p>Here’s the <a href="https://github.com/danvk/hybrid-boggle/blob/76caf9d58aa895b227feeba5d6b2d6c04d9bc1af/cpp/cpp_boggle.cc#L50">pybind11 wrapper code</a>:</p>

<div><div><pre><code><span>// cpp_boggle.cc</span>
<span>PYBIND11_MODULE</span><span>(</span><span>cpp_boggle</span><span>,</span> <span>m</span><span>)</span> <span>{</span>
  <span>py</span><span>::</span><span>class_</span><span>&lt;</span><span>Trie</span><span>&gt;</span><span>(</span><span>m</span><span>,</span> <span>&#34;Trie&#34;</span><span>)</span>
    <span>.</span><span>def_static</span><span>(</span><span>&#34;create_from_file&#34;</span><span>,</span> <span>&amp;</span><span>Trie</span><span>::</span><span>CreateFromFile</span><span>)</span>

  <span>py</span><span>::</span><span>class_</span><span>&lt;</span><span>Boggler</span><span>&gt;</span><span>(</span><span>m</span><span>,</span> <span>&#34;Boggler&#34;</span><span>)</span>
    <span>.</span><span>def</span><span>(</span><span>py</span><span>::</span><span>init</span><span>&lt;</span><span>Trie</span> <span>*&gt;</span><span>())</span>
    <span>.</span><span>def</span><span>(</span><span>&#34;score&#34;</span><span>,</span> <span>&amp;</span><span>BB</span><span>::</span><span>Score</span><span>)</span>
    <span>.</span><span>def</span><span>(</span><span>&#34;find_words&#34;</span><span>,</span> <span>&amp;</span><span>BB</span><span>::</span><span>FindWords</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>To build a C extension, you <a href="https://github.com/danvk/hybrid-boggle/blob/76caf9d58aa895b227feeba5d6b2d6c04d9bc1af/build.sh">run your C++ compiler</a> with the appropriate include paths, which the pybind11 executable will provide for you:</p>

<div><div><pre><code>$ gcc -std=c++20 -fPIC -O3 -undefined dynamic_lookup \
  $(poetry run python -m pybind11 --includes) \
  cpp_boggle.cc trie.cc boggler.cc \
  -o ../cpp_boggle$(python3-config --extension-suffix)
</code></pre></div></div>

<p>(Why <code>-undefined dynamic_lookup</code>? See <a href="https://github.com/pybind/pybind11/issues/382">this issue</a>, it seems to be a macOS thing.)</p>

<p>This produces a build artifact that includes your system architecture and Python version:</p>

<div><div><pre><code>$ ls -l cpp_boggle.cpython-31*
-rwxr-xr-x  1 danvk  staff   1.0M Aug 27 10:01 cpp_boggle.cpython-313-darwin.so
</code></pre></div></div>

<p>Here’s a first gotcha: make sure you use the same Python version when you build your C++ and execute your Python. If you switch Python versions in one terminal but not another, you can wind up in a confusing situation where you build a new version of your C++ but execute an old one.</p>

<p>Finally, here’s the <a href="https://github.com/danvk/hybrid-boggle/blob/76caf9d58aa895b227feeba5d6b2d6c04d9bc1af/boggle/args.py#L54C5-L54C17">Python code</a>:</p>

<div><div><pre><code><span>from</span> <span>cpp_boggle</span> <span>import</span> <span>Trie</span><span>,</span> <span>Boggler</span>

<span>t</span> <span>=</span> <span>Trie</span><span>.</span><span>create_from_file</span><span>(</span><span>&#34;wordlists/enable2k.txt&#34;</span><span>)</span>
<span>b</span> <span>=</span> <span>Boggler</span><span>(</span><span>t</span><span>)</span>
<span>print</span><span>(</span><span>b</span><span>.</span><span>score</span><span>(</span><span>&#34;abcdefghijklmnop&#34;</span><span>))</span>  <span># 18
</span><span>print</span><span>(</span><span>b</span><span>.</span><span>score</span><span>(</span><span>&#34;perslatgsineters&#34;</span><span>))</span>  <span># 3625
</span></code></pre></div></div>

<p>A few things to note here:</p>

<ul>
  <li>These functions all take small inputs (strings), have small outputs (pointers or ints), and do lots of work. This is exactly the sort of function that you want to wrap. There is a small but measurable overhead to going between C++ and Python. If you do it millions of times a second, it will be a wash. (Thousands of times a second is probably still a win.)</li>
  <li>The C++ <code>score</code> function is 20-30x faster than the equivalent in pure Python. This speedup is typical.</li>
  <li>pybind11 happily converts between Python <code>str</code> and C++ <code>const char*</code>. It’s also happy to convert the STL types <code>const string&amp;</code> and <code>vector&lt;vector&lt;int&gt;&gt;</code>.</li>
</ul>

<p><code>CreateFromFile</code> returns a <code>unique_ptr</code>, a C++ smart pointer. When you return a <code>unique_ptr</code> (or a raw pointer), pybind11 will have Python’s garbage collector track it. When <code>t</code> goes out of scope (in Python), it will be destroyed. This is usually what you want but, if it’s not, you can disable this with a <code>return_value_policy::reference</code> annotation in the pybind11 wrapper:</p>

<div><div><pre><code><span>// trie.h</span>
<span>Trie</span><span>*</span> <span>FindWord</span><span>(</span><span>const</span> <span>char</span><span>*</span> <span>wd</span><span>);</span>

<span>// cpp_boggle.cc</span>
<span>py</span><span>::</span><span>class_</span><span>&lt;</span><span>Trie</span><span>&gt;</span><span>(</span><span>m</span><span>,</span> <span>&#34;Trie&#34;</span><span>)</span>
  <span>.</span><span>def_static</span><span>(</span><span>&#34;create_from_file&#34;</span><span>,</span> <span>&amp;</span><span>Trie</span><span>::</span><span>CreateFromFile</span><span>)</span>
  <span>.</span><span>def</span><span>(</span><span>&#34;find_word&#34;</span><span>,</span> <span>&amp;</span><span>Trie</span><span>::</span><span>FindWord</span><span>,</span> <span>py</span><span>::</span><span>return_value_policy</span><span>::</span><span>reference</span><span>)</span>
</code></pre></div></div>

<p>When I got segfaults from Python, a missing <code>return_value_policy</code> was usually the culprit.</p>

<h2 id="python-and-c-a-great-combination">Python and C++: A Great Combination</h2>

<p>The fear with mixed solutions is always that they’ll be <a href="https://en.wikipedia.org/wiki/Leaky_abstraction">leaky abstractions</a>. In this case, that would mean that you’d need to be proficient with Python, C++, <em>and</em> pybind11, rather than just Python and C++.</p>

<p>That fear didn’t materialize. Once I understood the <a href="https://pybind11.readthedocs.io/en/stable/advanced/functions.html#return-value-policies">return value policy</a>, I could mostly just write Python and C++ and forget that pybind11 was in the middle. If I added a class or method, I’d need to add a wrapper, but this was pretty mechanical. I never ran into a performance issue that was due to pybind11.</p>

<p>I really liked being able to write all my code that wasn’t performance sensitive in Python. This included CLI wrappers, data serialization and unit tests. <a href="https://github.com/danvk/hybrid-boggle/blob/76caf9d58aa895b227feeba5d6b2d6c04d9bc1af/boggle/boggler_test.py">Using pytest</a> to write unit tests for my C++ code was particularly nice.</p>

<p>In the end, you are still writing C++, of course. You still have to worry about segfaults, alignment and the <a href="https://www.danvk.org/2025/04/10/following-insight.html#inline-child-nodes-and-arenas">layout of your structs</a>. This is the cost of that 20-30x speedup. But at least you only pay it for the small part of your code that’s truly performance critical.</p>

<h2 id="prototype-in-python-implement-in-c-a-mixed-bag">Prototype in Python, Implement in C++: A Mixed Bag</h2>

<p>For an open-ended project like this, you wind up exploring lots of ideas that don’t pan out. In the end, at least 90% of my ideas for speeding up BoggleMax either didn’t work or eventually got replaced with something better. If you can explore an idea and reject it in Python, without paying the cost of implementing it in C++, then you save a lot of time and mental energy. One thing I remembered from working on this in 2009 was that it was a real bummer to sink a week or two of spare time into implementing an algorithm in C++, only to not have it work out. I wanted to avoid that.</p>

<p>This worked as I hoped <em>some</em> of the time. Prototyping an idea in Python was a good way to hash out the details and learn about unforeseen complications. And having a reference Python implementation made porting to C++ much easier. I could use the same tests to ensure that <a href="https://github.com/15r10nk/inline-snapshot/discussions/199">the two implementations matched</a>. LLMs are very good at porting code between languages, so I often didn’t need to do this myself.</p>

<p>Where this didn’t work at all was in prototyping performance optimizations. You optimize for the system you develop in. If you make a change and your code gets slower, you’ll reject it. If it makes it faster, you’ll keep it. Unfortunately, changes that make your Python code faster may or may not have that effect on the C++ version. This effect is not subtle. I found a few 5x speedups in Python that wound up being completely neutral in C++.</p>

<p>Why does this happen? At a high level, running pure Python code is slow. Anything you can do to shift the bottleneck to C/C++ code is going to be a win. Porting your code to C++ is an obvious way to do that, but there are more subtle ways.</p>

<p>For example, I found that <a href="https://www.danvk.org/2025/02/13/boggle2025.html#compression-and-de-duping">memoizing a particular function</a> in Python was a big win. But memoizing the same function in C++ had no effect. Looking at a CPU profile revealed why. By memoizing the Python function, you shift more of the computation to the <code>hash</code> builtin, which is written in C. So memoization is a sneaky way of migrating your work from Python to C.</p>

<p>Another subtle effect: I developed on my M2 Macbook, but I did <a href="https://www.danvk.org/2025/04/23/boggle-solved.html#the-results">the big runs</a> on Intel chips on Google Cloud. These chips have different memory bandwidth, cache sizes and branch prediction behaviors. If I’d developed on Intel, I might have made different choices.</p>

<p>Sometimes an idea would be easy to implement in Python, then I’d port it to C++ and realize it <a href="https://github.com/danvk/hybrid-boggle/issues/83#issuecomment-3099324655">depended on garbage collection</a> in a way that I hadn’t thought about. Memory management matters. Using an arena wound up being a <a href="https://github.com/danvk/hybrid-boggle/pull/62">huge performance win</a>, but there’s no way to prototype that in Python.</p>

<p>In the end, this meant that it was still a lot of work to build out an idea in C++ before I found out whether it was a performance win. Still, having the reference Python implementation did make it easier to find bugs and keep my sanity along the way.</p>

<h2 id="conclusions">Conclusions</h2>

<p>Overall, combining C++ and Python worked very well. For the most part, I was able to get the best of both worlds: the ergonomics and developer productivity of Python for 90% of my code, and the speed of C++ for the 10% where it mattered.</p>

<p>If you’re comfortable with C++ and Python, I’d highly recommend using pybind11. (If you like CMake, you might try <a href="https://nanobind.readthedocs.io/en/latest/why.html">nanobind</a>.) Be aware of its behavior when you return a pointer. But otherwise, it really just works.</p>

<p>Prototyping in Python and then porting to C++ was more of a mixed bag. It did help to hammer out the details of an idea and get a correct reference implementation. But it didn’t provide useful guidance on what would be a performance win. C++ isn’t always exactly 20-30x faster than Python. Speedups in Python are only loosely correlated with speedups in C++. If performance is the goal, you’ll still have to get a complete C++ implementation before you know if you have a win.</p>


  </div></div>
  </body>
</html>
