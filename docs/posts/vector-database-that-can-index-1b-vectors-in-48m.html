<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.vectroid.com/blog/why-and-how-we-built-Vectroid">Original</a>
    <h1>Vector database that can index 1B vectors in 48M</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>We are excited to announce Vectroid, a serverless vector search solution that delivers exceptional accuracy and low latency in a cost effective package. Vectroid is not just <em>another vector search</em> solution—it’s a search engine that performs and scales in all scenarios.</p><h3>Why we built Vectroid</h3><p>Talk to any team working with large, low latency vector workloads and you’ll hear a familiar story: something always has to give. Vector databases often make significant tradeoffs between speed, accuracy, and cost. That’s the nature of the mathematical underpinnings of vector search works—taking algorithmic <em>shortcuts</em> to get near-perfect results in a short amount of time.</p><p>There are some common permutations of these tradeoffs:</p><li>Ve<em>ry high accuracy</em>, but <em>very expensive</em> and <em>slow</em></li>
<li><em>Fast speed</em> and <em>tolerable accuracy</em>, but <em>very expensive</em></li>
<li><em>Cheap</em> and <em>fast</em>, but <em>inaccurate</em> to a <em>disqualifying degree</em></li>
<p>Based on the existing vector database landscape, it would seem that building a cost effective vector database requires sacrificing either speed or accuracy at scale. We believe that’s a false pretense: building a cost-efficient database <em>is</em> possible with high accuracy and low latency. We just need to rethink our underlying mechanism.</p><h3>Our “aha” moment</h3><p>Query speed and recall are largely a function of the chosen ANN algorithm. Algorithms which are both fast <em>and</em> accurate like HNSW (Hierarchical Navigable Small Worlds) are memory intensive and expensive to index. The traditional assumption is that these types of algorithms are untenable for a cost-conscious system.</p><p>We had two major realizations which challenged this assumption.</p><ol><li><strong>Demand for in-memory HNSW is not static.</strong> Real world usage patterns are bursty and uneven. A cost efficient database can optimize for this reality by making resource allocation dynamic and by individually scaling system components as needed.</li>
<li><strong>HNSW’s memory footprint is tunable.</strong> It can be easily be flattened (ex. by compressing vectors using quantization) and expanded (ex. by increasing layer count), which gives us the flexibility to experiment with different configurations to find a goldilocks setup.</li>
</ol>
<h3>What is Vectroid?</h3><p>Vectroid is a serverless vector database with premium performance. It delivers the same or stronger balance of speed and recall promised by high-end offerings, but costs less than competitors.</p><ol><li>Performant vector search: HNSW for ultra fast, high recall similarity search.</li>
<li>Near real-time search capabilities: Newly ingested records are searchable almost instantly.</li>
<li>Massive scalability: Seamlessly handles billions of vectors in a single namespace.</li>
<li>Cost efficient resource utilization: Scaling each layer (ingest, index, query) separately.</li>
</ol>
<h3>How Vectroid performs</h3><p>The core philosophy of Vectroid is that optimizing for one metric at any cost to the others doesn’t make for a robust system. Instead, vector search should be designed for balanced performance across recall, latency, and cost so users don’t have to make painful tradeoffs as workloads grow.</p><p>When tested against other state-of-the-art vector search, Vectroid is not only competitive but the most consistent across the board. Across all of our tests, Vectroid is the <em>only</em> databases that was able to maintain over 90% recall while scaling to 10 query threads per second—all while maintaining good latency scores.</p><h3>Some early benchmarks:</h3><li>Indexed <strong>1B vectors (Deep1B)</strong> in ~<strong>48 minutes</strong></li>
<li>Achieved <strong>P99 latency of 34ms</strong> on the <strong>MS Marco 138M vector / 1024 dimensions dataset</strong></li>
<p>We’ll be releasing the full benchmark suite (with setup details so anyone can reproduce them) in an upcoming post. For now, these numbers highlight the kind of scale and performance we designed Vectroid to handle.</p><h3>How Vectroid works</h3><p>Vectroid is composed of two independently scalable microservices for writes and reads.</p><p><img src="https://www.vectroid.com/images/blog/vectroid-arch-diagram.png"/></p><p>As the diagram shows, index state, vector data, and metadata are persisted to cloud object storage (GCS for now, S3 coming soon). Disk, cache, and in-memory storage layers each employ a usage-aware model for index lifecycle in which indexes are lazily loaded from object storage on demand and evicted when idle.</p><p>For fast, high-recall ANN search, we chose the <strong>HNSW algorithm</strong>. It offers excellent latency and accuracy tradeoffs, supports incremental updates, and performs well across large-scale workloads. To patch its limitations, we added a number of targeted optimizations:</p><li>Slow indexing speed ⇒ in-memory write buffer to ensure newly inserted vectors are immediately searchable</li>
<li>High indexing cost ⇒ batched, highly concurrent and partitioned indexing</li>
<li>High memory usage ⇒ vector compression via quantization</li>
<h3>Final Thoughts</h3><p>We’re just getting started. If you’re building applications that rely on fast, scalable vector search (or you’re running up against the limits of your current stack), we’d love to hear from you. Start using Vectroid today or sign up for our newsletter to follow along as we continue building.</p></div></div></div></div>
  </body>
</html>
