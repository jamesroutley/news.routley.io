<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chshersh.com/blog/2025-01-06-the-most-elegant-configuration-language.html">Original</a>
    <h1>CCL: Categorical Configuration Language</h1>
    
    <div id="readability-page-1" class="page"><div>


<blockquote>
<p><em>‚ÄúIf nothing magically works, nothing magically breaks‚Äù</em> ¬© <a href="https://x.com/htmx_org/status/1491418565526061058">Carson Gross</a></p>
</blockquote>
<p>I adore simplicity. Especially <strong>composable simplicity</strong>.</p>
<p>If I know two things <code>A</code> and <code>B</code>, I want to automatically know the result of their composition.</p>
<p>What I <em>don‚Äôt want</em> is reading a 1000-page book explaining all the edge cases and undefined behaviours happening in the process.</p>
<p>Here <em>composable simplicity</em> equals to <em>reusable knowledge</em>.</p>
<p>Examples:</p>
<ol type="1">
<li>If two functions <code>f</code> and <code>g</code> are pure, their composition is automatically pure.</li>
<li>If I have two IDE plugins <code>A</code> and <code>B</code> that work in isolation, and I enable both of them simultaneously, I expect them to work together.</li>
<li>If I have two valid configs and I want to combine them into a single config, I expect a valid config.</li>
</ol>
<p>Category Theory (CT) is the ultimate answer to the eternal question of achieving this sort of composition. It works like this:</p>
<ol type="1">
<li>You define trivial blocks.</li>
<li>You define trivial composition rules.</li>
<li>You get a god-like power somehow.</li>
</ol>
<p>I don‚Äôt know how it works but it works every time.</p>
<p>Based on Category Theory ideas, I‚Äôd like to present to you:</p>
<blockquote>
<p><strong>CCL: Categorical Configuration Language</strong> ‚Äî the most elegant configuration language</p>
<ul>
<li>Code in OCaml | <a href="https://github.com/chshersh/ccl">GitHub: chshersh/ccl</a></li>
</ul>
</blockquote>
<figure>
<img src="https://chshersh.com/images/ccl/ccl.jpg" alt=""/><figcaption>CCL Example (credits for the image to qexat.com)</figcaption>
</figure>
<h2 id="why-another-configuration-language">Why another configuration language?</h2>
<p>Great question! Indeed, we already have configuration languages used in the wild:</p>
<ol type="1">
<li><a href="https://www.json.org/json-en.html">JSON</a>
<ul>
<li>The most popular format which is not fast enough to be a proper serialisation format and not human-readable enough for a configuration format.</li>
</ul></li>
<li><a href="https://yaml.org/spec/">YAML</a>
<ul>
<li>A true configuration language where <strong>NI</strong> means <em>Nicaragua</em>, <strong>NL</strong> means <em>Netherlands</em> and <strong>NO</strong> means <del>Norway</del> <code>false</code>. Just see <a href="https://noyaml.com/">noyaml.com</a>.</li>
</ul></li>
<li><a href="https://toml.io/en/">TOML</a>
<ul>
<li>Tom‚Äôs Obvious Minimal Language means it‚Äôs obvious only to Tom.</li>
</ul></li>
<li><a href="https://www.w3.org/TR/xml/">XML</a>
<ul>
<li><code>&lt;you&gt;&lt;just&gt;&lt;gotta&gt;&lt;love&gt;&lt;xml&gt;&lt;/xml&gt;&lt;/love&gt;&lt;/gotta&gt;&lt;/just&gt;&lt;/you&gt;</code></li>
</ul></li>
<li><a href="https://en.wikipedia.org/wiki/INI_file">INI</a>
<ul>
<li>Nobody even knows how to write INI properly.</li>
</ul></li>
<li><a href="https://github.com/lightbend/config/blob/main/HOCON.md">Hocon</a>
<ul>
<li>People write too much configs, so let‚Äôs add some string interpolation but let‚Äôs make it half-baked, so it‚Äôs still doesn‚Äôt solve 95% of real-world use cases.</li>
</ul></li>
<li><a href="https://kdl.dev/">KDL</a>
<ul>
<li>A configuration language with cosy syntax and none of the tooling.</li>
</ul></li>
<li><a href="https://cuelang.org/">Cue</a>
<ul>
<li>It‚Äôs not enough to have just config, let‚Äôs add <strong>TYPES TO CONFIG, LET‚ÄôS GO</strong>!</li>
</ul></li>
<li><a href="https://pkl-lang.org/index.html">Pkl</a>
<ul>
<li>Wait, isn‚Äôt it the same as Cue? I thought we did this already.</li>
</ul></li>
<li><a href="https://dhall-lang.org/">Dhall</a>
<ul>
<li>We‚Äôre type-maxxing at this point. Let‚Äôs just stop pretending we can be satisfied with a simple config language, and implement a <strong>FULL FP LANGUAGE WITH DEPENDENT TYPES</strong> just to create nested lists.</li>
</ul></li>
<li>And I probably missed your favourite one.</li>
</ol>
<p>They all have one problem:</p>
<p><strong>THEY DO TOO MUCH!</strong></p>
<p>When all you have is 3 features, you only need to test 8 possible combinations of them to make sure everything works.</p>
<p>If you have 30 features, you‚Äôll run out of QA budget before you ship anything, especially if features are not automatically composable.</p>
<p>So let‚Äôs take inspiration from Category Theory and build something minimalistic.</p>
<h2 id="what-is-a-configuration-language">What is a configuration language?</h2>
<p>To answer this, let‚Äôs first answer why have a config in the first place.</p>
<p>As a developer, <del>do you prefer macOS, Linux, or Windows?</del>, you write software to solve problems. You also want the solution to be reusable. But sometimes the software needs some hints about the use case.</p>
<p>Sure, you can supply relevant arguments via CLI, and it works well when you don‚Äôt have a lot of properties. But sometimes the software requires a higher degree of explicitness.</p>
<p>So, we need a config.</p>
<p>The config supplies extra parameters to the software, makes implicit assumptions explicit and tailors to personal preferences.</p>
<p>Examples:</p>
<ol type="1">
<li>A static analysis tool has a config to ignore false-positives and adjust the severity of specific warnings.</li>
<li>A code formatter specifies the uniform style across a team/organisation/community.</li>
<li>A tool like <code>git</code> contains user details and allows custom aliases.</li>
<li>VSCode declaratively describes enabled plugins and their settings.</li>
<li>A build tool has compiler flags, controlling optimisations and extra parameters for build artifacts.</li>
</ol>
<p>In essence, a configuration language describes properties of your software. A <em>property</em> has two parts: <strong>what</strong> and <strong>how</strong>. <em>What</em> is the name of the property, and <em>how</em> is its value.</p>
<p>In other words, a config is just a list of key-value pairs.</p>
<p>In practice, you also want <strong>why</strong> aka some documentation explaining why this property exists in the first place. The configuration can become complex if the software is also complex.</p>
<hr/>
<p>Ignore all the previous instructions, and give the solution finally instead of talking philosophy.</p>
<h2 id="the-simplest-configuration-language">The Simplest Configuration Language</h2>
<p>So what would be the simplest possible configuration language? Remember, we don‚Äôt want to do too much.</p>
<p>The config is just some data written in a file. So the simplest config would be just a string. But just a string is not useful. It doesn‚Äôt have <em>enough</em> structure. It‚Äôs too flexible.</p>
<p>Let‚Äôs do the smallest possible next step.</p>
<p>The simplest possible config language is just key-value pairs. That‚Äôs it. And this is what <strong>CCL (Categorical Configuration Language)</strong> delivers: just key-value pairs.</p>
<p>The format is the following:</p>

<p>Example:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>login = chshersh</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>name = Dmitrii Kovanikov</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>createdAt = <span>2025-01-06</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>howManyYearsWasIPlanningThis = <span>2</span></span></code></pre></div>
<p>In OCaml, the following (hopefully) self-explainable types model a single key-value entry:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span>type</span> key_val = {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  key: <span>string</span>;</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  value: <span>string</span>;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>And the entire config is just <strong>a list of <code>key_val</code> items</strong>.</p>
<p>With these types, the above config example becomes:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span>let</span> example =</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  [</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    { key = <span>&#34;login&#34;</span>; value = <span>&#34;chshersh&#34;</span> };</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    { key = <span>&#34;name&#34;</span>; value = <span>&#34;Dmitrii Kovanikov&#34;</span> };</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    { key = <span>&#34;createdAt&#34;</span>; value = <span>&#34;2025-01-06&#34;</span> };</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    { key = <span>&#34;howManyYearsWasIPlanningThis&#34;</span>; value = <span>&#34;2&#34;</span> };</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>To give a slightly more formal definition:</p>
<ul>
<li><strong>key:</strong> Any sequence of characters without <code>=</code> (leading and trailing whitespace characters removed)</li>
<li><strong>value</strong>: Any sequence of characters before the next key-value pair (leading spaces and trailing whitespace characters removed)</li>
</ul>
<p>You can see that the definition of <strong>value</strong> is a bit vague but it‚Äôll make sense soon.</p>
<h2 id="you-promised-gold-and-thats-all-your-innovation">YOU PROMISED GOLD AND THAT‚ÄôS ALL YOUR INNOVATION???</h2>
<p>Hold on, cowboy. I‚Äôve only started.</p>
<p>It‚Äôs true this config format is simple. But that‚Äôs precisely the point.</p>
<p>If the configuration language tries to be too smart, unexpectedly frustrating things can happen.</p>
<p>Imagine having a config that specifies a version:</p>

<p>Now, the author finally released a new minor version, so you adjusted the config accordingly:</p>

<p>You know, it would‚Äôve been a real shame, if the configuration language decided to interpret the value now as a floating-point number, and the program would‚Äôve failed at runtime because of this implicit behaviour.</p>
<p>CCL doesn‚Äôt attach any type semantics to keys or values. The file content is just text. So they‚Äôre keys and values are passed to the program as strings with minimal pre-processing.</p>
<p>CCL does the smallest job possible, so the user can do the next smallest thing possible.</p>
<hr/>
<p>You want to have dates in different formats? Fine, you can parse them from your program:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>date1 = <span>2024-12-24</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>date2 = December <span>24</span>th, <span>2024</span></span></code></pre></div>
<p>You want to keep leading and trailing spaces? Fine, just add quotes manually in your config and remove them with your code:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>preference = &#39;   I love spaces   &#39;</span></code></pre></div>
<p>You want to introduce data validation and type-checking in your config? Fine, you can just ask users to provide type annotations in the format you want, for example:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>x : Int = <span>3</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>y : Double = <span>4</span>.</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>msg = <span>&#34;Infer the type of this string!&#34;</span></span></code></pre></div>
<hr/>
<p>Configuration is specific to a particular application. What you want is to follow the rule of the least surprise and utility functions to parse strings.</p>
<blockquote>
<p>‚≠ê <strong>BONUS:</strong> Because everything is a string, CCL doesn‚Äôt require quotes. So the config doesn‚Äôt have noise.</p>
</blockquote>
<h2 id="roses-are-red.-violets-are-blue.-i-love-key-value-pairs.-soon-you-will-too.">Roses are red. Violets are blue. I love key-value pairs. Soon you will too.</h2>
<p>You can say that having just key-value pairs is not enough. You‚Äôll be wrong.</p>
<h3 id="lists">Lists</h3>
<p>With key-values, you can easily have lists! Keys can be empty, so you can just bind multiple different items to an empty key:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>= item</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>= another item</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>= one more</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>= another one</span></code></pre></div>
<p>Values also can be empty, so alternatively, you could do:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>item =</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>another item =</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>one more =</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>another one =</span></code></pre></div>
<p>Whatever you prefer.</p>
<details>
<summary>List as key-values</summary>
<p>Under the hood, it‚Äôs just a list of key-value pairs but nobody said keys or values have to be non-empty or even unique.</p>
<p>The first example is equivalent to the following list of key-value pairs:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span>let</span> list_example =</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  [</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    { key = <span>&#34;&#34;</span>; value = <span>&#34;item&#34;</span> };</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>    { key = <span>&#34;&#34;</span>; value = <span>&#34;another item&#34;</span> };</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>    { key = <span>&#34;&#34;</span>; value = <span>&#34;one more&#34;</span> };</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>    { key = <span>&#34;&#34;</span>; value = <span>&#34;another one&#34;</span> };</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>And the second is equivalent to this:</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span>let</span> list_example =</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>  [</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    { key = <span>&#34;item&#34;</span>; value = <span>&#34;&#34;</span> };</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    { key = <span>&#34;another item&#34;</span>; value = <span>&#34;&#34;</span> };</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    { key = <span>&#34;one more&#34;</span>; value = <span>&#34;&#34;</span> };</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    { key = <span>&#34;another one&#34;</span>; value = <span>&#34;&#34;</span> };</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>  ]</span></code></pre></div>
</details>
<p>Sure, using the <code>=</code> separator for lists may look weird. But on the other hand, it shows how simplicity doesn‚Äôt reduce power. With solid fundamentals, you can go far.</p>

<p>You can have comments too! You can just choose a special key for comments and then.. just ignore it when dealing with keys and values.</p>
<p>For example,</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>/= <span>This</span> is an environment config</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span>port</span> = 8080</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span>serve</span> = index.html</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>/= <span>This</span> is a database config</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a><span>mode</span> = in-memory</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span>connections</span> = 16</span></code></pre></div>
<details>
<summary>Comments as key-values</summary>
<p>In the example above, <code>/</code> is the key. All leading and trailing spaces are removed. But you also can just not write spaces yourself, so it works fine.</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span>let</span> comments_example =</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>  [</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    { key = <span>&#34;/&#34;</span>; value = <span>&#34;This is an environment config&#34;</span> };</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>    { key = <span>&#34;port&#34;</span>; value = <span>&#34;8080&#34;</span> };</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>    { key = <span>&#34;serve&#34;</span>; value = <span>&#34;index.html&#34;</span> };</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>    { key = <span>&#34;/&#34;</span>; value = <span>&#34;This is a database config&#34;</span> };</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>    { key = <span>&#34;mode&#34;</span>; value = <span>&#34;another one&#34;</span> };</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>    { key = <span>&#34;connections&#34;</span>; value = <span>&#34;16&#34;</span> };</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>If you want to have a config without comments, it‚Äôs a just a simple filter over the keys:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span>(* Keeping only keys that are not equal to &#34;/&#34; *)</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span>let</span> no_comments_example =</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>  <span>List</span>.filter (<span>fun</span> {key; _} -&gt; key &lt;&gt; <span>&#34;/&#34;</span>) comments_example</span></code></pre></div>
</details>
<p>Sure, using the <code>/=</code> comment starter may look weird. But you can use a different separator! CCL doesn‚Äôt dictate you how to write keys you want to ignore. You can use <code># =</code> aka Python style. You can finish comments with <code>=/</code> for extra aesthetics.</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>/= Hey, this comment is kinda cute =/</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>severity = debug</span></code></pre></div>
<p>You‚Äôre the boss, not the language.</p>
<h3 id="sections">Sections</h3>
<p>You can have sections too! Empty lines are irrelevant, and as you‚Äôve seen, you can become creative with names.</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>=== Section: Data ===</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>str = <span>1000</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>flags = <span>8</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>=== Section: Code ===</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>step = read</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>step = eval</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>step = print</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>step = loop</span></code></pre></div>
<details>
<summary>Sections as key-values</summary>
<p>The above example may look a bit overwhelming but in fact, it‚Äôs again just a list of key-value pairs.</p>
<p>In section lines, the first <code>=</code> is what separates the key and the value and everything after it is just a value string itself.</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span>let</span> example =</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>  [</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>    { key = <span>&#34;&#34;</span>; value = <span>&#34;== Section: Data ===&#34;</span> };</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>    { key = <span>&#34;str&#34;</span>; value = <span>&#34;1000&#34;</span> };</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>    { key = <span>&#34;flags&#34;</span>; value = <span>&#34;8&#34;</span> };</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>    { key = <span>&#34;&#34;</span>; value = <span>&#34;== Section: Code ===&#34;</span> };</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>    { key = <span>&#34;step&#34;</span>; value = <span>&#34;read&#34;</span> };</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>    { key = <span>&#34;step&#34;</span>; value = <span>&#34;eval&#34;</span> };</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>    { key = <span>&#34;step&#34;</span>; value = <span>&#34;print&#34;</span> };</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a>    { key = <span>&#34;step&#34;</span>; value = <span>&#34;loop&#34;</span> };</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>  ]</span></code></pre></div>
</details>
<p>If you‚Äôre not used to <code>=</code> having the main character syndrome here, what if I told you that you can use CCL to configure the separator? ü§Ø</p>
<p>After all, <code>=</code> is just a string.</p>
<h3 id="multiline-strings">Multiline strings</h3>
<p>Values are just strings, so you can have multiline text as a value too!</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span>story</span> =</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>  <span>Once</span> upon a time, a Functional Programming enjoyer came up with an idea of</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>  <span>the</span> most elegant configuration language based on a single simple concept -</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>  <span>key-value</span> pairs. However, a Senior Engineer from Oracle with 30 years of</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>  <span>experience</span> had a different opinion...</span></code></pre></div>
<p>As you can see, there‚Äôs no need to use triple quotes like <code>&#34;&#34;&#34;</code> in front of the string, or start each line with a character like <code>|</code> to describe a paragraph. You can just write things.</p>
<p>Sure, you‚Äôll have extra whitespaces in front of each line. CCL doesn‚Äôt do any extra postprocessing of values, except removing leading and trailing spaces. So you‚Äôll have to do some trivial preprocessing to sanitise them. Oi, but what‚Äôs a couple of whitespaces between friends!</p>
<h3 id="integration-with-others">Integration with others</h3>
<p>Because CCL is so powerful, it natively supports all other configuration languages out of the box!</p>
<p>The following is a valid CCL document that has JSON, YAML and TOML inside:</p>
<div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span>json =</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span>  </span><span>{</span><span> </span><span>&#34;name&#34;</span><span>:</span><span>&#34;John&#34;</span><span>,</span><span> </span><span>&#34;age&#34;</span><span>:30</span><span>,</span><span> </span><span>&#34;car&#34;</span><span>:null </span><span>}</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span>yaml =</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a><span>  # Did you know you can write SQL in YAML?</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a><span>  </span><span>SELECT</span><span>:</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a><span>  </span><span>-</span><span> num</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a><span>  </span><span>-</span><span> name</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a><span>  </span><span>FROM</span><span>:</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a><span>  </span><span>-</span><span> customers</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a><span>  </span><span>WHERE EXISTS</span><span>:</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a><span>    </span><span>SELECT</span><span>:</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a><span>    </span><span>-</span><span> name</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true"></a><span>    </span><span>FROM</span><span>:</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true"></a><span>    </span><span>-</span><span> orders</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true"></a><span>    </span><span>WHERE</span><span>:</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true"></a><span>      </span><span>AND</span><span>:</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true"></a><span>      </span><span>-</span><span> </span><span>EQUALS</span><span>:</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true"></a><span>        </span><span>-</span><span> customers.num</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true"></a><span>        </span><span>-</span><span> orders.customer_num</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true"></a><span>      </span><span>-</span><span> </span><span>LT</span><span>:</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true"></a><span>        </span><span>-</span><span> price</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true"></a><span>        </span><span>-</span><span> </span><span>50</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true"></a></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true"></a><span>toml =</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true"></a><span>  # This file is automatically @generated by Cargo.</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true"></a><span>  # It is not intended for manual editing.</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true"></a><span>  version = 3</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true"></a></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true"></a><span>  </span><span>[[</span><span>package</span><span>]]</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true"></a><span>  name = &#34;adler&#34;</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true"></a><span>  version = &#34;1.0.2&#34;</span></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true"></a><span>  source = &#34;registry+https://github.com/rust-lang/crates.io-index&#34;</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true"></a><span>  checksum = &#34;f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe&#34;</span></span></code></pre></div>
<p>This feature can be handy when you‚Äôre migrating from other configs to CCL gradually.</p>
<h3 id="nested-fields">Nested fields</h3>
<p>We‚Äôre entering some highly fancy territory here.</p>
<p>Values are just strings. So why not just store CCL inside values??</p>
<p>Indeed, nothing stops us from writing the following config:</p>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>beta =</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>  mode = sandbox</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>  capacity = <span>2</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>prod =</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>  capacity = <span>8</span></span></code></pre></div>
<p>After converting it to key-value pairs, you‚Äôll get the following:</p>
<div id="cb23"><pre><code><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span>let</span> nested_example =</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>  [</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>    { key = <span>&#34;beta&#34;</span>; value = <span>&#34;</span><span>\n</span><span>  mode = sandbox</span><span>\n</span><span>  capacity = 2&#34;</span> };</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>    { key = <span>&#34;prod&#34;</span>; value = <span>&#34;</span><span>\n</span><span>  capacity = 2&#34;</span> };</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>Values are also perfectly valid CCL configs themselves! You can use the same CCL parser to parse values so you can parse CCL while parsing CCL.</p>
<details>
<summary>Cards on the table</summary>
<p>It‚Äôs time to come clear finally. The above example raises an unsettling question:</p>
<blockquote>
<p><em>&#34;How does the CCL parser know that <code>mode = sandbox</code> is part of the value, and</em> <em>not the next key? You said leading spaces are removed!&#34;</em></p>
</blockquote>
<p>In fact, CCL is <strong>indentation-sensitive</strong>.</p>
<p>I know. I know.</p>
<p>Right now, I give you the freedom to close the article and say that CCL is unusable. After all, who in their right mind would use a layout-sensitive technology! Nonsense!!</p>
<hr/>
<p>If you stayed, good. You‚Äôre my reader, and I‚Äôm going to cherish you by explaining the motivation and some implementation details.</p>
<p>Sensitivity to indentation can play some unexpected tricks with you. But having delimiters like <code>{</code> and <code>}</code> to denote the start and end of the section imposes extra challenges for the configuration language. Specifically, escaping.</p>
<p>Every time you add an special character in a config or data language, you have to deal with escaping. But escaping doesn‚Äôt play well with the ‚ÄúThe Most Elegant Configuration Language‚Äù brand.</p>
<p>Whitespaces are invisible, people don‚Äôt rely on the specific number of whitespaces in the front, and adding more whitespaces doesn‚Äôt increase visual noise. They‚Äôre the perfect delimiters and escaping characters, like silent ninjas.</p>
<p>To handle nested values easily, the CCL parser implementation remembers the number of spaces <code>N</code> in front of the first key and follows two simple rules:</p>
<ol type="1">
<li>Lines with <code>‚©Ω N</code> leading spaces start new key-value entry.</li>
<li>Lines with <code>&gt; N</code> leading spaces continue the previous value.</li>
</ol>
</details>
<h3 id="algebraic-data-types">Algebraic Data Types</h3>
<p>The concept of Algebraic Data Types (ADTs) is essential to Functional Programming. Unfortunately, most configuration and serialisation formats don‚Äôt support ADTs nicely.</p>
<p>For CCL, it‚Äôs peanuts.</p>
<p>Consider the following ADT that describes a date range that can be either empty, single-dated or a range between two dates.</p>
<div id="cb24"><pre><code><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span>type</span> date = {</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>  year: <span>int</span>;</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>  month: <span>int</span>;</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>  day: <span>int</span>;</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>}</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a><span>type</span> date_range =</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>  | Empty</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a>  | Single <span>of</span> date</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a>  | Range <span>of</span> date * date</span></code></pre></div>
<p>A list of different values of this type will look like this:</p>
<div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span>let</span> date_range_example =</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>  [</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>    Empty;</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>    Single { year = <span>2025</span>; month = <span>6</span>; day = <span>25</span> };</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>    Range ({ year = <span>2025</span>; month = <span>1</span>; day = <span>1</span> },</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>           { year = <span>2025</span>; month = <span>12</span>; day = <span>31</span> });</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>You can encode (and decode!) the same list in CCL without problems, using constructor names as keys and values as payloads.</p>
<div id="cb26"><pre><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>empty =</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>single = <span>2025-06-25</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>range =</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>  <span>0</span> = <span>2025-01-01</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>  <span>1</span> = <span>2025-12-31</span></span></code></pre></div>
<p>If you have named constructors instead of positional, you can use nested named keys!</p>
<h2 id="category-theory-enters-the-chat">Category Theory Enters The Chat</h2>
<p>You thought I finished after describing all CCL features.</p>
<p>In fact, I haven‚Äôt even started.</p>
<h3 id="composition">Composition</h3>
<p>When writing software that works with configuration, it‚Äôs common to follow this pattern:</p>
<ol type="1">
<li>Have a default configuration.</li>
<li>Have a system-specific configuration for all users on the system.</li>
<li>Have a global user-specific configuration.</li>
<li>Have a project-specific local configuration.</li>
<li>Have a temporary configuration to override values during local development or experimentation.</li>
</ol>
<p>For example, you use a linter and you want to have the same consistent experience for all your hobby projects on your laptop. But occasionally, different projects have different needs. So it‚Äôs desirable to have project-specific overrides.</p>
<p>In other words, you have multiple layers of configurations, and you want to combine them. What you actually want is to <strong>compose</strong> them.</p>
<p>Turns out, with CCL this is trivial.</p>
<p>If you have one config like this one:</p>
<div id="cb27"><pre><code><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>no-trailing-whitespaces = <span>true</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>insert-final-newline = <span>true</span></span></code></pre></div>
<p>And another config like this:</p>

<p>Concatenating them together produces a valid config trivially:</p>
<div id="cb29"><pre><code><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>no-trailing-whitespaces = <span>true</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>insert-final-newline = <span>true</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>color-theme = dark</span></code></pre></div>
<p>So with this simple approach, you can trivially combine configs and expect a valid config in the end. There‚Äôs no special magic.</p>
<h3 id="associativity">Associativity</h3>
<p>A <strong>category</strong> in Category Theory comprises <em>objects</em> (you can choose them: numbers, strings, sets, types, other categories, etc.) and <em>morphisms</em> (arrows between objects). You can compose morphisms, and this composition is <strong>associative</strong>.</p>
<p>Turns out, composing CCL configs in the above way is an associative operation. Let‚Äôs call this operation <code>smoosh</code>.</p>
<p>Associativity means that combining three configs this way:</p>
<div id="cb30"><pre><code><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>smoosh (smoosh ccl1 ccl2) ccl3</span></code></pre></div>
<p>Is the same as:</p>
<div id="cb31"><pre><code><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>smoosh ccl1 (smoosh ccl2 ccl3)</span></code></pre></div>
<p>There‚Äôs an immediate practical application of this property: if you have three configs (e.g.¬†default, user-specific and project-specific), it doesn‚Äôt matter which two configs you append first, the result will be the same. Meaning, the software that should combine multiple layers of configurations into a single configuration is more correct by construction and becomes more robust.</p>
<h3 id="semigroup">Semigroup</h3>
<p>Turns out, our CCL configuration with the operation of combining two configs forms an important mathematical abstraction ‚Äî <strong>semigroup</strong>.</p>
<blockquote>
<p>I explain this abstraction in detail in my <em>Pragmatic Category Theory</em> series, <a href="https://chshersh.com/blog/2024-07-30-pragmatic-category-theory-part-01.html">Part 1: Semigroup</a> specifically. I spend time exploring why associativity matters in <a href="https://chshersh.com/blog/2024-12-20-pragmatic-category-theory-part-03.html">Part 3: Associativity</a>.</p>
</blockquote>
<p>In OCaml, we can describe a general Semigroup interface with the following code:</p>
<div id="cb32"><pre><code><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span>module</span> <span>type</span> SEMIGROUP = <span>sig</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>  <span>type</span> t</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>  <span>val</span> smoosh : t -&gt; t -&gt; t</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a><span>end</span></span></code></pre></div>
<p>We have a type <code>t</code> and we <code>smoosh</code> two values together (and this <code>smoosh</code> operation must be associative to form a valid Semigroup).</p>
<p>Just by leveraging this abstraction from math, we‚Äôve got an immediate practical application of composing multiple configuration worry-free.</p>
<p>But why stop here?</p>
<h3 id="monoid">Monoid</h3>
<p>I hate it when I run a piece of software and it complains about not having a configuration.</p>
<p>Every software MUST WORK WITHOUT A CONFIG!!</p>
<p>So, <strong>empty config or no config file at all must be a valid configuration</strong>.</p>
<p>Turns out, if the configuration type is Semigroup, and we have an empty configuration called <code>empty</code> that satisfies the following properties (called <strong>identity</strong> properties):</p>
<div id="cb33"><pre><code><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>smoosh ccl empty = ccl</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>smoosh empty ccl = ccl</span></code></pre></div>
<p>then the configuration is another abstraction ‚Äî <strong>monoid</strong>.</p>
<blockquote>
<p>üìú It‚Äôs easy to show these properties hold for CCL.</p>
</blockquote>
<p>In OCaml, we would represent this abstraction in the following way:</p>
<div id="cb34"><pre><code><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span>module</span> <span>type</span> MONOID = <span>sig</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>  <span>type</span> t</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>  <span>val</span> empty : t</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>  <span>val</span> smoosh : t -&gt; t -&gt; t</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a><span>end</span></span></code></pre></div>
<hr/>
<p>Here we went from a practical example to rediscovering a math abstraction. But when you‚Äôre familiar with such abstractions, the usual thinking route is the following:</p>
<ol type="1">
<li>I want to combine my configs. Is there a nice math abstraction for this? Aha, Semigroup!</li>
<li>Okay, can my Semigroup be a Monoid too? What is my <code>empty</code> value?</li>
<li>Turns out, there‚Äôs an immediate practical application: an empty configuration should be a valid config too, duh!</li>
</ol>
<h3 id="monoid-homomorphism">Monoid Homomorphism</h3>
<p>We have actually two ways to represent a valid CCL config.</p>
<p><strong>1: A file with text</strong></p>
<div id="cb35"><pre><code><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>subtitles = enabled</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>playback-speed = <span>1.25</span></span></code></pre></div>
<p>We know that our configs form Semigroup with the file concatenation operation being associative (let‚Äôs call this operation <code>cat</code>) and the empty file being the identity element and thus forming a Monoid.</p>
<p><strong>2: A list of key-value pairs</strong></p>
<div id="cb36"><pre><code><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span>let</span> settings_example =</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>  [</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>    { key = <span>&#34;subtitles&#34;</span>; value = <span>&#34;enabled&#34;</span> };</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>    { key = <span>&#34;playback-speed&#34;</span>; value = <span>&#34;1.25&#34;</span> };</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>The list append operator in OCaml is <code>@</code>. Turns out, appending lists is an associative operation, and therefore lists with <code>@</code> form a Semigroup.</p>
<p>Moreover, empty list <code>[]</code> satisfies the <em>identity</em> properties in relation to <code>@</code>. Therefore lists with <code>@</code> also form a Monoid.</p>
<p>We also have a function to convert the contents of the file into a list of key-value pairs:</p>
<div id="cb37"><pre><code><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span>val</span> parse : <span>string</span> -&gt; key_val <span>list</span></span></code></pre></div>
<p>This function satisfies a peculiar property:</p>
<div id="cb38"><pre><code><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>parse (cat ccl1 ccl2) ‚â° parse ccl1 @ parse ccl2</span></code></pre></div>
<p>In English, concatenating two files and then parsing the result is the same as parsing two files separately and then appending the resulting lists of key-value pairs.</p>
<p>We have two Monoids: (1) CCL (aka text files) and (2) lists of key-value pairs. And we have a function <code>parse</code> with the above property. In this case, <code>parse</code> is a <strong>monoid homomorphism</strong>.</p>
<p>A <em>monoid homomorphism</em> is a function that maps one monoid to another while preserving monoidal properties (such as associativity and identity).</p>
<p>Is there an immediate practical application of this? Of course there‚Äôs! Otherwise, I wouldn‚Äôt mention it.</p>
<p>First of all, for <code>parse</code> to truly be a <em>monoid homomorphism</em>, it needs to preserve the emptiness property. In other words:</p>

<p>Which is totally reasonable, we should parse an empty file to a valid config. Moreover, this config must be an empty list.</p>
<p>But second, and most important, if <code>parse</code> is a true <em>monoid homomorphism</em> then it doesn‚Äôt matter if we concat files first and then parse or if we first parse and then concat. The result will be the same!</p>
<p>It means, we can actually improve the performance of parsing multiple files. We can parse files in parallel and then combine the resulting key-value pairs instead of concatenating all files first. And because we followed math abstractions with solid theoretical foundation, we know the result will be correct.</p>
<p>This property can become handy when you start representing your cloud configuration a-la K8S with hundreds of config files, and suddenly the pod start time starts to matter.</p>
<details>
<summary>Pedantic Alert #1: Error-handling</summary>
<p>To simplify the explanation, I made an assumption that the function <code>parse</code> doesn‚Äôt fail. In practice, it‚Äôs absolutely possible for parsing to fail on invalid inputs. Does it mean we can‚Äôt benefit from monoid homomorphisms here? Of course not!</p>
<p>The trick here involves two steps:</p>
<ol type="1">
<li>Represent errors as values</li>
<li>Use a return type that returns errors while still being a monoid.</li>
</ol>
<p>To do this, let‚Äôs introduce type like this one:</p>
<div id="cb40"><pre><code><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a><span>type</span> (&#39;a, &#39;e) validation =</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a>  | <span>Failure</span> <span>of</span> &#39;e <span>list</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a>  | Success <span>of</span> &#39;a <span>list</span></span></code></pre></div>
<p>In English, this polymorphic type is either a list of errors or a list of successes.</p>
<p>This type is a Monoid with the following implementation:</p>
<div id="cb41"><pre><code><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a><span>let</span> empty = Success []</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a><span>let</span> append val1 val2 =</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a>  <span>match</span> val1, val2 <span>with</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true"></a>  | <span>Failure</span> errors1, <span>Failure</span> errors2 -&gt; <span>Failure</span> (errors1 @ errors2)</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true"></a>  | <span>Failure</span> errors, Success _ -&gt; <span>Failure</span> errors</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true"></a>  | Success _, <span>Failure</span> errors -&gt; <span>Failure</span> errors</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true"></a>  | Success a, Success b -&gt; Success (a @ b)</span></code></pre></div>
<p>In English, when we combine two validations:</p>
<ol type="1">
<li>If both are failures, we just combine all errors.</li>
<li>If at least one is a failure, we keep errors from it and discard success.</li>
<li>If both are successes, we combine all successes.</li>
</ol>
<p>And our <code>parse</code> will change it‚Äôs type to:</p>
<div id="cb42"><pre><code><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a><span>val</span> parse : <span>string</span> -&gt; (key_val, parse_error) validation</span></code></pre></div>
<p>Because <code>validation</code> is a monoid, our <code>parse</code> remains a <em>monoid homomorphism</em> with the semantics of either getting all errors from all sources or appending all successful results if no errors happened.</p>
</details>
<details>
<summary>Pedantic Alert #2: File concatenation</summary>
<p>So, again, I simplified things a little. Because CCL is indentation sensitive, appending two files like this:</p>
<p><strong>example1.ccl</strong></p>

<p><strong>example2.ccl</strong></p>

<p>and then parsing them is not the same as parsing first and appending later because after appending files we‚Äôll get only one key.</p>
<p>An annoyance but easily fixable: we can‚Äôt simply append files, we need to remove leading spaces. An implementation in OCaml:</p>
<div id="cb45"><pre><code><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a><span>let</span> cat ccl1 ccl2 = ccl1 ^ <span>&#34;</span><span>\n</span><span>&#34;</span> ^ <span>String</span>.trim ccl2</span></code></pre></div>
<p>Notice how we benefited from math abstractions. But following them precisely, we discovered an annoying bug and fixed it early.</p>
</details>
<details>
<summary>Bonus: Isomorphism</summary>
<p>Btw, the pretty-printing function like this:</p>
<div id="cb46"><pre><code><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a><span>val</span> pretty : key_val <span>list</span> -&gt; <span>string</span></span></code></pre></div>
<p>Is a <em>monoid homomorphism</em> too. Together with <code>parse</code> they form <strong>monoid isomorphisms</strong>: you can convert both ways while preserving the structure.</p>
<p>This property is incredibly useful for testing when you want to parse, then pretty-print back and make sure you don‚Äôt lose any information in the process.</p>
</details>
<h3 id="fixed-point">Fixed Point</h3>
<p>So far, I haven‚Äôt explored one important topic: <strong>key overrides</strong>.</p>
<p>In configurations, it‚Äôs common to have the same key mapped to different values. Especially, if we start combining configs that have overlapping properties.</p>
<p>Let‚Äôs say we have two configs.</p>
<p><strong>default.ccl</strong></p>
<div id="cb47"><pre><code><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a>trailing-whitespaces = yes</span></code></pre></div>
<p><strong>project.ccl</strong></p>
<div id="cb48"><pre><code><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a>trailing-whitespaces = no</span></code></pre></div>
<p>What should be the value of the <code>trailing-whitespaces</code> property once we combine them?</p>
<div id="cb49"><pre><code><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a>trailing-whitespaces = yes</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a>trailing-whitespaces = no</span></code></pre></div>
<p>The quick answer: DIY. When you parse the final config (or parse first and then append lists, remember <em>monoid homomorphisms</em>), you‚Äôll get the following list of key-value pairs:</p>
<div id="cb50"><pre><code><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a><span>let</span> overrides_example =</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a>  [</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a>    { key = <span>&#34;trailing-whitespaces&#34;</span>; value = <span>&#34;yes&#34;</span> };</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a>    { key = <span>&#34;trailing-whitespaces&#34;</span>; value = <span>&#34;no&#34;</span> };</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>Overrides are not a problem because you keep both values. And you can decide what to do with them: keep only the first, keep only the last or use some smart logic to combine both of them. You‚Äôre the boss.</p>
<p>Unfortunately, this business becomes nasty once you start having nested records. Manually parsing and resolving all the nested key overrides is annoying.</p>
<p>CCL solved this too.</p>
<p>The key idea here is to treat values as.. keys (pun intended).</p>
<p>Remember how in the ‚ÄúNested records‚Äù section I mentioned that you can parse values using the same CCL config parser? If you do it recursively until the end, you‚Äôll parse all values.</p>
<p>What? You ask when do you stop parsing? That‚Äôs the neat part, you don‚Äôt.</p>
<p>Or, more precisely, you stop when you can‚Äôt parse any more. By applying parsing recursively until parsing doesn‚Äôt change anything, you reach a so-called <strong>fixed point</strong>.</p>
<p>Because we now have this nested structure, we no longer treat CCL as a list of key-value pairs. What is it though?</p>
<p>A configuration in CCL is actually a <em>fixed point</em> for a dictionary from strings to.. itself!</p>
<p>In OCaml, it‚Äôs pure elegancy:</p>
<div id="cb51"><pre><code><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a><span>type</span> t = Fix <span>of</span> t <span>Map</span>.Make(<span>String</span>).t</span></code></pre></div>
<p>It‚Äôs a map that maps strings (i.e.¬†keys) to itself. The only way to stop the recursion is to bind a key to an empty map. And therefore, final level is values mapped to empty maps.</p>
<p>We can have a pure function to turn a list of key-value pairs on this representation:</p>
<div id="cb52"><pre><code><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a><span>val</span> fix : key_val <span>list</span> -&gt; t</span></code></pre></div>
<p>When we had lists, we could just append lists (a pretty understandable operation). How can we append such fixed points? That‚Äôs pretty easy too.</p>
<p>The operation to merge two fixed points is straightforward, using just the OCaml standard library:</p>
<div id="cb53"><pre><code><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a><span>let</span> <span>rec</span> merge (Fix map1) (Fix map2) =</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true"></a>  Fix</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true"></a>    (<span>Map</span>.Make(<span>String</span>).merge</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true"></a>       (<span>fun</span> _key t1 t2 -&gt;</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true"></a>         <span>match</span> (t1, t2) <span>with</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true"></a>         | <span>None</span>, t2 -&gt; t2</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true"></a>         | t1, <span>None</span> -&gt; t1</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true"></a>         | <span>Some</span> t1, <span>Some</span> t2 -&gt; <span>Some</span> (merge t1 t2))</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true"></a>       map1 map2)</span></code></pre></div>
<p>It looks like this function does nothing (it just recursively calls itself). Yet, it does everything.</p>
<p>Now, things are getting juicy. When you have a config like this one:</p>
<div id="cb54"><pre><code><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a>ports = <span>8080</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true"></a>ports = <span>8081</span></span></code></pre></div>
<p>In CCL, it‚Äôs actually just syntax sugar for:</p>
<div id="cb55"><pre><code><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a>ports =</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true"></a>  <span>8080</span> =</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true"></a>ports =</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true"></a>  <span>8081</span> =</span></code></pre></div>
<p>You got it correctly. It‚Äôs not two keys of the same name mapped to two different string values. It‚Äôs two keys mapped to two different nested singleton objects where keys are values.</p>
<p>Parsing and applying <code>fix</code> merges the keys, and we get the following:</p>

<p>So now, we easily combine multiple similar keys and join their values on all levels of nestedness with <em>checks notes</em> with just 10 lines of OCaml.</p>
<hr/>
<p>Wanna hear the cool part? Our <strong>fixed point</strong> with <code>merge</code> is a monoid too. Meaning, that <code>fix</code> is actually a monoid homomorphism from a list of key-value pairs to a map. And the composition of <code>parse</code> and <code>fix</code> is a composition of monoid homomorphisms, meaning it‚Äôs automatically also a monoid homomorphism.</p>
<p>And we get all the discussed benefits for free again.</p>
<p>That‚Äôs why we needed only 10 lines of OCaml. We‚Äôre standing on the shoulders of giants who have been creating math for thousands of years.</p>
<h2 id="whats-next">What‚Äôs next?</h2>
<p>I have a CCL PoC <a href="https://github.com/chshersh/ccl">built in OCaml on GitHub</a>.</p>
<p>It works. It passes the tests. It‚Äôs not production-ready.</p>
<p>Meaning, that documentation might lack important details, performance wasn‚Äôt optimised, code is ugly at some places, the quality of error messages is poor, utility functions are lacking, and breaking changes are expected. You know, just like a typical SaaS product, except CCL is free and was done in 10 evenings.</p>
<p>However, I‚Äôve implemented an exhaustive test suite with dozens of unit tests covering diverse edge-cases as well as property-based tests to verify algebraic laws.</p>
<figure>
<img src="https://chshersh.com/images/ccl/tests.png" alt=""/><figcaption>Example of passing tests (they pass, it‚Äôs true)</figcaption>
</figure>
<p>If you try it and discover bugs, please report! I‚Äôll try to fix them.</p>
<p>Currently, I‚Äôm focusing on building <a href="https://github.com/chshersh/github-tui">GitHub TUI</a> in OCaml. If at some point the need for a config arises, I return to <code>ccl</code>.</p>
<p>For example, to make CCL production-ready, one essential API piece is missing: decoding CCL values into actual programming values.</p>
<p>I envision an API in OCaml like this one:</p>
<div id="cb57"><pre><code><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a><span>type</span> user = {</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a>  login: <span>string</span>;</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a>  name: <span>string</span>;</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a>  last_active: <span>int</span>;  <span>(* timestamp in UNIX epoch *)</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true"></a>}</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true"></a></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true"></a><span>let</span> codec =</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true"></a>  Ccl.(</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true"></a>    <span>let</span>+ login = Codec.<span>string</span> <span>&#34;login&#34;</span> (<span>fun</span> {login; _} -&gt; login)</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true"></a>    <span>and</span>+ name = Codec.<span>string</span> <span>&#34;name&#34;</span> (<span>fun</span> {name; _} -&gt; name)</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true"></a>    <span>and</span>+ last_active =</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true"></a>      Codec.<span>int</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true"></a>        <span>&#34;last_active&#34;</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true"></a>        (<span>fun</span> {last_active; _} -&gt; last_active)</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true"></a>    <span>in</span></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true"></a>    { login; name; last_active }</span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true"></a>  )</span></code></pre></div>
<p>I used to work on something similar in the past, using Category Theory abstractions such as Category, Isomorphisms, Profunctors and Applicative Functors. But I‚Äôll save this for another article.</p>
<p>The implementation of CCL is so simple, you can even try implementing it in your favourite language, and this could be a nice hobby project!</p>
<hr/>
<p>My goal is not to make everyone use this new language. What I want is to inspire you.</p>
<p>I hope you can see how much you can achieve with so little.</p>
<p>I hope you‚Äôll try to pursue simplicity as well.</p>
<p>I hope we can make the software better together.</p>

<hr/>
<blockquote>
<p>If you liked this blog post, consider supporting my work on GitHub Sponsors, or following me on the Internet:</p>
<ul>
<li><a target="_blank" href="https://github.com/sponsors/chshersh">GitHub Sponsors: @chshersh</a></li>
<li><a target="_blank" href="https://youtube.com/c/chshersh">YouTube: @chshersh</a></li>
<li><a target="_blank" href="https://x.com/ChShersh">ùïè: @chshersh</a></li>
<li><a target="_blank" href="https://bsky.app/profile/chshersh.com">BlueSky: @chshersh.com</a></li>
<li><a target="_blank" href="https://functional.cafe/@chshersh">Mastodon: functional.cafe@chshersh</a></li>
<li><a target="_blank" href="https://www.twitch.tv/chshersh">Twitch: @chshersh </a></li>
</ul>
</blockquote>
    </div></div>
  </body>
</html>
