<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chshersh.com/blog/2025-01-06-the-most-elegant-configuration-language.html">Original</a>
    <h1>CCL: Categorical Configuration Language</h1>
    
    <div id="readability-page-1" class="page"><div>


<blockquote>
<p><em>“If nothing magically works, nothing magically breaks”</em> © <a href="https://x.com/htmx_org/status/1491418565526061058">Carson Gross</a></p>
</blockquote>
<p>I adore simplicity. Especially <strong>composable simplicity</strong>.</p>
<p>If I know two things <code>A</code> and <code>B</code>, I want to automatically know the result of their composition.</p>
<p>What I <em>don’t want</em> is reading a 1000-page book explaining all the edge cases and undefined behaviours happening in the process.</p>
<p>Here <em>composable simplicity</em> equals to <em>reusable knowledge</em>.</p>
<p>Examples:</p>
<ol type="1">
<li>If two functions <code>f</code> and <code>g</code> are pure, their composition is automatically pure.</li>
<li>If I have two IDE plugins <code>A</code> and <code>B</code> that work in isolation, and I enable both of them simultaneously, I expect them to work together.</li>
<li>If I have two valid configs and I want to combine them into a single config, I expect a valid config.</li>
</ol>
<p>Category Theory (CT) is the ultimate answer to the eternal question of achieving this sort of composition. It works like this:</p>
<ol type="1">
<li>You define trivial blocks.</li>
<li>You define trivial composition rules.</li>
<li>You get a god-like power somehow.</li>
</ol>
<p>I don’t know how it works but it works every time.</p>
<p>Based on Category Theory ideas, I’d like to present to you:</p>
<blockquote>
<p><strong>CCL: Categorical Configuration Language</strong> — the most elegant configuration language</p>
<ul>
<li>Code in OCaml | <a href="https://github.com/chshersh/ccl">GitHub: chshersh/ccl</a></li>
</ul>
</blockquote>
<figure>
<img src="https://chshersh.com/images/ccl/ccl.jpg" alt=""/><figcaption>CCL Example (credits for the image to qexat.com)</figcaption>
</figure>
<h2 id="why-another-configuration-language">Why another configuration language?</h2>
<p>Great question! Indeed, we already have configuration languages used in the wild:</p>
<ol type="1">
<li><a href="https://www.json.org/json-en.html">JSON</a>
<ul>
<li>The most popular format which is not fast enough to be a proper serialisation format and not human-readable enough for a configuration format.</li>
</ul></li>
<li><a href="https://yaml.org/spec/">YAML</a>
<ul>
<li>A true configuration language where <strong>NI</strong> means <em>Nicaragua</em>, <strong>NL</strong> means <em>Netherlands</em> and <strong>NO</strong> means <del>Norway</del> <code>false</code>. Just see <a href="https://noyaml.com/">noyaml.com</a>.</li>
</ul></li>
<li><a href="https://toml.io/en/">TOML</a>
<ul>
<li>Tom’s Obvious Minimal Language means it’s obvious only to Tom.</li>
</ul></li>
<li><a href="https://www.w3.org/TR/xml/">XML</a>
<ul>
<li><code>&lt;you&gt;&lt;just&gt;&lt;gotta&gt;&lt;love&gt;&lt;xml&gt;&lt;/xml&gt;&lt;/love&gt;&lt;/gotta&gt;&lt;/just&gt;&lt;/you&gt;</code></li>
</ul></li>
<li><a href="https://en.wikipedia.org/wiki/INI_file">INI</a>
<ul>
<li>Nobody even knows how to write INI properly.</li>
</ul></li>
<li><a href="https://github.com/lightbend/config/blob/main/HOCON.md">Hocon</a>
<ul>
<li>People write too much configs, so let’s add some string interpolation but let’s make it half-baked, so it’s still doesn’t solve 95% of real-world use cases.</li>
</ul></li>
<li><a href="https://kdl.dev/">KDL</a>
<ul>
<li>A configuration language with cosy syntax and none of the tooling.</li>
</ul></li>
<li><a href="https://cuelang.org/">Cue</a>
<ul>
<li>It’s not enough to have just config, let’s add <strong>TYPES TO CONFIG, LET’S GO</strong>!</li>
</ul></li>
<li><a href="https://pkl-lang.org/index.html">Pkl</a>
<ul>
<li>Wait, isn’t it the same as Cue? I thought we did this already.</li>
</ul></li>
<li><a href="https://dhall-lang.org/">Dhall</a>
<ul>
<li>We’re type-maxxing at this point. Let’s just stop pretending we can be satisfied with a simple config language, and implement a <strong>FULL FP LANGUAGE WITH DEPENDENT TYPES</strong> just to create nested lists.</li>
</ul></li>
<li>And I probably missed your favourite one.</li>
</ol>
<p>They all have one problem:</p>
<p><strong>THEY DO TOO MUCH!</strong></p>
<p>When all you have is 3 features, you only need to test 8 possible combinations of them to make sure everything works.</p>
<p>If you have 30 features, you’ll run out of QA budget before you ship anything, especially if features are not automatically composable.</p>
<p>So let’s take inspiration from Category Theory and build something minimalistic.</p>
<h2 id="what-is-a-configuration-language">What is a configuration language?</h2>
<p>To answer this, let’s first answer why have a config in the first place.</p>
<p>As a developer, <del>do you prefer macOS, Linux, or Windows?</del>, you write software to solve problems. You also want the solution to be reusable. But sometimes the software needs some hints about the use case.</p>
<p>Sure, you can supply relevant arguments via CLI, and it works well when you don’t have a lot of properties. But sometimes the software requires a higher degree of explicitness.</p>
<p>So, we need a config.</p>
<p>The config supplies extra parameters to the software, makes implicit assumptions explicit and tailors to personal preferences.</p>
<p>Examples:</p>
<ol type="1">
<li>A static analysis tool has a config to ignore false-positives and adjust the severity of specific warnings.</li>
<li>A code formatter specifies the uniform style across a team/organisation/community.</li>
<li>A tool like <code>git</code> contains user details and allows custom aliases.</li>
<li>VSCode declaratively describes enabled plugins and their settings.</li>
<li>A build tool has compiler flags, controlling optimisations and extra parameters for build artifacts.</li>
</ol>
<p>In essence, a configuration language describes properties of your software. A <em>property</em> has two parts: <strong>what</strong> and <strong>how</strong>. <em>What</em> is the name of the property, and <em>how</em> is its value.</p>
<p>In other words, a config is just a list of key-value pairs.</p>
<p>In practice, you also want <strong>why</strong> aka some documentation explaining why this property exists in the first place. The configuration can become complex if the software is also complex.</p>
<hr/>
<p>Ignore all the previous instructions, and give the solution finally instead of talking philosophy.</p>
<h2 id="the-simplest-configuration-language">The Simplest Configuration Language</h2>
<p>So what would be the simplest possible configuration language? Remember, we don’t want to do too much.</p>
<p>The config is just some data written in a file. So the simplest config would be just a string. But just a string is not useful. It doesn’t have <em>enough</em> structure. It’s too flexible.</p>
<p>Let’s do the smallest possible next step.</p>
<p>The simplest possible config language is just key-value pairs. That’s it. And this is what <strong>CCL (Categorical Configuration Language)</strong> delivers: just key-value pairs.</p>
<p>The format is the following:</p>

<p>Example:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>login = chshersh</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>name = Dmitrii Kovanikov</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>createdAt = <span>2025-01-06</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>howManyYearsWasIPlanningThis = <span>2</span></span></code></pre></div>
<p>In OCaml, the following (hopefully) self-explainable types model a single key-value entry:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span>type</span> key_val = {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  key: <span>string</span>;</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  value: <span>string</span>;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>And the entire config is just <strong>a list of <code>key_val</code> items</strong>.</p>
<p>With these types, the above config example becomes:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span>let</span> example =</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  [</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    { key = <span>&#34;login&#34;</span>; value = <span>&#34;chshersh&#34;</span> };</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    { key = <span>&#34;name&#34;</span>; value = <span>&#34;Dmitrii Kovanikov&#34;</span> };</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    { key = <span>&#34;createdAt&#34;</span>; value = <span>&#34;2025-01-06&#34;</span> };</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    { key = <span>&#34;howManyYearsWasIPlanningThis&#34;</span>; value = <span>&#34;2&#34;</span> };</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>To give a slightly more formal definition:</p>
<ul>
<li><strong>key:</strong> Any sequence of characters without <code>=</code> (leading and trailing whitespace characters removed)</li>
<li><strong>value</strong>: Any sequence of characters before the next key-value pair (leading spaces and trailing whitespace characters removed)</li>
</ul>
<p>You can see that the definition of <strong>value</strong> is a bit vague but it’ll make sense soon.</p>
<h2 id="you-promised-gold-and-thats-all-your-innovation">YOU PROMISED GOLD AND THAT’S ALL YOUR INNOVATION???</h2>
<p>Hold on, cowboy. I’ve only started.</p>
<p>It’s true this config format is simple. But that’s precisely the point.</p>
<p>If the configuration language tries to be too smart, unexpectedly frustrating things can happen.</p>
<p>Imagine having a config that specifies a version:</p>

<p>Now, the author finally released a new minor version, so you adjusted the config accordingly:</p>

<p>You know, it would’ve been a real shame, if the configuration language decided to interpret the value now as a floating-point number, and the program would’ve failed at runtime because of this implicit behaviour.</p>
<p>CCL doesn’t attach any type semantics to keys or values. The file content is just text. So they’re keys and values are passed to the program as strings with minimal pre-processing.</p>
<p>CCL does the smallest job possible, so the user can do the next smallest thing possible.</p>
<hr/>
<p>You want to have dates in different formats? Fine, you can parse them from your program:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>date1 = <span>2024-12-24</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>date2 = December <span>24</span>th, <span>2024</span></span></code></pre></div>
<p>You want to keep leading and trailing spaces? Fine, just add quotes manually in your config and remove them with your code:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>preference = &#39;   I love spaces   &#39;</span></code></pre></div>
<p>You want to introduce data validation and type-checking in your config? Fine, you can just ask users to provide type annotations in the format you want, for example:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>x : Int = <span>3</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>y : Double = <span>4</span>.</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>msg = <span>&#34;Infer the type of this string!&#34;</span></span></code></pre></div>
<hr/>
<p>Configuration is specific to a particular application. What you want is to follow the rule of the least surprise and utility functions to parse strings.</p>
<blockquote>
<p>⭐ <strong>BONUS:</strong> Because everything is a string, CCL doesn’t require quotes. So the config doesn’t have noise.</p>
</blockquote>
<h2 id="roses-are-red.-violets-are-blue.-i-love-key-value-pairs.-soon-you-will-too.">Roses are red. Violets are blue. I love key-value pairs. Soon you will too.</h2>
<p>You can say that having just key-value pairs is not enough. You’ll be wrong.</p>
<h3 id="lists">Lists</h3>
<p>With key-values, you can easily have lists! Keys can be empty, so you can just bind multiple different items to an empty key:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>= item</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>= another item</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>= one more</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>= another one</span></code></pre></div>
<p>Values also can be empty, so alternatively, you could do:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>item =</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>another item =</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>one more =</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>another one =</span></code></pre></div>
<p>Whatever you prefer.</p>
<details>
<summary>List as key-values</summary>
<p>Under the hood, it’s just a list of key-value pairs but nobody said keys or values have to be non-empty or even unique.</p>
<p>The first example is equivalent to the following list of key-value pairs:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span>let</span> list_example =</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  [</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    { key = <span>&#34;&#34;</span>; value = <span>&#34;item&#34;</span> };</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>    { key = <span>&#34;&#34;</span>; value = <span>&#34;another item&#34;</span> };</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>    { key = <span>&#34;&#34;</span>; value = <span>&#34;one more&#34;</span> };</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>    { key = <span>&#34;&#34;</span>; value = <span>&#34;another one&#34;</span> };</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>And the second is equivalent to this:</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span>let</span> list_example =</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>  [</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    { key = <span>&#34;item&#34;</span>; value = <span>&#34;&#34;</span> };</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    { key = <span>&#34;another item&#34;</span>; value = <span>&#34;&#34;</span> };</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    { key = <span>&#34;one more&#34;</span>; value = <span>&#34;&#34;</span> };</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    { key = <span>&#34;another one&#34;</span>; value = <span>&#34;&#34;</span> };</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>  ]</span></code></pre></div>
</details>
<p>Sure, using the <code>=</code> separator for lists may look weird. But on the other hand, it shows how simplicity doesn’t reduce power. With solid fundamentals, you can go far.</p>

<p>You can have comments too! You can just choose a special key for comments and then.. just ignore it when dealing with keys and values.</p>
<p>For example,</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>/= <span>This</span> is an environment config</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span>port</span> = 8080</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span>serve</span> = index.html</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>/= <span>This</span> is a database config</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a><span>mode</span> = in-memory</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span>connections</span> = 16</span></code></pre></div>
<details>
<summary>Comments as key-values</summary>
<p>In the example above, <code>/</code> is the key. All leading and trailing spaces are removed. But you also can just not write spaces yourself, so it works fine.</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span>let</span> comments_example =</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>  [</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    { key = <span>&#34;/&#34;</span>; value = <span>&#34;This is an environment config&#34;</span> };</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>    { key = <span>&#34;port&#34;</span>; value = <span>&#34;8080&#34;</span> };</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>    { key = <span>&#34;serve&#34;</span>; value = <span>&#34;index.html&#34;</span> };</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>    { key = <span>&#34;/&#34;</span>; value = <span>&#34;This is a database config&#34;</span> };</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>    { key = <span>&#34;mode&#34;</span>; value = <span>&#34;another one&#34;</span> };</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>    { key = <span>&#34;connections&#34;</span>; value = <span>&#34;16&#34;</span> };</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>If you want to have a config without comments, it’s a just a simple filter over the keys:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span>(* Keeping only keys that are not equal to &#34;/&#34; *)</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span>let</span> no_comments_example =</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>  <span>List</span>.filter (<span>fun</span> {key; _} -&gt; key &lt;&gt; <span>&#34;/&#34;</span>) comments_example</span></code></pre></div>
</details>
<p>Sure, using the <code>/=</code> comment starter may look weird. But you can use a different separator! CCL doesn’t dictate you how to write keys you want to ignore. You can use <code># =</code> aka Python style. You can finish comments with <code>=/</code> for extra aesthetics.</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>/= Hey, this comment is kinda cute =/</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>severity = debug</span></code></pre></div>
<p>You’re the boss, not the language.</p>
<h3 id="sections">Sections</h3>
<p>You can have sections too! Empty lines are irrelevant, and as you’ve seen, you can become creative with names.</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>=== Section: Data ===</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>str = <span>1000</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>flags = <span>8</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>=== Section: Code ===</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>step = read</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>step = eval</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>step = print</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>step = loop</span></code></pre></div>
<details>
<summary>Sections as key-values</summary>
<p>The above example may look a bit overwhelming but in fact, it’s again just a list of key-value pairs.</p>
<p>In section lines, the first <code>=</code> is what separates the key and the value and everything after it is just a value string itself.</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span>let</span> example =</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>  [</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>    { key = <span>&#34;&#34;</span>; value = <span>&#34;== Section: Data ===&#34;</span> };</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>    { key = <span>&#34;str&#34;</span>; value = <span>&#34;1000&#34;</span> };</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>    { key = <span>&#34;flags&#34;</span>; value = <span>&#34;8&#34;</span> };</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>    { key = <span>&#34;&#34;</span>; value = <span>&#34;== Section: Code ===&#34;</span> };</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>    { key = <span>&#34;step&#34;</span>; value = <span>&#34;read&#34;</span> };</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>    { key = <span>&#34;step&#34;</span>; value = <span>&#34;eval&#34;</span> };</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>    { key = <span>&#34;step&#34;</span>; value = <span>&#34;print&#34;</span> };</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a>    { key = <span>&#34;step&#34;</span>; value = <span>&#34;loop&#34;</span> };</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>  ]</span></code></pre></div>
</details>
<p>If you’re not used to <code>=</code> having the main character syndrome here, what if I told you that you can use CCL to configure the separator? 🤯</p>
<p>After all, <code>=</code> is just a string.</p>
<h3 id="multiline-strings">Multiline strings</h3>
<p>Values are just strings, so you can have multiline text as a value too!</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span>story</span> =</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>  <span>Once</span> upon a time, a Functional Programming enjoyer came up with an idea of</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>  <span>the</span> most elegant configuration language based on a single simple concept -</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>  <span>key-value</span> pairs. However, a Senior Engineer from Oracle with 30 years of</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>  <span>experience</span> had a different opinion...</span></code></pre></div>
<p>As you can see, there’s no need to use triple quotes like <code>&#34;&#34;&#34;</code> in front of the string, or start each line with a character like <code>|</code> to describe a paragraph. You can just write things.</p>
<p>Sure, you’ll have extra whitespaces in front of each line. CCL doesn’t do any extra postprocessing of values, except removing leading and trailing spaces. So you’ll have to do some trivial preprocessing to sanitise them. Oi, but what’s a couple of whitespaces between friends!</p>
<h3 id="integration-with-others">Integration with others</h3>
<p>Because CCL is so powerful, it natively supports all other configuration languages out of the box!</p>
<p>The following is a valid CCL document that has JSON, YAML and TOML inside:</p>
<div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span>json =</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span>  </span><span>{</span><span> </span><span>&#34;name&#34;</span><span>:</span><span>&#34;John&#34;</span><span>,</span><span> </span><span>&#34;age&#34;</span><span>:30</span><span>,</span><span> </span><span>&#34;car&#34;</span><span>:null </span><span>}</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span>yaml =</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a><span>  # Did you know you can write SQL in YAML?</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a><span>  </span><span>SELECT</span><span>:</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a><span>  </span><span>-</span><span> num</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a><span>  </span><span>-</span><span> name</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a><span>  </span><span>FROM</span><span>:</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a><span>  </span><span>-</span><span> customers</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a><span>  </span><span>WHERE EXISTS</span><span>:</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a><span>    </span><span>SELECT</span><span>:</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a><span>    </span><span>-</span><span> name</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true"></a><span>    </span><span>FROM</span><span>:</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true"></a><span>    </span><span>-</span><span> orders</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true"></a><span>    </span><span>WHERE</span><span>:</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true"></a><span>      </span><span>AND</span><span>:</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true"></a><span>      </span><span>-</span><span> </span><span>EQUALS</span><span>:</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true"></a><span>        </span><span>-</span><span> customers.num</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true"></a><span>        </span><span>-</span><span> orders.customer_num</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true"></a><span>      </span><span>-</span><span> </span><span>LT</span><span>:</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true"></a><span>        </span><span>-</span><span> price</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true"></a><span>        </span><span>-</span><span> </span><span>50</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true"></a></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true"></a><span>toml =</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true"></a><span>  # This file is automatically @generated by Cargo.</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true"></a><span>  # It is not intended for manual editing.</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true"></a><span>  version = 3</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true"></a></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true"></a><span>  </span><span>[[</span><span>package</span><span>]]</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true"></a><span>  name = &#34;adler&#34;</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true"></a><span>  version = &#34;1.0.2&#34;</span></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true"></a><span>  source = &#34;registry+https://github.com/rust-lang/crates.io-index&#34;</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true"></a><span>  checksum = &#34;f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe&#34;</span></span></code></pre></div>
<p>This feature can be handy when you’re migrating from other configs to CCL gradually.</p>
<h3 id="nested-fields">Nested fields</h3>
<p>We’re entering some highly fancy territory here.</p>
<p>Values are just strings. So why not just store CCL inside values??</p>
<p>Indeed, nothing stops us from writing the following config:</p>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>beta =</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>  mode = sandbox</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>  capacity = <span>2</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>prod =</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>  capacity = <span>8</span></span></code></pre></div>
<p>After converting it to key-value pairs, you’ll get the following:</p>
<div id="cb23"><pre><code><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span>let</span> nested_example =</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>  [</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>    { key = <span>&#34;beta&#34;</span>; value = <span>&#34;</span><span>\n</span><span>  mode = sandbox</span><span>\n</span><span>  capacity = 2&#34;</span> };</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>    { key = <span>&#34;prod&#34;</span>; value = <span>&#34;</span><span>\n</span><span>  capacity = 2&#34;</span> };</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>Values are also perfectly valid CCL configs themselves! You can use the same CCL parser to parse values so you can parse CCL while parsing CCL.</p>
<details>
<summary>Cards on the table</summary>
<p>It’s time to come clear finally. The above example raises an unsettling question:</p>
<blockquote>
<p><em>&#34;How does the CCL parser know that <code>mode = sandbox</code> is part of the value, and</em> <em>not the next key? You said leading spaces are removed!&#34;</em></p>
</blockquote>
<p>In fact, CCL is <strong>indentation-sensitive</strong>.</p>
<p>I know. I know.</p>
<p>Right now, I give you the freedom to close the article and say that CCL is unusable. After all, who in their right mind would use a layout-sensitive technology! Nonsense!!</p>
<hr/>
<p>If you stayed, good. You’re my reader, and I’m going to cherish you by explaining the motivation and some implementation details.</p>
<p>Sensitivity to indentation can play some unexpected tricks with you. But having delimiters like <code>{</code> and <code>}</code> to denote the start and end of the section imposes extra challenges for the configuration language. Specifically, escaping.</p>
<p>Every time you add an special character in a config or data language, you have to deal with escaping. But escaping doesn’t play well with the “The Most Elegant Configuration Language” brand.</p>
<p>Whitespaces are invisible, people don’t rely on the specific number of whitespaces in the front, and adding more whitespaces doesn’t increase visual noise. They’re the perfect delimiters and escaping characters, like silent ninjas.</p>
<p>To handle nested values easily, the CCL parser implementation remembers the number of spaces <code>N</code> in front of the first key and follows two simple rules:</p>
<ol type="1">
<li>Lines with <code>⩽ N</code> leading spaces start new key-value entry.</li>
<li>Lines with <code>&gt; N</code> leading spaces continue the previous value.</li>
</ol>
</details>
<h3 id="algebraic-data-types">Algebraic Data Types</h3>
<p>The concept of Algebraic Data Types (ADTs) is essential to Functional Programming. Unfortunately, most configuration and serialisation formats don’t support ADTs nicely.</p>
<p>For CCL, it’s peanuts.</p>
<p>Consider the following ADT that describes a date range that can be either empty, single-dated or a range between two dates.</p>
<div id="cb24"><pre><code><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span>type</span> date = {</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>  year: <span>int</span>;</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>  month: <span>int</span>;</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>  day: <span>int</span>;</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>}</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a><span>type</span> date_range =</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>  | Empty</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a>  | Single <span>of</span> date</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a>  | Range <span>of</span> date * date</span></code></pre></div>
<p>A list of different values of this type will look like this:</p>
<div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span>let</span> date_range_example =</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>  [</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>    Empty;</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>    Single { year = <span>2025</span>; month = <span>6</span>; day = <span>25</span> };</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>    Range ({ year = <span>2025</span>; month = <span>1</span>; day = <span>1</span> },</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>           { year = <span>2025</span>; month = <span>12</span>; day = <span>31</span> });</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>You can encode (and decode!) the same list in CCL without problems, using constructor names as keys and values as payloads.</p>
<div id="cb26"><pre><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>empty =</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>single = <span>2025-06-25</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>range =</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>  <span>0</span> = <span>2025-01-01</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>  <span>1</span> = <span>2025-12-31</span></span></code></pre></div>
<p>If you have named constructors instead of positional, you can use nested named keys!</p>
<h2 id="category-theory-enters-the-chat">Category Theory Enters The Chat</h2>
<p>You thought I finished after describing all CCL features.</p>
<p>In fact, I haven’t even started.</p>
<h3 id="composition">Composition</h3>
<p>When writing software that works with configuration, it’s common to follow this pattern:</p>
<ol type="1">
<li>Have a default configuration.</li>
<li>Have a system-specific configuration for all users on the system.</li>
<li>Have a global user-specific configuration.</li>
<li>Have a project-specific local configuration.</li>
<li>Have a temporary configuration to override values during local development or experimentation.</li>
</ol>
<p>For example, you use a linter and you want to have the same consistent experience for all your hobby projects on your laptop. But occasionally, different projects have different needs. So it’s desirable to have project-specific overrides.</p>
<p>In other words, you have multiple layers of configurations, and you want to combine them. What you actually want is to <strong>compose</strong> them.</p>
<p>Turns out, with CCL this is trivial.</p>
<p>If you have one config like this one:</p>
<div id="cb27"><pre><code><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>no-trailing-whitespaces = <span>true</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>insert-final-newline = <span>true</span></span></code></pre></div>
<p>And another config like this:</p>

<p>Concatenating them together produces a valid config trivially:</p>
<div id="cb29"><pre><code><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>no-trailing-whitespaces = <span>true</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>insert-final-newline = <span>true</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>color-theme = dark</span></code></pre></div>
<p>So with this simple approach, you can trivially combine configs and expect a valid config in the end. There’s no special magic.</p>
<h3 id="associativity">Associativity</h3>
<p>A <strong>category</strong> in Category Theory comprises <em>objects</em> (you can choose them: numbers, strings, sets, types, other categories, etc.) and <em>morphisms</em> (arrows between objects). You can compose morphisms, and this composition is <strong>associative</strong>.</p>
<p>Turns out, composing CCL configs in the above way is an associative operation. Let’s call this operation <code>smoosh</code>.</p>
<p>Associativity means that combining three configs this way:</p>
<div id="cb30"><pre><code><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>smoosh (smoosh ccl1 ccl2) ccl3</span></code></pre></div>
<p>Is the same as:</p>
<div id="cb31"><pre><code><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>smoosh ccl1 (smoosh ccl2 ccl3)</span></code></pre></div>
<p>There’s an immediate practical application of this property: if you have three configs (e.g. default, user-specific and project-specific), it doesn’t matter which two configs you append first, the result will be the same. Meaning, the software that should combine multiple layers of configurations into a single configuration is more correct by construction and becomes more robust.</p>
<h3 id="semigroup">Semigroup</h3>
<p>Turns out, our CCL configuration with the operation of combining two configs forms an important mathematical abstraction — <strong>semigroup</strong>.</p>
<blockquote>
<p>I explain this abstraction in detail in my <em>Pragmatic Category Theory</em> series, <a href="https://chshersh.com/blog/2024-07-30-pragmatic-category-theory-part-01.html">Part 1: Semigroup</a> specifically. I spend time exploring why associativity matters in <a href="https://chshersh.com/blog/2024-12-20-pragmatic-category-theory-part-03.html">Part 3: Associativity</a>.</p>
</blockquote>
<p>In OCaml, we can describe a general Semigroup interface with the following code:</p>
<div id="cb32"><pre><code><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span>module</span> <span>type</span> SEMIGROUP = <span>sig</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>  <span>type</span> t</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>  <span>val</span> smoosh : t -&gt; t -&gt; t</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a><span>end</span></span></code></pre></div>
<p>We have a type <code>t</code> and we <code>smoosh</code> two values together (and this <code>smoosh</code> operation must be associative to form a valid Semigroup).</p>
<p>Just by leveraging this abstraction from math, we’ve got an immediate practical application of composing multiple configuration worry-free.</p>
<p>But why stop here?</p>
<h3 id="monoid">Monoid</h3>
<p>I hate it when I run a piece of software and it complains about not having a configuration.</p>
<p>Every software MUST WORK WITHOUT A CONFIG!!</p>
<p>So, <strong>empty config or no config file at all must be a valid configuration</strong>.</p>
<p>Turns out, if the configuration type is Semigroup, and we have an empty configuration called <code>empty</code> that satisfies the following properties (called <strong>identity</strong> properties):</p>
<div id="cb33"><pre><code><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>smoosh ccl empty = ccl</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>smoosh empty ccl = ccl</span></code></pre></div>
<p>then the configuration is another abstraction — <strong>monoid</strong>.</p>
<blockquote>
<p>📜 It’s easy to show these properties hold for CCL.</p>
</blockquote>
<p>In OCaml, we would represent this abstraction in the following way:</p>
<div id="cb34"><pre><code><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span>module</span> <span>type</span> MONOID = <span>sig</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>  <span>type</span> t</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>  <span>val</span> empty : t</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>  <span>val</span> smoosh : t -&gt; t -&gt; t</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a><span>end</span></span></code></pre></div>
<hr/>
<p>Here we went from a practical example to rediscovering a math abstraction. But when you’re familiar with such abstractions, the usual thinking route is the following:</p>
<ol type="1">
<li>I want to combine my configs. Is there a nice math abstraction for this? Aha, Semigroup!</li>
<li>Okay, can my Semigroup be a Monoid too? What is my <code>empty</code> value?</li>
<li>Turns out, there’s an immediate practical application: an empty configuration should be a valid config too, duh!</li>
</ol>
<h3 id="monoid-homomorphism">Monoid Homomorphism</h3>
<p>We have actually two ways to represent a valid CCL config.</p>
<p><strong>1: A file with text</strong></p>
<div id="cb35"><pre><code><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>subtitles = enabled</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>playback-speed = <span>1.25</span></span></code></pre></div>
<p>We know that our configs form Semigroup with the file concatenation operation being associative (let’s call this operation <code>cat</code>) and the empty file being the identity element and thus forming a Monoid.</p>
<p><strong>2: A list of key-value pairs</strong></p>
<div id="cb36"><pre><code><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span>let</span> settings_example =</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>  [</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>    { key = <span>&#34;subtitles&#34;</span>; value = <span>&#34;enabled&#34;</span> };</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>    { key = <span>&#34;playback-speed&#34;</span>; value = <span>&#34;1.25&#34;</span> };</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>The list append operator in OCaml is <code>@</code>. Turns out, appending lists is an associative operation, and therefore lists with <code>@</code> form a Semigroup.</p>
<p>Moreover, empty list <code>[]</code> satisfies the <em>identity</em> properties in relation to <code>@</code>. Therefore lists with <code>@</code> also form a Monoid.</p>
<p>We also have a function to convert the contents of the file into a list of key-value pairs:</p>
<div id="cb37"><pre><code><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span>val</span> parse : <span>string</span> -&gt; key_val <span>list</span></span></code></pre></div>
<p>This function satisfies a peculiar property:</p>
<div id="cb38"><pre><code><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>parse (cat ccl1 ccl2) ≡ parse ccl1 @ parse ccl2</span></code></pre></div>
<p>In English, concatenating two files and then parsing the result is the same as parsing two files separately and then appending the resulting lists of key-value pairs.</p>
<p>We have two Monoids: (1) CCL (aka text files) and (2) lists of key-value pairs. And we have a function <code>parse</code> with the above property. In this case, <code>parse</code> is a <strong>monoid homomorphism</strong>.</p>
<p>A <em>monoid homomorphism</em> is a function that maps one monoid to another while preserving monoidal properties (such as associativity and identity).</p>
<p>Is there an immediate practical application of this? Of course there’s! Otherwise, I wouldn’t mention it.</p>
<p>First of all, for <code>parse</code> to truly be a <em>monoid homomorphism</em>, it needs to preserve the emptiness property. In other words:</p>

<p>Which is totally reasonable, we should parse an empty file to a valid config. Moreover, this config must be an empty list.</p>
<p>But second, and most important, if <code>parse</code> is a true <em>monoid homomorphism</em> then it doesn’t matter if we concat files first and then parse or if we first parse and then concat. The result will be the same!</p>
<p>It means, we can actually improve the performance of parsing multiple files. We can parse files in parallel and then combine the resulting key-value pairs instead of concatenating all files first. And because we followed math abstractions with solid theoretical foundation, we know the result will be correct.</p>
<p>This property can become handy when you start representing your cloud configuration a-la K8S with hundreds of config files, and suddenly the pod start time starts to matter.</p>
<details>
<summary>Pedantic Alert #1: Error-handling</summary>
<p>To simplify the explanation, I made an assumption that the function <code>parse</code> doesn’t fail. In practice, it’s absolutely possible for parsing to fail on invalid inputs. Does it mean we can’t benefit from monoid homomorphisms here? Of course not!</p>
<p>The trick here involves two steps:</p>
<ol type="1">
<li>Represent errors as values</li>
<li>Use a return type that returns errors while still being a monoid.</li>
</ol>
<p>To do this, let’s introduce type like this one:</p>
<div id="cb40"><pre><code><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a><span>type</span> (&#39;a, &#39;e) validation =</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a>  | <span>Failure</span> <span>of</span> &#39;e <span>list</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a>  | Success <span>of</span> &#39;a <span>list</span></span></code></pre></div>
<p>In English, this polymorphic type is either a list of errors or a list of successes.</p>
<p>This type is a Monoid with the following implementation:</p>
<div id="cb41"><pre><code><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a><span>let</span> empty = Success []</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a><span>let</span> append val1 val2 =</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a>  <span>match</span> val1, val2 <span>with</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true"></a>  | <span>Failure</span> errors1, <span>Failure</span> errors2 -&gt; <span>Failure</span> (errors1 @ errors2)</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true"></a>  | <span>Failure</span> errors, Success _ -&gt; <span>Failure</span> errors</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true"></a>  | Success _, <span>Failure</span> errors -&gt; <span>Failure</span> errors</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true"></a>  | Success a, Success b -&gt; Success (a @ b)</span></code></pre></div>
<p>In English, when we combine two validations:</p>
<ol type="1">
<li>If both are failures, we just combine all errors.</li>
<li>If at least one is a failure, we keep errors from it and discard success.</li>
<li>If both are successes, we combine all successes.</li>
</ol>
<p>And our <code>parse</code> will change it’s type to:</p>
<div id="cb42"><pre><code><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a><span>val</span> parse : <span>string</span> -&gt; (key_val, parse_error) validation</span></code></pre></div>
<p>Because <code>validation</code> is a monoid, our <code>parse</code> remains a <em>monoid homomorphism</em> with the semantics of either getting all errors from all sources or appending all successful results if no errors happened.</p>
</details>
<details>
<summary>Pedantic Alert #2: File concatenation</summary>
<p>So, again, I simplified things a little. Because CCL is indentation sensitive, appending two files like this:</p>
<p><strong>example1.ccl</strong></p>

<p><strong>example2.ccl</strong></p>

<p>and then parsing them is not the same as parsing first and appending later because after appending files we’ll get only one key.</p>
<p>An annoyance but easily fixable: we can’t simply append files, we need to remove leading spaces. An implementation in OCaml:</p>
<div id="cb45"><pre><code><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a><span>let</span> cat ccl1 ccl2 = ccl1 ^ <span>&#34;</span><span>\n</span><span>&#34;</span> ^ <span>String</span>.trim ccl2</span></code></pre></div>
<p>Notice how we benefited from math abstractions. But following them precisely, we discovered an annoying bug and fixed it early.</p>
</details>
<details>
<summary>Bonus: Isomorphism</summary>
<p>Btw, the pretty-printing function like this:</p>
<div id="cb46"><pre><code><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a><span>val</span> pretty : key_val <span>list</span> -&gt; <span>string</span></span></code></pre></div>
<p>Is a <em>monoid homomorphism</em> too. Together with <code>parse</code> they form <strong>monoid isomorphisms</strong>: you can convert both ways while preserving the structure.</p>
<p>This property is incredibly useful for testing when you want to parse, then pretty-print back and make sure you don’t lose any information in the process.</p>
</details>
<h3 id="fixed-point">Fixed Point</h3>
<p>So far, I haven’t explored one important topic: <strong>key overrides</strong>.</p>
<p>In configurations, it’s common to have the same key mapped to different values. Especially, if we start combining configs that have overlapping properties.</p>
<p>Let’s say we have two configs.</p>
<p><strong>default.ccl</strong></p>
<div id="cb47"><pre><code><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a>trailing-whitespaces = yes</span></code></pre></div>
<p><strong>project.ccl</strong></p>
<div id="cb48"><pre><code><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a>trailing-whitespaces = no</span></code></pre></div>
<p>What should be the value of the <code>trailing-whitespaces</code> property once we combine them?</p>
<div id="cb49"><pre><code><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a>trailing-whitespaces = yes</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a>trailing-whitespaces = no</span></code></pre></div>
<p>The quick answer: DIY. When you parse the final config (or parse first and then append lists, remember <em>monoid homomorphisms</em>), you’ll get the following list of key-value pairs:</p>
<div id="cb50"><pre><code><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a><span>let</span> overrides_example =</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a>  [</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a>    { key = <span>&#34;trailing-whitespaces&#34;</span>; value = <span>&#34;yes&#34;</span> };</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a>    { key = <span>&#34;trailing-whitespaces&#34;</span>; value = <span>&#34;no&#34;</span> };</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>Overrides are not a problem because you keep both values. And you can decide what to do with them: keep only the first, keep only the last or use some smart logic to combine both of them. You’re the boss.</p>
<p>Unfortunately, this business becomes nasty once you start having nested records. Manually parsing and resolving all the nested key overrides is annoying.</p>
<p>CCL solved this too.</p>
<p>The key idea here is to treat values as.. keys (pun intended).</p>
<p>Remember how in the “Nested records” section I mentioned that you can parse values using the same CCL config parser? If you do it recursively until the end, you’ll parse all values.</p>
<p>What? You ask when do you stop parsing? That’s the neat part, you don’t.</p>
<p>Or, more precisely, you stop when you can’t parse any more. By applying parsing recursively until parsing doesn’t change anything, you reach a so-called <strong>fixed point</strong>.</p>
<p>Because we now have this nested structure, we no longer treat CCL as a list of key-value pairs. What is it though?</p>
<p>A configuration in CCL is actually a <em>fixed point</em> for a dictionary from strings to.. itself!</p>
<p>In OCaml, it’s pure elegancy:</p>
<div id="cb51"><pre><code><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a><span>type</span> t = Fix <span>of</span> t <span>Map</span>.Make(<span>String</span>).t</span></code></pre></div>
<p>It’s a map that maps strings (i.e. keys) to itself. The only way to stop the recursion is to bind a key to an empty map. And therefore, final level is values mapped to empty maps.</p>
<p>We can have a pure function to turn a list of key-value pairs on this representation:</p>
<div id="cb52"><pre><code><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a><span>val</span> fix : key_val <span>list</span> -&gt; t</span></code></pre></div>
<p>When we had lists, we could just append lists (a pretty understandable operation). How can we append such fixed points? That’s pretty easy too.</p>
<p>The operation to merge two fixed points is straightforward, using just the OCaml standard library:</p>
<div id="cb53"><pre><code><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a><span>let</span> <span>rec</span> merge (Fix map1) (Fix map2) =</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true"></a>  Fix</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true"></a>    (<span>Map</span>.Make(<span>String</span>).merge</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true"></a>       (<span>fun</span> _key t1 t2 -&gt;</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true"></a>         <span>match</span> (t1, t2) <span>with</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true"></a>         | <span>None</span>, t2 -&gt; t2</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true"></a>         | t1, <span>None</span> -&gt; t1</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true"></a>         | <span>Some</span> t1, <span>Some</span> t2 -&gt; <span>Some</span> (merge t1 t2))</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true"></a>       map1 map2)</span></code></pre></div>
<p>It looks like this function does nothing (it just recursively calls itself). Yet, it does everything.</p>
<p>Now, things are getting juicy. When you have a config like this one:</p>
<div id="cb54"><pre><code><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a>ports = <span>8080</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true"></a>ports = <span>8081</span></span></code></pre></div>
<p>In CCL, it’s actually just syntax sugar for:</p>
<div id="cb55"><pre><code><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a>ports =</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true"></a>  <span>8080</span> =</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true"></a>ports =</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true"></a>  <span>8081</span> =</span></code></pre></div>
<p>You got it correctly. It’s not two keys of the same name mapped to two different string values. It’s two keys mapped to two different nested singleton objects where keys are values.</p>
<p>Parsing and applying <code>fix</code> merges the keys, and we get the following:</p>

<p>So now, we easily combine multiple similar keys and join their values on all levels of nestedness with <em>checks notes</em> with just 10 lines of OCaml.</p>
<hr/>
<p>Wanna hear the cool part? Our <strong>fixed point</strong> with <code>merge</code> is a monoid too. Meaning, that <code>fix</code> is actually a monoid homomorphism from a list of key-value pairs to a map. And the composition of <code>parse</code> and <code>fix</code> is a composition of monoid homomorphisms, meaning it’s automatically also a monoid homomorphism.</p>
<p>And we get all the discussed benefits for free again.</p>
<p>That’s why we needed only 10 lines of OCaml. We’re standing on the shoulders of giants who have been creating math for thousands of years.</p>
<h2 id="whats-next">What’s next?</h2>
<p>I have a CCL PoC <a href="https://github.com/chshersh/ccl">built in OCaml on GitHub</a>.</p>
<p>It works. It passes the tests. It’s not production-ready.</p>
<p>Meaning, that documentation might lack important details, performance wasn’t optimised, code is ugly at some places, the quality of error messages is poor, utility functions are lacking, and breaking changes are expected. You know, just like a typical SaaS product, except CCL is free and was done in 10 evenings.</p>
<p>However, I’ve implemented an exhaustive test suite with dozens of unit tests covering diverse edge-cases as well as property-based tests to verify algebraic laws.</p>
<figure>
<img src="https://chshersh.com/images/ccl/tests.png" alt=""/><figcaption>Example of passing tests (they pass, it’s true)</figcaption>
</figure>
<p>If you try it and discover bugs, please report! I’ll try to fix them.</p>
<p>Currently, I’m focusing on building <a href="https://github.com/chshersh/github-tui">GitHub TUI</a> in OCaml. If at some point the need for a config arises, I return to <code>ccl</code>.</p>
<p>For example, to make CCL production-ready, one essential API piece is missing: decoding CCL values into actual programming values.</p>
<p>I envision an API in OCaml like this one:</p>
<div id="cb57"><pre><code><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a><span>type</span> user = {</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a>  login: <span>string</span>;</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a>  name: <span>string</span>;</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a>  last_active: <span>int</span>;  <span>(* timestamp in UNIX epoch *)</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true"></a>}</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true"></a></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true"></a><span>let</span> codec =</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true"></a>  Ccl.(</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true"></a>    <span>let</span>+ login = Codec.<span>string</span> <span>&#34;login&#34;</span> (<span>fun</span> {login; _} -&gt; login)</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true"></a>    <span>and</span>+ name = Codec.<span>string</span> <span>&#34;name&#34;</span> (<span>fun</span> {name; _} -&gt; name)</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true"></a>    <span>and</span>+ last_active =</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true"></a>      Codec.<span>int</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true"></a>        <span>&#34;last_active&#34;</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true"></a>        (<span>fun</span> {last_active; _} -&gt; last_active)</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true"></a>    <span>in</span></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true"></a>    { login; name; last_active }</span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true"></a>  )</span></code></pre></div>
<p>I used to work on something similar in the past, using Category Theory abstractions such as Category, Isomorphisms, Profunctors and Applicative Functors. But I’ll save this for another article.</p>
<p>The implementation of CCL is so simple, you can even try implementing it in your favourite language, and this could be a nice hobby project!</p>
<hr/>
<p>My goal is not to make everyone use this new language. What I want is to inspire you.</p>
<p>I hope you can see how much you can achieve with so little.</p>
<p>I hope you’ll try to pursue simplicity as well.</p>
<p>I hope we can make the software better together.</p>

<hr/>
<blockquote>
<p>If you liked this blog post, consider supporting my work on GitHub Sponsors, or following me on the Internet:</p>
<ul>
<li><a target="_blank" href="https://github.com/sponsors/chshersh">GitHub Sponsors: @chshersh</a></li>
<li><a target="_blank" href="https://youtube.com/c/chshersh">YouTube: @chshersh</a></li>
<li><a target="_blank" href="https://x.com/ChShersh">𝕏: @chshersh</a></li>
<li><a target="_blank" href="https://bsky.app/profile/chshersh.com">BlueSky: @chshersh.com</a></li>
<li><a target="_blank" href="https://functional.cafe/@chshersh">Mastodon: functional.cafe@chshersh</a></li>
<li><a target="_blank" href="https://www.twitch.tv/chshersh">Twitch: @chshersh </a></li>
</ul>
</blockquote>
    </div></div>
  </body>
</html>
