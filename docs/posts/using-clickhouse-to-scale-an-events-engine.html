<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/getlago/lago/wiki/Using-Clickhouse-to-scale-an-events-engine">Original</a>
    <h1>Using ClickHouse to scale an events engine</h1>
    
    <div id="readability-page-1" class="page"><div data-view-component="true">          <div id="wiki-body">
              <div>
                <p>Like many companies, we had to change our database stack midway while scaling our core product Lago, an open-source usage-based billing platform. As we grew more popular, we began ingesting millions of events every minute. And our rudimentary Postgres-only stack wasn’t cutting it. We were suffering heavy load times, impacting our entire app’s performance.</p>
<p>After some exploration, we decided to use a distributed ClickHouse instance strictly for our streamed events. Our analytics services were now able to directly query ClickHouse, an OLAP database. For all other data needs, we kept Postgres.</p>
<p>The strategy was successful. Since the refactor, we haven’t looked back.</p>
<p>Today, we’re going to explore that decision for a hybrid database stack, and more specifically, why we decided to go with ClickHouse.</p>
<div><h2>OLTP versus OLAP databases</h2><a id="user-content-oltp-versus-olap-databases" aria-label="Permalink: OLTP versus OLAP databases" href="#oltp-versus-olap-databases"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p>Most developers, including junior developers, have experience using OLTP (online transactional processing) databases such as Postgres. As the name implies, OLTP databases are designed for processing <em>transactions</em>. A transaction is one of many different types of instructions that software might invoke to a database. The most common are: (i) read, (ii) insert, (iii) update and (iv) delete.</p>
<p>OLTP databases are typically general-purpose databases. Because they support every type of data processing, they could be used for any data problem <em>within limits</em>. And, even at a large scale, they are fantastic for software that require:</p>
<ul>
<li>
<strong>atomic transactions</strong>, where a set of grouped transactions either all occur or don’t occur at all</li>
<li>
<strong>consistency</strong>, where queries in-between writes and updates are deterministic and predictable</li>
</ul>
<p>For most problems, these are important qualities. For some, they are crucial. A banking application can’t have discrepancies whenever money is transferred between accounts. For those problems, an OLTP database is needed for cents-level accuracy.
Today, we still use Postgres as our <strong>primary</strong> database, configured [<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/config/database.yml#L5">via our database.yml file</a>](<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/config/database.yml#L5">https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/config/database.yml#L5</a>). And given that we use Ruby on Rail’s, [<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/db/schema.rb">our Postgres schema</a>](<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/db/schema.rb">https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/db/schema.rb</a>) is automatically generated by Rail’s [<a href="https://guides.rubyonrails.org/active_record_basics.html" rel="nofollow">Active Record</a>](<a href="https://guides.rubyonrails.org/active_record_basics.html" rel="nofollow">https://guides.rubyonrails.org/active_record_basics.html</a>), an ORM that manages our various models such as [<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/charge_spec.rb">charges</a>](<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/charge_spec.rb">https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/charge_spec.rb</a>), [<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/credit_note_spec.rb">credit notes</a>](<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/credit_note_spec.rb">https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/credit_note_spec.rb</a>), [<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/invoice_spec.rb">invoices</a>](<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/invoice_spec.rb">https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/invoice_spec.rb</a>), [<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/invite_spec.rb">invites</a>](<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/invite_spec.rb">https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/invite_spec.rb</a>), [<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/fee_spec.rb">fees</a>](<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/fee_spec.rb">https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/fee_spec.rb</a>), [<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/coupon_spec.rb">coupons</a>](<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/coupon_spec.rb">https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models/coupon_spec.rb</a>), and [<a href="https://github.com/getlago/lago-api/tree/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models">much, much more</a>](<a href="https://github.com/getlago/lago-api/tree/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models">https://github.com/getlago/lago-api/tree/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/spec/models</a>). We write some custom queries given [<a href="https://github.com/getlago/lago/wiki/Is-ORM-still-an-%27anti-pattern%27%3F">the performance limits of the ORM</a>](<a href="https://github.com/getlago/lago/wiki/Is-ORM-still-an-%27anti-pattern%27%3F">https://github.com/getlago/lago/wiki/Is-ORM-still-an-%27anti-pattern%27%3F</a>), but otherwise lean heavily on Active Record for most transactions.</p>
<p>So where do OLAP (online analytical processing) databases like ClickHouse come in? Well, Postgres was designed to be <em>strictly</em> atomic and consistent; two properties that require for data to be fully <strong>ingested</strong> before any query that might process them is run. This creates a problem for tables where entries are ingested in the millions per minutes (e.g. billable events, especially those for infrastructure services like managed servers). Specifically, the issue <em><strong>isn’t</strong></em> ingesting data, but rather simultaneously handling expensive analytical queries without locking up the queue. These data-summarizing problems are where OLAP databases like ClickHouse shine.</p>
<p>OLAP databases are designed for two primary problems—(i) efficiently answering complex read queries with <em><strong>approximate</strong></em> accuracy and (ii) batch processing a large number of write queries. However, OLAP databases are <strong>terrible</strong> for mutating data (where the <strong>entire</strong> database often needs to be re-written) or deleting data.</p>
<p>Different OLAP solutions (e.g. ClickHouse, QuestDB, Druid) have different strengths, and we’ll dive into the specific strain of traits that made ClickHouse a winning solution in the next section. But all OLAP solutions share a common quality—data is stored in an inverted layout relative to OLTP databases like Postgres.
<img width="778" alt="Storage types" src="https://private-user-images.githubusercontent.com/85290767/289697112-9b014845-d4f4-4f54-ac71-bd88af75060c.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTI4NzAyNjUsIm5iZiI6MTcxMjg2OTk2NSwicGF0aCI6Ii84NTI5MDc2Ny8yODk2OTcxMTItOWIwMTQ4NDUtZDRmNC00ZjU0LWFjNzEtYmQ4OGFmNzUwNjBjLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA0MTElMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNDExVDIxMTI0NVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWMxNWJjODFlM2QyMzRlOTIwOWE3NjUzOWUzNmZkNmFiZjk4NzY1MzU1ZDZlYWE3OGM2ZWFhYTU5ZjQwYWEyNjYmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.IqPq30AZ6aQbfOyZ2Kbtg0xRQqcLtbAtm3Z8mbRcGFc" content-type-secured-asset="image/png"/></p>
<p>Now, from the user’s standpoint, the table’s columns and rows are still just columns and rows. But, physically in memory, data is scanned column-by-column, not row-by-row.  This makes aggregations—such as adding every value in a certain field—very, very fast, as the relevant data is read sequentially.</p>
<div><h2>Enter ClickHouse, our chosen OLAP solution</h2><a id="user-content-enter-clickhouse-our-chosen-olap-solution" aria-label="Permalink: Enter ClickHouse, our chosen OLAP solution" href="#enter-clickhouse-our-chosen-olap-solution"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p>[<a href="https://clickhouse.com/" rel="nofollow">ClickHouse</a>](<a href="https://clickhouse.com" rel="nofollow">https://clickhouse.com</a>) is an open-source tool spun out from a closed-source algorithm used by Yandex’s website analytics product. Today, ClickHouse is shepherded by [<a href="https://clickhouse.com/company/our-story" rel="nofollow">ClickHouse Inc</a>](<a href="https://clickhouse.com/company/our-story" rel="nofollow">https://clickhouse.com/company/our-story</a>) with notable contributions by [<a href="https://altinity.com/" rel="nofollow">Altinity</a>](<a href="https://altinity.com" rel="nofollow">https://altinity.com</a>). To date, it is one of the most successful OLAP databases, both commercially and qualitatively.</p>
<p>ClickHouse has three notable features that make it an analytics powerhouse—(i) dynamic materialized views, (ii) specialized engines, and (iii) vectorized query execution.</p>
<p>To summarize each:</p>
<ul>
<li>
<strong>Dynamic</strong> <strong>Materialized Views.</strong> Materialized Views are query-able views that are generated from raw data in underlying tables. While many databases <strong>do</strong> support materialized views, including Postgres, ClickHouse’s materialized views are dynamic, efficiently refreshing content whenever new content is ingested. These contrasts with ordinary materialized views which are just snapshots of a specific point of time, and are very expensive to refresh.</li>
<li>
<strong>Specialized Engines</strong>. Many databases have a single engine for utilizing hardware to process queries / transactions. ClickHouse, however, has dedicated engines for specific mathematical functions, such as summing or averaging numbers.</li>
<li>
<strong>Vectorized Query Execution</strong>. ClickHouse’s specialized engines leverage vectorized query execution, where the hardware uses multiple units in parallel to achieve a communal result (known as SIMD—Single Instruction, Multiple Data).</li>
</ul>
<p>Combined with its columnar storage, these traits allow ClickHouse to easily sum, average, or generally aggregate database values.</p>
<p>As a caveat, Postgres isn’t <em>entirely</em> incapable of achieving similar results, but only via a bastion of optimizations. For instance, there is a third-party [<a href="https://github.com/citusdata/postgres_vectorization_test">vectorized executor</a>](<a href="https://github.com/citusdata/postgres_vectorization_test">https://github.com/citusdata/postgres_vectorization_test</a>) designed for Postgres that imitates ClickHouse’s native support. There is also [<a href="https://aws.amazon.com/blogs/database/building-fast-refresh-capability-in-amazon-rds-for-postgresql/" rel="nofollow">a Fast Refresh Module</a>](<a href="https://aws.amazon.com/blogs/database/building-fast-refresh-capability-in-amazon-rds-for-postgresql/" rel="nofollow">https://aws.amazon.com/blogs/database/building-fast-refresh-capability-in-amazon-rds-for-postgresql/</a>) that uses Postgres’s log to dynamically update materialized views. Coupled with Postgres triggers, developers could create a ClickHouse-like set-up. But all of these techniques require <em>significant</em> set-up work and additional columns to reach any efficiency that is even comparable to ClickHouse’s.</p>
<p><img width="631" alt="Untitled (2)" src="https://private-user-images.githubusercontent.com/85290767/289697301-27120962-d6a1-46e6-b0bf-fe3ec3a65b0a.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTI4NzAyNjUsIm5iZiI6MTcxMjg2OTk2NSwicGF0aCI6Ii84NTI5MDc2Ny8yODk2OTczMDEtMjcxMjA5NjItZDZhMS00NmU2LWIwYmYtZmUzZWMzYTY1YjBhLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA0MTElMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwNDExVDIxMTI0NVomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWY0YmZkYTk0Y2QwZjBmMmRjMmU5NGFkYTQyNmZlZjY2M2Y3OTk4MjBjNDNjNTA4ZDI4YTlmY2NjNzgxZWU5ODMmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.ypPdSdCqVAxqC1UkIzM6JOpixP8TokC7YZe6qXG6v5I" content-type-secured-asset="image/png"/></p><p>A relevant <a href="https://posthog.com/blog/clickhouse-vs-postgres" rel="nofollow">meme</a> from my Postgres vs Clickhouse guide for PostHog</p>
<p>Recently, the most interesting rift in the Postgres vs OLAP space is [<a href="https://www.hydra.so/" rel="nofollow">Hydra</a>](<a href="https://www.hydra.so" rel="nofollow">https://www.hydra.so</a>), an open-source, column-oriented distribution of Postgres that was <em><strong>very</strong></em> recently launched (after our migration to ClickHouse). Had Hydra been available during our decision-making time period, we might’ve made a different choice. However, ClickHouse remains an incredible pick, given its mature product, large community, hardware optimizations, and ease of use side-by-side with Postgres.</p>
<p>Of course, migrating analytics processes to ClickHouse is only half the battle. The next is actually deploying ClickHouse to production—where a few strategies exist.</p>
<div><h2>How we utilize ClickHouse</h2><a id="user-content-how-we-utilize-clickhouse" aria-label="Permalink: How we utilize ClickHouse" href="#how-we-utilize-clickhouse"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p>When discussing our ClickHouse implementation, there are fundamentally two different topics—what we use ClickHouse <em><strong>for</strong></em>, and how our ClickHouse instance is deployed and maintained.</p>
<div><h3>What we query ClickHouse for</h3><a id="user-content-what-we-query-clickhouse-for" aria-label="Permalink: What we query ClickHouse for" href="#what-we-query-clickhouse-for"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p>Our ClickHouse instance [<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/app/models/clickhouse/events_raw.rb#L3">ingests raw billable events</a>](<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/app/models/clickhouse/events_raw.rb#L3">https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/app/models/clickhouse/events_raw.rb#L3</a>) dispatched by our users. While we don’t write our own ClickHouse schema (as it is auto-generated by ActiveRecord), it is written to a file, [<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/db/clickhouse_schema.rb#L4">available in our open-source repository</a>](<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/db/clickhouse_schema.rb#L4">https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/db/clickhouse_schema.rb#L4</a>). Our ClickHouse instance only has two tables—<code>raw_events</code> and <code>raw_events_queue</code>—alongside one materialized view, <code>events_raw_mv</code> . That’s it. We don’t store any of the other “business-critical” data on ClickHouse because they aren’t analytical queries.</p>
<p>In detail, our <code>[raw_events_queue](https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/db/clickhouse_migrate/20231026124912_create_events_raw_queue.rb)</code> is where events are initially streamed to via [<a href="https://kafka.apache.org/" rel="nofollow">Apache Kafka</a>](<a href="https://kafka.apache.org" rel="nofollow">https://kafka.apache.org</a>), open-source event streaming software. From it, the <code>[events_raw_mv](https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/db/clickhouse_migrate/20231030163703_create_events_raw_mv.rb)</code> is generated with ClickHouse’s <code>[cast()](https://clickhouse.com/docs/en/sql-reference/functions/type-conversion-functions)</code> function, which maps the event’s metadata from a JSON blob to a string array. Finally, this materialized view pushes data to the <code>[raw_events](https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/db/clickhouse_migrate/20231024084411_create_events_raw.rb)</code> table. This is a [<a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree" rel="nofollow">MergeTree</a>](<a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree" rel="nofollow">https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree</a>) table that is apt for a large number of writes.</p>
<p><code>raw_events</code> is what Lago’s general codebase interfaces with via our <code>[ClickHouseStores](https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/app/services/events/stores/clickhouse_store.rb#L14)</code> class, which is tapped when [<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/app/services/billable_metrics/aggregation_factory.rb#L18">aggregating billable metrics</a>](<a href="https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/app/services/billable_metrics/aggregation_factory.rb#L18">https://github.com/getlago/lago-api/blob/e0da0a0b136577bffe5a1b8dac8747c913f7cdf1/app/services/billable_metrics/aggregation_factory.rb#L18</a>). <code>raw_events</code> uses a tuple of <code>organization_id</code>, <code>external_subscription_id</code>, <code>code</code>, and a timestamp as primary keys; given ClickHouse’s [<a href="https://medium.com/datadenys/how-clickhouse-primary-key-works-and-how-to-choose-it-4aaf3bf4a8b9" rel="nofollow">sophisticated support for primary key tuples</a>](<a href="https://medium.com/datadenys/how-clickhouse-primary-key-works-and-how-to-choose-it-4aaf3bf4a8b9" rel="nofollow">https://medium.com/datadenys/how-clickhouse-primary-key-works-and-how-to-choose-it-4aaf3bf4a8b9</a>), this helps ClickHouse locate rows <strong>very</strong> quickly.</p>

<p>Because ClickHouse is an open-source database, it could be self-hosted on any ordinary Linux server. However, many companies trust managed database solutions because they (i) often reduce overall costs, (ii) make scaling databases easier, and (iii) take care of safe replication/backups.</p>
<p>One of the most popular options is ClickHouse Inc’s ClickHouse Cloud offering, which offers a serverless ClickHouse instance with decoupled compute and storage.</p>
<p>However, we instead opted for Altinity Operator, which deploys and manages ClickHouse in a Kubernetes cluster in our existing cloud offering. We preferred this approach given more flexibility due to custom definitions, efficiency on cost, and ease of maintenance.</p>
<div><h2>Other notable open-source projects that use ClickHouse</h2><a id="user-content-other-notable-open-source-projects-that-use-clickhouse" aria-label="Permalink: Other notable open-source projects that use ClickHouse" href="#other-notable-open-source-projects-that-use-clickhouse"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p>We aren’t the only open-source project that uses ClickHouse; in fact, we aren’t even the only open-source project that migrated from Postgres to ClickHouse. A notable example is [<a href="https://posthog.com/" rel="nofollow">PostHog</a>](<a href="https://posthog.com" rel="nofollow">https://posthog.com</a>), an open-source analytics suite that switched from [<a href="https://posthog.com/blog/clickhouse-announcement" rel="nofollow">Postgres to ClickHouse</a>](<a href="https://posthog.com/blog/clickhouse-announcement" rel="nofollow">https://posthog.com/blog/clickhouse-announcement</a>) given the sheer amount of web events they were processing per second.</p>
<p>Another great example is Gitlab, which used ClickHouse to store data of streamed events [<a href="https://docs.gitlab.com/ee/architecture/blueprints/clickhouse_usage/" rel="nofollow">in their observability suite</a>](<a href="https://docs.gitlab.com/ee/architecture/blueprints/clickhouse_usage/" rel="nofollow">https://docs.gitlab.com/ee/architecture/blueprints/clickhouse_usage/</a>). In general, it’s common for open-source companies (and closed-source projects alike) to find their general-purpose database like Postgres or mySQL ill-suited as they start to scale.</p>
<p>Even some closed-source solutions, like the HTTP data-streaming product TinyBird, have made [<a href="https://www.tinybird.co/blog-posts/we-launched-an-open-source-clickhouse-knowledge-base" rel="nofollow">open-source contributions to ClickHouse</a>](<a href="https://www.tinybird.co/blog-posts/we-launched-an-open-source-clickhouse-knowledge-base" rel="nofollow">https://www.tinybird.co/blog-posts/we-launched-an-open-source-clickhouse-knowledge-base</a>) given their dependence on it. Slowly, ClickHouse is building the same level of success in the OLAP world as Postgres is achieving in the OLTP space.</p>

<p>Due to the hardware optimizations of inverting table layouts, there is no one-size-fits-all database as applications scale. We ran into that problem fairly early in our journey given the event-heavy nature of our product. However, that doesn’t meant that every team needs to start with an OLTP + OLAP stack—just to be ready for it when the moment arrives.</p>

              </div>

          </div>
</div></div>
  </body>
</html>
