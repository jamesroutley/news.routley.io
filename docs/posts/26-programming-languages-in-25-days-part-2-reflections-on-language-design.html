<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matt.might.net/articles/26-languages-part2/">Original</a>
    <h1>26 programming languages in 25 days, Part 2: Reflections on language design</h1>
    
    <div id="readability-page-1" class="page"><div id="main-abstract">
   <p>I <a href="https://matt.might.net/articles/26-languages-part1/">recently wrote</a> about completing <a href="https://adventofcode.com/">Advent of Code</a> 2022 using a different programming language (or two) every day for 25 days.</p>

<p>That note focused on the strategy, tactics and logistics involved in using 26 languages in 25 days without saying much about the languages or the experience itself.</p>

<p>Using so many languages in such a short span provided insight into the relative strengths and weaknesses of language design choices such as static versus dynamic typing and strict versus lazy evaluation.</p>

<p>Here are my two high-level reflections from the experience:</p>

<ul>
<li><p> Good design in the first part of each puzzle – especially more functional techniques and abstractions – tended to make the second part easier. So, in general, functional languages seemed to have the advantage in the puzzles.</p></li>
<li><p> Using better algorithms and data structures was far more important than having a “faster” programming language. There was never a time where rewriting in another language felt like the right way to get better performance.</p></li>
</ul>

<p>Read on for more specific reflections on language design.</p>
  </div><div id="main-content">
  <h2 id="onsyntax">On syntax</h2>

<p>Aside from notable (negative) experiences in bash, vimscript and TeX, language syntax mattered little to me.</p>

<p>I have a soft spot for S-Expressions, so I really enjoyed using Common Lisp and Racket (despite having never used Common Lisp previously).</p>

<p>Somewhat surprisngly, indentation-sensitivity in languages like Python and Haskell had me writing cleaner-looking and more readable code by default.</p>

<p>In fact, I routinely found that even in the languages where an <code>end</code> or an <code>endfunction</code> or <code>}</code> was needed, the indentation always predicted where it would have gone anyway.</p>

<p>Based on this experience alone, if I were to design a non-S-Expression-based language, it would push me toward indentation-sensitivity.</p>

<p>That’s a notable shift from my prior perspective, where I felt that whitespace-insensitivity was preferrable to indentation-sensitivity.</p>

<h2 id="onstaticversusdynamictyping">On static versus dynamic typing</h2>

<p>I’ve bounced back and forth between statically typed and dynamically typed
languages my whole career.</p>

<p>I’ve never settled dogmatically into any camp, and this experience didn’t change that.</p>

<p>On the contrary, I probably feel more firmly than ever before that neither philosophy is strictly superior, and that approaches than enable a mixture of static and dynamic typing are critical.</p>

<p>For instance, puzzles that emphasized manipulating complex nested data structures benefited from having the type-checker looking over my shoulder.</p>

<p>And, in general, I did feel that statically typed languages (especially the stricter ones like Haskell and Standard ML) reduced overall debugging, and more often than not, my code worked correctly once it compiled.</p>

<p>However, for puzzles where the data structures were straightforward, dynamically typed languages had me moving faster out of the gate.</p>

<p>In particular, days where dense matrices were the primary data structure seemed to favor dynamically typed languages.</p>

<p>If I were to design a language, I’d probably follow the approach of Racket and Typed Racket – of having a dynamically typed language as the default and a closely related typed language into which code could be gradually imported as needed.</p>

<h2 id="onpurityversusimpurity">On purity versus impurity</h2>

<p>I used pure (or almost pure) functional programming languages (Erlang, Standard ML, Haskell) on a few days.</p>

<p>On some others, I programmed in a purely or almost purely functional manner even in languages that fluidly supported side effects (C#, JavaScript, Common Lisp, Scala, Racket).</p>

<p>In general, programming functionally tended to reduce the amount of time I had to spend to refactor my code to solve part 2, often significantly.</p>

<p>There also seemed to be far fewer bugs in my code.</p>

<p>On no day did purity seem to make a meaningful impact on performance.</p>

<p>As a programmer, my instinct will remain to use purely functional programming until there is a compelling reason to use side effects.</p>

<p>However, if I were to design a language, I probably wouldn’t remove mutability.</p>

<p>Rather, I’d encourage purely functional programming with <a href="https://matt.might.net/articles/red-black-delete/">rich, purely functional data structures</a> in the standard library.</p>

<p>And, I’d provide strong up-front support for “transparent” side effects like memoization.</p>

<h2 id="onlazyversusstrict">On lazy versus strict</h2>

<p>Haskell was the only truly lazy language I used, but others like Scala and Racket had support for using laziness as needed.</p>

<p>To solve several of the puzzles, I rolled laziness by hand into the algorithm itself.</p>

<p>There were certainly days where that laziness improved performance substantially.</p>

<p>My sense, however, was that laziness by default was overkill, with laziness on demand sufficient in every case.</p>

<p>Were I to design a language, I’d probably opt for strict by default with substantial support for laziness as needed.</p>

<h2 id="oncompilationversusinterpretation">On compilation versus interpretation</h2>

<p>It doesn’t make sense to think of a language itself as <em>compiled</em> or <em>interpreted</em>, even as language implementations tend to favor one approach or the other.</p>

<p>While compilation versus interpretation never made a sigificant difference in
performance for my solutions (which tended to be dominated by algorithmic
complexity concerns), there was a significant difference in the rate at which I
learned the language.</p>

<p>Having access to an interpreter to poke at the run-time values of a partially
completed program or to quickly test out an idea was a noticeable accelerant.</p>

<p>Were I to implement a language, I think I’d favor having an interpreter first.</p>

<p>That said, in language design, I’d hold back on features like <code>eval</code> that can substantially complicate compilation.</p>

<h2 id="ondomain-specificversusgeneral-purpose">On domain-specific versus general-purpose</h2>

<p>Not surprisingly, domain-specific languages (e.g. sed, awk, MATLAB) tended to be
pleasant within their intended domain, and miserable outside of it.</p>

<p>A notable exception was vimscript.</p>

<p>It felt miserable to program in vimscript even when I was using it to write
programs intended to manipulate text interactively.</p>

<p>What I’d really like to see is more support for embedded domain-specific languages within general-purpose languages.</p>

<h2 id="finalthoughts">Final thoughts</h2>

<p>Of course, Advent of Code isn’t intended as a language design exercise.</p>

<p>Even so, the chance to kick the tires on so many languages in such a short span did shift my long-settled perspectives on language design.</p>

<p>Of existing languages, Racket (paired with Typed Racket) probably comes closest to what I feel is the sweet spot for language design, and it may explain why I seem to pick it more than most other languages when given a choice.</p>
  </div></div>
  </body>
</html>
