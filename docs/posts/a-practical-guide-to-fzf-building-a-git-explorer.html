<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thevaluable.dev/fzf-git-integration/">Original</a>
    <h1>A Practical Guide to fzf: Building a Git Explorer</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><article><section><picture><source srcset="https://thevaluable.dev/images/2024/fzf-git-integration/c3po_rd2d_fzf_git.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/fzf-git-integration/c3po_rd2d_fzf_git.jpg" alt="C3PO and RD2D obviously use fzf interfaces with Git"/></picture><div><div><ol><li><a href="https://thevaluable.dev/practical-guide-fzf-example/">A Practical Guide to fzf: Building a File Explorer</a></li><li><a href="https://thevaluable.dev/fzf-shell-integration/">A Practical Guide to fzf: Shell Integration</a></li><li><a href="https://thevaluable.dev/fzf-vim-integration/">A Practical Guide to fzf: Vim Integration</a></li><li><a href="https://thevaluable.dev/fzf-git-integration/">A Practical Guide to fzf: Building a Git Explorer</a></li></ol></div></div><p>It’s again a boring day in the offices of MegaCorpMoneyMaker, the company you’re working with. As often you’re writing spaghetti code, not because you’re a bad developer, but because your deadlines are incredibly short, your motivation non-existent, and your colleagues care more about their promotions than their actual work.</p><p>Looking out of the window while questioning your life choices, you suddenly see a globular and reflecting flying saucer landing on the parking of the company. Flabbergasted, you begin to wonder if these aliens want to buy the horrible products MegaCorpMoneyMaker is selling. Quite disappointed to see aliens with such a lack of taste, you decide to see by yourself what these creatures want.</p><p>From the flying saucer comes creatures you have a hard time to describe, even to yourself. They’re like cones with cyclopean tentacles, covered by tiny holes opening and closing randomly, like hundreds of little mouths trying to say something. Nobody is around, you’re alone with these nightmares.</p><p>Suddenly, you hear a voice in your head:</p><p>“Git is such a nightmare to use. Write some interfaces we can customize easily, earthling! We don’t like GUI, it’s not configurable enough, and we don’t like to use a mouse. Our tentacles can’t grab it easily.”</p><p>Wondering what they’ll do to you if you refuse, you quickly have the answer pumping in your head:</p><p>“Do you want to see the heart of a star, earthling? The bottom of a black hole? Do you want to travel in different plans, full of creatures even uglier than you?”</p><p>You realize suddenly that these propositions don’t sound too appealing. Working in MegaCorpMoneyMaker is not that bad, at the end.</p><p>You come back to your office, grab your laptop, and begin to work. This day was written in the Memory of a Charming Alien, a very famous book every alien in the universe read at least once, even these rednecks on Titan. This article is a transcription of the work done in this day.</p><p>More precisely, we’ll see:</p><ul><li>How to create an interface with fzf to manage files with Git.</li><li>How to create an interface with fzf to manage Git commits.</li><li>How to create an interface with fzf to manage Git branches.</li></ul><p>We’ll build these interfaces step by step: we’ll first define how to display the information we’re interested in, to then add keystrokes to perform some useful operations using the Holy Git.</p><p>There is no guarantee that these commands work in any situation, but they’re explained enough for you to improve and customize them depending on your needs and preferences.</p><p>The goal of this article is to show you how far we can go with fzf, some useful Git commands you might not be aware of, as well as some general tips about shell scripting in general. I won’t explain everything related to Git here, but if you’re interested to see a series of article covering this amazing tool, don’t hesitate <a href="https://thevaluable.dev/page/newsletter/">to connect</a>, or to let a comment at the end of this page.</p><p>If you’re lost in the different fzf options we’ll use in this article, they’re all explained <a href="https://thevaluable.dev/practical-guide-fzf-example/">in the first article of this series</a>.</p><p>Are you ready to interface the sourcing power of Git with the listing energy of fzf?</p><h2 id="the-article-companion">The Article Companion</h2><p>To get the most of this article, I’d recommend you to follow along and fidget with the different commands we’ll discuss here. We’ll use a dummy repository to test out the different interfaces we’ll create; you just need to clone it with the following shell command:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git clone https://github.com/Phantas0s/tvd_companion_git_fzf
</span></span></code></pre></div><p>We’ll call this project the article companion.</p><p>From there, simply open a terminal, go to the folder <code>tvd_companion_git_fzf</code>, and you’re good to go. All the commands we’ll see in this article work in Bash (tested with GNU bash, version 5.2.26) and other similar shells like Zsh. I used fzf 0.48.</p><h2 id="working-with-files">Working with Files</h2><p>The files are your project are the most important entities when it comes to version control. Let’s build an interface to perform the most common operations in a typical Git workflow.</p><h3 id="preparing-the-terrain">Preparing the Terrain</h3><p>To stage and unstage files using Git, we need first to create, modify, and delete some of them in our article companion. Let’s run the following shell commands:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>touch 1.md 2.md
</span></span><span><span>rm DUMMY.md
</span></span><span><span><span>echo</span> <span>&#39;New line!&#39;</span> &gt;&gt; README.md
</span></span></code></pre></div><p>If you run <code>git status --short</code> you should get the following output:</p><div><pre tabindex="0"><code data-lang="bash"><span><span> D DUMMY.md
</span></span><span><span> M README.md
</span></span><span><span>?? 1.md
</span></span><span><span>?? 2.md
</span></span></code></pre></div><p>If you’re not familiar with this output, let me explain quickly:</p><ul><li>Each file are prefixed with two columns, indicating the status of the file.</li><li>The prefix <code>??</code> indicates that the file is untracked by Git. It has never been committed yet.</li><li>The prefix <code>D</code> indicates that the file has been <span>d</span>eleted. Because the <code>D</code> is in the second column of the prefix, we know that this deleted file is unstaged.</li><li>The prefix <code>M</code> indicated that the file was <span>m</span>odified. It’s also in the second column of the prefix, so we know that it’s unstaged.</li></ul><p>If we run the command <code>git add DUMMY.md</code>, the deletion becomes staged; the status <code>D</code> is now in the first column of the prefix:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>D  DUMMY.md
</span></span><span><span> M README.md
</span></span><span><span>?? 1.md
</span></span><span><span>?? 2.md
</span></span></code></pre></div><p>Let’s unstage the deletion: run <code>git reset DUMMY.md</code>.</p><div><p><code>man git-status</code> - Search for “Changed Tracked Entries”</p></div><h3 id="listing-staged-and-unstaged-files">Listing Staged and Unstaged Files</h3><p>One of the most common thing we can do with Git is staging and unstaging files, thanks to the shell command <code>git add</code> and <code>git reset</code> respectively.</p><p>We could imagine using fzf to get the list of unstaged files, select the files we want to stage, and run <code>git add</code> on the selection.</p><h4 id="listing-the-unstaged-files">Listing the Unstaged Files</h4><p>First, we need to list the unstaged files. We could use <code>git ls-files</code> to get the files modified, deleted, and untracked (“other”). We should also skip the files listed in <code>.gitignore</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git ls-files --modified --deleted --other --exclude-standard
</span></span></code></pre></div><p>Here’s what you should get:</p><div><pre tabindex="0"><code data-lang="text"><span><span>1.md
</span></span><span><span>2.md
</span></span><span><span>DUMMY.md
</span></span><span><span>DUMMY.md
</span></span><span><span>README.md
</span></span></code></pre></div><p>Deleted and unstaged files are considered both modified and deleted, that’s why <code>DUMMY.md</code> appears two times here. We need to add the option <code>--deduplicate</code> to fix this problem:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git ls-files --modified --deleted --other --exclude-standard --deduplicate
</span></span></code></pre></div><p>The magical output:</p><div><pre tabindex="0"><code data-lang="text"><span><span>1.md
</span></span><span><span>2.md
</span></span><span><span>DUMMY.md
</span></span><span><span>README.md
</span></span></code></pre></div><p>But this command is not perfect for our use case. To illustrate the problem, run <code>cd subdir</code> to change our current directory to a subdirectory of the article companion. If we run again the above Git command, there won’t be any output.</p><p>It’s because <code>git ls-files</code> look at the current directory by default, not the root directory of a project. We could give this root directory as argument to fix this problem. Good news everyone: the following command output what we need:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git rev-parse --show-toplevel
</span></span></code></pre></div><p>If we run the following, we’ll always have the unstaged files we need, even if we’re in a subdirectory of a project:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git ls-files <span>\
</span></span></span><span><span><span></span>    --modified <span>\
</span></span></span><span><span><span></span>    --deleted <span>\
</span></span></span><span><span><span></span>    --other <span>\
</span></span></span><span><span><span></span>    --exclude-standard <span>\
</span></span></span><span><span><span></span>    --deduplicate <span>\
</span></span></span><span><span><span></span>    <span>$(</span>git rev-parse --show-toplevel<span>)</span>
</span></span></code></pre></div><p>The output:</p><div><pre tabindex="0"><code data-lang="text"><span><span>../1.md
</span></span><span><span>../2.md
</span></span><span><span>../DUMMY.md
</span></span><span><span>../DUMMY.md
</span></span><span><span>../README.md
</span></span></code></pre></div><h4 id="listing-the-staged-files">Listing the Staged Files</h4><p>If we want a fzf interface to also unstage files, we need a list of all staged ones. First, let’s stage a file in our article companion:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git add ../1.md
</span></span></code></pre></div><p>The following command can display the list of staged files:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git diff --name-only --staged
</span></span></code></pre></div><p>The output:</p><div><pre tabindex="0"><code data-lang="text"><span><span>1.md
</span></span></code></pre></div><p>But, again, we have a problem: we’re still in the subdirectory <code>subdir</code>, so the path <code>1.md</code> is not correct. Running <code>git add 1.md</code> won’t work; instead, we need the list of the relative filepaths of our staged files, to be able to do something like <code>git add ../1.md</code> for example.</p><p>An alternative would be to use <code>git status</code> to list all the staged files and get the good filepaths, but it gets a bit more complicated:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git status --short <span>|</span> grep <span>&#39;^[A-Z]&#39;</span> <span>|</span> awk <span>&#39;{print $NF}&#39;</span>
</span></span></code></pre></div><p>We basically list here all the staged and unstaged files, and only grep the ones which have a letter in the first column of their prefixes (and therefore which are staged). We also use the CLI tool awk to get the name of the files without the prefixes. As you can see, we get what we want:</p><div><pre tabindex="0"><code data-lang="text"><span><span>../1.md
</span></span></code></pre></div><h3 id="an-interface-to-stage-and-unstage-files">An interface to Stage and Unstage Files</h3><p>Let’s combine the commands we’ve seen above with fzf. First, let’s create an interface to stage files:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git add <span>$(</span>git ls-files <span>\
</span></span></span><span><span><span></span>    --modified <span>\
</span></span></span><span><span><span></span>    --deleted <span>\
</span></span></span><span><span><span></span>    --other <span>\
</span></span></span><span><span><span></span>    --exclude-standard <span>\
</span></span></span><span><span><span></span>    --deduplicate <span>\
</span></span></span><span><span><span></span>    <span>$(</span>git rev-parse --show-toplevel<span>)</span> <span>\
</span></span></span><span><span><span></span>  <span>|</span> fzf --multi --reverse --no-sort<span>)</span>
</span></span></code></pre></div><p>Here’s another command to unstage files:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git reset -- <span>$(</span>git status --short <span>\
</span></span></span><span><span><span></span>  <span>|</span> grep <span>&#39;^[A-Z]&#39;</span> <span>\
</span></span></span><span><span><span></span>  <span>|</span> awk <span>&#39;{print $NF}&#39;</span> <span>\
</span></span></span><span><span><span></span>  <span>|</span> fzf --multi --reverse --no-sort<span>)</span>
</span></span></code></pre></div><p>We add <code>--</code> here to specify to Git that we want to reset files, not commits.</p><p>If we don’t want to quit fzf when adding one or multiple files, we could also bind the <code>ENTER</code> key to add the files. Let’s also add a preview showing the status of all the project’s files, a nice prompt, and some help:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>staged_files</span><span>=</span><span>&#39;git ls-files \
</span></span></span><span><span><span>  --modified \
</span></span></span><span><span><span>  --deleted \
</span></span></span><span><span><span>  --other \
</span></span></span><span><span><span>  --exclude-standard \
</span></span></span><span><span><span>  --deduplicate \
</span></span></span><span><span><span>  $(git rev-parse --show-toplevel)&#39;</span> <span>\
</span></span></span><span><span><span></span><span>&amp;&amp;</span> <span>eval</span> <span>&#34;</span><span>$staged_files</span><span>&#34;</span> <span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --multi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --prompt<span>=</span><span>&#39;Add &gt; &#39;</span> <span>\
</span></span></span><span><span><span></span>  --header-first <span>\
</span></span></span><span><span><span></span>  --header<span>=</span><span>&#39;ENTER to stage the files&#39;</span> <span>\
</span></span></span><span><span><span></span>  --preview<span>=</span><span>&#39;git status --short&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;enter:execute(git add {+})&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#34;enter:+reload(</span><span>$staged_files</span><span>)&#34;</span>
</span></span></code></pre></div><p>If you don’t understand what all these options stand for, the <a href="https://thevaluable.dev/practical-guide-fzf-example/">first article of this series</a> can help you.</p><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2024/fzf-git-integration/01_fzf_git_add_files.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/fzf-git-integration/01_fzf_git_add_files.jpg" alt="fzf interface to stage files using Git"/></picture><p>From there, it’s easy to come up with a similar command to unstage files:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>unstaged_files</span><span>=</span><span>&#39;git status --short \
</span></span></span><span><span><span>  | grep &#34;^[A-Z]&#34; \
</span></span></span><span><span><span>  | awk &#34;{print \$NF}&#34;&#39;</span> <span>\
</span></span></span><span><span><span></span><span>&amp;&amp;</span> <span>eval</span> <span>&#34;</span><span>$unstaged_files</span><span>&#34;</span> <span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --multi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --prompt<span>=</span><span>&#39;Reset &gt; &#39;</span> <span>\
</span></span></span><span><span><span></span>  --header-first <span>\
</span></span></span><span><span><span></span>  --header<span>=</span><span>&#39;ENTER to unstage the file&#39;</span> <span>\
</span></span></span><span><span><span></span>  --preview<span>=</span><span>&#39;git status --short&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;enter:execute(git reset -- {+})&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#34;enter:+reload(</span><span>$unstaged_files</span><span>)&#34;</span>
</span></span></code></pre></div><p>We have to escape the <code>$</code> of <code>$NF</code> using a backslash (<code>\$NF</code>) because we’re using weak double quotes here, and we don’t want the shell to expand <code>$NF</code>; awk should do that instead. When we begin to add layers of quoting in Bash, we run quickly into nasty problems. This trope will follow us until the end of this article, and possibly the end of time.</p><p>All of that is great, but we have now two different interfaces to stage and unstage our files. What about having only one interface to rule them all? We could switch between the “Add mode” and the “Reset mode” with a couple of keystrokes.</p><p>What should happen when we hit <code>ENTER</code>? If the files can be found in the list of unstaged files, we stage them; otherwise, we unstage them. Something like the following:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git ls-files --modified --deleted --other --exclude-standard --deduplicate <span>|</span> grep <span>{}</span> <span>\
</span></span></span><span><span><span></span><span>&amp;&amp;</span> git add <span>{</span>+<span>}</span> <span>\
</span></span></span><span><span><span></span><span>||</span> git reset -- <span>{</span>+<span>}</span>
</span></span></code></pre></div><p>Here’s a possible implementation:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>staged_files</span><span>=</span><span>&#39;git ls-files \
</span></span></span><span><span><span>  --modified \
</span></span></span><span><span><span>  --deleted \
</span></span></span><span><span><span>  --other \
</span></span></span><span><span><span>  --exclude-standard \
</span></span></span><span><span><span>  --deduplicate \
</span></span></span><span><span><span>  $(git rev-parse --show-toplevel)&#39;</span> <span>\
</span></span></span><span><span><span></span><span>&amp;&amp;</span> <span>unstaged_files</span><span>=</span><span>&#39;git status  --short \
</span></span></span><span><span><span>  | grep &#34;^[A-Z]&#34; \
</span></span></span><span><span><span>  | awk &#34;{print \$NF}&#34;&#39;</span> <span>\
</span></span></span><span><span><span></span><span>&amp;&amp;</span> <span>eval</span> <span>&#34;</span><span>$staged_files</span><span>&#34;</span> <span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --multi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --prompt<span>=</span><span>&#39;Add &gt; &#39;</span> <span>\
</span></span></span><span><span><span></span>  --header-first <span>\
</span></span></span><span><span><span></span>  --header <span>&#39;
</span></span></span><span><span><span>  &gt; CTRL-R to Reset | CTRL-A to Add
</span></span></span><span><span><span>  &gt; ENTER to Reset or Add files
</span></span></span><span><span><span>  &gt; ENTER in Reset mode switch back to Add mode
</span></span></span><span><span><span>  &#39;</span> <span>\
</span></span></span><span><span><span></span>  --preview<span>=</span><span>&#39;git status --short&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;ctrl-a:change-prompt(Add &gt; )&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#34;ctrl-a:+reload(</span><span>$staged_files</span><span>)&#34;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;ctrl-r:change-prompt(Reset &gt; )&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#34;ctrl-r:+reload(</span><span>$unstaged_files</span><span>)&#34;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#34;enter:execute(</span><span>$staged_files</span><span> | grep {} \
</span></span></span><span><span><span>    &amp;&amp; git add {+} \
</span></span></span><span><span><span>    || git reset -- {+})&#34;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;enter:+change-prompt(Add &gt; )&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#34;enter:+reload(</span><span>$staged_files</span><span>)&#34;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;enter:+refresh-preview&#39;</span>
</span></span></code></pre></div><p>As explained in the <code>header</code>, we can switch to “Add mode” by hitting <code>CTRL-a</code>, and to “Reset mode” by hitting <code>CTRL-r</code>.</p><p>Each time we reset one (or multiple) files, we come back to “Add mode”. It’s because it’s difficult to know in what mode we’re in, and, as a result, it’s difficult to know what shell command we should use to reload the list of entries in fzf when we stage or unstage files. Always being in “Add mode” allows us to avoid this problem; we just have to reload the list of unstaged files. But it’s not ideal.</p><p>It’s also a bit annoying to have two different keystrokes for our two modes. What about having one keystroke to switch between them? It’s where the <code>transform</code> action can help us:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>staged_files</span><span>=</span><span>&#39;git ls-files \
</span></span></span><span><span><span>  --modified \
</span></span></span><span><span><span>  --deleted \
</span></span></span><span><span><span>  --other \
</span></span></span><span><span><span>  --exclude-standard \
</span></span></span><span><span><span>  --deduplicate \
</span></span></span><span><span><span>  $(git rev-parse --show-toplevel)&#39;</span> <span>\
</span></span></span><span><span><span></span><span>&amp;&amp;</span> <span>unstaged_files</span><span>=</span><span>&#39;git status --short \
</span></span></span><span><span><span>  | grep &#34;^[A-Z]&#34; \
</span></span></span><span><span><span>  | awk &#34;{print \$NF}&#34;&#39;</span> <span>\
</span></span></span><span><span><span></span><span>&amp;&amp;</span> <span>eval</span> <span>&#34;</span><span>$staged_files</span><span>&#34;</span> <span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --multi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --prompt<span>=</span><span>&#39;Add &gt; &#39;</span> <span>\
</span></span></span><span><span><span></span>  --header-first <span>\
</span></span></span><span><span><span></span>  --header <span>&#39;
</span></span></span><span><span><span>  &gt; CTRL-S to switch between Add and Reset mode
</span></span></span><span><span><span>  &gt; ENTER to Reset or Add files
</span></span></span><span><span><span>  &#39;</span> <span>\
</span></span></span><span><span><span></span>  --preview<span>=</span><span>&#39;git status --short&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#34;ctrl-s:transform:[[ \$FZF_PROMPT =~ &#39;Add &gt;&#39; ]] \
</span></span></span><span><span><span>    &amp;&amp; echo &#39;change-prompt(Reset &gt; )+reload(</span><span>$unstaged_files</span><span>)&#39; \
</span></span></span><span><span><span>    || echo &#39;change-prompt(Add &gt; )+reload(</span><span>$staged_files</span><span>)&#39;&#34;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#34;enter:execute(
</span></span></span><span><span><span>    </span><span>$staged_files</span><span> | grep {} \
</span></span></span><span><span><span>    &amp;&amp; git add {+} \
</span></span></span><span><span><span>    || git reset -- {+}
</span></span></span><span><span><span>    )&#34;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#34;enter:+reload(
</span></span></span><span><span><span>    [[ \$FZF_PROMPT =~ &#39;Add &gt;&#39; ]] \
</span></span></span><span><span><span>    &amp;&amp; </span><span>$staged_files</span><span> \
</span></span></span><span><span><span>    || </span><span>$unstaged_files</span><span>
</span></span></span><span><span><span>    )&#34;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;enter:+refresh-preview&#39;</span>
</span></span></code></pre></div><p>The sumptuous result:</p><p>The internal variable <code>$FZF_PROMPT</code> store the string used as prompt in fzf (<code>Add &gt;</code> or <code>Reset &gt;</code> here). We can look at its value to know in what mode we’re in; as a result, we can refresh the good list of files (staged or unstaged) each time we hit <code>CTRL-s</code> or <code>ENTER</code>.</p><h3 id="multiple-preview">Multiple Preview</h3><p>It’s great to display the status of our files in fzf’s preview, but it would also be useful to show the diff of these files, to know what was modified at a glance.</p><p>To display the diff of the file <code>../README.md</code> for example, we can run the following command:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git diff --color ../README.md
</span></span></code></pre></div><p>The output:</p><div><pre tabindex="0"><code data-lang="text"><span><span>────────────────────────────────────
</span></span><span><span>modified: README.md
</span></span><span><span>────────────────────────────────────
</span></span><span><span>@ README.md:1 @
</span></span><span><span>This is the companion repository for the article [A Practical Guide to fzf: Building a Git Explorer](https://thevaluable.dev/fzf-git-integration).
</span></span><span><span>New line!
</span></span></code></pre></div><p>The first four lines of the diff are quite useless for our use case, so let’s use the CLI tool sed to get rid of them:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git diff --color<span>=</span>always archives/outlines/fzf-git-integration.md <span>\
</span></span></span><span><span><span></span><span>|</span> sed <span>&#39;1,4d&#39;</span>
</span></span></code></pre></div><p>If you want to know more about sed, <a href="https://thevaluable.dev/sed-cli-practical-guide-examples/">I’ve written an article about it</a>.</p><p>You might not want to display the diff at all, but only some stats. You could do the following in that case:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git diff --color --stat ../README.md
</span></span></code></pre></div><p>As always, it depends on what you prefer. For example, we could also add <code>--diff-algorithm=histogram</code> to avoid repeating some changes in common elements. Also, the options <code>--ignore-all-space</code> and <code>--ignore-blank-lines</code> can be useful if you don’t want to bother with diff of spaces and blank lines.</p><p>Here are the options we can add to our interfaces to change the preview:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>  --bind<span>=</span><span>&#39;ctrl-f:change-preview-label([ Diff ])&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;ctrl-f:+change-preview(git diff --color=always {} | sed &#34;1,4d&#34;)&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;ctrl-s:change-preview-label([ Status ])&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;ctrl-s:+change-preview(git status --short)&#39;</span> <span>\
</span></span></span></code></pre></div><p>Unfortunately, it seems that there is no way to use only one keystroke to switch between the two previews. There is no environment variable like <code>$FZF_PROMPT</code> which contains the label of the preview, to switch to the other one. But fear not! I’ve <a href="https://github.com/junegunn/fzf/pull/3693" target="_blank" rel="noopener">open a pull request</a> to add a new environment variable <code>$FZF_PREVIEW_LABEL</code>; if it’s ever merged, something like the following would then be possible:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>  --bind<span>=</span><span>&#34;ctrl-p:transform:[[ \$FZF_PREVIEW_LABEL =~ &#39;[ Status ]&#39; ]] \
</span></span></span><span><span><span>    &amp;&amp; echo &#39;change-preview(git diff --color=always {} | sed \&#34;1,4d\&#34;)+change-preview-label([ Diff ])&#39; \
</span></span></span><span><span><span>    || echo &#39;change-preview(git status --short)+change-preview-label([ Status ])&#39;&#34;</span> <span>\
</span></span></span></code></pre></div><p>We can also add another keystroke to display a preview of <code>git blame</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span> --bind<span>=</span><span>&#39;ctrl-b:change-preview-label([ Blame ])&#39;</span> <span>\
</span></span></span><span><span><span></span> --bind<span>=</span><span>&#39;ctrl-b:+change-preview(git blame --color-by-age {})&#39;</span> <span>\
</span></span></span></code></pre></div><p>Now that our preview can be quite long, it would be nice to have some keystrokes to scroll it. We can add the following ones for example, mimicking some good old <a href="https://thevaluable.dev/vim-commands-beginner/">Vim keystrokes</a>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>--bind<span>=</span><span>&#39;ctrl-y:preview-up&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-e:preview-down&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-u:preview-half-page-up&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-d:preview-half-page-down&#39;</span> <span>\
</span></span></span></code></pre></div><h3 id="adding-patches">Adding Patches</h3><p>If you have multiple changes in a single file, and you want to commit some of these changes but not all of them, you can choose and add hunks of patch thanks to <code>git add --patch</code>. Let’s add this functionality to our splendid interface:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>--bind<span>=</span><span>&#39;alt-p:execute(git add --patch {+})&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;alt-p:+reload($unstaged_files)&#39;</span> <span>\
</span></span></span></code></pre></div><h3 id="editing-the-files">Editing the Files</h3><p>What about editing the files selected in your favorite editor (which is obviously Vim) directly from fzf? We can add the following keystrokes to do so:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>--bind <span>&#39;alt-e:execute(${EDITOR:-vim} {+})&#39;</span> <span>\
</span></span></span></code></pre></div><p>We use the environment variable <code>$EDITOR</code> to find your favorite editor and edit the files selected. If the variable is empty we default to <a href="https://thevaluable.dev/vim-commands-beginner/">Vim</a>.</p><h3 id="checkout-the-files">Checkout the Files</h3><p>If you want to undo all the changes you’ve made since the last commit in some files, you simply need to checkout them. We could add this functionality to our interface: first, we reset the file in case it was staged, and then we undo all the modifications we did in the last commit. Something like the following:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>--bind<span>=</span><span>&#39;alt-d:execute(git reset -- {+})&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;alt-d:+execute(git checkout {+})&#39;</span> <span>\
</span></span></span></code></pre></div><h3 id="to-commit-or-not-to-commit">To commit or not to Commit</h3><p>Lastly, it would be nice to create commits directly from our interface. Let’s not wait any longer:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>--bind <span>&#39;alt-c:execute(git commit)+abort&#39;</span> <span>\
</span></span></span></code></pre></div><p>We could also add the staged files to the last commit as follows:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>--bind <span>&#39;alt-a:execute(git commit --amend)+abort&#39;</span> <span>\
</span></span></span></code></pre></div><p>As you can see, when the commit is created, we ask fzf to abort. Again, it’s up to you: you might not want to close fzf when you’ve committed your staged files.</p><h3 id="a-script-to-rule-them-all">A Script to rule them all</h3><p>At that point, our command is quite a monster. It’s time to create a Bash script, to make our interface readily available, and also to refactor it a bit.</p><p>You can <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/guide-fzf-git/fzf_git_files.sh" target="_blank" rel="noopener">find the final result here</a>. Let’s look a bit more closely at this implementation; first, we don’t allow all the keystrokes for each mode:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>local</span> -r <span>mode_reset</span><span>=</span><span>&#34;change-prompt(</span><span>$prompt_reset</span><span>)+reload(</span><span>$git_staged_files</span><span>)+change-header(</span><span>$reset_header</span><span>)+unbind(alt-p)+rebind(alt-d)&#34;</span>
</span></span><span><span>
</span></span><span><span><span>local</span> -r <span>mode_add</span><span>=</span><span>&#34;change-prompt(</span><span>$prompt_add</span><span>)+reload(</span><span>$git_unstaged_files</span><span>)+change-header(</span><span>$add_header</span><span>)+rebind(alt-p)+unbind(alt-d)&#34;</span>
</span></span></code></pre></div><p>As you can see, we unbind <code>ATL-p</code> when we are in “Reset mode”, and we unbind <code>ALT-d</code> when we are in the “Add mode”. It’s because we don’t want to enable <code>git add --patch</code> in “Reset mode”, and we don’t want to enable <code>git checkout</code> in <code>Add mode</code>.</p><p>Since we’re directly in “Add mode” when we start fzf, we also need to unbind <code>ALT-d</code> at startup:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>--bind<span>=</span><span>&#39;start:unbind(alt-d)&#39;</span> <span>\
</span></span></span></code></pre></div><p>We also use some <a href="https://en.wikipedia.org/wiki/Here_document" target="_blank" rel="noopener">heredoc</a> to make long strings and commands more manageable. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>	<span>local</span> -r <span>header</span><span>=</span><span>$(</span>cat <span>&lt;&lt;-EOF
</span></span></span><span><span><span>		&gt; CTRL-S to switch between Add Mode and Reset mode
</span></span></span><span><span><span>		&gt; CTRL_T for status preview | CTRL-F for diff preview | CTRL-B for blame preview
</span></span></span><span><span><span>		&gt; ALT-E to open files in your editor
</span></span></span><span><span><span>		&gt; ALT-C to commit | ALT-A to append to the last commit
</span></span></span><span><span><span>		EOF</span>
</span></span><span><span>	<span>)</span>
</span></span></code></pre></div><p>We use here <code>TAB</code> characters for our indentation coupled with <code>&lt;&lt;-</code>, which will ignore any leading <code>TAB</code> character. It means that the string itself won’t have any indentation.</p><p>If you don’t use <code>TAB</code> characters as indentation in your file, and you don’t want any indentation in the string itself, you can do the following:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>    <span>local</span> -r <span>header</span><span>=</span><span>$(</span>cat <span>&lt;&lt;EOF
</span></span></span><span><span><span>&gt; CTRL-S to switch between Add Mode and Reset mode
</span></span></span><span><span><span>&gt; CTRL_T for status preview | CTRL-F for diff preview | CTRL-B for blame preview
</span></span></span><span><span><span>&gt; ALT-E to open files in your editor
</span></span></span><span><span><span>&gt; ALT-C to commit | ALT-A to append to the last commit
</span></span></span><span><span><span>EOF</span>
</span></span><span><span><span>)</span>
</span></span></code></pre></div><p>If you’re a blessed Vim user and if you want to replace all your indentations with tabs in your file, you can simply run the following:</p><div><pre tabindex="0"><code data-lang="vim"><span><span><span>:</span><span>set</span> <span>noexpandtab</span> <span>shiftwidth</span><span>=</span><span>2</span> <span>tabstop</span><span>=</span><span>2</span> <span>|</span> <span>retab</span><span>!</span><span>
</span></span></span></code></pre></div><p>That’s it! We have now a functional interface to manage our files with Git. It’s time now to go a level higher in our adventure: let’s create a new interface to manage Git commits.</p><h2 id="working-with-commits">Working with Commits</h2><p>Managing commits is also an important part in a typical Git workflow. Let’s see how we can use fzf to make the changes we want as easily as possible.</p><h3 id="listing-git-commits">Listing Git Commits</h3><p>If we want to manage our commits using fzf, we first need to list them. One commit per line would be ideal; each line should contain the commit hash, to be able to give it as argument to other Git commands.</p><p>The following list all the commit hashes of the current branch:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git log --format<span>=</span><span>&#34;%h&#34;</span>
</span></span></code></pre></div><p>The output:</p><div><pre tabindex="0"><code data-lang="text"><span><span>27f62ab
</span></span><span><span>73ce782
</span></span><span><span>2716af8
</span></span><span><span>a0df21f
</span></span><span><span>008faec
</span></span><span><span>c13db2b
</span></span><span><span>21868b1
</span></span><span><span>7c2636f
</span></span></code></pre></div><p>From there, we can add more information on each line to make these commits more understandable. For example, we can add:</p><ul><li>The short form of the committer date (<code>%cs</code>).</li><li>The subject of the commit (<code>%s</code>).</li><li>The name of the reference; for example head, tags, or remote branch (<code>%d</code>).</li></ul><p>Here’s the command we need:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git log --format<span>=</span><span>&#39;%h - %cs - %s%d&#39;</span>
</span></span></code></pre></div><p>The output:</p><div><pre tabindex="0"><code data-lang="text"><span><span>27f62ab - 2024-03-22 - Revert the changes from a0df21f in DUMMY (HEAD -&gt; new-branch, origin/main, origin/HEAD, main)
</span></span><span><span>73ce782 - 2024-03-22 - Merge branch &#39;another_branch&#39;
</span></span><span><span>2716af8 - 2024-03-22 - Add more explanation to DUMMY
</span></span><span><span>a0df21f - 2024-03-22 - Add more text to DUMMY (origin/another_branch, another_branch)
</span></span><span><span>008faec - 2024-03-22 - Add more text to another_file
</span></span><span><span>c13db2b - 2024-03-22 - Add another file
</span></span><span><span>21868b1 - 2024-03-22 - Add README, subdir and a file, and DUMMY
</span></span><span><span>7c2636f - 2024-03-20 - First commit
</span></span></code></pre></div><p>Let’s improve our display even further, by adding pretty colors, and a graph:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git log --graph --color --format<span>=</span><span>&#39;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#39;</span>
</span></span></code></pre></div><p>The output:</p><div><pre tabindex="0"><code data-lang="text"><span><span>* 27f62ab - 2024-03-22 - Revert the changes from a0df21f in DUMMY (HEAD)
</span></span><span><span>*   73ce782 - 2024-03-22 - Merge branch &#39;another_branch&#39;
</span></span><span><span>|\
</span></span><span><span>| * a0df21f - 2024-03-22 - Add more text to DUMMY (origin/another_branch)
</span></span><span><span>| * 008faec - 2024-03-22 - Add more text to another_file
</span></span><span><span>| * c13db2b - 2024-03-22 - Add another file
</span></span><span><span>* | 2716af8 - 2024-03-22 - Add more explanation to DUMMY
</span></span><span><span>|/
</span></span><span><span>* 21868b1 - 2024-03-22 - Add README, subdir and a file, and DUMMY
</span></span><span><span>* 7c2636f - 2024-03-20 - First commit
</span></span></code></pre></div><p>It’s time to bring fzf in the party:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git log --graph --color <span>\
</span></span></span><span><span><span></span>  --format<span>=</span><span>&#39;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --ansi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort
</span></span></code></pre></div><p>What about displaying the changes of the selected commit in fzf’s preview? We can use <code>git show</code> to do so. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git show --color 7c2636f
</span></span></code></pre></div><p>It means that we need to isolate the commit hash from each line of our graph, and give it to <code>git show</code>. Let’s consider the following line as an example:</p><div><pre tabindex="0"><code data-lang="text"><span><span>| * 008faec - 2024-03-22 - Add more text to another_file
</span></span></code></pre></div><p>We could get the hash using grep here:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>echo</span> <span>&#39;| * 008faec - 2024-03-22 - Add more text to another_file&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> grep -o <span>&#34;[a-f0-9]\{7\}&#34;</span>
</span></span></code></pre></div><p>We get our expected output, the commit hash:</p><div><pre tabindex="0"><code data-lang="text"><span><span>008faec
</span></span></code></pre></div><p>If you want to know more about grep, I’ve written <a href="https://thevaluable.dev/grep-cli-guide-examples/">an article about it</a>. Also, if you’re not comfortable with the basics of regular expression, you can <a href="https://thevaluable.dev/regular-expression-basics-vim-grep/">look at this other article</a>.</p><p>Let’s improve our interface with this new preview:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git log --graph --color <span>\
</span></span></span><span><span><span></span>  --format<span>=</span><span>&#39;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --ansi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --preview<span>=</span><span>&#39;
</span></span></span><span><span><span>    echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; \
</span></span></span><span><span><span>    &amp;&amp; git show --color $(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34;)
</span></span></span><span><span><span>  &#39;</span>
</span></span></code></pre></div><p>The splendid result:</p><picture><source srcset="https://thevaluable.dev/images/2024/fzf-git-integration/02_fzf_git_commits.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/fzf-git-integration/02_fzf_git_commits.jpg" alt="fzf interface to manage Git commits"/></picture><p>We repeat <code>echo {} | grep -o &#34;[a-f0-9]\{7\}&#34;</code> two times here. The first one make sure that there is indeed a hash on the line (it’s possible to have lines without commit hashes because of the <code>--graph</code> option). If a hash is found on the selected line, we run <code>git show</code> with the hash as argument.</p><p>If there is also a hash in the subject of the commit, we end up with multiple hashes on the same line (as you can see above). Let’s make sure that we only give to <code>git show</code> the first hash of the line:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git log --graph --color <span>\
</span></span></span><span><span><span></span>  --format<span>=</span><span>&#39;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --ansi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --preview<span>=</span><span>&#39;
</span></span></span><span><span><span>    echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; \
</span></span></span><span><span><span>    &amp;&amp; git show --color $(echo {} \
</span></span></span><span><span><span>    | grep -o &#34;[a-f0-9]\{7\}&#34; \
</span></span></span><span><span><span>    | sed -n &#34;1p&#34;)
</span></span></span><span><span><span>  &#39;</span>
</span></span></code></pre></div><p>The preview command can be simpler (without using sed or even grep) if you get rid of the <code>--graph</code> option. As a result, you’re now sure that the commit is always the first field of each line:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git log --color <span>\
</span></span></span><span><span><span></span>  --format<span>=</span><span>&#39;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --ansi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --preview<span>=</span><span>&#39;git show --color {1}&#39;</span>
</span></span></code></pre></div><p>Scrolling and looking at fzf’s preview is not always the most practical. We could also try to open a new subshell and display the commit’s changes using less when hitting <code>ENTER</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git log --graph --color <span>\
</span></span></span><span><span><span></span>  --format<span>=</span><span>&#39;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --ansi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --preview<span>=</span><span>&#39;
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; git show --color $hash
</span></span></span><span><span><span>    &#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;enter:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; sh -c &#34;git show --color $hash | less -R&#34;
</span></span></span><span><span><span>    )&#39;</span> <span>\
</span></span></span><span><span><span></span>  --header-first <span>\
</span></span></span><span><span><span></span>  --header <span>&#39;
</span></span></span><span><span><span>    &gt; ENTER to display the diff
</span></span></span><span><span><span>  &#39;</span>
</span></span></code></pre></div><p>Now that we can get the hash of each of our commits, let’s add more functionalities to our interface.</p><h3 id="checkout-and-reset-commits">Checkout and Reset Commits</h3><p>It’s sometimes useful to checkout a commit to look at the state of a project at a specific point in time. Let’s add a binding to do so:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git log --graph --color <span>\
</span></span></span><span><span><span></span>  --format<span>=</span><span>&#39;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --ansi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --preview<span>=</span><span>&#39;
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; git show --color $hash
</span></span></span><span><span><span>    &#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;enter:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; sh -c &#34;git show --color $hash | less -R&#34;
</span></span></span><span><span><span>    )&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;alt-c:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; git checkout $hash
</span></span></span><span><span><span>    )+abort&#39;</span> <span>\
</span></span></span><span><span><span></span>  --header-first <span>\
</span></span></span><span><span><span></span>  --header <span>&#39;
</span></span></span><span><span><span>  &gt; ENTER to display the diff
</span></span></span><span><span><span>  &gt; ALT-C to checkout the commit
</span></span></span><span><span><span>  &#39;</span>
</span></span></code></pre></div><p>Also, when I develop a new functionality, I often create a bunch of random commits. When I’m done, I reset to the first commit I’ve made for this functionality, and I re-create a bunch of new commits which are more logical, describing each important step, and it’s ideally possible to revert them without crashing the whole application.</p><p>It’s quite trivial to add this functionality to our interface:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git log --graph --color <span>\
</span></span></span><span><span><span></span>  --format<span>=</span><span>&#39;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --ansi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --preview<span>=</span><span>&#39;
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; git show --color $hash
</span></span></span><span><span><span>    &#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;enter:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; sh -c &#34;git show --color $hash | less -R&#34;
</span></span></span><span><span><span>    )&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;alt-c:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; git checkout $hash
</span></span></span><span><span><span>    )+abort&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;alt-r:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; git reset $hash
</span></span></span><span><span><span>    )+abort&#39;</span> <span>\
</span></span></span><span><span><span></span>  --header-first <span>\
</span></span></span><span><span><span></span>  --header <span>&#39;
</span></span></span><span><span><span>  ENTER to display the diff
</span></span></span><span><span><span>  ALT-C to checkout the commit | ALT-R to reset to the commit
</span></span></span><span><span><span>  &#39;</span>
</span></span></code></pre></div><h3 id="interactive-rebasing">Interactive Rebasing</h3><p>Interactive rebasing can be useful if you want to modify a bunch of commits. Let’s add the functionality in our interface:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git log --graph --color --format<span>=</span><span>&#39;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#39;</span> <span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --ansi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --preview<span>=</span><span>&#39;
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; git show --color $hash
</span></span></span><span><span><span>    &#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;enter:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; sh -c &#34;git show --color $hash | less -R&#34;
</span></span></span><span><span><span>    )&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;alt-c:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; git checkout $hash
</span></span></span><span><span><span>    )+abort&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;alt-r:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; git reset $hash
</span></span></span><span><span><span>    )+abort&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;alt-i:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; git rebase --interactive $hash
</span></span></span><span><span><span>    )+abort&#39;</span> <span>\
</span></span></span><span><span><span></span>  --header-first <span>\
</span></span></span><span><span><span></span>  --header <span>&#39;
</span></span></span><span><span><span>  &gt; ENTER to display the diff
</span></span></span><span><span><span>  &gt; ALT-C to checkout the commit | ALT-R to reset to the commit
</span></span></span><span><span><span>  &gt; ALT-I to rebase interactively
</span></span></span><span><span><span>  &#39;</span>
</span></span></code></pre></div><p>Nothing new here; as you can see, it’s trivial to implement new bindings using the commit hash of the current line.</p><h3 id="cherry-pick-a-commit">Cherry-Pick a Commit</h3><p>It can be useful to cherry-pick a commit and add it on top of the current branch. We could add the following to our previous command:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>  --bind<span>=</span><span>&#39;alt-p:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; git cherry-pick $hash
</span></span></span><span><span><span>    )+abort&#39;</span> <span>\
</span></span></span></code></pre></div><p>But it’s not idea: our interface only list commits of the current branch, and it’s often useful to cherry-pick a commit from another branch. Again, we could imagine switching between two lists in fzf:</p><ol><li>The list of the commits of the current branch.</li><li>The list of all commits reachable from a reference (for example a branch or a tag).</li></ol><p>To do so, we’ll have to use the fzf action <code>transform</code> again. Here’s a possible solution:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>branch_commits</span><span>=</span><span>&#39;git log --graph --color --format=&#34;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#34;&#39;</span> <span>\
</span></span></span><span><span><span></span><span>&amp;&amp;</span> <span>all_commits</span><span>=</span><span>&#39;git log --all --graph --color --format=&#34;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#34;&#39;</span> <span>\
</span></span></span><span><span><span></span><span>&amp;&amp;</span> <span>eval</span> <span>&#34;</span><span>$branch_commits</span><span>&#34;</span> <span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --ansi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --prompt<span>=</span><span>&#34;Branch &gt; &#34;</span> <span>\
</span></span></span><span><span><span></span>  --preview<span>=</span><span>&#39;
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; git show --color $hash
</span></span></span><span><span><span>    &#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#34;ctrl-s:transform:[[ \$FZF_PROMPT =~ &#39;Branch &gt;&#39; ]] \
</span></span></span><span><span><span>    &amp;&amp; echo &#39;change-prompt(All &gt; )+reload(</span><span>$all_commits</span><span>)&#39; \
</span></span></span><span><span><span>    || echo &#39;change-prompt(Branch &gt; )+reload(</span><span>$branch_commits</span><span>)&#39;&#34;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;enter:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; sh -c &#34;git show --color $hash | less -R&#34;
</span></span></span><span><span><span>    )&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;alt-c:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp;  git checkout $hash
</span></span></span><span><span><span>    )+abort&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;alt-r:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; git reset $hash
</span></span></span><span><span><span>    )+abort&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;alt-i:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; git rebase --interactive $hash
</span></span></span><span><span><span>    )+abort&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;alt-p:execute(
</span></span></span><span><span><span>    hash=$(echo {} | grep -o &#34;[a-f0-9]\{7\}&#34; | sed -n &#34;1p&#34;) \
</span></span></span><span><span><span>    &amp;&amp; [[ $hash != &#34;&#34; ]] \
</span></span></span><span><span><span>    &amp;&amp; git cherry-pick $hash
</span></span></span><span><span><span>    )+abort&#39;</span> <span>\
</span></span></span><span><span><span></span>  --header-first <span>\
</span></span></span><span><span><span></span>  --header <span>&#39;
</span></span></span><span><span><span>  &gt; ENTER to display the diff
</span></span></span><span><span><span>  &gt; ALT-C to checkout the commit | ALT-R to reset to the commit
</span></span></span><span><span><span>  &gt; ALT-I to rebase interactively
</span></span></span><span><span><span>  &gt; ALT-P to cherry pick
</span></span></span><span><span><span>  &#39;</span>
</span></span></code></pre></div><p>We’ve created a monster again; it’s time to create a Bash script and refactor this mess. You’ll find the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/guide-fzf-git/fzf_git_commits.sh" target="_blank" rel="noopener">complete function here</a>.</p><p>We have now two different interfaces to manage our files and our commits. Again, it’s time to move a level higher: let’s create a last interface to manage our Git branches.</p><h2 id="working-with-branches">Working with Branches</h2><p>First, let’s list all the branches we have for our current project. We can do so with this simple command:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git branch --color
</span></span></code></pre></div><p>The output:</p><div><pre tabindex="0"><code data-lang="text"><span><span>  another_branch
</span></span><span><span>* main
</span></span><span><span>  new-branch
</span></span><span><span>  yet_another_branch
</span></span></code></pre></div><p>If we want to also include the remote branches in the list, we can add the option <code>--all</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git branch --all --color
</span></span></code></pre></div><p>What about checkout the selected branch directly from fzf? We can do that easily with the following:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git checkout <span>\
</span></span></span><span><span><span></span>  <span>$(</span>git branch --color <span>|</span> fzf --ansi --reverse --no-sort <span>|</span> tr -d <span>&#39; &#39;</span><span>)</span>
</span></span></code></pre></div><p>Since the output of <code>git branch</code> includes many <code>SPACE</code> characters, we use here the CLI tool tr to <span>d</span>elete them.</p><p>We can also shorten the reference or our remote branch by using the <code>--format</code> option:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git branch --all --color --format<span>=</span><span>&#34;%(refname:short)&#34;</span>
</span></span></code></pre></div><p>The output:</p><div><pre tabindex="0"><code data-lang="text"><span><span>another_branch
</span></span><span><span>main
</span></span><span><span>new-branch
</span></span><span><span>yet_another_branch
</span></span><span><span>origin
</span></span><span><span>origin/another_branch
</span></span><span><span>origin/main
</span></span><span><span>origin/yet_another_branch
</span></span></code></pre></div><p>We can also add some color:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git branch --all --color --format<span>=</span><span>&#34;%(color:green) %(refname:short)&#34;</span>
</span></span></code></pre></div><p>It would also be nice to have a star <code>*</code> in front of the current branch, to know where we are in life:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git branch --all --color --format<span>=</span><span>&#34;%(HEAD) %(color:green)%(refname:short)&#34;</span>
</span></span></code></pre></div><p>If we want to checkout the selected branch, we also need to get rid of the star <code>*</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git checkout <span>$(</span>git branch --all --color <span>\
</span></span></span><span><span><span></span>  --format<span>=</span><span>&#34;%(HEAD) %(color:green)%(refname:short)&#34;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> fzf --ansi --reverse --no-sort <span>\
</span></span></span><span><span><span></span><span>|</span> sed <span>&#39;s/^[* ]*//&#39;</span><span>)</span>
</span></span></code></pre></div><p>Granted, trying to checkout the current branch is a bit useless, but, at least, with this solution, Git will output the correct error message if we try to do so.</p><p>Let’s not stop here: let’s add the short committer date, and the subject of the last commit of each branch since we’re at it:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git checkout <span>$(</span>git branch --all --color <span>\
</span></span></span><span><span><span></span>  --format<span>=</span><span>&#34;%(HEAD) %(color:yellow)%(refname:short) %(color:green)%(committerdate:short) %(color:blue)%(subject)&#34;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> fzf --ansi --reverse --no-sort <span>\
</span></span></span><span><span><span></span><span>|</span> sed <span>&#39;s/^[* ]*//&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> awk <span>&#39;{print $1}&#39;</span><span>)</span>
</span></span></code></pre></div><p>We also have more information per line now, so we need to use the CLI tool awk again to select the name of the branch we want to checkout.</p><p>We’re using the short version of the committer date (for example <code>2024-01-01</code>), but you can also use the relative committer date (for example <code>2 weeks ago</code>) with <code>committerdate:relative</code>.</p><p>As you can see, the formatting is a bit all over the place. We could try to format our output in a table, using the CLI tool column:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git checkout <span>$(</span>git branch --all --color <span>\
</span></span></span><span><span><span></span>  --format<span>=</span><span>$&#39;%(HEAD) %(color:yellow)%(refname:short)\t%(color:green)%(committerdate:short)\t%(color:blue)%(subject)&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> column --table --separator <span>$&#39;\t&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> fzf --ansi --reverse --no-sort <span>\
</span></span></span><span><span><span></span><span>|</span> sed <span>&#39;s/^[* ]*//&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> awk <span>&#39;{print $1}&#39;</span><span>)</span>
</span></span></code></pre></div><p>We use the quoting <code>$&#39;</code> here to interpret the escape sequence <code>\t</code> as a <code>TAB</code> character. We could have used any other character as delimiter for our columns, but if this delimiter is also in the subject of the last commit of a branch, the formatting breaks. Feel free to use any other delimiter if you have some <code>TAB</code> characters in one of these subjects.</p><p>Let’s now display the logs of the selected branch as preview:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git checkout <span>$(</span>git branch --all --color <span>\
</span></span></span><span><span><span></span>  --format<span>=</span><span>$&#39;%(HEAD) %(color:yellow)%(refname:short)\t%(color:green)%(committerdate:short)\t%(color:blue)%(subject)&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> column --table --separator <span>$&#39;\t&#39;</span> <span>|</span> <span>\
</span></span></span><span><span><span></span>  fzf <span>\
</span></span></span><span><span><span></span>  --ansi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --preview <span>&#39;git log $(echo {} \
</span></span></span><span><span><span>    | sed &#34;s/^[* ]*//&#34; \
</span></span></span><span><span><span>    | awk &#34;{print \$1}&#34;) \
</span></span></span><span><span><span>    --graph --color \
</span></span></span><span><span><span>    --format=&#34;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#34;&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> sed <span>&#39;s/^[* ]*//&#39;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> awk <span>&#39;{print $1}&#39;</span><span>)</span>
</span></span></code></pre></div><p>We could also display the diff between the current branch and the branch selected in fzf as preview. Let’s also bind the <code>ENTER</code> key to <code>git checkout</code>, to avoid closing fzf when we checkout a different branch:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>git_branches</span><span>=</span><span>&#34;git branch --all --color \
</span></span></span><span><span><span>  --format=</span>$<span>&#39;%(HEAD) %(color:yellow)%(refname:short)\t%(color:green)%(committerdate:short)\t%(color:blue)%(subject)&#39; \
</span></span></span><span><span><span>  | column --table --separator=</span>$<span>&#39;\t&#39;&#34;</span> <span>\
</span></span></span><span><span><span></span><span>&amp;&amp;</span> <span>eval</span> <span>&#34;</span><span>$git_branches</span><span>&#34;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --ansi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --preview-label <span>&#39;[ Commits ]&#39;</span> <span>\
</span></span></span><span><span><span></span>  --preview <span>&#39;git log $(echo {} \
</span></span></span><span><span><span>    | sed &#34;s/^[* ]*//&#34; | \
</span></span></span><span><span><span>    awk &#34;{print \$1}&#34;) \
</span></span></span><span><span><span>    --graph --color  \
</span></span></span><span><span><span>    --format=&#34;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#34;&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind <span>&#39;ctrl-f:change-preview-label([ Diff ])&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind <span>&#39;ctrl-f:+change-preview(
</span></span></span><span><span><span>    git diff --color \
</span></span></span><span><span><span>    $(git branch --show-current)..$(echo {} \
</span></span></span><span><span><span>      | sed &#34;s/^[* ]*//&#34; \
</span></span></span><span><span><span>      | awk &#34;{print \$1}&#34;)
</span></span></span><span><span><span>    )&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind <span>&#39;ctrl-i:change-preview-label([ Commits ])&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind <span>&#39;ctrl-i:+change-preview(
</span></span></span><span><span><span>    git log $(echo {} \
</span></span></span><span><span><span>    | sed &#34;s/^[* ]*//&#34; \
</span></span></span><span><span><span>    | awk &#34;{print \$1}&#34;) \
</span></span></span><span><span><span>    --graph --color \
</span></span></span><span><span><span>    --format=&#34;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#34;)&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind <span>&#39;enter:execute(
</span></span></span><span><span><span>    git checkout $(echo {} \
</span></span></span><span><span><span>    | sed &#34;s/^[* ]*//&#34; \
</span></span></span><span><span><span>    | awk &#34;{print \$1}&#34;)
</span></span></span><span><span><span>    )&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind <span>&#34;enter:+reload(</span><span>$git_branches</span><span>)&#34;</span> <span>\
</span></span></span><span><span><span></span>  --header-first <span>\
</span></span></span><span><span><span></span>  --header <span>&#39;
</span></span></span><span><span><span>  &gt; CTRL-F to preview with diff | CTRL-I to preview with logs
</span></span></span><span><span><span>  &gt; ENTER to checkout the branch
</span></span></span><span><span><span>  &#39;</span>
</span></span></code></pre></div><p>The fantastic result:</p><picture><source srcset="https://thevaluable.dev/images/2024/fzf-git-integration/03_fzf_git_branches.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2024/fzf-git-integration/03_fzf_git_branches.jpg" alt="fzf interface to manage Git branches"/></picture><p>We could also display the diff in a subshell when hitting <code>ENTER</code>, and checkout any branch with <code>ALT-c</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>git_branches</span><span>=</span><span>&#34;git branch --all --color \
</span></span></span><span><span><span>  --format=</span>$<span>&#39;%(HEAD) %(color:yellow)%(refname:short)\t%(color:green)%(committerdate:short)\t%(color:blue)%(subject)&#39; \
</span></span></span><span><span><span>  | column --table --separator=</span>$<span>&#39;\t&#39;&#34;</span> <span>\
</span></span></span><span><span><span></span><span>&amp;&amp;</span> <span>eval</span> <span>&#34;</span><span>$git_branches</span><span>&#34;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --ansi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --preview-label<span>=</span><span>&#39;[ Commits ]&#39;</span> <span>\
</span></span></span><span><span><span></span>  --preview<span>=</span><span>&#39;
</span></span></span><span><span><span>    git log $(echo {} \
</span></span></span><span><span><span>    | sed &#34;s/^[* ]*//&#34; \
</span></span></span><span><span><span>    | awk &#34;{print \$1}&#34;) \
</span></span></span><span><span><span>    --graph --color \
</span></span></span><span><span><span>    --format=&#34;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#34;&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;alt-c:execute(
</span></span></span><span><span><span>    git checkout $(echo {} \
</span></span></span><span><span><span>    | sed &#34;s/^[* ]*//&#34; \
</span></span></span><span><span><span>    | awk &#34;{print \$1}&#34;)
</span></span></span><span><span><span>    )&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind <span>&#34;alt-c:+reload(</span><span>$git_branches</span><span>)&#34;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;enter:execute(
</span></span></span><span><span><span>    branch=$(echo {} \
</span></span></span><span><span><span>    | sed &#34;s/^[* ]*//&#34; \
</span></span></span><span><span><span>    | awk &#34;{print \$1}&#34;) \
</span></span></span><span><span><span>    &amp;&amp; sh -c &#34;git diff --color $branch \
</span></span></span><span><span><span>    | less -R&#34;
</span></span></span><span><span><span>    )&#39;</span> <span>\
</span></span></span><span><span><span></span>  --header-first <span>\
</span></span></span><span><span><span></span>  --header <span>&#39;
</span></span></span><span><span><span>  &gt; ALT C to checkout the branch
</span></span></span><span><span><span>  &gt; ENTER to open the diff with less
</span></span></span><span><span><span>  &#39;</span>
</span></span></code></pre></div><p>Let’s not stop here: what about merging and rebasing the branch selected with the current one?</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>git_branches</span><span>=</span><span>&#34;git branch --all --color \
</span></span></span><span><span><span>  --format=</span>$<span>&#39;%(HEAD) %(color:yellow)%(refname:short)\t%(color:green)%(committerdate:short)\t%(color:blue)%(subject)&#39; \
</span></span></span><span><span><span>  | column --table --separator=</span>$<span>&#39;\t&#39;&#34;</span> <span>\
</span></span></span><span><span><span></span><span>&amp;&amp;</span> <span>eval</span> <span>&#34;</span><span>$git_branches</span><span>&#34;</span> <span>\
</span></span></span><span><span><span></span><span>|</span> fzf <span>\
</span></span></span><span><span><span></span>  --ansi <span>\
</span></span></span><span><span><span></span>  --reverse <span>\
</span></span></span><span><span><span></span>  --no-sort <span>\
</span></span></span><span><span><span></span>  --preview-label<span>=</span><span>&#39;[ Commits ]&#39;</span> <span>\
</span></span></span><span><span><span></span>  --preview<span>=</span><span>&#39;git log $(echo {} \
</span></span></span><span><span><span>    | sed &#34;s/^[* ]*//&#34; \
</span></span></span><span><span><span>    | awk &#34;{print \$1}&#34;) \
</span></span></span><span><span><span>    --graph --color \
</span></span></span><span><span><span>    --format=&#34;%C(white)%h - %C(green)%cs - %C(blue)%s%C(red)%d&#34;&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;alt-c:execute(
</span></span></span><span><span><span>    git checkout $(echo {} \
</span></span></span><span><span><span>    | sed &#34;s/^[* ]*//&#34; \
</span></span></span><span><span><span>    | awk &#34;{print \$1}&#34;)
</span></span></span><span><span><span>    )&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#34;alt-c:+reload(</span><span>$git_branches</span><span>)&#34;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;alt-m:execute(git merge $(echo {} \
</span></span></span><span><span><span>    | sed &#34;s/^[* ]*//&#34; \
</span></span></span><span><span><span>    | awk &#34;{print \$1}&#34;)
</span></span></span><span><span><span>    )+abort&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;alt-r:execute(git rebase $(echo {} \
</span></span></span><span><span><span>    | sed &#34;s/^[* ]*//&#34; \
</span></span></span><span><span><span>    | awk &#34;{print \$1}&#34;)
</span></span></span><span><span><span>    )+abort&#39;</span> <span>\
</span></span></span><span><span><span></span>  --bind<span>=</span><span>&#39;enter:execute(
</span></span></span><span><span><span>    branch=$(echo {} \
</span></span></span><span><span><span>    | sed &#34;s/^[* ]*//&#34; \
</span></span></span><span><span><span>    | awk &#34;{print \$1}&#34;) \
</span></span></span><span><span><span>    &amp;&amp; sh -c &#34;git diff --color $branch | less -R&#34;
</span></span></span><span><span><span>    )&#39;</span> <span>\
</span></span></span><span><span><span></span>  --header-first <span>\
</span></span></span><span><span><span></span>  --header <span>&#39;
</span></span></span><span><span><span>  &gt; The branch marked with a star * is the current branch
</span></span></span><span><span><span>  &gt; ALT-C to checkout the branch
</span></span></span><span><span><span>  &gt; ALT-M to merge with current branch | ALT-R to rebase with current branch
</span></span></span><span><span><span>  &gt; ENTER to open the diff with less
</span></span></span><span><span><span>  &#39;</span>
</span></span></code></pre></div><p>You have now a good foundation to add anything you want. You could add a binding to run <code>git fetch</code> to get all the remote branches for example, or add another binding running <code>git branch --delete --force</code> to delete a remote branch. The sky’s the limit.</p><p>As always, there is a <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/guide-fzf-git/fzf_git_branches.sh" target="_blank" rel="noopener">final Bash script waiting for you</a>.</p><h2 id="vim-integration">Vim Integration</h2><p>What about having these nice interfaces directly in Vim? I already cover fzf integration with Vim <a href="https://thevaluable.dev/fzf-vim-integration/">in this article</a>.</p><p>For example, we could create a new scrim <code>fzf.vim</code> and source it in our vimrc. Here’s a simple fzf interface to stage files:</p><div><pre tabindex="0"><code data-lang="vim"><span><span><span>let</span> <span>s</span>:<span>git_unstaged</span><span>=</span><span>&#39;git ls-files --modified --deleted --other --exclude-standard --deduplicate $(git rev-parse --show-toplevel)&#39;</span><span>
</span></span></span><span><span><span></span><span>command</span><span>!</span> <span>-</span><span>bang</span> <span>GitAdd</span> <span>call</span> <span>fzf</span>#<span>run</span><span>(</span><span>fzf</span>#<span>wrap</span><span>(</span>{<span>
</span></span></span><span><span><span></span>    \ <span>&#39;source&#39;</span>: <span>s</span>:<span>git_unstaged</span><span>,</span><span>
</span></span></span><span><span><span></span>    \ <span>&#39;options&#39;</span>: [<span>
</span></span></span><span><span><span></span>        \ <span>&#39;--multi&#39;</span><span>,</span><span>
</span></span></span><span><span><span></span>        \ <span>&#39;--reverse&#39;</span><span>,</span><span>
</span></span></span><span><span><span></span>        \ <span>&#39;--no-sort&#39;</span><span>,</span><span>
</span></span></span><span><span><span></span>        \ <span>&#39;--prompt&#39;</span><span>,</span> <span>&#39;Add &gt; &#39;</span><span>,</span><span>
</span></span></span><span><span><span></span>        \ <span>&#39;--preview&#39;</span><span>,</span> <span>&#39;git status --short&#39;</span><span>,</span><span>
</span></span></span><span><span><span></span>        \ <span>&#39;--bind&#39;</span><span>,</span> <span>&#39;enter:execute(git add {+})&#39;</span><span>,</span><span>
</span></span></span><span><span><span></span>        \ <span>&#39;--bind&#39;</span><span>,</span> <span>&#39;enter:+reload(&#39;</span>.<span>s</span>:<span>git_unstaged</span>.<span>&#39;)&#39;</span><span>,</span><span>
</span></span></span><span><span><span></span>    \ ]}<span>))</span><span>
</span></span></span></code></pre></div><p>The prefix <code>s:</code> in Vimscript simply means that the scope of the variable is the current script only, to avoid conflicts with other variables having the same name.</p><h2 id="an-interface-to-merge-them-all">An Interface to Merge Them All</h2><p>As we saw in this article, using the advanced functionalities of fzf is not hard if we build our interfaces step by step. We can then craft powerful and customized tools directly in our comfy shell, without the need to program a full-blown TUI.</p><p>If you have other ideas to improve the functions we’ve written in this article, or if you want to share your own interfaces written with fzf, don’t hesitate to leave a comment. You know, sharing is caring!</p></section></article></div></div>
  </body>
</html>
