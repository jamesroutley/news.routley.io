<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://seri.tools/blog/castrol-honda-superbike/">Original</a>
    <h1>Why Castrol Honda Superbike crashes on (most) modern systems</h1>
    
    <div id="readability-page-1" class="page"><div><div><main><div><p>Posted: 2025-11-16</p><p>A friend cleaned up and gave me a copy of a game I&#39;ve not heard about before: <em>Castrol Honda Superbike World Champions</em>, a motorbike racing game for PC, released 1998 by Interactive Entertainment Ltd. and Midas Interactive Entertainment.</p><p><a title="Picture of the jewelcase" href="https://seri.tools/blog/castrol-honda-superbike/jewelcase.webp"> <img alt="Picture of the jewelcase" loading="lazy" src="https://seri.tools/blog/castrol-honda-superbike/jewelcase.webp" width="1024"/> </a></p><p>Given the age of the game (and looking at the system requirements) it&#39;s clear that the game comes from the tricky era of early 3D-accelerated PC gaming. For context, my copy of the game helpfully asks to install DirectX 5.</p><p>Before Windows was known for cramming AI and account requirements into every single corner of the system, no matter how unnecessary, it was known for its excellent backwards compatibility with older software. Generally, unless there are genuine bugs (and sometimes even despite them), Windows tries its hardest to run old applications correctly.</p><p>Pushing my luck and trying to run it on my Windows 7 machine, however, resulted in either a getting stuck on a black screen, or a crash, seemingly at random:</p><p><a title="Crash dialog from Windows 7: bike.exe has stopped working" href="https://seri.tools/blog/castrol-honda-superbike/crash.webp"> <img alt="Crash dialog from Windows 7: bike.exe has stopped working" loading="lazy" src="https://seri.tools/blog/castrol-honda-superbike/crash.webp" width="527"/> </a></p><p>Let&#39;s go back in time and see how far we need to go to get it running: Installing and running it on my Windows 98 and Windows XP machines was as uneventful, and the game works just fine, including with 3D acceleration. Glorious 1024x768x16:</p><p><a title="Screencap ingame" href="https://seri.tools/blog/castrol-honda-superbike/ingame.webp"> <img alt="Screencap ingame" loading="lazy" src="https://seri.tools/blog/castrol-honda-superbike/ingame.webp" width="1024"/> </a></p><h2 id="debugging-the-issue">Debugging the issue <a href="#debugging-the-issue">#</a></h2><p>Debugging is more fun than playing, so let&#39;s get started! :^)</p><p>I pulled over the installation directory to my main machine and ran <a href="https://github.com/horsicq/Detect-It-Easy">Detect It Easy</a> to see what we can learn about the executable:</p><p><a title="Screenshot of Detect It Easy with bike.exe loaded" href="https://seri.tools/blog/castrol-honda-superbike/die.webp"> <img alt="Screenshot of Detect It Easy with bike.exe loaded" loading="lazy" src="https://seri.tools/blog/castrol-honda-superbike/die.webp" width="1440"/> </a></p><p><code>Linker: Microsoft Linker(5.10)</code> and <code>Compiler: Microsoft Visual C/C++(...)[libcmtd]</code> are the interesting bits here. Notice how it&#39;s <code>libcmtd</code>, not <code>libcmt</code>? The binary is linked against the static <em>debug</em> version of VC5&#39;s runtime. The debug runtime has heaps of extra checks and <a href="https://learn.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-outputdebugstringa">logging</a>, which might help later.</p><p>Let&#39;s attach a debugger and see what&#39;s going on. Given that the game crashes very early on (before the credits intro screen), I hoped to see something right away. The cases where the game got stuck in a loop seemed to actually get stuck in some Windows API call stack.</p><p>Anyway, the cases where it crashed gave a clearer starting point:</p><p><a title="Stack trace from debugger" href="https://seri.tools/blog/castrol-honda-superbike/stack.webp"> <img alt="Stack trace from debugger" loading="lazy" src="https://seri.tools/blog/castrol-honda-superbike/stack.webp" width="821"/> </a></p><p>The game seems to be stuck after a call to DirectInput&#39;s <code>DirectInputCreateEx</code> function. At this point I started to do some static analysis of the functions leading to this call. While doing that I noticed that the game seems to have quite extensive logging, anything from game initialization to memory allocations.</p><blockquote><p>If you&#39;re interested in all the logs, here are the config settings to enable them all:</p><ul><li>In <code>Config.dat</code>, switch <code>ErrorLog</code>, <code>FileLog</code>, <code>MallocLog</code> from <code>off</code> to <code>on</code>. <ul><li>These are the &#34;normal&#34; log files the game produces.</li><li><code>ErrorLog</code> produces <code>error.log</code>, which is the general log file.</li><li><code>FileLog</code> produces <code>files.log</code>, tracking all opened files and their access modes.</li><li><code>MallocLog</code> produces <code>malloc.log</code>, tracking all memory allocations and frees. The devs even kept descriptions for every allocation site!</li></ul></li><li>Set an environment variable named <code>errorfile</code> to any file name (not path). The game will write logs to that file in the game directory. <ul><li>You might also need to create an empty <code>*.c</code> file in the game directory.</li><li>Just gives a bit of extra logging.</li></ul></li></ul><p>Bonus: add a setting named <code>windowed=true</code> to the config file to force windowed mode; only works correctly in 16-bit mode (garbled graphics in True Color).</p></blockquote><p>After enabling all the logging, I ran the game a few more times, and noticed that the last log messages in <code>error.log</code> before the crash were these:</p><pre><code><span>0&gt; Instance : Mouse
</span><span>0&gt; Product : Mouse
</span><span>1&gt; Instance : Keyboard
</span><span>1&gt; Product : Keyboard
</span><span>2&gt; Instance : Gaming Mouse G502
</span><span>2&gt; Product : Gaming Mouse G502
</span><span>3&gt; Instance : Gaming Mouse G502
</span><span>3&gt; Product : Gaming Mouse G502
</span><span>4&gt; Instance : Gaming Mouse G502
</span><span>4&gt; Product : Gaming Mouse G502
</span><span>5&gt; Instance : Gaming Mouse G502
</span><span>5&gt; Product : Gaming Mouse G502
</span><span>6&gt; Instance : USB Keyboard
</span><span>6&gt; Product : USB Keyboard
</span><span>7&gt; Instance : USB Keyboard
</span><span>7&gt; Product : USB Keyboard
</span><span>8&gt; Instance : LED Controller
</span><span>8&gt; Product : LED Controller
</span></code></pre><p>Great, the game is enumerating input devices— uh, why is there an &#34;LED Controller&#34; device? The motherboard in my Windows 7 machine has a built-in LED controller, so that checks out. Maybe the detection isn&#39;t working properly, and the game is trying to use it as an input device?</p><p>After disabling the LED controller in Device Manager, the game started up just fine, consistently! So far, so good. Of course I wanted to know what was actually going wrong, though, so let&#39;s see where these messages are printed.</p><h2 id="side-quest-cd-check">Side quest: CD check <a href="#side-quest-cd-check">#</a></h2><p>The game seemed to close without any notice if I forgot to insert the game disc. A quick trace showed that the <code>GibbonPosture</code> setting in <code>f1.cfg</code> is used to point to the disc drive from which the game was installed. The only check seems to be that the path <code>redist\dsetup.dll</code> exists on the disc. Copying the redist folder to the installation directory and changing the setting to <code>GibbonPosture=.\</code> seems to work just fine. :)</p><h2 id="the-bug">The bug <a href="#the-bug">#</a></h2><p>Finding the <code>Instance :</code> and <code>Product :</code> log messages in the binary was easy enough. They are referenced in only one function, which is a <a href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ee416622(v=vs.85)"><code>DIEnumDevicesCallback</code></a> callback function that is provided to <code>IDirectInput::EnumDevices</code> (Microsoft has only kept the documentation for the <a href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ee417804(v=vs.85)">DX8 version</a> of EnumDevices left online, but it&#39;s close enough).</p><p>This is the pseudocode of the call and the callback, and the relevant data structure:</p><pre data-lang="c"><code data-lang="c"><span>struct </span><span>DinputDeviceData
</span><span>{
</span><span>  </span><span>char</span><span> instance_name[</span><span>128</span><span>];
</span><span>  </span><span>char</span><span> product_name[</span><span>128</span><span>];
</span><span>  </span><span>DWORD</span><span> dwDevType;
</span><span>  GUID guid;
</span><span>};
</span><span>
</span><span>// ...
</span><span>
</span><span>BOOL</span><span> __stdcall </span><span>dinput_enumdevices_callback</span><span>(LPCDIDEVICEINSTANCEA </span><span>lpDevice</span><span>, </span><span>LPVOID </span><span>pvRef</span><span>)
</span><span>{
</span><span>    </span><span>int</span><span> index </span><span>=</span><span> g_dinput_device_index;
</span><span>    g_direct_input_devices[index].</span><span>guid </span><span>=</span><span> lpDevice-&gt;guidInstance;
</span><span>    </span><span>strcpy</span><span>(g_direct_input_devices[index].instance_name, lpDevice-&gt;tszInstanceName)</span><span>;
</span><span>    </span><span>strcpy</span><span>(g_direct_input_devices[index].product_name, lpDevice-&gt;tszProductName)</span><span>;
</span><span>    g_direct_input_devices[index].</span><span>dwDevType </span><span>=</span><span> lpDevice-&gt;dwDevType;
</span><span>
</span><span>    </span><span>log_line(</span><span>&#34;</span><span>%d</span><span>&gt; Instance : </span><span>%s</span><span>\n&#34;</span><span>, index, lpDevice-&gt;tszInstanceName)</span><span>;
</span><span>    </span><span>log_line(</span><span>&#34;</span><span>%d</span><span>&gt; Product : </span><span>%s</span><span>\n&#34;</span><span>, index, lpDevice-&gt;tszProductName)</span><span>;
</span><span>
</span><span>    </span><span>if </span><span>( </span><span>LOBYTE(g_direct_input_devices[index].dwDevType) </span><span>==</span><span> DIDEVTYPE_JOYSTICK )
</span><span>    {
</span><span>        </span><span>int</span><span> joystick_index </span><span>=</span><span> g_joystick_index;
</span><span>        g_joystick_info[joystick_index].</span><span>dinput_device_index </span><span>=</span><span> index;
</span><span>        g_joystick_info[joystick_index].</span><span>field_4 </span><span>= </span><span>0</span><span>;
</span><span>        g_joystick_info[joystick_index].</span><span>field_8 </span><span>= </span><span>0</span><span>;
</span><span>        g_joystick_info[joystick_index].</span><span>field_38 </span><span>= </span><span>0</span><span>;
</span><span>        g_joystick_info[joystick_index].</span><span>field_1 </span><span>= </span><span>0</span><span>;
</span><span>        g_joystick_index </span><span>=</span><span> joystick_index </span><span>+ </span><span>1</span><span>;
</span><span>    }
</span><span>    g_dinput_device_index </span><span>=</span><span> index </span><span>+ </span><span>1</span><span>;
</span><span>
</span><span>    </span><span>return</span><span> DIENUM_CONTINUE;
</span><span>}
</span><span>
</span><span>// ...
</span><span>
</span><span>g_dinput_create_hresult </span><span>= </span><span>DirectInputCreateA(hInstance, </span><span>0x500</span><span>u</span><span>, </span><span>&amp;</span><span>g_dinput_instance, </span><span>0</span><span>)</span><span>;
</span><span>g_dinput_device_index </span><span>= </span><span>0</span><span>;
</span><span>g_joystick_index </span><span>= </span><span>0</span><span>;
</span><span>g_dinput_instance-&gt;lpVtbl-&gt;</span><span>EnumDevices(
</span><span>    g_dinput_instance, </span><span>0</span><span>, dinput_enumdevices_callback, </span><span>0</span><span>, DIEDFL_ATTACHEDONLY)</span><span>;
</span></code></pre><p>So, for each enumerated device, the game stores some general information about it in the global array <code>g_direct_input_devices</code>. Then, if the device is a joystick (generally, a game controller), it also adds it to <code>g_joystick_info</code>.</p><p>Can you guess the bug yet? :) If not, here&#39;s the declaration of the global arrays:</p><pre data-lang="c"><code data-lang="c"><span>DinputDeviceData g_direct_input_devices[</span><span>8</span><span>];
</span><span>// ...
</span><span>JoystickInfo g_joystick_info[</span><span>8</span><span>];
</span></code></pre><p>There&#39;s only space for eight DirectInput devices in the array! <code>8&gt; Instance : LED Controller</code> was the ninth one, overwriting lots of important other data in the process, including timer handles and the actual DirectInput instance pointer.</p><p>But it gets worse: The game uses DirectInput for game controllers only. Copying the device info out of <code>lpDevice</code> is entirely pointless for other types of devices. Just moving the <code>DIDEVTYPE_JOYSTICK</code> check up would have hidden the bug for basically all setups, since you&#39;d have to have more than 8 game controllers connected for the game to write out of bounds.</p><p>Actually, there would&#39;ve been an even simpler workaround: <code>EnumDevices</code> allows passing a <code>DIDEVTYPE</code> as a filter:</p><pre data-lang="c"><code data-lang="c"><span>g_dinput_instance-&gt;lpVtbl-&gt;</span><span>EnumDevices(
</span><span>    g_dinput_instance, DIDEVTYPE_JOYSTICK, dinput_enumdevices_callback, </span><span>0</span><span>, DIEDFL_ATTACHEDONLY)</span><span>;
</span><span>                    </span><span>// ^^^^^^^^^^^^^^^^^^
</span></code></pre><p>This would make DirectInput call the callback for game controllers only. Without it, all devices, whether they are keyboards, mice, or actually any HID devices, are enumerated. (I&#39;ve checked the DirectX 5 SDK docs, and even there it mentions the HID device support.) This includes the vendor-defined devices of my mouse and its emulated keyboard (for macros), and of course the motherboard&#39;s LED controller.</p><p>The moral of the story? Always check your bounds, kids! You&#39;ll never know if some weirdo comes along and plugs in a dozen game controllers to their PC. :^)</p><h2 id="the-fix">The fix <a href="#the-fix">#</a></h2><p><a href="https://github.com/seritools/castrol-honda-dinput-fix">Over on GitHub</a> I&#39;ve pushed a minimal patch as a classic DLL shim. With the provided <code>dinput.dll</code> in the game directory, the game will load that instead of the system one. DirectInput has only one relevant exported function that we need to shim: <code>DirectInputCreateA</code>. The rest of the API is implemented via COM interfaces, for which we can modify the respective vtables as needed.</p><p>I&#39;ve implemented two fixes in the shim:</p><ol><li>Inject the <code>DIDEVTYPE_JOYSTICK</code> filter in the call to <code>EnumDevices</code> to only return joysticks/game controllers.</li><li>Cancel enumeration once 8 joysticks have been found.</li></ol><p>For fun, I&#39;ve also tried to minimize the size of the shim DLL -- the final binary weighs in at 2 KiB.</p><blockquote><p>These are the reasonable settings I changed:</p><ul><li>Compile with <code>opt-level = &#34;z&#34;</code> to optimize for minimum size. (though the code is so low-level that it&#39;s effectively the same as <code>opt-level = 3</code>)</li><li><code>#[no_std]</code> to avoid linking the Rust standard library.</li><li><code>codegen-units = 1</code> and <code>lto = true</code> to enable whole-program optimization.</li><li><code>panic = &#34;immediate-abort&#34;</code> to remove all unnecessary panic handling code; an unwrap will immediately abort the process.</li></ul><p>And these are the cursed ones:</p><ul><li><code>/NODEFAULTLIB</code> to not link against any MSVC runtime library; added my own minimal <code>DllMain</code>.</li><li><code>/FORCE:UNRESOLVED</code> to ignore the missing symbols for <code>_aullrem</code>, <code>_aulldiv</code>, and <code>_fltused</code>. We aren&#39;t using any of these, but the LLVM target still seems to insist on linking them in.</li><li><code>/FILEALIGN:512</code> to force the linker to use the minimum supported PE section alignment in the file.</li><li><code>/MERGE:.rdata=.text</code> merges the read-only data section into the code section.</li><li>Prevent zero-initialization of the system directory path by using <code>MaybeUninit</code>.</li><li>Storing globals in <code>static mut</code> just like the original game does. Since the fix is specific to this game I can do these &#34;global&#34; assumptions here :^) <ul><li>Ensure all globals are zero-initialized so the <code>.data</code> section is 0 bytes in the binary.</li></ul></li><li><code>.unwrap_unchecked()</code> to avoid any extra branches where they aren&#39;t needed.</li><li><code>/DEBUG:NONE</code> to not generate debug information, and not store a <code>.pdb</code> path in the binary.</li></ul></blockquote><p>Furthermore, I switched to <code>rust-lld.exe</code> as the linker, as it&#39;s fine with setting <code>/SUBSYSTEM:WINDOWS,4.0&#34;</code> and <code>/OSVERSION:4.0</code> without complaining. :) Since there is no linked runtime code at all, the resulting binary should work on any 32-bit Windows version, even without <a href="https://github.com/rust9x/rust/wiki">Rust9x</a>. I&#39;ve tested it on Windows 7 and Windows 98 SE.</p><p>Feel free to grab the compiled DLL from the <a href="https://github.com/seritools/castrol-honda-dinput-fix/releases">releases page</a>.</p></div></main></div></div></div>
  </body>
</html>
