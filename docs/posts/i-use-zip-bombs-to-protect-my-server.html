<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://idiallo.com/blog/zipbomb-protection">Original</a>
    <h1>I use zip bombs to protect my server</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody" id="articleBody">
	

<p>The majority of the traffic on the web is from bots. For the most part, these bots are used to discover new content. These are RSS Feed readers, search engines crawling your content, or nowadays AI bots crawling content to power LLMs. But then there are the malicious bots. These are from spammers, content scrapers or hackers. At my old employer, a bot discovered a wordpress vulnerability and inserted a malicious script into our server. It then turned the machine into a botnet used for DDOS. One of my first websites was yanked off of Google search entirely due to bots generating spam. At some point, I had to find a way to protect myself from these bots. That&#39;s when I started using zip bombs.</p>

<p>A zip bomb is a relatively small compressed file that can expand into a very large file that can overwhelm a machine. </p>

<p>A feature that was developed early on the web was compression with gzip. The Internet being slow and information being dense, the idea was to compress data as small as possible before transmitting it through the wire. So an 50 KB HTML file, composed of text, can be compressed to 10K, thus saving you 40KB in transmission. On dial up Internet, this meant downloading the page in 3 seconds instead of 12 seconds.</p>

<p>This same compression can be used to serve CSS, Javascript, or even images. Gzip is fast, simple and drastically improves the browsing experience. When a browser makes a web request, it includes the headers that signals the target server that it can support compression. And if the server also supports it, it will return a compressed version of the expected data.</p>

<pre><code>Accept-Encoding: gzip, deflate
</code></pre>

<p>Bots that crawl the web also support this feature. Especially since their job is to ingest data from all over the web, they maximize their bandwidth by using compression. And we can take full advantage of this feature. </p>

<p>On this blog, I often get bots that scan for security vulnerabilities, which I ignore for the most part. But when I detect that they are either trying to inject malicious attacks, or are probing for a response, I return a 200 OK response, and serve them a gzip response. I vary from a 1MB to 10MB file which they are happy to ingest. For the most part, when they do, I never hear from them again. Why? Well, that&#39;s because they crash right after ingesting the file.</p>

<pre><code>Content-Encoding: deflate, gzip
</code></pre>

<p>What happens is, they receive the file, read the header that instructs them that it is a compressed file. So they try to decompress the 1MB file to find whatever content they are looking for. But the file expands, and expands, and expands, until they run out of memory and their server crashes. The 1MB file decompresses into a 1GB. This is more than enough to break most bots. However, for those pesky scripts that won&#39;t stop, I serve them the 10MB file. This one decompresses into 10GB and instantly kills the script.</p>

<p>Before I tell you how to create a zip bomb, I do have to warn you that you can potentially crash and destroy your own device. Continue at your own risk. So here is how we create the zip bomb:</p>

<pre><code>dd if=/dev/zero bs=1G count=10 | gzip -c &gt; 10GB.gz
</code></pre>

<p>Here is what the command does:</p>

<ol>
<li><code>dd</code>: The dd command is used to copy or convert data. </li>
<li><code>if</code>: Input file, specifies <code>/dev/zero</code> a special file that produces an infinite stream of zero bytes. </li>
<li><code>bs</code>: block size, sets the block size to 1 gigabyte (1G), meaning dd will read and write data in chunks of 1 GB at a time.</li>
<li><code>count=10</code>: This tells dd to process 10 blocks, each 1 GB in size. So, this will generate 10 GB of zeroed data.</li>
</ol>

<p>We then pass the output of the command to gzip which will compress the output into the file 10GB.gz. The resulting file is 10MB in this case. </p>

<p>On my server, I&#39;ve added a middleware that checks if the current request is malicious or not. I have a list of black-listed ips that try to scan the whole website repeatedly. I have other heuristics in place to detect spammers. A lot of spammers attempt to spam a page, then come back to see if the spam has made it to the page. I use this pattern to detect them. It looks something like this:</p>

<pre><code>if (ipIsBlackListed() || isMalicious()) {
    header(&#34;Content-Encoding: deflate, gzip&#34;);
    header(&#34;Content-Length: &#34;+ filesize(ZIP_BOMB_FILE_10G)); // 10 MB
    readfile(ZIP_BOMB_FILE_10G);
    exit;
}
</code></pre>

<p>That&#39;s all it takes. The only price I pay is that I&#39;m serving a 10MB file now on some occasions. If I have an article going viral, I decrease it to the 1MB file, which is just as effective. </p>

<p>One more thing, a zip bomb is not foolproof. It can be easily detected and circumvented. You could partially read the content after all. But for unsophisticated bots that are blindly crawling the web disrupting servers, this is a good enough tool for protecting your server.</p>

<p>You can see it in action in <a href="https://idiallo.com/blog/surviving-the-hug-of-death">this replay of my server logs</a>.</p>

	<hr/>



	
	</div></div>
  </body>
</html>
