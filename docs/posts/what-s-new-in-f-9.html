<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://learn.microsoft.com/en-us/dotnet/fsharp/whats-new/fsharp-9">Original</a>
    <h1>What&#39;s New in F# 9</h1>
    
    <div id="readability-page-1" class="page">
	<div>
		<a href="#main" tabindex="1">Skip to main content</a>

		<div id="unsupported-browser" hidden="">
			<div>
				<p>This browser is no longer supported.</p>
				<p>Upgrade to Microsoft Edge to take advantage of the latest features, security updates, and technical support.</p>
				
			</div>
		</div>
		<!-- liquid-tag banners global -->

		<!-- site header -->
		<header id="ms--site-header" data-test-id="site-header-wrapper" role="banner" itemscope="itemscope" itemtype="http://schema.org/Organization">
			
			
			
		</header>
	</div>

	<div data-bi-name="body">

		<div><!-- .primary-holder -->
			<section>
				<!--div.columns -->
				<div><div id="main-column">

						<main id="main" role="main" data-bi-name="content" lang="en-us" dir="ltr"><!-- article-header -->
							
							<!-- end article-header --><!-- end mobile-contents button  -->

							<div><nav id="center-doc-outline" data-bi-name="intopic toc" aria-label="In this article">
											<h2 id="ms--in-this-article">In this article</h2>
										</nav><!-- <content> --><p>F# 9 introduces a range of enhancements that make your programs safer, more resilient, and performant. This article highlights the major changes in F# 9, developed in the <a href="https://github.com/dotnet/fsharp" data-linktype="external">F# open source code repository</a>.</p>
<p>F# 9 is available in .NET 9. You can download the latest .NET SDK from the <a href="https://dotnet.microsoft.com/download" data-linktype="external">.NET downloads page</a>.</p>
<h2 id="nullable-reference-types">Nullable reference types</h2>
<p>Although F# is designed to avoid <code>null</code>, it can creep in when interfacing with .NET libraries written in C#. F# now provides a type-safe way to deal with reference types that can have <code>null</code> as a valid value.</p>
<p>For more details, watch out for an <a href="https://devblogs.microsoft.com/dotnet/tag/f/" data-linktype="external">upcoming blog post about this feature</a>.</p>
<p>Here are some examples:</p>
<pre><code>// Declared type at let-binding
let notAValue: string | null = null

let isAValue: string | null = &#34;hello world&#34;

let isNotAValue2: string = null // gives a nullability warning

let getLength (x: string | null) = x.Length // gives a nullability warning since x is a nullable string

// Parameter to a function
let len (str: string | null) =
    match str with
    | null -&gt; -1
    | NonNull s -&gt; s.Length  // binds a non-null result

// Parameter to a function
let len (str: string | null) =
    let s = nullArgCheck &#34;str&#34; str // Returns a non-null string
    s.Length  // binds a non-null result

// Declared type at let-binding
let maybeAValue: string | null = hopefullyGetAString()

// Array type signature
let f (arr: (string | null)[]) = ()

// Generic code, note &#39;T must be constrained to be a reference type
let findOrNull (index: int) (list: &#39;T list) : &#39;T | null when &#39;T : not struct =
    match List.tryItem index list with
    | Some item -&gt; item
    | None -&gt; null
</code></pre>
<h2 id="discriminated-union-is-properties">Discriminated union <code>.Is*</code> properties</h2>
<p>Discriminated unions now have auto-generated properties for each case, allowing you to check if a value is of a particular case. For example, for the following type:</p>
<pre><code>type Contact =
    | Email of address: string
    | Phone of countryCode: int * number: string

type Person = { name: string; contact: Contact }
</code></pre>
<p>Previously, you had to write something like:</p>
<pre><code>let canSendEmailTo person =
    match person.contact with
    | Email _ -&gt; true
    | _ -&gt; false
</code></pre>
<p>Now, you can instead write:</p>
<pre><code>let canSendEmailTo person =
    person.contact.IsEmail
</code></pre>
<h2 id="partial-active-patterns-can-return-bool-instead-of-unit-option">Partial active patterns can return <code>bool</code> instead of <code>unit option</code></h2>
<p>Previously, partial active patterns returned <code>Some ()</code> to indicate a match and <code>None</code> otherwise. Now, they can also return <code>bool</code>.</p>
<p>For example, the active pattern for the following:</p>
<pre><code>match key with
| CaseInsensitive &#34;foo&#34; -&gt; ...
| CaseInsensitive &#34;bar&#34; -&gt; ...
</code></pre>
<p>Was previously written as:</p>
<pre><code>let (|CaseInsensitive|_|) (pattern: string) (value: string) =
    if String.Equals(value, pattern, StringComparison.OrdinalIgnoreCase) then
        Some ()
    else
        None
</code></pre>
<p>Now, you can instead write:</p>
<pre><code>let (|CaseInsensitive|_|) (pattern: string) (value: string) =
    String.Equals(value, pattern, StringComparison.OrdinalIgnoreCase)
</code></pre>
<h2 id="prefer-extension-methods-to-intrinsic-properties-when-arguments-are-provided">Prefer extension methods to intrinsic properties when arguments are provided</h2>
<p>To align with a pattern seen in some .NET libraries, where extension methods are defined with the same names as intrinsic properties of a type, F# now resolves these extension methods instead of failing the type check.</p>
<p>Example:</p>
<pre><code>type Foo() =
    member val X : int = 0 with get, set

[&lt;Extension&gt;]
type FooExt =
    [&lt;Extension&gt;]
    static member X (f: Foo, i: int) = f.X &lt;- i; f

let f = Foo()

f.X(1) // We can now call the extension method to set the property and chain further calls
</code></pre>
<h2 id="empty-bodied-computation-expressions">Empty-bodied computation expressions</h2>
<p>F# now supports empty <a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions" data-linktype="relative-path">computation expressions</a>.</p>
<pre><code>let xs = seq { } // Empty sequence
</code></pre>
<pre><code>let html =
    div {
        p { &#34;Some content.&#34; }
        p { } // Empty paragraph
    }
</code></pre>
<p>Writing an empty computation expression will result in a call to the computation expression builder&#39;s <code>Zero</code> method.</p>
<p>This is a more natural syntax compared to the previously available <code>builder { () }</code>.</p>
<h2 id="hash-directives-are-allowed-to-take-non-string-arguments">Hash directives are allowed to take non-string arguments</h2>
<p>Hash directives for the compiler previously only allowed string arguments passed in quotes. Now, they can take any type of argument.</p>
<p>Previously, you had:</p>
<pre><code>#nowarn &#34;0070&#34;
#time &#34;on&#34;
</code></pre>
<p>Now, you can write:</p>
<pre><code>#nowarn 0070
#time on
</code></pre>
<p>This also ties into the next two changes.</p>
<h2 id="extended-help-directive-in-fsi-to-show-documentation-in-the-repl">Extended #help directive in fsi to show documentation in the REPL</h2>
<p>The <code>#help</code> directive in F# Interactive now shows documentation for a given object or function, which you can now pass without quotes.</p>
<pre><code>&gt; #help List.map;;

Description:
Builds a new collection whose elements are the results of applying the given function
to each of the elements of the collection.

Parameters:
- mapping: The function to transform elements from the input list.
- list: The input list.
Returns:
The list of transformed elements.

Examples:
let inputs = [ &#34;a&#34;; &#34;bbb&#34;; &#34;cc&#34; ]

inputs |&gt; List.map (fun x -&gt; x.Length)
// Evaluates to [ 1; 3; 2 ]

Full name: Microsoft.FSharp.Collections.ListModule.map
Assembly: FSharp.Core.dll
</code></pre>
<p>See <a href="https://devblogs.microsoft.com/dotnet/enhancing-help-in-fsi/" data-linktype="external">Enhancing #help in F# Interactive blog post</a> for more details.</p>
<h2 id="allow-nowarn-to-support-the-fs-prefix-on-error-codes-to-disable-warnings">Allow #nowarn to support the FS prefix on error codes to disable warnings</h2>
<p>Previously, when you wanted to disable a warning and wrote <code>#nowarn &#34;FS0057&#34;</code>, you would get an <code>Invalid warning number &#39;FS0057&#39;</code>. Even though the warning number is correct, it just wasn&#39;t supposed to have the <code>FS</code> prefix.</p>
<p>Now, you won&#39;t have to spend time figuring that out because the warning numbers are accepted even with the prefix.</p>
<p>All of these will now work:</p>
<pre><code>#nowarn 57
#nowarn 0057
#nowarn FS0057

#nowarn &#34;57&#34;
#nowarn &#34;0057&#34;
#nowarn &#34;FS0057&#34;
</code></pre>
<p>It&#39;s a good idea to use the same style throughout your project.</p>
<h2 id="warning-about-tailcall-attribute-on-non-recursive-functions-or-let-bound-values">Warning about TailCall attribute on non-recursive functions or let-bound values</h2>
<p>F# now emits a warning when you put the <code>[&lt;TailCall&gt;]</code> attribute somewhere it doesn&#39;t belong. While it has no effect on what the code does, it could confuse someone reading it.</p>
<p>For example, these usages will now emit a warning:</p>
<pre><code>[&lt;TailCall&gt;]
let someNonRecFun x = x + x

[&lt;TailCall&gt;]
let someX = 23

[&lt;TailCall&gt;]
let rec someRecLetBoundValue = nameof(someRecLetBoundValue)
</code></pre>
<h2 id="enforce-attribute-targets">Enforce attribute targets</h2>
<p>The compiler now correctly enforces the <code>AttributeTargets</code> on let values, functions, union case declarations, implicit constructors, structs, and classes. This can prevent some hard-to-notice bugs, such as forgetting to add the unit argument to an Xunit test.</p>
<p>Previously, you could write:</p>
<pre><code>[&lt;Fact&gt;]
let ``this test always fails`` =
  Assert.True(false)
</code></pre>
<p>When you ran the tests with <code>dotnet test</code>, they would pass. Since the test function is not actually a function, it was ignored by the test runner.</p>
<p>Now, with correct attribute enforcement, you will get an <code>error FS0842: This attribute is not valid for use on this language element</code>.</p>
<h2 id="updates-to-the-standard-library-fsharpcore">Updates to the <a href="https://fsharp.github.io/fsharp-core-docs/" data-linktype="external">standard library (FSharp.Core)</a></h2>
<h3 id="random-functions-for-collections">Random functions for collections</h3>
<p>The <code>List</code>, <code>Array</code>, and <code>Seq</code> modules have new functions for random sampling and shuffling. This makes F# easier to use for common data science, machine learning, game development, and other scenarios where randomness is needed.</p>
<p>All functions have the following variants:</p>
<ul>
<li>One that uses an implicit, thread-safe, shared <a href="https://learn.microsoft.com/en-us/dotnet/api/system.random" data-linktype="absolute-path">Random</a> instance</li>
<li>One that takes a <code>Random</code> instance as an argument</li>
<li>One that takes a custom <code>randomizer</code> function, which should return a float value greater than or equal to 0.0 and less than 1.0</li>
</ul>
<p>There are four functions (each with three variants) available: <code>Shuffle</code>, <code>Choice</code>, <code>Choices</code>, and <code>Sample</code>.</p>
<h4 id="shuffle">Shuffle</h4>
<p>The <code>Shuffle</code> functions return a new collection of the same type and size, with each item in a randomly mixed position. The chance to end up in any position is weighted evenly on the length of the collection.</p>
<pre><code>let allPlayers = [ &#34;Alice&#34;; &#34;Bob&#34;; &#34;Charlie&#34;; &#34;Dave&#34; ]
let round1Order = allPlayers |&gt; List.randomShuffle // [ &#34;Charlie&#34;; &#34;Dave&#34;; &#34;Alice&#34;; &#34;Bob&#34; ]
</code></pre>
<p>For arrays, there are also <code>InPlace</code> variants that shuffle the items in the existing array instead of creating a new one.</p>
<h4 id="choice">Choice</h4>
<p>The <code>Choice</code> functions return a single random element from the given collection. The random choice is weighted evenly on the size of the collection.</p>
<pre><code>let allPlayers = [ &#34;Alice&#34;; &#34;Bob&#34;; &#34;Charlie&#34;; &#34;Dave&#34; ]
let randomPlayer = allPlayers |&gt; List.randomChoice // &#34;Charlie&#34;
</code></pre>
<h4 id="choices">Choices</h4>
<p>The <code>Choices</code> functions select N elements from the input collection in random order, allowing elements to be selected more than once.</p>
<pre><code>let weather = [ &#34;Raining&#34;; &#34;Sunny&#34;; &#34;Snowing&#34;; &#34;Windy&#34; ]
let forecastForNext3Days = weather |&gt; List.randomChoices 3 // [ &#34;Windy&#34;; &#34;Snowing&#34;; &#34;Windy&#34; ]
</code></pre>
<h4 id="sample">Sample</h4>
<p>The <code>Sample</code> functions select N elements from the input collection in random order, without allowing elements to be selected more than once. N cannot be greater than the collection length.</p>
<pre><code>let foods = [ &#34;Apple&#34;; &#34;Banana&#34;; &#34;Carrot&#34;; &#34;Donut&#34;; &#34;Egg&#34; ]
let today&#39;sMenu = foods |&gt; List.randomSample 3 // [ &#34;Donut&#34;; &#34;Apple&#34;; &#34;Egg&#34; ]
</code></pre>
<p>For a full list of functions and their variants, see (<a href="https://github.com/fsharp/fslang-design/blob/main/RFCs/FS-1135-random-functions-for-collections.md" data-linktype="external">RFC #1135</a>).</p>
<h3 id="parameterless-constructor-for-customoperationattribute">Parameterless constructor for <code>CustomOperationAttribute</code></h3>
<p>This constructor makes it easier to create a custom operation for a computation expression builder. It uses the name of the method instead of having to explicitly name it (when in most cases the name matches the method name already).</p>
<pre><code>type FooBuilder() =
    [&lt;CustomOperation&gt;]  // Previously had to be [&lt;CustomOperation(&#34;bar&#34;)&gt;]
    member _.bar(state) = state
</code></pre>
<h3 id="c-collection-expression-support-for-f-lists-and-sets">C# collection expression support for F# lists and sets</h3>
<p>When using F# lists and sets from C#, you can now use collection expressions to initialize them.</p>
<p>Instead of:</p>
<pre><code>FSharpSet&lt;int&gt; mySet = SetModule.FromArray([1, 2, 3]);
</code></pre>
<p>You can now write:</p>
<pre><code>FSharpSet&lt;int&gt; mySet = [ 1, 2, 3 ];
</code></pre>
<p>Collection expressions make it easier to use the F# immutable collections from C#. You might want to use the F# collections when you need their structural equality, which <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.immutable" data-linktype="absolute-path">System.Collections.Immutable</a> collections don&#39;t have.</p>
<h2 id="developer-productivity-improvements">Developer productivity improvements</h2>
<h3 id="parser-recovery">Parser recovery</h3>
<p>There have been continuous improvements in parser recovery, meaning that tooling (for example, syntax highlighting) still works with code when you&#39;re in the middle of editing it and it might not be syntactically correct at all times.</p>
<p>For example, the parser will now recover on unfinished <code>as</code> patterns, object expressions, enum case declarations, record declarations, complex primary constructor patterns, unresolved long identifiers, empty match clauses, missing union case fields, and missing union case field types.</p>
<h3 id="diagnostics">Diagnostics</h3>
<p>Diagnostics, or understanding what the compiler doesn&#39;t like about your code, are an important part of the user experience with F#. There are a number of new or improved diagnostic messages or more precise diagnostic locations in F# 9.</p>
<p>These include:</p>
<ul>
<li>Ambiguous override method in object expression</li>
<li>Abstract members when used in non-abstract classes</li>
<li>Property that has the same name as a discriminated union case</li>
<li>Active pattern argument count mismatch</li>
<li>Unions with duplicated fields</li>
<li>Using <code>use!</code> with <code>and!</code> in computation expressions</li>
</ul>
<p>There is also a new compile-time error for classes with over 65,520 methods in generated <a href="https://learn.microsoft.com/en-us/dotnet/standard/managed-code#intermediate-language--execution" data-linktype="relative-path">IL</a>. Such classes aren&#39;t loadable by the CLR and result in a run-time error. (You won&#39;t author that many methods, but there have been cases with generated code.)</p>
<h3 id="real-visibility">Real visibility</h3>
<p>There is a quirk with how F# generates assemblies that results in private members being written to <a href="https://learn.microsoft.com/en-us/dotnet/standard/managed-code#intermediate-language--execution" data-linktype="relative-path">IL</a> as internal. This allows inappropriate access to private members from non-F# projects that have access to an F# project via <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.internalsvisibletoattribute" data-linktype="absolute-path"><code>InternalsVisibleTo</code></a>.</p>
<p>Now, there is an opt-in fix for this behavior available via the <code>--realsig+</code> compiler flag. Try it in your solution to see if any of your projects depend on this behavior. You can add it to your <code>.fsproj</code> files like this:</p>
<pre><code>&lt;PropertyGroup&gt;
    &lt;RealSig&gt;true&lt;/RealSig&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<h2 id="performance-improvements">Performance improvements</h2>
<h3 id="optimized-equality-checks">Optimized equality checks</h3>
<p>Equality checks are now faster and allocate less memory.</p>
<p>For example:</p>
<pre><code>[&lt;Struct&gt;]
type MyId =
    val Id: int
    new id = { Id = id }

let ids = Array.init 1000 MyId
let missingId = MyId -1

// used to box 1000 times, doesn&#39;t box anymore
let _ = ids |&gt; Array.contains missingId
</code></pre>
<h4 id="benchmark-results-for-affected-array-functions-applied-to-a-2-member-struct">Benchmark results for affected array functions, applied to a 2-member struct</h4>
<p>Before:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Error</th>
<th>Gen0</th>
<th>Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayContainsExisting</td>
<td>15.48 ns</td>
<td>0.398 ns</td>
<td>0.0008</td>
<td>48 B</td>
</tr>
<tr>
<td>ArrayContainsNonexisting</td>
<td>5,190.95 ns</td>
<td>103.533 ns</td>
<td>0.3891</td>
<td>24000 B</td>
</tr>
<tr>
<td>ArrayExistsExisting</td>
<td>17.97 ns</td>
<td>0.389 ns</td>
<td>0.0012</td>
<td>72 B</td>
</tr>
<tr>
<td>ArrayExistsNonexisting</td>
<td>5,316.64 ns</td>
<td>103.776 ns</td>
<td>0.3891</td>
<td>24024 B</td>
</tr>
<tr>
<td>ArrayTryFindExisting</td>
<td>24.80 ns</td>
<td>0.554 ns</td>
<td>0.0015</td>
<td>96 B</td>
</tr>
<tr>
<td>ArrayTryFindNonexisting</td>
<td>5,139.58 ns</td>
<td>260.949 ns</td>
<td>0.3891</td>
<td>24024 B</td>
</tr>
<tr>
<td>ArrayTryFindIndexExisting</td>
<td>15.92 ns</td>
<td>0.526 ns</td>
<td>0.0015</td>
<td>96 B</td>
</tr>
<tr>
<td>ArrayTryFindIndexNonexisting</td>
<td>4,349.13 ns</td>
<td>100.750 ns</td>
<td>0.3891</td>
<td>24024 B</td>
</tr>
</tbody>
</table>
<p>After:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Error</th>
<th>Gen0</th>
<th>Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayContainsExisting</td>
<td>4.865 ns</td>
<td>0.3452 ns</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>ArrayContainsNonexisting</td>
<td>766.005 ns</td>
<td>15.2003 ns</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>ArrayExistsExisting</td>
<td>8.025 ns</td>
<td>0.1966 ns</td>
<td>0.0004</td>
<td>24 B</td>
</tr>
<tr>
<td>ArrayExistsNonexisting</td>
<td>834.811 ns</td>
<td>16.2784 ns</td>
<td>-</td>
<td>24 B</td>
</tr>
<tr>
<td>ArrayTryFindExisting</td>
<td>16.401 ns</td>
<td>0.3932 ns</td>
<td>0.0008</td>
<td>48 B</td>
</tr>
<tr>
<td>ArrayTryFindNonexisting</td>
<td>1,140.515 ns</td>
<td>22.7372 ns</td>
<td>-</td>
<td>24 B</td>
</tr>
<tr>
<td>ArrayTryFindIndexExisting</td>
<td>14.864 ns</td>
<td>0.3648 ns</td>
<td>0.0008</td>
<td>48 B</td>
</tr>
<tr>
<td>ArrayTryFindIndexNonexisting</td>
<td>990.028 ns</td>
<td>19.7157 ns</td>
<td>-</td>
<td>24 B</td>
</tr>
</tbody>
</table>
<p>You can read all the details here: <a href="https://devblogs.microsoft.com/dotnet/fsharp-developer-stories-how-weve-finally-fixed-a-9yearold-performance-issue/" data-linktype="external">F# Developer Stories: How we’ve finally fixed a 9-year-old performance issue</a>.</p>
<h3 id="field-sharing-for-struct-discriminated-unions">Field sharing for struct discriminated unions</h3>
<p>If fields in multiple cases of a struct discriminated union have the same name and type, they can share the same memory location, reducing the struct&#39;s memory footprint. (Previously, same field names weren&#39;t allowed, so there are no issues with binary compatibility.)</p>
<p>For example:</p>
<pre><code>[&lt;Struct&gt;]
type MyStructDU =
    | Length of int64&lt;meter&gt;
    | Time of int64&lt;second&gt;
    | Temperature of int64&lt;kelvin&gt;
    | Pressure of int64&lt;pascal&gt;
    | Abbrev of TypeAbbreviationForInt64
    | JustPlain of int64
    | MyUnit of int64&lt;MyUnit&gt;

sizeof&lt;MyStructDU&gt; // 16 bytes
</code></pre>
<p>Comparing to previous verion (where you had to use unique field names):</p>
<pre><code>[&lt;Struct&gt;]
type MyStructDU =
    | Length of length: int64&lt;meter&gt;
    | Time of time: int64&lt;second&gt;
    | Temperature of temperature: int64&lt;kelvin&gt;
    | Pressure of pressure: int64&lt;pascal&gt;
    | Abbrev of abbrev: TypeAbbreviationForInt64
    | JustPlain of plain: int64
    | MyUnit of myUnit: int64&lt;MyUnit&gt;

sizeof&lt;MyStructDU&gt; // 60 bytes
</code></pre>
<h3 id="integral-range-optimizations">Integral range optimizations</h3>
<p>The compiler now generates optimized code for more instances of <code>start..finish</code> and <code>start..step..finish</code> expressions. Previously, these were only optimized when the type was <code>int</code>/<code>int32</code> and the step was a constant <code>1</code> or <code>-1</code>. Other integral types and different step values used an inefficient <code>IEnumerable</code>-based implementation. Now, all of these are optimized.</p>
<p>This leads to anywhere from 1.25× up to 8× speed up in loops:</p>
<pre><code>for … in start..finish do …
</code></pre>
<p>List/array expressions:</p>
<pre><code>[start..step..finish]
</code></pre>
<p>and comprehensions:</p>
<pre><code>[for n in start..finish -&gt; f n]
</code></pre>
<h3 id="optimized-for-x-in-xs----in-list-and-array-comprehensions">Optimized <code>for x in xs -&gt; …</code> in list and array comprehensions</h3>
<p>On a related note, comprehensions with <code>for x in xs -&gt; …</code> have been optimized for lists and arrays, with notable improvements especially for arrays, with speedups up to 10× and ⅓ to ¼ allocation size.</p>

<h3 id="live-buffers-in-visual-studio">Live buffers in Visual Studio</h3>
<p>This previously opt-in feature has been thoroughly tested and is now enabled by default. The background compiler powering the IDE now works with live file buffers, meaning you don&#39;t have to save the files to disk to get the changes applied. Previously, this could cause some unexpected behavior. (Most notoriously when you tried to rename a symbol present in a file that had been edited but not saved.)</p>
<h3 id="analyzer-and-code-fix-for-removing-unnecessary-parentheses">Analyzer and code fix for removing unnecessary parentheses</h3>
<p>Sometimes extra parentheses are used for clarity, but sometimes they are just noise. For the latter case, you now get a code fix in Visual Studio to remove them.</p>
<p>For example:</p>
<pre><code>let f (x) = x // -&gt; let f x = x
let _ = (2 * 2) + 3 // -&gt; let _ = 2 * 2 + 3
</code></pre>
<h3 id="custom-visualizer-support-for-f-in-visual-studio">Custom visualizer support for F# in Visual Studio</h3>
<p>The debugger visualizer in Visual Studio now works with F# projects.</p>
<p><img src="https://learn.microsoft.com/en-us/dotnet/fsharp/media/whats-new/fsharp-9/vs-visualizer.gif" alt="debug visualizer" data-linktype="relative-path"/></p>
<h3 id="signature-tooltips-shown-mid-pipeline">Signature tooltips shown mid-pipeline</h3>
<p>Previously, signature help wasn&#39;t offered in a situation like the following, where a function in the middle of a pipeline already had a complex curried parameter (for example, a lambda) applied to it. Now, the signature tooltip shows up for the next parameter (<code>state</code>):</p>
<p><img src="https://learn.microsoft.com/en-us/dotnet/fsharp/media/whats-new/fsharp-9/help.png" alt="tooltip" data-linktype="relative-path"/></p>
</div>
							
							<!-- </content> -->

						</main><!-- recommendations section --><!-- end recommendations section -->

						<!-- feedback section --><section data-bi-name="open-source-feedback-section" data-open-source-feedback-section="" hidden="">
	<div>
		<div>
			<div>
				<div>
					<span aria-hidden="true">
						<span></span>
					</span>
					<span>Collaborate with us on GitHub</span>
				</div>
				<span>
					The source for this content can be found on GitHub, where you can also create and review issues and pull requests. For more information, see <a href="https://learn.microsoft.com/contribute/content/dotnet/dotnet-contribute">our contributor guide</a>.
				</span>
			</div>
		</div>
		
	</div>
</section><!-- end feedback section -->

						<!-- feedback report section --><!-- end feedback report section --></div><div id="ms--additional-resources" data-bi-name="pageactions" role="complementary" aria-label="Additional resources">
							<div id="affixed-right-container" data-bi-name="right-column">
								<h2 id="ms--additional-resources-heading" hidden="">Additional resources</h2>
								<section id="right-rail-events" data-bi-name="events-card" hidden=""></section>
								<section id="right-rail-training" data-bi-name="learning-resources-card" hidden=""></section>
								<section id="right-rail-recommendations" data-bi-name="recommendations" hidden=""></section>
								<nav id="side-doc-outline" data-bi-name="intopic toc" aria-label="In this article">
									<h3>In this article</h3>
								</nav>
								<section id="right-rail-qna" data-bi-name="qna-link-card" hidden=""></section>
							</div>
						</div></div>
				<!--end of div.columns -->

			</section>
			<!--end of .primary-holder -->

			<!-- interactive container -->
			
			<!-- end of interactive container -->
		</div>

	</div>
	<!--end of .mainContainer -->

	<section>

	</section>

	

</div>
  </body>
</html>
