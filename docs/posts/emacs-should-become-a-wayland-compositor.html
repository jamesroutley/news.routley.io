<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://emacsconf.org/2022/talks/wayland/">Original</a>
    <h1>Emacs should become a Wayland compositor</h1>
    
    <div id="readability-page-1" class="page"><div>
<div><p>A few days ago, I wrote an article about <a href="https://the.scapegoat.dev/why-i-am-learning-category-theory-1/">why I am learning category theory</a>, which made it to the Hacker News front page and thus put a lot of eyes on the article. I enjoy it when that happens because I know that there will be an active <a href="https://news.ycombinator.com/item?id=33802844">comment thread</a> with civil if often heated, debate. In this case, the discussion was fantastic, and I got many additional resources, links, and inspiration from the responses.</p>
<p>A few comments were, however, to the tenor of &#34;what does category theory bring me as a developer concretely,&#34; often also phrased as &#34;you should study X instead; it&#39;s much more concrete and applicable.&#34;</p>
<p>Questions like these are genuinely hard to answer because <strong>there is nothing I can point to in my programming that I could explain as coming from category theory</strong>. All the code I write is plain old design patterns (I work in a language that uses the vocabulary from category theory only to obfuscate things, vs., say, Haskell, where I could reuse type class machinery). These design patterns can be more easily studied independently or using concepts from algebra or analysis.</p>
<p>After a few discussions and continuing to very slowly read through Eugenia Cheng&#39;s &#34;The Joy of Abstraction&#34; (a fantastic book of crystal-clear simplicity, I wonder why I even write this blog post when I could point at the book), I think I can put into words what category theory brings to me as a developer and how it influences the way I program.</p>
<h2 id="category-theory-the-final-step-in-the-abstraction-ladder">Category theory, the final step in the abstraction ladder</h2>
<p>Category theory is less about being a &#34;productive&#34; version of mathematics, full of insights and theorems and proving novel properties about things, and more about providing a framework that allows us to be abstract all the other mathematical objects that diverse disciplines study into &#34;simpler&#34; objects.</p>
<p>Computers are ultimately mathematical machines, and every aspect of writing software and running software (think distributed systems, CPU caches, operating systems, not just lambda calculus) can be considered mathematical objects.</p>
<p>If we consider abstraction to be a ladder with many levels, where each level simplifies (or &#34;erases&#34;) details of the levels below to expose their commonalities, category theory tries to position itself at the highest level. Categories form a category (or many categories) as well. Every time we form a new abstraction within the language of category theory, we can immediately move on to abstracting said new abstraction.</p>
<p><strong>It&#39;s abstraction all the way up, dude.</strong></p>
<h2 id="abstraction-the-intangible-beast">Abstraction, the intangible beast</h2>
<p>I have a hard time thinking about abstraction. As cognitive animals, we are designed to be abstraction machines. The natural world is infinitely complex, and it needs to be broken down into &#34;simpler&#34; (more abstract) concepts for our brains to reason about it.</p>
<p>I am not even an amateur neuroscientist, but I think it&#39;s probable that there is a difference between reasoning (carefully working things out) and intuiting (having a gut feeling or intuition about something). While reasoning requires us to abstract things, intuition is a much more diffuse thinking mode where the bandwidth from the natural world to cognition is potentially much broader. Intuition is fast, and reasoning is slow (these are ideas lifted from &#34;Thinking fast and slow&#34; by Daniel Kahneman.)</p>
<p><strong>To turn slow thinking into fast thinking, abstractions need to be internalized. And once they are internalized, we cease to be conscious that we are working with abstractions</strong>. After all, our thinking is now intuitive and fast. We spend so much time learning to speak, to count, and as developers, what a function and a variable are, how HTTP works—yet these concepts are almost invisible to us once acquired. Of course, we speak words and form sentences. Of course, we use variables to store values. Of course, 1 + 1 = 2. Of course, HTTP GET 200.</p>
<h2 id="category-theory-as-deliberate-practice-for-abstraction">Category theory as deliberate practice for abstraction</h2>
<p>I like the act of forming abstractions and working with them until they become intuitive. <strong>Abstraction is why I am drawn to computers</strong>: I love seeing how things that seem different or tedious can be reformulated in a much more straightforward manner yet work just as well (or better). I love legacy software and extracting its inner meaning and cleaning it up, leaving the areas that can be messy and focusing on its foundational abstractions.</p>
<p>I spent a lot of time learning about many different abstractions. The easiest and most gratifying way for me is to learn other programming languages and write actual, big, real-world systems with them. The next best way is to learn some mathematics. But it wasn&#39;t until I started digging deeper into category theory that I realized all these things were about discovering and refining abstractions. <strong>Similar to how a musician practices their instrument (playing scales, trying out new fingerings, using a metronome), this is what category theory is for me: an instrument to do deliberate abstraction practice.</strong></p>
<p>Abstraction is a two-edged sword. It makes the world simpler once the abstraction has been well understood (when it can be intuited). But getting to that point requires a lot of effort—we often forget how much effort since its very goal is to make thinking effortless. <strong>Speaking in the language of abstraction makes it easy to exchange complex ideas, but it also makes it easy to alienate people who haven&#39;t formed the same abstractions.</strong></p>
<p>Furthermore, abstraction is just that: abstract. <strong>Abstraction can&#39;t directly be applied to something concrete and, as such, can never stand on its own.</strong> I can intuit that a sewage system is just a series of connected pipes and is thus very similar to the internet, I&#39;ll still have to learn how to change an O-ring if I want to stop my tap from leaking, and all my networking knowledge won&#39;t stop me from fucking it up either. However, I might very well be able to provide some thoughtful advice about where a lack of pressure might be coming from since I have a good grasp of bandwidth, back pressure, and other concepts (no idea if this makes any sense because I have no idea how plumbing works, but it sounds cool).</p>
<h2 id="why-people-think-abstraction-is-useless">Why people think abstraction is useless</h2>
<p>I think so many people believe that learning more abstract things is useless because they haven&#39;t realized that all the things they know were abstract to them at some point. Because learning is rarely framed as &#34;learning an abstraction for X, as well as its practical application&#34; and instead just called &#34;learning X,&#34; it causes people to write responses such as &#34;you could learn all this from Y instead,&#34; where Y is a lower rung on the ladder of abstraction (say, abstract algebra, or software design patterns, or &#34;just write some CRUD code, who needs that fancy stuff anyway&#34;).</p>
<p>These people learned X, internalized its abstractions, and think that&#39;s all there is to it because, after all, they can get their work done just fine. This kind of anti-intellectualism (<strong>because I think it is anti-intellectual to tell other people not to engage in whatever tickles their interest because it is &#34;useless.&#34; Things are only useless to the person that has no use for them, and what is joy if not something useful</strong>) stems from not having been exposed to the idea that abstraction is a ladder that can be climbed at different speeds and to different heights, that some people genuinely enjoy working at more lofty heights, and that everybody needs to come down to get real work done.</p>
<p><strong>I love category theory because it makes my abstraction muscles stronger.</strong> This means that I can make the world I work with (software, computers, networks) simpler by stirring it all into one giant &#34;everything is just a monad, yo&#34; melting pot, and then, through sheer professional practice and muscle memory, bring it back to the real world and write it down as a line of ugly PHP.</p>
<p>The PHP I write today solves the same problem that I used to solve 20 years ago: a user sends a request, I transform their request into some query to storage, and I return the result and handle errors while doing so.</p>
<p>The value of category theory is that I find more and more ways to break down an absurd variety of problems to exactly that formulation: <code>response = lookup(request)</code>. It doesn&#39;t teach me anything about what <code>response</code> or <code>=</code> or <code>lookup</code> or <code>request</code> or <code>()</code> is, I need to work these things out using other resources (and often just writing a lot of code).</p>
<p>That the formulation doesn&#39;t tell me anything about how it works in the real world is precisely why category theory looks both trivial and is so helpful. It means I can forget all the detail and form a naive, simple, intuitive understanding of what works and what doesn&#39;t.</p>
</div>
</div></div>
  </body>
</html>
