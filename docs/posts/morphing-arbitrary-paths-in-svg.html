<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://minus-ze.ro/posts/morphing-arbitrary-paths-in-svg/">Original</a>
    <h1>Morphing Arbitrary Paths in SVG</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<article>
    
<p>
<svg id="showcaseMorph0" width="100%" viewBox="0 0 100 100">
  <defs>
    <pattern id="grid" viewBox="0 0 10 10" width="5%" height="5%">
      <polygon points="0 0, 10 0, 10 10, 0 10" fill="var(--bg)" stroke-width="0.05" stroke="var(--fg)"></polygon>
    </pattern>
  </defs>
  <rect x="0" y="0" width="100" height="100" fill="var(--bg)"></rect>
</svg>
<svg id="showcaseMorph1" width="100%" viewBox="-5 0 33 22"></svg>
<svg id="showcaseMorph2" width="100%" viewBox="-5 2 32 20"></svg>
<svg id="showcaseMorph3" width="100%" viewBox="-120 0 750 500"></svg>
<svg id="showcaseMorph4" width="100%" viewBox="-100 28 705 460"></svg>
<svg id="showcaseMorph5" width="100%" viewBox="-150 0 780 500"></svg>
<svg id="showcaseMorph6" width="100%" viewBox="-4 0 30 30"></svg>
<svg id="showcaseMorph7" width="100%" viewBox="0 0 515 330">&gt;</svg>
<svg id="showcaseMorph8" width="100%" viewBox="0 0 10 10"></svg>
</p>

<p>All the animations that you can see above have been created at page load automatically. I copied some paths from <a href="https://www.svgrepo.com">SVG Repo</a>, plugged them into a function that converts the paths so that they can be morphed, and then I set the SMIL animations properly. If you want to quickly test your own paths and see the generated SVG yourself, go <a href="#interactive-demo">near the end of this page</a> for an interactive demo.</p>
<p>Paths in SVG can already be morphed with <code>&lt;animate&gt;</code> for the <code>&#39;d&#39;</code> attribute. The catch is that the paths need to have exactly the same number of points and the drawing commands need to be of exactly the same type. You can’t morph a line into a curve, for example.</p>
<p>There are existing solutions for this, like <a href="https://gsap.com/docs/v3/Plugins/MorphSVGPlugin/">GSAP</a>, <a href="https://notoriousb1t.github.io/polymorph-docs/">Polymorph</a> or others. They are likely more robust than what I have made here, and I believe that they are the best solution if you have SVGs that you want to process on demand.</p>
<p>I’d argue, however, that the more common use case is having some existing paths that you want to morph. In that case, you don’t really need a big JS library loaded at runtime, and you can just generate the animations beforehand. And in this blog post I want to explain how that can be achieved.</p>
<p>You can always look at the <a href="https://minus-ze.ro/svg-morph-code.js">code</a> of this post which includes all the important implementation details. Though I’ll note that it came out a bit uglier than what I would’ve wanted.</p>

<p>Given the limitations that I’ve described above, what can we do so that we can morph two arbitrary paths? The first obvious solution is to manually match the graphics elements of both paths. This could be done in a vector graphics editor, though it’s a relatively elaborate process. This can work when you already have morphing working, but you want to tweak the looks of the animation, and you modify the paths a bit. But doing this to achieve morphing in the first place can take quite a lot of time, and I personally would not recommend it.</p>
<p>Another option is do what we would’ve manually done by matching both paths to be of the same structure, but programmatically. Let’s find out how we can do that.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d">Paths in SVG</a> are strings that contain many drawing commands. A drawing command is one of <code>M, L, H, V, Q, T, C, S, A, Z</code> (with lowercase alternatives for relative paths). It’s as if you have a pen that you move on the screen. Let’s take an example:</p>
<pre tabindex="0"><code>M20 80 L80 80 Q100 0,50 20 C0 0,0 100,20 80Z
</code></pre><ul>
<li>We <code>move to</code> (<code>M</code>) the point <code>(20, 80)</code>. A new path is created, and the current point is now <code>(20, 80)</code>.</li>
<li>We then draw a <code>line to</code> (<code>L</code>) to the point <code>(80, 80)</code>. The current point becomes <code>(80, 80)</code>.</li>
<li>Now we draw a quadratic <a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">Bézier curve</a> with control point <code>(100, 0)</code> to <code>(50, 20)</code>. The current point becomes <code>(50, 20)</code>.</li>
<li>We then draw a cubic Bézier curve (<code>Q</code>) with control points <code>(0, 0)</code> and <code>(100, 20)</code> to <code>(20, 80)</code>. The current point is <code>(20, 80)</code>, back where we started.</li>
<li>At last, we close the path with <code>Z</code>. This command draws a line from the current point to the starting point of the path. Technically the path is already closed in our case because we finished drawing at the point where we started, but you should still close the path with <code>Z</code> if you want your path to be filled. If you only want the path to be stroked, you don’t have to close it.</li>
</ul>
<p>It’s quite difficult to work with paths by hand, but it’s still important to know what they mean in order to understand the rest of the post. If you want to play around with paths, I strongly recommend you use <a href="https://yqnn.github.io/svg-path-editor/">this path editor</a>. If you want a more interactive guide on paths, check <a href="https://svg-path-visualizer.netlify.app/">this</a> visualizer out.</p>
<p>So we have two paths that we want to morph between, and now we know how these paths are built. It’s not immediately apparent, but we can match paths to be of the same structure to allow morphing with <code>&lt;animate&gt;</code> by converting every drawing command to a common primitive, for both paths. Then the task transforms into splitting as many primitives as needed so that we can match the number of points between the paths.</p>
<p>The primitive that I’ll choose for implementation is the cubic Bézier curve. It’s powerful enough to represent exactly all other drawing commands except one, that I’ll explain later. It’s also trivial to split into multiple sub-curves. As far as I know, it’s pretty much what GSAP does as well.</p>

<p>To convert a path into one that only contains <code>C</code> drawing commands, we’ll first have to parse it. Unfortunately I haven’t found an API in the browser (that’s not deprecated) which can iterate through drawing commands of a path. So I approached this the hard way and <a href="https://github.com/AlexandruIca/svg-path-parser">wrote a parser</a> for SVG paths. There are existing solutions already, but I wanted a parser that does not validate the path itself (things like starting with an <code>M</code> command) and does not alter the input commands. I wanted to implement something that tries to draw things even if the path might not be fully correct according the <a href="https://www.w3.org/TR/SVG2/paths.html">spec</a>.</p>
<h2 id="normalizing-paths">“Normalizing” Paths</h2>
<p>To make our lives easier, we can first get rid of the graphics primitives that are duplicates of others. By this I mean:</p>
<ul>
<li>Converting all relative commands to absolute ones.</li>
<li>Converting <code>H</code> and <code>V</code> to <code>L</code> commands.</li>
<li>Converting <code>T</code> to <code>Q</code>.</li>
<li>Converting <code>S</code> to <code>C</code>.</li>
</ul>
<p>This will mean a bit of duplication of points, but it’s a pragmatic trade-off which will make the implementation much easier. I don’t know if “normalization” is a good term for this, but I couldn’t think of a better one.</p>
<p>Converting relative commands to absolute ones is trivial. We need to interate through the commands, and whenever a relative command is met, we need to add the coordinates to the current point, instead of simply assigning them.</p>
<p><code>H</code> and <code>V</code> mean “<code>horizontal to</code>” and “<code>vertical to</code>”, so it’s trivial to convert them into lines. Converting <code>T</code> to <code>Q</code> is not difficult. When we iterate through the commands, we need to keep the last two points of the last quadratic we’ve seen. Having those points (let’s call them \(control\) and \(end\)), what we need to do is to mirror \(control\) to the other side of \(end\). If no quadratic was seen before, we can consider both of these points to be equal to the current point.</p>
<p>We can mirror a point on a line easily and intuitively by making use of the parametric form of a line that goes between point \(A\) and \(B\):</p>
\[A + t (B - A)\]
<p>Where \(t\) goes from \(0.0\) to \(1.0\). To mirror \(A\) on the other side of \(B\) we can give \(t\) the value of \(2.0\), and we get our mirrored point. We do that for our \(control\) and \(end\) and we can now find out the new control point of the curve. Thus we can convert <code>T</code> to <code>Q</code>.</p>
<p><code>S</code> can be converted in the exact same way, the only difference being that we need to keep the last to points of the last <em>cubic</em> that we’ve seen, instead of the last quadratic.</p>
<h2 id="converting-lines-to-cubics">Converting Lines To Cubics</h2>
<p>Now that we only have <code>M, L, Q, C, A</code> commands, we can start converting everything to cubics. The easiest primitive to convert is the line. Using the line expression describe above, to convert a line to a cubic curve: we consider the start and end points of the curve to be the same as the start and end points of the line, and the control points can be obtained by giving \(t\) values of \(\frac{1}{3}\) and \(\frac{2}{3}\).</p>
<h2 id="converting-quadratics-to-cubics">Converting Quadratics To Cubics</h2>
<p>Thankfully Bézier curves can be raised to a higher degree without any loss of precision. For quadratics, we can consider their construction:</p>
\[B(t) = (1-t)^2 P_0 + 2t(1 - t)P_1 + t^2 P_2\]
<p>Where \(t\) goes, again, from \(0.0\) to \(1.0\). To elevate its degree, we can rewrite it using a basic trick:</p>
\[B(t) = (1-t) B(t) + t B(t)\]
<p>With this, we can now obtain the same quadratic but with a third-degree term. By comparing it with the original form, we can obtain the control points for our cubic (the start and end points remain the same as the quadratic). They are:</p>
\[C_0 = \frac{1}{3} (P_0 + 2P_1)\]
\[C_1 = \frac{1}{3} (2P_1 + P_2)\]
<svg id="quadratic" width="100%" viewBox="0 0 100 100">
  <rect x="0" y="0" width="100" height="100" fill="url(#grid)"></rect>
  <path id="quadraticCtrl" d="M20 80 L50 20 L80 80" stroke="var(--fg)" stroke-width="1" fill="transparent" stroke-linejoin="round" stroke-linecap="round"></path>
  <path id="quadraticCubicCtrl" d="M20 80 C50 20,50 20,80 80" stroke="#ab7f50" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" fill="transparent"></path>
  <path id="quadraticCubic" d="M20 80 C50 20,50 20,80 80" stroke="#54AAFF" stroke-width="1.5" fill="transparent" stroke-linejoin="round" stroke-linecap="round"></path>
  <circle cx="20" cy="80" r="2" fill="var(--fg)" id="quadp0"></circle>
  <circle cx="50" cy="20" r="2" fill="var(--fg)" id="quadp1"></circle>
  <circle cx="80" cy="80" r="2" fill="var(--fg)" id="quadp2"></circle>
</svg>
<h2 id="converting-arcs-to-cubics">Converting Arcs To Cubics</h2>
<p>The one primitive that can’t be fully represented by a cubic is the <code>A</code> command. This command draws an elliptical arc, which <a href="https://pomax.github.io/bezierinfo/#circles">Bézier curves are not able to represent exactly</a>, but they are pretty good at approximating it. So what we <em>can</em> do is approximate an arc with multiple cubics, and this will make it impossible for the user to notice that it’s not actually a real arc.</p>
<p>I’ve already shown how arcs can be converted to cubics in <a href="https://minus-ze.ro/posts/flattening-bezier-curves-and-arcs/">my previous post</a>, but the idea is to approximate arcs no longer than \(\frac{\pi}{4}\) on the unit circle, and scaling them back to the original ellipse.</p>
<p>All of these conversion steps can be merged into the “normalization” step, as it’s relatively easy to combine them once you have the conversion functions implemented.</p>
<h2 id="a-note-on-m-and-z">A Note On <code>M</code> and <code>Z</code></h2>
<p>It’s important to keep these in our new path, as we will need to know when a new path has started, or when an existing path has ended. This is because a path can have multiple sub-paths, and it’s important to take this into account. We won’t be able to morph properly if one command contains a <code>Z</code> in the middle, while the other path doesn’t contain the <code>Z</code> in the exact same place.</p>

<p>So now we have two paths that we have “normalized”, and converted to a series of cubics, we can proceed to split the cubics as needed so that we can match the number of points between our paths.</p>
<p>Before doing that though, we have to take care of the case where there are multiple sub-paths in a path. We need to extract all sub-paths for both of our paths, and then work with those directly.</p>
<h2 id="splitting-sub-paths">Splitting Sub-Paths</h2>
<p>Let’s take an example (the paths would be converted to cubics by this point, but I’m keeping the example simple):</p>
<pre tabindex="0"><code>M0 0 L5 10 L10 0Z M3 6 L7 6 L5 4Z

M0 5 L5 5 L2.5 0Z M5 10 L7 5 L3 5Z M5 5 L10 5 L7.5 0Z
</code></pre><p>The first path contains two sub-paths, and the second one contains three sub-paths. Remember that <code>Z</code> commands need to be placed at exactly the same places in both paths so that morphing can work. This means that we can’t directly morph between these two paths, even after we convert them to cubics. It might be easy to make it work by tweaking the paths in this case, but for more complex paths that will quickly become unfeasible. We’ll have to create multiple morph animations in parallel to make it work properly. And of course, paths may have many more sub-paths than in this example.</p>
<svg width="100%" viewBox="0 0 100 20">
  
  <path fill="var(--bg)" stroke="var(--fg)" stroke-width="1" d="M1 1 H25 V9 H1Z M25 1 H50 V9 H25Z M50 1 H62.5 V9 H50Z M62.5 1 H99 V9 H62.5Z      M1 9 H12.5 V18 H1Z M12.5 9 H25 V18 H12.5Z M25 9 H37.5 V18 H25Z M37.5 9 H50 V18 H37.5Z M50 9 H62.5 V18 H50Z M62.5 9 H75 V18 H62.5Z M75 9 H87.5 V18 H75Z M87.5 9 H99 V18 H87.5Z"></path>
  <text x="10" y="5.5">A</text>
  <text x="35" y="5.5">A</text>
  <text x="54" y="5.5">...</text>
  <text x="79" y="5.5">A</text>
  <text x="5" y="14">B</text>
  <text x="16.5" y="14">B</text>
  <text x="29" y="14">B</text>
  <text x="41.5" y="14">B</text>
  <text x="54" y="14">...</text>
  <text x="66.5" y="14">B</text>
  <text x="79" y="14">B</text>
  <text x="91" y="14">B</text>
</svg>
<p>I hope this illustration is intuitive: when the number of sub-paths differ, we make some parallel animations to achieve the morphing effect. For example, if A had 3 sub-paths and B had 7, for every sub-path of A we would morph two sub-paths of B in parallel into it. Since 7 divided by 3 has the remainder of 1, we would include that remainder in the last sub-path of A. Of course the process can be done in the other direction too.</p>
<p>Note that this trick of using multiple animations to the same path might affect the results if transparency is involved. In SVG, since we generate multiple animations, we can set the animation for the <code>fill</code> attribute to come to a zero opacity value whenever we want to avoid unwanted transparency effects, on any path that we need. It’s not a perfect solution, but it should work well enough for a lot of cases.</p>
<p>Multiple morphs into the same path might also be vulnerable to <a href="https://github.com/ruffle-rs/ruffle/issues/26">conflation artifacts</a>. In my experience it shouldn’t affect the result <em>too much</em>, but your mileage may vary. Animating the fill to become transparent, as explained above, should also be able to avoid this.</p>
<h2 id="matching-points-between-sub-paths">Matching Points Between Sub-Paths</h2>
<p>Now that we have a way of working with only two sub-paths at a time, we can finally process them to make sure we can obtain two paths that have the same number of <code>C</code> commands. Remember that by this point, our paths have already been converted to cubics.</p>
<p>We can apply an identical approach as we’ve done for splitting sub-paths, and simply look at the path with the smaller number of curves. For each curve, we would split it until it matches the number of cubics in the second path.</p>
<p>If we consider the same illustration as we’ve seen when we split the sub-paths, we could consider that A has three cubics, while B has seven. For every cubic of A, we would split it into two cubics to match what B has. The last cubic would be split into three.</p>
<h2 id="splitting-a-cubic">Splitting A Cubic</h2>
<p>How exactly can a cubic curve be split into multiple sub-curves? The answer is: <a href="https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm">De Casteljau</a> subdivision. We can make use of the fact that cubics are nothing more that a series of line interpolations. When computing the point at a \(t\) value on the curve, we can use the intermediate results of interpolations to construct two separate cubics which form the big cubic.</p>
<div><pre tabindex="0"><code data-lang="js"><span><span><span>function</span> <span>lineAt</span>(<span>p0</span>, <span>p1</span>, <span>t</span>) {
</span></span><span><span>  <span>return</span> {
</span></span><span><span>    <span>x</span><span>:</span> <span>p0</span>.<span>x</span> <span>+</span> <span>t</span> <span>*</span> (<span>p1</span>.<span>x</span> <span>-</span> <span>p0</span>.<span>x</span>),
</span></span><span><span>    <span>y</span><span>:</span> <span>p0</span>.<span>y</span> <span>+</span> <span>t</span> <span>*</span> (<span>p1</span>.<span>y</span> <span>-</span> <span>p0</span>.<span>y</span>),
</span></span><span><span>  };
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>function</span> <span>splitCubic</span>(<span>p0</span>, <span>p1</span>, <span>p2</span>, <span>p3</span>, <span>t</span>) {
</span></span><span><span>  <span>const</span> <span>p01</span> <span>=</span> <span>lineAt</span>(<span>p0</span>, <span>p1</span>, <span>t</span>);
</span></span><span><span>  <span>const</span> <span>p12</span> <span>=</span> <span>lineAt</span>(<span>p1</span>, <span>p2</span>, <span>t</span>);
</span></span><span><span>  <span>const</span> <span>p23</span> <span>=</span> <span>lineAt</span>(<span>p2</span>, <span>p3</span>, <span>t</span>);
</span></span><span><span>  <span>const</span> <span>c0</span> <span>=</span> <span>lineAt</span>(<span>p01</span>, <span>p12</span>, <span>t</span>);
</span></span><span><span>  <span>const</span> <span>c1</span> <span>=</span> <span>lineAt</span>(<span>p12</span>, <span>p23</span>, <span>t</span>);
</span></span><span><span>  <span>const</span> <span>p</span> <span>=</span> <span>lineAt</span>(<span>c0</span>, <span>c1</span>, <span>t</span>);
</span></span><span><span>
</span></span><span><span>  <span>return</span> [
</span></span><span><span>    { <span>p0</span><span>:</span> <span>p0</span>, <span>p1</span><span>:</span> <span>p01</span>, <span>p2</span><span>:</span> <span>c0</span>, <span>p3</span><span>:</span> <span>p</span> },
</span></span><span><span>    { <span>p0</span><span>:</span> <span>p</span>, <span>p1</span><span>:</span> <span>c1</span>, <span>p2</span><span>:</span> <span>p23</span>, <span>p3</span><span>:</span> <span>p3</span> },
</span></span><span><span>  ];
</span></span><span><span>}
</span></span></code></pre></div><p>With this function we can split a cubic in two at any \(t\) value. To split a curve into as many equally-sized smaller cubics as we want, we can call this repeatedly:</p>
<div><pre tabindex="0"><code data-lang="js"><span><span><span>function</span> <span>split</span>(<span>p0</span>, <span>p1</span>, <span>p2</span>, <span>p3</span>, <span>count</span>) {
</span></span><span><span>  <span>let</span> <span>result</span> <span>=</span> [];
</span></span><span><span>  <span>for</span> (<span>let</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>count</span>; <span>++</span><span>i</span>) {
</span></span><span><span>    <span>const</span> <span>t</span> <span>=</span> <span>1</span> <span>/</span> (<span>count</span> <span>-</span> <span>i</span>);
</span></span><span><span>    <span>const</span> [<span>first</span>, <span>second</span>] <span>=</span> <span>splitCubic</span>(<span>p0</span>, <span>p1</span>, <span>p2</span>, <span>p3</span>, <span>t</span>);
</span></span><span><span>    <span>result</span>.<span>push</span>(<span>first</span>);
</span></span><span><span>    [<span>p0</span>, <span>p1</span>, <span>p2</span>, <span>p3</span>] <span>=</span> [<span>second</span>.<span>p0</span>, <span>second</span>.<span>p1</span>, <span>second</span>.<span>p2</span>, <span>second</span>.<span>p3</span>];
</span></span><span><span>  }
</span></span><span><span>  <span>return</span> <span>result</span>;
</span></span><span><span>}
</span></span></code></pre></div><svg id="cubic" width="100%" viewBox="0 0 100 100">
  <rect x="0" y="0" width="100" height="100" fill="url(#grid)"></rect>
  <path id="cubicCtrl" d="" stroke="var(--fg)" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" fill="transparent"></path>
  <g id="splitCubics" fill="transparent" stroke-linejoin="round" stroke-linecap="round" stroke-width="1"></g>
  <circle cx="0" cy="0" r="2" fill="var(--fg)" id="cubicp0"></circle>
  <circle cx="0" cy="0" r="2" fill="var(--fg)" id="cubicp1"></circle>
  <circle cx="0" cy="0" r="2" fill="var(--fg)" id="cubicp2"></circle>
  <circle cx="0" cy="0" r="2" fill="var(--fg)" id="cubicp3"></circle>
</svg>

<p>With that said, we now have all the pieces we need to morph arbitrary paths. You can animate the resulting paths with SMIL natively since we have made sure that they satisfy all the requirements regarding the number of points and the structure of the paths.</p>

<p>Below you can play around with how morphing looks like, implemented like I’ve tried to explain in this post. The view box for this demo is <code>&#39;0 0 100 100&#39;</code>.</p>



<p>If you want to morph text, the first option is to convert the glyphs to paths and use that as the input. Getting the paths can easily be done in something like InkScape. However, in my opinion, the animations don’t look that great unless both texts have the same number of glyphs. In case you want to morph arbitrary text, I’d personally prefer an effect like <a href="https://codesandbox.io/p/sandbox/morphing-text-svg-title-jmswz?file=%2Fsrc%2Findex.js">this</a> instead of the method presented here.</p>

<p>Shape morphing is probably my favorite kind of animation. When I first learned about it around 8 years ago, I remember that I tried to understand how arbitrary shapes could be morphed together, and I couldn’t really figure it out at that time. Over the years I have learned a lot more about vector graphics (and graphics in general), and it became clear how one could achieve it.</p>
<p>I hope that this post can be useful to you. Even if you don’t need this, I hope that this was at least interesting to read!</p>


</article>

        </div></div>
  </body>
</html>
