<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.amoses.dev/blog/upl-people-counter/">Original</a>
    <h1>Overengineering a way to know if people are in my university&#39;s CS lab</h1>
    
    <div id="readability-page-1" class="page"><div> <!-- Second slot for content inside the content div -->   <div data-astro-cid-w6n32adp=""> <h2 id="a-history-of-upls-cameras"><a href="#a-history-of-upls-cameras">#</a>A History of UPL’s Cameras</h2>
<p>For almost as long as <a href="https://www.upl.cs.wisc.edu">the Undergraduate Projects Lab</a> at the University of Wisconsin has existed, there’s been a camera of some sort peering at the room. There’s evidence of a system existing even as far back as the 1990s, with a <a href="https://web.archive.org/web/19981202092257/http://www.upl.cs.wisc.edu/cgi-bin/uplcam.html">prehistoric revision of the site</a> mentioning that an old iteration was:</p>
<blockquote>
<p>…a $15 video camera attached to the wall with duct tape, connected to a VCR, connected to a video spigot in a Mac IIcx, running Timed Video Grabber (TVG), and FTPd. Dax, an HP workstation ran a script that would try to FTP the latest image every 60 seconds. Because the clocks would drift, occasionally, the file accesses would collide, and the whole scheme would break.</p>
</blockquote>
<p>Just <em>reading</em> that makes me stare at the camera that now sits perched on top of the arcade cabinet with wonder. What used to be several thousand dollars of equipment is now achievable (with immeasurably better quality) with a $50 webcam plugged into a Raspberry Pi.</p>
<p><img src="https://www.amoses.dev/images/upl-pc/old_upl.png" alt="A grainy image featuring an interior view of the UPL, a triangular-shaped undergraduate lab at UW-Madison."/>
    <img src="https://www.amoses.dev/images/upl-pc/new_upl.jpeg" alt="An image featuring the interior of the UPL, a lab at UW-Madison. Students sit at laptops."/>
</p>
<p><i>Taken ~25 years apart.</i></p>
<p>I could—and probably will—write an entire other blog post about the intricate history of the UPL, mentioning how <a href="https://web.archive.org/web/20001003051528/http://www.upl.cs.wisc.edu/uplcam/spincam.html">older versions of the website</a> allowed for users to control the tilt and pan of the camera using four stepper motors attached to the camera.</p>
<p>However, the focus of this article is about the two <em>latest</em> iterations of cameras in the UPL.</p>
<h2 id="is-the-upl-open-right-now"><a href="#is-the-upl-open-right-now">#</a>“Is the UPL open right now?”</h2>
<p>I’m sure that any UPL member can testify the horror of arriving to the lab to see a closed door. If you live anywhere off campus, it’s heartbreaking to see your arduous trek to the CS building result in failure.</p>
<p>There’s no doubt that as far back as IRC, members of the UPL messaged each other asking if the lab was open. With the advent of mobile phones, it’s gotten easier to bother your friends—who may not even be in the room!</p>
<p>Well, myself, in collaboration with other UPL members, decided to fix this issue in, perhaps, the most CS-student-esque way possible: an automated system to identify the occupancy of the lab.</p>
<h2 id="people-counting"><a href="#people-counting">#</a>People counting</h2>
<p>The first iteration of the people counting system (as built by <a href="https://github.com/mdberkey">Michael Berkey</a>) utilized a Logitech C920 camera mounted on a vantage point that had a clear view of the room. A Discord bot was set on a 15 minute loop (using discord.py.ext’s <code>@tasks.loop(minutes=15)</code>) to call a YOLOv7 model set to class 0 (detecting people). The bot called the webcam to take an image, then ran it through the model for inference. It returned the number of people in the room (and annotated the image with bounding boxes of where it believed the people to be, for debug purposes).</p>
<p><img src="https://www.amoses.dev/images/upl-pc/camera-over.png" alt="The front side of a C920 webcam."/>
    <img src="https://www.amoses.dev/images/upl-pc/camera-peek.png" alt="The back side of a C920 webcam."/>
</p>
<p><i>…don’t mind the tape.</i></p>
<p>It then set the name of a channel to the results (either <code>1-person-in-upl</code> or <code>X-people-in-upl</code>), which others could check.</p>
<p><img src="https://www.amoses.dev/images/upl-pc/8-people-in-upl.png" alt="A channel in the UPL Discord reads &#39;8 people in UPL&#39;."/>
</p>
<p><i>An example of what the Discord looked like on a day with a semi-busy UPL.</i></p>
<h2 id="switching-to-door-sensing"><a href="#switching-to-door-sensing">#</a>Switching to door sensing</h2>
<p>This worked perfectly for a while — people would check the Discord channel name and see the estimated count of the number of people in the room. If it said “zero people”, they could infer that the UPL wasn’t open.</p>
<p>However, this solution started presenting issues. For one, having people in the room didn’t necessarily indicate that the UPL was open. There could be a meeting, or a separate gathering where the doors were closed and people weren’t allowed inside. This was confusing to people who might have seen “8 people inside the UPL”, only to arrive at the building to see coords having a meeting.</p>
<p>There was also the issue of the model sometimes interpreting the chair in the corner as a person<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>:</p>
<p><img src="https://www.amoses.dev/images/upl-pc/upl_empty.png" alt="An image of the empty lab. An annotation on a brown armchair reads &#39;Person 0&#39;, despite no human on the chair."/>
</p>
<p><i>Either the model is too sensitive, or the UPL has a friendly ghost!</i></p>
<p>It was around this time that I stumbled upon the homepage of <a href="https://miters.mit.edu/">MITERS</a>, a makerspace at MIT. On their website, they broadcast whether the door to the space is open using a reed switch attached to a Raspberry Pi. Reed switches are small, physical components that are able to detect a magnetic field. If you put one on a doorframe, and then attach a tiny magnet to the door itself, you have an effective way of detecting whether a door is open or closed! I was able to find <a href="https://andrewbirkel.com/projects/MITERS_Door.html">a writeup</a> by a former member of the space on their implementation, but I can’t guarantee that it’s accurate to how it’s set up there currently.</p>
<p>I considered using similar components for a door status checker for the UPL — it wouldn’t have been too much effort to buy WiFi enabled ESP32 modules and off-the-shelf door-mountable reed switches. Then, I would have the chips simply send a POST request with their status every time the door was opened or closed.</p>
<p>I decided against this approach for a few reasons:</p>
<ul>
<li>
<p>The UPL doesn’t really have the equipment to maintain such a system. I don’t know how to solder, and mounting breadboards to the walls doesn’t seem like the most future-proof or aesthetically pleasing solution.</p>
</li>
<li>
<p>If the system were to spontaneously break after I left, it would be difficult to find somebody to fix it. The UPL is mainly a software oriented lab!</p>
</li>
<li>
<p>The WiFi ran by the university (UWNet) requires you to log in with a <a href="https://en.wikipedia.org/wiki/Captive_portal">captive portal</a> to register your device to connect to the network. Without intervention, it will occasionally require you to sign back in to renew your ability to connect<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>. While there <em>are</em> some ways to emulate the specific requests a typical browser would use to authenticate with your NetID, it would be a ton of recurring effort (and the login it used would have to be changed as people graduated)!</p>
</li>
</ul>
<p>So, I decided that the sensors themselves would have to act autonomously and simply relay their state to a device elsewhere in the room. Luckily, the Raspberry Pi that ran the code for the people counter was easily repurposed. I installed <a href="https://www.home-assistant.io/">Home Assistant</a>, an open source platform for interfacing with various network connected devices.</p>
<p>There are plenty of devices that track the status of doors, made by companies like Ring and ADT for home security. However, they usually require proprietary hubs to check their status, and don’t offer easily accessible APIs to interface with the device. Luckily, there was a better solution!</p>
<h2 id="zigbee"><a href="#zigbee">#</a>Zigbee!</h2>
<p>Enter Zigbee. It’s a low-rate mesh wireless protocol that allows for smart devices to communicate over a personal area network. A benefit of this is that you’re able to use one hub to communicate with a variety of devices, even those made by different manufacturers. Instead of searching for a particular brand for the door contact sensors, I would just have to find ones that supported the Zigbee protocol. Then I would be able to view their status through Home Assistant’s dashboard.</p>
<p>It’s important to note that Zigbee radios operate independently from WiFi or Bluetooth antennas. If you want to interface with Zigbee devices, you’ll have to pick up a special receiver that can support the protocol. For this project, I picked up <a href="https://www.amazon.com/SONOFF-Universal-Assistant-Zigbee2MQTT-Wireless/dp/B0B6P22YJC/">this one</a> made by SONOFF. Home Assistant’s Zigbee integration is called <a href="https://www.home-assistant.io/integrations/zha/">Zigbee Home Automation</a>, and it supports a variety of Zigbee coordinators (the USB dongles that allow for connections). When you use this integration, Home Assistant automatically creates a Zigbee network that the devices can join.</p>
<p>I decided to use <a href="https://www.amazon.com/Aqara-MCCGQ11LM-Window-Sensor-White/dp/B07D37VDM3/">these Aqara door and window sensors</a> for this project. They had the best reviews out of all of the Zigbee door sensors I looked at, and have a battery life of two years (with an easily replaceable CR1632 cell).</p>
<p>Once the coordinator and sensors arrived, I created a Home Assistant login and installed the ZHA integration. Pairing simply required holding the “reset” button on the sensors until Home Assistant recognized them and added the corresponding entities in the dashboard.</p>

<h2 id="using-the-door-statuses"><a href="#using-the-door-statuses">#</a>Using the door statuses</h2>
<p>Once this was all configured, I had the live statuses of the doors through the Home Assistant dashboard! I’m not going to lie, it was really fun opening and closing the doors repeatedly and seeing the dashboard change in real-time (even if passerby in the CS building probably thought I was crazy).</p>
<p>
    <video src="/images/upl-pc/doors.mp4" controls="">
    Your browser does not support the video tag.
</video>
</p>
<p><i>It’s so satisfying to watch this happen in real-time.<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup></i></p>
<p>An important thing to note here is that UWNet provides total access point isolation. None of the devices on the network can see any of the others (for good reason, as it would be a huge security vulnerability for any devices with open ports). If this wasn’t a limitation, I would just have the website directly query the rpi.</p>
<p>My first intuition was to use Home Assistant’s <a href="https://www.home-assistant.io/integrations/rest_command/">RESTful Command</a> integration to send a POST request to my webserver whenever the status of the doors changed. These require you to setup each command ahead of time, in HA’s <code>configuration.yml</code>:</p>
<div><figure><pre data-language="yaml"><code><div><div><p>1</p></div><p><span>rest_command</span><span>:</span></p></div><div><div><p>2</p></div><p><span>  </span><span>door1_opened</span><span>:</span></p></div><div><div><p>3</p></div><p><span>    </span><span>url</span><span>: </span><span>&#34;https://doors.amoses.dev/door1/open&#34;</span></p></div><div><div><p>4</p></div><p><span>    </span><span>method</span><span>: </span><span>POST</span></p></div><div><div><p>5</p></div><p><span>    </span><span>headers</span><span>:</span></p></div><div><div><p>6</p></div><p><span>      </span><span>content-type</span><span>: </span><span>&#34;application/json&#34;</span></p></div><div><div><p>7</p></div><p><span>    </span><span>payload</span><span>: </span><span>&#39;{&#34;door&#34;: &#34;door1&#34;, &#34;state&#34;: &#34;open&#34;}&#39;</span></p></div><div><div><p>8</p></div><p><span>    </span><span>content_type</span><span>: </span><span>&#34;application/json; charset=utf-8&#34;</span></p></div><div><div><p>9</p></div></div><div><div><p>10</p></div><p><span>  </span><span>door1_closed</span><span>:</span></p></div><div><div><p>11</p></div><p><span>    </span><span>url</span><span>: </span><span>&#34;https://doors.amoses.dev/door1/close&#34;</span></p></div><div><div><p>12</p></div><p><span>    </span><span>method</span><span>: </span><span>POST</span></p></div><div><div><p>13</p></div><p><span>    </span><span>headers</span><span>:</span></p></div><div><div><p>14</p></div><p><span>      </span><span>content-type</span><span>: </span><span>&#34;application/json&#34;</span></p></div><div><div><p>15</p></div><p><span>    </span><span>payload</span><span>: </span><span>&#39;{&#34;door&#34;: &#34;door1&#34;, &#34;state&#34;: &#34;closed&#34;}&#39;</span></p></div><div><div><p>16</p></div><p><span>    </span><span>content_type</span><span>: </span><span>&#34;application/json; charset=utf-8&#34;</span></p></div><div><div><p>17</p></div></div><div><div><p>18</p></div><p><span>  </span><span>door2_opened</span><span>:</span></p></div><div><div><p>19</p></div><p><span>    </span><span>url</span><span>: </span><span>&#34;https://doors.amoses.dev/door2/open&#34;</span></p></div><div><div><p>20</p></div><p><span>    </span><span>method</span><span>: </span><span>POST</span></p></div><div><div><p>21</p></div><p><span>    </span><span>headers</span><span>:</span></p></div><div><div><p>22</p></div><p><span>      </span><span>content-type</span><span>: </span><span>&#34;application/json&#34;</span></p></div><div><div><p>23</p></div><p><span>    </span><span>payload</span><span>: </span><span>&#39;{&#34;door&#34;: &#34;door2&#34;, &#34;state&#34;: &#34;open&#34;}&#39;</span></p></div><div><div><p>24</p></div><p><span>    </span><span>content_type</span><span>: </span><span>&#34;application/json; charset=utf-8&#34;</span></p></div><div><div><p>25</p></div></div><div><div><p>26</p></div><p><span>  </span><span>door2_closed</span><span>:</span></p></div><div><div><p>27</p></div><p><span>    </span><span>url</span><span>: </span><span>&#34;https://doors.amoses.dev/door2/close&#34;</span></p></div><div><div><p>28</p></div><p><span>    </span><span>method</span><span>: </span><span>POST</span></p></div><div><div><p>29</p></div><p><span>    </span><span>headers</span><span>:</span></p></div><div><div><p>30</p></div><p><span>      </span><span>content-type</span><span>: </span><span>&#34;application/json&#34;</span></p></div><div><div><p>31</p></div><p><span>    </span><span>payload</span><span>: </span><span>&#39;{&#34;door&#34;: &#34;door2&#34;, &#34;state&#34;: &#34;closed&#34;}&#39;</span></p></div><div><div><p>32</p></div><p><span>    </span><span>content_type</span><span>: </span><span>&#34;application/json; charset=utf-8&#34;</span></p></div></code></pre></figure></div>
<p>…but I very quickly realized that this solution wasn’t the best. For one, when I published <a href="https://github.com/UW-UPL/people-counter-v2/blob/main/home-assistant/configuration.yaml">the source code</a> onto GitHub, some very funny students decided that they would manually simulate the POST requests and change the status of the doors to be inaccurate. That’s what I get for leaving the endpoint unsecured!<sup><a href="#user-content-fn-4" id="user-content-fnref-4" data-footnote-ref="" aria-describedby="footnote-label">4</a></sup></p>
<p>I eventually learned that Home Assistant provides a <a href="https://developers.home-assistant.io/docs/api/rest/">RESTful API</a> directly alongside the web dashboard. If I set that up, I would be able to query the instance for the states of the connected devices.<sup><a href="#user-content-fn-5" id="user-content-fnref-5" data-footnote-ref="" aria-describedby="footnote-label">5</a></sup> All it took was appending an <code>/api/</code> route to the HA URL. I could just use that!</p>
<p>The API has all of its routes authenticated with a bearer token (to most likely mirror the permissions of the frontend, which requires a user login before showing any data). Given that I wanted to display the door status on the UPL’s page, I realized the potential danger in shipping the bearer token with the site. Any crafty user could take it and access any other route on Home Assistant’s API. Given the level of information and control available on HA instances, this could be disastrous.</p>
<p>I made a quick webserver using Express that proxies the request with the bearer token and only serves the relevant door information. Because it displays this separately, the user has no way of seeing or manipulating anything beyond this.</p>
<div><figure><pre data-language="js"><code><details><summary></summary><div><p><span>const</span><span> </span><span>express</span><span> = </span><span>require</span><span>(</span><span>&#34;express&#34;</span><span>);</span></p></div><div><p><span>const</span><span> </span><span>axios</span><span> = </span><span>require</span><span>(</span><span>&#34;axios&#34;</span><span>);</span></p></div><div><p><span>const</span><span> </span><span>cors</span><span> = </span><span>require</span><span>(</span><span>&#34;cors&#34;</span><span>);</span></p></div><div></div><div><p><span>const</span><span> </span><span>app</span><span> = </span><span>express</span><span>();</span></p></div><div><p><span>const</span><span> </span><span>PORT</span><span> = </span><span>3500</span><span>;</span></p></div><div></div></details><div><div><p>8</p></div><p><span>const</span><span> </span><span>apiUrl</span><span> = </span><span>&#34;https://HOMEASSISTANT-URL-HERE/api/states&#34;</span><span>;</span></p></div><div><div><p>9</p></div><p><span>const</span><span> </span><span>token</span><span> = </span><span>&#34;Bearer TOKEN-GOES-HERE&#34;</span><span>;</span></p></div><div><div><p>10</p></div></div><div><div><p>11</p></div><p><span>app</span><span>.</span><span>use</span><span>(</span><span>cors</span><span>());</span></p></div><div><div><p>12</p></div></div><div><div><p>13</p></div><p><span>app</span><span>.</span><span>get</span><span>(</span><span>&#34;/door-status&#34;</span><span>, </span><span>async</span><span> (</span><span>req</span><span>, </span><span>res</span><span>) </span><span>=&gt;</span><span> {</span></p></div><div><div><p>14</p></div><p><span>  </span><span>try</span><span> {</span></p></div><div><div><p>15</p></div><p><span>    </span><span>const</span><span> </span><span>response</span><span> = </span><span>await</span><span> </span><span>axios</span><span>.</span><span>get</span><span>(</span><span>apiUrl</span><span>, {</span></p></div><div><div><p>16</p></div><p><span>      </span><span>headers:</span><span> {</span></p></div><div><div><p>17</p></div><p><span>        </span><span>Authorization:</span><span> </span><span>token</span><span>,</span></p></div><div><div><p>18</p></div><p><span><span>      </span></span><span>},</span></p></div><div><div><p>19</p></div><p><span><span>    </span></span><span>});</span></p></div><div><div><p>20</p></div></div><div><div><p>21</p></div><p><span>    </span><span>const</span><span> </span><span>data</span><span> = </span><span>response</span><span>.</span><span>data</span><span>;</span></p></div><div><div><p>22</p></div></div><div><div><p>23</p></div><p><span>    </span><span>// grab the items with the appropriate HA entity ids</span></p></div><div><div><p>24</p></div><p><span>    </span><span>const</span><span> </span><span>doors</span><span> = </span><span>data</span><span>.</span><span>filter</span><span>(</span></p></div><div><div><p>25</p></div><p><span><span>      </span></span><span>(</span><span>item</span><span>) </span><span>=&gt;</span></p></div><div><div><p>26</p></div><p><span>        </span><span>item</span><span>.</span><span>entity_id</span><span> === </span><span>&#34;binary_sensor.back&#34;</span><span> ||</span></p></div><div><div><p>27</p></div><p><span>        </span><span>item</span><span>.</span><span>entity_id</span><span> === </span><span>&#34;binary_sensor.front&#34;</span></p></div><div><div><p>28</p></div><p><span><span>    </span></span><span>);</span></p></div><div><div><p>29</p></div></div><div><div><p>30</p></div><p><span>    </span><span>// extract status and last updated information</span></p></div><div><div><p>31</p></div><p><span>    </span><span>const</span><span> </span><span>doorStatus</span><span> = </span><span>doors</span><span>.</span><span>map</span><span>((</span><span>door</span><span>) </span><span>=&gt;</span><span> ({</span></p></div><div><div><p>32</p></div><p><span>      </span><span>door:</span><span> </span><span>door</span><span>.</span><span>attributes</span><span>.</span><span>friendly_name</span><span>,</span></p></div><div><div><p>33</p></div><p><span>      </span><span>status:</span><span> </span><span>door</span><span>.</span><span>state</span><span>,</span></p></div><div><div><p>34</p></div><p><span>      </span><span>last_updated:</span><span> </span><span>door</span><span>.</span><span>last_updated</span><span>,</span></p></div><div><div><p>35</p></div><p><span><span>    </span></span><span>}));</span></p></div><div><div><p>36</p></div></div><div><div><p>37</p></div><p><span>    </span><span>// send the filtered data as a json response</span></p></div><div><div><p>38</p></div><p><span>    </span><span>res</span><span>.</span><span>json</span><span>(</span><span>doorStatus</span><span>);</span></p></div><div><div><p>39</p></div><p><span><span>  </span></span><span>} </span><span>catch</span><span> (</span><span>error</span><span>) {</span></p></div><div><div><p>40</p></div><p><span>    </span><span>res</span><span>.</span><span>status</span><span>(</span><span>500</span><span>).</span><span>send</span><span>(</span><span>&#34;Error fetching data&#34;</span><span>);</span></p></div><div><div><p>41</p></div><p><span><span>  </span></span><span>}</span></p></div><div><div><p>42</p></div><p><span>});</span></p></div><details><summary></summary><div></div><div><p><span>// :P</span></p></div><div><p><span>app</span><span>.</span><span>get</span><span>(</span><span>&#34;/&#34;</span><span>, </span><span>async</span><span> (</span><span>req</span><span>, </span><span>res</span><span>) </span><span>=&gt;</span><span> {</span></p></div><div><p><span>  </span><span>res</span></p></div><div><p><span><span>    </span></span><span>.</span><span>status</span><span>(</span><span>200</span><span>)</span></p></div><div><p><span><span>    </span></span><span>.</span><span>send</span><span>(</span><span>&#34;&lt;html&gt;&lt;body&gt;&lt;b&gt;wow upl door status endpoint 443&lt;/b&gt;&lt;/body&gt;&lt;/html&gt;&#34;</span><span>);</span></p></div><div><p><span>});</span></p></div><div></div><div><p><span>app</span><span>.</span><span>listen</span><span>(</span><span>PORT</span><span>, () </span><span>=&gt;</span><span> {</span></p></div><div><p><span>  </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`Server is running on port </span><span>${</span><span>PORT</span><span>}</span><span>`</span><span>);</span></p></div><div><p><span>});</span></p></div></details></code></pre></figure></div>
<p>Now, the server will query Home Assistant’s API on your behalf (with the proper bearer token). It’ll return a JSON object of the door statuses and their last change, like so:</p>
<div><figure><pre data-language="json"><code><div><p><span>[</span></p></div><div><p><span><span>  </span></span><span>{</span></p></div><div><p><span>    </span><span>&#34;door&#34;</span><span>: </span><span>&#34;back&#34;</span><span>,</span></p></div><div><p><span>    </span><span>&#34;status&#34;</span><span>: </span><span>&#34;on&#34;</span><span>,</span></p></div><div><p><span>    </span><span>&#34;last_updated&#34;</span><span>: </span><span>&#34;2024-10-12T20:01:54.353657+00:00&#34;</span></p></div><div><p><span><span>  </span></span><span>},</span></p></div><div><p><span><span>  </span></span><span>{</span></p></div><div><p><span>    </span><span>&#34;door&#34;</span><span>: </span><span>&#34;front&#34;</span><span>,</span></p></div><div><p><span>    </span><span>&#34;status&#34;</span><span>: </span><span>&#34;on&#34;</span><span>,</span></p></div><div><p><span>    </span><span>&#34;last_updated&#34;</span><span>: </span><span>&#34;2024-10-12T20:02:10.132178+00:00&#34;</span></p></div><div><p><span><span>  </span></span><span>}</span></p></div><div><p><span>]</span></p></div></code></pre></figure></div>
<p>…and the Discord bot/UPL website can use that to let people know what the status is.</p>
<p><img src="https://www.amoses.dev/images/upl-pc/open_door.png" alt="The UPL website reads &#39;the doors are open!&#39; with an icon of an open door."/>
</p>
<p><i>The UPL website uses a header component which fetches the door status every 15 seconds.</i></p>
<p><img src="https://www.amoses.dev/images/upl-pc/upl_discord.png" alt="A channel in the UPL Discord reads &#39;UPL doors open&#39;."/>
</p>
<p><i>The Discord channel name is an easy way to see the status without opening the site.</i></p>
<h2 id="conclusion"><a href="#conclusion">#</a>Conclusion</h2>
<p>I’m pretty happy with how this project turned out. It’s been really fun developing something that I actually use every day, and I find it pretty special that every time I check if the UPL’s open or not, I’m doing it via something that I made myself.</p>
</div>   </div></div>
  </body>
</html>
