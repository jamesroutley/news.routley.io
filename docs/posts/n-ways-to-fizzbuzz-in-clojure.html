<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.evalapply.org/posts/n-ways-to-fizzbuzz-in-clojure/">Original</a>
    <h1>n ways to FizzBuzz in Clojure</h1>
    
    <div id="readability-page-1" class="page"><div><div>
<p>FizzBuzz is everywhere. Every programmer passes through its rite of passage,
or at least bears witness to another. Over the years, many gentlenerds have
taken it upon themselves to discover ever new ways to incant those hoary symbols.</p>
<p>I hereby enjoin these few drops of Clojure to that roiling ocean of FizzBuzzery.</p>
<p>The brainwave here is to (mis)use the feature set of Clojure and its standard
library to cook up as many ways to encode FizzBuzz as one can muster (or steal).
If all goes well, this post will receive many updates. If it goes <em>really</em>
well, all sorts of bad ideas and clever foot-guns will be discovered and used.</p>
<p>Not to be indelicate, but I will state the problem before proceeding.</p>
<blockquote>
<p>Fizz buzz is a group word game for children to teach them about division.
Players take turns to count incrementally, replacing any number divisible by
three with the word “fizz”, and any number divisible by five with the word “buzz”.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Fizz%5Fbuzz">https://en.wikipedia.org/wiki/Fizz%5Fbuzz</a></li>
</ul>
</blockquote>
<p>Needless to say, they mean natural numbers starting at 1 when they say “numbers”.</p>
<p>Phew that was rough on the ego. Let us compose ourselves for a minute.</p>
<p>…</p>
<p>OK, onward.</p>
<ul>
<li><a href="#usage-guide">Usage guide</a></li>
<li><a href="#le-fizzbuzz-classique">Le FizzBuzz Classique</a></li>
<li><a href="#le-fizzbuzz-classique-est-mort-%C3%A0-clojure-dot-d%C3%A9sol%C3%A9">Le FizzBuzz Classique est mort à Clojure. Désolé :(</a></li>
<li><a href="#le-fizzbuzz-classique-remedied">Le FizzBuzz Classique, remedied</a></li>
<li><a href="#le-fizzbuzz-classique-dissected">Le FizzBuzz Classique, dissected</a></li>
<li><a href="#le-fizzbuzz-classique-doseq-d">Le FizzBuzz Classique, doseq’d</a></li>
<li><a href="#le-fizzbuzz-classique-doall-d">Le FizzBuzz Classique, doall’d</a></li>
<li><a href="#little-functions-are-good">Little functions are good!</a></li>
<li><a href="#map-reduce-for-fizzbuzz">map reduce for FizzBuzz</a></li>
<li><a href="#domain-driven-design-fizzbuzz">Domain Driven Design FizzBuzz</a></li>
<li><a href="#actually-domain-driven-fizzbuzz">Actually Domain Driven FizzBuzz</a></li>
<li><a href="#fizzbuzz-by-construction">FizzBuzz by construction</a></li>
<li><a href="#interlude-all-the-fizz-buzzes-so-far">Interlude: all the fizz-buzzes so far</a></li>
<li><a href="#peano-fizzbuzz">Peano FizzBuzz</a></li>
<li><a href="#dispatch-buzz">Dispatch Buzz</a></li>
<li><a href="#buzz">TODO Buzz</a></li>
<li><a href="#acknowledgments">Acknowledgments</a></li>
</ul>
<hr/>
<h2 id="usage-guide">Usage guide<a href="#usage-guide" arialabel="Anchor">⌗</a> </h2>
<p>Reading the code:</p>
<ul>
<li>
<p>Find the <code>check-all-fizz-buzzers</code> function below, for usage examples.</p>
</li>
<li>
<p>We use functions only from Clojure’s standard library (clojure.core).</p>
</li>
<li>
<p>Lookup unfamiliar functions at <a href="https://clojuredocs.org/quickref">https://clojuredocs.org/quickref</a>, helpfully
illustrated with community-contributed examples.</p>
</li>
</ul>
<p>Running the code:</p>
<ul>
<li>
<p>If you don’t already have <a href="https://clojure.org/guides/getting%5Fstarted">Clojure installed</a>,
you can run the code online at <a href="https://tryclojure.org/">https://tryclojure.org/</a> (fully client-side,
but minimalist), or at <a href="https://repl.it/languages/clojure">https://repl.it/languages/clojure</a> (feature-rich
web-based IDE, but requires signup).</p>
</li>
<li>
<p>Preferably, copy over code as you go along. Try it out bit by bit.</p>
</li>
<li>
<p>If you are in a hurry, find the “Interlude” section and copy over all the
code from there.</p>
</li>
<li>
<p>Finally, run <code>(check-all-fizz-buzzers)</code> to see if it all works as expected.</p>
</li>
</ul>
<p>Complaining about the code:</p>
<ul>
<li>If I’ve written any bugs (possible) or made egregious remarks (very possible),
please write to <em>weblog</em> at this website. I’ll fix the bugs.</li>
</ul>
<p>Right, then. Shall we begin?</p>
<h2 id="le-fizzbuzz-classique">Le FizzBuzz Classique<a href="#le-fizzbuzz-classique" arialabel="Anchor">⌗</a> </h2>
<p>In the beginning, one might trawl the Clojure standard library for familiar,
safe-looking words and accidentally discover <code>for</code><sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.
Python or Javascript gentlenerds may say <em>“Ooh, List Comprehension. Nice!&#34;</em>,
and bang out <em>Le FizzBuzz Classique</em>. Java or C# gentlenerds may struggle a
lot more, because Clojure has no <code>Class</code>. We are sorry for this disappointment.
Please follow the Python for now.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>fizz-buzz-classic
  [num-xs]
  (for [n num-xs]
    (<span>cond</span>
      (zero? (rem n <span>15</span>)) (println <span>&#34;FizzBuzz&#34;</span>)
      (zero? (rem n <span>3</span>)) (println <span>&#34;Fizz&#34;</span>)
      (zero? (rem n <span>5</span>)) (println <span>&#34;Buzz&#34;</span>)
      <span>:else</span> (println n))))
</code></pre></div><p>Then you will evaluate it <em>in</em> the “REPL”, et voilà! Something
très familiar!</p>
<div><pre tabindex="0"><code data-lang="clojure">user=&gt; (<span>fizz-buzz-classic</span> (list <span>1</span> <span>3</span> <span>5</span> <span>15</span> <span>16</span>))
<span>1</span>
Fizz
Buzz
FizzBuzz
<span>16</span>
(<span>nil</span> nil nil nil nil)
</code></pre></div><p>(Except for that pesky last line full of nils. But like, whatever. It worked.).</p>
<h2 id="le-fizzbuzz-classique-est-mort-à-clojure-dot-désolé">Le FizzBuzz Classique est mort à Clojure. Désolé :(<a href="#le-fizzbuzz-classique-est-mort-à-clojure-dot-désolé" arialabel="Anchor">⌗</a> </h2>
<p>Sadly, the spurious nils are the least of your woes. You just fell prey to
something called “Laziness”, and the code is dead on arrival, but you don’t
know it yet because evaluating <em>in</em> the “REPL” obscures this fact.</p>
<p>Welcome to Functional Programming (FP) with lazy sequences, which is <em>awesome</em>,
but which is also one of the double edges of Clojure that will cut you if you
come here with set ideas about How Things Ought To Work.</p>
<p>Saying it in French (however broken) felt gentler, somehow.</p>
<p>At this point, you might accuse me of setting you up with this strawman <code>for</code>.
In response, I might simply wait for your production to blow up. Unknowing
mixing of laziness and side effects reliably trips up all programmers new to
Clojure <sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</p>
<p>Luckily we can avoid going down that rabbit hole <sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> entirely, because
there is a more pressing problem that makes <em>Le FizzBuzz Classique</em> look
severely defective to this Clojurist’s FP-addled brain. Fixing that makes the
point of lazy sequences moot, as a nice bonus.</p>
<h2 id="le-fizzbuzz-classique-remedied">Le FizzBuzz Classique, remedied<a href="#le-fizzbuzz-classique-remedied" arialabel="Anchor">⌗</a> </h2>
<p>Behold this cleaned up version.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>lazybuzz
  [num-xs]
  (for [n num-xs]
    (<span>cond</span>
      (zero? (rem n <span>15</span>)) <span>&#34;FizzBuzz&#34;</span>
      (zero? (rem n <span>3</span>)) <span>&#34;Fizz&#34;</span>
      (zero? (rem n <span>5</span>)) <span>&#34;Buzz&#34;</span>
      <span>:else</span> n)))
</code></pre></div><p>Yes, <code>println</code> is no more, and…</p>
<div><pre tabindex="0"><code data-lang="clojure">user=&gt; (<span>lazybuzz</span> (list <span>1</span> <span>3</span> <span>5</span> <span>15</span> <span>16</span>))
(<span>1</span> <span>&#34;Fizz&#34;</span> <span>&#34;Buzz&#34;</span> <span>&#34;FizzBuzz&#34;</span> <span>16</span>)
</code></pre></div><p>Compare the shape of the collection of nils seen classically, with what we see
now. They are both sequences with the same number of items, <em>but</em> the new one
contains useful values (insert :trollface: :).</p>
<div><pre tabindex="0"><code data-lang="clojure">user=&gt; (<span>fizz-buzz-classic</span> (list <span>1</span> <span>3</span> <span>5</span> <span>15</span> <span>19</span>))
<span>1</span>
Fizz
Buzz
FizzBuzz
<span>19</span>
(<span>nil</span> nil nil nil nil) <span>; 5 prints, 5 nils</span>

user=&gt; (<span>lazybuzz</span> (list <span>1</span> <span>3</span> <span>5</span> <span>15</span> <span>19</span>))
(<span>1</span> <span>&#34;Fizz&#34;</span> <span>&#34;Buzz&#34;</span> <span>&#34;FizzBuzz&#34;</span> <span>19</span>) <span>; no prints, 1 value containing 5 values</span>
</code></pre></div><p>Well, that’s because all expressions in Clojure return a value. <code>println</code>
creates a side effect of printing and has a return value of <code>nil</code>. Thus for
each item in the input range, the “impure” classic version prints to the REPL,
collects the return value of each println (nil), and returns that collection.</p>
<p>The “purified” fizz-buzz simply calculates a result for each branch and the
<code>for</code> returns the accumulated result. And now the results are printed inside
parentheses, which is, like, sure whatever. At least it <em>looks</em> like it’s
doing the right calculations <em>and</em> the pesky nils are gone, so we can move on?</p>
<p>Not so fast.</p>
<h2 id="le-fizzbuzz-classique-dissected">Le FizzBuzz Classique, dissected<a href="#le-fizzbuzz-classique-dissected" arialabel="Anchor">⌗</a> </h2>
<p>To FizzBuzz creatively in Clojure, we must examine <em>and avoid</em> the defects of
the classic version, which are as follows.</p>
<ol>
<li><strong>Broken behaviour</strong>: <code>println</code> alters the state of the world and thus
injects non-determinism into an otherwise purely functional calculation.
This is anathema <sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> to Clojurists (and FP practitioners at large).</li>
<li><strong>Broken API contract</strong>: We get back a useless collection nils, instead of the
result of a calculation that we can use further. We prefer to always write
functions that return useful values.</li>
<li><strong>Broken time model</strong>: Effects want to happen “now” (here, printing to
some output device), while lazy computations want to happen “maybe never”
(here, a definition that maps the domain of a collection of countless
numbers to the domain of FizzBuzz). Effects and laziness can be made to
pair well, <em>but only when</em> we define them separately from the get go, and
have some third way of joining them together safely when needed. For now,
you could do worse than lasering this into your brain: “Never mix (side)
effects and laziness.”.</li>
<li><strong>Broken aesthetic</strong>: We like our functions to do one job, and do it well.
Printing things is a <em>second</em> job, and as Messers Hal and Gerry like to
say in SICP <sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>, “That’s George’s problem.”.</li>
</ol>
<p>Henceforth, all functions shall be pure calculations, and we will rely on
our metaphorical George “the REPL” Ableman to handle all our print jobs.</p>
<p>As an added benefit, writing pure functions makes laziness such a good friend,
that we don’t even need to acknowledge its presence.</p>
<p>Yet another benefit is that we won’t have to burn hundreds of words to apologise
for broken code <sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>.</p>
<p>See? Such passion. I wasn’t joking when I said “looks severely defective to me” <sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup>.</p>
<h2 id="le-fizzbuzz-classique-doseq-d">Le FizzBuzz Classique, doseq’d<a href="#le-fizzbuzz-classique-doseq-d" arialabel="Anchor">⌗</a> </h2>
<p>Maybe you still aren’t convinced. <code>println</code> is such a global standard. <em>Easy</em> <sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup>.
So you might dig into the standard library more and come up with <code>doseq</code> to
eliminate laziness…</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>doseq-fizz-buzz
  [num-xs]
  (doseq [n num-xs]
    (<span>cond</span>
      (zero? (rem n <span>15</span>)) (println <span>&#34;FizzBuzz&#34;</span>)
      (zero? (rem n <span>3</span>)) (println <span>&#34;Fizz&#34;</span>)
      (zero? (rem n <span>5</span>)) (println <span>&#34;Buzz&#34;</span>)
      <span>:else</span> (println n))))
</code></pre></div><p>And declare victory…</p>
<div><pre tabindex="0"><code data-lang="clojure">user=&gt; (<span>doseq-fizz-buzz</span> (list <span>1</span> <span>3</span> <span>5</span> <span>15</span> <span>19</span>))
<span>1</span>
Fizz
Buzz
FizzBuzz
<span>19</span>
nil <span>; maybe we can live with just one nil?</span>
</code></pre></div><p>But the code is still fatally broken for the other reasons, and now <em>it is
also worse</em>, because this implementation cannot say “here are <em>all</em> the
fizzbuzzes”. Only a lazy definition can say this <em>and</em> allow you to carry on
computing. Besides, <code>doseq</code> is meant for cases when we <em>want to cause</em> side
effects. And the functional Clojurist almost never <em>wants</em> to.</p>
<p>Remember the children’s game definition of FizzBuzz? It is beautiful because
it <em>does not</em> say “FizzBuzz only for the first K numbers”. Now if you go
DuckDuck search the standard coding interview version of the question, what
do you find? “Write a program that prints the numbers from 1 to 100
such that…”.</p>
<p>Boo.</p>
<h2 id="le-fizzbuzz-classique-doall-d">Le FizzBuzz Classique, doall’d<a href="#le-fizzbuzz-classique-doall-d" arialabel="Anchor">⌗</a> </h2>
<p>As a famous TV detective would say; “Oh, just one other thing.”. Here are ways
to break your programs. And if you are feeling suitably adventurous, to also
test the stability of your employment.</p>
<p>The following invocation of <code>lazybuzz</code> in your <code>-main</code> would not be fine,
assuming you wanted to do something useful with it. But would also not
precipitate anything terrible.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>-main
  <span>&#34;The entry point to your microservice.&#34;</span>
  [<span>&amp;</span> args]
  <span>;; Do things ...</span>
  (println <span>&#34;I&#39;m about to do...&#34;</span>)

  <span>;; No block, no foul.</span>
  (<span>lazybuzz</span> (<span>range</span>))

  <span>;; Sure, why not ...</span>
  (println <span>&#34;I&#39;m done!&#34;</span>))
</code></pre></div><p>Here is a good way to break your software and print FizzBuzzes to the console
indefinitely (or at least as long as your computer can make new numbers).</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>-main
  <span>&#34;The entry point to your microservice.&#34;</span>
  [<span>&amp;</span> args]
  <span>;; Do things ...</span>
  (println <span>&#34;I&#39;m about to do...&#34;</span>)

  <span>;; Spin wheels until the numbers run out.</span>
  (<span>doseq-fizz-buzz</span> (<span>range</span>))

  <span>;; Maybe never ...</span>
  (println <span>&#34;I&#39;m done!&#34;</span>))
</code></pre></div><p>As a funner party trick, if you make a computer (VM) with a bad output device
(or redirect program output to /dev/full), then you can crash or hang your
program. If you discover it crashes, feel free to daemonise it and make an
infinitely restarting JVM process that does nothing but burn CPU cycles.
Take that, cryptominers!</p>
<p>To be fair, you can also break programs with lazy evaluation, with the added
benefit of doing it silently. But at least you are forced to say <code>doall</code>,
which might make you feel at least a tiny bit guilty.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>-main
  <span>&#34;The entry point to your microservice.&#34;</span>
  [<span>&amp;</span> args]
  <span>;; Do things...</span>
  (println <span>&#34;I&#39;m about to do...&#34;</span>)

  <span>;; Spin wheels silently, until OOM or no more numbers,</span>
  <span>;; whichever happens first.</span>
  (doall (<span>lazybuzz</span> (<span>range</span>)))

  <span>;; Maybe not ...</span>
  (println <span>&#34;I&#39;m done!&#34;</span>))
</code></pre></div><p>To see if you can get <em>fired</em> by solving fizzbuzz (now that’s a concept,
innit?), you can ship to production <sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup> the…</p>
<ul>
<li>doseq version, to fill up your log files with fizzbuzz. They will fill
up really fast. Faster than logrotate.</li>
<li>doall lazybuzz version, to confuse the daylights out of everyone, at
least until your process dies with OOM.</li>
<li>badly daemonised verison, to enjoy repeated restart cycles through crashes
from number overflows and/or OOMs.</li>
<li>Or something actually dangerous…</li>
</ul>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>-main
  <span>&#34;The entry point to your microservice.&#34;</span>
  [<span>&amp;</span> args]
  <span>;; Do things...</span>
  (println <span>&#34;I&#39;m about to do...&#34;</span>)

  <span>;; Your /thought/ you were going to /do/ something useful here.</span>
  (<span>fizz-buzz-classic</span> (<span>range</span>))

  <span>;; You now falsely believe you did something useful ...</span>
  (println <span>&#34;I&#39;m done!&#34;</span>))
</code></pre></div><p>I assure you, experienced Clojurists are no longer grinning at the tomfoolery.
Many of us have shipped <sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup> (or <em>almost</em> shipped) this category of
bugs to prod. Not fun.</p>
<p>OK, now I consider <em>Le Cheval Classique</em> suitably flogged postmortem, and
yourself suitably <em>Caveat Emptor</em>-ed.</p>
<p>Now we will FizzBuzz joyously.</p>
<h2 id="little-functions-are-good">Little functions are good!<a href="#little-functions-are-good" arialabel="Anchor">⌗</a> </h2>
<p>Once we remove the <em>ick</em> of <code>println</code> from our code, we can see further room
for improvement. <code>(zero? (rem n divisor))</code> is not only a common pattern,
it is actually a distinct <em>idea</em>, viz. “Is <code>n</code> <em>divisible</em> by <code>divisor</code>?”.</p>
<p>We can name it locally, with <code>let</code>.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>letbuzz
  [num-xs]
  (for [n num-xs]
    (<span>let </span>[divisible? (<span>fn </span>[n1 n2] (zero? (rem n1 n2)))] <span>; locally-bound lambda</span>
      (<span>cond</span>
        (<span>divisible?</span> n <span>15</span>) <span>&#34;FizzBuzz&#34;</span>
        (<span>divisible?</span> n <span>3</span>) <span>&#34;Fizz&#34;</span>
        (<span>divisible?</span> n <span>5</span>) <span>&#34;Buzz&#34;</span>
        <span>:else</span> n))))
</code></pre></div><p><em>However</em>, this definition of divisibility is generally applicable to numbers,
so it makes sense to define a top-level global concept.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>def </span>divisible?
  <span>&#34;True when the remainder of n1/n2 is zero. e.g. (divisible? 4 2) =&gt; true&#34;</span>
  (<span>fn </span>[n1 n2] (zero? (rem n1 n2))))
</code></pre></div><p>Yep, <code>defn</code> is just <code>def</code> + <code>fn</code> under the hood, and we can conveniently
write the same thing as follows.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>divisible?
  <span>&#34;True when the remainder of n1/n2 is zero. e.g. (divisible? 4 2) =&gt; true&#34;</span>
  [n1 n2]
  (zero? (rem n1 n2)))
</code></pre></div><p>We can also use <code>comp</code> to define divisibility more succinctly.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>def </span>divisible?
  <span>&#34;True when the remainder of n1/n2 is zero. e.g. (divisible? 4 2) =&gt; true&#34;</span>
  (comp zero? rem))
</code></pre></div><p>Since the various implementations of <code>divisible?</code> are all pure functions,
they are drop-in replacements for each other (“referentially transparent”).
Use whichever version you like best.</p>
<p>It may seem silly to write such tiny functions, but we earn a lot of firepower
by lifting out named domain concepts, <em>especially</em> the simple ones, because
we can <em>compose</em> them flexibly to express other domain concepts as needed.</p>
<h2 id="map-reduce-for-fizzbuzz">map reduce for FizzBuzz<a href="#map-reduce-for-fizzbuzz" arialabel="Anchor">⌗</a> </h2>
<p>Here’s a doozy. By putting FizzBuzz <em>logic</em> inside <code>for</code>, we have in fact
deeply intertwined <sup id="fnref:11"><a href="#fn:11" role="doc-noteref">11</a></sup> two very distinct computations; viz. sequence
generation, and choice-making.</p>
<p>Suppose we lifted out the decision logic into its own function?</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>basic-buzz
  <span>&#34;We can also trivially rewrite this with &#39;condp&#39;.
</span><span>  ref: https://clojuredocs.org/clojure.core/condp&#34;</span>
  [n]
  (<span>cond</span>
    (<span>divisible?</span> n <span>15</span>) <span>&#34;FizzBuzz&#34;</span>
    (<span>divisible?</span> n <span>3</span>) <span>&#34;Fizz&#34;</span>
    (<span>divisible?</span> n <span>5</span>) <span>&#34;Buzz&#34;</span>
    <span>:else</span> n))

(<span>comment</span>
  <span>;; Unsurprisingly...</span>
  (<span>basic-buzz</span> <span>1</span>) =&gt; <span>1</span>
  (<span>basic-buzz</span> <span>3</span>) =&gt; <span>&#34;Fizz&#34;</span>
  (<span>basic-buzz</span> <span>5</span>) =&gt; <span>&#34;Buzz&#34;</span>
  (<span>basic-buzz</span> <span>15</span>) =&gt; <span>&#34;FizzBuzz&#34;</span>
  )
</code></pre></div><p>Now we can bring back <code>for</code> this way…</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>def </span>all-fizz-buzzes
  (for [n (rest (<span>range</span>))]
    (<span>basic-buzz</span> n)))
</code></pre></div><p>But our new choice opens up the design space, because we can directly say
“this is just a mapping of the domain of numbers to the domain of FizzBuzz”.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>def </span>all-fizz-buzzes
  (map basic-buzz (rest (<span>range</span>))))
</code></pre></div><p>Now since <code>map</code> is conceptually just a special case of <code>reduce</code>, we could write
the following. <em>However</em> in Clojure, <code>map</code> is lazy but <code>reduce</code> is eager, and
we only use <em>reduce</em> when we want to force a final calculation.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>def </span>just-some-fizz-buzzes
  (reduce (<span>fn </span>[result n]
            (conj result
                  (<span>basic-buzz</span> n)))
          []
          <span>;; the classic programmer&#39;s problem statement</span>
          (range <span>1</span> <span>101</span>)))
</code></pre></div><p>Once again, we earned more compositional power by lifting out another small
concept. Let’s do some more of that.</p>
<h2 id="domain-driven-design-fizzbuzz">Domain Driven Design FizzBuzz<a href="#domain-driven-design-fizzbuzz" arialabel="Anchor">⌗</a> </h2>
<p>We can further define concepts specific to the business domain of FizzBuzz.
This opens up our design space even more.</p>
<p>Before that I’ll make one small tweak to help us express ourselves better.
I’ll rearrange the argument list of <code>divisible?</code> so that the “more constant”
argument is placed first, and successively more variable argument(s) are
placed successively. Also rely on “truthiness” in Clojure to imply yes/no.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>divisible?
  <span>&#34;Given a number &#39;n&#39;, return the given word (truthy) when it is divisible
</span><span>   by the divisor, or nil otherwise (falsey).&#34;</span>
  [divisor the-word n]
  (when (zero? (rem n divisor))
    the-word))

(<span>def </span>fizzes?
  <span>&#34;Is a given number divisible by 3?&#34;</span>
  (partial divisible? <span>3</span> <span>&#34;Fizz&#34;</span>))

(<span>def </span>buzzes?
  <span>&#34;Is a given number divisible by 5?&#34;</span>
  (partial divisible? <span>5</span> <span>&#34;Buzz&#34;</span>))

(<span>def </span>fizzbuzzes?
  <span>&#34;Is a given number divisible by 3 and 5?&#34;</span>
  (partial divisible? <span>15</span> <span>&#34;FizzBuzz&#34;</span>))
</code></pre></div><p>Now we can rewrite <code>basic-buzz</code> using <code>or</code>, which short-circuits, and
returns the first <em>truthy</em> value it encounters. You will see this construct
in real-world Clojure code.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>or-buzz
  <span>&#34;Just like conditional matching, but exploit short-circuit behaviour of &#39;or&#39;.
</span><span>   Sadly, order of conditionals still matters.&#34;</span>
  [n]
  (or (<span>fizzbuzzes?</span> n)
      (<span>buzzes?</span> n)
      (<span>fizzes?</span> n)
      n))
</code></pre></div><p>We argued that we are essentially expressing a choice, and that we can even
do it with <code>juxt</code>, because once we grok <code>juxt</code>, we want to use it <em>everywhere</em>.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>juxt-buzz
  <span>&#34;juxt for fun:
</span><span>       e.g. ((juxt f g h) 42) -&gt; [(f 42) (g 42) (h 42)]
</span><span>       cf. https://clojuredocs.org/clojure.core/juxt
</span><span>   Sadly, order of conditional checks still matters, which combined with
</span><span>   the nil-punning that&#39;s going on here is too subtle for production use.&#34;</span>
  [n]
  (some identity ((<span>juxt</span> fizzbuzzes? buzzes? fizzes? identity)
                  n)))
</code></pre></div><p>Yeah, that’s a head-scratcher. Best leave it back at home.</p>
<h2 id="actually-domain-driven-fizzbuzz">Actually Domain Driven FizzBuzz<a href="#actually-domain-driven-fizzbuzz" arialabel="Anchor">⌗</a> </h2>
<p>You might protest that well actually the clever little functions, in fact,
express the domain of the <em>solution</em> (the business of calculating FizzBuzz),
not the domain of the <em>problem</em> (arithmetic representation of FizzBuzz).</p>
<p>And even though I flunked maths a lot, I would concur. So here goes nothing…</p>
<p>15 is the least common multiple of the prime factors. Suppose we cook up an
encoding scheme based on remainders of 15, and write it down as a lookup table?
We can then find <code>(rem n 15)</code>, and look up the answer to FizzBuzz in the table.</p>
<p>Why do a lookup table? Well, what is the simplest possible function? A literal
hard-coded lookup table!</p>
<p>In Clojure, we can use hash-maps to write down look-up tables.</p>
<div><pre tabindex="0"><code data-lang="clojure"><span>;; A table of remainders of 15, in a hash-map.</span>
{<span>0</span>  <span>&#34;FizzBuzz&#34;</span>
 <span>3</span>  <span>&#34;Fizz&#34;</span>
 <span>6</span>  <span>&#34;Fizz&#34;</span>
 <span>9</span>  <span>&#34;Fizz&#34;</span>
 <span>12</span> <span>&#34;Fizz&#34;</span>
 <span>5</span>  <span>&#34;Buzz&#34;</span>
 <span>10</span> <span>&#34;Buzz&#34;</span>}
</code></pre></div><p>And here is a very fun and useful fact. Clojure hash-maps are not just inert
data. They also behave as functions of their keys. We can literally call
<code>({:a 42} :a)</code> and get back 42. Noice!</p>
<p>So suppose we define a global lookup table?</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>def </span>rem15-&gt;fizz-buzz
  {<span>0</span>  <span>&#34;FizzBuzz&#34;</span>
   <span>3</span>  <span>&#34;Fizz&#34;</span>
   <span>6</span>  <span>&#34;Fizz&#34;</span>
   <span>9</span>  <span>&#34;Fizz&#34;</span>
   <span>12</span> <span>&#34;Fizz&#34;</span>
   <span>5</span>  <span>&#34;Buzz&#34;</span>
   <span>10</span> <span>&#34;Buzz&#34;</span>})

(<span>comment</span>
  (<span>rem15-&gt;fizz-buzz</span> (rem <span>3</span> <span>15</span>)) =&gt; <span>&#34;Fizz&#34;</span>
  (<span>rem15-&gt;fizz-buzz</span> (rem <span>5</span> <span>15</span>)) =&gt; <span>&#34;Buzz&#34;</span>
  (<span>rem15-&gt;fizz-buzz</span> (rem <span>15</span> <span>15</span>)) =&gt; <span>&#34;FizzBuzz&#34;</span>
  (<span>rem15-&gt;fizz-buzz</span> (rem <span>1</span> <span>15</span>)) =&gt; nil
  )
</code></pre></div><p>See the <code>nil</code> returned for “no result found”? If you were paying attention
to the nil punning <sup id="fnref:12"><a href="#fn:12" role="doc-noteref">12</a></sup>, and the short-circuiting <code>or</code>, you might get
the following idea. And you would not be wrong.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>or-rem15-buzz
  [n]
  (or (<span>rem15-&gt;fizz-buzz</span> (rem n <span>15</span>))
      n))
</code></pre></div><p>But we can be more right by using the <code>get</code> function, which is designed for
use with hash-maps, and which allows us to conveniently specify a fallback
value for the “not found” case.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>get-rem15-buzz
  [n]
  (get rem15-&gt;fizz-buzz
       (rem n <span>15</span>)
       n))
</code></pre></div><p>Not to press the point, but they are referentially transparent.</p>
<div><pre tabindex="0"><code data-lang="clojure">(= (map or-rem15-buzz (range <span>1</span> <span>16</span>))
   (map get-rem15-buzz (range <span>1</span> <span>16</span>)))
</code></pre></div><p>You may have also astutely noted that, in both the implementations above,
the order of calculation ceases to matter. Now we are doing maths.</p>
<h2 id="fizzbuzz-by-construction">FizzBuzz by construction<a href="#fizzbuzz-by-construction" arialabel="Anchor">⌗</a> </h2>
<p>Closely related to remainder lookup tables, we can make the observation that
FizzBuzz is cyclical in modulo 3, 5, and 15. So we can directly define the
<em>idea</em> of FizzBuzz in those terms.</p>
<p>This FizzBuzz is correctly ordered <em>by definition</em>.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>def </span>mod-cycle-buzz
  <span>&#34;We can declare a lazy sequence of FizzBuzz as modulo 3, 5, 15.
</span><span>  The sequence is ordered by definition.&#34;</span>
  (<span>let </span>[n  identity
        f  (constantly <span>&#34;Fizz&#34;</span>)
        b  (constantly <span>&#34;Buzz&#34;</span>)
        fb (constantly <span>&#34;FizzBuzz&#34;</span>)]
    (cycle [n n f
            n b f
            n n f
            b n f
            n n fb])))
</code></pre></div><p>Now, Clojure’s <code>map</code> is not only lazy, it can also apply a function of <code>n</code>
arguments over <code>n</code> collections until any one of the collections is exhausted.
So we can…</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>def </span>all-fizz-buzzes
  (map (<span>fn </span>[f n] (<span>f</span> n))
       mod-cycle-buzz <span>; countless modulo pattern</span>
       (rest (<span>range</span>)))) <span>; countless sequence of numbers</span>
</code></pre></div><p>If we think in terms of the prime factors 3 and 5, along with modulo cycles,
it may inspire a generalised version of fizzbuzz, like so.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>any-mod-cycle-buzz
  <span>&#34;Given a number and a sequence of words mapping to prime factors,
</span><span>   either return the corresponding word-version for the number position,
</span><span>   or the number itself, if no prime factor exists.
</span><span>
</span><span>   Basically, the set of words should map to set of prime factors.
</span><span>
</span><span>   We also don&#39;t make any assumptions about order of words here. It is up
</span><span>   to the caller to choose whatever sequence they please.&#34;</span>
  [num <span>&amp;</span> words]
  (or (<span>not-empty</span> (reduce str words))
      num))

(map any-mod-cycle-buzz
     (range <span>1</span> <span>16</span>)
     (cycle [nil nil <span>&#34;Fizz&#34;</span>])
     (cycle [nil nil nil nil <span>&#34;Buzz&#34;</span>]))
</code></pre></div><p>And last but not least, this interpretation allows us to express the arithmetic
<em>identity</em> of the whole category of FizzBuzzes, which is, just the number
sequence itself. (As in, the identity of + is 0 and that of * is 1).</p>
<div><pre tabindex="0"><code data-lang="clojure">(map any-mod-cycle-buzz
     (range <span>1</span> <span>16</span>))
</code></pre></div><p>But then again, I’ve flunked maths too often to be confident about any of this.
Please complain to me if I’m wrong.</p>
<h2 id="interlude-all-the-fizz-buzzes-so-far">Interlude: all the fizz-buzzes so far<a href="#interlude-all-the-fizz-buzzes-so-far" arialabel="Anchor">⌗</a> </h2>
<p>I’ll drop this mini <em>pièce de résistance</em> (for now), and pause for a breather.
I’ve copied down all the fizz-buzz variants (minus doc strings for brevity).</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>ns </span>all.them.fizz.buzzers)

(<span>def </span>fizz-buzz map) <span>; now, what `map` can do fizz-buzz can too</span>

<span>;; Le FizzBuzz Classique Functional</span>

(<span>defn </span>basic-buzz
  [n]
  (<span>let </span>[divisible? (comp zero? rem)]
    (<span>cond</span>
      (<span>divisible?</span> n <span>15</span>) <span>&#34;FizzBuzz&#34;</span>
      (<span>divisible?</span> n <span>5</span>) <span>&#34;Buzz&#34;</span>
      (<span>divisible?</span> n <span>3</span>) <span>&#34;Fizz&#34;</span>
      <span>:else</span> n)))


<span>;; Branching logic FizzBuzzes</span>

(<span>defn </span>divisible?
  [divisor the-word n]
  (when (zero? (rem n divisor))
    the-word))

(<span>def </span>fizzes? (partial divisible? <span>3</span> <span>&#34;Fizz&#34;</span>))
(<span>def </span>buzzes? (partial divisible? <span>5</span> <span>&#34;Buzz&#34;</span>))
(<span>def </span>fizzbuzzes? (partial divisible? <span>15</span> <span>&#34;FizzBuzz&#34;</span>))

(<span>defn </span>or-buzz
  [n]
  (or (<span>fizzbuzzes?</span> n)
      (<span>buzzes?</span> n)
      (<span>fizzes?</span> n)
      n))

(<span>defn </span>juxt-buzz
  [n]
  (some identity
        ((<span>juxt</span> fizzbuzzes? buzzes? fizzes? identity)
         n)))


<span>;; More mathematical FizzBuzzes</span>

(<span>def </span>rem15-&gt;fizz-buzz
  {<span>0</span>  <span>&#34;FizzBuzz&#34;</span>
   <span>3</span>  <span>&#34;Fizz&#34;</span>
   <span>6</span>  <span>&#34;Fizz&#34;</span>
   <span>9</span>  <span>&#34;Fizz&#34;</span>
   <span>12</span> <span>&#34;Fizz&#34;</span>
   <span>5</span>  <span>&#34;Buzz&#34;</span>
   <span>10</span> <span>&#34;Buzz&#34;</span>})

(<span>defn </span>or-rem15-buzz
  [n]
  (or (<span>rem15-&gt;fizz-buzz</span> (rem n <span>15</span>))
      n))

(<span>defn </span>get-rem15-buzz
  [n]
  (get rem15-&gt;fizz-buzz
       (rem n <span>15</span>)
       n))

(<span>def </span>mod-cycle-buzz
  (<span>let </span>[n  identity
        f  (constantly <span>&#34;Fizz&#34;</span>)
        b  (constantly <span>&#34;Buzz&#34;</span>)
        fb (constantly <span>&#34;FizzBuzz&#34;</span>)]
    (cycle [n n f
            n b f
            n n f
            b n f
            n n fb])))

(<span>defn </span>any-mod-cycle-buzz
  [num <span>&amp;</span> words]
  (or (<span>not-empty</span> (reduce str words))
      num))

<span>;; Inspect and check the fizz-buzzes</span>

(<span>defn </span>call-all-fizz-buzzers
  [range-of-buzzees]
  [(<span>fizz-buzz</span> basic-buzz
              range-of-buzzees)
   (<span>fizz-buzz</span> or-buzz
              range-of-buzzees)
   (<span>fizz-buzz</span> juxt-buzz
              range-of-buzzees)
   (<span>fizz-buzz</span> or-rem15-buzz
              range-of-buzzees)
   (<span>fizz-buzz</span> get-rem15-buzz
              range-of-buzzees)
   (<span>fizz-buzz</span> (<span>fn </span>[f n] (<span>f</span> n))
              mod-cycle-buzz
              range-of-buzzees)
   (<span>fizz-buzz</span> any-mod-cycle-buzz
              range-of-buzzees
              (cycle [nil nil <span>&#34;Fizz&#34;</span>])
              (cycle [nil nil nil nil <span>&#34;Buzz&#34;</span>]))])

(<span>defn </span>check-all-fizz-buzzers
  <span>&#34;Return true if all known fizz-buzzers produce equal results
</span><span>   for the programmer&#39;s FizzBuzz for numbers 1 to 100&#34;</span>
  []
  (apply = (<span>call-all-fizz-buzzers</span> (range <span>1</span> <span>101</span>))))
</code></pre></div><p>And lest we forget, let us flog the dead horse one last time.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>defn </span>severely-broken-buzz
  <span>&#34;Please don&#39;t do this in Clojure.&#34;</span>
  [n]
  (<span>cond</span>
    (<span>divisible?</span> n <span>15</span>) (println <span>&#34;FizzBuzz&#34;</span>)
    (<span>divisible?</span> n <span>3</span>) (println <span>&#34;Fizz&#34;</span>)
    (<span>divisible?</span> n <span>5</span>) (println <span>&#34;Buzz&#34;</span>)
    <span>:else</span> (println n)))
</code></pre></div><p>The mind is abuzz drafting moaaaar variants… Stay tuned!</p>
<h2 id="peano-fizzbuzz">Peano FizzBuzz<a href="#peano-fizzbuzz" arialabel="Anchor">⌗</a> </h2>
<p>Since we are computing with natural numbers, we can express FizzBuzz in terms
of the “Successor” operation of Peano arithmetic.</p>
<p>However, we have to modify our number system a bit to make it work right.
We define a PeanoBuzz number to be a pair of a natural number and its FizzBuzz
counterpart. The <em>PeanoBuzz</em> number system starts at <code>[0 0]</code>.</p>
<p>We can enjoy the fruits of compositionality that we planted earlier.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>ns </span>all.them.fizz.buzzers)

(<span>def </span>rem15-&gt;fizz-buzz
  {<span>0</span>  <span>&#34;FizzBuzz&#34;</span>
   <span>3</span>  <span>&#34;Fizz&#34;</span>
   <span>6</span>  <span>&#34;Fizz&#34;</span>
   <span>9</span>  <span>&#34;Fizz&#34;</span>
   <span>12</span> <span>&#34;Fizz&#34;</span>
   <span>5</span>  <span>&#34;Buzz&#34;</span>
   <span>10</span> <span>&#34;Buzz&#34;</span>})

(<span>defn </span>get-rem15-buzz
  [n]
  (get rem15-&gt;fizz-buzz
       (rem n <span>15</span>)
       n))

(<span>def </span>S
  <span>&#34;The PeanoBuzz number system starting at [0 0] is closed under
</span><span>  this definition of Successor.&#34;</span>
  (comp (<span>juxt</span> identity get-rem15-buzz)
        inc
        first))

(<span>def </span>all-peano-buzzes
  (iterate S [<span>0</span> <span>0</span>]))

(<span>comment</span>
  (= (take <span>16</span> all-peano-buzzes)
     [[<span>0</span> <span>0</span>] [<span>1</span> <span>1</span>] [<span>2</span> <span>2</span>]
      [<span>3</span> <span>&#34;Fizz&#34;</span>] [<span>4</span> <span>4</span>]
      [<span>5</span> <span>&#34;Buzz&#34;</span>]
      [<span>6</span> <span>&#34;Fizz&#34;</span>] [<span>7</span> <span>7</span>] [<span>8</span> <span>8</span>]
      [<span>9</span> <span>&#34;Fizz&#34;</span>]
      [<span>10</span> <span>&#34;Buzz&#34;</span>] [<span>11</span> <span>11</span>]
      [<span>12</span> <span>&#34;Fizz&#34;</span>] [<span>13</span> <span>13</span>] [<span>14</span> <span>14</span>]
      [<span>15</span> <span>&#34;FizzBuzz&#34;</span>]]))
</code></pre></div><p>Since we have a <code>S</code> that closes over the <em>PeanoBuzz</em> number system, I wonder
if we can satisfy all the <a href="https://en.wikipedia.org/wiki/Peano%5Faxioms">Peano Axioms</a>? Probably another blog post :)</p>
<p>Incidentally, we can trivially map the domain of PeanoBuzz back into the
domain of FizzBuzz.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>ns </span>all.them.fizz.buzzers)

(= (<span>fizz-buzz</span> basic-buzz
              (range <span>1</span> <span>101</span>))
   (<span>fizz-buzz</span> second
              (take <span>100</span> (rest all-peano-buzzes))))
</code></pre></div><p>We are already half way to Lambda Calculus / Church Numerals. But going there
will side-track our FizzBuzz expedition way too much. So I’ll leave the Church
Numerals version as an exercise to the reader <sup id="fnref:13"><a href="#fn:13" role="doc-noteref">13</a></sup>. Try to make it
so that that we can define an <code>all-church-nums-buzz</code> and slot it into the
<code>fizz-buzz</code> checks we already have.</p>
<h2 id="dispatch-buzz">Dispatch Buzz<a href="#dispatch-buzz" arialabel="Anchor">⌗</a> </h2>
<p>If you squint at the conditional FizzBuzzes, like <code>basic-buzz</code>, <code>or-buzz</code> etc.,
you might re-see them as a <em>dispatch</em> problem. And why would you be wrong?
They, like any other if-else-y construct are truth tables hard-wired to
“finalised” values or operations.</p>
<p>Naturally we will follow the consummate Clojurian’s primal instinct of needing
to pry apart two things masquerading as one (<em>“decomplecting”</em> <sup id="fnref:14"><a href="#fn:14" role="doc-noteref">14</a></sup>
in Clojurish). But, <em>what exactly</em> are we, ah, <em>decomplecting</em>? Now that is
a very interesting rabbit hole.</p>
<p>In this case we are <em>“separating mechanism from policy”</em> <sup id="fnref:15"><a href="#fn:15" role="doc-noteref">15</a></sup>.
Figuring out how to do this delivers a powerful, flexible method of program
design into our eager hands.</p>
<p>This table shows “mechanism” and “policy” hard-wired together.</p>
<div><pre tabindex="0"><code data-lang="org">&lt;<span>-- ------- MECHANISM -------- --</span>&gt;|&lt;<span>-- POLICY --</span>&gt;

<span>| n divisible? 3 | n divisible? 5 | Final value |</span>
<span>|----------------+----------------+-------------|</span>
<span>| true           | true           | FizzBuzz    |</span>
<span>| true           | false          | Fizz        |</span>
<span>| false          | true           | Buzz        |</span>
<span>| false          | false          | n           |</span>
</code></pre></div><p>Here is an attempt to pry the two apart.</p>
<p><em><strong>Mechanism</strong></em></p>
<p>The <em><strong>“mechanism”</strong></em> here is <em>any</em> function that translates a number (or more
generally, <em>any</em> thing) to the two inputs of a 2-value truth table. We can
see it more clearly if we rewrite the input columns of the truth table like
this. Here <code>f</code> and <code>g</code> are functions of <code>a</code> to Boolean.</p>
<div><pre tabindex="0"><code data-lang="org"><span>| (f a) | (g a) |</span>
<span>|-------+-------|</span>
<span>| true  | true  |</span>
<span>| true  | false |</span>
<span>| false | true  |</span>
<span>| false | false |</span>
</code></pre></div><p>We can express this as a Clojure punction ‘coz (f a) (g a) is ((juxt f g) a).</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>ns </span>dispatch.buzz)

(<span>defn </span>mechanism
  <span>&#34;Given two functions, presumably of anything -to-&gt; Boolean, return
</span><span>  a function that can construct inputs of a 2-input truth table.&#34;</span>
  [f? g?]
  (<span>juxt</span> f? g?))
</code></pre></div><p>See? Such abstract. Much general-purpose. Very decomplect. Wow.</p>
<p><em><strong>Policy</strong></em></p>
<p>Here, we define <em><strong>“policy”</strong></em> as something having special context of FizzBuzz
that consumes input rows of the truth table and emits corresponding output fields.</p>
<p>First, we specialise the abstract <code>mechanism</code> to a FizzBuzz mechanism. You
may smirk <sup id="fnref:16"><a href="#fn:16" role="doc-noteref">16</a></sup>, but just you wait. There is a (multi) method to the
madness…</p>
<p>Here is the table we started with, rewritten for our specialisation.</p>
<div><pre tabindex="0"><code data-lang="org"><span>| (fizzes? n) | (buzzes? n) | (mechanism fizzes? buzzes?) -&gt; mfb |</span>
<span>|-------------+-------------+------------------------------------|</span>
<span>| true        | true        | (mfb n) =&gt; &#34;FizzBuzz&#34;              |</span>
<span>| true        | false       | (mfb n) =&gt; &#34;Fizz&#34;                  |</span>
<span>| false       | true        | (mfb n) =&gt; &#34;Buzz&#34;                  |</span>
<span>| false       | false       | (mfb n) =&gt; n                       |</span>
</code></pre></div><p>Here is the intermediate step of the specialisation, viz. <code>(mechanism f g) -&gt; h</code>.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>ns </span>dispatch.buzz)

(<span>defn </span>divisible?
  [divisor n]
  (zero? (rem n divisor)))

(<span>def </span>fizzes? (partial divisible? <span>3</span>))
(<span>def </span>buzzes? (partial divisible? <span>5</span>))

<span>;; If we take the abstract mechanism and give it functions</span>
<span>;; that test numbers for fizzery and buzzery, then we can</span>
<span>;; construct a version of the truth table that is /concretely/</span>
<span>;; specific to FizzBuzz.</span>
(<span>comment</span>
  (= (map (<span>mechanism</span> fizzes? buzzes?)
          [<span>15</span> <span>3</span> <span>5</span> <span>1</span>])
     [[true true]
      [true false]
      [false true]
      [false false]])
  )
</code></pre></div><p>Finally, we hang it all together with Clojure’s multimethods <sup id="fnref:17"><a href="#fn:17" role="doc-noteref">17</a></sup>, like so.</p>
<div><pre tabindex="0"><code data-lang="clojure">(<span>ns </span>dispatch.buzz)

(<span>def </span>fizz-buzz map)

(<span>def </span>fizz-buzz-mechanism
  (<span>mechanism</span> fizzes? buzzes?))

(<span>defmulti </span>dispatch-buzz
  <span>&#34;It yields the third column of the truth table.&#34;</span>
  fizz-buzz-mechanism)

<span>;; The /Policy/, fully realised.</span>
<span>;; ((mechanism fizzes? buzzes?) n) -&gt; final results</span>
(<span>defmethod </span>dispatch-buzz [true true]
  [n]
  <span>&#34;FizzBuzz&#34;</span>)

(<span>defmethod </span>dispatch-buzz [true false]
  [n]
  <span>&#34;Fizz&#34;</span>)

(<span>defmethod </span>dispatch-buzz [false true]
  [n]
  <span>&#34;Buzz&#34;</span>)

(<span>defmethod </span>dispatch-buzz <span>:default</span>
  [n]
  n)

<span>;; The /Policy/, applied.</span>
(<span>comment</span>
  (= (<span>fizz-buzz</span> dispatch-buzz
                [<span>1</span> <span>3</span> <span>5</span> <span>15</span> <span>16</span>])
     [<span>1</span> <span>&#34;Fizz&#34;</span> <span>&#34;Buzz&#34;</span> <span>&#34;FizzBuzz&#34;</span> <span>16</span>])
  )
</code></pre></div><p>Yes, ‘tis a wee FizzBuzz interpreter!</p>
<p>(Pirouettes off-stage, gracefully.)</p>
<h2 id="buzz">TODO Buzz<a href="#buzz" arialabel="Anchor">⌗</a> </h2>
<p>Ideas on deck, to put self on the hook…</p>
<ul>
<li> curried fizzbuzz (like Ring libraries),</li>
<li> dispatch-based fizzbuzz (with multimethods),</li>
<li> OOP fizzbuzz (with protocols),</li>
<li> concurrent fizzbuzz (with agents, but the code in my head is
probably totally wrong),</li>
<li> parallel fizzbuzz, (just pmap, quite silly actually, but why not? It’s legit!)</li>
<li> transducing fizzbuzz, (should be able to transduce all the fizz-buzzes
up to Peano FizzBuzz)</li>
<li> maaabe also re-do Rich’s ants sim with FizzBuzz ants (4 species of, ah,
ConcurrAnts — IdentiAnt, FizzAnt, BuzzAnt, FizzBuzzAnt).</li>
</ul>
<p>Outside of clojure.core, maaaaybe core.async fizzbuzz, but IDK, maybe that
will be too high concept, and too contrived.</p>
<h2 id="acknowledgments">Acknowledgments<a href="#acknowledgments" arialabel="Anchor">⌗</a> </h2>
<p>Thanks to <a href="https://twitter.com/rdivyanshu">@rdivyanshu</a> for review and feedback.</p>
<section role="doc-endnotes">
<hr/>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Official and community-curated Clojure API docs <a href="https://clojure.org/api/api">https://clojure.org/api/api</a> <a href="#fnref:1" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Official guide: <a href="https://clojure.org/guides/repl/introduction">Programming at the REPL</a>. The REPL is an <em>eager</em> beast. Lazy sequences want to never be fully realised, if possible. But, a REPL is typically designed to fully evaluate everything it gets. This is why we didn’t feel the bite of mixing printing with lazy sequence generation. If we had this in our code somewhere, nothing would print, and any caller would get back just a useless collection of nils. <a href="#fnref:2" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>Laziness is a form of deferred computation. Clojure has “lazy sequences”. <code>for</code> generates a lazy sequence. Several essay-length answers await your eager perusal. Rich Hickey’s notes from back in the day: <a href="https://clojure.org/reference/lazy">Making Clojure Lazier</a>. Ramsharan G.J. muses <em>&#34;<a href="https://www.youtube.com/watch?v=XCYTvZtTetI">Lazy Seqs - Why are they so lazy?</a>&#34;</em> (<a href="https://speakerdeck.com/sharangj/lazy-sequences-why-are-they-so-lazy">slides</a>). Oitihjya Sen muses <a href="https://otee.dev/2022/01/17/lazy-clojure.html">Who Moved My Cheese: Laziness in Clojure</a>. Debashish Ghose has some thoughts on <a href="https://debasishg.blogspot.com/2010/05/laziness-in-clojure-some-thoughts.html">Laziness in Clojure</a>. <a href="#fnref:3" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>Watch Rafal Dittwald refactor some Javascript in <a href="https://www.youtube.com/watch?v=vK1DazRK%5Fa0">Solving Problems the Clojure Way</a>. Basically, we like to <em>prevent</em> side effecting code as much as humanely possible. When we can’t, we do <a href="https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell">Functional Core Imperative Shell</a>. <a href="#fnref:4" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>The <a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">full SICP textbook</a> is available free, online. The <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">video lecture series</a> from 1986. Further DuckDuck searches will yield various tours of SICP in Clojure. Still further into the deep end, there is now <a href="https://github.com/sicmutils">SICMUtils</a> in Clojure, built around the Structure and Interpretation of Classical Mechanics. <a href="#fnref:5" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>To anyone writing Clojure tutorials, please for the love of lambda, <em><strong>do not</strong></em> use <code>println</code> to “show” people results. You may think you are being kind by using a familiar way to “show” results, but it is far better to rip the bandage off right from the get go. Double down on teaching good REPL habits and quality FP thinking instead. <a href="#fnref:6" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:7" role="doc-endnote">
<p>Incidentally, the Classic implementation is also sensitive to the ordering of conditions, which is also a defect from a FP point of view, because there is no good reason to write an imperative control-flow-y interpretation of what could be a purely mathematical definition of FizzBuzz. <a href="#fnref:7" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:8" role="doc-endnote">
<p>Well, maybe Rich can convince you otherwise: <a href="https://www.infoq.com/presentations/Simple-Made-Easy/">Simple Made Easy</a>. <a href="#fnref:8" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:9" role="doc-endnote">
<p>I mean, don’t be actively malicious, of course. However, such a <em>category</em> of error can happen. And if “they” git-blame-fire you, then I’d say celebrate. You inadvertently self-evicted from a place that will destroy your soul with bad systems and bad management. <a href="#fnref:9" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:10" role="doc-endnote">
<p>One fine day, one of our Clojure services at $FormerEmployer, started to run out of heap space after a fresh deployment. Our service graphs looked like this <code>_/|_/|_/|_</code>. The sawtooth of heap death. It wasn’t super critical, and everybody was busy shipping features. So naturally we did some napkin math and rolled out a Jenkins job that triggered a rolling restart every six hours. Eventually, someone found the time to go debug the crashes. We had <em>memoized</em> a function that returned an anonymous function (a lambda or <em>thunk</em>), when we meant to memoize the return value from evaluating said lambda. Clojure creates a <em>new</em> object every time we ask it to make a lambda. So <a href="https://clojuredocs.org/clojure.core/memoize">memoize</a> saw new return values every time the original “thunkified” function was called, dutifully cached them all, and held onto them, thus preventing JVM garbage collector from cleaning them out. The story is relevant here because <em>thunking</em> (making functions return partially evaluated fuctions) is a form of delayed or “lazy” evaluation. Also because nobody was fired. Everyone learned a good lesson and had a good laugh. In fact, we continued to use the rolling restart job in at least one other case where the memory leak was very slow, the service was very fault tolerant, and the service owner was really pressed for time with other always-higher priorities in that hyper-growth phase of the company. Slow leak tolerance is very much justified when used carefully. In fact, the friend who owned that service recently told me the periodic restart method worked so well, that they almost forgot about it for several years until they did a whole data center migration, at which point the service crashed for the first time in years, because someone forgot to also switch on the restart job. More good laughs were had and the documentation and automation were improved. You may now like to read <a href="https://devblogs.microsoft.com/oldnewthing/20180228-00/?p=98125"><em>“An amusing story about a practical use of the null garbage collector”</em></a>. <a href="#fnref:10" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:11" role="doc-endnote">
<p>“<a href="https://www.merriam-webster.com/dictionary/complect">Complect</a>&#34;-ed, if you speak Clojurish. When a Thing is made of lots of Sub-Things that are braided together tightly, we say “This Thing is <em>complected</em>.” in Clojurish. After we transform and reconstitute the Thing in terms of sub-things that are <em>no longer</em> braided together, we smile inwardly and say “This Thing is now <em>decomplected</em>”. Clojurish is basically a postmodern revival of the Latin roots of American English. <a href="#fnref:11" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:12" role="doc-endnote">
<p>Eric Normand on <em><a href="https://ericnormand.me/podcast/what-is-nil-punning">“What is Nil Punning?&#34;</a></em>. <a href="#fnref:12" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:13" role="doc-endnote">
<p>For reference, <a href="https://github.com/adityaathalye/sicp/blob/master/ex2-06-church-numerals.scm">my attempt</a> at implementing <a href="https://en.wikipedia.org/wiki/Church%5Fencoding">Church Numerals</a> in SICP. <a href="#fnref:13" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:14" role="doc-endnote">
<p>See the footnote for “Complect”. <a href="#fnref:14" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:15" role="doc-endnote">
<p>Arne Brasseur on <a href="https://www.lambdaisland.com/blog/2022-03-10-mechanism-vs-policy">Improve your code by separating mechanism from policy</a>. Don’t you just love it when Lots Of Thoughts are rattling around in your brain, and someone drops a sweet one-liner that instantly crystallises it all for you? Thanks <a href="https://twitter.com/robstuttaford">@RobStuttaford</a> for bringing this back into my consciousness! <a href="#fnref:15" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:16" role="doc-endnote">
<p>I see you and that <code>AbstractFactoryFactory</code> joke forming in your brain. <a href="#fnref:16" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:17" role="doc-endnote">
<p>See <a href="https://clojure.org/reference/multimethods">Multimethods and Hierarchies</a> page at the official site, and the <a href="https://clojuredocs.org/quickref#multifunctions">Multifunctions</a> section at ClojureDocs for examples. This stuff may break your brain for a bit, if you are very accustomed to Class-y OO programming. That’s absolutely fine. It <em>is</em> fairly mind bending and takes some getting used to. Stay with it, play with concepts against the REPL. Translate or reduce as many patterns as you can to this kind of open-ended multiple dispatch. <a href="#fnref:17" role="doc-backlink">↩︎</a></p>
</li>
</ol>
</section>
</div></div></div>
  </body>
</html>
