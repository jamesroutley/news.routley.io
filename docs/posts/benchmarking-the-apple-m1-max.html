<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tlkh.dev/benchmarking-the-apple-m1-max">Original</a>
    
    <div id="readability-page-1" class="page"><div id="post-content-wrapper" itemprop="text"><h2 id="heading-introduction">Introduction</h2>
<p>I recently got a 2021 16&#34; M1 Max MacBook Pro. It&#39;s amazing for day-to-day use, but I was curious about the actual capabilities of the SOC. Benchmarking is a complex task, and there are plenty of outlets like  <a target="_blank" href="https://www.anandtech.com/show/17024/apple-m1-max-performance-review">Anandtech</a> that have comprehensively done different benchmarks. However, I still had questions, so here I am with some (casual) benchmarks that I hope add some additional perspective into interesting hardware capabilities on the M1 Max SOC, just for fun and out of my curiosity.</p>
<p>P.S. Benchmarking is complex with many different methodologies and configurations, and I am under no delusion that what I have come up with is the best way to do things. Constructive feedback is welcome! </p>
<h2 id="heading-cpu">CPU</h2>
<p>The CPU in the M1 Max is a 10-core CPU, with 2 efficiency cores at 2.1 GHz and 8 performance cores at 3.0 GHz during all-core load. There should be no difference between the CPU performance on the M1 Max and M1 Pro, barring slightly higher memory bandwidth available to the CPU complex on the M1 Max. As a reference point for comparison purposes, I have my desktop  <a target="_blank" href="https://www.amd.com/en/products/cpu/amd-ryzen-5-5600x">AMD Ryzen 5600X CPU</a> with DDR4 memory and not overclocked. The desktop is running Ubuntu 20.04.</p>
<h3 id="heading-matrix-multiplication-gemm-performance">Matrix Multiplication (GEMM) Performance</h3>
<p>We already know that the M1 Max CPU should have really strong matrix multiplication performance due to Apple&#39;s  <a target="_blank" href="https://gist.github.com/dougallj/7a75a3be1ec69ca550e7c36dc75e0d6f">&#34;hidden&#34;/undocumented AMX co-processor</a>  embedded in the CPU complex, and that it is leveraged when you use Apple&#39;s  <a target="_blank" href="https://developer.apple.com/documentation/accelerate">Accelerate</a> framework. What <strong>I</strong> didn&#39;t know is that you can compile NumPy to work with Accelerate, which allows you to easily leverage the AMX instructions via normal NumPy code (NumPy installed via conda does <strong>not</strong> include Accelerate support, and instead uses cblas). The results are quite stunning, especially for single precision, or FP32 (which is commonly used in machine learning applications), giving us about <strong>almost 2 TFLOPS</strong> for large enough matrix sizes (about the level of a GTX 1050 Ti). Mind you, this is via normal Python NumPy code. Presumably, if you use Accelerate directly via a lower-level language, you can get even better performance. Compared to the 5600X, the M1 Max CPU is generally at least 2x faster any data type and any matrix size, even with  <a target="_blank" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html">MKL</a>  enabled on the 5600X.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1636904092578/gYLNmTc_s.png?auto=compress,format&amp;format=webp" alt="GEMM TFLOPS Benchmarks"/></p>
<h3 id="heading-other-numpy-benchmarks">Other NumPy Benchmarks</h3>
<p>Of course, GEMM is not all. For other common NumPy functions, the differences while benchmarking are not as dramatic. Tested functions include random number generation, special functions (exp/trigo/log/power), statistical (mean/median/std), vector multiplication, SVD, and more.</p>
<p>(Execution timings for function reported, <strong>lower is better</strong>)</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1636970595029/gthCI6Rjd.png?auto=compress,format&amp;format=webp" alt="Other Numpy Benchmarks"/></p>
<p>Out of the 7 tasks tested:</p>
<ul>
<li>M1 Max, with Accelerate, is faster on 3 tasks (RNG, special, Cholesky)</li>
<li>Both are about the same on 1 task (stats)</li>
<li>5600X, with MKL is faster on 3 tasks (SVD, VecMul, eigendecomp)</li>
</ul>
<h3 id="heading-python-performance">Python Performance</h3>
<p>In general, Python runs really fast on the M1 Max. Here, the PyPerformance benchmark, an official suite of real-world Python application benchmarks. Overall, the M1 Max is <strong>about 70% faster</strong> than the 5600X.</p>
<p>(Execution timings reported, <strong>lower is better</strong>)</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1636903099070/BeN9wzF1y.png?auto=compress,format&amp;format=webp" alt="PyPerformance Benchmark"/></p>
<p>Notable exceptions where the 5600X is significantly faster:</p>
<ul>
<li>pidigits (generate digits of Pi)</li>
<li>Tornado HTTP server</li>
</ul>
<h3 id="heading-spacy-nlp-models">SpaCy NLP models</h3>
<p>For the execution of SpaCy NLP models, the M1 is generally faster than 5600X, even with MKL! On M1 Max, having Accelerate via NumPy doesn&#39;t seem to affect anything, except for the PyTorch-based Transformer model which does seem to be affected by NumPy performance. Installing SpaCy&#39;s AppleOps package which allows SpaCy to directly call Accelerate, resulting in a dramatic performance improvement.</p>
<p>(Tokens/second reported, higher is better)</p>
<div>
<table>
<thead>
<tr>
<td>config</td><td>en_core_web_sm</td><td>en_core_web_md</td><td>en_core_web_lg</td><td>en_core_web_trf</td></tr>
</thead>
<tbody>
<tr>
<td>M1 Max (conda)</td><td>3143</td><td>2899</td><td>2853</td><td>309</td></tr>
<tr>
<td>M1 Max (NumPy+Accelerate)</td><td>3191</td><td>2899</td><td>2900</td><td>1064</td></tr>
<tr>
<td>M1 Max (AppleOps)</td><td><strong>17295</strong></td><td><strong>16772</strong></td><td><strong>16670</strong></td><td><strong>1121</strong></td></tr>
<tr>
<td>5600X</td><td>9580</td><td>8748</td><td>8773</td><td>487</td></tr>
<tr>
<td>5600X + MKL</td><td>13895</td><td>12843</td><td>12916</td><td>1107</td></tr>
</tbody>
</table>
</div><h3 id="heading-pandas">Pandas</h3>
<p>(Execution timings reported in seconds, <strong>lower is better</strong>)</p>
<div>
<table>
<thead>
<tr>
<td>Task</td><td>M1 Max</td><td>5600X</td></tr>
</thead>
<tbody>
<tr>
<td>datagen</td><td><strong>3.2</strong></td><td>3.4</td></tr>
<tr>
<td>inner_merge</td><td><strong>17.6</strong></td><td>27.4</td></tr>
<tr>
<td>outer_merge</td><td><strong>27.6</strong></td><td>41.9</td></tr>
</tbody>
</table>
</div><p><code>outer_merge</code> is single-thread only, while the rest were run with the optimal number of threads tested:</p>
<ul>
<li>5600X: 2 threads was the fastest (tested 1, 2, 4, 6, 12)</li>
<li>M1: 10 threads was the fastest (tested 1, 2, 8, 10)</li>
</ul>
<p>This benchmark appears to be almost entirely memory-bound, which is why adding more cores on the 5600X does not help (2 cores are enough to maximize memory bandwidth), while 10 cores on the M1 Max is the optimal configuration (while also being the configuration giving the highest memory bandwidth). You can look at the memory-related benchmarks in the <a href="#memory">Memory</a> section. Thus, I hypothesize that the main feature of the M1 Max that is working in its favor is its much higher memory bandwidth, even in a single-core configuration. </p>
<h2 id="heading-gpu">GPU</h2>
<p>I have the version of M1 Max with the 32-core GPU (Apple G13X, Metal GPUFamily Apple 7), running at 1.2 GHz and apparently max power consumption of about 60W. In general, I ran the benchmarks with High Power Mode enabled and on AC power, although after some testing this does not seem to affect the benchmarks in any way.</p>
<p>One interesting thing I noticed early on is that the system reports the idle frequency of the GPU to be very, <strong>very</strong> low, at single-digit MHz, something which I have never observed. This is likely due to some clever clock-gating design on the M1 Max SOC, which allows for low power draw by idle components of the SOC by individually clocking them much lower than the rest of the SOC. </p>
<p>In terms of programmability, you can use Metal, but I took the easier approach by using <a target="_blank" href="https://www.tensorflow.org/">TensorFlow</a>, using  <a target="_blank" href="https://developer.apple.com/metal/tensorflow-plugin/">Apple&#39;s Metal device plugin</a>. The process to set it up was surprisingly painless, and it allowed me to use the GPU compute capabilities via Python.</p>
<h3 id="heading-gpu-matrix-multiplication-gemm-performance">GPU Matrix Multiplication (GEMM) Performance</h3>
<p>Because TensorFlow works, we can use it for a general Matrix Multiplication benchmark as well. It seems we can get about <strong>8 TFLOPS</strong> from the GPU pretty easily via TensorFlow. </p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1636907429006/7OZDH-LSX.jpeg?auto=compress,format&amp;format=webp" alt="M1 Max GPU TFLOPS plot"/></p>
<h3 id="heading-tensorflow-training">TensorFlow Training</h3>
<p>The GPU on the M1 Max is also very usable for training deep learning models.</p>
<div>
<table>
<thead>
<tr>
<td>Model</td><td>GPU</td><td>BatchSize</td><td>Throughput</td></tr>
</thead>
<tbody>
<tr>
<td>ResNet50</td><td>M1 Max 32c</td><td>128</td><td>140 img/sec</td></tr>
<tr>
<td>MobileNetV2</td><td>M1 Max 32c</td><td>128</td><td>352 img/sec</td></tr>
<tr>
<td>DistilBERT</td><td>M1 Max 32c</td><td>64</td><td>120 seq/sec</td></tr>
<tr>
<td>BERTLarge</td><td>M1 Max 32c</td><td>16</td><td>19 seq/sec</td></tr>
</tbody>
</table>
</div><p>How does that compare to a desktop RTX 3090 (400W power limit)?</p>
<div>
<table>
<thead>
<tr>
<td>Model</td><td>GPU</td><td>BatchSize</td><td>Throughput</td></tr>
</thead>
<tbody>
<tr>
<td>Same Batch Size as M1</td><td></td><td></td><td></td></tr>
<tr>
<td>ResNet50</td><td>3090</td><td>128</td><td>1100 img/sec</td></tr>
<tr>
<td>MobileNetV2</td><td>3090</td><td>128</td><td>2001 img/sec</td></tr>
<tr>
<td>DistilBERT</td><td>3090</td><td>64</td><td>1065 seq/sec</td></tr>
<tr>
<td>BERTLarge</td><td>3090</td><td>16</td><td>131 seq/sec</td></tr>
<tr>
<td>Larger Batch Size</td><td></td><td></td><td></td></tr>
<tr>
<td>ResNet50</td><td>3090</td><td>256</td><td>1185 img/sec</td></tr>
<tr>
<td>MobileNetV2</td><td>3090</td><td>256</td><td>2197 img/sec</td></tr>
<tr>
<td>DistilBERT</td><td>3090</td><td>256</td><td>1340 seq/sec</td></tr>
<tr>
<td>BERTLarge</td><td>3090</td><td>64</td><td>193 seq/sec</td></tr>
</tbody>
</table>
</div><p>Pretty much what we would expect, with the M1 Max having about 8x less performance, but at 8x less power, so performance per watt is surprisingly quite comparable between the two. Power observed for M1 Max GPU was 35-42W, versus 335-380W on the 3090. Note the 3090&#39;s software stack is much more mature, allowing the use of the XLA compiler and Tensor Cores. </p>
<h3 id="heading-performance-at-different-power-levels">Performance at different power levels</h3>
<p>Because I saw some discussion on the matter, I decided to attempt to investigate the performance difference at different power levels for the M1 Max and 3090. </p>
<ul>
<li>M1 Max: only high power (aka normal &lt;60W) and low power (~15W apparently) modes</li>
<li>3090: power limit set with nvidia-smi, no tuning of clocks/voltages etc</li>
</ul>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1637323980250/ey0NcPl0T.jpeg?auto=compress,format&amp;format=webp" alt="Performance at different power levels"/></p>
<p>Important note: a trend line is added to the M1 Max data points on the graph. I don&#39;t think it&#39;s a scientific way to predict M1 Max performance if we could actually unlock the power limit etc. but it is a visual aid to see how it lines up, potentially.</p>
<h3 id="heading-performance-at-different-batch-size">Performance at different batch size</h3>
<p>Similarly, here is some investigation of how the training performance is at different batch sizes. The 3090 is at stock settings, M1 Max with high power mode. At batch size 256, the M1 Max (32GB) started to use swap, and the performance to about 1/3. Presumably, if we could use FP16 for GPU (may or may not come in future SW update), this will be less of an issue, since 3090 (24GB) trains at FP16 just fine.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1637324099956/dXhnY4Mdy.png?auto=compress,format&amp;format=webp" alt="Screenshot 2021-11-19 at 19.54.32.png"/></p>
<h2 id="heading-neural-engine">Neural Engine</h2>
<p>One especially interesting component I wanted to play around with was the 16-core Apple Neural Engine (ANE), which is a bit of an <a target="_blank" href="https://github.com/hollance/neural-engine">undocumented enigma</a>. We can easily use it via Python by using Apple&#39;s <a target="_blank" href="https://github.com/apple/coremltools">coremltools</a> Python library, which can be used to convert models to Apple&#39;s <a target="_blank" href="https://coremltools.readme.io/docs/ml-programs">MLProgram</a> format, and also call inference on the ANE. I needed to build the library from  <a target="_blank" href="https://github.com/apple/coremltools">source</a> for the inference to work, but model conversion worked with the pip install. </p>
<p>According to Apple, ANE delivers 11TOPS at what presumably is INT8 performance, although we do not have access to call INT8 operations (<a target="_blank" href="https://coremltools.readme.io/docs/typed-execution">CoreML currently only exposes FP16 ops on the ANE</a>). Thus, we can assume a maximum of 5.5 TFLOPS FP16 on the ANE. This would be the same across A14/M1/M1 Pro/M1 Max as they have the same 16-core ANE. From our benchmarks below, we can achieve 5.1-5.3 TFLOPS FP16. </p>
<p>One important caveat here is that you cannot force a CoreML model to run on the ANE, you can only specify CPU, CPU/GPU, or CPU/GPU/ANE constraints. Hence, sometimes your model might run on the GPU instead of the ANE, and you cannot control this decision made by CoreML. We will see this happen for large batch sizes in the ResNet50 benchmark later.</p>
<h3 id="heading-matrix-multiplications">Matrix Multiplications</h3>
<p>How do we execute Matrix Multiplications on the ANE? My simple method is to bunch up a few of them and export it as a TensorFlow model. (It works!) It is important to stack many MatMuls in a single model call, as there is an overhead of calling the inference operation on the ANE, and if you call it once for every MatMul, the performance is very bad!</p>
<p>With a stack of 20 2048x2048 MatMuls, we get about <strong>5.1 TFLOPS</strong> FP16. Not bad!</p>
<h3 id="heading-convolutions">Convolutions</h3>
<p>For a more &#34;real-world&#34; benchmark, we execute a stack of convolution operations, similar to the MatMul benchmark. Why not use a real model, such as ResNet-50? The short answer is, I can more reliably compute the FLOPS from a simple stack of convolutions, and it is sufficient to satisfy my curiosity.</p>
<p>With a stack of 50 layers of 256 3x3 Conv2D filters, and input image size of 512x512, we get about <strong>5.3 TFLOPS</strong> FP16. Seems about right too.</p>
<h3 id="heading-resnet50-inference">ResNet50 Inference</h3>
<p>Using CoreML, I ran ResNet50 inference at various batch sizes, and compared the ANE to the 32-core GPU as well. </p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1636966507314/UjlTfWKnl.png?auto=compress,format&amp;format=webp" alt="Screenshot 2021-11-15 at 16.54.26.png"/></p>
<p>Key observations:</p>
<ul>
<li>At batch size &lt;32, the ANE is faster</li>
<li>At batch size 1, the ANE does ~38img/sec while the GPU does ~30img/sec</li>
<li>At batch size 256, the ANE does ~424img/sec while the GPU does ~674img/sec</li>
<li>At about 4 GFLOPS (estimated) per image, this is about 1.7 TFLOPS on the ANE and 2.7 TFLOPS on the GPU</li>
<li><strong>At batch size 512, CoreML does not use the ANE (it switches to the GPU instead)</strong></li>
</ul>
<h2 id="heading-memory">Memory</h2>
<p>The &#34;Unified Memory&#34; system on the M1-series of SOC is one of the most interesting things of the Apple Silicon architecture so far, allowing for not just a unified pool of memory resources, but also potentially zero-copy memory access between the CPU, GPU and other SOC components. On the M1 Max, the advertised memory bandwidth is 400 GB/s, much more than any other SOC on the market today! In fact, it is similar to a medium-range graphics card, but presumably because it is LPDDR5 instead of GDDR5/6, it has a lower latency and power consumption. The memory bandwidth is enabled by an actually crazy 512-bit bus.</p>
<h3 id="heading-cpu-memory-bandwidth">CPU Memory Bandwidth</h3>
<p>We can use the STREAM benchmark ( <a target="_blank" href="https://www.intel.com/content/www/us/en/developer/articles/technical/optimizing-memory-bandwidth-on-stream-triad.html">website is currently down, link to alternate source</a> ) to measure peak memory bandwidth usable by the CPU.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1636909687455/PMjGdwqDF.png?auto=compress,format&amp;format=webp" alt="STREAM"/></p>
<p>Yup, expected nothing less LOL. We can get about 200GB/s from the entire CPU complex. You can see the jump from single core/thread (about 90GB/s) to multiple threads saturating memory bandwidth from the entire P-CPU clusters, then to 10 threads saturating memory bandwidth from the entire CPU complex (with both the P-clusters and the E-cluster). </p>
<p>The observation here tracks with the memory-bound Pandas benchmark, where 10-thread works best on M1 Max and 2-thread works best on 5600X. In practice, not a lot of CPU tasks use such a high level of memory bandwidth, but when it does, the benefits are huge. </p>
<h3 id="heading-gpu-memory-bandwidth">GPU Memory Bandwidth</h3>
<p>Again using TensorFlow, we can write a memory intensive benchmark similar to STREAM, and measure what we can achieve. By performing an element-wise multiply-addition operation on a large 8192x8192 matrix, we create an entirely memory-bound task (very low FLOPS), and we can look at the bandwidth counters from the <a target="_blank" href="https://www.unix.com/man-page/osx/1/powermetrics/">powermetrics</a> tool on macOS. We can observe about 330 GB/s of sustained bandwidth. In practice, training deep learning models seem to use between 200-300GB/s of memory bandwidth on average. </p>
<h3 id="heading-combined-memory-bandwidth">Combined Memory Bandwidth</h3>
<p>So we can get about 200GB/s from the CPU, and about 330GB/s from the GPU. When we put them together, we can observe a combined bandwidth of 360GB/s, clearly some competition between the CPU and GPU. Below is the visualisation from <a target="_blank" href="https://github.com/tlkh/asitop">asitop</a> also showing the breakdown in bandwidth between the CPU clusters and the GPU, and other SOC components. </p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1636910405515/BltNWEVpg.png?auto=compress,format&amp;format=webp" alt="asitop total bandwidth"/></p>
<h3 id="heading-zero-copy-memory-access">Zero-copy Memory Access</h3>
<p>For this section, I wanted to test Zero-copy Memory Access via TensorFlow, which would be a reasonable application that can benefit from the unified memory architecture. However, it seems in the current build of TF-Metal, zero copy access is <strong>not</strong> working, maybe because the CPU parts are not executed in Metal.</p>
<p>For those curious, here are what the figures look like now (estimated from the throughput of the benchmark same as the GPU bandwidth test). The comparison system is a RTX 3090 connected to a 5600X via PCIE Gen 4 x16 (32GB/s theoretical bandwidth). </p>
<div>
<table>
<thead>
<tr>
<td>M1 Max</td><td>Bandwidth</td><td>5600X+3090</td><td>Bandwidth</td></tr>
</thead>
<tbody>
<tr>
<td>CPU -&gt; GPU</td><td>48 GB/s</td><td>CPU -&gt; GPU</td><td>30 GB/s</td></tr>
<tr>
<td>GPU -&gt; CPU</td><td>19 GB/s</td><td>GPU -&gt; CPU</td><td>19 GB/s</td></tr>
</tbody>
</table>
</div><h2 id="heading-package-power">Package Power</h2>
<ul>
<li>Idle: ~2W</li>
<li>YouTube video on Google Chrome: ~3W </li>
<li>MS Teams (Rosetta app), call with background blur: ~10W</li>
<li>Package power seems to have a ~92W hard limit</li>
<li>Fans hardly spin up from zero-RPM</li>
</ul>
<h3 id="heading-components-power">Components Power</h3>
<ul>
<li>CPU seems to consume up to 40W max</li>
<li>GPU seems to consume up to 60W max, usually 40-50W during benchmarks</li>
<li>ANE seems to consume no more than 8W max, usually much lower (2-4W during the ResNet benchmarks)</li>
</ul>
<h2 id="heading-benchmark-code">Benchmark Code</h2>
<p>The code used to perform the benchmarks related to this blog post can be found in the GitHub repositories linked below. The benchmarks are performed mainly for my own curiosity, and thus may not have a high level of polish. In addition, some of the benchmarks were performed with some background applications running - I do not expect it to affect the benchmarks significantly, and this is not meant to produce the absolute best numbers for fanboys to fight it out. Sometimes the internet is scary &gt;&lt; </p>
<ul>
<li>CPU and some memory benchmarking code: <a target="_blank" href="https://github.com/tlkh/m1-cpu-benchmarks">https://github.com/tlkh/m1-cpu-benchmarks</a></li>
<li>GPU, ANE, some memory benchmarks: <a target="_blank" href="https://github.com/tlkh/tf-metal-experiments">https://github.com/tlkh/tf-metal-experiments</a></li>
<li>Monitoring tool asitop: <a target="_blank" href="https://github.com/tlkh/asitop">https://github.com/tlkh/asitop</a></li>
</ul>
</div></div>
  </body>
</html>
