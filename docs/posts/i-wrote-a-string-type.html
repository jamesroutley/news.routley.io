<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mcyoung.xyz/2023/08/09/yarns/">Original</a>
    <h1>I wrote a string type</h1>
    
    <div id="readability-page-1" class="page"><div> <p><span> <span> <a href="https://mcyoung.xyz/tags.html#dark-arts">#dark-arts</a> <a href="https://mcyoung.xyz/tags.html#pointers">#pointers</a> <a href="https://mcyoung.xyz/tags.html#rust">#rust</a> </span> <span> 2023-08-09 </span> </span></p> <p>I write compilers for fun. I can’t help it. Consequently, I also write a lot of parsers. In systems programming, it’s usually a good idea to try to share memory rather than reuse it, so as such my AST types tend to look like this.</p> <div><figure><pre><code data-lang="rust"><span>pub</span> <span>enum</span> <span>Expr</span><span>&lt;</span><span>&#39;src</span><span>&gt;</span> <span>{</span>
  <span>Int</span><span>(</span><span>u32</span><span>)</span>
  <span>Ident</span><span>(</span><span>&amp;</span><span>&#39;src</span> <span>str</span><span>),</span>
  <span>// ...</span>
<span>}</span></code></pre></figure></div> <p>Whenever we parse an identifier, rather than copy its name into a fresh <code>String</code>, we borrow from the input source string. This avoids an extra allocation, an extra copy, and saves a word in the representation. Compilers can be memory-hungry, so it helps to pick a lean representation.</p> <p>Unfortunately, it’s not so easy for quoted strings. Most strings, like <code>&#34;all my jelly babies&#34;</code>, are “literally” in the original source, like an identifier. But strings with escapes aren’t: <code>\n</code> is encoded in the source code with the bytes <code>[0x5c, 0x6e]</code>, but the actual “decoded” value of a string literal replaces each escape with a single <code>0x0a</code>.</p> <p>The usual solution is a <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow&lt;str&gt;</code></a>. In the more common, escape-less verison, we can use <code>Cow::Borrowed</code>, which avoids the extra allocation and copy, and in the escaped version, we decode the escapes into a <code>String</code> and wrap it in a <code>Cow::Owned</code>.</p> <p>For example, suppose that we’re writing a parser for a language that has quoted strings with escapes. The string <code>&#34;all my jelly babies&#34;</code> can be represented as a byte string that borrows the input source code, so we’d use the <code>Cow::Borrowed</code> variant. This is most strings in any language: escapes tend to be rare.</p> <p>For example, if we have the string <code>&#34;not UTF-8 \xff&#34;</code>, the actual byte string value is different from that in the source code.</p> <div><figure><pre><code data-lang="text">// Bytes in the source.
hex:   6e 6f 74 20 55 54 46 2d 38 20 5c 78 66 66
ascii: n  o  t     U  T  F  -  8     \  x  f  f

// Bytes represented by the string.
hex:   6e 6f 74 20 55 54 46 2d 38 20 ff
ascii: n  o  t     U  T  F  -  8</code></pre></figure></div> <p>Escapes are relatively rare, so most strings processed by the parser do not need to pay for an allocation.</p> <p>However, we still pay for that extra word, since <code>Cow&lt;str&gt;</code> is 24 bytes (unless otherwise specified, all byte counts assume a 64-bit system), which is eight more than our <code>&amp;str</code>. Even worse, this is bigger than the string data itself, which is 11 bytes.</p> <p>If most of your strings are small (which is not uncommon in an AST parser), you will wind up paying for significant overhead.</p> <p>Over the years I’ve implemented various optimized string types to deal with this use-case, in various contexts. I finally got around to putting all of the tricks I know into a library, which I call <a href="https://docs.rs/byteyarn/latest/byteyarn/"><code>byteyarn</code></a>. It advertises the following nice properties.</p> <blockquote> <p>A <code>Yarn</code> is a highly optimized string type that provides a number of useful properties over <code>String</code>:</p> <ul> <li>Always two pointers wide, so it is always passed into and out of functions in registers.</li> <li>Small string optimization (SSO) up to 15 bytes on 64-bit architectures.</li> <li>Can be either an owned buffer or a borrowed buffer (like <code>Cow&lt;str&gt;</code>).</li> <li>Can be upcast to <code>&#39;static</code> lifetime if it was constructed from a known-static string.</li> </ul> </blockquote> <p>I’d like to share how these properties are achieved through careful layout optimization.</p> <h2 id="assumptions"><a href="#assumptions">Assumptions</a></h2> <p>We’re going to start by stating assumptions about how our strings will be used:</p> <ol> <li>Most strings are not mutated most of the time.</li> <li>Most strings are small.</li> <li>Most strings are substrings.</li> </ol> <h3 id="most-strings-are-immutable"><a href="#most-strings-are-immutable">Most Strings are Immutable</a></h3> <p><code>String</code> is modeled after C++’s <code>std::string</code>, which is a growable buffer that implements amortized linear-time append. This means that if we are appending <code>n</code> bytes to the buffer, we only pay for <code>n</code> bytes of <code>memcpy</code>.</p> <p>This is a useful but often unnecessary property. For example, Go strings are immutable, and when building up a large string, you are expected to use <code>strings.Builder</code>, which is implemented as essentially a Rust <code>String</code>. Java also as a similar story for strings, which allows for highly compact representations of <code>java.lang.String</code>s.</p> <p>In Rust, this kind of immutable string is represented by a <code>Box&lt;str&gt;</code>, which is eight bytes smaller than <code>String</code>. Converting from <code>String</code> to <code>Box&lt;str&gt;</code> is just a call to <code>realloc()</code> to resize the underlying allocation (which is often cheap<sup id="fnref:size-classes" role="doc-noteref"><a href="#fn:size-classes" rel="footnote">1</a></sup>) from being <code>capacity</code> bytes long to <code>len</code> bytes long.</p> <p>Thus, this assumption means we only need to store a pointer and a length, which puts our memory footprint floor at 16 bytes.</p> <h3 id="most-strings-are-substrings"><a href="#most-strings-are-substrings">Most Strings are Substrings</a></h3> <p>Suppose again that we’re parsing some textual format. Many structural elements will be verbatim references into the textual input. Not only string literals without escapes, but also identifiers.</p> <p><code>Box&lt;str&gt;</code> cannot hold borrowed data, because it will always instruct the allocator to free its pointer when it goes out of scope. <code>Cow&lt;str&gt;</code>, as we saw above, allows us to handle maybe-owned data uniformly, but has a minimum 24 byte overhead. This can’t be made any smaller, because a <code>Cow&lt;str&gt;</code> can contain a 24-byte <code>String</code> value.</p> <p>But, we don’t want to store a capacity. Can we avoid the extra word of overhead in <code>Cow&lt;str&gt;</code>?</p> <h3 id="most-strings-are-small"><a href="#most-strings-are-small">Most Strings are Small</a></h3> <p>Consider a string that is not a substring but which is small. For example, when parsing a string literal like <code>&#34;Hello, world!\n&#34;</code>, the trailing <code>\n</code> (bytes <code>0x5c 0x6e</code>) must be replaced with a newline byte (<code>0x0a</code>). This means we must handle a tiny heap allocation, 14 bytes long, that is smaller than a <code>&amp;str</code> referring to it.</p> <p>This is worse for single character<sup id="fnref:character" role="doc-noteref"><a href="#fn:character" rel="footnote">2</a></sup> strings. The overhead for a <code>Box&lt;str&gt;</code> is large.</p> <ul> <li>The <code>Box&lt;str&gt;</code> struct itself has a pointer field (eight bytes), and a length field (also eight bytes). Spelled out to show all the stored bits, the length is <code>0x0000_0000_0000_0001</code>. That’s a lot of zeroes!</li> <li>The pointer itself points to a heap allocation, which will not be a single byte! Allocators are not in the business of handing out such small pieces of memory. Instead, the allocation is likely costing us another eight bytes!</li> </ul> <p>So, the string <code>&#34;a&#34;</code>, whose data is just a <em>single byte</em>, instead takes up 24 bytes of memory.</p> <p>It turns out that for really small strings we can avoid the allocation altogether, <em>and</em> make effective use of all those zeroes in the <code>len</code> field.</p> <h2 id="stealing-bits"><a href="#stealing-bits">Stealing Bits</a></h2> <p>Let’s say we want to stick to a budget of 16 bytes for our <code>Yarn</code> type. Is there any extra space left for data in a <code>(*mut u8, usize)</code> pair?</p> <p><em>*cracks Fermi estimation knuckles*</em></p> <p>A <code>usize</code> is 64 bits, which means that the length of an <code>&amp;str</code> can be anywhere from zero to 18446744073709551615, or around 18 exabytes. For reference, “hundreds of exabytes” is a reasonable ballpark guess for how much RAM exists in 2023 (consider: 4 billion smartphones with 4GB each). More practically, the largest quantity of RAM you can fit in a server blade is measured in terabytes (much more than your measly eight DIMs on your gaming rig).</p> <p>If we instead use one less bit, 63 bits, this halves the maximum representable memory to nine exabytes. If we take another, it’s now four exabytes. Much more memory than you will ever <em>ever</em> want to stick in a string. <a href="https://en.wikipedia.org/wiki/Wikipedia:Size_of_Wikipedia#Size_of_the_English_Wikipedia_database">Wikpedia asserts</a> that Wikimedia Commons contains around 428 terabytes of media (the articles’ text with history is a measly 10 TB).</p> <p>Ah, but you say you’re programming for a 32-bit machine (today, this likely means either a low-end mobile phone, an embedded micro controller, or WASM).</p> <p>On a 32-bit machine it’s a little bit harrier: Now <code>usize</code> is 32 bits, for a maximum string size of 4 gigabytes (if you remember the 32-bit era, this limit may sound familiar). “Gigabytes” is an amount of memory that you can actually imagine having in a string.</p> <p>Even then, 1 GB of memory (if we steal two bits) on a 32-bit machine is a lot of data. You can only have four strings that big in a single address space, and every 32-bit allocator in the universe will refuse to serve an allocation of that size. If your strings are comparable in size to the whole address space, you should build your own string type.</p> <p>The upshot is that every <code>&amp;str</code> contains two bits we can reasonably assume are not used. <em>Free real-estate.</em><sup id="fnref:isize" role="doc-noteref"><a href="#fn:isize" rel="footnote">3</a></sup></p> <h3 id="a-hand-written-niche-optimization"><a href="#a-hand-written-niche-optimization">A Hand-Written Niche Optimization</a></h3> <p>Rust has the concept of <em>niches</em>, or invalid bit-patterns of a particular type, which it uses for automatic layout optimization of <code>enum</code>s. For example, references cannot be null, so the pointer bit-pattern of <code>0x0000_0000_0000_0000</code> is never used; this bit-pattern is called a “niche”. Consider:</p> <div><figure><pre><code data-lang="rust"><span>enum</span> <span>Foo</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>{</span>
  <span>First</span><span>(</span><span>&amp;</span><span>&#39;a</span> <span>T</span><span>),</span>
  <span>Second</span>
<span>}</span></code></pre></figure></div> <p>An <code>enum</code> of this form will not need any “extra” space to store the value that discriminates between the two variants: if a <code>Foo</code>’s bits are all zero, it’s <code>Foo::Second</code>; otherwise it’s a <code>Foo::First</code> and the payload is formed from <code>Foo</code>’s bit-pattern. This, incidentally, is what makes <code>Option&lt;&amp;T&gt;</code> a valid representation for a “nullable pinter”.</p> <p>There are more general forms of this: <code>bool</code> is represented as a single byte, of which two bit are valid; the other 254 potential bit-patterns are niches. In Recent versions of Rust, <code>RawFd</code> has a niche for the all-ones bit-pattern, since POSIX file descriptors are always non-negative <code>int</code>s.</p> <p>By stealing two bits off of the length, we have given ourselves four niches, which essentially means we’ll have a hand-written version of something like this <code>enum</code>.</p> <div><figure><pre><code data-lang="rust"><span>enum</span> <span>Yarn</span> <span>{</span>
  <span>First</span><span>(</span><span>*</span><span>mut</span> <span>u8</span><span>,</span> <span>u62</span><span>),</span>
  <span>Second</span><span>(</span><span>*</span><span>mut</span> <span>u8</span><span>,</span> <span>u62</span><span>),</span>
  <span>Third</span><span>(</span><span>*</span><span>mut</span> <span>u8</span><span>,</span> <span>u62</span><span>),</span>
  <span>Fourth</span><span>(</span><span>*</span><span>mut</span> <span>u8</span><span>,</span> <span>u62</span><span>),</span>
<span>}</span></code></pre></figure></div> <p>For reasons that will become clear later, we will specifically steal the <em>high</em> bits of the length, so that to recover the length, we do two shifts<sup id="fnref:two-shifts" role="doc-noteref"><a href="#fn:two-shifts" rel="footnote">4</a></sup> to shift in two high zero bits. Here’s some code that actually implements this for the low level type our string type will be built on.</p> <div><figure><pre><code data-lang="rust"><span>#[repr(C)]</span>
<span>#[derive(Copy,</span> <span>Clone)]</span>
<span>struct</span> <span>RawYarn</span> <span>{</span>
  <span>ptr</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span>
  <span>len</span><span>:</span> <span>usize</span><span>,</span>
<span>}</span>

<span>impl</span> <span>RawYarn</span> <span>{</span>
  <span>/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span>/// a length, and a pointer.</span>
  <span>fn</span> <span>from_raw_parts</span><span>(</span><span>kind</span><span>:</span> <span>u8</span><span>,</span> <span>len</span><span>:</span> <span>usize</span><span>,</span> <span>ptr</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>)</span> <span>{</span>
    <span>assert</span><span>!</span><span>(</span><span>len</span> <span>&lt;=</span> <span>usize</span><span>::</span><span>MAX</span> <span>/</span> <span>4</span><span>,</span> <span>&#34;no way you have a string that big&#34;</span><span>);</span>

    <span>RawYarn</span> <span>{</span>
      <span>ptr</span><span>,</span>
      <span>len</span><span>:</span> <span>(</span><span>kind</span> <span>as</span> <span>usize</span> <span>&amp;</span> <span>0b11</span><span>)</span> <span>&lt;&lt;</span> <span>(</span><span>usize</span><span>::</span><span>BITS</span> <span>-</span> <span>2</span><span>)</span> <span>|</span> <span>len</span><span>,</span>
    <span>}</span>
  <span>}</span>

  <span>/// Extracts the kind back out.</span>
  <span>fn</span> <span>kind</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>u8</span> <span>{</span>
    <span>(</span><span>self</span><span>.len</span> <span>&gt;&gt;</span> <span>(</span><span>usize</span><span>::</span><span>BITS</span> <span>-</span> <span>2</span><span>))</span> <span>as</span> <span>u8</span>
  <span>}</span>

  <span>/// Extracts the slice out (regardless of kind).</span>
  <span>unsafe</span> <span>fn</span> <span>as_slice</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>[</span><span>u8</span><span>]</span> <span>{</span>
    <span>slice</span><span>::</span><span>from_raw_parts</span><span>(</span><span>self</span><span>.ptr</span><span>,</span> <span>(</span><span>self</span><span>.len</span> <span>&lt;&lt;</span> <span>2</span><span>)</span> <span>&gt;&gt;</span> <span>2</span><span>)</span>
  <span>}</span>
<span>}</span></code></pre></figure></div> <p>Note that I’ve made this type <code>Copy</code>, and some functions take it by value. This is for two reasons.</p> <ol> <li> <p>There is a type of <code>Yarn</code> that is itself <code>Copy</code>, although I’m not covering it in this article.</p> </li> <li> <p>It is a two-word struct, which means that on most architectures it is eligible to be passed in a pair of registers. Passing it by value in the low-level code helps promote keeping it in registers. This isn’t always possible, as we will see when we discuss “SSO”.</p> </li> </ol> <p>Let’s chose kind <code>0</code> to mean “this is borrowed data”, and kind <code>1</code> to be “this is heap-allocated data”. We can use this to remember whether we need to call a destructor.</p> <div><figure><pre><code data-lang="rust"><span>pub</span> <span>struct</span> <span>Yarn</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>{</span>
  <span>raw</span><span>:</span> <span>RawYarn</span><span>,</span>
  <span>_</span><span>ph</span><span>:</span> <span>PhantomData</span><span>&lt;&amp;</span><span>&#39;a</span> <span>str</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>const</span> <span>BORROWED</span><span>:</span> <span>u8</span> <span>=</span> <span>0</span><span>;</span>
<span>const</span> <span>HEAP</span><span>:</span> <span>u8</span> <span>=</span> <span>1</span><span>;</span>

<span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>Yarn</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>{</span>
  <span>/// Create a new yarn from borrowed data.</span>
  <span>pub</span> <span>fn</span> <span>borrowed</span><span>(</span><span>data</span><span>:</span> <span>&amp;</span><span>&#39;a</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
    <span>let</span> <span>len</span> <span>=</span> <span>data</span><span>.len</span><span>();</span>
    <span>let</span> <span>ptr</span> <span>=</span> <span>data</span><span>.as_ptr</span><span>()</span><span>.cast_mut</span><span>();</span>
    <span>Self</span> <span>{</span>
      <span>raw</span><span>:</span> <span>RawYarn</span><span>::</span><span>from_raw_parts</span><span>(</span><span>BORROWED</span><span>,</span> <span>len</span><span>,</span> <span>ptr</span><span>),</span>
      <span>_</span><span>ph</span><span>:</span> <span>PhantomData</span><span>,</span>
    <span>}</span>
  <span>}</span>

  <span>/// Create a new yarn from owned data.</span>
  <span>pub</span> <span>fn</span> <span>owned</span><span>(</span><span>data</span><span>:</span> <span>Box</span><span>&lt;</span><span>str</span><span>&gt;</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
    <span>let</span> <span>len</span> <span>=</span> <span>data</span><span>.len</span><span>();</span>
    <span>let</span> <span>ptr</span> <span>=</span> <span>data</span><span>.as_ptr</span><span>()</span><span>.cast_mut</span><span>();</span>
    <span>mem</span><span>::</span><span>forget</span><span>(</span><span>data</span><span>);</span>

    <span>Self</span> <span>{</span>
      <span>raw</span><span>:</span> <span>RawYarn</span><span>::</span><span>from_raw_parts</span><span>(</span><span>HEAP</span><span>,</span> <span>len</span><span>,</span> <span>ptr</span><span>),</span>
      <span>_</span><span>ph</span><span>:</span> <span>PhantomData</span><span>,</span>
    <span>}</span>
  <span>}</span>

  <span>/// Extracts the data.</span>
  <span>pub</span> <span>fn</span> <span>as_slice</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>str</span> <span>{</span>
    <span>unsafe</span> <span>{</span>
      <span>// SAFETY: initialized either from uniquely-owned data,</span>
      <span>// or borrowed data of lifetime &#39;a that outlives self.</span>
      <span>str</span><span>::</span><span>from_utf8</span><span>(</span><span>self</span><span>.as_slice</span><span>())</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>impl</span> <span>Drop</span> <span>for</span> <span>Yarn</span><span>&lt;</span><span>&#39;_</span><span>&gt;</span> <span>{</span>
  <span>fn</span> <span>drop</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>{</span>
    <span>if</span> <span>self</span><span>.raw</span><span>.kind</span><span>()</span> <span>==</span> <span>HEAP</span> <span>{</span>
      <span>let</span> <span>dropped</span> <span>=</span> <span>unsafe</span> <span>{</span>
        <span>// SAFETY: This is just reconstituting the box we dismantled</span>
        <span>// in Yarn::owned().</span>
        <span>Box</span><span>::</span><span>from_raw</span><span>(</span><span>self</span><span>.as_slice</span><span>())</span>
      <span>};</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code></pre></figure></div> <p>This gives us a type that strongly resembles <code>Cow&lt;str&gt;</code> with only half of the bytes. We can even write code to extend the lifetime of a <code>Yarn</code>:</p> <div><figure><pre><code data-lang="rust"><span>impl</span> <span>Yarn</span><span>&lt;</span><span>&#39;_</span><span>&gt;</span> <span>{</span>
  <span>/// Removes the bound lifetime from the yarn, allocating if</span>
  <span>/// necessary.</span>
  <span>pub</span> <span>fn</span> <span>immortalize</span><span>(</span><span>mut</span> <span>self</span><span>)</span> <span>-&gt;</span> <span>Yarn</span><span>&lt;</span><span>&#39;static</span><span>&gt;</span> <span>{</span>
    <span>if</span> <span>self</span><span>.raw</span><span>.kind</span><span>()</span> <span>==</span> <span>BORROWED</span> <span>{</span>
      <span>let</span> <span>copy</span><span>:</span> <span>Box</span><span>&lt;</span><span>str</span><span>&gt;</span> <span>=</span> <span>self</span><span>.as_slice</span><span>()</span><span>.into</span><span>();</span>
      <span>self</span> <span>=</span> <span>Yarn</span><span>::</span><span>owned</span><span>(</span><span>copy</span><span>);</span>
    <span>}</span>

    <span>// We need to be careful that we discard the old yarn, since its</span>
    <span>// destructor may run and delete the heap allocation we created</span>
    <span>// above.</span>
    <span>let</span> <span>raw</span> <span>=</span> <span>self</span><span>.raw</span><span>;</span>
    <span>mem</span><span>::</span><span>forget</span><span>(</span><span>self</span><span>);</span>
    <span>Yarn</span><span>::</span><span>&lt;</span><span>&#39;static</span><span>&gt;</span> <span>{</span>
      <span>raw</span><span>,</span>
      <span>_</span><span>ph</span><span>:</span> <span>PhantomData</span><span>,</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code></pre></figure></div> <p>The remaining two niches can be put to use for optimizing small strings.</p> <h2 id="small-string-optimization"><a href="#small-string-optimization">Small String Optimization</a></h2> <p>C++’s <code>std::string</code> also makes the “most strings are small” assumption. In the <code>libc++</code> implementation of the standard library, <code>std::string</code>s of up to 23 bytes never hit the heap!</p> <p>C++ implementations do this by using most of the pointer, length, and capacity fields as a storage buffer for small strings, the so-called “small string optimization” (SSO). In <code>libc++</code>, in SSO mode, a <code>std::string</code>’s length fits in one byte, so the other 23 bytes can be used as storage. The capacity isn’t stored at all: an SSO string always has a capacity of 23.</p> <p><code>RawYarn</code> still has another two niches, so let’s dedicate one to a “small” representation. In small mode, the kind will be 2, and only the 16th byte will be the length.</p> <p>This is why we used the two <em>high</em> bits of <code>len</code> for our scratch space: no matter what mode it’s in, we can easily extract these bits<sup id="fnref:big-endian" role="doc-noteref"><a href="#fn:big-endian" rel="footnote">5</a></sup>. Some of the existing <code>RawYarn</code> methods need to be updated, though.</p> <div><figure><pre><code data-lang="rust"><span>#[repr(C)]</span>
<span>#[derive(Copy,</span> <span>Clone)]</span>
<span>struct</span> <span>RawYarn</span> <span>{</span>
  <span>ptr</span><span>:</span> <span>MaybeUninit</span><span>&lt;*</span><span>mut</span> <span>u8</span><span>&gt;</span><span>,</span>
  <span>len</span><span>:</span> <span>usize</span><span>,</span>
<span>}</span>

<span>const</span> <span>SMALL</span><span>:</span> <span>u8</span> <span>=</span> <span>2</span><span>;</span>

<span>impl</span> <span>RawYarn</span> <span>{</span>
  <span>/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span>/// a length, and a pointer.</span>
  <span>fn</span> <span>from_raw_parts</span><span>(</span><span>kind</span><span>:</span> <span>u8</span><span>,</span> <span>len</span><span>:</span> <span>usize</span><span>,</span> <span>ptr</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>)</span> <span>{</span>
    <span>debug_assert!</span><span>(</span><span>kind</span> <span>!=</span> <span>SMALL</span><span>);</span>
    <span>assert</span><span>!</span><span>(</span><span>len</span> <span>&lt;=</span> <span>usize</span><span>::</span><span>MAX</span> <span>/</span> <span>4</span><span>,</span> <span>&#34;no way you have a string that big&#34;</span><span>);</span>

    <span>RawYarn</span> <span>{</span>
      <span>ptr</span><span>:</span> <span>MaybeUninit</span><span>::</span><span>new</span><span>(</span><span>ptr</span><span>),</span>
      <span>len</span><span>:</span> <span>(</span><span>kind</span> <span>as</span> <span>usize</span> <span>&amp;</span> <span>0b11</span><span>)</span> <span>&lt;&lt;</span> <span>(</span><span>usize</span><span>::</span><span>BITS</span> <span>-</span> <span>2</span><span>)</span> <span>|</span> <span>len</span><span>,</span>
    <span>}</span>
  <span>}</span>

  <span>/// Extracts the slice out (regardless of kind).</span>
  <span>unsafe</span> <span>fn</span> <span>as_slice</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>[</span><span>u8</span><span>]</span> <span>{</span>
    <span>let</span> <span>(</span><span>ptr</span><span>,</span> <span>adjust</span><span>)</span> <span>=</span> <span>match</span> <span>self</span><span>.kind</span><span>()</span> <span>{</span>
      <span>SMALL</span> <span>=&gt;</span> <span>(</span><span>self</span> <span>as</span> <span>*</span><span>const</span> <span>Self</span> <span>as</span> <span>*</span><span>const</span> <span>u8</span><span>,</span> <span>usize</span><span>::</span><span>BITS</span> <span>-</span> <span>8</span><span>),</span>
      <span>_</span> <span>=&gt;</span> <span>(</span><span>self</span><span>.ptr</span><span>.assume_init</span><span>(),</span> <span>0</span><span>),</span>
    <span>};</span>

    <span>slice</span><span>::</span><span>from_raw_parts</span><span>(</span><span>ptr</span><span>,</span> <span>(</span><span>self</span><span>.len</span> <span>&lt;&lt;</span> <span>2</span><span>)</span> <span>&gt;&gt;</span> <span>(</span><span>2</span> <span>+</span> <span>adjust</span><span>))</span>
  <span>}</span>
<span>}</span></code></pre></figure></div> <p>In the non-<code>SMALL</code> case, we shift twice as before, but in the <code>SMALL</code> case, we need to get the high byte of the <code>len</code> field, so we need to shift down by an additional <code>usize::BITS - 8</code>. No matter what we’ve scribbled on the low bytes of <code>len</code>, we will always get just the length this way.</p> <p>We also need to use a different pointer value depending on whether we’re in <code>SMALL</code> mode. This is why <code>as_slice</code> needs to take a reference argument, since the slice data may be <em>directly</em> in <code>self</code>!</p> <p>Also, <code>ptr</code> is a <code>MaybeUninit</code> now, which will become clear in the next code listing.</p> <p>We should also provide a way to construct small strings.</p> <div><figure><pre><code data-lang="rust"><span>const</span> <span>SSO_LEN</span><span>:</span> <span>usize</span> <span>=</span> <span>size_of</span><span>::</span><span>&lt;</span><span>usize</span><span>&gt;</span><span>()</span> <span>*</span> <span>2</span> <span>-</span> <span>1</span><span>;</span>

<span>impl</span> <span>RawYarn</span> <span>{</span>
  <span>/// Create a new small yarn. `data` must be valid for `len` bytes</span>
  <span>/// and `len` must be smaller than `SSO_LEN`.</span>
  <span>unsafe</span> <span>fn</span> <span>from_small</span><span>(</span><span>data</span><span>:</span> <span>*</span><span>const</span> <span>u8</span><span>,</span> <span>len</span><span>:</span> <span>usize</span><span>)</span> <span>-&gt;</span> <span>RawYarn</span> <span>{</span>
    <span>debug_assert!</span><span>(</span><span>len</span> <span>&lt;=</span> <span>SSO_LEN</span><span>);</span>

    <span>// Create a yarn with an uninitialized pointer value (!!)</span>
    <span>// and a length whose high byte is packed with `small` and</span>
    <span>// `len`.</span>
    <span>let</span> <span>mut</span> <span>yarn</span> <span>=</span> <span>RawYarn</span> <span>{</span>
      <span>ptr</span><span>:</span> <span>MaybeUninit</span><span>::</span><span>uninit</span><span>(),</span>
      <span>len</span><span>:</span> <span>(</span><span>SMALL</span> <span>as</span> <span>usize</span> <span>&lt;&lt;</span> <span>6</span> <span>|</span> <span>len</span><span>)</span>
          <span>&lt;&lt;</span> <span>(</span><span>usize</span><span>::</span><span>BITS</span> <span>-</span> <span>8</span><span>),</span>
    <span>};</span>

    <span>// Memcpy the data to the new yarn.</span>
    <span>// We write directly onto the `yarn` variable. We won&#39;t</span>
    <span>// overwrite the high-byte length because `len` will</span>
    <span>// never be &gt;= 16.</span>
    <span>ptr</span><span>::</span><span>copy_nonoverlapping</span><span>(</span>
      <span>data</span><span>,</span>
      <span>&amp;</span><span>mut</span> <span>yarn</span> <span>as</span> <span>*</span><span>mut</span> <span>RawYarn</span> <span>as</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span>
      <span>data</span><span>,</span>
    <span>);</span>

    <span>yarn</span>
  <span>}</span>
<span>}</span></code></pre></figure></div> <p>The precise maximum size of an SSO string is a bit more subtle than what’s given above, but it captures the spirit. The <code>RawYarn::from_small</code> illustrates why the pointer value is hidden in a <code>MaybeUninit</code>: we’re above to overwrite it with garbage, and in that case it won’t be a pointer at all.</p> <p>We can update our public <code>Yarn</code> type to use the new small representation whenever possible.</p> <div><figure><pre><code data-lang="rust"><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>Yarn</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>{</span>
  <span>/// Create a new yarn from borrowed data.</span>
  <span>pub</span> <span>fn</span> <span>borrowed</span><span>(</span><span>data</span><span>:</span> <span>&amp;</span><span>&#39;a</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
    <span>let</span> <span>len</span> <span>=</span> <span>data</span><span>.len</span><span>();</span>
    <span>let</span> <span>ptr</span> <span>=</span> <span>data</span><span>.as_ptr</span><span>()</span><span>.cast_mut</span><span>();</span>

    <span>if</span> <span>len</span> <span>&lt;=</span> <span>SSO_LEN</span> <span>{</span>
      <span>return</span> <span>Self</span> <span>{</span>
        <span>raw</span><span>:</span> <span>unsafe</span> <span>{</span> <span>RawYarn</span><span>::</span><span>from_small</span><span>(</span><span>len</span><span>,</span> <span>ptr</span><span>)</span> <span>},</span>
        <span>_</span><span>ph</span><span>:</span> <span>PhantomData</span><span>,</span>
      <span>}</span>
    <span>}</span>

    <span>Self</span> <span>{</span>
      <span>raw</span><span>:</span> <span>RawYarn</span><span>::</span><span>from_raw_parts</span><span>(</span><span>BORROWED</span><span>,</span> <span>len</span><span>,</span> <span>ptr</span><span>),</span>
      <span>_</span><span>ph</span><span>:</span> <span>PhantomData</span><span>,</span>
    <span>}</span>
  <span>}</span>

  <span>/// Create a new yarn from owned data.</span>
  <span>pub</span> <span>fn</span> <span>owned</span><span>(</span><span>data</span><span>:</span> <span>Box</span><span>&lt;</span><span>str</span><span>&gt;</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
    <span>if</span> <span>data</span><span>.len</span><span>()</span> <span>&lt;=</span> <span>SSO_LEN</span> <span>{</span>
      <span>return</span> <span>Self</span> <span>{</span>
        <span>raw</span><span>:</span> <span>unsafe</span> <span>{</span> <span>RawYarn</span><span>::</span><span>from_small</span><span>(</span><span>data</span><span>.len</span><span>(),</span> <span>data</span><span>.as_ptr</span><span>())</span> <span>},</span>
        <span>_</span><span>ph</span><span>:</span> <span>PhantomData</span><span>,</span>
      <span>}</span>
    <span>}</span>

    <span>let</span> <span>len</span> <span>=</span> <span>data</span><span>.len</span><span>();</span>
    <span>let</span> <span>ptr</span> <span>=</span> <span>data</span><span>.as_ptr</span><span>()</span><span>.cast_mut</span><span>();</span>
    <span>mem</span><span>::</span><span>forget</span><span>(</span><span>data</span><span>);</span>

    <span>Self</span> <span>{</span>
      <span>raw</span><span>:</span> <span>RawYarn</span><span>::</span><span>from_raw_parts</span><span>(</span><span>HEAP</span><span>,</span> <span>len</span><span>,</span> <span>ptr</span><span>),</span>
      <span>_</span><span>ph</span><span>:</span> <span>PhantomData</span><span>,</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code></pre></figure></div> <p>It’s also possible to construct a <code>Yarn</code> directly from a character now, too!</p> <div><figure><pre><code data-lang="rust"><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>Yarn</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>{</span>
  <span>/// Create a new yarn from borrowed data.</span>
  <span>pub</span> <span>fn</span> <span>from_char</span><span>(</span><span>data</span><span>:</span> <span>char</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
    <span>let</span> <span>mut</span> <span>buf</span> <span>=</span> <span>[</span><span>0u8</span><span>;</span> <span>4</span><span>];</span>
    <span>let</span> <span>data</span> <span>=</span> <span>data</span><span>.encode_utf8</span><span>(</span><span>&amp;</span><span>mut</span> <span>buf</span><span>);</span>
    <span>Self</span> <span>{</span>
      <span>raw</span><span>:</span> <span>unsafe</span> <span>{</span> <span>RawYarn</span><span>::</span><span>from_small</span><span>(</span><span>len</span><span>,</span> <span>ptr</span><span>)</span> <span>},</span>
      <span>_</span><span>ph</span><span>:</span> <span>PhantomData</span><span>,</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code></pre></figure></div> <p>(Note that we do not need to update <code>Yarn::immortalize()</code>; why?)</p> <p>What we have now is a maybe-owned string that does not require an allocation for small strings. However, we still have an extra niche…</p> <h2 id="string-constants"><a href="#string-constants">String Constants</a></h2> <p>String constants in Rust are interesting, because we can actually detect them at compile-time<sup id="fnref:leaks" role="doc-noteref"><a href="#fn:leaks" rel="footnote">6</a></sup>.</p> <p>We can use the last remaining niche, 3, to represent data that came from a string constant, which means that it does not need to be boxed to be immortalized.</p> <div><figure><pre><code data-lang="rust"><span>const</span> <span>STATIC</span><span>:</span> <span>u8</span> <span>=</span> <span>3</span><span>;</span>

<span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>Yarn</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>{</span>
  <span>/// Create a new yarn from borrowed data.</span>
  <span>pub</span> <span>fn</span> <span>from_static</span><span>(</span><span>data</span><span>:</span> <span>&amp;</span><span>&#39;static</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
    <span>let</span> <span>len</span> <span>=</span> <span>data</span><span>.len</span><span>();</span>
    <span>let</span> <span>ptr</span> <span>=</span> <span>data</span><span>.as_ptr</span><span>()</span><span>.cast_mut</span><span>();</span>

    <span>if</span> <span>len</span> <span>&lt;=</span> <span>SSO_LEN</span> <span>{</span>
      <span>return</span> <span>Self</span> <span>{</span>
        <span>raw</span><span>:</span> <span>unsafe</span> <span>{</span> <span>RawYarn</span><span>::</span><span>from_small</span><span>(</span><span>len</span><span>,</span> <span>ptr</span><span>)</span> <span>},</span>
        <span>_</span><span>ph</span><span>:</span> <span>PhantomData</span><span>,</span>
      <span>}</span>
    <span>}</span>

    <span>Self</span> <span>{</span>
      <span>raw</span><span>:</span> <span>RawYarn</span><span>::</span><span>from_raw_parts</span><span>(</span><span>STATIC</span><span>,</span> <span>len</span><span>,</span> <span>ptr</span><span>),</span>
      <span>_</span><span>ph</span><span>:</span> <span>PhantomData</span><span>,</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code></pre></figure></div> <p>This function is identical to <code>Yarn::borrowed</code>, except that <code>data</code> most now have a static lifetime, and we pass <code>STATIC</code> to <code>RawYarn::from_raw_parts()</code>.</p> <p>Because of how we’ve written all of the prior code, this does not require any special support in <code>Yarn::immortalize()</code> or in the low-level <code>RawYarn</code> code.</p> <p>The actual <code>byteyarn</code> library provides a <code>yarn!()</code> macro that has the same syntax as <code>format!()</code>. This is the primary way in which yarns are created. It is has been carefully written so that <code>yarn!(&#34;this is a literal&#34;)</code> always produces a <code>STATIC</code> string, rather than a heap-allocated string.</p>  <p>Unfortunately, because of how we’ve written it, <code>Option&lt;Yarn&gt;</code> is 24 bytes, a whole word larger than a <code>Yarn</code>. However, there’s still a little gap where we can fit the <code>None</code> variant. It turns out that because of how we’ve chosen the discriminants, <code>len</code> is zero if and only if it is an empty <code>BORROWED</code> string. But this is not the only zero: if the high byte is <code>0x80</code>, this is an empty <code>SMALL</code> string. If we simply require that no other empty string is ever constructed (by marking <code>RawYarn::from_raw_parts()</code> as unsafe and specifying it should not be passed a length of zero), we can guarantee that <code>len</code> is <em>never</em> zero.</p> <p>Thus, we can update <code>len</code> to be a <code>NonZeroUsize</code>.</p> <div><figure><pre><code data-lang="rust"><span>#[repr(C)]</span>
<span>#[derive(Copy,</span> <span>Clone)]</span>
<span>struct</span> <span>RawYarn</span> <span>{</span>
  <span>ptr</span><span>:</span> <span>MaybeUninit</span><span>&lt;*</span><span>mut</span> <span>u8</span><span>&gt;</span><span>,</span>
  <span>len</span><span>:</span> <span>NonZeroUsize</span><span>,</span>  <span>// (!!)</span>
<span>}</span>

<span>impl</span> <span>RawYarn</span> <span>{</span>
  <span>/// Constructs a new RawYarn from raw components: a 2-bit kind,</span>
  <span>/// a *nonzero* length, and a pointer.</span>
  <span>unsafe</span> <span>fn</span> <span>from_raw_parts</span><span>(</span><span>kind</span><span>:</span> <span>u8</span><span>,</span> <span>len</span><span>:</span> <span>usize</span><span>,</span> <span>ptr</span><span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>)</span> <span>{</span>
    <span>debug_assert!</span><span>(</span><span>kind</span> <span>!=</span> <span>SMALL</span><span>);</span>
    <span>debug_assert!</span><span>(</span><span>len</span> <span>!=</span> <span>0</span><span>);</span>
    <span>assert</span><span>!</span><span>(</span><span>len</span> <span>&lt;=</span> <span>usize</span><span>::</span><span>MAX</span> <span>/</span> <span>4</span><span>,</span> <span>&#34;no way you have a string that big&#34;</span><span>);</span>

    <span>RawYarn</span> <span>{</span>
      <span>ptr</span><span>:</span> <span>MaybeUninit</span><span>::</span><span>new</span><span>(</span><span>ptr</span><span>),</span>
      <span>len</span><span>:</span> <span>NonZeroUsize</span><span>::</span><span>new_unchecked</span><span>(</span>
        <span>(</span><span>kind</span> <span>as</span> <span>usize</span> <span>&amp;</span> <span>0b11</span><span>)</span> <span>&lt;&lt;</span> <span>(</span><span>usize</span><span>::</span><span>BITS</span> <span>-</span> <span>2</span><span>)</span> <span>|</span> <span>len</span><span>),</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code></pre></figure></div> <p>This is a type especially known to the Rust compiler to have a niche bit-pattern of all zeros, which allows <code>Option&lt;Yarn&gt;</code> to be 16 bytes too. This also has the convenient property that the all zeros bit-pattern for <code>Option&lt;Yarn&gt;</code> is <code>None</code>.</p> <h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2> <p>The <a href="https://docs.rs/byteyarn/latest/byteyarn/"><code>byteyarn</code></a> blurb describes what we’ve built:</p> <blockquote> <p>A <code>Yarn</code> is a highly optimized string type that provides a number of useful properties over <code>String</code>:</p> <ul> <li>Always two pointers wide, so it is always passed into and out of functions in registers.</li> <li>Small string optimization (SSO) up to 15 bytes on 64-bit architectures.</li> <li>Can be either an owned buffer or a borrowed buffer (like <code>Cow&lt;str&gt;</code>).</li> <li>Can be upcast to <code>&#39;static</code> lifetime if it was constructed from a known-static string.</li> </ul> </blockquote> <p>There are, of course, some trade-offs. Not only do we need the assumptions we made originally to hold, but we also need to relatively care more about memory than cycle-count performance, since basic operations like reading the length of the string require more math (but no extra branching).</p> <p>The actual implementation of <code>Yarn</code> is a bit more complicated, partly to keep all of the low-level book-keeping in one place, and partly to offer an ergonomic API that makes <code>Yarn</code> into a mostly-drop-in replacement for <code>Box&lt;str&gt;</code>.</p> <p>I hope this peek under the hood has given you a new appreciation for what can be achieved by clever layout-hacking. ◼</p>  </div></div>
  </body>
</html>
