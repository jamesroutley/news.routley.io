<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://owen.cafe/posts/six-times-faster-than-c/">Original</a>
    <h1>{n} times faster than C</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Sometimes humans can spot optimization opportunities that a compiler <del>canâ€™t</del>
doesnâ€™t. In this post, we start with a loop generated from C code by clang, and
tweak it in various ways, measuring the speedup.</p>
<p><strong>Disclaimer</strong>: <em>Iâ€™m not an optimization expert, by any means, in fact my
expertise is in high-level, purely-functional languages, where one
doesnâ€™t usually think about <strong>how</strong> a program is executed.</em></p>
<p>Code listings for this post can be found on <a href="https://github.com/414owen/blog-code/tree/master/01-six-times-faster-than-c" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="the-function"><a href="#the-function"><span>#Â </span>The Function</a></h2>
<p>Weâ€™ll start with a function that loops through a string, and increments or
decrements a number, depending on the characters it sees.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>int</span> <span>run_switches</span><span>(</span><span>char</span> <span>*</span><span>input</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>int</span> <span>res</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>char</span> <span>c</span> <span>=</span> <span>*</span><span>input</span><span>++</span><span>;</span>
</span></span><span><span>    <span>switch</span> <span>(</span><span>c</span><span>)</span> <span>{</span>
</span></span><span><span>      <span>case</span> <span>&#39;\0&#39;</span><span>:</span>
</span></span><span><span>        <span>return</span> <span>res</span><span>;</span>
</span></span><span><span>      <span>case</span> <span>&#39;s&#39;</span><span>:</span>
</span></span><span><span>        <span>res</span> <span>+=</span> <span>1</span><span>;</span>
</span></span><span><span>        <span>break</span><span>;</span>
</span></span><span><span>      <span>case</span> <span>&#39;p&#39;</span><span>:</span>
</span></span><span><span>        <span>res</span> <span>-=</span> <span>1</span><span>;</span>
</span></span><span><span>        <span>break</span><span>;</span>
</span></span><span><span>      <span>default</span><span>:</span>
</span></span><span><span>        <span>break</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>It increments on seeing an â€™sâ€™ (for successor) and decrements on seeing a
â€˜pâ€™ (for predecessor).</p>
<p>Itâ€™s a small enough function that gcc and/or clang should be able to optimize it
pretty well. Maybe optimally? I initially wrote this to see whether gcc produced
a jump table or a search.</p>
<p>This is what clang spat out (padding noops removed, and annotated manually):</p>
<div>
<p><label for="tab-asmc-0">pseudocode</label><label for="tab-asmc-1">arrows</label>
</p>
<div>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span># llvm-objdump -d --symbolize-operands --no-addresses --x86-asm-syntax=intel --no-show-raw-insn loop-1-clang.c.o
</span></span></span><span><span><span></span>
</span></span><span><span><span>run_switches:</span>
</span></span><span><span>      <span>xor</span>     <span>eax</span><span>,</span> <span>eax</span>            <span># res = 0
</span></span></span><span><span><span></span><span>loop:</span>                             <span># while (true) {
</span></span></span><span><span><span></span>      <span>movsx</span>   <span>ecx</span><span>,</span> <span>byte</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span> <span>#   c = *input
</span></span></span><span><span><span></span>      <span>test</span>    <span>ecx</span><span>,</span> <span>ecx</span>            <span>#   if (c == &#39;\0&#39;)
</span></span></span><span><span><span></span>      <span>je</span>      <span>ret</span>                 <span>#     return
</span></span></span><span><span><span></span>      <span>add</span>     <span>rdi</span><span>,</span> <span>1</span>              <span>#   input++
</span></span></span><span><span><span></span>      <span>cmp</span>     <span>ecx</span><span>,</span> <span>&#39;</span><span>p</span><span>&#39;</span>            <span>#   if (c == &#39;p&#39;)
</span></span></span><span><span><span></span>      <span>je</span>      <span>p</span>                   <span>#     goto p
</span></span></span><span><span><span></span>      <span>cmp</span>     <span>ecx</span><span>,</span> <span>&#39;</span><span>s</span><span>&#39;</span>            <span>#   if (c == &#39;s&#39;)
</span></span></span><span><span><span></span>      <span>jne</span>     <span>loop</span>                <span>#     continue
</span></span></span><span><span><span></span>      <span>add</span>     <span>eax</span><span>,</span> <span>1</span>              <span>#   res++
</span></span></span><span><span><span></span>      <span>jmp</span>     <span>loop</span>                <span>#   continue
</span></span></span><span><span><span></span><span>p:</span>    <span>add</span>     <span>eax</span><span>,</span> <span>-</span><span>1</span>             <span>#   res--
</span></span></span><span><span><span></span>      <span>jmp</span>     <span>loop</span>                <span># }
</span></span></span><span><span><span></span><span>ret:</span>  <span>ret</span>
</span></span></code></pre></div>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span># objdump -Mintel -d --no-addresses --no-show-raw-insn --visualize-jumps loop-1-clang.c.o
</span></span></span><span><span><span></span>
</span></span><span><span><span>run_switches:</span>
</span></span><span><span>              <span>xor</span>    <span>eax</span><span>,</span> <span>eax</span>
</span></span><span><span><span>loop:</span>
</span></span><span><span>      <span>â•­â”€â”€â”€â”€â¤</span> <span>movsx</span>  <span>ecx</span><span>,</span> <span>byte</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>
</span></span><span><span>      <span>â”‚</span>      <span>test</span>   <span>ecx</span><span>,</span> <span>ecx</span>
</span></span><span><span>      <span>â”‚</span> <span>â•­â”€â”€â”€</span> <span>je</span>     <span>ret</span>
</span></span><span><span>      <span>â”‚</span> <span>â”‚</span>    <span>add</span>    <span>rdi</span><span>,</span> <span>1</span>
</span></span><span><span>      <span>â”‚</span> <span>â”‚</span>    <span>cmp</span>    <span>ecx</span><span>,</span> <span>&#39;</span><span>p</span><span>&#39;</span>
</span></span><span><span>      <span>â”‚</span> <span>â”‚</span> <span>â•­â”€</span> <span>je</span>     <span>p</span>
</span></span><span><span>      <span>â”‚</span> <span>â”‚</span> <span>â”‚</span>  <span>cmp</span>    <span>ecx</span><span>,</span> <span>&#39;</span><span>s</span><span>&#39;</span>
</span></span><span><span>      <span>â”œâ”€â”‚â”€â”‚â”€</span> <span>jne</span>    <span>loop</span>
</span></span><span><span>      <span>â”‚</span> <span>â”‚</span> <span>â”‚</span>  <span>add</span>    <span>eax</span><span>,</span> <span>1</span>
</span></span><span><span>      <span>â”œâ”€â”‚â”€â”‚â”€</span> <span>jmp</span>    <span>loop</span>
</span></span><span><span><span>p:</span>    <span>â”‚</span> <span>â”‚</span> <span>â•°â¤</span> <span>add</span>    <span>eax</span><span>,</span> <span>-</span><span>1</span>
</span></span><span><span>      <span>â•°â”€â”‚â”€â”€â”€</span> <span>jmp</span>    <span>loop</span>
</span></span><span><span><span>ret:</span>    <span>â•°â”€â”€â¤</span> <span>ret</span>
</span></span></code></pre></div>
</div>
</div>
<p><strong>Runtime:</strong> 3.23s ğŸŒ</p>
<p><strong>Bitrate</strong>: 295.26MiB/s</p>
<p>GCC spat out a little more code, that ran a little faster (not much).</p>
<p>This code is pretty straightforward, it has three conditional branch
instructions (je, je, jne), leading to four possible blocks, â€˜\0â€™, â€™sâ€™, â€˜pâ€™, and
a block for any other character.</p>
<h2 id="rearranging-branches"><a href="#rearranging-branches"><span>#Â </span>Rearranging branches</a></h2>
<p>However, we know some things about this loop. We know that the only time we
break out of it is when we hit the null terminator (â€™\0â€™). The code clang
generates checks for the null terminator first, but this makes no sense. The
maximum number of null terminators we will ever hit in this function is 1, so
for every â€˜pâ€™ and â€™sâ€™ character, weâ€™re checking for null first. We should
optimize for â€˜pâ€™s, â€™sâ€™s and other characters over null terminators.</p>
<p>So, letâ€™s rearrange this loop a little.</p>
<div>
<p><label for="tab-asm1-0">arrows</label><label for="tab-asm1-1">raw</label>
</p>
<div>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>run_switches:</span>
</span></span><span><span>               <span>xor</span>    <span>eax</span><span>,</span> <span>eax</span>
</span></span><span><span><span>loop:</span>  <span>â•­â”€â”€â”€â”€â”€â¤</span> <span>movsx</span>  <span>ecx</span><span>,</span> <span>byte</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>
</span></span><span><span>       <span>â”‚</span>       <span>inc</span>    <span>rdi</span>
</span></span><span><span>       <span>â”‚</span>       <span>cmp</span>    <span>ecx</span><span>,</span> <span>&#39;</span><span>p</span><span>&#39;</span>
</span></span><span><span>       <span>â”‚</span> <span>â•­â”€â”€â”€â”€</span> <span>je</span>     <span>p</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span>     <span>cmp</span>    <span>ecx</span><span>,</span> <span>&#39;</span><span>s</span><span>&#39;</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span> <span>â•­â”€â”€</span> <span>je</span>     <span>s</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span> <span>â”‚</span>   <span>test</span>   <span>ecx</span><span>,</span> <span>ecx</span>
</span></span><span><span>       <span>â”œâ”€â”‚â”€â”‚â”€â”€</span> <span>jne</span>    <span>loop</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span> <span>â”‚</span>   <span>ret</span>
</span></span><span><span><span>p:</span>     <span>â”‚</span> <span>â•°â”€â”‚â”€â¤</span> <span>dec</span>    <span>eax</span>
</span></span><span><span>       <span>â”œâ”€â”€â”€â”‚â”€â”€</span> <span>jmp</span>    <span>loop</span>
</span></span><span><span><span>s:</span>     <span>â”‚</span>   <span>â•°â”€â¤</span> <span>inc</span>    <span>eax</span>
</span></span><span><span>       <span>â•°â”€â”€â”€â”€â”€â”€</span> <span>jmp</span>    <span>loop</span>
</span></span></code></pre></div>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>run_switches:</span>
</span></span><span><span>        <span>xor</span>     <span>eax</span><span>,</span> <span>eax</span>
</span></span><span><span><span>loop:</span>   <span>movsx</span>   <span>ecx</span><span>,</span> <span>byte</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>
</span></span><span><span>        <span>inc</span>     <span>rdi</span>
</span></span><span><span>        <span>cmp</span>     <span>ecx</span><span>,</span> <span>&#39;</span><span>p</span><span>&#39;</span>
</span></span><span><span>        <span>je</span>      <span>p</span>
</span></span><span><span>        <span>cmp</span>     <span>ecx</span><span>,</span> <span>&#39;</span><span>s</span><span>&#39;</span>
</span></span><span><span>        <span>je</span>      <span>s</span>
</span></span><span><span>        <span>test</span>    <span>ecx</span><span>,</span> <span>ecx</span>
</span></span><span><span>        <span>jne</span>     <span>loop</span>
</span></span><span><span>        <span>ret</span>
</span></span><span><span><span>p:</span>      <span>dec</span>     <span>eax</span>
</span></span><span><span>        <span>jmp</span>     <span>loop</span>
</span></span><span><span><span>s:</span>      <span>inc</span>     <span>eax</span>
</span></span><span><span>        <span>jmp</span>     <span>loop</span>
</span></span></code></pre></div>
</div>
</div>
<p>Great, now we branch earlier on seeing a â€˜pâ€™ or an â€™sâ€™, than on the rare â€˜\0â€™.</p>
<p><strong>Runtime:</strong> 3.10s ğŸ¦¥</p>
<p><strong>Speedup:</strong>: 1.04x ğŸ“ˆ</p>
<p><strong>Bitrate</strong>: 307.64MiB/s</p>
<h2 id="rearranging-blocks"><a href="#rearranging-blocks"><span>#Â </span>Rearranging blocks</a></h2>
<p>So both of our common cases (â€˜pâ€™ and â€™sâ€™) jump back to the top of the loop,
so why donâ€™t we remove one of those branches by putting its target block (or
BasicBlockâ„¢, for people in compiler land), at the top of the loop?</p>
<div>
<p><label for="tab-asm2-0">arrows</label><label for="tab-asm2-1">raw</label>
</p>
<div>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>run_switches:</span>
</span></span><span><span>              <span>xor</span>    <span>eax</span><span>,</span> <span>eax</span>
</span></span><span><span>       <span>â•­â”€â”€â”€â”€â”€</span> <span>jmp</span>    <span>loop</span>
</span></span><span><span><span>s:</span>     <span>â”‚</span> <span>â•­â”€â”€â¤</span> <span>inc</span>    <span>eax</span>
</span></span><span><span><span>loop:</span>  <span>â”œâ”€â”‚â”€â”€â¤</span> <span>movsx</span>  <span>ecx</span><span>,</span> <span>byte</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span>    <span>inc</span>    <span>rdi</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span>    <span>cmp</span>    <span>ecx</span><span>,</span> <span>&#39;</span><span>p</span><span>&#39;</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span> <span>â•­â”€</span> <span>je</span>     <span>p</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span> <span>â”‚</span>  <span>cmp</span>    <span>ecx</span><span>,</span> <span>&#39;</span><span>s</span><span>&#39;</span>
</span></span><span><span>       <span>â”‚</span> <span>â•°â”€â”‚â”€</span> <span>je</span>     <span>s</span>
</span></span><span><span>       <span>â”‚</span>   <span>â”‚</span>  <span>test</span>   <span>ecx</span><span>,</span> <span>ecx</span>
</span></span><span><span>       <span>â”œâ”€â”€â”€â”‚â”€</span> <span>jne</span>    <span>loop</span>
</span></span><span><span>       <span>â”‚</span>   <span>â”‚</span>  <span>ret</span>
</span></span><span><span><span>p:</span>     <span>â”‚</span>   <span>â•°â¤</span> <span>dec</span>    <span>eax</span>
</span></span><span><span>       <span>â•°â”€â”€â”€â”€â”€</span> <span>jmp</span>    <span>loop</span>
</span></span></code></pre></div>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>run_switches:</span>
</span></span><span><span>        <span>xor</span>     <span>eax</span><span>,</span> <span>eax</span>
</span></span><span><span>        <span>jmp</span>     <span>loop</span>       <span># This is new
</span></span></span><span><span><span></span><span>s:</span>      <span>inc</span>     <span>eax</span>        <span># This is up here now
</span></span></span><span><span><span></span><span>loop:</span>   <span>movsx</span>   <span>ecx</span><span>,</span> <span>byte</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>
</span></span><span><span>        <span>inc</span>     <span>rdi</span>
</span></span><span><span>        <span>cmp</span>     <span>ecx</span><span>,</span> <span>&#39;</span><span>p</span><span>&#39;</span>
</span></span><span><span>        <span>je</span>      <span>p</span>
</span></span><span><span>        <span>cmp</span>     <span>ecx</span><span>,</span> <span>&#39;</span><span>s</span><span>&#39;</span>
</span></span><span><span>        <span>je</span>      <span>s</span>
</span></span><span><span>        <span>test</span>    <span>ecx</span><span>,</span> <span>ecx</span>
</span></span><span><span>        <span>jne</span>     <span>loop</span>
</span></span><span><span>        <span>ret</span>
</span></span><span><span><span>p:</span>      <span>dec</span>     <span>eax</span>
</span></span><span><span>        <span>jmp</span>     <span>loop</span>
</span></span></code></pre></div>
</div>
</div>
<p>Great, now our â€™sâ€™ block falls through into the loop without a branch. Pretty
sweet.</p>
<p>Youâ€™ll notice that we now have to jump into the loop from the function start,
to avoid running the â€™sâ€™ block. This is a pretty good tradeoff though, jumping
into the loop from the function start happens once, whereas we encounter many
â€™sâ€™ characters.</p>
<p>But is it fast?</p>
<p><strong>Runtime:</strong> 2.98s ğŸ¢</p>
<p><strong>Overall speedup:</strong>: 1.08x ğŸ“ˆ</p>
<p><strong>Bitrate</strong>: 320.02MiB/s</p>
<h2 id="replacing-jumps-with-arithmetic"><a href="#replacing-jumps-with-arithmetic"><span>#Â </span>Replacing jumps with arithmetic</a></h2>
<p>Conditional jumps <a href="https://en.wikipedia.org/wiki/Branch_predictor" target="_blank" rel="noopener">are bad</a>, but
how about your standard garden variety unconditional <code>jmp</code>? What if we tried to
eliminate <code>p:</code>â€™s jump back into the loop?</p>
<p>A decrement is the same as two decrements and an increment, right? So letâ€™s use
that to fall through into <code>s:</code>.</p>
<div>
<p><label for="tab-asm3-0">arrows</label><label for="tab-asm3-1">raw</label>
</p>
<div>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>run_switches:</span>
</span></span><span><span>               <span>xor</span>    <span>eax</span><span>,</span> <span>eax</span>
</span></span><span><span>       <span>â•­â”€â”€â”€â”€â”€â”€</span> <span>jmp</span>    <span>loop</span>
</span></span><span><span><span>p:</span>     <span>â”‚</span>   <span>â•­â”€â¤</span> <span>sub</span>    <span>eax</span><span>,</span> <span>2</span>
</span></span><span><span><span>s:</span>     <span>â”‚</span> <span>â•­â”€â”‚â”€â¤</span> <span>inc</span>    <span>eax</span>
</span></span><span><span><span>loop:</span>  <span>â”œâ”€â”‚â”€â”‚â”€â¤</span> <span>movsx</span>  <span>ecx</span><span>,</span> <span>byte</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span> <span>â”‚</span>   <span>inc</span>    <span>rdi</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span> <span>â”‚</span>   <span>cmp</span>    <span>ecx</span><span>,</span> <span>&#39;</span><span>p</span><span>&#39;</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span> <span>â•°â”€â”€</span> <span>je</span>     <span>p</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span>     <span>cmp</span>    <span>ecx</span><span>,</span> <span>&#39;</span><span>s</span><span>&#39;</span>
</span></span><span><span>       <span>â”‚</span> <span>â•°â”€â”€â”€â”€</span> <span>je</span>     <span>s</span>
</span></span><span><span>       <span>â”‚</span>       <span>test</span>   <span>ecx</span><span>,</span> <span>ecx</span>
</span></span><span><span>       <span>â•°â”€â”€â”€â”€â”€â”€</span> <span>jne</span>    <span>loop</span>
</span></span><span><span>               <span>ret</span>
</span></span></code></pre></div>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>run_switches:</span>
</span></span><span><span>        <span>xor</span>     <span>eax</span><span>,</span> <span>eax</span>
</span></span><span><span>        <span>jmp</span>     <span>loop</span>
</span></span><span><span><span>p:</span>      <span>sub</span>     <span>eax</span><span>,</span> <span>2</span>
</span></span><span><span><span>s:</span>      <span>inc</span>     <span>eax</span>
</span></span><span><span><span>loop:</span>   <span>movsx</span>   <span>ecx</span><span>,</span> <span>byte</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>
</span></span><span><span>        <span>inc</span>     <span>rdi</span>
</span></span><span><span>        <span>cmp</span>     <span>ecx</span><span>,</span> <span>&#39;</span><span>p</span><span>&#39;</span>
</span></span><span><span>        <span>je</span>      <span>p</span>
</span></span><span><span>        <span>cmp</span>     <span>ecx</span><span>,</span> <span>&#39;</span><span>s</span><span>&#39;</span>
</span></span><span><span>        <span>je</span>      <span>s</span>
</span></span><span><span>        <span>test</span>    <span>ecx</span><span>,</span> <span>ecx</span>
</span></span><span><span>        <span>jne</span>     <span>loop</span>
</span></span><span><span>        <span>ret</span>
</span></span></code></pre></div>
</div>
</div>
<p>Well, we got rid of another branch instruction, using basic arithmetic. Good for
us. Is it faster though?</p>
<p><strong>Runtime:</strong> 2.87s ğŸ¦Œ</p>
<p><strong>Overall speedup:</strong>: 1.12x ğŸ“ˆ</p>
<p><strong>Bitrate</strong>: 332.29MiB/s</p>
<p>Fun fact, weâ€™ve been comparing our performance to clang 16â€™s output this whole
time, but GCC 12 actually produced faster (but more) code. GCCâ€™s code runs in
2.87s as well, so we only just caught up with it, however our program consists
of 13 instructions, and GCCâ€™s is 19.</p>
<p>GCCâ€™s code seems to have unrolled the loop, and is reusing the case blocks to
some extent.</p>
<h2 id="just-dont-branch"><a href="#just-dont-branch"><span>#Â </span>Just donâ€™t branch</a></h2>
<p>Okay, but these <strong>conditional</strong> branches are the real problem, right? How do you
make the branch predictor fast? I donâ€™t know, so letâ€™s just not use it.</p>
<div>
<p><label for="tab-asm4-0">arrows</label><label for="tab-asm4-1">pseudocode</label>
</p>
<div>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span># rdi: char *input
</span></span></span><span><span><span># eax: ouput
</span></span></span><span><span><span># r8:  1
</span></span></span><span><span><span># edx: -1
</span></span></span><span><span><span># ecx: char c
</span></span></span><span><span><span># esi: n
</span></span></span><span><span><span></span>
</span></span><span><span><span>run_switches:</span>
</span></span><span><span>            <span>xor</span>    <span>eax</span><span>,</span> <span>eax</span>
</span></span><span><span>            <span>mov</span>    <span>r8d</span><span>,</span> <span>1</span>
</span></span><span><span>            <span>mov</span>    <span>edx</span><span>,</span> <span>-</span><span>1</span>
</span></span><span><span><span>loop:</span> 
</span></span><span><span>       <span>â•­â”€â”€â¤</span> <span>movsx</span>  <span>ecx</span><span>,</span> <span>byte</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>
</span></span><span><span>       <span>â”‚</span>    <span>test</span>   <span>ecx</span><span>,</span> <span>ecx</span>
</span></span><span><span>       <span>â”‚</span> <span>â•­â”€</span> <span>je</span>     <span>ret</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span>  <span>inc</span>    <span>rdi</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span>  <span>mov</span>    <span>esi</span><span>,</span> <span>0</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span>  <span>cmp</span>    <span>ecx</span><span>,</span> <span>&#39;</span><span>p</span><span>&#39;</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span>  <span>cmove</span>  <span>esi</span><span>,</span> <span>edx</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span>  <span>cmp</span>    <span>ecx</span><span>,</span> <span>&#39;</span><span>s</span><span>&#39;</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span>  <span>cmove</span>  <span>esi</span><span>,</span> <span>r8d</span>
</span></span><span><span>       <span>â”‚</span> <span>â”‚</span>  <span>add</span>    <span>eax</span><span>,</span> <span>esi</span>
</span></span><span><span>       <span>â•°â”€â”‚â”€</span> <span>jmp</span>    <span>loop</span>
</span></span><span><span><span>ret:</span>     <span>â•°â¤</span> <span>ret</span>
</span></span></code></pre></div>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span># rdi: char *input
</span></span></span><span><span><span># eax: ouput
</span></span></span><span><span><span># r8:  1
</span></span></span><span><span><span># edx: -1
</span></span></span><span><span><span># ecx: char c
</span></span></span><span><span><span># esi: n
</span></span></span><span><span><span></span>
</span></span><span><span><span>run_switches:</span>
</span></span><span><span>        <span>xor</span>    <span>eax</span><span>,</span> <span>eax</span>             <span># res = 0
</span></span></span><span><span><span></span>        <span>mov</span>    <span>r8d</span><span>,</span> <span>1</span>               <span># need  1 in a register later
</span></span></span><span><span><span></span>        <span>mov</span>    <span>edx</span><span>,</span> <span>-</span><span>1</span>              <span># need -1 in a register later
</span></span></span><span><span><span></span><span>loop:</span>                               <span># while (true) {
</span></span></span><span><span><span></span>        <span>movsx</span>  <span>ecx</span><span>,</span> <span>byte</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>  <span>#   char c = *input
</span></span></span><span><span><span></span>        <span>test</span>   <span>ecx</span><span>,</span> <span>ecx</span>             <span>#   if (c == &#39;\0&#39;)
</span></span></span><span><span><span></span>        <span>je</span>     <span>ret</span>                  <span>#     return
</span></span></span><span><span><span></span>        <span>inc</span>    <span>rdi</span>                  <span>#   input++
</span></span></span><span><span><span></span>        <span>mov</span>    <span>esi</span><span>,</span> <span>0</span>               <span>#   n = 0
</span></span></span><span><span><span></span>        <span>cmp</span>    <span>ecx</span><span>,</span> <span>&#39;</span><span>p</span><span>&#39;</span>             <span>#   if (c == &#39;p&#39;)
</span></span></span><span><span><span></span>        <span>cmove</span>  <span>esi</span><span>,</span> <span>edx</span>             <span>#     n = -1
</span></span></span><span><span><span></span>        <span>cmp</span>    <span>ecx</span><span>,</span> <span>&#39;</span><span>s</span><span>&#39;</span>             <span>#   if (c == &#39;s&#39;)
</span></span></span><span><span><span></span>        <span>cmove</span>  <span>esi</span><span>,</span> <span>r8d</span>             <span>#     n = 1
</span></span></span><span><span><span></span>        <span>add</span>    <span>eax</span><span>,</span> <span>esi</span>             <span>#   res += n
</span></span></span><span><span><span></span>        <span>jmp</span>    <span>loop</span>                 <span># }
</span></span></span><span><span><span></span><span>ret:</span>    <span>ret</span>
</span></span></code></pre></div>
</div>
</div>
<p>Wow that removed a lot of arrows from the control flow graphâ€¦</p>
<p>Instead of branching/jumping conditionally, weâ€™re using a different value
for the addition depending on the current character, using <code>cmove</code>, orâ€¦
âœ¨âœ¨<strong>conditional move on equality</strong>âœ¨âœ¨.</p>
<p>The rules are: by default use zero, if weâ€™re on an â€™sâ€™, use 1, and if weâ€™re on a
â€˜pâ€™, use -1. Then <strong>always</strong> add.</p>
<p>Right, nice flex, butâ€¦ Is it fast?</p>
<p><strong>Runtime:</strong> 0.48s ğŸ†</p>
<p><strong>Overall speedup:</strong>: 6.73x ğŸ“ˆ</p>
<p><strong>Bitrate</strong>: 1.94GiB/s</p>
<p>Yes itâ€™s pretty damn fast.</p>
<h2 id="freeing-up-a-register"><a href="#freeing-up-a-register"><span>#Â </span>Freeing up a register</a></h2>
<p>x86_64 has another way of conditionally setting a (1 byte) register to 0 or 1.
Itâ€™s called <code>sete</code>. Letâ€™s use that, and remove our use of r8d.</p>
<div>
<p><label for="tab-asm5-0">arrows</label><label for="tab-asm5-1">pseudocode</label>
</p>
<div>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>run_switches:</span>
</span></span><span><span>             <span>xor</span>    <span>eax</span><span>,</span> <span>eax</span>
</span></span><span><span>             <span>mov</span>    <span>edx</span><span>,</span> <span>-</span><span>1</span>
</span></span><span><span><span>loop:</span>
</span></span><span><span>        <span>â•­â”€â”€â¤</span> <span>movsx</span>  <span>ecx</span><span>,</span> <span>byte</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>
</span></span><span><span>        <span>â”‚</span>    <span>test</span>   <span>ecx</span><span>,</span> <span>ecx</span>
</span></span><span><span>        <span>â”‚</span> <span>â•­â”€</span> <span>je</span>     <span>ret</span>
</span></span><span><span>        <span>â”‚</span> <span>â”‚</span>  <span>inc</span>    <span>rdi</span>
</span></span><span><span>        <span>â”‚</span> <span>â”‚</span>  <span>mov</span>    <span>esi</span><span>,</span> <span>0</span>
</span></span><span><span>        <span>â”‚</span> <span>â”‚</span>  <span>cmp</span>    <span>ecx</span><span>,</span> <span>&#39;</span><span>s</span><span>&#39;</span>
</span></span><span><span>        <span>â”‚</span> <span>â”‚</span>  <span>sete</span>   <span>sil</span>
</span></span><span><span>        <span>â”‚</span> <span>â”‚</span>  <span>cmp</span>    <span>ecx</span><span>,</span> <span>&#39;</span><span>p</span><span>&#39;</span>
</span></span><span><span>        <span>â”‚</span> <span>â”‚</span>  <span>cmove</span>  <span>esi</span><span>,</span> <span>edx</span>
</span></span><span><span>        <span>â”‚</span> <span>â”‚</span>  <span>add</span>    <span>eax</span><span>,</span> <span>esi</span>
</span></span><span><span>        <span>â•°â”€â”‚â”€</span> <span>jmp</span>    <span>loop</span>
</span></span><span><span><span>ret:</span>      <span>â•°â¤</span> <span>ret</span>
</span></span></code></pre></div>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>run_switches:</span>
</span></span><span><span>        <span>xor</span>   <span>eax</span><span>,</span> <span>eax</span>             <span># res = 0
</span></span></span><span><span><span></span>        <span>mov</span>   <span>edx</span><span>,</span> <span>-</span><span>1</span>              <span># need -1 in a register later
</span></span></span><span><span><span></span><span>loop:</span>                              <span># while (true) {
</span></span></span><span><span><span></span>        <span>movsx</span> <span>ecx</span><span>,</span> <span>byte</span> <span>ptr</span> <span>[</span><span>rdi</span><span>]</span>  <span>#   char c = *input
</span></span></span><span><span><span></span>        <span>test</span>  <span>ecx</span><span>,</span> <span>ecx</span>             <span>#   if (c == &#39;\0&#39;)
</span></span></span><span><span><span></span>        <span>je</span>    <span>ret</span>                  <span>#     return
</span></span></span><span><span><span></span>        <span>inc</span>   <span>rdi</span>                  <span>#   input++
</span></span></span><span><span><span></span>        <span>mov</span>   <span>esi</span><span>,</span> <span>0</span>               <span>#   n = 0
</span></span></span><span><span><span></span>        <span>cmp</span>   <span>ecx</span><span>,</span> <span>&#39;</span><span>s</span><span>&#39;</span>             <span>#   c == &#39;s&#39;?
</span></span></span><span><span><span></span>        <span>sete</span>  <span>sil</span>                  <span>#     n = 0|1
</span></span></span><span><span><span></span>        <span>cmp</span>   <span>ecx</span><span>,</span> <span>&#39;</span><span>p</span><span>&#39;</span>             <span>#   if (c == &#39;p&#39;)
</span></span></span><span><span><span></span>        <span>cmove</span> <span>esi</span><span>,</span> <span>edx</span>             <span>#     n = -1
</span></span></span><span><span><span></span>        <span>add</span>   <span>eax</span><span>,</span> <span>esi</span>             <span>#   res += n
</span></span></span><span><span><span></span>        <span>jmp</span>   <span>loop</span>                 <span># }
</span></span></span><span><span><span></span><span>ret:</span>    <span>ret</span>
</span></span></code></pre></div>
</div>
</div>
<p>â€¦ But is it fast?</p>
<p><strong>Runtime:</strong> 0.51s ğŸ¦</p>
<p><strong>Overall speedup:</strong>: 6.33x ğŸ“ˆ</p>
<p><strong>Bitrate</strong>: 1.83GiB/s</p>
<p>Well, thatâ€™s slower than using <code>cmov</code>s. I guess there are no points for using
less registers, or for using 8-bit operations instead of 32-bit onesâ€¦</p>
<h2 id="other-attempts"><a href="#other-attempts"><span>#Â </span>Other attempts</a></h2>
<p>I tried unrolling the loop of our best version. This slowed down the code.</p>
<p>I tried aligning the start of the loop to a 16-byte boundary (pro tip, you
can add <code>.align &lt;bytes&gt;</code> before a label, and GNU assembler will insert <code>nop</code>
instructions for you). This also slowed down the code.</p>
<h2 id="benchmarking-setup"><a href="#benchmarking-setup"><span>#Â </span>Benchmarking setup</a></h2>
<div><pre tabindex="0"><code data-lang="sh"><span><span>$ uname -sr
</span></span><span><span>Linux 6.1.33
</span></span><span><span>$ lscpu
</span></span><span><span>...
</span></span><span><span>  Model name:            AMD Ryzen <span>5</span> 5625U with Radeon Graphics
</span></span><span><span>    CPU family:          <span>25</span>
</span></span><span><span>    Thread<span>(</span>s<span>)</span> per core:  <span>2</span>
</span></span><span><span>    Core<span>(</span>s<span>)</span> per socket:  <span>6</span>
</span></span><span><span>    Socket<span>(</span>s<span>)</span>:           <span>1</span>
</span></span><span><span>$ clang --version
</span></span><span><span>clang version 16.0.1
</span></span><span><span>$ gcc --version
</span></span><span><span>gcc <span>(</span>GCC<span>)</span> 12.2.0
</span></span></code></pre></div><p>The C versions were compiled with <code>-march=native</code>, so that the C compiler knew
to produce code that was fast on <strong>my specific</strong> CPU, not some generic x86_64.</p>
<p>The benchmark runs the function over a list of one million characters (random
â€˜pâ€™s and â€™sâ€™s) one thousand times.</p>
<p>For each version, the benchmark was run several times, and the best result
chosen.</p>
<h2 id="conclusion"><a href="#conclusion"><span>#Â </span>Conclusion</a></h2>
<p>You can (sometimes) get a 6x speedup by hand-coding your tight C loop in
assembly, and optimizing using techniques that compilers donâ€™t seem to have
automated away yet.</p>
<p>Of course, this post isnâ€™t the end. If this still isnâ€™t fast enough for you,
you can read <a href="https://owen.cafe/posts/the-same-speed-as-c/">part two</a>.</p>
</div></div>
  </body>
</html>
