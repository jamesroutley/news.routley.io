<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cybertec-postgresql.com/en/multiranges-in-postgresql-14/">Original</a>
    <h1>Multiranges in Postgres</h1>
    
    <div id="readability-page-1" class="page"><div id="page"><div id="content"><div id="primary"><main id="main" role="main"><div><div><article id="post-38763"><div><header></header><p>Range types have been around in PostgreSQL for quite some time and are successfully used by developers to store various kinds of intervals with upper and lower bounds. However, in <a href="https://www.postgresql.org/docs/release/14.2/">PostgreSQL 14</a> a major new feature has been added to the database which makes this feature even more powerful: multiranges. To help you understand multiranges, I have compiled a brief introduction outlining the basic concepts and most important features.</p><h2>Getting started with range types</h2><p>Before we dive into multiranges, I want to quickly introduce basic range types so that you can compare what was previously available with what is available now. Here’s a simple example:</p><pre title="">test=# SELECT int4range(10, 20);
int4range
-----------
[10,20)
(1 row)
</pre><p>The important thing to note here is that ranges can be formed on the fly. In this case I’ve created an int4 range. The ranges starts at 10 (which is included) and ends at 20 (which is not included anymore). Basically, every numeric data type that can be sorted can be turned into a range.</p><p>What’s important to see is that PostgreSQL will ensure that the range is indeed valid which means that the upper bound has to be higher than the lower bound and so on:</p><pre title="">test=# SELECT int4range(432, 20);
ERROR: range lower bound must be less than or equal to range upper bound
</pre><h2>What is the purpose of a range type in the first place?</h2><p>Well, in addition to validation, PostgreSQL provides a rich set of operators. One of the basic operations you’ll often need is a way to check whether a value is inside a range or not. Here’s how it works:</p><pre title="">

test=# SELECT 17 &lt;@ int4range(10, 20);
?column?
----------
t
(1 row)

</pre><p>You can see from the above that 17 is indeed between 10 and 20 in the table. It’s a simple example, but this is also very useful in more complex cases.</p><h3>It’s also possible to use ranges as data types which can be part of a table:</h3><pre title="">

test=# CREATE TABLE t_range (id serial, t tstzrange);
CREATE TABLE
test=# INSERT INTO t_range (t)
VALUES (&#39;[&#34;2022-01-01&#34;, &#34;2022-12-31&#34;]&#39;) RETURNING *;
id | t
----+-----------------------------------------------------
1 | [&#34;2022-01-01 00:00:00-05&#34;,&#34;2022-12-31 00:00:00-05&#34;]
(1 row)

INSERT 0 1

</pre><p>In this case, I’ve used the tstzrange (“timestamp with time zone range”), and I’ve successfully inserted a value.</p><p>The beauty here is that the operators are available are consistent and work the same way for all range types. This makes them relatively easy to use.</p><h2>Multiranges: Range types of steroids</h2><p>So what are multiranges? The idea is simple: <strong>A multirange is a compilation of ranges.</strong> Instead of storing just two values, you can store as many pairs as you want. Let ‘s take a look at a practical example:</p><pre title="">

test=# SELECT int4multirange(int4range(10, 20), int4range(40, 50));
int4multirange
-------------------
{[10,20),[40,50)}
(1 row)

</pre><p>In this case, the multirange has been formed on the fly using two ranges. However, you can stuff in as many value pairs as you want:</p><pre title="">

test=# SELECT int4multirange(
int4range(10, 20),
int4range(40, 50),
int4range(56, 62),
int4range(80, 90)
);
int4multirange
-----------------------------------
{[10,20),[40,50),[56,62),[80,90)}
(1 row)

</pre><h3>PostgreSQL has a really nice features which can be seen when ranges are formed. Consider the following example:</h3><pre title="">

test=# SELECT int4multirange(
int4range(10, 20),
int4range(12, 25),
int4range(38, 42)
);
int4multirange
-------------------
{[10,25),[38,42)}
(1 row)

</pre><p>As you can see, multiple ranges are folded together to form a set of non-overlapping parts. This happens automatically and greatly reduces complexity.</p><h3>A multirange can also be used as a data type and stored inside a table just like any other value:</h3><pre title="">

test=# CREATE TABLE t_demo (id int, r int4multirange);
CREATE TABLE
test=# INSERT INTO t_demo
SELECT 1, int4multirange(
int4range(10, 20),
int4range(12, 25),
int4range(38, 42))
RETURNING *;
id | r
----+-------------------
1 | {[10,25),[38,42)}
(1 row)

INSERT 0 1

</pre><h3>The way you query this type of column is pretty straightforward and works as follows:</h3><pre title="">

test=# SELECT * FROM t_demo WHERE 17 &lt;@ r;
id | r
----+-------------------
1 | {[10,25),[38,42)}

</pre><p>You can simply apply the operator on the column, and you’re good to do. In our example, one row is returned which is exactly what we expect.</p><h2>Handling “infinity” inside ranges</h2><p>So far, you’ve seen that ranges have a beginning and a clearly defined end. However, there is more.</p><blockquote><p>In PostgreSQL, a range is aware of the concept of “infinity”.</p></blockquote><h3>Here is an example:</h3><pre title="">

test=# SELECT

numrange(NULL, 10);
numrange
----------
(,10)
(1 row)

</pre><p>This range starts with -INFINITY and ends at 10 (not included).</p><h3>Again, you’re able to fold single ranges into a bigger block:</h3><pre title="">

test=# SELECT numrange(NULL, 10), numrange(8, NULL);
numrange | numrange
----------+----------
(,10) | [8,)
(1 row)

test=# SELECT nummultirange(
numrange(NULL, 10),
numrange(8, NULL)
);
nummultirange
---------------
{(,)}
(1 row)

</pre><h3>The example shows a range than spans all numbers (= – INFINITY all the way to +INFINITY). The following query is proof of this fact:</h3><pre title="">

test=# SELECT 165.4 &lt;@ nummultirange(
numrange(NULL, 10),
numrange(8, NULL)
);
?column?
----------
t
(1 row)

</pre><p>The result is true: 165.4 is indeed within the range of valid numbers.</p><h2>Performing basic calculations</h2><p>That’s not all: you can perform basic operations using these ranges. Now just imagine what it would take to do such calculations by hand in some application. It would be slow, error-prone and in general, pretty cumbersome:</p><pre title="">

test=# SELECT nummultirange(numrange(1, 20)) - nummultirange(numrange(4, 6));
?column?
----------------
{[1,4),[6,20)}
(1 row)

</pre><p>You can deduct ranges from each other and form a multirange, which represents two ranges and a gap in between. The next example shows how intersections can be calculated:</p><pre title="">

test=# SELECT nummultirange(numrange(1, 20)) * nummultirange(numrange(4, 6));
?column?
----------
{[4,6)}
(1 row)

</pre><p>There are many more of these kinds of operations you can use to work with ranges. A complete list of all functions and operators is available in <a href="https://www.postgresql.org/docs/current/functions.html">the PostgreSQL documentation</a>.</p><h2>Multiranges: aggregating ranges</h2><p>The final topic I want to present is how to aggregate ranges into bigger blocks. Often, data is available in a standard form, and you want to do something fancy with it. Let ‘s create a table:</p><pre title="">

test=# CREATE TABLE t_holiday (name text, h_start date, h_end date);
CREATE TABLE
test=# INSERT INTO t_holiday
VALUES (&#39;hans&#39;, &#39;2020-01-10&#39;, &#39;2020-01-15&#39;);
INSERT 0 1
test=# INSERT INTO t_holiday
VALUES (&#39;hans&#39;, &#39;2020-03-04&#39;, &#39;2020-03-12&#39;);
INSERT 0 1
test=# INSERT INTO t_holiday
VALUES (&#39;joe&#39;, &#39;2020-01-04&#39;, &#39;2020-03-02&#39;);
INSERT 0 1
</pre><p>I’ve created a table and added 3 rows. Note that data is stored in the traditional way (“from / to”).</p><h3>What you can do now is to form ranges on the fly and create a multirange using the range_agg function:</h3><pre title="">

test=# SELECT range_agg(daterange(h_start, h_end)) FROM t_holiday;
range_agg
---------------------------------------------------
{[2020-01-04,2020-03-02),[2020-03-04,2020-03-12)}
(1 row)

</pre><h3>What’s important here is that you can do more than create a multirange – you can also unnest such a data type and convert it into single entries:</h3><pre title="">

test=# SELECT x, lower(x), upper(x)
FROM unnest((SELECT range_agg(daterange(h_start, h_end))
FROM t_holiday)) AS x;
x | lower | upper
-------------------------+------------+------------
[2020-01-04,2020-03-02) | 2020-01-04 | 2020-03-02
[2020-03-04,2020-03-12) | 2020-03-04 | 2020-03-12
(2 rows)

</pre><p>Let’s think about this query: Basically, aggregation and unnesting allow you to answer questions such as: “How many continuous periods of activity did we see?” That can be really useful if you are, for example, running data warehouses.</p><h2>Finally…</h2><p>In general, multiranges are a really valuable extension on top of what PostgreSQL already has to offer. This new feature in  PostgreSQL v14 allows us to offload many things to the database which would have otherwise been painful to do and painful to implement on your own.</p><p>If you want to learn more about PostgreSQL data types, take a look at Laurenz Albe’s recent blog on <a href="https://www.cybertec-postgresql.com/en/query-parameter-data-types-performance/">Query Parameter Data Types and Performance</a>, and if you are interested in data type abstraction check out my blog about <a href="https://www.cybertec-postgresql.com/en/create-domain-data-type-abstraction/">CREATE DOMAIN</a>.</p></div></article></div></div></main></div></div></div></div>
  </body>
</html>
