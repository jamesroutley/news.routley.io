<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elma.dev/notes/ai-makes-seniors-stronger/">Original</a>
    <h1>AI was supposed to help juniors shine. why does it mostly make seniors stronger?</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><div><p>The question “Will coding be taken over entirely by AI?” has been asked to death already, and people keep trying to answer it. I’m not sure there’s anything truly new to say, but I want to share my own observations.</p>
<p>The early narrative was that companies would need fewer seniors, and juniors together with AI could produce quality code. At least that’s what I kept seeing. But now, partly because AI hasn’t quite lived up to the hype, it looks like what companies actually need is not <strong>junior + AI</strong>, but <strong>senior + AI</strong>.</p>
<h2 id="why"><a aria-hidden="true" href="#why" tabindex="-1"><span></span></a>Why?</h2>
<p>Let’s look at where AI is good and where it falls short in coding.</p>
<p><strong>Where it helps:</strong></p>
<ul>
<li>Cranking out boilerplate and scaffolding</li>
<li>Automating repetitive routines</li>
<li>Trying out different implementations</li>
<li>Validating things quickly thanks to fast iteration</li>
<li>Shipping features fast, as long as you know what you want</li>
</ul>
<p>And who benefits most from that? Obviously seniors. In the hands of a junior, these things are harder to turn into real value. Still possible, but much tougher.</p>
<p><strong>Where it backfires:</strong></p>
<ul>
<li><strong>Code review</strong>: AI can’t really reason. Reviews can be useful, but once edge cases pop up (and they do a lot more in AI-generated code), you’re left needing a senior anyway.</li>
<li><strong>Bad prompts</strong>: Who writes good prompts? The people who actually understand what they’re building. If someone lacks the knowledge, they might still get “okay-ish” results, but with no proper checks in place it just leads to bugs and headaches.</li>
<li><strong>Architecture</strong>: Without solid architecture, software quickly loses value. Today AI can’t truly design good architecture; it feels like it might, but this kind of reasoning still requires humans. Projects that start with weak architecture end up drowning in technical debt.</li>
<li><strong>Code quality</strong>: Choosing the right abstractions, applying design patterns properly, keeping things clean and context-appropriate. AI still struggles here.</li>
<li><strong>Security</strong>: Think of it like a house without doors, or with broken locks. Security holes pop up more often with junior + AI combinations. Sure, security bugs exist everywhere, but at least with seniors you have some level of awareness and caution.</li>
<li><strong>Wrong learning</strong>: If someone can’t really evaluate the code, they may not realize what’s wrong with what AI produces. Inside a company that can mean producing damage instead of value.</li>
</ul>
<p>There are more examples, but the main point is this: AI is not really a threat to senior developers yet. It may even be the opposite. And this is not about criticizing juniors. It is about not throwing them into risky situations with unrealistic expectations.</p>
<p><strong>Where we should use AI:</strong></p>
<ul>
<li><strong>Fast prototyping</strong>: Perfect for trying out an idea quickly.</li>
<li><strong>Speeding up routines</strong>: The most important use. Automate the things you already know well and repeat often.</li>
<li><strong>Multi-disciplinary work</strong>: Filling gaps in your knowledge, suggesting useful methods or libraries, helping connect the dots when multiple domains collide.</li>
<li><strong>Function tests</strong>: Simple, repetitive, low-risk code you can easily double-check.</li>
</ul>
<p>From my perspective, that is the current state of things. We still have to read every line AI writes. It is far from perfect. No awareness. Reasoning is imitation. It is non-deterministic, which is why we rely on deterministic things like tests. But then, are you really going to trust the AI to write the tests that verify its own code?</p>
<p>It reminds me of something I tweeted: there was a prompt making AI say “I don’t know” when it didn’t know. My take was: <em>“If such AI says ‘I don’t know,’ you can’t be sure it knows that either.”</em></p>
<p>Of course, the junior + AI pairing was tempting. It looked cheaper, and it fed the fear that “AI will take our jobs.” But when you compare software to other professions, the field still shows signs of immaturity. In construction, architects design. In software, even the architects are still laying bricks by writing code. Our roles are still not specialized or merit-driven enough, and cost-cutting dominates. That devalues the work and burns people out.</p>
<p>So instead of democratizing coding, AI right now has mostly concentrated power in the hands of experts. Expectations did not quite match reality. We will see what happens next. I am optimistic about AI’s future, but in the short run we should probably reset our expectations before they warp any further.</p></div></div></div>
  </body>
</html>
