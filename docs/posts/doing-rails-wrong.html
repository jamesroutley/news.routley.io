<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bananacurvingmachine.com/articles/you-re-doing-rails-wrong">Original</a>
    <h1>Doing Rails Wrong</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p><em>Kevin</em>: Hey, have you tried Vite for Rails 8? It’s insanely fast.</p><p><em>John</em>: I’ve heard of it. Isn’t that a build tool? Didn’t Rails already come with one?</p><p><em>K</em>: Well, it did, but Vite is like… modern. You’ll need to install Node, npm, and configure a few scripts, but it’s totally worth it.</p><p><em>J</em>: Wait, Rails needs Node now?</p><p><em>K</em>: Well, yeah — if you want to use React. Everyone’s using React.</p><p><em>J</em>: Didn’t Rails have something for that?</p><p><em>K</em>: It did, but now you’ll want to use Vite with React Refresh so you get instant component reloads. And if you want TypeScript support, you’ll have to configure that too.</p><p><em>J</em>: Sounds… like a lot.</p><p><em>K</em>: Oh, not really. Just install Babel, configure your .babelrc, add vite-plugin-ruby, then you’ll want PostCSS for your styles.</p><p><em>J</em>: PostCSS?</p><p><em>K</em>: Yeah, and then Tailwind, obviously — you don’t want to write CSS like a peasant.</p><p><em>J</em>: Of course not.</p><p><em>K</em>: Then you’ll probably want to add ESLint and Prettier to make sure your code looks clean, and maybe Husky for pre-commit hooks.</p><p><em>J</em>: So... Vite, React, Babel, PostCSS, Tailwind, ESLint, Prettier, Husky. That’s it?</p><p><em>K</em>: Pretty much. Oh, unless you want server-side rendering — then you’ll need Next.js or Remix.</p><p><em>J</em>: Wait, we’re still talking about a Rails app, right?</p><p><em>K</em>: Yeah, but hybrid stacks are the way to go! You could also use StimulusReflex or Hotwire if you want reactive components without JS frameworks.</p><p><em>J</em>: StimulusReflex sounds like a Marvel character.</p><p><em>K</em>: Ha! No, it’s for real-time updates. But you’ll need ActionCable configured, Redis running, and—</p><p><em>J</em>: Redis?</p><p><em>K</em>: Yeah, you need a pub/sub layer. Don’t worry, it’s just another Docker container.</p><p><em>J</em>: Docker too?</p><p><em>K</em>: Yeah, to isolate your dependencies. And if you want everything reproducible, you’ll need Docker Compose, maybe Fly.io for deployment, and a build pipeline with GitHub Actions.</p><p><em>J</em>: That’s... quite a setup.</p><p><em>K</em>: It’s just modern web development, man. Keeps things simple. What are you doing?</p><p><em>J</em>: Just tinkering.</p><p><em>(John runs a single command. The app boots instantly, working forms, instant loading times, blazing fast navigation.)</em></p><p><em>K</em>: Wow, that looks like a pretty complex setup. What stack’s that?</p><p><em>J</em>: Vanilla Rails.</p><p><em>Just F#$%^&amp; use Rails.</em></p>
</div></div>
  </body>
</html>
