<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jsoftware.com/help/jforc/loopless_code_i_verbs_have_r.htm">Original</a>
    
    <div id="readability-page-1" class="page"><div>

<p>Most J programs contain no loops equivalent to <span><span>while</span></span>
and <span><span>for</span></span>
in C.  J does contain <span><span>while.</span></span> and <span><span>for.</span></span>
constructs, but they carry a performance penalty and are a wise choice only
when the body of the loop is a time-consuming operation.<span>  </span>You are just going to have to learn to learn
to code without loops.</p>

<p>I think this is the most intimidating thing about learning
J--more intimidating even than programs that look like a three-year-old with a
particular fondness for periods and colons was set before the keyboard.<span>  </span>You have developed a solid understanding of
loops, and can hardly think of programming without using them.<span>  </span>But J is a revolutionary language, and all
that is solid melts into air: you will find that most of your loops disappear
altogether, and the rest are replaced by small gestures to the interpreter
indicating your intentions.</p>

<p>Come, let us see how it can be done.<span>  </span>I promise, if you code in J for 6 months, you
will no longer think in loops, and if you stay with it for 2 years, you will
see that looping code was an artifact of early programming languages, ready to
be displayed in museums along with vacuum tubes, delay lines, and punched
cards.  Remember, in the 1960s programmers
laughed at the idea of programming without <span><span>goto</span></span>s!</p>

<p>You are not used to classifying loops according to their
function, but I am going to do so as a way of introducting J&#39;s primitives. We
will treat the subject of loopless iteration in 7 scattered chapters, showing
how to replace different variants of loops:</p>

<p>Loops where each iteration of the loop performs the same
operation on different data;</p>

<p>Loops that apply an operation between all the items of an
array, for example finding the largest item;</p>

<p>Loops where the operation to be performed on each cell is
different;</p>

<p>Loops that are applied to regularly-defined subsets of
the data;</p>

<p>Loops that are applied to subsets of the data defined
irregularly;</p>

<p>Loops that accumulate information between iterations of
the loop;</p>

<p>Loops that implement finite-state machines.</p>

<p>The simplest case is the most important, and we start with
a few experiments.</p>

<p><a name="_Toc191734332"></a><a name="_Toc5414548"></a><a name="_Toc5414402"></a><a name="_Toc1896185"><span><span><span>Examples
of Implicit Loops</span></span></span></a></p>

<p>   2 + 3 4 5</p>

<p>5 6 7</p>

<p>The verb dyad <span><span>+</span></span> is addition, and
we have our first example of an implicit loop: the left argument <span><span>2</span></span>
was added to each atom in the right argument.</p>

<p>   1 2 3 + 4
5 6</p>

<p>5 7 9</p>

<p>And look!  If
each operand is a list, the respective items are added.<span>  </span>We wonder if the behavior of <span><span>2 + 3 4 5</span></span>
was because items of the shorter operand are repeated cyclically:</p>

<p>   1 2 + 4 5
6</p>

<p>|length error</p>

<p>|   1 2<span>    </span>+4 5 6</p>

<p>Evidently not. 
A &#39;length error&#39; means that the operands to <span><span>+</span></span> did not &#39;agree&#39;
(and you get an error if you try to add them). 
We will shortly understand exactly what this means.</p>

<p>   i. 2 3</p>

<p>0 1 2</p>

<p>3 4 5</p>

<p>A reminder of what monad <span><span>i.</span></span> does.</p>

<p>   0 100 +
i. 2 3</p>

<p>  0<span>   </span>1   2</p>

<p>103 104 105</p>

<p>Whoa!  The
atoms of the left operand were applied to rows of the right operand.<span>  </span>Interesting. 
This seems to be some kind of nested implicit loop.</p>

<p>Let&#39;s learn a couple of more verbs, <!--[if supportFields]><span
style='mso-element:field-begin'></span><span
style='mso-spacerun:yes'> </span>XE "<span class=Jcode><span
style='mso-bidi-font-family:"Times New Roman"'>#.</span></span> monad" <![endif]--><!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->monad <span><span>#.</span></span> and <!--[if supportFields]><span
style='mso-element:field-begin'></span><span
style='mso-spacerun:yes'> </span>XE "<span class=Jcode><span
style='mso-bidi-font-family:"Times New Roman"'>#\:</span></span> monad" <![endif]--><!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]-->monad <span><span>#:</span></span><span> </span>.<span>  </span>Monad <span><span>#:</span></span> creates the
binary representation of an integer (i. e. a list of <span><span>0</span></span>s and <span><span>1</span></span>s),
and monad <span><span>#.</span></span>
is its inverse, creating the integer from the binary representation.<span>  </span>For the longest time I couldn&#39;t remember
which was which, but at last I saw the mnemonic: the verb with the single dot (<span><span>#.</span></span>)
creates an atom from a list; the verb with multiple dots (<span><span>#:</span></span>) creates a list
from an atom:</p>

<p>   #: 5</p>

<p>1 0 1</p>

<p>   #. 1 0 1</p>

<p>5</p>

<p>Yes, they seem to perform as advertised.<span>  </span>They can be applied to arrays:</p>

<p>   ]a =. #:
5 9</p>

<p>0 1 0 1</p>

<p>1 0 0 1</p>

<p>Look: the result is not a rank-1 list, but
rather a rank-2 array, where each item has the binary representation of
one operand value (and notice, an extra leading zero was added to the representation
of 5).  The little trick with <span><span>]a =.</span></span>
will be explained later, but for now just think of <span><span>]a =.</span></span> as &#39;assign
to <span><span>a</span></span>
and display the result&#39;.  With <span><span>a</span></span>
assigned, we have:</p>

<p>   #. a</p>

<p>5 9</p>

<p>This seems to be the desired result, but on reflection we
are puzzled: how did the interpreter know to apply <span><span>#.</span></span> to each 1-cell
rather than to each 0-cell? 
Contrast this result with the result of the verb monad <span><span>+:</span></span>,
which means &#39;multiply by 2&#39;:</p>

<p>   +: a</p>

<p>0 2 0 2</p>

<p>2 0 0 2</p>

<p>Evidently the verbs themselves have some attribute
that affects the rank of cell they are applied to.<span>  </span>It&#39;s time for us to stop experimenting and
learn what that attribute is.</p>

<p><a name="_Toc191734333"></a><a name="_Toc5414549"></a><a name="_Toc5414403"></a><a name="_Toc1896186"><span><span><span>The
Concept of Verb Rank</span></span></span></a></p>

<p>Every verb has a <span>rank</span>--the
rank<!--[if supportFields]><span style='mso-element:field-begin'></span> XE "rank"
<![endif]--><!--[if supportFields]><span style='mso-element:field-end'></span><![endif]--><span> </span>of the cells to which it is applied.<span>  </span>If the rank of the verb&#39;s operand is smaller
than the rank of the verb, the verb is applied to the entire operand and it is
up to the author of the verb to ensure that it produces a meaningful result in
that case.</p>

<p>Dyads have a rank for each operand, not necessarily the
same.</p>

<p>A verb&#39;s rank can be infinite (<span><span>_</span></span>), in which case
the verb is always applied to the operand in its entirety.<span>  </span>In other words, if a verb has infinite rank
for an operand, that operand is always processed as a single cell (having the
rank of the operand).</p>

<p>If you don&#39;t know the rank of a verb, you don&#39;t know the
verb.  Using a verb of unknown rank is
like wiring in a power-supply of unknown voltage--it will do something when you
plug it in; it might even work; but if the voltage is wrong it will destroy
what it&#39;s connected to.  Avoid
embarrassment!  Know the rank of the
verbs you use.</p>

<p>The definition page of each J verb gives the ranks of the
verbs defined on the page, right at the top of the page after the name of the
verb.  Since most pages define both a
monad and a dyad, you will usually find 3 numbers: the first is the rank of the
monad, the other two are the left and right rank of the dyad.<span>  </span>For example, click up the page for <span><span>#:</span></span>
and you will see</p>

<p>#:  _ 1 0</p>

<p>which means that monad <span><span>#:</span></span> has infinite
rank, while dyad <span><span>#:</span></span>
has left rank 1 and right rank 0.  For
any verb, including user-written verbs, you can ask the interpreter the rank by
typing <span><i><span>verbname</span></i></span><span><span> b. 0 </span></span>:</p>

<p>   #: b. 0</p>

<p>_ 1 0</p>

<p><a name="_Toc191734334"></a><a name="_Toc5414550"></a><a name="_Toc5414404"></a><a name="_Toc1896187"><span><span><span>Verb
Execution--How Rank Is Used (Monads)</span></span></span></a></p>

<p>The implicit looping in J results from the interplay of
verb rank and noun rank.  For monads, it
goes like this:</p>

<p><!--[if !supportLists]--><span>1.<span>     
</span></span><!--[endif]-->Figure out the rank <span>r</span> of
the cells that will be operated on; this will be the <b>smaller</b> of the rank
of the verb and the rank of the operand. 
For the important case of a verb infinite rank, according to this rule <i>r</i>
will be the rank of the operand, which is another way of saying that the verb
applies to the operand in its entirety.</p>

<p>Find the frame<!--[if supportFields]><span
style='mso-element:field-begin'></span> XE "frame" <![endif]--><!--[if supportFields]><span
style='mso-element:field-end'></span><![endif]--><span> </span><span>f</span> of the operand
with respect to cells of rank<i> r.</i></p>

<p>Think of the operand as an array with shape<i> f </i>made up of cells of rank <i>r</i>.<span>  </span>Apply the verb to each<i> r</i><span>-cell</span>,
replacing each cell with the result of the verb.<span>  </span>Obviously, this will yield an array of shape<i> f </i>whose items have the shape of the
result of applying the verb to an <i>r</i>-cell.</p>

<p>Let&#39;s look at some simple examples:</p>

<p>   i. 2 2</p>

<p>0 1</p>

<p>2 3</p>

<p>This will be the right operand.</p>

<p>   +: i. 2 2</p>

<p>0 2</p>

<p>4 6</p>

<p>The steps to get this result are:</p>

<table>
 <tbody><tr>
  <td colspan="2">
  <p>The verb rank is 0 and the noun rank is 2, so
  we will be applying the verb to 0-cells.<span>  </span>The frame <i>f</i> is <span><span>2 2</span></span></p>
  </td>
 </tr>
 <tr>
  <td>
  <p>Think of the operand as a 2x2 array of 0-cells:</p>
  </td>
  <td>
  
  
  </td>
 </tr>
 <tr>
  <td>
  <p>The verb is applied to each cell:</p>
  </td>
  <td>
  
  
  </td>
 </tr>
 <tr>
  <td>
  <p>Since each result is an atom, i. e. a 0-cell,
  the result is a 2x2 array of 0-cells, i. e. an array of shape <span><span>2 2</span></span></p>
  </td>
  <td>
  <p>0 2</p>
  <p>4 6</p>
  </td>
 </tr>
</tbody></table>

<div>

<div>
  <p>Figure <!--[if supportFields]><span
  style='mso-element:field-begin'></span><span
  style='mso-spacerun:yes'> </span>SEQ Figure \* ARABIC <span style='mso-element:
  field-separator'></span><![endif]--><span>1</span><!--[if supportFields]><span
  style='mso-element:field-end'></span><![endif]-->.<span>  </span>Execution of +: i. 2 2</p>
  </div>

</div>

<!--[if !supportTextWrap]--><!--[endif]-->



























<!--[if !supportTextWrap]-->
<!--[endif]-->





























































<!--[if !supportTextWrap]-->
<!--[endif]-->

































<!--[if !supportTextWrap]-->
<!--[endif]-->











<!--[if !supportTextWrap]-->
<!--[endif]-->

















<!--[if !supportTextWrap]-->
<!--[endif]-->



























































































































































<!--[if !supportTextWrap]-->
<!--[endif]-->

































































<!--[if !supportTextWrap]-->
<!--[endif]-->







































<!--[if !supportTextWrap]-->
<!--[endif]-->































<!--[if !supportTextWrap]-->
<!--[endif]-->

























































































































































</div></div>
  </body>
</html>
