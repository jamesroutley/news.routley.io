<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://avestura.dev/blog/problems-of-c-and-how-zig-addresses-them">Original</a>
    <h1>Problems of C, and how Zig addresses them</h1>
    
    <div id="readability-page-1" class="page"><div><p>C is a low-level systems programming language with almost no abstraction over memory
(so the memory management is all yours) and with minimal
abstractions over assembly (yet expressive enough to support some general concepts like
having a type system). It is also a very portable programming language, so when
written correctly, it can run on your kitchen toaster even if it has some obscure architecture.</p>
<p>The characteristics of C make it a highly suitable language for its intended purposes.
However, this does not imply that its design decisions are flawless by today&#39;s standards.
In this blog post, we will discuss certain issues that have led to multiple attempts at
creating alternative languages aimed at replacing C.</p>
<p>The Zig programming language has garnered considerable attention as a new systems
programming language, positioning itself as <em>the better C</em>. But how does Zig achieve this?
In this blog post, our aim is to examine some of the issues associated with C and explore
how Zig intends to address them.</p>
<h3 id="table-of-differences"><a href="#table-of-differences" aria-hidden="true" tabindex="-1"><span></span></a>Table of Differences</h3>
<ul>
<li><a href="#comptime-over-textual-replacement-preprocessing"><code>Comptime</code> over Textual Replacement Preprocessing</a></li>
<li><a href="#memory-management-and-zig-allocators">Memory Management, and Zig <code>Allocator</code>s</a></li>
<li><a href="#billion-dollar-mistake-vs-zig-optionals">Billion dollar mistake vs Zig Optionals</a></li>
<li><a href="#pointer-arithmetics-vs-zig-slices">Pointer arithmetics vs Zig <code>Slice</code>s</a></li>
<li><a href="#explicit-memory-alignment">Explicit memory alignment</a></li>
<li><a href="#arrays-as-values">Arrays as values</a></li>
<li><a href="#error-handling">Error handling</a></li>
<li><a href="#everything-is-an-expression">Everything is an expression</a></li>
<li><a href="#c-has-a-more-complex-syntax-to-deal-with">C has a more complex syntax to deal with</a></li>
</ul>
<h2 id="comptime-over-textual-replacement-preprocessing"><a href="#comptime-over-textual-replacement-preprocessing" aria-hidden="true" tabindex="-1"><span></span></a><code>Comptime</code> over Textual Replacement Preprocessing</h2>
<p>Replacing the text in the source code using preprocessors is not exclusive to C. It existed way before the
creation of C and can be traced back to earlier examples such as the SAP assembler for IBM 704 computers.
Below is an example of an AMD64
assembly snippet that defines a <code>pushr</code> macro and substitutes it with either <code>push</code> or <code>pushf</code>
based on its argument:</p>

<p>C being a minimal abstraction over assembly adopted the same method to support macros, which can
easily turn into a foot gun. As a small example:</p>

<p>One might expect this code to set the value of the <code>result</code> to <code>square of (2 + 3) = (2 + 3)^2 = 25</code>.
However, due to the textual replacement nature of the <code>SQUARE</code> macro function, the expansion
results in <code>2 + 3 * 2 + 3</code>, which evaluates to 11, not 25.</p>
<p>To make this work correctly, it is crucial to ensure that all our macros are properly parenthesized:</p>

<p>C will not tolerate such errors, nor will be kind enough to notify you about them. An error can
show itself much later, on another input, in a completely irrelevant part of the program.</p>
<p>Zig, on the other hand, employs a much more intuitive approach for such tasks by introducing <code>comptime</code>
parameters and functions. This enables us to execute functions during compile-time rather than runtime.
Here&#39;s the same C <code>SQUARE</code> macro in Zig:</p>

<p>Another advantage of the Zig compiler is its ability to perform type checking on inputs, even if it is <code>anytype</code>.
When calling the <code>square</code> function in Zig, if a type is used that does not support the <code>*</code> operator,
it would result in a compile-time type error:</p>

<p><code>Comptime</code> allows execution of any arbitrary code in compile time:</p>

<p>This Zig program defines a <code>fibonacci</code> function and then calls the function
at compile-time to set the value of <code>foo</code>. No <code>fibonacci</code> is called at runtime.</p>
<p>Zig&#39;s comptime evaluations can also cover some of the small C quirks: For instance, in a platform where
the minimum <code>signed</code> value is -2^15=-32768 and the maximum value is (2^15)-1=32767,
it is impossible to write the minimum value of the type <code>signed</code> as a literal constant in C.</p>

<p>That is because in C <code>-32768</code> is actually <code>-1 * 32768</code> and <code>32768</code> is not in the boundaries
of the <code>signed</code> type. In Zig, however, <code>-1 * 32768</code> is a compile time evaluation.</p>

<h2 id="memory-management-and-zig-allocators"><a href="#memory-management-and-zig-allocators" aria-hidden="true" tabindex="-1"><span></span></a>Memory Management, and Zig <code>Allocator</code>s</h2>
<p>As I&#39;ve previously mentioned, C has almost no abstraction over memory. This has pros and cons:</p>
<ul>
<li><strong>Pro</strong>: One has full control over memory and can do whatever one wants with it</li>
<li><strong>Con</strong>: One has full control over memory and can do whatever one wants with it</li>
</ul>
<p>With great power comes great responsibility. Mismanaging memory in a language like C with manual
memory-management can have great security consequences. At best it can result in a denial of service,
and at worst it can let an attacker to execute any arbitrary code. Many languages tried to reduce
that responsibility by either imposing coding restrictions, or by erasing the entire question
using a Garbage Collector. However, Zig adopts a different approach.</p>
<p>Zig offers several advantages simultaneously:</p>
<ul>
<li>Manual Memory Management: You do you. Control over memory is in your hands. No coding restrictions as you see in Rust.</li>
<li>No hidden allocation: Nothing allocates on the heap, without you knowing it and letting it happen.
Zig utilizes the <code>Allocator</code> type to achieve this. Any function that allocates on heap
receives an <code>Allocator</code> as parameter. Anything that doesn&#39;t do so won&#39;t allocate on heap, guaranteed.</li>
<li>Safety tools to avoid memory leaks e.g. <code>std.heap.GeneralPurposeAllocator</code></li>
</ul>
<p>Zig doesn&#39;t limit you on the way you code as Rust does,
helps your remain safe and avoid leaks, but still let you go full rogue as you can do in C. I
personally think it might be a convenient middle ground.</p>

<p>The above Zig code utilized the built-in <code>std.testing.allocator</code> to initialize an <code>ArrayList</code>
and lets you <code>allocate</code> and <code>free</code>, and test if you&#39;re leaking memory:</p>


<h2 id="billion-dollar-mistake-vs-zig-optionals"><a href="#billion-dollar-mistake-vs-zig-optionals" aria-hidden="true" tabindex="-1"><span></span></a>Billion dollar mistake vs Zig Optionals</h2>
<p>This C code crashes abruptly, leaving you no clue other than a <code>SIGSEGV</code> about what the hell is going on:</p>

<p>On the other hand, Zig does not have any <code>null</code> references. It has Optional types instead
denoted by a question mark at the beginning.
You can assign <code>null</code> only to optional types, and you can
only reference them when you have checked if they are not null using <code>orelse</code> keyword or simply
via an <code>if</code> expression. You&#39;ll end up facing a compile error otherwise.</p>


<h2 id="pointer-arithmetics-vs-zig-slices"><a href="#pointer-arithmetics-vs-zig-slices" aria-hidden="true" tabindex="-1"><span></span></a>Pointer arithmetics vs Zig <code>Slice</code>s</h2>
<p>In C, an address is represented as a numeric value, which allows developers to perform arithmetic
operations on pointers. This feature enables C developers to access and modify arbitrary memory
locations by manipulating addresses.</p>
<p>Pointer arithmetic is commonly used for tasks such as manipulating or accessing specific parts of
an array or navigating through dynamically allocated memory blocks efficiently, without the need
for copying. However, due to the unforgiving nature of C, pointer arithmetic can easily lead to
issues such as segmentation faults or undefined behavior, making debugging a true pain in the arms.</p>
<p>Most of such issues can be fixed using <code>Slice</code>s. Slices provide a safer and more
intuitive way to manipulate and access arrays or sections of memory:</p>

<h2 id="explicit-memory-alignment"><a href="#explicit-memory-alignment" aria-hidden="true" tabindex="-1"><span></span></a>Explicit memory alignment</h2>
<p>Each type has an alignment number which defines the memory addresses
that are considered legal for that type.
Alignment is measured in bytes, and it ensures that the starting address of a variable is evenly
divisible by the alignment value. For example:</p>
<ul>
<li>The <code>u8</code> type has the natural alignment of 1, meaning it can reside in any memory address.</li>
<li>The <code>u16</code> type has the natural alignment of 2, meaning it can only reside in locations of memory with addresses
that are evenly divisible by 2, such as 0, 2, 4, 6, 8, etc...</li>
<li>The <code>u32</code> type has the natural alignment of 4, meaning it can only reside in locations of memory with addresses
that are evenly divisible by 4, such as 0, 4, 8, 12, 16, etc...</li>
</ul>
<p>The CPU enforces these alignment requirements. If a variable&#39;s type is not properly aligned,
it can lead to program crashes such as segmentation faults or result in <code>illegal instruction</code> errors.</p>
<p>Now we are going to intentionally create a misaligned pointer to an <code>unsigned int</code> in the code
below. This code will crash on runtime on most CPUs:</p>

<p>Working with low-level languages can brings its own challanges like managing the alignment of
the memory. Making a mistake can cause a crash, and C won&#39;t help with that. How about Zig?</p>
<p>Let&#39;s write a similar code in Zig:</p>

<p>If you compile the code above, Zig will complain and prevent compiling as there is an alignment issue:</p>

<p>Even if you try to fool zig with an explicit <code>@alignCast</code>, Zig will add a pointer alignment safety check
to the generated code on safe build modes to make sure the pointer is aligned as promised.
So if the alignment is wrong on runtime, it will panic with a message and a trace for you to
have a clue where the problem is coming from. Something that C doesn&#39;t do for you:</p>

<p>And on runtime you&#39;ll receive:</p>

<p>Cool stuff!</p>
<h2 id="arrays-as-values"><a href="#arrays-as-values" aria-hidden="true" tabindex="-1"><span></span></a>Arrays as values</h2>
<p>The semantics of C defines arrays to be always passed as references&#34;</p>

<p>The solution in C is to create a <em>wrapper</em> struct and pass the struct instead:</p>

<p>In Zig it just works:</p>

<h2 id="error-handling"><a href="#error-handling" aria-hidden="true" tabindex="-1"><span></span></a>Error handling</h2>
<p>Many C APIs have the concept of error codes where the return value of a function represents
either the success status or an integer indicating the specific error that occurred.</p>
<p>Zig uses the same method to handle errors, but improves upon this concept by capturing it in a
more useful and expressive manner within the type system.</p>
<p>An error set in Zig is like an enum. However, each error name across the entire compilation
gets assigned an unsigned integer greater than 0.</p>
<p>An error set type and a normal type can be combined with the ! operator to form an error
union type (example: <code>FileOpenError!u16</code>).
Values of these types may be an error value, or a value of the normal type.</p>

<p>Zig does have <code>try</code> and <code>catch</code> keywords but they are unrelated to <code>try</code> and <code>catch</code> in other languages as
Zig does not have exceptions.</p>
<p><code>try x</code> is a shortcut for <code>x catch |err| return err</code>, and is commonly used in places where handling an error isnâ€™t appropriate.</p>
<p>Overall, Zig&#39;s error handling mechanism is similar to C, but has the type system&#39;s support.</p>


<h2 id="everything-is-an-expression"><a href="#everything-is-an-expression" aria-hidden="true" tabindex="-1"><span></span></a>Everything is an expression</h2>
<p>Coming from higher level languages to C, you might have missed features like this:</p>

<p>The beauty of Zig is that you can behave Zig blocks as if they are expressions.</p>

<p>Or for a more complex example:</p>

<p>Every block can have a label like <code>:blk</code> and <code>break</code> from that block with <code>break blk:</code> to return a value.</p>
<h2 id="c-has-a-more-complex-syntax-to-deal-with"><a href="#c-has-a-more-complex-syntax-to-deal-with" aria-hidden="true" tabindex="-1"><span></span></a>C has a more complex syntax to deal with</h2>
<p>Look at this C type:</p>

<p>This declares <code>bar</code> as a constant pointer to the array 5 of the pointer to the function (int) returning a
constant pointer to char. Whatever that means.</p>
<p>There are even tools like <a target="_blank" rel="noopener noreferrer" href="https://cdecl.org/">cdecl.org</a>
which helps you read C types and humanizes them for you. I am pretty sure
it might not be that challenging for practical C developers out there to deal with such types.
Some people are blessed with such abilities to be able to read the language of gods.
But for a simple man like me who rather keep things stupid simple,
Zig types are easier to read and maintain.</p>

<h2 id="conclustion"><a href="#conclustion" aria-hidden="true" tabindex="-1"><span></span></a>Conclustion</h2>
<p>In this blog post, we have discussed some of the issues with C that have led people to
seek or create alternatives for this relic of the past.</p>
<p>Zig, in summary, tackles these problems by:</p>
<ul>
<li>Zig Comptimes</li>
<li>Zig Allocators</li>
<li>Zig Optionals</li>
<li>Zig Slices</li>
<li>Zig Explicit Alignment</li>
<li>Zig Arrays</li>
<li>Zig error types</li>
<li>Zig expressions</li>
</ul>

<ul>
<li><a href="https://www.evalapply.org/blog/ideal-programming-language">An opinion on what&#39;s a good general-purpose programming language</a></li>
</ul>
<h2 id="appreciation"><a href="#appreciation" aria-hidden="true" tabindex="-1"><span></span></a>Appreciation</h2>
<p>Thanks to my friend <a target="_blank" rel="noopener noreferrer" href="https://github.com/trgwii">Thomas</a> for technically reviewing this blog post.</p>
<h2 id="references"><a href="#references" aria-hidden="true" tabindex="-1"><span></span></a>References</h2>
<p>These are some of the references used to write this article:</p>
<ul>
<li>Gustedt, J. (2019). Modern C. Manning.</li>
<li>Zhirkov, I. (2017). Low-Level Programming: C, Assembly, and Program Execution on Intel x86-64 Architecture. Apress.</li>
<li>Zig Language Reference. [Online]. <a target="_blank" rel="noopener noreferrer" href="https://ziglang.org/documentation/master">ziglang.org/documentation/master</a></li>
<li>Zig Learn. [Online]. <a target="_blank" rel="noopener noreferrer" href="https://ziglearn.org">ziglearn.org</a></li>
</ul></div></div>
  </body>
</html>
