<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jtarchie.com/posts/2024-08-30-exploring-goja-a-golang-javascript-runtime">Original</a>
    <h1>Goja: A Golang JavaScript Runtime</h1>
    
    <div id="readability-page-1" class="page"><div><p>This post explores <a href="https://github.com/dop251/goja">Goja</a>, a JavaScript runtime
library in the Golang ecosystem. Goja stands out as a powerful tool for
embedding JavaScript within Go applications, offering unique advantages when
manipulating data and exposing an SDK that doesn’t require a <code>go build</code> step.</p><h2 id="background-the-need-for-goja"><a href="#background-the-need-for-goja">#</a> Background: The Need for Goja</h2><p>In my project, I encountered challenges when querying and manipulating large
datasets. Initially, everything was written in Go, which was efficient but
became cumbersome, especially when dealing with complex JSON responses. While
Go’s minimalistic approach is generally advantageous, the verbosity required for
specific tasks slowed me down.</p><p>Using an embedded scripting language could simplify the process, leading me to
explore various options. Lua was my first choice because of its reputation for
being lightweight and embeddable. Still, I quickly found that the available Go
libraries for Lua were all over the place in implementations, versions (5.1,
5.2, etc), and active support.</p><p>I then investigated other popular scripting languages in the Go ecosystem. I
considered options like <a href="https://github.com/expr-lang/expr/">Expr</a>,
<a href="https://github.com/tommie/v8go">V8</a>, and
<a href="https://github.com/google/starlark-go">Starlark</a>, but eventually, Goja emerged
as the most promising candidate.</p><p>Here is the
<a href="https://github.com/jtarchie/benchmark-tests/blob/22789057b4fcf95443ea8cb61f261dea31935cda/eval_benchmark_test.go">GitHub repository</a>,
where I conducted some benchmarks on these libraries, testing their performance
and ease of integration with Go.</p><h2 id="why-goja"><a href="#why-goja">#</a> Why Goja?</h2><p>Goja won me over because of its seamless integration with Go structs. When you
assign a Go struct to a value in the JavaScript runtime, Goja automatically
infers the fields and methods, making them accessible in JavaScript without
requiring a separate bridge layer. It leverages Go’s reflection capabilities to
invoke getters and setters on these fields, offering a robust and transparent
interaction between Go and JavaScript.</p><p>Let’s dive into some examples to see Goja in action. These examples highlight
features I’ve found useful, but desired to have more examples in the
documentation with.</p><h2 id="assigning-and-returning-values"><a href="#assigning-and-returning-values">#</a> Assigning and Returning Values</h2><p>To start, let’s take a simple example where we pass an array of integers from Go
to the JavaScript runtime and filter out the even values.</p><pre tabindex="0"><code><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> <span>(</span>
</span></span><span><span>	<span>&#34;fmt&#34;</span>
</span></span><span><span>
</span></span><span><span>	<span>&#34;github.com/dop251/goja&#34;</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>	<span>vm</span> <span>:=</span> <span>goja</span><span>.</span><span>New</span><span>()</span>
</span></span><span><span>
</span></span><span><span>	<span>// Passing an array of integers from 1 to 100
</span></span></span><span><span><span></span>	<span>values</span> <span>:=</span> <span>[]</span><span>int</span><span>{}</span>
</span></span><span><span>	<span>for</span> <span>i</span> <span>:=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>100</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
</span></span><span><span>		<span>values</span> <span>=</span> <span>append</span><span>(</span><span>values</span><span>,</span> <span>i</span><span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>// Define the JavaScript code to filter even values
</span></span></span><span><span><span></span>	<span>script</span> <span>:=</span> <span>`
</span></span></span><span><span><span>		values.filter((x) =&gt; {
</span></span></span><span><span><span>			return x % 2 === 0;
</span></span></span><span><span><span>		})
</span></span></span><span><span><span>  `</span>
</span></span><span><span>
</span></span><span><span>	<span>// Set the array in the JavaScript runtime
</span></span></span><span><span><span></span>	<span>vm</span><span>.</span><span>Set</span><span>(</span><span>&#34;values&#34;</span><span>,</span> <span>values</span><span>)</span>
</span></span><span><span>
</span></span><span><span>	<span>// Run the script
</span></span></span><span><span><span></span>	<span>result</span><span>,</span> <span>err</span> <span>:=</span> <span>vm</span><span>.</span><span>RunString</span><span>(</span><span>script</span><span>)</span>
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>		<span>panic</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>// Convert the result back to a Go slice of empty interfaces
</span></span></span><span><span><span></span>	<span>filteredValues</span> <span>:=</span> <span>result</span><span>.</span><span>Export</span><span>().([]</span><span>interface</span><span>{})</span>
</span></span><span><span>
</span></span><span><span>	<span>fmt</span><span>.</span><span>Println</span><span>(</span><span>filteredValues</span><span>)</span>
</span></span><span><span>	<span>// Outputs: [2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100]
</span></span></span><span><span><span></span>
</span></span><span><span>	<span>first</span> <span>:=</span> <span>filteredValues</span><span>[</span><span>0</span><span>].(</span><span>int64</span><span>)</span>
</span></span><span><span>	<span>fmt</span><span>.</span><span>Println</span><span>(</span><span>first</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre><p>In this example, you can see that iterating through an array in Goja doesn’t
require explicit type annotations. Goja is able to infer the type of the array
based on its content, thanks to Go’s reflection mechanism. When filtering the
values and returning the result, Goja converts the result back to an array of
empty interfaces (<code>[]interface{}</code>). This is because Goja needs to handle
JavaScript’s dynamic typing within Go’s static type system.</p><p>If you need to work with the resulting values in Go, you’ll have to perform type
assertions to extract the integers. Internally, Goja represents all integers as
<code>int64</code>.</p><h2 id="structs-and-method-calls"><a href="#structs-and-method-calls">#</a> Structs and Method Calls</h2><p>Next, let’s explore how Goja handles Go structs, particularly focusing on
methods and exported fields.</p><pre tabindex="0"><code><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> <span>(</span>
</span></span><span><span>    <span>&#34;fmt&#34;</span>
</span></span><span><span>    <span>&#34;github.com/dop251/goja&#34;</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>Person</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>Name</span> <span>string</span>
</span></span><span><span>    <span>age</span>  <span>int</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// Method to get the age (unexported)
</span></span></span><span><span><span></span><span>func</span> <span>(</span><span>p</span> <span>*</span><span>Person</span><span>)</span> <span>GetAge</span><span>()</span> <span>int</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>p</span><span>.</span><span>age</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>vm</span> <span>:=</span> <span>goja</span><span>.</span><span>New</span><span>()</span>
</span></span><span><span>
</span></span><span><span>    <span>// Create a new Person instance
</span></span></span><span><span><span></span>    <span>person</span> <span>:=</span> <span>&amp;</span><span>Person</span><span>{</span>
</span></span><span><span>        <span>Name</span><span>:</span> <span>&#34;John Doe&#34;</span><span>,</span>
</span></span><span><span>        <span>age</span><span>:</span>  <span>30</span><span>,</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// Set the Person struct in the JavaScript runtime
</span></span></span><span><span><span></span>    <span>vm</span><span>.</span><span>Set</span><span>(</span><span>&#34;person&#34;</span><span>,</span> <span>person</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// JavaScript code to access the struct&#39;s fields and methods
</span></span></span><span><span><span></span>    <span>script</span> <span>:=</span> <span>`
</span></span></span><span><span><span>        const name = person.Name;    // Access exported field
</span></span></span><span><span><span>        const age = person.GetAge(); // Access unexported field via getter
</span></span></span><span><span><span>        name + &#34; is &#34; + age + &#34; years old.&#34;;
</span></span></span><span><span><span>    `</span>
</span></span><span><span>
</span></span><span><span>    <span>result</span><span>,</span> <span>err</span> <span>:=</span> <span>vm</span><span>.</span><span>RunString</span><span>(</span><span>script</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>panic</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>result</span><span>.</span><span>String</span><span>())</span> <span>// Outputs: John Doe is 30 years old.
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre><p>In this example, I’ve defined a <code>Person</code> struct with an exported <code>Name</code> field
and an unexported <code>age</code> field. The <code>GetName</code> method is exported. When accessing
these fields and methods from JavaScript, Goja adheres to the naming conventions
on the struct. The method <code>GetAge</code> is accessed as <code>GetName</code>.</p><p>There is a pattern for making the Javascript naming convention of camel case
translate to Golang naming convention via
<a href="https://pkg.go.dev/github.com/dop251/goja#FieldNameMapper"><code>FieldNameMapper</code></a>.
This allows for the Go method <code>GetAge</code> to be called as <code>getAge</code> in the
javascript invocation.</p><h2 id="exception-handling"><a href="#exception-handling">#</a> Exception Handling</h2><p>When an exception occurs in JavaScript, Goja uses standard Go error handling to
manage it. Let’s explore an example of a runtime exception—division by zero.</p><pre tabindex="0"><code><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> <span>(</span>
</span></span><span><span>	<span>&#34;errors&#34;</span>
</span></span><span><span>	<span>&#34;fmt&#34;</span>
</span></span><span><span>
</span></span><span><span>	<span>&#34;github.com/dop251/goja&#34;</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>// JavaScript code that triggers a division by zero error
</span></span></span><span><span><span></span><span>const</span> <span>script</span> <span>=</span> <span>`
</span></span></span><span><span><span>	// Using BigInt notation in JavaScript
</span></span></span><span><span><span>	const a = 1n / 0n;
</span></span></span><span><span><span>`</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>	<span>vm</span> <span>:=</span> <span>goja</span><span>.</span><span>New</span><span>()</span>
</span></span><span><span>
</span></span><span><span>	<span>// Execute the JavaScript code
</span></span></span><span><span><span></span>	<span>_</span><span>,</span> <span>err</span> <span>:=</span> <span>vm</span><span>.</span><span>RunString</span><span>(</span><span>script</span><span>)</span>
</span></span><span><span>
</span></span><span><span>	<span>// Handle any errors that occur
</span></span></span><span><span><span></span>	<span>var</span> <span>exception</span> <span>*</span><span>goja</span><span>.</span><span>Exception</span>
</span></span><span><span>	<span>if</span> <span>errors</span><span>.</span><span>As</span><span>(</span><span>err</span><span>,</span> <span>&amp;</span><span>exception</span><span>)</span> <span>{</span>
</span></span><span><span>		<span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;JavaScript error: %s\n&#34;</span><span>,</span> <span>exception</span><span>.</span><span>Error</span><span>())</span>
</span></span><span><span>		<span>// Output: JavaScript error: RangeError: Division by zero at &lt;eval&gt;:1:1(3)
</span></span></span><span><span><span></span>	<span>}</span> <span>else</span> <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>		<span>// Handle other types of errors (if any)
</span></span></span><span><span><span></span>		<span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;Error: %s\n&#34;</span><span>,</span> <span>err</span><span>.</span><span>Error</span><span>())</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre><p>The error value returned is of type <code>*goja.Exception</code>, which provides
information about the JavaScript exception that was raised and where it failed.
While I haven’t found a strong need to inspect these errors beyond logging them
to services like New Relic or DataDog, Goja does offer the tools to do so if
necessary.</p><p>Additionally, Goja can raise other types of exceptions, such as
<code>*goja.StackOverflowError</code>, <code>*goja.InterruptedError</code>, and
<code>*goja.CompilerSyntaxError</code>, which correspond to specific issues related to the
interpreter. These exceptions can be useful to handle and report, especially
when dealing with clients that execute JavaScript code.</p><h2 id="sandbox-user-code-with-a-pool-of-vms"><a href="#sandbox-user-code-with-a-pool-of-vms">#</a> Sandbox User Code with a Pool of VMs</h2><p>While developing my application, I noticed that initializing the VM took a
significant amount of time. Each VM required global modules that needed to be
available to the user at runtime. Go provides <code>sync.Pool</code> to help <em>reuse</em>
objects, making it a perfect fit for my use case to avoid the overhead of heavy
initialization.</p><p>Here’s an example of a pool of Goja VMs:</p><pre tabindex="0"><code><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> <span>(</span>
</span></span><span><span>	<span>&#34;fmt&#34;</span>
</span></span><span><span>	<span>&#34;sync&#34;</span>
</span></span><span><span>
</span></span><span><span>	<span>&#34;github.com/dop251/goja&#34;</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>var</span> <span>vmPool</span> <span>=</span> <span>sync</span><span>.</span><span>Pool</span><span>{</span>
</span></span><span><span>	<span>New</span><span>:</span> <span>func</span><span>()</span> <span>interface</span><span>{}</span> <span>{</span>
</span></span><span><span>		<span>vm</span> <span>:=</span> <span>goja</span><span>.</span><span>New</span><span>()</span>
</span></span><span><span>
</span></span><span><span>		<span>// Define a global function available in every VM
</span></span></span><span><span><span></span>		<span>vm</span><span>.</span><span>Set</span><span>(</span><span>&#34;add&#34;</span><span>,</span> <span>func</span><span>(</span><span>a</span><span>,</span> <span>b</span> <span>int</span><span>)</span> <span>int</span> <span>{</span>
</span></span><span><span>			<span>return</span> <span>a</span> <span>+</span> <span>b</span>
</span></span><span><span>		<span>})</span>
</span></span><span><span>
</span></span><span><span>		<span>// ... other global values set ...
</span></span></span><span><span><span></span>
</span></span><span><span>		<span>return</span> <span>vm</span>
</span></span><span><span>	<span>},</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>	<span>vm</span> <span>:=</span> <span>vmPool</span><span>.</span><span>Get</span><span>().(</span><span>*</span><span>goja</span><span>.</span><span>Runtime</span><span>)</span>
</span></span><span><span>	<span>// Put the VM back into the pool for reuse
</span></span></span><span><span><span></span>	<span>defer</span> <span>vmPool</span><span>.</span><span>Put</span><span>(</span><span>vm</span><span>)</span>
</span></span><span><span>
</span></span><span><span>	<span>script</span> <span>:=</span> <span>`
</span></span></span><span><span><span>		const result = add(5, 10);
</span></span></span><span><span><span>		result;
</span></span></span><span><span><span>	`</span>
</span></span><span><span>
</span></span><span><span>	<span>value</span><span>,</span> <span>err</span> <span>:=</span> <span>vm</span><span>.</span><span>RunString</span><span>(</span><span>script</span><span>)</span>
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>		<span>panic</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;Result:&#34;</span><span>,</span> <span>value</span><span>.</span><span>Export</span><span>())</span>
</span></span><span><span>	<span>// Result: 15
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre><p>Since <a href="https://pkg.go.dev/sync#Pool"><code>sync.Pool</code></a> is well-documented, let’s
focus on the JavaScript runtime. In this example, the user declares a variable
<code>result</code>, and its value is returned. However, we encounter a limitation: the VM
cannot be reused as is.</p><p>The global namespace has been polluted with the variable <code>result</code>. If I rerun
the same code with the same pool, I receive the following error:
<code>SyntaxError: Identifier &#39;result&#39; has already been declared at &lt;eval&gt;:1:1(0)</code>.
There is a <a href="https://github.com/dop251/goja/issues/205">GitHub issue</a> that
recommends clearing the value of <code>result</code> each time. However, I found this
pattern impractical due to the added complexity when dealing with user-provided
code.</p><p>Until now, the examples I’ve given have been demonstrations of predefined code.
My application, however, allows users to provide their own code to run within
the Goja runtime. This required some experimentation,
<a href="https://github.com/pocketbase/pocketbase/blob/5547c0deded8f9cc329cd6f0670aef19e2a3001a/plugins/jsvm/binds.go#L218">exploration</a>,
and the adoption of patterns to avoid the “already declared” error.</p><pre tabindex="0"><code><span><span><span>value</span><span>,</span> <span>err</span> <span>:=</span> <span>vm</span><span>.</span><span>RunString</span><span>(</span><span>&#34;(function() {&#34;</span> <span>+</span> <span>userCode</span> <span>+</span> <span>&#34;})()&#34;</span><span>)</span>
</span></span><span><span><span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>	<span>panic</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre><p>The final solution for sandboxing user code involves executing the <code>userCode</code>
within an anonymous function in its own scope. Since the function isn’t named,
it isn’t assigned globally, and therefore doesn’t require cleanup. After some
benchmark testing, I confirmed that garbage collection effectively cleans it up
as well.</p><h2 id="conclusion"><a href="#conclusion">#</a> Conclusion</h2><p>I’ve unlocked a flexible and efficient way to handle complex scripting tasks
without sacrificing performance. This approach significantly reduces the time
spent on cumbersome tasks, giving you more time to focus on other important
aspects, and enhances the overall user experience by providing a seamless and
responsive scripting environment.</p><p>My experience with the nuances of Goja helps you get started quickly!</p></div></div>
  </body>
</html>
