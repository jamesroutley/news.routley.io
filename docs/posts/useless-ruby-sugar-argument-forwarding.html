<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zverok.space/blog/2023-11-24-syntax-sugar4-argument-forwarding.html">Original</a>
    <h1>&#34;Useless Ruby sugar&#34;: Argument forwarding</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <blockquote>
  <p>This is a part of a blog post series about “useless” (or: controversial) syntax elements that emerged in recent Ruby version. The goal of the series is not to defend (or criticize) the features, but to share a “thought framework” for analysis of their reasons, design, and effect the new syntax has on a code that uses it. See also <a href="https://zverok.space/blog/2023-10-02-syntax-sugar.html">intro/ToC post</a>.</p>
</blockquote>

<p>Today’s post covers the feature that, unlike most of the others in the series, caused very little pushback: a set of shortcuts for <strong>argument forwarding</strong>.</p>

<h2 id="what">What</h2>

<p>Since <a href="https://rubyreferences.github.io/rubychanges/2.7.html#keyword-argument-related-changes">Ruby 2.7</a>, this is possible (please note that <code>...</code> in the code below is the exact valid syntax, not “code omitted for a blog post”):</p>

<div><div><pre><code><span>def</span> <span>foo</span><span>(</span><span>...</span><span>)</span>
  <span># bar receives all positional, named and block arguments</span>
  <span># that foo received</span>
  <span>bar</span><span>(</span><span>...</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>Since <a href="https://rubyreferences.github.io/rubychanges/3.1.html#anonymous-block-argument">Ruby 3.1</a>, an anonymous block argument can be “forwarded” separately:</p>

<div><div><pre><code><span>def</span> <span>iterate_through_data</span><span>(</span><span>&amp;</span><span>)</span>
  <span>data</span><span>.</span><span>each</span><span>(</span><span>&amp;</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>Since <a href="https://rubyreferences.github.io/rubychanges/3.2.html#anonymous-arguments-passing-improvements">Ruby 3.2</a>, one can also “forward” positional and named (keyword) arguments separately:</p>

<div><div><pre><code><span>def</span> <span>split_arguments</span><span>(</span><span>*</span><span>,</span> <span>**</span><span>)</span>
  <span>pass_positional</span><span>(</span><span>*</span><span>)</span> <span># passes all positional arguments</span>
  <span>pass_keywords</span><span>(</span><span>**</span><span>)</span> <span># passes all keyword arguments</span>
<span>end</span>

<span>split_arguments</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>a: </span><span>4</span><span>,</span> <span>b: </span><span>5</span><span>)</span>
<span># after this call, those methods would be called:</span>
<span>#   pass_positional(1, 2, 3)</span>
<span>#   pass_keywords(a: 4, b: 5)</span>
</code></pre></div></div>

<h2 id="why--how">Why &amp; How</h2>

<p>…are inseparable here!</p>

<p>The introduction of <code>...</code> was not something discussed for years (at least, I am unaware of such discussions). It was rather an impromptu invention on the wave of the Big Changes in Ruby 2.7.</p>

<p>Version 2.7 was the last preparatory version before 3.0, and it introduced some of the “big oh” changes so everybody had time to prepare. One of such changes was a <em>final separation</em> of positional and keyword arguments: making some rules of treating arguments stricter and less cumbersome than they historically were.</p>

<p>This is a complicated topic, well covered by the <a href="https://www.ruby-lang.org/en/news/2019/12/12/separation-of-positional-and-keyword-arguments-in-ruby-3-0/">official explanation</a>. In the context of the shorthand invention, we need to know that one of the side effects of the separation was that writing a method that just passes all of its arguments to another method became complicated. The pre-2.7 way of doing so was this:</p>

<div><div><pre><code><span>def</span> <span>reader</span><span>(</span><span>name</span><span>,</span> <span>mode</span><span>:)</span>
  <span># does some reading</span>
<span>end</span>

<span>def</span> <span>writer</span><span>(</span><span>name</span><span>,</span> <span>content</span><span>)</span>
  <span># does some writing</span>
<span>end</span>

<span>def</span> <span>wrap</span><span>(</span><span>method</span><span>,</span> <span>*</span><span>args</span><span>)</span>
  <span># a typical wrapper method, which might, say, log execution,</span>
  <span># catch extra errors, do a more complicated dispatching and so on.</span>
  <span>send</span><span>(</span><span>method</span><span>,</span> <span>*</span><span>args</span><span>)</span>
<span>end</span>

<span>wrap</span><span>(</span><span>:reader</span><span>,</span> <span>&#34;file.txt&#34;</span><span>,</span> <span>mode: </span><span>&#39;wb&#39;</span><span>)</span>
<span>wrap</span><span>(</span><span>:writer</span><span>,</span> <span>&#34;file.txt&#34;</span><span>,</span> <span>&#39;some content&#39;</span><span>)</span>
</code></pre></div></div>

<p><code>*args</code> in the method signature and the method call was enough to pass all positional and keyword arguments around. In Ruby 2.7, the separation would become more formal<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>, so to handle every kind of method, one needed to write:</p>

<div><div><pre><code><span>def</span> <span>wrap</span><span>(</span><span>method</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>
  <span>send</span><span>(</span><span>method</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>In a generic situation, the third type of the argument should’ve been considered: a block (Ruby’s special “tail lambda”). So for a truly universal delegator, one needed to write this:</p>

<div><div><pre><code><span>def</span> <span>wrap</span><span>(</span><span>method</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>,</span> <span>&amp;</span><span>block</span><span>)</span>
  <span>send</span><span>(</span><span>method</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>,</span> <span>&amp;</span><span>block</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>That’s a whole lot of syntax <em>and</em> naming to do a thing that is so simple by its idea!</p>

<p>So the practical solution for a shortcut “just pass whatever arguments you have” was <a href="https://bugs.ruby-lang.org/issues/16253">proposed</a> and quickly accepted in the form of <code>...</code>.</p>

<p>A few technicalities and edge cases were discussed and settled, some immediately, some in the next version. Say, <a href="https://rubyreferences.github.io/rubychanges/3.0.html#arguments-forwarding--supports-leading-arguments">support for passing a leading argument before forwarding syntax</a> was introduced in 3.0 but considered so useful it was then backported to the 2.7 branch and has been available there since around 2.7.3.</p>

<p>It was kind of a big deal because “delegate everything” is a very widespread phraseology in Ruby, used for all kinds of effects:</p>

<div><div><pre><code><span># hide the real call sequence complexity:</span>
<span>def</span> <span>log</span><span>(</span><span>text</span><span>,</span> <span>level</span><span>:,</span> <span>**</span><span>payload</span><span>)</span>
  <span>Loggers</span><span>::</span><span>Registry</span><span>.</span><span>fetch</span><span>(</span><span>:http_logger</span><span>).</span><span>log</span><span>(</span><span>text</span><span>,</span> <span>level: </span><span>level</span><span>,</span> <span>**</span><span>payload</span><span>)</span>
<span>end</span>

<span># dynamically choose an implementation</span>
<span>def</span> <span>make_event</span><span>(</span><span>type</span><span>,</span> <span>sender</span><span>,</span> <span>**</span><span>details</span><span>)</span>
  <span>EVENT_CLASSES</span><span>[</span><span>type</span><span>].</span><span>new</span><span>(</span><span>sender</span><span>,</span> <span>**</span><span>details</span><span>)</span>
<span>end</span>

<span># make a nice DSL with dynamically defined methods:</span>
<span>class</span> <span>HTML</span>
  <span>def</span> <span>method_missing</span><span>(</span><span>name</span><span>,</span> <span>content</span><span>,</span> <span>**</span><span>attributes</span><span>)</span>
    <span># construct tag string from tag name, content and attrs</span>
  <span>end</span>
<span>end</span>

<span>HTML</span><span>.</span><span>new</span><span>.</span><span>a</span><span>(</span><span>&#39;Ruby&#39;</span><span>,</span> <span>href: </span><span>&#39;https://ruby-lang.org&#39;</span><span>)</span>
<span>#=&gt; &#34;&lt;a href=&#39;https://ruby-lang.org&#39;&gt;Ruby&lt;/a&gt;&#34;</span>
</code></pre></div></div>

<p>All of those cases can be made much shorter with <code>...</code>, without losing the <em>real</em> meaning of “just pass everything”!</p>

<p>This syntax change was a rare case when many groups with frequently conflicting views directly saw an immediate gain:</p>

<ul>
  <li>those who are usually curious about syntax changes and shortcuts found it pretty;</li>
  <li>those more cautious and frequently asking “what’s the use case”, in this case, immediately knew plenty of them (especially considering that after ruby 2.7, a lot of delegating code should’ve been rewritten anyway, either to <code>...</code> or to <code>*args, **kwargs</code>, so making peace with a shortcut seemed acceptable);</li>
  <li>finally, those with an emphasis on language as a pragmatic engineering tool saw a gain of the improved performance.</li>
</ul>

<p>The latter has a simple explanation: what you don’t name, you don’t need to put in the object. E.g., this allocates an intermediate array and hash to put positional and keyword arguments into:</p>
<div><div><pre><code><span>def</span> <span>delegator</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>
  <span># `args` is Array, and `kwargs` is Hash here</span>
  <span># ...but we needed them only to immediately unpack</span>
  <span>delegatee</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>While this code doesn’t make additional local variables available, and therefore no need to allocate an array/hash:</p>
<div><div><pre><code><span>def</span> <span>delegator</span><span>(</span><span>...</span><span>)</span>
  <span># no extra local vars here</span>
  <span>delegatee</span><span>(</span><span>...</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>So, it wasn’t a surprise or a scandal when, a couple of versions later, separate shortcuts to pass only positional and only keyword args were proposed.</p>

<p>Moreover, the change was small; those signatures were already valid syntax:</p>
<div><div><pre><code><span>def</span> <span>ignore_my_args</span><span>(</span><span>*</span><span>)</span>
<span>end</span>

<span>def</span> <span>ignore_keyword_args</span><span>(</span><span>some</span><span>,</span> <span>positional</span><span>,</span> <span>**</span><span>)</span>
<span>end</span>
</code></pre></div></div>
<p>…to say, “the method accepts any numbers of positional or keyword args (maybe for compatibility with the same method in neighbor classes), but ignores them.” So the only change <a href="https://rubyreferences.github.io/rubychanges/3.2.html#anonymous-arguments-passing-improvements">in Ruby 3.2</a> was to additionally allow to say “…and passes them further”:</p>

<div><div><pre><code><span>def</span> <span>pass_my_args</span><span>(</span><span>*</span><span>)</span>
  <span>other_method</span><span>(</span><span>*</span><span>)</span>
<span>end</span>

<span>def</span> <span>pass_keyword_args</span><span>(</span><span>some</span><span>,</span> <span>positional</span><span>,</span> <span>**</span><span>)</span>
  <span>other_method</span><span>(</span><span>**</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>Considering the intuitive feeling of “no new syntax” and that <code>...</code> was already there, and with the same “no unnecessary allocations” argument, the change was quickly accepted. The fact that it was <a href="https://bugs.ruby-lang.org/issues/18351">proposed</a> (and the high-quality implementation supplied) by Jeremy Evans, author of prominent libraries like Sequel and Roda and a member of Ruby core helped, too.</p>

<p>Interestingly enough, the new syntax is acceptable not only for delegation to another method but almost everywhere where unpacking of named variables was supported:</p>

<div><div><pre><code><span>def</span> <span>with_anonymous_args</span><span>(</span><span>*</span><span>,</span> <span>**</span><span>)</span>
  <span>ary</span> <span>=</span> <span>[</span><span>*</span><span>]</span>
  <span>hash</span> <span>=</span> <span>{</span><span>**</span><span>}</span>
  <span>p</span> <span>ary</span><span>,</span> <span>hash</span>
<span>end</span>

<span>with_anonymous_args</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>a: </span><span>4</span><span>,</span> <span>b: </span><span>5</span><span>)</span>
<span># Prints:</span>
<span>#   [1, 2, 3]</span>
<span>#   {:a=&gt;4, :b=&gt;5}</span>
</code></pre></div></div>

<p>This can be considered more of a curiosity (at least the “don’t instantiate an array/hash” gain is lost here), but might be at least useful for temporary debugging statements in the pass-everything methods:</p>
<div><div><pre><code><span>def</span> <span>make_event</span><span>(</span><span>type</span><span>,</span> <span>**</span><span>)</span>
  <span>puts</span> <span>&#34;DEBUG!&#34;</span> <span>if</span> <span>{</span><span>**</span><span>}.</span><span>key?</span><span>(</span><span>:password</span><span>)</span>  <span># temp</span>
  <span>EVENT_CLASSES</span><span>[</span><span>type</span><span>].</span><span>new</span><span>(</span><span>**</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>Or, as the slightly-over-the-top example at the end of the “<a href="https://zverok.space/blog/2023-11-03-syntax-sugar2-pattern-matching-fin.html#taking-it-further">Pattern Matching / Taking it further</a>” shows, the “we don’t care about the name” can be repurposed to further pattern match the argument list as several possible signatures with different meanings (and, therefore, names) for parts of the argument list.</p>

<hr/>

<p>The story with <code>&amp;</code> for anonymous block forwarding is a bit more complicated.</p>

<p>Unlike <code>*</code> or <code>**</code>, there was no <code>&amp;</code> for “just ignore this block” because block arguments in Ruby are always optional, and there is no way neither to demonstrate in the method signature “we require it” nor that we don’t. (It is sometimes a problem when blocks are erroneously passed—and ignored—to methods that never expected them, but it is quite <a href="https://bugs.ruby-lang.org/issues/19979">hard</a> <a href="https://bugs.ruby-lang.org/issues/15554">to solve</a>.)</p>

<p>So, when the standalone forwarding with <code>&amp;</code> <a href="https://bugs.ruby-lang.org/issues/11256">was proposed</a>—long before the 2.7’s “argument forwarding” work—mainly as an optimization for block allocation, it was met with great caution. At that time, the optimization part was <a href="https://bugs.ruby-lang.org/issues/14045">implemented</a> on its own as just optimization of passing the block around even if it was named. Later, though, when the basic argument forwarding with <code>...</code> was already in the language, the six-year-long discussion about the acceptability and readability of <code>&amp;</code> was ended with its introduction in <a href="https://rubyreferences.github.io/rubychanges/3.1.html#anonymous-block-argument">Ruby 3.1</a>.</p>

<p>That’s the same effect we saw <a href="https://zverok.space/blog/2023-11-10-syntax-sugar3-hash-values-omission.html#how">while discussing</a> keyword argument omission (which became acceptable after we got used to other cases of value-less <code>key:</code> syntax). Once a “bigger” feature takes its mindshare, the smaller ones might follow more easily.</p>

<h2 id="irks-and-quirks">Irks and quirks</h2>

<p>A small irk around ellipsis-based delegation is related to parentheses. The nature of the problem is similar to what we saw in the keyword omission case:</p>

<div><div><pre><code><span>def</span> <span>my_method</span><span>(</span><span>...</span><span>)</span>
  <span>p</span> <span>...</span>
<span>end</span>
</code></pre></div></div>
<p>Is actually</p>
<div><div><pre><code><span>def</span> <span>my_meth</span><span>(</span><span>...</span><span>)</span>
  <span>(</span><span>p</span><span>()</span><span>...</span><span>)</span> <span># empty method call + a range from its result to infinity</span>
<span>end</span>
</code></pre></div></div>

<p>This affects only ellipsis (not other forms of anonymous forwarding) and is remedied, as usual, by adding parentheses:</p>

<div><div><pre><code><span>def</span> <span>my_method</span><span>(</span><span>...</span><span>)</span>
  <span>p</span><span>(</span><span>...</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>The worse problem is that anonymous forwarding is not supported in blocks/procs. This is especially confusing considering that an old syntax of “anonymous splat” <em>is</em> supported, and therefore one might potentially write code with a very confusing effect:</p>

<div><div><pre><code><span>def</span> <span>process</span><span>(</span><span>*</span><span>)</span>
  <span># ...a lot of code...</span>
  <span>[</span><span>&#39;test&#39;</span><span>,</span> <span>&#39;me&#39;</span><span>].</span><span>each</span> <span>{</span> <span>|*|</span> <span>puts</span><span>(</span><span>*</span><span>)</span> <span>}</span>
<span>end</span>

<span>process</span><span>(</span><span>&#39;input&#39;</span><span>)</span>
</code></pre></div></div>

<p>This looks as if it will print “test” and “me” (inside of proc, <code>*</code> accepts its arguments and passes them to <code>puts</code>), but <em>actually</em>, it prints:</p>


<p>What happens here is:</p>

<ul>
  <li><code>each { |*|</code> is treated in old logic “accept all arguments and discard them;”</li>
  <li><code>puts(*)</code> is treated in the new logic “see if the context has anonymous forwardable arguments”—and consider <em>the method’s arguments</em> as such.</li>
</ul>

<p>This is an <a href="https://bugs.ruby-lang.org/issues/19370">open discussion</a> on the matter, with a confusing (for me, at least) outcome: the Ruby developers’ meeting seems to be leaning toward an idea of just prohibiting the case like above (<code>*</code>-forwarding inside of a block with <code>*</code> arguments) while allowing more unambiguous cases.</p>

<h2 id="consequences">Consequences</h2>

<p>What happens on a (mindful) usage of argument forwarding shortcuts is the <strong>onset of explicitness</strong>.</p>

<p>This might sound confusing because the “explicitness” is frequently associated with adding more names to the code or more steps to construct the value. Like splitting the formula into a few named local variables or, instead of passing the result of some method to another, first attaching it to some name. (In pathological cases, it is “every non-trivial call/check/calculation should be its own method with the name explaining its usage.”)</p>

<p>But here, I am talking about <em>the explicitness of the intention</em> of some sizeable chunk of code, a “page” or a “chapter” of it. (In the same way in the intro article <a href="https://zverok.space/blog/2023-10-02-syntax-sugar.html#how-i-think-about-the-programming-language">I underlined</a> we’ll be talking about the reader’s comfort in comprehension of the narrative instead of the “readability” of a single line.)</p>

<p>Imagine a code like this:</p>

<div><div><pre><code><span>def</span> <span>event</span><span>(</span><span>type</span><span>,</span> <span>sender</span><span>:,</span> <span>content</span><span>:,</span> <span>details</span><span>:)</span>
  <span>EventBus</span><span>::</span><span>Registry</span><span>.</span><span>instance</span><span>.</span><span>push_event</span><span>(</span><span>type</span><span>,</span> <span>sender: </span><span>sender</span><span>,</span> <span>content: </span><span>content</span><span>,</span> <span>details: </span><span>details</span><span>)</span>
<span>end</span>
</code></pre></div></div>
<p>Such “intermediaries” are frequent in layered systems: the params are already checked and defaults assigned by the layer above; the handling itself would be performed by the layer below; and this current method is just a shortcut in the current module (that probably invokes it many times, so repeating the verbose call of the underlying layer is tiresome).</p>

<p>There are several ways to make this definition shorter, like using <a href="https://zverok.space/blog/2023-11-10-syntax-sugar3-hash-values-omission.html">values omission</a></p>
<div><div><pre><code><span>def</span> <span>event</span><span>(</span><span>type</span><span>,</span> <span>sender</span><span>:,</span> <span>content</span><span>:,</span> <span>details</span><span>:)</span>
  <span>EventBus</span><span>::</span><span>Registry</span><span>.</span><span>instance</span><span>.</span><span>push_event</span><span>(</span><span>type</span><span>,</span> <span>sender</span><span>:,</span> <span>content</span><span>:,</span> <span>details</span><span>:)</span>
<span>end</span>
</code></pre></div></div>
<p>…or “keyword-rest” splatting:</p>
<div><div><pre><code><span>def</span> <span>event</span><span>(</span><span>type</span><span>,</span> <span>**</span><span>event_data</span><span>)</span>
  <span>EventBus</span><span>::</span><span>Registry</span><span>.</span><span>instance</span><span>.</span><span>push_event</span><span>(</span><span>type</span><span>,</span> <span>**</span><span>event_data</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>But the real intention of this method is just to “pass everything further,” what the author thinks about its argument names is closer to “like, <em>you know,</em> everything” or “yeah, <em>whatever,</em> just pass it” (and frequently would just call the rest arguments <code>**kwrest</code>, or, <code>**options</code>—the latter is a long yet frequently misleading tradition of naming the last hash/keyword argument).</p>

<p>So, eventually, we can be just <strong>explicit</strong> in expressing these “you know” or “whatever”:</p>

<div><div><pre><code><span>def</span> <span>event</span><span>(</span><span>...</span><span>)</span>
  <span>EventBus</span><span>::</span><span>Registry</span><span>.</span><span>instance</span><span>.</span><span>push_event</span><span>(</span><span>...</span><span>)</span>
<span>end</span>
</code></pre></div></div>
<p>Or, with one-line method definitions (a topic of the next article), just</p>
<div><div><pre><code><span>def</span> <span>event</span><span>(</span><span>...</span><span>)</span> <span>=</span> <span>EventBus</span><span>::</span><span>Registry</span><span>.</span><span>instance</span><span>.</span><span>push_event</span><span>(</span><span>...</span><span>)</span>
</code></pre></div></div>

<p>Such simplifications might appear in various stages of design. Sometimes, “just pass everything through” is an early-prototype version that allows to quickly assemble the reasonable stack of layers; and later clarify on each step what are the particular responsibilities besides pass-through.</p>

<p>Other times, after a long period of design and clarification, it becomes obvious that a bit of meaningful realignment of layers with each other’s capabilities and expectations allows dripping the trivial things in favor of the literal embodiment of “you know”,  <code>...</code>. The intention to do so sometimes would uncover an unjustified signature change through the layers and, as a <em>consequence</em>, might lead to useful cleanups.</p>

<p>In any case, an ability to designate “what’s obvious/doesn’t matter here” allows the reader to focus better on the other parts: those that <em>are</em> non-trivial and important. Or: if everything is important (and underlined by language means like long explanatory names), then nothing is.</p>

<p>That’s why I am talking about explicitness: akin to the case of <a href="https://zverok.space/blog/2023-10-11-syntax-sugar1-numeric-block-args.html">numbered block parameters</a>, sometimes giving a name to a value is just <strong>pretending</strong> to explain something. In these cases, it is good to have a syntax that allows to be <strong>clear and explicit</strong> about “nothing more to explain here.”</p>

<div>
  <h3>A weekly postcard from Ukraine</h3>

  <p><em><strong>Please stop here for a moment.</strong> This is your weekly reminder that I am a living person from Ukraine, with some random fact or event from our last week.</em></p>

  <p>A few days ago, there was an “anniversary” of sorts: my home region have seen its 3000s air raid alert since the beginning of the full-scale invasion. (And it is already more than 100 days by the summary length of the alerts.)</p>

  <p><img src="https://blog.plover.com/img/2023-11-24/alerts.png" alt=""/></p>

  <p>Please proceed with the rest of the article.</p>
</div>

<h2 id="how-others-do-it">How others do it</h2>

<p>Like last time (with “value omission syntax”), I actually struggled to find the <em>exact</em> correspondence of the “pass every argument” syntax: partially, maybe because there is no other languages to arrive to <code>(*args, **kwargs, &amp;block)</code> as the shortest <em>normative</em> way to say “everything that can be passed to a function.”</p>

<p>The design space here is related to accepting to the function a variable number of arguments—the concept is frequently called “<a href="https://en.wikipedia.org/wiki/Varargs">varargs</a>” (frequently demonstrated by formatted-printing functions such as <code>printf</code>). It seems that languages that have them (some, like Rust, consciously do not; Zig had them in the early versions but then decided <a href="https://github.com/ziglang/zig/issues/208#issuecomment-393777148">against</a>), there are a few groups:</p>

<p><strong>Group 1, “The old school”:</strong> make a declaration “variable number of arguments is accepted here” in the function signature, and provide some special name (of variable/function/macro) to access them. Say, in C:</p>

<div><div><pre><code><span>int</span> <span>sum</span><span>(</span><span>int</span> <span>count</span><span>,</span> <span>...)</span> <span>{</span>
  <span>va_list</span> <span>args</span><span>;</span>
  <span>va_start</span><span>(</span><span>args</span><span>,</span> <span>count</span><span>);</span>
  <span>// handle `count` of `args`, calling `va_arg(args, int);` each time</span>
  <span>va_end</span><span>(</span><span>args</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p><strong>Group 2, “The old school, but dynamic”:</strong> in the old JS and old PHP any function, regardless of its signature, could accept<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup> any number of arguments and exposed them with <code>arguments</code> (JS) or <code>func_get_args()</code> (PHP):</p>

<div><div><pre><code><span>function</span> <span>variadic</span><span>()</span> <span>{</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>arguments</span><span>)</span> <span>}</span>

<span>variadic</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>{</span><span>foo</span><span>:</span> <span>&#39;</span><span>bar</span><span>&#39;</span><span>})</span>
<span>// Prints</span>
<span>//   Arguments(4) [1, 2, 3, {foo: &#39;bar&#39;}]</span>
</code></pre></div></div>

<p>In a radical variant of this, Perl’s <code>sub</code> doesn’t have a syntax for arguments declaration at all, and all arguments are accessible inside the subroutine in a list variable <code>@_</code>, and the way to designate their names is to assign them to local variables:</p>
<div><div><pre><code><span>sub </span><span>test</span> <span>{</span>
  <span>my</span><span>(</span><span>$x</span><span>,</span> <span>$y</span><span>)</span> <span>=</span> <span>@_</span><span>;</span>
  <span>print</span> <span>&#34;</span><span>x=</span><span>$x</span><span> y=</span><span>$y</span><span>\n</span><span>&#34;</span>
<span>}</span>

<span>test</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span>
<span># prints x=1, y=2</span>
</code></pre></div></div>

<p><strong>Group 3, “New school”:</strong> Many languages have a special syntax for a function signature to declare a named parameter that would “catch” the variable list of parameters. Like in modern JS:</p>
<div><div><pre><code><span>function</span> <span>new_variadic</span><span>(...</span><span>myargs</span><span>)</span> <span>{</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>myargs</span><span>)</span> <span>}</span>

<span>new_variadic</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>{</span><span>foo</span><span>:</span> <span>&#39;</span><span>bar</span><span>&#39;</span><span>})</span>
<span>// Prints</span>
<span>//   [1, 2, 3, {foo: &#39;bar&#39;}] -- note no special &#34;Arguments&#34; object wrapper</span>
</code></pre></div></div>

<p>The designation used is frequently <code>...</code> or <code>*</code>, though C# uses <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/method-parameters#params-modifier"><code>param</code></a> keyword for such cases, and Kotlin uses <a href="https://kotlin-quick-reference.com/130-R-vararg-parameters.html"><code>vararg</code></a>.</p>

<p>It seems to be a generally agreed-upon practice nowadays.</p>

<p>The symmetric question is also more or less agreed upon<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup>: if you have a list/array/tuple of values and want to pass them as separate arguments to some function, there is an operator for that (usually looking the same as “rest arguments” declaration, and frequently called “splat” or “spread”):</p>

<div><div><pre><code><span>function</span> <span>function_with_3_args</span><span>(</span><span>arg1</span><span>,</span> <span>arg2</span><span>,</span> <span>arg3</span><span>)</span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>({</span><span>arg1</span><span>,</span> <span>arg2</span><span>,</span> <span>arg3</span><span>})</span>
<span>}</span>
<span>args_in_array</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>
<span>function_with_3_args</span><span>(...</span><span>args_in_array</span><span>)</span>
<span>// Prints: {arg1: 1, arg2: 2, arg3: 3}</span>
</code></pre></div></div>
<p>…which provides a way to perform pass-through (accept in one function “whatever arguments passed” and pass them to another function).</p>

<p>It wasn’t a given in old times! In <code>arguments</code> days of JS, “pass all arguments further” was as cumbersome as:</p>
<div><div><pre><code><span>function</span> <span>b</span><span>(){</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>arguments</span><span>);</span> <span>//arguments[0] = 1, etc</span>
<span>}</span>
<span>function</span> <span>a</span><span>(){</span>
    <span>b</span><span>.</span><span>apply</span><span>(</span><span>null</span><span>,</span> <span>arguments</span><span>);</span> <span>// pass them through, first `null` is for `this`</span>
<span>}</span>
<span>a</span><span>(</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>);</span>
</code></pre></div></div>

<p>So today’s situation (with, usually, just one named “splat” argument to be “splat” further down the layers) is enough for most pass-through situations.</p>

<p>Though, wait!</p>

<p>The interesting thing happened to Lua (as I discovered while writing the article).</p>

<p>As of <a href="https://www.lua.org/manual/5.0/manual.html#2.5.8">version 5.0</a>, it belonged to “group 1”: <code>...</code> in signature to designate “accepts any number of arguments,” a special variable <code>arg</code> with a table of all arguments inside of a function.</p>

<div><div><pre><code><span>function</span> <span>f</span><span>(</span><span>...</span><span>)</span>
  <span>print</span><span>(</span><span>arg</span><span>)</span>
<span>end</span>

<span>f</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span>
<span>-- prints  1  2  3</span>
</code></pre></div></div>

<p>And yet, in <a href="https://www.lua.org/versions.html#5.1">Lua 5.1</a>, <code>...</code> <a href="https://www.lua.org/manual/5.1/manual.html#2.5.9">replaced</a> the <code>arg</code>, so now it looks the closest to Ruby’s shortcuts:</p>

<div><div><pre><code><span>function</span> <span>f</span><span>(</span><span>...</span><span>)</span>
  <span>print</span><span>(</span><span>...</span><span>)</span>
<span>end</span>

<span>f</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span>
<span>-- prints  1  2  3</span>

<span>-- even can be used as a simple variable:</span>
<span>function</span> <span>f</span><span>(</span><span>...</span><span>)</span>
  <span>print</span><span>(</span><span>...+</span><span>5</span><span>)</span>
<span>end</span>

<span>f</span><span>(</span><span>1</span><span>)</span> <span>-- prints 6</span>
</code></pre></div></div>

<p>The world of programming languages evolution is full of wonders!</p>

<hr/>

<p>An aside note: the temptation to use the <code>...</code> as a syntax construct along the lines of “and so on” is tempting not only for Ruby and Lua: it is present at least in Python, where bare <code>...</code> produces an object <code>Ellipsis</code>, which can be passed around as a regular value and has various uses:</p>
<div><div><pre><code><span>def</span> <span>method</span><span>():</span>
  <span>...</span> <span># do-nothing method
</span>
<span># specify type of fun as a callable with any input arguments and str result
</span><span>fun</span><span>:</span> <span>Callable</span><span>[...,</span> <span>str</span><span>]</span>

<span>matrix</span> <span>=</span> <span>np</span><span>.</span><span>matrix</span><span>([[</span><span>1</span><span>,</span> <span>2</span><span>],</span> <span>[</span><span>3</span><span>,</span> <span>4</span><span>]])</span>
<span># take all data by all dimensions, but only 0th column
</span><span>matrix</span><span>[...,</span> <span>0</span><span>]</span> <span>#=&gt; matrix([[1], [3]])
</span></code></pre></div></div>

<h2 id="taking-it-further">Taking it further</h2>

<p>There is one idea that is unlikely to be implemented yet still tempting: can we sometimes shift the place where “well, you know” can be said?</p>

<p>Imagine this code: a frequent idiom for a “callable class” (which might encapsulate a complicated multi-step algorithm that is split into multiple private methods):</p>

<div><div><pre><code><span>class</span> <span>MyOperation</span>
  <span>def</span> <span>initialize</span><span>(</span><span>some</span><span>,</span> <span>arguments</span><span>,</span> <span>of</span><span>:,</span> <span>various: </span><span>&#34;kinds&#34;</span><span>)</span>
    <span># arguments assignment</span>
  <span>end</span>

  <span>def</span> <span>call</span>
    <span># ... implementation ...</span>
  <span>end</span>

  <span># public interface:</span>
  <span>def</span> <span>self</span><span>.</span><span>call</span><span>(</span><span>...</span><span>)</span> <span>=</span> <span>new</span><span>(</span><span>...</span><span>).</span><span>call</span>
<span>end</span>
</code></pre></div></div>
<p>Its intended usage is simple:</p>
<div><div><pre><code><span>MyOperation</span><span>.</span><span>call</span><span>(</span><span>with</span><span>,</span> <span>some</span><span>,</span> <span>of: :arguments</span><span>)</span>
</code></pre></div></div>

<p>…which just creates an instance with all arguments passed and immediately invokes its <code>#call</code> (the meat of the implementation) method.</p>

<p>The problem here is that the only public method of this class doesn’t give any information in its signature: neither to render into autogenerated documentation nor to extract via introspection:</p>
<div><div><pre><code><span>m</span> <span>=</span> <span>MyOperation</span><span>.</span><span>method</span><span>(</span><span>:call</span><span>)</span>
<span>#=&gt; #&lt;Method: MyOperation.call(...)&gt; -- not informative!</span>
<span>m</span><span>.</span><span>parameters</span>
<span>#=&gt; [[:rest, :*], [:keyrest, :**], [:block, :&amp;]] -- not informative either!</span>
</code></pre></div></div>

<p>The “callable wrapper” is not the only situation demonstrating this problem: a typical HTTP client implementation might have something like this (if it is written in a modern Ruby):</p>
<div><div><pre><code><span>def</span> <span>get</span><span>(</span><span>...</span><span>)</span>
  <span>make_request</span><span>(</span><span>method: :get</span><span>,</span> <span>...</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>Here, again, “public interface” method <code>get</code> doesn’t demonstrate any information about its signature (which “private implementation” method <code>make_request</code> knows).</p>

<p>So, maybe it would be possible to still support the “pass everything” syntax in the presence of explicit arguments declaration? As a compromise between “say it the shortest way possible” and “spell everything like a beginner exercise”:</p>

<div><div><pre><code><span>def</span> <span>get</span><span>(</span><span>endpoint</span><span>,</span> <span>params: </span><span>{},</span> <span>headers: </span><span>{},</span> <span>redirect: </span><span>false</span><span>)</span> <span># spell it here</span>
  <span>make_request</span><span>(</span><span>method: :get</span><span>,</span> <span>...</span><span>)</span> <span># &#34;just pass it further&#34; here</span>
<span>end</span>
</code></pre></div></div>

<p>The ticket, describing the idea, <a href="https://bugs.ruby-lang.org/issues/16296">exists</a>, but it never received much attention.</p>

<p>BTW, there is place in Ruby where something like this works! Calling <code>super</code> (“parent class’ version of this method”) implicitly passes all arguments of the current method<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" rel="footnote">4</a></sup>, which allows for some very nice shortcuts. Say, here is everything you need to do to add some defaults to a <code>Data</code> initialization:</p>

<div><div><pre><code><span>class</span> <span>Measurement</span> <span>&lt;</span> <span>Data</span><span>.</span><span>define</span><span>(</span><span>:amount</span><span>,</span> <span>:unit</span><span>)</span>
  <span>def</span> <span>initialize</span><span>(</span><span>amount</span><span>:,</span> <span>unit: </span><span>&#39;-none-&#39;</span><span>)</span> <span>=</span> <span>super</span>
<span>end</span>

<span>Measurement</span><span>.</span><span>new</span><span>(</span><span>100</span><span>,</span> <span>&#39;m&#39;</span><span>)</span> <span>#=&gt; #&lt;data Measurement amount=100, unit=&#34;m&#34;&gt;</span>
<span>Measurement</span><span>.</span><span>new</span><span>(</span><span>100</span><span>)</span>      <span>#=&gt; #&lt;data Measurement amount=100, unit=&#34;-none-&#34;&gt;</span>
</code></pre></div></div>

<p>So, the idea of “accept params declared explicitly, then just pass everything” is not <em>unimaginable</em>, at least!</p>

<h2 id="conclusions">Conclusions</h2>

<p>So, here are some things to round up today’s entry:</p>

<ol>
  <li><strong>Not all things should be named</strong>—we already talked about this while discussing numbered block parameters.</li>
  <li><strong>Being explicit about the absence of additional meaning</strong> is a useful kind of explicitness that should be considered to underline the meaningfulness of important parts.</li>
  <li><strong>Sometimes, performance optimization and clarity optimization align like stars</strong>, producing a feature that (while <em>still</em> meeting its haters) might be explained and defended from several points of view at once!</li>
</ol>

<p>The next part will be dedicated to the <strong>one-line (endless) methods</strong>, the syntax feature that was born out of April Fools’ joke.</p>

<p>You can subscribe to my <a href="https://zverok.substack.com/">Substack</a> to not miss it, or follow me on <a href="https://twitter.com/zverok">Twitter</a>.</p>

<hr/>

<p><strong>Thank you for reading. Please support Ukraine with your donations and lobbying for military and humanitarian help. <a href="https://war.ukraine.ua/">Here</a>, you’ll find a comprehensive information source and many links to state and private funds accepting donations.</strong></p>

<p><strong>If you don’t have time to process it all, donating to <a href="https://savelife.in.ua/en/">Come Back Alive</a> foundation is always a good choice.</strong></p>

<p><strong>If you’ve found the post (or some of my previous work) useful, I have a <a href="https://www.buymeacoffee.com/zverok">Buy Me A Coffee account</a> now. Till the end of the war, 100% of payments to it (if any) would be spent on my or my brothers’ necessary equipment or sent to one of the funds above.</strong></p>





  </div></div>
  </body>
</html>
