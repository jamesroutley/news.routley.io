<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.davidv.dev/posts/pcie-driver-dma/">Original</a>
    <h1>Learning about PCI-e: Driver and DMA</h1>
    
    <div id="readability-page-1" class="page"><article id="blogpost">
                
                <section id="blogpost-content">
                    <p>In the <a href="https://elijer.github.io/learning-pcie.html">previous entry</a> we covered the implementation of a trivial PCI-e device, which allowed us to read and write to it, 32 bits at a time, 
by relying on manual peek/poke with a hardcoded address (<code>0xfe000000</code>) which came from copy-pasting the address of BAR0 from <code>lspci</code>.</p>

<p>To get this address programmatically, we need to ask the PCI subsystem for the details of the memory mapping for this device.</p>

<p>First, we need to make a <a href="https://elixir.bootlin.com/linux/v6.9/source/include/linux/pci.h#L887">struct pci_driver</a>, which only requires two fields: a table of supported devices, and a <code>probe</code> function.</p>

<p>The table of supported devices is an array of the pairs of device/vendor IDs which this driver supports:</p>

<div>
<pre><span></span><code><span>static</span><span> </span><span>struct</span><span> </span><span>pci_device_id</span><span> </span><span>gpu_id_tbl</span><span>[]</span><span> </span><span>=</span><span> </span><span>{</span>
<span>    </span><span>{</span><span> </span><span>PCI_DEVICE</span><span>(</span><span>0x1234</span><span>,</span><span> </span><span>0x1337</span><span>)</span><span> </span><span>},</span>
<span>    </span><span>{</span><span> </span><span>0</span><span>,</span><span> </span><span>},</span>
<span>};</span>
</code></pre>
</div>

<p>The <code>probe</code> function (which is only called if the device/vendor IDs match), needs to return <code>0</code> if it takes ownership of the device.</p>

<p>We need to update the driver&#39;s state to hold a reference to the device&#39;s memory region</p>

<div>
<pre><span></span><code><span> </span>typedef struct GpuState {
<span> </span>   struct pci_dev *pdev;
<span>+   u8 __iomem *hwmem;</span>
<span> </span>} GpuState;
</code></pre>
</div>

<p>Within the <code>probe</code> function, we can enable the device and store a reference to the <code>pci_dev</code>:</p>

<div>
<pre><span></span><code><span>static</span><span> </span><span>int</span><span> </span><span>gpu_probe</span><span>(</span><span>struct</span><span> </span><span>pci_dev</span><span> </span><span>*</span><span>pdev</span><span>,</span><span> </span><span>const</span><span> </span><span>struct</span><span> </span><span>pci_device_id</span><span> </span><span>*</span><span>id</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>int</span><span> </span><span>bars</span><span>;</span>
<span>    </span><span>int</span><span> </span><span>err</span><span>;</span>
<span>    </span><span>unsigned</span><span> </span><span>long</span><span> </span><span>mmio_start</span><span>,</span><span> </span><span>mmio_len</span><span>;</span>
<span>    </span><span>GpuState</span><span>*</span><span> </span><span>gpu</span><span> </span><span>=</span><span> </span><span>kmalloc</span><span>(</span><span>sizeof</span><span>(</span><span>struct</span><span> </span><span>GpuState</span><span>),</span><span> </span><span>GFP_KERNEL</span><span>);</span>
<span>    </span><span>gpu</span><span>-&gt;</span><span>pdev</span><span> </span><span>=</span><span> </span><span>pdev</span><span>;</span>
<span>    </span><span>pr_info</span><span>(</span><span>&#34;called probe&#34;</span><span>);</span>

<span>    </span><span>pci_enable_device_mem</span><span>(</span><span>pdev</span><span>);</span>

<span>    </span><span>// create a bitfield of the available BARs, eg: 0b1 for &#39;BAR #0&#39;</span>
<span>    </span><span>bars</span><span> </span><span>=</span><span> </span><span>pci_select_bars</span><span>(</span><span>pdev</span><span>,</span><span> </span><span>IORESOURCE_MEM</span><span>);</span>

<span>    </span><span>// claim ownership of the address space for each BAR in the bitfield</span>
<span>    </span><span>pci_request_region</span><span>(</span><span>pdev</span><span>,</span><span> </span><span>bars</span><span>,</span><span> </span><span>&#34;gpu-pci&#34;</span><span>);</span>

<span>    </span><span>mmio_start</span><span> </span><span>=</span><span> </span><span>pci_resource_start</span><span>(</span><span>pdev</span><span>,</span><span> </span><span>0</span><span>);</span>
<span>    </span><span>mmio_len</span><span> </span><span>=</span><span> </span><span>pci_resource_len</span><span>(</span><span>pdev</span><span>,</span><span> </span><span>0</span><span>);</span>

<span>    </span><span>// map physical address to virtual</span>
<span>    </span><span>gpu</span><span>-&gt;</span><span>hwmem</span><span> </span><span>=</span><span> </span><span>ioremap</span><span>(</span><span>mmio_start</span><span>,</span><span> </span><span>mmio_len</span><span>);</span>
<span>    </span><span>pr_info</span><span>(</span><span>&#34;mmio starts at 0x%lx; hwmem 0x%px&#34;</span><span>,</span><span> </span><span>mmio_start</span><span>,</span><span> </span><span>gpu</span><span>-&gt;</span><span>hwmem</span><span>);</span>
<span>    </span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>
</code></pre>
</div>

<p>Now, if we call <code>pci_register_driver</code> during <code>module_init</code>, we can see the card is initialized and we get back the BAR0 address:</p>

<div>
<pre><span></span><code><span>[</span><span>    </span><span>0</span>.488699<span>]</span><span> </span>called<span> </span>probe
<span>[</span><span>    </span><span>0</span>.488705<span>]</span><span> </span>mmio<span> </span>starts<span> </span>at<span> </span>0xfe000000<span>;</span><span> </span>hwmem<span> </span>0xffffbf5200600000
<span>[</span><span>    </span><span>0</span>.488817<span>]</span><span> </span>gpu_module_init<span> </span><span>done</span>
</code></pre>
</div>

<a data-header="1" href="#exposing-the-card-to-userspace"><h2 id="exposing-the-card-to-userspace">Exposing the card to userspace</h2></a>

<p>Now that we have mapped the BAR0 address space in our kernel driver, we can create a character device to allow user-space applications to interact with the PCIe device through file operations: <code>read(2)</code> and <code>write(2)</code>.</p>

<p>For this driver, we only need to implement <code>open</code>, <code>read</code> and <code>write</code>, which have these signatures:</p>

<div>
<pre><span></span><code><span>static</span><span> </span><span>int</span><span> </span><span>gpu_open</span><span>(</span><span>struct</span><span> </span><span>inode</span><span> </span><span>*</span><span>inode</span><span>,</span><span> </span><span>struct</span><span> </span><span>file</span><span> </span><span>*</span><span>file</span><span>);</span>
<span>static</span><span> </span><span>ssize_t</span><span> </span><span>gpu_read</span><span>(</span><span>struct</span><span> </span><span>file</span><span> </span><span>*</span><span>file</span><span>,</span><span> </span><span>char</span><span> </span><span>__user</span><span> </span><span>*</span><span>buf</span><span>,</span><span> </span><span>size_t</span><span> </span><span>count</span><span>,</span><span> </span><span>loff_t</span><span> </span><span>*</span><span>offset</span><span>);</span>
<span>static</span><span> </span><span>ssize_t</span><span> </span><span>gpu_write</span><span>(</span><span>struct</span><span> </span><span>file</span><span> </span><span>*</span><span>file</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>__user</span><span> </span><span>*</span><span>buf</span><span>,</span><span> </span><span>size_t</span><span> </span><span>count</span><span>,</span><span> </span><span>loff_t</span><span> </span><span>*</span><span>offset</span><span>);</span>
</code></pre>
</div>

<p>First, add a reference to the cdev in the driver&#39;s state</p>

<div>
<pre><span></span><code><span> </span>typedef struct GpuState {
<span> </span>   struct pci_dev *pdev;
<span> </span>   u8 __iomem *hwmem;
<span>+   struct cdev cdev;</span>
<span> </span>} GpuState;
</code></pre>
</div>

<p>Then we define a set of file operations and a <code>setup</code> function:</p>

<div>
<pre><span></span><code><span>static</span><span> </span><span>const</span><span> </span><span>struct</span><span> </span><span>file_operations</span><span> </span><span>fileops</span><span> </span><span>=</span><span> </span><span>{</span>
<span>    </span><span>.</span><span>owner</span><span>      </span><span>=</span><span> </span><span>THIS_MODULE</span><span>,</span>
<span>    </span><span>.</span><span>open</span><span>       </span><span>=</span><span> </span><span>NULL</span><span>,</span>
<span>    </span><span>.</span><span>read</span><span>       </span><span>=</span><span> </span><span>NULL</span><span>,</span>
<span>    </span><span>.</span><span>write</span><span>      </span><span>=</span><span> </span><span>NULL</span>
<span>};</span>

<span>int</span><span> </span><span>setup_chardev</span><span>(</span><span>GpuState</span><span>*</span><span> </span><span>gpu</span><span>,</span><span> </span><span>struct</span><span> </span><span>class</span><span>*</span><span> </span><span>class</span><span>,</span><span> </span><span>struct</span><span> </span><span>pci_dev</span><span> </span><span>*</span><span>pdev</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>dev_t</span><span> </span><span>dev_num</span><span>,</span><span> </span><span>major</span><span>;</span>
<span>    </span><span>alloc_chrdev_region</span><span>(</span><span>&amp;</span><span>dev_num</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>MAX_CHAR_DEVICES</span><span>,</span><span> </span><span>&#34;gpu-chardev&#34;</span><span>);</span>
<span>    </span><span>major</span><span> </span><span>=</span><span> </span><span>MAJOR</span><span>(</span><span>dev_num</span><span>);</span>

<span>    </span><span>cdev_init</span><span>(</span><span>&amp;</span><span>gpu</span><span>-&gt;</span><span>cdev</span><span>,</span><span> </span><span>&amp;</span><span>fileops</span><span>);</span>
<span>    </span><span>cdev_add</span><span>(</span><span>&amp;</span><span>gpu</span><span>-&gt;</span><span>cdev</span><span>,</span><span> </span><span>MKDEV</span><span>(</span><span>major</span><span>,</span><span> </span><span>0</span><span>),</span><span> </span><span>1</span><span>);</span>
<span>    </span><span>device_create</span><span>(</span><span>class</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>MKDEV</span><span>(</span><span>major</span><span>,</span><span> </span><span>0</span><span>),</span><span> </span><span>NULL</span><span>,</span><span> </span><span>&#34;gpu-io&#34;</span><span>);</span>
<span>    </span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>
</code></pre>
</div>

<p>At this point, the character device will be visible in the filesystem:</p>

<div>
<pre><span></span><code>/<span> </span><span># ls -l /dev/gpu-io </span>
crw-rw----<span>    </span><span>1</span><span> </span><span>0</span><span>        </span><span>0</span><span>         </span><span>241</span>,<span>   </span><span>0</span><span> </span>May<span> </span><span>25</span><span> </span><span>15</span>:58<span> </span>/dev/gpu-io
</code></pre>
</div>

<p>At this point, I tried to <code>write</code> and got a bit stuck, as <code>write</code> receives a <code>void* private_data</code> via the <code>struct file*</code> but it must be populated during <code>open</code>, which does <em>not</em> receive a <code>private_data</code>/<code>user_data</code> argument.</p>

<p>When reading the definition of <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h#L721">struct inode</a>, I saw a pointer back to the character device (<code>struct cdev *i_cdev</code>), which gave me an idea:</p>

<p>As <code>struct GpuState</code> <em>embeds</em> <code>struct cdev</code>, having a pointer to <code>struct cdev</code> allows us to get a reference back to <code>GpuState</code> with <code>offsetof</code>:</p>

<p><img src="https://elijer.github.io/images/pcie-device/container_of.svg"/></p>

<p>The kernel provides a <code>container_of</code> macro which is built for this specific purpose, so we can now implement open/read/write:</p>

<div>
<pre><span></span><code><span>static</span><span> </span><span>int</span><span> </span><span>gpu_open</span><span>(</span><span>struct</span><span> </span><span>inode</span><span> </span><span>*</span><span>inode</span><span>,</span><span> </span><span>struct</span><span> </span><span>file</span><span> </span><span>*</span><span>file</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>GpuState</span><span> </span><span>*</span><span>gpu</span><span> </span><span>=</span><span> </span><span>container_of</span><span>(</span><span>inode</span><span>-&gt;</span><span>i_cdev</span><span>,</span><span> </span><span>struct</span><span> </span><span>GpuState</span><span>,</span><span> </span><span>cdev</span><span>);</span>
<span>    </span><span>file</span><span>-&gt;</span><span>private_data</span><span> </span><span>=</span><span> </span><span>gpu</span><span>;</span>
<span>    </span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>
</code></pre>
</div>

<p>and read/write are simple &#34;one <span data-tooltip="32 bits">DWORD</span> at a time&#34; implementations:</p>

<div>
<pre><span></span><code><span>static</span><span> </span><span>ssize_t</span><span> </span><span>gpu_read</span><span>(</span><span>struct</span><span> </span><span>file</span><span> </span><span>*</span><span>file</span><span>,</span><span> </span><span>char</span><span> </span><span>__user</span><span> </span><span>*</span><span>buf</span><span>,</span><span> </span><span>size_t</span><span> </span><span>count</span><span>,</span><span> </span><span>loff_t</span><span> </span><span>*</span><span>offset</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>GpuState</span><span> </span><span>*</span><span>gpu</span><span> </span><span>=</span><span> </span><span>(</span><span>GpuState</span><span>*</span><span>)</span><span> </span><span>file</span><span>-&gt;</span><span>private_data</span><span>;</span>
<span>    </span><span>uint32_t</span><span> </span><span>read_val</span><span> </span><span>=</span><span> </span><span>ioread32</span><span>(</span><span>gpu</span><span>-&gt;</span><span>hwmem</span><span> </span><span>+</span><span> </span><span>*</span><span>offset</span><span>);</span>
<span>    </span><span>copy_to_user</span><span>(</span><span>buf</span><span>,</span><span> </span><span>&amp;</span><span>read_val</span><span>,</span><span> </span><span>4</span><span>);</span>
<span>    </span><span>*</span><span>offset</span><span> </span><span>+=</span><span> </span><span>4</span><span>;</span>
<span>    </span><span>return</span><span> </span><span>4</span><span>;</span>
<span>}</span>
<span>static</span><span> </span><span>ssize_t</span><span> </span><span>gpu_write</span><span>(</span><span>struct</span><span> </span><span>file</span><span> </span><span>*</span><span>file</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>__user</span><span> </span><span>*</span><span>buf</span><span>,</span><span> </span><span>size_t</span><span> </span><span>count</span><span>,</span><span> </span><span>loff_t</span><span> </span><span>*</span><span>offset</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>GpuState</span><span> </span><span>*</span><span>gpu</span><span> </span><span>=</span><span> </span><span>(</span><span>GpuState</span><span>*</span><span>)</span><span> </span><span>file</span><span>-&gt;</span><span>private_data</span><span>;</span>
<span>    </span><span>u32</span><span> </span><span>n</span><span>;</span>
<span>    </span><span>copy_from_user</span><span>(</span><span>&amp;</span><span>n</span><span>,</span><span> </span><span>buf</span><span> </span><span>+</span><span> </span><span>*</span><span>offset</span><span> </span><span>+</span><span> </span><span>written</span><span>,</span><span> </span><span>4</span><span>);</span>
<span>    </span><span>*</span><span>offset</span><span> </span><span>+=</span><span> </span><span>4</span><span>;</span>
<span>    </span><span>return</span><span> </span><span>4</span><span>;</span>
<span>}</span>
</code></pre>
</div>

<p>This method works well for small data transfers, but it&#39;s not practical for larger ones. Sending 1 packet a time keeps the CPU busy and is quite slow; for example, transferring 1.2MiB (640x480 at 32bpp) took ~800ms!</p>

<a data-header="1" href="#letting-the-&#34;hardware&#34;-do-the-hard-work"><h2 id="letting-the-&#34;hardware&#34;-do-the-hard-work">Letting the &#34;hardware&#34; do the hard work</h2></a>

<p>Instead of having the CPU copy one <span data-tooltip="32 bits">DWORD</span> worth of data at a time, we can ask the card to take care of copying the data itself, by using <span data-tooltip="Direct Memory Access">DMA</span>.</p>

<p>To send work requests to the card, we can use <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O_and_port-mapped_I/O">memory-mapped IO</a>: we treat certain memory addresses as registers, which will be the &#39;parameters&#39; to our &#39;function call&#39;, and we treat other memory addresses as the execution of a &#39;function call&#39;.</p>

<p>When defining the interface for this DMA &#34;function call&#34;:</p>

<ol>
<li>The CPU has to tell the card:
<ul>
<li>What data to copy (source address, length)</li>
<li>The destination address</li>
<li>Whether the data flows <em>towards</em> main memory or <em>from</em> main memory (read or write)</li>
</ul></li>
<li>The CPU has to tell the card when it is ready for the copy to start</li>
<li>The card has to tell the CPU when it has finished the transfer</li>
</ol>

<p>As an example, we can map these addresses as registers:</p>

<div>
<pre><span></span><code><span>#define REG_DMA_DIR         0</span>
<span>#define REG_DMA_ADDR_SRC    1</span>
<span>#define REG_DMA_ADDR_DST    2</span>
<span>#define REG_DMA_LEN         3</span>
</code></pre>
</div>

<p>and we can define a set of &#34;commands&#34; to imply a call, as being different from just filling in some registers</p>

<div>
<pre><span></span><code><span>#define CMD_ADDR_BASE       0xf00</span>
<span>#define CMD_DMA_START       (CMD_ADDR_BASE + 0)</span>
</code></pre>
</div>

<p>and implement a function to execute DMA:</p>

<div>
<pre><span></span><code><span>static</span><span> </span><span>void</span><span> </span><span>write_reg</span><span>(</span><span>GpuState</span><span>*</span><span> </span><span>gpu</span><span>,</span><span> </span><span>u32</span><span> </span><span>val</span><span>,</span><span> </span><span>u32</span><span> </span><span>reg</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>iowrite32</span><span>(</span><span>val</span><span>,</span><span>  </span><span>gpu</span><span>-&gt;</span><span>hwmem</span><span> </span><span>+</span><span> </span><span>(</span><span>reg</span><span> </span><span>*</span><span> </span><span>sizeof</span><span>(</span><span>u32</span><span>)));</span>
<span>}</span>
<span>void</span><span> </span><span>execute_dma</span><span>(</span><span>GpuState</span><span>*</span><span> </span><span>gpu</span><span>,</span><span> </span><span>u8</span><span> </span><span>dir</span><span>,</span><span> </span><span>u32</span><span> </span><span>src</span><span>,</span><span> </span><span>u32</span><span> </span><span>dst</span><span>,</span><span> </span><span>u32</span><span> </span><span>len</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>write_reg</span><span>(</span><span>gpu</span><span>,</span><span> </span><span>dir</span><span>,</span><span> </span><span>REG_DMA_DIR</span><span>);</span>
<span>    </span><span>write_reg</span><span>(</span><span>gpu</span><span>,</span><span> </span><span>src</span><span>,</span><span> </span><span>REG_DMA_ADDR_SRC</span><span>);</span>
<span>    </span><span>write_reg</span><span>(</span><span>gpu</span><span>,</span><span> </span><span>dst</span><span>,</span><span> </span><span>REG_DMA_ADDR_DST</span><span>);</span>
<span>    </span><span>write_reg</span><span>(</span><span>gpu</span><span>,</span><span> </span><span>len</span><span>,</span><span> </span><span>REG_DMA_LEN</span><span>);</span>
<span>    </span><span>write_reg</span><span>(</span><span>gpu</span><span>,</span><span> </span><span>1</span><span>,</span><span>   </span><span>CMD_DMA_START</span><span>);</span>
<span>}</span>
</code></pre>
</div>

<p>We also need to implement the MMIO side in the adapter, by replacing the previous <code>gpu_write</code> function:</p>

<div>
<pre><span></span><code><span>static</span><span> </span><span>void</span><span> </span><span>gpu_write</span><span>(</span><span>void</span><span> </span><span>*</span><span>opaque</span><span>,</span><span> </span><span>hwaddr</span><span> </span><span>addr</span><span>,</span><span> </span><span>uint64_t</span><span> </span><span>val</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>size</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>GpuState</span><span> </span><span>*</span><span>gpu</span><span> </span><span>=</span><span> </span><span>opaque</span><span>;</span>
<span>    </span><span>val</span><span> </span><span>=</span><span> </span><span>lower_n_bytes</span><span>(</span><span>val</span><span>,</span><span> </span><span>size</span><span>);</span>
<span>    </span><span>uint32_t</span><span> </span><span>reg</span><span> </span><span>=</span><span> </span><span>addr</span><span> </span><span>/</span><span> </span><span>4</span><span>;</span>
<span>    </span><span>if</span><span> </span><span>(</span><span>reg</span><span> </span><span>&lt;</span><span> </span><span>CMD_ADDR_BASE</span><span>)</span><span> </span><span>{</span><span> </span><span>// register</span>
<span>        </span><span>gpu</span><span>-&gt;</span><span>registers</span><span>[</span><span>reg</span><span>]</span><span> </span><span>=</span><span> </span><span>(</span><span>uint32_t</span><span>)</span><span>val</span><span>;</span>
<span>        </span><span>return</span><span>;</span>
<span>    </span><span>}</span>
<span>    </span><span>switch</span><span> </span><span>(</span><span>reg</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>case</span><span> </span><span>REG_DMA_START</span><span>:</span>
<span>            </span><span>if</span><span> </span><span>(</span><span>gpu</span><span>-&gt;</span><span>registers</span><span>[</span><span>REG_DMA_DIR</span><span>]</span><span> </span><span>==</span><span> </span><span>DIR_HOST_TO_GPU</span><span>)</span><span> </span><span>{</span>
<span>                </span><span>pci_dma_read</span><span>(</span><span>&amp;</span><span>gpu</span><span>-&gt;</span><span>pdev</span><span>,</span>
<span>                             </span><span>gpu</span><span>-&gt;</span><span>registers</span><span>[</span><span>REG_DMA_ADDR_SRC</span><span>],</span><span> </span><span>// host addr</span>
<span>                             </span><span>(</span><span>gpu</span><span>-&gt;</span><span>framebuffer</span><span> </span><span>+</span><span> </span><span>gpu</span><span>-&gt;</span><span>registers</span><span>[</span><span>REG_DMA_ADDR_DST</span><span>]),</span><span> </span><span>// dev addr</span>
<span>                             </span><span>gpu</span><span>-&gt;</span><span>registers</span><span>[</span><span>REG_DMA_LEN</span><span>]);</span>
<span>            </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>                </span><span>printf</span><span>(</span><span>&#34;Unimplemented DMA direction</span><span>\n</span><span>&#34;</span><span>);</span>
<span>            </span><span>}</span>
<span>            </span><span>break</span><span>;</span>
<span>    </span><span>}</span>
<span>}</span>
</code></pre>
</div>

<p>in which we only store the &#39;arguments&#39; to the DMA &#39;function call&#39;, and execute it when a token value is written.</p>

<p>Then, we can go back to the kernel driver and implement <code>write</code>:</p>

<div>
<pre><span></span><code><span>static</span><span> </span><span>ssize_t</span><span> </span><span>gpu_fb_write</span><span>(</span><span>struct</span><span> </span><span>file</span><span> </span><span>*</span><span>file</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span> </span><span>__user</span><span> </span><span>*</span><span>buf</span><span>,</span><span> </span><span>size_t</span><span> </span><span>count</span><span>,</span><span> </span><span>loff_t</span><span> </span><span>*</span><span>offset</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>GpuState</span><span> </span><span>*</span><span>gpu</span><span> </span><span>=</span><span> </span><span>(</span><span>GpuState</span><span>*</span><span>)</span><span> </span><span>file</span><span>-&gt;</span><span>private_data</span><span>;</span>
<span>    </span><span>dma_addr_t</span><span> </span><span>dma_addr</span><span>;</span>
<span>    </span><span>u8</span><span>*</span><span> </span><span>kbuf</span><span> </span><span>=</span><span> </span><span>kmalloc</span><span>(</span><span>count</span><span>,</span><span> </span><span>GFP_KERNEL</span><span>);</span>
<span>    </span><span>copy_from_user</span><span>(</span><span>kbuf</span><span>,</span><span> </span><span>buf</span><span>,</span><span> </span><span>count</span><span>);</span>

<span>    </span><span>dma_addr</span><span> </span><span>=</span><span> </span><span>dma_map_single</span><span>(</span><span>&amp;</span><span>gpu</span><span>-&gt;</span><span>pdev</span><span>-&gt;</span><span>dev</span><span>,</span><span> </span><span>kbuf</span><span>,</span><span> </span><span>count</span><span>,</span><span> </span><span>DMA_TO_DEVICE</span><span>);</span>
<span>    </span><span>execute_dma</span><span>(</span><span>gpu</span><span>,</span><span> </span><span>DIR_HOST_TO_GPU</span><span>,</span><span> </span><span>dma_addr</span><span>,</span><span> </span><span>*</span><span>offset</span><span>,</span><span> </span><span>count</span><span>);</span>
<span>    </span><span>kfree</span><span>(</span><span>kbuf</span><span>);</span>
<span>    </span><span>return</span><span> </span><span>count</span><span>;</span>
<span>}</span>
</code></pre>
</div>

<p>Which now is fast enough to report as ~300us on my system.</p>

<a data-header="1" href="#blocking-writes"><h2 id="blocking-writes">Blocking writes</h2></a>

<p>There&#39;s a problem though; the DMA execution is asynchronous, and it would be a lot nicer if <code>write</code> would block until the write has finished.</p>

<p><em>Conveniently</em>, PCI-e cards can arbitrarily send signals to the CPU as <span data-tooltip="MSI">Message Signalled Interrupts</span> -- we can send an MSI to notify the CPU that the DMA transfer has completed.</p>

<p>We are only focusing on MSIs here which, as the name implies, they communicate the interrupt by sending a normal message (packet) on the bus, this is in contrast with classic interrupts which had a dedicated electrical connection to send out-of-band signals.</p>

<p>To configure MSI-X, we need to set aside some space to store some configuration for each interrupt (the MSI-X table) and some extra space for a bitmap of pending interrupts (the <span data-tooltip="Pending Bit Array">PBA</span>, but we won&#39;t use it).</p>

<p>First, we define some shared constants:</p>

<div>
<pre><span></span><code><span>#define IRQ_COUNT           1</span>
<span>#define IRQ_DMA_DONE_NR     0</span>
<span>#define MSIX_ADDR_BASE      0x1000</span>
<span>#define PBA_ADDR_BASE       0x3000</span>
</code></pre>
</div>

<p>In QEMU, in <code>pci_gpu_realize</code> we need to add</p>

<div>
<pre><span></span><code><span>msix_init</span><span>(</span><span>pdev</span><span>,</span><span> </span><span>IRQ_COUNT</span><span>,</span>
<span>          </span><span>&amp;</span><span>gpu</span><span>-&gt;</span><span>mem</span><span>,</span><span> </span><span>0</span><span> </span><span>/* table_bar_nr = bar id */</span><span>,</span><span> </span><span>MSIX_ADDR_BASE</span><span>,</span>
<span>          </span><span>&amp;</span><span>gpu</span><span>-&gt;</span><span>mem</span><span>,</span><span> </span><span>0</span><span> </span><span>/* pba_bar_nr = bar id */</span><span>,</span><span> </span><span>PBA_ADDR_BASE</span><span>,</span>
<span>          </span><span>0x0</span><span> </span><span>/* capabilities */</span><span>,</span><span> </span><span>errp</span><span>);</span>
<span>for</span><span>(</span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>IRQ_COUNT</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span>
<span>    </span><span>msix_vector_use</span><span>(</span><span>pdev</span><span>,</span><span> </span><span>i</span><span>);</span>
</code></pre>
</div>

<p>which will reserve an 8KiB space for MSIs (at the 4K offset) and another 8KiB space for PBAs at the 12KiB offset, or, in stack form:</p>

<p><img src="https://elijer.github.io/images/pcie-device/ioregion.svg"/></p>

<p>At this point, we can see that MSI-X are enabled, and the offsets of the vector table &amp; PBA:</p>

<div>
<pre><span></span><code>/<span> </span><span># lspci -vv</span>
...
Region<span> </span><span>0</span>:<span> </span>Memory<span> </span>at<span> </span>fc000000<span> </span><span>(</span><span>32</span>-bit,<span> </span>non-prefetchable<span>)</span><span> </span><span>[</span><span>size</span><span>=</span>16M<span>]</span>
Capabilities:<span> </span><span>[</span><span>40</span><span>]</span><span> </span>MSI-X:<span> </span>Enable-<span> </span><span>Count</span><span>=</span><span>1</span><span> </span>Masked-
<span>        </span>Vector<span> </span>table:<span> </span><span>BAR</span><span>=</span><span>0</span><span> </span><span>offset</span><span>=</span><span>00001000</span>
<span>        </span>PBA:<span> </span><span>BAR</span><span>=</span><span>0</span><span> </span><span>offset</span><span>=</span><span>00003000</span>
</code></pre>
</div>

<p>Then to send an interrupt when <code>pci_dma_read</code> finishes, we can call</p>

<div>
<pre><span></span><code><span>msix_notify</span><span>(</span><span>&amp;</span><span>gpu</span><span>-&gt;</span><span>pdev</span><span>,</span><span> </span><span>IRQ_DMA_DONE_NR</span><span>);</span>
</code></pre>
</div>

<p>The kernel needs to hook a handler for the interrupt, which can be done with</p>

<div>
<pre><span></span><code><span>static</span><span> </span><span>irqreturn_t</span><span> </span><span>irq_handler</span><span>(</span><span>int</span><span> </span><span>irq</span><span>,</span><span> </span><span>void</span><span> </span><span>*</span><span>data</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>pr_info</span><span>(</span><span>&#34;IRQ %d received</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>irq</span><span>);</span>
<span>    </span><span>return</span><span> </span><span>IRQ_HANDLED</span><span>;</span>
<span>}</span>
<span>static</span><span> </span><span>int</span><span> </span><span>setup_msi</span><span>(</span><span>GpuState</span><span>*</span><span> </span><span>gpu</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>int</span><span> </span><span>msi_vecs</span><span>;</span>
<span>    </span><span>int</span><span> </span><span>irq_num</span><span>;</span>

<span>    </span><span>msi_vecs</span><span> </span><span>=</span><span> </span><span>pci_alloc_irq_vectors</span><span>(</span><span>gpu</span><span>-&gt;</span><span>pdev</span><span>,</span><span> </span><span>IRQ_COUNT</span><span>,</span><span> </span><span>IRQ_COUNT</span><span>,</span><span> </span><span>PCI_IRQ_MSIX</span><span> </span><span>|</span><span> </span><span>PCI_IRQ_MSI</span><span>);</span>
<span>    </span><span>irq_num</span><span> </span><span>=</span><span> </span><span>pci_irq_vector</span><span>(</span><span>gpu</span><span>-&gt;</span><span>pdev</span><span>,</span><span> </span><span>IRQ_DMA_DONE_NR</span><span>);</span>
<span>    </span><span>pr_info</span><span>(</span><span>&#34;Got MSI vec %d, IRQ num %d&#34;</span><span>,</span><span> </span><span>msi_vecs</span><span>,</span><span> </span><span>irq_num</span><span>);</span>
<span>    </span><span>request_threaded_irq</span><span>(</span><span>irq_num</span><span>,</span><span> </span><span>irq_handler</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>&#34;GPU-Dma0&#34;</span><span>,</span><span> </span><span>gpu</span><span>);</span>
<span>    </span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>
</code></pre>
</div>

<p>and we can call <code>setup_msi</code> in the <code>gpu_probe</code> (PCI probe) function.</p>

<p>On boot, we can see that the kernel assigned an IRQ number for us:</p>

<div>
<pre><span></span><code>/<span> </span><span># grep Dma /proc/interrupts </span>
<span>             </span>CPU<span> </span><span>0</span>
<span>  </span><span>24</span>:<span>          </span><span>0</span><span>          </span>PCI-MSIX-0000:00:02.0<span>   </span><span>0</span>-edge<span>      </span>GPU-Dma0
</code></pre>
</div>

<p>However, this does not work, because the card does not yet have permissions to independently send messages to the CPU. To be able to do this, the card has to be granted the &#39;bus master&#39; capability.</p>

<p>Bus mastering is a feature which allows devices to directly manipulate system memory without involving the CPU.</p>

<p>We can grant the card bus master capabilities by calling <code>pci_set_master(pdev);</code> in the kernel&#39;s <code>gpu_probe</code> function, after which, if we call <code>write</code> twice we can see:</p>

<div>
<pre><span></span><code><span>[</span><span>    </span><span>7</span>.086591<span>]</span><span> </span>IRQ<span> </span><span>24</span><span> </span>received
<span>[</span><span>   </span><span>11</span>.540884<span>]</span><span> </span>IRQ<span> </span><span>24</span><span> </span>received
</code></pre>
</div>

<a data-header="1" href="#actually-blocking-writes"><h3 id="actually-blocking-writes">Actually blocking writes</h3></a>

<p>With the interrupt machinery in place we can use a <a href="https://stackoverflow.com/a/20065881/3530257">wait queue</a> to convert <code>write</code> to blocking.</p>

<div>
<pre><span></span><code><span>wait_queue_head_t</span><span> </span><span>wq</span><span>;</span>
<span>volatile</span><span> </span><span>int</span><span> </span><span>irq_fired</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>static</span><span> </span><span>irqreturn_t</span><span> </span><span>irq_handler</span><span>(</span><span>int</span><span> </span><span>irq</span><span>,</span><span> </span><span>void</span><span> </span><span>*</span><span>data</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>irq_fired</span><span> </span><span>=</span><span> </span><span>1</span><span>;</span>
<span>    </span><span>wake_up_interruptible</span><span>(</span><span>&amp;</span><span>wq</span><span>);</span>
<span>    </span><span>return</span><span> </span><span>IRQ_HANDLED</span><span>;</span>
<span>}</span>
</code></pre>
</div>

<p>add <code>init_waitqueue_head(&amp;wq)</code> to <code>setup_msi</code>, and add the blocking condition in <code>write</code>:</p>

<div>
<pre><span></span><code><span> </span>static ssize_t gpu_fb_write(struct file *file, const char __user *buf, size_t count, loff_t *offset) {
<span> </span>   ...
<span> </span>   execute_dma(gpu, DIR_HOST_TO_GPU, dma_addr, *offset, count);
<span>+   if (wait_event_interruptible(wq, irq_fired != 0)) {</span>
<span>+       pr_info(&#34;interrupted&#34;);</span>
<span>+       return -ERESTARTSYS;</span>
<span>+   }</span>
<span> </span>   kfree(kbuf);
<span> </span>   return count;
<span> </span>}
</code></pre>
</div>

<a data-header="1" href="#displaying-something"><h2 id="displaying-something">Displaying something</h2></a>

<p>We now have a &#39;framebuffer&#39; that can receive <code>write(2)</code> from userspace, and will forward the data as-is to a PCI-e device using DMA; we can cheat a little bit to pretend we have a working GPU, by hooking the card&#39;s buffer to QEMU&#39;s console output:</p>

<p>In QEMU&#39;s source:</p>

<div>
<pre><span></span><code><span> </span>struct GpuState {
<span> </span>   PCIDevice pdev;
<span> </span>   MemoryRegion mem;
<span>+   QemuConsole* con;</span>
<span> </span>   uint32_t registers[0x100000 / 32]; // 1 MiB = 32k, 32 bit registers
<span> </span>   uint32_t framebuffer[0x200000]; // barely enough for 1920x1080 at 32bpp
<span> </span>};
</code></pre>
</div>

<div>
<pre><span></span><code><span> </span>static void pci_gpu_realize(PCIDevice *pdev, Error **errp) {
<span> </span>   ...
<span>+    gpu-&gt;con = graphic_console_init(DEVICE(pdev), 0, &amp;ghwops, gpu);</span>
<span>+    DisplaySurface *surface = qemu_console_surface(gpu-&gt;con);</span>
<span>+   // Display a test pattern</span>
<span>+   for(int i = 0; i&lt;640*480; i++) {</span>
<span>+       ((uint32_t*)surface_data(surface))[i] = i;</span>
<span>+   }</span>
}
</code></pre>
</div>

<p>and add a &#34;passthrough&#34; implementation for the display surface</p>

<div>
<pre><span></span><code><span>static</span><span> </span><span>void</span><span> </span><span>vga_update_display</span><span>(</span><span>void</span><span> </span><span>*</span><span>opaque</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>GpuState</span><span>*</span><span> </span><span>gpu</span><span> </span><span>=</span><span> </span><span>opaque</span><span>;</span>
<span>    </span><span>DisplaySurface</span><span> </span><span>*</span><span>surface</span><span> </span><span>=</span><span> </span><span>qemu_console_surface</span><span>(</span><span>gpu</span><span>-&gt;</span><span>con</span><span>);</span>
<span>    </span><span>for</span><span>(</span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span>&lt;</span><span>640</span><span>*</span><span>480</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>((</span><span>uint32_t</span><span>*</span><span>)</span><span>surface_data</span><span>(</span><span>surface</span><span>))[</span><span>i</span><span>]</span><span> </span><span>=</span><span> </span><span>gpu</span><span>-&gt;</span><span>framebuffer</span><span>[</span><span>i</span><span> </span><span>%</span><span> </span><span>0x200000</span><span> </span><span>];</span>
<span>    </span><span>}</span>

<span>    </span><span>dpy_gfx_update</span><span>(</span><span>gpu</span><span>-&gt;</span><span>con</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>640</span><span>,</span><span> </span><span>480</span><span>);</span>
<span>}</span>
<span>static</span><span> </span><span>const</span><span> </span><span>GraphicHwOps</span><span> </span><span>ghwops</span><span> </span><span>=</span><span> </span><span>{</span>
<span>   </span><span>.</span><span>gfx_update</span><span>  </span><span>=</span><span> </span><span>vga_update_display</span><span>,</span>
<span>};</span>
</code></pre>
</div>

<p>when launching QEMU, we can now see the test pattern:</p>

<center><img alt="" src="https://elijer.github.io/images/pcie-device/qemu_test_pattern.png"/></center>

<p>And whenever writing patterns to the underlying device, we can see the display change!</p>

<center><video controls=""><source src="/videos/pcie-device/qemu_test_pattern_writes.mp4"/></video></center>

<hr/>

<p>That&#39;s it for now, next time, we <em>may</em> look at multiple DMA engines, zero-copy DMA and/or becoming a <em>real</em> GPU.</p>

<p>You can find the source <a href="https://github.com/DavidVentura/pci-device">here</a>.</p>

<a data-header="1" href="#references:"><h2 id="references:">References:</h2></a>

<ol>
<li><a href="https://www.kernel.org/doc/Documentation/PCI/pci.txt">Kernel&#39;s docs on PCI</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/PCI/MSI-HOWTO.txt">Kernel&#39;s docs on MSI</a></li>
<li><a href="https://linux-kernel-labs.github.io/refs/heads/master/labs/device_drivers.html">Linux Kernel Labs - Device Drivers</a></li>
<li><a href="https://olegkutkov.me/2021/01/07/writing-a-pci-device-driver-for-linux/">Writing a PCI device driver for Linux</a></li>
<li><a href="https://olegkutkov.me/2018/03/14/simple-linux-character-device-driver/">Simple character device driver for Linux</a></li>
<li><a href="https://github.com/luizinhosuraty/pciemu">pciemu</a></li>
<li><a href="https://www.intel.com/content/www/us/en/docs/programmable/683686/20-4/msi-x-capability-structure.html">MSI-X Capability structure</a></li>
</ol>

                </section>
            </article></div>
  </body>
</html>
