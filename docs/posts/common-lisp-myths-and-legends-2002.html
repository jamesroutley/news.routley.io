<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.lispworks.com/products/myths_and_legends.html">Original</a>
    <h1>Common Lisp – Myths and Legends (2002)</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
					<!-- #BeginEditable "content" -->
<h2><a name="top" id="top"></a>Common Lisp - Myths and Legends</h2>
<p>Lisp has been supporting the world&#39;s most complex applications 
                since 1958. And Lisp has grown a <i>lot</i> since then. So if 
                you or someone you know harbors fears or concerns about Lisp because 
                of something learned in a class or muttered by a friend 20 or 
                30 years ago, it&#39;s time to take a fresh look. In this paper we&#39;re 
                going to survey what Lisp is <i>today</i>.</p>
              <p>Partially, Lisp is the stuff of Legends. We hear again and again 
                from our users that writing their system in Lisp cut their investment 
                in developer years by a factor of five or ten. &#34;We couldn&#39;t 
                have done this in any other language,&#34; they say. Once bitten 
                by Lisp, they don&#39;t want to let go. In this paper we&#39;ll take a 
                look at some of the reasons for this enthusiasm, at why lisp is 
                <i>the</i> premier language for advanced application development.</p>
              <p>There are a lot of myths out there which need to be dispelled, 
                and we&#39;ve decided to take some of these head-on in this paper. 
                If we leave you with any questions, <i>please</i> feel welcome 
                to ask a <a href="http://www.lispworks.com"></a>LispWorks representative 
                to clarify them. We&#39;re not afraid of hard questions; confronting 
                hard questions is our speciality. And it also happens to be what 
                has kept Lisp alive and strong through four decades!</p>
              <h3>Who&#39;s Using Lisp?</h3>
              <p>You don&#39;t always see it, but Lisp is all around you.</p>
              <p>The Web is growing as fast for Lisp as for the rest of the industry. 
                <a href="http://store.yahoo.com/" target="_blank">Yahoo! Store</a> 
                includes a WYSIWYG editor for editing your online store through 
                a standard web browser. The editor is written in Common Lisp. 
                Public domain Lisp-based web servers include <a href="http://www.ai.mit.edu/projects/iiip/doc/cl-http/home-page.html" target="_blank">CL-HTTP</a>, 
                architected by <a href="mailto:jcma@ai.mit.edu">John Mallery</a> 
                at the <a href="http://www.ai.mit.edu/" target="_blank">MIT Artificial 
                Intelligence Laboratory</a>.</p>
              <p>Some companies consider Lisp technology so valuable that they 
                tend to keep their use of it under wraps; this is often a source 
                of frustration to those wanting to crow about Lisp&#39;s successes. 
                But in 1994, in an unusual move, AT&amp;T permitted <a href="http://en.wikipedia.org/wiki/Harlequin_%28software_company%29" target="_blank">Harlequin</a> 
                to confirm that they had ``been 
                supplying Lisp consulting services and products to AT&amp;T, in 
                support of AT&amp;T&#39;s development of switched virtual circuit 
                capabilities&#39;&#39;. Toward this end, Harlequin created a special 
                variant of its LispWorks<sup>®</sup> system 
                which offers the realtime response necessary to meet AT&amp;T&#39;s 
                rigorous needs, even in spite of being a garbage collected system!</p>
              <p>Do you use a credit card? It&#39;s quite possible there&#39;s Lisp technology 
                used when you present your card for authorization. Fraud detection 
                is another area where Lisp has been used with great success.</p>
              <p><a href="http://www.xanalys.com/solutions/linkexplorer.html" target="_blank"></a>Xanalys Ltd uses Common Lisp
                within application
                products. Its <a href="http://www.xanalys.com/solutions/linkexplorer.html" target="_blank">Xanalys LinkEXPLORER</a> is a LispWorks application.</p>
              <p>In addition to the above specific examples involving
                internet web services, telecommunications, document
                translation, credit-card fraud detection, and criminal
                investigation, Lisp is also used in applications
                involving financial and investment analysis and
                tracking stock market trends, airline scheduling,
                space exploration, process planning and scheduling,
                robotics, chemistry, medicine, physics.</p>
              <p>That&#39;s a broad range of uses, but it has an important commonality: 
                each of these areas confronts seriously hard problems. So from 
                this we can evolve a checklist of possible reasons for using Lisp.</p>
              <h3>Should I be using Lisp?</h3>
              <p>We won&#39;t claim that <i>everyone</i> should be using Lisp, but 
                there are some particular situations in which we think you&#39;re 
                really hurting yourself if you&#39;re not. If you answer yes to any 
                of the following questions, Lisp is <i>definitely</i> for you:</p>
              <dl>
                <dt><b>Is the problem very complex or ill-specified?</b></dt>
                <dd>Experience shows that Lisp excels at dealing with partially 
                  specified problems and problems whose essential nature is not 
                  fully known at the outset. A programmer can write an approximation 
                  to a process and then use the programming to refine his or her 
                  understanding of the process interactively.</dd>
                <dt><b>Does the problem involve multiple representations of data 
                  from varying sources?</b></dt>
                <dd>Because of Lisp&#39;s flexible class system and dynamic typing, 
                  configuring robust systems is easy. If new data types are added, 
                  classes and methods already compiled usually do not have to 
                  be recompiled in order to interact properly. Lisp is ideal for 
                  large systems that evolve over time.</dd>
                <dt><b>Do the conditions of the problem change frequently, even 
                  dynamically?</b></dt>
                <dd>Lisp has become highly optimized over the years for `incremental 
                  change&#39;. For example: 
                  <ul>
                    <li>New function and class definitions can be loaded after 
                      Lisp starts, even multiple times to accommodate runtime redefinition 
                      of behavior. The default behavior of class redefinition 
                      is to update existing data to accommodate the new definition 
                      automatically in a fairly general way that usually involves 
                      no programming at all, but more refined programmer control 
                      of this process is available for cases where it is needed.</li>
                    <li>Methods on new datatypes can be added to existing generic 
                      functions <i>without access to sources for the methods on 
                      existing datatypes <u>and</u> without the need to recompile 
                      existing methods</i>!</li>
                    <li>Lisp&#39;s automatic storage mechanism, the ``garbage collector&#39;&#39;, 
                      is constantly on guard to reclaim old storage in the face 
                      of redefinition.</li>
                  </ul>
                </dd>
                <dd>These are only some of the many features Lisp has to support 
                  incrementality in ways that most other languages do not.</dd>
                <dt><b>Does the program have to be delivered quickly?</b></dt>
                <dd>Many features of Lisp support rapid prototyping and application 
                  delivery. Lisp provides a comprehensive set of pre-defined libraries. 
                  The presence of the garbage collector saves time in writing 
                  storage reclamation code, permits more flexible programming 
                  styles, and avoids wasted programmer time tracking down obscure 
                  memory leaks. Lisp makes it easy to write modular code and to 
                  test modules interactively. For more information about the features 
                  of Lisp that support rapid prototyping, see: <a href="http://www.nhplace.com/kent/PS/Hindsight.html" target="_blank">http://www.nhplace.com/kent/PS/Hindsight.html</a></dd>
                <dt><b>Will the program have to be frequently modified and updated?</b></dt>
                <dd>The last thing one wants to have to do is to constantly be 
                  recompiling every module of change. As we have discussed already, 
                  Lisp is optimized for incrementality and redefinition. Common 
                  operations like adding or deleting a method, or adding and deleting 
                  a slot don&#39;t normally require recompilation of a whole system.</dd>
                <dt><b>Will the program have to deal with faulty or erroneous 
                  data?</b></dt>
                <dd>The last thing you want is to have programs that think error 
                  handling means popping up a bomb box or dumping core. Lisp&#39;s 
                  error handling capabilities are powerful and give you a lot 
                  more options than that. It&#39;s easy to control the disposition 
                  of a specific kind of error dynamically. Also, the error system 
                  of Lisp is active, not passive, so you don&#39;t have to be constantly 
                  checking functions to see if they returned &#34;error codes&#34; 
                  rather than correct results. You can write your programs to 
                  assume a correct result will come back because you can arrange 
                  for an active transfer of control to happen in the case where 
                  an error occurs. This makes programming more modular and also 
                  avoids compounding an error by failing to test for it!</dd>
              </dl>
              <p>The problems we&#39;ve enumerated above are ones that usually cause 
                other programming languages to fall flat. But they are the very 
                things that Lisp was designed, through its long association with 
                the Artificial Intelligence community, to handle best.</p>
              <p>So what <i>doesn&#39;t</i> Lisp do? Well, we don&#39;t get a lot of call 
                for it to do business accounting systems. Bulk processing of well-understood, 
                very homogenous data is something Lisp could do but is rarely 
                called upon to do because commodity languages usually work fine. 
                But it&#39;s almost too bad Lisp hasn&#39;t been used for more business 
                systems because among Lisp&#39;s many features is a built-in understanding 
                of dates and times which is <i>not</i> susceptible to the Year 
                2000 bug. And Lisp&#39;s dynamically modifiable class and object system 
                would provide excellent support for the changing needs of growing 
                companies.</p>
              <p>Oh, and we don&#39;t tend to do terribly well on dumping out tiny 
                ``hello world&#39;&#39; executables. So if your only need is a program 
                that does very little and is correspondingly tiny, we&#39;re probably 
                not the language for you. But in our experience, one&#39;s needs tend 
                to grow with time and we find that ``hello world&#39;&#39; is not typical 
                in size or functionality to <i>real</i> commercial programs. So 
                we&#39;ve focused our energies on optimizing <i>real</i> programs.</p>
              <h3>What Does Lisp Offer Me?</h3>
              <p>In one sentence: Lisp offers you a stunning level of productivity 
                which frees you to write complex, robust, understandable and evolving 
                applications with an order-of-magnitude reduction in the associated 
                pain.</p>
              <p>Lisp systems are particularly good at supporting <a href="http://www.nhplace.com/kent/PS/Hindsight.html" target="_blank">rapid 
                prototyping</a> - you develop your application the same way as 
                you think about it: from the top down. Modules can be constructed 
                in isolation, partially written programs can be tested and debugged 
                interactively. Interpreted code under development can be freely 
                mixed with highly optimized compiled code. Lisp IDEs generally 
                come with a built-in lisp editor - the code you write becomes 
                a fully integrated part of your system as you write it, and you 
                never have to leave your lisp session to rebuild and start over. 
                Your development style ends up reflecting the dynamic powers of 
                the language itself: you can redefine your functions and classes, 
                as often as you want, both in development and in the running application. 
                You don&#39;t have to worry about implementing a whole load of primitives 
                just to get yourself going, because the language provides them 
                for you.</p>
              <p>Then when the job&#39;s done you can deliver either free-running 
                executables or relocatable libraries (DLLs on Windows). Tree-shaking 
                and pruning tools are typically provided to help you cut you application 
                down to size.</p>
              <h3><b>ANSI Common Lisp</b></h3>
              <p>Lisp is actually a whole family of languages, but in this document 
                we&#39;re mostly talking about ANSI Common Lisp, the Lisp dialect 
                of choice for industrial-strength applications development worldwide.</p>
              <p>ANSI Common Lisp offers you the following features:</p>
              <ul>
                <li><b>Compiler configurability</b> 
                  <p>Using simple constructs within Lisp itself you get to select 
                    where your code will run fast, where it will run slower but 
                    &#34;safe&#34; (automatically performing checks on the data 
                    as it runs), and where the compilation itself will be rapid. 
                    You can specify this by the system, per file, or even on a 
                    line-by-line basis when you need to. Further constructs allow 
                    you to state which functions should be compiled inline.</p>
                </li><li><b>Macros</b> 
                  <p>A powerful and elegant macro facility allows lisp code to 
                    generate more lisp code. The macros themselves are also written 
                    in lisp and can perform arbitrary operations as part of the 
                    expansion process. Calls to the macro-expander have the same 
                    syntax as function calls - there is no sense of leaving lisp 
                    or learning a second language.</p>
                </li><li><b>Common Lisp Object System</b> 
                  <p>Otherwise known as CLOS, the most advanced object system 
                    in the world. It supports:</p>
                  <ul>
                    <li>dynamic change of an object&#39;s class, 
                    </li><li>dynamic method recombination for runtime-added methods 
                      <i>without</i> access to source code or any need to &#34;rebuild&#34;, 
                    </li><li>dispatch on classes or object identity, 
                    </li><li>dispatch on multiple objects, not just one object, 
                    </li><li>user-defined forms of method combination, 
                    </li><li>an unofficial but widely accepted &#34;Meta Object Protocol&#34; 
                      which allows introspection and even dynamic redefinition 
                      of the object system itself. 
                  </li></ul>
                  <br/>
                </li><li><b>Built-in types</b> 
                  <p>Lisp provides a rich set of built-in data-types, including</p>
                  <ul>
                    <li>Symbols (symbolic identifiers) 
                    </li><li>Numerical types: 
                      <ul>
                        <li>Machine integers and arbitrary precision integers 
                        </li><li>IEEE floats (single and double) 
                        </li><li>Rational and complex numbers 
                      </li></ul>
                    </li><li>Characters 
                    </li><li>Containers: 
                      <ul>
                        <li>Arrays (simple or indirect, with varying element types) 
                        </li><li>Lists (containing mixed and arbitrary kinds of typed 
                          objects) 
                        </li><li>Strings 
                        </li><li>Various kinds of Hash Tables 
                      </li></ul>
                    </li><li>Pathnames: portable file naming which accesses the native 
                      file system while hiding system characteristics for cross-platform 
                      situations 
                    </li><li>Functions (including high-order functions) as first class 
                      objects 
                  </li></ul>
                  <br/>
                </li><li><b>Standardized library</b> 
                  <p>The runtime library for Common Lisp is part of the standard. 
                    That makes it fully platform and vendor independent. The library 
                    is large and supplies several hundred highly flexible functions. 
                    These cover sequence and string utilities, sorting, hash table 
                    creation/lookup, flexible file I/O, numerical operations (extremely 
                    efficient with declarations), and much much more.</p>
                </li><li><b>Powerful error-handling facility</b> 
                  <p>No application is perfect, and nor is the real world with 
                    which applications interact. Errors do occur, and what Common 
                    Lisp does is to provide a rich facility for surviving such 
                    &#34;conditions&#34;: signalling, handling, restarting - 
                    all under program control. As an aid to debugging that elusive 
                    error, Common Lisp allows you to trace and even to disassemble 
                    your code.</p>
              </li></ul>
              <h3>Other features</h3>
              <p>We listed above the main features of ANSI Common Lisp. Other 
                features of note, but at this time not included within the standard, 
                include:</p>
              <ul>
                <li><b>Introspection tools</b> 
                  <p>Lisp systems provide considerable assistance to writing and 
                    debugging an application. The following tools are typical, 
                    and tend to be fully integrated: state and values can be exchanged 
                    between them with a minimum of fuss.</p>
                  <ul>
                    <li>Lisp listeners allow interaction with the underlying lisp 
                      system - lisp forms (think of them as small programs) are 
                      evaluated and the results returned. 
                    </li><li>Inspectors allow introspection of Lisp objects - you can 
                      present an inspector with an arbitrary object and it will 
                      show you the values in all its slots. You don&#39;t need to 
                      tell the inspector what type the object is - Lisp can figure 
                      that out for itself. 
                    </li><li>Class tools allow you to browse the accessors associated 
                      with any object. In conjunction with inspectors they allow 
                      for extremely rapid learning about existing systems. 
                    </li><li>Debuggers give the application writer access to the stack 
                      in the event of an unhandled error. Arguments to function 
                      calls can be inspected, handed to the listener which can 
                      perform arbitrary operations on them, or even changed and 
                      the function called again with the new values. 
                  </li></ul>
                  <br/>
                </li><li><b>Common Lisp Interface Manager</b> 
                  <p>Standardized (but not within ANSI-CL), CLIM gives application 
                    users one of the most highly sought-after features around: 
                    a combination of both vendor and platform independence in 
                    their user interface. It offers:</p>
                  <ul>
                    <li>optional specification of native look-and-feel, supporting 
                      most standard GUI widgets. 
                    </li><li>a straight-forward mapping of application semantic components 
                      (actions and objects) to GUI components (commands and text/graphics) 
                    </li><li>powerful graphics facilities (shapes, fonts, colors, bitmaps) 
                    </li><li>incremental redisplay manager 
                    </li><li>table formatting, including dynamic layout based on size 
                      of cell entries, arbitrary text and/or graphics for cell 
                      entries, nesting of tables, etc 
                    </li><li>commands trivially made available as keystrokes, pull-down 
                      menu entries, command-line style (with completion), and/or 
                      associated with pointer gestures on display objects 
                    </li><li>automatic prompting for and type-checked parsing of command 
                      arguments 
                    </li><li>horizontal or vertical formatting of n-ary, cyclic graphs 
                      with text or graphics for node labels 
                    </li><li>high-level support for common pointer-based operations 
                      (like drag-and-drop) 
                  </li></ul>
                  <p>and much more.</p>
                </li><li><b>Multitasking</b> 
                  <p>Light-weight control of multiple execution strands within 
                    a single machine process. On Windows this would typically 
                    be implemented with native threads.</p>
                </li><li><b>System definition</b> 
                  <p>To keep track of build dependencies when it you&#39;re managing 
                    a large system.</p>
              </li></ul>
              <h3>Myths About Lisp</h3>
              <p>In this section, we&#39;ll look at some of the amazing myths that 
                we still hear told about Lisp, and contrast them with the actual 
                reality.</p>
              <h4>Myth #1: Lisp is slow</h4>
              <p>The reality is that when all datatypes are appropriately declared, 
                a typical commercial Lisp compiler produces native machine code 
                that is comparable in speed with other languages.</p>
              <p>However, something Lisp does which other languages don&#39;t is to 
                allow you to run code with no type declarations. In this mode, 
                types are dynamically determined and appropriate behavior occurs 
                based on runtime dispatch. This is slower than heavily declared 
                compiled code would be, but it&#39;s faster to write and therefore 
                a big boon to debugging. After all, who wants to write type declarations 
                for a bunch of tentative code they aren&#39;t sure they&#39;re even going 
                to use? It&#39;s not appropriate to compare the speed of such non-type-declared 
                code to the speed of other languages since in other languages, 
                the absence of declarations is fatal to programs in most other 
                languages.</p>
              <p>If you want to make a proper comparison, you have to either compare 
                properly declared code in Lisp to properly declared code in other 
                languages. If you do that, Lisp will compare favorably. Otherwise, 
                to be fair, you should compare the speed of undeclared code in 
                Lisp (modest) to the speed of undeclared code in other languages 
                (often zero, since such code in other languages is usually ``incomplete&#39;&#39; 
                and will not run). Once such a proper comparison is made, we again 
                see the Lisp&#39;s behavior is quite favorable.</p>
              <h4>Myth #2: Lisp is big</h4>
              <p>Big is a moving target. Sometime in the early 1980&#39;s, people 
                started complaining about the size of Lisp as an impediment. Lisp 
                <i>was</i> big at that time, compared to other applications of 
                the time because it packed a lot of useful functionality and there 
                was a limit to how small that functionality could be made. But 
                Lisp vendors became very sensitive to the size issue and Lisp 
                has been one of the few programming languages in recent years 
                that has not been allowed to grow by leaps and bounds with every 
                release.</p>
              <p>At this point, the size of a typical application in Lisp and 
                its runtime libraries are comparable in size to what a similar 
                application would be written in another language. But if the ``bloating&#39;&#39; 
                trend of other languages increases as it has been, Lisp will soon 
                be seen as the much more compact alternative!</p>
              <h4>Myth #3: Lisp has no arrays</h4>
              <p>Lisp has had an array datatype for at least 30 years, but it&#39;s 
                common for people who took a ``comparative programming languages&#39;&#39; 
                course not to know this. This is because other languages often 
                have not had Lisp&#39;s well-known <tt>LIST</tt> datatype, and so 
                Lisp is used as a showcase for dealing with linked lists and recursion. 
                Sometimes out of ignorance and sometimes just for sheer lack of 
                time, the discussion of array types in Lisp often receives no 
                attention. But that doesn&#39;t mean Lisp doesn&#39;t offer powerful support 
                for single and multi-dimensional arrays, arrays of varying element 
                type, and array access that provides transparent access to fixed 
                size arrays, arrays displaced to other arrays, and arrays whose 
                size is expected to dynamically grow and shrink.</p>
              <h4>Myth #4: Lisp has no compiler</h4>
              <p>Since its earliest days, now 40 years ago, Lisp implementations 
                have been variously interpreted or compiled, and often both. In 
                fact, much important work in the theory of program compilation 
                has been done using Lisp, and Lisp compilers have benefited enormously 
                by this. No modern commercial Lisp is without a compiler. The 
                fact that modern Lisps often come with an interpreter as well 
                is simply a convenience for some implementations to encourage 
                late-binding semantics and promote program flexibility, including 
                interactive debugging.</p>
              <p>The ANSI Common Lisp standard does not require the presence of 
                a compiler provided that an interpreter achieves the defined semantics. 
                It is intended that the marketplace will sort out this issue. 
                The ability to omit a compiler allows certain price/performance 
                points to be achieved, especially among subset and freeware implementations. 
                However, serious commercial implementations invariably offer optimizing 
                compilers as a standard part of their product. Ask to be sure, 
                but don&#39;t let <i>ever</i> anyone tell you there&#39;s no such thing!</p>
              <h4>Myth #5: Lisp is not standard</h4>
              <p>This one is simple to correct. X3.226/1994, the American National 
                Standard for Programming Language Common Lisp, not only exists 
                but in fact was the <i>first</i> ANSI standard for an object-oriented 
                programming language.</p>
              <p>A webbed adaptation of the ANSI Common Lisp standard, <a href="https://riskmusings.substack.com/documentation/common-lisp.html">The 
                Common Lisp HyperSpec<sup>TM</sup></a> (CLHS) is available from 
                <a href="http://www.lispworks.com"></a>LispWorks Ltd free of charge from 
                <a href="https://riskmusings.substack.com/downloads/index.html">our downloads page</a>. CLHS 
                contains a comprehensive glossary and myriad programming examples. 
                It is heavily cross-indexed (105K hyperlinks) and is optimized 
                to use low graphics for very fast browsing.</p>
              <p>Common Lisp is not only a standard but it places a heavy emphasis 
                on program portability. This allows you to smoothly deploy the 
                same program on quite different platforms. With additional help 
                from CLIM, the Common Lisp Interface Manager, an application can 
                be developed which uses the same code to take on a native Motif 
                look-and-feel under X Windows or a Windows look-and-feel under 
                Windows.</p>
              <p>The design of the Common Lisp language planned for a wide variety 
                of potential platform variances (character set, machine word size, 
                filename syntax, interaction style) and will serve its users well 
                into the future without the need to make costly program upgrades 
                required by other languages.</p>
              <h4>Myth #6: Lisp doesn&#39;t talk to other programs</h4>
              <p>While the ANSI standard for Common Lisp doesn&#39;t require it, a 
                serious vendor of Common Lisp such as LispWorks Ltd goes well beyond 
                what the standard requires in the way of potential connections 
                between Lisp and the rest of your computer system. And in future 
                releases, we&#39;ll be adding more because we know this is a key issue 
                in the modern, heterogeneous computing environment.</p>
              <ul>
                <p><b>Foreign Interface.</b> Data and program interfaces to C 
                  can be declared and called in a way that is transparent to Lisp 
                  programs.</p>
                <p><b>Network interfaces.</b> Lisp supports easy access to TCP 
                  so that programming TCP-based interfaces is easy. Also, third-party 
                  software such as CL-HTTP (mentioned earlier), allows Common 
                  Lisp to talk to the web. And, of course, access to other network 
                  facilities for which there is no pre-packaged access in Lisp 
                  is still readily accessible using the Foreign Interface.</p>
                <p><b>CORBA Interface.</b> A binding of CORBA to Lisp allows natural 
                  Lisp programming style to be used when interacting with CORBA 
                  interfaces.</p>
                <p><b>Database Interfaces.</b> Flexible accesses to external database 
                  through SQL and ODBC interfaces make database entities conveniently 
                  available as Lisp data.</p>
                <p><b>DDE Client.</b> A DDE client interface is available for 
                  programs requiring Inter-application communication under Windows.</p>
                <p><b>COM and Automation. </b>COM client/server and Automation 
                  modules are also available on Windows.</p>
              </ul>
              <p>The reality is far from what the myth suggests because, in fact, 
                Common Lisp from LispWorks Ltd provides a flexible and growing set of 
                interconnection options.</p>
              <h4>Myth #7: Lisp syntax is painful</h4>
              <p>If you haven&#39;t seen it before, the Lisp notation for what other 
                languages might write as ``<tt>5*a+3</tt>&#39;&#39; is ``<tt>(+ (* 5 a) 
                3)</tt>&#39;&#39;. And we&#39;ll admit this is to some degree a matter of 
                personal taste. <i>However</i>, in spite of the fact that it may 
                look initially a little funny to the unaccustomed, there are some 
                sound <i>technical</i> reasons why Lisp syntax exists and is preferred 
                by most Lisp programmers, and we&#39;ve tried to enumerate them here:</p>
              <ul>
                <p><i>It&#39;s easy to teach.</i> There are no complicated precedence 
                  rules waiting to trip you up. Grouping of operators and associativity 
                  is manifestly obvious.</p>
                <p><i>It&#39;s easy to parse.</i> A few simple rules apply throughout. 
                  If you extend the language to add a new operator, you don&#39;t 
                  have to train the Lisp parser (provided to Lisp programmers 
                  as the function called <tt>READ</tt>) to understand your new 
                  operator. You can focus immediately on the semantics, which 
                  is what&#39;s important anyway.</p>
                <p><i>It maps naturally to an underlying data structure.</i> When 
                  teaching someone about macros, it&#39;s obvious what the internal 
                  representation of a Lisp expression is because it looks just 
                  like Lisp program data. This greatly simplifies the writing 
                  of macros and ``automatic programming&#39;&#39; facilities. It means 
                  that when you extend the language, you don&#39;t have to worry about 
                  system operators looking different than the ones you define. 
                  This breaks down the system/user distinction and keeps the system 
                  operators from looking more important than the ones you write 
                  yourself.</p>
                <p><i>Text editors can provide better support.</i> A text editor, 
                  such as <a href="http://www.gnu.org/" target="_blank">GNU Emacs</a> 
                  or the built-in editor that comes with products like Common 
                  LispWorks, can automatically provide useful support for indentation 
                  based solely on parenthesis level without having to understand 
                  the specifics of your program. They can also provide commands 
                  for moving forward and backward conveniently over expressions, 
                  which in turn allows more flexible use of ``keyboard macros&#39;&#39; 
                  to perform automated program manipulation that is much harder 
                  to do in infix languages because the beginning and end of an 
                  infix expression must always be designated explicitly (usually 
                  by mouse motion to establish a ``region&#39;&#39;).</p>
              </ul>
              <h4>Myth #8: Lisp GC is slow</h4>
              <ul>
                <p><b>Generational GC.</b> First, LispWorks offers a modern ``generational&#39;&#39; 
                  garbage collector. Such collectors are based on a layering theory 
                  of data that says that when one wants to get back some storage, 
                  one should look ``nearby&#39;&#39; for recently discarded objects. If 
                  not enough are found, additional work is done to find slightly 
                  older objects. And so on. The idea is that the nearby search 
                  is quickest and if that succeeds, very little work will have 
                  been done. Objects that survive for a long time in the innermost 
                  circle are eventually ``aged&#39;&#39; and become part of a second generation. 
                  In practice, this kind of garbage collector can be highly efficient, 
                  especially in an environment in which virtual memory is used, 
                  because they generally don&#39;t have to touch all of memory in 
                  order to reclaim enough storage to succeed.</p>
                <p><b>Realtime GC.</b> Customers whose applications can&#39;t even 
                  tolerate the speed of a generational GC should talk to LispWorks Ltd 
                  about its realtime implementation of Lisp. So far, this has 
                  not been packaged as a shrink-wrapped product but we might be 
                  able to provide it to you under some sort of consulting arrangement. 
                  Even if you&#39;re not sure you want to get involved in a consulting 
                  arrangement, please do contact us about your needs so we can 
                  be aware of your interest and help you determine how best to 
                  proceed.</p>
              </ul>
              <h4>Myth #9: Lisp needs special hardware</h4>
              <p>No.</p>
              <p>Lisp&#39;s performance can certainly be optimized by special hardware. 
                It&#39;s hard to imagine a language that couldn&#39;t. Various machines 
                from Digital Equipment Corporation in the 1970&#39;s, notably the 
                PDP-10 processor, contained numerous instructions which 
                helped Lisp work efficiently. Later, in the 1980&#39;s and into the 
                very early 1990&#39;s, there were several companies that built custom 
                ``Lisp chips&#39;&#39; which ran Lisp very efficiently. But <i>any</i> 
                language can benefit from a hardware assist; that doesn&#39;t automatically 
                mean it <i>requires</i> special hardware to run that language. 
                In the 1970&#39;s, the C language grew up on the PDP11, and yet now 
                it is used widely. Lisp grew up on a wide variety of machines, 
                most of them general purpose.</p>
              <p>LispWorks Ltd Lisp products were originally developed on stock hardware. 
                They have never been ported to Lisp-only platforms. Today they 
                run on Unix workstations and on the PC under Linux, Solaris, FreeBSD and MS Windows 
                and on Apple Macintosh hardware running Mac OS X.</p>
              <h4>Myth #10: Lisp is expensive</h4>
              <p>This is wrong on several levels.</p>
              <p>First, some people believe the expense comes from the need for 
                special purpose hardware. As mentioned already, that&#39;s not necessary. 
                LispWorks will run comfortably on a low to mid-range home 
                PC - that&#39;s about as general purpose as you can get.</p>
              <p>Second, features such as dynamic redefinition, powerful debugging 
                tools and automatic memory management mean Lisp programmers are 
                highly productive.</p>
              <p>Third, Lisp is available at a variety of prices. For example, 
                a person who&#39;s just getting his or her feet wet with Lisp might 
                want to obtain the LispWorks Personal Edition, which is 
                available for free. Hopefully <i>that&#39;s</i> not too expensive! 
                Of course, it comes with some limitations that are not present 
                in the Professional Edition and Enterprise Edition. And even these 
                other editions are quite reasonably priced; see the <a href="https://riskmusings.substack.com/p/index.html">products</a> 
                or <a href="https://riskmusings.substack.com/buy/index.html">contact a LispWorks Ltd sales 
                representative</a> for details.</p>
              <p>Or, if you&#39;re not ready to actually order a copy of Lisp, feel 
                free to browse the <a href="https://riskmusings.substack.com/documentation/common-lisp.html">Common 
                Lisp HyperSpec<sup>TM</sup></a> to get a feel for the language.</p>
              <h2>Lisp tools from LispWorks Ltd</h2>
              <p><a href="https://riskmusings.substack.com/p/index.html">LispWorks Ltd brings the best of Common Lisp</a> 
                to the Windows, Macintosh, Linux and UNIX platforms. All versions 
                include optimizing native code compilers, advanced garbage collection, 
                and excellent platform integration. LispWorks implements the ANSI 
                Common Lisp Standard and adds numerous libraries for GUI creation, 
                foreign function and enterprise integration, and expert system 
                programming. The <a href="https://riskmusings.substack.com/p/ide.html">LispWorks integrated development environment</a> 
                further simplifies software development.</p>
              <p>Once your application is developed, LispWorks supports optimized application delivery. There is no charge for runtime distribution on the Windows, Macintosh, Linux, FreeBSD and x86/x64 Solaris platforms. On UNIX platforms, runtime distribution is available for a modest fee.</p>
              <h3>LispWorks IDE</h3>
              <p>The <a href="https://riskmusings.substack.com/p/ide.html">LispWorks IDE</a> provides a smooth 
                and comfortable workflow, allowing you to incrementally write, 
                test, and extend your software while it is running. Features of 
                the LispWorks IDE include:</p>
              <ul>
                <li>Interactive Lisp listener, for compiling and executing expressions, 
                </li><li>Debugger, tracer and source code stepper,
                </li><li>Object inspector, 
                </li><li>Browsers for classes, generic functions, and compilation errors, 
                </li><li>Execution time profiler, 
                </li><li>Integrated extensible editor and ability to use external editors 
                  (e.g. EMACS), 
                </li><li>Build system manager, 
                </li><li>Incremental compiler and dynamic loader, 
                </li><li>Source code location and cross-referencing tool, 
                </li><li>Complete on-line documentation in hypertext format. 
              </li></ul>
              <h3>Language Extensions</h3>
              <p>Our Common Lisp products include a number of extensions to 
                the language standard, further increasing your productivity. Additional 
                libraries and features include:</p>
              <ul>
                <li>CAPI portable GUI toolkit, supporting both Windows and OSF/Motif 
                  look and feel, 
                </li><li>CLIM 2.0, the Common Lisp Interface Manager, 
                </li><li>CORBA interface for creating distributed components, 
                </li><li>KnowledgeWorks<sup>®</sup> and Prolog for expert system 
                  programming, 
                </li><li>Integrated database access, 
                </li><li>Support for internationalization through Unicode, 
                </li><li>Symmetric Multiprocessing, 
                </li><li>Programmer-extensible I/O streams, 
                </li><li>TCP socket streams, 
                </li><li>Object finalization; weak vectors and hash tables. 
              </li></ul>
              <h3>Platforms</h3>
              <p>LispWorks Ltd provides Common Lisp implementations on a variety of 
                operating system and hardware platforms. The use of portable language 
                constructs lets you maintain your software on all of these platforms 
                simultaneously.</p>
              <p>LispWorks for Windows provides a full native implementation of Common Lisp on all modern x86/x64 Windows computers.</p>
              <p>LispWorks for Windows, LispWorks for Macintosh, LispWorks for x86/x64 Solaris, LispWorks for Linux, LispWorks for FreeBSD and LispWorks for AIX are available in several editions. All editions include an advanced Common Lisp compiler, runtime system, and Common LispWorks IDE. LispWorks Ltd does not charge runtime license fees for applications developed with the HobbyistDV, Professional and Enterprise Editions.</p>
              <p>The Personal Edition is intended for personal and educational 
                Lisp programming. As a contribution to the Common Lisp community, 
                LispWorks Ltd makes the Personal Edition of LispWorks available free 
                of charge. While the Personal Edition includes the full Common 
                Lisp compiler and development environment, it does limit program 
                size and duration and it does not support application delivery.</p>
              <p>The Professional Edition includes everything you need for commercial 
                Common Lisp software development and application delivery. CLIM 
                2.0 is included to further increase program portability.</p>
              <p>The Enterprise Edition (with a 64-bit version now available) includes all the features of the Professional 
                Edition, and provides further support for software needs of the modern enterprise, including:</p>
              <ul>
                <li>Database access through object-oriented SQL/ODBC libraries.</li>
                <li>Portable distributed computing through CORBA.</li>
                <li>Expert system programming through our KnowledgeWorks product and an embedded Prolog compiler.</li>
              </ul>
              <p>For UNIX platforms, we offers two products: LispWorks and 
                Liquid Common Lisp (formerly Lucid Common Lisp). Both include 
                the full LispWorks integrated development environment and foreign 
                function interface. Product delivery and specialized libraries 
                are available as separate add-ons. The following platforms are 
                supported:</p>
              <ul>
                <li>Compaq Tru64 Unix (OSF 1)</li>
                <li>PA-RISC / HP-UX</li>
                <li>Sun SPARC / Solaris</li>
              </ul>
              <h3>Acknowledgements</h3>
              <p>Copyright © LispWorks Ltd 2000-10. All rights reserved.</p>
              <h3>How Can I Contact LispWorks Ltd?</h3>
              <p>If you have more questions, or if you want to place an order, 
                please <a href="https://riskmusings.substack.com/buy/index.html">contact Lisp Sales</a>.</p>
            
<!-- #EndEditable --> 
				</div></div>
  </body>
</html>
