<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://caseymuratori.com/blog_0015">Original</a>
    <h1>Semantic Compression (2014)</h1>
    
    <div id="readability-page-1" class="page"><div><p>So, before I started adding lots of new buttons, I already felt like I should spend a little time working on the underlying code to make it simpler to add new things.  Why did I feel that way, and how did I know what “simpler” means in this case?
</p></div><div><p>I look at programming as having essentially two parts: figuring out what the processor actually needs to do to get something done, and then figuring out the most efficient way to express that in the language I’m using.  Increasingly, it is the latter that accounts for what programmers actually spend their time on: wrangling all those algorithms and all that math into a coherent whole that doesn’t collapse under its own weight.
</p><p>So any experienced programmer who’s any good has had to come up with some way  —  if even just by intuition  —  of thinking about what it means to program efficiently.  By “efficiently”, this doesn’t just mean that the code is optimized.  Rather, it means that the <i>development</i> of the code is optimized  —  that the code is structured in such a way so as to minimize the amount of human effort necessary to type it, get it working, modify it, and debug it enough for it to be shippable.
</p><p>I like to think of efficiency as holistically as possible.  If you look at the development process for a piece of code as a whole, you won’t overlook any hidden costs.  Given a certain level of performance and quality required by the places the code gets used, beginning at its inception and ending with the last time the code is ever used by anyone for any reason, the goal is to minimize the amount of human effort it cost.  This includes the time to type it in.  It includes the time to debug it.  It includes the time to modify it.  It includes the time to adapt it for other uses.  It includes any work done to other code to get it to work with this code that perhaps wouldn’t have been necessary if the code were written differently.  All work on the code for its entire usable lifetime is included.
</p><p>When considered in this way, my experience has led me to conclude that the most efficient way to program is to approach your code as if you were a dictionary compressor.  Like, literally, pretend you were a really great version of PKZip, running continuously on your code, looking for ways to make it (semantically) smaller.  And just to be clear, I mean semantically smaller, as in less duplicated or similar code, not physically smaller, as in less text, although the two often go hand-in-hand.
</p><p>This is a very bottom-up programming methodology, a pseudo-variant of which has recently gained the monicker “refactoring”, even though that is a ridiculous term for a number of reasons that are not worth belaboring at the moment.  I also think that the formal “refactoring” stuff missed the main point, but that’s also not worth belaboring.  Point being, they are sort-of related, and hopefully you will understand the similarities and differences more over the course of this article series.
</p><p>So what does compression-oriented programming look like, and why is it efficient?
</p><p>Like a good compressor, I don’t reuse anything until I have at least two instances of it occurring.  Many programmers don’t understand how important this is, and try to write “reusable” code right off the bat, but that is probably one of the biggest mistakes you can make.  My mantra is, “make your code usable before you try to make it reusable”.
</p><p>I always begin by just typing out exactly what I want to happen in each specific case, without any regard to “correctness” or “abstraction” or any other buzzword, and I get that working.  Then, when I find myself doing the same thing a second time somewhere else, that is when I pull out the reusable portion and share it, effectively “compressing” the code.  I like “compress” better as an analogy, because it means something useful, as opposed to the often-used “abstracting”, which doesn’t really imply anything useful.  Who cares if code is abstract?
</p><p>Waiting until there are (at least) two examples of a piece of code means I not only save time thinking about how to reuse it until I know I really need to, but it also means I always have at least two different real examples of what the code has to do before I try to make it reusable.  This is crucial for efficiency, because if you only have one example, or worse, no examples (in the case of code written preemptively), then you are very likely to make mistakes in the way you write it and end up with code that isn’t conveniently reusable.  This leads to even more wasted time once you go to use it, because either it will be cumbersome, or you will have to redo it to make it work the way you need it to.  So I try very hard to never make code “prematurely reusable”, to evoke Knuth.
</p><p>Similarly, like a magical globally optimizing compressor (which sadly PKZip isn’t), when you are presented with new places where a previously reused piece of code could be reused again, you make a decision: if the reusable code is already suitable, you just use it, but if it’s not, you decide whether or not you should modify how it works, or whether you should introduce a new layer on top of or underneath it.  Multiresolution entry points are a big part of making code resuable, but I’ll save discussion of that for a later article, since it’s a topic unto itself.
</p><p>Finally, the underlying assumption in all of this is, if you compress your code to a nice compact form, it is easy to read, because there’s a minimal amount of it, and the semantics tend to mirror the real “language” of the problem, because like a real language, those things that are expressed most often are given their own names and are used consistently.  Well-compressed code is also easy to maintain, because all the places in the code that are doing identical things all go through the same paths, but code that is unique is not needlessly complicated or separated from its use.  Finally, well-compressed code is easy to extend, because producing more code that does similar operations is simple, as all the necessary code is there in a nicely recomposable way.
</p><p>These are all things that most programming methodologies claim to do in an abstract fashion (build UML diagrams, make class hierarchies, make systems of objects, etc.), but always fail to achieve, because the hard part of code is getting the details right.  Starting from a place where the details don’t exist inevitably means you will forget or overlook something that will cause your plans to fail or lead to suboptimal results.  Starting with the details and repeatedly compressing to arrive at the eventual architecture avoids all the pitfalls of trying to conceive the architecture ahead of time.
</p><p>With all that in mind, let’s take a look at how all this can be applied to the simple Witness UI code.
</p></div><div><p>The first bit of code compression I did on the UI code happens to be one of my very favorites, since it’s trivial to do and yet is extremely satisfying.
</p><p>Basically, in C++, functions are very selfish.  They keep all their local variables to themselves, and you can’t really do anything about that (although as the cancerous C++ specification continues to metastasize, it’s starting to add more options for this, but that is a separate issue).  So when I see code like the Witness UI code that’s doing stuff like this:
</p></div></div>
  </body>
</html>
