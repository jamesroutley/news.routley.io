<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/51-Find-Minimum-in-Rotated-Sorted-Array">Original</a>
    <h1>51-Find Minimum in Rotated Sorted Array</h1>
    
    <div id="readability-page-1" class="page"><div id="quartz-body"><div><article><p>This was tricky for me. It took me about an hour and a half to really understand.</p>
<p>This is the form my understanding finally took:</p>
<p><strong>Getting over what part of this is binary search and what isn’t</strong>
The first confusing thing about this problem was that once we can identify a sorted list where <code>l</code> is less than <code>r</code>, which happens to be the familiar starting point of binary search - that’s exactly when we <em>stop</em> doing binary search.</p>
<p>In <em>this</em> problem, we are just looking for the lowest value. So under those circumstances of <code>l &lt;= r</code>, <code>l</code> is probably going to be the min value. We don’t need to binary search it.</p>
<p>So then what <em>are</em> we binary searching? We are binary searching <em>for that condition</em>. We calculating this middle value to get to a situation where <code>l &lt;= r</code> as quickly as possible.</p>
<p>And the way we are doing that is mostly from an important thing we know, which is that as long as <code>!(l &lt;= r)</code>, there are two halves of our range. On the left side of our range somewhere, we will never find the minimum value. We can only find it on the right side of that divide. So our question becomes just, is <code>mid</code> on the right side or the left side?</p>
<p>We can determine this by checking if <code>mid</code> is more than or less than <code>nums[l]</code>. If it’s more than <code>nums[l]</code>, we know mid is on the left section, and we should constrict our window to only look to the right of it. Also, by being more than another number, we’ve disqualified the possibility of <code>mid</code>’s value being the min value.</p>
<p>On the other hand, if <code>mid</code> is LESS THAN <code>nums[l]</code>, we’re on that right section! We have to consider that the <code>mid</code> could be the minimum value. So we save it as our min value and move on by cutting out the right side of our window and searching the left of it.</p>
<p>Then, moving forward, we overwrite the mid value we wrote if our new <code>l&lt;=r</code>. But that might not happen. We may have to do a few more subdivisions before our <code>mid</code> is more than our <code>left</code>. I think that at this point, it’s completely safe to say as soon as our <code>mid</code> <em>is</em> more than our left, <code>l&lt;=r</code>, since as long as we’re on the right section of the split, <code>mid</code> is less than <code>right</code>.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> findMin</span><span>(</span><span>nums</span><span>:</span><span> number</span><span>[])</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    let</span><span> l </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    let</span><span> r </span><span>=</span><span> nums.</span><span>length</span><span>-</span><span>1</span></span>
<span data-line=""><span>    let</span><span> res </span><span>=</span><span> nums[</span><span>0</span><span>]</span></span>
<span data-line=""> </span>
<span data-line=""><span>    while</span><span> (l </span><span>&lt;=</span><span> r){</span></span>
<span data-line=""><span>        if</span><span> (nums[l] </span><span>&lt;=</span><span> nums[r]){</span></span>
<span data-line=""><span>            res </span><span>=</span><span> Math.</span><span>min</span><span>(res, nums[l])</span></span>
<span data-line=""><span>            break</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""> </span>
<span data-line=""><span>        // so in every other case we don&#39;t have a sorted range - l is more than r! Because of the pivot or break point</span></span>
<span data-line=""><span>        const</span><span> mid</span><span> =</span><span> Math.</span><span>floor</span><span>((l</span><span>+</span><span>r)</span><span>/</span><span>2</span><span>)</span></span>
<span data-line=""><span>        if</span><span> (nums[mid]</span><span>&gt;=</span><span>nums[l]){ </span></span>
<span data-line=""><span>            l</span><span>=</span><span>mid</span><span>+</span><span>1</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            r</span><span>=</span><span>mid</span><span>-</span><span>1</span></span>
<span data-line=""><span>            res </span><span>=</span><span> nums[mid]</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> res</span></span>
<span data-line=""><span>};</span></span></code></pre></figure></article><hr/></div></div></div>
  </body>
</html>
