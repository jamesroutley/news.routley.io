<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/19%29-Longest-Palindromic-Substring">Original</a>
    <h1>19) Longest Palindromic Substring</h1>
    
    <div id="readability-page-1" class="page"><article><p><a href="https://leetcode.com/problems/longest-palindromic-substring/">Here is the leetcode URL for this string<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<p>Wishful programming was mentioned in <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/18)-Longest-Substring-Without-Repeating-Characters" data-slug="devnotes/LeetCode-Journal/18)-Longest-Substring-Without-Repeating-Characters">18) Longest Substring Without Repeating Characters</a>, but I didn’t really use it until this one. Here is my first attempt at wishful programming:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> longestPalindrome</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> string</span><span> {</span></span>
<span data-line=""><span>    // validPalindrome = s[0]</span></span>
<span data-line=""><span>    middleIndex </span><span>=</span><span> middle</span></span>
<span data-line=""><span>    width </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    subString </span><span>=</span><span> getIt</span><span>()</span></span>
<span data-line=""><span>    while</span><span> (middleIndex </span><span>&lt;</span><span> s.</span><span>length</span><span> -</span><span> 1</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    if</span><span> (</span><span>isPalindrome</span><span>(subString)){</span></span>
<span data-line=""><span>        // and both sides are in bounds</span></span>
<span data-line=""><span>        validPalindrome </span><span>=</span><span> Math.</span><span>max</span><span>(subString.</span><span>length</span><span>, validPalindrome.</span><span>length</span><span>)</span></span>
<span data-line=""><span>        width</span><span>++</span></span>
<span data-line=""><span>    } </span><span>else</span><span> {</span></span>
<span data-line=""><span>        width </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    if</span><span> palindrome, palindrome </span><span>=</span><span> s.</span><span>slice</span><span>(start, end)</span></span>
<span data-line=""><span>    if</span><span> NOT</span><span> a palindrome, move end farther along</span></span>
<span data-line=""> </span>
<span data-line=""><span>};</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>// </span></span></code></pre></figure>
<p>It’s sort of like half pseudo-code, reminiscent of  spanglish is half english. I like the <code>getIt()</code> function, which was code I was confident I could figure out later, so I just pretended like it did its job and moved on.</p>
<p>Jaseem and I uncovered a very powerful benefit to this - if I ended up pivoting directions, I would only lose the 1 or 2 seconds it took me to write <code>getIt()</code> versus if I had written that function out from the get go.</p>
<p>Possibly even more importantly, I wouldn’t be as <em>averse</em> to pivoting, since I haven’t invested as much time into an initial approach. This <em>shouldn’t</em> really be a factor because it falls into the sunk-costs fallacy, but emotions can be charged during an interview, which can lead to falling into traps like this.</p>
<p>Jaseem had a fancy, complicated technique he showed me in which he created a double nested array in which the first index represented the start of the window and the second index represented the end. He set every value to <code>0</code> initially to show that they hadn’t been checked, then on a diagonal set each string representing an individual letter to <code>true</code> to show it was, by nature of being a single character, palindromic.</p>
<p>There was a fancy attempt at dynamic programming here, but it was an old answer of his, and although we were impressed by it, we couldn’t really see a reason why this was necessary for this problem.</p>
<p>I’m fresh off writing <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/18)-Longest-Substring-Without-Repeating-Characters" data-slug="devnotes/LeetCode-Journal/18)-Longest-Substring-Without-Repeating-Characters">18) Longest Substring Without Repeating Characters</a> though, so I’m actually going to try to just apply that sliding window technique directly to this as well since it seems so similar.</p>
<p>Here is a sort of goofily similar approach:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> longestPalindrome</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> string</span><span> {</span></span>
<span data-line=""><span>    // babad</span></span>
<span data-line=""><span>    // return longe=est valid palindrome</span></span>
<span data-line=""><span>    // .slice is inclusive/exclusive</span></span>
<span data-line=""><span>    // OR just 0/exclusive if only one char passed</span></span>
<span data-line=""><span>    if</span><span> (s.</span><span>length</span><span> &lt;</span><span> 1</span><span>) </span><span>return</span><span> &#39;&#39;</span></span>
<span data-line=""><span>    if</span><span> (s.</span><span>length</span><span> ===</span><span> 1</span><span>) </span><span>return</span><span> s[</span><span>0</span><span>]</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> start </span><span>=</span><span> 0</span><span>, end </span><span>=</span><span> 1</span><span>, longestPal </span><span>=</span><span> &#39;&#39;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> isPalindrome</span><span> =</span><span> (</span><span>inputString</span><span>:</span><span> string</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>        console.</span><span>log</span><span>(inputString)</span></span>
<span data-line=""><span>        if</span><span> (inputString.</span><span>length</span><span> %</span><span> 2</span><span> ===</span><span> 0</span><span>){</span></span>
<span data-line=""><span>            let</span><span> middleRight </span><span>=</span><span> inputString.</span><span>length</span><span> /</span><span> 2</span></span>
<span data-line=""><span>            return</span><span> inputString.</span><span>slice</span><span>(middleRight) </span><span>===</span><span> inputString.</span><span>slice</span><span>(middleRight, inputString.</span><span>length</span><span>)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            let</span><span> middle </span><span>=</span><span> Math.</span><span>floor</span><span>(inputString.</span><span>length</span><span> /</span><span> 2</span><span>)</span></span>
<span data-line=""><span>            return</span><span> inputString.</span><span>slice</span><span>(middle) </span><span>===</span><span> inputString.</span><span>slice</span><span>(middle</span><span>+</span><span>1</span><span>, inputString.</span><span>length</span><span>)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> longestString</span><span> =</span><span> (</span><span>stringOne</span><span>:</span><span> string</span><span>, </span><span>stringTwo</span><span>:</span><span> string</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>        if</span><span> (stringOne.</span><span>length</span><span> &gt;=</span><span> stringTwo.</span><span>length</span><span>) </span><span>return</span><span> stringOne</span></span>
<span data-line=""><span>        return</span><span> stringTwo</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    while</span><span> (end </span><span>&lt;</span><span> s.</span><span>length</span><span>){</span></span>
<span data-line=""><span>        let</span><span> window </span><span>=</span><span> s.</span><span>slice</span><span>(start, end)</span></span>
<span data-line=""><span>        if</span><span> (</span><span>isPalindrome</span><span>(window)){</span></span>
<span data-line=""><span>            longestPal </span><span>=</span><span> longestString</span><span>(longestPal, s.</span><span>slice</span><span>(start, end</span><span>++</span><span>))</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            start</span><span>++</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> longestPal</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>But that’s silly. We gotta use width, not a true <code>start/end</code> window.</p>
<p>HA. That last sample was with 3 minutes to go. I changed it to this before I hit the 20m mark:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> longestPalindrome</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> string</span><span> {</span></span>
<span data-line=""><span>    // babad</span></span>
<span data-line=""><span>    // return longe=est valid palindrome</span></span>
<span data-line=""><span>    // .slice is inclusive/exclusive</span></span>
<span data-line=""><span>    // OR just 0/exclusive if only one char passed</span></span>
<span data-line=""><span>    if</span><span> (s.</span><span>length</span><span> &lt;</span><span> 1</span><span>) </span><span>return</span><span> &#39;&#39;</span></span>
<span data-line=""><span>    if</span><span> (s.</span><span>length</span><span> ===</span><span> 1</span><span>) </span><span>return</span><span> s[</span><span>0</span><span>]</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> middle </span><span>=</span><span> 0</span><span>, radius </span><span>=</span><span> 0</span><span>, longestPal </span><span>=</span><span> &#39;&#39;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> isPalindrome</span><span> =</span><span> (</span><span>inputString</span><span>:</span><span> string</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>        console.</span><span>log</span><span>(inputString)</span></span>
<span data-line=""><span>        if</span><span> (inputString.</span><span>length</span><span> %</span><span> 2</span><span> ===</span><span> 0</span><span>){</span></span>
<span data-line=""><span>            let</span><span> middleRight </span><span>=</span><span> inputString.</span><span>length</span><span> /</span><span> 2</span></span>
<span data-line=""><span>            return</span><span> inputString.</span><span>slice</span><span>(middleRight) </span><span>===</span><span> inputString.</span><span>slice</span><span>(middleRight, inputString.</span><span>length</span><span>)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            let</span><span> middle </span><span>=</span><span> Math.</span><span>floor</span><span>(inputString.</span><span>length</span><span> /</span><span> 2</span><span>)</span></span>
<span data-line=""><span>            return</span><span> inputString.</span><span>slice</span><span>(middle) </span><span>===</span><span> inputString.</span><span>slice</span><span>(middle</span><span>+</span><span>1</span><span>, inputString.</span><span>length</span><span>)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> longestString</span><span> =</span><span> (</span><span>stringOne</span><span>:</span><span> string</span><span>, </span><span>stringTwo</span><span>:</span><span> string</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>        if</span><span> (stringOne.</span><span>length</span><span> &gt;=</span><span> stringTwo.</span><span>length</span><span>) </span><span>return</span><span> stringOne</span></span>
<span data-line=""><span>        return</span><span> stringTwo</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    while</span><span> (middle </span><span>+</span><span> radius </span><span>&lt;</span><span> s.</span><span>length</span><span>){</span></span>
<span data-line=""><span>        if</span><span> (middle </span><span>-</span><span> radius </span><span>&lt;</span><span> 0</span><span>) </span><span>continue</span></span>
<span data-line=""><span>        let</span><span> window </span><span>=</span><span> s.</span><span>slice</span><span>(middle </span><span>-</span><span> radius, middle </span><span>+</span><span> radius </span><span>+</span><span> 1</span><span>)</span></span>
<span data-line=""><span>        longestPal </span><span>=</span><span> longestString</span><span>(longestPal, window)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> longestPal</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>But of course this timed out, it’s not done - the while loop goes on forever. Actually took 6 minutes of changes to really get this idea ironed out:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""> </span>
<span data-line=""><span>function</span><span> longestPalindrome</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> string</span><span> {</span></span>
<span data-line=""><span>    // babad</span></span>
<span data-line=""><span>    // return longe=est valid palindrome</span></span>
<span data-line=""><span>    // .slice is inclusive/exclusive</span></span>
<span data-line=""><span>    // OR just 0/exclusive if only one char passed</span></span>
<span data-line=""><span>    if</span><span> (s.</span><span>length</span><span> &lt;</span><span> 1</span><span>) </span><span>return</span><span> &#39;&#39;</span></span>
<span data-line=""><span>    if</span><span> (s.</span><span>length</span><span> ===</span><span> 1</span><span>) </span><span>return</span><span> s[</span><span>0</span><span>]</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> middle </span><span>=</span><span> 0</span><span>, radius </span><span>=</span><span> 0</span><span>, longestPal </span><span>=</span><span> &#39;&#39;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> isPalindrome</span><span> =</span><span> (</span><span>inputString</span><span>:</span><span> string</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>        console.</span><span>log</span><span>(inputString)</span></span>
<span data-line=""><span>        if</span><span> (inputString.</span><span>length</span><span> %</span><span> 2</span><span> ===</span><span> 0</span><span>){</span></span>
<span data-line=""><span>            let</span><span> middleRight </span><span>=</span><span> inputString.</span><span>length</span><span> /</span><span> 2</span></span>
<span data-line=""><span>            return</span><span> inputString.</span><span>slice</span><span>(middleRight) </span><span>===</span><span> inputString.</span><span>slice</span><span>(middleRight, inputString.</span><span>length</span><span>)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            let</span><span> middle </span><span>=</span><span> Math.</span><span>floor</span><span>(inputString.</span><span>length</span><span> /</span><span> 2</span><span>)</span></span>
<span data-line=""><span>            return</span><span> inputString.</span><span>slice</span><span>(middle) </span><span>===</span><span> inputString.</span><span>slice</span><span>(middle</span><span>+</span><span>1</span><span>, inputString.</span><span>length</span><span>)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> longestString</span><span> =</span><span> (</span><span>stringOne</span><span>:</span><span> string</span><span>, </span><span>stringTwo</span><span>:</span><span> string</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>        if</span><span> (stringOne.</span><span>length</span><span> &gt;=</span><span> stringTwo.</span><span>length</span><span>) </span><span>return</span><span> stringOne</span></span>
<span data-line=""><span>        return</span><span> stringTwo</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    while</span><span> (middle </span><span>+</span><span> radius </span><span>&lt;</span><span> s.</span><span>length</span><span>){</span></span>
<span data-line=""><span>        if</span><span> (middle </span><span>-</span><span> radius </span><span>&lt;</span><span> 0</span><span>){</span></span>
<span data-line=""><span>            middle</span><span>++</span></span>
<span data-line=""><span>            continue</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>        let</span><span> window </span><span>=</span><span> s.</span><span>slice</span><span>(middle </span><span>-</span><span> radius, middle </span><span>+</span><span> radius </span><span>+</span><span> 1</span><span>)</span></span>
<span data-line=""><span>        if</span><span> (s[middle </span><span>-</span><span> radius] </span><span>===</span><span> s[middle </span><span>+</span><span> radius]){</span></span>
<span data-line=""><span>            longestPal </span><span>=</span><span> longestString</span><span>(longestPal, window)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>        radius</span><span>++</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> longestPal</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Unfortunately…this doesn’t really handle the detection of even palindromes. So. I think it’s time to look at some answers.</p>
<p>This is what perplexity ‘came up with’:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> longestPalindrome</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> string</span><span> {</span></span>
<span data-line=""><span>    if</span><span> (s.</span><span>length</span><span> &lt;</span><span> 2</span><span>) </span><span>return</span><span> s;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> start </span><span>=</span><span> 0</span><span>, maxLength </span><span>=</span><span> 1</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    function</span><span> expandAroundCenter</span><span>(</span><span>left</span><span>:</span><span> number</span><span>, </span><span>right</span><span>:</span><span> number</span><span>) {</span></span>
<span data-line=""><span>        while</span><span> (left </span><span>&gt;=</span><span> 0</span><span> &amp;&amp;</span><span> right </span><span>&lt;</span><span> s.</span><span>length</span><span> &amp;&amp;</span><span> s[left] </span><span>===</span><span> s[right]) {</span></span>
<span data-line=""><span>            const</span><span> currentLength</span><span> =</span><span> right </span><span>-</span><span> left </span><span>+</span><span> 1</span><span>;</span></span>
<span data-line=""><span>            if</span><span> (currentLength </span><span>&gt;</span><span> maxLength) {</span></span>
<span data-line=""><span>                start </span><span>=</span><span> left;</span></span>
<span data-line=""><span>                maxLength </span><span>=</span><span> currentLength;</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>            left</span><span>--</span><span>;</span></span>
<span data-line=""><span>            right</span><span>++</span><span>;</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> s.</span><span>length</span><span>; i</span><span>++</span><span>) {</span></span>
<span data-line=""><span>        expandAroundCenter</span><span>(i, i);  </span><span>// Odd length palindromes</span></span>
<span data-line=""><span>        expandAroundCenter</span><span>(i, i </span><span>+</span><span> 1</span><span>);  </span><span>// Even length palindromes</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> s.</span><span>slice</span><span>(start, start </span><span>+</span><span> maxLength);</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>It looks pretty neat, and it performs pretty well.</p>
<p>Okay let me think this through line by line.</p>
<p>If there are 0 or 1 characters in the string, return the string.
We only have two variables to change - start and Maxlength.</p>
<p>We define a function expandAroundCenter that we can presume can be reused for odd and even cases.</p>
<p>This function takes a left and a right. When we use it later on, it looks like the odd incantation passes both of these values as the same. The even incantation passes i, and then i + 1.</p>
<p>In this function, we check a few things to stay in the while loop:</p>
<ul>
<li>left has to be more than or equal to 0.</li>
<li>the <code>right</code> needs to be less than the length of the string - familiar to <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/18)-Longest-Substring-Without-Repeating-Characters" data-slug="devnotes/LeetCode-Journal/18)-Longest-Substring-Without-Repeating-Characters">18) Longest Substring Without Repeating Characters</a></li>
<li>This last one is cool! Right has to be equal to left, or we quit the while loop</li>
</ul>
<p>Then in the while loop, we get to a sort of index-fiddly thing where we are keeping track of NOT ONLY the <code>maxLength</code> palindrome we’ve found, but also the <code>start</code>, which is the just the place we store the <code>left</code> value that corresponds to the longest palindrome we’ve found.</p>
<p>Phew. Okay. So this all makes sense, and isn’t crazy complicated, it’s just a lot. Let’s see if I can reproduce it from scratch. Let’s go.</p>
<p>Okay 4 minutes in ran it, got a compile error:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> longestPalindrome</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> string</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    if</span><span> (s.</span><span>length</span><span> &lt;</span><span> 2</span><span>) </span><span>return</span><span> s </span><span>// handle cases where string is just one or no letters</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> start </span><span>=</span><span> 0</span><span>, maxLength </span><span>=</span><span> 0</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> expandOutFromCenter</span><span>(left</span><span>:</span><span> number</span><span>, </span><span>right</span><span>:</span><span> number</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>        while</span><span> (</span><span>left</span><span> &gt;</span><span>=</span><span> 0</span><span> &amp;&amp;</span><span> right </span><span>&lt;</span><span> s.</span><span>length</span><span> &amp;&amp;</span><span> left </span><span>==</span><span> right){</span></span>
<span data-line=""><span>            let</span><span> window </span><span>=</span><span> s.</span><span>slice</span><span>(left, right</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""><span>            if</span><span> (window.</span><span>length</span><span> &gt;</span><span> maxLength){</span></span>
<span data-line=""><span>                start </span><span>=</span><span> left</span></span>
<span data-line=""><span>                maxLength </span><span>=</span><span> window.</span><span>length</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>            left</span><span>--</span></span>
<span data-line=""><span>            right</span><span>++</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>const</span><span> i</span><span> =</span><span> 0</span><span>; i </span><span>&lt;</span><span> s.</span><span>length</span><span>; s</span><span>++</span><span>){</span></span>
<span data-line=""><span>        expandOutFromCenter</span><span>(i, i)</span></span>
<span data-line=""><span>        expandOutFromCenter</span><span>(i, i</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> s.</span><span>slice</span><span>(start, start </span><span>+</span><span> maxLength)</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // increment through every starting position of string for even and odd cases</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Okay fixed a few bugs and added in console logs:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> longestPalindrome</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> string</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    if</span><span> (s.</span><span>length</span><span> &lt;</span><span> 2</span><span>) </span><span>return</span><span> s </span><span>// handle cases where string is just one or no letters</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> start </span><span>=</span><span> 0</span><span>, maxLength </span><span>=</span><span> 0</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> expandOutFromCenter</span><span> =</span><span> (</span><span>left</span><span>:</span><span> number</span><span>, </span><span>right</span><span>:</span><span> number</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>        console.</span><span>log</span><span>({left, right})</span></span>
<span data-line=""><span>        while</span><span> (left </span><span>&gt;=</span><span> 0</span><span> &amp;&amp;</span><span> right </span><span>&lt;</span><span> s.</span><span>length</span><span> &amp;&amp;</span><span> left </span><span>===</span><span> right){</span></span>
<span data-line=""><span>            let</span><span> window </span><span>=</span><span> s.</span><span>slice</span><span>(left, right</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""><span>            if</span><span> (window.</span><span>length</span><span> &gt;</span><span> maxLength){</span></span>
<span data-line=""><span>                start </span><span>=</span><span> left</span></span>
<span data-line=""><span>                maxLength </span><span>=</span><span> window.</span><span>length</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>            left</span><span>--</span></span>
<span data-line=""><span>            right</span><span>++</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> s.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>        expandOutFromCenter</span><span>(i, i)</span></span>
<span data-line=""><span>        expandOutFromCenter</span><span>(i, i</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""><span>        console.</span><span>log</span><span>(</span><span>&#39;-----&#39;</span><span>)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> s.</span><span>slice</span><span>(start, start </span><span>+</span><span> maxLength)</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // increment through every starting position of string for even and odd cases</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>HA. I got it!</p>
<p><code>8.26 minutes</code></p>
<p>My problem was that in my <code>while loop</code> conditional I was comparing the indexes of <code>left</code> and <code>right</code>, not their values - this was sort of clear from the console logs I got:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>{ </span><span>left</span><span>: </span><span>0</span><span>, </span><span>right</span><span>: </span><span>0</span><span> }</span></span>
<span data-line=""><span>{ </span><span>left</span><span>: </span><span>0</span><span>, </span><span>right</span><span>: </span><span>1</span><span> }</span></span>
<span data-line=""><span>-----</span></span>
<span data-line=""><span>{ </span><span>left</span><span>: </span><span>1</span><span>, </span><span>right</span><span>: </span><span>1</span><span> }</span></span>
<span data-line=""><span>{ </span><span>left</span><span>: </span><span>1</span><span>, </span><span>right</span><span>: </span><span>2</span><span> }</span></span>
<span data-line=""><span>-----</span></span>
<span data-line=""><span>{ </span><span>left</span><span>: </span><span>2</span><span>, </span><span>right</span><span>: </span><span>2</span><span> }</span></span>
<span data-line=""><span>{ </span><span>left</span><span>: </span><span>2</span><span>, </span><span>right</span><span>: </span><span>3</span><span> }</span></span>
<span data-line=""><span>-----</span></span>
<span data-line=""><span>{ </span><span>left</span><span>: </span><span>3</span><span>, </span><span>right</span><span>: </span><span>3</span><span> }</span></span>
<span data-line=""><span>{ </span><span>left</span><span>: </span><span>3</span><span>, </span><span>right</span><span>: </span><span>4</span><span> }</span></span>
<span data-line=""><span>-----</span></span>
<span data-line=""><span>{ </span><span>left</span><span>: </span><span>4</span><span>, </span><span>right</span><span>: </span><span>4</span><span> }</span></span>
<span data-line=""><span>{ </span><span>left</span><span>: </span><span>4</span><span>, </span><span>right</span><span>: </span><span>5</span><span> }</span></span>
<span data-line=""><span>-----</span></span></code></pre></figure>
<p>I looked at these and saw hmm. We’re not progressing through the for loop. Here’s the reproduced winner:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> longestPalindrome</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> string</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    if</span><span> (s.</span><span>length</span><span> &lt;</span><span> 2</span><span>) </span><span>return</span><span> s </span><span>// handle cases where string is just one or no letters</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> start </span><span>=</span><span> 0</span><span>, maxLength </span><span>=</span><span> 0</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> expandOutFromCenter</span><span> =</span><span> (</span><span>left</span><span>:</span><span> number</span><span>, </span><span>right</span><span>:</span><span> number</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>        console.</span><span>log</span><span>({left, right})</span></span>
<span data-line=""><span>        while</span><span> (left </span><span>&gt;=</span><span> 0</span><span> &amp;&amp;</span><span> right </span><span>&lt;</span><span> s.</span><span>length</span><span> &amp;&amp;</span><span> s[left] </span><span>===</span><span> s[right]){</span></span>
<span data-line=""><span>            if</span><span> (right </span><span>-</span><span> left </span><span>+</span><span> 1</span><span> &gt;</span><span> maxLength){</span></span>
<span data-line=""><span>                start </span><span>=</span><span> left</span></span>
<span data-line=""><span>                maxLength </span><span>=</span><span> window.</span><span>length</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>            left</span><span>--</span></span>
<span data-line=""><span>            right</span><span>++</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> s.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>        expandOutFromCenter</span><span>(i, i)</span></span>
<span data-line=""><span>        expandOutFromCenter</span><span>(i, i</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""><span>        console.</span><span>log</span><span>(</span><span>&#39;-----&#39;</span><span>)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> s.</span><span>slice</span><span>(start, start </span><span>+</span><span> maxLength)</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // increment through every starting position of string for even and odd cases</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Weirdly the performance is WAY worse than the Perplexity code.</p>
<p>Perplexity’s solution: 83ms
Mine one: 661ms.</p>
<p>What gives? I bet you can spot it.</p>
<p>After looking back over my code I got it - it’s this line: <code>let window = s.slice(left, right+1)</code></p>
<p>I am creating a new string every while loop. But I don’t need a whole string. I just need to know the length of the window.</p>
<blockquote>
<p>OKAY NOPE</p>
</blockquote>
<p>That’s sort of correct - that seems to account for 40ms of latency. But the other 538 just come from the two console logs!</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> longestPalindrome</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> string</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    if</span><span> (s.</span><span>length</span><span> &lt;</span><span> 2</span><span>) </span><span>return</span><span> s </span><span>// handle cases where string is just one or no letters</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> start </span><span>=</span><span> 0</span><span>, maxLength </span><span>=</span><span> 0</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> expandOutFromCenter</span><span> =</span><span> (</span><span>left</span><span>:</span><span> number</span><span>, </span><span>right</span><span>:</span><span> number</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>        while</span><span> (left </span><span>&gt;=</span><span> 0</span><span> &amp;&amp;</span><span> right </span><span>&lt;</span><span> s.</span><span>length</span><span> &amp;&amp;</span><span> s[left] </span><span>===</span><span> s[right]){</span></span>
<span data-line=""><span>            let</span><span> window </span><span>=</span><span> right </span><span>+</span><span> 1</span><span> -</span><span> left</span></span>
<span data-line=""><span>            if</span><span> (window </span><span>&gt;</span><span> maxLength){</span></span>
<span data-line=""><span>                start </span><span>=</span><span> left</span></span>
<span data-line=""><span>                maxLength </span><span>=</span><span> window</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>            left</span><span>--</span></span>
<span data-line=""><span>            right</span><span>++</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> s.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>        expandOutFromCenter</span><span>(i, i)</span></span>
<span data-line=""><span>        expandOutFromCenter</span><span>(i, i</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> s.</span><span>slice</span><span>(start, start </span><span>+</span><span> maxLength)</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // increment through every starting position of string for even and odd cases</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>^ Here’s my final solution, which is now 81ms. Sweet! That was a tough 40 minutes or so of studying but I feel good. I will try to reproduce these both tomorrow and see how I do.</p>

<p>Okay it’s been a day! I got it in <code>14:56</code> after a couple challenges:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> longestPalindrome</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> string</span><span> {</span></span>
<span data-line=""><span>    if</span><span> (s.</span><span>length</span><span> &lt;</span><span> 2</span><span>) </span><span>return</span><span> s</span></span>
<span data-line=""><span>    // okay so I need to do this with the expand from center function</span></span>
<span data-line=""><span>    // The expand from center function starts with a left and a right</span></span>
<span data-line=""><span>    // and then it continues expanding as long as each expansion left === right</span></span>
<span data-line=""><span>    // one quirk of it is that it has to save the &#34;start&#34; of palindrome as well as, at least, some way to calculate the end as well, so we can actually return what we&#39;ve found</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> start </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    let</span><span> length </span><span>=</span><span> 0</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> expandFromCenter</span><span> =</span><span> (</span><span>left</span><span>:</span><span> number</span><span>, </span><span>right</span><span>:</span><span> number</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>        while</span><span> (s[left] </span><span>===</span><span> s[right] </span><span>&amp;&amp;</span><span> left </span><span>&gt;</span><span> -</span><span>1</span><span> &amp;&amp;</span><span> right </span><span>&lt;</span><span> s.</span><span>length</span><span>){</span></span>
<span data-line=""><span>            if</span><span> (right</span><span>-</span><span>left </span><span>&gt;</span><span> length){</span></span>
<span data-line=""><span>                start</span><span>=</span><span>left</span></span>
<span data-line=""><span>                length</span><span>=</span><span>right</span><span>-</span><span>left</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>            left</span><span>--</span></span>
<span data-line=""><span>            right</span><span>++</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> s.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>        expandFromCenter</span><span>(i, i</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""><span>        expandFromCenter</span><span>(i, i)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> s.</span><span>slice</span><span>(start, start</span><span>+</span><span>length</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Problems I faces:</p>
<ol>
<li>I left in a <code>console.log</code> at one point, which caused leetcode to error out in a way I hadn’t seen - the stdout limit was exceeded! It was written as <code>output exceeded</code>, but when I removed the <code>console.log</code> the submission worked splendidly, executing within a competitive time complexity.</li>
<li>I accidentally incremented <code>right</code> <em>and</em> <code>left</code> at first</li>
<li>I had to add the <code>+1</code> on the last line, but I’m not totally sure why. I just did it intuitively in response to the strings that were being returned to me.</li>
</ol>
<p>Let me think about though. Ah right! <code>.slice</code>’s second argument is <code>exclusive</code>.</p>

<p>time: <code>5:35</code>
Features I forgot:
Originally I thought that I could just do <code>Math.max(maxLength, end-start)</code>, but forgot I also have to save the start. I wonder if there’s any way around saving two separate variables.</p></article></div>
  </body>
</html>
