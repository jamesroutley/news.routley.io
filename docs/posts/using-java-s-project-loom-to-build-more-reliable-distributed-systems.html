<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jbaker.io/2022/05/09/project-loom-for-distributed-systems/">Original</a>
    <h1>Using Java&#39;s Project Loom to build more reliable distributed systems</h1>
    
    <div id="readability-page-1" class="page"><div>
        <div>
  
  <p><span>09 May 2022</span></p><p>Building distributed databases is very difficult. There are lots of clever ideas you can put into a distributed database, but making the ideas work well together in a real system can be very challenging because different decompositions of the same problem can massively affect how difficult it is to solve, and bugs are typically both subtle and hard to detect. This is especially problematic as the system evolves, where it can be difficult to understand whether an improvement helps or hurts.</p>

<p>With Jepsen and FoundationDB I’ve seen two particularly interesting mechanisms of testing that distributed systems maintain the properties they claim to hold, and Java’s Project Loom should enable a hybrid approach that gains the most of the benefits of both without the costs.</p>

<h2 id="jepsen">Jepsen</h2>

<p>Jepsen is a software framework and blog post series which attempts to find bugs in distributed databases, especially although not exclusively around partition tolerance. The database is installed in a controlled environment (say, virtual machines or Docker containers) and operations are issued and their results recorded. Control over the environment is used to inject <em>nemeses</em> (say, clock skew, network latency, network partitions) randomly, while the operations are being issued and recorded reliably. Invariants can be written according to the database’s marketing
material, and should the results violate the invariants, one has cast iron evidence of a bug. As a comparative tool,
the results speak for themselves. In the early days, many fanciful claims made by database companies bit the dust, and more recently contracting Kyle Kingsbury to stress your database has become something of a rite of passage.</p>

<p><img src="https://jbaker.io/assets/images/jepsen.jpg" alt="jepsen" width="100%"/></p>

<p>As a white box tool for bug detection, Jepsen is fantastic. If you’ve written the database in question, Jepsen leaves something to be desired. By falling down to the lowest common denominator of ‘the database must run on Linux’, testing is both slow and non-deterministic because most production-level actions one can take are comparatively slow. For a quick example, suppose I’m looking for bugs in Apache Cassandra which occur due to adding and removing nodes. It’s usual for adding and removing nodes to Cassandra to take hours or even days, although for small databases it might be possible in minutes, probably not much less than. A Jepsen environment could only run one iteration of the test every few minutes; if the failure case only happens one time in every few thousand attempts, without massive parallelism I might expect to discover issues only every few days, if that. I had an improvement that I was testing out against a Cassandra cluster which I discovered deviated from Cassandra’s pre-existing behaviour with (against a production workload) probability one in a billion. Jepsen likely won’t help with that.</p>

<p>Suppose that we either have a large server farm or a large amount of time and have detected the bug somewhere in our stack of at least tens of thousands of lines of code. We now have a bug, but no reproduction of said bug. If there is some kind of smoking gun in the bug report or a sufficiently small set of potential causes, this might just be the start of an odyssey.</p>

<p>Jepsen is probably the best known example of this type of testing, and it certainly moved the state of the art; most database authors have similar suites of tests. ScyllaDB documents their testing strategy <a href="https://www.scylladb.com/product/technology/scylla-testing/">here</a> and while the styles of testing might vary between different vendors, the strategis have mostly coalesced around this approach.</p>

<p>Jepsen is limited here by its broadness. As the author of the database, we have much more access to the database if we so desire, as shown by <a href="https://www.foundationdb.org/">FoundationDB</a>.</p>

<h2 id="foundationdb">FoundationDB</h2>

<p>One of the most personally influential tech talks I’ve watched is
<a href="https://www.youtube.com/watch?v=4fFDFbi3toc">Will Wilson’s FoundationDB talk at StrangeLoop 2014</a>.
I highly recommend watching the talk, but here follows a brief summary.</p>

<p>When the FoundationDB team set out to build a distributed database, they didn’t start by building a distributed database. Instead, they built a <em>deterministic simulation</em> of a distributed database. They built mocks of networks, filesystems, hosts, which all worked similarly to those you’d see in a real system but with simulated time and resources allowing injection of failures.</p>

<p><img src="https://jbaker.io/assets/images/fdb.jpg" alt="fdb" width="100%"/></p>

<p>They could now write deterministic tests of their system, similarly to the Jepsen tests, except for two key differences:</p>

<ol>
  <li>The tests were deterministic and so any test failure naturally had a baked in reproduction (one can simply re-run the test to observe the same result).</li>
  <li>The tests could be made extremely fast because the test doubles enabled skipping work. For example, suppose that a task needs to wait for a second. Instead of implementing by actually waiting for a second, the simulation could possibly increment a number (time) by a second (and do any work that needed to be done in the meantime). Alternatively, consider an RPC connection. Instead of actually using the TCP stack, a simulation could be used which does not require any operating system collaboration.</li>
</ol>

<p>Once the team had built their simulation of a database, they could swap out their mocks for the real thing, writing the adapters from their interfaces to the various underlying operating system calls. At this point, they could run the same tests in a way similar to Jepsen (my understanding was that a small fleet of servers, programmable switches and power supplies was used). These real-hardware re-runs could be used to ensure that the simulation matched the real world, since any failure not seen in the simulation naturally corresponds to a deficiency in the simulation.</p>

<p>Once satisfied with their simulation, they had a database they could sell!</p>

<p>I’ve heard that this was beneficial to the company in a number of ways, but the one that caught my eye can be paraphrased as ‘because we had very high confidence in the correctness of our code and the changes we were making to it, we could be much more aggressive with regards to the technical architecture of the system<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>’.</p>

<p><img src="https://jbaker.io/assets/images/fdb-pyramid.jpg" alt="fdb-pyramid" width="100%"/></p>

<p>One problem with this approach is that it makes a huge technical tradeoff - programming languages and operating system concepts typically do not make it easy to solve problems using this mechanic because large parts of the system are not naturally controllable in a deterministic way. Let’s use a simple Java example, where we have a thread that kicks off some concurrent work, does some work for itself, and then waits for the initial work to finish.</p>

<div><div><pre><code><span>ExecutorService</span> <span>executor</span> <span>=</span> <span>createExecutorService</span><span>();</span>
<span>Future</span><span>&lt;</span><span>String</span><span>&gt;</span> <span>task</span> <span>=</span> <span>executor</span><span>.</span><span>submit</span><span>(()</span> <span>-&gt;</span> <span>{</span>
   <span>Future</span><span>&lt;</span><span>String</span><span>&gt;</span> <span>concurrentComputation</span> <span>=</span> <span>executor</span><span>.</span><span>submit</span><span>(</span><span>this</span><span>::</span><span>doExpensiveComputation</span><span>);</span>
   <span>return</span> <span>doExpensiveComputation2</span><span>()</span> <span>+</span> <span>concurrentComputation</span><span>.</span><span>get</span><span>();</span>
<span>});</span>
</code></pre></div></div>

<p>If the <code>ExecutorService</code> involved is backed by multiple operating system threads, then the task will not be executed in
a deterministic fashion because the operating system task scheduler is not pluggable. If instead it is backed by a single operating system thread, it will deadlock.</p>

<p>An alternative approach might be to use an asynchronous implementation, using <code>Listenable/CompletableFutures</code>, <code>Promises</code>, etc. Here, we don’t block on another task, but use callbacks to move state. Palantir’s <a href="https://github.com/palantir/dialogue/">Dialogue</a> uses this model to implement an RPC library. By utilizing an asynchronous implementation and using a <a href="https://github.com/palantir/dialogue/tree/develop/simulation/src/main/java/com/palantir/dialogue/core">deterministic scheduler</a> (as well as swapping out the underlying Apache HTTP client for a stub implementation), they can easily simulate the load balancing logic and generate predictions of how well different algorithms handle different cases against differently unperformant servers, producing <a href="https://github.com/palantir/dialogue/blob/develop/simulation/src/test/resources/slow_503s_then_revert%5BCONCURRENCY_LIMITER_ROUND_ROBIN%5D.png">pretty charts of the results</a> which can be posted to pull requests each time they change. This had a side effect - by measuring the runtime of the simulation, one can get a good understanding of the CPU overheads of the library and optimize the runtime against this. In some ways this is similar to <a href="https://www.sqlite.org/draft/cpu.html">SQLite’s approach to CPU optimization</a>. More broad usage of the model can easily become unwieldy<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup>.</p>

<p>FoundationDB’s usage of this model required them to build their own programming language, <a href="https://apple.github.io/foundationdb/flow.html">Flow</a>, which is transpiled to C++. The simulation model therefore infects the entire codebase and places large constraints on dependencies, which makes it a difficult choice.</p>

<h2 id="conclusion">Conclusion</h2>

<p>It’s typical to test the consistency protocols of distributed systems via randomized failure testing. Two approaches which sit at different ends of the spectrum are Jepsen and the simulation mechanism pioneered by FoundationDB. The former allows the system under test to be implemented in any way, but is only viable as a last line of defense. The latter can be used to guide a much more aggressive implementation strategy, but requires the system to be implemented in a very specific style.</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Jepsen-style</th>
      <th>FoundationDB-style</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Integration difficulty</td>
      <td>So long as it uses syscalls, it can be done</td>
      <td>Required writing own programming language</td>
    </tr>
    <tr>
      <td>Speed of testing</td>
      <td>Slow - good for acceptance tests</td>
      <td>Fast - much faster than the production DB</td>
    </tr>
    <tr>
      <td>Representative?</td>
      <td>Yes - all subsystems same as in production</td>
      <td>No - detailed simulations, but test doubles relied upon</td>
    </tr>
    <tr>
      <td>Useful for debugging</td>
      <td>No - distributed systems failures never fun to debug.</td>
      <td>Yes - since deterministic, all failures replayable</td>
    </tr>
  </tbody>
</table>

<p>Java’s Project Loom considerably shakes up this tradeoff.</p>

<p><img src="https://jbaker.io/assets/images/spectrum.jpg" alt="spectrum" width="100%"/></p>



<p><a href="https://wiki.openjdk.java.net/display/loom/Main">Project Loom</a> provides ‘virtual’ threads as a first class concept within Java. There is plenty of good information in the 2020 blog post ‘<a href="http://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part1.html">State of Loom</a>’ although details have changed in the last two years.</p>

<p>I will give a simplified description of what I find exciting about this. In traditional Java we can launch a Thread. If it needs to pause for some reason, the thread will be paused, and will resume when it is able to. Java does not make it easy to control the threads (pause at a critical section, pick who acquired the lock, etc), and so influencing the interleaving of execution is very difficult except for in very isolated cases.</p>

<p>With Loom’s virtual threads, when a thread starts, a <code>Runnable</code> is submitted to an <code>Executor</code>. When that task is run by the executor, if the thread needs to block, the submitted runnable will exit, instead of pausing. When the thread can be unblocked, a new runnable is submitted to the same executor to pick up where the previous <code>Runnable</code> left off. Here, interleaving is much, much easier, since we are passed each piece of runnable work as it becomes runnable. Combined with the <code>Thread.yield()</code> primitive, we can also influence the points at which code becomes deschedulable.</p>

<div><div><pre><code><span>Queue</span><span>&lt;</span><span>Runnable</span><span>&gt;</span> <span>executor</span> <span>=</span> <span>new</span> <span>ArrayDeque</span><span>&lt;&gt;();</span>
<span>Lock</span> <span>lock</span> <span>=</span> <span>new</span> <span>ReentrantLock</span><span>();</span>
<span>lock</span><span>.</span><span>lock</span><span>();</span>
<span>newVirtualThread</span><span>(</span><span>executor:</span><span>:</span><span>add</span><span>,</span> <span>lock:</span><span>:</span><span>lock</span><span>);</span>
<span>assertThat</span><span>(</span><span>executor</span><span>).</span><span>hasSize</span><span>(</span><span>1</span><span>)</span>
    <span>.</span><span>as</span><span>(</span><span>&#34;runnable for vthread has been submitted&#34;</span><span>);</span>
<span>executor</span><span>.</span><span>poll</span><span>().</span><span>run</span><span>();</span>
<span>assertThat</span><span>(</span><span>executor</span><span>).</span><span>hasSize</span><span>(</span><span>0</span><span>)</span>
    <span>.</span><span>as</span><span>(</span><span>&#34;vthread has blocked, no longer runnable&#34;</span><span>);</span>
<span>lock</span><span>.</span><span>unlock</span><span>();</span>
<span>assertThat</span><span>(</span><span>executor</span><span>).</span><span>hasSize</span><span>(</span><span>1</span><span>)</span>
    <span>.</span><span>as</span><span>(</span><span>&#34;due to unlock, the vthread is now schedulable again&#34;</span><span>);</span>
<span>executor</span><span>.</span><span>poll</span><span>().</span><span>run</span><span>();</span>
<span>assertThat</span><span>(</span><span>lock</span><span>.</span><span>tryLock</span><span>()).</span><span>isFalse</span><span>()</span>
    <span>.</span><span>as</span><span>(</span><span>&#34;the virtual thread now holds the lock&#34;</span><span>);</span>
</code></pre></div></div>

<p>By utilizing this API, we can exert fine grained deterministic control over execution within Java. Let’s give a micro level example. Suppose we’re trying to test the correctness of a buggy version of Guava’s <code>Suppliers.memoize</code> function.</p>

<div><div><pre><code><span>class</span> <span>BrokenMemoizingSupplier</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>implements</span> <span>Supplier</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
  <span>private</span> <span>final</span> <span>Lock</span> <span>lock</span><span>;</span>
  <span>private</span> <span>final</span> <span>Supplier</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>delegate</span><span>;</span>
  <span>private</span> <span>volatile</span> <span>boolean</span> <span>initialized</span> <span>=</span> <span>false</span><span>;</span>
  <span>private</span> <span>volatile</span> <span>T</span> <span>value</span><span>;</span>

  <span>BrokenMemoizingSupplier</span><span>(</span><span>Supplier</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>delegate</span><span>)</span> <span>{</span>
    <span>this</span><span>(</span><span>new</span> <span>ReentrantLock</span><span>(),</span> <span>delegate</span><span>);</span>
  <span>}</span>

  <span>@VisibleForTesting</span>
  <span>BrokenMemoizingSupplier</span><span>(</span><span>Lock</span> <span>lock</span><span>,</span> <span>Supplier</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>delegate</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>lock</span> <span>=</span> <span>lock</span><span>;</span>
    <span>this</span><span>.</span><span>delegate</span> <span>=</span> <span>delegate</span><span>;</span>
  <span>}</span>

  <span>@Override</span>
  <span>public</span> <span>T</span> <span>get</span><span>()</span> <span>{</span>
    <span>if</span> <span>(!</span><span>initialized</span><span>)</span> <span>{</span>
      <span>lock</span><span>.</span><span>lock</span><span>();</span>
      <span>try</span> <span>{</span>
        <span>// This code is broken because initialized may have changed between its check before the call to &#39;lock&#39; and now.</span>
        <span>T</span> <span>result</span> <span>=</span> <span>delegate</span><span>.</span><span>get</span><span>();</span>
        <span>value</span> <span>=</span> <span>result</span><span>;</span>
        <span>initialized</span> <span>=</span> <span>true</span><span>;</span>
        <span>return</span> <span>result</span><span>;</span>
      <span>}</span> <span>finally</span> <span>{</span>
        <span>lock</span><span>.</span><span>unlock</span><span>();</span>
      <span>}</span>
    <span>}</span>
    <span>return</span> <span>value</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This test is enough to deterministically exhibit the bug:</p>

<div><div><pre><code><span>// This will fail every time</span>
<span>@ParameterizedTest</span>
<span>@MethodSource</span><span>(</span><span>&#34;range&#34;</span><span>)</span>
<span>void</span> <span>testAllCases</span><span>(</span><span>int</span> <span>seed</span><span>)</span> <span>{</span>
  <span>AtomicInteger</span> <span>countCalls</span> <span>=</span> <span>new</span> <span>AtomicInteger</span><span>();</span>
  <span>BrokenMemoizingSupplier</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>supplier</span> <span>=</span>
    <span>new</span> <span>BrokenMemoizingSupplier</span><span>&lt;&gt;(</span>
      <span>new</span> <span>YieldingLock</span><span>(),</span>
      <span>countCalls:</span><span>:</span><span>incrementAndGet</span><span>);</span>
  <span>Random</span> <span>random</span> <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>seed</span><span>);</span>
  <span>RandomizingExecutor</span> <span>executor</span> <span>=</span> <span>new</span> <span>RandomizingExecutor</span><span>(</span><span>random</span><span>);</span>
  <span>newVirtualThread</span><span>(</span><span>executor</span><span>,</span> <span>supplier:</span><span>:</span><span>get</span><span>);</span>
  <span>newVirtualThread</span><span>(</span><span>executor</span><span>,</span> <span>supplier:</span><span>:</span><span>get</span><span>);</span>
  <span>executor</span><span>.</span><span>drain</span><span>();</span>
  <span>assertThat</span><span>(</span><span>supplier</span><span>.</span><span>get</span><span>()).</span><span>isOne</span><span>();</span>
<span>}</span>

<span>static</span> <span>Stream</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>range</span><span>()</span> <span>{</span>
  <span>return</span> <span>IntStream</span><span>.</span><span>range</span><span>(</span><span>0</span><span>,</span> <span>10</span><span>).</span><span>boxed</span><span>();</span>
<span>}</span>

<span>/**
  * This executor executes randomly for brevity. By tracking which
  * tasks launch which other tasks, one could generate all valid
  * interleavings for small cases such as this.
  */</span>
<span>private</span> <span>static</span> <span>final</span> <span>class</span> <span>RandomizingExecutor</span> <span>implements</span> <span>Executor</span> <span>{</span>
  <span>private</span> <span>final</span> <span>Random</span> <span>random</span><span>;</span>
  <span>private</span> <span>final</span> <span>List</span><span>&lt;</span><span>Runnable</span><span>&gt;</span> <span>queue</span> <span>=</span> <span>new</span> <span>ArrayList</span><span>&lt;&gt;();</span>

  <span>private</span> <span>RandomizingExecutor</span><span>(</span><span>Random</span> <span>random</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>random</span> <span>=</span> <span>random</span><span>;</span>
  <span>}</span>

  <span>@Override</span>
  <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>Runnable</span> <span>command</span><span>)</span> <span>{</span>
    <span>queue</span><span>.</span><span>add</span><span>(</span><span>command</span><span>);</span>
  <span>}</span>

  <span>public</span> <span>void</span> <span>drain</span><span>()</span> <span>{</span>
    <span>while</span> <span>(!</span><span>queue</span><span>.</span><span>isEmpty</span><span>())</span> <span>{</span>
      <span>Collections</span><span>.</span><span>shuffle</span><span>(</span><span>queue</span><span>,</span> <span>random</span><span>);</span>
      <span>Runnable</span> <span>task</span> <span>=</span> <span>queue</span><span>.</span><span>remove</span><span>(</span><span>queue</span><span>.</span><span>size</span><span>()</span> <span>-</span> <span>1</span><span>);</span>
      <span>task</span><span>.</span><span>run</span><span>();</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>// Thread.yield will pause the thread and cause it to become schedulable again.</span>
<span>private</span> <span>static</span> <span>final</span> <span>class</span> <span>YieldingLock</span> <span>extends</span> <span>ReentrantLock</span> <span>{</span>
  <span>@Override</span>
  <span>public</span> <span>void</span> <span>lock</span><span>()</span> <span>{</span>
    <span>Thread</span><span>.</span><span>yield</span><span>();</span>
    <span>super</span><span>.</span><span>lock</span><span>();</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This test is highly limited as compared to a tool like <a href="https://shipilev.net/blog/2016/close-encounters-of-jmm-kind">jcstress</a>, since any issues related to compiler reordering of reads or writes will be untestable. There are however two key advantages of testing using this style.</p>

<ol>
  <li>Many races will only be exhibited in specific circumstances. For example, on a single core machine, in the absence of a sleep or control primitive like a CountDownLatch, it’s unlikely that the above bug could be found. By generating a lot of simulated context switching, a broader set of possible interleavings can be cheaply explored. This makes it more likely that the author will find bugs that they were not specifically looking for.</li>
  <li>The approach can be scaled up to much larger systems.</li>
</ol>

<h2 id="hypothesis">Hypothesis</h2>

<p>Loom offers the same simulation advantages of FoundationDB’s Flow language (Flow has other features too, it should be noted) but with the advantage that it works well with almost the entire Java runtime. This means that idiomatic Java (or other JVM languages like Kotlin, Scala or presumably eventually anything that works on GraalVM) fits in well, and the APIs that Loom exposes<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup> makes it straightforward to experiment with this kind of approach. This significantly broadens the scope for FoundationDB like implementation patterns, making it much easier for a large class of software to utilize this mechanism of building and verifying distributed systems.</p>

<p>What one could do is the following:</p>

<ol>
  <li>Start by building a simulation of core Java primitives (concurrency/threads/locks/caches, filesystem access, RPC). Implement the ability to insert delays, errors in the results as necessary. The simulations could be high or low level. One could implement a simulation of core I/O primitives like <code>Socket</code>, or a much higher level primitive like a gRPC unary RPC<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" rel="footnote">4</a></sup>.</li>
  <li>As you build your distributed system, write your tests using the simulation framework.
    <ul>
      <li>For shared datastructures that see accesses from multiple threads, one could write unit tests which check that properties are maintained using the framework.</li>
      <li>Subsystems could be tested in isolation against the simulation (for example, the storage backend could be tested against a simulation of a filesystem).</li>
      <li>And then the integration of the system could also be tested against the simulation.</li>
    </ul>
  </li>
  <li>Sufficiently high level tests would be run against the real system as well, with any unobserved behaviours or failures that cannot be replicated in the simulation the start of a refining feedback loop.</li>
  <li>Run tests continuously, using a server farm to accelerate the rate of test execution, different runs starting on different seeds; flag failures for diagnosis.</li>
  <li>Over time, refine the infrastructure. For unit test type simulations, perhaps try to find all topological sorts of triggered futures  or otherwise try to understand different dependencies (control flow, data, etc) between different tasks. For acceptance test style simulation, probably try to accelerate the feedback loop of what to do when a test fails; perhaps re-run the test up to a few minutes before so that a human can attach a debugger at a relevant point, snapshot state, etc etc. Start looking for ‘smoke’, large memory allocations or slowdowns that might not influence correctness.</li>
</ol>

<p>Because Java’s implementation of virtual threads is so general, one could also retrofit the system onto their pre-existing system. A loosely coupled system which uses a <a href="https://www.martinfowler.com/articles/injection.html">‘dependency injection’ style</a> for construction where different subsystems can be replaced with test stubs as necessary would likely find it easy to get started (similarly to writing a new system). A tightly coupled system which uses lots of static singletons would likely need some refactoring before the model could be attempted. It’s also worth saying that even though Loom is a preview feature and is not in a production release of Java, one could run their <em>tests</em> using Loom APIs with preview mode enabled, and their production code in a more traditional way.</p>

<p>My main claim is that the team that follows this path would find themselves to have commercial advantages over a more traditionally tested database. Historically, what I’ve seen is that confidence must be paid for - testing infra for distributed systems can be extremely expensive to maintain; infra becomes outdated, the software evolves, the infra becomes unrepresentative, flakes must be understood and dealt with promptly. These costs are particularly high for distributed systems. Loom-driven simulations make much of this far simpler.</p>

<h2 id="usage-in-a-real-database-raft">Usage in a real database (Raft)</h2>

<p>To demonstrate the value of an approach like this when scaled up, I challenged myself to write a toy implementation of <a href="https://raft.github.io/raft.pdf">Raft</a>, according to the simplified protocol in the paper’s figure 2 (no membership changes, no snapshotting). I chose Raft because it’s new to me (although I have some experience with Paxos), and is supposed to be hard to get right and so a good target for experimenting with bug-finding code.</p>

<p>All code is made available <a href="https://www.github.com/j-baker/loom-experiments">here</a>.</p>

<h3 id="implementation-sketch">Implementation sketch</h3>

<p>The core of the simulation is built around a <code>PriorityQueue</code> of runnable tasks. Tasks are added to this queue with a certain launch <code>Instant</code>, and the priority queue moves time forward as it processes tasks, somewhat like:</p>

<div><div><pre><code><span>class</span> <span>Simulation</span> <span>{</span>
  <span>PriorityQueue</span><span>&lt;</span><span>QueuedTask</span><span>&gt;</span> <span>taskQueue</span> <span>=</span> <span>new</span> <span>PriorityQueue</span><span>&lt;&gt;();</span>
  <span>Instant</span> <span>now</span> <span>=</span> <span>Instant</span><span>.</span><span>EPOCH</span><span>;</span>
  <span>long</span> <span>taskId</span> <span>=</span> <span>0</span><span>;</span>

  <span>boolean</span> <span>runNextTask</span><span>()</span> <span>{</span>
    <span>QueuedTask</span> <span>maybeTask</span> <span>=</span> <span>taskQueue</span><span>.</span><span>poll</span><span>();</span>
    <span>if</span> <span>(</span><span>maybeTask</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
      <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    <span>now</span> <span>=</span> <span>maybeTask</span><span>.</span><span>launchTime</span><span>;</span>
    <span>try</span> <span>{</span>
      <span>maybeTask</span><span>.</span><span>task</span><span>.</span><span>run</span><span>();</span>
    <span>}</span> <span>catch</span> <span>(</span><span>RuntimeException</span> <span>e</span><span>)</span> <span>{</span>
      <span>log</span><span>.</span><span>info</span><span>(</span><span>&#34;caught exception&#34;</span><span>,</span> <span>e</span><span>);</span>
    <span>}</span>
    <span>return</span> <span>!</span><span>taskQueue</span><span>.</span><span>isEmpty</span><span>();</span>
  <span>}</span>

  <span>Clock</span> <span>clock</span><span>()</span> <span>{</span>
    <span>return</span> <span>new</span> <span>SupplierClock</span><span>(()</span> <span>-&gt;</span> <span>now</span><span>);</span>
  <span>}</span>

  <span>void</span> <span>enqueue</span><span>(</span><span>Duration</span> <span>delay</span><span>,</span> <span>Runnable</span> <span>task</span><span>)</span> <span>{</span>
    <span>taskQueue</span><span>.</span><span>add</span><span>(</span><span>new</span> <span>QueuedTask</span><span>(</span>
      <span>now</span><span>.</span><span>plus</span><span>(</span><span>delay</span><span>),</span> <span>task</span><span>,</span> <span>taskId</span><span>++));</span>
  <span>}</span>

  <span>class</span> <span>QueuedTask</span> <span>implements</span> <span>Comparable</span><span>&lt;</span><span>QueuedTask</span><span>&gt;</span> <span>{</span>
    <span>Instant</span> <span>launchTime</span><span>;</span>
    <span>Runnable</span> <span>task</span><span>;</span>
    <span>long</span> <span>tieBreak</span><span>;</span>

    <span>QueuedTask</span><span>(</span><span>Instant</span> <span>launchTime</span><span>,</span> <span>Runnable</span> <span>task</span><span>,</span> <span>long</span> <span>tieBreak</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span><span>launchTime</span> <span>=</span> <span>launchTime</span><span>;</span>
      <span>this</span><span>.</span><span>task</span> <span>=</span> <span>task</span><span>;</span>
      <span>this</span><span>.</span><span>tieBreak</span> <span>=</span> <span>tieBreak</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>QueuedTask</span> <span>other</span><span>)</span> <span>{</span>
      <span>int</span> <span>ltc</span> <span>=</span> <span>launchTime</span><span>.</span><span>compareTo</span><span>(</span><span>other</span><span>.</span><span>launchTime</span><span>);</span>
      <span>if</span> <span>(</span><span>ltc</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>ltc</span><span>;</span>
      <span>}</span>
      <span>return</span> <span>Long</span><span>.</span><span>compare</span><span>(</span><span>tieBreak</span><span>,</span> <span>other</span><span>.</span><span>tieBreak</span><span>);</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Other primitives (such as RPC, thread sleeps) can be implemented in terms of this. Certain parts of the system need some closer attention. For example, there are many potential failure modes for RPCs that must be considered; network failures, retries, timeouts, slowdowns etc; we can encode logic that accounts for a realistic model of this.</p>

<p>For the actual Raft implementation, I follow a thread-per-RPC model, similar to many web applications. My application has HTTP endpoints (via Palantir’s <a href="https://github.com/palantir/conjure">Conjure</a> RPC framework) for implementing the Raft protocol, and requests are processed in a thread-per-RPC model similar to most web applications. Local state is held in a store (which multiple threads may access), which for purposes of demonstration is implemented solely in memory. In a production environment, there would then be two groups of threads in the system.</p>

<p><img src="https://jbaker.io/assets/images/server.jpg" alt="server" width="100%"/></p>

<ol>
  <li>Request threads (one per request, probably pooled). These access the store and mutate state in response to the requirements of the paper, they can be thought of as similar to any other HTTP API backed by a key-value store.</li>
  <li>Leadership thread (singleton). This processes the leadership state machine in response to timeouts. For simplicity, you can think of it as implementing ‘If the leader didn’t heartbeat us in the last X time, try to become the leader. If we’re the leader, make sure the other nodes are up to date with us’.</li>
</ol>

<p>Any standard methods that needed to be simulated (like <code>Clock</code>s) were replacable with test doubles.</p>

<p>The bulk of the Raft implementation can be found in <a href="https://github.com/j-baker/loom-experiments/blob/0.0.2/loom-experiments-core/src/main/java/io/jbaker/loom/raft/resource/RaftResource.java">RaftResource</a>, and the bulk of the simulation in <a href="https://github.com/j-baker/loom-experiments/blob/0.0.2/loom-experiments-core/src/test/java/io/jbaker/loom/raft/simulation/DefaultSimulation.java">DefaultSimulation</a>. The store sadly goes against my usual good code principles by heavily using setter methods, but this kept the implementation brief.</p>

<h2 id="evaluation">Evaluation</h2>

<h3 id="simulation-performance">Simulation performance</h3>

<p>The simulation was surprisingly performant. I have no clear comparison point, but on my computer with reasonable-looking latency configurations I was able to simulate about 40k Raft rounds per second on a single core, and 500k when running multiple simulations in parallel. This represents simulating hundreds of thousands of individual RPCs per second, and represents 2.5M Loom context switches per second on a single core.</p>

<p>When I cranked up the rate of timeouts and failures (leading to lots of exceptions being thrown), I saw closer to 15k requests per second processed (with about 100 leader elections during that time) and when I made performance uniformly excellent, I saw single core throughput as high as 85k Raft rounds per second.</p>

<h3 id="using-the-simulation-to-improve-protocol-performance">Using the simulation to improve protocol performance</h3>

<p>The determinism made it straightforward to understand the throughput of the system. For example, with one version of the code I was able to compute that after simulating 10k requests, the simulated system time had moved by <em>8m37s</em>. After looking through the code, I determined that I was not parallelizing calls to the two followers on one codepath. After making the improvement, after the same number of requests only <em>6m14s</em> of simulated time (and 240ms of wall clock time!) had passed. This makes it very easy to understand performance characteristics with regards to changes made.</p>

<p>When building a database, a challenging component is building a benchmarking harness. It’s challenging because the cadence at which one can surface benchmark results to developers is governed by how noisy the tests are. Many improvements and regressions represent 1-2% changes in whole-system results; if due to the benchmarking environment or the actual benchmarks 5% variance can be seen, it’s difficult to understand improvements in the short term. Due to this, many teams will either overly rely on microbenchmark results, which can be hard to understand due to Amdahl’s Law, or choose to not benchmark continuously, meaning that regressions will only be caught and sorted infrequently.</p>

<p>Deterministic scheduling entirely removes noise, ensuring that improvements over a wide spectrum can be more easily measured. Even when the improvements are algorithmic and so not represented in the time simulation, the fact that the whole cluster runs in a single core will naturally lead to reduced noise over something that uses a networking stack. Not a panacea, but an improvement for sure.</p>

<h3 id="using-the-simulation-to-test-for-correctness">Using the simulation to test for correctness</h3>

<p>Here, I found a number of bugs in my implementation. There may still be bugs, since I have no need to perfect this. However, the rough technique I ended up using was to use a Raft state machine that made it easier to detect bugs; Raft’s guarantees are</p>

<blockquote>
  <ul>
    <li><em>Election Safety</em>. At most one leader can be elected in a given term</li>
    <li><em>Leader Append-Only</em>. A leader never overwrites or deletes entries in its log; it only append new entries.</li>
    <li><em>Log Matching</em>. If two logs contain an entry with the same index and term, the logs are identical in all entries up through the given index.</li>
    <li><em>Leader completeness</em>. If a log entry is committed in a given term, then that entry will be present in the logs of the leaders for all higher-numbered terms.</li>
    <li><em>State Machine Safety</em>. If a server has applied a log entry at a given index to its state machine, no other server will ever apply a different log entry for the same index.</li>
  </ul>
</blockquote>

<p>By adding some simple hooks (such as a callback for when a new leader is elected) to the underlying servers, and to provide a state machine implementation which validates the state machine property, as well as periodically validating other state properties, I was able to continuously validate as rounds ran that the correctness properties are maintained, with liveness being testable by ensuring that the state machine continues to progress.</p>

<p>By tweaking latency properties I could easily ensure that the software continued to work in the presence of e.g. RPC failures or slow servers, and I could validate the testing quality by introducing obvious bugs (e.g. if the required quorum size is set too low, it’s not possible to make progress).</p>

<div><div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>class</span> <span>CorrectnessValidator</span> <span>implements</span> <span>Hooks</span> <span>{</span>
  <span>private</span> <span>final</span> <span>Map</span><span>&lt;</span><span>TermId</span><span>,</span> <span>ServerId</span><span>&gt;</span> <span>leaders</span> <span>=</span> <span>new</span> <span>HashMap</span><span>&lt;&gt;();</span>
  <span>private</span> <span>boolean</span> <span>incorrectnessDetected</span> <span>=</span> <span>false</span><span>;</span>
  <span>private</span> <span>final</span> <span>List</span><span>&lt;</span><span>LogEntry</span><span>&gt;</span> <span>canonicalStateMachineEntries</span> <span>=</span> <span>new</span> <span>ArrayList</span><span>&lt;&gt;();</span>

  <span>public</span> <span>void</span> <span>ensureNoBadnessFound</span><span>()</span> <span>{</span>
    <span>checkState</span><span>(!</span><span>incorrectnessDetected</span><span>,</span> <span>&#34;at some point, some form of incorrectness was found&#34;</span><span>);</span>
  <span>}</span>

  <span>@Override</span>
  <span>public</span> <span>void</span> <span>onNewLeader</span><span>(</span><span>TermId</span> <span>termId</span><span>,</span> <span>ServerId</span> <span>leader</span><span>)</span> <span>{</span>
    <span>ServerId</span> <span>currentLeader</span> <span>=</span> <span>leaders</span><span>.</span><span>putIfAbsent</span><span>(</span><span>termId</span><span>,</span> <span>leader</span><span>);</span>
    <span>checkState</span><span>(</span>
        <span>currentLeader</span> <span>==</span> <span>null</span><span>,</span>
        <span>&#34;two leaders were elected for the same&#34;</span><span>,</span>
        <span>SafeArg</span><span>.</span><span>of</span><span>(</span><span>&#34;term&#34;</span><span>,</span> <span>termId</span><span>),</span>
        <span>SafeArg</span><span>.</span><span>of</span><span>(</span><span>&#34;currentLeader&#34;</span><span>,</span> <span>currentLeader</span><span>),</span>
        <span>SafeArg</span><span>.</span><span>of</span><span>(</span><span>&#34;newLeader&#34;</span><span>,</span> <span>leader</span><span>));</span>
  <span>}</span>

  <span>public</span> <span>StateMachine</span> <span>newStateMachine</span><span>()</span> <span>{</span>
    <span>return</span> <span>new</span> <span>StateMachine</span><span>()</span> <span>{</span>
      <span>private</span> <span>LogIndex</span> <span>currentIndex</span> <span>=</span> <span>LogIndexes</span><span>.</span><span>ZERO</span><span>;</span>

      <span>@Override</span>
      <span>public</span> <span>void</span> <span>apply</span><span>(</span><span>LogIndex</span> <span>logIndex</span><span>,</span> <span>LogEntry</span> <span>entry</span><span>)</span> <span>{</span>
        <span>checkState</span><span>(</span>
            <span>logIndex</span><span>.</span><span>equals</span><span>(</span><span>LogIndexes</span><span>.</span><span>inc</span><span>(</span><span>currentIndex</span><span>)),</span>
            <span>&#34;out of order log entries passed to state machine&#34;</span><span>);</span>
        <span>if</span> <span>(</span><span>canonicalStateMachineEntries</span><span>.</span><span>size</span><span>()</span> <span>&gt;=</span> <span>logIndex</span><span>.</span><span>get</span><span>())</span> <span>{</span>
          <span>checkState</span><span>(</span>
              <span>canonicalStateMachineEntries</span>
                  <span>.</span><span>get</span><span>(</span><span>LogIndexes</span><span>.</span><span>listIndex</span><span>(</span><span>logIndex</span><span>))</span>
                  <span>.</span><span>equals</span><span>(</span><span>entry</span><span>),</span>
              <span>&#34;two state machines saw different entries for a given log index&#34;</span><span>);</span>
        <span>}</span> <span>else</span> <span>{</span>
          <span>canonicalStateMachineEntries</span><span>.</span><span>add</span><span>(</span><span>entry</span><span>);</span>
        <span>}</span>
        <span>currentIndex</span> <span>=</span> <span>logIndex</span><span>;</span>
      <span>}</span>
    <span>};</span>
  <span>}</span>

  <span>private</span> <span>void</span> <span>checkState</span><span>(</span><span>boolean</span> <span>condition</span><span>,</span> <span>String</span> <span>message</span><span>,</span> <span>SafeArg</span><span>&lt;?&gt;...</span> <span>args</span><span>)</span> <span>{</span>
    <span>if</span> <span>(!</span><span>condition</span><span>)</span> <span>{</span>
      <span>incorrectnessDetected</span> <span>=</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>Preconditions</span><span>.</span><span>checkState</span><span>(</span><span>condition</span><span>,</span> <span>message</span><span>,</span> <span>args</span><span>);</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<h2 id="conclusion-1">Conclusion</h2>

<p>I’ve found Jepsen and FoundationDB to apply two similar in idea but different in implementation testing methodologies in an extremely interesting way. Java’s Project Loom makes fine grained control over execution easier than ever before, enabling a hybridized approach to be cheaply invested in. I believe that there’s a competitive advantage to be had for a development team that uses simulation to guide their development, and usage of Loom should allow a team to dip in and out where the approach is and isn’t beneficial. Historically this approach was viable, but a gamble, since it led to large compromises elsewhere in the stack. Loom’s primitives mean that for a Java shop, the prior compromises are almost entirely absent due to the depth of integration put into making Loom work well with the core of Java, meaning that most libraries and frameworks will work with virtual threads unmodified. I think that there’s room for a library to be built that provides standard Java primitives in a way that can admits straightforward simulation (for example, something similar to <a href="https://www.scylladb.com/2016/02/16/fault-injection-filesystem-software-testing/">CharybdeFS</a> using standard Java IO primitives).</p>

<hr/>



  
</div>



      </div></div>
  </body>
</html>
