<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neugierig.org/software/blog/2023/05/retrowin32-async-dll-tracing-zig.html">Original</a>
    <h1>Retrowin32: Async, DLL loading, tracing execution, and Zig</h1>
    
    <div id="readability-page-1" class="page"><div>



<p>One demo I&#39;ve been attempted to get running under
<a href="https://neugierig.org/software/blog/2022/10/retrowin32.html">retrowin32, my win32 emulator</a>
loads <a href="https://www.un4seen.com/bass.html">an external DLL</a> to play its music and, as best
as I can tell from the disassembly, uses progress counters from playing the
music to advance the graphical state. So while I didn&#39;t especially want to
tackle DLL loading or sound, here I am!</p>
<p>In Windows, DLLs are PE files much like executables so loading one was
relatively easy. The main wrinkle is that DLLs have their own <code>DllMain()</code> that
must be invoked when the DLL is loaded for initialization purposes. In
retrowin32&#39;s architecture we previously started the CPU pointed directly at the
executable&#39;s <code>WinMain()</code> equivalent, so it took me some effort to puzzle through
how to layer things to invoke code in the proper order.</p>
<h2>Async</h2>
<p>Semantically, I wanted to write the equivalent of</p>
<pre><code>for dll in dlls {
    emulate(dll.DllMain);
}
emulate(exe.WinMain);
</code></pre>
<p>but I have no single <code>emulate</code> function like that; there is just an x86 CPU that
knows how to emulate basic blocks. In other words, the code I write in the
emulator is ordinary synchronous Rust code, while emulated x86 code is invoked
a subset at a time in a loop. But I needed to fundamentally solve this problem,
because there are plenty of Windows APIs I&#39;m implementing like
<code>DispatchMessage()</code> that need to synchronously call back into the executable&#39;s
code.</p>
<p>Ultimately what I wanted was coroutines and I managed to cobble something
together with Rust&#39;s <code>async</code> support and the result feels pretty decent. Observe
how I define
<a href="https://github.com/evmar/retrowin32/blob/ae956ef99722e6fc5ef4a1f6499f0694552f488d/win32/src/winapi/ddraw.rs#LL587C14-L587C21">EnumDisplayModes as an <code>async</code> function and it
manages to await a call to a callback</a>.</p>
<p>I&#39;m pretty sure I didn&#39;t do it quite right but it seems to at least work for my
limited purposes. It feels like it might nicely generalize to cases where
emulated code wants to synchronously perform some operation that ends up async
in the web platform (like reading files) but I haven&#39;t explored it too much yet.</p>
<h2>Failed self-check</h2>
<p>In any case, once I had DLL loading roughly in place, I found this particular
library&#39;s initialization code performs some sort of self-check and fails with a
<code>MessageBox()</code>: &#34;This file has been tampered with and MAY BE INFECTED BY A
VIRUS!&#34;</p>
<p>What this actually points to is some bug in the emulator; running the program on
a native Windows machine is fine. But how can I isolate the bug? Via a
disassembler I can see that the initialization code runs a bunch of loops over
memory and at some point things go wrong ... but where?</p>
<p>I had been putting it off, but a friend earlier gave me the idea that I could
write a program that traces execution on a native Windows machine. That program
can dump state at various points, and then similarly make the emulator can dump
state at those same points, and I could then compare traces between the two to
find where I diverge. So I wrote that program.</p>
<h2>Windows debugger</h2>
<p>This is a native Windows program that spawns another program (the debuggee) and
uses the Windows debugger API to introspect its behavior.</p>
<p>For extra fun credit
<a href="https://github.com/evmar/retrowin32/blob/main/exe/trace/trace.zig">I wrote it in Zig</a>,
which has a really pleasant cross-compilation story and which generates a tiny
executable (23kb so far!). It&#39;s been pretty interesting how writing code in an
environment where allocating memory is just a little bit less convenient
naturally leads you down paths where you don&#39;t wantonly allocate. One last
highlight I appreciated is that Zig models
<a href="https://ziglang.org/documentation/master/#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a>
in its type system which was particularly important to get right when shoveling
parsed command-line argument slices into calls into the Windows library that
wants NUL-terminated strings.</p>
<p>There are downsides too. Zig is basically a statically typed language with a
large compile-time component that is effectively dynamically typed. I think this
is a really fascinating tradeoff to explore but so far it has some pretty rough
edges that I am not sure they will be able to solve, particularly around
build-time tooling; much like writing Python, a lot of the errors you get are of
the form &#34;I ran a bunch of code and something went wrong&#34; and there&#39;s not much
better it can do.
(<a href="https://matklad.github.io/2023/03/26/zig-and-rust.html">This blog post</a> is
worth your time.) For similar reasons it also feels relatively easy to create
references to un-nameable types (like my <code>stdout</code> variable in the above). There
are also plenty of smaller clunky bits (such as incomplete docs) but I
appreciate the language is in development and I&#39;m not as concerned about those
as I am about the fundamental model.</p>
<p>I hadn&#39;t before explored how a debugger works, so let me tell you the
interesting part. My program wants to say &#34;when the CPU hits the instruction at
address <em>X</em>, stop execution and let me do something&#34;. To do this you just
overwrite address <em>X</em> with an <code>int3</code> instruction, which is helpfully just the
single byte 0xcc (which also now possibly explains
<a href="http://0xcc.net/">my old friend&#39;s choice of domain name</a>). Once the program
hits that address it suspends and hands control back to the debugger.</p>
<p>To resume execution, the debugger needs to repair the program by (1) writing the
previous code back over the <code>int3</code>, (2) backing up the instruction pointer by
one to resume execution starting at address <em>X</em>, and (3) setting a CPU flag so
the CPU single-steps. This last part allows the debugger to single-step execute
the repaired instruction and then immediately repatch it back to the <code>int3</code> so
that it can intercept the next execution.</p>
<p>Unfortunately, at least so far, my emulator trace matches my native Windows one,
so the ultimate fix here will be something I still need to track down.</p>
<h2>A bit of progress</h2>
<p>As a reward for reading this far, you can see
<a href="https://evmar.github.io/retrowin32/debugger.html?dir=monolife/&amp;exe=monolife.exe&amp;file=monolife.dat&amp;file=BASS.DLL">the demo in question render
some graphics</a>
(click &#39;run&#39; once it loads). This relies on the above async support for invoking
some callbacks (from DirectDraw back into the executable), but with the DLL bits
stubbed out because they don&#39;t work yet.</p>

</div></div>
  </body>
</html>
