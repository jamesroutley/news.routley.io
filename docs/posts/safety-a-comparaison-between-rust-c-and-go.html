<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nested.substack.com/p/safety">Original</a>
    <h1>Safety: A comparaison between Rust, C&#43;&#43; and Go</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><p><em><span>This post presents a lot of code as screenshots.  The complete code is available for download at </span><a href="https://github.com/jeffs/nested/tree/main/safety" rel="">github.com/jeffs/nested/safety</a><span>.  Leave a comment if screenshots make you </span></em><span>üòç</span><em> or </em><span>üò°</span><em>.</em></p><p><span>Memory safety is a hot topic these days.  (For example, it‚Äôs one of </span><a href="https://nested.substack.com/p/carbon-the-would-be-c-successor" rel="">Carbon</a><span>‚Äôs primary goals.)  While everyone seems to agree that memory safety is really important, what actually constitutes </span><em>safety</em><span> remains subjective.  This week, we‚Äôll peek at semantically equivalent Rust, C++, and Go code to see how their approaches to safety differ.</span></p><p>First, consider a simple append() function that concatenates two lists of integers:</p><p><span>This is pretty straightforward, and doesn‚Äôt pose a challenge for any of our three languages.  Things get more interesting if we define a function that takes only the suffix parameter, but returns a brand new function (a </span><em>closure</em><span>) that can append the suffix to any given list of items:</span></p><p><span>The Rust make_appender‚Äôs return type includes the </span><em>lifetime</em><span> </span><code>&#39;_</code><span>, expressing an important property of the function.  It means, basically:  ‚ÄúYou passed me a pointer to something.  The value I return is only good as long as that object is still alive.‚Äù  It‚Äôs like an expiration date for in-memory objects:  If the original argument is destroyed, then the function‚Äôs return value expires, and you can‚Äôt use it anymore.  For example, let‚Äôs try calling the Rust closure after the original suffix object goes out of scope:</span></p><p>Rust won‚Äôt let pointers dangle as C++ would, nor will it have a Garbage Collector (GC) keep the original object‚Äôs memory on life support.  (It‚Äôs common for GCs to keep memory alive even after you destroy/close/dispose an object, even though the object is useless, just so extant pointers to it don‚Äôt dangle.)</p><p>C++ does not handle this situation well:</p><p><span>The suffix object {3, 4} in our C++ test is implicitly destroyed before the assertion even executes.  Why doesn‚Äôt it survive to the end of the function?  Just a weirdness of C++.  Once the suffix object is destroyed, the closure (append34) is broken.  It has a pointer to the memory where the suffix object used to live, but the object doesn‚Äôt live there anymore.  The compiler doesn‚Äôt catch this, even with the warnings cranked up.  Insead, we get </span><em>undefined behavior</em><span> (UB) at run time.  We‚Äôre lucky the test happened to fail; sometimes, UB manages to corrupt memory (making a program do bad things) without failing any tests.</span></p><p><span>To make C++ do the right thing, we have to </span><em>move</em><span> the suffix into the closure:</span></p><p>Go fares much better.  Not only does it compile, it actually works as intended:</p><p><span>Preventing dangling pointers and undefined behavior is what most people mean when they talk about memory safety, but there‚Äôs more to the story.  As you may have heard, </span><a href="https://nested.substack.com/p/to-share-or-to-mutate" rel="">shared mutable state is evil</a><span>.  Rust‚Äôs major innovation is to guarantee that mutable state is never shared, and shared state is never mutated.</span></p><p>For example, suppose that after calling make_appender, we mutate the suffix object.  Should subsequent calls to the returned closure use the original value, or the new one?</p><p>Rust does the only sane thing it can in this situation:  It refuses to compile the code.  Guess what C++ does?</p><p>You guessed it: undefined behavior!  Again, the C++ compiler is of no help.  Instead of a failed test, this time we managed a segfault.</p><p>Go compiles and runs, and lets the mutation proceed, such that modifying the suffix object becomes a backdoor way to change the behavior of the closure:</p><p>We could debate whether Go‚Äôs behavior makes sense, but allowing this kind of spooky action at a distance opens the door to a host of heinous bugs.  This problem isn‚Äôt specific to Go in particular; in fact, Go is a great example of a modern garbage-collected language.  Ownership is rarely clear in GC languages, because really, everything is sort of part-owned by the garbage collector.  You may think your object owns its constituent parts, but the GC has a lien against them.  GC languages could, in principle, have move semantics and other niceties; but in practice, they do not.</p><div><figure><a target="_blank" rel="nofollow" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F743460a8-6e7d-4a9f-85d5-df367b6bd3f9_968x702.png"><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F743460a8-6e7d-4a9f-85d5-df367b6bd3f9_968x702.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F743460a8-6e7d-4a9f-85d5-df367b6bd3f9_968x702.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F743460a8-6e7d-4a9f-85d5-df367b6bd3f9_968x702.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F743460a8-6e7d-4a9f-85d5-df367b6bd3f9_968x702.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F743460a8-6e7d-4a9f-85d5-df367b6bd3f9_968x702.png" width="968" height="702" data-attrs="{&#34;src&#34;:&#34;https://bucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com/public/images/743460a8-6e7d-4a9f-85d5-df367b6bd3f9_968x702.png&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:702,&#34;width&#34;:968,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:530703,&#34;alt&#34;:&#34;\&#34;All the things\&#34; meme:  ALL THE OBJECTS... ARE PARTIALLY OWNED BY THE GARBAGE COLLECTOR&#34;,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true}" alt="&#34;All the things&#34; meme:  ALL THE OBJECTS... ARE PARTIALLY OWNED BY THE GARBAGE COLLECTOR" title="&#34;All the things&#34; meme:  ALL THE OBJECTS... ARE PARTIALLY OWNED BY THE GARBAGE COLLECTOR" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F743460a8-6e7d-4a9f-85d5-df367b6bd3f9_968x702.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F743460a8-6e7d-4a9f-85d5-df367b6bd3f9_968x702.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F743460a8-6e7d-4a9f-85d5-df367b6bd3f9_968x702.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F743460a8-6e7d-4a9f-85d5-df367b6bd3f9_968x702.png 1456w" sizes="100vw" loading="lazy"/></picture></a></figure></div><p>We‚Äôve covered a lot of ground in this post, but there‚Äôs a great deal more to discuss, such as how object lifetimes, shared state, and mutation interact with concurrency and parallellism.  Please leave a comment if you feel we should (or should not!) dig deeper into this topic, or if Rust, C++, and Go aren‚Äôt the languages you‚Äôd most like to see in future posts.</p></div></div></div></article></div></div></div>
  </body>
</html>
