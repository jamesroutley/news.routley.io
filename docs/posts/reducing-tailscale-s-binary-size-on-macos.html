<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tailscale.com/blog/macos-binary-size/">Original</a>
    <h1>Reducing Tailscale’s binary size on macOS</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>A few months ago I was poking around the package contents of Tailscale’s macOS app when I happened to notice that the main <code>Tailscale</code> binary was surprisingly large — more than 37 megabytes. Some of the size is explained by it being a <a href="https://developer.apple.com/documentation/apple-silicon/building-a-universal-macos-binary">universal app</a> — it includes both <code>x86_64</code> (for Intel-based Macs) and <code>arm64</code> slices (for Apple silicon ones). However, even when accounting for that, it seemed too large for what is mostly a UI wrapper — the core logic lives in a <a href="https://developer.apple.com/documentation/networkextension">network extension</a>. In fact, looking at that extension (<code>IPNExtension.appex</code>), I was surprised to find that it was only slightly smaller (36.5 MB).</p>

    
    

<figure>
        <img src="https://tailscale.com/assets/84113/1676487724-before.png" alt="Contents of the v1.34 Tailscale.app package, highlighting that both the main executable and the network extension are around 36MB"/>
    
</figure>

<p>Inspecting the main executable with <a href="https://www.hopperapp.com/">Hopper</a> showed a lot of unlabeled functions, which was not immediately helpful. Running <code>strings</code> on it showed a lot of Go package names, which was the clue that I needed: we were including Tailscale’s open source <a href="https://github.com/tailscale/tailscale">Go core</a> not just in the extension (expected), but in the main app itself. This also explained the very similar binary sizes.</p>
<p>I thought this would be a quick size win, so I removed the static library that we generate from our Go code from the main app’s dependencies… and promptly got a linker error: “<a href="https://github.com/tailscale/tailscale/blob/71029cea2ddf82007b80f465b256d027eab0f02d/cmd/tailscale/cli/cli.go#L50-L94"><code>ActLikeCLI</code></a> is not defined.” I now had my explanation for why we included the Go code in the main app: Tailscale <a href="https://tailscale.com/kb/1080/cli/">has a CLI interface</a>, and on macOS it’s invoked by <a href="https://tailscale.com/kb/1080/cli/?tab=macos#using-the-cli">running the regular app</a> from the command line.</p>
<p>Knowing that the app only needed the CLI bits of the Go code, I set about generating a separate static library with just that, figuring it would be a lot smaller. However, as I started to get lost in a maze of twisty little <a href="https://github.com/apenwarr/redo">redo</a> rules, <a href="https://en.wikipedia.org/wiki/Colossal_Cave_Adventure#:~:text=Additionally%2C%20in%20the,result.%5B39%5D">all alike</a>, I began to reconsider. Even if I got this to work, would there be a significant size savings? The CLI static library would still end up including its own copy of the Go runtime and code that is shared with the Tailscale backend. Looking at the Linux version of Tailscale, the <code>tailscale</code> binary (which is just the CLI) is still more than half the size of <code>tailscaled</code> (the backend daemon) — 14 MB vs. 24 MB.</p>
<p>I decided to approach the CLI invocation from first principles. All the Mac app really needs to do is invoke the <a href="https://github.com/tailscale/tailscale/blob/71029cea2ddf82007b80f465b256d027eab0f02d/cmd/tailscale/cli/cli.go#L128-L129"><code>Run</code> function</a> from Tailscale’s <code>cli</code> Go package. Most of the time the Go code is already running (in the network extension), and there’s <a href="https://github.com/tailscale/tailscale/blob/main/ipn/localapi/localapi.go">a local HTTP server</a> that the app uses. We could add a <code>/localapi/v0/cli</code> endpoint and have the app invoke it. However, I hesitated to do this. This was partly because it would add yet more states and edge cases: what if the backend is not running, or what if a local firewall blocks the request? We also knew that these local endpoints are scrutinized for security reasons, and are wary of adding such powerful ones.</p>
<p>Letting my mind wander a bit, I was reminded of two tidbits:</p>
<ol>
<li>Tailscale can be built in a mode where it <a href="https://tailscale.com/kb/1207/small-tailscale/#step-1-building-tailscale">combines the backend and CLI into one binary</a>, for extra size savings. </li>
<li>Some programs (most memorably <a href="https://neugierig.org/software/chromium/notes/2009/01/startup.html#:~:text=Chrome%20is%20built%20as%20a%20.exe%20and%20.dll%20pair%2C%20where%20the%20exe%20just%20calls%20the%20one%20exported%20function%20from%20the%20DLL%2C%20called%20ChromeMain().">Chrome</a>) just have a very small shell binary, with the bulk of the logic being in a separate library that is loaded and invoked at startup.</li>
</ol>
<p>I wondered if this approach could be taken here: the network extension already has the combined binary, including the CLI logic — so what if we treated it as a shared library that we could load and call functions from, when the app needs to run in CLI mode? Some playing around with <code>dlopen</code> and <code>dlsym</code> showed that it could work. Here’s a sketch of what I ended up with (all of the error-handling has been omitted):</p>
<div><pre tabindex="0"><code data-lang="swift"><span><span><span>// Generate path to the app extension binary.</span>
</span></span><span><span><span>let</span> <span>plugInsURL</span> <span>=</span> <span>Bundle</span><span>.</span><span>main</span><span>.</span><span>builtInPlugInsURL</span>
</span></span><span><span><span>let</span> <span>extensionURL</span> <span>=</span> <span>plugInsURL</span><span>.</span><span>appendingPathComponent</span><span>(</span>
</span></span><span><span>  <span>&#34;IPNExtension.appex/Contents/MacOS/IPNExtension&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>// Open the extension binary as a shared library and find</span>
</span></span><span><span><span>// the CLI entrypoint symbol.</span>
</span></span><span><span><span>let</span> <span>extensionHandle</span> <span>=</span> <span>dlopen</span><span>(</span><span>extensionURL</span><span>.</span><span>path</span><span>,</span> <span>RTLD_LOCAL</span><span>)</span>
</span></span><span><span><span>let</span> <span>goBeCLISymbol</span> <span>=</span> <span>dlsym</span><span>(</span><span>extensionHandle</span><span>,</span> <span>&#34;goBeCLI&#34;</span><span>&#39;</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>// Invoke the goBeCLI symbol.</span>
</span></span><span><span><span>typealias</span> <span>goBeCLIType</span> <span>=</span> <span>@</span><span>convention</span><span>(</span><span>c</span><span>)</span> <span>(</span><span>UnsafePointer</span><span>&lt;</span><span>Int8</span><span>&gt;)</span> <span>-&gt;</span> <span>Void</span>
</span></span><span><span><span>let</span> <span>dir</span> <span>=</span> <span>...</span> <span>// URL to the app sandbox directory</span>
</span></span><span><span><span>dir</span><span>.</span><span>path</span><span>.</span><span>withCString</span> <span>{</span>
</span></span><span><span>  <span>goBeCLI</span><span>(</span><span>$0</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// Unreachable beyond this point, Go does an os.Exit.</span>
</span></span></code></pre></div><p>The real code ended up being slightly more complicated, because it needs to handle Tailscale’s <a href="https://tailscale.com/kb/1065/macos-variants/">standalone variant</a>, which has the network extension at a different path. The only other gotcha was that we had to make sure that <code>goBeCLI</code> was in <a href="https://developer.apple.com/documentation/xcode/build-settings-reference#Exported-Symbols-File">our exported symbols list</a>; otherwise, the linker would remove it when doing dead code stripping.</p>

    
    

<figure>
        <img src="https://tailscale.com/assets/84113/1676487805-after.png" alt="Contents of the v1.36 Tailscale.app package, highlighting that both the main executable is now only 1.5MB"/>
    
</figure>

<p>This change shipped with Tailscale v1.36, and it was very satisfying to check the binary size for it — 35 MB smaller than v1.34. In addition to scratching my optimization itch, it should result in faster download and update times for everyone.</p>

    </div></div>
  </body>
</html>
