<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2022/faster-sorting-with-go-generics/">Original</a>
    <h1>Faster Sorting with Go Generics</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
    <section id="content">
        <article>
            
            <div>
                
                <p>Recently, a new set of sorting functions <a href="https://go-review.googlesource.com/c/exp/+/378134">has landed</a> in Go&#39;s
<tt>golang.org/exp/slices</tt> package <a href="#id4" id="id1">[1]</a>. These functions leverage Go generics
to provide a more ergonomic API for sorting (without requiring users to
implement <a href="https://pkg.go.dev/sort#Interface">sort.Interface</a>), and also
deliver a nice performance improvement, as the CL demonstrates.</p>
<p>In this post, I&#39;ll dive deep into <em>why</em> these generic functions are faster than
the existing ones in the <tt>sort</tt> package, even though they use precisely
the same algorithm and loop structure. This should hopefully be an interesting
peek into how Go generics are implemented, in comparison to the existing
dynamic dispatch mechanism (interfaces).</p>
<p>To decouple our discussion from the messy specifics of the Go standard library
and experimental repositories, and to be able to focus on a smaller, simpler
code sample, I&#39;ve reimplemented this comparison on a simpler sorting algorithm,
where the performance difference also manifests <a href="#id5" id="id2">[2]</a>.</p>
<div id="bubble-sort">
<h2>Bubble sort</h2>
<p>Let&#39;s implement good old <a href="https://en.wikipedia.org/wiki/Bubble_sort">bubble sort</a>!</p>
<p><img alt="Bubblesort animation from Wikipedia" src="https://eli.thegreenplace.net/images/2022/bubblesort-wikipedia-animation.gif"/></p><p>The full code for this post, along with tests and benchmarks is
<a href="https://github.com/eliben/code-for-blog/tree/master/2022/genericsort">available on GitHub</a>.
Here&#39;s a simple bubble sort implementation using a Go interface for
customization:</p>
<div><pre><span></span><span>func</span> <span>bubbleSortInterface</span><span>(</span><span>x</span> <span>sort</span><span>.</span><span>Interface</span><span>)</span> <span>{</span>
  <span>n</span> <span>:=</span> <span>x</span><span>.</span><span>Len</span><span>()</span>
  <span>for</span> <span>{</span>
    <span>swapped</span> <span>:=</span> <span>false</span>
    <span>for</span> <span>i</span> <span>:=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
      <span>if</span> <span>x</span><span>.</span><span>Less</span><span>(</span><span>i</span><span>,</span> <span>i</span><span>-</span><span>1</span><span>)</span> <span>{</span>
        <span>x</span><span>.</span><span>Swap</span><span>(</span><span>i</span><span>,</span> <span>i</span><span>-</span><span>1</span><span>)</span>
        <span>swapped</span> <span>=</span> <span>true</span>
      <span>}</span>
    <span>}</span>
    <span>if</span> <span>!</span><span>swapped</span> <span>{</span>
      <span>return</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</pre></div>
<p>As a reminder, <a href="https://pkg.go.dev/sort#Interface">sort.Interface</a> is an
interface defined in Go&#39;s <tt>sort</tt> package, and looks like this:</p>
<div><pre><span></span><span>type</span> <span>Interface</span> <span>interface</span> <span>{</span>
  <span>Len</span><span>()</span> <span>int</span>
  <span>Less</span><span>(</span><span>i</span><span>,</span> <span>j</span> <span>int</span><span>)</span> <span>bool</span>
  <span>Swap</span><span>(</span><span>i</span><span>,</span> <span>j</span> <span>int</span><span>)</span>
<span>}</span>
</pre></div>
<p>The <tt>sort</tt> package also provides useful type adapters to imbue
<tt>sort.Interface</tt> onto common slice types. For example, <tt>sort.StringSlice</tt>
makes a <tt>[]string</tt> implement this interface in a way that sorts elements in
ascending order, and we can write something like:</p>
<div><pre><span></span><span>var</span> <span>ss</span> <span>[]</span><span>string</span>
<span>// ... code that populates ss</span>
<span>bubbleSortInterface</span><span>(</span><span>sort</span><span>.</span><span>StringSlice</span><span>(</span><span>ss</span><span>))</span>
</pre></div>
</div>
<div id="generic-bubble-sort">
<h2>Generic bubble sort</h2>
<p>Here&#39;s a generic bubble sort, for a slice of types that implement
<a href="https://pkg.go.dev/golang.org/x/exp/constraints#Ordered">constraints.Ordered</a>:</p>
<div><pre><span></span><span>func</span> <span>bubbleSortGeneric</span><span>[</span><span>T</span> <span>constraints</span><span>.</span><span>Ordered</span><span>](</span><span>x</span> <span>[]</span><span>T</span><span>)</span> <span>{</span>
  <span>n</span> <span>:=</span> <span>len</span><span>(</span><span>x</span><span>)</span>
  <span>for</span> <span>{</span>
    <span>swapped</span> <span>:=</span> <span>false</span>
    <span>for</span> <span>i</span> <span>:=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
      <span>if</span> <span>x</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>x</span><span>[</span><span>i</span><span>-</span><span>1</span><span>]</span> <span>{</span>
        <span>x</span><span>[</span><span>i</span><span>-</span><span>1</span><span>],</span> <span>x</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>x</span><span>[</span><span>i</span><span>],</span> <span>x</span><span>[</span><span>i</span><span>-</span><span>1</span><span>]</span>
        <span>swapped</span> <span>=</span> <span>true</span>
      <span>}</span>
    <span>}</span>
    <span>if</span> <span>!</span><span>swapped</span> <span>{</span>
      <span>return</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</pre></div>
<p>As you can see, the code is exactly the same except that we can use <tt>len</tt>,
<tt>&lt;</tt> and swapping with multiple assignment directly instead of deferring to
interface methods. This is possible because the function knows important things
about what it&#39;s sorting: that it&#39;s a slice and also that it implements
<tt>Ordered</tt>.</p>
</div>
<div id="benchmarking">
<h2>Benchmarking</h2>
<p>I&#39;ve benchmarked these two implementations against each other by sorting a
randomly-generated slice of 1000 strings; here are the results on my machine:</p>
<div><pre><span></span>$ go test -bench=.
goos: linux
goarch: amd64
pkg: example.com
cpu: Intel(R) Core(TM) i7-4771 CPU @ 3.50GHz
BenchmarkSortStringInterface-8             124           9599141 ns/op
BenchmarkSortStringGeneric-8               158           7433097 ns/op
</pre></div>
<p>The generic version is over 20% faster. This is great news, overall. Go
generics not only delivers a convenient way to write code that acts on multiple
types, but can also provide performance benefits!</p>
<p>In the rest of this post, we&#39;ll discuss <em>why</em> generics is faster here.</p>
</div>
<div id="analyzing-the-interface-version">
<h2>Analyzing the interface version</h2>
<p>In the <a href="https://github.com/eliben/code-for-blog/tree/master/2022/genericsort">code accompanying this post</a>, I
have a standalone runner program that&#39;s useful for profiling. It creates a large
slice and sorts it using one of the methods provided on the command-line; it
also enables pprof-based CPU profiling. Let&#39;s see how this looks for our
interface-based bubble sort:</p>
<div><pre><span></span>$ ./bubble.out -cpuprofile cpui.out -kind strinterface
$ go tool pprof -list bubbleSortInterface ./bubble.out cpui.out
&lt;...&gt;
ROUTINE ======================== main.bubbleSortInterface
     350ms      1.10s (flat, cum)   100% of Total
         .          .     26:
         .          .     27:func bubbleSortInterface(x sort.Interface) {
         .          .     28: n := x.Len()
         .          .     29: for {
         .          .     30:         swapped := false
      70ms       70ms     31:         for i := 1; i &lt; n; i++ {
     160ms      830ms     32:                 if x.Less(i, i-1) {
      20ms      100ms     33:                         x.Swap(i, i-1)
         .          .     34:                         swapped = true
         .          .     35:                 }
         .          .     36:         }
     100ms      100ms     37:         if !swapped {
         .          .     38:                 return
         .          .     39:         }
         .          .     40: }
         .          .     41:}
         .          .     42:
</pre></div>
<p>As expected, the program spends most of its time in the inner loop doing
comparisons and swaps, but mostly just comparisons. Bubble sort does O(N^2)
comparisons for a sequence of length N.</p>
<p>If the majority of the time is spent on comparisons, it&#39;s interesting to examine
what that actually entails; what instructions does the CPU execute while
calling <tt>x.Less</tt> in this code? Luckily, I&#39;ve recently written <a href="https://eli.thegreenplace.net/2022/interface-method-calls-with-the-go-register-abi/">another blog
post on exactly this topic</a>!
I recommend that you at least skim it, but the important part for our purpose
is that calling <tt>x.Less</tt> means this sequence of instructions:</p>
<div><pre><span></span>MOVQ  0x48(SP), DX
MOVQ  0x20(DX), SI
LEAQ  -0x1(CX), DI
MOVQ  DI, 0x30(SP)
MOVQ  0x50(SP), AX
MOVQ  CX, BX
MOVQ  DI, CX
NOPL
CALL  SI
</pre></div>
<p>In our code, we&#39;re running <tt>bubbleSortInterface(sort.StringSlice(ss))</tt>, so we
have to turn to <tt>sort.StringSlice</tt> for the definition of the actual <tt>Less</tt>
method that&#39;s going to be invoked:</p>
<div><pre><span></span><span>func</span> <span>(</span><span>x</span> <span>StringSlice</span><span>)</span> <span>Less</span><span>(</span><span>i</span><span>,</span> <span>j</span> <span>int</span><span>)</span> <span>bool</span> <span>{</span> <span>return</span> <span>x</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>x</span><span>[</span><span>j</span><span>]</span> <span>}</span>
</pre></div>
<p>In assembly, it looks like this:</p>
<div><pre><span></span>CMPQ  0x10(R14), SP
JBE   0x4664d1
SUBQ  $0x28, SP
MOVQ  BP, 0x20(SP)
LEAQ  0x20(SP), BP
MOVQ  AX, 0x30(SP)
CMPQ  DI, BX
JBE   0x4664c5
SHLQ  $0x4, DI
MOVQ  0(DI)(AX*1), DX
MOVQ  0x8(DI)(AX*1), R8
CMPQ  SI, BX
JBE   0x4664b8
SHLQ  $0x4, SI
MOVQ  0(AX)(SI*1), CX
MOVQ  0x8(AX)(SI*1), DI
MOVQ  DX, AX
MOVQ  R8, BX
CALL  runtime.cmpstring(SB)
TESTQ AX, AX
SETL  AL
MOVQ  0x20(SP), BP
ADDQ  $0x28, SP
RET
</pre></div>
<p>If this looks longer than you&#39;ve expected, it&#39;s because slice indexing in Go is
protected against out-of-bounds access, and the comparisons we see at the
beginning of the function are precisely that - jumping to a portion of the code
(which I didn&#39;t include, for brevity) that invokes <tt>runtime.panicIndex</tt>. At
last, the actual string comparison is performed with a call to
<tt>runtime.cmpstring</tt>; this, on its own, is a pretty interesting function that&#39;s
implemented in assembly for the common architectures (<a href="https://cs.opensource.google/go/go/+/master:src/internal/bytealg/compare_amd64.s;l=19?q=cmpstring&amp;ss=go%2Fgo&amp;start=11">for example AMD64</a>),
but let&#39;s stop the rabbit hole here, since this part will be shared across both
the implementations we&#39;re comparing.</p>
<p>Now we should have a fairly comprehensive understanding of where the CPU spends
its time when running bubble sort using the interface dispatch version. Let&#39;s
turn our attention to the generic version.</p>
</div>
<div id="detour-how-generics-are-implemented-in-go-1-18">
<h2>Detour: how generics are implemented in Go 1.18</h2>
<p>Russ Cox has a short and excellent blog post titled <a href="https://research.swtch.com/generic">The Generic Dilemma</a>. Its main claim is that when a language
decides on whether to have generics and how to implement them, it faces the
following decision:</p>
<blockquote>
do you want slow programmers, slow compilers and bloated binaries, or slow
execution times?</blockquote>
<p>&#34;Slow compilers and bloated binaries&#34; refers to the C++ approach of implementing
templates by <a href="https://en.wikipedia.org/wiki/Monomorphization">full monomorphization</a> - each template invocation
is treated a bit like a macro expansion with its full code copy-pasted with the
right types.</p>
<p>&#34;Slow execution times&#34; refers to the Java approach of boxing, or to dynamic
languages where code is trivially generic due to transparent dynamic dispatch
on every call.</p>
<p>Please note that none of these descriptions are meant to be denigratory; these
are all real tradeoffs language designers face, Go included.</p>
<p>Specifically, Go has seriously considered both monomorphization (called
&#34;stenciling&#34; in the Go world) and dynamic dispatch (called &#34;dictionaries&#34; in the
Go world):</p>
<ul>
<li><a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/generics-implementation-stenciling.md">Generics implementation - Stenciling design doc</a></li>
<li><a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/generics-implementation-dictionaries.md">Generics implementation - Dictionaries design doc</a></li>
</ul>
<p>Neither approach is perfect on its own, due to the reasons stated above.
Therefore, another design was proposed:</p>
<ul>
<li><a href="https://github.com/golang/proposal/blob/master/design/generics-implementation-gcshape.md">Generics implementation - GC Shape Stenciling</a></li>
</ul>
<p>This &#34;GC shape&#34; approach is a compromise between the two extremes of stenciling
and dictionaries. Depending on the instantiated type we either monomorphize or
use dynamic dispatch. There is a <a href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md">more up-to-date document</a>
that describes how Go 1.18 does this in detail.</p>
<p>Specifically, different underlying types like <tt>int</tt>s and <tt>string</tt>s will
get their own GC shape, meaning that a different function will be generated for
each, with the types hard-coded (so this is monomorphization). On the other
hand, all pointer types will be grouped in the same GC shape and will use
dynamic dispatch.</p>
<p>Note that this is the state of the world in Go 1.18; it may, and most likely
<em>will</em> change in the future, as the Go team is teaming up with the community
to learn what works best for real-life workloads.</p>
</div>
<div id="analyzing-the-generic-version">
<h2>Analyzing the generic version</h2>
<p>If we use pprof to analyze the generic version, we&#39;ll see that it also spends
the majority of its time in comparisons, but overall less time than the
interface version.</p>
<p>As discussed in the previous section, a <tt>string</tt> type will get its own GC
shape and therefore its own function hard-coded for the <tt>string</tt> type. Let&#39;s
see how this looks in the assembly.</p>
<p>First, rummaging through the debug information of the binary we&#39;ll find the
symbol <tt>bubbleSortGeneric[go.shape.string_0]</tt> which represents the stenciled
version of <tt>bubbleSortGeneric</tt> for the GC shape that <tt>string</tt> is currently
the only member of. We won&#39;t find it as a standalone function to call, though,
since it&#39;s inlined into its call site. This inlining does not affect performance
in any way, so we&#39;ll just focus on the instructions for the inner loop that,
to remind you, does this:</p>
<div><pre><span></span><span>for</span> <span>i</span> <span>:=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
  <span>if</span> <span>x</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>x</span><span>[</span><span>i</span><span>-</span><span>1</span><span>]</span> <span>{</span>
    <span>x</span><span>[</span><span>i</span><span>-</span><span>1</span><span>],</span> <span>x</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>x</span><span>[</span><span>i</span><span>],</span> <span>x</span><span>[</span><span>i</span><span>-</span><span>1</span><span>]</span>
    <span>swapped</span> <span>=</span> <span>true</span>
  <span>}</span>
<span>}</span>
</pre></div>
<p>And it translates to this assembly:</p>
<div><pre><span></span>MOVQ  0x80(SP), R8
INCQ  R8
MOVQ  0x70(SP), CX
MOVQ  0x78(SP), BX
MOVQ  R8, DX
MOVL  AX, SI
MOVQ  0xb0(SP), AX
CMPQ  DX, BX
JLE   0x4aef20
MOVQ  DX, 0x80(SP)
MOVB  SI, 0x3d(SP)
MOVQ  DX, SI
SHLQ  $0x4, DX
MOVQ  DX, 0x90(SP)
MOVQ  0(DX)(AX*1), R8
MOVQ  0x8(DX)(AX*1), BX
LEAQ  -0x1(SI), R9
SHLQ  $0x4, R9
MOVQ  R9, 0x88(SP)
MOVQ  0(R9)(AX*1), CX
MOVQ  0x8(R9)(AX*1), DI
MOVQ  R8, AX
CALL  runtime.cmpstring(SB)
MOVQ  0xb0(SP), DX
MOVQ  0x90(SP), SI
LEAQ  0(SI)(DX*1), DI
MOVQ  0x88(SP), R8
LEAQ  0(R8)(DX*1), R9
TESTQ AX, AX
JGE   0x4af01a
</pre></div>
<p>The first thing to note is that there is no dynamic dispatch to the <tt>Less</tt>
method. Each loop iteration invokes <tt>cmpstring</tt> directly. Second, the latter
part of the assembly resembles the code of <tt>Less</tt> shown earlier, with one
crucial difference - there are no bounds checks! Go includes a
<a href="https://go101.org/article/bounds-check-elimination.html">bounds-check elimination (BCE) pass</a>
which can get rid of the bounds checks for the comparison:</p>
<div><pre><span></span><span>// ... earlier we had n := len(x)</span>
<span>for</span> <span>i</span> <span>:=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
  <span>if</span> <span>x</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>x</span><span>[</span><span>i</span><span>-</span><span>1</span><span>]</span> <span>{</span>
</pre></div>
<p>The compiler knows that <tt>i</tt> is between 1 and <tt>len(x)</tt> at all times (by
looking at the loop description and the fact that <tt>i</tt> is not otherwise
modified <a href="#id6" id="id3">[3]</a>) and hence that <tt>x[i]</tt> and <tt><span>x[i-1]</span></tt> are both safely accessing
the slice in-bounds.</p>
<p>In the interface version, the compiler does not eliminate
the bounds checks from <tt>Less</tt>; the function is defined like this:</p>
<div><pre><span></span><span>func</span> <span>(</span><span>x</span> <span>StringSlice</span><span>)</span> <span>Less</span><span>(</span><span>i</span><span>,</span> <span>j</span> <span>int</span><span>)</span> <span>bool</span> <span>{</span> <span>return</span> <span>x</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>x</span><span>[</span><span>j</span><span>]</span> <span>}</span>
</pre></div>
<p>And who knows what indices are passed in! Moreover, because of the dynamic
dispatch this function is not inlined its caller, where the compiler could
perhaps have more insight into what&#39;s going on. The Go compiler has some
devurtualization capabilities, but they don&#39;t kick in here. This is
an additional interesting area of compiler improvements.</p>
</div>
<div id="generic-sort-with-a-custom-comparison-function">
<h2>Generic sort with a custom comparison function</h2>
<p>To verify some of the observations described earlier, I&#39;ve implemented another
version of the generic bubble sort; this time, without relying on
<tt>constraints.Ordered</tt> but using a comparison function instead:</p>
<div><pre><span></span><span>func</span> <span>bubbleSortFunc</span><span>[</span><span>T</span> <span>any</span><span>](</span><span>x</span> <span>[]</span><span>T</span><span>,</span> <span>less</span> <span>func</span><span>(</span><span>a</span><span>,</span> <span>b</span> <span>T</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
  <span>n</span> <span>:=</span> <span>len</span><span>(</span><span>x</span><span>)</span>
  <span>for</span> <span>{</span>
    <span>swapped</span> <span>:=</span> <span>false</span>
    <span>for</span> <span>i</span> <span>:=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
      <span>if</span> <span>less</span><span>(</span><span>x</span><span>[</span><span>i</span><span>],</span> <span>x</span><span>[</span><span>i</span><span>-</span><span>1</span><span>])</span> <span>{</span>
        <span>x</span><span>[</span><span>i</span><span>-</span><span>1</span><span>],</span> <span>x</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>x</span><span>[</span><span>i</span><span>],</span> <span>x</span><span>[</span><span>i</span><span>-</span><span>1</span><span>]</span>
        <span>swapped</span> <span>=</span> <span>true</span>
      <span>}</span>
    <span>}</span>
    <span>if</span> <span>!</span><span>swapped</span> <span>{</span>
      <span>return</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</pre></div>
<p>We can use this function to sort strings as follows:</p>
<div><pre><span></span><span>bubbleSortFunc</span><span>(</span><span>ss</span><span>,</span> <span>func</span><span>(</span><span>a</span><span>,</span> <span>b</span> <span>string</span><span>)</span> <span>bool</span> <span>{</span> <span>return</span> <span>a</span> <span>&lt;</span> <span>b</span> <span>})</span>
</pre></div>
<p>Before reading what follows, can you guess how well this approach does in
the benchmarks compared to the generic sort that uses <tt>&lt;</tt> and compared
to the interface-based sort?</p>
<div><pre><span></span>$ go test -bench=.
goos: linux
goarch: amd64
pkg: example.com
cpu: Intel(R) Core(TM) i7-4771 CPU @ 3.50GHz
BenchmarkSortStringInterface-8             124           9599141 ns/op
BenchmarkSortStringGeneric-8               158           7433097 ns/op
BenchmarkSortStringFunc-8                  138           8584866 ns/op
</pre></div>
<p>It&#39;s about in the middle! 14% slower than the other generic function, but 10%
faster than the interface-based version.</p>
<p>When looking at its assembly code, it&#39;s easy to see why. While the
function-based version does not avoid the function call for each comparison (it
has to call a function provided as an argument), it <em>does</em> avoid the bounds
checks, because the access to <tt>x[i]</tt> and <tt><span>x[i-1]</span></tt> happens within the body of
the function (and not in a function it invokes). So we get a partial win.</p>
<p>This comparison has interesting real-life implications because <tt>SortFunc</tt> is
also a variant that was added to the <tt>golang.org/exp/slices</tt>, to provide more
general sorting capabilities (for types that are unconstrained). This version
also provides a speedup against <tt>sort.Sort</tt>.</p>
<p>Another implication is for sorting pointer types; as mentioned earlier, the Go
compiler in 1.18 will group all pointer types into a single GC shape, meaning
that it will need to pass a dictionary around for dynamic dispatch. This may
make the code slower, though BCE should still kick in - so not <em>much</em> slower. I
have a benchmark demonstrating this in <a href="https://github.com/eliben/code-for-blog/tree/master/2022/genericsort">the repository</a>.</p>
<p>Finally, as a simple exercise - take the bubble sort functions shown here and
benchmark sorting a large slice of integers using the generic function vs. the
interface-based one. You&#39;ll likely see a <em>massive</em> speedup with generics, more
than for strings. Can you figure out why?</p>
</div>
<div id="parting-words">
<h2>Parting words</h2>
<p>While this post was about 2/3 of the way through its draft process, <a href="https://planetscale.com/blog/generics-can-make-your-go-code-slower">this
article written by Planetscale engineers</a> was
published. It describes some scenarios in which converting monomorphized code to
generics makes it significantly slower. It&#39;s a very good article, and is worth a
read (and I <em>love</em> the disassembly widget).</p>
<p>It&#39;s worth saying that generics in Go are <em>very new</em>. What we&#39;re playing with
now is the initial implementation that was published literally 2 weeks ago! The
first release focused on making generics work at all, with a large effort
spent on correctness for many tricky corner cases. <a href="https://wiki.c2.com/?MakeItWorkMakeItRightMakeItFast">Making it fast</a> is also planned, but
it&#39;s not the highest priority right now.</p>
<p>That said, the implementation is in flux and being improved all the time; for
example, <a href="https://go-review.googlesource.com/c/go/+/385274">this Go change</a>
which will make it into Go 1.19 already fixes some of the issues discussed in
the Planetscale article. On the other hand, due to the reasons discussed in
<em>The Generic Dilemma</em>, it&#39;s unlikely that Go&#39;s generics will ever be &#34;zero-cost&#34;
in all possible scenarios. Go places a strong priority on fast compile times
and compact binary sizes, so it has to make a certain set of tradeoffs with
any design.</p>
<p>Give generics a ride for your use cases! Play, explore, try things out. Peek
under the hood (hopefully my post helps with that), report issues that you find
with correctness <em>or</em> performance. This is just the beginning for Go generics.</p>
<hr/>



</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<p>
For comments, please send me
<a href="mailto:eliben@gmail.com"><i></i> an email</a>.
</p>        </article>
    </section>

    </div>
</div></div>
  </body>
</html>
