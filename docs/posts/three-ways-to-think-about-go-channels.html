<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dolthub.com/blog/2024-06-21-channel-three-ways/">Original</a>
    <h1>Three ways to think about Go channels</h1>
    
    <div id="readability-page-1" class="page"><div data-cy="blog-post-text"><p>One of Golang&#39;s steepest learning curves is how to use
channels.</p>
<p>At the practical level, channels are locked, buffered queues. Their API
matches that of a queue, the implementation is a queue, and I find it
easiest to write and read channel code with this abstraction.</p>
<p>But it is not enough to know how the channel API works. You also need to be
comfortable with the channel ecosystem. Channels usually depend on
errorgroups, goroutines, and other concurrency primitives.</p>
<p>Lastly, understanding how the Go runtime manages channels is important
when comparing implementations. In some cases, channels add unnecessary
overhead compared to mutexes or atomics. But alternatives to channels can disagree
with the Golang runtime in ways that make source code clunky and hamper
performance.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/c640141a342a471bdcdf2e68945092b0/cea38/max-channel-abstractions.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="queues" title="" src="https://www.dolthub.com/blog/static/c640141a342a471bdcdf2e68945092b0/ad12c/max-channel-abstractions.png" srcset="/blog/static/c640141a342a471bdcdf2e68945092b0/a48b3/max-channel-abstractions.png 214w,
/blog/static/c640141a342a471bdcdf2e68945092b0/47730/max-channel-abstractions.png 428w,
/blog/static/c640141a342a471bdcdf2e68945092b0/ad12c/max-channel-abstractions.png 856w,
/blog/static/c640141a342a471bdcdf2e68945092b0/7a18f/max-channel-abstractions.png 1284w,
/blog/static/c640141a342a471bdcdf2e68945092b0/cea38/max-channel-abstractions.png 1644w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>Segmenting these concerns helps me focus on the right things at the
right time.  When I want to write channel code that works, I think
&#34;queues&#34;. When I need my channel code to stop running, I compare
concurrency patterns for tracking threads.  When I want to
compare performance and safety, the theoretical concerns matter.</p>
<p>We will deep dive these topics to get a better understanding of each.</p>

<blockquote>
<p>&#34;you can think [of] it as a box in which you put a[n] item at one end and
then pick it from other end.&#34;
<a href="https://stackoverflow.com/questions/39826692/what-are-channels-used-for">https://stackoverflow.com/questions/39826692/what-are-channels-used-for</a></p>
</blockquote>
<p>Channels are implemented as a queue with lock-protected access. Senders
try to add to the queue. Receivers try to read from the queue. The queue
size is fixed. Senders can pile up waiting to add to the
queue, and receivers can pile up competing for the next item. The sender
and receiver queues (as opposed to the message queue), sit in linked
lists. The Go runtime parks and signals senders and receivers manually
to avoid, for example, a sender wasting time spinning on a full queue
while a receiver could be doing work.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/929347d5ab95c8ec9090c0cb50aa7032/8b95f/max-channel-queue.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="queue" title="" src="https://www.dolthub.com/blog/static/929347d5ab95c8ec9090c0cb50aa7032/ad12c/max-channel-queue.png" srcset="/blog/static/929347d5ab95c8ec9090c0cb50aa7032/a48b3/max-channel-queue.png 214w,
/blog/static/929347d5ab95c8ec9090c0cb50aa7032/47730/max-channel-queue.png 428w,
/blog/static/929347d5ab95c8ec9090c0cb50aa7032/ad12c/max-channel-queue.png 856w,
/blog/static/929347d5ab95c8ec9090c0cb50aa7032/7a18f/max-channel-queue.png 1284w,
/blog/static/929347d5ab95c8ec9090c0cb50aa7032/56caf/max-channel-queue.png 1712w,
/blog/static/929347d5ab95c8ec9090c0cb50aa7032/8b95f/max-channel-queue.png 2848w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>Here is how you send work to a channel:</p>
<div data-language="go"><pre><code><span>func</span> <span>send</span><span>(</span>w Work<span>,</span> ch <span>chan</span> Work<span>)</span> <span>{</span>
    ch <span>&lt;-</span> w
<span>}</span></code></pre></div>
<p>Here is how you read from a channel:</p>
<div data-language="go"><pre><code><span>func</span> <span>recv</span><span>(</span>ch <span>chan</span> Work<span>)</span> <span>(</span>Work<span>,</span> <span>bool</span><span>)</span> <span>{</span>
    w<span>,</span> ok <span>:=</span> <span>&lt;-</span>ch
    <span>return</span> w<span>,</span> ok
<span>}</span></code></pre></div>
<p>Which is similar to appending/removing from a queue:</p>
<div data-language="go"><pre><code><span>func</span> <span>(</span>q <span>*</span>Queue<span>)</span> <span>send</span><span>(</span>w Work<span>)</span> <span>{</span>
    q <span>=</span> <span>append</span><span>(</span>q<span>,</span> w<span>)</span>
<span>}</span>

<span>func</span> <span>(</span>q <span>*</span>Queue<span>)</span> <span>recv</span><span>(</span><span>)</span> <span>(</span>Work<span>,</span> <span>bool</span><span>)</span> <span>{</span>
    <span>if</span> <span>len</span><span>(</span>q<span>)</span> <span>==</span> <span>0</span> <span>{</span>
        <span>return</span> <span>nil</span><span>,</span> <span>false</span>
    <span>}</span>
    w <span>:=</span> q<span>[</span><span>0</span><span>]</span>
    q <span>=</span> q<span>[</span><span>1</span><span>:</span><span>]</span>
    <span>return</span> w<span>,</span> <span>true</span>
<span>}</span>
</code></pre></div>
<p>Because channel operations can block, a <code>select</code> statement is often
used to expand our options when a channel is full. Below we try to send work
to the channel, but fallthrough if the channel is full:</p>
<div data-language="go"><pre><code><span>func</span> <span>trySend</span><span>(</span>w Work<span>,</span> ch <span>chan</span> Work<span>)</span> <span>(</span>success <span>bool</span><span>)</span> <span>{</span>
    <span>select</span> <span>{</span>
    <span>case</span> ch <span>&lt;-</span>w<span>:</span>
        <span>return</span> <span>true</span>
    <span>default</span><span>:</span>
        <span>return</span> <span>false</span>
    <span>}</span>
<span>}</span></code></pre></div>
<p>Similarly, extra channels can provide an escape hatch if we want to
block until a related component decides we should stop:</p>
<div data-language="go"><pre><code><span>func</span> <span>sendWithEscapeHatch</span><span>(</span>w Work<span>,</span> ch <span>chan</span> Work<span>,</span> done <span>chan</span> <span>struct</span><span>{</span><span>}</span><span>)</span> <span>bool</span> <span>{</span>
    <span>select</span> <span>{</span>
    <span>case</span> ch <span>&lt;-</span> w<span>:</span>
        <span>return</span> <span>true</span>
    <span>case</span> <span>&lt;-</span>done<span>:</span>
        <span>return</span> <span>false</span>
    <span>}</span>
<span>}</span>

<span>func</span> <span>escapeHatch</span><span>(</span>done <span>chan</span> <span>struct</span><span>{</span><span>}</span><span>)</span> <span>{</span>
    <span>close</span><span>(</span>done<span>)</span>
<span>}</span></code></pre></div>
<p>The <a href="https://go.dev/src/runtime/chan.go">full channel implementation</a>
has a lot of subtle details. But I really find &#34;what would a queue do&#34;
helpful when writing code:</p>
<ul>
<li>Writing to a full queue -&gt; sender waits in line</li>
<li>Reading from an empty queue -&gt; reader waits in line</li>
<li>Reading from a closed queue -&gt; read values until empty</li>
<li>Writing to a closed queue -&gt; your application is doing something wrong, either we missed work, or the program should be interrupting writers</li>
<li>Closing a nil or previously closed channel -&gt; you app is doing something wrong</li>
</ul>

<blockquote>
<p>&#34;channels and goroutines are the primitives on top of which most of
concurrent golang code is built.&#34;
<a href="https://www.reddit.com/r/golang/comments/103undh/comment/j31qtug/">https://www.reddit.com/r/golang/comments/103undh/comment/j31qtug/</a></p>
</blockquote>
<p>The second way to think about channels is not as their own isolated
abstraction, but as one fundamental component in the Go ecosystem of
concurrency controls. To use channels to write concurrent code, you need
to understand the other primitives as well.</p>
<h2 id="goroutines"><a href="#goroutines" aria-label="goroutines permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Goroutines</h2>
<p>We mentioned <a href="https://go.dev/tour/concurrency/1">goroutines</a> and <a href="https://go.dev/tour/concurrency/5">select
blocks</a> in the last section, which
are ways to decouple a linear program into concurrent segments:</p>
<div data-language="go"><pre><code><span>go</span> <span>func</span><span>(</span><span>)</span> <span>{</span>
    fmt<span>.</span><span>Println</span><span>(</span><span>&#34;thing 1&#34;</span><span>)</span>
<span>}</span><span>(</span><span>)</span>
<span>go</span> <span>func</span><span>(</span><span>)</span> <span>{</span>
    fmt<span>.</span><span>Println</span><span>(</span><span>&#34;thing 2&#34;</span><span>)</span>
<span>}</span><span>(</span><span>)</span></code></pre></div>
<p>It is non-deterministic whether &#34;thing 1&#34; or &#34;thing 2&#34; is printed first
in the example above. Both functions are ran in new threads
separate from the original calling context. In the context of channels, we
often run <code>send</code> and <code>recv</code> operations in separate goroutines because
the Go runtime switches contexts depending on where work is building up.</p>
<div data-language="go"><pre><code>ch <span>:=</span> <span>make</span><span>(</span><span>chan</span> Work<span>)</span>

<span>go</span> <span>recv</span><span>(</span>ch<span>)</span>

<span>for</span> <span>_</span><span>,</span> w <span>:=</span> <span>range</span> work <span>{</span>
    <span>go</span> <span>send</span><span>(</span>w<span>,</span> ch<span>)</span>
<span>}</span></code></pre></div>
<h2 id="timing"><a href="#timing" aria-label="timing permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Timing</h2>
<p><a href="https://go.dev/wiki/Timeouts">Timeouts</a> and <a href="https://gobyexample.com/tickers">tickers</a> are two
ways to extend select blocks with time-based logic. The example below
uses a <code>ticker</code> to send one item a second.</p>
<div data-language="go"><pre><code>ticker <span>:=</span> time<span>.</span><span>NewTicker</span><span>(</span><span>1</span> <span>*</span> time<span>.</span>Second<span>)</span>
<span>for</span> <span>_</span><span>,</span> w <span>:=</span> <span>range</span> work <span>{</span>
    <span>select</span> <span>{</span>
    <span>case</span> <span>&lt;-</span>ticker<span>.</span>C
        ch <span>&lt;-</span> w
    <span>}</span>
<span>}</span></code></pre></div>
<p>We do the same thing with a timeout below:</p>
<div data-language="go"><pre><code><span>for</span> <span>_</span><span>,</span> w <span>:=</span> <span>range</span> work <span>{</span>
    <span>select</span> <span>{</span>
    <span>case</span> <span>&lt;-</span>time<span>.</span><span>After</span><span>(</span><span>1</span> <span>*</span> time<span>.</span>Second<span>)</span><span>:</span>
        ch <span>&lt;-</span> w
    <span>}</span>
<span>}</span></code></pre></div>
<p>Tickers can rate-limit the throughput of channels, and timers can be
used to interrupt work that is taking too long to finish.</p>
<h2 id="waitgroups"><a href="#waitgroups" aria-label="waitgroups permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>WaitGroups</h2>
<p><a href="https://pkg.go.dev/sync#example-WaitGroup">Wait groups</a>
and <a href="https://pkg.go.dev/golang.org/x/sync/errgroup#example-Group-JustErrors">error
groups</a>
are two ways to coordinate thread shutdown. We have already noted the
<code>done</code> pattern, which lets us kill straggler senders/receivers when the
runtime decides we want to exit:</p>
<div data-language="go"><pre><code><span>select</span> <span>{</span>
<span>case</span> ch <span>&lt;-</span> w<span>:</span>
    <span>return</span> <span>true</span>
<span>case</span> <span>&lt;-</span>done<span>:</span>
    <span>return</span> <span>false</span>
<span>}</span></code></pre></div>
<p>If we know the amount of work ahead of time and are unconcerned with
errors, wait groups block a main process until a fixed set of concurrent threads
finish:</p>
<div data-language="go"><pre><code><span>func</span> <span>sumRange</span><span>(</span>n <span>int</span><span>)</span> <span>int</span> <span>{</span>
	<span>var</span> wg sync<span>.</span>WaitGroup
	work <span>:=</span> <span>make</span><span>(</span><span>chan</span> <span>int</span><span>)</span>
	res <span>:=</span> <span>make</span><span>(</span><span>chan</span> <span>int</span><span>)</span>
	<span>go</span> <span>func</span><span>(</span><span>)</span> <span>{</span>
		<span>var</span> sum <span>int</span>
		<span>for</span> <span>{</span>
            
			<span>select</span> <span>{</span>
			<span>case</span> i<span>,</span> ok <span>:=</span> <span>&lt;-</span>work<span>:</span>
				<span>if</span> <span>!</span>ok <span>{</span>
					res <span>&lt;-</span> sum
					<span>return</span>
				<span>}</span>
				sum <span>+=</span> i
			<span>}</span>
		<span>}</span>
	<span>}</span><span>(</span><span>)</span>
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span> <span>{</span>
		wg<span>.</span><span>Add</span><span>(</span><span>1</span><span>)</span> 
		i <span>:=</span> i
		<span>go</span> <span>func</span><span>(</span><span>)</span> <span>{</span>
			work <span>&lt;-</span> i
			wg<span>.</span><span>Done</span><span>(</span><span>)</span> 
		<span>}</span><span>(</span><span>)</span>
	<span>}</span>
	wg<span>.</span><span>Wait</span><span>(</span><span>)</span>    
	<span>close</span><span>(</span>work<span>)</span>  
	<span>return</span> <span>&lt;-</span>res 
<span>}</span></code></pre></div>
<p>We divide senders and receivers into two pools above. The senders
increment and decrement from a WaitGroup to signal work in progress.
The receiver is a single goroutine that accepts work from the senders.
When the senders have finished sending work, <code>wg.Wait()</code> unblocks. At
that point, no more work will be added to the queue, so we close the
work channel. We use a final result channel <code>res</code> to let the receiver
finish adding values before returning.</p>
<p>The code is <a href="https://go.dev/play/p/Hbk6cwlsnYa">here</a> if you would like
to run yourself.</p>
<h2 id="error-groups"><a href="#error-groups" aria-label="error groups permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Error Groups</h2>
<p>While <code>done</code> and <code>WaitGroup</code> have their place, it is rare for an
application to know much about its shutdown routine in advance. In our
experience, shutdown usually occurs unpredictably, and we need to
combine primitives to gracefully (1) kill senders, (2) flush the
queue, and (3) kill receivers.</p>
<div data-language="go"><pre><code><span>type</span> counter <span>struct</span> <span>{</span>
    work <span>chan</span> <span>int</span>
    res <span>chan</span> <span>int</span>
    eg <span>*</span>errgroup<span>.</span>Group
<span>}</span>

<span>func</span> <span>newCounter</span><span>(</span>ctx context<span>.</span>Context<span>)</span> <span>*</span>counter <span>{</span>
	eg<span>,</span> <span>_</span> <span>:=</span> errgroup<span>.</span><span>WithContext</span><span>(</span>ctx<span>)</span>
	c <span>:=</span> <span>&amp;</span>counter<span>{</span>
		work<span>:</span> <span>make</span><span>(</span><span>chan</span> <span>int</span><span>)</span><span>,</span>
		res<span>:</span>  <span>make</span><span>(</span><span>chan</span> <span>int</span><span>)</span><span>,</span>
		eg<span>:</span>   eg<span>,</span>
	<span>}</span>
	<span>go</span> c<span>.</span><span>recv</span><span>(</span>ctx<span>)</span>
	<span>return</span> c
<span>}</span>

<span>func</span> <span>(</span>c <span>*</span>counter<span>)</span> <span>recv</span><span>(</span>ctx context<span>.</span>Context<span>)</span> <span>error</span> <span>{</span>
	sum <span>:=</span> <span>0</span>
	<span>for</span> <span>{</span>
		<span>select</span> <span>{</span>
		<span>case</span> i<span>,</span> ok <span>:=</span> <span>&lt;-</span>c<span>.</span>work<span>:</span>
			<span>if</span> <span>!</span>ok <span>{</span>
				c<span>.</span>res <span>&lt;-</span> sum
				<span>return</span> <span>nil</span>
			<span>}</span>
			sum <span>+=</span> i
		<span>case</span> <span>&lt;-</span>ctx<span>.</span><span>Done</span><span>(</span><span>)</span><span>:</span>
			<span>return</span> context<span>.</span><span>Cause</span><span>(</span>ctx<span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span>

<span>func</span> <span>(</span>c <span>*</span>counter<span>)</span> <span>send</span><span>(</span>ctx context<span>.</span>Context<span>,</span> n <span>int</span><span>)</span> <span>{</span>
	c<span>.</span>eg<span>.</span><span>Go</span><span>(</span><span>func</span><span>(</span><span>)</span> <span>error</span> <span>{</span>
		<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span> <span>{</span>
			<span>select</span> <span>{</span>
			<span>case</span> c<span>.</span>work <span>&lt;-</span> i<span>:</span>
			<span>case</span> <span>&lt;-</span>ctx<span>.</span><span>Done</span><span>(</span><span>)</span><span>:</span>
				<span>return</span> context<span>.</span><span>Cause</span><span>(</span>ctx<span>)</span>
			<span>}</span>
		<span>}</span>
		<span>return</span> <span>nil</span>
	<span>}</span><span>)</span>
<span>}</span>

<span>func</span> <span>(</span>c <span>*</span>counter<span>)</span> <span>finalize</span><span>(</span><span>)</span> <span>(</span><span>int</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
	<span>if</span> err <span>:=</span> c<span>.</span>eg<span>.</span><span>Wait</span><span>(</span><span>)</span><span>;</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>0</span><span>,</span> err
	<span>}</span>
	<span>close</span><span>(</span>c<span>.</span>work<span>)</span>
	<span>return</span> <span>&lt;-</span>c<span>.</span>res<span>,</span> <span>nil</span>
<span>}</span>

<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    ctx <span>:=</span> context<span>.</span><span>Background</span><span>(</span><span>)</span>
    c <span>:=</span> <span>newCounter</span><span>(</span>ctx<span>)</span>
    c<span>.</span><span>send</span><span>(</span>ctx<span>,</span> <span>10</span><span>)</span>
    c<span>.</span><span>send</span><span>(</span>ctx<span>,</span> <span>10</span><span>)</span>
    c<span>.</span><span>send</span><span>(</span>ctx<span>,</span> <span>10</span><span>)</span>
    sum<span>,</span> err <span>:=</span> c<span>.</span><span>finalize</span><span>(</span><span>)</span>
<span>}</span></code></pre></div>
<p>Our queue is again divided between senders and workers. Now the
senders use the error group <code>eg</code> instead of a wait group to coordinate
with one another. The receiver thread still pulls work from the queue
accumulating results. Shutdown also works similarly.
<code>finalize()</code> blocks until in-progress senders have finished their work.
Once senders are finished, we are safe to <code>close(c.work)</code>. And the
receiver will populate the result channel after draining the queue.</p>
<p>The main difference is that we may have unbounded work. The
<code>counter</code> organization accounts for an arbitrary number of <code>send</code>
calls before <code>finalize</code>.</p>
<p>Unbounded work also opens up a number of failure cases. If the <code>ctx</code> is
canceled, <code>&lt;-ctx.Done()</code> returns immediately. Senders and
receivers shutdown early, the error group will accept no new work, and the call
to <code>finalize</code> will return the first error encountered.</p>
<p>There are other ways we could manage shutdown in this last example. We
could have two separate error groups to track senders and receivers. We
could use a <code>done</code> channel for receiver errors to signal for senders to
stop (or at least avoid blocking). We don&#39;t always want to interrupt a
whole process just because one component fails. The code can be
run/edited <a href="https://go.dev/play/p/qoQWZceFKTo">here</a>.</p>
<p>Choosing the right organizational
pattern and set of primitives can be a bit of an art. <a href="https://go.dev/blog/pipelines">This blog
implements a number squaring function</a> in
a variety of ways using the same primitives, to give a second example of
implementation tradeoffs.</p>

<blockquote>
<p>&#34;Go channels are modeled on Hoare&#39;s Communicating Sequential
Processes, a process algebra for concurrency that is oriented around
event flows between communicating actors&#34;
<a href="https://stackoverflow.com/a/13602361">https://stackoverflow.com/a/13602361</a></p>
</blockquote>
<p>If you are still here, you have probably seen the channel call to
action:</p>
<blockquote>
<p>don&#39;t communicate by sharing memory, share memory by communicating</p>
</blockquote>
<p>I don&#39;t know about you, but this doesn&#39;t exactly get me in the mood.
Keeping two mental models for the queue implementation/API and the
language-specific syntax is hard enough without this third layer of
complexity. But this is the canonical channel quote, we have to unpack
it.</p>
<p>One literal interpretation of Pike&#39;s quote is that message passing is
different than sharing memory for pedantic reasons. Copying values
between sender/receiver stacks is safer than sharing memory. But it is
also possible to send values with pointers into channels, so that
doesn&#39;t really prevent developers from abusing the model. I don&#39;t think
avoiding shared memory is a top of mind consideration for developers
deciding whether to use channels.</p>
<p>The second observation is that the Golang developers didn&#39;t put so much
effort into channels just to be equivalent to a
user-implemented queue. Golang&#39;s control over runtime
Goroutines makes the channel implementation very efficient. Go&#39;s runtime
can pause and resume
threads depending on where there is work to be done. Concurrency adds a
fixed overhead of context switching, but it would be difficult for a
user queue implementation to be as performant.</p>
<p>Embedding channels into the language runtime also makes it easier to
write more aggressively concurrent code. The channel ecosystem makes
them harder to learn, but it also lets you do a lot more.</p>
<p><a href="https://www.dolthub.com/team#aaron">Aaron&#39;s</a> recent <a href="https://www.dolthub.com/blog/2024-05-08-dolt-new-puller/">fetcher
refactor</a> is
one example where almost a dozen channel contexts coordinate to download table
updates. The implementation <a href="https://github.com/dolthub/dolt/blob/b4492803f152878a91e6c9f49c2262decf22f55a/go/libraries/doltcore/remotestorage/chunk_fetcher.go#L65">in the
code</a>
is only concise because the channel API abstracts so many
details. And the Go runtime&#39;s smart context switching makes it possible
to maximize productive work in-between network calls.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/09749f17ede13df6fc1a2a2fbdd69dbf/218a4/old_puller_sequence_uml.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="fetcher" title="" src="https://www.dolthub.com/blog/static/09749f17ede13df6fc1a2a2fbdd69dbf/ad12c/old_puller_sequence_uml.png" srcset="/blog/static/09749f17ede13df6fc1a2a2fbdd69dbf/a48b3/old_puller_sequence_uml.png 214w,
/blog/static/09749f17ede13df6fc1a2a2fbdd69dbf/47730/old_puller_sequence_uml.png 428w,
/blog/static/09749f17ede13df6fc1a2a2fbdd69dbf/ad12c/old_puller_sequence_uml.png 856w,
/blog/static/09749f17ede13df6fc1a2a2fbdd69dbf/218a4/old_puller_sequence_uml.png 1052w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>

<p>I find channels easiest to understand as a queue abstraction. But
channels on their own are not enough. Real applications depend on the
set of concurrency primitives in Golang. And lastly, channels usually
abstract details that that make developers lives easier in a way that is
also more performant than other concurrency options.</p>
<p>All of these abstractions are useful! But they are often useful in
different contexts.</p>
<p>If you have any questions about Dolt, databases, or Golang performance
reach out to us on <a href="https://twitter.com/dolthub">Twitter</a>,
<a href="https://discord.gg/gqr7K4VNKe">Discord</a>, and
<a href="https://github.com/dolthub/go-mysql-server">GitHub</a>!</p></div></div>
  </body>
</html>
