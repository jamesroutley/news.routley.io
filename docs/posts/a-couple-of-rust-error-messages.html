<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2022/12/02/a-couple-of-rust-error-messages/">Original</a>
    <h1>A couple of Rust error messages</h1>
    
    

<p>Hello!</p>

<p>I&rsquo;ve been doing <a href="https://adventofcode.com/2022">Advent of Code</a> in Rust for the
past couple of days, because I&rsquo;ve never really gotten comfortable with the
language and I thought doing some Advent of Code problems might help.</p>

<p>My solutions aren&rsquo;t anything special, but because I&rsquo;m trying to learn, I&rsquo;ve
been trying to take a slightly more rigorous approach than usual to compiler
errors. Instead of just fixing the error and moving on, I&rsquo;m trying to make sure
that I actually understand what the error message means and what it&rsquo;s telling
me about how the language works.</p>

<p>My steps to do that are:</p>

<ol>
<li>fix the bug</li>
<li>make a tiny standalone program reproducing the same compiler error</li>
<li>think about it and try to explain it to myself to make sure I actually understand why that error happened</li>
<li>ask for help if I still don&rsquo;t understand</li>
</ol>

<p>So here are a couple of compiler errors and my explanations to myself of why
the error is happening.</p>

<p>Both of them are pretty basic Rust errors, but I had fun thinking about them
today. I wrote this for an imagined audience of &ldquo;people who know some Rust
basics but are still pretty bad at Rust&rdquo;, if there are any of you out there.</p>

<h3 id="error-1-a-borrowing-error">error 1: a borrowing error</h3>

<p>Here&rsquo;s some code (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=20f26bdcd30f5f8c1bccb17b36cc32de">rust playground link</a>):</p>

<pre><code>fn inputs() -&gt; Vec&lt;(i32, i32)&gt; {
    return vec![(0, 0)];
}
fn main() {
    let scores = inputs().iter().map(|(a, b)| {
        a + b
    });
    println!(&quot;{}&quot;, scores.sum::&lt;i32&gt;());
    
}
</code></pre>

<p>And here&rsquo;s the compiler error:</p>

<pre><code>5 |     let scores = inputs().iter().map(|(a, b)| {
  |                  ^^^^^^^^ creates a temporary which is freed while still in use
6 |         a + b
7 |     });
  |       - temporary value is freed at the end of this statement
8 |     println!(&quot;{}&quot;, scores.sum::&lt;i32&gt;());
  |                    ------ borrow later used here
  help: consider using a `let` binding to create a longer lived value
  |
5 ~     let binding = inputs();
6 ~     let scores = binding.iter().map(|(a, b)| {
  |

For more information about this error, try `rustc --explain E0716`.
</code></pre>

<p>This is a pretty basic Rust error message about borrowing, but I&rsquo;ve forgotten
everything about Rust so I didn&rsquo;t understand it.</p>

<p>There are 2 things I didn&rsquo;t know / wasn&rsquo;t thinking about here:</p>

<p><strong>thing 1</strong>: Variables are <strong>semantically meaningful</strong> in Rust.</p>

<p>What I mean by that is that this code:</p>

<pre><code>let scores = inputs().iter().map(|(a, b)| { ... };
</code></pre>

<p>does <strong>not do the same thing</strong> as if we factor out <code>inputs()</code> into a variable, in this code:</p>

<pre><code>let input = inputs();
let scores = input.iter().map(|(a, b)| { ... };
</code></pre>

<p>If some memory is allocated and it isn&rsquo;t in its own variable, then it&rsquo;s freed
at the end of the expression (though there are some exceptions to this
apparently, see <code>rustc --explain E0716</code> for more). But it <em>does</em> have its own
variable, then it&rsquo;s kept around until the end of the block.</p>

<p>In the error message the Rust compiler actually suggests an explanation to read
(<code>rustc --explain E0716</code>), which explains all of this and more. I didn&rsquo;t notice
it right away, but once I read it (and Googled a little), it really helped me.</p>

<p><strong>thing 2</strong>:. Computations with <code>iter()</code> <strong>don&rsquo;t happen right away</strong>.</p>

<p>This is something that I theoretically knew, but wasn&rsquo;t thinking about how it
might relate to compiler errors.</p>

<p>When I call <code>.map(...)</code>, that doesn&rsquo;t actually do the <code>map</code> right away &ndash; it
just sets up an iterator that can do actual calculation later, when we call
<code>.sum()</code>.</p>

<p>This means that I need to keep around the memory from <code>inputs()</code>, because none
of the calculation has even happened yet!</p>

<h3 id="error-2-summing-an-iterator">error 2: summing an <code>Iterator&lt;()&gt;</code></h3>

<p>Here&rsquo;s some code (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=275f94fe419f49479dabf1704068c5d3">rust playground link</a>) (This isn&rsquo;t the actual code I was debugging, but it&rsquo;s the fastest way to demonstrate the error message)</p>

<pre><code class="language-rust">fn main() {
    vec![(), ()].iter().sum::&lt;i32&gt;();
}
</code></pre>

<p>This has a pretty obvious bug: You can&rsquo;t sum a bunch of <code>()</code> (the empty type)
and get an <code>i32</code> as a result. Here&rsquo;s the compiler error, though:</p>

<pre><code>2 |     vec![(), ()].iter().sum::&lt;i32&gt;();
  |     ^^^^^^^^^^^^^^^^^^^ --- required by a bound introduced by this call
  |     |
  |     the trait `Sum&lt;&amp;()&gt;` is not implemented for `i32`
</code></pre>

<p>This was very confusing to me &ndash; I&rsquo;d expect to see an error saying something
like <code>Sum is not implemented for Iterator&lt;()&gt;</code>. But instead it says that <code>Sum</code> is
not implemented for <strong>i32</strong>. But I&rsquo;m not trying to sum i32s! What&rsquo;s going on?</p>

<p>What&rsquo;s actually going on here is (thanks to some lovely people who helped me out!):</p>

<ul>
<li><code>i32</code> has a static method called <code>sum(iter: Iterator&lt;i32&gt;)</code>, that comes from the <a href="https://doc.rust-lang.org/std/iter/trait.Sum.html#"><code>Sum</code> trait</a>. (<a href="https://github.com/rust-lang/rust/blob/32e613bbaafee1bcabba48a2257b838f8d1c03d3/library/core/src/iter/traits/accum.rs#L41-L47">defined here for integers</a>)</li>
<li><code>Iterator</code> has a <code>sum()</code> method that calls this static method on <code>i32</code> (<a href="https://github.com/rust-lang/rust/blob/e526d123aa4703aa7b85c5b8e70c20b5ee0deade/library/core/src/iter/traits/iterator.rs#L3376-L3382">defined here</a>)</li>
<li>when I run <code>my_iter.sum()</code>, it tries to call <code>i32::sum(my_iter)</code></li>
<li>But <code>i32::sum</code> isn&rsquo;t defined for <code>Iterator&lt;&amp;()&gt;</code>!</li>
<li>The type parameter in <code>Sum</code> (eg) <code>Sum&lt;&amp;()&gt;</code> refers to the type of the <em>iterator</em> that&rsquo;s being passed to <code>i32::sum()</code></li>
<li>as a result, we get the error message <code>the trait Sum&lt;&amp;()&gt; is not implemented for i32</code></li>
</ul>

<p>I might not have gotten all the types/terms exactly right here, but I think
that&rsquo;s the gist of it.</p>

<p>This was a good reminder that sometimes methods (like <code>sum()</code> on <code>Iterator</code> are
defined in slightly indirect/counterintuitive ways and that you have to hunt
down the details of how it&rsquo;s implemented to understand the compiler errors.</p>

<p><small>
(my actual bug here was actually that I&rsquo;d accidentally added an extra <code>;</code> in my
code, which meant that I accidentally created an <code>Iterator&lt;()&gt;</code> instead of an
<code>Iterator&lt;i32&gt;</code>, and the confusing error message made it harder to figure out that
out)
</small></p>

<h3 id="rust-error-messages-are-cool">Rust error messages are cool</h3>

<p>I found these error messages pretty helpful, I especially really apprecated the <code>--explain</code> output on the borrowing error.</p>

  </body>
</html>
