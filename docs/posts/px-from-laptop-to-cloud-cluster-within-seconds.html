<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://amontalenti.com/2025/12/11/px-launch-overview">Original</a>
    <h1>PX: from laptop to cloud cluster within seconds</h1>
    
    <div id="readability-page-1" class="page"><article id="post-5113">
	
	<!-- .entry-header -->

	<div>
		<p>For years, every backend software engineering team I worked with struggled with one unavoidable bottleneck: turning working local code into live production reality.</p>
<p>Running and debugging your code in the cloud was always slow, brittle, complex, and confusing. Often, it required total code rewrites into sophisticated frameworks to get the code to even run at all in the cloud environment.</p>
<p>PX is our attempt to finally fix this widespread pain.</p>
<p><img decoding="async" src="https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_deployed_code.png" alt="" width="778" height="601" srcset="https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_deployed_code.png 778w, https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_deployed_code-300x232.png 300w, https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_deployed_code-768x593.png 768w" sizes="(max-width: 778px) 100vw, 778px"/>
</p>
<p>After years of watching talented people struggle with this pain, I realized something important: the cloud had matured, but our day-to-day tools for <em>wielding the cloud</em> hadn’t.</p>
<p>This matters because so much of what we build today depends on the cloud, yet the gap from working software to deployed cloud system has only grown wider.</p>
<p>PX aims to close that gap. And I’m happy to say that for the last few months I’ve been working with a small team of former colleagues on this, which is “startup #2” for me. Building the PX platform up from first principles has been fun. And I already see huge potential in what we’ve built. I’m ready to share a little bit about it publicly.</p>
<p>Our new company, PX, helps developers go from laptop to cloud cluster within seconds.</p>
<p><a target="_blank" href="https://px.app" rel="noopener"><img decoding="async" src="https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_code_cluster.png" alt="" width="1485" height="800" srcset="https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_code_cluster.png 1485w, https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_code_cluster-300x162.png 300w, https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_code_cluster-1024x552.png 1024w, https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_code_cluster-768x414.png 768w" sizes="(max-width: 1485px) 100vw, 1485px"/></a>
</p>
<p>If you’re a backend engineer, read on. If not, you can still check out our website at <a href="https://px.app">https://px.app</a> and share this post or the site with your team, where they can learn more.</p>
<p>The rest of this post will go into some of the technical details of how PX already works today, including how to build your first PX cluster and run your first PX cluster job — all the while using your favorite programming language and your existing cloud environment. The last section of the post will cover how we plan to expand PX’s use cases over time, moving from one-off (batch) workloads to all other backend cloud cluster workloads.</p>

<h3>Root-striking the issue</h3>
<p>I spent more than a decade as a CTO for a real-time analytics software company (<a href="http://Parse.ly">Parse.ly</a>) whose backend engineering team shipped rock-solid distributed systems built with Python and deployed atop commodity cloud Linux VMs. Our company’s growth corresponded with the rise of mature public cloud data centers like Amazon Web Services (AWS) and Google Cloud Platform (GCP).</p>
<p>One of my toughest technical projects was when we <a href="https://amontalenti.com/2019/04/03/shipping-the-second-system">“shipped the second system”</a>, which involved developing deep expertise in open source distributed systems like Elasticsearch, Cassandra, Kafka, and Spark — and how we got it all to run reliably, cost-effectively, and at-scale in AWS. But, as I described in that post, getting our business logic into the distributed cloud environment required herculean feats of systems engineering.</p>
<p>A few years ago, <a href="http://Parse.ly">Parse.ly</a> <a href="https://amontalenti.com/2021/12/08/parsely-and-automattic">was acquired</a> by Automattic, the creators of <a href="https://WordPress.com">WordPress.com</a>. I spent a couple years as a head of product + engineering at Automattic. From my time as an engineering lead, I’ve witnessed backend teams face similar development challenges in deploying their distributed systems. When I got to take a step back from the cloud architectures I helped design — and the architectures of many other backend teams — something clicked for me.</p>
<p>I realized that the cloud market had changed. There was an inflection point in how backend architectures could be designed — and simplified. Through this lens, I came to understand the common complexity spirals as newly solvable. Specifically: I realized they could be solved a layer down.</p>
<p>PX is our way of “root-striking” these issues. Our mission is to deliver to backend developers the joy they deserve when shipping their software to the cloud.</p>
<p>PX offers a new daily tool for programmers. Its user experience is centered around a command-line tool called, well, <code>px</code>.</p>
<p>I’m really excited about it because it’s a tool and a product I always wished I had — and always wished I could give to the engineering teams I led or advised.</p>
<p>PX builds on my past experience as a CTO. But its real inspiration comes from tools like <code>git</code> and <code>terraform</code>, tools that completely transformed backend software practices in the last decade.</p>
<p>In much the same way that <code>git</code> is a programmer’s daily tool to manage code at dev time, <code>px</code> aims to be the programmer’s daily tool to manage code at <em>cloud runtime</em>.</p>
<p>What does that mean? Let me explain.</p>
<h3>Building your first cluster</h3>
<p>Let’s say you already have <code>px</code> installed on your laptop and you’re in a local checkout of a <code>git</code> repository for a Python project. You could use:</p>
<pre><code>$ px cluster up CLUSTER_NAME
</code></pre>
<p>This will build you a cloud cluster. What kind, exactly? That depends on your <code>px.yaml</code> file. Here’s how it looks if I just want a 2-node cluster to bulk process a bunch of JPG images:</p>
<pre><code>$ px cluster up jpg
&lt;px&gt; Reading [px.yaml]
&lt;px&gt; Connected to your [Google Cloud Platform] account. ✅
&lt;px&gt; Cluster up [2 nodes x 4 cores = 8 cores]. ✅
</code></pre>
<p>Under the hood, <code>px</code> uses an up-to-date cloud pricing database. This includes the tens of thousands of hardware instance types. But rather than asking for specific hardware instance types, you can just specify some basic requirements in <code>px.yaml</code> — such as number of cores, amount of disk/memory, preferred region — and <code>px</code> will use that guidance to find you the best/cheapest cluster options. Then it’ll rapidly build you that cloud cluster, network it up, and track the estimated per-minute/per-hour operating costs.</p>
<p>Much like <code>git</code>, <code>px</code> doesn’t care about your programming language or framework. It supports everything that runs on a Linux server. And it also directly supports all of the top public clouds. During our private beta period, we are shipping with direct support for GCP, but AWS support will follow closely behind. Then, Microsoft Azure and DigitalOcean will round out the initial public cloud support.</p>
<p><a target="_blank" href="https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_development_sketch.png" rel="noopener"><img decoding="async" src="https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_development_sketch.png" alt="" width="989" height="616" srcset="https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_development_sketch.png 989w, https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_development_sketch-300x187.png 300w, https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_development_sketch-768x478.png 768w" sizes="(max-width: 989px) 100vw, 989px"/></a>
</p>
<h3>Running your first cluster job</h3>
<p>Let’s say the local Python project I’m working on has a single Python script as its entry point. It’s just called <code>jpg.py</code>. It’s a command-line tool that takes JPG filenames as input and produces converted JPEG XL files as output.</p>
<p>As a backend programmer, you’ve probably written tens (or hundreds) of such programs across different programming languages. This is also the kind of simple command-line program that a modern AI/LLM tool could generate with ease.</p>
<p>Here is a sample invocation:</p>
<pre><code>$ python jpg.py data/input.jpg
Processed 1 image(s) in 0.5s
</code></pre>
<p>How would I run this Python CLI program on my <code>px</code> cloud cluster across hundreds/thousands of JPG images? Simple as this:</p>
<pre><code>$ px run &#39;python jpg.py&#39; --cluster jpg --args-file &#39;images.txt&#39;
&lt;px&gt; Reading [px.yaml]
&lt;px&gt; Submitting &#39;python jpg.py&#39; job to PX cluster [2 nodes].
[...]
Processed 1000 image(s) in 14.7s
</code></pre>
<p>This instantly schedules a <code>px</code> job on your cluster and runs it. It feels just like running the program locally: the script’s output streams right back to your terminal.</p>
<p>Under the hood, <code>px</code> is shipping your code to the cluster, running it in a highly parallel way, partitioning the inputs, and multiplexing (muxing) the terminal outputs.</p>
<p>The input JPG files come from cloud storage — in this case, Google Cloud Storage (GCS). We’re starting with GCS, but the same pattern extends naturally to Amazon S3, Azure Blob Storage, and DigitalOcean Spaces.</p>
<p>Your program doesn’t call cloud APIs to access those files, however. Your program just operates on files! Your cloud storage is transparently and automatically mounted as a filesystem mount point in your cluster node. More on this architecture decision in a future blog post. (For some simple use cases, operating directly on streaming lines and bytes over <code>stdin</code> is also an option.)</p>
<p>When you run a <code>px</code> job on your cluster, you also get instant real-time debugging by way of the PX dashboard. Your PX dashboard is securely hosted at <a href="https://px.app">https://px.app</a>, where you can now find a website describing the core PX offering.</p>
<p>If you’re a backend engineer, by now, you probably see where we’re going.</p>
<h3>Backend engineering can be simple and joyful</h3>
<p>We’re trying to make the cloud development experience as simple for backend coders as it has been for frontend coders/designers thanks to tools like Vercel, Netlify, and the like. But we understand that backend engineers want 100% transparency and full control over their deployed systems. Thus, our design is very different.</p>
<p>We are not suggesting the adoption of an entirely new cloud. We know that’s a non-starter for many/most backend engineers. So though we sometimes describe PX to folks as “Vercel for backend,” our design is inherently cloud independent and open source friendly, which are values we know are important to backend engineers. And values that are important to us!</p>
<p>Thus <code>px</code> feels a little closer in spirit to tools like <code>git</code> and <code>terraform</code> (or <a href="https://opentofu.org/">OpenTofu</a>, these days). Like <code>git</code>, it is meant to be a daily developer tool, executed just as frequently as you execute your code to test and debug it. Like the original vision for open source <code>terraform</code>, it is meant to be 100% cloud independent, relying only upon the availability of certain cloud primitives. Among these: Linux, VMs, VPCs, <code>ssh</code>, spot instance marketplaces, and cloud object storage.</p>
<p>PX is also quite different from some of the other “hosted backend” offerings on the market (e.g. Firebase, Supabase) because its goal is to support “bring your own cloud.” That is:  <code>px</code> runs in your cloud, works with every programming language, and doesn’t require you to rewrite your code <em>in any way</em>. The basic rule is, if you can run it as a CLI or Linux process locally, <code>px</code> can run it on a cluster of any size and shape.</p>
<p>It’s thus better to think about <code>px</code> as a “cloud cluster provision + cloud cluster execution engine” for arbitrary backend code projects. It’s not a database. It’s not a framework. It’s true infrastructure. It is a transparent layer below your code — but above your public cloud hardware.</p>
<p>The goal is to let you keep your code simple. To let you test your code locally. To let you debug your code ergonomically. And to give you a way to get your code shipped, running, and instrumented on just-in-time provisioned cloud clusters with ease.</p>
<p>For complex use cases, PX could be used as an alternative to frameworks like Ray/Spark running on a system like Amazon EMR/SageMaker or Google Dataproc/VertexAI. But these architectures are limited to only a few programming languages (usually Python), and were designed for very specific data science and machine learning workloads.</p>
<p>For simple backend use cases, PX could be used instead of AWS Lambda or GCP Cloud Run Jobs. Those are great “serverless” products, but they are limited to only a single cloud, by definition. They don’t leverage your existing Linux debugging skills. They don’t allow for easy local development workflows. Nor do they allow under-the-hood production debugging. They force you to program against a proprietary API and runtime environment. Those runtime environments are quirky and limited in various ways. And they hide the hardware underneath!</p>
<p>What about hand‑rolling a solution to this? Most backend teams eventually end up in the same place: a couple of special <code>cron</code> boxes, a maze of old <code>bash</code> scripts, and a tangle of cloud services wired together in ways nobody wants to touch anymore. It works… until it doesn’t.</p>
<p>At that point, the default answer is usually “let’s do some platform engineering.” Thus you get a shared Kubernetes cluster, a pile of YAML, and a small InfraOps/DevOps team acting as translators between backend engineers who say, “I just want to run this code!” and the reality of “This is how our cluster works.” That model can keep production up. But all the complexity and gatekeeping takes away from a backend engineer’s ability to ship.</p>
<p><a target="_blank" href="https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_market_position.png" rel="noopener"><img decoding="async" loading="lazy" src="https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_market_position.png" alt="" width="1287" height="671" srcset="https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_market_position.png 1287w, https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_market_position-300x156.png 300w, https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_market_position-1024x534.png 1024w, https://amontalenti.com/wordpress/wp-content/uploads/2025/11/px_market_position-768x400.png 768w" sizes="(max-width: 1287px) 100vw, 1287px"/></a>
</p>
<p>Our design with PX already works with your backend stack. We want to help backend engineers ship code every day. And, as a company, we are 100% focused on backend coder ergonomics. We want to make your backend cloud developer experience feel awesome. The way local development feels.</p>
<p>Shipping your production backend app should have the same rapid “build – test – debug” loop that you get when writing small programs for <a href="https://adventofcode.com/">Advent of Code</a> in a flow state!</p>
<p>PX also lets you reuse your Linux debugging skills. Because it gives you direct access to cloud hardware via Linux VMs. And direct access to nodes. Your code runs on those VMs in a way that is easy for you to understand and very similar to how code runs when it is tested locally on your laptop. Thanks to the PX design, however, there is more ability to leverage cheap instances (e.g. spot instances), to parallelize across data, and to survive/understand process crashes.</p>
<p>We want “from laptop to cloud cluster within seconds” to be the daily mantra of the <code>px</code> tool, the associated PX dashboard, and the overall developer experience. With PX, we hope to blaze a whole new path in the space.</p>
<h3>Where we are and where we’re going</h3>
<p>Right now, PX only supports one-off jobs (aka batch jobs). Because: you have to start somewhere. But already that covers quite a lot of use cases. You can use PX to bulk convert images or videos. To process piles of data files to transform them or load them into a data warehouse. To implement a web crawler. And many other humdrum and sophisticated software use cases besides.</p>
<p>We plan to add scheduled jobs (aka <code>cron</code> jobs) soon, which will cover many more use cases. And then streaming jobs after that. Once we have streaming, I believe PX will cover pretty much all backend programming use cases. Which then means it can be a unified cloud provisioning and execution engine, regardless of the shape of your code.</p>
<p>For this private beta launch, it only supports GCP. But it’ll support other clouds soon, starting with AWS. We want to build a community out of all backend programmers, regardless of language or cloud. There is a huge stack of common problems to solve. We also want to support the porting of systems and subsystems between languages, something much easier in the era of AI/LLMs.</p>
<p>So, this is just a start. But it could lead to something truly big!</p>
<p>There are between 25M and 100M+ self-described developers in the world today, depending <a href="https://github.blog/news-insights/octoverse/octoverse-a-new-developer-joins-github-every-second-as-ai-leads-typescript-to-1/">who is counting</a>. And many more are self-describing as developers thanks to the ease of generating working code from a natural language spec, thanks to AI/LLM tooling. The lion’s share of that code has to ship to the cloud if it’s going to see the light of day. I hope PX can help.</p>
<p>I’m quite excited about it. And so is the small and talented core engineering team we’ve built around it. This includes <a href="https://github.com/nbetm">Nelson Monserrate</a> and <a href="https://www.codyhiar.com/">Cody Hiar</a>, two amazing engineers who I’ve known and worked with for years. I also got an excellent design assist from <a href="https://marguerite.io/">Marguerite</a>, another talented former colleague from my last startup. This holiday season, I’m feeling thankful about getting to work with Nelson, Cody, and Marguerite again!</p>
<p>Feel free to reach out, sign up for our private beta waitlist, and we’ll help you make backend programming a joy again — whether for yourself, your company, or your next greenfield project.</p>
<p>Check out <a href="https://px.app">https://px.app</a> and let us know what you think. And if you have questions, shoot an email to <a href="https://amontalenti.com/cdn-cgi/l/email-protection#630b060f0f0c23131b4d101a1017060e10"><span data-cfemail="c7afa2ababa887b7bfe9b4beb4b3a2aab4">[email protected]</span></a>.</p>
<p>Happy hacking!</p>
<hr/>
<p><small><strong>Acknowledgements:</strong> Thank you to <a href="https://bourgoin.dev/about/">Keith Bourgoin</a> for reading a prepublication draft of this post and providing excellent detailed feedback that improved it before publication. Thank you also to Nelson, Cody, and Marguerite for reviewing earlier drafts.</small></p>
	</div><!-- .entry-content -->

	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
