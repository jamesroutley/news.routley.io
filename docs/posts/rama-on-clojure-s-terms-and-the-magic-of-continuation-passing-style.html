<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.redplanetlabs.com/2024/10/10/rama-on-clojures-terms-and-the-magic-of-continuation-passing-style/">Original</a>
    <h1>Rama on Clojure&#39;s terms, and the magic of continuation-passing style</h1>
    
    <div id="readability-page-1" class="page"><article id="post-2002">
	<!-- .entry-header -->

	<div>
		




<div><p><a href="https://blog.redplanetlabs.com/2023/08/15/how-we-reduced-the-cost-of-building-twitter-at-twitter-scale-by-100x/">Rama</a> is a platform with huge applicability, able to express all the computation and storage for a backend at any scale. Just like the UNIX philosophy of composing simple programs to do more complex tasks, Rama is based on simple building blocks that compose for any backend use case.</p>
<p>At the heart of Rama is its dataflow language, a Clojure library that’s also a full-fledged language. Rama’s dataflow language is based on <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">continuation-passing style</a> (CPS). Rama provides a clean and elegant way to express entire programs in CPS while producing bytecode that’s just as efficient as Clojure. In this post I’ll explore how Rama works in comparison to equivalent Clojure code written in a CPS style. You’ll see how CPS through Rama greatly generalizes the basic concept of a function, how that enables new ways of writing code in general, and how that is particularly liberating for writing parallel and asynchronous code.</p>
</div>



<p>You can follow along with the code in this post by cloning <a href="https://github.com/redplanetlabs/rama-demo-gallery">rama-demo-gallery</a> and opening a REPL with

<code>lein repl</code>

. Run the following to set up your REPL:</p>









<h2 id="Basic_example">Basic example</h2>



<p>Let’s start by defining the equivalent of Clojure’s

<code>identity</code>

function in Rama:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span>deframaop identity<span>-</span>rama <span>[</span><span>*</span>v<span>]</span></p></div></td></tr></tbody></table></div>

<p>Here we define a “Rama operation” called

<code>identity-rama</code>

that accepts one argument named

<code>*v</code>

. Variables in Rama code are symbols beginning with

<code>*</code>

. A “Rama operation” can do everything a regular Clojure function can – conditionals, loops, define anonymous operations with lexical closures, declare locals, etc. – plus it can do much more.</p>

<p>In this case, the body of

<code>identity-rama</code>

“emits” the value of

<code>*v</code>

to its caller using

<code>:&gt;</code>

. This is equivalent to the following Clojure code:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span><span>defn</span> identity<span>-</span>rama<span>-</span>clj <span>[</span>v cont<span>]</span></p></div></td></tr></tbody></table></div>

<p>In Rama code, the continuation is implicit and is invoked by calling

<code>:&gt;</code>

like a function. A Rama operation does not return a value to its caller. It emits values to its continuation. This is a critical distinction, as part of what makes Rama operations more general than functions is how they can emit multiple times, not emit at all, or emit asynchronously.</p>

<p>Note that Rama does not compile to Clojure code like this. It compiles straight to bytecode, which is necessary to achieve high performance.</p>

<p>Now suppose you want to call

<code>identity-rama</code>

with the value “Hello world!” and print the result. In Rama you would write this like so:</p>






<p>

<code>?&lt;-</code>

is called the “execution operator” and just dynamically executes some Rama code. It’s not used in production and is just for playing at the REPL like this. Here the string “Hello world!” is passed as input to our

<code>identity-rama</code>

operation. The

<code>:&gt; *str</code>

part binds the output of the operation to the variable

<code>*str</code>

. The

<code>:&gt;</code>

keyword distinguishes the input from the output and is called the “default output stream” (you’ll see soon how you can have more than one output stream). The variable

<code>*str</code>

is then passed to

<code>println</code>

.</p>

<p>Here’s the equivalent Clojure code in CPS:</p>



<p>So far, you can see from this example how Rama makes things more concise by eliminating nested callback functions from the code. Here’s a slightly more complicated example to show how unreadable CPS gets when done manually:</p>



<p>In Clojure with CPS versions of

<code>+</code>

and

<code>*</code>

, this looks like:</p>



<p>In addition to how unreadable all the nesting makes this, it’s also extremely inefficient. Every single “emit” uses up another stack frame, so it seems entire programs compiled this way will quickly overflow the stack. If this is all Rama was doing, that would indeed be the case. You’ll see later some important optimizations Rama makes so that dataflow code is just as efficient as idiomatic code in any other language. The continuation being implicit in Rama rather than explicit like in the Clojure CPS examples gives Rama critical flexibility to make those optimizations.</p>



<h2 id="Emitting_zero_or_multiple_times">Emitting zero or multiple times</h2>



<p>As mentioned, you don’t have to call the continuation exactly one time. You can call it multiple times, or you can call it zero times. You can also call it asynchronously, on a different thread, or even on a different machine. This is where the expressive power of dataflow starts to show itself.</p>

<p>Here’s an example of a

<code>deframaop</code>

that emits multiple times along with some code that uses it:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span>deframaop emit<span>-</span>many<span>-</span>times <span>[</span><span>]</span></p></div></td></tr></tbody></table></div>

<p>This is equivalent to this CPS Clojure function:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span><span>defn</span> emit<span>-</span>many<span>-</span>times<span>-</span>clj <span>[</span>cont<span>]</span></p></div></td></tr></tbody></table></div>

<p>Let’s now take a look at another

<code>deframaop</code>

that does filtering:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span>deframaop my<span>-</span>filter<span>&gt;</span> <span>[</span><span>*</span>v<span>]</span></p></div></td></tr></tbody></table></div>

<p>We’ll look more at conditionals later on in this post.

<code>my-filter&gt;</code>

is the same as the built-in operation <a href="https://redplanetlabs.com/clojuredoc/com.rpl.rama.html#var-filter.3E">filter&gt;</a> and is equivalent to:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span><span>defn</span> my<span>-</span>filter<span>&gt;-</span>clj <span>[</span>v cont<span>]</span></p></div></td></tr></tbody></table></div>

<p>As you can see here,

<code>my-filter&gt;</code>

emits zero values to its continuation. Emits can be done with any number of values, and in the next section you’ll see examples of emitting multiple values.</p>

<p>You could combine

<code>my-filter&gt;</code>

with

<code>emit-many-times</code>

to write code like this:</p>



<p>You can nest expressions in Rama code just like you can in Clojure code, and the above is the same as writing:</p>



<p>This is equivalent to:</p>



<p>Running any of these prints:</p>



<p>This code is kind of like doing a

<code>filter</code>

on a sequence followed by a

<code>doseq</code>

, except no sequences are materialized. It also reads kind of like a WHERE clause in SQL, in that the filter is expressed solely on the value in question with an arbitrary predicate, and computation only continues with values that match.</p>

<p>Operations can also emit a dynamic number of times. For example, Rama has an operation in its standard library called

<code>explode</code>

that’s equivalent to this CPS Clojure function:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span><span>defn</span> explode<span>-</span>clj <span>[</span>aseq cont<span>]</span></p></div></td></tr></tbody></table></div>

<p>You could use

<code>explode</code>

to print every element of a sequence like this:</p>



<p>This is the same as:</p>






<h2 id="Emitting_multiple_values_in_one_emit">Emitting multiple values in one emit</h2>



<p>Besides being able to emit multiple times, Rama operations can emit multiple values per emit. Here’s an example:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span>deframaop emit<span>-</span>many <span>[</span><span>*</span>v<span>]</span></p></div></td></tr></tbody></table></div>

<p>This is equivalent to the Clojure CPS code (for brevity, without doing

<code>inc</code>

,

<code>dec</code>

,

<code>*</code>

, or

<code>/</code>

in CPS):</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span><span>defn</span> emit<span>-</span>many<span>-</span>clj <span>[</span>v cont<span>]</span></p></div></td></tr></tbody></table></div>

<p>Something important here is the caller needs to know how many fields are expected to be given to the continuation. In Rama that’s specified by the number of variables bound to the

<code>:&gt;</code>

output stream, and in the Clojure version that’s specified by the arity of the passed continuation function. In both cases, you’ll get a runtime error if you bind the incorrect number of continuation outputs. Whereas with a Clojure function you only have to know what arities are valid for inputs, with Rama operations you also must know the arity of the output.</p>



<h2 id="Anonymous_operations">Anonymous operations</h2>



<p>Just like how you can declare anonymous functions in Clojure and pass them around as values, you can do the same in Rama with Rama operations. Like anonymous Clojure functions, anonymous Rama operations capture their lexical scope. Here’s a basic example of this:</p>



<p>

<code>&lt;&lt;ramaop</code>

defines an anonymous Rama operation with the given name, arguments, and body. Vars for anonymous operations are prefixed with

<code>%</code>

. There’s no difference in functionality between an anonymous Rama op and a top-level one. The above code is equivalent to this Clojure CPS code:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span><span>defn</span> adder<span>-</span>clj <span>[</span>v1 cont<span>]</span></p></div></td></tr></tbody></table></div>

<p>As alluded to before, Rama operations can be passed around as values. Here’s an example of passing around top-level Rama operations, anonymous Rama operations, and regular Clojure functions as values in Rama:</p>



<p>This prints “Result: 46”.</p>



<h2 id="Emitting_asynchronously">Emitting asynchronously</h2>



<p>Rama operations being able to emit asynchronously is what makes Rama so good for writing parallel and asynchronous code. To demonstrate this, I’ll briefly introduce you to Rama’s cluster programming environment which implements the underlying infrastructure powering the parallel programming primitives you’re about to see. A “Rama module” is what you deploy to a Rama cluster, and it uses dataflow to define all the data ingestion, processing, and indexing for a backend. A module is launched with a configurable number of partitions called “tasks”, and these tasks run across the cluster in processes launched for the module. Dataflow code runs across all tasks in parallel and defines how to react to incoming data.</p>

<p>For a basic example of distributed programming with dataflow, here’s code doing a bank transfer from

<code>*from-user-id</code>

to

<code>*to-user-id</code>

in the amount of

<code>*amt</code>

dollars. This code is a stripped down version of our <a href="https://github.com/redplanetlabs/rama-demo-gallery/blob/master/src/main/clj/rama/gallery/bank_transfer_module.clj">open-source atomic bank transfer example</a>, and the code for reading/writing that information to durable storage is mocked out to focus on the distributed programming aspects.

<code>$$funds</code>

here refers to a durable index, similar to a database.</p>



<p>

<code>|hash</code>

is called a “partitioner”, and it relocates computation to a different thread/node. The only difference with the other Rama operations you’ve seen is it emits to its continuation asynchronously and potentially on a different thread/node.

<code>|hash</code>

computes the target task by modding the hash of its argument by the total number of tasks in the module. Hashing ensures the same argument always goes to the same task, while different arguments get evenly distributed across all tasks.</p>

<p>Computation and storage are colocated in Rama. By using partitioners to control where code is executing, you’re able to control to which partitions of durable storage you read and write. This lets you control in a fine-grained way how data is partitioned across durable storage.</p>

<p>What makes partitioners powerful is they’re just like any other Rama operation, and that uniformity enables composition. You can use partitioners just like any other code, such as within conditionals, loops, or helper operations. Code is read linearly without any callback functions even though you’re jumping around the cluster with impunity.</p>

<p>Rama’s implementation of partitioners is similar to this Clojure CPS version:</p>



<p>Internally, every task of a module has a queue that runs events in the order in which they arrive. The event sent in this case is the continuation, which when called continues computation where it left off. This is no different than if the emit was done synchronously.</p>

<p>The Rama operation definition is similar, though since we haven’t exposed manipulating continuations in Rama’s public API, the following code is only representative of what the definition looks like internally:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span>deframaop <span>|</span>hash<span>-</span>pseudo <span>[</span><span>*</span>k<span>]</span></p></div></td></tr></tbody></table></div>

<p>

<code>&lt;&lt;continuation</code>

defines an anonymous Rama operation just like any other, with the difference being that it emits to the caller of its parent rather than its own caller. This is just like the Clojure CPS version: when

<code>cont</code>

is eventually invoked on the other thread/node, it invokes the code following the call of

<code>|hash-clj</code>

.</p>

<p>Rama takes care of efficiently serializing the continuation, including any information in its closure. The Rama compiler analyzes what vars are used after every invoke of an operation, and it uses that information to only include in the closure vars that are referenced in downstream code. This minimizes the amount of information sent across the wire. This compiler analysis isn’t specific to partitioners, as its used for closure construction for all anonymous operations.</p>

<p>Partitioners don’t have to emit just one time at one location. Sometimes, for example, you want to run code like this:</p>



<p>Code like this is typical for queries that fetch and aggregate information stored across all partitions.

<code>|all</code>

partitions to all tasks in parallel, and

<code>|global</code>

always goes to the same task.

<code>|all</code>

is defined approximately like this:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span>deframaop <span>|</span>all<span>-</span>pseudo <span>[</span><span>*</span>k<span>]</span></p></div></td></tr></tbody></table></div>

<p>And

<code>|global</code>

is defined approximately like this:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span>deframaop <span>|</span>global<span>-</span>pseudo <span>[</span><span>*</span>k<span>]</span></p></div></td></tr></tbody></table></div>

<p>CPS and the ability to emit asynchronously unifies general purpose programming with distributed programming, by enabling parallel code to be expressed no differently than any other logic. Partitioners enable Rama code to precisely control not just what is executing, but where.</p>




<h2 id="Emitting_to_multiple_output_streams">Emitting to multiple output streams</h2>



<p>Emitting zero or multiple times, emitting multiple values, and emitting asynchronously are three ways Rama operations are more general than functions. Another is that Rama operations can emit to output streams besides

<code>:&gt;</code>

.</p>

<p>Here’s an example Rama operation doing this:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span>deframaop emit<span>-</span>multiple<span>-</span>streams <span>[</span><span>]</span></p></div></td></tr></tbody></table></div>

<p>This emits to three streams:

<code>:&gt;</code>

,

<code>:a&gt;</code>

, and

<code>:b&gt;</code>

. Let’s take a look at an equivalent Clojure function in CPS. Instead of passing in one continuation function, we’ll now pass in a map from output stream to continuation function:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span><span>defn</span> emit<span>-</span>multiple<span>-</span>streams<span>-</span>clj <span>[</span>cont<span>-</span><span>map</span><span>]</span></p></div></td></tr></tbody></table></div>

<p>This isn’t totally accurate, as Rama does not require a caller to provide a continuation for each output stream. If there’s no continuation, then emitting to that output stream is a no-op. So the Clojure code that matches what Rama does is this:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span><span>defn</span> emit<span>-</span>multiple<span>-</span>streams<span>-</span>clj <span>[</span>cont<span>-</span><span>map</span><span>]</span></p></div></td></tr></tbody></table></div>

<p>Invoking a Rama operation that emits multiple output streams is a little bit different, as each output stream is a different code path. Here’s an example:</p>



<p>Rama code produces an “abstract syntax graph” (ASG), whereas Clojure (and most other languages) produce an “abstract syntax tree” (AST).

<code>&lt;emitted-a&gt;</code>

and

<code>&lt;b&gt;</code>

are called “anchors” and label part of the ASG. Those anchors are used by

<code>&lt;&lt;branch</code>

to specify where that code should attach. You can visualize this code like so:</p>



<figure><img data-recalc-dims="1" decoding="async" width="656" height="275" data-attachment-id="2040" data-permalink="https://blog.redplanetlabs.com/2024/10/10/rama-on-clojures-terms-and-the-magic-of-continuation-passing-style/branching/" data-orig-file="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2024/10/branching.png?fit=786%2C329&amp;ssl=1" data-orig-size="786,329" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="branching" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2024/10/branching.png?fit=300%2C126&amp;ssl=1" data-large-file="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2024/10/branching.png?fit=656%2C275&amp;ssl=1" tabindex="0" role="button" src="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2024/10/branching.png?resize=656%2C275&amp;ssl=1" alt="" srcset="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2024/10/branching.png?w=786&amp;ssl=1 786w, https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2024/10/branching.png?resize=300%2C126&amp;ssl=1 300w, https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2024/10/branching.png?resize=768%2C321&amp;ssl=1 768w" sizes="(max-width: 656px) 100vw, 656px"/></figure>



<p>Rama has <a href="https://redplanetlabs.com/docs/~/clj-dataflow-lang.html#_branching">other ways</a> to specify how code should be attached. In this particular case, since each stream has only one line of code attached to it, the above code can be written more concisely as:</p>






<p>

<code>:&gt;&gt;</code>

is called an inline hook and automatically handles setting up anchors and branching.</p>

<p>The above can be written with Clojure CPS like so:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span>emit<span>-</span>multiple<span>-</span>streams<span>-</span>clj</p></div></td></tr></tbody></table></div>

<p>All of these print:</p>



<p>As mentioned, you can also call

<code>emit-multiple-streams</code>

without providing continuations for every output stream. For example:</p>



<p>This is equivalent to:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span>emit<span>-</span>multiple<span>-</span>streams<span>-</span>clj</p></div></td></tr></tbody></table></div>

<p>Both of these print:</p>



<p>Each continuation and the code attached to it is fully executed before the subsequent line of

<code>emit-multiple-streams</code>

is run. The behavior of Rama is exactly the same as the Clojure CPS version in this respect.</p>

<p>Rama provides an operation called

<code>if&gt;</code>

which is the basic primitive for specifying conditional behavior.

<code>if&gt;</code>

takes in a value and emits to

<code>:then&gt;</code>

or

<code>:else&gt;</code>

depending on the truthiness of that value. The operation

<code>&lt;&lt;if</code>

mentioned before is a Rama macro (called “segmacro”) implemented using

<code>if&gt;</code>

. Here’s an example of usage of

<code>if&gt;</code>

:</p>



<p>This prints “False”. Unlike

<code>if</code>

in Clojure (as well as the equivalent in pretty much every other programming language),

<code>if&gt;</code>

is not a special form in Rama. It doesn’t have to be, since it’s no different than any other Rama operation. So it can be passed around just like any Rama operation, like so:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span>deframaop exec<span>-</span>if<span>-</span>like<span>-</span>op <span>[</span><span>%</span>f <span>*</span>v<span>]</span></p></div></td></tr></tbody></table></div>

<p>This prints “Result: True branch”.</p>

<p>So far, I’ve never found a reason to pass

<code>if&gt;</code>

around dynamically like this. What this demonstrates is how Rama’s richer language primitives provide greater uniformity and less special cases.</p>

<p>Also important to note is that

<code>if&gt;</code>

produces exactly the same bytecode as Clojure’s

<code>if</code>

when invoked directly (not as an anonymous operation). Rama accomplishes this with an “intrinsic” implementation for

<code>if&gt;</code>

in its compiler. This doesn’t change anything about semantics and is purely an optimization.</p>



<h2 id="Unification">Unification</h2>



<p>Rama’s “unification” facility enables separate branches of computation to be merged together. It’s another way to share code that fits naturally into dataflow. Here’s an example:</p>






<p>You can visualize this code like so:</p>



<figure><img data-recalc-dims="1" decoding="async" width="359" height="374" data-attachment-id="2049" data-permalink="https://blog.redplanetlabs.com/2024/10/10/rama-on-clojures-terms-and-the-magic-of-continuation-passing-style/unify/" data-orig-file="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2024/10/unify.png?fit=359%2C374&amp;ssl=1" data-orig-size="359,374" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="unify" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2024/10/unify.png?fit=288%2C300&amp;ssl=1" data-large-file="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2024/10/unify.png?fit=359%2C374&amp;ssl=1" tabindex="0" role="button" src="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2024/10/unify.png?resize=359%2C374&amp;ssl=1" alt="" srcset="https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2024/10/unify.png?w=359&amp;ssl=1 359w, https://i0.wp.com/blog.redplanetlabs.com/wp-content/uploads/2024/10/unify.png?resize=288%2C300&amp;ssl=1 288w" sizes="(max-width: 359px) 100vw, 359px"/></figure>



<p>

<code>unify&gt;</code>

is a compile-time directive on how to construct the abstract syntax graph. When either

<code>:a&gt;</code>

or

<code>:b&gt;</code>

emit, the code continues on the shared code after the

<code>unify&gt;</code>

.

<code>unify&gt;</code>

can merge any number of branches, not just two.</p>

<p>Since the code after a

<code>unify&gt;</code>

is shared among all its parent branches, there are rules regarding what vars are in scope after a

<code>unify&gt;</code>

. Only vars defined in all parent branches are in scope. So if you try to reference a var after a

<code>unify&gt;</code>

that doesn’t exist in all of the parent branches, you’ll get a compile-time error.</p>

<p>The above code can be written in Clojure CPS like so:</p>



<p>As you can see, the only way to share code across the two branches is to factor out a helper function defined <b>before</b> the code that executes first. The dataflow version reads much nicer since the code is ordered the same way it executes.</p>



<h2 id="Loops">Loops</h2>



<p>Dataflow loops are similar to Clojure loops, but like Rama operations they can emit any number of times. Here’s an example of a dataflow loop:</p>






<p>Like a Clojure loop, a dataflow loop has bindings along with initial values. Here the variable

<code>*a</code>

is initialized to 10. The bindings vector also binds emits from this loop to output variables which will be in scope after the loop – 

<code>*v</code>

in this case. A loop is recurred with

<code>continue&gt;</code>

, and emits are done with

<code>:&gt;</code>

just like emitting from a Rama operation.</p>

<p>This is equivalent to the following Clojure code:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span><span>let</span> <span>[</span>cont <span>(</span><span>fn</span> <span>[</span>v<span>]</span> <span>(</span>println <span>&#34;Emitted:&#34;</span> v<span>)</span><span>)</span><span>]</span></p></div></td></tr></tbody></table></div>

<p>Loops compose with everything else in dataflow, including partitioners. This makes it trivial to do distributed loops that hop around the cluster. Such loops are common with graph algorithms where you may be traversing from node to node fetching connections from each partition. For example:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span>loop<span>&lt;-</span> <span>[</span><span>*</span>node<span>-</span>id <span>*</span>start<span>-</span>node<span>-</span>id :<span>&gt;</span> <span>*</span>ancestor<span>-</span>node<span>]</span></p></div></td></tr></tbody></table></div>

<p>Like before, the details of storage are mocked out to focus on the computation aspects. Here

<code>$$parents</code>

represents a datastore mapping the parent for every node. This code fetches all ancestors for a node ID by traversing the graph across the cluster in a loop.</p>



<h2 id="Optimizations_in_dataflow_compiler">Optimizations in dataflow compiler</h2>



<p>As mentioned earlier, passing a continuation on every invocation is inefficient and would likely cause a stack overflow if done for every invocation in a program. Rama has a number of optimizations to make the bytecode it produces just as efficient as Clojure. I’ll focus on one particularly important optimization.</p>



<p>When a Rama operation emits exactly one time, synchronously, and as the last thing it does, then it’s like a function. Rama provides two ways of defining operations:

<code>deframaop</code>

, as already shown, and

<code>deframafn</code>

.

<code>deframafn</code>

is just like

<code>deframaop</code>

except its implementation must synchronously emit exactly one time to the

<code>:&gt;</code>

stream as the last thing it does.</p>

<p>For every invoke, Rama determines if it’s executing a

<code>deframaop</code>

or a

<code>deframafn</code>

. If it’s a

<code>deframafn</code>

, then it invokes it just like how functions are invoked in Clojure by unrolling the stack frame with the return value. For example, consider this Rama code:</p>

<div><table><tbody><tr><td></td><td><div><p><span>(</span>deframafn double<span>-</span>value <span>[</span><span>*</span>v<span>]</span></p></div></td></tr></tbody></table></div>

<p>The Rama execution will be very similar to this Clojure CPS:</p>



<p>The calls to

<code>double</code>

and

<code>println</code>

do not pass a continuation and instead do optimized invokes as functions.</p>

<p>It’s also worth noting that since a

<code>deframafn</code>

works just like a Clojure function, it can be invoked directly from Clojure like any Clojure function.</p>

<p>

<code>deframafn</code>

only has restrictions on emits to the

<code>:&gt;</code>

output stream – it can emit to all other streams any number of times and/or asynchronously. Internally, we refer to operations like that as “semi-functions”. Rama determines whether a

<code>deframafn</code>

is a semi-function or regular function by statically analyzing whether emits are done to any other output stream beside

<code>:&gt;</code>

. If so, invokes of that operation will unroll the stack <b>and</b> pass a continuation for the other output streams.</p>

<p>Finally, the <a href="https://redplanetlabs.com/clojuredoc/com.rpl.rama.html#var-ramafn.3E">ramafn&gt;</a> annotation can be used to tell Rama an anonymous operation is a

<code>ramafn</code>

.</p>

<p>The

<code>ramafn</code>

optimization is critical because the majority of code is still best written with function semantics. So most of a codebase will compile to stack-efficient invokes. Emitting multiples times, zero times, or asynchronously is powerful but less common.</p>

<p>The general term we use to refer to an object which is either a

<code>ramafn</code>

or

<code>ramaop</code>

is “fragment”. A

<code>ramafn</code>

is a fragment that has restrictions on the

<code>:&gt;</code>

stream, while a

<code>ramaop</code>

has no restrictions.</p>



<h2 id="Conclusion">Conclusion</h2>



<div><p>Dataflow turns CPS into a full-fledged programming paradigm that’s elegant and efficient. This paradigm isn’t just for backend programming, like data processing, indexing, and querying. It’s a general purpose paradigm that we’ve used for building a huge amount of Rama itself. Emitting zero times, multiple times, asynchronously, or to multiple output streams are major generalizations of functions that open up huge new avenues to explore in the craft of programming. One of the joys of working on Rama has been the opportunity to explore and develop new techniques utilizing this new programming paradigm.</p>
<p>There’s a lot I didn’t cover in this post, like “segmacros” (macros that produce dataflow code) and “batch blocks” (a slightly declarative form of dataflow that has equivalent functionality as relational languages, like joins and aggregation). These additional capabilities are documented on <a href="https://redplanetlabs.com/docs/~/clj-dataflow-lang.html">this page</a>.</p>
<p>Rama as a cluster platform adds durable storage into the mix, using dataflow to process distributed logs and produce indexes of any shape. It generalizes the ideas of event sourcing and materialized views into a unified system, providing strong fault-tolerance and <a href="https://redplanetlabs.com/docs/~/acid.html">ACID semantics</a>. Dataflow is one of the keys to how it’s such a generally applicable platform, as it gives tight control over what, where, and how code executes.</p>
</div>
			</div><!-- .entry-content -->

	<!-- .entry-footer -->

	</article></div>
  </body>
</html>
