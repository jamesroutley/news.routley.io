<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sequin.io/how-we-used-elixirs-observer-to-hunt-down-bottlenecks/">Original</a>
    <h1>We used Elixir&#39;s Observer to hunt down bottlenecks</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
      <blockquote>Want to work on challenging distributed systems problems with Elixir and OTP? Sequin lets developers integrate with APIs using Postgres. We use a suite of OTP tools to sync data in real-time. <a href="https://www.sequin.io/careers">We&#39;re hiring</a>, no Elixir experience required.</blockquote><p>We recently experienced some puzzling runtime characteristics: our machine reported a high load average but only moderate CPU utilization. All cores on our machine were evenly utilized, consistently at about 40%. Nonetheless, our performance benchmarks degraded – the machine <em>felt</em> overloaded. We turned to Observer to figure out why.</p><p>Observer is a great diagnostic tool for Elixir/Erlang applications. It&#39;s like Activity Monitor or <code>htop</code> for the BEAM. You can see the overall health stats of a running node, understand how cores are being utilized by the scheduler, and drill down to individual processes to see if anything is amiss:</p><figure><img src="https://blog.sequin.io/content/images/2022/08/observer-overview.png" alt="elixir observer main window, showing various stats" loading="lazy"/></figure><p>Observer has a lot of functionality, but this post will focus on the parts we found most helpful in our investigation.</p><h2 id="investigation">Investigation</h2><p>To understand the insights Observer is presenting, you&#39;ll need to know a little about the Elixir/Erlang runtime. So I&#39;ll switch between describing properties of the Erlang VM (the BEAM) and how Observer helps you inspect them.</p><p>We&#39;ll start with the fundamentals of the BEAM: processes and schedulers.</p><h3 id="processes-and-schedulers">Processes and schedulers</h3><p>Erlang was built from the ground up to support tremendous concurrency. Erlang processes are lightweight and fast to create and terminate – they can send messages to one another, but each has its own isolated memory. Processes are managed by the BEAM, not the underlying operating system.</p><p>The BEAM boots a <em>scheduler</em> for each core on its host machine. A scheduler distributes &#34;air time&#34; on a CPU core among processes. If you have ten processes running CPU-intensive tasks on a single-core machine, the scheduler will distribute CPU core time between them: it will allow Process A to run for a bit, then interrupt it to give Process B a little time, and so on.</p><p>Naturally, if you run those same 10 processes on a multi-core machine, the work will be distributed among those cores evenly.</p><p>Utilizing all cores efficiently is half the motivation for using processes. The other half is I/O. A process waiting on an I/O operation – say, a request to a remote webserver – uses almost no resources (outside its memory allocation) while it waits for a response.</p><h3 id="the-run-queue">The run queue</h3><p>The &#34;System&#34; tab is the first one you see after launching Observer:</p><figure><img src="https://blog.sequin.io/content/images/2022/08/observer-overview-2.png" alt="elixir observer main window, showing various stats" loading="lazy"/></figure><p>This tab shows you memory usage, helpfully broken out between things like processes and binaries (strings). Of most interest to us was the &#34;Run Queue&#34; stat.</p><p>When a process needs CPU time but can&#39;t be scheduled immediately, it enters its scheduler&#39;s <em>run queue</em>.</p><p>An item is in the run queue because you have more work than you have CPUs to do it. In our previous example of a single-core machine with a single scheduler juggling 10 CPU-intensive processes, the run queue would be pegged at 9: there are 9 processes that want CPU time, but are awaiting their turn because there aren&#39;t any idle cores.</p><p>You can test this for yourself. On my computer, I popped open <code>iex</code> and defined this recursive function which performs a CPU-intensive task:</p><pre><code>defmodule A do
  # define a module function, which can call itself recursively
  def gen_recursive do
    :public_key.generate_key({:rsa, 4096, 65537})
    gen_recursive()
  end
end
</code></pre><p>Then I ran the following loop to spawn twice as many processes as I have cores. <code>System.schedulers_online</code> is a helper function that returns how many cores are available to the BEAM:</p><pre><code>for _n &lt;- 1..(System.schedulers_online * 2) do
  # spawn_link/1 starts a new process
  spawn_link(fn -&gt; A.gen_recursive() end)
end
</code></pre><p>With those processes booted, I ran <code>:observer.start</code>. I have 8 cores on my machine but there are 16 CPU-intensive processes running, all vying for CPU time. At any give time, there are 8 in the run queue:</p><figure><img src="https://blog.sequin.io/content/images/2022/08/observer-run-queue-8.png" alt="elixir observer main window, run queue is highlighted at 8" loading="lazy"/></figure><p>José Valim, Elixir&#39;s creator, confirms you want to keep this number <em>very</em> low, like below half your CPU core count. A longer run queue indicates your machine can&#39;t keep pace with all the work you&#39;re trying to do.</p><p>Take a look at how the &#34;Load Charts&#34; tab in Observer looked during our investigation. Our CPU cores aren&#39;t working at capacity, but the schedulers are reporting they are completely busy:</p><figure><img src="https://blog.sequin.io/content/images/2022/08/schedulers.png" alt="elixir observer, schedulers tab, showing three graphs" loading="lazy"/></figure><p>The combination of a high run queue and high scheduler utilization confirmed our suspicions: Sequin&#39;s machine was overloaded.</p><p>Even so, instead of just throwing more resources at our application, we wanted to understand more about <em>why</em> the machine was overloaded. We dug deeper into Observer. The &#34;Processes&#34; tab proved instrumental.</p><h2 id="optimizing-processes">Optimizing processes</h2><p>The &#34;Processes&#34; tab lists all processes running on the node. For each process on this tab, you can see these high-level attributes:</p><h3 id="reductions">Reductions</h3><p>You can sort processes by <em>reductions</em>, or the number of function calls that have happened inside the process. This may tell you if a particular process/module is overactive. For us, reductions didn&#39;t reveal anything unexpected.</p><h3 id="memory">Memory</h3><p>Next, you can sort by memory usage (in bytes) to get a sense of which processes hog or leak it. The beautiful part about the BEAM is that once you have a process in your sights, you can easily dig in deeper to figure out what&#39;s amiss.</p><p>You can right click on a process and pull up its process info:</p><figure><img src="https://blog.sequin.io/content/images/2022/08/process-drilldown.png" alt="" loading="lazy" width="2000" height="1522" srcset="https://blog.sequin.io/content/images/size/w600/2022/08/process-drilldown.png 600w, https://blog.sequin.io/content/images/size/w1000/2022/08/process-drilldown.png 1000w, https://blog.sequin.io/content/images/size/w1600/2022/08/process-drilldown.png 1600w, https://blog.sequin.io/content/images/2022/08/process-drilldown.png 2091w" sizes="(min-width: 720px) 720px"/></figure><p>This gives us a little more detail. If you <em>really</em> want to understand where that memory allocation is coming from, hop over to your <code>iex</code> shell.</p><p>In the shell, you can use <code>:sys.get_state/1</code> to get the state of a GenServer. The process you care about is likely a GenServer and, unless it has a big message queue, the memory consumption you&#39;re concerned about is probably in its state.</p><p>To get a shell on your remote Erlang node you can <a href="https://railsware.com/blog/interconnecting-elixir-nodes/">jump over there from your local shell</a>. Once logged in, you need to create a PID literal to pass to <code>:sys.get_state/1</code>. You&#39;ll be tempted to take the PID as you see it in observer and do this:</p><pre><code>:c.pid(11972, 14658, 0)
</code></pre><p>But then you&#39;ll hit this issue:</p><pre><code>** (ArgumentError) errors were found at the given arguments:

* 1st argument: not a textual representation of a pid

:erlang.list_to_pid(&#39;&lt;11972.14658.0&gt;&#39;)
</code></pre><p>Why&#39;s this? Because the first number in a PID&#39;s address is the number of the node. You booted Observer in your local shell <em>on your local node</em>. Your local node always has address <code>0</code>. It assigned <code>11972</code> to the remote node in this example.</p><p>Now that you&#39;re on the remote node, the address of this PID is prefixed with a <code>0</code>!</p><pre><code>(iex)&gt; :c.pid(0, 14658, 0)
#PID&lt;0.14658.0&gt;
</code></pre><p>Great. Now you can pipe that pid to <code>:sys.get_state/1</code> and see a full dump of the GenServer&#39;s state.</p><h3 id="message-queue-length">Message queue length</h3><p>As we discussed, the message queue is a process&#39; mailbox. When one process sends a message to another, that message is copied into the receiving process&#39; message queue. Most message sending happens <em>synchronously</em> (i.e. via <code>GenServer.call/2</code>). So, when one GenServer calls another, it blocks until it receives a reply.</p><p>If a process is &#34;backed up&#34; with a large message queue, that&#39;s an indication of a bottleneck. Ideally, any GenServer that&#39;s expected to field messages should be immediately responsive. All I/O or CPU intensive work in your system should be pushed to the edges, to GenServers or Tasks that are dedicated to working and don&#39;t need to answer to other GenServers. Seeing even a few messages in a process&#39; queue may warrant reconsidering your system design.</p><h2 id="process-memory-usage">Process memory usage</h2><p>Sequin didn&#39;t have any processes that had an outlier count of reductions. &#34;Message queue length&#34; helped us fix a couple situations where a process was overwhelmed with requests.</p><p>But our biggest improvement was minimizing process memory.</p><p>As an immutable language, Elixir manipulates lists and maps efficiently. For example, suppose you&#39;ve instantiated one variable as a list <code>items</code>. If you create a new variable with <code>items</code> as its tail – something like <code>[&#34;head&#34; | items]</code> – it&#39;ll embed a reference to <code>items</code> without copying it.</p><p>Processes, however, don&#39;t share memory between each other. This makes sense; among other things, doing so would make garbage collection much more difficult.</p><p>When one process sends a message to another, that message is inserted into the receiving process&#39; <em>message queue</em>. That message queue is located inside the receiving process&#39; <em>process heap</em>. Therefore, the message – and all variables inside of it – is copied.</p><p>This means you should be mindful about passing around your large data structures.</p><p>Our codebase has several instances of the process pool pattern where a primary GenServer relies on a pool of worker processes to do I/O work. We made two big improvements in our implementation of this pattern:</p><p>First, we had instances where every time a worker received a new job, it also received a data structure that could get large (tens of megabytes) but that didn&#39;t change between jobs. Every time the worker grabbed a job, it re-copied that unchanged data into its heap. Instead, we could have the worker receive the data structure on its first run, then never receive it again.</p><p>Second, we passed one particularly large data structure from a manager to a pool of dedicated worker processes. This meant we were reincurring the memory cost of this data structure for each worker process. We couldn&#39;t eliminate the repetition, but reducing the data to its bare essentials before passing it down to the workers minimizes that cost.</p><blockquote>For the astute: No, using something like ETS would not resolve this memory-sharing problem. When a process retrieves data from ETS, that data too is copied into its process heap.</blockquote><h2 id="recap">Recap</h2><p>After running our investigation with Observer and performing some optimizations, we have a better handle on our system&#39;s runtime properties and how to introspect them.</p><p>We used a combination of the run queue and scheduler utilization to confirm our machine was overloaded and at scale. Then we used the &#34;Processes&#34; tab to identify process bottlenecks. We optimized our process memory overhead and rearchitected processes that were occasionally overloaded by messages.</p><p>We&#39;re feeling well-equipped for the next time. I hope you do too!</p><blockquote>Join the discussion: <a href="https://news.ycombinator.com/item?id=32566891">https://news.ycombinator.com/item?id=32566891</a></blockquote><h2 id="appendix-a-running-observer">Appendix A: Running Observer</h2><p>Ready to try out Observer yourself?</p><p>While Observer does come with a CLI tool that&#39;s easier to run in production, I think it&#39;s worth it to do a little more work to get Observer running in its GUI.</p><p>One of the killer features of Elixir/the BEAM is the ability to connect two nodes on separate machines. When two nodes are connected, a process from one node can send a message to a process in another node.</p><p>We can use this feature to run a local instance of Observer that&#39;s connected to a remote node.</p><p>To pull this off, we use <a href="https://github.com/chazsconi/connect-remote-elixir-docker">this great little script</a> which focuses specifically on a remote Elixir node running inside a docker container. The basic idea:</p><ul><li>The script boots a local instance of iex (Elixir&#39;s REPL).</li><li>The script opens an SSH tunnel between your machine and the machine running your Docker container.</li><li>In the machine running your Docker container, the script runs a <code>docker exec</code> command that instructs the node to connect to your local instance of iex.</li></ul><p>Once the two are wired up, you can simply run <code>:observer.start</code> in your local REPL to boot Observer. It will default to showing you stats for your local iex Node. In the menubar at the top, you&#39;ll select &#34;Nodes&#34; then your production Node.</p><blockquote>Here&#39;s a grab-bag of other notes for this setup:</blockquote><h2 id="appendix-b-starving-the-system">Appendix B: Starving the system</h2><p>While measuring and optimizing, we ran an experiment that allowed the team to shape our mental model of processes and schedulers with a real-world example operating at the limits.</p><p>We have one codepath that is called frequently but is very CPU intensive. We were curious what would happen if we parallelized the process using <a href="https://hexdocs.pm/flow/Flow.html">Flow</a>. Flow is an Elixir library that makes it easy to create data pipelines that fan units of work out into processes. So the same amount of work would be completed, but it would be chunked and processed in parallel.</p><p>The result? The operation ran much faster. But, the rest of the system suffered. The graph for the execution time of the operation plummeted, but the graphs for latency in other parts of the system climbed in kind.</p><p>We quickly figured out what was happening: This operation, with its massive parallelization, was <em>starving</em> the rest of the system. Imagine that our already-overloaded scheduler was originally in charge of distributing work among 10 processes that each needed CPU time. Then this operation starts. Without Flow, this operation would be a single process. With Flow, it spins up to a total of 10 processes. That means 20 processes that each need CPU time. The scheduler round-robins execution time between these processes. Because 10 of those processes are dedicated to the operation, the operation gets 50% of the core&#39;s air time!</p><p>Flow shines when you&#39;re running a CPU- or IO-intensive task and have cores on your machine to spare. But use caution if operating at the limits or if the task is running constantly. You may end up over-allocating resources towards it.</p>
    </div>

    <!-- The design of the summary of contents / table of contents is ready, and here. Yet, it still needs to import the headings
    <div class="absolute h-full top-2 -left-72">
      <div class="sticky top-28 p-4 rounded bg-gray-100 w-60 flex flex-col gap-2.5">
        <a class="p-4 bg-black dark:bg-gray-700 dark:hover:bg-gray-600 hover:bg-gray-800 hover:shadow-xl transition-all text-root text-white w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Introduction  
        </a>
        <a class="p-4  bg-white dark:bg-gray-400 dark:hover:bg-gray-600 hover:bg-gray-200 hover:shadow-xl transition-all text-root text-black w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Chapter 1  
        </a>
            <a class="p-4 bg-white dark:bg-gray-400 dark:hover:bg-gray-600 hover:bg-gray-200 hover:shadow-xl transition-all text-root text-black w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Chapter 2  
        </a>
            <a class="p-4 bg-white dark:bg-gray-400 dark:hover:bg-gray-600 hover:bg-gray-200 hover:shadow-xl transition-all text-root text-black w-full h-12 rounded inline-flex flex-row items-center cursor-pointer font-bold font-display">
          Chapter 3  
        </a>
      </div>
    </div>
    -->
    
  </div></div>
  </body>
</html>
