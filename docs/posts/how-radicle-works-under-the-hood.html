<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://radicle.xyz/guides/protocol">Original</a>
    <h1>How Radicle Works Under the Hood</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      <p>How Radicle works under the hood</p>
      
      <ul><li><a href="#introduction">Introduction</a></li><li><a href="#nodes">Nodes</a><ul><li><a href="#seeding-repositories">Seeding Repositories</a></li><li><a href="#node-identifiers-nids">Node Identifiers (NIDs)</a></li><li><a href="#running-a-node">Running a Node</a></li></ul></li><li><a href="#peer-to-peer-protocol">Peer-to-peer Protocol</a><ul><li><a href="#gossip-protocol">Gossip Protocol</a></li><li><a href="#transport-encryption--privacy">Transport Encryption &amp; Privacy</a></li><li><a href="#replication-via-git">Replication via Git</a></li><li><a href="#bootstrap-nodes">Bootstrap Nodes</a></li><li><a href="#federation-vs-peer-to-peer">Federation vs. Peer-to-peer</a></li></ul></li><li><a href="#repositories">Repositories</a><ul><li><a href="#delegates">Delegates</a></li><li><a href="#identity-document">Identity Document</a></li><li><a href="#private-repositories">Private Repositories</a></li><li><a href="#repository-identifier-rid">Repository Identifier (RID)</a></li></ul></li><li><a href="#local-first-storage">Local-First Storage</a><ul><li><a href="#working-vs-stored-copy">Working vs. Stored Copy</a></li><li><a href="#storage-layout">Storage Layout</a></li><li><a href="#git-url-scheme">Git URL Scheme</a></li></ul></li><li><a href="#trust-through-self-certification">Trust through Self-Certification</a><ul><li><a href="#canonical-branches">Canonical Branches</a></li><li><a href="#self-certifying-repositories">Self-certifying Repositories</a><ul><li><a href="#signed-refs">Signed Refs</a></li></ul></li></ul></li><li><a href="#collaborative-objects">Collaborative Objects</a><ul><li><a href="#concurrency--consistency">Concurrency &amp; Consistency</a></li><li><a href="#extending-cobs">Extending COBs</a></li></ul></li><li><a href="#conclusion">Conclusion</a></li></ul>
      <hr/>
      <p>Heartwood, the latest generation of the <a href="https://radicle.xyz/">Radicle</a> protocol establishes a
sovereign data network for code collaboration and publishing, built on top of
<a href="https://git-scm.com/">Git</a>. In Radicle, users maintain local copies of their repositories of
interest and related social artifacts such as issues and patches. Instead
of depending on a centralized service like GitHub, each participant in Radicle
operates a node that is capable of running on a personal computer, and is
connected via a peer-to-peer network.</p>

<p>Nodes, identified by <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">public keys</a>, host and synchronize Git repositories
across the network, using a novel gossip protocol for peer and repository
discovery, alongside Git’s <a href="https://git-scm.com/docs/protocol-v2">protocol</a> for data replication. In
combination, this allows nodes to locate, replicate, and verify any repository
published to the network, provided at least one other peer seeding the
repository is online. Since Radicle is built on Git, it can easily interoperate
with existing tools and workflows.</p>

<p>Radicle’s architecture is <a href="https://www.inkandswitch.com/local-first/">local-first</a>, ensuring continuous access to one’s
repositories directly from their device, regardless of internet connectivity.
Repositories have unique identifiers and are self-certifying, meaning all
actions, from committing code to adding a comment to an issue, are performed
locally and <a href="https://en.wikipedia.org/wiki/Digital_signature">cryptographically signed</a>, allowing peers to verify
authenticity and data provenance once propagated to the network. This allows
trust to be established without reliance on a centralized authority.</p>

<p>Radicle is designed for extensibility, allowing for diverse use cases without
necessitating modifications at the protocol level. This guide delves into the
capabilities of Radicle’s initial release, which has a focus on code
collaboration and code publishing. Nonetheless, a range of other applications
is foreseen in the future and possible today, including knowledge sharing,
project coordination, and data set collaboration.</p>

<h2 id="introduction">Introduction</h2>

<p>Git, the most widely-used distributed version control system, enables users to
maintain and modify personal copies of data repositories, commonly for source
code control. Its structure for direct user-to-user collaboration, while
feasible, is often cumbersome since Git primarily focuses on version control
rather than collaboration. As a result, users frequently opt for centralized
<a href="https://en.wikipedia.org/wiki/Forge_(software)">forges</a> like GitHub or GitLab, which offer enhanced interfaces and
collaborative tools on top of Git, such as project management and code review.
This dependency, however, can result in vendor lock-in since it places a
project’s social artifacts (e.g. issues, comments, pull requests) out of user
control, potentially compromising data sovereignty and other user freedoms.</p>

<p>Traditional self-hosted forges like <a href="https://about.gitea.com/">Gitea</a> or <a href="https://forgejo.org/">Forgejo</a> provide more
sovereignty but often lead to fragmented collaboration environments, as users
must create separate profiles for each hosted instance. This simultaneously
limits a project’s exposure to the wider open source community, a key advantage
of platforms like GitHub, which have grown significantly due to network
effects. This isolation can impact the visibility and collaborative potential
of projects that choose traditional self-hosted solutions.</p>

<p>The Radicle protocol, in contrast, extends Git’s capabilities with a
decentralized identity system, novel gossip protocol, and integrated social
artifacts, forming a <em>self-hosted network for code collaboration</em>. Radicle
locates, serves, and replicates Git repositories – including artifacts –
across a <a href="https://en.wikipedia.org/wiki/Peer-to-peer">peer-to-peer</a> network while maintaining data authenticity via
cryptographic signatures, so peers can directly exchange data without the need
for a trusted third party. This enables communities to both self-host and share
their repositories across a distributed protocol, contributing to the emergence
of a new sovereign network for code collaboration and more.</p>

<h2 id="nodes">Nodes</h2>

<p>Radicle is a <a href="https://en.wikipedia.org/wiki/Peer-to-peer">peer-to-peer</a> system, which means that there is no traditional
client-server model. Peers on the Radicle network are referred to as <em>nodes</em>,
and are indistinguishable from users at the protocol level. Nodes, identified
by their <a href="#node-identifier-nid">Node ID</a> (NID) – an <a href="https://ed25519.cr.yp.to/">Ed25519</a> public
key – are responsible for seeding Git repositories, each identified by a unique
<a href="#repository-identifier-rid">Repository ID</a> (RID). The seeding process involves
both hosting the repository data and synchronizing changes with other nodes.
Every Radicle user, irrespective of their role or activity, runs a node on
their device. No specialized equipment is necessary for operating a node as a
typical end-user; nodes can run on a personal computer without requiring a
server.</p>



<h3 id="seeding-repositories">Seeding Repositories</h3>

<p>Whenever a user clones, initializes, or opts to seed a repository, their node’s
seeding policy is changed to reflect their choices. This policy establishes the
repositories they are interested in and sets the rules for data retention, and
synchronization, allowing users to have direct control over which repositories
are kept on their device and offered to the network.</p>

<p>The typical end-user may choose to only seed the repositories they are actively
collaborating on. However, more dedicated users may opt to run an always-on
<strong>seed node</strong>, offering their infrastructure to the wider
Radicle network or to their community. Seed nodes significantly enhance the
network’s capacity to provide continuous access to a broad range of
repositories. They can vary in their seeding policies, from <em>public seed nodes</em>
that openly seed all repositories to <em>community seed nodes</em> that selectively
seed repositories from a group of trusted peers.</p>



<h3 id="node-identifiers-nids">Node Identifiers (NIDs)</h3>



<p>Radicle node identity is based on <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">public-key cryptography</a>, which makes
it easy to verify the authenticity of messages within the network through
<a href="https://en.wikipedia.org/wiki/Digital_signature">digital signatures</a>. This also allows for consistent identification
even as a user’s physical address varies. When setting up a node, users
generate their unique key pair, an <a href="https://ed25519.cr.yp.to/">Ed25519</a> public and private key, the
public part of which is encoded and shared as a <a href="https://www.w3.org/TR/did-core/">Decentralized Identifier</a>
(DID). Creating a node identity requires no permission or coordination: the key
pair can be created while offline without providing an email address or any
personal identifying information.</p>



<figure>
  <pre>did:key:<span>z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK</span></pre>
  <figcaption>Example Node ID encoded as a DID using the <a href="https://w3c-ccg.github.io/did-method-key/"><code>did:key</code>
  method</a>.</figcaption>
</figure>

<p>It is important to safeguard one’s private key, as if it is either lost or
compromised, one will have to generate a new node identity. A changeable,
non-unique <strong>alias</strong> can optionally be associated to each node, for easier
human identification across the network.</p>



<h3 id="running-a-node">Running a Node</h3>

<p>To run a node and connect to the network, users install Radicle client software
that is lightweight and suitable for use on both end-user devices and seed
nodes. The reference implementation can be found in the Radicle <a href="https://app.radicle.xyz/nodes/seed.radicle.xyz/rad:z3gqcJUoA1n9HaHKufZs5FCSGazv5">Heartwood</a>
repository, and is actively maintained by a small team of engineers.</p>



<p>The Radicle <em>stack</em> is comprised of both the network client and a command line
interface (CLI), which can be optionally supplemented with a web frontend.
Radicle is released under the open source MIT and Apache 2.0 licenses, to
encourage the development of diverse clients and applications. All client
software adheres to the Radicle protocol specification, as outlined in the
<a href="https://app.radicle.xyz/nodes/seed.radicle.xyz/rad:z3trNYnLWS11cJWC6BbxDs5niGo82">Radicle Improvement Proposals</a> (RIPs) repository, ensuring consistent
functionality across implementations.</p>



<h2 id="peer-to-peer-protocol">Peer-to-peer Protocol</h2>

<p>Radicle adopts a local-first, peer-to-peer (P2P) architecture, which draws
inspiration from Secure Scuttlebutt (SSB) and Bitcoin’s <a href="https://en.wikipedia.org/wiki/Lightning_Network">Lightning
Network</a>.</p>

<p>Nodes on the Radicle network subscribe to repository data they are interested
in, and peers announce updates that in turn trigger fetches for the underlying
content. Just like SSB and Lightning, updates are <a href="https://en.wikipedia.org/wiki/Gossip_protocol">gossiped</a> on the
network until they reach all interested peers.</p>

<p>Peer connections in Radicle are secured thanks to a <a href="http://www.noiseprotocol.org/noise.html">Noise protocol</a>
handshake. Radicle uses the <a href="https://noiseexplorer.com/patterns/XK/">Noise XK</a> pattern specifically, just
like the Lightning Network with the Node ID as the <em>static key</em>. This requires
nodes to know the Node IDs of their peers before connecting to them, which
takes place through the exchange of peer information over the gossip protocol.</p>

<p>Unlike SSB’s focus on social networking via append-only logs, Radicle focuses
on code collaboration by incorporating Git’s <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects">object model</a> and
<a href="https://git-scm.com/docs/pack-protocol/en">transfer protocol</a> into a peer-to-peer context. This architecture
not only leverages Git’s proven efficiency and reliability but also gives users
complete autonomy over their social artifacts. Radicle’s peer-to-peer
architecture, in contrast to federated systems, ensures no centralized points
of failure, allowing the network to persist as long as users operate nodes.</p>

<figure>
  
  <figcaption>A set of connected peers forming a gossip network.</figcaption>
</figure>

<h3 id="gossip-protocol">Gossip Protocol</h3>

<p>The Radicle networking layer is designed as a gossip protocol, where messages
are relayed between peers to build routing tables that aid in repository
discovery and replication. The core functionality is achieved with three
message types, each fulfilling a distinct role:</p>

<p><strong>Node Announcements</strong> are used for broadcasting Node IDs and physical
   addresses on which a node is publicly reachable, to facilitate peer
   discovery.</p>

<table>
  <thead>
    <tr>
      <th>Node Announcement</th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code>features</code></strong></td>
      <td><code>u64</code></td>
      <td>Advertised node capabilities</td>
    </tr>
    <tr>
      <td><strong><code>timestamp</code></strong></td>
      <td><code>u64</code></td>
      <td>Message timestamp (unix time)</td>
    </tr>
    <tr>
      <td><strong><code>alias</code></strong></td>
      <td><code>u8[]</code></td>
      <td>Non-unique alias (UTF-8)</td>
    </tr>
    <tr>
      <td><strong><code>addresses</code></strong></td>
      <td><code>Address[]</code></td>
      <td>External addresses</td>
    </tr>
    <tr>
      <td><strong><code>nonce</code></strong></td>
      <td><code>u64</code></td>
      <td>Nonce used for DoS protection</td>
    </tr>
  </tbody>
</table>

<p><strong>Inventory Announcements</strong> are used for broadcasting repository inventories
   and constructing the routing table which maps out what repositories are
   hosted where.</p>

<table>
  <thead>
    <tr>
      <th>Inventory Announcement</th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code>inventory</code></strong></td>
      <td><code>RepoID[]</code></td>
      <td>Repository inventory</td>
    </tr>
    <tr>
      <td><strong><code>timestamp</code></strong></td>
      <td><code>u64</code></td>
      <td>Message timestamp (unix time)</td>
    </tr>
  </tbody>
</table>

<p><strong>Reference Announcements</strong> are used for broadcasting updates to
   repositories, relayed only to nodes interested in the relevant repository.</p>

<table>
  <thead>
    <tr>
      <th>Refs Announcement</th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code>rid</code></strong></td>
      <td><code>RepoID</code></td>
      <td>Repository that was updated</td>
    </tr>
    <tr>
      <td><strong><code>refs</code></strong></td>
      <td><code>{NodeID, OID}[]</code></td>
      <td>Updated signed refs (<code>rad/sigrefs</code>)</td>
    </tr>
    <tr>
      <td><strong><code>timestamp</code></strong></td>
      <td><code>u64</code></td>
      <td>Message timestamp (unix time)</td>
    </tr>
  </tbody>
</table>



<p>To prevent endless propagation, nodes drop any message already encountered.
However, for the sake of broadcasting messages to new nodes, gossip messages
may be temporarily stored and replayed to nodes joining the network for the
first time, or after a long period of being offline.</p>

<p>Each announcement includes the originating <em>Node ID</em> along with a
<em>cryptographic signature</em> and <em>timestamp</em>, allowing network participants to
verify the authenticity of messages before relaying them to peers.</p>

<figure>
  
  <figcaption>Announcement message structure.</figcaption>
</figure>

<blockquote>
  <p><strong>Tip</strong>: Refer to <a href="https://app.radicle.xyz/nodes/seed.radicle.xyz/rad:z3trNYnLWS11cJWC6BbxDs5niGo82/tree/0001-heartwood.md">RIP-1</a> to learn more details about Radicle’s
networking protocol.</p>
</blockquote>

<h3 id="transport-encryption--privacy">Transport Encryption &amp; Privacy</h3>

<p>Connections between peers in the Radicle network are encrypted using a <a href="http://www.noiseprotocol.org/noise.html">Noise</a>
protocol handshake. This begins with two peers performing a <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie-Hellman</a> key
exchange to agree on a shared session key that is used for the duration
of the connection.</p>

<p>Radicle uses the <a href="https://noiseexplorer.com/patterns/XK/">XK</a> handshake pattern, which requires the
connection responder’s <em>static key</em> to be known in advance by the initiator.
This <em>pre-sharing</em> takes place over the gossip network via the
<code>NodeAnnouncement</code> message, since the static key is simply the Node ID.</p>



<figure>
  
</figure>

<p>Once the static key is known, a connection to the node can be initiated
securely, by generating an ephemeral key from the static key, using
Diffie-Hellman. The last step involves the initiating node sending its own
static key over the secure channel.</p>

<figure>
  
</figure>

<p>After the handshake phase is completed, all data exchanged between peers is
fully encrypted and benefits from strong <a href="https://en.wikipedia.org/wiki/Forward_secrecy">forward secrecy</a>, ensuring
secure and private communications across the network.</p>

<blockquote>
  <p><strong>Tip</strong>: Radicle also supports <a href="https://torproject.org/">Tor</a> addresses. Users can leverage Tor to
hide their IP address from peers, and connect to <code>.onion</code> addresses on the
Tor network.</p>
</blockquote>

<h3 id="replication-via-git">Replication via Git</h3>

<p>While gossip is used to exchange metadata, actual repository data is
transferred via replication using the <a href="https://git-scm.com/docs/pack-protocol/en">Git protocol</a>. The process
begins with a node establishing a secure connection to one or more of the
repository’s seeds, upon receiving a <em>reference</em> or <em>inventory</em> announcement of
interest.</p>

<p>Once connected, the node initiates a Git <em>fetch</em> protocol, which involves
negotiating which objects should be sent or skipped by the remote node. The
objects are then downloaded into the node’s storage, making them accessible to
other nodes via the same process.</p>

<p>Since Radicle uses a <a href="https://en.wikipedia.org/wiki/Frame_(networking)">framing</a> protocol for all its sessions, the fetch
protocol is able to take place over the same physical connection between nodes
as the gossip protocol. This allows for a more efficient use of resources
and avoids certain problems with <a href="https://en.wikipedia.org/wiki/Network_address_translation">NATs</a>. Although Git’s protocols are
typically connection-based, Radicle’s design allows for multiple concurrent
Git fetches to take place over a single connection.</p>



<figure>
  
  <figcaption>Connection multiplexing in Radicle.</figcaption>
</figure>

<h3 id="bootstrap-nodes">Bootstrap Nodes</h3>

<p>A node joining the network for the first time will not know any peers. Hence,
it’s useful to pre-configure network clients with addresses of well-known nodes
that can be used to initiate or <em>bootstrap</em> the peer discovery process and build
an address book.</p>

<p>Radicle’s reference implementation is pre-configured with two <a href="https://en.wikipedia.org/wiki/Bootstrapping_node">bootstrap
nodes</a> that are connected to if the address book is empty:
<a href="https://app.radicle.xyz/nodes/seed.radicle.garden">seed.radicle.garden</a> and <a href="https://app.radicle.xyz/nodes/seed.radicle.xyz">seed.radicle.xyz</a>. These are nodes run by the
Radicle team and have large address books that are shared with connecting
peers.</p>

<p>In the bootstrapping process, nodes connect to an initial set of bootstrap nodes
and once they establish a connection, use the regular peer discovery mechanism
to find more peers.</p>

<h3 id="federation-vs-peer-to-peer">Federation vs. Peer-to-peer</h3>

<p>Federation allows for a degree of sovereignty, as each node can set its content
policies, but user experience and identity are ultimately tied and mediated by
these nodes’ administrators rather than by the users themselves.</p>

<blockquote>
  <p><strong>federation</strong> /ˌfɛdəˈreɪʃn/ <em>n.</em></p>

  <p><em>(Computing)</em> A system architecture where multiple independent servers or
nodes operate under a common set of standards and protocols, allowing them to
share data, resources, and functionalities across boundaries while
maintaining autonomy. This model enables interoperability and collective
services among diverse systems without fully centralizing control, thereby
enhancing privacy, scalability, and resilience. Each node in a federated
network can set its policies, manage its users, and control its data.</p>
</blockquote>



<p>Although federated models promote a level of decentralization, they face unique
challenges, such as when node operators decide to block other nodes, taking
that choice away from its users and restricting the free flow of information.</p>

<p>Federated systems also face challenges related to incentives; specifically,
when the operational costs of maintaining a node exceed the perceived benefits,
node operators are often compelled to shut down. This can disrupt access for
users, undermining the platform’s reliability and the continuity of service.</p>

<p>While Radicle seed nodes face similar challenges, this has little bearing on
the end user: seed nodes are interchangeable and offer an undifferentiated
service; they are not tied to a user’s identity or access to the network.</p>

<figure>
  
  <figcaption>Federation (left) vs. peer-to-peer (right).</figcaption>
</figure>

<h2 id="repositories">Repositories</h2>

<p><strong>Repositories</strong> are central to the Radicle network, serving as the primary
data abstraction and object shared between peers. A repository in Radicle is
fundamentally a Git repository, supplemented with a unique repository
identifier (RID) and metadata essential for validating the authenticity of its
contents.</p>

<p>Radicle repositories, which can be either public or private, can accommodate
diverse content including source code, documentation, and arbitrary data sets.
All repositories are initialized with an <a href="#identity-document">identity
document</a> from which a unique Repository ID (RID) is
derived.</p>

<p>The identity document is where repository permissions and ownership are defined,
as well as identifying metadata such as name and description.</p>

<h3 id="delegates">Delegates</h3>

<p>Repositories are managed and owned by what are called <em>delegates</em>. A delegate
is an individual, group, or bot, identified by a <a href="https://www.w3.org/TR/did-core/">DID</a>. Delegates are
responsible for critical tasks such as merging patches, addressing issues, and
modifying repository permissions. A repository always begins with one delegate,
its creator, and can eventually grow to multiple delegates.</p>

<h3 id="identity-document">Identity Document</h3>

<p>Before a repository can be published on Radicle, it needs to be initialized
with an <em>identity document</em>. This JSON document, stored under the <code>refs/rad/id</code>
reference in Git, encapsulates key metadata such as the repository’s name,
description, and default branch. It also includes the DIDs of the
repository’s delegates and the <em>threshold</em> of delegate signatures required to
authorize changes to the repository’s default branch.</p>



<p>Here’s an example of the identity document for the <a href="https://app.radicle.xyz/nodes/seed.radicle.xyz/rad:z3gqcJUoA1n9HaHKufZs5FCSGazv5">heartwood</a> repository:</p>

<div><div><pre><code><span>{</span><span>
  </span><span>&#34;delegates&#34;</span><span>:</span><span> </span><span>[</span><span>&#34;did:key:z6MknSLrJoTcukLrE435hVNQT4JUhbvWLX4kUzqkEStBU8Vi&#34;</span><span>],</span><span>
  </span><span>&#34;threshold&#34;</span><span>:</span><span> </span><span>1</span><span>,</span><span>
  </span><span>&#34;payload&#34;</span><span>:</span><span> </span><span>{</span><span>
    </span><span>&#34;xyz.radicle.project&#34;</span><span>:</span><span> </span><span>{</span><span>
      </span><span>&#34;name&#34;</span><span>:</span><span> </span><span>&#34;heartwood&#34;</span><span>,</span><span>
      </span><span>&#34;description&#34;</span><span>:</span><span> </span><span>&#34;Radicle Heartwood Protocol &amp; Stack ❤️🪵&#34;</span><span>,</span><span>
      </span><span>&#34;defaultBranch&#34;</span><span>:</span><span> </span><span>&#34;master&#34;</span><span>
    </span><span>}</span><span>
  </span><span>}</span><span>
</span><span>}</span><span>
</span></code></pre></div></div>
<h3 id="private-repositories">Private Repositories</h3>

<p>Radicle supports <strong>private repositories</strong> where access is restricted to a
designated group of trusted peers. This is achieved by setting the <code>visibility</code>
attribute in the identity document. For example, the following snippet sets
the visibility to <em>private</em>, while also allowing a specific peer to have
access to the repository.</p>

<div><div><pre><code><span>{</span><span>
  </span><span>...</span><span>
  </span><span>&#34;visibility&#34;</span><span>:</span><span> </span><span>{</span><span>
    </span><span>&#34;type&#34;</span><span>:</span><span> </span><span>&#34;private&#34;</span><span>,</span><span>
    </span><span>&#34;allow&#34;</span><span>:</span><span> </span><span>[</span><span>&#34;did:key:z6Mkt67GdsW7715MEfRuP4pSZxJRJh6kj6Y48WRqVv4N1tRk&#34;</span><span>]</span><span>
  </span><span>}</span><span>
</span><span>}</span><span>
</span></code></pre></div></div>

<p>This ensures only nodes in the privacy set can replicate and access the data,
maintaining confidentiality. While the data is not encrypted at rest, these
repositories rely on selective replication through the <em>allow list</em> for
privacy, which renders them invisible and inaccessible to other nodes in the
Radicle network.</p>

<p>Note that repository delegates <em>always</em> have access to their private
repositories.</p>

<h3 id="repository-identifier-rid">Repository Identifier (RID)</h3>

<p>To ensure uniqueness and easy identification of repositories, a stable and
globally unique identifier, known as the Repository Identifier (RID), is
assigned to each repository. The RID is deterministically derived from the
initial version of the repository’s identity document. This process involves
using Git’s <code>hash-object</code> function to produce a 160-bit SHA-1 digest of the
document. This is then encoded using <a href="https://w3c-ccg.github.io/multibase/">multibase</a> encoding with the
<code>base-58-btc</code> alphabet, and prefixed with <code>rad:</code>, making it a valid <a href="https://datatracker.ietf.org/doc/html/rfc8141">URN</a>:</p>

<figure>
  <pre>rad:<span>z3gqcJUoA1n9HaHKufZs5FCSGazv5</span></pre>
  <figcaption>Example Repository ID for the heartwood project.</figcaption>
</figure>

<p>Since the RID is derived from the <em>initial</em> version of the repository’s identity
document, the document is able to change while the RID remains the same.</p>

<blockquote>
  <p><strong>Tip</strong>: Refer to <a href="https://app.radicle.xyz/nodes/seed.radicle.xyz/rad:z3trNYnLWS11cJWC6BbxDs5niGo82/tree/0002-identity.md">RIP-2</a> for more details about how repository
identity works in the Radicle protocol.</p>
</blockquote>

<!-- TODO: Add info about self-certifying updates -->

<h2 id="local-first-storage">Local-First Storage</h2>

<p>Storage is designed in such a way that it’s easy to transfer data between peers
over the network using an unmodified Git protocol. Radicle repositories are
simply Git repositories stored in a special location on disk. Peer data
is stored within the same repository using Git <a href="https://git-scm.com/docs/gitnamespaces">namespaces</a>, where Node
IDs are used as the namespace. This allows storage to be managed through a
partitioned approach where each user maintains their own <em>local fork</em> of a
repository, as well as any other forks they have an interest in, all within the
same Git repository. These forks are then shared among users across the
network.</p>

<p>Each repository fork has a <em>single owner and writer</em>, and users are only
permitted to make changes to their respective forks.</p>

<h3 id="working-vs-stored-copy">Working vs. Stored Copy</h3>

<p>Storage is accessed directly by the node to report its inventory to other
nodes, and by the end user through either specialized tooling or the <code>git</code>
command line tool. Users are typically interacting with two repository copies:
the <em>working copy</em>, and a remote <em>stored copy</em> that is interacted with via <code>git
push</code> and <code>git fetch</code>, using Radicle’s <a href="https://git-scm.com/docs/gitremote-helpers">git-remote-helper</a>.</p>

<p>This workflow is akin to what most developers are used to, when synchronizing
changes between their working copy, and the <code>origin</code> remote, which is typically
a repository on a hosted Git forge.</p>

<p>Changes to the stored copy are automatically propagated to the network when the
user is connected to the internet, but can also be made while offline. This
local-first design not only enhances the user experience by making offline work
frictionless, but also eliminates the need for centralized servers.</p>

<figure>
  
  <figcaption>Synchronizing the working copy with the stored copy of a repository.</figcaption>
</figure>

<h3 id="storage-layout">Storage Layout</h3>

<p>Radicle’s storage layout is designed to support multiple repositories and
multiple peers per repository. Each repository is a <em>bare</em> Git repository,
stored under a common base directory, identified uniquely with its Repository
ID or RID. Instead of each of the repository’s peers storing data in a separate
Git repository with a separate <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects">object database</a> (ODB), peer data is
stored within the same Git repository using Git <a href="https://git-scm.com/docs/gitnamespaces">namespaces</a>.</p>



<p>For each peer, including the local peer, their unique Node ID (NID) is used as
the namespace. Thus, each peer has its own namespaced references (eg.
<code>refs/heads</code>, and <code>refs/tags</code>), while sharing the underlying objects (i.e.
commits and blobs) with other namespaces via a shared object database. This
design ensures only one copy of each object is stored across all repository
forks.</p>

<p>Since the underlying storage uses Git, the storage layout below is represented
as a file tree on the file-system, with <code>&lt;storage&gt;</code> representing the storage
root, or top-level directory under which all repositories are stored on a
user’s device. For every repository, each peer associated with that repository
must have a separate, logical Git source tree – which contains all the usual
reference categories. This <em>logical repository</em> is also known as the repository
<em>fork</em> or <em>view</em>, and allows nodes to maintain local data for all peers in the
same physical repository.</p>

<div><div><pre><code>&lt;storage&gt;                     # Storage root containing all repositories
├─ &lt;rid&gt;                      # Storage for first repository
│  └─ refs                    # All Git references locally stored
│     └─ namespaces           # All peer source trees or &#34;forks&#34;
│        ├─ &lt;nid&gt;             # First node&#39;s source tree
│        │  └─ refs           # First node&#39;s Git references
│        │     ├─ heads       # First node&#39;s branches
│        │     │   └─ master  # First node&#39;s master branch
│        │     └─ tags        # First node&#39;s tags
│        │
│        └─ &lt;nid&gt;             # Second node&#39;s source tree
│           ├─ refs           # Second node&#39;s references
│           └─ ...
├─ &lt;rid&gt;                      # Storage for second repository
│   ...
└─ &lt;rid&gt;                      # etc.
    ...
</code></pre></div></div>

<p>Though this storage tree is browsable by the user with standard file system
commands, it is not meant to be interacted with directly by users, for risk of
corrupting the data. Additionally, Git is free to pack the objects, which means
they may not always appear as individual files.</p>

<blockquote>
  <p><strong>Tip</strong>: Refer to <a href="https://app.radicle.xyz/nodes/seed.radicle.xyz/rad:z3trNYnLWS11cJWC6BbxDs5niGo82/tree/0003-storage-layout.md">RIP-3</a> to learn more about storage in the Radicle
protocol.</p>
</blockquote>

<h3 id="git-url-scheme">Git URL Scheme</h3>

<p>The Radicle protocol uses its own URL scheme to point to specific repository
forks in the network. This allows the Git <code>fetch</code> and <code>push</code> commands to
operate on the correct namespace when fetching or pushing code.</p>

<figure>
  <pre>rad://<span>z42hL2jL4XNk6K8oHQaSWfMgCL7ji</span>/<span>z6MknSLrJoTcukLrE435hVNQT4JUhbvWLX4kUzqkEStBU8Vi</span></pre>
  <figcaption> Example URL for repository <code>z42hL2jL4XNk6K8oHQaSWfMgCL7ji</code> and
  peer <code>z6MknSLrJoTcukLrE435hVNQT4JUhbvWLX4kUzqkEStBU8Vi</code>. </figcaption>
</figure>

<p>The Radicle <a href="https://git-scm.com/docs/gitremote-helpers">remote helper</a> is what allows Git to interpret URLs with the
<code>rad://</code> scheme. By using this scheme, the user instructs Git to
invoke the <code>git-remote-rad</code> executable during <code>git push</code> or <code>git fetch</code>, which
allows the user to interact with the network through the storage layer.</p>

<p>For example, the above URL would map a push to the <code>master</code> branch to the following
path under the local storage root:</p>

<pre>/<span>z42hL2jL4XNk6K8oHQaSWfMgCL7ji</span>/refs/namespaces/<span>z6MknSLrJoTcukLrE435hVNQT4JUhbvWLX4kUzqkEStBU8Vi</span>/refs/heads/master
</pre>

<p>If a Node ID is not specified in the URL, Git will interact with the
repository’s <a href="#Canonical-Repository-Version">canonical references</a>, also know
as the authoritative repository state. This is the state agreed on by the
repository <a href="#delegates">delegates</a>.</p>

<figure>
  <pre>rad://<span>z42hL2jL4XNk6K8oHQaSWfMgCL7ji</span></pre>
  <figcaption> Example URL for repository
  <code>z42hL2jL4XNk6K8oHQaSWfMgCL7ji</code>&#39;s canonical
  references.</figcaption>
</figure>

<h2 id="trust-through-self-certification">Trust through Self-Certification</h2>

<p>Unlike centralized forges such as GitHub, where repositories are deemed
authentic based on their location (e.g. <code>https://github.com/bitcoin/bitcoin</code>),
in a decentralized network like Radicle, location is not enough. Instead, we
need a way to automatically verify the data we get from <em>any given location</em>.
This is because peers in a decentralized network may be dishonest. Radicle’s
approach hinges on the self-certifying nature of its repositories, anchored in
the repository <a href="#identity-document">identity document</a>.</p>

<h3 id="canonical-branches">Canonical Branches</h3>

<p>When repositories are hosted in a known, trusted location, updating the
repository’s canonical branch (eg. <code>master</code>) is simply a matter of pushing
to that repository’s branch. Permission to push is granted to a small set
of maintainers, and any one maintainer is allowed to update the branch.</p>

<p>In Radicle, lacking a central location where repositories are hosted, the
canonical branch is established <em>dynamically</em> based on the signature
<strong>threshold</strong> defined in the repository’s identity document. For example, if a
threshold of two out of three delegates is set, with the default branch set to
<code>master</code>, and two delegates have pushed the same commit to their <code>master</code>
branches, that commit is recognized as the authoritative, canonical state of
the repository.</p>

<blockquote>
  <p><strong>Note</strong>: Currently, only the branch specified under the <code>defaultBranch</code>
attribute of the identity document is set automatically based on a signature
threshold. In the future, additional branches may be supported.</p>
</blockquote>

<h3 id="self-certifying-repositories">Self-certifying Repositories</h3>

<p>Together, a repository’s RID and its identity document create a cryptographic
proof that serves as the basis for verifying all repository states leading
up to its current state. For this reason, we say that Radicle repositories
are <em>self-certifying</em>: the process of verification doesn’t require any
inputs other than the repository itself.</p>

<p>For repositories to be self-certifying, delegates authenticate every change to
the repository data and metadata via cryptographic signatures. This includes
all Git references published to the network.</p>

<!-- TODO: Copy section from RIP-2 -->

<h4 id="signed-refs">Signed Refs</h4>

<p>To enable the verification of Git references beyond commits to the source code,
Radicle automatically signs the entirety of a node’s references every time they
change. This signature is then placed in a Git blob under a special branch
referenced under <code>refs/rad/sigrefs</code>, along with the references that were signed.</p>

<figure>
  <pre>9767b485c2aad1e23097d2b5165287ba84cfa452 refs/heads/master
f3eaa7454e3a4714885905ae99f616fc7895b5fa refs/cobs/xyz.radicle.patch/fe31d5b6049583a42c21a543545d182b893aa4a0
0590b78ee42b39087983e4de04164065e5aa11bc refs/cobs/xyz.radicle.patch/ffbb812ad6e7fe1c5c610b1246ca5ca9d7d16027</pre>
  <figcaption>Example <code>refs</code> blob under a user&#39;s <code>refs/rad/sigrefs</code> branch.
  </figcaption>
</figure>



<p>Signed refs are key to establishing a repository’s canonical state and are
updated whenever there are changes to a repository.</p>

<p>Given an RID and a Radicle repository clone, anyone can retrieve the initial
identity document and authenticate all subsequent repository updates without a
trusted third party. This verification model draws inspiration from <a href="https://theupdateframework.github.io/specification/latest/">The Update
Framework</a> (TUF), a framework designed to secure software update systems.</p>

<h2 id="collaborative-objects">Collaborative Objects</h2>

<p>In the Radicle protocol, Collaborative Objects (COBs) play an important role in
supplementing Git with social artifacts such as issues, code reviews and
discussions, which are not inherently supported by Git. Typically, these
artifacts are only found on centralized platforms like GitHub or GitLab, or
their self-hosted counterparts.</p>

<p>In Radicle, COBs allow for social artifacts to be stored directly inside a
repository, and replicated between peers. This means that social artifacts
inherit the same properties as source code: they are local-first, user-owned,
and cryptographically signed.</p>

<p>Radicle includes three predefined collaborative object types to support code
collaboration: <em>Issues</em>, <em>Patches</em>, and <em>Identities</em>, but users have full
control to customize them or extend Radicle with entirely new COB types.</p>

<ul>
  <li><strong>Issues</strong> (<code>xyz.radicle.issue</code>) are used for tracking bugs or feature
requests, and support discussions, labeling and assigning.</li>
  <li><strong>Patches</strong> (<code>xyz.radicle.patch</code>) are used to propose changes to a
branch, and support reviews, versioning of changes and discussions.</li>
  <li><strong>Identities</strong> (<code>xyz.radicle.id</code>) are used to represent identity documents.</li>
</ul>



<p>COBs are identified by a unique type name in <a href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation">reverse domain name
notation</a> and a unique Object ID.</p>

<h3 id="concurrency--consistency">Concurrency &amp; Consistency</h3>

<p>In a system with no central server, operation concurrency is the norm. If
two users comment on an issue at the same time, those comments will reach
peers in the network at different times and in different orders. To maintain
a good user experience, it’s important that these factors don’t determine
the issue’s final state. All users must eventually converge to the same exact
state and see the same thing.</p>

<p>To achieve this, Radicle makes use of Git’s native synchronization primitives,
and encodes COBs as a set of commits in a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph</a> (DAG).
Each issue, patch or identity document is represented by one such commit graph
that is disjoint from any other COB or source code branch.</p>

<p>This representation gives Radicle a few things for free:</p>

<ol>
  <li>Data integrity is guaranteed by Git.</li>
  <li>Synchronization is handled by Git.</li>
  <li>Causal dependencies can be modeled as commit parent-child relationships.</li>
</ol>

<p>It may be useful to think of Radicle’s usage of Git commit histories as a
form of <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">conflict-free replicated data type</a> (CRDT). When the histories
of two peers are synchronized, the commit graphs are simply <em>unioned</em> with
each other in a non-destructive, idempotent way.</p>



<figure>
  
</figure>



<p>Then, to materialize the state that is displayed to the user, this new graph is
<em>reduced</em> in <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological order</a>, starting from the root of the graph and
going up to the tips. This ordering happens to be <a href="https://en.wikipedia.org/wiki/Causal_consistency">causally
consistent</a>, ensuring that changes that have observed other changes
are traversed in causal order. Since topological ordering may yield <em>partial</em>
orders in the face of concurrency, a merge function is also defined, the
simplest of which is to traverse the partially-ordered graph vertices sorted by
their commit hash. If a merge function cannot be defined, a COB may be
configured to treat this as a <em>conflict</em> which can be bubbled up to the user.</p>



<p>In summary, this mechanism supports multiple users independently interacting
without coordination. Each COB records the initial version of an object and
tracks all subsequent modifications made across the network. Each modification
is stored as a separate Git <em>commit</em> object to ensure that the CRDT change
graph is compatible with Git’s fetch protocol. To retrieve the current state of
an object, the system replays all the changes to the object in a deterministic
and causally-consistent order.</p>

<h3 id="extending-cobs">Extending COBs</h3>

<p>Radicle’s predefined COB types are stored under the <code>refs/cobs</code> hierarchy.
These are associated with unique namespaces, such as <code>xyz.radicle.issue</code> and
<code>xyz.radicle.patch</code>, to prevent naming collisions.</p>

<p>This hierarchical arrangement under <code>refs/cobs</code> not only houses Radicle’s
predefined COBs but also accommodates user-defined ones. For example, if a user
or organization were to define a new COB type under their domain, it might look
something like <code>com.acme.task</code>, for some hypothetical “task” COB under the
<code>acme.com</code> domain.</p>

<p>This extensibility allows for an unlimited set of new collaboration primitives
to be defined by users, without requiring coordination with the broader network
or user-base.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Radicle Heartwood protocol introduces a new approach to code collaboration
and hosting rooted in sovereignty. Built upon Git’s well-established protocol,
Radicle can easily interoperate with existing systems and workflows that are
already familiar. Users have full control and ownership over their identity and
data. Repositories are self-certifying data structures, meaning updates are
cryptographically signed and can be verified by anyone, without needing a
trusted third party. Every user in Radicle is self-hosting while remaining
connected to a wider network. Radicle is highly extensible with its
Collaborative Objects that enable full control and customization over workflows
and datatypes, while also opening the possibility for Radicle to support a
wider range of functionalities, potentially extending far beyond code
collaboration.</p>

<!-- References -->


    </div></div>
  </body>
</html>
