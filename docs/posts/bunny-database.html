<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bunny.net/blog/meet-bunny-database-the-sql-service-that-just-works/">Original</a>
    <h1>Bunny Database</h1>
    
    <div id="readability-page-1" class="page"><section><section><div><div><p>Don’t want to babysit your app database on a VM but not willing to pay the DBaaS tax either? We&#39;re building a third way.</p><p>Today, we’re launching Bunny Database as a public preview: a SQLite-compatible managed service that spins down when idle, keeps latency low wherever your users are, and doesn’t cost a fortune.</p><h2 id="so-what%E2%80%99s-the-deal-with-database-services-in-2026">So what’s the deal with database services in 2026?</h2><p>It’s become clear by now that the DBaaS platforms that garnered the love of so many devs are all going upmarket. Removing or dumbing down free tiers, charging for unused capacity, charging extra for small features, or bundling them in higher tiers — you already know the drill.</p><p>Hard to blame anyone for growing their business, but it doesn’t feel right when these services stop making sense for the very people who helped popularize them in the first place.</p><p>So where does that leave you?</p><h2 id="like-sqlite-but-for-the-web">Like SQLite, but for the web</h2><p>Not every project needs Postgres, and that’s okay. Sometimes you just want a simple, reliable database that you can spin up quickly and build on, without worrying it’ll hit your wallet like an EC2.</p><p>That’s what we built Bunny Database for.</p><p>What you get:</p><ul><li><strong>One-click deployment</strong>: just name your database and go, no config needed</li><li><strong>Language-specific tooling</strong>: SDKs for TS/JS, Go, Rust, and .NET help you handle the boring bits</li><li><strong>Low latency anywhere</strong>: replication regions let you serve reads close to your users</li><li><strong>41 regions worldwide</strong>: choose between automatic, single-region, and multi-region deployment</li><li><strong>Works over HTTP</strong>: wire up anything you’d like</li><li><strong>Database editor</strong>: insert data or run queries on the spot</li><li><strong>Metrics</strong>: instant visibility into reads, writes, storage, and latency</li><li><strong>Affordable, pay-as-you-go pricing</strong>: only pay for what you use, but without the serverless tax</li></ul><p>Get the full tour including how to connect Bunny Database to your app in this quick demo from our DX Engineer, Jamie Barton:</p>
<!--kg-card-begin: html-->

<!--kg-card-end: html-->
<h2 id="why-care-about-database-latency-anyway">Why care about database latency anyway?</h2><p>You probably optimize the heck out of your frontend, APIs, and caching layers, all for the sake of delivering an experience that feels instant to your users. But when your database is far away from them, round-trip time starts to add noticeable latency.</p><p>The usual fix is to introduce more caching layers, denormalized reads, or other workarounds. That’s obviously no fun.</p><p>And when you think about it, devs end up doing this because the popular DBaaS platforms are usually either limited, complex, or too costly when it comes to multi-region deployments. So what looks like a caching problem is actually a data locality issue.</p><p>OK, but how bad can it really be?</p><p>To find out, we ran a read latency benchmark and measured p95 latency in Bunny Database.</p><p>We picked a number of regions across the world and compared round-trip time for client locations ever farther away from the database in:</p><ul><li>a single-region setup,</li><li>with replication regions enabled.</li></ul><p>Turns out serving reads close to clients reduced latency by up to 99%.</p><p>Check out the full write-up on the benchmark setup and results <a href="https://bunny.net/blog/how-database-location-affects-far-away-users-benchmarking-read-latency-in-bunny-database/">here</a>.</p><figure><img src="https://bunny.net/blog/content/images/2026/01/Bunny-Database-Latency-Graph.webp" alt="" loading="lazy" width="1330" height="986" srcset="https://bunny.net/blog/content/images/size/w600/2026/01/Bunny-Database-Latency-Graph.webp 600w, https://bunny.net/blog/content/images/size/w1000/2026/01/Bunny-Database-Latency-Graph.webp 1000w, https://bunny.net/blog/content/images/2026/01/Bunny-Database-Latency-Graph.webp 1330w" sizes="(min-width: 720px) 720px"/></figure><p>While this definitely matters most to apps with global users, data locality does apply to everyone. With Bunny Database, you don’t have to stick to major data center locations and compensate with caching workarounds any more. Instead, you get a lot of flexibility to set up regions in an intuitive interface and it’s easy to switch things up as your requirements change.</p><p>Choose between 3 deployment types when creating a database:</p><ul><li><strong>Automatic region selection</strong> gives you one-click deployment with minimal latency. Bunny Database will select regions for you based on your IP address (you can check and tweak the selection in settings later).</li><li><strong>Single-region deployment</strong> lets you pick one of 41 regions available worldwide (check the full list <a href="https://docs.bunny.net/magic-containers/regions" rel="noopener noreferrer">here</a>).</li><li><strong>Manual region selection</strong> gives you custom multi-region setup, where you can freely pick regions that make the most sense for your audience.</li></ul><figure><img src="https://bunny.net/blog/content/images/2026/01/Bunny-Database-regions.webp" alt="" loading="lazy" width="1524" height="1328" srcset="https://bunny.net/blog/content/images/size/w600/2026/01/Bunny-Database-regions.webp 600w, https://bunny.net/blog/content/images/size/w1000/2026/01/Bunny-Database-regions.webp 1000w, https://bunny.net/blog/content/images/2026/01/Bunny-Database-regions.webp 1524w" sizes="(min-width: 720px) 720px"/></figure><p>All of this lets you start wherever you’d like and add regions as needed, without re-architecting your app.</p><h2 id="usage-based-pricing-but-without-the-serverless-tax">Usage-based pricing, but without the serverless tax</h2><p>In the database world, capacity-based pricing gives you some predictability. But no one likes to pay for unused capacity, right?</p><p>Serverless, on the other hand, is supposed to be cost-efficient, yet can rack up bills quickly, especially when the DBaaS charges significant markups on top of already pricey compute.</p><p>We don’t do hyperscalers, though, so we can charge a fair price for Bunny Database in a usage-based model.</p><ul><li>Reads: <strong>$0.30 per billion rows</strong></li><li>Writes: <strong>$0.30 per million rows</strong></li><li>Storage: <strong>$0.10 per GB per active region</strong> (monthly)</li><li>When not getting requests, Bunny Database only incurs storage costs. One primary region is charged continuously, while read replicas only add storage costs when serving traffic (metered by the hour)</li><li>Your usage is charged continuously (pay-as-you-go) and invoiced monthly</li></ul><p>During the public preview phase, Bunny Database is free.</p><h2 id="wait-what-does-%E2%80%9Csqlite-compatible%E2%80%9D-actually-mean">Wait, what does “SQLite-compatible” actually mean?</h2><p>Bunny Database wouldn’t be possible without libSQL, the open-source, open-contribution fork of SQLite created by Turso.</p><p>We run Bunny Database on our own fork of libSQL, which gives us the freedom to integrate it tightly with the bunny.net platform and handle the infrastructure and orchestration needed to run it as a managed, multi-region service.</p><p>What does this mean for Bunny Database’s upstream feature parity with libSQL and SQLite, respectively?</p><p>The short answer is that we don’t currently promise automatic or complete feature parity with either upstream libSQL or the latest SQLite releases.</p><p>While libSQL aims to stay compatible with SQLite’s API and file format, it doesn’t move in lockstep with upstream SQLite. We wouldn’t expect otherwise, especially as Turso has shifted focus from libSQL toward a long-term rewrite of SQLite in Rust.</p><p>For Bunny Database, this means that compatibility today is defined by the libSQL version we’re built on, rather than by chasing every upstream SQLite or libSQL change as it lands. We haven’t pulled in any upstream changes yet, and we don’t currently treat upstream parity as an automatic goal.</p><p>That’s intentional. Our focus so far has been on making Bunny Database reliable and easy to operate as a service. We think bringing in upstream changes only makes sense when they clearly improve real-world use cases, not just to tick a parity checkbox.</p><p>If there are specific libSQL features you’d like to see exposed in Bunny Database, or recent SQLite features you’d want us to pull in, we’d love to hear about it. <a href="https://discord.com/invite/bunnynet" rel="noopener noreferrer">Join our Discord</a> to discuss your use cases and help shape the roadmap!</p><h2 id="what%E2%80%99s-ahead-for-bunny-database">What’s ahead for Bunny Database</h2><p>Speaking of the roadmap, we don’t stop cooking. Here’s what’s coming up next:</p><ul><li>Automatic backups</li><li>Database file import/export</li><li>Auto-generated, schema-aware API with type-safe SDKs</li></ul><p>There’s even more to come, but it’s too soon to spill the beans yet, especially while we’re in public preview. We’d love to hear your feedback, so we can shape what ships next together.</p><p>Bunny Database works standalone and fits right into your stack via the SDKs (or you can hook up anything using the HTTP API). But it also plays nicely with <a href="https://docs.bunny.net/docs/edge-scripting-overview">Bunny Edge Scripting</a> and <a href="https://docs.bunny.net/docs/magic-containers-overview">Bunny Magic Containers</a>.</p><p>To connect your database to an Edge Script or a Magic Containers app, simply go to the Access tab of the chosen database and click <strong>Generate Tokens</strong> to create new access credentials for it.</p><p>Once they’re generated, you’ll get two paths to choose from:</p><ul><li><strong>Click Add Secrets to an Edge Script</strong> and select the one you’d like to connect from the list. You’ll also need to import the libSQL TypeScript client and use the provided code snippet to connect it to your database.</li><li><strong>Click Add Secrets to Magic Container App</strong> and select the one you’d like to connect from the list. You’ll also need to connect to the database from your app using one of the client libraries or the HTTP API.</li></ul><p>After you complete the setup, the database URL and access token will be available as environment variables in your script or app. Use them to connect to your database:</p>
<!--kg-card-begin: html-->
<div>

  <p><code>import</code> 
  <code>{</code> 
  <code>createClient</code> 
  <code>}</code> 
  <code>from</code> 
  <code>&#34;@libsql/client/web&#34;</code><code>;</code></p></div>

<!--kg-card-end: html-->
<p>You can find more detailed, step-by-step integration instructions in the docs:</p><ul><li><a href="https://docs.bunny.net/database/connect/scripting" rel="noopener noreferrer">Connecting an Edge Script to Bunny Database</a></li><li><a href="https://docs.bunny.net/database/connect/magic-containers" rel="noopener noreferrer">Connecting a Magic Containers app to Bunny Database</a></li></ul><h2 id="hop-on-board">Hop on board</h2><p>We can’t wait to see what you’ll build with Bunny Database and what you think of it. During the public preview phase, you get 50 databases per user account, each capped at 1 GB, but we hope this should be more than enough for lots of fun projects.</p><p>Just sign in to the bunny.net dashboard to get started. Happy building!</p></div></div></section></section></div>
  </body>
</html>
