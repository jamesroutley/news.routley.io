<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://enzom.dev/b/passkeys/">Original</a>
    <h1>Things I learnt about passkeys when building passkeybot</h1>
    
    <div id="readability-page-1" class="page"><article itemscope="" itemtype="https://schema.org/BlogPosting">
				
				
				<p>
					I recently released
					<a href="http://passkeybot.com">passkeybot.com</a>, a hosted sign in
					page that allows you to add passkey auth to your site with just a few
					server side HTTP handlers.
				</p>
				<p>Here are the things I learnt in the process.</p>
				<h2>What Secure Enclave Processors (SEP) are</h2>
				<p>
					Apple devices have secure enclaves which are like a separate tiny
					computer living inside the main CPU that has its own isolated
					encrypted memory and OS. It can create secrets that never leave the
					secure enclave. The main OS can only prove it has possession of that
					secret by asking the secure enclave to sign some data and getting the
					signature as a response (it can only use this message protocol with
					the SEP).
				</p>
				<p>
					When the user signs in with their passkey with User Verification =
					true, the SEP requires a biometric/passcode auth first before signing
					the data with the private key.
				</p>
				<p>
					Other devices have something similar to the SEP, but are branded with
					different names.
				</p>
				<p>
					Phone SIM cards are actually a form of secure element. SIM cards are
					CPUs that run a stripped down version of Java, and use the same
					principle of “secrets can never leave the SIM” and “prove possession
					with message signing”.
				</p>
				<h2>User Presence (UP) vs User Verification (UV)</h2>
				<p>
					<strong>Presence</strong> means “the user tapped a button and was
					there”, <strong>verification</strong> means “the user entered their
					biometric or passcode”.
				</p>
				<p>You can request which one you require with the JS passkey API.</p>
				<p>
					The difference is <strong>presence can</strong> be faked by anyone
					with the unlocked device by pressing a button, but
					<strong>verification</strong> always requires the re-auth of the user
					with biometrics or a passcode.
				</p>
				<h2>What an authenticator is</h2>
				<p>
					An authenticator is the hardware and software that holds the
					private/public key pairs and signs the passkey challenge to prove it
					has the private key. On Apple devices that is the SEP.
				</p>
				<p>
					The browser asks the user which authenticator they want to use, then
					uses OS level APIs to interact with the chosen authenticator.
				</p>
				<p>For example:</p>
				<ul>
					<li>
						User chooses on-device <strong>Apple SEP</strong> → site calls JS
						API → browser uses Swift API for passkey operations.
					</li>
					<li>
						User chooses <strong>Yubikey</strong> → site calls JS API → browser
						uses Yubikey API over USB for passkey operations
					</li>
				</ul>
				<p>
					The interesting thing here is that the JS API normalises all these
					different possible authenticator APIs. Under the hood the browser
					implements all the possible API protocols for different
					authenticators.
				</p>
				<p>
					The Chrome Dev Tools also has a virtual authenticator to bypass
					reptetive OS password entry for testing.
				</p>
				<h2>What attestation is</h2>
				<p>
					<strong>Signing proves possession</strong>: Being able to sign with
					the private key proves you have possession of it.
				</p>
				<p>
					<strong>Attestation proves device hardware used</strong>: Attestation
					proves what hardware and software combination created the passkey
					pair. It allows enforcing policies for what set of hardware devices
					are trusted, and which are blocked.
				</p>
				<p>
					The issue is that attestation data also allows fingerprinting as it
					reveals exactly what hardware the user is using.
				</p>
				<p>
					Hardware attestation only occurs for the creation of the passkey pair
					(not on every auth). This creates an issue: if keys are synced to
					another device, the attestation is no longer valid. So if you require
					strict attestation that specific hardware is used, you create a new
					keypair for every device instead of allowing use of a passkey pair
					that has moved to a non-attested device.
				</p>
				<p>
					Without attestation the secure enclave is still used, it is just not
					proven to the webauthn client API.
				</p>
				<p>
					Apple hardware has attestation disabled by default unless you have
					<a href="https://support.apple.com/en-gb/guide/deployment/depc0aadd3fe/web">enterprise device management</a>
					enabled. This lets enterprises define an allow-list of trusted
					authenticator hardware.
				</p>
				<h2>
					Passkeys are just for authentication, not for general signing of
					intent
				</h2>
				<p>
					When the user authenticates with a passkey, they sign a challenge that
					is a hash unique to that particular sign in flow. The challenge hash
					needs to have 16 bytes or more of random data to avoid replays, but it
					can also include a hash over other metadata.
				</p>
				<p>
					The authenticator GUI only shows “sign in to your_domain.com”. It
					never allows a more general “sign this content for your_domain.com”.
					E.g. “sign this transaction request to move £50 to Bob&#39;s account”.
				</p>
				<h2>The JS code must be secure, but it cannot be verified</h2>
				<p>
					If the JS code of a site is compromised, the attacker can read all
					personal data. They could also trick the user into signing something
					with their authenticator (as the authenticator does not show the user
					what they are actually signing) - this leads to a real private key
					signing over faked challenge data.
				</p>
				<p>
					The browser has Subresource Integrity (SRI) which only allows
					executing JS scripts with a given hash. But the root document HTML is
					not checked in that case, which means the attacker can change the SRI
					hashes to match their own JS. Chrome Extensions also allow injecting
					JS.
				</p>
				<p>
					It would be interesting if authenticators could also attest as to what
					HTML/JS was loaded on the page to rule out that they have been
					compromised.
				</p>
				<h2>Immediate mediation - an upcoming “fast sign in” API</h2>
				<p>
					<a href="https://developer.chrome.com/blog/webauthn-immediate-mediation-ot">This Chrome origin trial</a>
					will add an option the passkey API:
				</p>
				<pre>navigator.credentials.get({mediation: &#34;immediate&#34;})  
</pre>

				<p>
					This allows you to sign in a user who already has a passkey quickly.
				</p>
				<p>
					If they do not have a passkey, you can decide what to do from JS
					(instead of having the browser show them a UI to find passkeys on
					other devices).
				</p>
				<p>
					There is no way to get a list of the user&#39;s passkeys from JS -
					lists are always shown from the browser UI.
				</p>
				<p>
					The immediate mediation option allows your JS to get an immediate “the
					user has 0 local keys” message without any user interaction:
				</p>
				<ul>
					<li>
						0 keys: Immediate JS response with NotAllowedError,
						<strong>JS decides next step</strong>.
					</li>
					<li>1 key: Immediately ask the user to sign in with that one.</li>
					<li>&gt;1 key: Ask the user to choose.</li>
				</ul>
				<h2>Related Origin Requests</h2>
				<p>
					<a href="https://web.dev/articles/webauthn-related-origin-requests">Related Origin Requests</a>
					allow you as a domain owner to define a list of other domains that can
					create passkeys for your domain. They work by having you serve the
					list from <code>/.well-known/webauthn</code>.
				</p>
				<p>
					This is what <a href="http://passkeybot.com">passkeybot.com</a> uses
					to allow domain owners to grant permissions to passkeybot.
				</p>
				<p>
					But RORs do not work over HTTP, only HTTPS. The reason is the
					authenticator requests the well-known file over HTTPS only, so
					localhost will not work.
				</p>
				<p>They are also not supported in iOS 18 or Firefox.</p>
				<p>
					If an authenticator creates a passkey for the root domain, that
					passkey will work for all subdomains. But if it creates it for a
					subdomain, it only ever works on that specific subdomain.
				</p>
				<h2>The counter is just a “heuristic”</h2>
				<p>
					Authenticators store a counter which increments for each passkey
					usage. In theory this can detect a cloned authenticator. But much of
					the recommendations say to use the counter as a heuristic rather than
					evidence of a cloned authenticator because there are many legitimate
					reasons the counter can be wrong. I think in practice this counter is
					often ignored.
				</p>
				<h2>Use passkeys stored on nearby devices using Bluetooth</h2>
				<p>
					You can sign into a public computer that does not have your passkeys
					by having your own device&#39;s authenticator communicate with it over
					Bluetooth Low Energy (BLE). Bluetooth is used to assert your close
					proximity with the device you are signing into. Your keys never leave
					your device, the signing protocol travels between the two devices.
				</p>
				<h2>Deleting passkeys with the Signal API</h2>
				<p>
					The JS API cannot list or modify the list of passkeys, only the
					browser GUI or Apple Passwords can do that.
				</p>
				<p>
					But you can asynchronously signal that you want to delete a passkey.
					It is only a hint, and you will not receive back any confirmation as
					that may leak user data.
				</p>
				<p>
					The
					<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/signalUnknownCredential_static">Signal API methods</a>
					currently are:
				</p>
				<pre>PublicKeyCredential.signalUnknownCredential({ rpId, credentialId })  
PublicKeyCredential.signalAllAcceptedCredentials({ rpId, userId, allAcceptedCredentialIds })  
PublicKeyCredential.signalCurrentUserDetails({ rpId, userId, name, displayName })  
</pre>

				<h2>user.id and userHandle represent “one account”</h2>
				<p>
					The <code>user.id</code> and userHandle are the same value, but with
					different names in different JS API calls.
				</p>
				<p>
					They are used to map many passkeys to a single logical account. It
					should be set and stored as passkey APIs require the
					<code>user.id</code> (like the signal APIs above).
				</p>
				<p>
					You can generate one unique <code>user.id</code> per new passkey and
					just store the user =&gt; passkey relation in your database, but this
					may prevent “per account” passkey grouping and management in the
					browser UI.
				</p>
				<h2>crypto.subtle.generateKey can create non-extractable keys</h2>
				<p>
					<a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey">generateKey</a>
					is a JS API that allows you to create new key pairs, where the private
					key cannot be extracted similar to passkeys.
				</p>
				<pre>crypto.subtle.generateKey(algorithm, extractable, keyUsages)  
</pre>

				<p>
					You can perform general operations like signing with this key pair,
					but in the case of JS being compromised, the private key cannot be
					read and moved to a different device. But compromised JS can still
					sign using that unextractable private key.
				</p>
				<h2>
					PKCE = &#34;Proof Key for Code Exchange” was retrofitted into OAuth
				</h2>
				<p>
					<a href="https://datatracker.ietf.org/doc/html/rfc7636">PKCE</a> is a
					protocol that works like a one time password: at the start of every
					sign in flow an actor creates a code_verifier and code_challenge.
				</p>
				<p>
					The code_verifier is a secret random 32 bytes held on the flow
					initiating actor. The code_challenge is the sha256 hash of those
					bytes, and is shared with the user going through the sign in flow.
				</p>
				<p>
					The code_challenge is also sent to the auth service that verifies the
					user and creates a (token, code_challenge).
				</p>
				<p>
					PKCE protects this token by only allowing the holder of the
					code_verifier secret to redeem it by sending (token, code_verifier).
				</p>
				<p>
					This means even if the token is stolen, only the actor that started
					the flow can redeem it with the auth API.
				</p>
				<p>
					PKCE was originally designed for environments that cannot hold static
					secrets because the source code can be read - like JS or desktop apps.
					Instead of embedding static secrets, these actors dynamically create
					secrets at runtime at the start of each sign in flow (the
					code_verifier and code_challenge pair).
				</p>
				<p>
					Passkeybot uses PKCE to avoid having to manage API bearer token
					secrets for each API client. Note: Passkeybot uses the general
					principle behind PKCE, but naming and interaction differs from the
					OAuth standard.
				</p>
				<p>
					It is interesting how they managed to retrofit PKCE into the OAuth
					standard to solve the “token interception” problem. It only requires a
					sha256 hash function so is very easy to implement.
				</p>
				<h2>
					Digital Credentials API is a browser bridge to the native OS wallet
				</h2>
				<p>
					This is a passkey adjacent JS API. The
					<a href="https://developer.chrome.com/blog/digital-credentials-api-shipped">Digital Credentials API</a>
					will allow you to request things from the user&#39;s native OS wallet
					like IDs, tickets, badges, membership cards. It allows you to do
					things like prove your age or ability to drive without having to share
					your actual identity cards.
				</p>
			</article></div>
  </body>
</html>
