<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.wezm.net/v2/posts/2024/gleam-tauri/">Original</a>
    <h1>Building a hybrid native application with Gleam and Tauri</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>I took a few hours this weekend to experiment with building a hybrid
native app with Gleam and Tauri. This post is a summary of that project. If
you’d just like to see the code, I have published that at:</p>
<p><a href="https://forge.wezm.net/wezm/gleam-tauri-experiment">https://forge.wezm.net/wezm/gleam-tauri-experiment</a></p>



<figure>
  <a href="https://www.wezm.net/v2/posts/2024/gleam-tauri/screenshot.png">
  
    <img src="https://www.wezm.net/v2/posts/2024/gleam-tauri/screenshot.png" width="650" alt="Screenshot of the application showing a name field, minus button, plus button, Greet button and the current time."/>
  
  </a>
  <figcaption>Screenshot of the application.</figcaption>
</figure>
<h3 id="introduction">Introduction</h3>
<p><a href="https://gleam.run/">Gleam</a> is statically typed functional language originally written to target
the Erlang virtual machine. Now it also has a JavaScript back-end that allows
Gleam code to run in the browser as well as in <a href="https://nodejs.org/">node.js</a> and <a href="https://deno.com/">Deno</a>. The generated
JavaScript is quite readable similar to <a href="https://elm-lang.org/">Elm</a> and <a href="https://rescript-lang.org/">ReScript</a>/<a href="https://reasonml.github.io/">ReasonML</a>.</p>
<p>Gleam appeals to me as an option for writing front-end code because it’s
stricter than TypeScript, has nominal types, is fast to compile, has a nice
all-in-one developer experience like cargo with the <code>gleam</code> CLI.</p>
<p>One of the things that makes writing front-end applications in Gleam feasible
is the delightful <a href="https://github.com/lustre-labs/lustre">Lustre</a> package. It’s an implementation of the <a href="https://guide.elm-lang.org/architecture/">Elm
architecture</a> in Gleam. If you’ve used Elm a Lustre application will look
extremely familiar. In this context Gleam is kind of like an actively
maintained Elm without the restrictions on interop with existing JavaScript
code.</p>
<p>To get started here’s some Gleam code that demonstrates a decent chunk of the
language:</p>
<pre data-lang="gleam"><code data-lang="gleam"><span>import </span><span>gleam/io
</span><span>import </span><span>gleam/list
</span><span>import </span><span>gleam/int
</span><span>
</span><span>pub type </span><span>Temperature {
</span><span>  F(Float)
</span><span>  C(Float)
</span><span>}
</span><span>
</span><span>pub type </span><span>Celcius {
</span><span>  Celcius(Float)
</span><span>}
</span><span>
</span><span>pub fn </span><span>main</span><span>() {
</span><span>  </span><span>let</span><span> temps = [C(</span><span>22.0</span><span>), C(-</span><span>5.0</span><span>), F(</span><span>0.0</span><span>), C(</span><span>0.0</span><span>), F(</span><span>32.0</span><span>)]
</span><span>  io.</span><span>debug</span><span>(</span><span>avg</span><span>(temps))
</span><span>}
</span><span>
</span><span>pub fn </span><span>avg</span><span>(</span><span>measurements: </span><span>List(Temperature)) </span><span>-&gt; </span><span>Celcius {
</span><span>  </span><span>let</span><span> sum =
</span><span>    list.</span><span>fold</span><span>(measurements, </span><span>0.0</span><span>, </span><span>fn</span><span>(sum, val) {
</span><span>      let Celcius(c) = </span><span>to_c</span><span>(val)
</span><span>      sum +. c
</span><span>    })
</span><span>  </span><span>let</span><span> length =
</span><span>    list.</span><span>length</span><span>(measurements)
</span><span>    |&gt; int.to_float
</span><span>  Celcius(sum /. length)
</span><span>}
</span><span>
</span><span>fn </span><span>to_c</span><span>(</span><span>temp: </span><span>Temperature) </span><span>-&gt; </span><span>Celcius {
</span><span>  </span><span>case</span><span> temp {
</span><span>    C(c) </span><span>-&gt; </span><span>Celcius(c)
</span><span>    F(f) </span><span>-&gt; </span><span>Celcius({ f -. </span><span>32.0 </span><span>} /. </span><span>1.8</span><span>)
</span><span>  }
</span><span>}
</span></code></pre>
<p>When run it outputs:</p>
<pre><code><span>Celcius(1.8444444444444443)
</span></code></pre>
<p>The generated JavaScript (as of Gleam v1.0.0-rc2) is shown below. While it’s
certainly longer than what you might naively write in JavaScript directly it’s
pretty clear what’s going on.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>import </span><span>* </span><span>as </span><span>$int </span><span>from </span><span>&#34;</span><span>../gleam_stdlib/gleam/int.mjs</span><span>&#34;;
</span><span>import </span><span>* </span><span>as </span><span>$io </span><span>from </span><span>&#34;</span><span>../gleam_stdlib/gleam/io.mjs</span><span>&#34;;
</span><span>import </span><span>* </span><span>as </span><span>$list </span><span>from </span><span>&#34;</span><span>../gleam_stdlib/gleam/list.mjs</span><span>&#34;;
</span><span>import </span><span>{ </span><span>toList</span><span>, </span><span>CustomType </span><span>as </span><span>$CustomType</span><span>, </span><span>divideFloat </span><span>} </span><span>from </span><span>&#34;</span><span>./gleam.mjs</span><span>&#34;;
</span><span>
</span><span>export class </span><span>F </span><span>extends </span><span>$CustomType </span><span>{
</span><span>  </span><span>constructor</span><span>(</span><span>x0</span><span>) </span><span>{
</span><span>    </span><span>super</span><span>();
</span><span>    </span><span>this</span><span>[</span><span>0</span><span>] </span><span>= </span><span>x0</span><span>;
</span><span>  }
</span><span>}
</span><span>
</span><span>export class </span><span>C </span><span>extends </span><span>$CustomType </span><span>{
</span><span>  </span><span>constructor</span><span>(</span><span>x0</span><span>) </span><span>{
</span><span>    </span><span>super</span><span>();
</span><span>    </span><span>this</span><span>[</span><span>0</span><span>] </span><span>= </span><span>x0</span><span>;
</span><span>  }
</span><span>}
</span><span>
</span><span>export class </span><span>Celcius </span><span>extends </span><span>$CustomType </span><span>{
</span><span>  </span><span>constructor</span><span>(</span><span>x0</span><span>) </span><span>{
</span><span>    </span><span>super</span><span>();
</span><span>    </span><span>this</span><span>[</span><span>0</span><span>] </span><span>= </span><span>x0</span><span>;
</span><span>  }
</span><span>}
</span><span>
</span><span>function </span><span>to_c</span><span>(</span><span>temp</span><span>) {
</span><span>  </span><span>if </span><span>(</span><span>temp </span><span>instanceof C) {
</span><span>    </span><span>let </span><span>c </span><span>= </span><span>temp</span><span>[</span><span>0</span><span>];
</span><span>    </span><span>return </span><span>new Celcius(</span><span>c</span><span>);
</span><span>  } </span><span>else </span><span>{
</span><span>    </span><span>let </span><span>f </span><span>= </span><span>temp</span><span>[</span><span>0</span><span>];
</span><span>    </span><span>return </span><span>new Celcius(</span><span>divideFloat</span><span>((</span><span>f </span><span>- </span><span>32.0</span><span>), </span><span>1.8</span><span>));
</span><span>  }
</span><span>}
</span><span>
</span><span>export function </span><span>avg</span><span>(</span><span>measurements</span><span>) {
</span><span>  </span><span>let </span><span>sum </span><span>= </span><span>$list</span><span>.</span><span>fold</span><span>(
</span><span>    </span><span>measurements</span><span>,
</span><span>    </span><span>0.0</span><span>,
</span><span>    (</span><span>sum</span><span>, </span><span>val</span><span>) </span><span>=&gt; </span><span>{
</span><span>      </span><span>let </span><span>$ </span><span>= </span><span>to_c</span><span>(</span><span>val</span><span>);
</span><span>      </span><span>let </span><span>c </span><span>= </span><span>$</span><span>[</span><span>0</span><span>];
</span><span>      </span><span>return </span><span>sum </span><span>+ </span><span>c</span><span>;
</span><span>    },
</span><span>  );
</span><span>  </span><span>let </span><span>length </span><span>= (() </span><span>=&gt; </span><span>{
</span><span>    </span><span>let </span><span>_pipe </span><span>= </span><span>$list</span><span>.</span><span>length</span><span>(</span><span>measurements</span><span>);
</span><span>    </span><span>return </span><span>$int</span><span>.</span><span>to_float</span><span>(</span><span>_pipe</span><span>);
</span><span>  })();
</span><span>  </span><span>return </span><span>new Celcius(</span><span>divideFloat</span><span>(</span><span>sum</span><span>, </span><span>length</span><span>));
</span><span>}
</span><span>
</span><span>export function </span><span>main</span><span>() {
</span><span>  </span><span>let </span><span>temps </span><span>= </span><span>toList</span><span>([
</span><span>    new C(</span><span>22.0</span><span>),
</span><span>    new C(-</span><span>5.0</span><span>),
</span><span>    new F(</span><span>0.0</span><span>),
</span><span>    new C(</span><span>0.0</span><span>),
</span><span>    new F(</span><span>32.0</span><span>),
</span><span>  ]);
</span><span>  </span><span>return </span><span>$io</span><span>.</span><span>debug</span><span>(</span><span>avg</span><span>(</span><span>temps</span><span>));
</span><span>}
</span></code></pre>
<h3 id="building-a-hybrid-native-app">Building a Hybrid Native App</h3>

<p><a href="https://tauri.app/">Tauri</a> is a framework for building hybrid native applications. By that I mean
an application that uses native code for the back-end and web technology for the
user interface. This is similar to <a href="https://www.electronjs.org/">Electron</a> except that Tauri does not include
a copy of Chromium in every application, instead relying on the system web view
on the host operating system.</p>
<p>You implement your application logic in Rust and communicate with the UI
by emitting and listening to events. The end result is a cross-platform desktop
app that is a lot smaller than if it were built with Electron.</p>
<p>This weekend I decided to try combining these things to see how feasible it
would be to build a hybrid desktop app with Gleam and Tauri. I started by
following <a href="https://tauri.app/v1/guides/getting-started/setup/vite">the Tauri guide for setting up a Vite project</a>. <a href="https://vitejs.dev/">Vite</a>
is a bundler that takes care of transforming source files on the front-end as
well is providing a nice auto-reloading development experience.</p>
<p>Once that was working I initialised a Gleam project in the same directory:</p>
<pre><code><span>gleam new --name gleamdemo gleam-demo
</span></code></pre>
<p><strong>Note:</strong> I originally called my application <code>videopls</code> there are still some
references to it in the code.</p>
<p>I then followed <a href="https://erikarow.land/notes/gleam-vite">Erika Rowland’s guide to using Gleam with Vite</a>. This
resulted in a simple counter demo running in the Tauri window. At this point
the Gleam code was almost identical to Erika’s post.</p>



<figure>
  <a href="https://www.wezm.net/v2/posts/2024/gleam-tauri/phase1.png">
  
    <img src="https://www.wezm.net/v2/posts/2024/gleam-tauri/phase1.png" width="650" alt="Screenshot of the application showing a counter with plus and minus buttons"/>
  
  </a>
  <figcaption>Phase 1 complete.</figcaption>
</figure>
<p>Now came the uncharted waters: how to integrate <a href="https://tauri.app/v1/references/architecture/inter-process-communication/#commands">Tauri’s command
system</a> to invoke commands in the back-end. Commands are a sort
of in-process communication mechanism where the UI can invoke a function
implemented in Rust on the back-end.</p>
<p>I added a Tauri command to the back-end:</p>
<pre data-lang="rust"><code data-lang="rust"><span>// src-tauri/src/main.rs
</span><span>
</span><span>#[</span><span>tauri</span><span>::</span><span>command</span><span>]
</span><span>fn </span><span>greet</span><span>(</span><span>name</span><span>: &amp;</span><span>str</span><span>) -&gt; String {
</span><span>    format!(&#34;</span><span>Hello, </span><span>{}</span><span>!</span><span>&#34;, name)
</span><span>}
</span></code></pre>
<p>I then needed to be able to use <a href="https://beta.tauri.app/references/v2/js/core/namespacecore/#invoke">the <code>invoke</code> function</a> from the
<a href="https://www.npmjs.com/package/@tauri-apps/api">@tauri-apps/api npm package</a>. Following the pattern I observed
in other Gleam packages I created a JavaScript file to act as a bridge between
Gleam and <code>@tauri-apps/api</code>:</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>// src/ffi/commands.js
</span><span>
</span><span>import </span><span>{ </span><span>invoke </span><span>} </span><span>from </span><span>&#39;</span><span>@tauri-apps/api/core</span><span>&#39;;
</span><span>import </span><span>{ </span><span>Ok</span><span>, </span><span>Error </span><span>} </span><span>from </span><span>&#34;</span><span>../../build/dev/javascript/videopls/gleam.mjs</span><span>&#34;;
</span><span>
</span><span>export async function </span><span>greet</span><span>(</span><span>name</span><span>) {
</span><span>  </span><span>try </span><span>{
</span><span>    </span><span>return </span><span>new Ok(</span><span>await </span><span>invoke</span><span>(&#39;</span><span>greet</span><span>&#39;, { name: </span><span>name </span><span>}));
</span><span>  } </span><span>catch </span><span>(</span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>new Error(</span><span>error</span><span>.</span><span>toString</span><span>());
</span><span>  }
</span><span>}
</span></code></pre>
<p>I could then define the external function in the Gleam code and call it:</p>
<pre data-lang="gleam"><code data-lang="gleam"><span>// src/demo.gleam
</span><span>
</span><span>@external</span><span>(javascript, &#34;</span><span>./ffi/commands.js</span><span>&#34;, &#34;</span><span>greet</span><span>&#34;)
</span><span>pub fn </span><span>greet</span><span>(</span><span>name: </span><span>String) </span><span>-&gt; </span><span>Promise(Result(String, String))
</span></code></pre>
<p>The next challenge was <code>greet</code> is an async function, so it returns a promise,
which does not integrate into a <a href="https://lustre.build/api/lustre#simple">lustre.simple</a> application well. Fortunately
there is the less simple <a href="https://lustre.build/api/lustre#application">lustre.application</a> that adds effects. After looking
at some existing code I was finally able to come up with a working solution.
The full Gleam code is shown below. <code>get_greeting</code> and <code>do_get_greeting</code> being
the main parts of interest.</p>
<pre data-lang="gleam"><code data-lang="gleam"><span>// src/demo.gleam
</span><span>
</span><span>import </span><span>gleam/int
</span><span>import </span><span>gleam/javascript/promise.{</span><span>type </span><span>Promise}
</span><span>import </span><span>lustre
</span><span>import </span><span>lustre/attribute </span><span>as </span><span>attr
</span><span>import </span><span>lustre/element.{</span><span>type </span><span>Element}
</span><span>import </span><span>lustre/element/html
</span><span>import </span><span>lustre/event
</span><span>import </span><span>lustre/effect.{</span><span>type </span><span>Effect}
</span><span>
</span><span>pub fn </span><span>main</span><span>() {
</span><span>  </span><span>let</span><span> app = lustre.</span><span>application</span><span>(init, update, view)
</span><span>  </span><span>let assert </span><span>Ok(dispatch) = lustre.</span><span>start</span><span>(app, &#34;</span><span>#app</span><span>&#34;, Nil)
</span><span>
</span><span>  dispatch
</span><span>}
</span><span>
</span><span>type </span><span>Model {
</span><span>  Model(</span><span>count: </span><span>Int, </span><span>greeting: </span><span>String, </span><span>name: </span><span>String)
</span><span>}
</span><span>
</span><span>fn </span><span>init</span><span>(_) </span><span>-&gt;</span><span> #(Model, Effect(Msg)) {
</span><span>  #(Model(</span><span>0</span><span>, &#34;&#34;, &#34;&#34;), effect.</span><span>none</span><span>())
</span><span>}
</span><span>
</span><span>pub type </span><span>Msg {
</span><span>  Increment
</span><span>  Decrement
</span><span>  Greet
</span><span>  GotGreeting(String)
</span><span>  UpdateName(String)
</span><span>}
</span><span>
</span><span>fn </span><span>update</span><span>(</span><span>model: </span><span>Model, </span><span>msg: </span><span>Msg) </span><span>-&gt;</span><span> #(Model, Effect(Msg)) {
</span><span>  </span><span>case</span><span> msg {
</span><span>    Increment </span><span>-&gt;</span><span> #(Model(..model, </span><span>count:</span><span> model.count + </span><span>1</span><span>), effect.</span><span>none</span><span>())
</span><span>    Decrement </span><span>-&gt;</span><span> #(Model(..model, </span><span>count:</span><span> model.count - </span><span>1</span><span>), effect.</span><span>none</span><span>())
</span><span>    Greet </span><span>-&gt;</span><span> #(model, </span><span>get_greeting</span><span>(model.name))
</span><span>    GotGreeting(greeting) </span><span>-&gt;</span><span> #(
</span><span>      Model(..model, </span><span>greeting:</span><span> greeting),
</span><span>      effect.</span><span>none</span><span>(),
</span><span>    )
</span><span>    UpdateName(name) </span><span>-&gt;</span><span> #(Model(..model, </span><span>name:</span><span> name), effect.</span><span>none</span><span>())
</span><span>  }
</span><span>}
</span><span>
</span><span>fn </span><span>get_greeting</span><span>(</span><span>name: </span><span>String) </span><span>-&gt; </span><span>Effect(Msg) {
</span><span>  effect.</span><span>from</span><span>(</span><span>do_get_greeting</span><span>(name, _))
</span><span>}
</span><span>
</span><span>fn </span><span>do_get_greeting</span><span>(</span><span>name: </span><span>String, </span><span>dispatch: </span><span>fn</span><span>(Msg) </span><span>-&gt; </span><span>Nil) </span><span>-&gt; </span><span>Nil {
</span><span>  </span><span>greet</span><span>(name)
</span><span>  |&gt; promise.</span><span>map</span><span>(</span><span>fn</span><span>(response) {
</span><span>    case response {
</span><span>      Ok(greeting) </span><span>-&gt; </span><span>GotGreeting(greeting)
</span><span>      Error(err) </span><span>-&gt; </span><span>GotGreeting(&#34;</span><span>Error: </span><span>&#34; &lt;&gt; err)
</span><span>    }
</span><span>  })
</span><span>  |&gt; promise.</span><span>tap</span><span>(dispatch)
</span><span>
</span><span>  Nil
</span><span>}
</span><span>
</span><span>@external</span><span>(javascript, &#34;</span><span>./ffi/commands.js</span><span>&#34;, &#34;</span><span>greet</span><span>&#34;)
</span><span>pub fn </span><span>greet</span><span>(</span><span>name: </span><span>String) </span><span>-&gt; </span><span>Promise(Result(String, String))
</span><span>
</span><span>fn </span><span>update_name</span><span>(</span><span>text: </span><span>String) </span><span>-&gt; </span><span>Msg {
</span><span>  UpdateName(text)
</span><span>}
</span><span>
</span><span>// -- VIEW
</span><span>
</span><span>fn </span><span>view</span><span>(</span><span>model: </span><span>Model) </span><span>-&gt; </span><span>Element(Msg) {
</span><span>  </span><span>let</span><span> count = int.</span><span>to_string</span><span>(model.count)
</span><span>
</span><span>  html.</span><span>div</span><span>([], [
</span><span>    html.</span><span>h1</span><span>([], [element.</span><span>text</span><span>(&#34;</span><span>Gleam + Vite + Tauri</span><span>&#34;)]),
</span><span>    html.</span><span>div</span><span>([attr.</span><span>class</span><span>(&#34;</span><span>field text-center</span><span>&#34;)], [
</span><span>      html.</span><span>label</span><span>([attr.</span><span>for</span><span>(&#34;</span><span>greet_name</span><span>&#34;)], [element.</span><span>text</span><span>(&#34;</span><span>Name</span><span>&#34;)]),
</span><span>      element.</span><span>text</span><span>(&#34; &#34;),
</span><span>      html.</span><span>input</span><span>([
</span><span>        attr.</span><span>type_</span><span>(&#34;</span><span>text</span><span>&#34;),
</span><span>        attr.</span><span>name</span><span>(&#34;</span><span>greet_name</span><span>&#34;),
</span><span>        event.</span><span>on_input</span><span>(update_name),
</span><span>      ]),
</span><span>    ]),
</span><span>    html.</span><span>p</span><span>([attr.</span><span>class</span><span>(&#34;</span><span>text-center</span><span>&#34;)], [
</span><span>      element.</span><span>text</span><span>(model.greeting &lt;&gt; &#34; &#34; &lt;&gt; count &lt;&gt; &#34;</span><span> ✨</span><span>&#34;),
</span><span>    ]),
</span><span>    html.</span><span>div</span><span>([attr.</span><span>class</span><span>(&#34;</span><span>text-center</span><span>&#34;)], [
</span><span>      html.</span><span>button</span><span>([event.</span><span>on_click</span><span>(Decrement)], [element.</span><span>text</span><span>(&#34;</span><span>-</span><span>&#34;)]),
</span><span>      html.</span><span>button</span><span>([event.</span><span>on_click</span><span>(Increment)], [element.</span><span>text</span><span>(&#34;</span><span>+</span><span>&#34;)]),
</span><span>      html.</span><span>button</span><span>([event.</span><span>on_click</span><span>(Greet)], [element.</span><span>text</span><span>(&#34;</span><span>Greet</span><span>&#34;)]),
</span><span>    ]),
</span><span>  ])
</span><span>}
</span></code></pre>
<p>I added a <code>Greet</code> message for when the “Greet” button is clicked. The <code>update</code>
function that doesn’t update the model but calls <code>get_greeting</code> as its
side-effect. That builds an <code>Effect</code> from <code>do_get_greeting</code>, which calls the
FFI function and maps the <code>Result</code> to a <code>GotGreeting</code> message containing the
greeting or an error message.</p>
<p><code>update</code> handles the <code>GotGreeting</code> message by updating the model, which in
turn updates the UI. I’m skipping over the <code>Model</code>, <code>view</code>, <code>update</code>
architecture of this Lustre application since it’s basically the <a href="https://guide.elm-lang.org/architecture/">Elm
architecture</a>. A similar pattern is seen in Reason React, ReScript, and <a href="https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers">React
with actions and reducers</a>.</p>
<p>At this point I had worked out how to invoke Rust functions in the back-end via
Tauri commands but I wanted to take it step further. In a real application you
can imagine that the back-end might be performing actions that it needs to tell
the UI about. For example, when updated data is available after a sync.
To do this Tauri provides a way for both parts of the application to emit
events with a payload, and listen for those events. It’s all very similar to how
events work in JavaScript.</p>
<p>I wanted to test this out by periodically having the back-end emit an event and
have the UI listen for the event and update as a result. I decided to have
the back-end emit the current time each second as a UNIX timestamp. Working out
how to do this on back-end stumped me for a bit but I eventually worked out I
could spawn a thread in the <code>setup</code> function:</p>
<pre data-lang="rust"><code data-lang="rust"><span>// src-tauri/src/main.rs
</span><span>
</span><span>use </span><span>std::time::{Duration, Instant, SystemTime, </span><span>UNIX_EPOCH</span><span>};
</span><span>use </span><span>tauri::EventTarget;
</span><span>use </span><span>tauri::Manager;
</span><span>
</span><span>fn </span><span>main</span><span>() {
</span><span>    tauri::Builder::default()
</span><span>        .</span><span>setup</span><span>(|</span><span>app</span><span>| {
</span><span>            </span><span>let</span><span> app = app.</span><span>handle</span><span>().</span><span>clone</span><span>();
</span><span>            std::thread::spawn(</span><span>move </span><span>|| {
</span><span>                </span><span>loop </span><span>{
</span><span>                    </span><span>let</span><span> now = SystemTime::now();
</span><span>                    </span><span>let</span><span> duration = now.</span><span>duration_since</span><span>(</span><span>UNIX_EPOCH</span><span>).</span><span>unwrap</span><span>();
</span><span>                    app.</span><span>emit_to</span><span>(EventTarget::any(), &#34;</span><span>tick</span><span>&#34;, duration.</span><span>as_secs</span><span>())
</span><span>                        .</span><span>unwrap</span><span>();
</span><span>                    std::thread::sleep(Duration::from_secs(</span><span>1</span><span>));
</span><span>                }
</span><span>            });
</span><span>            Ok(())
</span><span>        })
</span><span>        .</span><span>invoke_handler</span><span>(tauri::generate_handler![greet])
</span><span>        .</span><span>run</span><span>(tauri::generate_context!())
</span><span>        .</span><span>expect</span><span>(&#34;</span><span>error while running tauri application</span><span>&#34;);
</span><span>}
</span></code></pre>
<p>In a production application you’d want a mechanism for cleanly shutting the
thread down but for experimentation purposes I skipped that. Now I needed to
listen for the <code>tick</code> event in the UI. I added another glue function to the FFI
file:</p>
<pre data-lang="gleam"><code data-lang="gleam"><span>// src/ffi/commands.js
</span><span>
</span><span>export async function </span><span>listenForTick</span><span>(handler) {
</span><span>  await </span><span>listen</span><span>(&#39;tick&#39;, (event) =&gt; {
</span><span>    </span><span>handler</span><span>(event.payload);
</span><span>  });
</span><span>}
</span></code></pre>
<p>And added a function to the Gleam code to call it and dispatch a message when
it was received:</p>
<pre data-lang="gleam"><code data-lang="gleam"><span>// src/demo.gleam
</span><span>
</span><span>fn </span><span>bind_clock</span><span>() </span><span>-&gt; </span><span>Effect(Msg) {
</span><span>  effect.</span><span>from</span><span>(</span><span>fn</span><span>(dispatch) {
</span><span>    </span><span>listen_for_tick</span><span>(</span><span>fn</span><span>(time) {
</span><span>      </span><span>tick</span><span>(time)
</span><span>      |&gt; dispatch
</span><span>    })
</span><span>
</span><span>    Nil
</span><span>  })
</span><span>}
</span></code></pre>
<p>As a first pass I just rendered the number in the UI but I then extended it to
parse the timestamp into a JavaScript Date and render the stringified version
of it. Surprisingly the <a href="https://hexdocs.pm/gleam_javascript/">gleam_javascript</a> package doesn’t have Date bindings
yet so I created some for what I needed:</p>
<pre data-lang="gleam"><code data-lang="gleam"><span>// src/ffi/js_extra.js
</span><span>
</span><span>export function </span><span>from_unix</span><span>(timestamp) {
</span><span>    return new Date(timestamp * </span><span>1000</span><span>);
</span><span>}
</span><span>
</span><span>export function </span><span>date_to_string</span><span>(date) {
</span><span>    return date.</span><span>toString</span><span>();
</span><span>}
</span></code></pre>
<p>I think in an ideal world simple bindings like this (especially <code>toString</code>)
would be able to be expressed solely though the <code>@external</code> attribute. That
doesn’t seem to be possible yet but if it is please let me know.</p>
<p>I bound those in Gleam:</p>
<pre data-lang="gleam"><code data-lang="gleam"><span>// src/demo.gleam
</span><span>
</span><span>pub type </span><span>Date
</span><span>
</span><span>@external</span><span>(javascript, &#34;</span><span>./ffi/js_extra.js</span><span>&#34;, &#34;</span><span>from_unix</span><span>&#34;)
</span><span>pub fn </span><span>new_date</span><span>(</span><span>timestamp: </span><span>Int) </span><span>-&gt; </span><span>Date
</span><span>
</span><span>@external</span><span>(javascript, &#34;</span><span>./ffi/js_extra.js</span><span>&#34;, &#34;</span><span>date_to_string</span><span>&#34;)
</span><span>pub fn </span><span>date_to_string</span><span>(</span><span>date: </span><span>Date) </span><span>-&gt; </span><span>String
</span></code></pre>
<p>and updated the application to use them. The result is a clock at the bottom of
the page that updates each second:</p>

<p>The final Gleam application looks like this:</p>
<pre data-lang="gleam"><code data-lang="gleam"><span>// src/demo.gleam
</span><span>
</span><span>import </span><span>gleam/int
</span><span>import </span><span>gleam/javascript/promise.{</span><span>type </span><span>Promise}
</span><span>import </span><span>lustre
</span><span>import </span><span>lustre/attribute </span><span>as </span><span>attr
</span><span>import </span><span>lustre/element.{</span><span>type </span><span>Element}
</span><span>import </span><span>lustre/element/html
</span><span>import </span><span>lustre/event
</span><span>import </span><span>lustre/effect.{</span><span>type </span><span>Effect}
</span><span>
</span><span>pub fn </span><span>main</span><span>() {
</span><span>  </span><span>let</span><span> app = lustre.</span><span>application</span><span>(init, update, view)
</span><span>  </span><span>let assert </span><span>Ok(dispatch) = lustre.</span><span>start</span><span>(app, &#34;</span><span>#app</span><span>&#34;, Nil)
</span><span>
</span><span>  dispatch
</span><span>}
</span><span>
</span><span>type </span><span>Model {
</span><span>  Model(</span><span>count: </span><span>Int, </span><span>greeting: </span><span>String, </span><span>name: </span><span>String, </span><span>time: </span><span>Int)
</span><span>}
</span><span>
</span><span>fn </span><span>init</span><span>(_) </span><span>-&gt;</span><span> #(Model, Effect(Msg)) {
</span><span>  #(Model(</span><span>0</span><span>, &#34;&#34;, &#34;&#34;, </span><span>0</span><span>), </span><span>bind_clock</span><span>())
</span><span>}
</span><span>
</span><span>pub type </span><span>Msg {
</span><span>  Increment
</span><span>  Decrement
</span><span>  Greet
</span><span>  GotGreeting(String)
</span><span>  UpdateName(String)
</span><span>  Tick(Int)
</span><span>}
</span><span>
</span><span>fn </span><span>update</span><span>(</span><span>model: </span><span>Model, </span><span>msg: </span><span>Msg) </span><span>-&gt;</span><span> #(Model, Effect(Msg)) {
</span><span>  </span><span>case</span><span> msg {
</span><span>    Increment </span><span>-&gt;</span><span> #(Model(..model, </span><span>count:</span><span> model.count + </span><span>1</span><span>), effect.</span><span>none</span><span>())
</span><span>    Decrement </span><span>-&gt;</span><span> #(Model(..model, </span><span>count:</span><span> model.count - </span><span>1</span><span>), effect.</span><span>none</span><span>())
</span><span>    Greet </span><span>-&gt;</span><span> #(model, </span><span>get_greeting</span><span>(model.name))
</span><span>    GotGreeting(greeting) </span><span>-&gt;</span><span> #(
</span><span>      Model(..model, </span><span>greeting:</span><span> greeting),
</span><span>      effect.</span><span>none</span><span>(),
</span><span>    )
</span><span>    UpdateName(name) </span><span>-&gt;</span><span> #(Model(..model, </span><span>name:</span><span> name), effect.</span><span>none</span><span>())
</span><span>    Tick(time) </span><span>-&gt;</span><span> #(Model(..model, </span><span>time:</span><span> time), effect.</span><span>none</span><span>())
</span><span>  }
</span><span>}
</span><span>
</span><span>fn </span><span>get_greeting</span><span>(</span><span>name: </span><span>String) </span><span>-&gt; </span><span>Effect(Msg) {
</span><span>  effect.</span><span>from</span><span>(</span><span>do_get_greeting</span><span>(name, _))
</span><span>}
</span><span>
</span><span>fn </span><span>do_get_greeting</span><span>(</span><span>name: </span><span>String, </span><span>dispatch: </span><span>fn</span><span>(Msg) </span><span>-&gt; </span><span>Nil) </span><span>-&gt; </span><span>Nil {
</span><span>  </span><span>greet</span><span>(name)
</span><span>  |&gt; promise.</span><span>map</span><span>(</span><span>fn</span><span>(response) {
</span><span>    case response {
</span><span>      Ok(greeting) </span><span>-&gt; </span><span>GotGreeting(greeting)
</span><span>      Error(err) </span><span>-&gt; </span><span>GotGreeting(&#34;</span><span>Error: </span><span>&#34; &lt;&gt; err)
</span><span>    }
</span><span>  })
</span><span>  |&gt; promise.</span><span>tap</span><span>(dispatch)
</span><span>
</span><span>  Nil
</span><span>}
</span><span>
</span><span>fn </span><span>bind_clock</span><span>() </span><span>-&gt; </span><span>Effect(Msg) {
</span><span>  effect.</span><span>from</span><span>(</span><span>fn</span><span>(dispatch) {
</span><span>    </span><span>listen_for_tick</span><span>(</span><span>fn</span><span>(time) {
</span><span>      </span><span>tick</span><span>(time)
</span><span>      |&gt; dispatch
</span><span>    })
</span><span>
</span><span>    Nil
</span><span>  })
</span><span>}
</span><span>
</span><span>@external</span><span>(javascript, &#34;</span><span>./ffi/commands.js</span><span>&#34;, &#34;</span><span>greet</span><span>&#34;)
</span><span>pub fn </span><span>greet</span><span>(</span><span>name: </span><span>String) </span><span>-&gt; </span><span>Promise(Result(String, String))
</span><span>
</span><span>type </span><span>UnlistenFn =
</span><span>  </span><span>fn</span><span>() </span><span>-&gt; </span><span>Nil
</span><span>
</span><span>@external</span><span>(javascript, &#34;</span><span>./ffi/commands.js</span><span>&#34;, &#34;</span><span>listenForTick</span><span>&#34;)
</span><span>pub fn </span><span>listen_for_tick</span><span>(</span><span>handler: </span><span>fn</span><span>(Int) </span><span>-&gt; </span><span>Nil) </span><span>-&gt; </span><span>Promise(UnlistenFn)
</span><span>
</span><span>pub type </span><span>Date
</span><span>
</span><span>@external</span><span>(javascript, &#34;</span><span>./ffi/js_extra.js</span><span>&#34;, &#34;</span><span>from_unix</span><span>&#34;)
</span><span>pub fn </span><span>new_date</span><span>(</span><span>timestamp: </span><span>Int) </span><span>-&gt; </span><span>Date
</span><span>
</span><span>@external</span><span>(javascript, &#34;</span><span>./ffi/js_extra.js</span><span>&#34;, &#34;</span><span>date_to_string</span><span>&#34;)
</span><span>pub fn </span><span>date_to_string</span><span>(</span><span>date: </span><span>Date) </span><span>-&gt; </span><span>String
</span><span>
</span><span>fn </span><span>update_name</span><span>(</span><span>text: </span><span>String) </span><span>-&gt; </span><span>Msg {
</span><span>  UpdateName(text)
</span><span>}
</span><span>
</span><span>fn </span><span>tick</span><span>(</span><span>time: </span><span>Int) </span><span>-&gt; </span><span>Msg {
</span><span>  Tick(time)
</span><span>}
</span><span>
</span><span>// -- VIEW
</span><span>
</span><span>fn </span><span>view</span><span>(</span><span>model: </span><span>Model) </span><span>-&gt; </span><span>Element(Msg) {
</span><span>  </span><span>let</span><span> count = int.</span><span>to_string</span><span>(model.count)
</span><span>  </span><span>let</span><span> time =
</span><span>    model.time
</span><span>    |&gt; new_date
</span><span>    |&gt; date_to_string
</span><span>
</span><span>  html.</span><span>div</span><span>([], [
</span><span>    html.</span><span>h1</span><span>([], [element.</span><span>text</span><span>(&#34;</span><span>Gleam + Vite + Tauri</span><span>&#34;)]),
</span><span>    html.</span><span>div</span><span>([attr.</span><span>class</span><span>(&#34;</span><span>field text-center</span><span>&#34;)], [
</span><span>      html.</span><span>label</span><span>([attr.</span><span>for</span><span>(&#34;</span><span>greet_name</span><span>&#34;)], [element.</span><span>text</span><span>(&#34;</span><span>Name</span><span>&#34;)]),
</span><span>      element.</span><span>text</span><span>(&#34; &#34;),
</span><span>      html.</span><span>input</span><span>([
</span><span>        attr.</span><span>type_</span><span>(&#34;</span><span>text</span><span>&#34;),
</span><span>        attr.</span><span>name</span><span>(&#34;</span><span>greet_name</span><span>&#34;),
</span><span>        event.</span><span>on_input</span><span>(update_name),
</span><span>      ]),
</span><span>    ]),
</span><span>    html.</span><span>p</span><span>([attr.</span><span>class</span><span>(&#34;</span><span>text-center</span><span>&#34;)], [
</span><span>      element.</span><span>text</span><span>(model.greeting &lt;&gt; &#34; &#34; &lt;&gt; count &lt;&gt; &#34;</span><span> ✨</span><span>&#34;),
</span><span>    ]),
</span><span>    html.</span><span>div</span><span>([attr.</span><span>class</span><span>(&#34;</span><span>text-center</span><span>&#34;)], [
</span><span>      html.</span><span>button</span><span>([event.</span><span>on_click</span><span>(Decrement)], [element.</span><span>text</span><span>(&#34;</span><span>-</span><span>&#34;)]),
</span><span>      html.</span><span>button</span><span>([event.</span><span>on_click</span><span>(Increment)], [element.</span><span>text</span><span>(&#34;</span><span>+</span><span>&#34;)]),
</span><span>      html.</span><span>button</span><span>([event.</span><span>on_click</span><span>(Greet)], [element.</span><span>text</span><span>(&#34;</span><span>Greet</span><span>&#34;)]),
</span><span>    ]),
</span><span>    html.</span><span>div</span><span>([attr.</span><span>class</span><span>(&#34;</span><span>clock text-center</span><span>&#34;)], [
</span><span>      element.</span><span>text</span><span>(&#34;</span><span>Clock: </span><span>&#34; &lt;&gt; time),
</span><span>    ]),
</span><span>  ])
</span><span>}
</span></code></pre>
<h3 id="conclusion">Conclusion</h3>
<p>I successfully built a hybrid native application with Gleam and Tauri. While
what I built is clearly experimental code I think it was enough to work out the
approach and patterns you could use to build a larger application. Using Gleam
to build a web components or web front-ends seems quite feasible.</p>
<p>Some unanswered questions I have from this experiment are:</p>
<ol>
<li>Does binding to external functions in the JS platform or npm packages always
require some JS glue code? It seems it does at the moment.</li>
<li>What is the right way to import <code>gleam.mjs</code> from JavaScript code?</li>
<li>What is the structure of the Gleam <code>build</code> directory?
<ul>
<li>I see <code>dev</code> and <code>prod</code> sub-directories.</li>
<li>Is the <code>prod</code> on used when targeting JavaScript
<ul>
<li>I can’t see any equivalent of Cargo’s <code>--release</code> in the <code>gleam</code> CLI help.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The full project code is available here:</p>
<p><a href="https://forge.wezm.net/wezm/gleam-tauri-experiment">https://forge.wezm.net/wezm/gleam-tauri-experiment</a></p>
<h4 id="thanks">Thanks</h4>
<p>Special thanks to the following folks:</p>
<ul>
<li><a href="https://github.com/hayleigh-dot-dev">Hayleigh Thompson</a> for building Lustre.</li>
<li><a href="https://github.com/Enderchief">Enderchief</a> for <a href="https://github.com/Enderchief/gleam-tools/tree/master/packages/vite-gleam">vite-gleam</a>, which makes it super easy to integrate Gleam code with Vite.</li>
<li><a href="https://erikarow.land/">Erika Rowland</a> for <a href="https://erikarow.land/notes/gleam-vite">her Gleam Vite guide</a>. <a href="https://erikarow.land/notes/esgleam-embed">The follow up on <code>esgleam</code></a> is also good.</li>
</ul>

  </div></div>
  </body>
</html>
