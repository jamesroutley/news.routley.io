<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jacobbartlett.substack.com/p/through-the-ages-apple-cpu-architecture">Original</a>
    <h1>Apple CPU Architecture Through the Ages</h1>
    
    <div id="readability-page-1" class="page"><div class=""><div><div dir="auto"><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fef56b4d8-b9c0-4766-98f4-ffebb24d9458_700x620.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fef56b4d8-b9c0-4766-98f4-ffebb24d9458_700x620.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fef56b4d8-b9c0-4766-98f4-ffebb24d9458_700x620.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fef56b4d8-b9c0-4766-98f4-ffebb24d9458_700x620.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fef56b4d8-b9c0-4766-98f4-ffebb24d9458_700x620.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fef56b4d8-b9c0-4766-98f4-ffebb24d9458_700x620.png" width="700" height="620" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/ef56b4d8-b9c0-4766-98f4-ffebb24d9458_700x620.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:620,&#34;width&#34;:700,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:null,&#34;alt&#34;:&#34;&#34;,&#34;title&#34;:null,&#34;type&#34;:null,&#34;href&#34;:null,&#34;belowTheFold&#34;:false,&#34;topImage&#34;:true,&#34;internalRedirect&#34;:null}" alt="" title="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fef56b4d8-b9c0-4766-98f4-ffebb24d9458_700x620.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fef56b4d8-b9c0-4766-98f4-ffebb24d9458_700x620.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fef56b4d8-b9c0-4766-98f4-ffebb24d9458_700x620.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fef56b4d8-b9c0-4766-98f4-ffebb24d9458_700x620.png 1456w" sizes="100vw" fetchpriority="high"/></picture></div></a><figcaption><span>CPU die of the Apple Silicon M1 system-on-a-chip — Image from </span><a href="https://www.apple.com/uk/newsroom/2020/11/apple-unleashes-m1/" rel="">Apple Newsroom</a></figcaption></figure></div><p>This is the tale of the 4 Ages of Apple CPU Architecture. Each chapter, however, also serves as a framing device for fundamental CPU concepts.</p><p>If Android is more your thing, you are free to jump between sections at will like an overclocked instruction pointer.</p><p><strong><a href="https://jacobbartlett.substack.com/i/138428815/motorola-k" rel="">1984 — Motorola 68k</a></strong></p><ul><li><p><a href="https://jacobbartlett.substack.com/i/138428815/the-cpu-and-registers" rel="">The CPU and Registers</a></p></li><li><p><a href="https://jacobbartlett.substack.com/i/138428815/the-alu" rel="">The Arithmetic-Logic Unit</a></p></li><li><p><a href="https://jacobbartlett.substack.com/i/138428815/bit-and-bit" rel="">8-bit vs. 16-bit</a></p></li><li><p><a href="https://jacobbartlett.substack.com/i/138428815/endian-ness" rel="">Endian-ness</a></p></li></ul><p><strong><a href="https://jacobbartlett.substack.com/i/138428815/powerpc" rel="">1994 — PowerPC</a></strong></p><ul><li><p><a href="https://jacobbartlett.substack.com/i/138428815/cisc-vs-risc" rel="">CISC vs. RISC</a></p></li><li><p><a href="https://jacobbartlett.substack.com/i/138428815/pipelining" rel="">Pipelining</a></p></li><li><p><a href="https://jacobbartlett.substack.com/i/138428815/assembly-language" rel="">Assembly Language</a></p></li><li><p><a href="https://jacobbartlett.substack.com/i/138428815/the-powerpc-transition" rel="">Emulation</a></p></li></ul><p><strong><a href="https://jacobbartlett.substack.com/i/138428815/intel-x" rel="">2006 — Intel x86</a></strong></p><ul><li><p><a href="https://jacobbartlett.substack.com/i/138428815/cpu-caches" rel="">CPU Caches (L1, L2, L3)</a></p></li><li><p><a href="https://jacobbartlett.substack.com/i/138428815/branch-prediction" rel="">Branch Prediction</a></p></li><li><p><a href="https://jacobbartlett.substack.com/i/138428815/superscalar-architecture" rel="">Superscalar Architecture</a></p></li><li><p><a href="https://jacobbartlett.substack.com/i/138428815/further-intel-innovations" rel="">Hyper-threading</a></p></li></ul><p><strong><a href="https://jacobbartlett.substack.com/i/138428815/apple-silicon" rel="">2020 — Apple Silicon</a></strong></p><ul><li><p><a href="https://jacobbartlett.substack.com/i/138428815/heterogeneous-computing" rel="">Heterogeneous Computing</a></p></li><li><p><a href="https://jacobbartlett.substack.com/i/138428815/unified-memory-architecture" rel="">Unified Memory Architecture</a></p></li><li><p><a href="https://jacobbartlett.substack.com/i/138428815/out-of-order-execution" rel="">Out-of-order Execution</a></p></li><li><p><a href="https://jacobbartlett.substack.com/i/138428815/physics-the-ultimate-constraint" rel="">Physics: The Ultimate Constraint</a></p></li></ul><p>I’m no evangelist, but it doesn’t take a fanboy to acknowledge that Apple is an impressive company.</p><p><span>They invented the </span><a href="https://macdailynews.com/2019/05/16/apples-iphone-is-the-most-successful-product-of-all-time/" rel="">most successful product in the history of capitalism</a><span>, and subsequently became the first business to hit a $1T market cap. Through hit products like the iPod, unparalleled branding, and the reality distortion field of Steve Jobs, they even managed to make tech </span><em>cool</em><span>.</span></p><p><span>Behind this impressive execution is a borderline-obsessive hardware optimisation: Since the Mac was released </span><a href="https://www.youtube.com/watch?v=VtvjbmoDx-I" rel="">in 1984</a><span>, Apple has migrated its CPU architecture </span><strong>three times</strong><span>.</span></p><p>This is no easy feat.</p><p><span>Every time a computer company announces a CPU architecture migration, there is widespread skepticism about whether the business can survive </span><em>its entire software ecosystem being deprecated at once</em><span>.</span></p><p><span>In the days when software still came in cardboard boxes, this skepticism bordered on incredulity. John Dvorak, prominent tech columnist, suggested the 2005 move to Intel x86 was a precursor to </span><a href="https://web.archive.org/web/20060409115933/http://www.pcmag.com/article2/0,1895,1927885,00.asp" rel="">bringing Apple onto Windows</a><span>.</span></p><blockquote><p><span>Apple is the undisputed </span><em><strong>king</strong></em><span> of CPU architecture migrations.</span></p></blockquote><p>Apple’s tolerance for pain in the short term has allowed them to master the processor game. Each new CPU architecture allowed Apple to stay competitive against existential threats; or to place themselves head-and-shoulders above the competition.</p><p>Today, we’re going on an odyssey through the 4 eras of Apple CPU architectures. I’ll colour in the business context — why each migration was necessary — and will show you how Apple survived each transition to end up even stronger than before.</p><p>Along the way, we’ll learn some critical CPU concepts as we go. Chip technology becomes more and more advanced as time marches on, offering us a convenient learning curve as we travel Through The Ages.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6e6bd540-cd5d-42d6-9241-af44ce10c444_573x505.jpeg" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6e6bd540-cd5d-42d6-9241-af44ce10c444_573x505.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6e6bd540-cd5d-42d6-9241-af44ce10c444_573x505.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6e6bd540-cd5d-42d6-9241-af44ce10c444_573x505.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6e6bd540-cd5d-42d6-9241-af44ce10c444_573x505.jpeg 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6e6bd540-cd5d-42d6-9241-af44ce10c444_573x505.jpeg" width="573" height="505" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/6e6bd540-cd5d-42d6-9241-af44ce10c444_573x505.jpeg&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:505,&#34;width&#34;:573,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:null,&#34;alt&#34;:&#34;&#34;,&#34;title&#34;:null,&#34;type&#34;:null,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="" title="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6e6bd540-cd5d-42d6-9241-af44ce10c444_573x505.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6e6bd540-cd5d-42d6-9241-af44ce10c444_573x505.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6e6bd540-cd5d-42d6-9241-af44ce10c444_573x505.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6e6bd540-cd5d-42d6-9241-af44ce10c444_573x505.jpeg 1456w" sizes="100vw" loading="lazy"/></picture></div></a><figcaption><span>Internal die of the Motorola 68,000 CPU — Image from </span><a href="https://www.cpu-world.com/CPUs/68000/die/L_Motorola-MC68000L8.jpg" rel="">cpu-world.com</a></figcaption></figure></div><p>1981.</p><p>Reagan. MTV. Indiana Jones.</p><p>Apple is stumbling.</p><p>Its early breakout success and cash cow, the Wozniak wizardry of the 1977 Apple II, was creaking under its age.</p><p>The IBM PC has just hit the mass market, precipitating an unprecedented influx of purchase orders for PCs. 24-year-old whizkid Bill Gates was asked to supply IBM’s operating system.</p><blockquote><p><em>In 10 years, let’s check in on our friends at IBM to see how this move went.</em></p></blockquote><p>Apple’s LISA is shaping up to be their flagship product. After being a huge jerk to everybody for 5 years, Steve Jobs has been relegated by the board to run the low-end Macintosh project.</p><p><span>Initially a cheaper mass-market consumer product, the Macintosh under Jobs pivoted to focus on one thing: </span><a href="https://www.howtogeek.com/677270/deja-vu-a-brief-history-of-every-mac-cpu-architecture/" rel="">upstaging the LISA team</a><span>. Steve introduced a cutting-edge </span><a href="https://crm.org/articles/xerox-parc-and-the-origins-of-gui" rel="">totally-not-stolen</a><span> graphical user interface to the Macintosh and demanded his team find the most advanced hardware available at the time.</span></p><p><span>If you want to </span><em>make a dent in the personal computer universe</em><span>, your choice of CPU is critical. This is the hardware in which your OS lives and the platform upon which you nurture your software ecosystem.</span></p><p><span>Very early PCs — the sort that hobbyists like Wozniak assembled in their garages — </span><a href="https://lowendmac.com/2014/cpus-motorola-68000/" rel="">used 8-bit CPUs</a><span>. But if you’re designing a powerful mass-market computer in the early 1980s, you’re going to want to use modern 16-bit processor architecture. There are really three major choices available: The Intel 8088, the Zilog Z8000, or the Motorola 68k.</span></p><p>Here, 8-bit and 16-bit refers to the size, or “width” in bits, of the registers and data bus with which the CPU works.</p><p><span>Let’s get on the same page: a </span><strong>CPU</strong><span> is a device that moves data from computer memory (RAM) into fast temporary memory (registers), runs operations on this data, then moves the output back into memory.</span></p><p><span>A </span><strong>register</strong><span> is the tiniest unit of electronic memory — they each hold just a few bits in the heart of the CPU. The CPU follows instructions (a computer program) to perform operations on this data — manipulating the bits (</span><code>1</code><span>s and </span><code>0</code><span>s).</span></p><p><span>These operations are performed by the </span><strong>Arithmetic-Logic Unit</strong><span> (ALU). This is basically a collection of circuits that perform simple, specialised jobs, such as:</span></p><ul><li><p><span>Adding up binary numbers, e.g. </span><code>0010</code><span> + </span><code>0101</code><span> = </span><code>0111</code></p></li><li><p><span>Perform logical operations, e.g. </span><code>NOT</code><span> </span><code>0000</code><span> = </span><code>1111</code></p></li><li><p><span>Shift bits around, e.g. left-shifting </span><code>0011</code><span> by 1 place becomes </span><code>0110</code></p></li></ul><p><span>The CPU’s control unit decodes instructions one at a time to decide what </span><em>data</em><span> should move to which </span><em>register</em><span>, and which </span><em>register’s data</em><span> should go through which </span><em>ALU circuitry</em><span>.</span></p><p>Perform these operations lots of times, very quickly, and it adds up to outputs such as matrix multiplication, collision physics in a video game, or rasterising image data into on-screen pixels.</p><p>So why does bit width matter?</p><p><span>An 8-bit CPU can run a </span><code>NOT</code><span> operation on </span><code>0010110</code><span> in one clock cycle, inverting its bits into </span><code>1101001</code><span>. A 16-bit CPU leaves this in the dust, converting a hefty </span><code>10100100010110</code><span> into </span><code>01011001101001</code><span> in the same amount of time.</span></p><p>Moreover, a single 8-bit register can point at 2⁸ different byte ‘addresses’ in RAM — a meagre 256 locations in which we can look for data. Due to this limitation, most 8-bit computers needed two registers to store memory addresses. 16-bit registers, or two 8-bit registers stacked against each other, can point to 2¹⁶ memory addresses, meaning access to 64kB of memory.</p><p><strong>Endian-ness</strong><span> becomes a major compatibility consideration when upgrading from 8-bit (1 byte) to 16-bit CPUs (2 bytes). Systems are either big-endian or little-endian, which defines the order in which they store bytes — for example, the number 41,394, in hexadecimal fashion, would be stored on registers as </span><code>A1 B2</code><span> in big-endian systems and </span><code>B2 A1</code><span> in little-endian systems.</span></p><p><span>Lastly, the “</span><strong>data bus</strong><span>” refers to the circuity that connects the CPU to main memory; so a 16-bit bus is essentially twice as fast as an 8-bit bus at reading and writing data to and from memory.</span></p><p>Are we all on the same page? Let’s get back to Apple.</p><p>Let’s imagine you’re Apple’s VP of Hardware presenting to Jobs.</p><p>Which chip architecture do you think you’d choose?</p><ul><li><p>8/16-bit microprocessor — 8-bit registers with a 16-bit data bus.</p></li><li><p>20-bit memory addressing range — supports 640kB of RAM.</p></li><li><p>The IBM PC uses this chip architecture, so it has a strong existing software ecosystem.</p></li><li><p>Low-end price point of ~$35 (in 1983 dollars) thanks to Intel’s massive economies of scale.</p></li><li><p>Little-endian.</p></li></ul><ul><li><p>Pure 16-bit microprocessor — 16-bit registers and 16-bit data bus.</p></li><li><p>23-bit memory addressing rage — supports 8MB of RAM</p></li><li><p>Few large competitors use this architecture, minimal software ecosystem.</p></li><li><p><span>Mid-range price point of ~</span><a href="https://thechipletter.substack.com/p/captain-zilog-crushed-supplemental" rel="">$55 in 1983 dollars</a><span> while looking to build market share.</span></p></li><li><p>(Mostly) big-endian.</p></li></ul><ul><li><p>16/32-bit microprocessor — 32-bit registers with a 16-bit data bus.</p></li><li><p>24-bit memory addressing range —supports 16MB of RAM.</p></li><li><p>Atari and Commodore use this chip architecture, some existing dev ecosystem.</p></li><li><p>Prior supplier relationship with Motorola through the Apple I, Apple II, and LISA.</p></li><li><p>Mid-to-high-end price point of ~$70 in 1983 dollars.</p></li><li><p>Big-endian.</p></li></ul><p><span>Overall, the Motorola 68k appeared to be the forward-thinking choice to </span><a href="https://www.youtube.com/watch?v=VtvjbmoDx-I" rel="">show why 1984 won’t be like 1984</a><span>. The weaker dev ecosystem and compatibility was a necessary sacrifice to provide brand differentiation against the dominant IBM PC.</span></p><p><span>What’s more, the 68k had a (mostly) </span><strong>orthogonal</strong><span> instruction set — this meant that (almost) every CPU operation could be performed on (almost) every register, whereas many competing CPUs had instructions restricted to specific registers. Orthogonality makes a CPU much easier to program, which is ideal when nurturing a nascent software ecosystem.</span></p><p>The 16MB addressing range ended up becoming critical: the Macintosh reserved the top 12MB of RAM for the OS, leaving a pithy 4MB of computer memory shared between software applications.</p><p>If you ever looked, dismayed, at the storage space available in your 16GB iPod Touch in 2012, you’ll know that nothing changes.</p><p>The year is 1994.</p><p>Steve Jobs was ousted by Apple 8 years ago, and is busy inventing Pixar and NeXT.</p><p>Apple is losing relevance.</p><p>Their former bitter PC rival, IBM, was in the long, painful process of having their lunch eaten by Microsoft.</p><p><span>Intel and Bill Gates, who was more commonly known as “the devil” in the 1990s, had entered an unholy marriage referred to as </span><em><a href="https://www.mayin.org/ajayshah/MEDIA/1998/wintel.html" rel="">Wintel</a><span> </span></em><span>that was carving out near-monopolies for both businesses.</span></p><p><span>Beyond consistent improvement to their powerful x86 chip architecture, Intel had just produced the greatest innovation since the transistor: giving their chip a cool name. The </span><em>Pentium </em><span>processor powered the Microsoft market-share munching machine.</span></p><p>That’s not to downplay the power of x86 chip architecture: Intel was earning its dominance with a 100MHz clock speeds and unparalleled power efficiency. The Motorola 68,000 chip family that carried the Macintosh into the 90’s was failing to keep up.</p><p>With the computer world under threat from monopoly, Apple joined up with its longtime partner, Motorola, and an unlikely ally, IBM. The plan: use the power of friendship to fight the forces of capitalism.</p><p>The AIM (Apple, IBM, Motorola) alliance was born. They realised that the x86 architecture had a key weakness: it utilised CISC architecture.</p><p><span>In response, AIM deployed a RISCy tactic: </span><strong>PowerPC</strong><span>.</span></p><p>There are two opposing chip design philosophies:</p><ul><li><p><strong>CISC</strong><span> (Complex Instruction Set Computer)</span></p></li><li><p><strong>RISC</strong><span> (Reduced Instruction Set Computer)</span></p></li></ul><p><span>To understand this, we need to get a handle on what is meant by </span><strong>Instruction Sets</strong><span>. In the previous section, I mentioned the CPU is running </span><em>operations</em><span> every </span><em>clock cycle</em><span>. These operations include things like moving data between registers, arithmetic, and logic operations.</span></p><p><span>Each CPU, constrained by the actual physical layout of its circuitry, can perform a limited number of different operations. These individual operations are represented by </span><strong>Assembly Language</strong><span>, also called machine code. This code is fed into the processor as a sequence of binary instructions and performed sequentially.</span></p><p>The two schools of thought lead to divergent approaches for building microprocessors:</p><ul><li><p><strong>CISC </strong><span>accepts a complex instruction set to continue adding functionality to your CPU. Eventually, you gain the power to perform complex multi-step processing with single instructions, such as the (in)famous </span><em>evaluate polynomial</em><span> instruction, </span><code>POLY</code><span>. While this felt like magic, it also meant lots of internal state was held by the processor — and devastating performance hits if anything goes wrong.</span></p></li><li><p><strong>RISC</strong><span> takes the “Keep it simple, stupid!” approach. The big pitfall in CISC was complexity for the developers. The compiler engineers writing for CISC architectures had to consult 500-page manuals to find the instructions they might need, while RISC engineers were laughing with the 60-ish instructions stored in their registers — I mean — brains.</span></p></li></ul><p><span>To really see the primary performance boost endowed by RISC, you need to understand </span><strong>Pipelining</strong><span> by looking at the fetch-decode-execute cycle. In short, in a single clock cycle — the time for one operation to execute on the CPU — one of three things is done:</span></p><ul><li><p><strong>Fetch:</strong><span> The CPU fetches the next machine code instruction from memory.</span></p></li><li><p><strong>Decode</strong><span>: The CPU’s control unit interprets the instruction to work out what it actually does.</span></p></li><li><p><strong>Execute: </strong><span>The CPU executes the instruction — that is; moving data between registers and memory, or pushing bits through logic units.</span></p></li></ul><p><span>When your CPU uses a simpler RISC instruction set, these steps each take a single cycle, and you can </span><em>line up these operations concurrently</em><span>. In each clock cycle, you can get 3 instruction running, 1 at each of the 3 stages, in parallel. This results in (on average) one machine code operation executed per clock cycle.</span></p><p><span>When using CISC, each steps might not take a consistent 1-cycle-per-step. For the </span><code>POLY</code><span> operation, the execute step alone might take 10 cycles for an x² expression. In CISC, it’s hard to get your operations lining up nicely and therefore it’s tough to get good performance on complex instructions.</span></p><p>Pipelining, in short, is the concept of interleaving these instructions concurrently.</p><p>Apple and the AIM alliance hatched their scheme.</p><p>PowerPC, a modern Reduced Instruction Set Computer microprocessor architecture, was built to compete directly with the dominant Intel x86 architecture.</p><p>PowerPC promised better efficiency — that is, more CPU operations per watt of electricity — and since Apple controlled both software and hardware, they could optimise the Mac OS for this processor architecture.</p><p>Now they just had to migrate their ecosystem.</p><p>Software written for one processor doesn’t necessarily run on another. Different families of processors naturally contain different instruction sets — that is, the list of assembly instructions that define each CPU operation.</p><p>Here’s a slice of Motorola 68k assembly code:</p><pre><code>MOVE.L  $1000, D0     ; Load longword from address $1000 into data register D0
MOVE.L  $1004, D1     ; Load longword from address $1004 into data register D1
ADD.L   D1, D0        ; Add the values in D0 and D1, result stored in D0
MOVE.L  $1000, D0     ; Load longword from address $1000 into data register D1
NOT.L   D1            ; Invert all bits in D1</code></pre><p>And now, here is what PowerPC assembly code looked like:</p><pre><code>lwz     r3, 0x1000    ; Load word from address 0x1000 into register r3
lwz     r4, 0x1004    ; Load word from address 0x1004 into register r4
add     r5, r3, r4    ; Add the values in r3 and r4, result stored in r5
lwz     r3, 0x1000    ; Load word from address 0x1000 into register r3
not     r4, r3        ; Invert all bits in r3 and store the result in r4</code></pre><p><span>Since the machine instructions themselves are different, all the existing software in Apple’s ecosystem would need to be re-compiled, and in some cases re-written (such as when writing compiler software, or when code makes </span><a href="https://www.reddit.com/r/AskComputerScience/comments/1tg6dw/when_apple_made_the_switch_from_powerpc_to_intel/" rel="">assumptions about endian-ness</a><span>), in order to work on PowerPC machines.</span></p><p>Apple needed a plan.</p><p>Apple developed two strategies to manage this transition:</p><p><span>A </span><strong>Emulator</strong><span> was developed where PowerPC could </span><a href="https://computerhistory.org/blog/transplanting-the-macs-central-processor-gary-davidian-and-his-68000-emulator/" rel="">emulate the Motorola CPU</a><span>. This translates instructions from one instruction set architecture to another in real-time.</span></p><p>This, unsurprisingly, incurs a huge performance cost. Fortunately, since the PowerPC CPUs were so powerful, emulation wasn’t usually a massive issue for consumers who were upgrading their hardware.</p><p><span>Another strategy which Apple employed was to use “</span><strong>fat binaries</strong><span>” for software during the transition period. This allowed software to contain code compiled for both 68k and PowerPC architectures. Therefore, engineers could ship a single app which worked on both Mac CPU platforms by containing two separate binaries.</span></p><p><span>In the era when 80MB was a </span><em>decent</em><span> hard drive, this was pretty annoying, so </span><a href="https://apple.fandom.com/wiki/Fat_binary" rel="">a cottage industry</a><span> of binary stripping tools spawned so end-users only needed to save the one that worked on their device.</span></p><p>Overall, Apple’s migration was a success. Moving from 68k to PowerPC lent a massive performance boost. Emulation and fat binaries allowed the software ecosystem to transition without a major hitch.</p><p><span>Unfortunately, the </span><em>Wintel</em><span> alliance was barely touched. Their market dominance grew to unprecedented levels with the release of Pentium and Windows 95. Windows grew into </span><em>the</em><span> default computing platform, tragically transforming school ICT curriculums the world over into “how to use Microsoft Office”.</span></p><p><span>Now that they had a solid hardware platform, Apple’s antiquated System 7 Mac OS became the primary headwind. </span><a href="https://www.quora.com/Why-did-Apple-buy-NeXT-Computer" rel="">Internal projects to create a modern competitor to Windows had failed</a><span>, which meant an acquisition was the only way out of a tailspin — simply buying a new OS.</span></p><p>This laid the groundwork for Apple’s purchase of NeXT and the return of Steve Jobs.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0ac0a9dd-fd43-42c8-97d4-1cbc51128deb_500x419.jpeg" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0ac0a9dd-fd43-42c8-97d4-1cbc51128deb_500x419.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0ac0a9dd-fd43-42c8-97d4-1cbc51128deb_500x419.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0ac0a9dd-fd43-42c8-97d4-1cbc51128deb_500x419.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0ac0a9dd-fd43-42c8-97d4-1cbc51128deb_500x419.jpeg 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0ac0a9dd-fd43-42c8-97d4-1cbc51128deb_500x419.jpeg" width="500" height="419" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/0ac0a9dd-fd43-42c8-97d4-1cbc51128deb_500x419.jpeg&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:419,&#34;width&#34;:500,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:null,&#34;alt&#34;:&#34;&#34;,&#34;title&#34;:null,&#34;type&#34;:null,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="" title="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0ac0a9dd-fd43-42c8-97d4-1cbc51128deb_500x419.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0ac0a9dd-fd43-42c8-97d4-1cbc51128deb_500x419.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0ac0a9dd-fd43-42c8-97d4-1cbc51128deb_500x419.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0ac0a9dd-fd43-42c8-97d4-1cbc51128deb_500x419.jpeg 1456w" sizes="100vw" loading="lazy"/></picture></div></a><figcaption><span>Intel Pentium 4 600 Series die (the large block to the left is its hefty 2MB L2 cache) — from </span><a href="https://www.anandtech.com/show/1621/3" rel="">AnandTech</a></figcaption></figure></div><p>By the early 2000s, Apple had its mojo back.</p><p><span>Jobs is CEO. An era-defining software transition to Mac OS X had been a success. The iPod has turned a struggling computer company with single-digit market share into a </span><a href="https://www.cnet.com/tech/mobile/features/inventing-the-ipod-how-really-big-risks-paid-off-for-apple/" rel="">consumer electronics powerhouse</a><span>.</span></p><p><span>Desktops dominated the 80s, the 90s, and the turn of the millennium. But as </span><a href="https://www.intel.com/content/www/us/en/history/virtual-vault/articles/moores-law.html" rel="">Moore’s Law</a><span> marches inexorably onwards, electronics are miniaturising and </span><a href="https://www.theguardian.com/technology/2009/oct/28/laptops-sales-desktop-computers" rel="">laptops are becoming big business</a><span>.</span></p><p>When your hardware isn’t connected to mains electricity, battery becomes a bottleneck. With performance-per-watt the foremost concern, one thing became clear in the early 2000s: PowerPC architecture was failing to keep pace behind the Intel x86 behemoth.</p><p><span>Intel had simply been out-executing, out-manufacturing, and out-R&amp;D-ing the competition. Their </span><a href="https://www.quora.com/Why-was-the-PowerPC-architecture-unable-to-keep-up-with-Intel-x86" rel="">vast installed base</a><span> of Windows hardware granted an unbeatable ecosystem of compatible software, and printed money to further invest in deepening the Intel processor technology moat.</span></p><p><span>The early-2000s PowerPC CPUs used far too much power and generated </span><a href="https://everymac.com/mac-answers/macintel-faq/why-did-apple-switch-to-intel.html" rel="">far too much heat</a><span> to create the ultra-thin </span><a href="https://www.cultofmac.com/522973/macbook-air-worlds-thinnest-notebook/" rel="">MacBook Air</a><span> that Jobs was envisioning. With more than 50% of their revenues already drawn from laptop computers, the decision was clear: to compete, Apple </span><em>had</em><span> to switch to Intel.</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fecc3b4c4-aea0-4495-919b-eaa9e4656f30_700x369.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fecc3b4c4-aea0-4495-919b-eaa9e4656f30_700x369.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fecc3b4c4-aea0-4495-919b-eaa9e4656f30_700x369.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fecc3b4c4-aea0-4495-919b-eaa9e4656f30_700x369.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fecc3b4c4-aea0-4495-919b-eaa9e4656f30_700x369.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fecc3b4c4-aea0-4495-919b-eaa9e4656f30_700x369.png" width="700" height="369" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/ecc3b4c4-aea0-4495-919b-eaa9e4656f30_700x369.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:369,&#34;width&#34;:700,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:null,&#34;alt&#34;:&#34;&#34;,&#34;title&#34;:null,&#34;type&#34;:null,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="" title="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fecc3b4c4-aea0-4495-919b-eaa9e4656f30_700x369.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fecc3b4c4-aea0-4495-919b-eaa9e4656f30_700x369.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fecc3b4c4-aea0-4495-919b-eaa9e4656f30_700x369.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fecc3b4c4-aea0-4495-919b-eaa9e4656f30_700x369.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a><figcaption><span>Steve Jobs announces the switch from PowerPC to Intel at </span><a href="https://www.youtube.com/watch?v=JcHQXMAd0c0" rel="">WWDC 2005</a></figcaption></figure></div><p>Jobs explained it best at Apple’s 2005 Worldwide Developer Conference:</p><blockquote><p><em>“I stood up here two years ago in front of you and I promised you a 3 GHz Mac, and we haven’t been able to deliver that to you yet.</em></p><p><em>… As we look ahead we can of envision some amazing products we want to build for you and we don’t know how to build them with the future PowerPC roadmap.”</em></p></blockquote><p><strong>But my favourite part of the video?</strong></p><blockquote><p><em>“So get on Xcode 2.1 and get your copy today. There will be a copy for everybody at the registration desk immediately following this keynote.”</em></p></blockquote><p><span>As someone who became a developer in the 2010s, picking up a CD at a conference for your latest Xcode update seems so </span><em>quaint</em><span>. I wonder if the 2005 Betas were as glitchy as we are used to today.</span></p><p>What really fascinates me, however, is this:</p><p><span>Intel x86 processors are descended from a family of instruction set architectures pioneered in 1978 with the Intel 8086. Future processors, such as 1982&#39;s Intel 80186 or 2000’s Pentium 4, maintained backwards compatibility with this original instruction set. You’re reading that right: a program compiled on 8086 in the 70s would run fine in the 2000s </span><em>without any modification</em><span>.</span></p><p>But software ecosystem is just part of the story.</p><p>By 2006, high-end Intel x86 processors were projected to produce almost 5x the performance per watt compared to PowerPC, and nearly 1.5x the clock speed.</p><p>Intel was innovating on all aspects of their CPUs, such as:</p><ul><li><p>CPU Caches (L1, L2, and L3)</p></li><li><p>Branch Prediction</p></li><li><p>Superscalar Architecture</p></li></ul><p>Let’s go over these in some detail, since they are really important concepts in modern CPU performance. No piece single-handedly made Intel’s x86 the winner — the interconnected nature of a CPU meant that optimisation across all these components (and more) kept x86 ahead of the pack.</p><p>As previously explained, a CPU takes data from memory (RAM), places it in ultra-fast registers on the processor chip, and performs operations on that data. But at gigahertz clock speeds (1,000,000,000 operations per second), fetching instructions and data from RAM is far too slow.</p><p>Therefore, CPUs evolved on-chip caches to store middling amounts of data. These act as intermediary miniature blocks of RAM, stored physically closer to the chip itself, and allow for faster access to the necessary data.</p><p>These caches are themselves tiered:</p><ul><li><p><span>The </span><strong>L1 Cache </strong><span>is the smallest, fastest tier — directly integrated with the CPU core to store a small amount of data (a few kB) for rapid retrieval. Since these are integrated so close to the processor circuitry itself, there is an L1 Cache for each CPU core.</span></p></li><li><p><span>The </span><strong>L2 Cache</strong><span> is the middle layer, balancing speed and capacity, usually integrated somewhere on the CPU chip itself (and like all middle siblings, usually left to the side). This cache could be partitioned for each CPU core, or shared between them all.</span></p></li><li><p><span>The </span><strong>L3 Cache</strong><span> is the final buffer before the dreaded cache miss forces the CPU to search for data in RAM — a pyrrhic round-trip across the motherboard and back. This tier of storage is a shared memory pool of many megabytes between all CPU cores.</span></p></li></ul><p>This diagram from Harvard’s CS course explains better than I ever could:</p><p><span>Whenever a CPU needs to fetch instructions or data that isn’t stored in the nearest cache, it’s known as a </span><em>cache miss</em><span>. It needs to fetch from the next tier of cache, or the next tier, or RAM, or disk! This can badly impact speed and efficiency.</span></p><p>As a macro-scale analogy, consider how slowly your app appears to load when your program has to look for data over the network, instead of from local storage. Round-trips on the nano-scale of a CPU can add up quickly.</p><p><span>By the mid-2000s, </span><a href="https://forums.macrumors.com/threads/analysis-x86-vs-ppc-this-article-is-concerned-with-the-tec.31775/" rel="">Intel’s x86 CPU caches dwarfed those on PowerPC</a><span>, meaning lower latency and better performance. When supplemented with improved pre-fetching and predictive algorithms, expensive cache misses became less of a problem on x86.</span></p><p>These in turn improved performance-per-watt because when data is next to the processor, less electricity is physically being moved through the CPU’s circuitry to move bytes of memory around.</p><p>Branch Prediction sounds like arcane, occult magick when you first hear about it.</p><p><span>Branch instructions are the assembly code versions of conditional statements such as </span><code>if</code><span>/</span><code>else</code><span> — manifesting on the processor as </span><a href="https://blog.cloudflare.com/branch-predictor/" rel="">jumps, calls, and returns</a><span>. Clever CPUs use statistics to guess where the code is going, and try to keep the instruction pipeline filled for maximum utilisation.</span></p><p><span>The mechanism for this involves hardware algorithms built directly into the circuits of the CPU. A buffer called the Branch History Table caches recent branch outcomes. </span><a href="https://www.geeksforgeeks.org/correlating-branch-prediction/" rel="">Patterns are analysed</a><span> to draw predictions.</span></p><p><span>Advanced branch predictors apply the ultimate YOLO method: speculative execution, where instructions on the predicted branch are executed </span><em>before the outcome is confirmed</em><span>.</span></p><p>Intel’s silicon crystal balls helped the x86 processor go far faster than non-psychic CPUs.</p><p><span>Superscalar architecture is the ultimate in multitasking. Superscalar CPUs can simultaneously </span><a href="https://www.elprocus.com/superscalar-processor" rel="">execute multiple instructions</a><span> during a single clock cycle:</span></p><ul><li><p><span>In the </span><strong>fetch</strong><span> phase, the CPU collects multiple instructions from the operation pipeline.</span></p></li><li><p><span>The </span><strong>decode</strong><span> phase utilises multiple decoder units to evaluate each instruction.</span></p></li><li><p><span>These instructions may be dispatched to different </span><strong>execution </strong><span>units of the CPU.</span></p></li></ul><p>This architecture works because operations such as arithmetic, moving memory between registers, and floating-point operations require different pieces of circuitry on the ALU. Therefore, if you’re clever, several instructions can be performed in parallel.</p><p><span>This is a tough process to get right. </span><a href="https://kb.iu.edu/d/aett" rel="">Bottlenecks can occur</a><span> if multiple simultaneous operations need to use the same resource such as the same register or the same ALU adder circuit. Dependency issues can also lead to stalls, especially if an instruction is stuck waiting on the result of another longer-running operation.</span></p><p>Intel had the will and, more importantly, the R&amp;D dollars, to get superscalar architecture working effectively on their CPU cores.</p><p>As well as caching, branch prediction, and superscalar architecture, Intel’s x86 chips further optimised many features of their CPUs:</p><ul><li><p><strong>Advanced pipelining</strong><span> that split the fetch, decode, execute cycle </span><a href="https://arstechnica.com/gadgets/2011/04/ask-ars-whats-the-relationship-between-cpu-clockspeed-and-performance/" rel="">into up to 21 stages</a><span> that allowed for far more instructions to run per second at a given clock speed.</span></p></li><li><p><span>Increased </span><a href="https://www.quora.com/To-what-degree-do-applications-for-x86-processors-utilize-multiple-cores-for-parallel-execution" rel="">numbers of </a><strong><a href="https://www.quora.com/To-what-degree-do-applications-for-x86-processors-utilize-multiple-cores-for-parallel-execution" rel="">execution units</a><span> </span></strong><span>in the ALUs to allow for easier parallelisation of operations from superscalar architecture.</span></p></li><li><p><strong>Hyper-threading</strong><span> which allowed a single CPU core to present to the OS as 2 logical cores, enabling one core to </span><a href="https://www.androidauthority.com/intel-hyper-threading-explained-1226271/" rel="">execute 2 threads simultaneously</a><span>.</span></p></li></ul><p>Apple again employed their time-honoured transition techniques for a smooth CPU architecture migration.</p><p>Apple introduced universal binaries built for both CPU architectures, which could be set up with a simple Xcode build configuration.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F93a73a6c-9564-4efe-b6a9-1575811df41f_700x370.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F93a73a6c-9564-4efe-b6a9-1575811df41f_700x370.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F93a73a6c-9564-4efe-b6a9-1575811df41f_700x370.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F93a73a6c-9564-4efe-b6a9-1575811df41f_700x370.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F93a73a6c-9564-4efe-b6a9-1575811df41f_700x370.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F93a73a6c-9564-4efe-b6a9-1575811df41f_700x370.png" width="700" height="370" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/93a73a6c-9564-4efe-b6a9-1575811df41f_700x370.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:370,&#34;width&#34;:700,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:null,&#34;alt&#34;:&#34;&#34;,&#34;title&#34;:null,&#34;type&#34;:null,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="" title="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F93a73a6c-9564-4efe-b6a9-1575811df41f_700x370.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F93a73a6c-9564-4efe-b6a9-1575811df41f_700x370.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F93a73a6c-9564-4efe-b6a9-1575811df41f_700x370.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F93a73a6c-9564-4efe-b6a9-1575811df41f_700x370.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a><figcaption><span>Steve Jobs explains how to build a Universal Binary in Xcode at </span><a href="https://www.youtube.com/watch?v=JcHQXMAd0c0" rel="">WWDC 2005</a></figcaption></figure></div><p><span>Apple also introduced Rosetta, a </span><a href="https://www.wikiwand.com/en/Rosetta_(software)" rel="">dynamic binary translator</a><span> which Apple described as “the most amazing software you’ll never see”. It was embedded in Mac OS X Tiger, the first OS released on x86 Macs, and allowed PowerPC apps to run on x86 </span><em>automagically</em><span>.</span></p><p><span>Apple goes very far out of their way to explain that </span><a href="https://web.archive.org/web/20101116094453/http://www.apple.com/asia/rosetta/" rel="">Rosetta is not an emulator </a><span>— Rosetta dynamically translates code ‘on the fly’ as your program runs. In practice, what this meant was that PowerPC CPU instructions and OS system calls from the application binary were translated into equivalent x86 assembly and syscalls.</span></p><p><span>Apple under-promised with a years-long transition timeline and over-delivered way ahead of schedule, </span><a href="https://www.apple.com/uk/newsroom/2008/01/15Apple-Introduces-MacBook-Air-The-Worlds-Thinnest-Notebook/" rel="">fulfilling Jobs’ dreams of tiny form factors </a><span>and bringing Apple into the modern age.</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50724fa6-477e-445f-8c3b-a351b9149e52_678x646.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50724fa6-477e-445f-8c3b-a351b9149e52_678x646.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50724fa6-477e-445f-8c3b-a351b9149e52_678x646.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50724fa6-477e-445f-8c3b-a351b9149e52_678x646.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50724fa6-477e-445f-8c3b-a351b9149e52_678x646.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50724fa6-477e-445f-8c3b-a351b9149e52_678x646.png" width="678" height="646" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/50724fa6-477e-445f-8c3b-a351b9149e52_678x646.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:646,&#34;width&#34;:678,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:null,&#34;alt&#34;:&#34;&#34;,&#34;title&#34;:null,&#34;type&#34;:null,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="" title="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50724fa6-477e-445f-8c3b-a351b9149e52_678x646.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50724fa6-477e-445f-8c3b-a351b9149e52_678x646.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50724fa6-477e-445f-8c3b-a351b9149e52_678x646.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50724fa6-477e-445f-8c3b-a351b9149e52_678x646.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a><figcaption><span>Annotated diagram of the 2020 Mac Mini M1 CPU die, from </span><a href="https://www.anandtech.com/show/16252/mac-mini-apple-m1-tested" rel="">AnandTech</a></figcaption></figure></div><p><span>Anyone who’s read </span><a href="https://www.waterstones.com/book/steve-jobs/walter-isaacson/9780349140438" rel="">Walter Isaacson’s</a><span> book on Jobs will know Apple’s ethos, and their ultimate competitive advantage: the tight integration of hardware and software to produce </span><em>insanely great</em><span> products.</span></p><p><span>Reliance on Intel for x86 CPUs meant a sometimes painful dependency on Intel’s </span><a href="https://wccftech.com/apple-macbook-air-delay-intel/" rel="">supply constraints</a><span> and </span><a href="https://www.cnbc.com/2020/07/24/intel-chip-delay-shows-exactly-why-apple-is-right-to-move-to-arm.html" rel="">release delays</a><span> which sometimes impacted Apple’s roadmap.</span></p><p><span>For decades, the CPU had been </span><em>the one that got away</em><span>. From the off-the-shelf </span><a href="https://www.apple1registry.com/en/theapple1.html" rel="">MOS 6502</a><span> microprocessor of the Apple I to the high-end </span><a href="https://support.apple.com/kb/SP797?locale=en_GB" rel="">Intel Xeon</a><span> CPU of the 2019 Mac Pro, Apple never truly owned this part of the value chain.</span></p><p>But now, they could.</p><p>The O.G. 2G iPhone released in 2007 with an ARM CPU supplied by Samsung. At the turn of the decade, however, from the iPhone 4, Apple began to design its own chips, starting with the A4.</p><p>Apple iterated. And then continued to iterate.</p><p>2020.</p><p>The iPhone is the god of all cash cows.</p><p><span>Apple, now the most valuable publicly-traded company on the planet, is plowing $20,000,000,000 of cash flow into R&amp;D </span><a href="https://www.macrotrends.net/stocks/charts/AAPL/apple/research-development-expenses" rel="">like it’s nothing</a><span>.</span></p><p><em>Wait a moment</em><span> — before we get to the present day, we need to go back in history a bit. This might get bumpy.</span></p><p><span>In 2008, Apple purchased </span><a href="https://www.computerworld.com/article/2536788/apple-to-buy-processor-designer-p-a--semi--says-report.html" rel="">P.A. Semiconductor</a><span> for $278m, a CPU design company known for high-end low-power processors. P.A.’s CPUs were originally based on IBM’s Power architecture — the very same instruction set used by the AIM alliance in the PowerPC Macs.</span></p><p>At the time, Android OS was entering the smartphone market. Owning its own chip designs would allow the iPhone to differentiate further from competitors in the newly crowded market. The acquisition also allowed Apple, famous for its obsessive degree of secrecy, to keep its best proprietary chip designs hush-hush in-house.</p><p><span>This acquisition was supplemented a decade later, in 2018, with a partial </span><a href="https://www.theverge.com/2018/10/11/17963112/apple-dialog-chipmaker-power-management-acquihire-acquisition" rel="">acqui-hire of Dialog</a><span>, a European chip designer, for $300m.</span></p><p><em>Alright, can we talk about M1 now?</em></p><p><span>No. First, we must go back </span><em>even</em><span> further.</span></p><p><span>ARM’s RISC instruction set and chip designs are dominant today. ARM was in fact </span><a href="https://www.google.com/search?q=arm+fgounded+by+apple&amp;oq=arm+fgounded+by+apple&amp;aqs=chrome..69i57j46i131i199i433i465i512l2j0i131i433i512j46i131i199i433i465i512l2j0i433i512l2j46i131i199i433i465i512.1998j0j4&amp;sourceid=chrome&amp;ie=UTF-8" rel="">founded in 1990</a><span> as a joint venture between Apple and Acorn Computers. Legend has it — and by legend I mean </span><a href="https://www.quora.com/Why-is-Apples-M1-chip-so-fast-yet-power-consumption-so-much-lower-compared-to-mainstream-technology-from-chip-leaders-Intel-AMD-Whats-special-about-its-design-architecture-that-made-it-so-amazing" rel="">this unsourced claim on Quora</a><span> — that Steve Jobs convinced Acorn to abandon their hardware products and focus on low-power processor design.</span></p><p><span>I </span><em>want to</em><span> believe it, because it’s just perfectly emblematic of the long-term thinking that made Apple what it is today.</span></p><p>Anyway. You follow? Grand. Back to 2020.</p><p>Apple Engineers had been designing and iterating upon the ARM chips in the iPhone and iPad for years.</p><p>Due to the mobile form factor — it’s tough to fit cooling fans in your pocket — power consumption and heat efficiency are the big concerns. RISC architecture is the clear answer to this, supplanting the x86 giant in mobile use cases.</p><p><span>And by 2020, these ARM CPUs had been improving </span><em>fast</em><span>.</span></p><p><em>Way faster</em><span> than Intel’s x86 chips.</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7691df53-c1de-44c1-bb4b-688ddd1ad63a_678x732.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7691df53-c1de-44c1-bb4b-688ddd1ad63a_678x732.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7691df53-c1de-44c1-bb4b-688ddd1ad63a_678x732.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7691df53-c1de-44c1-bb4b-688ddd1ad63a_678x732.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7691df53-c1de-44c1-bb4b-688ddd1ad63a_678x732.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7691df53-c1de-44c1-bb4b-688ddd1ad63a_678x732.png" width="678" height="732" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/7691df53-c1de-44c1-bb4b-688ddd1ad63a_678x732.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:732,&#34;width&#34;:678,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:null,&#34;alt&#34;:&#34;&#34;,&#34;title&#34;:null,&#34;type&#34;:null,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="" title="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7691df53-c1de-44c1-bb4b-688ddd1ad63a_678x732.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7691df53-c1de-44c1-bb4b-688ddd1ad63a_678x732.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7691df53-c1de-44c1-bb4b-688ddd1ad63a_678x732.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7691df53-c1de-44c1-bb4b-688ddd1ad63a_678x732.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a><figcaption><span>The quintessential disruption graph, from </span><a href="https://www.anandtech.com/show/16226/apple-silicon-m1-a14-deep-dive/4" rel="">AnandTech</a></figcaption></figure></div><p><span>Apple’s custom ARM CPUs had improved to the point where </span><a href="https://www.anandtech.com/show/16226/apple-silicon-m1-a14-deep-dive/4" rel="">there was no question about it</a><span>—they was powerful enough to use </span><a href="https://www.macrumors.com/guide/apple-silicon/" rel="">in Apple laptops</a><span>.</span></p><p>In 2020, Apple announced its third great Mac CPU architecture transition with the M1 — heralding the age of Apple Silicon.</p><p><span>The M1 was the first iteration of the “M family” of </span><em>Apple Silicon</em><span> chips, their custom hardware for Mac laptops and desktops. It has siblings such as the M1 Pro, the M1 Max, and the M1 Ultra. Today, you can even buy M2 chips in the latest hardware (but I’m holding out for M3 before I start petitioning my CTO).</span></p><p><span>The M1 is a </span><a href="https://www.production-expert.com/production-expert-1/why-are-the-apple-m1-m1-pro-and-m1-max-chips-so-fast" rel="">system-on-a-chip</a><span> (SoC). This is an approach to building hardware that differs from standard desktop PCs. Instead of mounting interchangeable components on a motherboard (such as CPU, storage, RAM, graphics card), SoCs integrate everything into a single component, which is why the approach lent itself naturally to space-constrained mobile devices.</span></p><p>Upgrading to an M1 MacBook for the first time is like magic. A real game-changer. Everything is lightning-fast, the cooling fan never seems to switch on, and the battery lasts all day on a single charge.</p><p><span>How is the M1 so powerful, when using</span><em> so little power?</em></p><p>As mentioned in the Intel section, the interconnected nature of a CPU usually makes it tough to evaluate outperformance between chip architectures.</p><p>Intel’s primary performance driver has been to shrink transistors and fit more, faster, CPU cores onto the chip. More, faster, CPU cores leads naturally to higher performance.</p><p><span>But in the case of the M1, there is a completely different approach which leads to its outperformance: </span><strong>Specialisation</strong><span>.</span></p><p><span>The M1 chips apply a </span><a href="https://debugger.medium.com/why-is-apples-m1-chip-so-fast-3262b158cba2" rel="">heterogeneous computing strategy</a><span>. This means specialised components for specific workloads. PC gamers are already familiar with this. For decades, Nvidia has been selling graphics cards — GPUs — to handle the specialised parallel workloads you encounter with videogame rendering engines.</span></p><p>Apple takes this approach to the next level with a radical shift in the direction of heterogeneous workloads. The components of the M1 SoC are specialised for many computing tasks:</p><ul><li><p>Image processing circuitry</p></li><li><p>Mathematical signal processors</p></li><li><p>AI-accelerating neural engines</p></li><li><p>Dedicated video encoder and decoders</p></li><li><p>A secure enclave for encrypted storage</p></li><li><p>8 GPU cores with 128 parallel execution units</p></li><li><p><span>4 high-performance </span><em><a href="https://www.anandtech.com/show/16252/mac-mini-apple-m1-tested" rel="">Firestorm</a></em><a href="https://www.anandtech.com/show/16252/mac-mini-apple-m1-tested" rel=""> CPU cores</a></p></li><li><p><span>4 efficient, low-energy </span><em>Icestorm</em><span> CPU cores</span></p></li></ul><p><span>This approach to utilising twin sets of CPUs was coined by ARM as </span><a href="https://www.arm.com/technologies/big-little" rel="">big.LITTLE architecture</a><span>, which optimises power consumption for those general CPU workloads not dispatched to specialist components.</span></p><p><span>The Firestorm CPUs relentlessly execute time-sensitive workloads requested by the user; while the Icestorm CPUs handle background workloads more slowly while consuming </span><a href="https://www.imore.com/mac-apple-silicon-transition-everything-you-need-know" rel="">90% less power</a><span>.</span></p><p>As well as the core heterogeneous architecture of the Apple Silicon SoC, there are some further supplementary reasons for the astonishing M1 performance:</p><ul><li><p>Unified Memory Architecture</p></li><li><p>Out-of-order Execution</p></li><li><p>Physics: The Ultimate Constraint</p></li></ul><p><span>The M1 chips have a </span><strong><a href="https://debugger.medium.com/why-is-apples-m1-chip-so-fast-3262b158cba2" rel="">unified memory architecture</a></strong><span> shared between GPU and CPUs. This is a masterstroke for performance. When sending data to an external GPU for processing, a CPU usually needs to copy data into the memory owned by the GPU, before it could be picked up for processing.</span></p><blockquote><p><em><span>This is the problem </span><strong>Metal</strong><span> was introduced to solve — intermediary translation of a graphics driver utilises the CPU, which introduces a serious performance bottleneck when you really want graphics instructions to go to the GPU.</span></em></p><p><em><span>Interested? Read more in my previous entry in this series, </span><a href="https://medium.com/better-programming/through-the-ages-apple-animation-apis-2ab5925f546b#f4ef" rel="">Through the Ages: Apple Animation APIs</a><span>.</span></em></p></blockquote><p>Why don’t all processors have integrated graphics?</p><p>In order to get this right, Apple had to solve two major problems that arise when integrating CPU and GPU onto a SoC:</p><ul><li><p>CPUs and GPUs like their data formatted differently. CPUs love to nibble small bytes little and often, GPUs like to guzzle massive blobs of data, infrequently, for massively parallel processing.</p></li><li><p>GPUs make heat. A lot of heat. This is why graphics cards have integrated cooling fans for that “jumbo jet” aesthetic.</p></li></ul><p>Apple’s approach allocates the same blocks of memory — both RAM and L3 cache — shared between both processors, in a format that can supply big chunks that the GPU likes at the high throughput that the CPU requires. Their ARM chips are low-energy enough to integrate on the same die without melting a hole through your lap(top).</p><p>While the heterogeneous architecture allows specialised workloads to go to the best tool for the job, the Firestorm CPU cores themselves are extremely powerful for general workloads.</p><p><span>We previously discussed superscalar architecture that enabled CPU cores to simultaneously fetch, decode, and dispatch multiple instructions at once. The M1 chips, by virtue of their RISC architecture, allow Apple to take this to the next level with </span><a href="https://debugger.medium.com/why-is-apples-m1-chip-so-fast-3262b158cba2#8ac1" rel="">out-of-order execution</a><span>.</span></p><p>ARM RISC instructions are all 4 bytes long (32 bits), while x86 CISC instructions vary from 1–15 bytes. This means ARM chips can easily split up a continuous stream of instruction bytes straight to decoders without any analysis overhead.</p><p><span>The basic M1 chip has an insane </span><strong>8 decoders</strong><span>, which the Firestorm CPU cores fill simultaneously each clock cycle. These instructions are dispatched in parallel to its various specialised pieces of circuitry.</span></p><p><span>Apple Silicon analyses a dependency graph between hundreds of instructions at once, so it knows what can be dispatched now and what needs to wait on results. Pair this with its </span><a href="https://drive.google.com/file/d/1WrMYCZMnhsGP4o3H33ioAUKL_bjuJSPt/view" rel="">advanced branch prediction</a><span>, and the M1 CPU is essentially </span><a href="https://mistborn.fandom.com/wiki/Atium" rel="">burning Atium</a><span>.</span></p><p>There is one final reason this SoC is so fast and so power-efficient. It’s the same concept we looked at when learning about CPU caches.</p><p><span>Simply put, everything on the M1 chip is physically so close together. Even with electrical signals moving literally at lightning speed, operations are simply </span><em>faster</em><span> when there is less distance to travel.</span></p><p>At GHz clock speeds, those nanoseconds add up.</p><p>For the M1 Ultra chips, designed to give the maximum output, Apple took a more blunt instrument out of its tool-belt. Instead of an extreme ultraviolet lithography machine, Tim Cook took out a sledgehammer.</p><p><span>The M1 Ultra chip is </span><a href="https://www.wired.com/story/apple-m1-ultra-chip-moores-law/" rel="">simply two M1 Max chips stuck together</a><span>.</span></p><p>It’s perhaps a little more subtle than that — the bridging structure enables a pretty inter-chip throughput of 2.5TB/s, which allows the components to behave exactly as if they’re the same chip.</p><p>Apple continued to apply its battle-tested approach for the transition from Intel x86 to Apple Silicon.</p><p>Developers can build universal apps which contain both Intel and Apple Silicon binaries. Additionally, Rosetta has been upgraded to Rosetta II to invisibly interpret Intel instructions into ARM on-the-fly.</p><p><span>Grandiose as always, Apple claims that some </span><a href="https://www.imore.com/mac-apple-silicon-transition-everything-you-need-know" rel="">Intel apps and games will perform better</a><span> on ARM using Rosetta II than they did on their original.</span></p><p><span>It was a painful blow to Intel for one of their biggest customers to break off their longstanding partnership. Intel is somewhat </span><a href="https://9to5mac.com/2021/10/18/intels-apple-silicon-take/" rel="">in denial of reality</a><span> and is pretty sure they can catch up by investing further in their own.</span></p><p>Between Apple Silicon and the dominance of Nvidia for AI use cases, one thing is clear: Intel has been too complacent for too long.</p><blockquote><p><em>“Success breeds complacency, complacency breeds failure, only the paranoid survive”</em></p><p>- Andy Grove, Intel Co-Founder</p></blockquote><p>Originally, this was meant to be a brief history of Apple’s famous CPU architecture migrations, however as usual my curiosity kind of got away from me. I was frustrated with the surface-level depth of most of my information sources.</p><ul><li><p><span>I had to know </span><em>why</em><span> the Macintosh team picked Motorola 68k over the available options.</span></p></li><li><p><span>I had to know what made a migration to a new CPU architecture like PowerPC so </span><em>difficult</em><span>.</span></p></li><li><p><span>I had to know what actually caused Intel’s x86 architecture to be </span><em>so far ahead</em><span> of its competition.</span></p></li><li><p><span>I had to know </span><em>how on Earth</em><span> the M1 chips were so damn efficient.</span></p></li></ul><p>I reckon I did a pretty good job.</p><p>I hope you learned a little, and most importantly, had some fun on the way.</p><p>Have you used any of these architectures before? Perhaps you’ve written assembly for them, used the CPU as a component in a custom build PC, or perhaps even just been amazed at your new M1 Mac? Share your story in the comments!</p><p><span>If you liked this piece, check out my other entry in my </span><em>Through The Ages</em><span> series: </span><a href="https://jacobbartlett.substack.com/p/apple-animation-through-the-ages" rel="">Through the Ages: Apple Animation APIs</a><span>.</span></p><div data-attrs="{&#34;url&#34;:&#34;https://jacobbartlett.substack.com/p/through-the-ages-apple-cpu-architecture?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&#34;,&#34;text&#34;:&#34;Share&#34;}" data-component-name="CaptionedButtonToDOM"><p>If you really enjoyed this post, please share to help me grow my Substack audience. </p><p data-attrs="{&#34;url&#34;:&#34;https://jacobbartlett.substack.com/p/through-the-ages-apple-cpu-architecture?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&#34;,&#34;text&#34;:&#34;Share&#34;}" data-component-name="ButtonCreateButton"><a href="https://jacobbartlett.substack.com/p/through-the-ages-apple-cpu-architecture?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share" rel=""><span>Share</span></a></p></div></div></div></div></div>
  </body>
</html>
