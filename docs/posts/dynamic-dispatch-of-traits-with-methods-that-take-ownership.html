<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://samuelselleck.com/blog/dynamic-dispatch-of-traits-with-methods-that-take-ownership/">Original</a>
    <h1>Dynamic Dispatch of Traits with Methods that take Ownership</h1>
    
    <div id="readability-page-1" class="page"><div><p>Bumped into this the other day! Suppose you have a trait method that takes ownership of self in a case something like this:</p><pre data-lang="rust"><code data-lang="rust"><span>trait </span><span>Enchantment </span><span>{
</span><span>    </span><span>fn </span><span>enchant</span><span>(</span><span>self</span><span>, </span><span>character</span><span>: </span><span>&amp;mut</span><span> Character);
</span><span>}
</span><span>
</span><span>struct </span><span>Frogify;
</span><span>
</span><span>impl </span><span>Enchantment </span><span>for </span><span>Frogify </span><span>{
</span><span>    </span><span>fn </span><span>enchant</span><span>(</span><span>self</span><span>, </span><span>character</span><span>: </span><span>&amp;mut</span><span> Character) </span><span>{
</span><span>        character</span><span>.</span><span>strength </span><span>= </span><span>1</span><span>;
</span><span>    </span><span>}
</span><span>}
</span><span>
</span><span>struct </span><span>Character </span><span>{
</span><span>    </span><span>strength</span><span>: </span><span>u32
</span><span>}
</span><span>
</span><span>fn </span><span>main</span><span>() </span><span>{
</span><span>    </span><span>let </span><span>mut</span><span> prince </span><span>=</span><span> Character </span><span>{</span><span> strength: </span><span>10 </span><span>}</span><span>;
</span><span>    </span><span>let</span><span> enchantment </span><span>=</span><span> Frogify </span><span>{}</span><span>;
</span><span>    enchantment</span><span>.</span><span>enchant</span><span>(</span><span>&amp;mut</span><span> prince);
</span><span>    println!(</span><span>&#34;prince has strength </span><span>{}</span><span>&#34;</span><span>, prince</span><span>.</span><span>strength);
</span><span>}
</span></code></pre><p>everything here works fine! But now suppose you make a function that returns a random enchantment:</p><pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>random_enchantment</span><span>() </span><span>-&gt; </span><span>Box</span><span>&lt;dyn Enchantment&gt; </span><span>{
</span><span>    </span><span>// not very random, but could be!
</span><span>    </span><span>Box</span><span>::</span><span>new(Frogify </span><span>{}</span><span>)
</span><span>}
</span></code></pre><p>and decide to try to enchant the prince with a random enchantment:</p><pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>main</span><span>() </span><span>{
</span><span>    </span><span>let </span><span>mut</span><span> prince </span><span>=</span><span> Character </span><span>{</span><span> strength: </span><span>10 </span><span>}</span><span>;
</span><span>    </span><span>let</span><span> enchantment </span><span>= </span><span>random_enchantment</span><span>();
</span><span>    enchantment</span><span>.</span><span>enchant</span><span>(</span><span>&amp;mut</span><span> prince);
</span><span>    println!(</span><span>&#34;prince has strength </span><span>{}</span><span>&#34;</span><span>, prince</span><span>.</span><span>strength);
</span><span>}
</span></code></pre><p>you’ll get this error:</p><pre><code><span>error[E0161]: cannot move a value of type `dyn Enchantment`
</span><span>  --&gt; src/main.rs:24:5
</span><span>   |
</span><span>24 |     enchantment.enchant(&amp;mut prince);
</span><span>   |     ^^^^^^^^^^^ the size of `dyn Enchantment` cannot be statically determined
</span></code></pre><p>To call the function enchant, rust tries to dereference the boxed enchantment value but can’t do so because of it having an unknown size! One option is to just not consume the enchantment on use, but that might be a nice feature if the operation is expensive, or semantically describes what is being done in a nice way (enchantments might be one use only). So then, How can we represent an owned value of a dynamically dispatched object, that has a fixed size? With a box! Let’s rewrite the example:</p><pre data-lang="rust"><code data-lang="rust"><span>trait </span><span>Enchantment </span><span>{
</span><span>    </span><span>fn </span><span>enchant</span><span>(</span><span>self</span><span>: </span><span>Box</span><span>&lt;</span><span>Self</span><span>&gt;, </span><span>character</span><span>: </span><span>&amp;mut</span><span> Character);
</span><span>}
</span><span>
</span><span>struct </span><span>Frogify;
</span><span>
</span><span>impl </span><span>Enchantment </span><span>for </span><span>Frogify </span><span>{
</span><span>    </span><span>fn </span><span>enchant</span><span>(</span><span>self</span><span>: </span><span>Box</span><span>&lt;</span><span>Self</span><span>&gt;, </span><span>character</span><span>: </span><span>&amp;mut</span><span> Character) </span><span>{
</span><span>        character</span><span>.</span><span>strength </span><span>= </span><span>1</span><span>;
</span><span>    </span><span>}
</span><span>}
</span><span>
</span><span>struct </span><span>Character </span><span>{
</span><span>    </span><span>strength</span><span>: </span><span>u32</span><span>,
</span><span>}
</span><span>
</span><span>fn </span><span>random_enchantment</span><span>() </span><span>-&gt; </span><span>Box</span><span>&lt;dyn Enchantment&gt; </span><span>{
</span><span>    </span><span>// not very random, but could be!
</span><span>    </span><span>Box</span><span>::</span><span>new(Frogify </span><span>{}</span><span>)
</span><span>}
</span><span>
</span><span>fn </span><span>main</span><span>() </span><span>{
</span><span>    </span><span>let </span><span>mut</span><span> prince </span><span>=</span><span> Character </span><span>{</span><span> strength: </span><span>10 </span><span>}</span><span>;
</span><span>    </span><span>let</span><span> enchantment </span><span>= </span><span>random_enchantment</span><span>();
</span><span>    enchantment</span><span>.</span><span>enchant</span><span>(</span><span>&amp;mut</span><span> prince);
</span><span>    println!(</span><span>&#34;prince has strength </span><span>{}</span><span>&#34;</span><span>, prince</span><span>.</span><span>strength);
</span><span>}
</span></code></pre><p>Note that this requires us to <em>always</em> box Enchantments before calling the enchant method, but that was worth it in my case!</p><p>Hope it helps in some way! &lt;3</p></div></div>
  </body>
</html>
