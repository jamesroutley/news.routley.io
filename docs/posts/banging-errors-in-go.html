<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://flak.tedunangst.com/post/bango">Original</a>
    <h1>Banging errors in Go</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>One of the many problems with programming in go is there’s functions, and the functions are written by people, and the people make mistakes, and the functions return errors, and now you have to check for the errors. This is all very tedious and tiresome. We can’t fix the people who cherish their imperfections as a sign of humanity, but we can change go to pretend the errors aren’t there.</p><p>A short experiment to write a tool to bang away the errors. Mostly to poke around and manipulate the AST some more.<br/></p><h3>error time</h3><p>We’ve got a simple function, but it’s more than half errors. Why would anyone write such problematic code?</p><pre><code><span>func</span> decomp<span>(</span>filename <span>string</span><span>)</span> <span>(</span>[]<span>byte</span><span>,</span> error<span>)</span> <span>{</span>
        fd<span>,</span> err <span>:=</span> os<span>.</span>Open<span>(</span>filename<span>)</span>
        <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
                <span>return</span> <span>nil</span><span>,</span> err
        <span>}</span>
        <span>defer</span> fd<span>.</span>Close<span>(</span><span>)</span>
        zd<span>,</span> err <span>:=</span> gzip<span>.</span>NewReader<span>(</span>fd<span>)</span>
        <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
                <span>return</span> <span>nil</span><span>,</span> err
        <span>}</span>
        data<span>,</span> err <span>:=</span> io<span>.</span>ReadAll<span>(</span>zd<span>)</span>
        <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
                <span>return</span> <span>nil</span><span>,</span> err
        <span>}</span>
        <span>return</span> data<span>,</span> <span>nil</span>
<span>}</span></code></pre><p>What does this function even do if there’s an error? I have to read so much code to find out. Wouldn’t it be cleaner if we could write lines like this?</p><pre><code>        data <span>:=</span> io<span>.</span>ReadAll<span>(</span>zd<span>)</span><span>!</span></code></pre><p>Now it’s obvious to everyone exactly what happens. All we need is a little tool to parse this code, rewrite it to add the err checks, and then send it to the real go compiler.<br/></p><h3>banging</h3><p>Except that’s not valid go syntax and won’t parse, and we’re not changing the parser for a fun toy. But this will.</p><pre><code>        data <span>:=</span> <span>!</span>io<span>.</span>ReadAll<span>(</span>zd<span>)</span></code></pre><p>I actually prefer this. When reading code, I tend to focus on the left side, around the assignment. That feels like the important part, and then I stop scanning before I get all the way to the end.</p><p>The catch is that if we use this particular operator, we won’t be able to call a boolean function and reverse it and assign it. I never seem to do this? I call !fn() in conditionals, and I assign boolean functions to variables, but not both at the same time. Nevertheless, we can avoid the conflict by selecting another operator.</p><pre><code>        data := ^io.ReadAll(zd)</code></pre><p>I quite like this. I know that I’ve <i>never</i> xored a function return in an assignment, although maybe there’s some field where that’s really common.</p><p>The caret also reminds me of a footnote, which seems appropriate. There’s a little extra happening here, but it’s not really important, no need to bore you with the details.</p><p>The final function looks like this.</p><pre><code><span>func</span> decomp<span>(</span>filename <span>string</span><span>)</span> <span>(</span>[]<span>byte</span><span>,</span> error<span>)</span> <span>{</span>
        fd <span>:=</span> ^os<span>.</span>Open<span>(</span>filename<span>)</span>
        <span>defer</span> fd<span>.</span>Close<span>(</span><span>)</span>
        zd <span>:=</span> ^gzip<span>.</span>NewReader<span>(</span>fd<span>)</span>
        data <span>:=</span> ^io<span>.</span>ReadAll<span>(</span>zd<span>)</span>
        <span>return</span> data<span>,</span> <span>nil</span>
<span>}</span></code></pre><p>All neat and tidy.<br/></p><h3>bango</h3><p>The internal operation of bango is straightforward. Scan through the AST looking for statements, then check that left and right sides have one expression, then check that right side is a unary xor operator applied to a call expression. Then we conjure up an if statement with an error check and return statement, and insert that into the block after the assignment.</p><p>The reverse operation is similar. Look for error checking statements after function calls, then remove them and add an xor to the function. Everything is so easy now that there’s functions to insert and remove from a slice.</p><p>Now that I have a little better understanding of the go AST structures, it was mostly just a matter of typing out what I wanted, then iterating until I was happy with the results.<br/></p><h3>matching</h3><p>Straightforward, but still tedious. The <a href="https://humungus.tedunangst.com/r/fungo/v/2/f/bango/main.go">old code</a> was not pretty.</p><details><summary>you may not like it, but this is ideal error checking</summary><pre><code>next <span>:=</span> block<span>.</span>List<span>[</span>i<span>+</span><span>1</span><span>]</span>
iff<span>,</span> ok <span>:=</span> next<span>.</span><span>(</span><span>*</span>ast<span>.</span>IfStmt<span>)</span>
<span>if</span> <span>!</span>ok <span>{</span>
	<span>continue</span>
<span>}</span>
cond<span>,</span> ok <span>:=</span> iff<span>.</span>Cond<span>.</span><span>(</span><span>*</span>ast<span>.</span>BinaryExpr<span>)</span>
<span>if</span> <span>!</span>ok || cond<span>.</span>Op <span>!=</span> token<span>.</span>NEQ <span>{</span>
	<span>continue</span>
<span>}</span>
x<span>,</span> _ <span>:=</span> cond<span>.</span>X<span>.</span><span>(</span><span>*</span>ast<span>.</span>Ident<span>)</span>
y<span>,</span> _ <span>:=</span> cond<span>.</span>Y<span>.</span><span>(</span><span>*</span>ast<span>.</span>Ident<span>)</span>
<span>if</span> x <span>==</span> <span>nil</span> || x<span>.</span>Name <span>!=</span> <span>&#34;err&#34;</span> || y <span>==</span> <span>nil</span> || y<span>.</span>Name <span>!=</span> <span>&#34;nil&#34;</span> <span>{</span>
	<span>continue</span>
<span>}</span>
body <span>:=</span> iff<span>.</span>Body
<span>if</span> <span>len</span><span>(</span>body<span>.</span>List<span>)</span> <span>!=</span> <span>1</span> <span>{</span>
	<span>continue</span>
<span>}</span>
ret<span>,</span> ok <span>:=</span> body<span>.</span>List<span>[</span><span>0</span><span>]</span><span>.</span><span>(</span><span>*</span>ast<span>.</span>ReturnStmt<span>)</span>
<span>if</span> <span>!</span>ok <span>{</span>
	<span>continue</span>
<span>}</span>
res <span>:=</span> ret<span>.</span>Results
<span>if</span> <span>len</span><span>(</span>res<span>)</span> <span>!=</span> <span>2</span> <span>{</span>
	<span>continue</span>
<span>}</span>
x<span>,</span> _ <span>=</span> res<span>[</span><span>0</span><span>]</span><span>.</span><span>(</span><span>*</span>ast<span>.</span>Ident<span>)</span>
y<span>,</span> _ <span>=</span> res<span>[</span><span>1</span><span>]</span><span>.</span><span>(</span><span>*</span>ast<span>.</span>Ident<span>)</span>
<span>if</span> x <span>==</span> <span>nil</span> || x<span>.</span>Name <span>!=</span> <span>&#34;nil&#34;</span> || y <span>==</span> <span>nil</span> || y<span>.</span>Name <span>!=</span> <span>&#34;err&#34;</span> <span>{</span>
	<span>continue</span>
<span>}</span></code></pre></details></div><div><p>
Posted 19 Oct 2023 18:09 by tedu Updated: 19 Oct 2023 18:09 
</p></div></div>
  </body>
</html>
