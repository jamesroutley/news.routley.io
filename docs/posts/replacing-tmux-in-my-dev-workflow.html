<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bower.sh/you-might-not-need-tmux">Original</a>
    <h1>Replacing tmux in my dev workflow</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
        <p>Hear me out, I can already read the descenting opinions:</p>
<ul>
<li>But I need session persistence!</li>
<li>But I need split windows!</li>
<li>But I need to group windows per project!</li>
<li>But I need lots of terminals inside of a remote server!</li>
</ul>
<p>I had the exact same response whenever someone would argue against using <code>tmux</code>.
For context, I&#39;ve been a huge fan of <code>tmux</code> and have been using it as a daily
part of my workflow for 7+ years. Whether I&#39;m developing on my local machine or
in SSH, I was using <code>tmux</code>.</p>
<p>However, a couple of years ago I stumbled across a
<a href="https://github.com/kovidgoyal/kitty/issues/391#issuecomment-638320745" rel="nofollow">GitHub issue in the kitty project</a>
that has stuck in my mind like an itch that I cannot scratch.</p>
<blockquote>
<p>In summary: multiplexers add unnecessary overhead, suffer from a complexity
cascade, because they actually have to <em>translate</em> escape codes, modifying
them in hackish ways to get them to work with their concepts of
windows/sessions.</p>
</blockquote>
<p>And then a couple of weeks ago I watched this excellent interview from
<code>linkarzu</code> and kovid (creator of kitty). In it, they
<a href="https://www.youtube.com/watch?v=yOK4EJDyjcM" rel="nofollow">discussed <code>tmux</code></a>.</p>
<p>I have to say, the arguments are convincing. Over the years, I have had a
handful of problems with <code>tmux</code> that were not necessarily deal breakers but very
annoying to deal with on a regular basis.</p>
<p>For example, if you do not set <code>TERM</code> with <code>tmux</code> properly, your colors will
render incorrectly. Without <code>tmux</code> everything looks good, but with it things can
look washed out or just wrong. So when debugging issues related to terminal
features, you need to consider both your terminal emulator and <code>tmux</code>. Now add
another layer like <code>ssh</code> and you&#39;re really pulling your hair out.</p>
<p>Another example is buffer scrollback. It&#39;s one of those things where you have to
learn the <code>tmux</code> way of scrolling a window. You get used to it, of course, but
it&#39;s just not great.</p>
<p>And what about mouse select to copy/paste? It works most of the time, but
sometimes <code>tmux</code> gets ignored and I&#39;m selecting across splits which makes the
thing I&#39;m copying impossible to grab without bailing.</p>
<p>Another issue I ran into a couple of times is the lack of experimental protocol
support. I use &#34;experimental&#34; loosely since some of them are gaining popularity
inside terminal emulators, like the
<a href="https://sw.kovidgoyal.net/kitty/graphics-protocol/" rel="nofollow">kitty graphics protocol</a>.
Even if your terminal emulator supports the kitty graphics protocol,
<a href="https://github.com/tmux/tmux/issues/3395#issuecomment-1327312472" rel="nofollow"><code>tmux</code> does not</a>.</p>
<p>This is why kovid argues that terminal multiplexers:</p>
<blockquote>
<p>&#34;[...] act as a drag on the ecosystem as a whole, making it very hard to get
any new features.&#34;</p>
</blockquote>
<p>Okay, I get it, I&#39;m sympathetic to the issue terminal multiplexers cause to the
wider terminal ecosystem, but what&#39;s the alternative? <code>tmux</code> solves problems
that are not easy to replace:</p>
<ul>
<li>session persistence (detach + attach process from terminal)</li>
<li>window management (tabs, splits, moving them around)</li>
</ul>
<p>Session persistence can be accomplished in a number of ways, with varying
degrees of feature overlap with what <code>tmux</code> provides:</p>
<ul>
<li><code>ctrl-z</code> + <code>fg</code></li>
<li><code>nohup {cmd} &amp;</code></li>
<li><code>disown</code></li>
</ul>
<p>These are discussed in this
<a href="https://superuser.com/questions/178587/how-do-i-detach-a-process-from-terminal-entirely" rel="nofollow">stack exchange</a>
post. None of them quite work the way <code>tmux</code> works. In particular, these
commands will either a) get killed when you close your terminal, or b) cannot
reattach easily.</p>
<p>For window management, the argument is we should use our window managers to
manipulate our windows. That works great for local development, but what happens
when you are SSH&#39;d into a server? How do you let your window manager manipulate
windows within an SSH session?</p>
<p>Darn, built-in tools don&#39;t quite check all of our boxes, I wonder, are there any
<code>tmux</code> alternatives that could work?</p>
<p>I was desperate for a solution and I really did not want to build my own. I also
didn&#39;t want to replace <code>tmux</code> with something equally as large of a dependency.
Here&#39;s what I found:</p>
<ul>
<li><a href="https://dtach.sourceforge.net/" rel="nofollow">dtach</a></li>
<li><a href="https://github.com/martanne/abduco" rel="nofollow">abduco</a></li>
<li><a href="https://github.com/shell-pool/shpool" rel="nofollow">shpool</a></li>
</ul>
<p>All of these tools embody the unix philosophy of doing one thing, well. So they
are targeting session persistence (detach and attach functionality). What&#39;s
exciting about this idea is since there are no virtual splits, I can get native
scrollback!</p>
<p>Most of them work by <strong>creating a daemon<sup id="fnref:1"><a href="#fn:1" rel="nofollow">1</a></sup></strong> with some permutation of <code>fork()</code>
and communicating with a unix socket between the detached process and &#34;client&#34;
terminals. Some of them support buffer playback so when you reattach you can see
where you left off. Most of them haven&#39;t quite nailed this aspect of what <code>tmux</code>
does well, but <code>shpool</code> does a pretty good job.</p>
<p>I tried all of them with varying degrees of success. They could do what they
claim, but they are buggy. In particular, I could not get them to detach when
inside of <code>nvim</code>, which is a deal breaker. I assumed it was because the
shortcuts I was using to detach were being captured by <code>nvim</code>. Who knows, it
might be something misconfigured on my end.</p>
<p>However, out of those tools I used, <code>shpool</code> checked the most boxes.
Specifically they have a command <code>shpool detach</code> which allowed me to run a
command to detach the current process. So I was able to create a keymap that
sent the detach command to <code>shpool</code>:</p>
<pre><code><span><span>1</span><span><span>-- https://github.com/shell-pool/shpool/issues/71#issuecomment-2632396805</span>
</span></span><span><span>2</span><span><span>vim.keymap</span><span>.</span><span>set</span><span>({</span> <span>&#34;n&#34;</span><span>,</span> <span>&#34;v&#34;</span><span>,</span> <span>&#34;i&#34;</span><span>,</span> <span>&#34;t&#34;</span> <span>},</span> <span>&#34;&lt;C-space&gt;&lt;C-d&gt;&#34;</span><span>,</span> <span>function</span><span>()</span>
</span></span><span><span>3</span><span>  <span>vim.cmd</span><span>(</span><span>&#34;!shpool detach&#34;</span><span>)</span>
</span></span><span><span>4</span><span><span>end</span><span>)</span>
</span></span></code></pre><p>Nice, this is working well for session persistence. Let&#39;s move onto window
management. I&#39;m using <code>ghostty</code> on my work laptop and <code>sway+foot</code> on my personal
machines. I can use both of them for window management, but as a note I employ a
client+server development workflow. This means my client (e.g. laptop, desktop)
connects to a headless VM on my <code>proxmox</code> box where I do all of my dev. So I am
always SSH&#39;d during development. So how can I use my local window managers to
control all my <code>shpool</code> sessions on a remote server?</p>
<p><code>shpool</code> has some docs on how to
<a href="https://github.com/shell-pool/shpool?tab=readme-ov-file#optional-automatically-connect-to-shpool" rel="nofollow">automatically connect to <code>shpool</code></a></p>
<p>The idea is simple: use your window manager to create new terminal windows and
then <code>ssh</code> into each <code>shpool</code> session. Here&#39;s the <code>ssh_config</code> I use to make
this easier:</p>
<pre><code>Host *
    # ping server to make sure it&#39;s still responding
    ServerAliveInterval 60
    ServerAliveCountMax 3

Host = d.*
    HostName 192.168.88.xxx
    User erock
    IdentityFile ~/.ssh/id_ed25519

    # attach to shpool session based on the name provided
    RemoteCommand shpool attach -f %k
    RequestTTY yes

    # share ssh connection with all terminals that try to connect to this host
    ControlPath ~/.ssh/cm-%r@%h:%p
    ControlMaster auto
    ControlPersist 10m
</code></pre>
<p>Now I can automatically create or attach to my <code>shpool</code> sessions:</p>
<ul>
<li><code>ssh d.chat</code> -&gt; connect to IRC</li>
<li><code>ssh d.dot</code> -&gt; connect to my dotfiles <code>neovim</code> client</li>
<li><code>ssh d.term</code> -&gt; connect to a running terminal</li>
<li><code>ssh d.pico</code> -&gt; connect to my pico <code>neovim</code> client</li>
</ul>
<p>I can spin up as many <code>shpool</code> sessions as I want and connect to them as-needed.
Then when I combine this with <a href="https://linux.die.net/man/1/autossh" rel="nofollow"><code>autossh</code></a>,
I can keep my terminal windows open on my client and reconnect automatically
when the client reconnects to my network!</p>
<pre><code><span><span>1</span><span>autossh -M <span>0</span> d.chat
</span></span></code></pre><p>So, did I finally replace <code>tmux</code>? For me, the answer is a resounding yes! Once I
got all of this setup on my dev machine, I haven&#39;t used <code>tmux</code> or feel like a
massive downgrade. I did have to adjust my normal workflow slightly, but that&#39;s
been fun. Further, I&#39;m slowly noticing things that <code>tmux</code> didn&#39;t handle well,
but now, &#34;just work&#34;: native scrollback, terminal notifications, and terminal
titles being the most notable changes.</p>
<p>It&#39;s not perfect, there are active issues with <code>shpool</code>, like it doesn&#39;t restore
terminal state properly when reattaching which can make
<a href="https://github.com/shell-pool/shpool/issues/240" rel="nofollow">resizing broken while using <code>nvim</code></a>.
But as noted in that issue, there is a work-around:</p>
<pre><code><span><span>1</span><span><span>vim.keymap</span><span>.</span><span>set</span><span>(</span><span>&#34;n&#34;</span><span>,</span> <span>&#34;&lt;leader&gt;l&#34;</span><span>,</span> <span>function</span><span>()</span>
</span></span><span><span>2</span><span>  <span>io.stdout</span><span>:</span><span>write</span><span>(</span><span>&#34;</span><span>\027</span><span>[?2048h&#34;</span><span>)</span>
</span></span><span><span>3</span><span><span>end</span><span>,</span> <span>opts</span><span>)</span>
</span></span></code></pre><p><code>shpool</code> also
<a href="https://github.com/shell-pool/shpool/issues/40" rel="nofollow">doesn&#39;t support &#34;multiplayer&#34;</a>
which has caused some issues with using <code>autossh</code> on multiple clients since they
will disconnect each other.</p>
<p>Could this workflow replace <code>tmux</code> for you? Let me know!</p>



        

        <p>
          last updated: <time datetime="2025-08-01T01:32:31Z">2025-08-01</time>
        </p>

        
    </article>
</div></div>
  </body>
</html>
