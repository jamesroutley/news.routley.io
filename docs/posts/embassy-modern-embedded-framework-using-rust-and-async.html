<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/embassy-rs/embassy">Original</a>
    <h1>Embassy: Modern embedded framework, using Rust and async</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Embassy is the next-generation framework for embedded applications. Write safe, correct, and energy-efficient embedded code faster, using the Rust programming language, its async facilities, and the Embassy libraries.</p>

<div dir="auto"><h2 tabindex="-1" dir="auto">Rust + async ❤️ embedded</h2><a id="user-content-rust--async-️-embedded" aria-label="Permalink: Rust + async ❤️ embedded" href="#rust--async-️-embedded"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The Rust programming language is blazingly fast and memory-efficient, with no runtime, garbage collector, or OS. It catches a wide variety of bugs at compile time, thanks to its full memory- and thread-safety, and expressive type system.</p>
<p dir="auto">Rust&#39;s <a href="https://rust-lang.github.io/async-book/" rel="nofollow">async/await</a> allows for unprecedentedly easy and efficient multitasking in embedded systems. Tasks get transformed at compile time into state machines that get run cooperatively. It requires no dynamic memory allocation and runs on a single stack, so no per-task stack size tuning is required. It obsoletes the need for a traditional RTOS with kernel context switching, and is <a href="https://tweedegolf.nl/en/blog/65/async-rust-vs-rtos-showdown" rel="nofollow">faster and smaller than one!</a></p>

<ul dir="auto">
<li>
<p dir="auto"><strong>Hardware Abstraction Layers</strong></p>
<ul dir="auto">
<li>HALs implement safe, idiomatic Rust APIs to use the hardware capabilities, so raw register manipulation is not needed. The Embassy project maintains HALs for select hardware, but you can still use HALs from other projects with Embassy.</li>
<li><a href="https://docs.embassy.dev/embassy-stm32/" rel="nofollow">embassy-stm32</a>, for all STM32 microcontroller families.</li>
<li><a href="https://docs.embassy.dev/embassy-nrf/" rel="nofollow">embassy-nrf</a>, for the Nordic Semiconductor nRF52, nRF53, nRF54 and nRF91 series.</li>
<li><a href="https://docs.embassy.dev/embassy-rp/" rel="nofollow">embassy-rp</a>, for the Raspberry Pi RP2040 and RP23xx microcontrollers.</li>
<li><a href="https://docs.embassy.dev/embassy-mspm0/" rel="nofollow">embassy-mspm0</a>, for the Texas Instruments MSPM0 microcontrollers.</li>
<li><a href="https://github.com/esp-rs">esp-rs</a>, for the Espressif Systems ESP32 series of chips.
<ul dir="auto">
<li>Embassy HAL support for Espressif chips, as well as Async Wi-Fi, Bluetooth, and ESP-NOW, is being developed in the <a href="https://github.com/esp-rs/esp-hal">esp-rs/esp-hal</a> repository.</li>
</ul>
</li>
<li><a href="https://github.com/ch32-rs/ch32-hal">ch32-hal</a>, for the WCH 32-bit RISC-V(CH32V) series of chips.</li>
<li><a href="https://github.com/AlexCharlton/mpfs-hal">mpfs-hal</a>, for the Microchip PolarFire SoC.</li>
<li><a href="https://github.com/py32-rs/py32-hal">py32-hal</a>, for the Puya Semiconductor PY32 series of microcontrollers.</li>
</ul>
</li>
<li>
<p dir="auto"><strong>Time that Just Works</strong> -
No more messing with hardware timers. <a href="https://docs.embassy.dev/embassy-time" rel="nofollow">embassy_time</a> provides Instant, Duration, and Timer types that are globally available and never overflow.</p>
</li>
<li>
<p dir="auto"><strong>Real-time ready</strong> -
Tasks on the same async executor run cooperatively, but you can create multiple executors with different priorities so that higher priority tasks preempt lower priority ones. See the <a href="https://github.com/embassy-rs/embassy/blob/main/examples/nrf52840/src/bin/multiprio.rs">example</a>.</p>
</li>
<li>
<p dir="auto"><strong>Low-power ready</strong> -
Easily build devices with years of battery life. The async executor automatically puts the core to sleep when there&#39;s no work to do. Tasks are woken by interrupts, there is no busy-loop polling while waiting.</p>
</li>
<li>
<p dir="auto"><strong>Networking</strong> -
The <a href="https://docs.embassy.dev/embassy-net/" rel="nofollow">embassy-net</a> network stack implements extensive networking functionality, including Ethernet, IP, TCP, UDP, ICMP, and DHCP. Async drastically simplifies managing timeouts and serving multiple connections concurrently.</p>
</li>
<li>
<p dir="auto"><strong>Bluetooth</strong></p>
<ul dir="auto">
<li>The <a href="https://github.com/embassy-rs/trouble">trouble</a> crate provides a Bluetooth Low Energy 4.x and 5.x Host that runs on any microcontroller implementing the <a href="https://github.com/embassy-rs/bt-hci">bt-hci</a> traits (currently
<code>nRF52</code>, <code>nrf54</code>, <code>rp2040</code>, <code>rp23xx</code> and <code>esp32</code> and <code>serial</code> controllers are supported).</li>
<li>The <a href="https://github.com/embassy-rs/nrf-softdevice">nrf-softdevice</a> crate provides Bluetooth Low Energy 4.x and 5.x support for nRF52 microcontrollers.</li>
<li>The <a href="https://github.com/embassy-rs/embassy/tree/main/embassy-stm32-wpan">embassy-stm32-wpan</a> crate provides Bluetooth Low Energy 5.x support for stm32wb microcontrollers.</li>
</ul>
</li>
<li>
<p dir="auto"><strong>LoRa</strong> -
The <a href="https://github.com/lora-rs/lora-rs">lora-rs</a> project provides an async LoRa and LoRaWAN stack that works well on Embassy.</p>
</li>
<li>
<p dir="auto"><strong>USB</strong> -
<a href="https://docs.embassy.dev/embassy-usb/" rel="nofollow">embassy-usb</a> implements a device-side USB stack. Implementations for common classes such as USB serial (CDC ACM) and USB HID are available, and a rich builder API allows building your own.</p>
</li>
<li>
<p dir="auto"><strong>Bootloader and DFU</strong> -
<a href="https://github.com/embassy-rs/embassy/tree/main/embassy-boot">embassy-boot</a> is a lightweight bootloader supporting firmware application upgrades in a power-fail-safe way, with trial boots and rollbacks.</p>
</li>
</ul>

<div dir="auto" data-snippet-clipboard-copy-content="use defmt::info;
use embassy_executor::Spawner;
use embassy_time::{Duration, Timer};
use embassy_nrf::gpio::{AnyPin, Input, Level, Output, OutputDrive, Pin, Pull};
use embassy_nrf::{Peri, Peripherals};

// Declare async tasks
#[embassy_executor::task]
async fn blink(pin: Peri&lt;&#39;static, AnyPin&gt;) {
    let mut led = Output::new(pin, Level::Low, OutputDrive::Standard);

    loop {
        // Timekeeping is globally available, no need to mess with hardware timers.
        led.set_high();
        Timer::after_millis(150).await;
        led.set_low();
        Timer::after_millis(150).await;
    }
}

// Main is itself an async task as well.
#[embassy_executor::main]
async fn main(spawner: Spawner) {
    let p = embassy_nrf::init(Default::default());

    // Spawned tasks run in the background, concurrently.
    spawner.spawn(blink(p.P0_13.into()).unwrap());

    let mut button = Input::new(p.P0_11, Pull::Up);
    loop {
        // Asynchronously wait for GPIO events, allowing other tasks
        // to run, or the core to sleep.
        button.wait_for_low().await;
        info!(&#34;Button pressed!&#34;);
        button.wait_for_high().await;
        info!(&#34;Button released!&#34;);
    }
}"><pre><span>use</span> defmt<span>::</span>info<span>;</span>
<span>use</span> embassy_executor<span>::</span><span>Spawner</span><span>;</span>
<span>use</span> embassy_time<span>::</span><span>{</span><span>Duration</span><span>,</span> <span>Timer</span><span>}</span><span>;</span>
<span>use</span> embassy_nrf<span>::</span>gpio<span>::</span><span>{</span><span>AnyPin</span><span>,</span> <span>Input</span><span>,</span> <span>Level</span><span>,</span> <span>Output</span><span>,</span> <span>OutputDrive</span><span>,</span> <span>Pin</span><span>,</span> <span>Pull</span><span>}</span><span>;</span>
<span>use</span> embassy_nrf<span>::</span><span>{</span><span>Peri</span><span>,</span> <span>Peripherals</span><span>}</span><span>;</span>

<span>// Declare async tasks</span>
<span>#<span>[</span>embassy_executor<span>::</span>task<span>]</span></span>
<span>async</span> <span>fn</span> <span>blink</span><span>(</span><span>pin</span><span>:</span> <span>Peri</span><span>&lt;</span><span>&#39;</span><span>static</span><span>,</span> <span>AnyPin</span><span>&gt;</span><span>)</span> <span>{</span>
    <span>let</span> <span>mut</span> led = <span>Output</span><span>::</span><span>new</span><span>(</span>pin<span>,</span> <span>Level</span><span>::</span><span>Low</span><span>,</span> <span>OutputDrive</span><span>::</span><span>Standard</span><span>)</span><span>;</span>

    <span>loop</span> <span>{</span>
        <span>// Timekeeping is globally available, no need to mess with hardware timers.</span>
        led<span>.</span><span>set_high</span><span>(</span><span>)</span><span>;</span>
        <span>Timer</span><span>::</span><span>after_millis</span><span>(</span><span>150</span><span>)</span><span>.</span><span>await</span><span>;</span>
        led<span>.</span><span>set_low</span><span>(</span><span>)</span><span>;</span>
        <span>Timer</span><span>::</span><span>after_millis</span><span>(</span><span>150</span><span>)</span><span>.</span><span>await</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// Main is itself an async task as well.</span>
<span>#<span>[</span>embassy_executor<span>::</span>main<span>]</span></span>
<span>async</span> <span>fn</span> <span>main</span><span>(</span><span>spawner</span><span>:</span> <span>Spawner</span><span>)</span> <span>{</span>
    <span>let</span> p = embassy_nrf<span>::</span><span>init</span><span>(</span><span>Default</span><span>::</span><span>default</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>// Spawned tasks run in the background, concurrently.</span>
    spawner<span>.</span><span>spawn</span><span>(</span><span>blink</span><span>(</span>p<span>.</span><span>P0_13</span><span>.</span><span>into</span><span>(</span><span>)</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>let</span> <span>mut</span> button = <span>Input</span><span>::</span><span>new</span><span>(</span>p<span>.</span><span>P0_11</span><span>,</span> <span>Pull</span><span>::</span><span>Up</span><span>)</span><span>;</span>
    <span>loop</span> <span>{</span>
        <span>// Asynchronously wait for GPIO events, allowing other tasks</span>
        <span>// to run, or the core to sleep.</span>
        button<span>.</span><span>wait_for_low</span><span>(</span><span>)</span><span>.</span><span>await</span><span>;</span>
        <span>info</span><span>!</span><span>(</span><span>&#34;Button pressed!&#34;</span><span>)</span><span>;</span>
        button<span>.</span><span>wait_for_high</span><span>(</span><span>)</span><span>.</span><span>await</span><span>;</span>
        <span>info</span><span>!</span><span>(</span><span>&#34;Button released!&#34;</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span></pre></div>

<p dir="auto">Examples are found in the
<code>examples/</code> folder separated by the chip manufacturer they are designed to run on. For example:</p>
<ul dir="auto">
<li><code>examples/nrf52840</code> run on the
<code>nrf52840-dk</code> board (PCA10056) but should be easily adaptable to other nRF52 chips and boards.</li>
<li><code>examples/nrf5340</code> run on the <code>nrf5340-dk</code> board (PCA10095).</li>
<li><code>examples/stm32xx</code> for the various STM32 families.</li>
<li><code>examples/rp</code> are for the RP2040 chip.</li>
<li><code>examples/std</code> are designed to run locally on your PC.</li>
</ul>

<ul dir="auto">
<li>Install <code>probe-rs</code> following the instructions at <a href="https://probe.rs" rel="nofollow">https://probe.rs</a>.</li>
<li>Change directory to the sample&#39;s base directory. For example:</li>
</ul>

<ul dir="auto">
<li>
<p dir="auto">Ensure <code>Cargo.toml</code> sets the right feature for the name of the chip you are programming.
If this name is incorrect, the example may fail to run or immediately crash
after being programmed.</p>
</li>
<li>
<p dir="auto">Ensure <code>.cargo/config.toml</code> contains the name of the chip you are programming.</p>
</li>
<li>
<p dir="auto">Run the example</p>
</li>
</ul>
<p dir="auto">For example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cargo run --release --bin blinky"><pre>cargo run --release --bin blinky</pre></div>
<p dir="auto">For more help getting started, see <a href="https://github.com/embassy-rs/embassy/wiki/Getting-Started">Getting Started</a> and <a href="https://github.com/embassy-rs/embassy/wiki/Running-the-Examples">Running the Examples</a>.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Developing Embassy with Rust Analyzer-based editors</h2><a id="user-content-developing-embassy-with-rust-analyzer-based-editors" aria-label="Permalink: Developing Embassy with Rust Analyzer-based editors" href="#developing-embassy-with-rust-analyzer-based-editors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <a href="https://rust-analyzer.github.io/" rel="nofollow">Rust Analyzer</a> is used by <a href="https://code.visualstudio.com/" rel="nofollow">Visual Studio Code</a>
and others. Given the multiple targets that Embassy serves, there is no Cargo workspace file. Instead, the Rust Analyzer
must be told of the target project to work with. In the case of Visual Studio Code,
please refer to the <code>.vscode/settings.json</code> file&#39;s <code>rust-analyzer.linkedProjects</code>setting.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Minimum supported Rust version (MSRV)</h2><a id="user-content-minimum-supported-rust-version-msrv" aria-label="Permalink: Minimum supported Rust version (MSRV)" href="#minimum-supported-rust-version-msrv"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Embassy is guaranteed to compile on stable Rust 1.75 and up. It <em>might</em>
compile with older versions, but that may change in any new patch release.</p>

<p dir="auto">EMBedded ASYnc! :)</p>

<p dir="auto">Embassy is licensed under either of</p>
<ul dir="auto">
<li>Apache License, Version 2.0 (<a href="https://github.com/embassy-rs/embassy/blob/main/LICENSE-APACHE">LICENSE-APACHE</a> or
<a href="http://www.apache.org/licenses/LICENSE-2.0" rel="nofollow">http://www.apache.org/licenses/LICENSE-2.0</a>)</li>
<li>MIT license (<a href="https://github.com/embassy-rs/embassy/blob/main/LICENSE-MIT">LICENSE-MIT</a> or <a href="http://opensource.org/licenses/MIT" rel="nofollow">http://opensource.org/licenses/MIT</a>)</li>
</ul>
<p dir="auto">at your option.</p>

<p dir="auto">Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as above, without any additional terms or conditions.</p>
</article></div></div>
  </body>
</html>
