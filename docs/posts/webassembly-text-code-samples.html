<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2023/webassembly-text-code-samples/">Original</a>
    <h1>WebAssembly Text Code Samples</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>This post talks about writing WebAssembly by hand (using its textual format),
and mentions a new GitHub <a href="https://github.com/eliben/wasm-wat-samples/">repository</a> I&#39;ve created with code samples.</p>
<p>A bit of nomenclature first. <strong>WASM</strong> stands for WebAssembly - it has a <a href="https://webassembly.github.io/spec/core/binary/index.html">binary
format</a> and a
<a href="https://webassembly.github.io/spec/core/text/index.html">textual format</a>.
The textual format, called WebAssembly Text or <strong>WAT</strong>, is the subject of this
post.</p>
<div id="introduction-to-wat">
<h2>Introduction to WAT</h2>
<p>WASM is a stack machine, and while stack machines can lead to wonderfully
compact bytecode, they can also be awkward to code by hand - because the
programmer needs to have a mental model of the top stack slots at all times,
remembering what they refer to. While you can certainly code directly to the
stack machine with WAT, it also has some programmer-friendly constructs
that significantly improve writability and readability. Here&#39;s an example:</p>
<div><pre><span></span>(local.set $writeidx (i32.sub (local.get $writeidx) (i32.const 1)))
</pre></div>
<p>This is equivalent to <tt>writeidx <span>-=</span> 1</tt> in many mainstream languages. The two
WAT features at play here are:</p>
<ol>
<li>The ability to declare variables and to refer to them
by name (this includes function parameters).</li>
<li><em>Folded instructions</em> - allowing the programmer to condense a sequence of
stack operations into a single <a href="https://en.wikipedia.org/wiki/S-expression">s-expr</a>. This is music to
<a href="https://eli.thegreenplace.net/tag/lisp">my Lisper ears</a>!</li>
</ol>
<p>These folded instructions can go as deep as we wish; here&#39;s an even more nested
example involving memory access:</p>
<div><pre><span></span>(local.set
    $next_env_ptr
    (i32.load (i32.add  (global.get $env_ptrs)
                        (i32.mul (local.get $i) (i32.const 4)))))
</pre></div>
<p>In pseudo-C, this is equivalent to <a href="#footnote-1" id="footnote-reference-1">[1]</a>:</p>
<div><pre><span></span><span>next_env_ptr</span><span> </span><span>=</span><span> </span><span>memory</span><span>[</span><span>env_ptrs</span><span> </span><span>+</span><span> </span><span>i</span><span>*</span><span>4</span><span>];</span><span></span>
</pre></div>
<p>WAT has some additional ergonomic features that I like. For example, named
functions with named parameters, as well as declared return values:</p>
<div><pre><span></span>(func $itoa (export &#34;itoa&#34;) (param $num i32) (result i32 i32)
  ...
)
</pre></div>
<p>This function has a name we can refer to in calls, a single parameter with
a name (<tt>$num</tt>) and two return values. Calling this function can be done
in a folded expression like:</p>
<div><pre><span></span>(call $itoa (i32.add (local.get $n) (i32.const 1)))
</pre></div>
<p>Which is equivalent to <tt>itoa(n+1)</tt>. Another feature this example demonstrates
is <em>types</em> - WAT functions and values (parameters, globals and locals) have
types, which makes code easier to read and understand, and also provides the
compiler an opportunity to check for correctness at compile time.</p>
<p>Moreover, in the WASM model, type checking goes deeper and extends to stack
interactions; the WASM compiler knows how many stack slots each instruction uses
and produces, and this is verified as well - so common mistakes are easily
caught. I find that the code is much more often correct once I get it to compile
in WAT compared to other assembly languages.</p>
</div>
<div id="samples-of-wat-code">
<h2>Samples of WAT code</h2>
<p>Back to the original goal of this post. While I enjoy writing WAT code, one
aspect of the experience that could be improved is documentation. The
<a href="https://webassembly.github.io/spec/core/index.html">WASM spec</a> is
much more suitable for formal verification than for actual documentation
purposes; specifically, it&#39;s hard to grep and doesn&#39;t provide much in terms
of examples. This is alright for a spec, but I couldn&#39;t find complementary
resources that just show code samples.</p>
<p>Therefore, I&#39;ve decided to collect some of the WAT snippets I&#39;ve written so far
into a GitHub repository named <a href="https://github.com/eliben/wasm-wat-samples/">wasm-wat-samples</a>. It&#39;s my humble contribution to
the world of WAT documentation. The goal of the repository is to demonstrate how
WAT concepts (including WASI) and constructs are used in practice; it&#39;s
optimized for <em>greppability</em>.</p>
<p>I hope others find it useful as well - feel free to suggest additional samples
in issues and PRs!</p>
<hr/>

</div>

            </div></div>
  </body>
</html>
