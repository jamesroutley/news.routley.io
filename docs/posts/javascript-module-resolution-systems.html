<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/Javascript/JavaScript-Module-Resolution-Systems">Original</a>
    <h1>JavaScript Module Resolution Systems</h1>
    
    <div id="readability-page-1" class="page"><div id="quartz-body"><div><article><p>We can also think of these as <code>module specifications</code>. The question here is, what are the systems that Javascript uses to import and export code from various files and packages, and how are they different?</p>

<p><a href="https://codilime.com/blog/history-of-javascript-module-systems/">Navigating the module maze: history of JavaScript module systems<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<ul>
<li>Mentions ESM and CJS</li>
<li>Asks “what is a module?”</li>
<li>Talks about Revealing Module Pattern (which I had never heard of) <a href="#revealing-module-pattern">Revealing Module Pattern</a></li>
</ul>

<ul>
<li>Synchronous</li>
<li>Doesn’t work in the browser</li>
<li><a href="https://wiki.commonjs.org/wiki/Modules/1.1">Includes a Module Specification<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></li>
</ul>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>var</span><span> someModule </span><span>=</span><span> require</span><span>(</span><span>&#39;someModule&#39;</span><span>)</span></span>
<span data-line=""> </span>
<span data-line=""><span>exports</span><span> =</span><span> {}</span></span></code></pre></figure>

<ul>
<li>“Asynchronous Module Definition”</li>
<li>Asynchronous</li>
<li>Designed for a browser environment where network connection is less dependable and you may want to load multiple dependencies at once</li>
<li><a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md">A competing specification for modules, usually used in the browser<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></li>
</ul>

<ul>
<li>Probably most popular implementation of AMD</li>
<li>Implements the AMD API (but wants to keep the spirit of CommonJS)</li>
<li>Async</li>
<li>Offers CommonJS wrappers so that CommonJS modules can be directly imported for use with RequireJS</li>
</ul>

<p>Allows you to ‘require’ modules in the browser by bundling up all of your dependencies.</p>
<ul>
<li>Open source</li>
<li>Javascript bundler</li>
<li>Allows devs to write Node.js-style modular code and use it in the browser</li>
<li>Kind of old…? Is it still relevant?</li>
<li>Supports “transforms” which are kinda cool</li>
<li>Webpack and Rollup competed with it back in the day</li>
</ul>

<ul>
<li>Standardized into ECMAScript in 2015</li>
<li><strong>import</strong> and <strong>export</strong></li>
<li>Browser support</li>
<li>Also support in Node.js</li>
<li>Future proof (part of JS standard)</li>
<li>Is synchronous but has an optional <code>import</code> asynchronous option!</li>
</ul>

<p>They use IIFEs (immediately invoked function expressions):</p>
<pre><code>(function(){})()
</code></pre>
<p>Note to me: if that’s hard to remember, just note that it’s a normal function wrapped wrapped in an invoked closure: <code>()()</code>. There are at least two anatomical mnemonics that may help encode the immediacy part.</p>
<p>So his creates a local scope for all variables and methods. Only public methods will have access to the code inside an IIFE.</p>
<p>These are so cool. Here’s an example <a href="https://medium.com/@Rahulx1/revealing-module-pattern-tips-e3442d4e352#:~:text=Revealing%20module%20pattern%20is%20a,know%20how%20to%20avoid%20that">@Rahulx1 on medium<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>.) gives:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>var</span><span> namesCollection </span><span>=</span><span> (</span><span>function</span><span>() {</span></span>
<span data-line=""><span>    // private members</span></span>
<span data-line=""><span>    var</span><span> objects </span><span>=</span><span> [];</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    // Public Method</span></span>
<span data-line=""><span>    function</span><span> addObject</span><span>(</span><span>object</span><span>) {</span></span>
<span data-line=""><span>        objects.</span><span>push</span><span>(object);</span></span>
<span data-line=""><span>        printMessage</span><span>(object);</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  </span></span>
<span data-line=""><span>    // Private Method</span></span>
<span data-line=""><span>    function</span><span> printMessage</span><span>(</span><span>object</span><span>) {</span></span>
<span data-line=""><span>        console.</span><span>log</span><span>(</span><span>&#34;Object successfully added:&#34;</span><span>, object);</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    // public members, exposed with return statement</span></span>
<span data-line=""><span>    return</span><span> {</span></span>
<span data-line=""><span>        addObject: addObject,</span></span>
<span data-line=""><span>    };</span></span>
<span data-line=""><span>})();</span></span></code></pre></figure>
<p>Only the methods we want are returned! Wild! By the way, it’s okay to put the return statement at the <em>top</em> of the file. This…made no sense to me, so I investigated.</p>
<p>I actually tried this, and it didn’t work. But it <em>did</em> work if I put the return statement below this line:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>var</span><span> objects </span><span>=</span><span> []</span></span></code></pre></figure>
<p>This seems to be due to something called <code>function hoisting</code>, in which the interpreter function declarations to the top of their scope before code execution. <em>This means that you can call a function before it is declared in your code without encountering an error!</em></p>
<p>Okay definitely learning some new things here. Check this out
<a href="https://medium.com/@oguzhancelikkaya/function-declarations-vs-function-expressions-hoisting-ace84399a172">Function Declarations vs. Function Expressions &amp; Hoisting<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<blockquote data-callout="note" data-callout-fold="">

<p>This article was written a while ago and a few of the examples here don’t actually work quite as expected, but this is probably because they are using intentionally weird syntax that probably <em>shouldn’t</em> work, and his been weeded out.</p>
</blockquote>
<p>This actually taught me something much more important, which is the different between <code>function declarations</code> and  <code>function expressions</code></p>
<p>Function declaration:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> foo</span><span>(){}</span></span></code></pre></figure>
<p>Function expression:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>const</span><span> bar</span><span> =</span><span> function</span><span>(){}</span></span>
<span data-line=""><span>// or</span></span>
<span data-line=""><span>const</span><span> bar</span><span> =</span><span> () </span><span>=&gt;</span><span> {}</span></span></code></pre></figure>
<p>This gives an error:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>console.</span><span>log</span><span>(</span><span>hoist</span><span>())</span></span>
<span data-line=""><span>const</span><span> hoist</span><span> =</span><span> () </span><span>=&gt;</span><span> &#34;moose&#34;</span></span></code></pre></figure>
<blockquote>
<p>Cannot access ‘hoist’ before initialization. I tested this in <code>ts</code> <em>and</em> <code>js</code> just to be sure.</p>
</blockquote>
<p>This does not:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>console.</span><span>log</span><span>(</span><span>hoist</span><span>())</span></span>
<span data-line=""><span>function</span><span> hoist</span><span>(){</span></span>
<span data-line=""><span>  return</span><span> &#34;hoist&#34;</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>I was getting some mixed messages about which is called an <code>expression</code> and which is called a <code>declaration</code> so I called up my old friend MDN and she confirmed.</p>
<p>What I finally understand now is that arrow functions <em>are</em> a (relatively) more modern version of <em>traditional</em> function expressions. They’re nice because now function declarations and expressions look super different.</p>
<p>It turns out, declarations are loaded when the code is <em>compiled</em>, not when it’s executed, whereas expressions seem to be loaded and executed in the same step.</p></article><hr/></div></div></div>
  </body>
</html>
