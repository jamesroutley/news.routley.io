<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.joeshaw.org/dont-defer-close-on-writable-files/">Original</a>
    <h1>Don&#39;t defer Close() on writable files (2017)</h1>
    
    <div id="readability-page-1" class="page"><div><p><em>Update</em>: Another approach suggested by the inimitable
<a href="https://twitter.com/benbjohnson/status/874286396411961345">Ben Johnson</a>
has been added to the end of the post.</p><p><em>Update 2</em>: Discussion about <code>fsync()</code> added to the end of the post.</p><p>It’s an idiom that quickly becomes rote to Go programmers: whenever
you conjure up a value that implements the <code>io.Closer</code> interface,
after checking for errors you immediately <code>defer</code> its <code>Close()</code>
method. You see this most often when making HTTP requests:</p><div><pre><code data-lang="go">resp, err := http.<span>Get</span>(<span>&#34;https://joeshaw.org&#34;</span>)
<span>if</span> err != <span>nil</span> {
    <span>return</span> err
}
<span>defer</span> resp.Body.<span>Close</span>()
</code></pre></div><p>or opening files:</p><div><pre><code data-lang="go">f, err := os.<span>Open</span>(<span>&#34;/home/joeshaw/notes.txt&#34;</span>)
<span>if</span> err != <span>nil</span> {
    <span>return</span> err
}
<span>defer</span> f.<span>Close</span>()
</code></pre></div><p>But this idiom is actually harmful for writable files because
deferring a function call ignores its return value, and the <code>Close()</code>
method can return errors. <strong>For writable files, Go programmers should
avoid the <code>defer</code> idiom or very infrequent, maddening bugs will
occur.</strong></p><p>Why would you get an error from <code>Close()</code> but not an earlier <code>Write()</code>
call? To answer that we need to take a brief, high-level detour into
the area of computer architecture.</p><p>Generally speaking, as you move outside and away from your CPU,
actions get orders of magnitude slower. Writing to a CPU register is
very fast. Accessing system RAM is quite slow in comparison. Doing
I/O on disks or networks is an eternity.</p><p>If every <code>Write()</code> call committed the data to the disk synchronously,
the performance of our systems would be unusably slow. While
synchronous writes are very important for certain types of software
(like databases), most of the time it’s overkill.</p><p>The pathological case is writing to a file one byte at a time. Hard
drives – brutish, mechanical devices – need to physically move a
magnetic head to the position on the platter and possibly wait for a
full platter revolution before the data could be persisted. SSDs,
which store data in blocks and have a finite number of write cycles
for each block, would quickly burn out as blocks are repeatedly
written and overwritten.</p><p>Fortunately this doesn’t happen because multiple layers within
hardware and software implement caching and write buffering. When you
call <code>Write()</code>, your data is not immediately being written to media.
The operating system, storage controllers and the media itself are all
buffering the data in order to batch smaller writes together,
organizing the data optimally for storage on the medium, and deciding
when best to commit it. This turns our writes from slow, blocking
synchronous operations to quick, asynchronous operations that don’t
directly touch the much slower I/O device. Writing a byte at a time
is never the most efficient thing to do, but at least we are not
wearing out our hardware if we do it.</p><p>Of course, the bytes do have to be committed to disk at some point.
The operating system knows that when we close a file, we are finished
with it and no subsequent write operations are going to happen. It
also knows that closing the file is its last chance to tell us
something went wrong.</p><p>On POSIX systems like Linux and macOS, closing a file is handled by
the <code>close</code> system call. The BSD man page for <code>close(2)</code> talks about
the errors it can return:</p><pre><code>ERRORS
     The close() system call will fail if:

     [EBADF]            fildes is not a valid, active file descriptor.

     [EINTR]            Its execution was interrupted by a signal.

     [EIO]              A previously-uncommitted write(2) encountered an input/output
                        error.
</code></pre><p><code>EIO</code> is exactly the error we are worried about. It means that we’ve
lost data trying to save it to disk, and our Go programs should
absolutely not return a <code>nil</code> error in that case.</p><p>The simplest way to solve this is simply not to use <code>defer</code> when
writing files:</p><div><pre><code data-lang="go"><span>func</span> <span>helloNotes</span>() <span>error</span> {
    f, err := os.<span>Create</span>(<span>&#34;/home/joeshaw/notes.txt&#34;</span>)
    <span>if</span> err != <span>nil</span> {
        <span>return</span> err
    }

    <span>if</span> err = io.<span>WriteString</span>(f, <span>&#34;hello world&#34;</span>); err != <span>nil</span> {
        f.<span>Close</span>()
        <span>return</span> err
    }

    <span>return</span> f.<span>Close</span>()
}
</code></pre></div><p>This does mean additional bookkeeping of the file in the case of
errors: we must explicitly close it in the case where
<code>io.WriteString()</code> fails (and ignore its error, because the write
error takes precedence). But it’s clear, straightforward, and
properly checks the error from the <code>f.Close()</code> call.</p><p>There <em>is</em> a way to handle this case with <code>defer</code> by using named
return values and a closure:</p><div><pre><code data-lang="go"><span>func</span> <span>helloNotes</span>() (err <span>error</span>) {
    <span>var</span> f *os.File
    f, err = os.<span>Create</span>(<span>&#34;/home/joeshaw/notes.txt&#34;</span>)
    <span>if</span> err != <span>nil</span> {
        <span>return</span>
    }

    <span>defer</span> <span>func</span>() {
        cerr := f.<span>Close</span>()
        <span>if</span> err == <span>nil</span> {
            err = cerr
        }
    }()

    err = io.<span>WriteString</span>(f, <span>&#34;hello world&#34;</span>)
    <span>return</span>
}
</code></pre></div><p>The main benefit of this pattern is that it’s not possible to forget
to close the file because the deferred closure always executes. In
longer functions with more <code>if err != nil</code> conditional branches, this
pattern can also result in fewer lines of code and less repetition.</p><p>Still, I find this pattern to be a little too magical. I dislike
using named return values, and modifying the return value after the
core function finishes is not intuitively clear even to experienced Go
programmers.</p><p>I am willing to accept the tradeoff of more readable and easily
understandable code for needing to obsessively review code to ensure
that the file is closed in all cases, and that’s the approach I
recommend in code reviews I give to others.</p><h2 id="update">Update</h2><p>On Twitter, <a href="https://twitter.com/benbjohnson/status/874286396411961345">Ben Johnson
suggested</a>
that <code>Close()</code> may be safe to run multiple times on files, like so:</p><div><pre><code data-lang="go"><span>func</span> <span>doSomething</span>() <span>error</span> {
    f, err := os.<span>Create</span>(<span>&#34;foo&#34;</span>)
    <span>if</span> err != <span>nil</span> {
        <span>return</span> err
    }
    <span>defer</span> f.<span>Close</span>()

    <span>if</span> _, err := f.<span>Write</span>([]<span>byte</span>(<span>&#34;bar&#34;</span>); err != <span>nil</span> {
        <span>return</span> err
    }

    <span>if</span> err := f.<span>Close</span>(); err != <span>nil</span> {
        <span>return</span> err
    }
    <span>return</span> <span>nil</span>
}
</code></pre></div><p><a href="https://gist.github.com/benbjohnson/9eebd201ec096ab6430e1f33411e6427">(gist)</a></p><p>The Go docs on <code>io.Closer</code> <a href="https://golang.org/pkg/io/#Closer">explicitly say</a> that
at an interface level behavior after the first call is unspecificed,
but specific implementations may document their own behavior.</p><p>The docs for <code>*os.File</code> <a href="https://golang.org/pkg/os/#File.Close">unfortunately aren’t clear</a>
on its behavior, saying only, “Close closes the File, rendering it
unusable for I/O. It returns an error, if any.” The implemenation as
of 1.8, however, shows:</p><div><pre><code data-lang="go"><span>func</span> (f *File) <span>Close</span>() <span>error</span> {
    <span>if</span> f == <span>nil</span> {
        <span>return</span> ErrInvalid
    }
    <span>return</span> f.file.<span>close</span>()
}

<span>func</span> (file *file) <span>close</span>() <span>error</span> {
    <span>if</span> file == <span>nil</span> || file.fd == badFd {
        <span>return</span> syscall.EINVAL
    }
    <span>var</span> err <span>error</span>
    <span>if</span> e := syscall.<span>Close</span>(file.fd); e != <span>nil</span> {
        err = &amp;PathError{<span>&#34;close&#34;</span>, file.name, e}
    }
    file.fd = -<span>1</span> <span>// so it can&#39;t be closed again
</span><span></span>
    <span>// no need for a finalizer anymore
</span><span></span>    runtime.<span>SetFinalizer</span>(file, <span>nil</span>)
    <span>return</span> err
}
</code></pre></div><p>For clarity, <code>badFd</code> is defined as -1, so subsequent attempts to close
an <code>*os.File</code> will do nothing and return <code>syscall.EINVAL</code>. But since
we are ignoring the error from the <code>defer</code>, this doesn’t matter. It’s
not idempotent, exactly, but as Ben put later in the Twitter thread,
it <a href="https://twitter.com/benbjohnson/status/874289044800368640">“won’t blow shit up if you call it
twice.&#34;</a></p><p>The implementation is a good, common-sense one and it seems unlikely
to change in the future and cause problems. But the lack of
documentation about this outcome makes me a little nervous. Maybe a
doc update to codify this behavior would be a good task for Go 1.10.</p><h2 id="update-2">Update 2</h2><p>Closing the file is the last chance the OS has to tell us about
problems, but the buffers are not necessarily going to be flushed when
you close the file. It’s entirely possible that flushing the write
buffer to disk will happen <em>after</em> you close the file, and a failure
there cannot be caught. If this happens, it usually means you have
something seriously wrong, like a failing disk.</p><p>However, you can force the write to disk with the <code>Sync()</code> method on
<code>*os.File</code>, which calls the <code>fsync</code> system call. You should check for
errors from that call, but then I think it’s safe to ignore an error
from <code>Close()</code>. Calling <code>fsync</code> has serious implications on
performance: it’s flushing write buffers out to slow disks. But if
you really, really want the data on disk, the best pattern to follow
is probably:</p><div><pre><code data-lang="go"><span>func</span> <span>helloNotes</span>() <span>error</span> {
    f, err := os.<span>Create</span>(<span>&#34;/home/joeshaw/notes.txt&#34;</span>)
    <span>if</span> err != <span>nil</span> {
        <span>return</span> err
    }
    <span>defer</span> f.<span>Close</span>()

    <span>if</span> err = io.<span>WriteString</span>(f, <span>&#34;hello world&#34;</span>); err != <span>nil</span> {
        <span>return</span> err
    }

    <span>return</span> f.<span>Sync</span>()
}
</code></pre></div></div></div>
  </body>
</html>
