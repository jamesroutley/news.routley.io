<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://proclamations.nebcorp-hias.com/sundries/glome-ing-pt1/">Original</a>
    <h1>Glome-ing the Gossip, part 1: nebkor-maelstrom</h1>
    
    <div id="readability-page-1" class="page"><section>
            
<p><img src="https://proclamations.nebcorp-hias.com/sundries/glome-ing-pt1/./glome-ing_the_gossip.jpg" alt="glome-ing the gossip movie poster" title="glome-ing the gossip movie poster"/></p>
<p>Recently, I started working my way through the <a href="https://fly.io/dist-sys/">Gossip Glomers</a>
distributed system challenges, and as usual wanted to use
<a href="https://www.rust-lang.org/">Rust</a> to do it. There are a few off-the-shelf crates available for
this, but none of them quite hit the spot for me. As a result, I wrote and released a new crate for
writing Maelstrom clients, <a href="https://crates.io/crates/nebkor-maelstrom">nebkor-maelstrom</a>. This
post is going to talk about that; there&#39;s a follow-up post coming soon that will go into my
solutions using it.</p>
<p>Warning: seriously niche content.</p>
<h2 id="why-write-a-new-framework">Why write a new framework?</h2>
<p>First off, what exactly is <a href="https://github.com/jepsen-io/maelstrom">Maelstrom</a>? From the front page
of the Gossip Glomers, it&#39;s a platform that:</p>
<blockquote>
<p>lets you build out a &#39;node&#39; in your distributed system and Maelstrom will handle the routing of
messages between the those nodes. This lets Maelstrom inject failures and perform verification
checks based on the consistency guarantees required by each challenge.</p>
</blockquote>
<p>Maelstrom itself is built on top of <a href="https://jepsen.io/">Jepsen</a>, a framework for testing
and verifying properties of distributed systems. Concretely, it&#39;s a program that you run, giving it
the path to a binary that implements the Maelstrom protocol, along with the name of a &#34;workload&#34;
meant to emulate particular distributed systems. It will then spawn a bunch of copies of the node
that you wrote and start passing it messages, listening for responses, using <code>stdin</code> and <code>stdout</code> as
the network medium:</p>
<p><img src="https://proclamations.nebcorp-hias.com/sundries/glome-ing-pt1/./maelstrom-cloud.png" alt="Maelstrom is the network" title="Maelstrom is the network"/></p>
<p>Each challenge consists of writing a node that implements a single
<a href="https://github.com/jepsen-io/maelstrom/blob/main/doc/workloads.md">workload</a>. There are six
workloads in the Glomers challenges, though ten are available within Maelstrom.</p>
<p>The front page of the challenge goes on to say, &#34;The documentation for these challenges will be in
Go, however, Maelstrom is language agnostic so you can rework these challenges in any programming
language.&#34; They provide packages for <a href="https://github.com/jepsen-io/maelstrom/tree/main/demo">several different
languages</a>, including Rust. So, why something
new?</p>
<p>I actually started out using the crate they include as a demo,
<a href="https://crates.io/crates/maelstrom-node">maelstrom-node</a>. However, it didn&#39;t take too long before I
started chafing at it:</p>
<ul>
<li>there was a lot of boilerplate;</li>
<li>each message type required its own custom data structure;</li>
<li>it used async, which increased both he boilerplate as well as the compile times.</li>
</ul>
<p>So after watching <a href="https://www.youtube.com/watch?v=gboGyccRVXI">Jon Gjengset work through</a> the first
couple challenges while rolling his own Maelstrom support as he went, I decided to do the same,
paying attention to the following characteristics:</p>
<h3 id="minimal-boilerplate">minimal boilerplate</h3>
<p>This is subjective, but the framework is not the solution, and should stay as much out of your way
as possible, while providing the most support. The <code>maelstrom-node</code> crate obligated quite a bit of
ceremony, as you can see from the difference between my &#34;echo&#34; client using it vs. my own. First
off, the client using the off-the-shelf crate:</p>
<pre data-lang="rust"><code data-lang="rust"><span>#[</span><span>tokio</span><span>::</span><span>main</span><span>]
</span><span>async </span><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>let</span><span> handler = Arc::new(Handler::default());
</span><span>    </span><span>let </span><span>_ = Runtime::new()
</span><span>        .</span><span>with_handler</span><span>(handler)
</span><span>        .</span><span>run</span><span>()
</span><span>        .await
</span><span>        .</span><span>unwrap_or_default</span><span>();
</span><span>}
</span></code></pre>
<p>Now with my crate:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>let</span><span> node = Echo;
</span><span>    </span><span>let</span><span> runner = Runner::new(node);
</span><span>    runner.</span><span>run</span><span>(None);
</span></code></pre>
<p>Of course, when the code is that short, it&#39;s hard to appreciate the differences. But the first
version pulled in over over 60 dependencies; the second is half that due to not pulling in
Tokio. Also, the client is responsible for wrapping their node in an <code>Arc</code>, instead of letting the
runtime&#39;s
<a href="https://docs.rs/maelstrom-node/0.1.6/maelstrom/struct.Runtime.html#method.with_handler">runner</a>
take a generic parameter:</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub fn </span><span>with_handler</span><span>(</span><span>self</span><span>, </span><span>handler</span><span>: Arc&lt;dyn Node + Send + Sync&gt;) -&gt; </span><span>Self
</span></code></pre>
<p>vs</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub fn </span><span>new</span><span>&lt;N: Node + </span><span>&#39;static</span><span>&gt;(</span><span>node</span><span>: N) -&gt; </span><span>Self
</span></code></pre>
<p>Another source of boilerplate was the fact that the trait method for handling messages in the first
version has the following signature:</p>
<pre data-lang="rust"><code data-lang="rust"><span>async </span><span>trait </span><span>Node {
</span><span>    async </span><span>fn </span><span>process</span><span>(&amp;</span><span>self</span><span>, </span><span>runtime</span><span>: Runtime, </span><span>req</span><span>: Message) -&gt; Result&lt;()&gt;;
</span><span>}
</span></code></pre>
<p>Notably, <code>&amp;self</code> is immutable, which means that if you need to keep any state in your node, you need
to wrap it in like <code>Arc&lt;Mutex&lt;Vec&lt;_&gt;&gt;</code>, which means your client code is littered with like</p>
<pre data-lang="rust"><code data-lang="rust"><span>// drop into a temp scope so guard is dropped after
</span><span>{
</span><span>   </span><span>let mut</span><span> guard = </span><span>self</span><span>.store.</span><span>lock</span><span>().</span><span>unwrap</span><span>();
</span><span>   guard.</span><span>borrow_mut</span><span>().</span><span>entry</span><span>(key.</span><span>to_string</span><span>()).</span><span>or_insert</span><span>(val);
</span><span>}
</span></code></pre>
<p>My own crate&#39;s <a href="https://docs.rs/nebkor-maelstrom/latest/nebkor_maelstrom/trait.Node.html#tymethod.handle">analogous trait
method</a>
receives as <code>&amp;mut self</code>, so the above just turns into</p>
<pre data-lang="rust"><code data-lang="rust"><span>self</span><span>.store.</span><span>entry</span><span>(key.</span><span>to_string</span><span>()).</span><span>or_insert</span><span>(val);
</span></code></pre>
<p>which is 75% fewer lines.</p>
<p>My most complex client was the one for the <code>kafka</code> workload, at 158 lines; the simplest was for the
<code>echo</code> workload, at 21 lines. All in, the whole count for my Gossip Glomers challenges is:</p>
<pre><code><span>$ wc -l */*/*.rs |sort -n
</span><span>   21 gg-echo/src/main.rs
</span><span>   29 gg-uid/src/main.rs
</span><span>   59 gg-g_counter/src/main.rs
</span><span>  141 gg-txn/src/main.rs
</span><span>  142 gg-broadcast/src/main.rs
</span><span>  158 gg-kafka/src/main.rs
</span><span>  550 total
</span></code></pre>
<h3 id="weak-typing-not-for-production">weak typing/not for production</h3>
<p>The Maelstrom <a href="https://github.com/jepsen-io/maelstrom/blob/main/doc/protocol.md">protocol</a> is
extremely simple. The <a href="https://en.wikipedia.org/wiki/OSI_model#Layer_1:_Physical_layer">physical
layer</a> consists of <code>stdin</code> and
<code>stdout</code> as already mentioned. The wire format is newline-separated JSON objects:</p>
<pre data-lang="jsonnet"><code data-lang="jsonnet"><span>{
</span><span>  &#34;src&#34;:  A string identifying the node this message came from
</span><span>  &#34;dest&#34;: A string identifying the node this message is to
</span><span>  &#34;body&#34;: An object: the payload of the message
</span><span>}
</span></code></pre>
<p>The <code>body</code> is where all the real action is, however:</p>
<pre data-lang="jsonnet"><code data-lang="jsonnet"><span>{
</span><span>  &#34;type&#34;:        (mandatory) A string identifying the type of message this is
</span><span>  &#34;msg_id&#34;:      (optional)  A unique integer identifier
</span><span>  &#34;in_reply_to&#34;: (optional)  For req/response, the msg_id of the request
</span><span>}
</span></code></pre>
<p>A <code>body</code> can also contain arbitrary other keys and values, and each workload has a different set of
them.</p>
<p>A lot of the crates I saw that offered Maelstrom support exposed types like <code>Message&lt;P&gt;</code>, where <code>P</code>
is a generic &#34;payload&#34; parameter for a <code>Body&lt;P&gt;</code>, and would usually be an enum with a specific variant
for each possible message type in the workload.</p>
<p>I totally get where they&#39;re coming from; that kind of strict and strong type discipline is very
on-brand for Rust, and I&#39;m often grateful for how expressive and supportive Rust&#39;s type system is.</p>
<p>But for this, which is a tinkertoy set for building toy distributed systems, I thought it was a bit
much. My types look like this, with no generics:</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub struct </span><span>Message {
</span><span>    </span><span>pub </span><span>src</span><span>: String,
</span><span>    </span><span>pub </span><span>dest</span><span>: String,
</span><span>    </span><span>pub </span><span>body</span><span>: Body,
</span><span>}
</span></code></pre>
<p>In general, you don&#39;t worry about constructing a <code>Message</code> yourself in your handler, you construct a
<code>Body</code> using <code>Body::from_type(&amp;str)</code> and <code>Body::with_payload(self, Payload)</code> builder methods, then
pass that to a <code>send</code> or <code>reply</code> method that adds the <code>src</code> and <code>dest</code>.</p>
<p>The <code>Body</code> is a little more involved, mostly because the <a href="https://git.kittencollective.com/nebkor/nebkor-maelstrom/src/commit/e5150af666e0531a3a1615254718b63df117abb9/src/protocol.rs#L63-L78">Serde attributes double the line
count</a>,
but:</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub struct </span><span>Body {
</span><span>    </span><span>pub </span><span>typ</span><span>: String,
</span><span>    </span><span>pub </span><span>msg_id</span><span>: </span><span>u64</span><span>,
</span><span>    </span><span>pub </span><span>in_reply_to</span><span>: </span><span>u64</span><span>,
</span><span>    </span><span>pub </span><span>payload</span><span>: Payload,
</span><span>    </span><span>// the following are for the case of errors
</span><span>    </span><span>pub </span><span>code</span><span>: Option&lt;ErrorCode&gt;,
</span><span>    </span><span>pub </span><span>text</span><span>: Option&lt;String&gt;,
</span><span>}
</span></code></pre>
<p><code>Payload</code> is a type alias for <code>serde_json::Map&lt;String, serde_json::Value&gt;</code>; it&#39;s decorated with
<code>serde(flatten)</code>, which means, &#34;when serializing, don&#39;t put a literal &#39;payload&#39; field in the JSON,
just put the keys and values from it directly in the body&#34;. When a <code>Body</code> is being deserialized from
JSON, any unknown fields will be put into its <code>payload</code>.</p>
<p>The type of the <code>Body</code>, and hence the <code>Message</code> according to the Maelstrom protocol, is just a
string. When writing your clients, you only have a few possible message types to consider, and
it&#39;s easy and clear to just use bare strings in the places where they&#39;re needed.</p>
<p>I also deliberately ignore whole classes of errors and liberally <code>unwrap()</code> things like channel
<code>send()</code>s and mutex <code>lock()</code>s, because those kinds of errors are out of scope for Maelstrom. If you
can&#39;t get a handle to <code>stdin</code>, there&#39;s nothing you can do, so might as well assume its infallible.</p>
<h3 id="no-async-minimal-dependencies">no async/minimal dependencies</h3>
<p>I&#39;ve already mentioned this, so no real need to go over it again. Async is nice when you need it,
but when you don&#39;t, it&#39;s just more noise. <code>nebkor-maelstrom</code> has only three external deps (which have
their own dependencies, so the full transitive set is 10x this, but still):</p>
<pre data-lang="toml"><code data-lang="toml"><span>[dependencies]
</span><span>serde_json </span><span>= &#34;</span><span>1</span><span>&#34;
</span><span>serde </span><span>= { </span><span>version </span><span>= &#34;</span><span>1</span><span>&#34;, </span><span>default-features </span><span>= </span><span>false</span><span>, </span><span>features </span><span>= [&#34;</span><span>derive</span><span>&#34;] }
</span><span>serde_repr </span><span>= &#34;</span><span>0.1</span><span>&#34;
</span></code></pre>
<h3 id="simple-to-understand">simple to understand</h3>
<p>Finally, I wanted it to be as clean and minimal as possible. The async <code>maelstrom-node</code>
crate, for example, is extremely thorough and featureful, but is well over a
thousand lines of fairly complicated code. <code>nebkor-maelstrom</code>, by contrast, is less than 500 lines
of extremely straightforward code:</p>
<pre><code><span>$ wc -l src/*.rs
</span><span>   81 src/kv.rs
</span><span>  229 src/lib.rs
</span><span>  167 src/protocol.rs
</span><span>  477 total
</span></code></pre>
<p>Something that gave me particular trouble was how to handle RPC, that is, sending and receiving
messages while already handling a message. I faffed around trying to get something with callbacks
working, and then I finally found <a href="https://github.com/rafibayer/maelbreaker">this project</a>,
&#34;Maelbreaker&#34; (note the cool logo!), and copied its <a href="https://github.com/rafibayer/maelbreaker/blob/990a06293ebfbb0f1d5491bcc8a59a3c4d9f9274/src/runtime.rs#L27-L141">IO
system</a>,
which used multi-producer/single-consumer channels to send messages with <code>stdin</code> and <code>stdout</code> from
separate threads. I also stole their idea to <a href="https://git.kittencollective.com/nebkor/nebkor-maelstrom/src/commit/e5150af666e0531a3a1615254718b63df117abb9/src/lib.rs#L126-L137">use MPSC
channels</a>
as the method for getting values returned to the caller while the caller is handling a message already.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>And here we are! All in all, I probably spent about twice as much time writing <code>nebkor-maelstrom</code> as
I did solving the Gossip Glomers challenges, though partly that&#39;s due to the chores associated with
publishing software that other people might plausibly use, and trying to be reasonably decent about
it; things like writing examples and documentation and reviewing it for quality. I also enjoyed
writing it in tandem with the exercises; every bit of functionality was directly motivated by acute need.</p>
<p>So, if you&#39;re thinking about tackling the challenges, and want to do them in Rust, I humbly suggest
checking <code>nebkor-maelstrom</code> out; it&#39;s only a <code>cargo add</code> away!</p>
<hr/>






        </section></div>
  </body>
</html>
