<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dolphin-emu.org/blog/2024/09/04/dolphin-progress-report-release-2407-2409/">Original</a>
    <h1>Dolphin Progress Release 2407 and 2409</h1>
    
    <div id="readability-page-1" class="page"><div>
      <header>
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2409/progressreportheader2409.avif"/> 
<img src="https://dolphin-emu.org/m/user/blog/progress-report/2409/progressreportheader2409-mini.avif"/> 
</header>

<p>After an exciting round of feature articles, it&#39;s Progress Report time once again! However, a lot has changed. Dolphin has finally left the 5.0 era behind, and has entered the <em>Release Era</em>. Not only did we get our first release in eight years, but we also established a commitment to continuous releases going forward.</p>


<p>For the Reports, things will be more or less the same, but with a few changes.</p>
<p>Progress Reports are now also <em>release changelogs</em>. We&#39;ll be going over the notable additions and changes between each release in every Progress Report going forward, rather than within a range of dates. As such, the name of the Reports will reflect the release accompanying it - if you want the new features, just update to the version at the top or higher and you&#39;ll have them! (However, since 2407 had a release article without a changelog, this Report will be covering the changes in both Release 2407 and Release 2409.)</p>
<p>That also means that the next release is happening <em>right now!</em> Accompanying this report is <strong>Dolphin 2409</strong>. It is now rolling out via our updater, and is available for download here on our website.</p>
<p>But there was also another feature article since our last Report. Dolphin now has RetroAchievements support!</p>


<p>For those waiting for it to show up in a release build, the wait is now over.  Throughout the past couple of months, we&#39;ve ironed out one major issue alongside many smaller issues with RetroAchievements.  The first iteration of RetroAchievements in a release build is stable, but not all that flashy.  The groundwork is there for future improvements, but many features and options are yet to be finished.  As well, Android support is still deadlocked with a few issues. Please pardon our progress!</p>
<p>We have a bunch of cool statistics from the RetroAchievements team regarding the launch, however, we need to get on with the Report! So just <a href="#the-first-month-of-dolphin-retroachievements">click this handy link</a> to be taken to the bottom of the Report if you&#39;d like to read more!</p>
<p>But before we get to the Notable Changes, we have a couple of things to cover.</p>
<h3 id="google-play-update-delay"><strong>Google Play Update Delay</strong><a href="#google-play-update-delay" title="Permanent link">¶</a></h3>
<p>Last month, we got a surprise email from Google Play saying that Dolphin doesn&#39;t comply with their policies because it &#34;installs, but doesn&#39;t load&#34;. We have gotten emails like this before regarding Android TV, presumably because someone at Google tried to install Dolphin on one out of the vast majority of Android TV devices that don&#39;t meet Dolphin&#39;s hardware requirements, but this is the first time we&#39;ve gotten a rejection for Android as a whole. Seeing as Dolphin generally does load correctly on devices that are able to install it, we&#39;re not quite sure what happened here.</p>
<p>What does this mean for Dolphin? Dolphin is still available on Google Play, but the next update we release has to be manually checked by Google before it becomes available to users. Because of this, it will take longer than normal for the 2409 release to show up on Google Play, but any updates after that should be smooth sailing again. If you&#39;re impatient and want the latest version of Dolphin right now, it&#39;s available <a href="https://dolphin-emu.org/download/">on this website</a> as always!</p>
<h3 id="visual-studio-twenty-twenty-woes"><strong>Visual Studio Twenty-Twenty-Woes</strong><a href="#visual-studio-twenty-twenty-woes" title="Permanent link">¶</a></h3>
<p>During the rollout of the latest release, a lot of people updated Dolphin for the first time in a while! But for some of our Windows users, when they fired up Dolphin 2407 for the first time they were met <em>with a silent crash</em>. They reached out to us, and the support vanguards on our Discord quickly found a solution - reinstalling the 64-bit Microsoft Visual C++ redistributable for Visual Studio 2022 got Dolphin working for them once again.</p>
<p>We&#39;re not entirely sure why exactly this happened. But we have a theory.</p>
<p><img src="https://dolphin-emu.org/m/user/blog/progress-report/2019-november/visualstudio2019.svg"/>
</p>

<p>The Visual C++ 2022 Redistributable is a runtime library that contains everything needed to run programs compiled with Microsoft Visual Studio 2022. However, Visual Studio 2022 <em>is not static</em>: there are many subversions, and it gets regular updates. These updates <em>should</em> be backwards compatible with any other version of Visual Studio 2022. It would be <strong>madness</strong> to make a change to Visual Studio 2022 that breaks compatibility with Visual Studio 2022&#39;s own runtime libraries. However, Microsoft did exactly that.</p>
<p>In Visual Studio 2022 v17.10.0, Microsoft made a non-backwards compatible change to <code>std::mutex::lock</code>. This was <a href="https://developercommunity.visualstudio.com/t/Access-violation-with-std::mutex::lock-a/10664660">reported to Microsoft</a>, however, the issue report was marked as &#34;Closed - Not a Bug&#34;. Apparently this was intended! </p>
<p>This puts us, as an application that uses Visual Studio, into a weird place. We set up an automated process to update our Visual Studio builder to new subversions as they come out, confident that it will never break anything. It&#39;s just subversions. So we have told our Windows users that all they need to run Dolphin is the Visual C++ 2022 Redistributable, confident that it would work. However, Visual Studio automatically utilized the new version of <code>std::mutex::lock</code> when compiling our Windows builds. If a user is running <em>an older version of the Visual C++ 2022 Redistributable</em> before that new version of <code>std::mutex::lock</code> was implemented, they may download and run our program and see a silent crash. And of course, if we ask them if they are using the Visual C++ 2022 runtime, <em>they&#39;ll say yes</em>, because they have it installed.</p>
<p>According to Microsoft, this is our problem. Their expectation is for applications to be distributed with installers that will include the redistributable and install it with the app if required. However, they hand out the redistributable to users precisely for applications like us that ship without an installer. It&#39;s not like what we&#39;re doing is novel. And perhaps Microsoft should have made it fail in a way that communicates to the user that they need to update the redistributable, instead of just crashing silently? Or perhaps just include the Visual C++ 2022 runtime libraries <em>in Windows Update</em> so every user is guaranteed to have the latest version and applications don&#39;t even need to worry about it?</p>
<p>...Anyway, unfortunately, we don&#39;t have a great solution for this issue. We could disable our automated update process for our Visual Studio builder, but there are security benefits to keeping it, so this is something we&#39;d rather not do. For now, all we can tell our Windows users is that if you run a new version of Dolphin and encounter a crash, redownload and reinstall Visual C++ 2022 Redistributable. As always, we have a link to the redistributable <a href="https://dolphin-emu.org/download/">on our download page</a>.</p>
<p>On a happier note, it&#39;s time for our Notable Changes!</p>
<h3 id="notable-changes"><strong>Notable Changes</strong><a href="#notable-changes" title="Permanent link">¶</a></h3>
<p>All of the changes below are available in Release 2409. </p>
<h4 id="50-21462-windows-remove-rounded-corners-on-emulation-render-window-by-filoppi"><strong><a href="https://dolphin-emu.org/download/dev/master/5.0-21462/">5.0-21462 - Windows: Remove rounded corners on emulation render window</a></strong>  by <strong><a href="https://github.com/Filoppi">Filoppi</a></strong><a href="#50-21462-windows-remove-rounded-corners-on-emulation-render-window-by-filoppi" title="Permanent link">¶</a></h4>
<p>When Windows 11 released in late 2021, it brought the first major visual overhaul to Windows since <a href="https://en.wikipedia.org/wiki/Windows_phone">Windows Phone</a> from 2010. Gone were the sharp edges, bold colours, and dense squares of the <em>Live Tile</em> era, and in their place were soft tones, spacious design, and friendly round edges.</p>
<p>However, as part of this new aesthetic, Windows 11 applies round edges <em>everywhere</em>, even to game windows! Pixels that your computer spent your hard-earned money rendering are now <em>hidden</em> in windowed mode by default.</p>



<p>Recognizing this <em>travesty</em>, <strong><a href="https://github.com/Filoppi">Filoppi</a></strong> came to the rescue and saved our pixels. By configuring <code>DWM_WINDOW_CORNER_PREFERENCE</code> in our Windows builds, all pixels that Dolphin renders (on Windows 11 and in windowed mode) are now once again free to be seen by our illustrious eyeballs.</p>


<p>If only such relief could be bestowed upon our macOS users as well...</p>
<h4 id="balloon-tooltip-quality-of-life-updates-50-21123-50-21635-and-2407-130-by-dentomologist"><strong>Balloon Tooltip Quality of Life Updates</strong> - <a href="https://dolphin-emu.org/download/dev/master/5.0-21123/">5.0-21123</a>, <a href="https://dolphin-emu.org/download/dev/master/5.0-21635">5.0-21635</a>, and <a href="https://dolphin-emu.org/download/dev/master/2407-130/">2407-130</a> by <strong><a href="https://github.com/Dentomologist">Dentomologist</a></strong><a href="#balloon-tooltip-quality-of-life-updates-50-21123-50-21635-and-2407-130-by-dentomologist" title="Permanent link">¶</a></h4>
<p>A few years ago we introduced our <a href="https://dolphin-emu.org/blog/2020/12/10/dolphin-progress-report-october-2020/#50-13163-remove-description-box-in-graphics-tabs-and-use-custom-tooltips-instead-by-iwubcode">custom balloon tooltips</a>. Rather than have a large description area permanently taking up space or a terrible native tooltip defined by the OS, we created our own custom tooltips that gave us the best of both worlds.</p>


<p>They have been serving us well since. However, after they were rolled out for the graphics area of our config, they haven&#39;t really been <em>touched</em> since then. Now that&#39;s changing, and our Balloon Tooltips are finally getting some much needed love and a wider rollout!</p>
<p>First is <a href="https://dolphin-emu.org/download/dev/master/5.0-21123/">5.0-21123</a>, which reworked how they are drawn to resolve <em>many</em> longstanding quibbles with the tooltips.</p>


<p>Next is <a href="https://dolphin-emu.org/download/dev/master/5.0-21635/">5.0-21635</a>, which added tooltips to the Interface tab of Config.</p>


<p>And finally <a href="https://dolphin-emu.org/download/dev/master/2407-130/">2407-130</a>, which rolls out our tooltips to the General tab of Config!</p>


<p><strong><a href="https://github.com/Dentomologist">Dentomologist</a></strong> is still chipping away at the tooltips, so expect them to continue to improve and be applied to more windows over time!</p>
<h4 id="2407-103-cached-interpreter-20-by-mitaclaw"><strong><a href="https://dolphin-emu.org/download/dev/master/2407-103/">2407-103 - Cached Interpreter 2.0</a></strong>  by <strong><a href="https://github.com/mitaclaw">mitaclaw</a></strong><a href="#2407-103-cached-interpreter-20-by-mitaclaw" title="Permanent link">¶</a></h4>
<p>After the merge of &#34;Cached Interpreter 2.0&#34;, we&#39;ve seen some misinformation floating around emulation communities regarding what the cached interpreter is and what this change has brought. So for the Progress Report, we felt it was prudent to take a deep dive, and properly explain a bunch of concepts we&#39;ve been putting off for years now. Strap in everyone, <em>we&#39;re going deep!</em></p>
<hr/>
<p>The primary task of CPU emulation is translation: we take code that was originally designed for a specific type of CPU and translate it into something that a different type of CPU can understand. This is not free. Even ignoring the work involved in the act of translating in and of itself (more on that later), having to account for hardware differences means that the resulting translated code will usually be many times larger and more complex than the original code was on the original hardware. As such, there are many different approaches to CPU emulation.</p>
<p><strong>Interpretation</strong> is the most basic and literal CPU translation method. An interpreter decodes each individual instruction from the emulated architecture (guest), then translates that into the instruction<strong>s</strong> (plural) that allow the host to perform the same work. And yes, it translates <em>one instruction at a time</em>. This is extremely accurate (able to preserve all nuance) and very straightforward, making interpreters the perfect entry point for most emulators and a fallback for other translation methods. However, interpreters are so straightforward that they have barely any wiggle-room for optimization. Interpreters will always be costly.</p>
<p><strong>Recompilation</strong> gives us that wiggle-room. By translating the code in <em>blocks</em> rather than per instruction, recompilers can peek into what the code is doing and reimplement troublesome code in ways that are faster for the host hardware. However, reimplementation often causes inaccuracy, and correcting for that without sacrificing speed leads to ballooning complexity. Making a recompiler both fast <em>and</em> accurate can easily take thousands of hours from passionate engineers.</p>
<p>There are many different types of recompilers, but we&#39;re just going to focus on the primary recompiler type that Dolphin uses: JITs.</p>
<p><strong>Just-In-Time Recompilation</strong> (JIT) recompiles small blocks of code <em>while the program is running</em>. A JIT will fetch blocks of code from the program, analyze and reimplement as much as it can, then pass the JITed code to the host system to be processed and ready <em>just</em> before the program needs to consume those blocks.</p>
<p>&#34;Just-In-Time&#34; is literal.</p>
<p>
<figure>
<video autoplay="" muted="" loop="" playsinline="">
<source src="https://dolphin-emu.org/m/user/blog/progress-report/2409/trainchase-av1.webm" alt="anyminutenow (AV1)" type="video/webm" codecs="av01.0.00M.08, opus"/>
<source src="https://dolphin-emu.org/m/user/blog/progress-report/2409/trainchase-vp9.webm" alt="anyminutenow (VP9)" type="video/webm" codecs="vp9"/>
<source src="https://dolphin-emu.org/m/user/blog/progress-report/2409/trainchase-h264.mp4" alt="anyminutenow (h.264)" type="video/mp4"/>
</video>

<figcaption>This is an accurate representation of how JITs work.</figcaption>
</figure>
</p>

<p>The live analysis that JITs perform is overhead. While modern JITs will mitigate this somewhat by caching JITed code blocks, the analysis is still work, which some other recompilation techniques avoid. However, JITs have many benefits. By recompiling blocks of code while the program is running, JITs are able to adapt to whatever the program is doing and don&#39;t need to rely on assumptions. This allows for maximum optimization potential, even in self-modifying programs!</p>
<hr/>
<p>With that, we&#39;ve covered the two most common CPU emulation techniques. Generally, there is nothing inbetween these two options. Emulator authors make an interpreter first, and use it as a reference for building a recompiler. And that&#39;s it. Recompilers <em>are so much faster</em> than interpreters that making an interpreter faster is largely irrelevant.</p>
<p>There are several reasons for this. For example, interpreters can&#39;t place guest registers into the host registers, so any time the emulated CPU wants to read its registers, an interpreter has to fetch the registers&#39; contents from host system memory, which is <em>two orders of magnitude</em> slower. Also, for Dolphin, our interpreter has the <a href="https://dolphin-emu.org/blog/2016/09/06/booting-the-final-gc-game/#memory-management-unit-emulation">MMU</a> enabled <em>at all times</em>, and the constant memory manipulation is <em>even slower</em> in the interpreter than it is for a JIT!</p>
<p>However, what slows down interpreters the most is <strong>branching</strong>.</p>
<p>In computer science, a <a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a> is the act of diverging from the current flow of instructions. If a CPU is executing instructions sequentially, it can process them <em>very very fast</em>. But if an unpredictable branch occurs, the CPU will need to stop everything, flush all its pipelines, and spend the next 10-20 cycles building them back up again before it can resume processing. Branching is one of the most expensive low level operations in computing! As such, modern CPUs do <em>everything they possibly can</em> to improve branch performance, with branch prediction and speculative branch execution trying to get ahead of any branches and keep the pipelines flowing. These features are so important that improved branch prediction is one of the primary reasons why a 2024 CPU core at 4ghz is faster than a 2004 CPU core at 4ghz. It&#39;s that significant.</p>
<p>By operating on each instruction from the guest, one at a time, an interpreter will need to branch <em>very frequently</em> - several times for even a single instruction. And these branches are usually <em>unpredictable</em>, directly hurting what makes modern CPUs fast. With all factors combined and in a worst case scenario, a single instruction from the guest could take <strong>over a hundred cycles</strong> for our interpreter to decode! This occurs <em>millions of times per second</em>, thrashing our host CPU.</p>
<p>Interpreters are simple, straightforward, and readable, but they are <em>fundamentally inefficient</em>. A recompiler will always be faster, so there is little incentive to make an interpreter faster. Except, perhaps, <em>for fun</em>.</p>


<p>Nine years ago, <a href="https://github.com/degasus">degasus</a> had a fun idea. How fast could an interpreter be made (while still being an interpreter) if we applied a bunch of ideas from JITs? The result of this little experiment was the <em>Cached Interpreter</em>.</p>
<p>With a JIT, code is collected into blocks and recompiled into host-specific <a href="https://en.wikipedia.org/wiki/Machine_code">machine code</a> all together. This allows the JIT to reimplement some of the code to be faster for the host, but also allows the JIT to <em>cache</em> these JITed code blocks, so that any time code is reused, the JIT will just jump to the cache and skip the analysis for a speedup.</p>
<p>Dolphin&#39;s <strong>Cached Interpreter</strong> borrows this idea. Code is collected into blocks exactly like a JIT. However, rather than recompile it into JITed machine code, which is specific to the host and may be reimplemented, the code block is instead translated into an <em>intermediate representation</em> - code which stores the decoded instructions as &#34;commands&#34; that can be compiled into machine code that the host CPU can run.</p>
<p>This benefits our Cached Interpreter in many ways. Just like a JIT, the code blocks can be <em>cached</em>. Any time code reappears, the Cached Interpreter can just reuse the already decoded version in the cache, skipping the decode and all its associated branching. The act of interpreting in blocks rather than per instruction also reduces branching outright, down to roughly one branch per command, and makes branches more predictable too. This also reduces the cost of fetching instructions through the MMU, and brings several other benefits from the JIT, such as <a href="https://dolphin-emu.org/blog/2016/11/01/dolphin-progress-report-october-2016/#idle-skipping-option-removal">Idle Skipping</a>. <span data-toggle="tooltip" data-placement="top" title="Our interpreter supported Idle Skipping when the Cached Interpreter was first implemented, but improvements to idle skipping broke the interpreter&#39;s compatibility with the feature. However, our Cached Interpreter still supports Idle Skipping, largely because of its similarities to our JITs.">*</span></p>
<p>All combined, the Cached Interpreter was over twice as fast as our interpreter when it released! However, it was still an order of magnitude slower than our JITs. For most users, it was more or less irrelevant. However, the Cached Interpreter has found its niches. As it is still an interpreter, it retains the impeccable accuracy that interpreters provide, as well as the ability to run on any architecture - it&#39;s our interpreter, but faster. As such, it has become a useful tool for testing and JIT development. Plus, in <a href="https://dolphin-emu.org/blog/2024/04/30/dolphin-progress-report-february-march-and-april-2024/#why-dolphin-isnt-coming-to-the-ios-app-store">situations where JIT recompilers are unavailable</a>, the substantial speedup versus the standard interpreter is always welcome.</p>
<p>But what if the Cached Interpreter could be taken <em>further?</em></p>


<p>Fast forward to 2024, and <strong><a href="https://github.com/mitaclaw">mitaclaw</a></strong> and <strong><a href="https://github.com/Sam-Belliveau">Sam-Belliveau</a></strong> got into a competition to see just how optimized the Cached Interpreter could be. Eventually they merged their efforts, in what <strong><a href="https://github.com/mitaclaw">mitaclaw</a></strong> dubbed <strong>Cached Interpreter 2.0</strong>.</p>
<p>This change brought <em>many</em> optimizations to the Cached Interpreter, but the biggest change by far was <em>variable sized commands</em>. Previously, the commands inside the Cached Interpreter&#39;s intermediate representation had a fixed size, but <strong><a href="https://github.com/mitaclaw">mitaclaw</a></strong> and <strong><a href="https://github.com/Sam-Belliveau">Sam-Belliveau</a></strong> realized that by allowing the commands to be any size, the most common bookkeeping commands could be bundled together into a single command. This significantly reduces the number of bookkeeping commands in total, further reducing the amount of branching in our Cached Interpreter.</p>
<p>Just how big of an impact could these optimizations have? Let&#39;s get to the numbers!</p>

<p>With a 10 to 25% uplift, the Cached Interpreter is better than ever! It&#39;s also now 3 to 4 times faster than the interpreter, and in games with lots of idle loops to skip, such as <a href="https://wiki.dolphin-emu.org/index.php?title=Cave_Story">Cave Story</a>, Cached Interpreter leaves our interpreter in the dust. However, our JITs are still MUCH faster than in every scenario, so its role in Dolphin is unchanged. The Cached Interpreter still cannot serve as a JIT alternative. And according to <strong><a href="https://github.com/mitaclaw">mitaclaw</a></strong>, further optimizations had a negligible impact on its performance. Dolphin&#39;s Cached Interpreter will likely not see another significant performance bump again.</p>
<p>Nevertheless, for the niches where the Cached Interpreter thrives, it is now faster than it has ever been. </p>
<h4 id="2407-165-macos-embed-the-updater-into-dolphinqts-app-bundle-by-oatmealdome"><strong><a href="https://dolphin-emu.org/download/dev/master/2407-165/">2407-165 -  macOS: Embed the Updater into DolphinQt&#39;s app bundle</a></strong> by <strong><a href="https://github.com/OatmealDome">OatmealDome</a></strong><a href="#2407-165-macos-embed-the-updater-into-dolphinqts-app-bundle-by-oatmealdome" title="Permanent link">¶</a></h4>
<p>One of the best things about macOS is <em>application bundles</em>.</p>
<p>On Windows, programs are largely intended to bring their own dependencies. However, each program will need many different files in many different <em>and bizarre</em> places, so much so that it is standard to ship a <em>dedicated program</em> whose only purpose is to place or remove all of the disparate files an application needs to function. If something goes wrong with this process, <strong>good luck</strong>.</p>
<p>Linux, on the other hand, works more like code - dependencies are separate from the program and should be linked, not duplicated. However, dependencies will need to be installed along with the application, so Linux has package managers to install applications and any dependencies that are needed. While this is certainly better than the backwards-compatibility mess that is Windows, installing a single application in Linux still results in installing lots of things in lots of places.</p>
<p>macOS is different. It has something called <em>application bundles</em>. All apps on macOS (with the exception of command-line tools and scripts) are distributed in the bundle format. Application bundles are really just regular folders that follow a very specific structure with their contents. They allow all of an application&#39;s files and dependencies to be grouped together in a single folder, nice and neat. To the user, however, the bundle is shown as a single icon and they never see or know about all of the files inside. This allows for one of the best things about bundles - the process of installing or uninstalling an app is just... drag and drop. That&#39;s it. And to run the application, just double-click the bundle as if it were the application itself.</p>


<p>However, for the past several years Dolphin on macOS has shipped not one, but two bundles - Dolphin, and Dolphin Updater. The updater didn&#39;t do anything if you double-clicked it, and would just give an error; it was intended to be used only by Dolphin itself. Unfortunately, this has occasionally caused confusion with users. After all, the majority of macOS apps are distributed as a single bundle. Why does Dolphin have two?</p>


<p>Fortunately, this has now been fixed. When creating the main Dolphin bundle during a build, we now insert the updater bundle inside of it! Whenever we need to perform a Dolphin update, we just load the updater bundle from within the main Dolphin bundle, create a copy of it in a separate temporary location, and run that. With this change, the user only ever sees one bundle when installing Dolphin for the first time. Glorious single drag and drop installation has been achieved!</p>


<p><a href="https://dolphin-emu.org/download/dev/master/2407-173/">2407-173</a> removes all remnants of the separate updater bundle if any are present. If you have previously installed both Dolphin and the updater to your Applications folder, by the time you are reading this the separate Dolphin Updater will likely already be gone. If not, update and it will be removed.</p>
<p><em>Note: A bug was fixed in <a href="https://dolphin-emu.org/download/dev/master/2407-111">2407-111</a> which caused the updater to crash on startup on some Macs. If you are using an older build of Dolphin, you may need to update your copy of Dolphin manually first.</em></p>
<h4 id="zelda-hle-pikmin-fixes-2407-177-and-2407-225-by-flacs"><strong>Zelda HLE Pikmin Fixes</strong> - <strong><a href="https://dolphin-emu.org/download/dev/master/2407-177/">2407-177</a></strong> and <strong><a href="https://dolphin-emu.org/download/dev/master/2407-225/">2407-225</a></strong>  by <strong><a href="https://github.com/Tilka">flacs</a></strong><a href="#zelda-hle-pikmin-fixes-2407-177-and-2407-225-by-flacs" title="Permanent link">¶</a></h4>
<p>Audio emulation has gone through an interesting transformation throughout the many eras of Dolphin.  In the release era, HLE (High Level Emulation) audio is pretty much universally used for almost everything.  Over the course of time, almost every gap in accuracy between HLE and the more in-depth LLE (Low-Level Emulation) has been closed up.  Infamous HLE audio bugs like the screeching in <a href="https://wiki.dolphin-emu.org/index.php?title=Star_Wars_Rogue_Squadron_II:_Rogue_Leader">Star Wars: Rogue Squadron</a> games?  Solved.  The Grand Star hang in <a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Galaxy">Super Mario Galaxy</a>?  Long gone.  </p>
<p>It has been a massive struggle to get HLE audio to this point.  Back in the old days, you had a choice to make - potentially broken audio (or even no audio in some games!) with HLE, or deal with the massive performance demand that came with getting proper audio using LLE.  This all started to change back in the 3.5 era, when massive rewrites hit Dolphin&#39;s audio code.</p>
<p>Why does this all matter?  Well, users didn&#39;t like LLE audio, and these massive rewrites to HLE audio had tons of benefits.  The problem with HLE audio is that Dolphin has to correctly handle the functions of every revision of every microcode in order for things to work.  <a href="https://wiki.dolphin-emu.org/index.php?title=Pikmin">Pikmin</a> and <a href="https://wiki.dolphin-emu.org/index.php?title=Pikmin_2">Pikmin 2</a> use what we call the &#34;Zelda Microcode&#34;.  This microcode is used in games like <a href="https://wiki.dolphin-emu.org/index.php?title=The_Legend_of_Zelda:_The_Wind_Waker">the</a> <a href="https://wiki.dolphin-emu.org/index.php?title=The_Legend_of_Zelda:_Four_Swords_Adventures">Zelda</a> <a href="https://wiki.dolphin-emu.org/index.php?title=The_Legend_of_Zelda:_Twilight_Princess">games</a> (except <a href="https://wiki.dolphin-emu.org/index.php?title=The_Legend_of_Zelda:_Skyward_Sword">Skyward Sword</a>), <a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Sunshine">the</a> <a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Galaxy">Super</a> <a href="https://wiki.dolphin-emu.org/index.php?title=Super_Mario_Galaxy_2">Mario</a> games and <a href="https://wiki.dolphin-emu.org/index.php?title=Luigi%27s_Mansion">Luigi&#39;s Mansion</a>.</p>
<p>The problem with this is that <em>pretty much every game</em> uses a different version of the microcode.  This meant that in order to emulate <em>each game</em>, you had to figure out what functions they supported, and how to emulate them correctly.  For example, all of the microcode revisions will have functions to control volume, but earlier microcodes might have bugs that need to be emulated, later microcodes might have additional features, like controlling volume individually for different things.  Apply this to <em>everything</em>, and it becomes apparent how much of a pain in the rear this can be.</p>
<p>In order to get these massive rewrites merged, support for each individual microcode wasn&#39;t necessarily perfect.  Upon testing, the games sounded mostly correct, and the various problems of old-HLE audio were fixed.  However, there were minor issues spread across the various games.  Originally, New-Zelda-HLE had issues with the volume of echoes in <a href="https://wiki.dolphin-emu.org/index.php?title=Mario_Kart:_Double_Dash%E2%80%BC">Mario Kart: Double Dash</a>.  This was a known issue when it was merged, but was deemed acceptable due to all the other improvements.</p>
<p>The only difference between that and <a href="https://wiki.dolphin-emu.org/index.php?title=Pikmin">Pikmin</a> and <a href="https://wiki.dolphin-emu.org/index.php?title=Pikmin_2">Pikmin 2</a> is that their small issues seemed like they were never going to be addressed.  In fact, most users didn&#39;t even realize there was a problem.  They were by and large playable, and unless you played the game recently on console, you wouldn&#39;t know that some menu sounds were the wrong pitch, or there were missing sounds for puffs of smoke in the opening cutscene.  Thankfully, when New-Zelda-HLE was merged, the issues we did discover were archived, and <strong><a href="https://github.com/Tilka">flacs</a></strong> saw them and investigated them while looking for more audio issues to fix.</p>


<p>These may seem minor, but back in the day there were hundreds of issues like these due to HLE audio&#39;s imperfect emulation of the microcode.  It seems almost surreal that, in most cases, HLE audio and LLE audio are now indistinguishable.</p>
<h4 id="2407-228-videocommon-force-display-list-alignment-by-flacs"><strong><a href="https://dolphin-emu.org/download/dev/master/2407-228/">2407-228 - VideoCommon: Force Display List Alignment</a></strong>  by <strong><a href="https://github.com/Tilka">flacs</a></strong><a href="#2407-228-videocommon-force-display-list-alignment-by-flacs" title="Permanent link">¶</a></h4>
<p>Once upon a time, Dolphin bugs were obvious: a simple <em>screenshot</em> was all it took to convey just how broken Dolphin was in a particular title. <a href="https://www.youtube.com/watch?v=2jta4PkYBRk">Grey Zelda</a>, <a href="https://dolphin-emu.org/blog/2014/09/30/dolphin-progress-report-september-2014/#40-3194-fioras-fantastic-faster-mmu-by-fiora">Spider-man as a flying box</a>, <a href="https://dolphin-emu.org/m/user/blog/progress-report/2409/DearGod.webp">uwu Kirby</a>, <a href="https://dolphin-emu.org/m/user/blog/progress-report/september-2014/batman-the-flying-crotch.png">Batman as a flying crotch</a>, on and on. However, once Dolphin&#39;s fundamental inaccuracies were resolved in the 3.5 and 4.0 eras, that largely became a thing of the past. Today, we have to use fifologs and automation to catch changes, and carefully pixel-peep against console to verify that something is in fact actually incorrect.</p>
<p><a href="https://wiki.dolphin-emu.org/index.php?title=Wallace_%26_Gromit_in_Project_Zoo">Wallace and Gromit in Project Zoo</a> bucks this trend. The game&#39;s shadows looked fairly good on console, but in Dolphin?  <strong>They could ƒ^&amp;%ing explode.</strong></p>


<p>We had no idea why the shadows in this fairly obscure game would sometimes fail so catastrophically, but something was clearly very wrong, so in 2013 we added a patch to <em>remove these shadows from the game.</em> It was an extreme solution, but the game had an extreme problem, so we did what we could to at least make the game playable. It was certainly better than the video above. But as time passed, the developers who investigated the problem moved on, and these troublesome shadows slowly faded from memory...</p>


<p><strong>Ten years later</strong>, <strong><a href="https://github.com/Tilka">flacs</a></strong> happened to notice that Project Zoo&#39;s shadows were still broken, and looked into the issue. They soon spotted something suspicious: the game&#39;s <a href="https://www.songho.ca/opengl/gl_displaylist.html">display list</a> (a group of GPU commands stored for later execution) wasn&#39;t aligned. Rather than prevaricate about the bush,  <strong><a href="https://github.com/Tilka">flacs</a></strong> went straight to hardware testing and quickly adapted the <a href="https://github.com/devkitPro/gamecube-examples/tree/master/graphics/gx/triangle">triangle test homebrew</a> to use display lists.</p>
<p>Turns out that hunch was spot on target! <a href="https://wiki.dolphin-emu.org/index.php?title=Wallace_%26_Gromit_in_Project_Zoo">Wallace and Gromit in Project Zoo</a> submits display lists unaligned, and Dolphin was erroneously processing them exactly as they were submitted.  The hardware aligns the memory address by dropping its lower bits.  So for example, the game would point toward 0x80fc9b04, and Dolphin would start executing from there (getting bad opcodes) when hardware would <em>drop</em> the lowest 5 bits as it was 32-byte aligned and start at 0x80fc9b00. By not forcing alignment, Dolphin thought the game wanted to render <em>random garbage</em> and told the GPU driver to render it, which the GPU driver would try its best to do. Sometimes this only resulted in minor visual bugs, other times it would utterly explode as shown above.</p>
<p>With a very small change to Dolphin, we can now render these shadows just fine, and yet another hardware quirk is being emulated correctly.</p>


<h4 id="2407-236-android-fix-and-enable-input-device-sensor-input-by-josjuice"><strong><a href="https://dolphin-emu.org/download/dev/master/2407-236/">2407-236 - Android: Fix and enable input device sensor input</a></strong>  by <strong><a href="https://github.com/JosJuice">JosJuice</a></strong><a href="#2407-236-android-fix-and-enable-input-device-sensor-input-by-josjuice" title="Permanent link">¶</a></h4>
<p><img src="https://dolphin-emu.org/m/user/blog/progress-report/2017-april/android-logo-peeking.png"/></p>

<p>Last year, <strong><a href="https://github.com/JosJuice">JosJuice</a></strong> <a href="https://dolphin-emu.org/blog/2023/05/21/dolphin-progress-report-february-march-april-2023/#50-18920-rewrite-android-input-handling-by-josjuice">rewrote our Android controller input handling from scratch</a>. This rewrite replaced the old Java input handler with a brand new one written in C++ that more closely matched how Dolphin&#39;s PC input handlers work. Not only did this clean up some crusty old code with known problems, but it also unlocked dozens of &#34;new&#34; features for our Android users that were previously only in our desktop builds!</p>
<p>However, one very significant feature that was a part for that overhaul last year was disabled when the overhaul eventually landed - sensor input (accelerometers and gyroscopes) from external controllers, a feature available in Android 12 and up. During the final testing of the input rewrite, <strong><a href="https://github.com/JosJuice">JosJuice</a></strong> received reports that using controller sensors could make Dolphin crash when navigating between screens. Because their phone was stuck on Android 11, they couldn&#39;t test the feature themselves, and decided that rather than hold off the rewrite to address the issue, it was best to just disable external sensors for the time being and continue the rollout without it.</p>
<p>With over a year passed since then, <strong><a href="https://github.com/dreamsyntax">dreamsyntax</a></strong> showed up with not only willingness to investigate the crash, but also the needed hardware. The first step: Finding out why the crash is happening. The reports from a year prior included a stack trace showing where in the code the crash occurred, and <strong><a href="https://github.com/JosJuice">JosJuice</a></strong> had used this information to theorize that when Dolphin turned off unused sensors to save battery, Android would start notifying Dolphin about a sensor that Dolphin never had asked to be notified about. <strong><a href="https://github.com/dreamsyntax">dreamsyntax</a></strong> was able to replicate the crash and get a match stack trace, and then managed to take a step beyond the old investigation by figuring out the root cause of the crash. The sensor that Dolphin didn&#39;t recognize wasn&#39;t actually a new sensor - it was a new object representing the same sensor as before. The cause of the bug was that Dolphin checked if two sensor objects were literally the same object (<em>referential equality</em>) rather than checking if the objects had the same content (<em>structural equality</em>).</p>
<p>With that, it was time for the second step: Properly fixing the issue. <strong><a href="https://github.com/dreamsyntax">dreamsyntax</a></strong> began by making a quick solution to check that their approach was correct, but alas, Dolphin was still crashing! It turned out there was a <em>second crash</em> that nobody had discovered until now because the other crash always happened first! Somewhere within the code of Android itself, a <code>ConcurrentModificationException</code> was being thrown when Dolphin turned sensors off. <strong><a href="https://github.com/dreamsyntax">dreamsyntax</a></strong> couldn&#39;t quite make sense of why this was happening, but with all the information he had gathered, <strong><a href="https://github.com/JosJuice">JosJuice</a></strong> once again stepped into the picture. They discovered that the cause of the crash was a simple coding mistake in the operating system itself - <a href="https://cs.android.com/android/_/android/platform/frameworks/base/+/389eed52e469cadfc704708e10ddeec77ea807ae:core/java/android/hardware/input/InputDeviceSensorManager.java;l=285">removing objects from a list while looping through the list</a> - and implemented a workaround for this crash and a proper solution for the earlier crash. Finally, <strong><a href="https://github.com/dreamsyntax">dreamsyntax</a></strong> tested the change to make sure motion controls were now working properly.</p>
<p>With the issues now solved, sensors from external controllers are available for mapping in Dolphin on Android! The sensors in controllers such as the DualShock 4 can now be used to better emulate motion in Dolphin. Keep in mind that the feature only works for controllers your version of Android has sensor support for. If you&#39;re using Android 11 or older, sensors aren&#39;t supported for any controllers at all.</p>
<h3 id="last-months-contributors"><strong>Last Month&#39;s Contributors...</strong><a href="#last-months-contributors" title="Permanent link">¶</a></h3>
<p>Special thanks to <a href="https://github.com/dolphin-emu/dolphin/graphs/contributors?from=2024-05-01&amp;to=2024-09-04&amp;type=c">all of the contributors</a> that incremented Dolphin 349 commits in the final days of the 5.0 era, and 279 commits after Release 2407! </p>
<h3 id="the-first-month-of-dolphin-retroachievements"><strong>The First Month of Dolphin RetroAchievements</strong><a href="#the-first-month-of-dolphin-retroachievements" title="Permanent link">¶</a></h3>
<p>The RetroAchievements team has shared with us a bunch of statistics for the first month of RetroAchievement support in Dolphin! And there&#39;s a lot of interesting bits in here. Enjoy!</p>
<center>
<h4 id="general-statistics"><strong>General Statistics</strong><a href="#general-statistics" title="Permanent link">¶</a></h4>
<p><strong>Total Unlocks: 860,290</strong></p>
<p><strong>Total Hardcore Unlocks: 815,944</strong></p>
<p><strong>Total Points Earned: 5,864,862</strong></p>
<p><strong>Total Hardcore Points Earned: 5,558,151</strong></p>
<p><strong>Total Sessions: 284,432</strong></p>
<h4 id="top-ten-games-with-the-most-players"><strong>Top Ten Games with the Most Players</strong><a href="#top-ten-games-with-the-most-players" title="Permanent link">¶</a></h4>
<table>
<thead>
<tr>
<th>Game</th>
<th>Players</th>
</tr>
</thead>
<tbody>
<tr>
<td>Super Mario Sunshine</td>
<td>2532</td>
</tr>
<tr>
<td>Super Smash Bros. Melee</td>
<td>2230</td>
</tr>
<tr>
<td>Mario Kart: Double Dash!!</td>
<td>1908</td>
</tr>
<tr>
<td>Luigi&#39;s Mansion</td>
<td>1148</td>
</tr>
<tr>
<td>Legend of Zelda, The: The Wind Waker</td>
<td>1084</td>
</tr>
<tr>
<td>WarioWare, Inc.: Mega Party Games!</td>
<td>946</td>
</tr>
<tr>
<td>Kirby Air Ride</td>
<td>893</td>
</tr>
<tr>
<td>Legend of Zelda, The: Twilight Princess</td>
<td>888</td>
</tr>
<tr>
<td>Animal Crossing</td>
<td>847</td>
</tr>
<tr>
<td>Pikmin</td>
<td>758</td>
</tr>
</tbody>
</table>
<h4 id="top-ten-most-mastered-games"><strong>Top Ten Most Mastered Games</strong><a href="#top-ten-most-mastered-games" title="Permanent link">¶</a></h4>
<table>
<thead>
<tr>
<th>Game</th>
<th>Masteries</th>
</tr>
</thead>
<tbody>
<tr>
<td>Super Mario Sunshine</td>
<td>284</td>
</tr>
<tr>
<td>Piglet&#39;s Big Game</td>
<td>195</td>
</tr>
<tr>
<td>Magical Mirror Starring Mickey Mouse</td>
<td>172</td>
</tr>
<tr>
<td>Pokemon Channel</td>
<td>163</td>
</tr>
<tr>
<td>~Hack~ Samus Goes to the Fridge to Get a Glass of Milk 3D</td>
<td>152</td>
</tr>
<tr>
<td>Winnie the Pooh&#39;s Rumbly Tumbly Adventure</td>
<td>144</td>
</tr>
<tr>
<td>~Hack~ Luigi&#39;s Mansion Beta Restoration</td>
<td>140</td>
</tr>
<tr>
<td>Legend of Zelda, The: The Wind Waker</td>
<td>120</td>
</tr>
<tr>
<td>Wario World</td>
<td>112</td>
</tr>
<tr>
<td>WarioWare, Inc.: Mega Party Games!</td>
<td>101</td>
</tr>
</tbody>
</table>
<h4 id="top-ten-most-beaten-games"><strong>Top Ten Most Beaten Games</strong><a href="#top-ten-most-beaten-games" title="Permanent link">¶</a></h4>
<table>
<thead>
<tr>
<th>Game</th>
<th>Times Beaten</th>
</tr>
</thead>
<tbody>
<tr>
<td>Super Mario Sunshine</td>
<td>626</td>
</tr>
<tr>
<td>WarioWare, Inc.: Mega Party Games!</td>
<td>551</td>
</tr>
<tr>
<td>Luigi&#39;s Mansion</td>
<td>505</td>
</tr>
<tr>
<td>Super Smash Bros. Melee</td>
<td>339</td>
</tr>
<tr>
<td>Dance Dance Revolution: Mario Mix</td>
<td>305</td>
</tr>
<tr>
<td>Pokemon Channel</td>
<td>297</td>
</tr>
<tr>
<td>Mario Kart: Double Dash!!</td>
<td>297</td>
</tr>
<tr>
<td>Pikmin</td>
<td>273</td>
</tr>
<tr>
<td>Legend of Zelda, The: The Wind Waker</td>
<td>243</td>
</tr>
<tr>
<td>Naruto: Clash of Ninja</td>
<td>232</td>
</tr>
</tbody>
</table>
</center>


<!-- tooltip code below -->







    
    
    

    </div></div>
  </body>
</html>
