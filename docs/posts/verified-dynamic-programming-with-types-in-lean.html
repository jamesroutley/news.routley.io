<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tannerduve.github.io/blog/memoization-sigma/">Original</a>
    <h1>Verified dynamic programming with Σ-types in Lean</h1>
    
    <div id="readability-page-1" class="page"><div><header><p><i aria-hidden="true"></i> 17 minute read</p><p><strong><i aria-hidden="true"></i> Published:</strong> <time datetime="2025-05-21T00:00:00+00:00">May 21, 2025</time></p></header><section itemprop="text"><h2 id="1-introduction">1. <a name="Introduction"></a>Introduction</h2><p>If you’ve taken an algorithms class, you have likely seen dynamic programming, specifically a technique called <em>memoization</em>. Memoization works to optimize recursive algorithms by <em>caching</em> the solutions to subproblems in a table, and when a subproblem is encountered, it queries the table instead of recomputing the solution. This gives us an exponential performance boost.</p><p>This blog post will show how to solve a dynamic programming problem using memoization in Lean, and verify its correctness against a specification. The technique used in the proof of correctness here is an interesting application of Lean’s dependent types, and is generalized to work for any memoization algorithm. The idea came from a conversation with <a href="https://gasstationmanager.github.io">GasStationManager</a> over at the <a href="https://leanprover.zulipchat.com">Lean Zulip chat</a>, who I credit with coming up with the general technique.</p><p>This should be pretty beginner friendly. Basic data structures+algorithms at the undergrad level. Lean experience is not necessary but is helpful for following code samples.</p><!-- vscode-markdown-toc --><h2 id="table-of-contents">Table of Contents</h2><ol><li><a href="#Introduction">Introduction</a></li><li><a href="#Problem">Problem</a></li><li><a href="#FirstSolution">First Solution</a></li><li><a href="#Sigma">Type Theory Interlude: Subtypes and Dependent Pairs</a></li><li><a href="#Solution">Improved Solution</a></li><li><a href="#Conclusion">Conclusion</a></li><li><a href="#Exercises">Exercises</a></li><li><a href="#References">References</a></li></ol><!-- vscode-markdown-toc-config numbering=true autoSave=true /vscode-markdown-toc-config --> <!-- /vscode-markdown-toc --><h2 id="2-problem">2. <a name="Problem"></a>Problem</h2><p>The problem we will be working on here is called <a href="https://www.hackerearth.com/practice/algorithms/dynamic-programming/state-space-reduction/practice-problems/algorithm/bytelandian-gold-coins/">Bytelandian Gold Coins</a>. The problem description is as follows:</p><blockquote><p>In Byteland they have a very strange monetary system. Each Bytelandian gold coin has an integer number written on it. A coin n can be exchanged in a bank into three coins: n/2, n/3 and n/4. But these numbers are all rounded down (the banks have to make a profit).</p><p>You can also sell Bytelandian coins for American dollars. The exchange rate is 1:1. But you can not buy Bytelandian coins. You have one gold coin. What is the maximum amount of American dollars you can get for it?</p></blockquote><p>The solution is classic DP. Observe that for any amount up to 8, we can’t get more money by dividing into $n/2, n/3, n/4$. For any value, the minimum amount we can get out of it is $n$. We will compare this value with the value we get after dividing $n$ and select the bigger value.</p><h2 id="3-first-solution">3. <a name="FirstSolution"></a>First Solution</h2><p>The solution is given by the following recurrence relation :</p>\[f(n)= \begin{cases} n, &amp; n \le 8,\\[6pt] \displaystyle \max\!\bigl(n,\; f(\lfloor n/2\rfloor)+f(\lfloor n/3\rfloor)+f(\lfloor n/4\rfloor)\bigr), &amp; n&gt;8. \end{cases}\]<p>Before writing any code, here is the header we’ll want to use:</p><div><div><pre><code><span>import</span> <span>Std</span><span>.</span><span>Data</span><span>.</span><span>HashMap</span>
<span>open</span> <span>Std</span>
</code></pre></div></div><p>We define the recurrence in Lean as follows:</p><div><div><pre><code><span>def</span> <span>maxDollars_spec</span> (<span>n</span> : <span>Nat</span>) : <span>Nat</span> :=
  <span>if</span> <span>n</span> <span>≤</span> <span>8</span> <span>then</span><span>
  -- Base case: for `n ≤ 8`, it&#39;s better to sell the coin directly.</span>
    <span>n</span>
  <span>else</span><span>
  -- Recursive case: choose the maximum between selling the coin directly and exchanging it.</span>
    <span>max</span> <span>n</span> (<span>maxDollars_spec</span> (<span>n</span> <span>/</span> <span>2</span>) <span>+</span> <span>maxDollars_spec</span> (<span>n</span> <span>/</span> <span>3</span>) <span>+</span> <span>maxDollars_spec</span> (<span>n</span> <span>/</span> <span>4</span>))
</code></pre></div></div><p>This directly computes the maximum earnable amount. We will use this as our specification for proving our memoized solution is correct.</p><p>Now here is a memoized solution:</p><div><div><pre><code><span>def</span> <span>maxDollarsMemo</span> (<span>n</span> : <span>Nat</span>) : <span>Nat</span> :=
  <span>let</span> <span>rec</span> <span>helperMemo</span> : <span>Nat</span> <span>→</span> <span>HashMap</span> <span>Nat</span> <span>Nat</span> <span>→</span> <span>Nat</span> <span>×</span> <span>HashMap</span> <span>Nat</span> <span>Nat</span>
    <span>|</span> <span>n</span>, <span>memo</span> <span>=&gt;</span>
      <span>match</span> <span>memo</span><span>.</span><span>get</span><span>?</span> <span>n</span> <span>with</span>
      <span>|</span> <span>some</span> <span>v</span> <span>=&gt;</span> (<span>v</span>, <span>memo</span>)  <span>-- already cached</span>
      <span>|</span> <span>none</span> <span>=&gt;</span>
        <span>if</span> <span>n</span> <span>≤</span> <span>8</span> <span>then</span><span>          -- base case: sell coin directly</span>
          <span>let</span> <span>memo</span><span>&#39;</span> := <span>memo</span><span>.</span><span>insert</span> <span>n</span> <span>n</span>
          (<span>n</span>, <span>memo</span><span>&#39;</span>)
        <span>else</span><span>
          -- recursive: compute best exchange value, memoizing along the way</span>
          <span>let</span> (<span>v1</span>, <span>memo1</span>) := <span>helperMemo</span> (<span>n</span> <span>/</span> <span>2</span>) <span>memo</span>
          <span>let</span> (<span>v2</span>, <span>memo2</span>) := <span>helperMemo</span> (<span>n</span> <span>/</span> <span>3</span>) <span>memo1</span>
          <span>let</span> (<span>v3</span>, <span>memo3</span>) := <span>helperMemo</span> (<span>n</span> <span>/</span> <span>4</span>) <span>memo2</span>
          <span>let</span> <span>best</span> := <span>max</span> <span>n</span> (<span>v1</span> <span>+</span> <span>v2</span> <span>+</span> <span>v3</span>)
          <span>let</span> <span>memo</span><span>&#39;</span> := <span>memo3</span><span>.</span><span>insert</span> <span>n</span> <span>best</span>
          (<span>best</span>, <span>memo</span><span>&#39;</span>)
  (<span>helperMemo</span> <span>n</span> (<span>HashMap</span><span>.</span><span>emptyWithCapacity</span>))<span>.</span><span>fst</span>
</code></pre></div></div><p>This function defines a helper which caches the solutions to subproblems in a hashmap and at each recursive call, queries the hashmap for a stored value. It then calls the helper on the empty map and returns the <code>n</code>th value <em>(Exercise : Rewrite this using a state monad to simulate mutating the hashmap instead of passing around a new one with each insertion)</em></p><p>Now our correctness claim is as follows:</p><div><div><pre><code><span>theorem</span> <span>memo_correct</span> : <span>∀</span> (<span>n</span> : <span>ℕ</span>), <span>maxDollarsMemo</span> <span>n</span> <span>=</span> <span>maxDollarsSpec</span> <span>n</span>
</code></pre></div></div><p>That is, our memoized solution computes the recurrence correctly on every $n \in \mathbb{N}$. Trying to prove this ends up being <em>very</em> difficult. I invite the reader to try it out themselves and see where you get stuck. A good prover may figure it out. I attempted strong induction on $n$ to no avail and trying various approaches I kept getting stuck. The direct proof is indeed possible but the statement feels far too intuitively true to be worth this much effort. The key realization here as to what makes this proof difficult is that correctness relies on invariant properties of the data structure which we store our values in.</p><p>First off, we need to prove that the HashMap correctly computes subproblems, that is, that <code>get? x</code> always returns either <code>none</code> or a value which is equal to <code>maxDollars_spec x</code>. We also rely on the invariant that if the HashMap satisfies this property before the call to <code>helperMemo</code>, then it satisfies this property after the call to <code>helperMemo</code>. To prove this requires reasoning about the body of <code>helperMemo</code>.</p><p>There’s a lot of logic to juggle here in our proof, but thankfully there is a better way. A Haskeller is likely familiar with the notion of refinement types. In Lean we call them subtypes. Subtypes provide a way to attach logical properties to data using a familiar set-builder-like notation, where we can refer to the type of all elements of some type <code>T</code> for which a particular property holds. An example of a subtype is <code>{n : ℕ // Even n}</code> - the subtype of <code>ℕ</code> consisting of all of the Even natural numbers. This is all just syntactic sugar for a dependent pair type, aka $\Sigma$-types. Let’s explore these some more before moving on.</p><h2 id="4-type-theory-interlude-subtypes-and-dependent-pairs">4. <a name="Sigma"></a>Type Theory Interlude: Subtypes and Dependent Pairs</h2><p>This section is a brief detour into the theory of Lean’s subtypes. This is optional but I find it valuable. In dependent type theory, $\Sigma$-types are a generalization of a product type, where the type of the second element in a pair can <em>depend</em> on the value of the first element. In a non-dependent setting, the product $A \times B$ of two types $A$ and $B$ consists of all pairs $(a, b)$ where $a : A$ and $b : B$ - it’s just the standard cartesian product. The dependent pair type generalizes this.</p><p>Suppose we have a type $A$ and a <em>family of types indexed by $A$</em>, denoted $B : A \to \mathcal{U}$ (where $\mathcal{U}$ denotes the universe of all types). Then the type $\sum_{(x : A)}B(x)$ consists of the pairs $(a, b)$ where $a : A$ and $b : B(a)$ - the <em>type</em> of $b$ <em>depends</em> on the <em>value</em> of $a$. Note that the Cartesian product is exactly the special case where $B$ is constant, ie $\displaystyle\sum_{(x : A)}B = A \times B$.</p><p>Back to the original example, let’s think about <code>{n : ℕ // Even n}</code> in these terms. Under the <a href="https://en.wikipedia.org/wiki/Curry–Howard_correspondence">propositions-as-types</a> principle, the proposition <code>Even n</code> is of course just a type. But note that <code>Even n</code> is a <em>different</em> proposition for every <code>n : ℕ</code> - that is, <code>Even</code> is a <em>family</em> of types <em>indexed</em> by <code>ℕ</code>. So, the type <code>{n : ℕ // Even n}</code> is exactly the $\Sigma$-type $\sum_{n : \mathbb{N}}\text{Even}(n)$, which consists of pairs $(n, P_n)$, where $P_n$ is a <em>proof</em> that $n$ is Even.</p><p>For a primer on dependent type theory, see chapter 1 of <a href="https://www.cs.uoregon.edu/research/summerschool/summer14/rwh_notes/hott-book.pdf">HoTT</a></p><h2 id="5-improved-solution">5. <a name="Solution"></a>Improved Solution</h2><p>Now that we’ve introduced subtypes we will put them to use by writing a new memoized algorithm that, in some sense, proves itself. Remember part of our correctness proof is showing that the HashMap’s <code>get? x</code> method always returns a <code>y</code> such that <code>maxDollars_spec x = y</code>. What if, to guarantee this, we write a new version of <code>get?</code> so that <code>get? x</code> returns a <code>y</code> in the subtype <code>{y : ℕ // maxDollars_spec x = y}</code>? To do this, we can just subtype the data which our HashMap stores.</p><p>For the memoization, the property we want to hold is: for a pair <code>(k, v)</code> stored in your table, <code>f k = v</code> where <code>f</code> is the recursive function you are proving equivalence to (in our case, <code>f</code> is the the recurrence <code>maxDollars_spec</code>).</p><p>Now the implementation is as follows. We begin with a very general definition: a pair of values with a property attached to it:</p><div><div><pre><code><span>def</span> <span>cell</span> (<span>f</span> : α <span>→</span> β) := <span>{</span><span>c</span>: α <span>×</span> β <span>//</span> <span>f</span> <span>c</span><span>.</span><span>fst</span> <span>=</span> <span>c</span><span>.</span><span>snd</span><span>}</span>
</code></pre></div></div><p>That is, given a function <code>f : α → β</code>, for example the recurrence <code>maxDollars_spec</code> above, <code>cell f</code> is the type of all pairs <code>(a, b) : α × β</code> such that <code>f a = b</code></p><p>Our new HashMap, <code>PropMap</code>, stores keys of type <code>α</code> and values of type <code>cell f</code> whose first element is equal to the key:</p><div><div><pre><code><span>abbrev</span> <span>PropMap</span> [<span>BEq</span> α][<span>Hashable</span> α] [<span>LawfulBEq</span> α] (<span>f</span> : α <span>→</span> β) :=
  <span>HashMap</span> α (<span>cell</span> <span>f</span>)
</code></pre></div></div><p>Now we can define <code>get?</code> with the guarantee we are looking for:</p><div><div><pre><code><span>def</span> <span>PropMap_get</span><span>?</span> [<span>BEq</span> α][<span>Hashable</span> α] [<span>LawfulBEq</span> α] (<span>ft</span> : α <span>→</span> β) (<span>hm</span> : <span>PropMap</span> <span>ft</span>) (<span>a</span> : α) : <span>Option</span> <span>{</span> <span>b</span> : β <span>//</span> <span>ft</span> <span>a</span> <span>=</span> <span>b</span> <span>}</span> :=
  <span>match</span> <span>hf</span> : <span>hm</span><span>.</span><span>get</span><span>?</span> <span>a</span> <span>with</span><span>  -- Attempt to get the value associated with `a` in the map.</span>
  <span>|</span> <span>none</span> <span>=&gt;</span> <span>none</span><span>            -- If not found, return `none`.</span>
  <span>|</span> <span>some</span> <span>x</span> <span>=&gt;</span>
    <span>if</span> <span>heq</span> : <span>a</span> <span>==</span> <span>x</span><span>.</span><span>val</span><span>.</span><span>fst</span> <span>then</span><span>  -- Check if the key `a` matches `x.val.fst`.</span>
      <span>have</span> : <span>ft</span> <span>a</span> <span>=</span> <span>x</span><span>.</span><span>val</span><span>.</span><span>snd</span> := <span>by</span>
        <span>have</span> <span>hx</span> := <span>x</span><span>.</span><span>property</span><span>       -- Extract the proof that `ft x.val.fst = x.val.snd`.</span>
        <span>rw</span> [<span>beq_iff_eq</span>] <span>at</span> <span>heq</span><span>      -- Propositional equality from boolean equality</span>
        <span>rw</span> [<span>←</span> <span>heq</span>] <span>at</span> <span>hx</span><span>            -- Replace `x.val.fst` with `a` using `heq`.</span>
        <span>exact</span> <span>hx</span><span>                    -- Conclude that `ft a = x.val.snd`.</span>
      <span>pure</span> <span>⟨</span> <span>x</span><span>.</span><span>val</span><span>.</span><span>snd</span>, <span>this</span> <span>⟩</span><span>     -- Return the value and proof as `some`.</span>
    <span>else</span>
      <span>none</span><span>  -- If the keys don&#39;t match (shouldn&#39;t happen), return `none`.</span>
</code></pre></div></div><p>As well as an insertion function:</p><div><div><pre><code><span>def</span> <span>PropMap_insert</span> [<span>BEq</span> α][<span>Hashable</span> α] [<span>LawfulBEq</span> α] (<span>ft</span> : α <span>→</span> β) (<span>hm</span> : <span>PropMap</span> <span>ft</span>) (<span>k</span> : α) (<span>v</span> : β) (<span>h</span> : <span>ft</span> <span>k</span> <span>=</span> <span>v</span>) : <span>PropMap</span> <span>ft</span> :=
  <span>let</span> <span>cell</span> : <span>{</span> <span>c</span> : α <span>×</span> β <span>//</span> <span>ft</span> <span>c</span><span>.</span><span>fst</span> <span>=</span> <span>c</span><span>.</span><span>snd</span> <span>}</span> := <span>⟨</span>(<span>k</span>, <span>v</span>), <span>h</span><span>⟩</span><span>  -- Create the cell with proof.</span>
  <span>hm</span><span>.</span><span>insert</span> <span>k</span> <span>cell</span><span>  -- Insert the cell into the map at key `k`.</span>
</code></pre></div></div><p>And now we can define our recursive helper:</p><div><div><pre><code><span>def</span> <span>helper</span> (<span>n</span> : <span>Nat</span>) (<span>memo</span> : <span>PropMap</span> <span>maxDollars_spec</span>) :
  <span>{</span> <span>v</span> : <span>Nat</span> <span>//</span> <span>maxDollars_spec</span> <span>n</span> <span>=</span> <span>v</span> <span>}</span> <span>×</span> <span>PropMap</span> <span>maxDollars_spec</span> :=
  <span>match</span> <span>PropMap_get</span><span>?</span> <span>maxDollars_spec</span> <span>memo</span> <span>n</span> <span>with</span>
  <span>|</span> <span>some</span> <span>result</span> <span>=&gt;</span><span>
    -- If `n` is already in the memoization map, return the cached value and the memo.
    -- `result` has type `{ v : Nat // maxDollars_spec n = v }`.</span>
    (<span>result</span>, <span>memo</span>)
  <span>|</span> <span>none</span> <span>=&gt;</span>
    <span>if</span> <span>h</span> : <span>n</span> <span>≤</span> <span>8</span> <span>then</span><span>
      -- Base case: for `n ≤ 8`.</span>
      <span>let</span> <span>v</span> := <span>n</span>
      <span>let</span> <span>h_spec</span> : <span>maxDollars_spec</span> <span>n</span> <span>=</span> <span>v</span> := <span>by</span> <span>simp</span> [<span>maxDollars_spec</span>, <span>h</span>]
      <span>-- Prove that `maxDollars_spec n = n` using simplification.</span>
      <span>let</span> <span>memo</span><span>&#39;</span> := <span>PropMap_insert</span> <span>maxDollars_spec</span> <span>memo</span> <span>n</span> <span>v</span> <span>h_spec</span><span>
      -- Insert `(n, v)` with proof into the memoization map.</span>
      (<span>⟨</span><span>v</span>, <span>h_spec</span><span>⟩</span>, <span>memo</span><span>&#39;</span>)
    <span>else</span><span>
      -- Recursive case: compute the values for `n / 2`, `n / 3`, and `n / 4`.</span>
      <span>let</span> (<span>r1</span>, <span>memo1</span>) := <span>helper</span> (<span>n</span> <span>/</span> <span>2</span>) <span>memo</span>
      <span>let</span> (<span>r2</span>, <span>memo2</span>) := <span>helper</span> (<span>n</span> <span>/</span> <span>3</span>) <span>memo1</span>
      <span>let</span> (<span>r3</span>, <span>memo3</span>) := <span>helper</span> (<span>n</span> <span>/</span> <span>4</span>) <span>memo2</span><span>
      -- `r1`, `r2`, `r3` are of type `{ v : Nat // maxDollars_spec (n / x) = v }`. Basically an induction hypothesis.
      -- `memo3` is the updated memoization map after all recursive calls.</span>
      <span>let</span> <span>exchangeSum</span> := <span>r1</span><span>.</span><span>val</span> <span>+</span> <span>r2</span><span>.</span><span>val</span> <span>+</span> <span>r3</span><span>.</span><span>val</span><span>  -- Sum the values obtained from recursion.</span>
      <span>let</span> <span>v</span> := <span>max</span> <span>n</span> <span>exchangeSum</span><span>  -- Decide whether to sell `n` directly or exchange it.

      -- **Construct the proof that `maxDollars_spec n = v`**</span>
      <span>have</span> <span>h_spec</span> : <span>maxDollars_spec</span> <span>n</span> <span>=</span> <span>v</span> := <span>by</span>
        <span>unfold</span> <span>maxDollars_spec</span><span>         -- Expand `maxDollars_spec n`.</span>
        <span>rw</span> [<span>if_neg</span> <span>h</span>]                  <span>-- Since `n &gt; 8`, use the recursive case.</span>
        <span>rw</span> [<span>r1</span><span>.</span><span>property</span>, <span>r2</span><span>.</span><span>property</span>, <span>r3</span><span>.</span><span>property</span>]

      <span>-- Replace recursive calls with their computed values using the proofs from `r1`, `r2`, `r3`.</span>
      <span>let</span> <span>memo</span><span>&#39;</span> := <span>PropMap_insert</span> <span>maxDollars_spec</span> <span>memo3</span> <span>n</span> <span>v</span> <span>h_spec</span><span>
      -- Insert the computed value and its proof into the memoization map.</span>
      (<span>⟨</span><span>v</span>, <span>h_spec</span><span>⟩</span>, <span>memo</span><span>&#39;</span>)  <span>-- Return the computed value with proof and the updated memo.</span>
</code></pre></div></div><p>Look here. Subtypes require proofs that their value satisfies their logical property. Thus each time our algorithm computes a value <code>v</code> to go in our table, we also compute a proof that <code>v</code> is computed correctly according to <code>maxDollars_spec</code>. We are interleaving code and proof and essentially proving correctness <em>inside the algorithm itself</em>.</p><p>And finally, here is our main function:</p><div><div><pre><code><span>def</span> <span>maxDollars</span> (<span>n</span> : <span>Nat</span>) : <span>Nat</span> :=
  (<span>helper</span> <span>n</span> (<span>HashMap</span><span>.</span><span>empty</span>))<span>.1</span>
</code></pre></div></div><p>We’ve done most of the proof work already, and the final proof of correctness becomes trivial. For an arbitrary $n$, compute the table full of values and their proofs, and just pull out the $n$th proof:</p><div><div><pre><code><span>theorem</span> <span>maxDollars_spec_correct</span> : <span>∀</span> <span>n</span>, <span>maxDollars</span> <span>n</span> <span>=</span> <span>maxDollars_spec</span> <span>n</span> := <span>by</span>
  <span>intro</span> <span>n</span>
  <span>unfold</span> <span>maxDollars</span>
  <span>let</span> <span>⟨</span><span>v</span>, <span>h_spec</span><span>⟩</span> := (<span>helper</span> <span>n</span> <span>HashMap</span><span>.</span><span>empty</span>)<span>.1</span>
  <span>exact</span> <span>h_spec</span><span>.</span><span>symm</span>
</code></pre></div></div><p>And we’re done. The algorithm has been verified.</p><h2 id="5-conclusion">5. <a name="Conclusion"></a>Conclusion</h2><p>My goal here was to share what I learned from this technique and show how it can be applied to a particular problem. I also hope the reader came away understanding subtypes from the perspective of dependent type theory. I find intertwining code with proof in this way really cool and the people I’ve shown this to felt the same.</p><p>To review what we did:</p><ul><li><p>We introduced the Bytelandian Gold Coins problem and wrote a basic recursive specification using a natural recurrence relation.</p></li><li><p>We implemented a naive memoized version using a <code>HashMap</code>, and discussed why proving its correctness directly is tough due to the difficulty of reasoning about data structure invariants.</p></li><li><p>We took a detour into type theory to study subtypes and $\Sigma$-types as a way to attach logical properties to data.</p></li><li><p>We defined a new form of memoization table (<code>PropMap</code>) that stores not just computed values, but also <em>proofs</em> that they were computed correctly with respect to the spec.</p></li><li><p>We rewrote the algorithm so that correctness was proven incrementally, at every step, as a side effect of evaluation - embedding the proof <em>into</em> the recursion.</p></li><li><p>We ended with a trivial top-level proof: correctness follows directly from the structure of the implementation.</p></li></ul><p>All this code is available at <a href="https://github.com/tannerduve/coins">this repo</a></p><h2 id="6-exercises">6. <a name="Exercises"></a>Exercises</h2><p>Each of the following DP problems can be solved using the same framework introduced in this post: define a recurrence relation as a specification, write a memoized implementation that returns values paired with correctness proofs via subtypes, and prove the top-level function computes the intended result.</p><p>Try implementing and verifying your favorite(s) of the following:</p><ul><li><p><strong>Rod Cutting</strong> Given a rod of length <code>n</code> and a list of prices <code>p : List ℕ</code> where <code>p[i]</code> is the price of a rod of length <code>i + 1</code>, define:</p>\[r(n) = \max_{1 \le i \le n} (p[i{-}1] + r(n - i))\]<p>Implement <code>rodCut : ℕ → ℕ</code> using a memoization table and prove correctness</p></li><li><p><strong>0/1 Knapsack</strong> Given <code>n</code> items with weights <code>w : Fin n → ℕ</code>, values <code>v : Fin n → ℕ</code>, and a maximum capacity <code>C</code>, define:</p>\[\text{knapsack}(i, c) = \begin{cases} 0, &amp; i = n \\ \text{knapsack}(i+1, c), &amp; w[i] &gt; c \\ \max(\text{knapsack}(i+1, c),\ v[i] + \text{knapsack}(i+1, c - w[i])), &amp; \text{otherwise} \end{cases}\]<p>Implement and verify <code>knapsack : ℕ → ℕ</code> using a memo table indexed by item and capacity.</p></li><li><p><strong>Levenshtein Distance</strong> Given two strings <code>s</code> and <code>t</code>, define their edit/Levenshtein distance:</p>\[\text{dist}(i, j) = \begin{cases} i, &amp; j = 0 \\ j, &amp; i = 0 \\ \min\!\left( \text{dist}(i{-}1, j) + 1,\; \text{dist}(i, j{-}1) + 1,\; \text{dist}(i{-}1, j{-}1) + \text{cost} \right), &amp; \text{otherwise} \end{cases}\]<p>where <code>cost = 0</code> if <code>s[i-1] = t[j-1]</code> and <code>1</code> otherwise. Implement and verify <code>editDist : String → String → ℕ</code>.</p></li></ul><p>In each case, define the specification as a recursive function, then write a subtype-verified implementation using a <code>PropMap</code> to cache and prove subproblem results. Your goal is a final theorem of the form:</p><div><div><pre><code><span>theorem</span> <span>algorithm_correct</span> : <span>∀</span> <span>input</span>, <span>algorithm</span> <span>input</span> <span>=</span> <span>spec</span> <span>input</span>
</code></pre></div></div><h2 id="7-references">7. <a name="References"></a>References</h2><p><a href="https://gasstationmanager.github.io/ai/2024/12/03/memoization1.html">Proving Memoization in Lean, And Teaching it to Sonnet</a>, GasStationManager</p></section></div></div>
  </body>
</html>
