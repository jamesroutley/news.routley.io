<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://awesomekling.github.io/MutexProtected-A-C&#43;&#43;-Pattern-for-Easier-Concurrency/">Original</a>
    <h1>MutexProtected: A C&#43;&#43; Pattern for Easier Concurrency</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>In this post, we will discuss the challenges of programming with locks and how the C++ language offers some useful tools to make it easier. We will start with an example in C and then use C++ to improve upon it in steps. The example APIs are based on real-life APIs from the <a href="https://github.com/SerenityOS/serenity">SerenityOS</a> kernel.</p>

<h3 id="barebones-example-in-c">Barebones example in C</h3>

<p>Let’s imagine a struct <code>Thing</code> with a field <code>field</code> that will be accessed by multiple threads. We’ll use a mutex <code>mutex</code> to ensure that only one thread can access it at a time.</p>

<div><div><pre><code><span>struct</span> <span>Thing</span> <span>{</span>
    <span>Mutex</span> <span>mutex</span><span>;</span>
    <span>Field</span> <span>field</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>In C, accessing <code>Thing</code> would typically look something like this:</p>

<div><div><pre><code><span>mutex_lock</span><span>(</span><span>&amp;</span><span>thing</span><span>-&gt;</span><span>mutex</span><span>);</span>
<span>use</span><span>(</span><span>&amp;</span><span>thing</span><span>-&gt;</span><span>field</span><span>);</span>
<span>mutex_unlock</span><span>(</span><span>&amp;</span><span>thing</span><span>-&gt;</span><span>mutex</span><span>);</span>
</code></pre></div></div>

<p>An obvious problem in the C version is that the mutex must be manually unlocked. Forgetting to unlock a mutex tends to have unpleasant consequences.</p>

<h3 id="improving-it-with-a-c-raii-class">Improving it with a C++ RAII class</h3>

<p>The “forgot to unlock” problem is easily solved in C++ with a RAII class for automatic locking &amp; unlocking:</p>

<div><div><pre><code><span>{</span>
    <span>MutexLocker</span> <span>locker</span><span>(</span><span>thing</span><span>-&gt;</span><span>mutex</span><span>);</span>
    <span>use</span><span>(</span><span>thing</span><span>-&gt;</span><span>field</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>The <code>MutexLocker</code> locks the mutex when constructed and unlocks it when destroyed. No need for a manual call to <code>mutex_unlock()</code> anymore.</p>

<p>That’s already pretty good! However, the <code>MutexLocker</code> approach still has some major shortcomings:</p>

<ul>
  <li>You can still forget to <em>lock</em> the mutex and access <code>field</code> anyway.</li>
  <li>Developers who are unfamiliar with this code may not realize that <code>mutex</code> and <code>field</code> have this important relationship.</li>
</ul>

<p>Even so, the <code>MutexLocker</code> was our favored pattern in SerenityOS up until 2021, when we introduced a new pattern to the codebase.</p>

<h3 id="adding-lambdas-to-the-mix-introducing-mutexprotected">Adding lambdas to the mix: introducing <code>MutexProtected</code></h3>

<p><code>MutexProtected</code> is a powerful C++ construct that addresses the main issues with <code>MutexLocker</code> and makes it significantly easier to use mutexes correctly:</p>

<div><div><pre><code><span>struct</span> <span>Thing</span> <span>{</span>
    <span>MutexProtected</span><span>&lt;</span><span>Field</span><span>&gt;</span> <span>field</span><span>;</span>
<span>};</span>

<span>thing</span><span>-&gt;</span><span>field</span><span>.</span><span>with</span><span>([</span><span>&amp;</span><span>](</span><span>Field</span><span>&amp;</span> <span>field</span><span>)</span> <span>{</span>
    <span>use</span><span>(</span><span>field</span><span>);</span>
<span>});</span>
</code></pre></div></div>

<p>Essentially, <code>MutexProtected&lt;T&gt;</code> is a bundled mutex and <code>T</code>. However, you can’t access the <code>T</code> directly! The only way we’ll let you access the <code>T</code> is by calling <code>with()</code> and passing it a callback that takes a <code>T&amp;</code> parameter.</p>

<p>When called, <code>with()</code> locks the mutex, then invokes the callback, and finally unlocks the mutex again before returning.</p>

<p>As you can see, we’ve now also solved the issue of someone forgetting to <em>lock</em> the mutex before accessing the field. And not only that, but since the mutex and field have been combined into a single variable, you no longer have to be aware of the relationship between the two. It’s been encoded into the type system!</p>

<p>When multiple fields are protected by a single mutex, we can simply combine them into a struct:</p>

<div><div><pre><code><span>struct</span> <span>ManyFields</span> <span>{</span>
    <span>Field1</span> <span>field1</span><span>;</span>
    <span>Field2</span> <span>field2</span><span>;</span>
    <span>Field3</span> <span>field3</span><span>;</span>
<span>};</span>

<span>struct</span> <span>Thing</span> <span>{</span>
    <span>MutexProtected</span><span>&lt;</span><span>ManyFields</span><span>&gt;</span> <span>fields</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>Note that it’s still possible to make mistakes with <code>MutexProtected</code>, such as deadlocking the program by using multiple <code>MutexProtected</code> simultaneously in inconsistent order. Thankfully such bugs are generally trivial to diagnose compared to data races.</p>

<p>That concludes our look at <code>MutexProtected</code>. If you’re currently working on a C++ project using mainly the <code>MutexLocker</code> approach, consider adding something like our <code>MutexProtected</code> to further reduce the chances of using locks incorrectly.</p>

<p>You can find the SerenityOS implementation <a href="https://github.com/SerenityOS/serenity/blob/master/Kernel/Locking/MutexProtected.h">on GitHub</a>. (Note that it’s a little more sophisticated than the imaginary <code>MutexProtected</code> I’ve used for examples above.)</p>

<h3 id="final-notes">Final notes</h3>

<p>Although <code>MutexProtected</code> was introduced to SerenityOS in 2021, we do still have a lot of code using the old <code>MutexLocker</code> pattern. There are still cases where <code>MutexLocker</code> works better, for example when a mutex is used to synchronize something other than data.</p>

<p>And yes, it <em>is</em> possible to make life difficult by persisting the <code>T&amp;</code> to an outside location while inside the callback. This is C++ after all, so the programmer does have great freedom. However, doing so is definitely not recommended, and we have yet to encounter anyone trying to do this in our codebase.</p>

  </div></div>
  </body>
</html>
