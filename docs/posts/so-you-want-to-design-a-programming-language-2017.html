<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cs.lmu.edu/~ray/notes/languagedesignnotes/">Original</a>
    <h1>So you want to design a programming language (2017)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        

<p>So, you want to design your own language? Of course you do. Or perhaps you are taking a class and are being forced to create a programming language under penalty of a bad grade. What kinds of things do you need to know?</p>

<h2>Prerequisites</h2>

<p>It helps to be experienced. But it’s okay if you’re not—you can get lucky, too!</p>

<p>You should have a good sense of:
</p><ul>
<li><b>Programming Paradigms</b>: <span>imperative</span> <span>declarative</span> <span>structured</span> <span>object-oriented</span> <span>functional</span> <span>applicative</span> <span>concatenative</span> <span>logic</span> <span>protocol-oriented</span> <span>aspect-oriented</span> <span>array</span> <span>event-driven</span> <span>dataflow</span> <span>agent-based</span> etc.

</li><li><b>Programming Language Concepts</b>: Sequencing, conditional execution, iteration, recursion, functional decomposition, modularity, synchronization, metaprogramming, binding, scope, extent, volatility, subtyping, pattern matching, type inference, closures, prototypes, introspection, instrumentation, annotations, decorators, memoization, traits, streams, monads, actors, mailboxes, comprehensions, continuations, wildcards, promises, regular expressions, proxies, transactional memory, inheritance, polymorphism, parameter modes, etc.
</li></ul>

<h2>Study Existing Languages</h2>

<p>It’s nice to have a feel for a variety of languages. Here are a few that are good to be familiar with (and the reasons why they are good to study):
</p><ul>
<li><b>Python</b>, for basic imperative programming and scripting
</li><li><b>Smalltalk</b>, for OOP done beautifully, and Ruby for copying it, sort of, ...
</li><li><b>JavaScript</b>, for event-driven features, async, and promises
</li><li><b>CoffeeScript</b>, for ways to make syntax concise
</li><li><b>Io</b>, for ideas on building up everything from a minimal semantics
</li><li><b>Julia</b>, for multiple dispatch
</li><li><b>Clojure</b>, <b>Racket</b>, <b>Scheme</b>, and <b>Common Lisp</b>, for Lispiness (macros, etc.)
</li><li><b>Standard ML</b>, <b>OCaml</b>, <b>F#</b>, and <b>Elm</b>, for Hindley-Milner typing and more
</li><li><b>Haskell</b>, for typeclasses and functional purity
</li><li><b>eToys</b>, <b>Scratch</b>, <b>Snap!</b>, and <b>GP</b> for the blocks approach
</li><li><b>Erlang</b> and <b>Elixir</b>, for expressing concurrent processes
</li><li><b>Java</b> and <b>C#</b>, for being enterprisey
</li><li><b>Kotlin</b>, <b>Ceylon</b>, and <b>Scala</b>, as examples of evolving Java
</li><li><b>PureScript</b>, <b>TypeScript</b>, and <b>ClojureScript</b>, as examples of evolving JavaScript
</li><li><b>C++</b> and <b>Rust</b>, for pointers and other system constructs
</li><li><b>Go</b> and <b>Swift</b>, for more examples of modern, but generally mainline, ideas
</li><li><b>J</b> and <b>K</b>, for array programming
</li><li><b>Idris</b>, for dependent typing
</li><li><b>Prolog</b> and <b>Mercury</b>, for logic programming
</li><li><b>Factor</b>, for concatenative programming
</li><li><b>Quipper</b>, because it’s a language for quantum computing
</li><li><b>Brainfuck</b>, <b>Malbolge</b>, <b>LOLCODE</b>, <b>Whitespace</b>, and other classic esoterics
</li><li><b>GolfScript</b>, <b>CJam</b>, <b>Pyth</b>, <b>Jelly</b>, and other golfing languages, because this gives you a good sense of putting power into small syntactic constructs
</li><li><b>Piet</b> and <b>Hexagony</b>, for, well, check them out....
</li></ul>

<p>Also check out <a href="http://rtoal.github.io/ple/overviews.html">this mini-encyclopedia of 70 languages</a>.

</p><p>Here are some excellent cross-language comparisons that help you to hone your understanding of how different syntaxes can express the same idea:
</p><ul>
  <li><a href="http://rigaux.org/language-study/syntax-across-languages.html">Syntax Across Languages</a>
  </li><li><a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages">Wikipedia Programming Language Comparisons</a>
  </li><li><a href="http://hyperpolyglot.org/">Hyperpolyglot</a>
</li></ul>

<p>These are really good too:
</p><ul>
  <li><a href="http://codegolf.stackexchange.com/questions/44680">Showcase of Languages</a>
  </li><li><a href="http://codegolf.stackexchange.com/questions/48476">Languages Through the Years</a>
</li></ul>

<h2>Don’t Forget The Literature</h2>

<p>Remember, many people have designed languages before you. They made mistakes. They came up with brilliant ideas. Many were wildly successful. Some never made it big. Some people have brought in years of research on how people think and learn to come up with principles for language (and environment) design.

</p><p>You should learn form their experiences. Study classic papers. Read web essays. Here is a small sampling:
</p><ul>
<li><a href="http://web.eecs.umich.edu/~bchandra/courses/papers/Hoare_Hints.pdf">Hints on Programming Language Design</a> by Tony Hoare
</li><li><a href="http://worrydream.com/#!/LearnableProgramming">Learnable Programming</a> by Bret Victor
</li><li><a href="http://paulgraham.com/langdes.html">Five Questions about Language Design</a> by Paul Graham
</li><li>For early classic papers, check out the massive bibliography of <a href="http://lib.dr.iastate.edu/cgi/viewcontent.cgi?article=1093&amp;context=cs_techreports">this paper</a>
</li><li>Also look at the papers from <a href="http://www.cs.tufts.edu/comp/150PLD/schedule.html">Kathleen Fisher’s Programming Langauge Design class</a>
</li></ul>

<p>Think about the future:

</p><p><iframe width="560" height="315" src="https://www.youtube.com/embed/8pTEmbeENF4" frameborder="0" allowfullscreen=""></iframe>

</p><p><iframe width="560" height="315" src="https://www.youtube.com/embed/prIwpKL57dM" frameborder="0" allowfullscreen=""></iframe>

</p><h2>Sketch and Prototype</h2>

<p>Ready to strike out on your own? Do the following, in no particular order:
</p><ul>
<li>Understand the audience that the language is designed for, and what kinds of things they want to create with it, or problems they want to solve with it.</li>
<li>Sketch programs or program fragments in your language.
</li><li>Sketch fragments that are <em>not</em> in your language.
</li><li>Come up with a list of semantic capabilities, or features. Make sure they enable programmers to express their creations by following the suggestions and principle in the <a href="http://worrydream.com/#!/LearnableProgramming">Learnable Programming</a> essay, including:
  <ul>
    <li>Make meaning transparent
    </li><li>Explain in context
    </li><li>Make flow and time tangible and visible
    </li><li>Show the data, and avoid hidden state
    </li><li>Use metaphor
    </li><li>Allow easy decomposition and recomposition
    </li><li>Allow the programmer to write readable code—you <em>do</em> support mentioning parameter names in calls, right?
  </li></ul>
</li><li>Come up with a nice, consistent, syntactic theme.
</li></ul>
<p>Then:</p>
<ul>
<li>What will you call your language, and why?</li>
</ul>

<p>Remember that design is an iterative process, and creativity is enabled and enhanced with immediate feedback. So you should design with tools that allow you to experiment and test your ideas.

</p><p>You should use the Ohm Editor.

</p><h2>Use the Ohm Editor</h2>

<p>A great tool for <a href="http://web.cs.ucla.edu/~todd/theses/warth_dissertation.pdf">experimenting with programming languages</a> is the <a href="https://ohmlang.github.io/editor/">Ohm Editor</a>.

</p><p><img src="https://cs.lmu.edu/~ray/images/ohm-editor.png%20" alt="ohm-editor.png"/></p>
<p>In the upper left panel, design your grammar. You can load/save from your browser’s local storage, and even publish gists to GitHub. In the upper right panel, enter test cases: both tests you want to succeed (thumbs up) and those you want to fail (thumbs down). The bottom panel is an interactive concrete syntax tree for the currently selected test case.

</p><p>This tool will save you a lot of time.

</p><h2>Things To Think About</h2>

<p>Okay I’m just going to rattle off a bunch of this that come into my head that you may or may not want to think about when you design your language:
</p><ul>
<li>Are you trying to make a reasonable, usable language or an esoteric/joke/golfing/weirdo language?
</li><li>Do you have a specific audience in mind? Artists? Graphic designers? AI researchers? Numeric and Scientific nerds? Natural language types? Game developers? Machine learning people? Animators? High performance folks? System programmers? Or do you want a general purpose language? Or do you just want to do what <em>you</em> want?
</li><li>Do you want to be pragmatic, idealistic, researchy, or evil?
</li><li>Do you want your language firmly in one camp—OO, functional, logic, concatenative, plain-imperative—or be a multiparadigm symphony? Or a multiparadigm cacophany?
</li><li>Do you want a language built on a single characteristic building block (a <em>crystallization of style</em>) or one with a huge variety of syntactic forms for multiple semantic aspects (an <em>agglutination of features</em>)?
</li><li>What is your scheme for showing structure? Curly-brace (JavaScript, Java, C++, C#), Terminal-end (Ruby, Ada), Nested parentheses (Lisp, Clojure, Racket), Indentation (Python, CoffeeScript), Blocks (EToys, Scratch, Snap!), Pictures (Piet), Other (Haskell, Erlang, Prolog)?
</li><li>If your language supports functions:
  <ul>
  <li>Must you pass the exact number of arguments the function expects?
  </li><li>Can you specify parameter names in the call?
  </li><li>Do you have rest parameters? optional parameters? keyword parameters? default parameters?
  </li><li>Are the parameters typed?
  </li><li>Can parameters be modified? Are they passed by value, value-result, reference, name, etc?
  </li><li>Are arguments evaluated L-R, R-L, in parallel, or in arbitrary order?
  </li><li>How does a function return a value? Can it return zero or more values or just one?
  </li><li>Are functions first-class? If so, do you use deep binding or shallow binding?
  </li><li>Is recursion allowed?
  </li><li>Can you test functions for equality?
  </li><li>Can functions be anonymous?
  </li></ul>
</li><li>What is your type system like?
  <ul>
  <li>Static vs. dynamic, strong vs. weak, manifest vs. implicit?
  </li><li>Do you distinguish primitive types from reference types?
  </li><li>Do you have all those different numeric types based on bit size? What about decimals and ratios?
  </li><li>Do you have a separate character type? A separate boolean type?
  </li><li>Can you get the type of an expression at runtime?
  </li><li>Are types objects?
  </li><li>Do you have supertypes and subtypes? Multiple-inheritance? If so, how do you handle name collisions?
  </li><li>Are types the same as classes? Can you add new types?
  </li><li>Do you have both sum and product types?
  </li><li>Do functions have a type?
  </li><li>Are there pointer types?
  </li><li>Are there parameterized types? If so, are they (mostly) covariant, contravariant, or invariant?
  </li><li>Any dependent types?
  </li></ul>
</li><li>What do your expressions look like?
  <ul>
  <li>And does your runtime follow eager or lazy evaluation? Or both?
  </li><li>Do you have only prefix, only postfix, only infix, or a wild mix of operators?
  </li><li>Can you overload operators? If so, how?
  </li><li>Can you change the precedence of operators? Even the built-in ones? At runtime?
  </li><li>How much type inference do you have?
  </li><li>Can you mark variables as mutable or immutable?
  </li><li>Are your variables bound or assigned? Can they be assigned more than once?
  </li><li>Do you have destructuring and/or pattern matching?
  </li><li>How do you determine scope? Do you implicitly or explicitly import into inner scopes?
  </li><li>Are there keywords that define access like <code>public</code>, <code>private</code>, and <code>protected</code>, or are there conventions, like in Go, where capitalized entities are implicitly exportable and lower-cased entities are private?
  </li><li>Is there a <code>let</code>-expression for super-local scopes?
  </li><li>Is shadowing allowed?
  </li><li>Do you have anything like JavaScript’s <code>this</code> expression?
  </li></ul>
</li><li>How do you express control flow?
  <ul>
  <li>Do you like expression-orientation or do you have real statements?
  </li><li>How do you express sequential flow vs. nondeterministic flow vs. parallel flow?
  </li><li>If you have nondeterminism, how do you ensure fairness?
  </li><li>Must guards in a multiway selection be executed in any particular order?
  </li><li>Do you have short-circuit operators? Iterator objects? Generators?
  </li><li>Do you have all the loops: (1) forever, (2) n times, (3) while/until a condition, (4) through a numeric range (with an optional step size), or (5) through a collection?
  </li><li>Do you have <code>break</code> and <code>continue</code>? Anything like Ruby’s <code>retry</code> and <code>redo</code>?
  </li><li>Do you have exceptions? Or do you need Go-style constructs? Or do you have nullables everywhere?
  </li><li>Do you have a timer for sleeping, delaying execution, or running on intervals?
  </li><li>Can I haz <code>goto</code>?
  </li></ul>
</li><li>How do you support concurrency?
  <ul>
  <li>Threads, or events?
  </li><li>Shared memory only? Message passing only? Or both? If shared memory, is it mutable? If so, do you have locks, higher-level synchronization devices, or some kind of transactional memory?
  </li><li>Do you support different levels of granularity of concurrency?
  </li><li>Are tasks spawned implicitly when their enclosing block begins, or do they require explicit invocation?
  </li><li>Do tasks die when the enclosing block or spawning task terminates? Or does the spawner wait for all internal tasks to terminate?
  </li><li>Do taks know who started them?
  </li><li>If an asynchronous task is launched, how is a result obtained? Callback, promise, or some other mechanism?
  </li><li>Is message passing done via named channels, named processes, or bulletin board?
  </li><li>Is message passing always synchronous, asynchronous, or both?
  </li><li>Is there timed or conditional synchronization mechanisms?
  </li><li>Can tasks detect their own state?
  </li></ul>
</li><li>How meta are you?
  <ul>
  <li>Can a program get a list of its global variables, loaded classes, top-level functions, etc.? Can a class get a list of its fields, methods, constructors, superclass(es), subclasses, etc.? Can a function get its parameters, locals, return types, etc.?
  </li><li>Can a function find out who called it?
  </li><li>Can a variable be read or set via its name (a string) only? Can a function or method be invoked by its name (a string) only? Can new variables or types or functions be created at run time, given only their name and some indication of how they should look?
  </li><li>Does the language have a macro system? If so, is it string-based or AST-based?
  </li><li>Is it possible to unquote within a macro?
  </li><li>Are macros hygienic? What syntactic devices are provided to explicitly capture in- scope variables, if any?
  </li></ul>
</li></ul>

<blockquote data-lang="en"><p lang="en" dir="ltr">[God creating JavaScript]</p></blockquote>


<h2>Theoretical Concerns</h2>

<p>Moving on from our particular example, let’s look at things from a more academic perspective and consider real-life programming language definitions. There seem to be three ways to produce a language definition:
</p><ul>
<li>An official document, with a mix of formal notation and informal descriptions.
</li><li>An official document, with 100% of the definition specified in a formal notation.
</li><li>A <dfn>reference implementation</dfn>, namely a compiler, so that the language definition is “whatever this program does.”
</li></ul>

<p>Some language definitions are sanctioned by an official standards organization (like ISO, IEC, ECMA, ANSI, etc.) while some don’t even care about standardization.

</p><p><b>Exercise</b>: Create a bibliography of the official standards for the major programming languages.
</p>
<p>Usually a language is defined by considering its:
</p>

<h3>Syntax</h3>

<p>We have a lot of options for defining a syntax:

</p><ul>
<li>CFG (Context Free Grammar)
</li><li>BNF (Backus-Naur Form)
</li><li>EBNF (Extended Backus-Naur Form)
</li><li>ABNF (Augmented Backus-Naur Form)
</li><li>Syntax Diagrams (a.k.a. Railroad Diagrams)
</li><li>PEG (Parsing Expression Grammar)
</li><li>Ohm Grammar (variation on the classic PEG)
</li></ul>

<p>The first five forms are all equivalent. They describe exactly the class of context-free languages. PEGs capture a different set of languages, including some context-sensitive languages like $a^nb^nc^n$.

</p><p>It turns out general parsing of CSGs is hard or inefficient. So we normally give a grammar for the context-free parts and leave the context-<em>sensitive</em> parts, like “variables must be declared before being used,” to the semantics.

</p><p><b>Exercise</b>: Find out if there are any known complexity bounds (upper or lower) for parsing a context sensitive language.
</p>
<p>Syntax is usually (but not always) divided into:

</p><ul>
<li>A <dfn>microsyntax</dfn>, specifying how the characters in the source code stream are grouped into <dfn>tokens</dfn>. The microsyntax deals with whitespace, comments, and case sensitivity.
</li><li>A <dfn>macrosyntax</dfn>, speficying how the tokens are grouped into <dfn>phrases</dfn> (such as expressions, statements, declarations, etc.)
</li><li>An <dfn>abstract syntax</dfn>, which is a much-simplified restructuring of the macrosyntax.
</li></ul>

<h3>Semantics</h3>

<p>A language’s semantics is specified by mapping its syntactic forms (often abstract syntax tree fragments) into their meaning. Common approaches include:

</p><ul>
<li>Natural Language (informal)
</li><li>“Compile it and run it” (in which the compiler itself defines the language, and thus the compiler correctness problem is trivial—the compiler is by definition always correct)
</li><li>Denotational Semantics
</li><li>Operational Semantics
</li><li>Axiomatic Semantics
</li><li>Action Semantics
</li></ul>

<p>A hugely important distinction is that between:

</p><ul>
<li><dfn>Static Semantics</dfn>: which deals with legality rules—things you can check <em>before</em> running the code (compile time), and
</li><li><dfn>Dynamic Semantics</dfn>: which deals with the execution behavior; things that can only be known <em>at runtime</em>.
</li></ul>

<p><b>Example</b>: You’ve probably heard the distinction between “static” and “dynamic” before. Recall that a statically-typed language in which type checking is done <em>prior to</em> program execution and a dynamically typed language is one in which type checking is done <em>during</em> program execution. Most languages do a little of both, but one or the other usually predominates.
</p>
<h3>Pragmatics</h3>

<p>Pragmatics does not affect the <em>formal</em> specification of programming languages.  However, pragmatic concerns must guide your design of a programming language, if you want it to be easy to read, easy to write, and able to be implemented efficiently. Pragmatics encompasses:
</p><ul>
<li>Common programming idioms (the right ways and the wrong ways of doing things)
</li><li>Programming environments, e.g., IDEs, REPLs, workspaces, playgrounds, playpens
</li><li>The standard library or libraries
</li><li>The ecosystem for 3rd party libraries (e.g. NPM for JavaScript, Pip for Python, Gems for Ruby, Rocks for Lua, Maven for Java, ...)
</li></ul>
      </div>
    </div></div>
  </body>
</html>
