<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cendyne.dev/posts/2022-02-18-user-provided-primary-keys.html">Original</a>
    <h1>Do Not Recommend: User Provided Primary Keys</h1>
    
    <div id="readability-page-1" class="page"><div id="body">

<div>

<p>If you have a primary key or unique index that is stored and exchanged as just a bunch of characters, but your code interprets it in a structured way, you may soon find out you have a problem.
</p>
<p>Do you use a UUID as a primary key for your entities?
Did you use a regex to verify the data looks like a uuid before putting it into the database?
Is your database (like sqlite) using a <strong>case sensitive</strong> collation for the column?
Then you have a problem.
And it can stem from something as simple as casing!
It begins with trusting non-canonical data to be equatable, where multiple inputs have a single interpretation (which can be equated).
</p>
<p><picture><source type="image/jxl" srcset="/assets/2022-02-18/uuid.jxl"/><source type="image/avif" srcset="/assets/2022-02-18/uuid.avif"/><source type="image/webp" srcset="/assets/2022-02-18/uuid.webp"/><img loading="lazy" alt="UUIDs are often passed with different casing" src="https://cendyne.dev/assets/2022-02-18/uuid.jpg"/></picture></p><h2 id="Canonical-Forms">Canonical Forms
</h2>
<p>The process of conforming your data to a canonical form is <a href="https://en.wikipedia.org/wiki/Canonicalization">Canonicalization</a>, that is input data is forced to be output in the form that can be considered unique and any copies can be safely equated.
</p>
<p><picture><source type="image/jxl" srcset="/assets/2022-02-18/canonicalization.jxl"/><source type="image/avif" srcset="/assets/2022-02-18/canonicalization.avif"/><source type="image/webp" srcset="/assets/2022-02-18/canonicalization.webp"/><img loading="lazy" alt="multiple strings can be interpreted as the same number" src="https://cendyne.dev/assets/2022-02-18/canonicalization.jpg"/></picture></p><p>Consider the above diagram, the number <strong><code>2</code></strong> could be parsed from several numbers, such as <strong><code>&#34;002&#34;</code></strong>, <strong><code>&#34;02&#34;</code></strong>, and <strong><code>&#34;2&#34;</code></strong>. Note that the numeric encoding of <strong><code>2</code></strong> is <strong><code>&#34;2&#34;</code></strong>, and decoding <strong><code>&#34;2&#34;</code></strong> is <strong><code>2</code></strong>.
</p>
<p><picture><source type="image/jxl" srcset="/assets/2022-02-18/parser.jxl"/><source type="image/avif" srcset="/assets/2022-02-18/parser.avif"/><source type="image/webp" srcset="/assets/2022-02-18/parser.webp"/><img loading="lazy" alt="Parsing numbers" src="https://cendyne.dev/assets/2022-02-18/parser.jpg"/></picture></p><p>When the means of communicating, interpreting, and communicating the interpreted value results in the same literal value (what is being communicated), then you have your <strong>de-facto canonical form</strong> in the eyes of your application.
</p>
<p><picture><source type="image/jxl" srcset="/assets/2022-02-18/encoding.jxl"/><source type="image/avif" srcset="/assets/2022-02-18/encoding.avif"/><source type="image/webp" srcset="/assets/2022-02-18/encoding.webp"/><img loading="lazy" alt="A loop between encoding and decoding" src="https://cendyne.dev/assets/2022-02-18/encoding.jpg"/></picture></p><p>This <em>problem or feature</em> is tied to parsing and that is not just limited to when strings are passed between functions, processes, servers, and so on.
It is a part of the very languages you use to deliver something useful.
</p>
<p><picture><source type="image/jxl" srcset="/assets/2022-02-18/equivalence.jxl"/><source type="image/avif" srcset="/assets/2022-02-18/equivalence.avif"/><source type="image/webp" srcset="/assets/2022-02-18/equivalence.webp"/><img loading="lazy" alt="Equivalence of 0 0 2 to 2" src="https://cendyne.dev/assets/2022-02-18/equivalence.jpg"/></picture></p><p>You might eye roll and say what&#39;s the harm?
Multiple encodings are actually helpful in many circumstances.
Suppose you&#39;re at a restaurant and someone in the middle of the table says they need to get up and use the &#34;bathroom&#34;.
You know they mean the facilities labeled &#34;restroom&#34;, a place with toilets.
This individual is not going to bathe despite using the word &#34;bathroom&#34;, because the facilities <strong>do <em>not</em> afford</strong> that option.
Those facilities <strong>do afford</strong> the option to use toilets and wash hands.
</p>
<div><div><div><picture><source type="image/jxl" srcset="/assets/stickers/think.jxl"/><source type="image/avif" srcset="/assets/stickers/think.avif"/><source type="image/webp" srcset="/assets/stickers/think.webp"/><img loading="lazy" alt="think" src="https://cendyne.dev/assets/stickers/think.jpg"/></picture></div><div><div><p>
In a way, authorization is linked to affordances.
An attestation of authorization affords the bearer of the attestation to do something (usually).
When you say you&#39;re going to do something you are conveying intent or a command.
Often untrusted inputs should be treated as intents rather than commands, while trusted inputs are then evaluated as commands.
</p></div></div></div></div><div><div><div><div><p>
One time while driving in Kansas, I stopped at a gas station and filled up.
But in order to afford access to the rest room, I had to ask for a key at the cashier.
I received a PVC pipe with a key strung on the end.
<em>Is this normal in Kansas?</em>
</p></div></div><div><picture><source type="image/jxl" srcset="/assets/stickers/surprised-pikachu.jxl"/><source type="image/avif" srcset="/assets/stickers/surprised-pikachu.avif"/><source type="image/webp" srcset="/assets/stickers/surprised-pikachu.webp"/><img loading="lazy" alt="surprised-pikachu" src="https://cendyne.dev/assets/stickers/surprised-pikachu.jpg"/></picture></div></div></div><p>When we talk as humans we can distinguish meanings and decide equivalences with confidence.
But machines do not have this skill.
Machines cannot easily differentiate and equate things that require interpretation.
</p>
<p>Instead machines <em>can</em> compare bytes quite easily.
But the moment something inside those bytes need to be understood or interpreted, a parser is needed to transform those bytes into something structured and useful.
Those structures can be compared or equated too, usually.
But the danger here is when the same structures can be parsed from different data.
In sensitive security contexts the bytes themselves are compared as-is.
<em>There are cases where bytes are dynamically fed into a digest algorithm, but we will get to that later.</em>
</p>
<p><picture><source type="image/jxl" srcset="/assets/2022-02-18/octal.jxl"/><source type="image/avif" srcset="/assets/2022-02-18/octal.avif"/><source type="image/webp" srcset="/assets/2022-02-18/octal.webp"/><img loading="lazy" alt="Parsing numbers node with octal" src="https://cendyne.dev/assets/2022-02-18/octal.jpg"/></picture></p><p>For multiple contexts an input can be a string of digits and the result for each context can be an integer in memory.
Yet those integers in memory can be wildly different within the same language.
</p>
<p><code>Number.parseInt(&#34;0200&#34;)</code> may be meant to parse human input while <code>0200</code> in source code is traditionally an octal representation due to the leading <code>0</code>.
It turns out different parsers are used in node.js and this creates <strong>ambiguity</strong> for the very developer making something with it.
Did they think their numbers would be parsed as decimal or as octal?
</p><p>To resolve <strong>ambiguity</strong> we create <strong>specifications</strong> and when the bytes that are being compared need to have only one possible encoding for equivalence then it is a <strong>canonicalization specification</strong>.
</p>
<p><em>Why only one possible encoding is important for security contexts will come later.</em></p><h2 id="De-facto-vs-Specified-Canonicalization">De-facto vs Specified Canonicalization
</h2>
<p>As described above, de-facto is how the existing application is working at this moment.
While you can retroactively specify its behavior for compatibility later, until you ensure that inputs can only map to one interpretation, you may continue to face issues that come from non-canonical encodings in sensitive contexts.
</p>
<p>When creating and specifying a canonical encoding there&#39;s a few traps to be wary of.
</p>
<ul>
<li>
When concatenating multiple values together which come from an untrusted source,
include delimiters that encode the length of what is concatenated.
More on this type of attack can be seen on <a href="https://soatok.blog/2021/07/30/canonicalization-attacks-against-macs-and-signatures/">Canonicalization Attacks Against MACs and Signatures</a> by <a href="https://twitter.com/SoatokDhole/">Sparkling, blue, wolf-like creature: Soatok, Dhole</a>.
</li>
<li>
When concatenating entries of a map, set, or any unordered structure, ensure that elements are deterministically added to the canonical output.
</li>
<li>
Be cautious around parsing maps or dictionaries, entries can be added multiple times and be syntactically valid (in JSON or XML) but parsers may take the first or last value. Consider using parsers that reject input with duplicate keys.
</li>
<li>
I recommend using vectors of elements, if an element is optional put a placeholder value when it is absent.
</li>
<li>
All instances of a type of thing should use the same encoding.
For example, do not mix base64 standard padded and base64 standard unpadded or just plain binary.
</li>
</ul><p>When encodings for the same thing get mixed up, you enter a new class of problems which comes next!
</p>
<h3 id="Specifying-Primary-Keys">Specifying Primary Keys
</h3>
<p>Let&#39;s say you are working with UUID keys, UUIDs in upper case and lower case are both accepted by UUID parsers.
Also that your data store where these are primary keys is case sensitive and not using an embedded structured type.
<em>If you use an embedded type like <a href="https://www.postgresql.org/docs/14/datatype-uuid.html">PostgreSQL UUID</a> <strong>everywhere</strong>, then this is not an issue for you.</em>
</p>
<p>But if that&#39;s not possible or not feasible...
What if you only accept UUIDs with lower case, no mixed or upper case?
</p>
<p><picture><source type="image/jxl" srcset="/assets/2022-02-18/uuid.jxl"/><source type="image/avif" srcset="/assets/2022-02-18/uuid.avif"/><source type="image/webp" srcset="/assets/2022-02-18/uuid.webp"/><img loading="lazy" alt="UUID with regex validation" src="https://cendyne.dev/assets/2022-02-18/uuid.jpg"/></picture></p><pre><code>// re is a regex object that matches UUID looking things in lower case.
let re = /[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/;
--------------------------v--------------
&gt; !!&#39;825fb0c9-8241-42ad-99E2-20fdfb198bcc&#39;.match(re)
--------------------------^--------------
false
--------vv-v---------vv---v----vvvv---vvv
&gt; !!&#39;825FB0C9-8241-42AD-99E2-20FDFB198BCC&#39;.match(re)
--------^^-^---------^^---^----^^^^---^^^
false
-----------------------------------------
&gt; !!&#39;825fb0c9-8241-42ad-99e2-20fdfb198bcc&#39;.match(re)
-----------------------------------------
true</code></pre><p>Regex is often the first line of defense to things like this.
But not everything will fit or be expressable as a regex.
</p>
<p>What if you transform the input into a canonical form (all lower case)?
<strong>Be careful!</strong>
<a href="https://engineering.atspotify.com/2013/06/creative-usernames/">Spotify documented their difficulty on transforming usernames</a>! (<a href="https://archive.is/bcmTn">Archive link</a>)
If your transform function is not <strong>idempotent</strong> then it is not safe to use where equivalence is important.
</p>
<div><div><div><div><p>
Idempotency is that the operation can be run multiple times without a net change.
Here the transformation is on an input string to an output string.
It should be safe to run this type of transformation on an indexed key.
For example if you run <code>toLowerCase()</code> on a valid UUID then running it again will have no change in representation, as the alphabet used <code>[a-f0-9]</code> has no further lower case forms like Spotify&#39;s experience.
</p></div></div><div><picture><source type="image/jxl" srcset="/assets/stickers/notes.jxl"/><source type="image/avif" srcset="/assets/stickers/notes.avif"/><source type="image/webp" srcset="/assets/stickers/notes.webp"/><img loading="lazy" alt="notes" src="https://cendyne.dev/assets/stickers/notes.jpg"/></picture></div></div></div><p>Here&#39;s Spotify&#39;s example:
</p><pre><code>&gt;&gt;&gt; canonical_username(u&#39;\u1d2e\u1d35\u1d33\u1d2e\u1d35\u1d3f\u1d30&#39;)
u&#39;BIGBIRD&#39;
&gt;&gt;&gt; canonical_username(canonical_username(u&#39;\u1d2e\u1d35\u1d33\u1d2e\u1d35\u1d3f\u1d30&#39;))
u&#39;bigbird&#39;</code></pre>

<p>Their canonical function failed their use case because it was not idempotent.
The input and output could be transformed again into another unique output which demonstrated multiple interpretations for the &#39;bigbird&#39; text.
</p>
<p>While <code>toLowerCase()</code> works for this trivial example, your application may not be as trivial.
</p>
<pre><code>&gt; !!&#39;825fb0c9-8241-42ad-99e2-20fdfb198bcc&#39;.match(re)
true
&gt; !!&#39;825FB0C9-8241-42AD-99E2-20FDFB198BCC&#39;.toLowerCase().match(re)
true</code></pre><p>Rejecting input that does not meet expectations on canonical value is often the safer choice with regards to security.
But like Spotify&#39;s case, a balance has to be made for human user experience.
In the end Spotify chose to do both: transform the input so the human experienced case insensitive usernames and reject names which could not be properly canonicalized without looping.
</p>
<h3 id="Base64-Primary-Keys">Base64 Primary Keys
</h3>
<p>Here&#39;s an example by <a href="https://twitter.com/CiPHPerCoder">@CiPHPerCoder</a> <em>but in node js for consistency of this post</em>.
</p>
<pre><code>&gt; Buffer.from(&#39;PHP&#39;, &#39;base64&#39;).toString(&#39;base64&#39;)
&#39;PHM=&#39;
&gt; Buffer.from(&#39;PHM=&#39;, &#39;base64&#39;)
&lt;Buffer 3c 73&gt;
&gt; Buffer.from([0x3c, 0x73]).toString(&#39;base64url&#39;)
&#39;PHM&#39;</code></pre><p>The canonical encoding for the bytes <code>[0x3c, 0x73]</code> is <code>&#39;PHM=&#39;</code> in base64 standard with padding.
While the canonical encoding in base64 url without padding is <code>&#39;PHM&#39;</code>.
</p>
<div><div><div><picture><source type="image/jxl" srcset="/assets/stickers/talk-w-bubble.jxl"/><source type="image/avif" srcset="/assets/stickers/talk-w-bubble.avif"/><source type="image/webp" srcset="/assets/stickers/talk-w-bubble.webp"/><img loading="lazy" alt="talk-w-bubble" src="https://cendyne.dev/assets/stickers/talk-w-bubble.jpg"/></picture></div><div><div><p>Standard and URL encoding both have padded and unpadded variants, totalling 4 options. Most users of node.js use either standard padded or url safe unpadded encoding. URL encoding swaps two characters so the encoded contents can be embedded in urls and headers.</p></div></div></div></div><p>Many libraries, languages, environments will give you a <strong>non-strict base64 implementation</strong>. Below is an example of how the same bytes can look so wildly different encoded in different variants, but be decoded in <em>the other variant</em> without rejection.
</p>
<pre><code>&gt; Buffer.from([0xff, 0xef]).toString(&#39;base64&#39;)
&#39;/+8=&#39;
&gt; Buffer.from([0xff, 0xef]).toString(&#39;base64url&#39;)
&#39;_-8&#39;

&gt; Buffer.from(&#39;/+8=&#39;, &#39;base64url&#39;)
&lt;Buffer ff ef&gt;
&gt; Buffer.from(&#39;_-8&#39;, &#39;base64&#39;)
&lt;Buffer ff ef&gt;
&gt; Buffer.from(&#39;/+8&#39;, &#39;base64url&#39;)
&lt;Buffer ff ef&gt;
&gt; Buffer.from(&#39;_-8=&#39;, &#39;base64&#39;)
&lt;Buffer ff ef&gt;</code></pre><p>Most developers would see this as a feature, and I agree it&#39;s nice to know it&#39;s base64 and not mind which variant it is with or without padding and move on in making something useful.
</p>
<div><div><div><div><p>
I wrote a base64 implementation in C for a lisp language.
It was intentionally designed to be fast with lookup tables while supporting both web and standard encoding with or without padding with ease.
This might not be the best thing to have due to padding and variant malleability.
</p></div></div><div><picture><source type="image/jxl" srcset="/assets/stickers/everything-is-fine.jxl"/><source type="image/avif" srcset="/assets/stickers/everything-is-fine.avif"/><source type="image/webp" srcset="/assets/stickers/everything-is-fine.webp"/><img loading="lazy" alt="everything-is-fine" src="https://cendyne.dev/assets/stickers/everything-is-fine.jpg"/></picture></div></div></div><div><div><div><picture><source type="image/jxl" srcset="/assets/stickers/nervous.jxl"/><source type="image/avif" srcset="/assets/stickers/nervous.avif"/><source type="image/webp" srcset="/assets/stickers/nervous.webp"/><img loading="lazy" alt="nervous" src="https://cendyne.dev/assets/stickers/nervous.jpg"/></picture></div></div></div><p>But the issue here is... like UUID&#39;s what if you stored these as primary keys in the database as strings?
What if you used them where uniqueness or identity matters?
</p>
<p>What if a developer thought: <em>for performance reasons there&#39;s no need to re-encode some base64, I already have the base64 value as a string and have a proof of equivalence when decoded, so I can safely store the user supplied base64 value in this table?</em>
</p>
<div><div><div><div><p>
This sounds a lot like <a href="https://owasp.org/www-community/attacks/xss/">Cross Site Scripting</a> doesn&#39;t it?
Here untrusted input is persisted into the system and later used in a trusted context.
While it does not affect the browser with scripting, the context is <strong>sensitive</strong> and this provides an attack vector to accessing another user.
</p></div></div><div><picture><source type="image/jxl" srcset="/assets/stickers/access-granted.jxl"/><source type="image/avif" srcset="/assets/stickers/access-granted.avif"/><source type="image/webp" srcset="/assets/stickers/access-granted.webp"/><img loading="lazy" alt="access-granted" src="https://cendyne.dev/assets/stickers/access-granted.jpg"/></picture></div></div></div><p>Here&#39;s an example where it can go wrong, let us assume the target and the adversary do not have control over how IDs are assigned.
The ID might be random or it could be deterministically created.
</p>
<div><div><div><picture><source type="image/jxl" srcset="/assets/stickers/disapprove.jxl"/><source type="image/avif" srcset="/assets/stickers/disapprove.avif"/><source type="image/webp" srcset="/assets/stickers/disapprove.webp"/><img loading="lazy" alt="disapprove" src="https://cendyne.dev/assets/stickers/disapprove.jpg"/></picture></div><div><div><p>
For example, <a href="https://www.uuidtools.com/uuid-versions-explained">UUIDv3</a> contains an MD5 hash (<a href="https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca5351">which is broken</a>) of some input with a namespace.
That namespace could be secret to the application so users could not reasonably create their own.
But if case sensitivity were present and it was loaded into a <code>UUID</code> object, then what is described below still applies.
UUIDv5 isn&#39;t much better, it uses SHA-1, which is also <a href="https://duo.com/decipher/sha-1-fully-and-practically-broken-by-new-collision">cryptographically broken</a>.
</p></div></div></div></div><p>Here it will be a base64 string based on some deterministic process.
</p>
<pre><code>&gt; crypto = require(&#39;crypto&#39;)
&gt; crypto.createHash(&#39;md5&#39;).update(&#39;<a href="https://cendyne.dev/cdn-cgi/l/email-protection" data-cfemail="a5d1c4d7c2c0d1e5c0ddc4c8d5c9c08bcad7c2">[email protected]</a>&#39;).digest(&#39;base64&#39;)
&#39;+pgA3ruPzUGkJjBltX/Lkw==&#39;</code></pre><div><div><div><picture><source type="image/jxl" srcset="/assets/stickers/bonk.jxl"/><source type="image/avif" srcset="/assets/stickers/bonk.avif"/><source type="image/webp" srcset="/assets/stickers/bonk.webp"/><img loading="lazy" alt="bonk" src="https://cendyne.dev/assets/stickers/bonk.jpg"/></picture></div><div><div><p>
Don&#39;t use md5 for cryptographic purposes anymore, this is merely for a deterministic demonstration which you can run yourself.
</p></div></div></div></div><p>Suppose the user table uses bytes to store the user id, but someone else made the password reset table and it uses a string for the user id instead.
This difference of encodings enables the example below to be attacked.
</p>
<p>Further, assume the encoded user id can be used elsewhere (e.g. email) to continue the attack.
</p>
<p>Consider logic like this:
</p>
<pre><code data-language="java"><span>void</span> <span>forgotPassword</span><span>(</span><span>)</span><span>{</span>
        <span>userId</span> <span>=</span> <span>param</span><span>[</span><span>&#34;id&#34;</span><span>]</span><span>;</span>
        <span>user</span> <span>=</span> <span>Users</span><span>.</span><span>get</span><span>(</span><span>Buffer</span><span>.</span><span>from</span><span>(</span><span>userId</span><span>,</span> <span>&#34;base64&#34;</span><span>)</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>user</span> <span>!</span><span>=</span> <span>null</span><span>)</span> <span>{</span>
        <span>token</span> <span>=</span> <span>ForgetPassword</span><span>.</span><span>requestNewPassword</span><span>(</span><span>userId</span><span>)</span><span>;</span>
                                        <span>Email</span><span>.</span><span>send</span><span>(</span><span>userId</span> <span>+</span> <span>&#34;@example.org&#34;</span><span>,</span>
            <span>&#34;here you go &#34;</span> <span>+</span> <span>token</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>void</span> <span>resetPassword</span><span>(</span><span>)</span> <span>{</span>
        <span>token</span> <span>=</span> <span>param</span><span>[</span><span>&#34;token&#34;</span><span>]</span><span>;</span>
    <span>forgot</span> <span>=</span> <span>ForgotPassword</span><span>.</span><span>find</span><span>(</span><span>token</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>forgot</span> <span>!</span><span>=</span> <span>null</span><span>)</span> <span>{</span>
                <span>userId</span> <span>=</span> <span>forgot</span><span>.</span><span>userId</span><span>;</span> 
                <span>user</span> <span>=</span> <span>Users</span><span>.</span><span>get</span><span>(</span><span>Buffer</span><span>.</span><span>from</span><span>(</span><span>userId</span><span>,</span> <span>&#34;base64&#34;</span><span>)</span><span>)</span><span>;</span>
                        <span>user</span><span>.</span><span>setPassword</span><span>(</span><span>param</span><span>[</span><span>&#34;new_password&#34;</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span></code></pre><p>Given that we can successfully equate the same user id with different encodings, and the encoded value is stored as is without validation:
</p>
<pre><code>&gt; Buffer.from(&#39;+pgA3ruPzUGkJjBltX/Lkw==&#39;, &#39;base64&#39;).equals(Buffer.from(&#39;+pgA3ruPzUGkJjBltX/Lkz&#39;, &#39;base64&#39;))
true</code></pre><p>The workflow above is vulnerable to an attack by someone if they can somehow get access to another email address with the non-canonical base64 user id.
In fact, this example can be minimized.
Just the padding <code>(==)</code> can be removed, I did not even need to change the <code>&#39;w&#39;</code> on the end to a <code>&#39;z&#39;</code>.
</p>
<div><div><div><div><p>
Is this a canonicalization attack?
What name really describes this best?
In short the attack relies upon breaking uniqueness expectations where values are equal when interpreted or transformed.
</p></div></div><div><picture><source type="image/jxl" srcset="/assets/stickers/think.jxl"/><source type="image/avif" srcset="/assets/stickers/think.avif"/><source type="image/webp" srcset="/assets/stickers/think.webp"/><img loading="lazy" alt="think" src="https://cendyne.dev/assets/stickers/think.jpg"/></picture></div></div></div><p>Some mitigations:
</p>
<ul>
<li>Use strict decoders everywhere.</li>
<li>Encode again and reject input where it differs.</li>
<li>Update this code to use the user id on the user record instead of the user input once loaded when emailing.</li>
<li>Migrate the forgot password table and code to use the same binary encoding as the user table.</li>
<li>Don&#39;t assume properties of the system that involve concatenating untrusted user input with system constants. Instead have a field for email addresses on the user and refer to that when emailing.</li>
<li>Use <a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/implement-value-objects">value objects</a> to represent trusted validated structured information in context.</li>
</ul><h3 id="Canonicalization-attacks">Canonicalization attacks
</h3>
<p>If you search this you may find stuff about <a href="https://en.wikipedia.org/wiki/Directory_traversal_attack">file system traversal</a>.
How is it related?
It is actually quite close in concept to the example above with emailing: do not concatenate user input with system constants and hope all will be well.
</p>
<p>See, multiple input paths turn out to be the same output path in the file system:
</p>
<pre><code>cd /usr/share/gcc/python/libstdcxx/v6/../../../../misc
pwd
&gt; /usr/share/misc

cd /usr/share/misc
pwd
&gt; /usr/share/misc</code></pre><p>Do you see how multiple inputs have the same output?
The same interpretation (the final present working directory) came from multiple paths.
Canonicalization is part of this attack because the encoding and intent and context are not aligned.
What if the application expected that all file system access ocurred within a given path?
For example suppose uploading images could only be done in <code>/usr/share/gcc/python/libstdcxx/v6/</code> but the application accidentally allowed for overwriting <code>/usr/bin/sudo</code> because the file name was <code>../../../../../bin/sudo</code> in the upload form?
That&#39;s quite dangerous.
</p>
<div><div><div><picture><source type="image/jxl" srcset="/assets/stickers/watching-you.jxl"/><source type="image/avif" srcset="/assets/stickers/watching-you.avif"/><source type="image/webp" srcset="/assets/stickers/watching-you.webp"/><img loading="lazy" alt="watching-you" src="https://cendyne.dev/assets/stickers/watching-you.jpg"/></picture></div></div></div><h2 id="Canonicalization-for-Cryptographic-contexts">Canonicalization for Cryptographic contexts
</h2>
<p>In cryptographic contexts, hash functions are used where if any bit of the input were different, the output would be unrecognizably different.
A signature on a hash function&#39;s output or a keyed hash provides data integrity of the contents signed.
Any modification to the content would therefore invalidate the signature.
</p>
<p>Typically content of just bytes is encrypted or signed where integrity (modification is detected and rejected) is desired and required.
Protocols that involve the following are typically sound in construction:
</p>
<ol>
<li>Structured content is canonicalized at encoding time.</li>
<li>Encoded content has cryptographic integrity protection.</li>
<li>The package of encoded content with integrity protection is never disassembled and reassembled later.</li>
</ol><h3 id="Dynamic-Canonicalization">Dynamic Canonicalization
</h3>
<p>But alas, we have protocols like <a href="https://joonas.fi/2021/08/saml-is-insecure-by-design/">SAML which is insecure by design</a>.
The key part that makes it insecure goes back to that problem where <code>Number.parseInt(&#34;0200&#34;)</code> can differ from <code>200</code>.
There will be different parsers for different contexts and by authors who do not collaborate with quirks and unique behaviors on anything as complex as <a href="https://datatracker.ietf.org/doc/html/rfc3076">Canonical XML</a>.
Canonical XML is a dynamic canonicalization solution with many faults, <em>which will be cited later</em>.
</p>
<p>What makes those protocols fragile is how secured content is disassembled and reassembled later, even multiple times.
The encoded data which is used by the application is not protected for the application because it is mutable between the signer and the audience or intended recipient.
Instead it is left to the application to be diligent about handling mutable data with dynamic canonicalization.
This isn&#39;t just about attacks on XML though, equating structures is just inherently a hard problem: solutions have been proposed for <a href="https://www.rfc-editor.org/rfc/rfc8785">JSON</a>, <a href="https://datatracker.ietf.org/doc/html/rfc7049#section-3.9">CBOR</a>, and <a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-message-signatures/">even HTTP</a>!
</p>
<p>Now I get it, HTTP requests are literally received, modified, rewritten, reorganized, etc. between load balancers and applications.
There is no concept of nesting an HTTP request and its properties, it is all flat.
So what do you do when somewhere in the middle an insensitive header will be added or removed, that sensitive headers are reorganized but the reorganization has no change or net effect to application behavior?
</p>
<p>Unfortunately the solution is usually constraining or inventing a new specification which can then be used to deterministically encode a request to a canonical byte form, which is then signed or encrypted.
But... this canonical form is often not used by the application.
Instead it is used to filter requests without modifying the request with respect to how the application receives it.
</p>
<p>This is effectively what <a href="https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html">AWS SigV4</a> did.
Unfortunately, even SigV4 differs between services within AWS.
Specifically S3 has its own <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html">special variant</a>.
In case it interests you, others like <a href="https://cloud.google.com/storage/docs/access-control/signing-urls-manually">google</a> have their own version too!
</p>
<p>Outside of Amazon&#39;s specific needs, the vibes for HTTP Canonicalization with a <a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-message-signatures/">holistic approach</a> are not all that great.
You can explain it, and it makes sense, but it does not feel clean.
</p>
<figure><picture><source type="image/jxl" srcset="/assets/2022-02-18/vibe.jxl"/><source type="image/avif" srcset="/assets/2022-02-18/vibe.avif"/><source type="image/webp" srcset="/assets/2022-02-18/vibe.webp"/><img loading="lazy" alt="Bad vibes for HTTP Canonicalization" src="https://cendyne.dev/assets/2022-02-18/vibe.jpg"/></picture><figcaption>
<a href="https://archive.is/5CUME">Archived Tweet</a>
</figcaption></figure><p>Dynamic canonicalization often <strong>does not</strong> feed the canonical result into the application.
Instead it is calculated, used, and discarded.
It may not even be fully allocated either because outputs can be incrementally fed into a digest algorithm, and then finally verified against a signature.
</p>
<p>This is a bit of a trick too, how can you sign something that is dynamic so that it has only one possible encoding?
A requirement for digital signatures is deterministic verification.
Canonicalization is used to create a deterministic output as an input to the signature process by reorganizing all the information in a deterministic way.
But as mentioned before, if the application treats the input differently and there are things that can be tweaked to appear the same to the canonicalization process, then your implementation is vulnerable.
</p>
<figure><picture><source type="image/jxl" srcset="/assets/2022-02-18/xsw.jxl"/><source type="image/avif" srcset="/assets/2022-02-18/xsw.avif"/><source type="image/webp" srcset="/assets/2022-02-18/xsw.webp"/><img loading="lazy" alt="XSW Attack" src="https://cendyne.dev/assets/2022-02-18/xsw.jpg"/></picture><figcaption>
Figure 3.1 in section 3.1 XML Signature Wrapping Attacks – Basics from &#34;On the insecurity of XML Security&#34;.
</figcaption></figure><div><div><div><picture><source type="image/jxl" srcset="/assets/stickers/newspaper-ych.jxl"/><source type="image/avif" srcset="/assets/stickers/newspaper-ych.avif"/><source type="image/webp" srcset="/assets/stickers/newspaper-ych.webp"/><img loading="lazy" alt="newspaper-ych" src="https://cendyne.dev/assets/stickers/newspaper-ych.jpg"/></picture></div><div><div><p>
Protocols that use dynamic canonicalization have decreased confidence among cryptographers.
This is one of many reasons SAML has a bad reputation.
</p></div></div></div></div><div><div><div><div><div><p>
If you would like to read about this subject see: Somorovsky, Juraj. &#34;On the insecurity of XML Security&#34; it - Information Technology, vol. 56, no. 6, 2014, pp. 313-317. <a href="https://doi.org/10.1515/itit-2014-1045">https://doi.org/10.1515/itit-2014-1045</a></p></div></div></div><div><picture><source type="image/jxl" srcset="/assets/stickers/reading.jxl"/><source type="image/avif" srcset="/assets/stickers/reading.avif"/><source type="image/webp" srcset="/assets/stickers/reading.webp"/><img loading="lazy" alt="reading" src="https://cendyne.dev/assets/stickers/reading.jpg"/></picture></div></div></div><h2 id="Mismatch-between-Application-and-Security">Mismatch between Application and Security
</h2>
<p>Here&#39;s the rub.
You can create a canonical form, you can sign it, and it is valid, but what if your application never uses the canonical form? <em>Such as the dynamic canonicalization case.</em>
</p>
<p>Consider this input
</p>
<pre><code data-language="java"><span>{</span>
    <span>&#34;username&#34;</span><span>:</span> <span>&#34;Alice&#34;</span><span>,</span>
    <span>&#34;username&#34;</span><span>:</span> <span>&#34;Bob&#34;</span><span>,</span>
    <span>&#34;scope&#34;</span><span>:</span> <span>&#34;prod&#34;</span>
<span>}</span></code></pre><p>What if your signing process treated it as this when it signed it
</p>
<pre><code data-language="java"><span>{</span>
    <span>&#34;scope&#34;</span><span>:</span> <span>&#34;prod&#34;</span><span>,</span>
    <span>&#34;username&#34;</span><span>:</span> <span>&#34;Alice&#34;</span>
<span>}</span></code></pre><p>But your application treats it as this?
</p>
<pre><code data-language="java"><span>{</span>
    <span>&#34;scope&#34;</span><span>:</span> <span>&#34;prod&#34;</span><span>,</span>
    <span>&#34;username&#34;</span><span>:</span> <span>&#34;Bob&#34;</span>
<span>}</span></code></pre><p>Some say to just give the canonical form to the application instead, that <em>is</em> what is secured.
</p>
<p>But when it comes to XML, JSON, or whatever--guess what?
</p>
<p>The application and the security library may be using different incompatible structured interfaces!
Maybe the security library uses <a href="https://github.com/google/gson">GSON</a> and the application uses <a href="https://github.com/FasterXML/jackson">Jackson</a>. Or even different versions of the same library!
This is a real problem.
</p>
<p>Try importing a few SOAP SDKs some time and find out how many XML parsers are brought into your project and figure out how to keep them from colliding.
</p>
<h2 id="What-can-you-do-about-Canonicalization?">What can you do about Canonicalization?
</h2>
<p>Move to using typed values over strings from users.
Particularly if the value has some sensitive meaning like username.
It may be a string inside but the context has additional rules (like case insensitivity) that make is safer to use. By scoping and conforming the input to the domain and context with a <a href="https://martinfowler.com/bliki/ValueObject.html">value object</a> will ensure that input meets expectations and storing will only have one representation for that context.
</p>
<p>Your typed values should reject input during deserialization / parsing when input appears non canonical, or at least transform (i.e. lowercase uuid) and then reject if the transform is not idempotent. (Recall Spotify&#39;s difficulty.)
</p>
<div><div><div><picture><source type="image/jxl" srcset="/assets/stickers/hmm.jxl"/><source type="image/avif" srcset="/assets/stickers/hmm.avif"/><source type="image/webp" srcset="/assets/stickers/hmm.webp"/><img loading="lazy" alt="hmm" src="https://cendyne.dev/assets/stickers/hmm.jpg"/></picture></div></div></div><p>Consider rejecting inputs that may force canonicalization like directory traversal.
</p>
<div><div><div><div><p>
My recommendation: never allow user input to touch the file system.
Use generated names on the file system, use encoded hashes, just never user input.
Do you want your urls to contain user input for nice names and for some reason you want emoji and unicode support?
Consider some sort of origin request rewriting to a hash of the user input or use a service like S3 where it is not a path but a logical key.
</p></div></div><div><picture><source type="image/jxl" srcset="/assets/stickers/judges.jxl"/><source type="image/avif" srcset="/assets/stickers/judges.avif"/><source type="image/webp" srcset="/assets/stickers/judges.webp"/><img loading="lazy" alt="judges" src="https://cendyne.dev/assets/stickers/judges.jpg"/></picture></div></div></div><p>Once user input is parsed and structured, throw it away.
Only use the internal value or value object from then on.
In fact, isolate parsing into value types from the business logic that acts on the values supplied from the user.
</p>
<p>Avoid and migrate away from protocols that intermingle, nest, and mix sensitive data with insensitive data.
When anything is sensitive, signed, encrypted, leave it alone as is and only let the audience or intended recipient deal with it (see <code>&#34;aud&#34;</code> on <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/id-tokens">Active Directory id tokens</a>).
</p>
<p>If you&#39;re inventing your own protocol with bytes then encode with lists of fixed element length, if an element is optional use a placeholder for no value / <code>null</code>.
You will be better off if you can also encode the length of the element before the element in your canonicalized output.
</p>
<p>Also practice this stuff before you put it into production.
</p>
<h2 id="Inspiration-for-this-article">Inspiration for this article
</h2>
<p>A twitter user who wishes to remain unnamed reached out to me hinting at another possible way to misuse encoded base64.
Further he hinted that an author with many cited papers will be publishing a study on how many libraries react to non-canonical base64 data.
</p>
<p>Several of the concerns and ideas mentioned had already been covered in <a href="https://cendyne.dev/posts/2022-01-23-base64.html">A base64 surprise</a>.
But one scenario stook out to me!
</p>
<p>That is: abuse of an application through base64 primary keys, including padding removal or addition.
This extends also to base64 malleability where padding bits are altered so the encoded form appears unique and different but the binary form is equivalent.
</p>
<p>I have since gotten in contact with that author and eagerly await to see the paper&#39;s contents.
</p>
<h2 id="Update-2022-02-19">Update 2022-02-19
</h2>
<p>I got in contact with that author and reviewed the paper with some feedback.
</p>
<div><div><div><picture><source type="image/jxl" srcset="/assets/stickers/jittery-excited.jxl"/><source type="image/avif" srcset="/assets/stickers/jittery-excited.avif"/><source type="image/webp" srcset="/assets/stickers/jittery-excited.webp"/><img loading="lazy" alt="jittery-excited" src="https://cendyne.dev/assets/stickers/jittery-excited.jpg"/></picture></div><div><div><p>
Oh cool!
I haven&#39;t done anything like this in 9 years!
The last time I got to be listed as a technical editor on a C++ book.
</p></div></div></div></div>
</div>

</div></div>
  </body>
</html>
