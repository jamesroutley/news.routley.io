<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.zksecurity.xyz/posts/clean/">Original</a>
    <h1>Clean, a formal verification DSL for ZK circuits in Lean4</h1>
    
    <div id="readability-page-1" class="page"><div><p>We are really excited to share our initial steps towards building <strong>clean</strong>, an embedded DSL and formal verification framework for ZK circuits in Lean4.
As we recently shared, Zero Knowledge circuits are <a href="https://bugs.zksecurity.xyz/">full of bugs</a>, but fortunately, techniques like formal verification can provide a huge confidence boost in the correctness of ZK circuits.
Clean enables us to define circuits in Lean4, specify their desired properties, and – most importantly – formally prove them!</p>
<center><iframe width="560" height="315" src="https://www.youtube.com/embed/C2NfJoihXyQ?start=2027" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></center>
<h2 id="objectives">Objectives</h2>
<p>Our objective is to build an embedded DSL for writing zk circuits in Lean4, that allows us to reason about them in a formal way.
We believe that <strong>co-locating circuit definitions with their desired specification and correctness proof</strong> will allow us to create a robust library of reusable formally verified circuit gadgets.</p>
<p>We currently target AIR arithmetization, and we assume to have a table lookup primitive available by the underlying proof system.</p>
<h2 id="how-to-formally-verify-zk-circuits">How to formally verify ZK circuits</h2>
<p>In order to reason formally about ZK circuits, we first need to define a formal model. This involves the following steps:</p>
<ol>
<li>Defining what <strong>primitives</strong> our circuit language supports, i.e., which are the operations that we can use to define circuits.</li>
<li>Defining the <strong>semantics</strong> of such primitives.</li>
<li>Defining what are the <strong>properties</strong> we are interested to formally prove for a given circuit.</li>
</ol>
<p>Our language allows us to specify a <strong>circuit</strong>, which is composed of two main objects.</p>
<ul>
<li>A collection of variables, and</li>
<li>constraints and lookup relations over those variables.
The goal of a zero-knowledge proof system is exactly to convince a verifier that the prover <em>knows</em> a witness (i.e., an assignment of the variables) that <strong>satisfies</strong> the constraints and lookups of a given circuit.</li>
</ul>
<p>At a fundamental level, for a given circuit we are interested in how the satisfaction of the constraints and the witness are related.
In other words: <strong>if a witness satisfies the constraints, what property can we infer about it?</strong></p>
<p>Let’s make a concrete example.
Consider a circuit defined over one variable <code>x</code> and that is composed of only one contraint:</p>
<p>This is a very common gadget that ensures that <code>x</code> is a boolean value, i.e., it is either 0 or 1.
The specification of this ciruit can be expressed as:</p>
<p>Albeit being a very simple example, it shows the basic idea: we are interested in formally proving that if an assignment to the variables satisfies the constraints, then the specification holds as well.
We are also interested in the other direction: if an honest prover holds a witness that satisfies the specification, then there exists an assignment of the variables that satisfies the constraints.
Take the following alternative implementation of a boolean check</p>
<p>This new constraint is <strong>sound</strong>, because the only valid assignment that satifies it is <code>x = 0</code>, which is a boolean value.
However, it is not <strong>complete</strong>, as an honest prover that holds a valid boolean <code>x = 1</code> cannot provide a witness that satisfies the constraint.</p>
<p>More formally, the two properties we want to prove are:</p>
<ul>
<li><strong>Soundness</strong>: if the prover can exhibit any witness that satisfies the constraints and lookup relations defined by the circuit, then some specification property holds over that witness. Proving this property ensures that the circuit is not <strong>underconstrained</strong>.</li>
<li><strong>Completeness</strong>: for every possible input, an honest prover can always exhibit a witness that satisfies the constraints and lookup relations defined by the circuit. Proving this property ensures that the circuit is not <strong>overconstrained</strong>.</li>
</ul>
<h2 id="dsl-design">DSL design</h2>
<p>In our DSL, we support four basic operations for defining circuits.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>inductive</span> <span>Operation</span> (<span>F</span> <span>:</span> <span>Type</span>) [<span>Field</span> <span>F</span>] <span>where</span>
</span></span><span><span>  <span>|</span> witness <span>:</span> (m<span>:</span> <span>ℕ</span>) <span>-&gt;</span> (compute <span>:</span> <span>Environment</span> <span>F</span> <span>-&gt;</span> <span>Vector</span> <span>F</span> m) <span>-&gt;</span> <span>Operation</span> <span>F</span>
</span></span><span><span>  <span>|</span> assert <span>:</span> <span>Expression</span> <span>F</span> <span>-&gt;</span> <span>Operation</span> <span>F</span>
</span></span><span><span>  <span>|</span> lookup <span>:</span> <span>Lookup</span> <span>F</span> <span>-&gt;</span> <span>Operation</span> <span>F</span>
</span></span><span><span>  <span>|</span> subcircuit <span>:</span> {n <span>:</span> <span>ℕ</span>} <span>-&gt;</span> <span>SubCircuit</span> <span>F</span> n <span>-&gt;</span> <span>Operation</span> <span>F</span>
</span></span></code></pre></div><p>Indeed, we can:</p>
<ul>
<li><strong>Witness</strong>: introduce <code>m</code> new variables in the circuit, and add them to the witness.
This operation accepts also a <code>compute</code> function, which represents the <strong>witness generation</strong> function, in the honest prover case.</li>
<li><strong>Assert</strong>: add a new constraint to the circuit.</li>
<li><strong>Lookup</strong>: add a new lookup relation to the circuit. A lookup defines which variables are being looked up and in which other table.</li>
<li><strong>Subcircuit</strong>: add a new subcircuit to the circuit.
The subcircuit is instantiated in the current environment, and the internal variables of the subcircuit are added to the witness.
This is the main way to gain composability of gadgets.</li>
</ul>
<p>To enhance usability, we provide a way to define a circuit using a <strong>monadic interface</strong>, with a lot of convenience functions.
This interface allows us to define the circuits using very natural syntax constructs.</p>
<h2 id="design-of-the-composable-verification-framework">Design of the composable verification framework</h2>
<p>The main building block of our framework is the <code>FormalCircuit</code> structure.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>structure</span> <span>FormalCircuit</span> (<span>F:</span> <span>Type</span>) (β α<span>:</span> <span>TypeMap</span>)
</span></span><span><span>  [<span>Field</span> <span>F</span>] [<span>ProvableType</span> α] [<span>ProvableType</span> β]
</span></span><span><span><span>where</span>
</span></span><span><span>  main<span>:</span> <span>Var</span> β <span>F</span> <span>-&gt;</span> <span>Circuit</span> <span>F</span> (<span>Var</span> α <span>F</span>)
</span></span><span><span>  assumptions<span>:</span> β <span>F</span> <span>-&gt;</span> <span>Prop</span>
</span></span><span><span>  spec<span>:</span> β <span>F</span> <span>-&gt;</span> α <span>F</span> <span>-&gt;</span> <span>Prop</span>
</span></span><span><span>
</span></span><span><span>  soundness<span>:</span>
</span></span><span><span>    <span>∀</span> offset <span>:</span> <span>ℕ</span>, <span>∀</span> env,
</span></span><span><span>    <span>-- for all inputs that satisfy the assumptions</span>
</span></span><span><span>    <span>∀</span> b_var <span>:</span> <span>Var</span> β <span>F</span>, <span>∀</span> b <span>:</span> β <span>F</span>, eval env b_var <span>=</span> b <span>-&gt;</span>
</span></span><span><span>    assumptions b <span>-&gt;</span>
</span></span><span><span>    <span>-- if the constraints hold</span>
</span></span><span><span>    constraints_hold<span>.</span>soundness env (circuit<span>.</span>main b_var <span>|&gt;.</span>operations offset) <span>-&gt;</span>
</span></span><span><span>    <span>-- the spec holds on the input and output</span>
</span></span><span><span>    <span>let</span> a <span>:=</span> eval env (circuit<span>.</span>output b_var offset)
</span></span><span><span>    spec b a
</span></span><span><span>  
</span></span><span><span>  completeness<span>:</span>
</span></span><span><span>    <span>-- for all environments which _use the default witness generators for local variables_</span>
</span></span><span><span>    <span>∀</span> offset <span>:</span> <span>ℕ</span>, <span>∀</span> env, <span>∀</span> b_var <span>:</span> <span>Var</span> β <span>F</span>,
</span></span><span><span>    env<span>.</span>uses_local_witnesses (circuit<span>.</span>main b_var <span>|&gt;.</span>operations offset) <span>-&gt;</span>
</span></span><span><span>    <span>-- for all inputs that satisfy the assumptions</span>
</span></span><span><span>    <span>∀</span> b <span>:</span> β <span>F</span>, eval env b_var <span>=</span> b <span>-&gt;</span>
</span></span><span><span>    assumptions b <span>-&gt;</span>
</span></span><span><span>    <span>-- the constraints hold</span>
</span></span><span><span>    constraints_hold<span>.</span>completeness env (circuit<span>.</span>main b_var <span>|&gt;.</span>operations offset)
</span></span></code></pre></div><p>This structure tightly packages in a dependent-type way, the following objects:</p>
<ul>
<li><code>β</code> and <code>α</code> are respectively the input and output “shapes”, essentially they define a structured collection of elements.</li>
<li><code>main</code>: the circuit definition itself.</li>
<li><code>assumptions</code>: the assumptions that the circuit makes on the inputs. All properties are proved assuming that the input variables satisfy these assumptions.</li>
<li><code>spec</code>: the specification property of the circuit.</li>
<li><code>soundness</code>: proof for soundness of the circuit.</li>
<li><code>completeness</code>: proof for completeness of the circuit.</li>
</ul>
<p>A <code>FormalCircuit</code> encapsulates a formally proved, reusable gadget: when instantiating a <code>FormalCircuit</code> as a subcircuit, we are able to reuse the soundness and completeness proofs of the subcircuit to prove the soundness and completeness properties of the whole circuit.
This is accomplished by <strong>automatically replacing the constraints of a subcircuit with its (formally verified) spec</strong>.
In this way we can formally verify even large circuits by applying a <em>divide-et-impera</em> approach: we start by defining and proving correctness of low-level reusable gadgets, and then combine them to build more and more complex circuits.</p>
<h2 id="a-concrete-example-8-bit-addition">A concrete example: 8-bit addition</h2>
<p>Let’s walk through one of the simple gadgets we have implemented and verified: <a href="https://github.com/Verified-zkEVM/clean/blob/18ce1b6ac7d1a00a1f1ab87b8722a7d9c435f25b/Clean/Gadgets/Addition8/Addition8FullCarry.lean">addition on 8-bit numbers</a>.
This is a gadget that takes as input two bytes and an input carry, and returns the sum of the two bytes modulo 256, and the output carry.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>structure</span> <span>Inputs</span> (<span>F</span> <span>:</span> <span>Type</span>) <span>where</span>
</span></span><span><span>  x<span>:</span> <span>F</span>
</span></span><span><span>  y<span>:</span> <span>F</span>
</span></span><span><span>  carry_in<span>:</span> <span>F</span>
</span></span><span><span>
</span></span><span><span><span>structure</span> <span>Outputs</span> (<span>F</span> <span>:</span> <span>Type</span>) <span>where</span>
</span></span><span><span>  z<span>:</span> <span>F</span>
</span></span><span><span>  carry_out<span>:</span> <span>F</span>
</span></span></code></pre></div><p>Now, we define the assumptions the circuit makes on the input values, and the specification that the circuit should satisfy.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>def</span> assumptions (input <span>:</span> <span>Inputs</span> (<span>F</span> p)) <span>:=</span>
</span></span><span><span>  <span>let</span> { x, y, carry_in } <span>:=</span> input
</span></span><span><span>  x<span>.</span>val <span>&lt;</span> <span>256</span> <span>∧</span> y<span>.</span>val <span>&lt;</span> <span>256</span> <span>∧</span> (carry_in <span>=</span> <span>0</span> <span>∨</span> carry_in <span>=</span> <span>1</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> spec (input <span>:</span> <span>Inputs</span> (<span>F</span> p)) (out <span>:</span> <span>Outputs</span> (<span>F</span> p)) <span>:=</span>
</span></span><span><span>  <span>let</span> { x, y, carry_in } <span>:=</span> input
</span></span><span><span>  out<span>.</span>z<span>.</span>val <span>=</span> (x<span>.</span>val <span>+</span> y<span>.</span>val <span>+</span> carry_in<span>.</span>val) <span>%</span> <span>256</span> <span>∧</span>
</span></span><span><span>  out<span>.</span>carry_out<span>.</span>val <span>=</span> (x<span>.</span>val <span>+</span> y<span>.</span>val <span>+</span> carry_in<span>.</span>val) <span>/</span> <span>256</span>
</span></span></code></pre></div><p>The main circuit is defined as follows.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>def</span> add8_full_carry (input <span>:</span> <span>Var</span> <span>Inputs</span> (<span>F</span> p)) <span>:</span>
</span></span><span><span>    <span>Circuit</span> (<span>F</span> p) (<span>Var</span> <span>Outputs</span> (<span>F</span> p)) <span>:=</span> <span>do</span>
</span></span><span><span>  <span>let</span> { x, y, carry_in } <span>:=</span> input
</span></span><span><span>
</span></span><span><span>  <span>-- witness the result</span>
</span></span><span><span>  <span>let</span> z <span>&lt;-</span> witness (fun eval <span>=&gt;</span> mod_256 (eval (x <span>+</span> y <span>+</span> carry_in)))
</span></span><span><span>
</span></span><span><span>  <span>-- do a lookup over the byte table for z</span>
</span></span><span><span>  lookup (<span>ByteLookup</span> z)
</span></span><span><span>
</span></span><span><span>  <span>-- witness the output carry</span>
</span></span><span><span>  <span>let</span> carry_out <span>&lt;-</span> witness (fun eval <span>=&gt;</span> floordiv (eval (x <span>+</span> y <span>+</span> carry_in)) <span>256</span>)
</span></span><span><span>  
</span></span><span><span>  <span>-- ensures that the output carry is boolean</span>
</span></span><span><span>  <span>-- by instantiating the Boolean.circuit as a subcircuit</span>
</span></span><span><span>  assertion <span>Boolean</span><span>.</span>circuit carry_out
</span></span><span><span>
</span></span><span><span>  <span>-- main 8-bit addition constraint</span>
</span></span><span><span>  assert_zero (x <span>+</span> y <span>+</span> carry_in <span>-</span> z <span>-</span> carry_out <span>*</span> (const <span>256</span>))
</span></span><span><span>
</span></span><span><span>  return { z, carry_out }
</span></span></code></pre></div><p>Finally, we define the <code>FormalCircuit</code> structure, which packages all those definitions, together with the soundness and completeness proofs</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>def</span> circuit <span>:</span> <span>FormalCircuit</span> (<span>F</span> p) <span>Inputs</span> <span>Outputs</span> <span>where</span>
</span></span><span><span>  main <span>:=</span> add8_full_carry
</span></span><span><span>  assumptions <span>:=</span> assumptions
</span></span><span><span>  spec <span>:=</span> spec
</span></span><span><span>  soundness <span>:=</span> by
</span></span><span><span>    <span>...</span>
</span></span><span><span>  completeness <span>:=</span> by
</span></span><span><span>    <span>...</span>
</span></span></code></pre></div><p>Notice that this definition is generic over the field prime <code>p</code>, however we require an additional assumption on the prime, namely $p &gt; 512$, otherwise the circuit is not sound!</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>variable</span> {p <span>:</span> <span>ℕ</span>} [<span>Fact</span> p<span>.</span><span>Prime</span>]
</span></span><span><span><span>variable</span> [p_large_enough<span>:</span> <span>Fact</span> (p <span>&gt;</span> <span>512</span>)]
</span></span></code></pre></div><h2 id="verifying-concrete-air-tables">Verifying concrete AIR tables</h2>
<p>The <code>FormalCircuit</code> abstraction provides a modular definition of verified circuits, and it is mostly arithmetization-agnostic.
However, we want to target <strong>AIR</strong> as a concrete arithmetization, as it is a very popular choice in the zkVM design space.
AIR circuits are defined over <strong>traces</strong>: constraints are specificed together with an <strong>application domain</strong>, which represent which rows they should be applied to.
In principle, one could choose an arbitrary domain, however, in practice we choose domains that have a succinct representation in terms of vanishing polynomial.</p>
<p>Here are some examples of domains that have succinct representations and are used in practice.</p>
<ul>
<li>The constraint is applied to one specific row of the trace. This is often referred to as a <strong>boundary</strong> constraint.</li>
<li>The constraint is applied to all rows of the trace. This is often referred to as a <strong>recurring</strong> constraint. One feature is that constraints applied to every row can access neighbouring rows: for example they could access the next row or the previous row.</li>
<li>The constraint is applied to all rows, except a chosen small set of rows. For example, it could be applied to every row except the last one, or except the first one.</li>
<li>The constraint is applied to every $n$ rows of the trace.</li>
</ul>
<p>As a concrete example, let’s say that we want to give constraint over a trace for computing correctly the <strong>Fibonacci sequence</strong>, which is defined as follows.
$$
\begin{cases}
F_0 = 0 \\
F_1 = 1 \\
F_n = F_{n-2} + F_{n-1}
\end{cases}
$$</p>
<p>We can implement it with a trace composed of two columns: $x$ and $y$.
The invariant we want to prove is: on the $i$-th row, $x_i$ sould contain $F_i$ and $y_i$ should contain $F_{i+1}$.
We can achieve this behaviour by imposing the following contraints.</p>
<ul>
<li>We impose a <strong>boundary</strong> constraint on the first row: $x_0 = 0$ and $y_0 = 1$.</li>
<li>Additionally, we impose two <strong>recurring</strong> constraints, implementing the recursive relation: for every $i$ – except the last one –, $y_{i+1} = x_i + y_i$, and $x_{i+1} = y_i$.</li>
</ul>
<center>
<img src="https://blog.zksecurity.xyz/posts/clean/fib_trace.svg" alt="Fibonacci trace" width="100%"/>
</center>
<p>It is straight-forward to see that if a trace satisfies those constraints, then in the $i$-th row we will find the $i$-th Fibonacci number in the first column.</p>
<p>Notice that this set of constraints can be thought also as defining a correct sequence of <strong>states</strong>, one for each row:</p>
<ul>
<li>the boundary constraint is ensuring that the <strong>initial state is valid</strong>, while</li>
<li>the recurring constraint is ensuring that the <strong>state transition function is executed correctly</strong>.</li>
</ul>
<p>In our framework, we support AIR constraints by:</p>
<ul>
<li>Defining an inductive trace data structure, which we model as a sequence of rows.</li>
<li>Modeling what it means to apply a contraint to a trace using a particular domain: this in practice is done by providing an assignment from abstract variables to concrete trace cells and then applying the original constraint semantics.</li>
</ul>
<p>You can check out the soundness proof for the Fibonacci table using 8-bit addition <a href="https://github.com/Verified-zkEVM/clean/blob/18ce1b6ac7d1a00a1f1ab87b8722a7d9c435f25b/Clean/Tables/Fibonacci8.lean">here</a>, which satisfies the following, slightly more complicated, specification:
$$
\text{For every row } i, \quad x_i = (F_i \mod 256)
$$</p>
<h2 id="upcoming-work">Upcoming work</h2>
<p>The framework is still in early stages fo development, but it is already showing promising results.
Some planned next steps are:</p>
<ul>
<li>Continue adding low-level gadgets so that we have a rich library of basic reusable circuits.</li>
<li>Defining common hash function circuits and proving their correctness.</li>
<li>Build a formally verified minimal VM for a subset of RISC-V.</li>
</ul>
<p>The whole project is open source and available on <a href="https://github.com/Verified-zkEVM/clean">GitHub</a>, make sure to check it out!</p>
</div></div>
  </body>
</html>
