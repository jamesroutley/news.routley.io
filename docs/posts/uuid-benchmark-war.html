<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ardentperf.com/2024/02/03/uuid-benchmark-war/">Original</a>
    <h1>UUID Benchmark War</h1>
    
    <div id="readability-page-1" class="page"><div>
				
<p>This month‚Äôs <a href="https://www.pgsqlphriday.com/rules/">PGSQL Phriday</a> #015 topic is about UUIDs, <a href="https://mydbanotebook.org/post/uuid-fight/">hosted by L√¶titia Avrot</a>. L√¶titia has called for a debate. No, no, no. I say let‚Äôs have an all-out war. A benchmark war.</p>



<p>I have decided to orchestrate a benchmark war between four different methods of storing a primary key:</p>



<ol>
<li>use a text field to store UUIDs</li>



<li>use PostgreSQL‚Äôs native <code>uuid</code> data type</li>



<li>use the new uuidv7 code currently in CommitFest which we‚Äôre hoping will be in PostgreSQL 17 <em>(i think we might still be waiting on something related to the approval process for the official standard)</em></li>



<li>use the classic, efficient, fast, sql-standard <code>bigint generated as identity</code> data type.</li>
</ol>



<p>The challenge is simple: <strong>insert one million rows into a large table, while concurrently querying it, AS FAST AS YOU CAN!!!</strong></p>



<p>Sadly I ran out of time. There‚Äôs one issue with my script, and I know how to fix it, but I need to get this blog published today or I won‚Äôt make the PGSQL Phriday cutoff!!</p>



<p>My problem is a bit amusing‚Ä¶ <strong>the results successfully demonstrate how each option is better than the previous</strong>‚Ä¶ until you get to bigint. I‚Äôve demonstrated the size benefits of bigint but my uuidv7 performance is so good it basically matched bigint üòÇ ‚Äì but I‚Äôm guessing this is because my concurrent queries aren‚Äôt increasing cache pressure by using a uuid column yet‚Ä¶ I suspect fixing this will demonstrate the performance gap between uuidv7 and bigint.</p>



<p>Regardless: there‚Äôs some good and useful stuff here ‚Äì so let‚Äôs go ahead and dive in.</p>



<ol><li><a href="https://ardentperf.com/2024/02/03/uuid-benchmark-war/#results-summary">Results Summary</a></li><li><a href="https://ardentperf.com/2024/02/03/uuid-benchmark-war/#setup-overview">Setup Overview</a></li><li><a href="https://ardentperf.com/2024/02/03/uuid-benchmark-war/#cost">Cost</a></li><li><a href="https://ardentperf.com/2024/02/03/uuid-benchmark-war/#run-overview">Run Overview</a></li><li><a href="https://ardentperf.com/2024/02/03/uuid-benchmark-war/#run-details">Run Details</a></li><li><a href="https://ardentperf.com/2024/02/03/uuid-benchmark-war/#full-benchmark-scripts">Full Benchmark Scripts</a></li></ol>



<h2 id="results-summary">Results Summary</h2>



<figure><table><tbody><tr><td><strong>Test</strong></td><td><strong>Time to Insert One Million Rows</strong></td><td><strong>Average Rate</strong></td><td><strong>Size at Finish</strong></td><td><strong>Performance and Size Improvement</strong></td></tr><tr><td><strong>uuid::text</strong></td><td>410 sec</td><td>2421 tps</td><td>4.31 gb</td><td>‚Äì</td></tr><tr><td><strong>uuidv4</strong></td><td>375 sec</td><td>2670 tps</td><td>2.65 gb</td><td>10% faster and </td></tr><tr><td><strong>uuidv7</strong></td><td>290 sec</td><td>3420 tps</td><td>2.47 gb</td><td>30% faster and </td></tr><tr><td><strong>bigint</strong></td><td>290 sec</td><td>3480 tps</td><td>1.97 gb</td><td>same speed (in this test) and </td></tr></tbody></table></figure>



<figure><a href="https://ardentperf.files.wordpress.com/2024/02/image-4.png"><img data-attachment-id="3251" data-permalink="https://ardentperf.com/2024/02/03/uuid-benchmark-war/image-4-2/" data-orig-file="https://ardentperf.files.wordpress.com/2024/02/image-4.png" data-orig-size="3110,1732" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-4" data-image-description="" data-image-caption="" data-medium-file="https://ardentperf.files.wordpress.com/2024/02/image-4.png?w=300" data-large-file="https://ardentperf.files.wordpress.com/2024/02/image-4.png?w=750" width="1024" height="570" src="https://ardentperf.files.wordpress.com/2024/02/image-4.png?w=1024" alt="" srcset="https://ardentperf.files.wordpress.com/2024/02/image-4.png?w=1024 1024w, https://ardentperf.files.wordpress.com/2024/02/image-4.png?w=2048 2048w, https://ardentperf.files.wordpress.com/2024/02/image-4.png?w=150 150w, https://ardentperf.files.wordpress.com/2024/02/image-4.png?w=300 300w, https://ardentperf.files.wordpress.com/2024/02/image-4.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<figure><a href="https://ardentperf.files.wordpress.com/2024/02/image-5.png"><img data-attachment-id="3252" data-permalink="https://ardentperf.com/2024/02/03/uuid-benchmark-war/image-5-2/" data-orig-file="https://ardentperf.files.wordpress.com/2024/02/image-5.png" data-orig-size="3108,1734" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-5" data-image-description="" data-image-caption="" data-medium-file="https://ardentperf.files.wordpress.com/2024/02/image-5.png?w=300" data-large-file="https://ardentperf.files.wordpress.com/2024/02/image-5.png?w=750" width="1024" height="571" src="https://ardentperf.files.wordpress.com/2024/02/image-5.png?w=1024" alt="" srcset="https://ardentperf.files.wordpress.com/2024/02/image-5.png?w=1024 1024w, https://ardentperf.files.wordpress.com/2024/02/image-5.png?w=2048 2048w, https://ardentperf.files.wordpress.com/2024/02/image-5.png?w=150 150w, https://ardentperf.files.wordpress.com/2024/02/image-5.png?w=300 300w, https://ardentperf.files.wordpress.com/2024/02/image-5.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<h2 id="setup-overview">Setup Overview</h2>



<p>This benchmark is fully scripted and reproducible, based on my <a href="https://ardentperf.com/2024/01/08/copy-and-paste-a-new-postgres-dev-env-in-5-min/">Copy-and-Paste Postgres Dev Env</a>. Anyone can reproduce with a few simple copy-and-paste steps; the full details are at the bottom of this blog post.</p>



<p><strong>Processor:</strong> 1 full core AMD EPYC Genoa, 3.7 GHz, 1 thread per core, 2GB memory (ec2 c7a.medium)</p>



<p><strong>Schema:</strong> single table with 3 columns (id, foreign_table_id and data::bigint), data type for <code>id</code> and <code>foreign_table_id</code> follows the test</p>



<p><em>Aside: The new c7a/m7a/r7a EC2 instance family is interesting because of the switch to core-per-vCPU, similar to graviton. While the top-end <strong>r7i</strong>.48xlarge (intel) has 96 physical cores with hyperthreading, the top-end <strong>r7a</strong>.48xlarge (amd) is a beast with 192 physical cores and 1.5TB of memory. I look forward to playing with PostgreSQL on one of these machines someday.</em> üèá</p>



<h2 id="cost">Cost</h2>



<p>While my copy-and-paste-dev-env defaults to the free tier, I switched to a non-bursting instance family and added some beefy gp3 storage for this performance test.</p>



<p>The storage is significantly over-provisioned and could definitely be scaled down on all three dimensions to save quite a bit of money. I was in a hurry to make the publishing deadline and didn‚Äôt take the time to optimize this part.</p>



<p>It took a total of 4 hours and 13 minutes to run the benchmark 3 times in a row.‚ÄÇThe setup steps are copy-and-paste and take less than 10 minutes so lets round up to 4.5 hours.‚ÄÇI also repeated the full test (three loops) on a second server to verify performance consistency. According to the official AWS pricing calculator at <a href="https://calculator.aws/#/">calculator.aws</a> this is the cost breakdown:</p>



<ul>
<li>ec2 r7a.medium on-demand pricing: $0.07608/hr</li>



<li>ebs gp3 100GB 16k iops 100 MBps throughput: $0.14795/hr</li>



<li>two servers complete benchmark in 4.5 hours = total 9 hours</li>
</ul>



<p><strong>GRAND TOTAL for both servers = US$ 2.02</strong></p>



<p>Less than a cup of coffee.</p>



<p>Holy smokes batman ‚Äì do we live in a different world than 20 years ago when it comes to the price of benchmarking or what?!! Also why is coffee so expensive?</p>



<p>Of course I had it running a bit longer while I was iterating and getting things ironed out, but I think the point stands. üôÇ</p>



<h2 id="run-overview">Run Overview</h2>



<p>Tests:</p>



<ol>
<li><code>bigint generated by default as identity (cache 20)</code></li>



<li><code>text default gen_random_uuid()</code></li>



<li><code>uuid default gen_random_uuid()</code></li>



<li><code>uuid default uuidv7()</code> <em>(current proposed syntax; may change before future release)</em></li>
</ol>



<p>Workload:</p>



<pre><code>INIT_TABLE_ROWS=20000000</code></pre>



<h2 id="run-details">Run Details</h2>



<p>I ran the test on two servers, and on each server the whole test was repeated three times. Performance was consistent across both servers and all loops.</p>



<pre><code>grep &#34;tps,&#34; test_log.txt</code></pre>



<figure><a href="https://ardentperf.files.wordpress.com/2024/02/image-6.png"><img data-attachment-id="3258" data-permalink="https://ardentperf.com/2024/02/03/uuid-benchmark-war/image-6-2/" data-orig-file="https://ardentperf.files.wordpress.com/2024/02/image-6.png" data-orig-size="2890,1754" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-6" data-image-description="" data-image-caption="" data-medium-file="https://ardentperf.files.wordpress.com/2024/02/image-6.png?w=300" data-large-file="https://ardentperf.files.wordpress.com/2024/02/image-6.png?w=750" width="1024" height="621" src="https://ardentperf.files.wordpress.com/2024/02/image-6.png?w=1024" alt="" srcset="https://ardentperf.files.wordpress.com/2024/02/image-6.png?w=1024 1024w, https://ardentperf.files.wordpress.com/2024/02/image-6.png?w=2046 2046w, https://ardentperf.files.wordpress.com/2024/02/image-6.png?w=150 150w, https://ardentperf.files.wordpress.com/2024/02/image-6.png?w=300 300w, https://ardentperf.files.wordpress.com/2024/02/image-6.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>One quick note ‚Äì there is a dip in the TPS around 300 seconds. I haven‚Äôt verified in the logs but I suspect this is just the system checkpoint kicking in; I force a checkpoint right before starting each test and PostgreSQL defaults to 5 minute intervals.‚ÄÇ(And we increased the <code>max_wal_size</code> so that we wouldn‚Äôt get an early checkpoint.)</p>



<p>The data load of 20 million records took significantly longer for uuid::text than the other tests, which is reflected in the table sizes tracked over time.</p>



<pre><code>while true; do</code></pre>



<figure><a href="https://ardentperf.files.wordpress.com/2024/02/image-9.png"><img data-attachment-id="3265" data-permalink="https://ardentperf.com/2024/02/03/uuid-benchmark-war/image-9/" data-orig-file="https://ardentperf.files.wordpress.com/2024/02/image-9.png" data-orig-size="2340,1700" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-9" data-image-description="" data-image-caption="" data-medium-file="https://ardentperf.files.wordpress.com/2024/02/image-9.png?w=300" data-large-file="https://ardentperf.files.wordpress.com/2024/02/image-9.png?w=750" loading="lazy" width="1024" height="743" src="https://ardentperf.files.wordpress.com/2024/02/image-9.png?w=1024" alt="" srcset="https://ardentperf.files.wordpress.com/2024/02/image-9.png?w=1024 1024w, https://ardentperf.files.wordpress.com/2024/02/image-9.png?w=2045 2045w, https://ardentperf.files.wordpress.com/2024/02/image-9.png?w=150 150w, https://ardentperf.files.wordpress.com/2024/02/image-9.png?w=300 300w, https://ardentperf.files.wordpress.com/2024/02/image-9.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>The best way to get a fast, high-level look at what‚Äôs happening internally with PosgreSQL is to use wait events.‚ÄÇWe will zoom in on the higlighted section above, with <code>uuid</code> runs from the first loop and <code>bigint</code> from the second loop.</p>



<p>It‚Äôs immediately obvious that the biggest difference between the runs is the amount of time spent in <code>IO:DataFileRead</code> by database connections executing SQL.</p>



<pre><code>while true; do</code></pre>



<figure><a href="https://ardentperf.files.wordpress.com/2024/02/image-10-5.png"><img data-attachment-id="3304" data-permalink="https://ardentperf.com/2024/02/03/uuid-benchmark-war/image-10-5/" data-orig-file="https://ardentperf.files.wordpress.com/2024/02/image-10-5.png" data-orig-size="2690,1630" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-10-5" data-image-description="" data-image-caption="" data-medium-file="https://ardentperf.files.wordpress.com/2024/02/image-10-5.png?w=300" data-large-file="https://ardentperf.files.wordpress.com/2024/02/image-10-5.png?w=750" loading="lazy" width="1024" height="620" src="https://ardentperf.files.wordpress.com/2024/02/image-10-5.png?w=1024" alt="" srcset="https://ardentperf.files.wordpress.com/2024/02/image-10-5.png?w=1024 1024w, https://ardentperf.files.wordpress.com/2024/02/image-10-5.png?w=2046 2046w, https://ardentperf.files.wordpress.com/2024/02/image-10-5.png?w=150 150w, https://ardentperf.files.wordpress.com/2024/02/image-10-5.png?w=300 300w, https://ardentperf.files.wordpress.com/2024/02/image-10-5.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>We need to read blocks from the disk when they are not in the PostgreSQL buffer cache. Conveniently, PostgreSQL makes it very easy to inspect the contents of the buffer cache. This is where the big difference between uuidv4 and uuidv7 becomes clear. Because of the lack of data locality in uuidv4 data, the primary key index is consuming a huge amount of the buffer cache in order to support new data being inserted ‚Äì and this cache space is no longer available for other indexes and tables, and this significantly slows down the entire workload. Putting it another way: for some workloads uuidv4 significantly increases the total working set size.</p>



<pre><code>while true; do</code></pre>



<figure><a href="https://ardentperf.files.wordpress.com/2024/02/image-10-4.png"><img data-attachment-id="3303" data-permalink="https://ardentperf.com/2024/02/03/uuid-benchmark-war/image-10-4/" data-orig-file="https://ardentperf.files.wordpress.com/2024/02/image-10-4.png" data-orig-size="2892,1756" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-10-4" data-image-description="" data-image-caption="" data-medium-file="https://ardentperf.files.wordpress.com/2024/02/image-10-4.png?w=300" data-large-file="https://ardentperf.files.wordpress.com/2024/02/image-10-4.png?w=750" loading="lazy" width="1024" height="621" src="https://ardentperf.files.wordpress.com/2024/02/image-10-4.png?w=1024" alt="" srcset="https://ardentperf.files.wordpress.com/2024/02/image-10-4.png?w=1024 1024w, https://ardentperf.files.wordpress.com/2024/02/image-10-4.png?w=2045 2045w, https://ardentperf.files.wordpress.com/2024/02/image-10-4.png?w=150 150w, https://ardentperf.files.wordpress.com/2024/02/image-10-4.png?w=300 300w, https://ardentperf.files.wordpress.com/2024/02/image-10-4.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>PostgreSQL uses a clock sweep algorithm to manage its cache.‚ÄÇThis is different from the linux page cache active/inactive system; PostgreSQL tracks a ‚Äúusage count‚Äù on each buffer that can range from 0 to 5. The usage count is incremented any time a block already in the cache is used, and decremented any time a connection needs to use a block that isn‚Äôt currently in the cache ‚Äì it sweeps through the cache and looks for a block that‚Äôs eligible for eviction, decrementing usage counts as it goes. Hot blocks like index root nodes naturally maintain a high usage count and stay in the cache. Cache management algorithms are always an interesting topic (for example, see <a href="https://brooker.co.za/blog/2023/12/15/sieve.html">Marc Brooker‚Äôs recent blog article about SIEVE</a>). I am a fan of PostgreSQL‚Äôs current algorithm ‚Äì I think it works well and it‚Äôs easy to understand and reason about.</p>



<p>Not too long ago, Nathan Bossart added a very light-weight function to PostgreSQL to allow more detailed inspection of usage count data. Lets see what it looked like for this zoomed in time window.</p>



<pre><code>while true; do</code></pre>



<figure><a href="https://ardentperf.files.wordpress.com/2024/02/image-10-1.png"><img data-attachment-id="3273" data-permalink="https://ardentperf.com/2024/02/03/uuid-benchmark-war/image-10-1/" data-orig-file="https://ardentperf.files.wordpress.com/2024/02/image-10-1.png" data-orig-size="2892,1754" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-10-1" data-image-description="" data-image-caption="" data-medium-file="https://ardentperf.files.wordpress.com/2024/02/image-10-1.png?w=300" data-large-file="https://ardentperf.files.wordpress.com/2024/02/image-10-1.png?w=750" loading="lazy" width="1024" height="621" src="https://ardentperf.files.wordpress.com/2024/02/image-10-1.png?w=1024" alt="" srcset="https://ardentperf.files.wordpress.com/2024/02/image-10-1.png?w=1024 1024w, https://ardentperf.files.wordpress.com/2024/02/image-10-1.png?w=2048 2048w, https://ardentperf.files.wordpress.com/2024/02/image-10-1.png?w=150 150w, https://ardentperf.files.wordpress.com/2024/02/image-10-1.png?w=300 300w, https://ardentperf.files.wordpress.com/2024/02/image-10-1.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>I‚Äôve looked at a number of charts like this from different workloads over the past year or two. My experience has been that when the data set fits in the cache we see everything at usage count 5 (as expected), and when the working set is larger than the cache there‚Äôs always a spectrum between hot and cold similar to this picture. And the balance across the spectrum reflects the balance of pressure between hits and misses on the cache. I‚Äôve seen where a single large query can cause a spike in lower-usage-count buffers, and then the lines slope back downward as the workload pushes usage counts back up. In this particular workload, we see the large blocks of usage count 5 during initial data load before the data set reaches 1GB and we see the spectrum of usage counts once it exceeds 1GB. During the benchmark itself, the lines slope very slightly upward because our benchmark is adding a million rows, so we‚Äôre slowly increasing the total working set size, which causes more cache miss pressure relative to cache hits.</p>



<p>Interesting stuff! Hope this makes it clear why you should never store your UUIDs in a text field, and why some of us are excited for uuidv7 when it‚Äôs eventually ready.‚ÄÇIt should also be clear how even with uuidv7 there is still a total size penalty for choosing UUID (128-bit) over bigint (64-bit). And hopefully we can demonstrate at some point in the future how that can translate into performance impact for some workloads.</p>



<h2 id="full-benchmark-scripts">Full Benchmark Scripts</h2>



<p>To run this benchmark, <strong>follow the instructions at</strong> <a href="https://ardentperf.com/2024/01/08/copy-and-paste-a-new-postgres-dev-env-in-5-min/">Copy-and-Paste Postgres Dev Env</a> with the following modifications:</p>



<figure><table><tbody><tr><td></td><td>Open the web page <a href="https://ardentperf.com/2024/01/08/copy-and-paste-a-new-postgres-dev-env-in-5-min/">Copy-and-Paste Postgres Dev Env</a> and begin following those steps. Make the adjustments listed below.</td></tr><tr><td>step1</td><td>Copy the following command to switch to c7a.medium and a gp3 volume with the specs above:</td></tr><tr><td>step4</td><td>After checking out the PostgreSQL source code, copy the following commands to switch to a commit from January 29 2024 and apply v17 of the UUIDv7 patch from the PostgreSQL mailing lists.</td></tr><tr><td>step5</td><td>After compiling PostgreSQL, copy the following commands to apply two custom parameters before we start running our benchmark.</td></tr><tr><td>benchmark</td><td>The benchmark is very simple and straightforward. I‚Äôve copied the code into a GIST that you can copy or download.</td></tr></tbody></table></figure>

				

				
							</div></div>
  </body>
</html>
