<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikarow.land/notes/gleam-favorite-feature">Original</a>
    <h1>My Favorite Gleam Feature</h1>
    
    <div id="readability-page-1" class="page"><section id="My-Favorite-Gleam-Feature">

<p>I found myself liking Gleam’s syntax more than any other language that I’ve used.<label for="fn1"></label><span></span> This article follows the path of logic as I tried to unravel why.</p>
<p>My journey to understanding started with a simple question:</p>
<p>Why are Gleam’s functions backwards compared to Erlang and Python? Specifically, why are the arguments to Gleam’s <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#map"><code>list.map</code></a> in reverse order as compared Erlang’s <a href="https://www.erlang.org/doc/man/lists#map-2"><code>lists.map</code></a>?</p>
<section id="Reverse-Order">
<h2>Reverse Order</h2>
<p>Gleam’s <code>list.map</code> has the following signature:<label for="fn2"></label><span></span></p>
<pre><code>pub fn map(list: List(a), fun: fn(a) -&gt; b) -&gt; List(b)
</code></pre>
<p>Gleam takes a <code>List</code> as its first argument, and a function to map over the list, second.</p>
<p>By contrast, here is the signature of Erlang’s <code>lists.map</code>:</p>
<pre><code>map(Fun, List1) -&gt; List2
</code></pre>
<p>Erlang takes a function as the first argument and a list as the second argument.</p>
<p>Similarly, Python’s <a href="https://docs.python.org/3/library/functions.html#map"><code>map()</code></a> looks the same way:<label for="fn3"></label><span></span></p>
<pre><code>map(function, iterator) -&gt; iterator
</code></pre>
<p>In order to understand why Gleam is backwards, we need to understand why Erlang and Python are forwards. Why are Erlang’s and Python’s functions arranged that way?</p>
</section>
<section id="Partial-Application">
<h2>Partial Application</h2>
<p>Haskell shows a justification for why they’re created that way.<label for="fn4"></label><span></span></p>
<p>In Haskell, all functions are implicitly curried. That is, they’re secretly all functions that take one argument and return other functions.</p>
<p>This makes it easy to partially apply a function:</p>
<pre><code>mapPlusOne = map (+1)
</code></pre>
<p>Here, I’ve created a <code>mapPlusOne</code> function that takes a list of numbers and returns a list of those numbers with 1 added to them. Haskell’s currying means that I can accomplish this by simply putting the two functions next to each other.</p>
<p>In this way, <code>map</code> is “partially applied” and instead of getting back a list, I’ve created a useful function that I can reuse.</p>
<p>Partial application is most useful when the most generic part of the function is set in the first argument, getting more specific as you go to the right.</p>
<p>This makes it easy to “cut off” a function in a partially applied but generally useful state.</p>
<p>By contrast, if <code>map</code> was arranged like Gleam, then the partial application would be less useful:</p>
<pre><code>mapOnSpecificList = map [1,2,3] --insert function here
</code></pre>
<p>It’s far more likely that I’ll want to vary the input to a specific modification function, than to vary the modification function to a specific input. Data often changes more quickly than logic.</p>
<p>Python is following in these footsteps and provides <a href="https://docs.python.org/3/library/functools.html#functools.partial"><code>functools.partial</code></a> to accomplish similar things to Haskell:<label for="fn5"></label><span></span><label for="fn6"></label><span></span></p>
<pre><code>from functools import partial
map_plus_one = partial(map, lambda x: x + 1)
</code></pre>
<p>Erlang seems to have been influenced by the same ideas.</p>
<p>Okay, now we understand why Erlang’s functions are the way they are, why are Gleam’s functions backwards?</p>
</section>
<section id="Pipe-Operator">
<h2>Pipe Operator</h2>
<p>Gleam has a <a href="https://gleam.run/book/tour/functions.html#pipe-operator">pipe operator</a> <code>|&gt;</code> that will take the value on the left, and try to pass it in as the first argument of the function on the right. It looks like this:</p>
<pre><code>[1,2,3] |&gt; list.map(fn(x) { x + 1})
</code></pre>
<p>Gleam’s <code>list.map</code> takes two arguments, in the example above we’re able to write <code>list.map(fn(x) { x + 1})</code> because the pipe operator is silently filling the first argument with the list on the left side. This becomes a bit clearer if we use Gleam’s capture operator syntax:<label for="fn7"></label><span></span><label for="fn8"></label><span></span></p>
<pre><code>[1,2,3] |&gt; list.map(_, fn(x) { x + 1})
</code></pre>
<p>This has the same effect as calling the function directly with that value:</p>
<pre><code>list.map([1,2,3], fn(x) { x + 1})
</code></pre>
<p>The pipe operator has the benefit of making data transformations more “sentence”-like. Since the operator moves left to right, a series of pipe operators can transform data in the same direction as native English speakers read language:</p>
<pre><code>[1,2,3] 
|&gt; list.map(fn(x) { x + 1}) 
|&gt; list.filter(fn(x) { x &gt; 2 }) 
|&gt; list.at(1) // Ok(4)
</code></pre>
<p>Haskell, by contrast (often)<label for="fn9"></label><span></span> ends up having a right to left flow to its logic. The specific details are finalized on the right, and then transformed by functions as the calls are made to the left:<label for="fn10"></label><span></span><label for="fn11"></label><span></span></p>
<pre><code>(!! 1)
  . filter (&gt;2)
  . map (+1)
  $ [1,2,3]
-- 4
</code></pre>
<p>While I do love the pipe operator, we still haven’t answered the question: Why are Gleam’s functions backwards? To understand that, we need to explore another property of Gleam.</p>
</section>
<section id="method-like-functions">
<h2>“method”-like functions</h2>
<p>There are other languages that don’t have the pipe operator that do have this left to right directionality to data transformations.</p>
<p>Method chaining gives us a similar ability to read transformations left to right. For example in Javascript:<label for="fn12"></label><span></span></p>
<pre><code>[1,2,3]
  .map(x =&gt; { return x + 1})
  .filter(x =&gt; { return x &gt; 2})
  .at(1);
</code></pre>
<p>So before, when I said that Gleam’s functions are backwards compared to Python, that was technically true. But in practice, methods are far more common in Python than functions. Python method signatures all begin with <code>self</code>, similarly Rust’s methods also being with <code>self</code> as their first given argument.</p>
<p>For example, Rust’s <code>Iterator.map</code> method has this signature:<label for="fn13"></label><span></span></p>
<pre><code>fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
where
  F: Fn(Self::Item) -&gt; B
</code></pre>
<p>It returns type <code>Map</code> because it’s lazy, but otherwise the signature looks a lot like Gleam’s <code>list.map</code>.</p>
<p>Looking more closely at Gleam, we see a similar pattern: all of the functions in <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html"><code>gleam/list</code></a> take a value of type <code>List</code> as their first argument. And nearly all them return a <code>List</code> allowing pipe operator “chaining” to happen. In this way, Gleam’s functions are “method”-like, in that their signatures line up with what we would expect from method signatures in Python or Rust.<label for="fn14"></label><span></span></p>
<p>However, there is a substantial difference between Gleam and these method chaining languages: Gleam doesn’t have methods.</p>
</section>
<section id="Lack-of-methods">
<h2>Lack of methods</h2>
<p>Gleam<label for="fn15"></label><span></span> doesn’t have methods. All functions are associated with modules, and not with specific data. This comes as a consequence of Gleam’s default immutability.<label for="fn16"></label><span></span> When I pass a list to <code>list.map</code>, it returns a new list without mutating the original.</p>
<p>This gives us referential transparency, which means that a function given the same inputs will always have the same output. This makes it easy to reason about Gleam code, since seeing the inputs and logic of the function is enough to see what the function is going to do.</p>
<p>The net result of this lack of methods, is that the primary way to compose code in Gleam is to use the pipe operator.<label for="fn17"></label><span></span><label for="fn18"></label><span></span></p>
<p>So now Gleam has a pipe operator, and makes it the primary way to compose code, there’s one more quality of Gleam that enables my favorite feature:</p>
</section>
<section id="A-culture-of-qualified-imports">
<h2>A culture of qualified imports</h2>
<p>By default an <a href="https://gleam.run/book/tour/modules.html#import"><code>import</code></a> declaration in a Gleam module is qualified. That means that instead of dumping the functions and types from the imported module into the the current module’s namespace, they’re accessible by prefixing the imported modules name:</p>
<pre><code>import other_module

pub fn main() {
  other_module.useful_function(...)
}
</code></pre>
<p>To prevent this prefixing from getting unwieldy, Gleam will use the last part of the import path as the namespace:<label for="fn19"></label><span></span><label for="fn20"></label><span></span></p>
<pre><code>import gleam/list

pub fn main() {
  // instead of gleam/list.map
  [1,2,3] |&gt; list.map(...)
}
</code></pre>
<p>Gleam does allow for unqualified imports, where functions can be used directly the current modules namespace, but they must be enumerated explicitly:</p>
<pre><code>import gleam/list.{map, filter}

pub fn main() {
  [1,2,3]
  |&gt; map(fn(x) { x + 1})
  |&gt; filter(fn(x) { x &gt; 2})
}
</code></pre>
<p>However, Gleam warns against unqualified imports in the <a href="https://gleam.run/book/tour/modules.html#unqualified-import">language tour</a>:</p>
<blockquote>
<p>This may be useful for values that are used frequently in a module, but generally qualified imports are preferred as it <strong>makes it clearer where the value is defined</strong>.<label for="fn21"></label><span></span></p>
</blockquote>
<p>It is the combination of these three factors: a language designed around pipe operator, a lack of methods in the language, and a culture of qualified imports that leads to my favorite feature of Gleam:</p>
</section>
<section id="My-Favorite-Feature-Discoverability">
<h2>My Favorite Feature: Discoverability</h2>
<p>As a consequence of these three factors working in combination, I can visibly see which modules each function in a data transformation pipeline come from. For example in:</p>
<pre><code>import gleam/list

[1,2,3]
|&gt; list.map(...)
|&gt; list.filter(...)
|&gt; list.at(...)
</code></pre>
<p>I know where <code>map</code> and <code>filter</code> and <code>at</code> come from, and I can easily look up the documentation for <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html"><code>gleam/list</code></a> to understand more about each function and what other functions are available. The implementation details of a function in Gleam are plain to see and easy to learn more about.</p>
<p>So my favorite feature of Gleam, is that it’s discoverable. I can read someone else’s code and understand each every module that they chose to use, and where every function comes from.<label for="fn22"></label><span></span></p>
<p>This discoverability makes it a joy to read source code written in Gleam. I’ve improved as a software engineer as a consequence of being able to learn from the core libraries of my favorite language.</p>
<p>Thank you to John, <a href="https://theo-harris-dev.com">Theodore</a>, <a href="https://ntietz.com/">Nicole</a>, <a href="https://hachyderm.io/@jmeowmeow">Jeff</a>, Miccah, and <a href="https://jakelazaroff.com">Jake</a> for helping me write and edit this article. And thank you to the Gleam discord for helping me validate some of these concepts.</p>
</section>
</section></div>
  </body>
</html>
