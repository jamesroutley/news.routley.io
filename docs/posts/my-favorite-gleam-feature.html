<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikarow.land/notes/gleam-favorite-feature">Original</a>
    <h1>My Favorite Gleam Feature</h1>
    
    <div id="readability-page-1" class="page"><section id="My-Favorite-Gleam-Feature">

<p>I found myself liking Gleam’s syntax more than any other language that I’ve used.<label for="fn1"></label><span><span>With the specific exception of Elixir, where many of these insights took root. I chose to focus this article on Gleam, but both Elixir and Gleam share this feature.</span></span> This article follows the path of logic as I tried to unravel why.</p>
<p>My journey to understanding started with a simple question:</p>
<p>Why are Gleam’s functions backwards compared to Erlang and Python? Specifically, why are the arguments to Gleam’s <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#map"><code>list.map</code></a> in reverse order as compared Erlang’s <a href="https://www.erlang.org/doc/man/lists#map-2"><code>lists.map</code></a>?</p>
<section id="Reverse-Order">
<h2>Reverse Order</h2>
<p>Gleam’s <code>list.map</code> has the following signature:<label for="fn2"></label><span><span>Slightly simplified. The <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#map">actual signature</a> has a <code>with</code> <a href="https://gleam.run/book/tour/functions.html#labelled-arguments">label</a> on the function argument, which allows for <code>list.map([1,2,3], with: fn(x) { x + 1})</code>.</span></span></p>
<pre><code>pub fn map(list: List(a), fun: fn(a) -&gt; b) -&gt; List(b)
</code></pre>
<p>Gleam takes a <code>List</code> as its first argument, and a function to map over the list, second.</p>
<p>By contrast, here is the signature of Erlang’s <code>lists.map</code>:</p>
<pre><code>map(Fun, List1) -&gt; List2
</code></pre>
<p>Erlang takes a function as the first argument and a list as the second argument.</p>
<p>Similarly, Python’s <a href="https://docs.python.org/3/library/functions.html#map"><code>map()</code></a> looks the same way:<label for="fn3"></label><span><span>Technically, the return type hint in Python3 would look different, but for the sake of expediency, I’m using <code>-&gt; iterator</code>.</span></span></p>
<pre><code>map(function, iterator) -&gt; iterator
</code></pre>
<p>In order to understand why Gleam is backwards, we need to understand why Erlang and Python are forwards. Why are Erlang’s and Python’s functions arranged that way?</p>
</section>
<section id="Partial-Application">
<h2>Partial Application</h2>
<p>Haskell shows a justification for why they’re created that way.<label for="fn4"></label><span><span>And it is the other way, Haskell’s <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Prelude.html#v:map"><code>map</code></a> is arranged like Erlang’s.</span></span></p>
<p>In Haskell, all functions are implicitly curried. That is, they’re secretly all functions that take one argument and return other functions.</p>
<p>This makes it easy to partially apply a function:</p>
<pre><code>mapPlusOne = map (+1)
</code></pre>
<p>Here, I’ve created a <code>mapPlusOne</code> function that takes a list of numbers and returns a list of those numbers with 1 added to them. Haskell’s currying means that I can accomplish this by simply putting the two functions next to each other.</p>
<p>In this way, <code>map</code> is “partially applied” and instead of getting back a list, I’ve created a useful function that I can reuse.</p>
<p>Partial application is most useful when the most generic part of the function is set in the first argument, getting more specific as you go to the right.</p>
<p>This makes it easy to “cut off” a function in a partially applied but generally useful state.</p>
<p>By contrast, if <code>map</code> was arranged like Gleam, then the partial application would be less useful:</p>
<pre><code>mapOnSpecificList = map [1,2,3] --insert function here
</code></pre>
<p>It’s far more likely that I’ll want to vary the input to a specific modification function, than to vary the modification function to a specific input. Data often changes more quickly than logic.</p>
<p>Python is following in these footsteps and provides <a href="https://docs.python.org/3/library/functools.html#functools.partial"><code>functools.partial</code></a> to accomplish similar things to Haskell:<label for="fn5"></label><span><span>I’m editorializing a bit, <code>functools.partial</code> wasn’t added to Python until <a href="https://github.com/python/cpython/blob/main/Misc/HISTORY#L18905">version 2.5 in 2006</a>.</span><span>Python’s <code>map()</code> <em>has</em> always been explicitly for functional programming, as noted in the release notes for <a href="https://github.com/python/cpython/blob/main/Misc/HISTORY#L33166C34-L33166C34">Python 1.0.0</a>: “New built-in functions <code>map()</code>, <code>filter()</code> and <code>reduce()</code> perform standard functional programming operations”.</span></span><label for="fn6"></label><span><span>Interestingly, Lisp introduced a <code>mapList</code> function in <a href="https://www.softwarepreservation.org/projects/LISP/MIT/LISP_Prog_Man-Mar_1959.pdf/view">1959</a>, but it took the arguments in Gleam’s order: <code>mapList(L,f)</code>.</span><span>Nearly every other language uses the <code>map(function, list)</code> order, as shown on <a href="https://en.wikipedia.org/wiki/Map_%28higher-order_function%29#Language_comparison">Wikipedia</a>.</span><span>From this table, only Elixir, <a href="https://en.wikipedia.org/wiki/Haxe">Haxe</a>, <a href="https://en.wikipedia.org/wiki/R_%28programming_language%29">R</a>, and <a href="https://en.wikipedia.org/wiki/XQuery">XQuery</a> have non-method functions in Gleam’s order.</span></span></p>
<pre><code>from functools import partial
map_plus_one = partial(map, lambda x: x + 1)
</code></pre>
<p>Erlang seems to have been influenced by the same ideas.</p>
<p>Okay, now we understand why Erlang’s functions are the way they are, why are Gleam’s functions backwards?</p>
</section>
<section id="Pipe-Operator">
<h2>Pipe Operator</h2>
<p>Gleam has a <a href="https://gleam.run/book/tour/functions.html#pipe-operator">pipe operator</a> <code>|&gt;</code> that will take the value on the left, and try to pass it in as the first argument of the function on the right. It looks like this:</p>
<pre><code>[1,2,3] |&gt; list.map(fn(x) { x + 1})
</code></pre>
<p>Gleam’s <code>list.map</code> takes two arguments, in the example above we’re able to write <code>list.map(fn(x) { x + 1})</code> because the pipe operator is silently filling the first argument with the list on the left side. This becomes a bit clearer if we use Gleam’s capture operator syntax:<label for="fn7"></label><span><span>As noted in the <a href="https://gleam.run/book/tour/functions.html#function-capturing">language tour</a>, this is such a common operation that the former is simply a special shorthand for the latter.</span></span><label for="fn8"></label><span><span>In Elixir, the pipe operator is literally just a macro that takes <code>[1,2,3] |&gt; a_function(other, args)</code> and replaces it with <code>a_function([1,2,3], other, args)</code> during compilation.</span></span></p>
<pre><code>[1,2,3] |&gt; list.map(_, fn(x) { x + 1})
</code></pre>
<p>This has the same effect as calling the function directly with that value:</p>
<pre><code>list.map([1,2,3], fn(x) { x + 1})
</code></pre>
<p>The pipe operator has the benefit of making data transformations more “sentence”-like. Since the operator moves left to right, a series of pipe operators can transform data in the same direction as native English speakers read language:</p>
<pre><code>[1,2,3] 
|&gt; list.map(fn(x) { x + 1}) 
|&gt; list.filter(fn(x) { x &gt; 2 }) 
|&gt; list.at(1) // Ok(4)
</code></pre>
<p>Haskell, by contrast (often)<label for="fn9"></label><span><span>It’s worth noting that Haskell has a left-to-right composition operator <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Control-Arrow.html#v:-62--62--62-"><code>&gt;&gt;&gt;</code></a> and a reverse application operator which works like a pipe <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Function.html#v:-38-"><code>&amp;</code></a>, but in practice I don’t see it being used anywhere near as pervasively as the pipe operator in Gleam.</span></span> ends up having a right to left flow to its logic. The specific details are finalized on the right, and then transformed by functions as the calls are made to the left:<label for="fn10"></label><span><span>Haskell’s equivalent to the <code>list.at</code> function is the <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Prelude.html#v:-33--33-"><code>!!</code> operator</a>. By default all operators in Haskell are infix, but they can be turned into prefix form by wrapping them in parentheses. In this case, I also partially apply <code>!!</code> with index 1.</span></span><label for="fn11"></label><span><span>The <code>!!</code> operator is different from <code>list.at</code> in one way: Gleam’s version returns a result type, whereas Haskell’s version raises an error on an index missing from the list. I did find <a href="https://hackage.haskell.org/package/relude-1.2.1.0/docs/Relude-List.html#v:maybeAt">maybeAt</a> which returns a <code>Maybe</code>, Haskell’s version of result, but it’s in a library in not in Haskell’s standard library.</span></span></p>
<pre><code>(!! 1)
  . filter (&gt;2)
  . map (+1)
  $ [1,2,3]
-- 4
</code></pre>
<p>While I do love the pipe operator, we still haven’t answered the question: Why are Gleam’s functions backwards? To understand that, we need to explore another property of Gleam.</p>
</section>
<section id="method-like-functions">
<h2>“method”-like functions</h2>
<p>There are other languages that don’t have the pipe operator that do have this left to right directionality to data transformations.</p>
<p>Method chaining gives us a similar ability to read transformations left to right. For example in Javascript:<label for="fn12"></label><span><span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Here’s</a> the documentation for the Array <code>map</code> method. The other two methods are similar.</span></span></p>
<pre><code>[1,2,3]
  .map(x =&gt; { return x + 1})
  .filter(x =&gt; { return x &gt; 2})
  .at(1);
</code></pre>
<p>So before, when I said that Gleam’s functions are backwards compared to Python, that was technically true. But in practice, methods are far more common in Python than functions. Python method signatures all begin with <code>self</code>, similarly Rust’s methods also being with <code>self</code> as their first given argument.</p>
<p>For example, Rust’s <code>Iterator.map</code> method has this signature:<label for="fn13"></label><span><span>This signature has been simplified for clarity, you can confirm it against the real signature <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map">here</a>.</span></span></p>
<pre><code>fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
where
  F: Fn(Self::Item) -&gt; B
</code></pre>
<p>It returns type <code>Map</code> because it’s lazy, but otherwise the signature looks a lot like Gleam’s <code>list.map</code>.</p>
<p>Looking more closely at Gleam, we see a similar pattern: all of the functions in <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html"><code>gleam/list</code></a> take a value of type <code>List</code> as their first argument. And nearly all them return a <code>List</code> allowing pipe operator “chaining” to happen. In this way, Gleam’s functions are “method”-like, in that their signatures line up with what we would expect from method signatures in Python or Rust.<label for="fn14"></label><span><span>The lack of this design in command line applications is part of why unix’s <a href="https://en.wikipedia.org/wiki/Xargs#Placement_of_arguments"><code>xargs</code></a> exists, to “fix” pipelines with the arguments the wrong way around.</span></span></p>
<p>However, there is a substantial difference between Gleam and these method chaining languages: Gleam doesn’t have methods.</p>
</section>
<section id="Lack-of-methods">
<h2>Lack of methods</h2>
<p>Gleam<label for="fn15"></label><span><span>And Elixir.</span></span> doesn’t have methods. All functions are associated with modules, and not with specific data. This comes as a consequence of Gleam’s default immutability.<label for="fn16"></label><span><span>Gleam’s Erlang target allows you to manage state with living processes, and its Javascript target has support for <a href="https://hexdocs.pm/gleam_javascript/gleam/javascript/array.html">mutable arrays</a>.</span></span> When I pass a list to <code>list.map</code>, it returns a new list without mutating the original.</p>
<p>This gives us referential transparency, which means that a function given the same inputs will always have the same output. This makes it easy to reason about Gleam code, since seeing the inputs and logic of the function is enough to see what the function is going to do.</p>
<p>The net result of this lack of methods, is that the primary way to compose code in Gleam is to use the pipe operator.<label for="fn17"></label><span><span>There’s also the <a href="https://gleam.run/book/tour/use.html"><code>use</code> expression</a>, but that’s primarily syntax sugar for working with callbacks.</span></span><label for="fn18"></label><span><span>This lack of options is seems to be by design. Gleam has one happy path for doing things and not much room for alternate conventions. This ends up working in favor of my favorite feature.</span></span></p>
<p>So now Gleam has a pipe operator, and makes it the primary way to compose code, there’s one more quality of Gleam that enables my favorite feature:</p>
</section>
<section id="A-culture-of-qualified-imports">
<h2>A culture of qualified imports</h2>
<p>By default an <a href="https://gleam.run/book/tour/modules.html#import"><code>import</code></a> declaration in a Gleam module is qualified. That means that instead of dumping the functions and types from the imported module into the the current module’s namespace, they’re accessible by prefixing the imported modules name:</p>
<pre><code>import other_module

pub fn main() {
  other_module.useful_function(...)
}
</code></pre>
<p>To prevent this prefixing from getting unwieldy, Gleam will use the last part of the import path as the namespace:<label for="fn19"></label><span><span>In Elixir, all modules are always available at their fully qualified name <code>Module.Path.Here</code>, and you need to use the <a href="https://hexdocs.pm/elixir/1.12/Kernel.SpecialForms.html#alias/2"><code>alias</code></a> macro in order to shorten that prefix.</span><span>For example: <code>alias Module.Path.Here</code> will allow that module to be used as <code>Here</code>.</span><span>I prefer Gleam’s design here.</span></span><label for="fn20"></label><span><span>In fact, Gleam forces you to use the shortened prefix: <code>gleam/list.map</code> will raise an error. It does allow the <a href="https://gleam.run/book/tour/modules.html#named-import"><code>as</code></a> keyword to rename this qualified import if there’s a conflict.</span></span></p>
<pre><code>import gleam/list

pub fn main() {
  // instead of gleam/list.map
  [1,2,3] |&gt; list.map(...)
}
</code></pre>
<p>Gleam does allow for unqualified imports, where functions can be used directly the current modules namespace, but they must be enumerated explicitly:</p>
<pre><code>import gleam/list.{map, filter}

pub fn main() {
  [1,2,3]
  |&gt; map(fn(x) { x + 1})
  |&gt; filter(fn(x) { x &gt; 2})
}
</code></pre>
<p>However, Gleam warns against unqualified imports in the <a href="https://gleam.run/book/tour/modules.html#unqualified-import">language tour</a>:</p>
<blockquote>
<p>This may be useful for values that are used frequently in a module, but generally qualified imports are preferred as it <strong>makes it clearer where the value is defined</strong>.<label for="fn21"></label><span><span>Emphasis mine.</span></span></p>
</blockquote>
<p>It is the combination of these three factors: a language designed around pipe operator, a lack of methods in the language, and a culture of qualified imports that leads to my favorite feature of Gleam:</p>
</section>
<section id="My-Favorite-Feature-Discoverability">
<h2>My Favorite Feature: Discoverability</h2>
<p>As a consequence of these three factors working in combination, I can visibly see which modules each function in a data transformation pipeline come from. For example in:</p>
<pre><code>import gleam/list

[1,2,3]
|&gt; list.map(...)
|&gt; list.filter(...)
|&gt; list.at(...)
</code></pre>
<p>I know where <code>map</code> and <code>filter</code> and <code>at</code> come from, and I can easily look up the documentation for <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html"><code>gleam/list</code></a> to understand more about each function and what other functions are available. The implementation details of a function in Gleam are plain to see and easy to learn more about.</p>
<p>So my favorite feature of Gleam, is that it’s discoverable. I can read someone else’s code and understand each every module that they chose to use, and where every function comes from.<label for="fn22"></label><span><span>In a language with method chaining, a Language Server grants you write-time discoverability. You can add a <code>.</code> and hit tab, and discover all of the currently available methods.</span><span>However, at read time, this discoverability is lost, making it hard to understand which trait or type or object or class implements the method that you’re currently dealing with.</span><span>Often classes will reuse method names, overloading a given term, and making harder to search for where that method is implemented.</span></span></p>
<p>This discoverability makes it a joy to read source code written in Gleam. I’ve improved as a software engineer as a consequence of being able to learn from the core libraries of my favorite language.</p>
<p>Thank you to John, <a href="https://theo-harris-dev.com">Theodore</a>, <a href="https://ntietz.com/">Nicole</a>, <a href="https://hachyderm.io/@jmeowmeow">Jeff</a>, Miccah, and <a href="https://jakelazaroff.com">Jake</a> for helping me write and edit this article. And thank you to the Gleam discord for helping me validate some of these concepts.</p>
</section>
</section></div>
  </body>
</html>
