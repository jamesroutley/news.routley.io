<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://refactoringenglish.com/blog/software-essays-that-shaped-me/">Original</a>
    <h1>Software essays that shaped me</h1>
    
    <div id="readability-page-1" class="page"><div><section><article><header></header><p>I started reading software blogs before I got my first programming job 20 years ago. At this point, Iâ€™ve read thousands of blog posts and essays about software, but only a small handful stuck in my mind and changed the way I think.</p><ol><li><a href="#-by-joel-spolsky-2000">â€œThe Joel Test: 12 Steps to Better Codeâ€ by Joel Spolsky (2000)</a></li><li><a href="#-by-alexis-king-2019">â€œParse, donâ€™t validateâ€ by Alexis King (2019)</a></li><li><a href="#-by-fred-brooks-1986">â€œNo Silver Bullet - Essence and Accident in Software Engineeringâ€ by Fred Brooks (1986)</a></li><li><a href="#-by-joel-spolsky-2000-1">â€œChoicesâ€ by Joel Spolsky (2000)</a></li><li><a href="#-by-raymond-chen-2010">â€œApplication compatibility layers are there for the customer, not for the programâ€ by Raymond Chen (2010)</a></li><li><a href="#-by-erik-kuefler-2014">â€œDonâ€™t Put Logic in Testsâ€ by Erik Kuefler (2014)</a></li><li><a href="#-by-julia-evans-2020">â€œA little bit of plain Javascript can do a lotâ€ by Julia Evans (2020)</a></li><li><a href="#-by-dan-mckinley-2015">â€œChoose Boring Technologyâ€ by Dan McKinley (2015)</a></li><li><a href="#-by-terence-eden-2022">â€œIâ€™ve locked myself out of my digital lifeâ€ by Terence Eden (2022)</a></li><li><a href="#bonus-brad-fitzpatrick-on-parsing-user-input-2009">Bonus: Brad Fitzpatrick on parsing user input (2009)</a></li></ol><h2 id="-by-joel-spolsky-2000"><a href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/">â€œThe Joel Test: 12 Steps to Better Codeâ€</a> by Joel Spolsky (2000)<a href="#-by-joel-spolsky-2000">ğŸ”—</a></h2><p>Joel Spolsky is the greatest software blogger of all time. His essays have informed so much of my approach to software that it was hard to pick out just one, but â€œThe Joel Testâ€ is my favorite.</p><p>The Joel Test is a set of 12 questions that employers can ask themselves to see how well theyâ€™re investing in their software team:</p><blockquote><ol><li>Do you use source control?</li><li>Can you make a build in one step?</li><li>Do you make daily builds?</li><li>Do you have a bug database?</li><li>Do you fix bugs before writing new code?</li><li>Do you have an up-to-date schedule?</li><li>Do you have a spec?</li><li>Do programmers have quiet working conditions?</li><li>Do you use the best tools money can buy?</li><li>Do you have testers?</li><li>Do new candidates write code during their interview?</li><li>Do you do hallway usability testing?</li></ol></blockquote><p>Some of the questions are dated, but the point was never the questions themselves but rather the meta-point of the questions.</p><p>Joel was really asking employers: <strong>do you respect developers?</strong></p><p>The questions all assess whether an employer prioritizes their developersâ€™ time and focus over things like cheap office space and short-term deadlines.</p><p>Joel published this article at the height of the dot-com boom, when skilled developers were a precious resource, but not everyone realized it, including developers themselves.</p><p>Joelâ€™s blog always presented programmers as rare, delicate geniuses that employers needed to pursue and pamper. I liked that.</p><p>Throughout my career, I sought out employers that scored well on the Joel test, and Iâ€™m grateful to Joel for giving me the map to find them.</p><h2 id="-by-alexis-king-2019"><a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">â€œParse, donâ€™t validateâ€</a> by Alexis King (2019)<a href="#-by-alexis-king-2019">ğŸ”—</a></h2><p>This essay is about leveraging the type system in Haskell to â€” wait, wait! Donâ€™t go to sleep.</p><p>If you donâ€™t care about type systems or Haskell, I get it. I donâ€™t either. But this essay radically changed the way I think about software. You can use Alexisâ€™ technique outside of Haskell in any language that supports static types (e.g., Go, C++, Rust).</p><p>The highly abridged version of the essay is that whenever you validate any data, you should convert it to a new type.</p><p>Suppose that your app has a rule limiting usernames to a maximum of 20 alphanumeric characters. The naÃ¯ve solution would be to define a function that looks like this:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>validateUsername</span>(username <span>string</span>) <span>error</span> { ... }
</span></span></code></pre></div><p>With the above function, you run <code>validateUsername</code> anytime you receive a username from a user.</p><p>The problem with this approach is that your code is unsafe by default. You have to remember to validate every username you receive, so itâ€™s easy to create a code path that accidentally processes a username without validating it. And if a nefarious user notices the mistake, they can do tricky things like embed malicious code in the username field or stuff it with a billion characters to fill up your database.</p><p>Alexisâ€™ solution is to instead use a function like this:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>parseUsername</span>(raw <span>string</span>) (Username, <span>error</span>) { ... }
</span></span></code></pre></div><p>In the rest of your codebase, instead of passing around a <code>string</code> called â€œusername,â€ you use a custom type: <code>Username</code>. The only function that can create a <code>Username</code> is <code>parseUsername</code>, and it applies validation rules before returning a <code>Username</code> instance.</p><p>Therefore, if you have a <code>Username</code> instance, it must contain a valid username. Otherwise, it couldnâ€™t exist.</p><p>You canâ€™t forget to validate a username because untrusted input will always be a <code>string</code>, and you canâ€™t pass a <code>string</code> to a function that expects a <code>Username</code>.</p><p>Before Alexisâ€™ essay, I thought type systems were just a fun way to distract language nerds. â€œParse, donâ€™t validateâ€ opened my eyes to how valuable compiler features can be in improving an applicationâ€™s security and reliability.</p><h2 id="-by-fred-brooks-1986"><a href="https://www.cs.unc.edu/techreports/86-020.pdf">â€œNo Silver Bullet - Essence and Accident in Software Engineeringâ€</a> by Fred Brooks (1986)<a href="#-by-fred-brooks-1986">ğŸ”—</a></h2><p>In college, I read <em>The Mythical Man-Month</em>, a collection of essays about software engineering by Fred Brooks, drawing on his experience directing <a href="https://en.wikipedia.org/wiki/OS/360_and_successors">IBMâ€™s OS/360 project</a>.</p><p>The essays were hit or miss. Some felt too old to be relevant, even in 2002, but the one that stuck with me was, â€œNo Silver Bullet.â€</p><p>The essay argues that you can divide software work into two categories: essential complexity and accidental complexity.</p><p><strong>Essential complexity</strong> is the work that you absolutely have to do, regardless of your tooling and hardware. For example, if you write software that calculates bonuses for salespeople, you have to define formulas for those bonuses and cover all possible edge cases. This work is the same if you have a $5B supercomputer or a $1 microcontroller.</p><p><strong>Accidental complexity</strong> is everything else: dealing with memory leaks, waiting for your code to compile, figuring out how to use a third-party library. The better your tooling and hardware resources, the less time you spend on accidental complexity.</p><p>Given this model, Brooks concluded that it was impossible for any advancement in tooling or hardware to create a 10x improvement in developer productivity:</p><blockquote><p>How much of what software engineers now do is still devoted to the accidental, as opposed to the essential? Unless it is more than 9/10 of all effort, shrinking all the accidental activities to zero time will not give an order of magnitude improvement.</p></blockquote><p>Throughout my career, people have been trying to find ways to eliminate programmers from software. For a few years, no-code platforms generated buzz by promising non-programmers all the powers of a seasoned web developer.</p><p>Brooksâ€™ essay always reassured me that the latest buzzword platforms could never replace developers, as the platforms focused on the accidental, not the essential. Even if the platforms could magically create working code from a functional specification, you still need someone to write the spec:</p><blockquote><p>I believe the hard part of building software to be the specification, design, and testing of this conceptual construct, not the labor of representing it and testing the fidelity of the representation.</p></blockquote><p>Modern AI has thrown a wrench into Brooksâ€™ theory, as it actually <em>does</em> reduce essential complexity. You can hand AI an incomplete or contradictory specification, and the AI will fill in the gaps by cribbing from similar specifications.</p><p>Even if AI eliminates programming as we know it, Brooksâ€™ essay gives me hope that weâ€™ll still need people to manage essential complexity at whatever level of abstraction that ends up being.</p><h2 id="-by-joel-spolsky-2000-1"><a href="https://www.joelonsoftware.com/2000/04/12/choices/">â€œChoicesâ€</a> by Joel Spolsky (2000)<a href="#-by-joel-spolsky-2000-1">ğŸ”—</a></h2><p>I said <a href="#-by-joel-spolsky-2000">above</a> that it was hard to pick a single favorite Joel Spolsky essay, which is why Iâ€™ve chosen two.</p><p>â€œChoicesâ€ is about creating user interfaces and the subtle costs of giving a user power:</p><blockquote><p><strong>Every time you provide an option, youâ€™re asking the user to make a decision.</strong> That means they will have to think about something and decide about it. Itâ€™s not necessarily a bad thing, but, in general, you should always try to minimize the number of decisions that people have to make.</p></blockquote><p>As an example, Joel shares a ridiculous dialog that appears in Windows 98 when you try to search the help documentation:</p><p><a href="https://refactoringenglish.com/blog/software-essays-that-shaped-me/Stupidest_Dialog_Ever.gif"><img sizes="(min-width: 768px) 470px, 98vw" srcset="/blog/software-essays-that-shaped-me/Stupidest_Dialog_Ever.gif 470w" src="https://refactoringenglish.com/blog/software-essays-that-shaped-me/Stupidest_Dialog_Ever.gif" alt="" loading="lazy"/></a></p><p>The dialog infuriates Joel because it interrupts the user while theyâ€™re trying to get help, and it asks them to make an uninformed about database optimization. Windows was shirking a decision and pushing it onto the user.</p><p>Joelâ€™s essay focuses on graphical user interfaces, but I think about it wherever people might encounter my code, including on the command-line or other developers calling functions I wrote. Can I make a useful decision on my userâ€™s behalf while still giving them power over things they care about? There are countless times where Joelâ€™s essay has saved me from pushing a decision onto the user that I could make myself.</p><h2 id="-by-raymond-chen-2010"><a href="https://devblogs.microsoft.com/oldnewthing/20100311-00/?p=14643">â€œApplication compatibility layers are there for the customer, not for the programâ€</a> by Raymond Chen (2010)<a href="#-by-raymond-chen-2010">ğŸ”—</a></h2><p>Raymond Chen is one of the longest-serving developers on the Microsoft Windows team. His blog has thousands of informative, entertaining stories about the history of Windows programming, but the one I think back to most is one about compatibility mode in Windows Vista.</p><p>A customer had contacted Raymondâ€™s team with this request:</p><blockquote><p>Hi, we have a program that was originally designed for Windows XP and Windows Server 2003, but we found that it runs into difficulties on Windows Vista. Weâ€™ve found that if we set the program into Windows XP compatibility mode, then the program runs fine on Windows Vista. What changes do we need to make to our installer so that when the user runs it on Windows Vista, it automatically runs in Windows XP compatibility mode?</p></blockquote><p>Raymond proceeds to characterize the customerâ€™s request as follows:</p><blockquote><p>I normally toss my garbage on the sidewalk in front of the pet store, and every morning, when they open up, somebody sweeps up the garbage and tosses it into the trash. But the pet store isnâ€™t open on Sundays, so on Sundays, the garbage just sits there. How can I get the pet store to open on Sundays, too?</p></blockquote><p>I loved this analogy. The metaphor was so funny that I didnâ€™t realize until just now that Raymond is in the wrong. Heâ€™s making fun of a developer whose sin is expecting Windows not to break their app after a single release.</p><p>But as is the case with a lot of Raymond Chenâ€™s writing, itâ€™s so funny and sharp that I can look past the flaws.</p><p>Even though I disagree with the specifics, Raymondâ€™s post is an excellent lesson in influencing user behavior.</p><p>If you want to nudge the user to do something that helps you, think carefully about the path of least resistance from the userâ€™s perspective, because thatâ€™s the path theyâ€™ll take.</p><p>If you show the user that dumping garbage on the sidewalk completely solves their problem, theyâ€™re going to keep dumping their garbage on the sidewalk.</p><h2 id="-by-erik-kuefler-2014"><a href="https://testing.googleblog.com/2014/07/testing-on-toilet-dont-put-logic-in.html">â€œDonâ€™t Put Logic in Testsâ€</a> by Erik Kuefler (2014)<a href="#-by-erik-kuefler-2014">ğŸ”—</a></h2><p>Iâ€™ve always loved unit testing and took great pride in my test code. Thatâ€™s why I was so horrified when this essay <a href="https://testing.googleblog.com/2024/12/tech-on-toilet-driving-software.html">appeared in my bathroom</a> and revealed that Iâ€™d been writing awful tests my whole career.</p><p>Erikâ€™s essay shows the following unit test, which has a subtle bug:</p><div><pre tabindex="0"><code data-lang="java"><span><span>@Test <span>public</span> <span>void</span> <span>shouldNavigateToPhotosPage</span>() {
</span></span><span><span>  String baseUrl = <span>&#34;http://plus.google.com/&#34;</span>;
</span></span><span><span>  Navigator nav = <span>new</span> Navigator(baseUrl);
</span></span><span><span>  nav.goToPhotosPage();
</span></span><span><span>  assertEquals(baseUrl + <span>&#34;/u/0/photos&#34;</span>, nav.getCurrentUrl());
</span></span><span><span>}
</span></span></code></pre></div><p>When I first read the essay, I thought, â€œThatâ€™s exactly how I write unit tests!â€</p><p>Why duplicate the <code>http://plus.google.com/</code> string in two places? Create a single source of truth, just like in production code. I did this all the time, adding helper functions, variables, and loops to eliminate redundancy from my tests.</p><p>The problem with the approach above is that it masks a subtle bug. Itâ€™s actually asserting that the URL looks like this:</p><div><pre tabindex="0"><code data-lang="text"><span><span>http://plus.google.com//u/0/photos
</span></span><span><span>                      ^^
</span></span><span><span>                    whoops
</span></span></code></pre></div><p>Erikâ€™s essay made me realize that I shouldnâ€™t treat test code like production code at all. The two have <a href="https://mtlynch.io/good-developers-bad-tests/#test-code-is-not-like-other-code">completely different goals and constraints</a>.</p><p>Good test code should be, above all, clear. Test code doesnâ€™t have its own test code, so the only way to verify correctness is by inspection. A test should make it blindingly obvious to the reader what behavior it asserts. In service of that goal, you can accept redundancy to reduce complexity.</p><h2 id="-by-julia-evans-2020"><a href="https://jvns.ca/blog/2020/06/19/a-little-bit-of-plain-javascript-can-do-a-lot/">â€œA little bit of plain Javascript can do a lotâ€</a> by Julia Evans (2020)<a href="#-by-julia-evans-2020">ğŸ”—</a></h2><p>As a software engineer, I was embarrassingly late to the web. For the first 10 years of my career, I only wrote code for desktop apps and backend servers. I never bothered with HTML or JavaScript until 2017.</p><p>By the time I got serious about learning frontend development, my impression was that JavaScript was a mess of a language, <a href="https://www.computer.org/csdl/magazine/co/2012/02/mco2012020007/13rRUy08MzA">hacked together in 10 days</a>, and it had drastically different behavior in different browsers. If I was going to write web apps, I wanted something modern and sleek to protect me from all of JavaScriptâ€™s bile and warts.</p><p>So, I tried the popular web frameworks of the day: Angular, React, and Vue. I learned enough Vue to make my way around, but I was still spending an enormous amount of my time on dependency issues and framework gotchas. After all the work these frontend frameworks did to fix JavaScript, web programming still sucked.</p><p>Then, I read Juliaâ€™s essay, and I realized Iâ€™d been so confident that JavaScript needed fixing that I never gave it a chance.</p><p>At the time, I was working on <a href="https://mtlynch.io/tinypilot/">the prototype of TinyPilot</a>, which would become my first commercially successful software product. TinyPilot had a web interface that I was planning to implement with Vue, but Juliaâ€™s essay inspired me to see how far I could go with plain JavaScript. No framework, no wrapper libraries, no build step, no Node.js, just regular old JavaScript. Okay, not â€œoldâ€ â€” more like <a href="https://en.wikipedia.org/wiki/ECMAScript_version_history#9th_edition_%E2%80%93_ECMAScript_2018">ES2018</a>, but you know.</p><p>I kept expecting to hit some problem where Iâ€™d need to switch to some kind of framework or builder, but it never happened. There were still some gotchas, especially around WebComponents, but it was nothing compared to the suffering I endured with Vue and Angular.</p><p>I loved being free of the frameworks. When I had a runtime error, the stack trace wasnâ€™t some minified, transmogrified, tree-shakified fever dream of my code. I was debugging <em>my code</em>, exactly as I wrote it. Why hadnâ€™t I tried this sooner?</p><p>My biases about JavaScript were wrong. Modern JavaScript is pretty nice. It absorbed a lot of ideas from wrapper libraries, so now you donâ€™t need the wrappers. And browsers got their act together to ensure consistent behavior across platforms and devices.</p><p>I havenâ€™t integrated a JavaScript framework or build step into any new project since 2020, and Iâ€™ve never looked back. Plain JavaScript gets me 90% of the benefit of frameworks with 5% of the headache.</p><h2 id="-by-dan-mckinley-2015"><a href="https://mcfunley.com/choose-boring-technology">â€œChoose Boring Technologyâ€</a> by Dan McKinley (2015)<a href="#-by-dan-mckinley-2015">ğŸ”—</a></h2><p>This is an odd essay to include in this list because Iâ€™ve never actually read it.</p><p>People have quoted this essay to me, and once I understood the idea, it felt so intuitive that I didnâ€™t need to read it. In my interview with <a href="https://corecursive.com/">CoRecursive podcast</a> host Adam Gordon Bell, he talked about how there are certain non-fiction books where, once you understand the idea, <a href="https://refactoringenglish.com/blog/interview-adam-gordon-bell/#crafting-blog-post-titles">all you need is the title</a>. â€œChoose Boring Technologyâ€ is that for me.</p><p>Danâ€™s argument is that when you start a new project, youâ€™re tempted to use cutting-edge technology that has lots of buzz. Google just announced a new database that scales to exabytes, and itâ€™s 40% faster than Postgres at 20% the cost. Youâ€™d be an idiot to use Postgres when this sexy new alternative is right there!</p><p>In practice, the new technology has bugs and weaknesses, but theyâ€™re not obvious to you yet; theyâ€™re not obvious to anyone yet. So, when you run into them, youâ€™re stuck. Postgres has its issues, but after 30 years in the field, it has battle-tested solutions for any problem youâ€™re likely to encounter.</p><p>Dan concedes that you should use new technologies sometimes but only strategically and in limited quantities. He suggests that every business gets three â€œinnovation tokensâ€ to spend. If you want a flashy new database, youâ€™ll have to spend one of your tokens.</p><p>Danâ€™s essay dovetails naturally with Juliaâ€™s essay. I wish Iâ€™d read either of them before I wasted all that time with frontend frameworks.</p><h2 id="-by-terence-eden-2022"><a href="https://shkspr.mobi/blog/2022/06/ive-locked-myself-out-of-my-digital-life/">â€œIâ€™ve locked myself out of my digital lifeâ€</a> by Terence Eden (2022)<a href="#-by-terence-eden-2022">ğŸ”—</a></h2><p>Terence Eden is a delightful and eclectic technology blogger. He writes several new posts each week, but the one that impacted me the most was â€œIâ€™ve locked myself out of my digital life.â€</p><p>The article plays out what would happen if lightning struck Terenceâ€™s house and destroyed all of his possessions. He keeps his passwords to everything in a password manager, but if all his devices get destroyed, he canâ€™t access his password manager. And he canâ€™t fall back to hardware passkeys because those were in his house, too.</p><p>I always felt like I was pretty safe about my data because I store everything on redundant drives, and I have offsite backups on three continents with two vendors.</p><p>Terenceâ€™s post got me thinking about the many credible threats that could wipe out all of my devices simultaneously: fire, flood, electrical surge, criminal investigation. All of my data is encrypted with passwords that live in my head, so add to that list memory loss, incapacitation, or death.</p><p>Online services are bad at helping users recover from disaster. I use several services that assume itâ€™s impossible for me to ever lose my phone, let alone my email account and every digital device in my possession.</p><p>Ever since I read Terenceâ€™s essay, Iâ€™ve been thinking more about which services and devices are critical to me, and how I could recover from a scenario like the one Terence described. The next time I bought a laptop, I set it up at the library to test whether I could recover access to my password manager and critical accounts without any of the devices in my house.</p><p>I still could do a better job at digital disaster preparedness, but Terenceâ€™s post always echoes in my head whenever I think about how to secure my devices and data. What if everything was suddenly destroyed?</p><h2 id="bonus-brad-fitzpatrick-on-parsing-user-input-2009">Bonus: Brad Fitzpatrick on parsing user input (2009)<a href="#bonus-brad-fitzpatrick-on-parsing-user-input-2009">ğŸ”—</a></h2><p>Itâ€™s technically not an essay, but thereâ€™s a quote from a software interview I constantly think about.</p><p>In 2009, as a result of <a href="https://www.joelonsoftware.com/2009/09/23/the-duct-tape-programmer/">Joel Spolskyâ€™s gushing review</a>, (yes, again with the Joel), I read <a href="https://codersatwork.com/"><em>Coders at Work</em></a>, a collection of interviews with accomplished programmers.</p><p><a href="https://en.wikipedia.org/wiki/Brad_Fitzpatrick">Brad Fitzpatrick</a>, creator of <a href="https://en.wikipedia.org/wiki/LiveJournal">LiveJournal</a> and <a href="https://en.wikipedia.org/wiki/Memcached">Memcached</a>, appears in the book as one of the interviewees. He was only 28 years old at the time, the youngest programmer in the book and also the sweariest and most entertaining.</p><p>In response to a question about ethics in software engineering, Brad goes on an impassioned rant about input validation:</p><blockquote><p>I would like to ask that everyone is consistent on their credit-card forms to like let me put in fucking spaces or hypens. Computers are good at removing that shit. Like donâ€™t tell me how to format my numbers.</p><p>-Brad Fitzpatrick, in <em>Coders at Work</em></p></blockquote><p>I think back to this quote whenever I try to paste a phone number into a web form, and it whines that parentheses or spaces arenâ€™t allowed. Or worse, it truncates my phone number because of the parentheses, and <em>also</em> complains that parentheses arenâ€™t allowed.</p><p>Whenever I create input fields in my software and think about unexpected characters, I hear Brad Fitzpatrick say, â€œComputers are good at removing that shit.â€</p></article></section></div></div>
  </body>
</html>
