<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://cipht.net/2023/11/21/worried-by-wordexp.html">Original</a>
    <h1>worried by wordexp(3)</h1>
    
    <div id="readability-page-1" class="page"><div id="universe">
<div id="post">
<h2><a href="http://cipht.net/2023/11/21/worried-by-wordexp.html">worried by wordexp(3)</a>
<span>
<time>November 21, 2023</time>
<span>[c, posix]</span>
</span>
</h2>
<p>
The function <code>wordexp(3)</code> is a POSIX C standard library function which
performs &#34;word expansion like a POSIX shell&#34;. <code>wordexp(3)</code> combines
the safety of elaborate string parsing in C with the efficiency and
robustness of invoking the shell on arbitrary user input. Why does it
even exist? And why shouldn&#39;t you use it?
</p>
<div id="outline-container-orge618007">
<h2 id="orge618007"><span>1.</span> usage</h2>
<div id="text-1">
<p>
Probably the most legit use is by <code>init</code>-style programs executing a
command line (e.g. <a href="https://sources.debian.org/src/finit/4.2-1/src/service.c/?hl=520#L520">finit</a>); though, since many wordexp implementations
invoke the shell anyway, these might as well exec <code>sh -c &#39;exec ...&#39;</code>
instead.
</p>
<p>
Applications typically use <code>wordexp</code> to expand tildes and globs
(<code>~/*.txt</code>), and are oblivious to its excessive powers. Mostly, these
uses are in places like configuration files the user directly
controls, so any disasters as a consequence of <code>wordexp</code> can be
considered the user&#39;s fault.
</p>
<p>
More severe are the cases where wordexp&#39;s input comes from an
untrusted source<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup> or the program is in question is
setuid<sup><a id="fnr.2" href="#fn.2" role="doc-backlink">2</a></sup>. Sometimes people use it when parsing files, even
(e.g. this <a href="https://github.com/syoyo/tinygltf/issues/368">tinygltf issue</a> ended up affecting <a href="https://projects.blender.org/blender/blender/commit/466eb426ed96f2112494cc9ee12997255a6aaae2">blender</a>).<sup><a id="fnr.3" href="#fn.3" role="doc-backlink">3</a></sup>
</p>
<p>
I continue to find code copied from Stack Overflow where it remains
recommended, despite it being unsafe, and probably slow, too.
</p>
<p>
All this would just make wordexp seem like just another call like
<code>popen</code> or <code>system</code> where it&#39;s obvious that you&#39;re opening Pandora&#39;s
box, except wordexp has a flag, <code>WRDE_NOCMD</code>, intended to prevent the
worst abuses of it. The existence of this flag is a mistake, because
almost no libc actually tries to make it consistently safe. This flag
may imply to people that wordexp is ever safe to use on untrusted
input. However <code>WRDE_NOCMD</code> is effectively broken depending on the
combination of shell and libc in use.
</p>
</div>
</div>
<div id="outline-container-org36fb4cf">
<h2 id="org36fb4cf"><span>2.</span> a central problem</h2>
<div id="text-2">
<p>
Command substitution has two forms in shell: backtick-delimited
(<code>`command`</code>) and dollar-parenthesized (<code>$(command)</code>). The former
presents more problems for the user, but fewer for the author of the
parser: simply scan ahead for a matching backtick, obeying other
escaping and quoting.
</p>
<p>
The latter form is often where first-time shell writers fall into
despair. It may be nested, and contain content-dependent unbalanced
parentheses <sup><a id="fnr.4" href="#fn.4" role="doc-backlink">4</a></sup>. The lexer must mutually-recursively
invoke the parser just to find the end of the token.
</p>
<p>
The POSIX standard is ambiguous about a concerning detail of shell
syntax: the difference between command and arithmetic substitution.
Don&#39;t expend too much effort trying to understand this:
</p>
<blockquote>
<p>
If the current character is an unquoted &#39;<code>$</code>&#39; or &#39;<code>`</code>&#39;, the shell shall
identify the start of any candidates for parameter expansion, command
substitution, or arithmetic expansion from their introductory unquoted
character sequences: &#39;<code>$</code>&#39; or &#34;<code>${</code>&#34;, &#34;<code>$(</code>&#34; or &#39;<code>`</code>&#39;, and &#34;<code>$((</code>&#34;,
respectively. The shell shall read sufficient input to determine the
end of the unit to be expanded (as explained in the cited
sections). While processing the characters, if instances of expansions
or quoting are found nested within the substitution, the shell shall
recursively process them in the manner specified for the construct
that is found. The characters found from the beginning of the
substitution to its end, allowing for any recursion necessary to
recognize embedded constructs, shall be included unmodified in the
result token, including any embedded or enclosing substitution
operators or quotes. The token shall not be delimited by the end of
the substitution.
</p>
<p>
— <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_03">POSIX Shell Command Language, 2.3 Token Recognition</a>
</p>
</blockquote>
<p>
Each shell and wordexp implementation have their own take on how to
deal with ambiguous expressions like these:
</p>
<div>
<pre>$<span>(</span><span>(</span><span>echo</span> a<span>)</span>;<span>(</span><span>echo</span> b<span>)</span><span>)</span>
$<span>(</span><span>(</span><span>echo</span> <span>&#34;(&#34;</span><span>)</span>;<span>(</span><span>echo</span> <span>&#34;)&#34;</span><span>)</span><span>)</span>
$<span>(</span><span>(</span><span>case</span> a<span> in</span> *) <span>echo</span> b;; <span>esac</span><span>)</span><span>)</span>
</pre>
</div>
<p>
An actual shell needs to recursively parse these expressions, whereas
most wordexp implementations try to simply match parentheses. The
last example in particular offers an opportunity to introduce
arbitrary parentheses.
</p>
<p>
The POSIX rationale does say:
</p>
<blockquote>
<p>
Arithmetic expansions have precedence over command substitutions. That
is, if the shell can parse an expansion beginning with &#34;<code>$((</code>&#34; as an
arithmetic expansion then it will do so. It will only parse the
expansion as a command substitution (that starts with a subshell) if
it determines that it cannot parse the expansion as an arithmetic
expansion. If the syntax is valid for neither type of expansion, then
it is unspecified what kind of syntax error the shell reports.
</p>
<p>
— <a href="https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xcu_chap02.html#tag_23_02_06_03">POSIX Rationale for Shell and Utilities, 2.6</a>
</p>
</blockquote>
<p>
But who&#39;s reading that? Clearly not the authors of most popular
shells:
</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th scope="col">shell</th>
<th scope="col"><code>$((echo a);(echo b))</code></th>
<th scope="col"><code>$((echo &#34;(&#34;);(echo &#34;)&#34;))</code></th>
<th scope="col"><code>$((case a in *) echo b;; esac))</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>dash</td>
<td>expects )</td>
<td>parse error</td>
<td>parse error</td>
</tr>
<tr>
<td>bash</td>
<td><code>a b</code></td>
<td><code>( )</code></td>
<td>syntax error</td>
</tr>
<tr>
<td>zsh</td>
<td><code>a b</code></td>
<td>bad math expression</td>
<td><code>b</code></td>
</tr>
<tr>
<td>mksh</td>
<td><code>a b</code></td>
<td><code>( )</code></td>
<td><code>b</code></td>
</tr>
<tr>
<td>hush</td>
<td>expects )</td>
<td>syntax error</td>
<td>syntax error</td>
</tr>
</tbody>
</table>
<p>
And while perhaps <code>zsh</code> is unlikely to ever be <code>/bin/sh</code>, all of the
others are reasonable candidates for it that I&#39;ve seen on other
systems.
</p>
</div>
</div>
<div id="outline-container-org35a2bde">
<h2 id="org35a2bde"><span>3.</span> implementations</h2>
<p>
Now that we know shells handle these expressions inconsistently, how
do different libcs implement <code>wordexp</code>?
</p>
<div id="outline-container-orgb3c5085">
<h3 id="orgb3c5085"><span>3.1.</span> OpenBSD</h3>
<p>
OpenBSD has the best possible implementation of <code>wordexp(3)</code>: none.
The demerits of the function are discussed in <a href="https://www.mail-archive.com/tech@openbsd.org/msg02325.html">this thread from 2010</a>.
</p>
</div>
<div id="outline-container-org1128905">
<h3 id="org1128905"><span>3.2.</span> leveraging the shell</h3>
<p>
There are implementations which try to keep <code>wordexp</code> simple by
shelling out, which was probably the intended behavior when the
function was first created. Unfortunately, this means <code>WRDE_NOCMD</code>
can&#39;t be trusted in these libcs, without the direct assistance of the
shell.
</p>
<div id="outline-container-org35bf5dd">
<h4 id="org35bf5dd"><span>3.2.1.</span> musl</h4>
<p>
<a href="https://git.musl-libc.org/cgit/musl/tree/src/misc/wordexp.c?id=7c8454790080395bf5b27857a766b3468aa5ed98">musl&#39;s implementation</a> is nice and simple, because it shells out.
Unfortunately, in this simplicity, there&#39;s no way to really enforce
<code>WRDE_NOCMD</code>. musl tries, by matching parentheses, but <code>$((echo
a);(echo b))</code> or similar will get around it, as long as <code>/bin/sh</code>
supports such contortions (this confuses <code>dash</code>, but <code>bash</code> happily
runs these commands).
</p>
</div>
<div id="outline-container-orgc747211">
<h4 id="orgc747211"><span>3.2.2.</span> Apple / FreeBSD</h4>
<div id="text-3-2-2">
<p>
FreeBSD <a href="https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=13420">added wordexp in 2002</a>, using the <a href="https://cgit.freebsd.org/src/tree/lib/libc/gen/wordexp.c?id=faea1495bf19ed23bfec20c5c3257759d4e0e9eb">problematic shell-invoking
approach</a>. To FreeBSD&#39;s credit, <a href="https://cgit.freebsd.org/src/commit/?id=d358fa780b338913419f028acdf62896e2481d97">they fixed the major issues with
this approach</a> circa 2015 by specializing the shell, indeed noting:
</p>
<blockquote>
<p>
Shell syntax is too complicated to detect command substitution and
unquoted operators reliably without implementing much of sh&#39;s
parser. Therefore, have sh do this detection.
</p>
</blockquote>
<p>
macOS has inherited versions of this implementation, with some
modifications (<a href="https://opensource.apple.com/source/Libc/Libc-1044.1.2/gen/FreeBSD/wordexp.c">1044.1.2</a>, <a href="https://github.com/apple-oss-distributions/Libc/blob/Libc-1534.81.1/gen/FreeBSD/wordexp.c">1534.81.1</a>). An important practical
difference, though, is that on FreeBSD, <code>/bin/sh</code> is always their
<code>ash</code>, which at the least doesn&#39;t suffer from the aforementioned
parsing problem, while on macOS <code>/bin/sh</code> has been <code>bash</code>.<sup><a id="fnr.5" href="#fn.5" role="doc-backlink">5</a></sup>
</p>
<p>
One interesting twist of Apple&#39;s implementation is that in the past,
<a href="https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/wordexp.c#L192">they shelled out to <code>perl</code>, via <code>popen</code></a>. Last time I checked, they
use a helper called <code>/usr/lib/system/wordexp</code>, but this did nothing to
prevent command substitution – Apple&#39;s libc suffered the same problem
as musl. (The shell situation on macOS is <a href="https://www.jwz.org/blog/2023/11/how-did-apple-manage-to-break-redirects-on-all-versions-of-bash/">always evolving in
interesting ways</a> so who knows what the state is now.)
</p>
</div>
</div>
<div id="outline-container-orgb949a1a">
<h4 id="orgb949a1a"><span>3.2.3.</span> Solaris / Illumos</h4>
<div id="text-3-2-3">
<p>
The <a href="https://github.com/TritonDataCenter/illumos-joyent/blob/2f6344af1104ce12d08740df56cd755e87695926/usr/src/lib/libc/port/regex/wordexp.c#L232-L243">Solaris implementation</a> (originally from MKS with a copyright of
1985!) is notable for implementing <code>WRDE_NOCMD</code> by leveraging ksh&#39;s
restricted mode.
</p>
<p>
Not many people may still be using this implementation, but this is
pretty clever and I guess demonstrates that the commercial Unix
implementations may not have been bad.
</p>
</div>
</div>
</div>
<div id="outline-container-orgbde872f">
<h3 id="orgbde872f"><span>3.3.</span> parsing shell syntax</h3>
<div id="text-3-3">
<p>
So, instead of being simple, we can try the herculean task of
implementing most of a shell in libc instead. The only libc I know of
that does this is glibc, though (often old, broken) copies of its
implementation are found widely, both in programs trying to get around
systems like OpenBSD as well as other libcs. For example, uclibc
has <a href="https://github.com/gittup/uClibc/blob/9dbf00be840a15a52656a039f83d1997344ce507/libc/misc/wordexp/wordexp.c#L2020">an old version of glibc&#39;s wordexp</a> which has the fatal flaw that
backtick can still be parsed from arithmetic expressions, so
e.g. <code>$[`touch foo`]</code> will execute a command.
</p>
<p>
glibc avoids calling out to the shell except when it must, for command
substitution. This results in <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=posix/wordexp.c;h=0da98f5b083139629dda47ba554817d0551b6b69;hb=HEAD#l1">an elaborate, 2500-line
reimplementation of some of a shell parser</a>, including a single
800-line function to parse parameter expansions.
</p>
<p>
It omits many details; for example, in arithmetic expansion. Many
valid (and useful) expressions like <code>$((1&lt;&lt;16))</code> will not be
recognized.
</p>
<p>
However it has one great merit. In 2014, <a href="https://sourceware.org/git/?p=glibc.git;a=commit;h=a39208bd7fb76c1b01c127b4c61f9bfd915bfe7c">Carlos O&#39;Donnel fixed an
important vulnerability</a>. Previously, the code tried to enforce
<code>WRDE_NOCMD</code> only when it recognized command substitution&#39;s two forms,
like many of the implementations which lean on the shell for
everything. Though it seems obvious in retrospect, glibc&#39;s current
implementation guards the actual execution of commands with
<code>WRDE_NOCMD</code> tests, instead of trying to do this during parsing.
</p>
<p>
Despite its complexity, it does seem like the only implementation that
is safe to use, though it seems a better policy is to declare a ban on
wordexp.
</p>
</div>
</div>
</div>
<div id="outline-container-orgc46e6b4">
<h2 id="orgc46e6b4"><span>4.</span> conclusion</h2>
<div id="text-4">
<p>
I had never heard of <code>wordexp(3)</code> until I saw it mentioned in the
POSIX standard, while I was implementing a shell.
</p>
<p>
Many programs that just use <code>wordexp(&#34;~/foo&#34;)</code> could be replaced with
<code>glob(..., GLOB_TILDE)</code>. (Though keep in mind, <a href="https://sourceware.org/bugzilla/show_bug.cgi?id=24607">anyone can crash your
program with a bad glob</a>.)
</p>
<p>
I&#39;m not sure where it was first implemented; scanning the Unix history
repo, it doesn&#39;t really appear until the 90s but there&#39;s a reference
in a manpage from FreeBSD 1.0 (which doesn&#39;t implement it). Let&#39;s
hope it fades into history similarly.
</p>
</div>
</div>
<div id="footnotes">
<h2>Footnotes: </h2>
<div id="text-footnotes">
<div><p><sup><a id="fn.1" href="#fnr.1" role="doc-backlink">1</a></sup></p><p>
<a href="http://cvs.savannah.nongnu.org/viewvc/jailkit/jailkit/src/jk_lsh.c?view=markup#l151">jailkit</a> uses wordexp in its restricted shell; to be fair,
this is only enabled if you use the <code>allow_word_expansion</code> option
which is disabled by default, and there&#39;s always the chance it will
link with a safer wordexp like in modern glibc. However, it ships
with a vulnerable wordexp bundled, for systems without it, and for
example <code>jk_lsh -c &#39;$[`touch foo`]&#39;</code> will do bad things in such a
case.
</p></div>


<div><p><sup><a id="fn.4" href="#fnr.4" role="doc-backlink">4</a></sup></p><div role="doc-footnote"><p>
Consider this example:
</p>
<div>
<pre>$<span>(</span><span>case</span> $<span>(</span><span>case</span> $<span>x</span><span> in</span> *) <span>(</span><span>echo</span> $<span>x</span><span>)</span>;; <span>esac</span><span>)</span> <span>in</span> (x) $<span>(</span><span>echo</span> :<span>)</span>;; *) $<span>(</span><span>echo</span> :<span>)</span>;; <span>esac</span><span>)</span>
</pre>
</div></div></div>
<div><p><sup><a id="fn.5" href="#fnr.5" role="doc-backlink">5</a></sup></p><p>
bash has a (disabled by default at compile time) <code>--wordexp</code>
option, which is an attempt to provide this kind of functionality more
safely. It tries to disable command substitution everywhere and only
invokes the parser and expander immediately. Last time I checked,
macOS didn&#39;t use this.
</p></div>
</div>
</div>

</div>
</div></div>
  </body>
</html>
