<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://agourlay.github.io/ruxguitar-tablature-player/">Original</a>
    <h1>Playing Guitar Tablatures in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>If you ever tried to learn guitar, chances are you are familiar with guitar tablatures.</p>
<p>It is a simple way to visualize music for guitar, using ASCII characters to represent strings and frets as an alternative to sheet music.</p>
<p>For instance, here are the first four measures of the song &#34;Smoke on the Water&#34; by Deep Purple:</p>
<pre data-lang="txt"><code data-lang="txt"><span>e|-----------------|-----------------|-----------------|-----------------|
</span><span>B|-----------------|-----------------|-----------------|-----------------|
</span><span>G|-----3---5-------|---3---6-5-------|-----3---5-----3-|-----------------|
</span><span>D|-5---3---5-----5-|---3---6-5-------|-5---3---5-----3-|---5-------------|
</span><span>A|-5-------------5-|-----------------|-5---------------|---5-------------|
</span><span>E|-----------------|-----------------|-----------------|-----------------| &lt;- top
</span></code></pre>
<p>This song is played in standard tuning (EADGBe), which is conveyed by the letters on the left indicating the tuning for each string. While the numbers indicate where to put your fingers on the fretboard.</p>
<p>Beyond the text representation, the defacto standard is the format used by the <a href="https://www.guitar-pro.com/">Guitar Pro</a> software to render and synthetize sound for the tablature.</p>
<p>Those binary files have the <code>.gp3</code>, <code>.gp4</code>, <code>.gp5</code> or <code>.gp6</code> extension depending on the software version used to produce them, and can be easily found on the internet on websites such as <a href="https://www.ultimate-guitar.com/">Ultimate Guitar</a>.</p>
<p>Although the software to play the tablature is proprietary, some versions of the file format are well documented, and there are even open-source projects that can read them.</p>
<p>The best OSS tablature player is probably <a href="https://sourceforge.net/projects/tuxguitar/">TuxGuitar</a> which is very feature-rich and a fantastic tool to learn guitar.</p>
<p>Since <code>TuxGuitar</code> appears to be unmaintained and Java based, I thought it would be a fun challenge to write my own tablature player in Rust.</p>

<p>I named my project <code>Ruxguitar</code>, a portmanteau of <code>Rust</code> and <code>Guitar</code>.</p>
<p>The project is still in its early stages, but I believe it is now functional enough to be officially announced to the world - aka this very blog post!</p>
<p>Rather than describing what the project does, have a look at the following video which shows the tablature player in action with a song a bit more complex:</p>
<video id="myVideo" controls="" width="640" height="480">
  <source src="/2024-07-14/ruxguitar.mp4" type="video/mp4"/>
  Your browser does not support the video tag.
</video>
<p>You can obviously find the source code on <a href="https://github.com/agourlay/ruxguitar">GitHub</a> with pre-built <a href="https://github.com/agourlay/ruxguitar/releases">binaries</a> available for Linux, macOS and Windows.</p>
<p>Feel free to go play with it and come back when you want to read the rest of this post which will detail various aspects of the internals.</p>

<p>The first step in building a tablature player is to parse the binary tablature file.</p>
<p>During my research, I found a specification of the <code>.gp4</code> file format on <a href="https://dguitar.sourceforge.net/GP4format.html">dguitar</a> to get started.</p>
<p>The structure of the file is roughly the following:</p>
<ol>
<li>file version to know which version of the file format is used</li>
<li>information about the piece (e.g. title, subtitle, artist, album, etc.)</li>
<li>lyrics</li>
<li>number of measures and number of tracks</li>
<li>measures per track in the following order:
<ul>
<li>measure 1/track 1</li>
<li>measure 1/track 2</li>
<li>...</li>
<li>measure 1/track m</li>
<li>measure 2/track 1</li>
<li>measure 2/track 2</li>
<li>...</li>
<li>measure 2/track m</li>
<li>...</li>
<li>measure n/track 1</li>
<li>measure n/track 2</li>
<li>...</li>
<li>measure n/track m</li>
</ul>
</li>
<li>within each measure, we find the number of beats to read</li>
<li>within each beat, we find the beat duration and the number of notes to read</li>
<li>within each note, we find the string, the fret, the duration, the effect, etc.</li>
</ol>
<p>I decided to use the <a href="https://github.com/rust-bakery/nom">nom</a> crate to parse the tablature because I am <a href="https://github.com/agourlay/hprof-slurp">familiar</a> with it for parsing binary format.</p>
<p>Here is a quick peek at the code driving the parser so you get an idea of how it looks:</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub fn </span><span>parse_gp_data</span><span>(</span><span>file_data</span><span>: &amp;[</span><span>u8</span><span>]) -&gt; Result&lt;Song, RuxError&gt; {
</span><span>    </span><span>let </span><span>(rest, base_song) = </span><span>flat_map</span><span>(parse_gp_version, |</span><span>version</span><span>| {
</span><span>        </span><span>map</span><span>(
</span><span>            </span><span>tuple</span><span>((
</span><span>                </span><span>parse_info</span><span>(version),                                     
</span><span>                </span><span>cond</span><span>(version &lt; GpVersion::</span><span>GP5</span><span>, parse_bool),              
</span><span>                </span><span>cond</span><span>(version &gt;= GpVersion::</span><span>GP4</span><span>, parse_lyrics),           
</span><span>                </span><span>cond</span><span>(version &gt;= GpVersion::</span><span>GP5_10</span><span>, </span><span>take</span><span>(</span><span>19</span><span>usize</span><span>)),       
</span><span>                </span><span>cond</span><span>(version &gt;= GpVersion::</span><span>GP5</span><span>, parse_page_setup),       
</span><span>                </span><span>cond</span><span>(version &gt;= GpVersion::</span><span>GP5</span><span>, parse_int_sized_string), 
</span><span>                parse_int,                                               
</span><span>                </span><span>cond</span><span>(version &gt; GpVersion::</span><span>GP5</span><span>, parse_bool),              
</span><span>                parse_signed_byte,                                       
</span><span>                </span><span>cond</span><span>(version &gt; GpVersion::</span><span>GP3</span><span>, parse_int),               
</span><span>                parse_midi_channels,                                     
</span><span>            )),
</span><span>            </span><span>move </span><span>|(
</span><span>                song_info,
</span><span>                triplet_feel,
</span><span>                lyrics,
</span><span>                _master_effect,
</span><span>                page_setup,
</span><span>                tempo_name,
</span><span>                tempo,
</span><span>                hide_tempo,
</span><span>                key_signature,
</span><span>                octave,
</span><span>                midi_channels,
</span><span>            )| {
</span><span>                </span><span>// init base song
</span><span>                </span><span>let</span><span> tempo = Tempo::new(tempo, tempo_name);
</span><span>                Song {
</span><span>                    version,
</span><span>                    song_info,
</span><span>                    triplet_feel,
</span><span>                    lyrics,
</span><span>                    page_setup,
</span><span>                    tempo,
</span><span>                    hide_tempo,
</span><span>                    key_signature,
</span><span>                    octave,
</span><span>                    midi_channels,
</span><span>                    measure_headers: vec![],
</span><span>                    tracks: vec![],
</span><span>                }
</span><span>            },
</span><span>        )
</span><span>    })(file_data)
</span><span>    .</span><span>map_err</span><span>(|</span><span>_err</span><span>| {
</span><span>        log::error!(&#34;</span><span>Failed to parse GP data</span><span>&#34;);
</span><span>        RuxError::ParsingError(&#34;</span><span>Failed to parse GP data</span><span>&#34;.</span><span>to_string</span><span>())
</span><span>    })?;
</span><span>    </span><span>// parse tracks &amp; measures
</span><span>    ...
</span></code></pre>
<p>The heavy lifting required to parse the tracks and the measures is done in a different function that will be skipped for brevity.</p>
<p>At some point it became quite tedious to handle the various versions of the file format and I decided to focus on the <code>.gp5</code> version which is widely used.</p>
<p>To be honest, this part was rather challenging because the file format is quite complex and the documentation is not always clear.</p>
<p>Luckily I was able to inspect the parsers from <code>TuxGuitar</code> and the <a href="https://github.com/slundi/guitarpro">guitarpro</a> crate to get a better understanding of the file format.</p>
<p>To ensure correctness, I have written a few unit tests for specific tablature files to check that the parser is working as expected.</p>
<p>This approach is useful to get started but not very scalable, so I am also validating some high level invariants of the resulting <code>Song</code> structure over a directory containing several hundred tablatures.</p>
<p>I found a few bugs in the parser this way and I am confident that the parser is working as expected.</p>

<p>At this point, we have an in-memory representation of the tablature but no way to display it.</p>
<p>Not only should the user be able to see the tablature but also be able to interact with it.</p>
<p>I really wanted to use a native GUI library to ensure that the application would look and feel like a native application on all platforms.</p>
<p>The <a href="https://areweguiyet.com/">state</a> of GUI libraries in Rust required me to do some research.</p>
<p>I needed a truly event-based library to handle the synchronization during playback while also being able to draw the tablature in a custom way with some kind of canvas abstraction.</p>
<p>Based on those requirements, I decided to give <a href="https://iced.rs/">Iced</a> a spin as it checked all the boxes.</p>
<p>Spoiler alert: I am very happy with my choice so I did not try other libraries.</p>
<h2 id="iced">Iced</h2>
<p>The <code>Iced</code> library is very well written but could benefit from a bit more documentation.</p>
<p>I recommend reading the source code of the <a href="https://github.com/iced-rs/iced/tree/master/examples">examples</a> to get a better understanding of how to use the library.</p>
<p>I started with the <a href="https://github.com/iced-rs/iced/tree/master/examples/editor">text editor</a> example which I slowly adapted to my needs.</p>
<p>At some point, I ran into a bug in version <code>0.12.0</code> which forced me to upgrade to the <code>0.13.0</code> version which was not released yet.</p>
<p>This means I had to use the <code>main</code> branch of the <code>Iced</code> repository which was a bit scary but it worked out fine.</p>
<p>All the breakages I encountered were due to the <code>Iced</code> library being in active development and I am very grateful for the maintainers for their hard work.</p>
<p>The library is architectured around messages and subscriptions that trigger the update of the UI.</p>
<p>For instance, those are my messages:</p>
<pre data-lang="rust"><code data-lang="rust"><span>#[</span><span>derive</span><span>(Debug, Clone)]
</span><span>pub enum </span><span>Message {
</span><span>    OpenFile, </span><span>// open file dialog
</span><span>    FileOpened(Result&lt;(Vec&lt;</span><span>u8</span><span>&gt;, String), PickerError&gt;), </span><span>// file content &amp; file name
</span><span>    TrackSelected(TrackSelection), </span><span>// track selection
</span><span>    FocusMeasure(</span><span>usize</span><span>), </span><span>// used when clicking on measure in tablature
</span><span>    FocusTick(</span><span>usize</span><span>), </span><span>// focus on a specific tick in the tablature
</span><span>    PlayPause, </span><span>// toggle play/pause
</span><span>    StopPlayer, </span><span>// stop playback
</span><span>    ToggleSolo, </span><span>// toggle solo mode
</span><span>}
</span></code></pre>
<p>And this is the simplified application entry point:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl </span><span>RuxApplication {
</span><span>    </span><span>pub fn </span><span>start</span><span>(</span><span>args</span><span>: ApplicationArgs) -&gt; iced::Result {
</span><span>        iced::application(
</span><span>            RuxApplication::title,
</span><span>            RuxApplication::update,
</span><span>            RuxApplication::view,
</span><span>        )
</span><span>        .</span><span>subscription</span><span>(RuxApplication::subscription)
</span><span>        .</span><span>theme</span><span>(RuxApplication::theme)
</span><span>        .</span><span>font</span><span>(</span><span>ICONS_FONT</span><span>)
</span><span>        .</span><span>centered</span><span>()
</span><span>        .</span><span>antialiasing</span><span>(</span><span>true</span><span>)
</span><span>        .</span><span>run</span><span>()
</span><span>    }
</span><span>}
</span></code></pre>
<p>The application is built around functions that are orchestrated by the <code>Iced</code> engine appropriately.</p>
<p>The <code>update</code> function has for signature <code>Fn(&amp;mut State, Message) -&gt; C</code> where:</p>
<ul>
<li><code>State</code> is the application state that can be modified (here <code>RuxApplication</code>)</li>
<li><code>Message</code> is the message to process</li>
<li><code>C</code> is an output <code>Task</code> potentially producing a new <code>Message</code></li>
</ul>
<p>The <code>view</code> function has for signature <code>Fn(&amp;&#39;a State) -&gt; Widget</code> is rendering a <code>Widget</code> based on the current <code>&amp;State</code>.</p>
<h2 id="drawing-the-tablature">Drawing the tablature</h2>
<p>I started by crafting the code which carefully draws a single measure on an <code>Iced::Canvas</code>.</p>
<p>This means:</p>
<ul>
<li>drawing each strings</li>
<li>for each beat, drawing the notes on the strings and potential beat effect (e.g. palm mute)</li>
<li>for each note, adding the potential note effect (e.g. slide, hammer-on, bend) </li>
<li>annotate the measure with additional information (e.g. measure number, tempo, part annotation, chord)</li>
</ul>
<p>It required a bit of trial and error to get the offsets right but I am happy with the result.</p>
<p><img src="https://agourlay.github.io/2024-07-14/measure.png" alt="single measure"/></p>
<p>Once I have a collection of canvas measures, they are assembled in a responsive grid layout to display the whole tablature using the <code>wrap</code> widget from the <a href="https://github.com/iced-rs/iced_aw">iced-aw</a> crate.</p>
<p><img src="https://agourlay.github.io/2024-07-14/grid.png" alt="grid measures"/></p>
<p>The measures can have different lengths depending on the number of beats which makes silent measures very small and crazy guitar solo measures long.</p>

<p>To recap, we have an in-memory representation of a tablature and we have the UI, now we need to make some sounds!</p>
<p>What we want is a way to turn each note, for each beat, for each measure, for each track into a specific sound at the <strong>right</strong> time.</p>
<p>This can be achieved using a MIDI synthesizer which is a software that can produce sounds based on MIDI events.</p>
<h2 id="synthesizing-midi-events">Synthesizing MIDI events</h2>
<p>There are different kinds of MIDI events but the most important for us are the <code>NoteOn</code> and <code>NoteOff</code> ones.</p>
<ul>
<li>Note On: Indicates that a note is being pressed. It includes the note number (pitch) and velocity (how hard the note is pressed).</li>
<li>Note Off: Indicates that a note is being released.</li>
</ul>
<p>For each note in the tablature, we can generate a pair of MIDI events annotated with:</p>
<ul>
<li>the timestamp, also referred as a tick, at which they should be executed.</li>
<li>the track to which they belong.</li>
</ul>
<pre data-lang="rust"><code data-lang="rust"><span>pub enum </span><span>MidiEventType {
</span><span>    NoteOn(</span><span>i32</span><span>, </span><span>i32</span><span>, </span><span>i16</span><span>),  </span><span>// midi channel, note, velocity
</span><span>    NoteOff(</span><span>i32</span><span>, </span><span>i32</span><span>),      </span><span>// midi channel, note
</span><span>    ...
</span><span>}
</span><span>
</span><span>pub struct </span><span>MidiEvent {
</span><span>    </span><span>pub </span><span>tick</span><span>: </span><span>usize</span><span>,
</span><span>    </span><span>pub </span><span>event</span><span>: MidiEventType,
</span><span>    </span><span>pub </span><span>track</span><span>: </span><span>usize</span><span>,
</span><span>}
</span></code></pre>
<p>All those events are pushed into a single array sorted by the event tick. </p>
<p>This approach provides an efficient way to find the next events to play at any given time via binary search later on.</p>
<p>Those <code>MidiEvents</code> can be transformed into audio waves using a synthetizer before being sent to the audio output.</p>
<p>For the synthetizer I settled on the <a href="https://github.com/sinshu/rustysynth">rustysynth</a> crate which provides a neat MIDI synthetizer.</p>
<p>Here is a simplified version of the code to play a MIDI event:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> synthesizer_settings = SynthesizerSettings::new(</span><span>SAMPLE_RATE </span><span>as </span><span>i32</span><span>);
</span><span>let mut</span><span> synthesizer = Synthesizer::new(&amp;sound_font, &amp;synthesizer_settings);
</span><span>
</span><span>let</span><span> midi_event = </span><span>// find next event to play
</span><span>match</span><span> midi_event.event {
</span><span>    MidiEventType::NoteOn(channel, key, velocity) =&gt; {
</span><span>        synthesizer.</span><span>note_on</span><span>(channel, key, velocity as </span><span>i32</span><span>);
</span><span>    }
</span><span>    MidiEventType::NoteOff(channel, key) =&gt; {
</span><span>        synthesizer.</span><span>note_off</span><span>(channel, key);
</span><span>    }
</span><span>    ...
</span><span>}                    
</span></code></pre>
<p>It is important to note that a synthetizer requires a soundfont file to produce sound.</p>
<p>For the sake of simplicity, I included the <code>TimGM6mb.sf2</code> soundfont file in the binary at compile time.</p>
<pre data-lang="rust"><code data-lang="rust"><span>const </span><span>TIMIDITY_SOUND_FONT</span><span>: &amp;[</span><span>u8</span><span>] = include_bytes!(&#34;</span><span>../../resources/TimGM6mb.sf2</span><span>&#34;);
</span></code></pre>
<p>The trade-off is that the binary is a bit larger but the user does not have to worry about finding the soundfont file.</p>
<p>However, it is possible to provide a larger soundfont file to get better sound quality using the <code>--soundfont</code> command line argument.</p>
<p>For instance, I like to use <code>FluidR3_GM.sf2</code> which is present on most systems and easy to find online (<a href="https://musical-artifacts.com/artifacts/738">here</a> or <a href="https://member.keymusician.com/Member/FluidR3_GM/index.html">there</a>).</p>
<pre data-lang="bash"><code data-lang="bash"><span>./ruxguitar --sound-font-file</span><span> /usr/share/sounds/sf2/FluidR3_GM.sf2
</span></code></pre>
<h2 id="audio-loop">Audio loop</h2>
<p>The audio output stream is managed by a dedicated thread which will produce sound at a regular interval.</p>
<p>I picked the <a href="https://github.com/RustAudio/cpal">cpal</a> crate which is a cross-platform audio library.</p>
<p>Here is a simplified version of the code to setup an audio loop:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> host = cpal::default_host();
</span><span>let</span><span> device = host.</span><span>default_output_device</span><span>().</span><span>unwrap</span><span>();
</span><span>
</span><span>let</span><span> config = device.</span><span>default_output_config</span><span>().</span><span>unwrap</span><span>();
</span><span>let</span><span> stream_config: cpal::StreamConfig = config.</span><span>into</span><span>();
</span><span>
</span><span>let</span><span> channels_count = stream_config.channels as </span><span>usize</span><span>;
</span><span>assert_eq!(channels_count, </span><span>2</span><span>);
</span><span>
</span><span>// 4410 samples at 44100 Hz is 0.1 second
</span><span>let</span><span> mono_sample_count = </span><span>4410</span><span>;
</span><span>
</span><span>let mut</span><span> left: Vec&lt;</span><span>f32</span><span>&gt; = vec![</span><span>0_</span><span>f32</span><span>; mono_sample_count];
</span><span>let mut</span><span> right: Vec&lt;</span><span>f32</span><span>&gt; = vec![</span><span>0_</span><span>f32</span><span>; mono_sample_count];
</span><span>
</span><span>// build audio loop
</span><span>let</span><span> stream = device.</span><span>build_output_stream</span><span>(
</span><span>    &amp;stream_config,
</span><span>    </span><span>move </span><span>|output: &amp;</span><span>mut </span><span>[</span><span>f32</span><span>], _: &amp;cpal::OutputCallbackInfo| {
</span><span>        </span><span>let</span><span> midi_events = </span><span>// find events to play
</span><span>        </span><span>for</span><span> event in midi_events {
</span><span>            </span><span>// synthesize events
</span><span>            synthetizer.</span><span>process</span><span>(event)
</span><span>        }
</span><span>
</span><span>        </span><span>// Split buffer in two channels (left and right)
</span><span>        </span><span>let</span><span> channel_len = output.</span><span>len</span><span>() / channels_count;
</span><span>
</span><span>        </span><span>// Render the waveform.
</span><span>        synthesizer.</span><span>render</span><span>(&amp;</span><span>mut</span><span> left[..channel_len], &amp;</span><span>mut</span><span> right[..channel_len]);
</span><span>        
</span><span>        </span><span>// Interleave the left and right channels into the output buffer.
</span><span>        </span><span>for </span><span>(i, (l, r)) in left.</span><span>iter</span><span>().</span><span>zip</span><span>(right.</span><span>iter</span><span>()).</span><span>take</span><span>(channel_len).</span><span>enumerate</span><span>() {
</span><span>            output[i * </span><span>2</span><span>] = *l;
</span><span>            output[i * </span><span>2 </span><span>+ </span><span>1</span><span>] = *r;
</span><span>        }
</span><span>    }
</span><span>)
</span><span>// Start the stream.
</span><span>let</span><span> stream = stream.</span><span>unwrap</span><span>();
</span><span>stream.</span><span>play</span><span>().</span><span>unwrap</span><span>();
</span></code></pre>
<p>For each run of the audio loop, it is possible to compute the next window of time to process by taking into account:</p>
<ul>
<li>the current timestamp of the audio player</li>
<li>the tempo of the current measure</li>
<li>how much time has passed since the previous interval</li>
</ul>
<pre data-lang="rust"><code data-lang="rust"><span>const </span><span>QUARTER_TIME</span><span>: </span><span>i32 </span><span>= </span><span>960</span><span>; </span><span>// 1 quarter note = 960 ticks
</span><span>
</span><span>fn </span><span>tick_increase</span><span>(</span><span>tempo_bpm</span><span>: </span><span>i32</span><span>, </span><span>elapsed_seconds</span><span>: </span><span>f64</span><span>) -&gt; </span><span>usize </span><span>{
</span><span>    </span><span>let</span><span> tempo_bps = tempo_bpm as </span><span>f64 </span><span>/ </span><span>60.0</span><span>;
</span><span>    </span><span>let</span><span> bump = </span><span>QUARTER_TIME </span><span>as </span><span>f64 </span><span>* tempo_bps * elapsed_seconds;
</span><span>    bump as </span><span>usize
</span><span>}
</span></code></pre>
<p>Using the resulting tick increase, we can efficiently query our array of MIDI events to find the next events to play using binary search.</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> tick_increase = </span><span>tick_increase</span><span>(tempo, elapsed_seconds);
</span><span>let</span><span> next_tick = </span><span>self</span><span>.current_tick + tick_increase;
</span><span>// assume we already have a cursor for the start of the events (a.k.a. the index of the last event played)
</span><span>let</span><span> start_index = </span><span>self</span><span>.current_cursor;
</span><span>let</span><span> end_index = </span><span>match</span><span> sorted_events[start_index..].</span><span>binary_search_by_key</span><span>(start_index, |</span><span>event</span><span>| event.tick)
</span><span>{
</span><span>    Ok(next_position) =&gt; start_index + next_position,
</span><span>    Err(next_position) =&gt; {
</span><span>        </span><span>if</span><span> next_position == </span><span>0 </span><span>{
</span><span>            </span><span>// no matching elements
</span><span>            </span><span>return </span><span>Some(&amp;[]);
</span><span>        }
</span><span>        </span><span>// return slice until the last event
</span><span>        start_index + next_position - </span><span>1
</span><span>    }
</span><span>};
</span><span>// return slice of events to play
</span><span>return </span><span>Some(&amp;</span><span>self</span><span>.sorted_events[start_index..=end_index])
</span></code></pre>
<p>Now that we have the audio loop running, we can focus on the integration between the audio player and the UI.</p>

<p>Having a perfect integration is crucial to providing a smooth user experience: </p>
<ul>
<li>
<p>when clicking on the &#34;Play&#34; button, the tablature cursor should start moving, the notes should be highlighted as they are played.</p>
</li>
<li>
<p>when a measure is clicked, the player should jump to the corresponding position in the tablature and the correct notes should be played.</p>
</li>
<li>
<p>when clicking on a different track, the whole tablature should be updated to show the new track and the sound should be updated accordingly.</p>
</li>
<li>
<p>when clicking on the &#34;Solo&#34; button, all other tracks should be muted.</p>
</li>
<li>
<p>when clicking on the &#34;Stop&#34; button, the tablature cursor should be reset to the beginning and the sound should stop. </p>
</li>
</ul>
<p>I think you get the idea.</p>
<p>The critical bridge between the audio player and the UI is implemented using the <code>iced::Subscription</code> mechanism.</p>
<p>Subscriptions are a way to listen to external events and publish them as messages to the application.</p>
<p>For instance, here is how the application reacts to pressing the space bar to toggle the playback:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> keyboard_subscription = keyboard::on_key_press(|</span><span>key</span><span>, </span><span>_modifiers</span><span>| </span><span>match</span><span> key.</span><span>as_ref</span><span>() {
</span><span>    keyboard::Key::Named(Space) =&gt; Some(Message::PlayPause),
</span><span>    _ =&gt; None,
</span><span>});
</span></code></pre>
<p>The update function does not care whether the message has been triggered by the keyboard or by clicking on the &#34;Play&#34; button.</p>
<p>Using a similar mechanism, the audio player can send messages to the application to update the UI based on the current playback position.</p>
<p>The application holds the receiving end of an <a href="https://docs.rs/tokio/latest/tokio/sync/watch/index.html">tokio::sync::watch</a> channel containing the current timestamp which is published by the audio thread.</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>audio_player_beat_subscription</span><span>(&amp;</span><span>self</span><span>) -&gt; impl Stream&lt;Item = Message&gt; {
</span><span>    </span><span>let</span><span> beat_receiver = </span><span>self</span><span>.beat_receiver.</span><span>clone</span><span>();
</span><span>    stream::channel(</span><span>1</span><span>, </span><span>move </span><span>|</span><span>mut</span><span> output| async </span><span>move </span><span>{
</span><span>        </span><span>let mut</span><span> receiver = beat_receiver.</span><span>lock</span><span>().await;
</span><span>        </span><span>loop </span><span>{
</span><span>            </span><span>// get tick from audio player
</span><span>            </span><span>let</span><span> tick = *receiver.</span><span>borrow_and_update</span><span>();
</span><span>            </span><span>// publish to UI
</span><span>            output
</span><span>                .</span><span>send</span><span>(Message::FocusTick(tick))
</span><span>                .await
</span><span>                .</span><span>expect</span><span>(&#34;</span><span>send failed</span><span>&#34;);
</span><span>            </span><span>// wait for next beat
</span><span>            receiver.</span><span>changed</span><span>().await.</span><span>expect</span><span>(&#34;</span><span>receiver failed</span><span>&#34;);
</span><span>        }
</span><span>    })
</span><span>}
</span><span>...
</span><span>// setup subscription
</span><span>Subscription::run_with_id(&#34;</span><span>audio-player-beat</span><span>&#34;, audio_player_beat_subscription));
</span></code></pre>
<p>The tablature processes the <code>FocusTick</code> message to update the current measure position and highlight the notes.</p>
<p><img src="https://agourlay.github.io/2024-07-14/measure-cursor.gif" alt="measure cursor"/></p>
<p>A <strong>lot</strong> of details were required to maintain the illusion that everything is properly synchronized with the user&#39;s actions.</p>

<p>The current version of <code>Ruxguitar</code> is pretty much an MVP to get the project started.</p>
<p>It is nowhere near <code>TuxGuitar</code> in terms of features and usability.</p>
<p>Here are a few ideas for the future:</p>
<ul>
<li>support more file formats (currently only <code>.gp5</code> is supported)</li>
<li>display more information about the tablature (e.g. rhythm, time signature, key signature etc.)</li>
<li>support repeating measures</li>
<li>support slowing down and speeding up the playback</li>
</ul>

<p>I have been working on <code>Ruxguitar</code> over the past year and I am very happy with the result.</p>
<p>Not only did I learn a lot on the way but I also actually built a complex piece of software that appears to work.</p>
<p>Working on such a large project alone required a lot of discipline because there were many times when I felt like giving up, running into cryptic bugs or being stuck on a feature for weeks.</p>
<p>It would have been impossible to build <code>Ruxguitar</code> without <code>TuxGuitar</code> as a reference implementation and I am very grateful for the work done by the <code>TuxGuitar</code> team over the years.</p>
<p>After so much work on this project, it&#39;s about time I get back to playing guitar instead of writing software for it!</p>

    </div></div>
  </body>
</html>
