<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gopiandcode.uk/logs/log-unifying-folds.html">Original</a>
    <h1>Unifying fold left and fold right in Prolog</h1>
    
    <div id="readability-page-1" class="page"><div>
<main>
<article role="article">

<small>
<time datetime="2022-08-26T09:31:31-07:00">August</time>
<time datetime="2022-08-26T09:31:31-07:00">26</time>
<time datetime="2022-08-26T09:31:31-07:00">2022</time>
</small>
<a href=""><small>#prolog</small></a>
<a href=""><small>#lisp</small></a>
<a href=""><small>#pearl</small></a>
<div id="text-orgf8e4ea4">
<p>
Here&#39;s a rather cool trick we noticed during a recent discussion in
the NUS PLSE Lab.<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup>
</p>

<p>
Fold left and fold right… arguably two of the most fundamental
combinators when it comes to working with lists…
</p>

<p><b><i>But are</i> fold left <i>and</i> fold right <i>really all that</i> different?</b>
</p>


<p>
Well… as it turns out, we can actually <i>unify</i><sup><a id="fnr.2" href="#fn.2" role="doc-backlink">2</a></sup> these two algorithms into <b>one</b> in Prolog! Let&#39;s have a look!
</p>
</div>

<div id="outline-container-org7a38b62">
<h3 id="org7a38b62">Preliminaries: Functional fold left and right</h3>
<div id="text-org7a38b62">
<p>
Let&#39;s start by having a look at the traditional implementations of fold left and right:
</p>

<div>

<div>
<pre><span>let</span> <span>rec</span> <span>fold_left</span> f ls acc <span>=</span> 
  <span>match</span> ls <span>with</span> 
  <span>|</span> <span>[]</span> <span>-&gt;</span> acc
  <span>|</span> h <span>::</span> t <span>-&gt;</span> fold_left f t <span>(</span>f h acc<span>)</span>
</pre>
</div>
<div>
<pre><span>let</span> <span>rec</span> <span>fold_right</span> f ls acc <span>=</span> 
 <span>match</span> ls <span>with</span>
 <span>|</span> <span>[]</span> <span>-&gt;</span> acc
 <span>|</span> h <span>::</span> t <span>-&gt;</span> f h <span>(</span>fold_right f t acc<span>)</span>
</pre>
</div>
</div>


<p>
While these definitions might seem a little esoteric to the untrained
eye<sup><a id="fnr.3" href="#fn.3" role="doc-backlink">3</a></sup>, it turns out they can be used to represent a wide variety
of list transformations.
</p>

<p>
Here&#39;s an example of using fold left to reverse a list:
</p>

<div>
<pre>fold_left <span>(</span><span>fun</span> hd tl <span>-&gt;</span> hd <span>::</span> tl<span>)</span> <span>[</span>1<span>;</span> 2<span>;</span> 3<span>;</span> 4<span>]</span> <span>[]</span>

<span>(* </span><span>- : int list = [4; 3; 2; 1]</span><span> *)</span>
</pre>
</div>

<p>
Here&#39;s an example of using fold right to reverse a list<sup><a id="fnr.4" href="#fn.4" role="doc-backlink">4</a></sup>:
</p>

<div>
<pre>fold_right <span>(</span><span>fun</span> hd tl <span>-&gt;</span> tl <span>@</span> <span>[</span>hd<span>])</span> <span>[</span>1<span>;</span> 2<span>;</span> 3<span>;</span> 4<span>]</span> <span>[]</span>

<span>(* </span><span>- : int list = [4; 3; 2; 1]</span><span> *)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5b3906e">
<h3 id="org5b3906e">Fold right in Prolog</h3>
<div id="text-org5b3906e">
<p>
Now, let&#39;s look at implementing folds in Prolog<sup><a id="fnr.5" href="#fn.5" role="doc-backlink">5</a></sup>, starting with fold right<sup><a id="fnr.6" href="#fn.6" role="doc-backlink">6</a></sup>.
</p>

<div>
<pre><span>fold</span>(F, <span>[]</span>, ACC, ACC).
<span>fold</span>(F, <span>[</span>H<span>|</span>T<span>]</span>, ACC, RES) :-
    call(F, H, ACC, NEW_ACC),
    fold(F, T, NEW_ACC, RES).
</pre>
</div>

<p>
Here&#39;s an example of using it to reverse a list: 
</p>

<div>
<pre><span>snoc</span>(H, RES, T) :- append(T,<span>[</span>H<span>]</span>, RES).
?- fold(snoc, <span>[</span>1,2,3,4<span>]</span>, RES, <span>[]</span>).
<span>/* </span><span>RES = [4,3,2,1] */</span>
</pre>
</div>

<p>
Great! Okay, so, now, how about fold left?
</p>
</div>
</div>

<div id="outline-container-org0e87b99">
<h3 id="org0e87b99">Plot twist: Fold left <b>is</b> Fold right</h3>
<div id="text-org0e87b99">
<p>
Well, here&#39;s the cool part: We can use the <i>same</i> fold predicate to
implement <b>fold left</b>! All we need to do is to change which variables we
are querying and which ones we are instantiating:
</p>

<div>
<pre><span>cons</span>(H, T, <span>[</span>H<span>|</span>T<span>]</span>).
?- fold(cons, <span>[</span>1,2,3,4<span>]</span>, <span>[]</span>, RES).
<span>/* </span><span>RES = [4,3,2,1] */</span>
</pre>
</div>

<p>
An interesting thing to note is that the higher order predicates for
fold left and fold right also differ in which argument they treat as
existential and which arguments they instantiate: 
</p>

<ul>
<li>for fold left, the list head and accumulator are existential, and the output is instantiated to be a cons.</li>

<li>for fold right, the list head and result are existential and the accumulator is instantiated to be an append.</li>
</ul>

<p>
This is quite nice as it mirrors exactly the different recursion
scheme between the two combinators, where fold left updates the
accumulator immediately, while fold right recuses on the tail first,
and then uses the result of the recursive call to update the
accumulator.
</p>

<p>
So, fold left, and fold right… not so different after all…
</p>
</div>
</div>
</article>
</main>
</div></div>
  </body>
</html>
