<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jabperf.com/my-fear-of-commitment-to-the-1st-cpu-core/">Original</a>
    <h1>My Fear of Commitment to the First CPU Core</h1>
    
    <div id="readability-page-1" class="page"><div data-id="64ede99" data-element_type="widget" data-widget_type="theme-post-content.default">
				<div>
			
<p><span><svg aria-hidden="true" focusable="false" data-icon="clock" width="20" height="20" fill="none" stroke="currentColor" style="display:inline-block;vertical-align:-0.1em" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></span><span></span><span>Estimated reading time:  </span><span>15</span><span> minutes</span></p>



<p><strong>‚Äú<em>Who hurt you?</em>‚Äú</strong></p>



<p>That‚Äôs the recurring question every confirmed bachelor, Lothario, and playboy expects to hear around this Valentine‚Äôs Day Season. That time of year when couples exchange gifts of love, share romantic dinners, or whisk away on a mini-trip. Meanwhile, free-wheeling casual daters skillfully avoid the festivities with their multiple paramours with well-rehearsed scripts criticizing the holiday‚Äôs emptiness and commercial nature. Once that Celebration of Exclusivity passes, they come back out of hiding, ready to mingle! But why is that? Could it just be that some of us enjoy the excitement of sparking a romance with new and interesting people? Or might it stem from a fear of commitment due to some past heartbreak? <em>‚ÄúWho hurt you?‚Äù</em> assumes the latter.</p>



<p>You and I have formed a pretty solid bond over these past couple years, so I‚Äôll come clean with you: I fear commitment. . . to the 1st CPU core. And not just core 0, either, which we all know usually catches the brunt of interrupts and typically is singled-out as a house-keeping core. I‚Äôm talkin‚Äô about the 1st core on *any* CPU socket. And you‚Äôre right ‚Äì it‚Äôs not due to some free-wheeling excitement gained from the willy-nilly scheduling of threads across cores. It‚Äôs because the 1st CPU core once hurt me deeply, and I haven‚Äôt looked at it the same way since. Here‚Äôs my story.</p>











<h2 id="h-the-1st-cpu-core-and-how-we-met"><strong>The 1st CPU Core and How We Met</strong></h2>



<p>My meet-cute with the 1st CPU core began around 2014. RHEL 7 had just been released with very few in the HFT space considering a migration from RHEL 6.8 and its 2.6.32 kernel until they could suss out all latency gotchas in RHEL 7‚Äôs 3.10.0 kernel. It was under this backdrop that I worked with a startup Options Trading Group of a Chicago-based HFT firm.</p>



<p>I deployed all the optimal configurations you‚Äôd expect for a low latency shop, many of which <a href="https://www.jabperf.com/game-of-low-latency/" target="_blank" rel="noreferrer noopener">I‚Äôve alluded to in past articles</a>. Paramount among these settings was isolating all cores (using <em><a href="https://access.redhat.com/solutions/480473" target="_blank" rel="noreferrer noopener">isolcpus</a></em>) on the second CPU socket (where all the odd-numbered cores reside), which was home to the PCIe lanes attached to the high-performance NIC. Free from the vagaries of the Linux kernel scheduler, these cores served as low-jitter locations on which to pin latency-critical application threads. One of the more important threads we pinned to core 1, the 1st core on that 2nd socket. And for a few weeks, it was a fairy-tale affair. High <a href="https://www.jabperf.com/ipc-is-to-cpu-what-milk-is-to-cinnamon-toast-crunch/" target="_blank" rel="noreferrer noopener">IPC</a>, low jitter, low latency ‚Äì the pairing seemed destined! But nothing lasts forever, does it?</p>



<h2 id="h-cracks-begin-to-show"><strong>Cracks Begin To Show</strong></h2>



<p><em><strong>‚ÄúMark, we‚Äôre suddenly experiencing sporadic latency spikes of over 1ms on core 1!‚Äù</strong></em></p>



<p>Weeks had gone by without a hitch on the Options Trading Group‚Äôs system. So how could this be? Now, for those of you who have never serviced customers in IT, I‚Äôll let you in on a little secret ‚Äì they *never* tell you the whole story. It‚Äôs always <em>‚ÄúNo, we didn‚Äôt change anything ‚Äì we were just moseying along and then BOOM!‚Äù</em> But hey, it is what it is. So, I fired up the <em><a href="https://opensource.com/article/21/7/linux-kernel-ftrace" target="_blank" rel="noreferrer noopener">FTrace</a></em> facility and began tracking scheduler events on that core:</p>



<pre><code>echo sched_switch &gt; /sys/kernel/debug/tracing/current_tracer
echo latency-format &gt; /sys/kernel/debug/tracing/trace_options</code></pre>



<p>Here‚Äôs some of the tracing output I found after enabling those <em>FTrace </em>options:</p>



<pre><code>TradeApp-31594   1d.s.. 70251098us!:  31594:115:R   + [001]     6:120:R ksoftirqd
TradeApp-31594   1d.... <mark><strong>70252191us</strong></mark>!:  31594:115:R ==&gt; [001]     6:120:R ksoftirqd
ksoftirqd-6      1d.... <mark><strong>70252599us</strong></mark>!:      6:120:S ==&gt; [001] 31594:115:R TradeApp

<strong>&lt;&lt;&lt; above represents ~400 microsecond scheduling latency &gt;&gt;&gt;</strong>

TradeApp-31594   1d.s.. 85246192us!:  31594:115:R   + [001]     6:120:R ksoftirqd
TradeApp-31594   1d.... <mark><strong>85246652us</strong></mark>!:  31594:115:R ==&gt; [001]     6:120:R ksoftirqd
ksoftirqd-6      1d.... <mark><strong>85262686us</strong></mark>!:      6:120:R ==&gt; [001] 31594:115:R TradeApp

<strong>&lt;&lt;&lt; above represents a whopping 16 millisecond scheduling latency &gt;&gt;&gt;</strong></code></pre>



<p><em>Ksoftirqd</em> was taking as much as 16 *milliseconds* of cpu time from the trading application thread! This kernel thread jumps into action in process-context when the interrupt-context <em>softirq </em>is overwhelmed with work and, thus, needs to offload it to a schedule-able entity. But what type of work overloaded the <em>softirq </em>so much that it had to enlist the help of <em>ksoftirqd</em>?</p>



<p>For this, I enabled the <em>function_graph</em> tracer in <em>FTrace </em>to track the flow of kernel functions called during <em>ksoftirqd</em>‚Äòs runtime. What did I find? A bunch of block request queue completion work (i.e., the cleaning of block layer structures created during the process of handling I/O) from the megasas disk I/O controller. </p>



<p>But why? No one pinned the megasas driver IRQ to core 1. So why was all its associated background processing running there?</p>



<h2 id="h-the-1st-cpu-core-and-its-wandering-eye"><strong>The 1st CPU Core and its Wandering Eye </strong></h2>



<p>Every now and then, you might miss a configuration step or two, even while using configuration management tools like Puppet or Ansible. So I verified my IRQ-assignment assumptions by checking <em>/proc/interrupts</em>, which confirmed my understanding. However, I *did* find a torrent of ‚ÄúFunction Call Interrupts‚Äù (or <strong>CAL </strong>in <em>/proc/interrupts</em> parlance) hitting our beloved core 1:</p>



<pre><code>           CPU0       <mark><strong>CPU1       </strong></mark>CPU2       CPU3       CPU4       CPU5       CPU6       CPU7       
  0:         47          0          0          0          0          0          0          0   IO-APIC-edge      timer
  1:         25          0          0          0          0          0          0          0   IO-APIC-edge      i8042
  8:          1          0          0          0          0          0          0          0   IO-APIC-edge      rtc0
  9:        528          0          0        287          0          0          0          0   IO-APIC-fasteoi   acpi
 12:        207          0          0          0          0          0          0          0   IO-APIC-edge      i8042
 16:        493          0        187          0          0          0          0          0   IO-APIC-fasteoi   ehci_hcd:usb1, nouveau
 17:      29465          0          0          0          0          0          0          0   IO-APIC-fasteoi   ath9k, snd_hda_intel
 19:          0          0          0          0          0          0          0          0   IO-APIC-fasteoi   xhci_hcd:usb3
 23:       9352          0          0          0          0          0          0          0   IO-APIC-fasteoi   ehci_hcd:usb2
 45:          0          0          0          0          0          0          0          0   PCI-MSI-edge      eth0
 46:     192342          0          0          0          0          0          0          0   PCI-MSI-edge      ahci
 47:         14          0          0          0          0          0          0          0   PCI-MSI-edge      mei
 48:        294          0          0          0          0          0          0          0   PCI-MSI-edge      snd_hda_intel
NMI:          0          0          0          0          0          0          0          0   Non-maskable interrupts
LOC:     552219    1010298    2272333    3179890    1445484    1226202    1800191    1894825   Local timer interrupts
SPU:          0          0          0          0          0          0          0          0   Spurious interrupts
PMI:          0          0          0          0          0          0          0          0   Performance monitoring interrupts
IWI:          0          0          0          0          0          0          0          0   IRQ work interrupts
RTR:          7          0          0          0          0          0          0          0   APIC ICR read retries
RES:      18708       9550        771        528        129        170        151        139   Rescheduling interrupts
<strong><mark>CAL</mark>:        711    <mark>9153934       </mark>1312       1261       1446       1411       1433       1432   Function call interrupts
</strong>TLB:       4493       6108       4981       5014       1788       2327       1967        914   TLB shootdowns
TRM:          0          0          0          0          0          0          0          0   Thermal event interrupts</code></pre>



<p>That‚Äôs 3 orders of magnitude more <strong>CAL</strong>s on core 1 than any other core! Further debugging and source code reading (explained in the next section) revealed the culprit as the <em>/sys/block/sda/queue/rq_affinity</em> setting. From the kernel docs:</p>



<p><em>‚ÄúIf this option is ‚Äò1‚Äô, the block layer will migrate request completions to the</em></p>



<p>And of course, it was at this point that I noticed another core on that same CPU socket performing a heavy stream of writes to the disk attached to the megasas driver. <em>‚ÄúOh yeah, Mark, we pinned a new thread to core 3 on that socket to perform our data writes. Did we forget to mention that?‚Äù</em> <strong>*sigh*</strong></p>



<p>Just to make sure you all are following me, here‚Äôs a recap: Core 1 and I agreed that it would dedicate itself to our trading workload, but then weeks later some other I/O workload came struttin‚Äô by and stole its attention away from me. Really? Just like that, huh? What ever happened to trust? To fidelity? To <em>‚Äôtil decommission do us part‚Äô</em>?!</p>



<p>This I/O-heavy workload on core 3 adversely impacted latency on core 1 due to<em> rq_affinity</em> interrupting it via <strong>CAL</strong>s to perform block request completion cleanup (as we‚Äôll learn in the next section). But why was it always core 1? Why not share it with other cores within that same LLC-sharing ‚Äúgroup‚Äù? To answer that, we gotta read the source.</p>



<h3 id="h-how-rq-affinity-used-to-work"><em>How rq_affinity *Used* to Work</em></h3>



<p>The workhorse for <em>rq_affinity</em> is the <em>__blk_complete_request()</em> function shown below from a 2.6.32 kernel release:</p>



<pre><code>void __blk_complete_request(struct request *req)
{
	struct request_queue *q = req-&gt;q;
	unsigned long flags;
	int ccpu, cpu, group_cpu;

	BUG_ON(!q-&gt;softirq_done_fn);

	local_irq_save(flags);
	cpu = smp_processor_id();
<strong>	<mark>group_cpu = blk_cpu_to_group(cpu);</mark>
</strong>
	/*
	 * Select completion CPU
	 */
	if (test_bit(QUEUE_FLAG_SAME_COMP, &amp;q-&gt;queue_flags) &amp;&amp; req-&gt;cpu != -1)
		ccpu = req-&gt;cpu;
	else
		ccpu = cpu;

	<mark><strong>if (ccpu == cpu || ccpu == group_cpu)</strong></mark> {
		struct list_head *list;
do_local:
		list = &amp;__get_cpu_var(blk_cpu_done);
		list_add_tail(&amp;req-&gt;csd.list, list);

		/*
		 * if the list only contains our just added request,
		 * signal a raise of the softirq. If there are already
		 * entries there, someone already raised the irq but it
		 * hasn&#39;t run yet.
		 */
		if (list-&gt;next == &amp;req-&gt;csd.list)
			raise_softirq_irqoff(BLOCK_SOFTIRQ);
	} <mark><strong>else if (raise_blk_irq(ccpu, req))</strong></mark>
		goto do_local;

	local_irq_restore(flags);</code></pre>



<p>Here, it finds the core that is currently servicing the IRQ (<em>cpu </em>variable), compares it to the core identified in the block I/O request struct as the originator of the I/O (<em>req-&gt;cpu </em>variable), and checks if <em>rq_affinity</em> is set (i.e.,<em> QUEUE_FLAG_SAME_COMP</em> flag). If set, and both cores are not one and the same OR do not belong to the same LLC-sharing group, it will interrupt the originating core to process the block request completion using the <em>raise_blk_irq()</em> function:</p>



<pre><code>/*
 * Setup and invoke a run of &#39;trigger_softirq&#39; on the given cpu.
 */
static int raise_blk_irq(int cpu, struct request *rq)
{
	if (cpu_online(cpu)) {
		struct call_single_data *data = &amp;rq-&gt;csd;

		data-&gt;func = trigger_softirq;
		data-&gt;info = rq;
		data-&gt;flags = 0;

		<strong><mark>__smp_call_function_single(cpu, data, 0);</mark></strong>
		return 0;
	}

	return 1;
}</code></pre>



<p>Aha, so now we know the source of all those <strong>CAL</strong>s we saw in <em>/proc/interrupts</em> ‚Äì the <em>__smp_call_function_single()</em> function!</p>



<p>Ok, so this all seems reasonable now, right? We had cores 1 and 3 in the same ‚Äúgroup‚Äù, with <em>rq_affinity</em> enabled, and the megasas IRQ pinned to a core which was NOT part of that group. Case closed, right? Wrong, because that still doesn‚Äôt explain why core 1 is *always* the victim among all the cores on that second CPU socket. Let‚Äôs take a look at the <em>blk_cpu_to_group()</em> function referenced in the code snippet above for more insight:</p>



<pre><code>static inline int blk_cpu_to_group(int cpu)
{
#ifdef CONFIG_SCHED_MC
	const struct cpumask *mask = cpu_coregroup_mask(cpu);
	return <strong>cpumask_first</strong>(mask);
#elif defined(CONFIG_SCHED_SMT)
	return <strong>cpumask_first</strong>(topology_thread_cpumask(cpu));
#else
	return cpu;
#endif
}</code></pre>



<p>Uh, what‚Äôs with that ‚Äú_first‚Äù suffix to the <em>cpumask_first()</em> function? Makes me nervous. Hmm, maybe I‚Äôm being paranoid. Let‚Äôs check out its definition:</p>



<pre><code>/**
 * <mark><strong>cpumask_first - get the first cpu in a cpumask</strong></mark>
 * @srcp: the cpumask pointer
 *
 * Returns &gt;= nr_cpu_ids if no cpus set.
 */
static inline unsigned int cpumask_first(const struct cpumask *srcp)
{
	return <mark><strong>find_first_bit</strong></mark>(cpumask_bits(srcp), nr_cpumask_bits);
}</code></pre>



<p>NOOOO!!! It *always* picks the first core in the group, thus causing core 1‚Äôs milliseconds-long hiccups! You broke my heart, core 1. You broke my heart. I‚Äôll never trust the 1st core on any CPU socket with a low-latency assignment ever again, especially not when there‚Äôs a <em>cpumask_first()</em> function defined in the kernel just waiting for someone to use in the future!</p>



<h2 id="h-the-1st-cpu-core-attempts-to-rekindle-our-flame"><strong>The 1st CPU Core Attempts To Rekindle Our Flame</strong></h2>



<p>Nowadays, <em>rq_affinity</em> offers an extra option which makes the core that is generating all the I/O clean up after itself:</p>



<p>‚Äú<em>For storage configurations that need to maximize distribution of completion</em>‚Äú</p>



<p>It also removes any consideration about the ‚Äúfirst core in the group‚Äù as depicted in this snippet from the same <em>__blk_complete_request()</em> function from a more recent kernel release:</p>



<pre><code>/*
	 * Select completion CPU
	 */
	if (test_bit(QUEUE_FLAG_SAME_COMP, &amp;q-&gt;queue_flags) &amp;&amp; ccpu != -1) {
		if (!test_bit(QUEUE_FLAG_SAME_FORCE, &amp;q-&gt;queue_flags))
			shared = cpus_share_cache(cpu, ccpu);
	} else
		ccpu = cpu;

	/*
	 * If current CPU and requested CPU share a cache, run the softirq on
	 * the current CPU. One might concern this is just like
	 * QUEUE_FLAG_SAME_FORCE, but actually not. blk_complete_request() is
	 * running in interrupt handler, and currently I/O controller doesn&#39;t
	 * support multiple interrupts, so current CPU is unique actually. This
	 * avoids IPI sending from current CPU to the first CPU of a group.
	 */
	if (ccpu == cpu || shared) {
		struct list_head *list;</code></pre>



<p>But how can I be sure? When you go through a betrayal of this magnitude, you‚Äôre not eager to jump right back into that relationship. Let‚Äôs set up a test for this new setting on Rocky 8.6 (kernel release 4.18.0-372.9.1) using the <em><a href="https://fio.readthedocs.io/en/latest/fio_doc.html" target="_blank" rel="noreferrer noopener">fio</a></em> microbenchmark and the <em><a href="https://www.jabperf.com/ima-let-you-finish-but-hunting-down-system-interrupts/#h-the-infinity-gauntlet-of-system-interrupt-hunting-tools" target="_blank" rel="noreferrer noopener">osnoise</a></em> latency tracker.</p>



<h3 id="h-testing-the-updated-rq-affinity-1"><em>Testing the Updated rq_affinity = 1</em></h3>



<p>For this test, we have isolated the cores of the 2nd CPU socket (all odd-numbered cores). The target disk IRQ is assigned to core 7, our <em>fio </em>microbenchmark is pinned to core 3, and <em>rq_affinity </em>is set to ‚Äò1‚Äô (the default).</p>



<p>In a separate window, I‚Äôve set up the <em>osnoise </em>tracer to track any disturbance lasting for longer than a millisecond against any core on the 2nd CPU socket *except* core 3, where our <em>fio </em>workload will run:</p>



<pre><code><strong>[root@eltoro ~]#</strong> cd /sys/kernel/tracing/
<strong>[root@eltoro tracing]#</strong> echo osnoise &gt; current_tracer
<strong>[root@eltoro tracing]#</strong> echo osnoise &gt; set_event
<strong>[root@eltoro tracing]#</strong> echo &#34;1,5,7,9,11,13,15&#34; &gt; osnoise/cpus
<strong>[root@eltoro tracing]#</strong> echo 1000 &gt; osnoise/stop_tracing_us</code></pre>



<p>In a separate window, I fire up <em>fio </em>to perform random writes for 300 seconds against a 5GB file using one thread pinned to core 3:</p>



<pre><code><strong>[root@eltoro ~]#</strong> fio -name=blogpost -numjobs=1 -cpus_allowed=3 -filename=/corefiles/mytest.file -direct=0 -rw=randwrite -bs=4k -size=5G -iodepth=64 -ioengine=libaio -time_based=1 -runtime=300</code></pre>



<p>Once I hit ‚ÄòENTER‚Äô on the <em>fio </em>command, I start the trace in the other window like so:</p>



<pre><code><strong>[root@eltoro tracing]#</strong> echo 1 &gt; tracing_on
<strong>[root@eltoro tracing]#</strong> cat trace_pipe</code></pre>



<p>After a few seconds, the trace automatically stops and displays this output as its final few lines:</p>



<pre><code>       . . .
       . . .
       . . .
       osnoise/7-13353 [007] d.h. 37384.833988: irq_noise: ahci[0000:87:00.0]:47 start 37384.833985696 duration 2390 ns
       osnoise/7-13353 [007] ..s. 37384.840123: <strong><mark>softirq_noise:    BLOCK:4 start 37384.833988294 duration 6134479 ns</mark></strong>
       osnoise/7-13353 [007] .... 37384.840124: sample_threshold: start 37384.833985490 duration <strong><mark>6138539 ns</mark></strong> interference 2
<strong>[root@eltoro tracing]#</strong></code></pre>



<p>I keep reenabling the trace during the <em>fio </em>microbenchmark but the trace keeps stopping at lines showing disturbances only for core 7 from softirqs executing block-related code. This is great because it means that it‚Äôs not bugging core 1 like in older kernel releases! We get further proof from the preponderance of reported ‚ÄúBLOCK‚Äù softirqs, 256,724 in all (0 on the other cores), going to core 7 in <em>/proc/softirqs</em>:</p>



<pre><code><strong>[root@eltoro ~]#</strong> cat /proc/softirqs
                    CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       <strong><mark>CPU7       </mark></strong>CPU8       CPU9       CPU10      CPU11      CPU12      CPU13      CPU14      CPU15
          HI:          1          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0
       TIMER:    1311064       4732       4732       4733       4732       4731       4731       4732       4731       4731       4731       4731       4731       4731       4731       4731
      NET_TX:      14369          1          2          1          2          0          1          0          1          0          0          0          2          0          1          0
      NET_RX:     547910        525     151351       2080          3          0          3          0          3          2          4          1          4          1          3          0
       <strong>BLOCK</strong>:<strong>        106          0          0          0          0          0          0     <mark>256724          </mark>0          0          0          0          0          0          0          0</strong>
    IRQ_POLL:          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0
     TASKLET:      33514          0          0          0          0          0          0          0         19          0         64          0          0          0          0          0
       SCHED:          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0
     HRTIMER:          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0
         RCU:     999445       4754       4733       5599       4734       4765       4732       5147       4732       4823       4732       4767       4732       4816       4732       4751</code></pre>



<p>Now let‚Äôs see what happens after a clean reboot with <em>rq_affinity </em>set to ‚Äò2‚Äô.</p>



<h3 id="h-testing-the-updated-rq-affinity-2"><em>Testing the Updated rq_affinity = 2</em></h3>



<p>Everything is configured the exact same way as in the previous section except <em>rq_affinity </em>is now set to ‚Äò2‚Äô. I fire up <em>fio</em>, then I commence tracing and begin reading from the pipe:</p>



<pre><code><strong>[root@eltoro tracing]#</strong> echo 1 &gt; tracing_on
<strong>[root@eltoro tracing]#</strong> cat trace_pipe
       osnoise/5-2065  [005] d.h.   475.145177: irq_noise: local_timer:236 start 475.145176545 duration 584 ns
       osnoise/5-2065  [005] ..s.   475.145181: softirq_noise:    TIMER:1 start 475.145177244 duration 3489 ns
       osnoise/5-2065  [005] d.H.   475.145183: irq_noise: irq_work:246 start 475.145182922 duration 425 ns
       osnoise/5-2065  [005] ....   475.145184: sample_threshold: start 475.145176397 duration 8003 ns interference 3
       osnoise/7-2066  [007] d.h.   475.156856: irq_noise: ahci[0000:87:00.0]:73 start 475.156846144 duration 9333 ns
       osnoise/7-2066  [007] d.h.   475.156858: irq_noise: irq_work:246 start 475.156856920 duration 1280 ns
       osnoise/7-2066  [007] ....   475.156859: sample_threshold: start 475.156845776 duration 12710 ns interference 2
       osnoise/7-2066  [007] d.h.   475.160222: irq_noise: ahci[0000:87:00.0]:73 start 475.160219278 duration 2770 ns
       osnoise/7-2066  [007] d.h.   475.160225: irq_noise: irq_work:246 start 475.160223535 duration 1506 ns
       osnoise/7-2066  [007] ....   475.160225: sample_threshold: start 475.160218911 duration 6392 ns interference 2
      osnoise/15-2070  [015] dNh.   475.184177: irq_noise: reschedule:253 start 475.184176989 duration 170 ns
      osnoise/15-2070  [015] dNh.   475.184180: irq_noise: irq_work:246 start 475.184178651 duration 1389 ns
      . . .
      . . .
      . . .</code></pre>



<p>It just goes on and on until I explicitly disable tracing. No <em>softirq </em>hiccups to be had on cores 1, 5, 7, 9, 11, 13, or 15. So, then, where are they going? They shifted to the core responsible for all the disk I/O (<em>fio</em>), core 3 (114,729 in total), according to <em>/proc/softirqs</em>:</p>



<pre><code><strong>[root@eltoro ~]#</strong> cat /proc/softirqs
                    CPU0       CPU1       CPU2       <strong><mark>CPU3       </mark></strong>CPU4       CPU5       CPU6       CPU7       CPU8       CPU9       CPU10      CPU11      CPU12      CPU13      CPU14      CPU15
          HI:          1          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0
       TIMER:     110220         88         88         89         88         88         88         89         88         88         87         87         87         87         87         87
      NET_TX:        658          1          2          1          0          0          1          0          1          0          2          0          2          0          1          0
      NET_RX:      47970         86       2752         88          2          0          1          0          2          2          3          1          2          1          1          0
      <strong> BLOCK:       6387          0          0     <mark>114729          </mark>0          0          0       4348          0          0          0          0          0          0          0          0</strong>
    IRQ_POLL:          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0
     TASKLET:       3140          0          0          0          0          0          0          0         19          0         64          0          0          0          0          0
       SCHED:          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0
     HRTIMER:          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0
         RCU:      51021         98         90        707         89        118         89        214         89        132         88        118         88        119         88        119</code></pre>



<p>It looks like the updated <em>rq_affinity</em> code works as advertised. So. . . does this mean the 1st CPU core can be trusted again?</p>



<h2 id="h-what-we-had-was-beautiful-but"><strong>What We Had Was Beautiful But. . .</strong></h2>



<p>You guys wanted to know why I can‚Äôt commit to the 1st CPU core. You wanted my answer to, <em>‚ÄúWho hurt you?‚Äù</em> Well, now you know the history. True, the 1st CPU core has come a long way toward rebuilding the foundation of trust we once had. But for as long as the kernel defines a <em>cpumask_first()</em> function, I will always worry that some other Linux feature might employ it to force unrelated, latency-spiking workloads upon that core. For this reason, my fear of commitment to the 1st CPU core remains. And I will continue admonishing my clients to avoid the 1st CPU core for any latency-sensitive application threads.</p>



<p>Will I continue maintaining my wildly varied ‚Äúconfirmed bachelor‚Äù lifestyle, too? Well, that‚Äôs a topic for another day on another blog. üòâ Happy Valentine‚Äôs Day!</p>
		</div>
				</div></div>
  </body>
</html>
