<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.reachablecode.com/2025/07/31/c26-reflections-adventures-compile-time-uml/">Original</a>
    <h1>C&#43;&#43;26 Reflections adventures and compile-time UML</h1>
    
    <div id="readability-page-1" class="page"><div>
		<div>
<figure><img fetchpriority="high" decoding="async" width="502" height="385" src="https://www.reachablecode.com/wp-content/uploads/2025/07/uml_reflections_c26.png" alt="" srcset="https://www.reachablecode.com/wp-content/uploads/2025/07/uml_reflections_c26.png 502w, https://www.reachablecode.com/wp-content/uploads/2025/07/uml_reflections_c26-300x230.png 300w" sizes="(max-width: 502px) 100vw, 502px"/></figure></div>






<p>The first thing I do every time I need to learn a new codebase is to start drawing the UML diagram of its classes, and usually give up soon after I started. The process of doing it manually is certainly useful, but now with reflections I figure it would be fun to try generate it instead.</p>



<p>With C++26 reflections[1] the general consensus is that the magnitude of language change is comparable to what happened with C++11. After my little experiment with it, I would cautiously agree. So how does one go about creating a (Plant)UML diagram at compile time? With something like <a href="https://godbolt.org/z/qcTzT9c8o">this</a>.</p>



<p>With the spoilers out of the way let’s dig in the details.</p>



<p>P2996[1] introduces a couple of operators, namely lift <code>^^</code> and splice<code> [: :]</code>. The first one “lifts” a type or variable into a “meta” space, and the “splice” one (which imho should have been called “grounding operator”) does the opposite.</p>



<p>The first thing to understand is that regardless of what we apply the lift operator (^^) to, it creates a <code>std::meta::info</code> type. This means that some <code>info</code> objects will be <em>reflections of types</em>, and some will be <em>reflections of values</em>. This creates confusion in my head, as at times one needs to check which <em>kind</em> of <code>info </code>something is, but there are good reasons for this and are well explained in section 2.2 of the paper. With that in mind let’s start coding.</p>



<div><pre data-lang="C++"><code>int main() {
  MyClass s;
  constexpr const char* const dot_graph_uml = make_class_graph&lt;MyClass&gt;();

  std::cout &lt;&lt; dot_graph_uml &lt;&lt; std::endl;
}</code></pre></div>



<p>You’ll notice right away there is an ugly, and seemingly avoidable char pointer. Let’s get back to that later. Not much happens in <code>main()</code> besides us calling function template that is just a wrapper for what we actually care about:</p>



<div><pre data-lang="C++"><code>template&lt;typename U&gt;
consteval const char* make_class_graph() { 
  std::string graph = &#34;@startuml \nskinparam linetype ortho \n&#34;;

  std::vector&lt;std::meta::info&gt; already_drawn;
  graph += make_class_graph_impl(^^U, already_drawn);
  graph += &#34;@enduml&#34;;

  return std::define_static_string(graph);
}</code></pre></div>



<p>Here we see the first interesting thing, something called <code>std::define_static_string</code>[2]. What this does is take what is a compile time <code>std::string</code> and create a string literal, which we can return from a consteval function. If we were to try to return the<code> std::string</code> we would be greeted with the compiler error</p>



<pre><code>&lt;source&gt;:116:24: note: pointer to subobject of heap-allocated object is not a constant expression
/opt/compiler-explorer/clang-bb-p2996-trunk-20250703/bin/../include/c++/v1/__memory/allocator.h:117:13: note: heap allocation performed here
  117 |     return {allocate(__n), __n};</code></pre>



<p>Which makes sense as we cannot expect to create an object we allocate on the heap at compile time, then have this object <em>exist</em> in the heap also at runtime. This is why we end up with a big fat literal string that holds our final UML diagram, which we can do whatever we want with in <code>main()</code>. Looking at the assembly you’ll see the end result:</p>



<div><pre data-lang="C"><code> .asciz  &#34;@startuml \nskinparam linetype ortho \ntogether {\n class \&#34;MyClass\&#34;\n  \&#34;MyClass\&#34;*--\&#34;unsigned int\&#34;\n  \&#34;MyClass\&#34;*--\&#34;unsigned int\&#34;\n  \&#34;MyClass\&#34;*--\&#34;unsigned int\&#34;\n  \&#34;MyClass\&#34;*--\&#34;Nested\&#34;\n  \&#34;MyClass\&#34;-up-|&gt;\&#34;MyBase\&#34;\n}\ntogether {\n class \&#34;Nested\&#34;\n  \&#34;Nested\&#34;*--\&#34;int\&#34;\n  \&#34;Nested\&#34;*--\&#34;int\&#34;\n  \&#34;Nested\&#34;*--\&#34;MyClass\&#34;\n}\ntogether {\n class \&#34;MyBase\&#34;\n  \&#34;MyBase\&#34;*--\&#34;vector&lt;int, allocator&lt;int&gt;&gt;\&#34;\n}\ntogether {\n class \&#34;vector&lt;int, allocator&lt;int&gt;&gt;\&#34;\n}\n@enduml&#34;
</code></pre></div>



<p>Now that we have a magic function that “defines a static string” for us, let’s dig into the actual reflection bits. The first thing to note is what we pass to <code>make_class_graph_impl</code>, which shows the use of the <em>lift</em> operator, <code>^^U</code>. This creates a std::meta::info object that in this case is a <em>reflection of a type</em>. The Impl function itself, as you may have guessed, is meant to be recursive and takes a second argument that we’ll explain later:</p>



<div><pre data-lang="C++"><code>consteval std::string make_class_graph_impl(std::meta::info head, std::vector&lt;std::meta::info&gt;&amp; already_drawn)
{
  [...]

  constexpr auto ctx = std::meta::access_context::current();
  std::string uml_diagram;
    
  uml_diagram += &#34;together {\n class &#34; + add_quotes(display_string_of(head)) + &#34;\n&#34;;
  
  const std::string indent = &#34;  &#34;;

  // members
  for (std::meta::info field_info : std::meta::nonstatic_data_members_of(head, ctx))
  {
    uml_diagram += indent +  add_quotes(display_string_of(head)) + composition_arrow + add_quotes(display_string_of(remove_ptr_cv_type_of(field_info))) + &#34;\n&#34;;
  }
[...]</code></pre></div>



<p>First let’s talk about the new “context” object: the main paper[1] describes it as “<em>a class that represents a namespace, class, or function from which queries pertaining to access rules may be performed[…]</em>“, and it was introduced in [3] as a mean to resolve the “encapsulation” issue. This context comes in 3 flavours:</p>



<ul>
<li><code>std::meta::access_context::current()</code>: for accessing the public stuff in the current scope</li>



<li>s<code>td::meta::access_context::unprivileged()</code>: for accessing public stuff in the global scope</li>



<li><code>std::meta::access_context::unchecked()</code>: for accessing anything in the global scope</li>
</ul>







<p>After that the interesting things are <code>std::meta::nonstatic_data_members_of(head, ctx)</code>, and <code>std::meta::info::display_string_of(head)</code>. Those are pretty self explanatory, and they do make “metaprogramming” as easy as “programming”!</p>



<p>It gets a bit trickier later, when we have to recurse</p>



<div><pre data-lang="C++"><code>uml_diagram += make_class_graph_impl(remove_ptr_cv_type_of(field_info), already_drawn);</code></pre></div>



<p>Besides the very convenient fact that we can keep track of what we iterate over already simply using an <code>std::vector&lt;std::meta::info&gt;</code>, we do define a custom function with the terrible name of <code>remove_ptr_cv_type_of</code>.</p>



<div><pre data-lang="C++"><code>consteval auto remove_ptr_cv_type_of(std::meta::info r) -&gt; std::meta::info {
  return decay(remove_pointer(is_type(r) ? r : type_of(r)));
}</code></pre></div>



<p>This does what it says on the box, as in our UML we don’t want to distinguish between const/volatile/pointers whathaveyou. The important and interesting bit however is <code>std::meta::is_type(..)</code>. This function tells us what kind of <em>info</em> object we have, as they can be reflections of anything, and therefore we need to test whether or not we have a reflection of a type or a value and apply std::meta::type_of only when necessary. This is a bit of a pain, but imho it’s a small price to pay for Reflections.</p>



<p>That is basically it, we just need to try it out<a href="https://www.plantuml.com/plantuml/png/hOx12i8m44Jl-OebHp5_8ANeMVzXQPSsc6vATYCKzTyrO2r2eHTlRsQPcQr5CMaU0XYGg-SH4muGF9DE8q5CsaSm6ZlIdXBS3JG1HS2UfrC1Qs3XdNCsi_YEgGNF-iVZXKIf_R5T7jsZUiiZ2bdpNFjoYSrOoih0jZNlh3VFi_35ahbHep4TFEiUC8JOu4TMrNhFLg8cRlCGNW00" data-type="link" data-id="//www.plantuml.com/plantuml/png/hOx12i8m44Jl-OebHp5_8ANeMVzXQPSsc6vATYCKzTyrO2r2eHTlRsQPcQr5CMaU0XYGg-SH4muGF9DE8q5CsaSm6ZlIdXBS3JG1HS2UfrC1Qs3XdNCsi_YEgGNF-iVZXKIf_R5T7jsZUiiZ2bdpNFjoYSrOoih0jZNlh3VFi_35ahbHep4TFEiUC8JOu4TMrNhFLg8cRlCGNW00"> plotting our PlantUML result</a>, which gets printed out at runtime in this case. </p>



<h2>References</h2>



<p>[1] <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2996r12.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2996r12.html</a></p>



<p>[2] <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3491r3.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3491r3.html</a></p>



<p>[3] <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3547r0.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3547r0.html</a></p>
	</div></div>
  </body>
</html>
