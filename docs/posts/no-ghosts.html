<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sunfishcode.online/no-ghosts/">Original</a>
    <h1>No Ghosts</h1>
    
    <div id="readability-page-1" class="page"><article>
  

  
    <p>Posted on <time datetime="2022-03-15T00:00:00+00:00">March 15, 2022</time></p>
  

  <p>This post proposes and explores a design principle for components in complex
software systems:</p>
<p><em>No Ghosts!</em></p>
<p>The ideas in this post aren&#39;t new; they come from papers and blog posts such as
<a href="http://erights.org/talks/thesis/markm-thesis.pdf">Robust Composition</a>, <a href="https://www.cs.cmu.edu/%7Ealdrich/papers/effects-icfem2018.pdf">Capabilities: Effects for Free</a>, <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">Parse, don&#39;t validate</a>,
the <a href="https://bytecodealliance.org/articles/1-year-update">nanoprocess model</a>, and the <a href="https://github.com/WebAssembly/component-model/blob/main/design/high-level/Choices.md">design choices in the Wasm component model</a>, which
itself incorporates ideas from Erlang, OCaml, Rust, COM, and many others. This post
is an attempt to articulate what I see as one of the themes that runs through all of
these. It&#39;s not any kind of official position, and it certainly won&#39;t be the last
word on any of these topics.</p>
<p>I&#39;d also be very interested in feedback on what makes sense here, what doesn&#39;t, and
what&#39;s missing: <a href="https://hachyderm.io/@sunfish">mastodon</a>,
<a href="https://bytecodealliance.zulipchat.com/#narrow/pm-with/254083-user254083">zulip</a>,
<a href="mailto:blog-feedback@sunfishcode.online">email</a>.</p>
<p>This is motivated by WASI and Wasm components, however the core ideas generalize
to any complex software system, including those using libraries, daemons,
containers, VMs, microservices, or a combination.</p>
<hr/>
<p>One of the main ways we can make complex systems manageable is to make them
<em>modular</em>. This means being able to add, remove, change, or understand individual
components (or whatever a system is composed of) without needing to consider the
system around them.</p>
<p>It&#39;s common for systems with large numbers of components to have problems with
unexpected interactions between components. A common response to these kinds of
problems is to impose a level of modularity by introducing <em>heavyweight barriers</em>,
such as sandboxes, process boundaries, firewalls, or service meshes. These
comprehensively block many of the avenues for components to interact. Then,
since components still do need to communicate, it&#39;s common to effectively poke
small holes in the barriers, such as allowing specific HTTP connections to pass
through.</p>
<p>However, while the barriers-and-pinholes approach fixes the immediate problems,
barriers are sometimes <em>too</em> comprehensive. They get in the way of connecting
things that we <em>do</em> want to connect. This then leads us to do more things
through the pinholes, or poke more pinholes, which then increases the risks of
unexpected interactions again.</p>
<p><a href="https://xkcd.com/2044/"><img src="https://imgs.xkcd.com/comics/sandboxing_cycle.png" alt="XKCD 2044: Sandboxing Cycle"/></a></p>
<p>There are many reasons why we get stuck on this path, but one is that
heavyweight barriers tend to focus us on limiting the <em>mechanisms</em> that let
components interact, such as which components a component can directly talk to,
and what kinds of messages it can send. However, the more fundamental problems
are often in the <em>relationships</em> between components. One of the things we can
do to avoid these problems, and promote modularity in a sustainable way, is to
design component APIs that avoid <em>ghosts</em>.</p>
<p>üëª? üò±!</p>
<h2 id="ghosts">Ghosts?</h2>
<p>By ‚Äúghost‚Äù here, I mean any situation where resources are referenced by
<em>plain data</em>.</p>
<p>And by ‚Äúplain data‚Äù here, I mean strings, integers, or any other data where
independently produced copies of the data are interchangeable. For example, two
completely independent parts of a system may create a string with the value
<code>&#34;Purple&#34;</code>, and the two strings will be interchangeable.</p>
<p>Plain data can contain filenames, network addresses, usernames, or other forms
of data which effectively <em>reference</em> resources.</p>
<p>For example, when we say that a particular string contains a filesystem path, we
mean that it <em>refers to</em> an entity in a filesystem namespace. Filesystem namespaces
are not explicitly passed as arguments in the APIs of many popular systems, so
from the perspective of an API, while paths are explicit string parameters, the
additional information <em>referenced</em> by those paths is not. In this post, we&#39;ll
say this additional information is being carried by a ‚Äúghost‚Äù:</p>
<pre data-lang="c"><code data-lang="c"><span>    </span><span>// We&#39;re explicitly passing a path, but implicitly
</span><span>    </span><span>// passing the namespace to resolve it in.
</span><span>    </span><span>do_stuff</span><span>(&#34;</span><span>/tmp/data.txt</span><span>&#34;);
</span></code></pre>
<p>By passing a filename, the caller here is requiring that the callee have a
specific filesystem namespace, in order to interpret that filename. This is
an example of a <em>relationship</em> between components that&#39;s difficult to control
with heavyweight barriers focused on <em>mechanisms</em>. The actual message is
just a string, which could be communicated through practically any pinhole.
And once the caller can send filenames through, it can depend on the callee
having a particular namespace and being able to resolve those filenames, and
we have the potential to get complex relationships between caller and callee,
despite whatever barriers we put between them.</p>
<p>As another example, suppose one part of a system sets an environment variable,
and another part of the system reads it.</p>
<p>‚¨Ö In one place:</p>
<pre data-lang="sh"><code data-lang="sh"><span>export </span><span>TIMEOUT</span><span>=</span><span>30
</span></code></pre>
<p>‚û° In another:</p>
<pre data-lang="c"><code data-lang="c"><span>char </span><span>*timeout = </span><span>getenv</span><span>(&#34;</span><span>TIMEOUT</span><span>&#34;);
</span></code></pre>
<p>Here, two independent parts of the system both use the string <code>&#34;TIMEOUT&#34;</code> as
an identifier to send a message between them. As far as these specific parts of
the code know, it&#39;s as if the content of the message is carried by a ghost,
from one part to the other.</p>
<p>IP addresses are another example of plain data that references other
resources. If one part of a system listens on a socket and sends the
IP address to other parts of the system for them to connect to, the address
is a plain-data list of integers, while the interpretation of those integers
depends on a particular network view.</p>
<p><img width="512" alt="Ghosts can occur in filesystems, networks, and more" src="https://blog.sunfishcode.online/Ghosts.svg"/></p>
<p>Ghosts can also occur within key-value stores, registries, brokers, buses, and
many other things where the identifiers are plain data. There are situations
where plain-data identifiers are the only option, such as when working with
external resources. But when designing component APIs, we should seek to avoid
ghosts where we can, and seek to identify and encapsulate ghosts where we can&#39;t.</p>
<p>Granted, the way all these things work isn&#39;t <em>literally</em> supernatural. We
can figure out how filesystem namespaces, environment-variable dictionaries,
networks, and other things make our resources available if we know some
things about the surrounding system. However, that goes against our goal of
modularity. We specifically don&#39;t want individual components knowing about
the system around them.</p>
<h3 id="the-trouble-with-ghosts">The trouble with ghosts</h3>
<p>Ghosts are often <em>convenient</em>, in the way that duct tape is convenient. They
can quickly connect two things, even in a large system, without extensive
changes. And on small scales, they sometimes work well. But like duct tape,
they aren&#39;t a material one wants to build complex structures from.</p>
<p><a title="1sfoerster, CC BY-SA 3.0 &lt;https://creativecommons.org/licenses/by-sa/3.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:DuctTape.jpg"><img width="512" alt="a boat made from cardboard and duct tape" src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0f/DuctTape.jpg/512px-DuctTape.jpg"/></a></p>
<p>Ghosts have four distinct problems as systems scale up in complexity:</p>
<ul>
<li>Ghosts don&#39;t always go to the places we want them to üëª‚û°üòû. When we pass
plain-data references around, they depend on the ghosts going to the same
places. If our references go somewhere that the ghosts don&#39;t go, attempting
to resolve them may fail, or may resolve to something unintended. An example
of this is <a href="https://cwe.mitre.org/data/definitions/706.html">CWE-706</a> ‚ÄúUse of Incorrectly-Resolved Name or Reference‚Äù.</li>
</ul>
<ul>
<li>Ghosts may go places we don&#39;t want them to üëª‚û°üò≤. For example, environment
variable values are propagated to all child processes, even those that
don&#39;t need them, and some programs log the contents of their environment for
diagnostic purposes. If our variables contain sensitive information, it may
get exposed. Similarly, ghosts may also persist for longer than we want them
to, because cleaning them up can lead to dangling or even aliasing
references. Examples of this include <a href="https://cwe.mitre.org/data/definitions/532.html">CWE-532</a> ‚ÄúInsertion of Sensitive
Information into Log File‚Äù and <a href="https://cwe.mitre.org/data/definitions/386.html">CWE-386</a> ‚ÄúSymbolic Name not Mapping to
Correct Object‚Äù.</li>
</ul>
<ul>
<li>Ghosts may collide with other ghosts üëª‚û°üí•‚¨Öüëª. In a complex system,
the same name can end up getting used in multiple places. Naming
conventions can help, but aren&#39;t enough if there are multiple instances of
the same component within the larger system. In the case of filesystem
namespaces, sometimes two different parts of a system need different versions
of a resource, but they both expect it to be at the same path. An example of
this is <a href="https://cwe.mitre.org/data/definitions/435.html">CWE-435</a> ‚ÄúImproper Interaction Between Multiple Correctly-Behaving
Entities‚Äù.</li>
</ul>
<ul>
<li>And sometimes, ghosts <em>come from</em> places they&#39;re not expected to ‚ùì‚û°üëª.
When plain data can reference resources, any plain data within a system
could potentially be representing a reference. Plain data may also be
influenced by attackers. Examples of this are <a href="https://cwe.mitre.org/data/definitions/22.html">CWE-22</a>
‚ÄúImproper Limitation of a Pathname to a Restricted Directory
(&#39;Path Traversal&#39;)‚Äù and <a href="https://cwe.mitre.org/data/definitions/73.html">CWE-73</a> ‚ÄúExternal Control of File Name or Path‚Äù.</li>
</ul>
<p>Systems which use ghost patterns often face several challenges:</p>
<h4 id="ghosts-complicate-static-analysis">Ghosts complicate static analysis</h4>
<p>Being unable to know where ghosts are going and where they&#39;re coming from makes
it difficult and often impossible to answer questions such as:</p>
<ul>
<li>
<p>‚ÄúI have sensitive data flowing through part of the system. Where are
all the places that might be able to access it?‚Äù</p>
</li>
<li>
<p>‚ÄúIf I change the behavior of something, what are all the things I
need to update?‚Äù</p>
</li>
<li>
<p>‚ÄúIf there&#39;s a bug in something, what parts of the system could be affected?‚Äù</p>
</li>
<li>
<p>‚ÄúIf an attacker can control certain input data, what are all the things
which they might be able to influence?‚Äù</p>
</li>
</ul>
<h4 id="ghosts-complicate-debugging">Ghosts complicate debugging</h4>
<p>A common way to debug complex systems is to isolate parts of the system and
study how they behave independently. Ghosts create situations where components
work differently when run independently than when they&#39;re run together, or
work differently in different environments, making this kind of debugging more
difficult.</p>
<p>Ghosts create hidden cause-and-effect relationships, making it harder to
understand the system&#39;s behavior.</p>
<h4 id="ghosts-are-often-a-sign-of-over-sharing">Ghosts are often a sign of over-sharing</h4>
<p>Over-sharing happens when a component is given access to resources that it
doesn&#39;t need. This often happens in namespace-oriented systems because it&#39;s
difficult to precisely configure namespaces to be fine-grained and share only
what&#39;s needed to each component. Even with features such as bind mounts on Linux,
it can be tricky to make sure that every part of a complex system has access to
all the things it needs, at the paths it expects them to be at, and nothing it
doesn&#39;t need. As a result, programs are often run with more filesystem access
than they strictly need.</p>
<p>This makes it difficult to follow the <a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">Principle of Least Authority</a> (PoLA).</p>
<h4 id="ghosts-can-contribute-to-confused-deputies">Ghosts can contribute to confused deputies</h4>
<p>A common pattern in complex systems composed of multiple privilege levels
is that some components are considered to run on behalf of specific users,
which determine their privilege level. We can call components that work this
way <em>deputies</em> of the users that own them.</p>
<p>When components send plain-data requests to components running as different
users, senders may be able to reference resources they shouldn&#39;t be able to
access. In such situations, receivers perform <em>access control</em>, explicitly
checking requests to see whether the sender has the appropriate privileges.
This is often tricky, especially when an API has a complex surface area.
Receivers may get <em>confused</em> into doing things they shouldn&#39;t allow senders
to ask them to do.</p>
<p>This is a form of the <a href="https://en.wikipedia.org/wiki/Confused_deputy_problem">confused deputy problem</a>.</p>
<h3 id="a-different-kind-of-relationship">A different kind of relationship</h3>
<p>Systems which have a concept of <em>handles</em>‚Äîvalues which can be passed between
components, but which are not <em>plain data</em>‚Äîcan use them to avoid ghosts.
Handles provide a way to make specific resources accessible across a component
boundary without requiring any other relationship.</p>
<p><a title="User:Mateus2019, CC BY 2.0 DE &lt;https://creativecommons.org/licenses/by/2.0/de/deed.en&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:GER-BY-RO-Wasserburg_am_Inn_-_Brucktor_(mechanische_T%C3%BCrglocken_au%C3%9Fen).jpg"><img width="256" alt="GER-BY-RO-Wasserburg am Inn - Brucktor (mechanische T√ºrglocken au√üen)" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/GER-BY-RO-Wasserburg_am_Inn_-_Brucktor_%28mechanische_T%C3%BCrglocken_au%C3%9Fen%29.jpg/256px-GER-BY-RO-Wasserburg_am_Inn_-_Brucktor_%28mechanische_T%C3%BCrglocken_au%C3%9Fen%29.jpg"/></a></p>
<p>Handles make cause-and-effect relationships clear, since they are explicitly
passed between components. And, receivers can assume that any handle they are
passed represents a resource that the sender is allowed to ask them to
operate on. That way, receivers need less authority of their own, which
reduces the risk of them accidentally misusing their authority.</p>
<h2 id="ghosts-can-hide-inside-explicit-sharing">Ghosts can hide inside explicit sharing</h2>
<p>One of the tricky things about ghosts is that they&#39;re about <em>relationships</em>
rather than specific <em>mechanisms</em>. Mechanisms tend to be easy to understand,
and to sandbox. But, relationships that permit ghosts can pass through even
the most restrictive sandboxes.</p>
<p>This blog post talks a lot about implicitly shared resources, however that&#39;s
not the only place ghosts can hide. For example, consider our example above of
caller and callee implicitly sharing a filesystem namespace, and passing
strings representing paths:</p>
<pre data-lang="c"><code data-lang="c"><span>    </span><span>do_stuff</span><span>(&#34;</span><span>/tmp/data.txt</span><span>&#34;);
</span></code></pre>
<p>This is a ghost pattern, with a string carrying a reference to an implicitly
shared namespace. A simple way we might try to eliminate such a ghost is to
replace the use of an implicit namespace with an explicit filesystem root
parameter:</p>
<pre data-lang="c"><code data-lang="c"><span>    </span><span>do_stuff_in_root</span><span>(root_handle, &#34;</span><span>tmp/file.txt</span><span>&#34;);
</span></code></pre>
<p>This might be tempting, as it means that most of our code doesn&#39;t need to
fundamentally change. It&#39;s a mostly mechanical change to just add root
parameters in places where they&#39;re needed, and everything else about our
code can stay the same.</p>
<p>We might then be tempted to claim that we&#39;ve eliminated our ghosts here, because
we now do the sharing via explicit communication rather than an implicitly
shared resource. And we might indeed find that this code does afford us some
added flexibility.</p>
<p>The problem is that this doesn&#39;t change the <em>relationship</em>. We&#39;re still using
strings to identify specific resources within the filesystem root we&#39;re
passing around. And that means we still have resources being referenced by
plain data.</p>
<p>There&#39;s effectively a ghost, hiding <em>inside</em> the resource.</p>
<p><a title="gamene, CC BY 2.0 &lt;https://creativecommons.org/licenses/by/2.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Ghost_onigiri_bento_(4039012309).jpg"><img width="512" alt="onigiri bento with a ghost inside (4039012309)" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Ghost_onigiri_bento_%284039012309%29.jpg/512px-Ghost_onigiri_bento_%284039012309%29.jpg"/></a></p>
<p>One way to think about it is in terms of granularity. While passing around
handles to ‚Äúroot‚Äù, ‚Äúworld‚Äù, ‚Äúnamespace‚Äù or ‚Äúregistry‚Äù resources is better
than implicit sharing, those kinds of resources tend to be coarse-grained.
They can end up having ghosts hiding inside them. Plain-data references to
specific items within coarse-grained resources can still have dynamic
cause-and-effect relationships, and can still dangle, collide, or be
influenced by attackers.</p>
<p>To avoid ghosts, it&#39;s not enough to change the mechanisms. To change the
relationships, we need to switch from coarse-grained sharing to fine-grained
sharing with handles. Instead of whole filesystems, we should ideally
reference specific directories or even individual files, such as like this:</p>
<pre data-lang="c"><code data-lang="c"><span>    </span><span>// Open the file using our own privileges.
</span><span>    file_handle = </span><span>open</span><span>(root_handle, &#34;</span><span>tmp/file.txt</span><span>&#34;);
</span><span>
</span><span>    </span><span>// Instead of passing root_handle and a path, pass
</span><span>    </span><span>// *just* the one file handle to the other component.
</span><span>    </span><span>process_open_file</span><span>(file_handle);
</span></code></pre>
<h2 id="how-to-smell-a-ghost">How to smell a ghost</h2>
<p>There are some common signs that a ghost may be present.</p>
<ul>
<li>
<p><em>String parameters which don&#39;t represent user data</em>. String types in
programming languages can hold many different kinds of things, such
as names or text fields. And when a program is talking to the outside
world, strings may also contain external identifiers such as filenames,
network addresses, or URLs. But when software is talking to
other software, resources should ideally be identified by handles,
rather than by string identifiers. And as a bonus, this also helps
minimize exposure to <a href="https://eev.ee/blog/2015/09/12/dark-corners-of-unicode/">Unicode subtleties</a> and <a href="https://cwe.mitre.org/data/definitions/149.html">quoting subtleties</a>.</p>
<p>Heuristic: ‚ÄúStrings are for humans‚Äù üåü</p>
</li>
<li>
<p><em>The word ‚Äúthe‚Äù</em>. Whenever we find ourselves thinking about <em>the</em>
filesystem, <em>the</em> network, <em>the</em> process, <em>the</em> host, <em>the</em> OS,
or <em>the</em> computer, it often means we&#39;re making assumptions about state
that might be shared between parts of a larger system. Wherever possible,
components should not be aware of ‚Äúthe host‚Äù, or any entities associated
with it, as nouns.</p>
<p>Heuristic: ‚ÄúComponents should be hostless‚Äù üåü</p>
</li>
<li>
<p><em>User identity outside the user interface</em>. While there&#39;s a place for
user-facing software to maintain an explicit knowledge of who they&#39;re
acting on behalf of, components interfacing with other components should eagerly
resolve that user authority to obtain finer-grained handles which can then
be passed to other components. That way, those other components don&#39;t need
the full access of the user, and will be less likely to make assumptions about
shared state associated with the user.</p>
<p>Heuristic: ‚ÄúHandles are permissions‚Äù üåü</p>
</li>
</ul>
<h2 id="wrapping-it-up">Wrapping it up</h2>
<p>An important property for complex software systems is that they be modular,
where parts can be isolated from the whole. Ghosts, or resources referenced by
plain data, create implicit relationships which must be considered when we add,
remove, change, or understand individual components. They impede modularity,
making complex systems less manageable.</p>
<p>This leads to a design principle for components in complex software systems:</p>
<p><em>No Ghosts!</em></p>
<p>üëª? üö´!</p>

</article></div>
  </body>
</html>
