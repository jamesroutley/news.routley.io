<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wolfgirl.dev/blog/2025-10-22-4-unconventional-ways-to-cast-in-typescript/">Original</a>
    <h1>Unconventional Ways to Cast in TypeScript</h1>
    
    <div id="readability-page-1" class="page"><article data-astro-cid-7jjqptxk=""> <p>I saw a <a href="https://bsky.app/profile/qntm.org/post/3m3dak7s63k2v">post by qntm</a> and remembered I had a playground with a similar idea. I then expanded that playground into a (probably non-exhaustive) list of ways to cast between arbitrary<sup><a href="#user-content-fn-arbitrary" id="user-content-fnref-arbitrary" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>  types in Typescript:</p>
<h2 id="convention-the-as-operator">Convention: The <code>as</code> Operator</h2>
<p>Ah, good ol&#39; <code>as</code>:</p>
<pre tabindex="0" data-language="ts"><code><span><span>const</span><span> cast</span><span> =</span><span> &lt;</span><span>A</span><span>, </span><span>B</span><span>,&gt;(</span><span>a</span><span>:</span><span> A</span><span>)</span><span>:</span><span> B</span><span> =&gt;</span><span> a </span><span>as</span><span> unknown</span><span> as</span><span> B</span><span>;</span></span></code></pre>
<p>We can&#39;t just directly do <code>a as B</code> because Typescript is smart enough to warn us about <strong>that</strong>, at least. That very same error message also says,</p>
<blockquote>
<p>If this was intentional, convert the expression to &#39;unknown&#39; first.</p>
</blockquote>
<p>So we can just do that :3</p>
<p>If we were approaching this from a type theoretic perspective, it&#39;s already done &amp; dusted, we have the most cut-and-dry demonstration of unsoundness, pack it up go home.</p>
<p>But, what if we couldn&#39;t use <code>as</code>? Can we still get between two completely unrelated types?</p>
<h2 id="unconvention-1-the-is-operator">Unconvention 1: The <code>is</code> Operator</h2>
<p><code>is</code> is commonly used for for interfacing with Typescript&#39;s flow-typing system, helping it figure out what exactly the return value of a boolean function <em>means</em>. For example:</p>
<pre tabindex="0" data-language="ts"><code><span><span>const</span><span> notUndefined1</span><span> =</span><span> &lt;</span><span>A</span><span>,&gt;(</span><span>a</span><span>:</span><span> A</span><span> |</span><span> undefined</span><span>)</span><span>:</span><span> boolean</span><span> =&gt;</span><span> a </span><span>!==</span><span> undefined</span><span>;</span></span>
<span><span>const</span><span> notUndefined2</span><span> =</span><span> &lt;</span><span>A</span><span>,&gt;(</span><span>a</span><span>:</span><span> A</span><span> |</span><span> undefined</span><span>)</span><span>:</span><span> a</span><span> is</span><span> A</span><span> =&gt;</span><span> a </span><span>!==</span><span> undefined</span><span>;</span></span>
<span></span>
<span><span>const</span><span> maybeNumber0</span><span>:</span><span> number</span><span> |</span><span> undefined</span><span> =</span><span> someExternalFunction</span><span>();</span></span>
<span><span>if</span><span> (maybeNumber0 </span><span>!==</span><span> undefined</span><span>) </span><span>return</span><span>;</span></span>
<span><span>// Thanks to flow-typing, Typescript knows that `maybeNumber0: number`</span></span>
<span><span>// if we get here.</span></span>
<span><span>const</span><span> maybeNumber1</span><span> =</span><span> someExternalFunction</span><span>();</span></span>
<span><span>if</span><span> (</span><span>notUndefined1</span><span>(maybeNumber1)) </span><span>return</span><span>;</span></span>
<span><span>// However, Typescript cannot infer flow from ordinary functions;</span></span>
<span><span>// At this point, it still thinks `maybeNumber1: number | undefined`</span></span>
<span><span>const</span><span> maybeNumber2</span><span> =</span><span> someExternalFunction</span><span>();</span></span>
<span><span>if</span><span> (</span><span>notUndefined2</span><span>(maybeNumber2)) </span><span>return</span><span>;</span></span>
<span><span>// The `is` annotation has the exact same `boolean` value at runtime,</span></span>
<span><span>// but provides extra information to the compiler, so Typescript can know</span></span>
<span><span>// that `maybeNumber2: number` if we get here.</span></span></code></pre>
<p>However, <code>is</code> is sort of an escape hatch outside the regular typing system, and we can abuse it to tell the compiler whatever we want:</p>
<pre tabindex="0" data-language="ts"><code><span><span>const</span><span> badDetector</span><span> =</span><span> &lt;</span><span>A</span><span>, </span><span>B</span><span>,&gt;(</span><span>a</span><span>:</span><span> A</span><span>)</span><span>:</span><span> B</span><span> =&gt;</span><span> {</span></span>
<span><span>    const</span><span> detector</span><span> =</span><span> (</span><span>_ab</span><span>:</span><span> A</span><span> |</span><span> B</span><span>)</span><span>:</span><span> _ab</span><span> is</span><span> B</span><span> =&gt;</span><span> true</span><span>;</span></span>
<span><span>    if</span><span> (</span><span>detector</span><span>(a)) </span><span>return</span><span> a;</span></span>
<span><span>    throw</span><span> new</span><span> Error</span><span>(</span><span>&#34;unreachable&#34;</span><span>);</span></span>
<span><span>};</span></span></code></pre>
<p>Typescript doesn&#39;t (and can&#39;t!) check that the function body is actually doing what the <code>is</code> assertion says. So we can just write a bad one on purpose! (Or on accident, introducing quite a subtle bug.)</p>
<h2 id="unconvention-2-mutation-across-boundaries">Unconvention 2: Mutation Across Boundaries</h2>
<p>This cast requires a &#34;seed&#34; value <code>b: B</code> in order to be able to cast <code>a: A</code> to <code>B</code>, but make no mistake: this sort of thing can come up fairly often if we&#39;re not careful about how we mutate objects.</p>
<pre tabindex="0" data-language="ts"><code><span><span>const</span><span> mutation</span><span> =</span><span> &lt;</span><span>A</span><span>, </span><span>B</span><span>,&gt;(</span><span>a</span><span>:</span><span> A</span><span>, </span><span>b</span><span>:</span><span> B</span><span>)</span><span>:</span><span> B</span><span> =&gt;</span><span> {</span></span>
<span><span>    const</span><span> mutate</span><span> =</span><span> (</span><span>obj</span><span>:</span><span> { </span><span>field</span><span>:</span><span> A</span><span> |</span><span> B</span><span> })</span><span>:</span><span> void</span><span> =&gt;</span><span> {</span></span>
<span><span>        obj.field </span><span>=</span><span> a;</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    const</span><span> obj</span><span> =</span><span> { field: b };</span></span>
<span><span>    mutate</span><span>(obj);</span></span>
<span><span>    return</span><span> obj.field;</span></span>
<span><span>};</span></span></code></pre>
<p>I showed this to a type theory friend and their reaction was:</p>
<blockquote>
<p>bruh
ts type system mega fails
Variance is hard xd xd xd</p>
</blockquote>
<p>What they meant by that was, the coercion from <code>{ field: B }</code> to <code>{ field: A | B }</code> is unsafe when the destination <code>field</code> is mutable; if we allow it, we get exactly the behavior shown here. To make it safe we&#39;d need <code>{ readonly field: A | B }</code>, which then prevents the mutation.</p>
<p>Another way of thinking about this is, Typescript currently has no way to &#34;flow&#34; the cast of/assignment to <code>obj.field</code> after the function runs. (Potentially on purpose, because that would make the type system even more complex &amp; limit certain useful patterns.) Inlining the <code>obj.field = a;</code> allows us to catch this, but the analysis does not go across function boundaries.</p>
<h2 id="unconvention-3-smuggling-through-structural-typing">Unconvention 3: Smuggling Through Structural Typing</h2>
<p>Typescript is structurally typed. This means that, if we have an <code>obj: { field: string }</code>, all we know is that there exists an <code>obj.field: string</code>. Typescript doesn&#39;t care at all if <code>obj</code> has other fields, and in fact this is the biggest advantage of structural typing: we can freely &#34;upcast&#34; to less restrictive types (i.e. fewer fields) without having to change runtime representations.</p>
<p>The downside of this sort of upcasting is that, some operations like <code>Object.values</code>/the spread operator are only properly typed when they have a complete list of fields, and have their assumptions violated when extra fields are in the mix:</p>
<pre tabindex="0" data-language="ts"><code><span><span>const</span><span> loopSmuggling</span><span> =</span><span> &lt;</span><span>A</span><span>, </span><span>B</span><span>,&gt;(</span><span>a</span><span>:</span><span> A</span><span>, </span><span>b</span><span>:</span><span> B</span><span>)</span><span>:</span><span> B</span><span> =&gt;</span><span> {</span></span>
<span><span>    const</span><span> objAB</span><span> =</span><span> { fieldA: a, fieldB: b };</span></span>
<span><span>    const</span><span> objB</span><span>:</span><span> { </span><span>fieldB</span><span>:</span><span> B</span><span> } </span><span>=</span><span> objAB;</span></span>
<span><span>    for</span><span> (</span><span>const</span><span> field</span><span> of</span><span> Object.</span><span>values</span><span>(objB)) {</span></span>
<span><span>        // Object.values believes all fields have type `B`,</span></span>
<span><span>        // but actually `fieldA` is first in iteration order.</span></span>
<span><span>        return</span><span> field;</span></span>
<span><span>    }</span></span>
<span><span>    throw</span><span> new</span><span> Error</span><span>(</span><span>&#34;unreachable&#34;</span><span>);</span></span>
<span><span>};</span></span>
<span></span>
<span><span>const</span><span> spreadSmuggling</span><span> =</span><span> &lt;</span><span>A</span><span>, </span><span>B</span><span>,&gt;(</span><span>a</span><span>:</span><span> A</span><span>, </span><span>b</span><span>:</span><span> B</span><span>)</span><span>:</span><span> B</span><span> =&gt;</span><span> {</span></span>
<span><span>    const</span><span> objA</span><span> =</span><span> { field: a };</span></span>
<span><span>    const</span><span> obj</span><span>:</span><span> {} </span><span>=</span><span> objA;</span></span>
<span><span>    const</span><span> objB</span><span> =</span><span> { field: b, </span><span>...</span><span>obj };</span></span>
<span><span>    // `objB.field` has been overwritten by the spread,</span></span>
<span><span>    // but Typescript doesn&#39;t know that.</span></span>
<span><span>    return</span><span> objB.field;</span></span>
<span><span>};</span></span></code></pre>
<p>These casts have the same restriction as (2), in that we require a &#34;seed&#34; value <code>b: B</code> in order to make it typecheck. Still, it&#39;s a bit of a double-whammy, because trying to avoid (2) by copying objects with a <code>...</code> spread can make you run smack-dab into this one elsewhere.</p>
<h2 id="unconvention-4--void-is-very-bad">Unconvention 4: <code>| void</code> is Very Bad</h2>
<p>This one&#39;s by far the most unconventional; the rest you&#39;re probably aware of if you&#39;ve worked with Typescript for a while, but this one hardly ever comes up because it&#39;s such a &#34;why even do this&#34; kinda deal. Still, I have seen it in my work&#39;s codebase (and immediately excised it once I realized), so it&#39;s not <em>impossible</em> to come across.</p>
<p>Anyways here it is:</p>
<pre tabindex="0" data-language="ts"><code><span><span>const</span><span> orVoid</span><span> =</span><span> &lt;</span><span>A</span><span>, </span><span>B</span><span>,&gt;(</span><span>a</span><span>:</span><span> A</span><span>)</span><span>:</span><span> B</span><span> =&gt;</span><span> {</span></span>
<span><span>    const</span><span> outer</span><span> =</span><span> (</span><span>inner</span><span>:</span><span> () </span><span>=&gt;</span><span> B</span><span> |</span><span> void</span><span>)</span><span>:</span><span> B</span><span> =&gt;</span><span> {</span></span>
<span><span>        const</span><span> b</span><span> =</span><span> inner</span><span>();</span></span>
<span><span>        if</span><span> (b) </span><span>return</span><span> b;</span></span>
<span><span>        throw</span><span> new</span><span> Error</span><span>(</span><span>&#34;falsy&#34;</span><span>);</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    const</span><span> returnsA</span><span> =</span><span> ()</span><span>:</span><span> A</span><span> =&gt;</span><span> a;</span></span>
<span><span>    const</span><span> voidSmuggled</span><span>:</span><span> () </span><span>=&gt;</span><span> void</span><span> =</span><span> returnsA;</span></span>
<span><span>    return</span><span> outer</span><span>(voidSmuggled);</span></span>
<span><span>};</span></span></code></pre>
<p>This is a combination of a few interesting things. For Typescript, <code>void</code> is primarily seen as a function&#39;s return value, indicating &#34;I don&#39;t care what this function returns because I&#39;m not going to use it&#34;. This is why any function, including our <code>() =&gt; A</code> one, can be safely coerced to <code>() =&gt; void</code>. Usually, this is safe, because once we have a <code>() =&gt; void</code>, we really can&#39;t assign its output to a variable, nor can we directly type a value as <code>void</code>; it&#39;s a very special type after all.</p>
<p>However, <code>void</code> can still participate in type combinations like <code>B | void</code>. And, because functions are <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html#variance-annotations">covariant</a> in their return type, <code>() =&gt; void</code> can be safely coerced to <code>() =&gt; B | void</code>. And, as it turns out, we <em>can</em> assign that <code>B | void</code> return type to a variable!</p>
<p>If <code>void</code> were meant to be assigned directly, it <em>should</em> behave something more like <code>any</code> or <code>unknown</code>. But it&#39;s not, so instead it behaves like a <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">falsy</a> type, because a normal <code>void</code>-returning function actually returns <code>undefined</code> at runtime. This is how we&#39;re able to <code>if (b) return b;</code> (which is <strong>not</strong> the same as checking <code>b</code>&#39;s true type!) &amp; still have everything typecheck.</p>
<p>Unfortunately, that means this cast only works for truthy <code>a</code>. But that&#39;s not too much of an issue I think, the Cool Factor outweighs this limitation :3</p>
<h2 id="does-this-even-matter">Does This Even Matter?</h2>
<p>Yes, but it&#39;s complicated.</p>
<p>On the one hand, Typescript is clearly just a &#34;best effort&#34; at adding types to Javascript, and it does a darn good job at that. If you&#39;re holding it right, these things don&#39;t come up, and your code genuinely is much much safer than if you used raw Javascript.</p>
<p>On the other hand, all these &#34;unconventions&#34; are real footguns one can stumble into &amp; unintentionally introduce unsafety into your codebase. It only takes a little bit of unsoundness in one place to render entire swaths buggy. We can do our best to avoid these patterns manually, but an automated solution will always be better at catching them.</p>
<h2 id="what-can-we-do-about-this">What Can We Do About This?</h2>
<p><strong>TL;DR</strong> use <a href="https://typescript-eslint.io/">typescript-eslint</a><sup><a href="#user-content-fn-typescript-eslint" id="user-content-fnref-typescript-eslint" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>. While neither Typescript<sup><a href="#user-content-fn-typescript" id="user-content-fnref-typescript" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup> nor Eslint<sup><a href="#user-content-fn-eslint" id="user-content-fnref-eslint" data-footnote-ref="" aria-describedby="footnote-label">4</a></sup> on their own come with enough rules to detect any of these, the typescript-eslint ruleset includes things like <a href="https://typescript-eslint.io/rules/prefer-readonly-parameter-types/">@typescript-eslint/prefer-readonly-parameter-types</a> (prevents (2)), <a href="https://typescript-eslint.io/rules/no-invalid-void-type/">@typescript-eslint/no-invalid-void-type</a> (prevents (4)), &amp; <a href="https://typescript-eslint.io/rules/no-unnecessary-type-parameters/">@typescript-eslint/no-unnecessary-type-parameters</a> (prevents the rest by making the <code>unknown</code> viral). Unfortunately, all of them are opt-in, and Typescript + eslint + typescript-eslint always requires a fair bit of mucking about to get working.</p>
<p>Anyways, I hope these examples are enough to convince you to use more aggressive linting on your Typescript projects in the future :3</p>
 </article></div>
  </body>
</html>
