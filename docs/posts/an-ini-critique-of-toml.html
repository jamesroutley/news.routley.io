<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/madmurphy/libconfini/wiki/An-INI-critique-of-TOML">Original</a>
    <h1>An INI Critique of TOML</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p><em>Be conservative in what you do, be liberal in what you accept from others.</em></p>
<p>— <a href="https://en.wikipedia.org/wiki/Robustness_principle" rel="nofollow">Postel&#39;s law</a></p>
<p>Comparing TOML and INI is not straightforward. The first is a unique standard, the second is a federation of dialects. All INI dialects however are well-defined (every INI file is parsed by some application, and by studying a parser&#39;s source code it is <a href="https://github.com/madmurphy/libconfini/wiki/INI-formats">possible to deduce its rules</a>), and, if one looks closely, the number of INI dialects actually used in the wild is not infinite. With an inclusive approach in mind, <strong>libconfini</strong> tries to acknowledge, catalog and extend many of them, so that what once was an informal standard becomes a flexible standard engraved by years of common habits. In referring to “the INI format” this document implicitly refers to that fluid format that <strong>libconfini</strong> is able to parse; and such flexibility is referred to as one of the language&#39;s intrinsic features.</p>
<p>Although it claims to be a human-friendly language, TOML constitutes a step back into something more robotic and primitive when compared to INI files and <strong>libconfini</strong>&#39;s approach. Some of TOML&#39;s problems are shared with JSON, which is a problematic format outside the ECMAScript realm. Other are instead problems that TOML has created on its own. The reasons why this document addresses TOML and not, for example, JSON or YAML are two. The first obvious reason is that TOML&#39;s syntax is so similar to INI that it is useful to draw a line in front of other formats&#39; problematic design and explain why INI is something else. The other reason is that, while other formats like YAML modestly define themselves as “official subsets” of JSON (which was not born as a configuration format, but rather as a serialization format), TOML claims to be a “minimal configuration file format” – despite being another, definitely not minimal, JSON preprocessor, with dates.</p>
<p>TOML&#39;s syntax is documented at <a href="https://toml.io/en/v1.0.0" rel="nofollow">https://toml.io/en/v1.0.0</a> (at the time of writing its current revision is <a href="https://github.com/toml-lang/toml/tree/8296d6ba97aaaf3151a32a22ed0513301ac650bf">r793.8296d6b</a>). The following paragraphs explain why you might want to avoid TOML for your next configuration file for a C or a C++ application.</p>
<p>Writing a harsh critique of someone else&#39;s efforts is never a pleasant task. But it might be a necessary task when these efforts go in the wrong direction. It is possible that at some point TOML designers will fix the issues listed below. If they will do so, they will finally end up re-inventing INI files.</p>
<h2 id="user-content-1-data-types"><a href="#1-data-types">1. Data types<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>A TOML document syntactically <em>defines</em> data types. This means that writing <code>89</code> and writing <code>&#34;89&#34;</code> are two different things (the first is a number, the second is a string). And this also means that a compliant TOML parser <em>must</em> respond to type changes in a TOML document. Today you write <code>&#34;89&#34;</code>, your application receives a string and everything goes well, but tomorrow you write <code>89</code> and your application <em>must</em> receive a number…</p>
<p>…and crash.</p>
<p>Of course no application would let anyone do that. Any judicious application using TOML for its configuration will be either tolerant towards improper data types, or will be obstinate and refuse type changes. In the first scenario you will have a non-compliant TOML parser (basically an INI parser), in the second scenario you will have a parser slightly more stupid than an INI parser and still non-compliant (it will not allow a TOML document to define a data type). The question is then: why giving the configuration file the power to speak about data types when at the end of the day it does not have this power (the application does)? The whole thing sounds like “You decide. No, wait, I decide.”</p>
<p>In INI files everything is <em>a castable string</em>. It means that an application always receives a string, and such string is always able to produce a boolean, a number, a simple string, or <em>an array of castable strings</em>, without generating errors. But the application decides what to pick up and how to react to it, not the configuration file. If you want to tell the human about it, write it in a comment, but don&#39;t give the configuration file the illusion of a power it does not possess.</p>
<h2 id="user-content-2-quotes-in-values"><a href="#2-quotes-in-values">2. Quotes in values<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>There is also a deeper issue with data types. Imagine the following configuration file:</p>
<div data-snippet-clipboard-copy-content="[server]
continent = Europe"><pre><code>[server]
continent = Europe
</code></pre></div>
<p>The value above is not required to be a string, it is required to be <em>a continent name</em>. Writing</p>
<div data-snippet-clipboard-copy-content="[server]
continent = 1009"><pre><code>[server]
continent = 1009
</code></pre></div>
<p>is not worse than writing</p>
<div data-snippet-clipboard-copy-content="[server]
continent = &#34;Vacuum cleaner&#34;"><pre><code>[server]
continent = &#34;Vacuum cleaner&#34;
</code></pre></div>
<p>There is no award to gain in demanding that a value avoid a syntax that for some reason is reserved for numbers when it must not be a lot of other things either. And it does not make much sense to create a “string data type” when a “continent name data type” would be required – once again: <em>the <code>continent</code> key above does not expect a string, it expects a continent name</em> (which is not a string more than the ASCII characters used to express numbers are).</p>
<p>Instead, without any valid reason, TOML&#39;s syntax forces humans to encapsulate anything that is not a number, a boolean or a date in quotes, disregarding the fact that this would incorrectly present <code>Europe</code> as a string (it is an enumeration label to be exact – in configuration files most values tend to be enumeration labels of some sort) and despite humans would not need quotes for understanding when a sequence of characters – like <code>poet</code> – is not a boolean, or a number, or a date – as for the machines, that would not be a hard task either.</p>
<div data-snippet-clipboard-copy-content="[shakespeare]
birth = 1564
death = 1616

# invalid in TOML
job = poet"><pre><code>[shakespeare]
birth = 1564
death = 1616

# invalid in TOML
job = poet
</code></pre></div>
<p>It is probably not a coincidence that one of the first things that <a href="http://hjson.org/" rel="nofollow">the Hjson project</a> did in order to create a dialect of JSON “easy for humans to read and write” was to remove the necessity of using quotes for declaring strings.</p>
<p>TOML&#39;s creator claims that unquoted strings are inherently ambiguous. We can try to imagine the following scenario,</p>

<p>where the quotes seem to suggest that also <code>&#34;252.1&#34;</code> (i.e. a string) would be a valid value for the <code>version</code> key. But do they? What about?</p>
<div data-snippet-clipboard-copy-content="version = &#34;252_1%2!3?4-5/6=7&#34;"><pre><code>version = &#34;252_1%2!3?4-5/6=7&#34;
</code></pre></div>
<p>Would that be a valid version string? What other information does quoting <code>252</code> give except that there could also be “something else” than a simple number?</p>
<p>Without a comment that explains exactly how to format the <code>version</code> key there is just no way to make it unambiguous, quotes or not.</p>
<div data-snippet-clipboard-copy-content="#INI

# Please use MAJOR(.MINOR(.REVISION)) here
version = 252.1.0"><pre><code>#INI

# Please use MAJOR(.MINOR(.REVISION)) here
version = 252.1.0
</code></pre></div>
<p>As in a language that has an extensible semantics, in INI files quotes serve the simple purpose of giving hints, expressing literalness, or removing <em>syntactic</em> (not semantic) ambiguity when there is the risk of it, exactly like a human would do. For instance, an INI file would use quotes like the following example does, for indicating that the <code>#</code> character in <code>#fff000</code> does not mark a comment.</p>

<h2 id="user-content-3-case-sensitivity"><a href="#3-case-sensitivity">3. Case sensitivity<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>TOML&#39;s syntax is always case-sensitive, despite the fact that there are situations where a configuration file <em>must</em> be case-insensitive (think of configuration files that map a FAT32 filesystem or HTML tags, for example). INI formats can be either case-sensitive or case-insensitive depending on the application&#39;s choice.</p>
<h2 id="user-content-4-unicode-key-names"><a href="#4-unicode-key-names">4. Unicode key names<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>TOML&#39;s syntax forbids non-ASCII key names unless these are surrounded by quotes.</p>
<div data-snippet-clipboard-copy-content="value in € = 345    # valid with libconfini but invalid in TOML"><pre><code>value in € = 345    # valid with libconfini but invalid in TOML
</code></pre></div>
<p>There is no apparent motivation behind this rule, except that of conforming TOML to JSON, and probably a personal habit in dealing with the latter. But although JSON <em>does</em> have a valid reason to do so because of the programming language it has been designed to work with (ECMAScript property names follow the same rule of identifiers), TOML&#39;s reason remains somewhat mysterious.</p>
<h2 id="user-content-5-square-brackets"><a href="#5-square-brackets">5. Square brackets<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>TOML forces arrays to be encapsulated within square brackets (exactly like section paths do), although humans do not need square brackets for recognizing when something is a list.</p>
<div data-snippet-clipboard-copy-content="# not an array in TOML
wishes = apples, cars, elephants, chairs"><pre><code># not an array in TOML
wishes = apples, cars, elephants, chairs
</code></pre></div>
<p>Nested arrays are also not a valid reason for justifying square brackets, since in INI files it is already possible to nest arrays either by using different delimiters for each level,</p>
<div data-snippet-clipboard-copy-content="wishes = \
    apples : oranges : lemons, \
    cars, \
    elephants : tigers, \
    chairs"><pre><code>wishes = \
    apples : oranges : lemons, \
    cars, \
    elephants : tigers, \
    chairs
</code></pre></div>
<p>or by recursively quoting.</p>
<div data-snippet-clipboard-copy-content="wishes = \
    &#34;apples oranges lemons&#34; \
    cars \
    &#34;elephants tigers&#34; \
    chairs"><pre><code>wishes = \
    &#34;apples oranges lemons&#34; \
    cars \
    &#34;elephants tigers&#34; \
    chairs
</code></pre></div>
<p>But there is a more important reason why square brackets are a bad idea in a human-friendly configuration format: one-member arrays. There is no way to convince a human that something composed of only one member is a list (if you think differently, chances are that you are partly non-human). As friendly as they are, INI files behave accordingly, while TOML of course doesn&#39;t. Compare this (INI):</p>

<p>with this (TOML):</p>

<p>As in the C language, in INI files <em>a one-member array and a simple value are stored in the same way</em>. Of course you can declare a one-member array in INI files: just write a simple string.</p>
<p>Thanks to this, INI arrays do not constitute a syntactically distinct type and any string can be parsed as an array. If you have ever dealt with m4 macro arguments you will know the beauty of this.</p>
<h2 id="user-content-6-array-delimiters"><a href="#6-array-delimiters">6. Array delimiters<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>TOML forces arrays to be always comma-separated, although a human can recognize a list even when the separator is a mushroom.</p>
<div data-snippet-clipboard-copy-content="[Super Mario]
wishes = jumping 🍄 sneaking into pipes 🍄 princess Peach 🍄 flying
coins = 39586235"><pre><code>[Super Mario]
wishes = jumping 🍄 sneaking into pipes 🍄 princess Peach 🍄 flying
coins = 39586235
</code></pre></div>
<p><strong>libconfini</strong> does not allow mushrooms either – but for practical, not philosophical reasons (and the library is not human yet) – but you are free to choose any character within the ASCII range as array delimiter and change it as often as you wish. For instance, in an INI file where normally arrays are comma-separated you might decide that an IP address is also an array, but whose members are separated by dots instead of commas – and just because that is what an IP address actually is, and that might be what your application needs.</p>
<h2 id="user-content-7-mixed-arrays"><a href="#7-mixed-arrays">7. Mixed arrays<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>TOML encourages a nightmare for strongly typed languages like C and C++: mixed arrays. In short, after deciding that a configuration file must express strong types (and nevertheless still allowing <code>&#34;Vacuum cleaner&#34;</code> as a continent name), TOML forces applications to be able to mix them and display some kind of support for something that is natively not supported.</p>
<p>An array that mixes numbers, strings and other arrays is something a C or C++ application would escape from. Although it is possible to reach the same result also with INI, with both TOML and INI a mixed array can be just emulated, <em>never really implemented</em> from the C perspective (we have left an example under <code>examples/miscellanea/toml-like.c</code>, and we would discourage anyone from doing it). The difference between INI and TOML? INI syntax has <em>the power to express</em> mixed arrays but does not require applications to map them as such, TOML does.</p>
<h2 id="user-content-8-composite-configuration-files"><a href="#8-composite-configuration-files">8. Composite configuration files<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>TOML&#39;s syntax forbids to populate sections in different steps (sections are named “tables” in TOML). The following example, understood by a human and an INI parser, would be forbidden in TOML:</p>
<div data-snippet-clipboard-copy-content="[visitors]
list = karl, lisa, Andrew Smith, rick92

[host]
foo = bar

[visitors]          # invalid in TOML
checked = true      # invalid in TOML"><pre><code>[visitors]
list = karl, lisa, Andrew Smith, rick92

[host]
foo = bar

[visitors]          # invalid in TOML
checked = true      # invalid in TOML
</code></pre></div>
<p>Although this might look like an insignificant detail, allowing to populate a configuration file in different steps can come very much in handy when dealing with the composition of several smaller configuration files.</p>
<h2 id="user-content-9-dates"><a href="#9-dates">9. Dates<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>This is probably the most mysterious part of TOML language. In INI files a value can be <em>interpreted</em> as a boolean, a number, a string, an array, or whatever else you like (although in this last case <strong>libconfini</strong> will not help you). The situation is kind of similar in TOML (without the “whatever else you like” part), except that a value can also be <em>a date</em>.</p>
<p>There is something intriguing in all this. Even forgetting that an application might not need dates at all, why constraining something so particular and that can be formatted in so many different ways into a rigid primitive? Why not doing that for <em>a path</em>? Or <em>a username</em>? Or <em>an email address</em>? Or <em>a regular expression</em>? …Or <em>a continent name</em>? These have all a more constraining semantics than dates.</p>
<p>In INI files a date is either a time stamp or a human-friendly string.</p>
<div data-snippet-clipboard-copy-content="date = &#34;Thu, 30 Aug 2012 12:31:00 GMT&#34;"><pre><code>date = &#34;Thu, 30 Aug 2012 12:31:00 GMT&#34;
</code></pre></div>
<h2 id="user-content-10--empty-key-names"><a href="#10--empty-key-names">10.  Empty key names<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>Although a human would have no idea of what it could possibly mean (and probably a machine would not do any better), TOML&#39;s syntax explicitly allows (but discourages) to assign values to empty key names.</p>
<div data-snippet-clipboard-copy-content="&#34;&#34; = &#34;whatever&#34;     # valid in TOML
&#39;&#39; = &#39;whatever&#39;     # valid in TOML
= &#39;whatever&#39;        # invalid in TOML (seriously?)"><pre><code>&#34;&#34; = &#34;whatever&#34;     # valid in TOML
&#39;&#39; = &#39;whatever&#39;     # valid in TOML
= &#39;whatever&#39;        # invalid in TOML (seriously?)
</code></pre></div>
<h2 id="user-content-11-arrays-of-tables-aka-arrays-of-sections"><a href="#11-arrays-of-tables-aka-arrays-of-sections">11. Arrays of tables (a.k.a. arrays of sections)<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>Sometimes what initially appears to be a nice invention can end up being the opposite – yes, this can happen too. We are talking about arrays of tables here (a.k.a. arrays of sections).</p>
<p>Arrays of tables are declared in TOML using the double square bracket notation:</p>
<div data-snippet-clipboard-copy-content="# TOML

[[server]]
ip = &#34;214.252.11.145&#34;
country = &#34;Australia&#34;

[[server]]
ip = &#34;214.252.11.146&#34;
country = &#34;India&#34;

[[server]]
ip = &#34;214.252.11.147&#34;
country = &#34;Sweden&#34;

..."><pre><code># TOML

[[server]]
ip = &#34;214.252.11.145&#34;
country = &#34;Australia&#34;

[[server]]
ip = &#34;214.252.11.146&#34;
country = &#34;India&#34;

[[server]]
ip = &#34;214.252.11.147&#34;
country = &#34;Sweden&#34;

...
</code></pre></div>
<p>Strictly speaking, arrays of tables introduce the concept of “unnamed tables” – <code>server</code> in the example above is not the name of a table, it is the name of <em>a collection of tables, each of which does not have a name</em>. But independently of the syntactical consequences, this feature carries a major problem: it encourages using configuration files as databases.</p>
<p>The common way to deal with similar scenarios in INI files would be that of keeping a common parent section – so that the application can scroll blindly through the sibling subsections – and making the nesting explicit by giving each subsection a name (in fact, the only unnamed section in INI files can be the document&#39;s root):</p>
<div data-snippet-clipboard-copy-content="# INI

[server.main]
ip = 214.252.11.145
country = Australia

[server.secondary]
ip = 214.252.11.146
country = India

[server.broken]
ip = 214.252.11.147
country = Sweden

# You can add an infinite number of `server.*` subsections here and use
# arbitrary names, the application will retrieve all of them."><pre><code># INI

[server.main]
ip = 214.252.11.145
country = Australia

[server.secondary]
ip = 214.252.11.146
country = India

[server.broken]
ip = 214.252.11.147
country = Sweden

# You can add an infinite number of `server.*` subsections here and use
# arbitrary names, the application will retrieve all of them.
</code></pre></div>
<p>The INI way is inherently more human-readable (humans like descriptive names), and produces the nice outcome that when the entries have become too many, and naming each of them has become too cumbersome, it is the good sign that you should finally switch to a database format and keep your configuration file clean.</p>
<p>Even <a href="https://github.com/toml-lang/toml/blob/8296d6ba97aaaf3151a32a22ed0513301ac650bf/README.md#Example">TOML&#39;s featured example</a> proposes “the INI way”</p>
<div data-snippet-clipboard-copy-content="[servers.alpha]
ip = &#34;10.0.0.1&#34;
role = &#34;frontend&#34;

[servers.beta]
ip = &#34;10.0.0.2&#34;
role = &#34;backend&#34;"><pre><code>[servers.alpha]
ip = &#34;10.0.0.1&#34;
role = &#34;frontend&#34;

[servers.beta]
ip = &#34;10.0.0.2&#34;
role = &#34;backend&#34;
</code></pre></div>
<p>instead of “the TOML way”</p>
<div data-snippet-clipboard-copy-content="[[servers]]
ip = &#34;10.0.0.1&#34;
role = &#34;frontend&#34;

[[servers]]
ip = &#34;10.0.0.2&#34;
role = &#34;backend&#34;"><pre><code>[[servers]]
ip = &#34;10.0.0.1&#34;
role = &#34;frontend&#34;

[[servers]]
ip = &#34;10.0.0.2&#34;
role = &#34;backend&#34;
</code></pre></div>
<p>for presenting the language.</p>
<p>But if this does not convince you, and at the end of the day you really want to play dirty with your configuration files, INI sill offers you its quirks to reach TOML&#39;s effect, without the inconvenience of introducing anonymous sections:</p>
<div data-snippet-clipboard-copy-content="# INI

[server.&#34;214.252.11.145&#34;]
country = Australia

[server.&#34;214.252.11.146&#34;]
country = India

[server.&#34;214.252.11.147&#34;]
country = Sweden

..."><pre><code># INI

[server.&#34;214.252.11.145&#34;]
country = Australia

[server.&#34;214.252.11.146&#34;]
country = India

[server.&#34;214.252.11.147&#34;]
country = Sweden

...
</code></pre></div>
<p>It goes without saying that you should not follow TOML in this. INI is not a database format; it targets primarily humans, not machines. If you want to store multiple sections of the same kind, please give them human-friendly names, and have fun.</p>
<h2 id="user-content-12-lack-of-support-for-implicit-keys"><a href="#12-lack-of-support-for-implicit-keys">12. Lack of support for implicit keys<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>Serialization formats often have shortcuts for expressing a <code>true</code> boolean implicitly. A bare HTML attribute, for instance, is automatically given the <code>&#34;true&#34;</code> value – i.e. the <code>contenteditable</code> attribute in the following example is automatically parsed as <code>contenteditable=&#34;true&#34;</code>.</p>
<div data-snippet-clipboard-copy-content="&lt;div contenteditable class=&#34;my-class&#34;&gt;&lt;/div&gt;"><pre><code>&lt;div contenteditable class=&#34;my-class&#34;&gt;&lt;/div&gt;
</code></pre></div>
<p>Similarly, in the following INI fragment from <code>/etc/pacman.conf</code> (<strong>Arch</strong>), <code>Color</code> is an implicit key representing a <code>true</code> boolean – i.e. <code>Color = YES</code>.</p>
<div data-snippet-clipboard-copy-content="HoldPkg = pacman glibc
Architecture = auto
IgnorePkg =
Color
SigLevel = Required DatabaseOptional
LocalFileSigLevel = Optional"><pre><code>HoldPkg = pacman glibc
Architecture = auto
IgnorePkg =
Color
SigLevel = Required DatabaseOptional
LocalFileSigLevel = Optional
</code></pre></div>
<p>TOML lacks support for implicit keys, and key names not followed by an equals sign always constitute syntax errors.</p>
<h2 id="user-content-13-inline-tables-must-remain-inline"><a href="#13-inline-tables-must-remain-inline">13. Inline tables must remain… inline<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>In addition to the INI way, TOML introduces a duplicate way of declaring sections: “inline tables”. The following TOML example:</p>
<div data-snippet-clipboard-copy-content="# TOML

homepage = { page_header = &#34;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&#34;, page_footer = &#34;Orci varius natoque penatibus et magnis dis parturient montes.&#34; }"><pre><code># TOML

homepage = { page_header = &#34;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&#34;, page_footer = &#34;Orci varius natoque penatibus et magnis dis parturient montes.&#34; }
</code></pre></div>
<p>is an exact synonym of:</p>
<div data-snippet-clipboard-copy-content="# TOML

[homepage]
page_header = &#34;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&#34;
page_footer = &#34;Orci varius natoque penatibus et magnis dis parturient montes.&#34;"><pre><code># TOML

[homepage]
page_header = &#34;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&#34;
page_footer = &#34;Orci varius natoque penatibus et magnis dis parturient montes.&#34;
</code></pre></div>
<p>Besides the visual inconvenience of presenting entire sections like keys, not much would be wrong with this feature, not even the redundancy, had the feature not come with an ugly rule attached: inline tables must remain inline.</p>
<p>Such a coercion would become tolerable after being reminded that in that language a new line is supposed to end a node, if only there had not been an exception that makes it intolerable: arrays, on the contrary, can span multiple lines.</p>
<p>Thus, you can write,</p>
<div data-snippet-clipboard-copy-content="# TOML

homepage = [
	&#34;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&#34;,
	&#34;Orci varius natoque penatibus et magnis dis parturient montes.&#34;
]"><pre><code># TOML

homepage = [
	&#34;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&#34;,
	&#34;Orci varius natoque penatibus et magnis dis parturient montes.&#34;
]
</code></pre></div>
<p>but you cannot write</p>
<div data-snippet-clipboard-copy-content="# Invalid TOML example

homepage = {
	page_header = &#34;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&#34;,
	page_footer = &#34;Orci varius natoque penatibus et magnis dis parturient montes.&#34;
}"><pre><code># Invalid TOML example

homepage = {
	page_header = &#34;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&#34;,
	page_footer = &#34;Orci varius natoque penatibus et magnis dis parturient montes.&#34;
}
</code></pre></div>
<p>What makes things worse is the fact that this prohibition exists only for the sake of not having two ways of declaring tables that are both multi-line. It is “a moral prohibition”, not dictated by any practical reasons. In short, it exists only for telling you how to behave.</p>
<p>TOML&#39;s designers insist saying that allowing multi-line tables declared in this way would break one of TOML&#39;s pillars, which is precisely that of terminating a node when a (non-escaped) new line is found. But that is one of INI&#39;s pillars, not TOML&#39;s: TOML had already betrayed this principle after establishing its array syntax. Looking at the asymmetry above from a different perspective, one could indeed say that the original mistake lies with arrays, not with inline tables (but however one puts it, a mistake lies somewhere).</p>
<p>It is possible to argue further that inline tables bring TOML&#39;s syntax closer to JSON. That alone is a good reason to be happy that inline tables are alien in INI files.</p>
<h2 id="user-content-14-incompatibility"><a href="#14-incompatibility">14. Incompatibility<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>By design TOML is explicitly incompatible with about fourty years of configuration files.</p>
<h2 id="user-content-15-immediacy"><a href="#15-immediacy">15. Immediacy<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>A configuration file is meant to be edited by a human – possibly someone who has only <strong>Microsoft Notepad</strong> as text editor and has never heard of TOML or INI before – and editing it should feel like a natural and welcomed thing to do, not like hacking a program source code, especially if this does not give any expressive advantage.</p>
<p>If a person who has never heard of TOML sees the following configuration file,</p>
<div data-snippet-clipboard-copy-content="# TOML

[&#34;bank&#34;]
&#34;ip&#34; = &#34;192.168.1.1&#34;
&#34;square root&#34; = 15000

[&#34;client&#34;]
&#34;hello world&#34; = [&#34;sunny&#34;]
&#34;foo&#34; = &#34;9234&#34;"><pre><code># TOML

[&#34;bank&#34;]
&#34;ip&#34; = &#34;192.168.1.1&#34;
&#34;square root&#34; = 15000

[&#34;client&#34;]
&#34;hello world&#34; = [&#34;sunny&#34;]
&#34;foo&#34; = &#34;9234&#34;
</code></pre></div>
<p>how is the person supposed to know that <code>&#34;ip&#34;</code> can be written also without quotes, but that is not the case of <code>&#34;square root&#34;</code>, as this contains spaces and keys containing spaces must be always quoted? or that the string <code>[&#34;sunny&#34;]</code> is not a reference to a section name but is an array instead? or what data types a particular array can contain?</p>
<p>INI, on the other hand, encourages human-friendly comments for explaining what is not immediately visible.</p>
<div data-snippet-clipboard-copy-content="# INI

[bank]
ip = 192.168.1.1
square root = 15000

[client]
hello world = sunny  # it is possible to write a comma-separated list here
foo = 9234"><pre><code># INI

[bank]
ip = 192.168.1.1
square root = 15000

[client]
hello world = sunny  # it is possible to write a comma-separated list here
foo = 9234
</code></pre></div>
<p>You can write comments in TOML as well, of course. But the risk is that they end up being lists of things to avoid that have nothing to do with the application you are configuring, rather than suggestions of what is possible to do.</p>
<div data-snippet-clipboard-copy-content="# TOML

[&#34;bank&#34;]
&#34;ip&#34; = &#34;192.168.1.1&#34;    # you can remove the quotes from `&#34;ip&#34;` if you want
&#34;square root&#34; = 15000   # do not remove the quotes from `&#34;square root&#34;`, TOML forbids it

[&#34;client&#34;]
&#34;hello world&#34; = [&#34;sunny&#34;]   # `[&#34;sunny&#34;]` is not a section name
&#34;foo&#34; = &#34;9234&#34;  # do not remove the quotes from `&#34;9234&#34;`, it is not a number (I know...)"><pre><code># TOML

[&#34;bank&#34;]
&#34;ip&#34; = &#34;192.168.1.1&#34;    # you can remove the quotes from `&#34;ip&#34;` if you want
&#34;square root&#34; = 15000   # do not remove the quotes from `&#34;square root&#34;`, TOML forbids it

[&#34;client&#34;]
&#34;hello world&#34; = [&#34;sunny&#34;]   # `[&#34;sunny&#34;]` is not a section name
&#34;foo&#34; = &#34;9234&#34;  # do not remove the quotes from `&#34;9234&#34;`, it is not a number (I know...)
</code></pre></div>
<h2 id="user-content-16-genesis"><a href="#16-genesis">16. Genesis<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>Configuration files are born out of necessity, and different applications can have different requirements. There are cases where a configuration file differs substantially from the INI format. It is not rare in these situations that developers have ended up abandoning a widespread and solid configuration format such as INI only after realizing that they had no other choice and not without pain.</p>
<p>In this respect, the way <strong>libconfini</strong> was born is paradigmatic. It was born for an application – an editor – and that application had a very peculiar task: read different types of INI files written in the real world for the applications typically installed on a <strong>GNU/Linux</strong> distribution. What a better scenario for creating a parser?</p>
<p>The genesis of TOML instead is quite different. Someone without a parser <a href="https://github.com/toml-lang/toml/issues/411#issuecomment-219203431">decided that unquoted strings in INI files <em>are ugly</em> and forbad them</a>. A lot of rules have then been added afterwards on paper, without really thinking of any real case usage and only keeping JSON as a reference point.</p>
<p>In the beginning it was still only a specification. Many people, enthusiastic finally to read <em>a specification of something somewhere</em>, started to create their own parser for the newborn language. And that was the moment when problems began to appear.</p>
<p>When you write a parser you might indeed begin to notice contradictions in an apparently unflawed rule, your code might start to become unnecessarily complex because of absurd edge cases, and you might realize that the language you are trying to parse is not that well-designed after all.</p>
<p>And even if you do survive the process of writing a parser that is fully compliant with TOML (<a href="https://github.com/avakar/pytoml/issues/15#issuecomment-217739462">some people don&#39;t</a>), you still have done only half of the job, that of writing a parser, without really thinking of any real case usage. It is still possible that you have completely wasted your time after all.</p>
<p>There are of course cases where TOML works just fine, and these are the cases where JSON would also work fine (although one has always to tolerate TOML&#39;s idea to introduce a syntax for dates). But where JSON works fine, also other JSON dialects more human-friendly than TOML do.</p>
<h2 id="user-content-17-against-postels-law-by-design"><a href="#17-against-postels-law-by-design">17. Against Postel&#39;s law by design<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p><a href="https://en.wikipedia.org/wiki/Robustness_principle" rel="nofollow">Postel&#39;s law</a> is a good indicator of how robust a language is: the more a language is able to make sense of different types of input, the more robust the language.</p>
<p>In front of a heterogeneous landscape like that of configuration files, a parser that applies Postel&#39;s law will try to make sense of the largest possible set of habits and explore all possible solutions to avoid that errors be generated merely because of diversity.</p>
<p>TOML is a good example of a language designed against this principle. <em>The language&#39;s founding element was that of generating errors</em> when quotes were missing, and subsequent rules seem to have <em>in generating errors their only reason</em> (think of the requirement of using quotes for key names containing spaces or unicode characters, which has no justification whatsoever – if it is for aesthetical reasons, think that if you were a Chinese speaker you would rather be tempted to use quotes for the Latin characters and leave the Chinese ideograms out of quotes instead).</p>
<p>One would think that a language with such tendencies will always have only one way to express the same thing, at least. And instead no: inline tables were introduced as a duplicate of standard tables, despite being less readable and completely alien in the common practice – something vaguely similar were <a href="http://hyperrealm.github.io/libconfig/" rel="nofollow"><strong>libconfig</strong></a>&#39;s sections, but these spanned multiple lines and constituted the only way to declare sections in that language.</p>
<p>At the end of the day TOML&#39;s main goal seems to be that of generating errors. The opposite approach, instead, would be that of taking advantage of diversity and regard it is as a strength.</p>
<h2 id="user-content-18-performance"><a href="#18-performance">18. Performance<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>It is not so obvious to talk about “TOML&#39;s performance”: TOML is a language, not a particular parser. It is possible however to predict that any TOML-compliant parser will be on average <em>much slower</em> than an INI parser.</p>
<p>This entire section is being created while a TOML parser written in C (<a href="https://github.com/cktan/tomlc99"><strong>tomlc99</strong></a>) tries to parse a 50 MiB file that <strong>libconfini</strong> usually parses in half a second – and <strong>libconfini</strong>&#39;s primary goal is not speed (yes, we gave the TOML parser an INI file to parse).</p>
<p>This is not a critique to the particular parser chosen – we can assume that <strong>tomlc99</strong> is doing its best in its hard task. The reason why a TOML parser will always be slow is the error checking fury required by the language. Where most INI parsers&#39; approach will be that of “don&#39;t throw an error unless you really cannot make any sense of what is written in a configuration file – the application will do the rest and will do it better”, the approach of a TOML-compliant parser will be that of searching for errors even when both the application and the human would have already understood a content.</p>
<p>After 13 minutes and 20 seconds our TOML parser has finally parsed…</p>
<div data-snippet-clipboard-copy-content="54691749 bytes parsed in 800.849218 seconds.
Number of bytes parsed per second: 68292.192551

ERROR: cannot parse - line 1: extra chars after value"><pre><code>54691749 bytes parsed in 800.849218 seconds.
Number of bytes parsed per second: 68292.192551

ERROR: cannot parse - line 1: extra chars after value
</code></pre></div>
<p>Of course. Someone forgot to put quotes around the first value.</p>
<h2 id="user-content-19-human-friendly-vs-human-readable"><a href="#19-human-friendly-vs-human-readable">19. Human-friendly vs. human-readable<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>“Human-friendly” and “human-readable” might sound as synonyms, but often they are not. Some texts can be very easy to read but hard to edit.</p>
<p>An inscription on the front of the Pantheon in Rome says “Marcus Agrippa, son of Lucius, made this building when consul for the third time”. This is a very human-readable text if you know a bit of Latin. But in order to edit it you would need a ladder, a chisel and the wish to ruin a millenary monument – please do not try to do it.</p>
<p>An emblematic example of this in file formats is JSON. Due to curly brackets, a systematic indentation and a strict syntax it is probably one of the most human-readable serialization formats. But exactly because of the same reasons it is not the most human-friendly one.</p>
<p>Similarly, if used with a syntax highlighter, the human-readability of TOML is comparable to that of INI. Its human-friendliness, instead, lies a few steps below.</p>
<h2 id="user-content-20-aesthetics"><a href="#20-aesthetics">20. Aesthetics<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>Appearance has its importance too. TOML&#39;s specification comes with <a href="https://github.com/toml-lang/toml/blob/8296d6ba97aaaf3151a32a22ed0513301ac650bf/README.md#Example">the following example</a> for illustrating the language:</p>
<div data-snippet-clipboard-copy-content="# This is a TOML document.

title = &#34;TOML Example&#34;

[owner]
name = &#34;Tom Preston-Werner&#34;
dob = 1979-05-27T07:32:00-08:00 # First class dates

[database]
server = &#34;192.168.1.1&#34;
ports = [ 8000, 8001, 8002 ]
connection_max = 5000
enabled = true

[servers]

  # Indentation (tabs and/or spaces) is allowed but not required
  [servers.alpha]
  ip = &#34;10.0.0.1&#34;
  dc = &#34;eqdc10&#34;

  [servers.beta]
  ip = &#34;10.0.0.2&#34;
  dc = &#34;eqdc10&#34;

[clients]
data = [ [&#34;gamma&#34;, &#34;delta&#34;], [1, 2] ]

# Line breaks are OK when inside arrays
hosts = [
  &#34;alpha&#34;,
  &#34;omega&#34;
]"><pre><code># This is a TOML document.

title = &#34;TOML Example&#34;

[owner]
name = &#34;Tom Preston-Werner&#34;
dob = 1979-05-27T07:32:00-08:00 # First class dates

[database]
server = &#34;192.168.1.1&#34;
ports = [ 8000, 8001, 8002 ]
connection_max = 5000
enabled = true

[servers]

  # Indentation (tabs and/or spaces) is allowed but not required
  [servers.alpha]
  ip = &#34;10.0.0.1&#34;
  dc = &#34;eqdc10&#34;

  [servers.beta]
  ip = &#34;10.0.0.2&#34;
  dc = &#34;eqdc10&#34;

[clients]
data = [ [&#34;gamma&#34;, &#34;delta&#34;], [1, 2] ]

# Line breaks are OK when inside arrays
hosts = [
  &#34;alpha&#34;,
  &#34;omega&#34;
]
</code></pre></div>
<p>There are many ways of expressing exactly the same content using <strong>libconfini</strong>. The following is probably the most obvious one:</p>
<div data-snippet-clipboard-copy-content="# examples/ini_files/toml-like.conf

# Relax, this is an INI document.


title = INI Example

[owner]
name = madmurphy
dob = &#34;Sun, 27 May 1979 15:32:00 GMT&#34;

[database]
server = 192.168.1.1    # you can parse an IP address as an array too! :-)
ports = 8000, 8001, 8002
connection_max = 5000
enabled

  # Indentation (tabs and/or spaces) is allowed but not required
  [servers.alpha]
  ip = 10.0.0.1
  dc = eqdc10

  [servers.beta]
  ip = 10.0.0.2
  dc = eqdc10

[clients]
data = gamma : delta, 1 : 2

hosts = alpha, omega"><pre><code># examples/ini_files/toml-like.conf

# Relax, this is an INI document.


title = INI Example

[owner]
name = madmurphy
dob = &#34;Sun, 27 May 1979 15:32:00 GMT&#34;

[database]
server = 192.168.1.1    # you can parse an IP address as an array too! :-)
ports = 8000, 8001, 8002
connection_max = 5000
enabled

  # Indentation (tabs and/or spaces) is allowed but not required
  [servers.alpha]
  ip = 10.0.0.1
  dc = eqdc10

  [servers.beta]
  ip = 10.0.0.2
  dc = eqdc10

[clients]
data = gamma : delta, 1 : 2

hosts = alpha, omega
</code></pre></div>
<p>For a parsing example, please have a look at <code>examples/miscellanea/toml-like.c</code>.</p>
<h2 id="user-content-further-readings"><a href="#further-readings">Further readings<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<ul>
<li><a href="https://toml.io/en/v1.0.0" rel="nofollow">TOML Specification</a></li>
<li><a href="https://hitchdev.com/strictyaml/why-not/toml/" rel="nofollow">What is wrong with TOML?</a></li>
</ul>
<h2 id="user-content-state-of-this-document"><a href="#state-of-this-document">State of this document<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></h2>
<p>Last revision: October 2021</p>

              </div></div>
  </body>
</html>
