<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ariadne.space/2021/12/29/glibc-is-still-not-y2038-compliant-by-default/">Original</a>
    <h1>Glibc is still not Y2038 compliant by default</h1>
    
    <div id="readability-page-1" class="page"><div id="site-content" role="main">

	
<article id="post-387">

	
<!-- .entry-header -->

	<div>

		<div>

			
<p>Most of my readers are probably aware of the Y2038 issue by now.  If not, it refers to 3:14:07 UTC on January 19, 2038, when 32-bit <code>time_t</code> will overflow.  The Linux kernel has internally switched to 64-bit timekeeping several years ago, and Alpine made the jump to 64-bit <code>time_t</code> with the release of Alpine 3.13.</p>



<p>In the GNU/Linux world, the GNU libc started to support 64-bit <code>time_t</code> in version 2.34.  Unfortunately for the rest of us, the approach they have used to support 64-bit <code>time_t</code> is technically deficient, following in the footsteps of other never-fully-completed transitions.</p>



<h2>the right way to transition to new ABIs</h2>



<p>In the musl C library, which Alpine uses, and in many other UNIX C library implementations, <code>time_t</code> is always 64-bit in new code, and compatibility stubs are provided for code requiring the old 32-bit functions.  As code is rebuilt over time, it automatically becomes Y2038-compliant without any effort.</p>



<p>Microsoft went another step further in <code>msvcrt</code>: you get 64-bit <code>time_t</code> by default, but if you compile with the <code>_USE_32BIT_TIME_T</code> macro defined, you can still access the old 32-bit functions.</p>



<p>It should be noted that both approaches described above introduce zero friction to get the right thing.</p>



<h2>how GNU handles transitions in GNU libc</h2>



<p>The approach the GNU project have taken for transitioning to new ABIs is the exact opposite: you must explicitly ask for the new functionality, or you will never get it.  This approach leaves open the possibility for changing the defaults in the future, but they have never ever done this so far.</p>



<p>This can be observed with the large file support extension, which is needed to handle files larger than 2GiB, you must always build your code with <code>-D_FILE_OFFSET_BITS=64</code>.  And, similarly, if you’re on a 32-bit system, and you do not build your app with <code>-D_TIME_BITS=64</code>, it will not be built using an ABI that is Y2038-compliant.</p>



<p>This is the worst possible way to do this.  Consider libraries: what if a dependency is built with <code>-D_TIME_BITS=64</code>, and another dependency is built without, and they need to exchange <code>struct timespec</code> or similar with each other?  Well, in this case, your program will likely crash or have weird behavior, as you’re not consistently using the same <code>struct timespec</code> in the program you’ve compiled.</p>



<p>Fortunately, if you are targeting 32-bit systems, and you would like to manipulate files larger than 2GiB or have confidence that your code will continue to work in the year 2038, there are Linux distributions that are built on musl, like Alpine, which will allow you to not have to deal with the idiosyncrasies of the GNU libc.</p>


		</div><!-- .entry-content -->

	</div><!-- .post-inner -->

	<!-- .section-inner -->

	
	<!-- .pagination-single -->

	
		<!-- .comments-wrapper -->

		
</article><!-- .post -->

</div></div>
  </body>
</html>
