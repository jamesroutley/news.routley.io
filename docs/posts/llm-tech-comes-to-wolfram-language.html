<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://writings.stephenwolfram.com/2023/06/llm-tech-and-a-lot-more-version-13-3-of-wolfram-language-and-mathematica/">Original</a>
    <h1>LLM tech comes to Wolfram Language</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p><img title="LLM Tech and a Lot More: Version 13.3 of Wolfram Language and Mathematica" src="https://content.wolfram.com/uploads/sites/43/2023/06/13-3-hero.png" alt="LLM Tech and a Lot More: Version 13.3 of Wolfram Language and Mathematica" width="619" height=" "/></p>
<h2 id="the-leading-edge-of-2023-technology-...-and-beyond">The Leading Edge of 2023 Technology … and Beyond</h2>
<p>Today we’re launching Version 13.3 of <a href="https://www.wolfram.com/language/">Wolfram Language</a> and <a href="https://www.wolfram.com/mathematica/">Mathematica</a>—both available immediately on desktop and cloud. It’s only been 196 days since we released <a href="https://reference.wolfram.com/language/guide/SummaryOfNewFeaturesIn132">Version 13.2</a>, but there’s a lot that’s new, not least a whole subsystem around LLMs. </p>
<p><a href="https://www.youtube.com/watch?v=HxWg8exJxNY">Last Friday (June 23) we celebrated 35 years</a> since <a href="https://reference.wolfram.com/legacy/v1/">Version 1.0</a> of Mathematica (and what’s now Wolfram Language). And to me it’s incredible how far we’ve come in these 35 years—yet how consistent we’ve been in our mission and goals, and how well we’ve been able to just keep building on the foundations we created all those years ago.<span id="more-51812"></span></p>
<p>And when it comes to what’s now Wolfram Language, there’s a wonderful timelessness to it. We’ve worked very hard to make its design as clean and coherent as possible—and to make it a timeless way to elegantly represent computation and everything that can be described through it. </p>
<p>Last Friday I fired up Version 1 on an old Mac SE/30 computer (with 2.5 megabytes of memory), and it was a thrill see functions like <tt><a href="http://reference.wolfram.com/language/ref/Plot.html">Plot</a></tt> and <tt><a href="http://reference.wolfram.com/language/ref/NestList.html">NestList</a></tt> work just as they would today—albeit a lot slower. And it was wonderful to be able to take (on a floppy disk) the notebook I created with Version 1 and have it immediately come to life on a modern computer. </p>
<p>But even as we’ve maintained compatibility over all these years, the scope of our system has grown out of all recognition—with everything in Version 1 now occupying but a small sliver of the whole range of functionality of the modern Wolfram Language:</p>
<p><img src="https://content.wolfram.com/uploads/sites/43/2023/06/updated-88-2023.png" alt="Versions 1.0 and 13.3 of Wolfram Language compared" title="Versions 1.0 and 13.3 of Wolfram Language compared" width="620" height=""/></p>
<p>So much about Mathematica was ahead of its time in 1988, and perhaps even more about Mathematica and the Wolfram Language is ahead of its time today, 35 years later. From the whole idea of symbolic programming, to the concept of notebooks, the universal applicability of symbolic expressions, the notion of computational knowledge, and concepts like instant APIs and so much more, we’ve been energetically continuing to push the frontier over all these years.</p>
<p>Our long-term objective has been to build a full-scale computational language that can represent everything computationally, in a way that’s effective for both computers and humans. And now—in 2023—there’s a new significance to this. Because with the advent of LLMs our language has become a unique bridge between humans, AIs and computation. </p>
<p>The attributes that make Wolfram Language easy for humans to write, yet rich in expressive power, also make it ideal for LLMs to write. And—unlike traditional programming languages— Wolfram Language is intended not only for humans to write, but also to read and think in. So it becomes the medium through which humans can confirm or correct what LLMs do, to deliver computational language code that can be confidently assembled into a larger system.</p>
<p>The Wolfram Language wasn’t originally designed with the recent success of LLMs in mind. But I think it’s a tribute to the strength of its design that it now fits so well with LLMs—with so much synergy. The Wolfram Language is important to LLMs—in providing a way to access computation and computational knowledge from within the LLM. But LLMs are also important to Wolfram Language—in providing a rich linguistic interface to the language. </p>
<p>We’ve always built—and deployed—Wolfram Language so it can be accessible to as many people as possible. But the advent of LLMs—and <a href="https://writings.stephenwolfram.com/2023/06/introducing-chat-notebooks-integrating-llms-into-the-notebook-paradigm/">our new Chat Notebooks</a>—opens up Wolfram Language to vastly more people. <a href="https://www.wolframalpha.com/">Wolfram|Alpha</a> lets anyone use natural language—without prior knowledge—to get questions answered. Now with LLMs it’s possible to use natural language to start defining potential elaborate computations. </p>
<p>As soon as you’ve formulated your thoughts in computational terms, you can immediately “explain them to an LLM”, and have it produce precise Wolfram Language code. Often when you look at that code you’ll realize you didn’t explain yourself quite right, and either the LLM or you can tighten up your code. But anyone—without any prior knowledge—can now get started producing serious Wolfram Language code. And that’s very important in seeing Wolfram Language realize its potential to drive “computational X” for the widest possible range of <nobr>fields X.</nobr></p>
<p>But while LLMs are “the biggest single story” in Version 13.3, there’s a lot else in Version 13.3 too—delivering the latest from our long-term research and development pipeline. So, yes, in Version 13.3 there’s new functionality not only in LLMs but also in many “classic” areas—as well as in new areas having nothing to do with LLMs.</p>
<p>Across the 35 years since Version 1 we’ve been able to continue accelerating our research and development process, year by year building on the functionality and automation we’ve created. And we’ve also continually honed our actual process of research and development—for the past 5 years sharing our design meetings on <a href="https://livestreams.stephenwolfram.com/">open livestreams</a>. </p>
<p>Version 13.3 is—from its name—an “incremental release”. But—particularly with its new LLM functionality—it continues our tradition of delivering a long list of important advances and updates, even in incremental releases.</p>
<h2 id="llm-tech-comes-to-wolfram-language">LLM Tech Comes to Wolfram Language</h2>
<p>LLMs make possible many important new things in the Wolfram Language. And since I’ve been discussing these in <a href="https://writings.internal.stephenwolfram.com/category/wolfram-language/">a series of recent posts</a>, I’ll just give only a fairly short summary here. More details are in the other posts, both ones that have appeared, and ones that will appear soon.</p>
<div id="gpt-stripe">
<p>To ensure you have the latest Chat Notebook functionality installed and available, use: </p>
<div data-c2c-file="https://content.wolfram.com/uploads/sites/43/2023/06/sw062923sec2pacletimg2_copy.txt" data-c2c-type="text/html"><tt>PacletInstall[&#34;Wolfram/Chatbook&#34; <img title="" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062923sec2rightarrowimg1.png" alt="" width="16" height=""/> &#34;1.0.0&#34;, UpdatePacletSites <img title="" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062923sec2rightarrowimg1.png" alt="" width="16" height=""/> True]</tt><p>.</p></div>
</div>
<p>The most immediately visible LLM tech in Version 13.3 is Chat Notebooks. Go to <nobr><tt>File</tt> &gt; <tt>New</tt> &gt; <tt>Chat-Enabled Notebook</tt></nobr> and you’ll get a Chat Notebook that supports “chat cells” that let you “talk to” an LLM. Press <span><kbd>&#39;</kbd></span> (quote) to get a new chat cell:</p>
<p> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062723sec2img1-1.png" alt="Plot two sine curves" title="Plot two sine curves" width="620" height="580"/></p>
<p>You might not like some details of what got done (do you really want those boldface labels?) but I consider this pretty impressive. And it’s a great example of using an LLM as a “linguistic interface” with common sense, that can generate precise computational language, which can then be run to get a result.</p>
<p>This is all very new technology, so we don’t yet know what patterns of usage will work best. But I think it’s going to go like this. First, you have to think computationally about whatever you’re trying to do. Then you tell it to the LLM, and it’ll produce Wolfram Language code that represents what it thinks you want to do. You might just run that code (or the Chat Notebook will do it for you), and see if it produces what you want. Or you might read the code, and see if it’s what you want. But either way, you’ll be using computational language—Wolfram Language—as the medium to formalize and express what you’re trying to do.</p>
<p>When you’re doing something you’re familiar with, it’ll almost always be faster and better to think directly in Wolfram Language, and just enter the computational language code you want. But if you’re exploring something new, or just getting started on something, the LLM is likely to be a really valuable way to “get you to first code”, and to start the process of crispening up what you want in computational terms.</p>
<p>If the LLM doesn’t do exactly what you want, then you can tell it what it did wrong, and it’ll try to correct it—though sometimes you can end up doing a lot of explaining and having quite a long dialog (and, yes, it’s often vastly easier just to type Wolfram Language code yourself):</p>
<p>  <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062723sec2img2-1.png" alt="Draw red and green semicircles" title="Draw red and green semicircles" width="620" height="957"/> </p>
<p> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062723sec2img3-1.png" alt="Redraw red and green semicircles" title="Redraw red and green semicircles" width="620" height="1035"/></p>
<p>Sometimes the LLM will notice for itself that something went wrong, and try changing its code, and rerunning it:</p>
<p>  <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062723sec2img4.png" alt="Make table of primes" title="Make table of primes" width="620" height="684"/> </p>
<p>And even if it didn’t write a piece of code itself, it’s pretty good at piping up to explain what’s going on when an error is generated: </p>
<p> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062723sec2img5-1.png" alt="Error report" title="Error report" width="620" height="291"/></p>
<p>And actually it’s got a big advantage here, because “under the hood” it can look at lots of details (like stack trace, error documentation, etc.) that humans usually don’t bother with.</p>
<p>To support all this interaction with LLMs, there’s all kinds of new structure in the Wolfram Language. In Chat Notebooks there are chat cells, and there are chatblocks (indicated by gray bars, and generating with <span><kbd>~</kbd></span>) that delimit the range of chat cells that will be fed to the LLM when you press <span><kbd>shift</kbd><kbd>enter</kbd></span> on a new chat cell. And, by the way, the whole mechanism of cells, cell groups, etc. that we invented 36 years ago now turns out to be extremely powerful as a foundation for Chat Notebooks.</p>
<p>One can think of the LLM as a kind of “alternate evaluator” in the notebook. And there are various ways to set up and control it. The most immediate is in the menu associated with every chat cell and every chatblock (and also available in the notebook toolbar):</p>
<p> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062723sec2img6-1.png" alt="Chat cell and chatblock menu" title="Chat cell and chatblock menu" width="373" height="359"/> </p>
<p>The first items here let you define the “persona” for the LLM. Is it going to act as a Code Assistant that writes code and comments on it? Or is it just going to be a Code Writer, that writes code without being wordy about it? Then there are some “fun” personas—like <span>Wolfie</span> and <span>Birdnardo</span>—that respond “with an attitude”. The <tt>Advanced Settings</tt> let you do things like set the underlying LLM model you want to use—and also what tools (like Wolfram Language code evaluation) you want to connect to it.</p>
<p>Ultimately personas are mostly just special prompts for the LLM (together, sometimes with tools, etc.) And one of the new things we’ve recently launched to support LLMs is the <a href="https://resources.wolframcloud.com/PromptRepository/">Wolfram Prompt Repository</a>:</p>
<p> <a href="https://resources.wolframcloud.com/PromptRepository/"><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062723sec2img7-2.png" alt="Wolfram Prompt Repository" title="Wolfram Prompt Repository" width="620" height=""/></a></p>
<p>The Prompt Repository contains several kinds of prompts. The first are personas, which are used to “style” and otherwise inform chat interactions. But then there are two other types of prompts: function prompts, and modifier prompts.</p>
<p>Function prompts are for getting the LLM to do something specific, like summarize a piece of text, or suggest a joke (it’s not terribly good at that). Modifier prompts are for determining how the LLM should modify its output, for example translating into a different human language, or keeping it to a certain length.</p>
<p>You can pull in function prompts from the repository into a Chat Notebook by using <span><kbd>!</kbd></span>, and modifier prompts using <span><kbd>#</kbd></span>. There’s also a <span><kbd>^</kbd></span> notation for saying that you want the “input” to the function prompt to be the cell above:</p>
<p>  <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062723sec2img8-1.png" alt="ScientificJargonize" title="ScientificJargonize" width="619" height="117"/></p>
<p>This is how you can access LLM functionality from within a Chat Notebook. But there’s also a whole symbolic programmatic way to access LLMs that we’ve added to the Wolfram Language. Central to this is <tt><a href="http://reference.wolfram.com/language/ref/LLMFunction.html">LLMFunction</a></tt>, which acts very much like a Wolfram Language pure function, except that it gets “evaluated” not by the Wolfram Language kernel, but by an LLM:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062723sec2img9-1.png" alt="" title="" width="599" height="45"/> </p>
</div>
<p>You can access a function prompt from the Prompt Repository using <tt><a href="http://reference.wolfram.com/language/ref/LLMResourceFunction.html">LLMResourceFunction</a></tt>:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062723sec2img10-1.png" alt="" title="" width="485" height="54"/> </p>
</div>
<p>There’s also a symbolic representation for chats. Here’s an empty chat:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062723sec2img11-1.png" alt="" title="" width="185" height="76"/> </p>
</div>
<p>And here now we “say something”, and the LLM responds:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062723sec2img12-2.png" alt="" title="" width="600" height=""/> </p>
</div>
<p>There’s lots of depth to both <a href="https://writings.internal.stephenwolfram.com/2023/06/introducing-chat-notebooks-integrating-llms-into-the-notebook-paradigm/">Chat Notebooks</a> and <a href="https://writings.internal.stephenwolfram.com/2023/05/the-new-world-of-llm-functions-integrating-llm-technology-into-the-wolfram-language/">LLM functions</a>—<a href="https://writings.internal.stephenwolfram.com/category/wolfram-language/">as I’ve described elsewhere</a>. There’s <tt><a href="http://reference.wolfram.com/language/ref/LLMExampleFunction.html">LLMExampleFunction</a></tt> for getting an LLM to follow examples you give. There’s <tt><a href="http://reference.wolfram.com/language/ref/LLMTool.html">LLMTool</a></tt> for giving an LLM a way to call functions in the Wolfram Language as “tools”. And there’s <tt><a href="http://reference.wolfram.com/language/ref/LLMSynthesize.html">LLMSynthesize</a></tt> which provides raw access to the LLM as its text completion and other capabilities. (And controlling all of this is <tt><a href="http://reference.wolfram.com/language/ref/$LLMEvaluator.html">$LLMEvaluator</a></tt> which defines the default LLM configuration to use, as specified by an <tt><a href="http://reference.wolfram.com/language/ref/LLMConfiguration.html">LLMConfiguration</a></tt> object.) </p>
<p>I consider it rather impressive that we’ve been able to get to the level of support for LLMs that we have in Version 13.3 in less than six months (along with building things like the <a href="https://writings.stephenwolfram.com/2023/03/chatgpt-gets-its-wolfram-superpowers/">Wolfram Plugin for ChatGPT</a>, and the <a href="https://writings.stephenwolfram.com/2023/04/instant-plugins-for-chatgpt-introducing-the-wolfram-chatgpt-plugin-kit/">Wolfram ChatGPT Plugin Kit</a>). But there’s going to be more to come, with LLM functionality increasingly integrated into Wolfram Language and Notebooks, and, yes, Wolfram Language functionality increasingly integrated as a tool into LLMs.</p>
<h2 id="line,-surface-and-contour-integration">Line, Surface and Contour Integration</h2>
<p>“Find the integral of the function ___” is a typical core thing one wants to do in calculus. And in <a href="https://www.wolfram.com/mathematica/">Mathematica</a> and the <a href="https://www.wolfram.com/language/">Wolfram Language</a> that’s achieved with <tt><a href="http://reference.wolfram.com/language/ref/Integrate.html">Integrate</a></tt>. But particularly in applications of calculus, it’s common to want to ask slightly more elaborate questions, like “What’s the integral of ___ over the region ___?”, or “What’s the integral of ___ along the line ___?”</p>
<p>Almost a decade ago (in <a href="https://www.wolfram.com/mathematica/new-in-10/">Version 10</a>) we introduced a way to specify integration over regions—just by giving the region “geometrically” as the domain of the integral:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img1.png" alt="" title="" width="338" height="71"/> </p>
</div>
<p>It had always been possible to write out such an integral in “standard <tt><a href="http://reference.wolfram.com/language/ref/Integrate.html">Integrate</a></tt>” form</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img2.png" alt="" title="" width="642" height="71"/> </p>
</div>
<p>but the region specification is much more convenient—as well as being much more efficient to process.</p>
<p>Finding an integral along a line is also something that can ultimately be done in “standard <tt><a href="http://reference.wolfram.com/language/ref/Integrate.html">Integrate</a></tt>” form. And if you have an explicit (parametric) formula for the line this is typically fairly straightforward. But if the line is specified in a geometrical way then there’s real work to do to even set up the problem in “standard <a href="http://reference.wolfram.com/language/ref/Integrate.html"><tt>Integrate</tt></a>” form. So in Version 13.3 we’re introducing the function <a href="https://reference.wolfram.com/language/ref/LineIntegrate.html"><tt>LineIntegrate</tt></a> to automate this.</p>
<p><a href="https://reference.wolfram.com/language/ref/LineIntegrate.html"><tt>LineIntegrate</tt></a> can deal with integrating both scalar and vector functions over lines. Here’s an example where the line is just a straight line:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img3.png" alt="" title="" width="539" height="75"/> </p>
</div>
<p>But <a href="https://reference.wolfram.com/language/ref/LineIntegrate.html"><tt>LineIntegrate</tt></a> also works for lines that aren’t straight, like this parametrically specified one:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img4.png" alt="" title="" width="511" height="90"/> </p>
</div>
<p>To compute the integral also requires finding the tangent vector at every point on the curve—but <a href="https://reference.wolfram.com/language/ref/LineIntegrate.html"><tt>LineIntegrate</tt></a> automatically does that:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062623sec3Ximg2.png" alt="" title="" width="503" height="73"/> </p>
</div>
<p>Line integrals are common in applications of calculus to physics. But perhaps even more common are surface integrals, representing for example total flux through a surface. And in Version 13.3 we’re introducing <a href="https://reference.wolfram.com/language/ref/SurfaceIntegrate.html"><tt>SurfaceIntegrate</tt></a>. Here’s a fairly straightforward integral of flux that goes radially outward through a sphere:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img7.png" alt="" title="" width="401" height="43"/> </p>
</div>
<p>Here’s a more complicated case:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img8.png" alt="" title="" width="633" height="91"/> </p>
</div>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img9.png" alt="" title="" width="651" height="90"/> </p>
</div>
<p>And here’s what the actual vector field looks like on the surface of the dodecahedron:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img10.png" alt="" title="" width="641" height="338"/> </p>
</div>
<p><a href="https://reference.wolfram.com/language/ref/LineIntegrate.html"><tt>LineIntegrate</tt></a> and <a href="https://reference.wolfram.com/language/ref/SurfaceIntegrate.html"><tt>SurfaceIntegrate</tt></a> deal with integrating scalar and vector functions in Euclidean space. But in Version 13.3 we’re also handling another kind of integration: contour integration in the complex plane.</p>
<p>We can start with a classic contour integral—illustrating <a href="https://mathworld.wolfram.com/CauchyIntegralFormula.html">Cauchy’s theorem</a>:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img11.png" alt="" title="" width="305" height="43"/> </p>
</div>
<p>Here’s a slightly more elaborate complex function</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img12.png" alt="" title="" width="335" height="263"/> </p>
</div>
<p>and here’s its integral around a circular contour:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img13.png" alt="" title="" width="434" height="71"/> </p>
</div>
<p>Needless to say, this still gives the same result, since the new contour still encloses the same poles: </p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img14.png" alt="" title="" width="577" height="66"/> </p>
</div>
<p>More impressively, here’s the result for an arbitrary radius of contour:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img15.png" alt="" title="" width="677" height="149"/> </p>
</div>
<p>And here’s a plot of the (imaginary part of the) result:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img16.png" alt="" title="" width="250" height="146"/> </p>
</div>
<p>Contours can be of any shape:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img17.png" alt="" title="" width="494" height="114"/> </p>
</div>
<p>The result for the contour integral depends on whether the pole is inside the “Pac-Man”:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062023sec3img18B.png" alt="" title="" width="620" height=""/> </p>
</div>
<h2 id="another-milestone-for-special-functions">Another Milestone for Special Functions</h2>
<p>One can think of special functions as a way of “modularizing” mathematical results. It’s often a challenge to know that something can be expressed in terms of special functions. But once one’s done this, one can immediately apply the independent knowledge that exists about the special functions.</p>
<p>Even in <a href="https://reference.wolfram.com/legacy/v1/">Version 1.0</a> we already supported many special functions. And over the years we’ve added support for many more—to the point where we now cover everything that might reasonably be considered a “classical” special function. But in recent years we’ve also been tackling more general special functions. They’re mathematically more complex, but each one we successfully cover makes a new collection of problems accessible to exact solution and reliable numerical and symbolic computation.</p>
<p>Most of the “classic” special functions—like <a href="https://mathworld.wolfram.com/BesselFunction.html">Bessel functions</a>, <a href="https://mathworld.wolfram.com/LegendreFunctionoftheFirstKind.html">Legendre functions</a>, <a href="https://mathworld.wolfram.com/EllipticIntegral.html">elliptic integrals</a>, etc.—are in the end univariate <a href="https://mathworld.wolfram.com/HypergeometricFunction.html">hypergeometric functions</a>. But one important frontier in “general special functions” are those corresponding to bivariate hypergeometric functions. And already in <a href="https://reference.wolfram.com/legacy/v4/">Version 4.0</a> (1999) we introduced one example of such as a function: <tt><a href="http://reference.wolfram.com/language/ref/AppellF1.html">AppellF1</a></tt>. And, yes, it’s taken a while, but now in Version 13.3 we’ve finally finished doing the math and creating the algorithms to introduce <a href="https://reference.wolfram.com/language/ref/AppellF2.html"><tt>AppellF2</tt></a>, <a href="https://reference.wolfram.com/language/ref/AppellF3.html"><tt>AppellF3</tt></a> and <a href="https://reference.wolfram.com/language/ref/AppellF4.html"><tt>AppellF4</tt></a>.</p>
<p>On the face of it, it’s just another function—with lots of arguments—whose value we can find to any precision:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec4img1.png" alt="" title="" width="380" height="47"/> </p>
</div>
<p>Occasionally it has a closed form:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec4img2.png" alt="" title="" width="392" height="81"/> </p>
</div>
<p>But despite its mathematical sophistication, plots of it tend to look fairly uninspiring:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec4img3.png" alt="" title="" width="457" height="154"/> </p>
</div>
<p>Series expansions begin to show a little more:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec4img4.png" alt="" title="" width="485" height="138"/> </p>
</div>
<p>And ultimately this is a function that solves a pair of PDEs that can be seen as a generalization to two variables of the univariate hypergeometric ODE. So what other generalizations are possible? <a href="https://www.wolframalpha.com/input?i=Paul+Appell">Paul Appell</a> spent many years around the turn of the twentieth century looking—and came up with just four, which as of Version 13.3 now all appear in the Wolfram Language, as <tt><a href="http://reference.wolfram.com/language/ref/AppellF1.html">AppellF1</a></tt>, <a href="https://reference.wolfram.com/language/ref/AppellF2.html"><tt>AppellF2</tt></a>, <a href="https://reference.wolfram.com/language/ref/AppellF3.html"><tt>AppellF3</tt></a> and <a href="https://reference.wolfram.com/language/ref/AppellF4.html"><tt>AppellF4</tt></a>.</p>
<p>To make special functions useful in the Wolfram Language they need to be “knitted” into other capabilities of the language—from numerical evaluation to series expansion, calculus, equation solving, and integral transforms. And in Version 13.3 we’ve passed another special function milestone, around integral transforms. </p>
<p>When I started using special functions in the 1970s the main source of information about them tended to be a small number of handbooks that had been assembled through decades of work. When we began to build Mathematica and what’s now the Wolfram Language, one of our goals was to subsume the information in such handbooks. And over the years that’s exactly what we’ve achieved—for integrals, sums, differential equations, etc. But one of the holdouts has been integral transforms for special functions. And, yes, we’ve covered a great many of these. But there are exotic examples that can often only “coincidentally” be done in closed form—and that in the past have only been found in books of tables.</p>
<p>But now in Version 13.3 we can do cases like: </p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec4img5.png" alt="" title="" width="349" height="121"/> </p>
</div>
<p>And in fact we believe that in Version 13.3 we’ve reached the edge of what’s ever been figured out about <a href="https://mathworld.wolfram.com/LaplaceTransform.html">Laplace transforms</a> for special functions. The most extensive handbook—finally published in 1973—runs to about 400 pages. A few years ago we could do about 55% of the forward Laplace transforms in the book, and 31% of the inverse ones. But now in Version 13.3 we can do 100% of the ones that we can verify as correct (and, yes, there are definitely some mistakes in the book). It’s the end of a long journey, and a satisfying achievement in the quest to make as much mathematical knowledge as possible automatically computable.</p>
<h2 id="finite-fields!">Finite Fields!</h2>
<p>Ever since <a href="https://reference.wolfram.com/legacy/v1/">Version 1.0</a> we’ve been able to do things like factoring polynomials modulo primes. And many packages have been developed that handle specific aspects of finite fields. But in Version 13.3 we now have complete, consistent coverage of all finite fields—and operations with them.</p>
<p>Here’s our symbolic representation of the field of integers modulo 5 (AKA ℤ<sub>5</sub> or GF(5)):</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img2.png" alt="" title="" width="302" height="78"/> </p>
</div>
<p>And here are symbolic representations of the elements of this field—which in this particular case can be rather trivially identified with ordinary integers mod 5:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img3A.png" alt="" title="" width="314" height=""/> </p>
</div>
<p>Arithmetic immediately works on these symbolic elements:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img4.png" alt="" title="" width="162" height="70"/> </p>
</div>
<p>But where things get a bit trickier is when we’re dealing with prime-power fields. We represent the field GF(2<sup>3</sup>) symbolically as:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img6.png" alt="" title="" width="305" height="78"/> </p>
</div>
<p>But now the elements of this field no longer have a direct correspondence with ordinary integers. We can still assign “indices” to them, though (with elements 0 and 1 being the additive and multiplicative identities). So here’s an example of an operation in this field:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img7.png" alt="" title="" width="134" height="59"/> </p>
</div>
<p>But what actually is this result? Well, it’s an element of the finite field—with index 4—represented internally in the form:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img8.png" alt="" title="" width="547" height="78"/> </p>
</div>
<p>The little box opens out to show the symbolic <a href="https://reference.wolfram.com/language/ref/FiniteField.html"><tt>FiniteField</tt></a> construct:</p>
<p> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/f-swoosh-v2.png" alt="FormField construct" title="FormField construct" width="350" height=""/></p>
<p>And we can extract properties of the element, like its index:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img10.png" alt="" title="" width="172" height="55"/> </p>
</div>
<p>So here, for example, are the complete addition and multiplication tables for this field:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img11.png" alt="" title="" width="639" height="201"/> </p>
</div>
<p>For the field GF(7<sup>2</sup>) these look a little more complicated:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img13.png" alt="" title="" width="617" height="260"/> </p>
</div>
<p>There are various number-theoretic-like functions that one can compute for elements of finite fields. Here’s an element of GF(5<sup>10</sup>):</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img15.png" alt="" title="" width="214" height="59"/> </p>
</div>
<p>The multiplicative order of this (i.e. power of it that gives 1) is quite large:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img16.png" alt="" title="" width="269" height="62"/> </p>
</div>
<p>Here’s its minimal polynomial:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img17.png" alt="" title="" width="285" height="66"/> </p>
</div>
<p>But where finite fields really begin to come into their own is when one looks at polynomials over them. Here, for example, is factoring over GF(3<sup>2</sup>):</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img19.png" alt="" title="" width="653" height="76"/> </p>
</div>
<p>Expanding this gives a finite-field-style representation of the original polynomial:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img20.png" alt="" title="" width="193" height="61"/> </p>
</div>
<p>Here’s the result of expanding a power of a polynomial over GF(3<sup>2</sup>):</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec5img22A.png" alt="" title="" width="650" height=""/> </p>
</div>
<h2 id="more,-stronger-computational-geometry">More, Stronger Computational Geometry</h2>
<p>We originally introduced computational geometry in a serious way into the Wolfram Language a decade ago. And ever since then we’ve been building more and more capabilities in computational geometry.</p>
<p>We’ve had <tt><a href="http://reference.wolfram.com/language/ref/RegionDistance.html">RegionDistance</a></tt> for computing the distance from a point to a region for a decade. In Version 13.3 we’ve now extended <tt><a href="http://reference.wolfram.com/language/ref/RegionDistance.html">RegionDistance</a></tt> so it can also compute the shortest distance between two regions:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec6img1.png" alt="" title="" width="477" height="43"/> </p>
</div>
<p>We’ve also introduced <a href="https://reference.wolfram.com/language/ref/RegionFarthestDistance.html"><tt>RegionFarthestDistance</tt></a> which computes the furthest distance between any two points in two given regions:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec6img2.png" alt="" title="" width="535" height="43"/> </p>
</div>
<p>Another new function in Version 13.3 is <a href="https://reference.wolfram.com/language/ref/RegionHausdorffDistance.html"><tt>RegionHausdorffDistance</tt></a> which computes the largest of all shortest distances between points in two regions; in this case it gives a closed form:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec6img3.png" alt="" title="" width="546" height="95"/> </p>
</div>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec6img4.png" alt="" title="" width="92" height="43"/> </p>
</div>
<p>Another pair of new functions in Version 13.3 are <a href="https://reference.wolfram.com/language/ref/InscribedBall.html"><tt>InscribedBall</tt></a> and <a href="https://reference.wolfram.com/language/ref/CircumscribedBall.html"><tt>CircumscribedBall</tt></a>—which give (<em>n</em>-dimensional) spheres that, respectively, just fit inside and outside regions you give:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec6img5.png" alt="" title="" width="651" height="317"/> </p>
</div>
<p>In the past several versions, we’ve added functionality that combines geo computation with computational geometry. Version 13.3 has the beginning of another initiative—introducing abstract spherical geometry:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec6img6.png" alt="" title="" width="477" height="45"/> </p>
</div>
<p>This works for spheres in any number of dimensions:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec6img7.png" alt="" title="" width="474" height="88"/> </p>
</div>
<p>In addition to adding functionality, Version 13.3 also brings significant speed enhancements (often 10x or more) to some core operations in 2D computational geometry—making things like computing this fast even though it involves complicated regions:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec6img8.png" alt="" title="" width="414" height="343"/> </p>
</div>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec6img9A.png" alt="" title="" width="105" height=""/> </p>
</div>
<h2 id="visualizations-begin-to-come-alive">Visualizations Begin to Come Alive</h2>
<p>A great long-term strength of the Wolfram Language has been its ability to produce insightful visualizations in a highly automated way. In Version 13.3 we’re taking this further, by adding automatic “live highlighting”. Here’s a simple example, just using the function <tt><a href="http://reference.wolfram.com/language/ref/Plot.html">Plot</a></tt>. Instead of just producing static curves, <tt><a href="http://reference.wolfram.com/language/ref/Plot.html">Plot</a></tt> now automatically generates a visualization with interactive highlighting:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/Video1-Plot-2.gif" alt="" title="" width="414" height=""/> </p>
</div>
<p>The same thing works for <tt><a href="http://reference.wolfram.com/language/ref/ListPlot.html">ListPlot</a></tt>:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec7img2.png" alt="" title="" width="405" height="265"/> </p>
</div>
<p>The highlighting can, for example, show dates too:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec7img3.png" alt="" title="" width="466" height="246"/> </p>
</div>
<p>There are many choices for how the highlighting should be done. The simplest thing is just to specify a style in which to highlight whole curves: </p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/Video2-PlotHighlighting-2.gif" alt="" title="" width="431" height=""/> </p>
</div>
<p>But there are many other built-in highlighting specifications. Here, for example, is <tt>&#34;XSlice&#34;</tt>:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/Video3-XSlice.gif" alt="" title="" width="512" height=""/> </p>
</div>
<p>In the end, though, highlighting is built up from a whole collection of components—like <tt>&#34;NearestPoint&#34;</tt>, <tt>&#34;Crosshairs&#34;</tt>, <tt>&#34;XDropline&#34;</tt>, etc.—that you can assemble and style for yourself: </p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/Video5-XAxisLabel.gif" alt="" title="" width="451" height=""/> </p>
</div>
<p>The option <a href="https://reference.wolfram.com/language/ref/PlotHighlighting.html"><tt>PlotHighlighting</tt></a> defines global highlighting in a plot. But by using the <tt><a href="http://reference.wolfram.com/language/ref/Highlighted.html">Highlighted</a></tt> “wrapper” you can specify that only a particular element in the plot should be highlighted:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/Video6-ElementHighlighted-1.gif" alt="" title="" width="462" height=""/> </p>
</div>
<p>For interactive and exploratory purposes, the kind of automatic highlighting we’ve just been showing is very convenient. But if you’re making a static presentation, you’ll need to “burn in” particular pieces of highlighting—which you can do with <tt><a href="http://reference.wolfram.com/language/ref/Placed.html">Placed</a></tt>: </p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec7img8.png" alt="" title="" width="606" height="270"/> </p>
</div>

<p>In indicating elements in a graphic there are different effects one can use. In <a href="https://reference.wolfram.com/legacy/language/v13.1/">Version 13.1</a> we introduced <tt><a href="http://reference.wolfram.com/language/ref/DropShadowing.html">DropShadowing</a>[]</tt>. In Version 13.3 we’re introducing <a href="https://reference.wolfram.com/language/ref/Haloing.html"><tt>Haloing</tt></a>: </p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec7img9.png" alt="" title="" width="468" height="245"/> </p>
</div>
<p><a href="https://reference.wolfram.com/language/ref/Haloing.html"><tt>Haloing</tt></a> can also be combined with interactive highlighting:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec7img10.png" alt="" title="" width="673" height="254"/> </p>
</div>
<p>By the way, there are lots of nice effects you can get with <a href="https://reference.wolfram.com/language/ref/Haloing.html"><tt>Haloing</tt></a> in graphics. Here’s a geo example—including some parameters for the “orientation” and “thickness” of the haloing:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec7img11A.png" alt="" title="" width="474" height=""/> </p>
</div>
<h2 id="publishing-to-augmented-+-virtual-reality">Publishing to Augmented + Virtual Reality</h2>
<p>Throughout the history of the Wolfram Language 3D visualization has been an important capability. And we’re always looking for ways to share and communicate 3D geometry. Already back in the early 1990s we had experimental implementations of VR. But at the time there wasn’t anything like the kind of infrastructure for VR that would be needed to make this broadly useful. In the mid-2010s we then introduced VR functionality based on Unity—that provides powerful capabilities within the Unity ecosystem, but is not accessible outside.</p>
<p>Today, however, it seems there are finally broad standards emerging for AR and VR. And so in Version 13.3 we’re able to begin delivering what we hope will provide widely accessible AR and VR deployment from the Wolfram Language. </p>
<p>At a underlying level what we’re doing is to support the USD and GLTF geometry representation formats. But we’re also building a higher-level interface that allows anyone to “publish” 3D geometry for AR and VR.</p>
<p>Given a piece of geometry (which for now can’t involve too many polygons), all you do is apply <a href="https://reference.wolfram.com/language/ref/ARPublish.html"><tt>ARPublish</tt></a>:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062123sec8img1A.png" alt="" title="" width="229" height=""/> </p>
</div>
<p>The result is a cloud object that has a certain underlying UUID, but is displayed in a notebook as a QR code. Now all you do is look at this QR code with your phone (or tablet, etc.) camera, and press the URL it extracts.</p>
<p>The result will be that the geometry you published with <a href="https://reference.wolfram.com/language/ref/ARPublish.html"><tt>ARPublish</tt></a> now appears in AR on your phone:</p>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/triptych-AR-v2.png" alt="Augmented reality triptych" title="Augmented reality triptych" width="620" height=""/></p>
<p>Move your phone and you’ll see that your geometry has been realistically placed into the scene. You can also go to a VR “object” mode in which you can manipulate the geometry on your phone.</p>
<p>“Under the hood” there are some slightly elaborate things going on—particularly in providing the appropriate data to different kinds of phones. But the result is a first step in the process of easily being able to get AR and VR output from the Wolfram Language—deployed in whatever devices support AR and VR.</p>
<h2 id="getting-the-details-right:-the-continuing-story">Getting the Details Right: The Continuing Story</h2>
<p>In every version of Wolfram Language we add all sorts of fundamentally new capabilities. But we also work to fill in details of existing capabilities, continually pushing to make them as general, consistent and accurate as possible. In Version 13.3 there are many details that have been “made right”, in many different areas. </p>
<p>Here’s one example: the comparison (and sorting) of <tt><a href="http://reference.wolfram.com/language/ref/Around.html">Around</a></tt> objects. Here are 10 random “numbers with uncertainty”:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec9img1.png" alt="" title="" width="579" height="45"/> </p>
</div>
<p>These sort by their central value:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec9img2.png" alt="" title="" width="579" height="44"/> </p>
</div>
<p>But if we look at these, many of their uncertainty regions overlap:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec9img3.png" alt="" title="" width="299" height="194"/> </p>
</div>
<p>So when should we consider a particular number-with-uncertainty “greater than” another? In Version 13.3 we carefully take into account uncertainty when making comparisons. So, for example, this gives <tt><a href="http://reference.wolfram.com/language/ref/True.html">True:</a></tt></p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec9img4.png" alt="" title="" width="276" height="43"/> </p>
</div>
<p>But when there’s too big an uncertainty in the values, we no longer consider the ordering “certain enough”:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec9img5.png" alt="" title="" width="276" height="43"/> </p>
</div>
<p>Here’s another example of consistency: the applicability of <tt><a href="http://reference.wolfram.com/language/ref/Duration.html">Duration</a></tt>. We introduced <tt><a href="http://reference.wolfram.com/language/ref/Duration.html">Duration</a></tt> to apply to explicit time constructs, things like <tt><a href="http://reference.wolfram.com/language/ref/Audio.html">Audio</a></tt> objects, etc. But in Version 13.3 it also applies to entities for which there’s a reasonable way to define a “duration”:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec9img6.png" alt="" title="" width="388" height="58"/> </p>
</div>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec9img7.png" alt="" title="" width="362" height="62"/> </p>
</div>
<p>Dates (and times) are complicated things—and we’ve put a lot of effort into handling them correctly and consistently in the Wolfram Language. One concept that we introduced a few years ago is date granularity: the (subtle) analog of numerical precision for dates. But at first only some date functions supported granularity; now in Version 13.3 all date functions include a <tt><a href="http://reference.wolfram.com/language/ref/DateGranularity.html">DateGranularity</a></tt> option—so that granularity can consistently be tracked through all date-related operations:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec9img8.png" alt="" title="" width="377" height="55"/> </p>
</div>
<p>Also in dates, something that’s been added, particularly for astronomy, is the ability to deal with “years” specified by real numbers:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec9img9.png" alt="" title="" width="491" height="57"/> </p>
</div>
<p>And one consequence of this is that it becomes easier to make a plot of something like astronomical distance as a function of time:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec9img10.png" alt="" title="" width="615" height="187"/> </p>
</div>
<p>Also in astronomy, we’ve been steadily extending our capabilities to consistently fill in computations for more situations. In Version 13.3, for example, we can now compute sunrise, etc. not just from points on Earth, but from points anywhere in the solar system:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec9img11.png" alt="" title="" width="367" height="66"/> </p>
</div>
<p>By the way, we’ve also made the computation of sunrise more precise. So now if you ask for the position of the Sun right at sunrise you’ll get a result like this:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec9img12.png" alt="" title="" width="332" height="89"/> </p>
</div>
<p>How come the altitude of the Sun is not zero at sunrise? That’s because the disk of the Sun is of nonzero size, and “sunrise” is defined to be when any part of the Sun pokes over the horizon.</p>
<h2 id="even-easier-to-type:-affordances-for-wolfram-language-input">Even Easier to Type: Affordances for Wolfram Language Input</h2>
<p>Back in 1988 when what’s now Wolfram Language first existed, the only way to type it was like ordinary text. But gradually we’ve introduced more and more “affordances” to make it easier and faster to type correct Wolfram Language input. In 1996, with <a href="https://reference.wolfram.com/legacy/v3/">Version 3</a>, we introduced automatic spacing (and spanning) for operators, as well as brackets that flashed when they matched—and things like -&gt; being automatically replaced by <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423plainarrow.png" alt="" title="" width="17" height=""/>. Then in 2007, with <a href="https://reference.wolfram.com/legacy/v6/">Version 6</a>, we introduced—with some trepidation at first—syntax coloring. We’d had a way to request autocompletion of a symbol name all the way back to the beginning, but it’d never been good or efficient enough for us to make it happen all the time as you type. But in 2012, for <a href="https://reference.wolfram.com/legacy/v9/guide/Mathematica.html">Version 9</a>, we created a much more elaborate autocomplete system—that was useful and efficient enough that we turned it on for all notebook input. A key feature of this autocomplete system was its context-sensitive knowledge of the Wolfram Language, and how and where different symbols and strings typically appear. Over the past decade, we’ve gradually refined this system to the point where I, for one, deeply rely on it.</p>
<p>In recent versions, we’ve made other “typability” improvements. For example, in <a href="https://reference.wolfram.com/legacy/language/v12.3/">Version 12.3</a>, we generalized the -&gt; to <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423plainarrow.png" alt="" title="" width="17" height=""/> transformation to a whole collection of “auto operator renderings”. Then in <a href="https://reference.wolfram.com/legacy/language/v13/">Version 13.0</a> we introduced “automatching” of brackets, in which, for example, if you enter <tt>[</tt> at the end of what you’re typing, you’ll automatically get a matching <tt>]</tt>. </p>
<p>Making “typing affordances” work smoothly is a painstaking and tricky business. But in every recent version we’ve steadily been adding more features that—in very “natural” ways—make it easier and faster to type Wolfram Language input. </p>
<p>In Version 13.3 one major change is an enhancement to autocompletion. Instead of just showing pure completions in which characters are appended to what’s already been typed, the autocompletion menu now includes “fuzzy completions” that fill in intermediate characters, change capitalization, etc.</p>
<p>So, for example, if you type “<span>lp</span>” you now get <tt><a href="http://reference.wolfram.com/language/ref/ListPlot.html">ListPlot</a></tt> as a completion (the little underlines indicate where the letters you actually type appear):</p>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec10img2B.png" alt="ListPlot autocompletion menu" title="ListPlot automcompletion menu" width="152" height=""/> </p>
<p>From a design point of view one thing that’s important about this is that it further removes the “short name” premium—and weights things even further on the side of wanting names that explain themselves when they’re read, rather than that are easy to type in an unassisted way. With the <a href="https://resources.wolframcloud.com/FunctionRepository/">Wolfram Function Repository</a> it’s become increasingly common to want to type <tt><a href="http://reference.wolfram.com/language/ref/ResourceFunction.html">ResourceFunction</a></tt>. And we’d been thinking that perhaps we should have a special, short notation for that. But with the new autocompletion, one can operationally just press three <nobr>keys—<span><kbd>r</kbd><kbd>f</kbd><kbd>enter</kbd></span>—</nobr>to get to <tt><a href="http://reference.wolfram.com/language/ref/ResourceFunction.html">ResourceFunction</a></tt>:</p>
<p> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/rfmenu-v3.png" alt="ResourceFunction autocompletion menu" title="ResourceFunction autocompletion menu" width="163" height=""/></p>
<p>When one designs something and gets the design right, people usually don’t notice; things just “work as they expect”. But when there’s a design error, that’s when people notice—and are frustrated by—the design. But then there’s another case: a situation where, for example, there are two things that could happen, and sometimes one wants one, and sometimes the other. In doing the design, one has to pick a particular branch. And when this happens to be the branch people want, they don’t notice, and they’re happy. But if they want the other branch, it can be confusing and frustrating.</p>
<p>In the design of the Wolfram Language one of the things that has to be chosen is the precedence for every operator: <em>a</em> + <em>b</em> × <em>c</em> means <em>a</em> + (<em>b</em> × <em>c</em>) because × has higher precedence than +. Often the correct order of precedences is fairly obvious. But sometimes it’s simply impossible to make everyone happy all the time. And so it is with <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423plainarrow.png" alt="" title="" width="17" height=""/> and <tt>&amp;</tt>. It’s very convenient to be able to add <tt>&amp;</tt> at the end of something you type, and make it into a pure function. But that means if you type <nobr><em>a</em> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423plainarrow.png" alt="" title="" width="17" height=""/> <em>b</em> <tt>&amp;</tt></nobr> it’ll turn the whole thing into a function: <tt><em>a</em> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423plainarrow.png" alt="" title="" width="17" height=""/> <em>b</em> &amp;</tt>. When functions have options, however, one often wants things like <em>name</em> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423plainarrow.png" alt="" title="" width="17" height=""/> <em>function</em>. The natural tendency is to type this as <em>name</em> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423plainarrow.png" alt="" title="" width="17" height=""/> <em>body</em> <tt>&amp;</tt>. But this will mean (<em>name</em> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423plainarrow.png" alt="" title="" width="17" height=""/> <em>body</em>) <tt>&amp;</tt> rather than <em>name</em> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423plainarrow.png" alt="" title="" width="17" height=""/> (<em>body</em> <tt>&amp;</tt>). And, yes, when you try to run the function, it’ll notice it doesn’t have correct arguments and options specified. But you’d like to know that what you’re typing isn’t right as soon as you type it. And now in Version 13.3 we have a mechanism for that. As soon as you enter <tt>&amp;</tt> to “end a function”, you’ll see the extent of the function flash:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/purefunction-highlight-1-v2-1.gif" alt="" title="" width="555" height=""/> </p>
</div>
<p>And, yup, you can see that’s wrong. Which gives you the chance to fix it as:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/purefunction-highlight-2-v2-1.gif" alt="" title="" width="520" height=""/> </p>
</div>
<p>There’s another <a href="https://www.wolfram.com/notebooks/">notebook</a>-related update in Version 13.3 that isn’t directly related to typing, but will help in the construction of easy-to-navigate user interfaces. We’ve had <tt><a href="http://reference.wolfram.com/language/ref/ActionMenu.html">ActionMenu</a></tt> since 2007—but it’s only been able to create one-level menus. In Version 13.3 it’s been extended to arbitrary hierarchical menus:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/action-menu-arrows.png" alt="" title="" width="577" height=""/> </p>
</div>
<p>Again not directly related to typing, but now relevant to managing and editing code, there’s an update in Version 13.3 to package editing in the notebook interface. Bring up a .wl file and it’ll appear as a notebook. But its default toolbar is different from the usual notebook toolbar (and is newly designed in Version 13.3):</p>
<p>  <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec10img18.png" alt="New default toolbar" title="New default toolbar" width="603" height="51"/></p>
<p><tt>Go To</tt> now gives you a way to immediately go to the definition of any function whose name matches what you type, as well as any section, etc.:</p>
<p> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/WL-Toolbar2-v3.png" alt="Go To results" title="Go To results" width="480" height=""/></p>
<p>The numbers on the right here are code line numbers; you can also go directly to a specific line number by typing :<em>nnn</em>.</p>
<h2 id="the-elegant-code-project">The Elegant Code Project</h2>
<p>One of the central goals—and achievements—of the Wolfram Language is to create a computational language that can be used not only as a way to tell computers what to do, but also as a way to communicate computational ideas for human consumption. In other words, Wolfram Language is intended not only to be written by humans (for consumption by computers), but also to be read by humans. </p>
<p>Crucial to this is the broad consistency of the Wolfram Language, as well as its use of carefully chosen natural-language-based names for functions, etc. But what can we do to make Wolfram Language as easy and pleasant as possible to read? In the past we’ve balanced our optimization of the appearance of Wolfram Language between reading and writing. But in Version 13.3 we’ve got the beginnings of our Elegant Code project—to find ways to render Wolfram Language to be specifically optimized for reading.</p>
<p>As an example, here’s a small piece of code (from my <em><a href="https://www.wolfram.com/language/elementary-introduction/3rd-ed/">An Elementary Introduction to the Wolfram Language</a></em>), shown in the default way it’s rendered in notebooks:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423sec11img2.png" alt="" title="" width="487" height="18"/> </p>
</div>
<p>But in Version 13.3 you can use <tt>Format</tt> &gt; <tt>Screen Environment</tt> &gt; <tt>Elegant</tt> to set a notebook to use the current version of “elegant code”:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423sec11img1.png" alt="" title="" width="487" height="15"/> </p>
</div>
<p>(And, yes, this is what we’re actually using for code in this post, as well as some other recent ones.) So what’s the difference? First of all, we’re using a proportionally spaced font that makes the names (here of symbols) easy to “read like words”. And second, we’re adding space between these “words”, and graying back “structural elements” like <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423leftbracket.png" alt="" title="" width="8" height=""/> … <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423rightbracket.png" alt="" title="" width="8" height=""/> and <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423leftbrace.png" alt="" title="" width="8" height=""/> … <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423rightbrace.png" alt="" title="" width="8" height=""/>. When you write a piece of code, things like these structural elements need to stand out enough for you to “see they’re right”. But when you’re reading code, you don’t need to pay as much attention to them. Because the Wolfram Language is so based on “word-like” names, you can typically “understand what it’s saying” just by “reading these words”.</p>
<p>Of course, making code “elegant” is not just a question of formatting; it’s also a question of what’s actually in the code. And, yes, as with writing text, it takes effort to craft code that “expresses itself elegantly”. But the good news is that the Wolfram Language—through its uniquely broad and high-level character—makes it surprisingly straightforward to create code that expresses itself extremely elegantly.</p>
<p>But the point now is to make that code not only elegant in content, but also elegant in formatting. In technical documents it’s common to see math that’s at least formatted elegantly. But when one sees code, more often than not, it looks like something only a machine could appreciate. Of course, if the code is in a traditional programming language, it’ll usually be long and not really intended for human consumption. But what if it’s elegantly crafted Wolfram Language code? Well then we’d like it to look as attractive as text and math. And that’s the point of our Elegant Code project.</p>
<p>There are many tradeoffs, and many issues to be navigated. But in Version 13.3 we’re definitely making progress. Here’s an example that doesn’t have so many “words”, but where the elegant code formatting still makes the “blocking” of the code more obvious:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423sec11img4.png" alt="" title="" width="363" height="67"/> </p>
</div>
<p>Here’s a slightly longer piece of code, where again the elegant code formatting helps pull out “readable” words, as well as making the overall structure of the code more obvious: </p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423sec11img5.png" alt="" title="" width="385" height="92"/> </p>
</div>
<p>Particularly in recent years, we’ve added many mechanisms to let one write Wolfram Language that’s easier to read. There are the auto operator renderings, like <tt>m[[i]]</tt> turning into <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423sec11imgmiEC.png" alt="" title="" width="36" height=""/>. And then there are things like the <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423sec11rightarrow.png" alt="" title="" width="23" height=""/> notation for pure functions. One particularly important element is <tt><a href="http://reference.wolfram.com/language/ref/Iconize.html">Iconize</a></tt>, which lets you show any piece of Wolfram Language input in a visually “iconized” form—which nevertheless evaluates just like the corresponding underlying expression:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423sec11img6.png" alt="" title="" width="441" height="50"/> </p>
</div>
<p><tt><a href="http://reference.wolfram.com/language/ref/Iconize.html">Iconize</a></tt> lets you effectively hide details (like large amounts of data, option settings, etc.) But sometimes you want to highlight things. You can do it with <tt><a href="http://reference.wolfram.com/language/ref/Style.html">Style</a></tt>, <tt><a href="http://reference.wolfram.com/language/ref/Framed.html">Framed</a></tt>, <tt><a href="http://reference.wolfram.com/language/ref/Highlighted.html">Highlighted</a></tt>—and in Version 13.3, <a href="https://reference.wolfram.com/language/ref/Squiggled.html"><tt>Squiggled</tt></a>:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423sec11img7.png" alt="" title="" width="549" height="58"/> </p>
</div>
<p>By default, all these constructs persist through evaluation. But in Version 13.3 all of them now have the option <a href="https://reference.wolfram.com/language/ref/StripOnInput.html"><tt>StripOnInput</tt></a>, and with this set, you have something that shows up highlighted in an input cell, but where the highlighting is stripped when the expression is actually fed to the Wolfram Language kernel.</p>
<p>These show their highlighting in the notebook:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423sec11img8.png" alt="" title="" width="596" height="58"/> </p>
</div>
<p>But when used in input, the highlighting is stripped:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423sec11img9.png" alt="" title="" width="140" height="58"/> </p>
</div>
<h2 id="see-more-also...">See More Also…</h2>
<p>A great strength of the Wolfram Language (yes, perhaps initiated by my original 1988 <em><a href="https://www.stephenwolfram.com/publications/mathematica-book/">Mathematica Book</a></em>) is its detailed documentation—which has now proved valuable not only for human users but also for AIs. Plotting the number of words that appear in the documentation in successive versions, we see a strong progressive increase:</p>
<p>  <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec12img1.png" alt="Words graph" title="Words graph" width="431" height="261"/></p>
<p>But with all that documentation, and all those new things to be documented, the problem of appropriately crosslinking everything has increased. Even back in <a href="https://reference.wolfram.com/legacy/v1/">Version 1.0</a>, when the documentation was a physical book, there were “See Also’s” between functions:</p>
<p>  <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec12img2.png" alt="Versioni 1.0 documentation" title="Version 1.0 documentation" width="622" height="123"/></p>
<p>And by now there’s a complicated network of such See Also’s:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec12img4.png" alt="" title="" width="578" height="447"/> </p>
</div>
<p>But that’s just the network of how functions point to functions. What about other kinds of constructs? Like formats, characters or entity types—or, for that matter, entries in the Wolfram Function Repository, <a href="https://reference.wolfram.com/language/guide/WolframDataRepository.html">Wolfram Data Repository</a>, etc. Well, in Version 13.3 we’ve done a first iteration of crosslinking all these kinds of things.</p>
<p>So here now are the “See Also” areas for <a href="https://reference.wolfram.com/language/ref/Graph.html"><tt>Graph</tt></a> and <a href="https://reference.wolfram.com/language/ref/Molecule.html"><tt>Molecule</tt></a>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/seealso-graph.png" alt="Graph see also options" title="Graph see also options" width="620" height=""/> </p>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/seealso-molecule.png" alt="Molecule see also options" title="Molecule see also options" width="620" height=""/> </p>
<p>Not only are there functions here; there are also other kinds of things that a person (or AI) looking at these pages might find relevant. </p>
<p>It’s great to be able to follow links, but sometimes it’s better just to have material immediately accessible, without following a link. Back in <a href="https://reference.wolfram.com/legacy/v1/">Version 1.0</a> we made the decision that when a function inherits some of its options from a “base function” (say <tt><a href="http://reference.wolfram.com/language/ref/Plot.html">Plot</a></tt> from <tt><a href="http://reference.wolfram.com/language/ref/Graphics.html">Graphics</a></tt>), we only need to explicitly list the non-inherited option values. At the time, this was a good way to save a little paper in the printed book. But now the optimization is different, and finally in Version 13.3 we have a way to show “All Options”—tucked away so it doesn’t distract from the typically-more-important non-inherited options.</p>
<p>Here’s the setup for <tt><a href="http://reference.wolfram.com/language/ref/Plot.html">Plot</a></tt>. First, the list of non-inherited option values:</p>
<p> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec12img6.png" alt="Plot non-inherited option values" title="Plot non-inherited option values" width="622" height="169"/> </p>
<p>Then, at the end of the Details section </p>
<p> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/list-all-options-v2.png" alt="Details and options" title="Details and options" width="620" height=""/></p>
<p>which opens to: </p>
<p>  <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062223sec12img8.png" alt="Expanded list of all options" title="Expanded list of all options" width="622" height="281"/> </p>
<h2 id="pictures-from-words:-generative-ai-for-images">Pictures from Words: Generative AI for Images</h2>
<p>One of the remarkable things that’s emerged as a possibility from recent advances in AI and neural nets is the generation of images from textual descriptions. It’s not yet realistic to do this at all well on anything but a high-end (and typically server) GPU-enabled machine. But in Version 13.3 there’s now a built-in function <a href="https://reference.wolfram.com/language/ref/ImageSynthesize.html"><tt>ImageSynthesize</tt></a> that can get images synthesized, for now through an external API.</p>
<p>You give text, and <a href="https://reference.wolfram.com/language/ref/ImageSynthesize.html"><tt>ImageSynthesize</tt></a> will try to generate images for which that text is a description:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec13img1.png" alt="" title="" width="595" height="159"/> </p>
</div>
<p>Sometimes these images will be directly useful in their own right, perhaps as “theming images” for documents or user interfaces. Sometimes they will provide raw material that can be developed into icons or other art. And sometimes they are most useful as inputs to tests or other algorithms.</p>
<p>And one of the important things about <a href="https://reference.wolfram.com/language/ref/ImageSynthesize.html"><tt>ImageSynthesize</tt></a> is that it can immediately be used as part of any Wolfram Language workflow. Pick a random sentence from <em>Alice in Wonderland</em>:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec13img2.png" alt="" title="" width="561" height="69"/> </p>
</div>
<p>Now <a href="https://reference.wolfram.com/language/ref/ImageSynthesize.html"><tt>ImageSynthesize</tt></a> can “illustrate” it:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec13img3A.png" alt="" title="" width="589" height=""/> </p>
</div>
<p>Or we can get AI to feed AI:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec13img4.png" alt="" title="" width="651" height="45"/> </p>
</div>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec13img5A.png" alt="" title="" width="589" height=""/> </p>
</div>
<p><a href="https://reference.wolfram.com/language/ref/ImageSynthesize.html"><tt>ImageSynthesize</tt></a> is set up to automatically be able to synthesize images of different sizes:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/DaliCat-v2.png" alt="" title="" width="600" height=""/> </p>
</div>
<p>You can take the output of <a href="https://reference.wolfram.com/language/ref/ImageSynthesize.html"><tt>ImageSynthesize</tt></a> and immediately process it:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec13img7.png" alt="" title="" width="292" height="233"/> </p>
</div>
<p><a href="https://reference.wolfram.com/language/ref/ImageSynthesize.html"><tt>ImageSynthesize</tt></a> can not only produce complete images, but can also fill in transparent parts of “incomplete” images:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec13img8.png" alt="" title="" width="364" height="280"/> </p>
</div>
<p>In addition to <a href="https://reference.wolfram.com/language/ref/ImageSynthesize.html"><tt>ImageSynthesize</tt></a> and all its new LLM functionality, Version 13.3 also includes a number of advances in the core machine learning system for Wolfram Language. Probably the most notable are speedups of up to 10x and beyond for neural net training and evaluation on x86-compatible systems, as well as better models for <tt><a href="http://reference.wolfram.com/language/ref/ImageIdentify.html">ImageIdentify</a></tt>. There are also a variety of new networks in the <a href="https://resources.wolframcloud.com/NeuralNetRepository/">Wolfram Neural Net Repository</a>, particularly ones based on transformers.</p>
<h2 id="digital-twins:-fitting-system-models-to-data">Digital Twins: Fitting System Models to Data</h2>
<p>It’s been five years since we first began to introduce industrial-scale systems engineering capabilities in the Wolfram Language. The goal is to be able to compute with models of engineering and other systems that can be described by (potentially very large) collections of ordinary differential equations and their discrete analogs. Our separate <a href="https://www.wolfram.com/system-modeler/">Wolfram System Modeler</a> product provides an IDE and GUI for graphically creating such models.</p>
<p>For the past five years we’ve been able to do high-efficiency simulation of these models from within the Wolfram Language. And over the past few years we’ve been adding all sorts of higher-level functionality for programmatically creating models, and for systematically analyzing their behavior. A major focus in recent versions has been the synthesis of control systems, and various forms of controllers.</p>
<p>Version 13.3 now tackles a different issue, which is the alignment of models with real-world systems. The idea is to have a model which contains certain parameters, and then to determine these parameters by essentially fitting the model’s behavior to observed behavior of a real-world system. </p>
<p>Let’s start by talking about a simple case where our model is just defined by a single ODE:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec14img1.png" alt="" title="" width="435" height="138"/> </p>
</div>
<p>This ODE is simple enough that we can find its analytical solution:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec14img2.png" alt="" title="" width="330" height="73"/> </p>
</div>
<p>So now let’s make some “simulated real-world data” assuming <nobr><em>a</em> = 2,</nobr> and with some noise:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec14img4.png" alt="" title="" width="603" height="14"/> </p>
</div>
<p>Here’s what the data looks like:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec14img5.png" alt="" title="" width="305" height="195"/> </p>
</div>
<p>Now let’s try to “calibrate” our original model using this data. It’s a process similar to machine learning training. In this case we make an “initial guess” that the parameter <em>a</em> is 1; then when <a href="https://reference.wolfram.com/language/ref/SystemModelCalibrate.html"><tt>SystemModelCalibrate</tt></a> runs it shows the “loss” decreasing as the correct value of <em>a</em> is found:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec14img6.png" alt="" title="" width="484" height="132"/> </p>
</div>
<p>The “calibrated” model does indeed have <em>a</em> ≈ 2:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec14img8.png" alt="" title="" width="246" height="45"/> </p>
</div>
<p>Now we can compare the calibrated model with the data:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec14img9.png" alt="" title="" width="586" height="223"/> </p>
</div>
<p>As a slightly more realistic engineering-style example let’s look at a model of an electric motor (with both electrical and mechanical parts):</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec14img10.png" alt="" title="" width="102" height="14"/> </p>
</div>
<p>Let’s say we’ve got some data on the behavior of the motor; here we’ve assumed that we’ve measured the angular velocity of a component in the motor as a function of time. Now we can use this data to calibrate parameters of the model (here the resistance of a resistor and the damping constant of a damper):</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec14img11.png" alt="" title="" width="529" height="127"/> </p>
</div>
<p>Here are the fitted parameter values:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec14img12.png" alt="" title="" width="398" height="45"/> </p>
</div>
<p>And here’s a full plot of the angular velocity data, together with the fitted model and its 95% confidence bands: </p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec14img13.png" alt="" title="" width="502" height="249"/> </p>
</div>
<p><a href="https://reference.wolfram.com/language/ref/SystemModelCalibrate.html"><tt>SystemModelCalibrate</tt></a> can be used not only in fitting a model to real-world data, but also for example in fitting simpler models to more complicated ones, making possible various forms of “model simplification”. </p>
<h2 id="symbolic-testing-framework">Symbolic Testing Framework</h2>
<p>The Wolfram Language is by many measures one of the world’s most complex pieces of software engineering. And over the decades we’ve developed a large and powerful system for testing and validating it. A decade ago—in <a href="https://reference.wolfram.com/legacy/language/v10/">Version 10</a>—we began to make some of our internal tools available for anyone writing Wolfram Language code. Now in Version 13.3 we’re introducing a more streamlined—and “symbolic”—version of our testing framework. </p>
<p>The basic idea is that each test is represented by a symbolic <a href="https://reference.wolfram.com/language/ref/TestObject.html"><tt>TestObject</tt></a>, created using <a href="https://reference.wolfram.com/language/ref/TestCreate.html"><tt>TestCreate</tt></a>:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec15img1.png" alt="" title="" width="329" height="81"/> </p>
</div>
<p>On its own, <a href="https://reference.wolfram.com/language/ref/TestObject.html"><tt>TestObject</tt></a> is an inert object. You can run the test it represents using <a href="https://reference.wolfram.com/language/ref/TestEvaluate.html"><tt>TestEvaluate</tt></a>:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec15img2.png" alt="" title="" width="300" height="82"/> </p>
</div>
<p>Each test object has a whole collection of properties, some of which only get filled in when the test is run:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec15img3.png" alt="" title="" width="712" height="127"/> </p>
</div>
<p>It’s very convenient to have symbolic test objects that one can manipulate using standard Wolfram Language functions, say selecting tests with particular features, or generating new tests from old. And when one builds a test suite, one does it just by making a list of test objects. </p>
<p>This makes a list of test objects (and, yes, there’s some trickiness because <a href="https://reference.wolfram.com/language/ref/TestCreate.html"><tt>TestCreate</tt></a> needs to keep unevaluated the expression that’s going to be tested):</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec15img4.png" alt="" title="" width="646" height="157"/> </p>
</div>
<p>But given these tests, we can now generate a report from running them:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec15img5.png" alt="" title="" width="347" height="78"/> </p>
</div>
<p><a href="https://reference.wolfram.com/language/ref/TestReport.html"><tt>TestReport</tt></a> has various options that allow you to monitor and control the running of a test suite. For example, here we’re saying to echo every <tt>&#34;TestEvaluated&#34;</tt> event that occurs:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec15img6.png" alt="" title="" width="458" height="253"/> </p>
</div>
<h2 id="did-you-get-that-math-right?">Did You Get That Math Right?</h2>
<p>Most of what the Wolfram Language is about is taking inputs from humans (as well as programs, and now AIs) and computing outputs from them. But a few years ago we started introducing capabilities for having the Wolfram Language ask questions of humans, and then assessing their answers. </p>
<p>In recent versions we’ve been building up sophisticated ways to construct and deploy “quizzes” and other collections of questions. But one of the core issues is always how to determine whether a person has answered a particular question correctly. Sometimes that’s easy to determine. If we ask “What is 2 + 2?”, the answer better be “4” (or conceivably “four”). But what if we ask a question where the answer is some algebraic expression? The issue is that there may be many mathematically equal forms of that expression. And it depends on what exactly one’s asking whether one considers a particular form to be the “right answer” or not.</p>
<p>For example, here we’re computing a derivative:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec16img1.png" alt="" title="" width="157" height="47"/> </p>
</div>
<p>And here we’re doing a factoring problem:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec16img2.png" alt="" title="" width="178" height="44"/> </p>
</div>
<p>These two answers are mathematically equal. And they’d both be “reasonable answers” for the derivative if it appeared as a question in a calculus course. But in an algebra course, one wouldn’t want to consider the unfactored form a “correct answer” to the factoring problem, even though it’s “mathematically equal”.</p>
<p>And to deal with these kinds of issues, we’re introducing in Version 13.3 more detailed mathematical assessment functions. With a <tt>&#34;CalculusResult&#34;</tt> assessment function, it’s OK to give the unfactored form:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec16img3.png" alt="" title="" width="486" height="84"/> </p>
</div>
<p>But with a <tt>&#34;PolynomialResult&#34;</tt> assessment function, the algebraic form of the expression has to be the same for it to be considered “correct”:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec16img4.png" alt="" title="" width="507" height="84"/> </p>
</div>
<p>There’s also another type of assessment function—<tt>&#34;ArithmeticResult&#34;</tt>—which only allows trivial arithmetic rearrangements, so that it considers 2 + 3 equivalent to 3 + 2, but doesn’t consider 2/3 equivalent to 4/6:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec16img5.png" alt="" title="" width="537" height="78"/> </p>
</div>
<p>Here’s how you’d build a question with this:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/QuestionObject-v2.png" alt="" title="" width="546" height=""/> </p>
</div>
<p>And now if you type “2/3” it’ll say you’ve got it right, but if you type “4/6” it won’t. However, if you use, say, <tt>&#34;CalculusResult&#34;</tt> in the assessment function, it’ll say you got it right even if you type “4/6”.</p>
<h2 id="streamlining-parallel-computation">Streamlining Parallel Computation</h2>
<p>Ever since the mid-1990s there’s been the capability to do parallel computation in the Wolfram Language. And certainly for me it’s been critical in a whole range of research projects I’ve done. I currently have 156 cores routinely available in my “home” setup, distributed across 6 machines. It’s sometimes challenging from a system administration point of view to keep all those machines and their networking running as one wants. And one of the things we’ve been doing in recent versions—and now completed in Version 13.3—is to make it easier from within the Wolfram Language to see and manage what’s going on.</p>
<p>It all comes down to specifying the configuration of kernels. And in Version 13.3 that’s now done using symbolic <tt><a href="http://reference.wolfram.com/language/ref/KernelConfiguration.html">KernelConfiguration</a></tt> objects. Here’s an example of one:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec17img1-edit.png" alt="" title="" width="481" height=""/> </p>
</div>
<p>There’s all sorts of information in the kernel configuration object:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec17img2-edit2.png" alt="" title="" width="579" height=""/> </p>
</div>
<p>It describes “where” a kernel with that configuration will be, how to get to it, and how it should be launched. The kernel might just be local to your machine. Or it might be on a remote machine, accessible through <span>ssh</span>, or <span>https</span>, or our own <span>wstp</span> (<a href="https://www.wolfram.com/wstp/">Wolfram Symbolic Transport Protocol</a>) or <span>lwg</span> (<a href="https://www.wolfram.com/lightweight-grid-manager/">Lightweight Grid</a>) protocols.</p>
<p>In Version 13.3 there’s now a GUI for setting up kernel configurations: </p>
<p> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec17img3A-edit.png" alt="Kernel configuration editor" title="Kernal configuration editor" width="547" height=""/> </p>
<p>The <a href="https://reference.wolfram.com/language/ref/menuitem/KernelConfigurationOptions.html">Kernel Configuration Editor</a> lets you enter all the details that are needed, about network connections, authentication, locations of executables, etc.</p>
<p>But once you’ve set up a <tt><a href="http://reference.wolfram.com/language/ref/KernelConfiguration.html">KernelConfiguration</a></tt> object, that’s all you ever need—for example to say “where” to do a remote evaluation:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec17img4-edit.png" alt="" title="" width="605" height=""/> </p>
</div>
<p><tt><a href="http://reference.wolfram.com/language/ref/ParallelMap.html">ParallelMap</a></tt> and other parallel functions then just work by doing their computations on kernels specified by a list of <tt><a href="http://reference.wolfram.com/language/ref/KernelConfiguration.html">KernelConfiguration</a></tt> objects. You can set up the list in the Kernels Settings GUI:</p>
<p> <img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec17img5-edit.png" alt="Parallel kernels settings" title="Parallel kernels settings" width="507" height=""/></p>
<p>Here’s my personal default collection of parallel kernels:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec17img6-edit.png" alt="" title="" width="623" height=""/> </p>
</div>
<p>This now counts the number of individual kernels running on each machine specified by these configurations:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec17img7-edit.png" alt="" title="" width="682" height=""/> </p>
</div>
<p>In Version 13.3 a convenient new feature is named collections of kernels. For example, this runs a single “representative” kernel on each distinct machine:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec17img8-edit2.png" alt="" title="" width="480" height=""/> </p>
</div>
<h2 id="just-call-that-c-function!-direct-access-to-external-libraries">Just Call That C Function! Direct Access to External Libraries</h2>
<p>Let’s say you’ve got an external library written in C—or in some other language that can compile to a C-compatible library. In Version 13.3 there’s now foreign function interface (FFI) capability that allows you to directly call any function in the external library just using Wolfram Language code. </p>
<p>Here’s a very trivial C function:</p>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec18img0.png" alt="Trivial C function" title="Trivial C function" width="145" height=""/></p>
<p>This function happens to be included in compiled form in the <tt>compilerDemoBase</tt> library that’s part of Wolfram Language documentation. Given this library, you can use <a href="https://reference.wolfram.com/language/ref/ForeignFunctionLoad.html"><tt>ForeignFunctionLoad</tt></a> to load the library and create a Wolfram Language function that directly calls the C <span>addone</span> function. All you need do is specify the library and C function, and then give the type signature for the function:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec18img1.png" alt="" title="" width="598" height="78"/> </p>
</div>
<p>Now <tt>ff</tt> is a Wolfram Language function that calls the C <span>addone</span> function:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec18img2.png" alt="" title="" width="95" height="43"/> </p>
</div>
<p>The C function <span>addone</span> happens to have a particularly simple type signature, that can immediately be represented in terms of compiler types that have direct analogs as Wolfram Language expressions. But in working with low-level languages, it’s very common to have to deal directly with raw memory, which is something that never happens when you’re purely working at the Wolfram Language level.</p>
<p>So, for example, in the OpenSSL library there’s a function called <span>RAND_bytes</span>, whose C type signature is:</p>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec18img2X.png" alt="RAND_bytes" title="RAND_bytes" width="320" height=""/></p>
<p>And the important thing to notice is that this contains a pointer to a buffer <span>buf</span> that gets filled by <span>RAND_bytes</span>. If you were calling <span>RAND_bytes</span> from C, you’d first allocate memory for this buffer, then—after calling <span>RAND_bytes</span>—read back whatever was written to the buffer. So how can you do something analogous when you’re calling <span>RAND_bytes</span> using <a href="https://reference.wolfram.com/language/ref/ForeignFunction.html"><tt>ForeignFunction</tt></a> in Wolfram Language? In Version 13.3 we’re introducing a family of constructs for working with pointers and raw memory. </p>
<p>So, for example, here’s how we can create a Wolfram Language foreign function corresponding to <span>RAND_bytes</span>:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec18img3.png" alt="" title="" width="551" height="113"/> </p>
</div>
<p>But to actually use this, we need to be able to allocate the buffer, which in Version 13.3 we can do with <a href="https://reference.wolfram.com/language/ref/RawMemoryAllocate.html"><tt>RawMemoryAllocate</tt></a>:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec18img4.png" alt="" title="" width="389" height="108"/> </p>
</div>
<p>This creates a buffer that can store 10 unsigned chars. Now we can call <tt>rb</tt>, giving it this buffer:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec18img5.png" alt="" title="" width="124" height="43"/> </p>
</div>
<p><tt>rb</tt> will fill the buffer—and then we can import the results back into Wolfram Language:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec18img6.png" alt="" title="" width="331" height="45"/> </p>
</div>
<p>There’s some complicated stuff going on here. <a href="https://reference.wolfram.com/language/ref/RawMemoryAllocate.html"><tt>RawMemoryAllocate</tt></a> does ultimately allocate raw memory—and you can see its hex address in the symbolic object that’s returned. But <a href="https://reference.wolfram.com/language/ref/RawMemoryAllocate.html"><tt>RawMemoryAllocate</tt></a> creates a <a href="https://reference.wolfram.com/language/ref/ManagedObject.html"><tt>ManagedObject</tt></a>, which keeps track of whether it’s being referenced, and automatically frees the memory that’s been allocated when nothing references it anymore.</p>
<p>Long ago languages like BASIC provided PEEK and POKE functions for reading and writing raw memory. It was always a dangerous thing to do—and it’s still dangerous. But it’s somewhat higher level in Wolfram Language, where in Version 13.3 there are now functions like <tt><a href="http://reference.wolfram.com/language/ref/RawMemoryRead.html">RawMemoryRead</a></tt> and <a href="https://reference.wolfram.com/language/ref/RawMemoryWrite.html"><tt>RawMemoryWrite</tt></a>. (For writing data into a buffer, <a href="https://reference.wolfram.com/language/ref/RawMemoryExport.html"><tt>RawMemoryExport</tt></a> is also relevant.)</p>
<p>Most of the time it’s very convenient to deal with memory-managed <a href="https://reference.wolfram.com/language/ref/ManagedObject.html"><tt>ManagedObject</tt></a> constructs. But for the full low-level experience, Version 13.3 provides <a href="https://reference.wolfram.com/language/ref/UnmanageObject.html"><tt>UnmanageObject</tt></a>, which disconnects automatic memory management for a managed object, and requires you to explicitly use <a href="https://reference.wolfram.com/language/ref/RawMemoryFree.html"><tt>RawMemoryFree</tt></a> to free it.</p>
<p>One feature of C-like languages is the concept of a function pointer. And normally the function that the pointer is pointing to is just something like a C function. But in Version 13.3 there’s another possibility: it can be a function defined in Wolfram Language. Or, in other words, from within an external C function it’s possible to call back into the Wolfram Language. </p>
<p>Let’s use this C program:</p>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec18img6X.png" alt="C program" title="C program" width="306" height=""/></p>
<p>You can actually compile it right from Wolfram Language using:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062523sec18cdlibimg1.png" alt="" title="" width="348" height="110"/> </p>
</div>
<p>Now we load <tt>frun</tt> as a foreign function—with a type signature that uses <tt><a href="https://reference.wolfram.com/language/ref/compiledtype/OpaqueRawPointer.html">&#34;OpaqueRawPointer&#34;</a></tt> to represent the function pointer:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec18img9.png" alt="" title="" width="641" height="78"/> </p>
</div>
<p>What we need next is to create a function pointer that points to a callback to Wolfram Language:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec18img10.png" alt="" title="" width="587" height="124"/> </p>
</div>
<p>The Wolfram Language function here is just <tt><a href="http://reference.wolfram.com/language/ref/Echo.html">Echo</a></tt>. But when we call <tt>frun</tt> with the <tt>cbfun</tt> function pointer we can see our C code calling back into Wolfram Language to evaluate <tt><a href="http://reference.wolfram.com/language/ref/Echo.html">Echo</a></tt>:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062323sec18img11A.png" alt="" title="" width="145" height=""/> </p>
</div>
<p><a href="https://reference.wolfram.com/language/ref/ForeignFunctionLoad.html"><tt>ForeignFunctionLoad</tt></a> provides an extremely convenient way to call external C-like functions directly from top-level Wolfram Language. But if you’re calling C-like functions a great many times, you’ll sometimes want to do it using compiled Wolfram Language code. And you can do this using the <a href="https://reference.wolfram.com/language/ref/LibraryFunctionDeclaration.html"><tt>LibraryFunctionDeclaration</tt></a> mechanism that was introduced in Version 13.1. It’ll be more complicated to set up, and it’ll require an explicit compilation step, but there’ll be slightly less “overhead” in calling the external functions.</p>
<h2 id="the-advance-of-the-compiler-continues">The Advance of the Compiler Continues</h2>
<p>For several years we’ve had an ambitious project to develop a large-scale compiler for the Wolfram Language. And in each successive version we’re further extending and enhancing the compiler. In Version 13.3 we’ve managed to compile more of the compiler itself (which, needless to say, is written in Wolfram Language)—thereby making the compiler more efficient in compiling code. We’ve also enhanced the performance of the code generated by the compiler—particularly by optimizing memory management done in the compiled code.</p>
<p>Over the past several versions we’ve been steadily making it possible to compile more and more of the Wolfram Language. But it’ll never make sense to compile everything—and in Version 13.3 we’re adding <a href="https://reference.wolfram.com/language/ref/KernelEvaluate.html"><tt>KernelEvaluate</tt></a> to make it more convenient to call back from compiled code to the Wolfram Language kernel. </p>
<p>Here’s an example:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423sec19img1.png" alt="" title="" width="605" height="127"/> </p>
</div>
<p>We’ve got an argument <em>n</em> that’s declared as being of type <tt><a href="https://reference.wolfram.com/language/ref/compiledtype/MachineInteger.html">MachineInteger</a></tt>. Then we’re doing a computation on <em>n</em> in the kernel, and using <tt><a href="http://reference.wolfram.com/language/ref/TypeHint.html">TypeHint</a></tt> to specify that its result will be of type <tt><a href="https://reference.wolfram.com/language/ref/compiledtype/MachineInteger.html">MachineInteger</a></tt>. There’s at least arithmetic going on outside the <a href="https://reference.wolfram.com/language/ref/KernelEvaluate.html"><tt>KernelEvaluate</tt></a> that can be compiled, even though the <a href="https://reference.wolfram.com/language/ref/KernelEvaluate.html"><tt>KernelEvaluate</tt></a> is just calling uncompiled code:</p>
<div>
<p><img loading="lazy" src="https://content.wolfram.com/uploads/sites/43/2023/06/sw062423sec19img2.png" alt="" title="" width="98" height="43"/> </p>
</div>
<p>There are other enhancements to the compiler in Version 13.3 as well. For example, <tt><a href="http://reference.wolfram.com/language/ref/Cast.html">Cast</a></tt> now allows data types to be cast in a way that directly emulates what the C language does. There’s also now <a href="https://reference.wolfram.com/language/ref/SequenceType.html"><tt>SequenceType</tt></a>, which is a type analogous to the Wolfram Language <tt><a href="http://reference.wolfram.com/language/ref/Sequence.html">Sequence</a></tt> construct—and able to represent an arbitrary-length sequence of arguments to a function. </p>
<h2 id="and-much-more...">And Much More…</h2>
<p>In addition to everything we’ve already discussed here, there are lots of other updates and enhancements in Version 13.3—as well as thousands of bug fixes. </p>
<p>Some of the additions fill out corners of functionality, adding completeness or consistency. Statistical fitting functions like <tt><a href="http://reference.wolfram.com/language/ref/LinearModelFit.html">LinearModelFit</a></tt> now accept input in all various association etc. forms that machine learning functions like <tt><a href="http://reference.wolfram.com/language/ref/Classify.html">Classify</a></tt> accept. <tt><a href="http://reference.wolfram.com/language/ref/TourVideo.html">TourVideo</a></tt> now lets you “tour” <tt><a href="http://reference.wolfram.com/language/ref/GeoGraphics.html">GeoGraphics</a></tt>, with waypoints specified by geo positions. <tt><a href="http://reference.wolfram.com/language/ref/ByteArray.html">ByteArray</a></tt> now supports the “corner case” of zero-length byte arrays. The compiler can now handle byte array functions, and additional string functions. Nearly 40 additional special functions can now handle numeric interval computations. <tt><a href="http://reference.wolfram.com/language/ref/BarcodeImage.html">BarcodeImage</a></tt> adds support for UPCE and Code93 barcodes. <tt><a href="http://reference.wolfram.com/language/ref/SolidMechanicsPDEComponent.html">SolidMechanicsPDEComponent</a></tt> adds support for the <a href="https://en.wikipedia.org/wiki/Yeoh_hyperelastic_model" target="_blank" rel="noopener">Yeoh hyperelastic model</a>. And—twenty years after we first introduced export of SVG, there’s now built-in support for import of SVG not only to raster graphics, but also to vector graphics.</p>
<p>There are new “utility” functions like <a href="https://reference.wolfram.com/language/ref/RealValuedNumberQ.html"><tt>RealValuedNumberQ</tt></a> and <a href="https://reference.wolfram.com/language/ref/RealValuedNumericQ.html"><tt>RealValuedNumericQ</tt></a>. There’s a new function <a href="https://reference.wolfram.com/language/ref/FindImageShapes.html"><tt>FindImageShapes</tt></a> that begins the process of systematically finding geometrical forms in images. There are a number of new data structures—like <a href="https://reference.wolfram.com/language/ref/datastructure/SortedKeyStore"><tt>&#34;SortedKeyStore&#34;</tt></a> and <a href="https://reference.wolfram.com/language/ref/datastructure/CuckooFilter"><tt>&#34;CuckooFilter&#34;</tt></a>. </p>
<p>There are also functions whose algorithms—and output—have been improved. <tt><a href="http://reference.wolfram.com/language/ref/ImageSaliencyFilter.html">ImageSaliencyFilter</a></tt> now uses new machine-learning-based methods. <tt><a href="http://reference.wolfram.com/language/ref/RSolveValue.html">RSolveValue</a></tt> gives cleaner and smaller results for the important case of linear difference equations with constant coefficients.</p>


        </div></div>
  </body>
</html>
