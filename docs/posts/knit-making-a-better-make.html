<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zyedidia.github.io/blog/posts/3-knit-better-make/">Original</a>
    <h1>Knit: Making a Better Make</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>This article is about a new build tool I’ve been working on called
Knit. Check it out on <a href="https://github.com/zyedidia/knit">GitHub</a>!</p>

<p>This might be surprising but I actually like Make overall. It has a concise
syntax for declaring dependencies, and it doesn’t make any assumptions about
the programs I am building. These are the two biggest factors I consider when
looking for a replacement, and so far I haven’t found any build systems that
manage to keep Make’s core simplicity while improving on it<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> <sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>
<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>.</p>
<p>And there are definitely some things about Make that could be improved. Here
are my biggest inconveniences:</p>
<ol>
<li>Make’s rules don’t have implicit dependencies on their recipes. This means
that if a recipe changes, the rule doesn’t necessarily get rebuilt. I like to
use Make variables to control various flags, and changing a variable at the
command-line<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> doesn’t cause the modified rules to be rebuilt.
Instead Make tells me “nothing to do”, and then I have to use <code>make -B</code>. One
solution is to have the Makefile generate a stamp file that contains the
commands that were run, and use that file as a dependency for the rules. In my
experience this can easily become a complicated mess and is annoying to set up.</li>
<li>Make’s declarative rule syntax is good, but the meta-programming language
around it isn’t so good. I can never remember how to define/call a function
in Make. It just doesn’t stack up to a normal scripting language with features
like modules, loops, arrays/maps, a standard library etc…</li>
<li>Sub-builds in Make are usually done by putting a <code>Makefile</code> in a
sub-directory and then invoking it using <code>make -C subdir</code> with a rule that is
always out-of-date (so it always gets run). This is a clever mechanism, but
it fractures the build into multiple Make processes, each of which is not
fully aware of the build. As a result, Make needs things like the Job Server
(shared across multiple processes) to prevent it from spawning too many
jobs, and it isn’t possible for one Make process to know the entire
dependency graph (for example, to display it). There is also the unfortunate
consequence that sub-builds get spawned even if they are up-to-date, which
can slow down incremental builds.</li>
</ol>
<p>There are also some more minor inconveniences when working with Make:</p>
<ul>
<li>Built-in variables have strange names like <code>$@</code>, <code>$&lt;</code>, <code>$^</code>.</li>
<li>Makefiles require you to use tabs.</li>
<li>It isn’t possible to get information about the build graph, like dumping it
to a file. For example, Make could be able to automatically dump a
<code>compile_commands.json</code>.</li>
<li>I have to write my own clean functions, even though Make could know what
files need to be cleaned.</li>
<li>I have to use hacks like <code>.PHONY</code> to mark rules as virtual.</li>
<li>I can’t run <code>make</code> from anywhere in my project – I have to be at the root
(or wherever the Makefile is).</li>
</ul>

<p>After identifying the issues I was having with Make, I set out to make a tool
like Make but better. The result is <a href="https://github.com/zyedidia/knit">Knit</a>.
Knit keeps the concise declarative rule syntax that Make uses (with the
addition of rule attributes – an idea from Plan9 mk), but allows it to be
embedded within a Lua script and generally improves the build environment.
Sub-builds can be handled without spawning separate sub-processes, rules depend
on their recipes (tracked in the Knit cache<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>), and all the minor
inconveniences are fixed (normal variable names, automatic cleaning, rules
marked as virtual using an attribute, run <code>knit</code> from anywhere in the project,
can dump build information such as <code>compile_commands.json</code>).</p>
<p>There are also some other small improvements over Make: Knit runs jobs in
parallel by default (using up to the number of cores on your machine), and can
use a hash-based file modification checker or a timestamp-based one (and can
also be passed a list of files in flags that should be treated as updated).</p>
<p>So far I have been pretty happy with Knit. Hopefully it will be useful for
someone else as well! Knit is currently in beta, and I plan to release an
initial stable version in the next few months. If you have feedback on the
design, please let me know! I might be able to make changes based on your
feedback.</p>

<p>Let’s look at an example Knitfile. It should look quite familiar if you use
Make.</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>return</span> b{
</span></span><span><span>    <span>$</span> foo.o: foo.c
</span></span><span><span>        gcc <span>-</span>c <span>-</span>O2 <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>    <span>$</span> foo: foo.o
</span></span><span><span>        gcc <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>}
</span></span></code></pre></div><p>Knit uses roughly the same syntax for rules as Make. However, rules are defined
within a Lua script, and use the <code>$</code> prefix to differentiate them from standard
Lua code. In order to run a build, a Knitfile must return a buildset object,
which is created by calling the <code>b</code> function and passing it a table of rules.
Buildsets are explained in more detail in a later
<a href="#buildsets-and-rulesets">section</a>.</p>
<p>This post will explain how to use Knit, but please also refer to the
<a href="https://github.com/zyedidia/knit/blob/master/docs/knit.md">documentation</a> for
all the up-to-date details.</p>
<h2 id="whats-in-a-rule">What’s in a rule?</h2>
<p>This Knitfile defines two rules: one for building <code>foo.o</code> given <code>foo.c</code>, and
another for building <code>foo</code> given <code>foo.o</code>. Each rule defines a list of outputs
(or targets) and a list of inputs (or prerequisites). In this case, each rule
has one input and one output. These rules also each define a recipe, which is a
shell command that is invoked to create the outputs from the inputs. The
special variables <code>input</code> and <code>output</code> are defined in the recipe and hold the
list of targets and prerequisites (equivalent to Make’s <code>$^</code> and <code>$@</code>
variables).</p>
<p>Running <code>knit foo</code> in a directory with a file called <code>foo.c</code> will run</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ knit foo
</span></span><span><span>gcc -c -O2 foo.c -o foo.o
</span></span><span><span>gcc foo.o -o foo
</span></span></code></pre></div><p>Knit creates the build graph – determining that to build <code>foo</code> it must first
build <code>foo.o</code>, which can be built because <code>foo.c</code> exists.</p>
<p>
<img src="https://rfong.github.io/rflog/2023/04/04/img/3/foo-build.svg" width="500"/>
</p>
<p>(In this graph, <code>:build</code> is a special internal rule used as the root of the
build).</p>
<p>If you run <code>knit foo</code> again, it will say no work needs to be done because it
can tell that neither <code>foo.c</code> nor <code>foo.o</code> have been modified. If you modify a
file in the build graph, it will detect the modification and rebuild all
dependent rules (Knit can use either a timestamp or content-based technique to
detect the modification). This is all the same as Make (except Make only uses
timestamps).</p>
<p>Now if you change the <code>foo</code> rule to <code>gcc -O2 $input -o $output</code> and rebuild,
you’ll see that just that rule re-runs. This is because Knit rules have an
implicit dependency on their recipes.</p>
<p>Running <code>knit</code> on its own will run the first rule (in this case it will build
<code>foo.o</code> and then stop).</p>
<h2 id="rule-attributes">Rule attributes</h2>
<p>The general syntax for a rule is</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>targets:attributes: prerequisites
</span></span><span><span>    recipe
</span></span></code></pre></div><p>Note: within a Knitfile (which is a Lua program), a rule must be preceded by a
<code>$</code>.</p>
<p>The rule syntax is the same as Make except for the addition of the optional
attributes.  Attributes can specify additional information about the rule. For
example, the <code>V</code> attribute specifies that the rule is “virtual” and the target
is the name of the rule and not an output file.</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>return</span> b{
</span></span><span><span>    <span>$</span> build:V: foo
</span></span><span><span>
</span></span><span><span>    <span>$</span> foo.o: foo.c
</span></span><span><span>        gcc <span>-</span>c <span>-</span>O2 <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>    <span>$</span> foo: foo.o
</span></span><span><span>        gcc <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>}
</span></span></code></pre></div><p>Another useful attribute is <code>B</code>, which forces a rule to always be out-of-date.
I often use <code>VB</code> to make a virtual rule that always gets rebuilt.</p>
<h2 id="adding-build-options">Adding build options</h2>
<p>Next we might like to configure the rules to use some pre-defined variables. We
can define a variable for the C compiler so that we can easily switch between
using <code>gcc</code> and <code>clang</code>:</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>local</span> cc <span>=</span> <span>&#34;gcc&#34;</span>
</span></span><span><span>
</span></span><span><span><span>return</span> b{
</span></span><span><span>    <span>$</span> build:V: foo
</span></span><span><span>    <span>$</span> foo.o: foo.c
</span></span><span><span>        <span>$</span>cc <span>-</span>c <span>-</span>O2 <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>    <span>$</span> foo: foo.o
</span></span><span><span>        <span>$</span>cc <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>}
</span></span></code></pre></div><p>This lets us change the C compiler, but isn’t modifiable from the command-line.
In Knit, the <code>cli</code> table has entries for all variables passed at the command-line
of the form <code>var=value</code>. So for <code>cc</code> we can re-define it as</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>local</span> cc <span>=</span> cli.cc <span>or</span> <span>&#34;gcc&#34;</span>
</span></span></code></pre></div><p>Note: the <code>env</code> table similar contains entries for all defined environment
variables.</p>
<p>Now we can run</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ knit cc=gcc
</span></span><span><span>gcc -c -O2 foo.c -o foo.o
</span></span><span><span>gcc foo.o -o foo
</span></span><span><span>$ knit cc=clang
</span></span><span><span>clang -c -O2 foo.c -o foo.o
</span></span><span><span>clang foo.o -o foo
</span></span></code></pre></div><p>Notice that it automatically rebuilds the appropriate rules when the variable
is changed. Big win over Make!</p>
<p>We can add another configuration option: <code>debug</code>, which controls the
optimization flags.</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>local</span> conf <span>=</span> {
</span></span><span><span>    cc <span>=</span> cli.cc <span>or</span> <span>&#34;gcc&#34;</span>,
</span></span><span><span>    debug <span>=</span> tobool(cli.debug) <span>or</span> <span>false</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>local</span> cflags :<span>=</span> <span>-</span>Wall
</span></span><span><span>
</span></span><span><span><span>if</span> conf.debug <span>then</span>
</span></span><span><span>    cflags :<span>=</span> <span>$</span>cflags <span>-</span>Og <span>-</span>g <span>-</span>fsanitize<span>=</span>address
</span></span><span><span><span>else</span>
</span></span><span><span>    cflags :<span>=</span> <span>$</span>cflags <span>-</span>O2
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>return</span> b{
</span></span><span><span>    <span>$</span> build:V: foo
</span></span><span><span>    <span>$</span> foo.o: foo.c
</span></span><span><span>        <span>$</span>cc <span>$</span>cflags <span>-</span>c <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>    <span>$</span> foo: foo.o
</span></span><span><span>        <span>$</span>cc <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>}
</span></span></code></pre></div><p>This uses some new syntax: the <code>:=</code> definition. This is not a standard operator
in Lua, but is supported in Knit’s Lua. It defines a string, where the contents
is the rest of the line. It also automatically does string interpolation. This
gives nice syntactic sugar for declaring strings that is similar to Make.</p>
<p>Now we can run <code>knit debug=1</code> to build in debug mode, and Knit will automatically
detect the rules that have had their flags changed and rerun them!</p>

<p>Meta-rules are rules that specify a pattern for generating other rules. In Knit
(and in Make), they are rules with a <code>%</code> symbol. The <code>%</code> is a wildcard that can
match any characters, and if there is a match for a target that needs to be
built, the tool will instantiate a concrete rule for the particular target.</p>
<p>Here is a meta-rule for building object files from C files:</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>%.o: %.c
</span></span><span><span>    gcc -c $input -o $output
</span></span></code></pre></div><p>If the tool is looking for rules that build <code>foo.o</code>, this one will match and it
will be instantiated into the concrete rule:</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>foo.o: foo.c
</span></span><span><span>    gcc -c $input -o $output
</span></span></code></pre></div><p>The special variable <code>$match</code> will also be available to the recipe as the
string that matched the <code>%</code> wildcard.</p>
<p>Now we can upgrade our Knitfile to easily handle multiple C source files.</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>local</span> conf <span>=</span> {
</span></span><span><span>    cc <span>=</span> cli.cc <span>or</span> <span>&#34;gcc&#34;</span>,
</span></span><span><span>    debug <span>=</span> tobool(cli.debug) <span>or</span> <span>false</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>local</span> cflags :<span>=</span> <span>-</span>Wall
</span></span><span><span>
</span></span><span><span><span>if</span> conf.debug <span>then</span>
</span></span><span><span>    cflags :<span>=</span> <span>$</span>cflags <span>-</span>Og <span>-</span>g <span>-</span>fsanitize<span>=</span>address
</span></span><span><span><span>else</span>
</span></span><span><span>    cflags :<span>=</span> <span>$</span>cflags <span>-</span>O2
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>local</span> knit <span>=</span> require(<span>&#34;knit&#34;</span>)
</span></span><span><span><span>local</span> src <span>=</span> knit.glob(<span>&#34;*.c&#34;</span>)
</span></span><span><span><span>local</span> obj <span>=</span> knit.extrepl(src, <span>&#34;.c&#34;</span>, <span>&#34;.o&#34;</span>)
</span></span><span><span><span>-- name of the final binary</span>
</span></span><span><span><span>local</span> prog :<span>=</span> prog
</span></span><span><span>
</span></span><span><span><span>return</span> b{
</span></span><span><span>    <span>$</span> <span>$</span>prog: <span>$</span>obj
</span></span><span><span>        <span>$</span>(conf.cc) <span>$</span>cflags <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>    <span>$</span> <span>%</span>.o: <span>%</span>.c
</span></span><span><span>        <span>$</span>(conf.cc) <span>$</span>cflags <span>-</span>c <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>}
</span></span></code></pre></div><p>This required using some helper functions from the <code>knit</code> package:</p>
<ul>
<li><code>glob</code>: returns a table of all files that match the glob.</li>
<li><code>extrepl</code>: replaces extensions. In this case replacing <code>.c</code> file suffixes
with <code>.o</code>.</li>
</ul>

<p>The Knitfile is now relatively complete for building small C projects. One
problem is that it currently doesn’t take into account header file
dependencies. If a C source file includes a header file, Knit is not aware that
a change to the header file should cause a rebuild of all C files that included
it. Automatically determining what files were included is a bit
impractical<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>. Luckily C compilers provide flags to have them automatically
output dependency files in the Make rule format that describe all the files that
a compiled source code file depends on. Knit’s rule syntax is similar enough to
Make that these files are natively compatible with Knit’s rule parser.</p>
<p>Try setting this up:</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ ls
</span></span><span><span>foo.c foo.h
</span></span><span><span>$ cat foo.c
</span></span><span><span>#include foo.h
</span></span><span><span>$ gcc -c foo.c -I. -MMD
</span></span><span><span>$ ls
</span></span><span><span>foo.c foo.d foo.h
</span></span><span><span>$ cat foo.d
</span></span><span><span>foo.o: foo.c foo.h
</span></span></code></pre></div><p>The <code>-MMD</code> flag is the special flag that asks it to create a <code>.d</code> dependency
file. This file accurately describes that <code>foo.o</code> needs to be rebuilt if
<code>foo.c</code> <em>or</em> <code>foo.h</code> changes.</p>
<p>So we just need to get Knit to include this <code>.d</code> file as an extra set of rules.
You could manually do this using the <code>rulefile</code> function that reads rules from
an external file, but more convenient for this use-case is the <code>D</code> attribute.</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ %.o:D[%.d]: %.c
</span></span><span><span>    $(conf.cc) $cflags -MMD -c $input -o $output
</span></span></code></pre></div><p>This informs Knit that this command creates a <code>.d</code> dependency file, and the
rules within it should be included in the build.</p>
<p>The final Knitfile for small C projects looks like this:</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>local</span> conf <span>=</span> {
</span></span><span><span>    cc <span>=</span> cli.cc <span>or</span> <span>&#34;gcc&#34;</span>,
</span></span><span><span>    debug <span>=</span> tobool(cli.debug) <span>or</span> <span>false</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>local</span> cflags :<span>=</span> <span>-</span>Wall
</span></span><span><span>
</span></span><span><span><span>if</span> conf.debug <span>then</span>
</span></span><span><span>    cflags :<span>=</span> <span>$</span>cflags <span>-</span>Og <span>-</span>g <span>-</span>fsanitize<span>=</span>address
</span></span><span><span><span>else</span>
</span></span><span><span>    cflags :<span>=</span> <span>$</span>cflags <span>-</span>O2
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>local</span> knit <span>=</span> require(<span>&#34;knit&#34;</span>)
</span></span><span><span><span>local</span> src <span>=</span> knit.glob(<span>&#34;*.c&#34;</span>)
</span></span><span><span><span>local</span> obj <span>=</span> knit.extrepl(src, <span>&#34;.c&#34;</span>, <span>&#34;.o&#34;</span>)
</span></span><span><span><span>-- name of the final binary</span>
</span></span><span><span><span>local</span> prog :<span>=</span> prog
</span></span><span><span>
</span></span><span><span><span>return</span> b{
</span></span><span><span>    <span>$</span> <span>$</span>prog: <span>$</span>obj
</span></span><span><span>        <span>$</span>(conf.cc) <span>$</span>cflags <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>    <span>$</span> <span>%</span>.o:D[<span>%</span>.d]: <span>%</span>.c
</span></span><span><span>        <span>$</span>(conf.cc) <span>$</span>cflags <span>-</span>MMD <span>-</span>c <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>}
</span></span></code></pre></div><p>With the files <code>foo.c</code>, <code>foo.h</code> (included by <code>foo.c</code>), and <code>bar.c</code>, this
Knitfile would create the following build graph:</p>
<p>
<img src="https://rfong.github.io/rflog/2023/04/04/img/3/c-hdep.svg" width="500"/>
</p>

<p>Knit (taking inspiration from Plan9 mk) takes meta-rules to the next level with
regular expression rules. Instead of having one wildcard (<code>%</code>), a regular
expression rule uses an arbitrary regex with capture groups. It must be marked
with the <code>R</code> attribute.</p>
<p>We can re-create normal meta-rules with regex rules:</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>(.*)\.o:R: $1.c
</span></span><span><span>    gcc -c $input -o $output
</span></span></code></pre></div><p>Not as pretty as meta-rules, so it makes good sense to have both (given how
common meta-rules are). The power of regex rules shines through when trying
to do something a bit more complex, so let’s try that.</p>
<p>Note: The matched groups are available in the recipe as <code>$match1</code>, <code>$match2</code>,
<code>$match3</code>, …</p>
<h2 id="example-knitfile-for-go">Example Knitfile for Go</h2>
<p>When writing a Go program, I often want to be able to build it for many
different operating systems and architectures. I do this when preparing a
release, to build pre-built binaries for many different systems.</p>
<p>This becomes easy to do with regex rules:</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>-- name of the program</span>
</span></span><span><span>name :<span>=</span> foo
</span></span><span><span>
</span></span><span><span><span>local</span> systems <span>=</span> {
</span></span><span><span>    f<span>&#34;$name-linux-amd64&#34;</span>,
</span></span><span><span>    f<span>&#34;$name-linux-386&#34;</span>,
</span></span><span><span>    f<span>&#34;$name-linux-arm&#34;</span>,
</span></span><span><span>    f<span>&#34;$name-linux-arm64&#34;</span>,
</span></span><span><span>    f<span>&#34;$name-darwin-amd64&#34;</span>,
</span></span><span><span>    f<span>&#34;$name-darwin-arm64&#34;</span>,
</span></span><span><span>    f<span>&#34;$name-openbsd-amd64&#34;</span>,
</span></span><span><span>    f<span>&#34;$name-freebsd-amd64&#34;</span>,
</span></span><span><span>    f<span>&#34;$name-windows-amd64&#34;</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>return</span> b{
</span></span><span><span>    <span>$</span> build:VB: <span>$</span>systems
</span></span><span><span>
</span></span><span><span>    <span>$</span> (<span>$</span>name<span>-</span>(.<span>*</span>)<span>-</span>(.<span>*</span>)):RB:
</span></span><span><span>        GOOS<span>=</span><span>$</span>match2 GOARCH<span>=</span><span>$</span>match3 go build <span>-</span>o <span>$</span>match1
</span></span><span><span>}
</span></span></code></pre></div><p>Note: the <code>f</code> function performs string interpolation on its input.</p>
<p>Running <code>knit build</code> will build for all systems at once in parallel.</p>
<p>
<img src="https://rfong.github.io/rflog/2023/04/04/img/3/go-knitfile.svg" width="300"/>
</p>
<p>At this point you’ve seen a good overview of the basic features Knit provides.
The rest of this article will dive into more details, such as how Knit
interacts with the file structure of your project, some of Knit’s more advanced
Lua capabilities (e.g., using packages to organize builds), sub-builds and
modularity, and Knit’s sub-tools (automatic cleaning and build conversion).</p>

<p>When invoked, Knit will search up the direcotry hierarchy for a file called
<code>Knitfile</code> (or <code>knitfile</code>). This means if you project root has a Knitfile, you
can be anywhere in the directory structure of your project and run <code>knit</code> to
build it. Knit will automatically change directories when it runs commands so
that they are run from the appropriate location. If you are in a sub-directory,
any target you request will first be automatically prepended with the directory.</p>
<p>Consider the following Knitfile:</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>return</span> b{
</span></span><span><span>    <span>$</span> build:VB: foo<span>/</span>foo.txt
</span></span><span><span>    <span>$</span> foo<span>/</span>foo.txt:B:
</span></span><span><span>        echo <span>&#34;foo&#34;</span> <span>&gt;</span> <span>$</span>output
</span></span><span><span>}
</span></span></code></pre></div><p>If you are in <code>foo/</code>, with <code>Knitfile</code> placed in the parent directory, when you
run <code>knit foo.txt</code> the Knit subprocess will move to the parent directory and
run <code>knit foo/foo.txt</code>. Additionally, if the target <code>foo/X</code> does not exist,
Knit will try <code>X</code> as a fallback. In this example, running <code>knit build</code> from
inside <code>foo/</code> would still succeed: first it would try <code>knit foo/build</code>, but
since that doesn’t exist it would run <code>knit build</code> from the root.</p>

<p>So far I’ve mostly just explained the rule syntax that Knit uses without
dicussing much about the surrounding Lua system. Every Knitfile is a Lua 5.1
program that ultimately returns a buildset object (consisting of a table of
rules), or a string (which will be displayed as an error message). Since a
Knitfile is just a Lua program, it can use any normal Lua construct – <code>if</code>
statements, loops, functions, tables, packages, etc. and the syntax is easy to
remember. The Lua standard library is available, along with a special <code>knit</code>
package providing convenience functions for things like extension replacement,
globs, and running shell commands. There are also several built-in functions
such as <code>rule</code> (creates a Knit rule directly from a Lua string), <code>tobool</code>
(converts a string to a boolean) and more. See the
<a href="https://github.com/zyedidia/knit/blob/master/docs/knit.md#built-in-lua-functions">documentation</a>
for the full details. One interesting example is the <code>rule</code> built-in, which
generates a rule object from a string, allowing you to generate rules at
runtime using Lua.</p>
<h2 id="buildsets-and-rulesets">Buildsets and rulesets</h2>
<p>A buildset is a list of rules associated with a directory. A buildset is
created with the <code>b</code> function (<code>b{...}</code> invokes <code>b</code> and passes in the table
<code>{...}</code>). By default the directory is the current directory of the Knit
process. You may also pass a directory in as a second argument: <code>b({...}, dir)</code>. All commands in the buildset will be invoked from within the directory
<code>dir</code>. The table passed to <code>b</code> may contain rules, other buildsets, tables of
rules, or rulesets. You may also use the <code>+</code> operator to concatenate buildsets
together. The resulting buildset will use the first buildset’s directory. The
real power gained by having buildsets is explained more in the next section on
sub-builds.</p>
<p>A ruleset is just a list of rules, created with the <code>r</code> function. It is the
same as a buildset but has no associated directory. The main difference between
a ruleset and a normal table of rules is that the <code>+</code> operator may be used to
combine rulesets.</p>
<h2 id="example-c-module">Example: C module</h2>
<p>I like to use the Lua module system to make modules for building certain types
of files. For example, I might have a <code>build/c.knit</code> in a project that has definitions
for building C files:</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>local</span> c <span>=</span> {}
</span></span><span><span>
</span></span><span><span><span>function</span> <span>c</span>.<span>toolchain</span>(prefix)
</span></span><span><span>    <span>local</span> prefix <span>=</span> prefix <span>or</span> <span>&#34;&#34;</span>
</span></span><span><span>    <span>return</span> {
</span></span><span><span>        cc :<span>=</span> <span>$</span>(prefix)gcc
</span></span><span><span>        as :<span>=</span> <span>$</span>(prefix)as
</span></span><span><span>        ld :<span>=</span> <span>$</span>(prefix)ld
</span></span><span><span>        objcopy :<span>=</span> <span>$</span>(prefix)objcopy
</span></span><span><span>        objdump :<span>=</span> <span>$</span>(prefix)objdump
</span></span><span><span>    }
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>function</span> <span>c</span>.<span>rules</span>(tools, flags)
</span></span><span><span>    <span>return</span> r{
</span></span><span><span>        <span>$</span> <span>%</span>.o: <span>%</span>.c
</span></span><span><span>            <span>$</span>(tools.cc) <span>$</span>(flags.cc) <span>-</span>c <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>        <span>$</span> <span>%</span>.o: <span>%</span>.s
</span></span><span><span>            <span>$</span>(tools.as) <span>$</span>(flags.as) <span>-</span>c <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>        <span>$</span> <span>%</span>.bin: <span>%</span>.elf
</span></span><span><span>            <span>$</span>(tools.objcopy) <span>$</span>input <span>-</span>O binary <span>$</span>output
</span></span><span><span>        <span>$</span> <span>%</span>.list: <span>%</span>.elf
</span></span><span><span>            <span>$</span>(tools.objdump) <span>-</span>D <span>$</span>input <span>&gt;</span> <span>$</span>output
</span></span><span><span>        <span>$</span> <span>%</span>.mem: <span>%</span>.bin
</span></span><span><span>            hexdump <span>-</span>v <span>-</span>e <span>&#39;1/4 &#34;%08x</span><span>\n</span><span>&#34;&#39;</span> <span>$</span>input <span>&gt;</span> <span>$</span>output
</span></span><span><span>    }
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>function</span> <span>c</span>.<span>libgcc</span>(cc, cflags)
</span></span><span><span>    <span>local</span> knit <span>=</span> require(<span>&#34;knit&#34;</span>)
</span></span><span><span>    <span>return</span> knit.shell(f<span>&#34;$cc $cflags --print-file-name=libgcc.a&#34;</span>)
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>return</span> c
</span></span></code></pre></div><p>Then from the main Knitfile this can be imported and used with:</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>local</span> c <span>=</span> dofile(<span>&#34;build/c.knit&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>local</span> tools <span>=</span> c.toolchain(<span>&#34;riscv64-unknown-elf-&#34;</span>)
</span></span><span><span><span>local</span> flags <span>=</span> {
</span></span><span><span>    cc :<span>=</span> <span>-</span>O2 <span>-</span>Wall <span>-</span>march<span>=</span>rv64gc <span>-</span>mabi<span>=</span>lp64d <span>-</span>mcmodel<span>=</span>medany
</span></span><span><span>    as :<span>=</span> <span>-</span>march<span>=</span>rv64gc <span>-</span>mabi<span>=</span>lp64d
</span></span><span><span>}
</span></span><span><span><span>local</span> rules <span>=</span> c.rules(tools, flags)
</span></span><span><span>
</span></span><span><span><span>return</span> b{
</span></span><span><span>    <span>-- rule to build the ELF file</span>
</span></span><span><span>    <span>$</span> prog.elf: foo.o bar.o
</span></span><span><span>        <span>$</span>(tools.cc) <span>$</span>(flags.cc) <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>
</span></span><span><span>    <span>-- rules included from the C module</span>
</span></span><span><span>    rules
</span></span><span><span>}
</span></span></code></pre></div><p>This sets up some rules for doing RISC-V cross compilation, but it’s also very
easy to reuse the C module to generate rules for a different architecture.</p>
<p>In the future, Knit might even have a standard library of modules for building
various kinds of languages, or language developers could maintain a Knit module
for building files of that language.</p>

<p>Sometimes it’s useful to have parts of a system built in a sub-directory as a
more separate or independent build. For example, a program might contain a
library <code>libfoo</code> that gets built within the <code>foo/</code> directory, and the rules
to build <code>libfoo</code> are independent from the rest of the build.</p>
<p>Make allows for sub-builds by using the <code>-C</code> flag, which invokes Make after
changing into a specified directory. This isn’t a great mechanism because
it spawns a separate process per sub-build. The main problems that I see
as a result are that:</p>
<ol>
<li>No single process has a full view of the build (making it difficult to do
build analysis like auto-cleaning, or compilation database generation).</li>
<li>Limiting the number of parallel jobs involves inter-process communication
(the Make Jobserver).</li>
</ol>
<p>Knit still allows you to use <code>-C</code>, but has another method for handling
sub-builds as well that keeps the build unified. The method is to use multiple
buildsets, where the sub-build uses a buildset with the directory set to that
of the sub-project.</p>
<p>For example:</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>-- this buildset is relative to the &#34;libfoo&#34; directory</span>
</span></span><span><span><span>local</span> foorules <span>=</span> b({
</span></span><span><span>    <span>$</span> foo.o: foo.c
</span></span><span><span>        gcc <span>-</span>c <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>}, <span>&#34;libfoo&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>return</span> b{
</span></span><span><span>    <span>$</span> prog.o: prog.c
</span></span><span><span>        gcc <span>-</span>c <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>    <span>-- libfoo/foo.o is automatically resolved to correspond to the rule in foorules</span>
</span></span><span><span>    <span>$</span> prog: prog.o libfoo<span>/</span>foo.o
</span></span><span><span>        gcc <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>
</span></span><span><span>    <span>-- include the foorules buildset</span>
</span></span><span><span>    foorules
</span></span><span><span>}
</span></span></code></pre></div><p>This Knitfile assumes the build consists of <code>prog.c</code> and <code>libfoo/foo.c</code>. It
builds <code>libfoo/foo.o</code> using a sub-build and automatically determines that
the <code>foorules</code> buildset contains the rule for building <code>libfoo/foo.o</code>. Note
that the recipe for <code>foo.o</code> is run in the <code>libfoo</code> directory.</p>
<p>It is also useful to combine sub-builds with the <code>include(x)</code> function, which
runs the knit program <code>x</code> from the directory where it exists, and returns the
value that <code>x</code> produces. This means you can easily use a sub-directory’s
Knitfile to create a buildset for use in a sub-build (remember that the default
directory for a buildset is the directory of the Knit process when the buildset
is created).</p>
<p>For example, for the previous build we could use the following file system
structure:</p>
<p><code>libfoo/build.knit</code> contains:</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>-- this buildset&#39;s directory will be the current working directory</span>
</span></span><span><span><span>return</span> b{
</span></span><span><span>    <span>$</span> foo.o: foo.c
</span></span><span><span>        gcc <span>-</span>c <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>}
</span></span></code></pre></div><p><code>Knitfile</code> contains:</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>return</span> b{
</span></span><span><span>    <span>$</span> prog.o: prog.c
</span></span><span><span>        gcc <span>-</span>c <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>    <span>-- libfoo/foo.o is automatically resolved to correspond to the rule in foorules</span>
</span></span><span><span>    <span>$</span> prog: prog.o libfoo<span>/</span>foo.o
</span></span><span><span>        gcc <span>$</span>input <span>-</span>o <span>$</span>output
</span></span><span><span>
</span></span><span><span>    <span>-- include the libfoo rules: this will change directory into libfoo, execute</span>
</span></span><span><span>    <span>-- build.knit, and change back to the current directory, thus giving us a buildset</span>
</span></span><span><span>    <span>-- for the libfoo directory automatically</span>
</span></span><span><span>    include(<span>&#34;libfoo/build.knit&#34;</span>)
</span></span><span><span>}
</span></span></code></pre></div><p>Note that since knit looks upwards for the nearest Knitfile, you can run <code>knit foo.o</code> from inside <code>libfoo</code>, and knit will correctly build <code>libfoo/foo.o</code>.</p>
<p>Since managing the current working directory is important for easily creating
buildsets that automatically reference the correct directory, there are several
functions for this:</p>
<ul>
<li><code>include(x)</code>: runs a Lua file from the directory where it exists.</li>
<li><code>dcall(fn, args)</code>: calls a Lua function from the directory where it is defined.</li>
<li><code>dcallfrom(dir, fn, args)</code>: calls a Lua function from a specified directory.</li>
<li><code>rel(files)</code>: makes all input files relative to the build’s root directory.</li>
</ul>
<p>Note that since a Knitfile must return a buildset, Knitfiles that are not built
with sub-builds in mind can still be included in a larger project as a
sub-build without modification (just use <code>include(&#34;foo/Knitfile&#34;)</code>).</p>
<p>I think sub-builds are the area where Knit is the most different from Make, and
also the area where the design is least explored. I would be interested in
hearing feedback on this and on trying out other designs.</p>

<p>Knit has a set of sub-tools (inspired by Ninja’s sub-tools), which are small
tools that run on the build graph instead of actually executing a build. They
are invoked by running <code>knit -t TOOL</code>. The full list is displayed by the <code>list</code>
tool:</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ knit -t list
</span></span><span><span>list - list all available tools
</span></span><span><span>graph - print build graph in specified format: text, tree, dot, pdf
</span></span><span><span>clean - remove all files produced by the build
</span></span><span><span>targets - list all targets (pass &#39;virtual&#39; for just virtual targets, pass &#39;outputs&#39; for just output targets)
</span></span><span><span>compdb - output a compile commands database
</span></span><span><span>commands - output the build commands (formats: knit, json, make, ninja, shell)
</span></span><span><span>status - output dependency status information
</span></span><span><span>path - return the path of the current knitfile
</span></span></code></pre></div><h2 id="automatic-cleaning">Automatic cleaning</h2>
<p>Whenever Knit executes a rule, it records the name of the output file into the
Knit cache. The <code>clean</code> tool iterates through all these files and removes them.
Running <code>knit -t clean</code> will remove all files that have ever been created by
the current Knitfile. No more need for <code>clean</code> rules.</p>
<h2 id="visualizing-the-build-graph">Visualizing the build graph</h2>
<p>One of the more fun tools is the <code>graph</code> tool, which can visualize the build
graph using graphviz. Here is the visualized build graph for
<a href="https://github.com/zyedidia/riscinator">Riscinator</a>, my small 3-stage pipeline
RISC-V processor written in Chisel<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup>.</p>
<p><img src="https://rfong.github.io/rflog/2023/04/04/img/3/riscinator.svg" alt="riscinator build graph"/></p>
<p>This build unifies a lot of different languages/tools which makes it really
impractical to use a build system meant for one particular language. It builds
the Chisel design into Verilog, and a blink program in C into the design’s
memory, and then synthesizes the overall design into a bitstream for a
particular FPGA.</p>
<p>Created with</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ knit synth -t graph pdf &gt; graph.pdf
</span></span></code></pre></div><h2 id="creating-a-compile_commandsjson">Creating a <code>compile_commands.json</code></h2>
<p>A compilation command database is a list of files and the associated commands
to build each file (usually stored in a file called <code>compile_commands.json</code>).
Some editors can automatically integrate with a compilation command database
and use the commands to build the current file being edited, providing
in-editor errors/warnings from the compiler. Some language servers also use the
compilation command database to function properly. This is especially common in
C/C++ because CMake can automatically emit a <code>compile_commands.json</code> file. You
can also generate one with Knit by using <code>knit -t compdb</code>. This will generate a
compilation command database involving all files built by the default target.
If you want to include all files built by all targets, use the special target
<code>:all</code>: <code>knit :all -t compdb</code>.</p>
<h2 id="converting-a-knit-build-to-a-shell-script">Converting a Knit build to a shell script</h2>
<p>The <code>commands</code> tool will output the build in a specified format. For example,
<code>shell</code> will output a shell script that builds the requested target. The
following example uses the Knitfile in <code>examples/c</code> (in the <code>zyedidia/knit</code>
repository).</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ knit hello -t commands shell
</span></span><span><span>gcc -Wall -O2 -c hello.c -o hello.o
</span></span><span><span>gcc -Wall -O2 -c other.c -o other.o
</span></span><span><span>gcc -Wall -O2 hello.o other.o -o hello
</span></span></code></pre></div><p>This outputs all the commands to build the <code>hello</code> target as a shell script.
Other formats are available as well: <code>knit</code>, <code>json</code>, <code>make</code>, and <code>ninja</code>. Note:
this outputs the commands for a specific instantiation of the build (all
variables and meta-rules have been resolved and expanded).</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ knit hello -t commands make
</span></span><span><span>hello: hello.o other.o
</span></span><span><span>	gcc -Wall -O2 hello.o other.o -o hello
</span></span><span><span>hello.o: hello.c
</span></span><span><span>	gcc -Wall -O2 -c hello.c -o hello.o
</span></span><span><span>other.o: other.c
</span></span><span><span>	gcc -Wall -O2 -c other.c -o other.o
</span></span></code></pre></div><p>The <code>shell</code> and <code>json</code> outputs are likely to be the most useful, and the <code>make</code>
and <code>ninja</code> outputs are more experimental.</p>

<p>Knit can use several styles to display your build. The default style is
<code>basic</code>, which prints each command that is executed (just like Make).</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ knit
</span></span><span><span>gcc -Wall -O2 -c hello.c -o hello.o
</span></span><span><span>gcc -Wall -O2 -c other.c -o other.o
</span></span><span><span>gcc -Wall -O2 hello.o other.o -o hello
</span></span></code></pre></div><p>There is also the <code>steps</code> style that shows the step count and displays the
name of the file being built.</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ knit -s steps
</span></span><span><span>[1/3] hello.o
</span></span><span><span>[2/3] other.o
</span></span><span><span>[3/3] hello
</span></span></code></pre></div><p>The third style is the <code>progress</code> style, that shows a progress bar as the
build is running.</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ knit -s progress
</span></span><span><span>Built hello  100% [================================================] (3/3)
</span></span></code></pre></div><p>There might be more styles in the future or the option for user-created styles,
but for now these are the three options. I generally like the <code>steps</code> style
the most and use that for my projects.</p>

<p>All options that can be configured at the command-line can also be configured
in a <code>.knit.toml</code> file. Knit will search up the directory hierarchy from the
current Knitfile looking for <code>.knit.toml</code> files, with closer config files
overwriting further ones. This allows you to put project-specific option
defaults in a <code>.knit.toml</code> in the root of your project, and your personal
option defaults in <code>~/.knit.toml</code>. The options overwritten in the project’s
<code>.knit.toml</code> will take precedence over those in <code>~/.knit.toml</code>. Even further
down the priority order, Knit will look in <code>~/.config/knit/.knit.toml</code>.</p>
<p>All the command-line flags have a TOML equivalent, so your <code>.knit.toml</code> might
be something like this if you prefer the <code>steps</code> style and timestamp-based
file modification detection:</p>
<h2 id="default-knitfile">Default Knitfile</h2>
<p>You can make a file called <code>~/.config/knit/knitfile.def</code>, and Knit will use
it as the current Knitfile if it cannot find one.</p>

<p>When developing a build system it is useful to verify its correctness by
running a large and complex build. Sadly there weren’t any huge projects using
Knit before it was created. However, some industry-scale projects use CMake and
Ninja, so if there were a way to convert a Ninja build file to Knit, then it
would be possible to build the project using Knit.</p>
<h2 id="converting-ninja-to-knit-or-using-knit-as-a-cmake-backend">Converting Ninja to Knit (or: using Knit as a CMake backend)</h2>
<p>There is a project called <a href="https://github.com/michaelforney/samurai">Samurai</a>,
which is a simpler re-implementation of the Ninja build system in C. It was
fairly easy to add a sub-tool to Samurai that could output the internal build
graph as a Knitfile, thus making it possible to convert a Ninja build file to a
Knitfile. The resulting tool is called
<a href="https://github.com/zyedidia/knitja">knitja</a>.</p>
<p>I wouldn’t really recommend regularly using Knit as a CMake backend (just use
Ninja), but doing this is still useful for testing the limits and correctness
of Knit.</p>
<h2 id="building-cvc5-with-knit">Building CVC5 with Knit</h2>
<p>Using <code>knitja</code>, it is possible to build the CVC5 SMT solver (a large C++
project) using Knit. Pretty cool!</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ git clone https://github.com/cvc5/cvc5
</span></span><span><span>$ ./configure.sh --auto-download --ninja
</span></span><span><span>$ cd build
</span></span><span><span>$ knitja &gt; Knitfile
</span></span><span><span>$ knit all -s steps
</span></span><span><span>[1/831] deps/src/CaDiCaL-EP-stamp/CaDiCaL-EP-mkdir
</span></span><span><span>[2/831] deps/src/Poly-EP-stamp/Poly-EP-mkdir
</span></span><span><span>[3/831] deps/src/SymFPU-EP-stamp/SymFPU-EP-mkdir
</span></span><span><span>[4/831] CMakeFiles/gen-versioninfo
</span></span><span><span>[5/831] src/base/Trace_tags.h
</span></span><span><span>[6/831] src/theory/type_enumerator.cpp
</span></span><span><span>[7/831] src/theory/theory_traits.h
</span></span><span><span>...
</span></span></code></pre></div><p>We can even visualize the build graph using the Knit sub-tool.</p>
<p><img src="https://rfong.github.io/rflog/2023/04/04/img/3/cvc5-graph.png" alt="cvc5 build graph"/></p>
<p>That’s a pretty big build graph! The Graphviz Dot file is 1.4MB.</p>
<p>You thought that was big? Now do LLVM next :-)</p>

<p>I am quite happy with the current form of Knit. It is serving me well as the
build system for several projects such as
<a href="https://github.com/zyedidia/multiplix">Multiplix</a>,
<a href="https://github.com/zyedidia/riscinator">Riscinator</a>, and Knit itself. I hope
to keep improving it, and release a stable version 1.0 in the next few months.
If you have feedback on the design please let me know and I might be able to
incorporate your suggestions! I’m hoping to continue fixing issues that I run
into, and maybe at some point in the future (after several stable releases)
think about some new features such as a global build cache, ptrace-based
dependency tracking, sandboxed builds, and better support for dynamic
dependencies. Let me know if you try out Knit and like/dislike parts of it!</p>
<p>Happy Knitting<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup>!</p>


</div></div>
  </body>
</html>
