<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://prettygoodblog.com/p/what-threads-are-part-2">Original</a>
    <h1>A toy RTOS inside Super Mario Bros. using emulator save states</h1>
    
    <div id="readability-page-1" class="page"><div><div dir="auto"><p><em>This is another post about programming, which I almost never write about.</em></p><p><em><a href="https://prettygoodblog.com/i/164506409/how-to-try-it" rel="">Click here</a><span> to jump straight to trying this thing out for yourself.</span></em></p><p><span>In my </span><a href="https://prettygoodblog.com/p/what-threads-are-and-how-to-use-them" rel="">previous post</a><span> on Threads, I made an offhand comparison</span><span>:</span></p><blockquote><p><span>Threads</span><span> are just emulator</span><span> save states</span><span>, coupled with a condition upon which they will be resumed.</span></p></blockquote><p><span>At the  time, I thought this a </span><em>pretty</em><span> </span><em>okay</em><span> analogy — but I couldn’t stop thinking about it. I’ve been turning it around in my mind for a while. I think it has serious untapped potential as a pedagogical tool. </span></p><p><span>So I added multithreading to </span><em>Super Mario Bros.</em><span> for the NES.</span></p><p>No buried ledes here. </p><p>I should explain myself. </p><p><span>What you just watched happens to be a multithreaded NES emulation, with </span><em>Super Mario Bros.</em><span> as the threads.</span></p><p>There are three “threads” running, each a distinct instance of the game. Every so often, the emulator switches “threads”, swapping to a different instance of the game. </p><p>Each “thread” is assigned a different color palette, which we apply when we resume said thread. This is why the colors are constantly changing around in the video.</p><p><span>When World 1-1 starts, the “multithreading” begins. Specifically, my script creates three </span><em>save states</em><span>, each representing the current state of the game</span><span>. Then I create three </span><em>threads</em><span>, and give them their respective save state to hold on to.</span></p><p>Then I start the thread scheduler.</p><p>The thread scheduler’s job is simple:</p><ul><li><p>Every 160 frames, switch to a new thread</p><ul><li><p>The next thread ideally, in a rotating fashion (1, 2, 3, 1, 2, 3, 1, …)</p></li><li><p><span>Skip over threads which are </span><em>KILLED</em><span>, </span><em>BLOCKED</em><span> (unless they can be unblocked), or </span><em>SLEEPING</em><span> (unless it’s time to wake them)</span></p></li></ul></li><li><p>To switch to a new thread:</p><ul><li><p><span>First, update the </span><em>current</em><span> thread’s save state with the current game state</span></p></li><li><p><span>Then, load in the </span><em>new</em><span> thread’s save state</span></p></li><li><p><span>Finally, update the </span><em>game color palette</em><span> to reflect which thread we’re on</span></p></li></ul></li></ul><p>This covers what you see for the first bit of the video: each thread starts at the same time (the loading screen for World 1-1), with different “games” being swapped in every so often. </p><p><span>Essentially, </span><em>three different games of Mario Bros.</em><span> are being played “at the same time”, but only one is actually </span><em>active</em><span> at any given time.</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png" width="1456" height="98" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/a90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:98,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:25155,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:&#34;https://prettygoodblog.com/i/164506409?img=https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png&#34;,&#34;isProcessing&#34;:false,&#34;align&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa90d8482-d5d3-4f54-a42b-29c46c727722_3584x240.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a><figcaption>This image shows the full World 1-1 map, with color-coded areas indicating various features explained below. I recommend clicking to expand this image.</figcaption></figure></div><p>Time slicing is cool — we’re running three “concurrent” games of Mario! — but that’s far from the only threading concept demonstrated here.</p><p><span>I’ve set up the game world in such a way that certain areas or features activate synchronization primitives (such as a mutex); you can </span><em>physically interact with threading boundaries</em><span>. </span></p><p><span>I describe the synchronization primitives I’ve set up below, but the </span><em>net effect</em><span> is:</span></p><ul><li><p><span>If a Mario is standing on the three blocks at the start of the level, no other Mario’s game will run until he leaves (</span><strong>Disabled Interrupts</strong><span>)</span></p></li><li><p><span>Only one Mario can be inside the Pipe Sub-level at a time (</span><strong>Mutex</strong><span>)</span></p><ul><li><p>If a Mario enters while another Mario is inside, his game will not resume until the other Mario leaves</p></li></ul></li><li><p><span>Once a Mario touches the flagpole, his game pauses until all the other Marios have touched their flagpoles (</span><strong>Condition Variables</strong><span>)</span></p></li></ul><p><span>The red shaded area on the map denotes a section of the world where </span><em>interrupts are disabled</em><span>, and therefore, the thread scheduler cannot run.</span></p><p>Whenever a Mario enters the red shaded area, his thread won’t lose control until he leaves the area, regardless of what other Marios are doing.</p><p><span>The yellow shaded area (difficult to discern — it’s the fourth pipe from the left; the one you can go down) demonstrates a </span><em>mutex</em><span>: an area of the game world where only one Mario may exist at a time.</span></p><p><span>When a Mario goes down the pipe, he tries to acquire the </span><em>pipeMutex</em><span>. If nothing else owns that mutex (i.e., no other thread is currently in the pipe sub-level), then he immediately gains ownership of the mutex and proceeds without issue.</span></p><p><span>However, if another Mario owns the mutex (is presently in the pipe sub-level), then the Mario which is presently entering the pipe will be </span><em>blocked</em><span> until the mutex is released (the other Mario leaves the pipe sub-level).</span></p><p>Marios outside of the pipe sub-level are not blocked, and are still allowed to run.</p><p><span>The green shaded area (the flagpole at the end of the level) demonstrates a </span><em>condition variable</em><span>: when a Mario touches the flagpole, he increments </span><em>numMariosTouchedFlagpole</em><span> — a “condition variable” — by 1, and then blocks until that same condition variable is equal to the number of threads. In other words, he waits until all the other Marios have touched the flagpole before continuing.</span></p><p>Whenever a Mario kills an enemy, his thread goes to sleep for 300 frames.</p><p><span>It’s hard to tell in the video, but a thread that goes to sleep </span><em>doesn’t necessarily come back on time</em><span>; it has to wait until the thread scheduler next </span><em>decides</em><span> to run it.</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png" width="521" height="217.2026098901099" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/f8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:607,&#34;width&#34;:1456,&#34;resizeWidth&#34;:521,&#34;bytes&#34;:3039457,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:&#34;https://prettygoodblog.com/i/164506409?img=https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png&#34;,&#34;isProcessing&#34;:false,&#34;align&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff8667866-5150-44d1-b47c-4879d1d6e344_3456x1440.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p><span>This actually </span><em>is</em><span> threads</span><em>.</em><span> We have taken a machine — cursed with an inability</span><span> to do more than one thing at a time — and added concurrency to it, without modifying the </span><em>core engine</em><span> (or CPU) to have any notion of “threads”.</span></p><p><span>We added threads to this emulator </span><em>in the same way</em><span> that we add threads to normal CPUs: we take clever advantage of a mechanism which allows us to A) save the current state of the machine and B) load it back up in the future if and when we choose. All without the emulator </span><em>itself</em><span> ever being designed for, or having any notion of, “threads”.</span></p><p><span>And </span><em>you can touch it.</em><span> You interact with these bona fide threads not through a debugger, not by instantiating a Mutex, but by </span><em>walking into a critical section</em><span> and observing how the threading behavior changes in real time.</span></p><p>It’s sick!</p><h6><em>Has anyone seen it? Do you know where it lives? What time does it tend to come home?</em></h6><p><span>I want more people to understand the things that “nobody understands.” Not because we will imminently need them; but because </span><em>there is certain joy and immense value in conquering these things anyways</em><span>.</span></p><p><span>If you’re getting into software today, you are liable to be thrown right into the middle of the abstraction wilderness. One can spend </span><em>decades</em><span> in these lands: learning new frameworks; adopting new stacks; exploring endlessly in all directions but into the mysterious </span><em>down.</em><span> No need to go down there. Nobody knows what’s beyond that barrier.</span></p><p><span>But the concrete has not cured</span><span>. We do not have the luxury of treating these layers as bedrock: </span><em>don’t even bother trying to get in. Just trust that it’ll hold your house up</em><span>. Oh, we’ve built the house — this trillion-dollar industry of a house — and sure, it’s standing. But when the foundation fails, what use is the house? When the foundation must evolve, how will we contribute to that process, knowing only how to build atop it? How could we accurately judge a new foundation, knowing nothing about how the old one was built?</span></p><p><span>Threads are not very complicated, and I don’t think I’m particularly smart for knowing how they work. Simple circumstance forced me to work with them at a deep level, which one cannot do without gaining an understanding of the thing. Anyone who had to work with them in the same way I did would likely have the same level of understanding. Conversely, there are countless things I’ve never worked with — and thus do not understand — which I certainly </span><em>should</em><span> know more about.</span></p><p><span>What </span><em>is</em><span> complicated is how to make threads work </span><em>extremely efficiently</em><span> </span><em>and reliably</em><span>. Switching contexts? Not too hard. Optimizing the hell out of them with data structures and algorithms? My intuition usually fails me on this front — I am no CS guru. But the core innovation of threads requires none of this.</span></p><p><span>That’s the case for almost everything of this sort: these are all relatively simple ideas! Taking the time to understand them only requires understanding </span><em>structure</em><span> and </span><em>logical flow</em><span>; one does not need to dive into complex math or advanced algorithms in order to grasp the </span><strong>root idea</strong><span>. And once it’s been grasped, we can add it to our foundational understanding; a new bone in the ol’ conceptual skeleton; supercharging work </span><em>way up the stack</em><span> in ways we cannot predict.</span></p><p><span>Learning frontend frameworks is useful. One can produce billions of dollars from such work! But nothing will give you an understanding of </span><em>frontend frameworks as a concept </em><span>like creating your own framework</span><span>. Once you’ve done that, the way you perceive and grok any other framework will be permanently enhanced.</span></p><p><span>Before I built this, I would have struggled to talk about how to implement a mutex — I’ve never done it before! My implementation is certainly terrible; a naive, simplistic approach which works only because the stakes are so low. But that’s fine: </span><em>I can see the next steps</em><span>. The ways in which it could improve. Through working on this — even through </span><em>identifying problems I want to avoid solving</em><span> — my brain is building pathways and forging connections between concepts without my knowledge. </span></p><p><span>I don’t know how the Linux kernel implements mutexes, or the best way to implement them in a battle-hardened system; it’d be silly to say that building this toy would grant me such expertise. But I now know how to evaluate what I’m looking at if I have to. “</span><em>Damn, they built it way better than I did</em><span>” is a far more instructive, useful experience than “</span><em>damn, they built a thing I have no understanding of!”</em></p><p><span>At first, I was going to find an open-source NES emulator and add all this directly into its source code. This was going to be quite cool and impressive of me. Then I found </span><a href="https://fceux.com/web/home.html" rel="">FCEUX</a><span>, which exposes a Lua plugin system through which I can do everything I need. Jackpot.</span></p><p>I do still want the credit for the original plan, though.</p><p><span>A</span><a href="https://pastebin.com/raw/vrDVjqHb" rel=""> few hundred lines of Lua</a><span> later, and we have a legitimate thread scheduler, with support for mutexes, condition variables, interrupt masking, sleep, and more. </span></p><p><strong>I highly encourage you to read the code for yourself</strong><span>, but I’ll walk through some of it here.</span></p><p>Before we build a thread scheduler, we need to be comfortable in our environment. We’re writing a Lua plugin for an NES emulator… what can we do?</p><p><span>Luckily, the </span><a href="https://fceux.com/web/help/LuaFunctionsList.html" rel="">documentation</a><span> is quite helpful — already, we can see that we have the tools we need to:</span></p><ol><li><p><span>Create a save state (</span><em>savestate.create() </em><span>and </span><em>savestate.save()</em><span>)</span></p><ol><li><p>This is how we’ll “save” a thread so we can resume it later</p></li></ol></li><li><p><span>Load a save state (</span><em>savestate.load())</em></p><ol><li><p>This is how we’ll resume a thread we previously put to sleep</p></li></ol></li><li><p><span>Read memory from the game’s RAM (</span><em>memory.readbyte()</em><span>)</span></p><ol><li><p>This is how we’ll figure out what level the player is on, their coordinates within the level, etc.</p></li><li><p><span>We’ll use </span><a href="https://web.archive.org/web/20250401041042/https://datacrystal.tcrf.net/wiki/Super_Mario_Bros./RAM_map" rel="">this helpful document</a><span> to figure out where all the juicy bits live in the game’s RAM</span></p></li></ol></li><li><p><span>Draw text on the screen (</span><em>gui.drawtext()</em><span>)</span></p><ol><li><p>This is how we’ll obscure the majority of the screen with irrelevant information</p></li></ol></li><li><p><span>Control when frames get executed on the emulator (</span><em>emu.frameadvance()</em><span>)</span></p><ol><li><p>Our lua code needs to call this function whenever a frame of the game should run</p><ol><li><p><span>This lets us do anything we want </span><em>in-between frames</em></p></li></ol></li></ol></li></ol><p>This is everything we need!</p><p>Let’s start with a basic “do-nothing” script, which is functionally identical to no script at all:</p><pre><code><code>while true do
    emu.advanceframe()
end</code></code></pre><p>We want to only kick in and start multithreading once the player has started the game.</p><p><span>I don’t have the best solution here, but I decided to hook into the </span><em>GAME_MODE </em><span>(0x0770) and </span><em>PRE_LEVEL_SCREEN_SHOWING</em><span> (0x0757) memory addresses. When each has the value of </span><em>1</em><span>, we know that the game is starting and is showing the “pre-level screen”, which is a good place to start in my opinion.</span></p><p>This is what that looks like:</p><pre><code><code>function initiate()
    emu.frameadvance()

    if not emu.emulating() then
        return
    end

    local gameMode = memory.readbyte(0x0770)
    local preLevelScreen = memory.readbyte(0x0757)

    if gameMode ~= 1 or preLevelScreen ~= 1 then
        return
    end

    initiated = true
end

function loop()
    emu.frameadvance()
end

while true do
    if not initiated then
        initiate()
    else
        loop()
    end
end</code></code></pre><p><span>This works, but doesn’t </span><em>do</em><span> anything yet.</span></p><p>Now that we can detect when the game has begun, we can start implementing threads.</p><p><span>Remember: </span><em>threads are just snapshots of state, combined with a condition upon which they should be resumed.</em><span> </span></p><p>For now, we’ll ignore the “condition to resume” part. We’ll focus solely on the time-slicing bits.</p><p>So, we’ll need:</p><ul><li><p>A list of threads</p><ul><li><p>Each of which has:</p><ul><li><p>An ID</p></li><li><p>A save state</p></li></ul></li></ul></li><li><p>A notion of the “current thread”</p></li><li><p>A way to switch from the “current thread” to some other thread</p></li><li><p>A timer which tracks when we should switch threads</p></li></ul><p>Here’s the full implementation for just time slicing:</p><pre><code><code>THREAD_SWITCH_FREQUENCY = 100
NUM_THREADS = 3

local threads = {}
local curThreadIndex = nil
local curFrame = 0
local lastSwitchedThreads = 0

local initiated = false

function shouldRunScheduler()
    return (curFrame - lastSwitchedThreads) &gt;= THREAD_SWITCH_FREQUENCY
end

function threadScheduler()
    local newThreadIndex = curThreadIndex + 1

    if newThreadIndex &gt; NUM_THREADS then
        newThreadIndex = 1
    end

    local oldThread = threads[curThreadIndex]
    local newThread = threads[newThreadIndex]

    savestate.save(oldThread.saveState)
    savestate.load(newThread.saveState)

    curThreadIndex = newThreadIndex
end

function initiate()
    emu.frameadvance()

    if not emu.emulating() then
        return
    end

    local gameMode = memory.readbyte(0x0770)
    local preLevelScreen = memory.readbyte(0x0757)

    if gameMode ~= 1 or preLevelScreen ~= 1 then
        return
    end
    
    for i = 1, NUM_THREADS do
        local thread = {}
        thread.id = i
        thread.saveState = savestate.create()

        savestate.save(thread.saveState)
        table.insert(threads, thread)
    end

    initiated = true
    curThreadIndex = 1
    threadScheduler()
end

function loop()
    emu.frameadvance()

    if shouldRunScheduler() then
        threadScheduler()
        lastSwitchedThreads = curFrame
    end
end

while true do
    curFrame = curFrame + 1

    if not initiated then
        initiate()
    else
        loop()
    end
end</code></code></pre><p>This works! Start World 1-1, and you’ll start switching between 3 threads, ruining the gameplay experience in its entirety.</p><p>I think this is a good place to stop with the implementation details. </p><p>Now that you have a function which can switch threads on demand, it’s not too hard to add:</p><ul><li><p>Thread priorities</p></li><li><p>Sleeping</p></li><li><p>Locking on resources (mutexes, semaphores, etc.)</p></li><li><p>Whatever your heart desires!</p></li></ul><p>I encourage you to try out the full code — linked above — for yourself!</p><p>First, obtain a legal copy of a Super Mario Bros. ROM for the NES. I offer no assistance on this front.</p><p><span>Second, download </span><a href="https://fceux.com/web/home.html" rel="">FCEUX</a><span>. Click that blog link and download that unsigned executable. Do it.</span></p><p><span>Third, download the </span><a href="https://pastebin.com/raw/vrDVjqHb" rel="">Lua script</a><span> and save it somewhere you can find on your computer.</span></p><p><span>Fourth, </span><strong>read the Lua script and ensure I didn’t just trick you into downloading malware.</strong></p><p><span>Fifth, open FCEUX. Click </span><em>File → Load Lua Script</em><span>. Click </span><em>Browse</em><span>, then find the Lua file you saved. Hit </span><em>Load</em><span> and then </span><em>Start</em><span>.</span></p><p><span>Sixth, click </span><em>File → Open ROM</em><span>. Find the ROM file you downloaded.</span></p><p><span>Seventh, play the game. You might want to configure controls in </span><em>Options → Input Config.</em></p><p><span>Eighth, realize that constantly switching between three instances of </span><em>Super Mario Bros. </em><span>isn’t pleasant, and you had no good reason to think it would be.</span></p><p>I haven’t actually set up a situation in which a true deadlock (A holds X, B holds Y, A tries to get Y while B tries to get X) can occur, but it would be handled (in a primitive manner) by the thread scheduler.</p><p><span>Whenever there is no thread that </span><em>can</em><span> be run (as would be the case in a deadlock, or if all threads are dead, or if all threads are asleep</span><span>), the thread scheduler will halt the game and show an error message.</span></p><p><span>One deadlock-ish way this can happen is if every Mario is waiting on the mutex to enter the pipe, and then the Mario </span><em>inside</em><span> the pipe dies. This is really a dangling mutex, but let’s call it a deadlock.</span></p><p><em>(It’s hard to tell in this video, because the ‘on death’ trigger occurs before the animation even plays, but the Mario inside the pipe dies and thus leaves a dangling mutex)</em></p><p>What if the thread scheduler runs much more often?</p><p><strong>WARNING: I think this video could legitimately induce an epileptic seizure.</strong></p><p>I don’t like it.</p><p>This is not a good thread scheduler.</p><p>It does not support thread priorities; idle tasks; semaphores; fairness algorithms; dynamic thread spawning and joining; tracking mutex wait lists; making me any money. It is horribly inefficient, and very annoying to play with. But I love it.</p><p>I love it because I was able to build something — which I at one time presumed to be magic — in roughly 300 lines of Lua. I had never done this before! But here it is: my very own thread scheduler, in the most ridiculous of environments. Maybe this will be my DOOM thing: turning every video game into threads. Probably not.</p><p>It’s one of those projects that delights at every turn. How utterly wild it was to see it working the first time! Honestly, part of me didn’t expect that it would ever work.</p><p>I hope this taught you about… threads, was it?</p></div></div></div>
  </body>
</html>
