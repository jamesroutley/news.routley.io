<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sigma-star.at/blog/2025/06/deep-down-the-rabbit-hole-bash-overlayfs-and-a-30-year-old-surprise/">Original</a>
    <h1>Deep Down the Rabbit Hole: Bash, OverlayFS, and a 30-Year-Old Surprise</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<p>This blog post recounts a recent debugging session that uncovered a surprising set of issues involving Bash, <code>getcwd()</code><sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>, and OverlayFS<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.
What began as a simple customer bug report evolved into a deep dive worth sharing.</p>
<h2 id="initial-bug-report">Initial Bug Report</h2>
<p>A customer reported that OpenSSH scp<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> failed after switching to OverlayFS.
We found the following error in the logs:</p>
<pre tabindex="0"><code>shell-init: error retrieving current directory: \
getcwd: cannot access parent directories: Inappropriate ioctl for device
</code></pre><p>After analyzing the report, we realized the message didn’t come from scp itself but from the Bash shell.
We asked the key question: why couldn’t Bash determine the current working directory, and why did it fail with <code>ENOTTY</code> (Inappropriate ioctl for device)?</p>
<h2 id="ruling-out-the-kernel">Ruling Out the Kernel</h2>
<p>Because the issue appeared after the introduction of OverlayFS, we reviewed the OverlayFS source code in the Linux kernel for any code paths that return <code>ENOTTY</code>.
Although such paths exist, we considered hitting them highly unlikely.</p>
<p>Bash uses glibc and is written in C.
We examined the glibc system call wrapper for <code>getcwd()</code> but found no logic that could return <code>ENOTTY</code>.
The wrapper mainly handles buffer allocation and falls back to a generic implementation if the system call fails.</p>
<p>To test this theory, we enabled system call tracing.
Surprisingly, the trace revealed that the <code>getcwd()</code> system call never got called.
Since glibc offers multiple <code>getcwd()</code> implementations depending on the system, we double-checked that we had reviewed the correct Linux-specific one.
We found no code path that bypassed the system call.</p>
<h2 id="bashs-home-made-getcwd">Bash’s home made <code>getcwd()</code></h2>
<p>A hunch led us to check how Bash links to the <code>getcwd</code> symbol:</p>
<pre tabindex="0"><code data-lang="terminal">$ nm -D bash | grep getcwd
...
000c7b10 T getcwd
...
</code></pre><p>This showed that Bash includes its own <code>getcwd()</code> function rather than relying on glibc’s version.
We expected this output instead:</p>
<pre tabindex="0"><code data-lang="terminal">$ nm -D bash | grep getcwd
...
         U getcwd
...
</code></pre><p>Surprised, we inspected the Bash source and confirmed it does contain a <code>getcwd()</code> implementation, but guarded by the following:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>#if !defined (HAVE_GETCWD)
</span></span></span></code></pre></div><p>Developers originally intended this fallback for ancient Unix systems lacking the <code>getcwd()</code> system call.
On Linux, <code>HAVE_GETCWD</code> should normally be defined.</p>
<p>We confirmed in <code>config.h</code>:</p>
<p>At first, this puzzled us because under normal conditions, the implementation should never compile.
But further inspection of <code>config-bot.h</code> showed this logic:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>#if defined (HAVE_GETCWD) &amp;&amp; defined (GETCWD_BROKEN) &amp;&amp; !defined (SOLARIS)
</span></span></span><span><span><span>#  undef HAVE_GETCWD
</span></span></span><span><span><span>#endif
</span></span></span></code></pre></div><p>Sure enough, our <code>config.h</code> defined <code>GETCWD_BROKEN</code>.
That explained why Bash used its internal fallback.
But why did the system consider <code>getcwd()</code> broken?</p>
<h2 id="cross-compilation-confusion">Cross-Compilation Confusion</h2>
<p>We examined the output of the <code>configure</code> script in detail to trace the origin of <code>GETCWD_BROKEN</code>.
We found this line:</p>
<pre tabindex="0"><code>checking if getcwd() will dynamically allocate memory with 0 size... \
configure: WARNING: cannot check whether getcwd allocates memory when cross-compiling \
-- defaulting to no
</code></pre><p>The check in <code>aclocal.m4</code> sets <code>GETCWD_BROKEN</code> if it can’t confirm that <code>getcwd()</code> allocates memory with a zero-size buffer.
Since the build occurred in a cross-compilation environment, the test defaulted to failure.</p>
<p>We discovered that Bash becomes problematic in cross-compilation environments.
Since Bash is cross-compiled for ARM in this specific setup, this made sense.
We then wondered why this issue wasn’t more widespread.
After all, both Bash and OverlayFS are common in embedded systems.</p>
<p>Next, we looked into how major embedded Linux projects like Yocto handle cross-compiling Bash.
Although the Bash Yocto recipe didn’t mention <code>getcwd</code>, we found this line in <code>meta/site/common-glibc</code>:</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span><span>bash_cv_getcwd_malloc</span><span>=</span><span>${</span><span>bash_cv_getcwd_malloc</span><span>=yes</span><span>}</span>
</span></span></code></pre></div><p>Yocto explicitly overrides the test result to avoid the fallback.
The embedded Linux build system we used didn’t apply such a workaround.
This clarified the issue.
After we implemented a similar override, the issue vanished.</p>
<h2 id="root-cause-analysis">Root Cause Analysis</h2>
<p>At this point, we had identified and fixed the bug.
But several questions remained:</p>
<ul>
<li>Why did the issue appear only with OverlayFS?</li>
<li>Why did Bash’s fallback <code>getcwd()</code> fail?</li>
</ul>
<p>During testing, we observed another error message:</p>
<pre tabindex="0"><code>shell-init: error retrieving current directory: \
getcwd: cannot access parent directories: Success
</code></pre><p>This indicated that <code>errno</code> was sometimes set to <code>0</code>, suggesting no error occurred, yet <code>getcwd()</code> still failed.</p>
<h2 id="overlayfs-and-inode-numbers">OverlayFS and Inode Numbers</h2>
<p>To answer the remaining questions, we analyzed Bash’s <code>getcwd()</code> implementation.
On Linux, you can determine the current working directory in two ways:</p>
<ul>
<li>Use the <code>getcwd()</code> system call</li>
<li>Read the <code>/proc/self/cwd</code> symlink</li>
</ul>
<p>Bash’s implementation used neither, aiming to support systems lacking these features.
In fact, the fallback dates back to the last millennium.
It used a classic Unix algorithm to reconstruct the working directory path:</p>
<ul>
<li>It calls <code>stat(&#34;.&#34;)</code> to obtain the inode number of the current directory.</li>
<li>It calls <code>readdir(&#34;..&#34;)</code> to read the parent directory’s entries.</li>
<li>It compares inode numbers to identify <code>&#34;.&#34;</code>’s name.</li>
</ul>
<p>It repeats this process recursively to climb the full path.</p>
<p>Note that this simplified description omits many details.
In practice, you must evaluate both inode (<code>st_ino</code>) and device (<code>st_dev</code>) to work across mount points.</p>
<p>Tracing revealed that the fallback <code>getcwd()</code> failed on the very first path component.
<code>stat(&#34;.&#34;)</code><sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> returned an inode number <code>N</code>, but <code>readdir(&#34;..&#34;)</code><sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup> returned no matching directory with and inode number <code>N</code>.</p>
<p>OverlayFS merges two directories, a lower (read-only) and an upper (writable) layer.
When calling <code>readdir()</code> on a directory, OverlayFS combines entries from both layers without performing full lookups.
It returns the underlying inode numbers directly, unmodified.</p>
<p>This design means that inode numbers from <code>readdir()</code> don’t guarantee uniqueness or stability in the merged view.
Two entries might even share an inode number without being hard links.
OverlayFS uses this approach to provide fast directory listings, performing a full lookup for each entry would incur performance penalties.</p>
<p>Conversely, <code>stat()</code> triggers a full lookup.
OverlayFS allocates an inode object that provides stable and unique inode numbers.
That stability is crucial for tools like <code>find</code> or <code>du</code>.</p>
<p>Bash’s fallback <code>getcwd()</code> assumes that the inode from <code>stat()</code> matches one returned by <code>readdir()</code>.
OverlayFS breaks that assumption.</p>
<p>We eventually realized that <a href="https://docs.kernel.org/filesystems/overlayfs.html#inode-properties">OverlayFS documentation</a> acknowledges this limitation:
For directories, the inode number from <code>readdir()</code> may not match the number from <code>stat()</code>.</p>
<h2 id="the-role-of-the-xino-feature">The Role of the xino Feature</h2>
<p>OverlayFS can deliver stable inode numbers via <code>readdir()</code> when the <code>xino</code> feature is active.
64-bit systems can encode extra data (e.g., instance numbers) into inode fields to prevent collisions.
This works without requiring a full lookup and does not hurt <code>readdir()</code> performance.</p>
<p>However, 32-bit systems lack this space and the <code>xino</code> feature it not available.
We encountered the original problem on a 32-bit ARM platform, which explained why the issue occurred there.</p>
<h2 id="incorrect-use-of-readdir-in-bash">Incorrect Use of <code>readdir()</code> in Bash</h2>
<p>One question remained: why did <code>getcwd()</code> sometimes fail with <code>ENOTTY</code>?</p>
<p>Upon inspecting Bash’s <code>getcwd()</code>, we noticed it misused <code>readdir()</code> slightly:</p>
<ul>
<li><code>readdir()</code> returns <code>NULL</code> both on EOF and on error.</li>
<li>To distinguish between an error condition and the end of the directory list, the caller must set <code>errno</code> to zero before calling <code>readdir()</code>.</li>
<li>If <code>readdir()</code> returns <code>NULL</code> and <code>errno == 0</code>, it means EOF.</li>
<li>Bash forgot to reset <code>errno</code> before the call. For about 30 years, no one noticed.</li>
</ul>
<p>As a result, when <code>readdir()</code> returned <code>NULL</code> with no match, Bash incorrectly assumed an error.
It returned <code>NULL</code> and left <code>errno</code> in an undefined state.
Sometimes, <code>ENOTTY</code> from a previous system call remained, producing misleading errors.</p>
<p>We have <a href="https://lists.gnu.org/archive/html/bug-bash/2025-06/msg00149.html">reported</a> the issue to the GNU Bash project.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This bug hunt revealed several contributing factors:</p>
<ul>
<li>A misconfigured cross-compilation environment caused Bash to use its fallback <code>getcwd()</code>.</li>
<li>OverlayFS introduced subtle inode behavior differences, especially on 32-bit systems.</li>
<li>Bash’s fallback <code>getcwd()</code> relied on assumptions that failed with OverlayFS.</li>
<li>A decades-old oversight in Bash’s error handling created misleading <code>errno</code> values.</li>
</ul>
<p>While we resolved the issue with a simple build tweak, the investigation highlighted deeper lessons about portability assumptions, legacy code, and filesystem complexity.</p>


        </div></div>
  </body>
</html>
