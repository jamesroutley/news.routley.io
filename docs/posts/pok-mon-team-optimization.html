<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nchagnet.pages.dev/blog/pokemon-team-optimization/">Original</a>
    <h1>Pokémon Team Optimization</h1>
    
    <div id="readability-page-1" class="page"><div>  <p>I grew up as a big Pokémon fan, watching the anime on TV (even the movies), playing it on my Gameboy color (which was <a href="https://www.retronintendostore.com/Files/2/40000/40305/ProductPhotos/448/1673554947.jpg" rel="nofollow, noopener, noreferrer" target="_blank">Pikachu-themed</a> too), collecting the cards. I had figurines, posters, blankets, plushies, everything. Truth be told, it was mostly that once my family figured out I liked it, they had just found an endless resource of Christmas and birthday gifts. And 6-year-old me was not complaining.</p>
<p>I do remember the games fondly. I played generations I-IV religiously. However, I was soured by the soft reboot of generation V, and as I was on the cusp of teenagehood, I kind of gave up on it. Fast forward 10 years and I rediscovered the joy of it: playing through my favorite games again as an adult was a blast!</p>
<p>However I quickly realized I had lost some of the magic by not being a kid anymore, and it took me a bit to realize why. I was not only much older than the target audience, but I was also working as a scientist. I was just constantly trying to min-max my way through the game. I was always hunting for Pokémon with better abilities, better type coverage, analyzing synergy between moves… If you’ve ever played a mainline Pokémon game before, you must know how utterly unnecessary this is. Twenty years ago, I would have just powered through on Blastoise or Typhlosion alone. But adult-me likes to have a balanced team, always ready for any encounter. So, at the peak of this frenzy, I decided to build a little tool to help myself over-engineer a team. And in this post, I’ll guide you through how I did it.</p>

<h2 id="formulating-the-problem-as-a-mixed-integer-problem-mip">Formulating the problem as a Mixed-Integer Problem (MIP)</h2>
<p>Before we can move on to the formulation part, <em>what is it exactly that we’re trying to optimize?</em></p>
<p>If you’ve read this far, I assume you at least are familiar with what Pokémon is. At its core, it’s a turn-based game where you have a party of at most 6 “POcKEt MONsters” (or, Pokémon), which fight for you. There are currently 1025 Pokémon split into 9 generations. Each Pokémon belongs to one or two <em>types</em> (Fire, Water, Grass, etc.) and can learn up to 4 <em>moves</em>, each of which has its own type. Each type has its own strengths and weaknesses against other types. For example, water is strong against fire, so a Pokémon using a water attack against a fire Pokémon gets a 2x multiplicative factor.</p>
<figure id="type-matchup"><img src="https://upload.wikimedia.org/wikipedia/commons/9/97/Pokemon_Type_Chart.svg" alt="Pokemon type matchup table"/><figcaption><p>Pokémon type matchup table - <a href="https://commons.wikimedia.org/wiki/File:Pokemon_Type_Chart.svg">Aussie Evil and OmegaFallon, CC0, via Wikimedia Commons</a></p></figcaption></figure>
<p>Each Pokémon also has <em>stats</em>, like attack, defense, speed, etc., but in this post we’ll only consider the overall <em>base stat</em> as an indicator of a strong Pokémon. There are a lot of other important details I won’t get into (e.g., there is a Same Type Attack Bonus (STAB), a physical/special split, etc.) but these all contribute to making the gameplay rich and complex. For now, I’m interested in finding the best teams of Pokémon such that:</p>
<ol>
<li>the total base stat is as high as possible,</li>
<li>for each type <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span>, the team has a Pokémon resistant to it.</li>
</ol>
<p>In optimization terms, 1. is called <strong>the objective</strong> while 2. is a <strong>constraint</strong>. Other notable constraints of the problem are:</p>
<ul>
<li>a Pokémon can be chosen at most once,</li>
<li>the total amount of chosen Pokémon is at least 1 and at most 6.</li>
</ul>
<p>We could solve some variation of the same problem by swapping/combining 2. with</p>
<ol start="3">
<li>“for each type <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span>, the team has a Pokémon super effective to it”.</li>
</ol>
<p>Ideally, you would want a more complex version 2. which would be</p>
<ol start="4">
<li>“for each type <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span>, the team has a Pokémon resistant to it which can learn a super effective attack against it”.</li>
</ol>
<p>But that’s a lot more complicated so for now let’s stick with 2. To recap, we have an objective and some constraints, what we need now are <strong>decision variables</strong> which will encode the solution. Mathematically, we can denote by <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> whether a Pokémon labeled by <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span> is in the team or not. This is a boolean variable, i.e., <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">x_n \in \{0, 1\}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>∈</span><span></span></span><span><span></span><span>{</span><span>0</span><span>,</span><span></span><span>1</span><span>}</span></span></span></span>. Focusing on the simple constraints for now, the basic problem to solve is</p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">x</mi></mrow><mi>x</mi></msub><munder><mo>∑</mo><mi>n</mi></munder><msub><mi>b</mi><mi>n</mi></msub><msub><mi>x</mi><mi>n</mi></msub><mtext> </mtext><mo separator="true">,</mo><mtext> such that </mtext><mn>1</mn><mo>≤</mo><munder><mo>∑</mo><mi>n</mi></munder><msub><mi>x</mi><mi>n</mi></msub><mo>≤</mo><mn>6</mn><mtext> and </mtext><msub><mi>x</mi><mi>n</mi></msub><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo><mtext> </mtext><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathrm{argmax}_{x} \sum_n b_n x_n~,
\text{ such that } 1 \leq \sum_n x_n \leq 6 \text{ and } x_n \in \{ 0, 1 \}~.</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>argmax</span></span><span><span><span><span><span><span></span><span><span><span>x</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span><span><span><span><span><span></span><span><span>n</span></span></span><span><span></span><span><span>∑</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span><span><span>b</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span> </span><span>,</span><span></span><span><span> such that </span></span><span>1</span><span></span><span>≤</span><span></span></span><span><span></span><span><span><span><span><span><span></span><span><span>n</span></span></span><span><span></span><span><span>∑</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>≤</span><span></span></span><span><span></span><span>6</span><span><span> and </span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>∈</span><span></span></span><span><span></span><span>{</span><span>0</span><span>,</span><span></span><span>1</span><span>}</span><span> </span><span>.</span></span></span></span></span></p><p>The first part is the maximisation of the overall base stat, where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>b</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> is the base stat of Pokémon <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span>. The second part just tells us that a team must have between 1 and 6 Pokémon.</p>
<h3 id="optimization-of-linear-problems-101">Optimization of linear problems 101</h3>
<p>Before adding more complexity to this model, we can use this simpler example to illustrate how these kinds of problems are usually solved in operations research (OR). This is a rich area, with decades of research and a <strong>lot</strong> of industrial interest in it: routing, scheduling, stocking are all examples of complex problems which can be solved with these methods.</p>

<p>First of all, solving the problem with <em>integer</em> constraints is <strong>hard</strong>, so let’s relax that assumption for now. The problem is then a pure <em>linear optimization</em> problem (LP): all objectives and constraints are linear expressions in the decision variables. Geometrically, linear expressions match to shapes like lines, planes, etc. which means that:</p>
<ul>
<li>constraints each define a region of feasibility whose boundary is a <em>hyperplane</em> (a line in 2D, a plane in 3D, etc.),</li>
<li>the intersection of all constraints define a restricted region of feasibility in which points are possible solutions.</li>
</ul>
<figure><img src="https://nchagnet.pages.dev/blog/pokemon-team-optimization/feasibility-region.svg" alt="Feasibility region illustration"/><figcaption><p>Example: if you have only two decision variables which must be positive and the constraint <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>≤</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">x + y \leq 3</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span><span></span><span>+</span><span></span></span><span><span></span><span>y</span><span></span><span>≤</span><span></span></span><span><span></span><span>3</span></span></span></span>, this is what the feasibility region looks like. It is the intersection of the region below the line <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">x + y = 3</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span><span></span><span>+</span><span></span></span><span><span></span><span>y</span><span></span><span>=</span><span></span></span><span><span></span><span>3</span></span></span></span> with the regions <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x, y \geq 0</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span><span>,</span><span></span><span>y</span><span></span><span>≥</span><span></span></span><span><span></span><span>0</span></span></span></span>.</p></figcaption></figure>
<p>Since the objective is also linear, the surfaces on which it is constant (also called <em>isosurfaces</em>) are also geometrically matched to lines, planes, etc. When you move that surface along a direction or another, the objective either increases or decreases <em>monotonically</em>. If you combine these two facts, you can find the optimum quite easily: slide the hyperplane of constant objective value over the region of feasibility, in the direction where the value increases. Eventually, you will reach the edge of the surface, which will be either a single vertex or a whole parallel edge. This is where the optimal solution lives.</p>
<figure><img src="https://nchagnet.pages.dev/blog/pokemon-team-optimization/lp-simplex.svg" alt="Simplex method illustration"/><figcaption><p>Let’s take as objective <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y - x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>y</span><span></span><span>−</span><span></span></span><span><span></span><span>x</span></span></span></span>, which is constant along lines parallel to the dashed lines in black, increasing when <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span> decreases and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>y</span></span></span></span> increases. The colored dashed line is that isosurface with maximal value which also intersects the feasibility region. This is done on the vertex <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,3)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>0</span><span>,</span><span></span><span>3</span><span>)</span></span></span></span>, which is then the optimum.</p></figcaption></figure>
<p>This concept is behind the <strong>simplex</strong> algorithm used to solve linear problems. The basic idea of this algorithm is to explore the edge of the feasibility region, vertex to vertex, until it finds an optimum.</p>
<blockquote>
<p>Does this also work with the integer constraint?</p>
</blockquote>
<p>Unfortunately, no. Points on the edge of the region might be candidate optima to the objective, but there is generally no reason for them to obey the integer constraint. The candidates for this would be found <em>inside</em> the feasibility region (instead of at the edge) which is a <strong>much larger</strong> region to explore. Instead of doing that, what you can do is <em>branch and bound</em>:</p>
<ol>
<li>solve the relaxed LP and obtain a solution: if the integer constraint is obeyed, you’re done!</li>
<li>Otherwise, pick one of the non-integer variables <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N &lt; x &lt; N+1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>N</span><span></span><span>&lt;</span><span></span></span><span><span></span><span>x</span><span></span><span>&lt;</span><span></span></span><span><span></span><span>N</span><span></span><span>+</span><span></span></span><span><span></span><span>1</span></span></span></span>, and define two constraints <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">x \leq N</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span><span></span><span>≤</span><span></span></span><span><span></span><span>N</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≥</mo><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x \geq N+1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span><span></span><span>≥</span><span></span></span><span><span></span><span>N</span><span></span><span>+</span><span></span></span><span><span></span><span>1</span></span></span></span>. For each of these constraints, define the LP with the extra constraint and go back to 1.</li>
</ol>
<p>This algorithm continues recursively until either a solution obeying integer constraints is found, or no solutions are found. If you want to make sure to find a <strong>global</strong> optimum, you can also keep going after you’ve found a valid candidate solution, and use that objective to trim the recursive tree from branches which just won’t get any better!</p>
<h3 id="adding-non-linear-constraints">Adding non-linear constraints</h3>
<p>So far I only focused on simple constraints like the number of Pokémon in the team, which are linear and easy to visualize graphically, but we are going to be a bit more ambitious than that! Of course, in a LP, <em>all</em> constraints must be linear. For type-based constraints, let’s denote by <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{An}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>t</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> the matrix entry containing the damage factor of type <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span> against Pokémon <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span>. The constraint 2. is equivalent to the statement <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>min</mi><mo>⁡</mo></mrow><mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><msub><mi>t</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo><mo>≤</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\min_n(x_n t_{An}) \leq 0.5</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>min</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>x</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span><span>t</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>)</span><span></span><span>≤</span><span></span></span><span><span></span><span>0.5</span></span></span></span> (this means at least one selected Pokémon is resistant to this type). But here comes the difficulty! The operation <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo><mrow></mrow></mrow><annotation encoding="application/x-tex">\min{}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>min</span><span></span><span></span></span></span></span> is <strong>not</strong> linear. Thankfully there is a trick for this situation using auxiliary decision variables <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">y_{An} \in \{0, 1\}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>∈</span><span></span></span><span><span></span><span>{</span><span>0</span><span>,</span><span></span><span>1</span><span>}</span></span></span></span>. Take this system of constraints: <sup><a href="#user-content-fn-index" id="user-content-fnref-index" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup></p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>x</mi><mi>n</mi></msub><msub><mi>t</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mo>+</mo><mi>M</mi><mo>×</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≤</mo><mn>0.5</mn><mtext> with </mtext><mi>M</mi><mo>≫</mo><mn>1</mn><mtext> </mtext><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><munder><mo>∑</mo><mi>n</mi></munder><msub><mi>y</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≥</mo><mn>1</mn><mtext> </mtext><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
x_n t_{An} + M \times (y_{An} - 1) &amp; \leq 0.5 \text{ with } M \gg 1~, \\
\sum_n y_{An} &amp; \geq 1~.
\end{align*}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span>x</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span><span>t</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>+</span><span></span><span>M</span><span></span><span>×</span><span></span><span>(</span><span><span>y</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span><span>1</span><span>)</span></span></span><span><span></span><span><span><span><span><span><span><span></span><span><span>n</span></span></span><span><span></span><span><span>∑</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>≤</span><span></span><span>0.5</span><span><span> with </span></span><span>M</span><span></span><span>≫</span><span></span><span>1</span><span> </span><span>,</span></span></span><span><span></span><span><span></span><span></span><span>≥</span><span></span><span>1</span><span> </span><span>.</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>The second constraint basically means that for all <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span>, at least one of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">y_{An}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> must be 1. Since <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span></span></span></span> is taken very large (compared to the other numbers), then whenever <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">y_{An} = 0</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>0</span></span></span></span>, the first constraint is automatic. However, since <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y_{An} = 1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>1</span></span></span></span> for some <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span>, then for that value <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub><msub><mi>t</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mo>≤</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">x_n t_{An} \leq 0.5</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span><span>t</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>≤</span><span></span></span><span><span></span><span>0.5</span></span></span></span>. And voilà, the Pokémon will be resistant to the type <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span>!</p>
<p>There is one tiny flaw in this method. Whichever Pokémon sets <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y_{An} = 1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>1</span></span></span></span> might not be one of the selected Pokémon. What we want is not only that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y_{An} = 1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>1</span></span></span></span> but also that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x_n = 1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>1</span></span></span></span> at the same time (so either both 1 or both 0). To make this happen, we need more auxiliary decision variables <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z_{An}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>z</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> with the constraints:</p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>z</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≤</mo><msub><mi>x</mi><mi>n</mi></msub><mtext> </mtext><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>z</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≤</mo><msub><mi>y</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mtext> </mtext><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>z</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≥</mo><msub><mi>x</mi><mi>n</mi></msub><mo>+</mo><msub><mi>y</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mo>−</mo><mn>1</mn><mtext> </mtext><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
z_{An} &amp; \leq x_n~,\\
z_{An} &amp; \leq y_{An}~,\\
z_{An} &amp; \geq x_n + y_{An} - 1~.
\end{align*}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span>z</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span><span><span></span><span><span><span>z</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span><span><span></span><span><span><span>z</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>≤</span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span> </span><span>,</span></span></span><span><span></span><span><span></span><span></span><span>≤</span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span> </span><span>,</span></span></span><span><span></span><span><span></span><span></span><span>≥</span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>+</span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span><span>1</span><span> </span><span>.</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>This might sound complicated at first, but we can very easily summarize the possible values of each variable in the following table</p>
<div>





























<div><table><thead><tr><th><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></th><th><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">y_{An}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></th><th><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z_{An}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>z</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table></div></div>
<p>When either variable is 0, then the first two constraints impose that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z_{An} = 0</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>z</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>0</span></span></span></span> and the last one is automatic. But if both variables are 1, the last constraint imposes that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">z_{An} = 1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>z</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>1</span></span></span></span>. So really <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mi>x</mi><mo>∧</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">z = x \land y</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>z</span><span></span><span>=</span><span></span></span><span><span></span><span>x</span><span></span><span>∧</span><span></span></span><span><span></span><span>y</span></span></span></span> (logical AND operation). That’s great, this means that if we replace the condition <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mi>n</mi></msub><msub><mi>y</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_n y_{An} \geq 1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>∑</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>≥</span><span></span></span><span><span></span><span>1</span></span></span></span> by <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mi>n</mi></msub><msub><mi>z</mi><mrow><mi>A</mi><mi>n</mi></mrow></msub><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_n z_{An} \geq 1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>∑</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span><span>z</span><span><span><span><span><span><span></span><span><span><span>A</span><span>n</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>≥</span><span></span></span><span><span></span><span>1</span></span></span></span>, then the Pokémon which will be resistant to type <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span> will <em>also</em> be in the team!</p>
<h2 id="getting-our-hands-dirty-with-pulp">Getting our hands dirty with PuLP</h2>
<p>After the theory comes some practice! In this section, I’ll show you briefly how to actually solve the model we just defined. For this I used the Python library <a href="https://coin-or.github.io/pulp/" rel="nofollow, noopener, noreferrer" target="_blank">PuLP</a> but I can also recommend Google’s excellent <a href="https://developers.google.com/optimization/" rel="nofollow, noopener, noreferrer" target="_blank">OR-tools</a> library.</p>
<p>Of course, the first thing you need for this project is a dataset of Pokémon data with all the necessary information to use in the constraints. I chose <a href="https://www.kaggle.com/datasets/rounakbanik/pokemon" rel="nofollow, noopener, noreferrer" target="_blank">this one from Kaggle</a>. To define a maximization problem and its decision variables, all you need to do is</p>
<div><figure><pre data-language="python"><code><div><p><span>import</span><span> pulp</span></p></div><div></div><div><p><span>def</span><span> </span><span>solve_pokemon_team</span><span>(number_pkmn: </span><span>int</span><span>, number_types: </span><span>int</span><span>, types_matrix: list[list[</span><span>float</span><span>]], pkmn_base_stat: list[</span><span>int</span><span>]):</span></p></div><div><p><span><span>    </span></span><span>prob </span><span>=</span><span> pulp.LpProblem(</span><span>&#34;Pokemon_Team_Optimization&#34;</span><span>, pulp.LpMaximize)</span></p></div><div></div><div><p><span>    </span><span># Define the boolean variables</span></p></div><div><p><span><span>    </span></span><span>x </span><span>=</span><span> pulp.LpVariable.dicts(</span><span>&#34;x&#34;</span><span>, </span><span>range</span><span>(number_pkmn), </span><span>cat</span><span>=</span><span>&#34;Binary&#34;</span><span>)</span></p></div><div><p><span><span>    </span></span><span>y </span><span>=</span><span> pulp.LpVariable.dicts(</span><span>&#34;y&#34;</span><span>, (</span><span>range</span><span>(number_types), </span><span>range</span><span>(number_pkmn)), </span><span>cat</span><span>=</span><span>&#34;Binary&#34;</span><span>)</span></p></div><div><p><span><span>    </span></span><span>z </span><span>=</span><span> pulp.LpVariable.dicts(</span><span>&#34;z&#34;</span><span>, (</span><span>range</span><span>(number_types), </span><span>range</span><span>(number_pkmn)), </span><span>cat</span><span>=</span><span>&#34;Binary&#34;</span><span>)</span></p></div><div></div><div><p><span>    </span><span># the rest of the code will go here...</span></p></div></code></pre><div></div></figure></div>
<p>Constraints or objective can be added to the <code>prob</code> object like this:</p>
<div><figure><pre data-language="python"><code><div><p><span># Define the size constraint</span></p></div><div><p><span>prob </span><span>+=</span><span> pulp.lpSum(x[i] </span><span>for</span><span> i </span><span>in</span><span> </span><span>range</span><span>(number_pkmn)) </span><span>==</span><span> size_team, </span><span>&#34;Team Size&#34;</span></p></div><div></div><div><p><span># Define the base total sum objective</span></p></div><div><p><span>prob </span><span>+=</span><span> pulp.lpSum(pkmn_base_stat[i] </span><span>*</span><span> x[i] </span><span>for</span><span> i </span><span>in</span><span> </span><span>range</span><span>(number_pkmn)), </span><span>&#34;Maximal base total&#34;</span></p></div></code></pre><div></div></figure></div>
<p>Notice the difference between all the sums involved:</p>
<ul>
<li><code>lpSum</code> is an abstract index sum over a generator of constraints terms,</li>
<li><code>prob += constraint</code> means this constraint should be obeyed during the maximization process.</li>
</ul>
<p>Of course, for more complex constraints like the type-based one, you can programmatically do it</p>
<div><figure><pre data-language="python"><code><div><p><span># Define the weakness sum bound for each type</span></p></div><div><p><span>m </span><span>=</span><span> </span><span>100</span></p></div><div><p><span>for</span><span> a, type_col </span><span>in</span><span> </span><span>enumerate</span><span>(types_matrix):</span></p></div><div><p><span><span>    </span></span><span>prob </span><span>+=</span><span> pulp.lpSum(z[a][i] </span><span>for</span><span> i </span><span>in</span><span> </span><span>range</span><span>(number_pkmn)) </span><span>&gt;=</span><span> </span><span>1</span><span>  </span><span># Overall constraint for each type</span></p></div><div><p><span>    </span><span>for</span><span> i </span><span>in</span><span> </span><span>range</span><span>(number_pkmn):</span></p></div><div><p><span><span>        </span></span><span>prob </span><span>+=</span><span> z[a][i] </span><span>&lt;=</span><span> x[i], </span><span>f</span><span>&#34;Constraint z 1 for </span><span>{</span><span>a</span><span>}</span><span>,</span><span>{</span><span>i</span><span>}</span><span>&#34;</span></p></div><div><p><span><span>        </span></span><span>prob </span><span>+=</span><span> z[a][i] </span><span>&lt;=</span><span> y[a][i], </span><span>f</span><span>&#34;Constraint z 2 for </span><span>{</span><span>a</span><span>}</span><span>,</span><span>{</span><span>i</span><span>}</span><span>&#34;</span></p></div><div><p><span><span>        </span></span><span>prob </span><span>+=</span><span> z[a][i] </span><span>&gt;=</span><span> x[i] </span><span>+</span><span> y[a][i] </span><span>-</span><span> </span><span>1</span><span>, </span><span>f</span><span>&#34;Constraint z 3 for </span><span>{</span><span>a</span><span>}</span><span>,</span><span>{</span><span>i</span><span>}</span><span>&#34;</span></p></div><div><p><span><span>        </span></span><span>prob </span><span>+=</span><span> x[i] </span><span>*</span><span> pkmn_base_stat[i] </span><span>&lt;=</span><span> </span><span>0.5</span><span> </span><span>+</span><span> m </span><span>*</span><span> (</span><span>1</span><span> </span><span>-</span><span> y[a][i]), </span><span>f</span><span>&#34;Weakness </span><span>{</span><span>type_col</span><span>}</span><span> for pokemon </span><span>{</span><span>i</span><span>}</span><span>&#34;</span></p></div></code></pre><div></div></figure></div>
<p>And finally, once your problem is well-defined, you can call the solver to find a solution</p>
<div><figure><pre data-language="python"><code><div><p><span>out_code </span><span>=</span><span> prob.solve() </span><span># will be 1 if successful</span></p></div><div><p><span># Indices of Pkmn in the solution</span></p></div><div><p><span>pkmn_in_team </span><span>=</span><span> [i </span><span>for</span><span> i </span><span>in</span><span> </span><span>range</span><span>(number_pkmn) </span><span>if</span><span> pulp.value(x[i]) </span><span>==</span><span> </span><span>1</span><span>]</span></p></div></code></pre><div></div></figure></div>
<p>The function <code>pulp.value</code> is useful to get the value of any decision variable for the solution found.</p>
<h2 id="results-and-closing-words">Results and closing words</h2>

<blockquote>
<p>So what kind of team does this give?</p>
</blockquote>
<p>The basic answer to this question is pretty boring: the optimum team is entirely composed of legendary and pseudo-legendary Pokémon across generations, with: <sup><a href="#user-content-fn-sprites" id="user-content-fnref-sprites" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup></p>






























<p>This makes sense of course, these Pokémon tend to have the highest base stat. In terms of types, if you refer back to the <a href="#type-matchup">type matchup table above</a>, you can see the two types with the most resistance are Dragon and Steel. So Metagross and Rayquaza already account for a chunk of the resistance we need to satisfy the constraints. If you look by rows, you can see some types encounter very few resistance in type matches, so any good team should have at least:</p>
<ul>
<li>one Dark Pokémon to resist Ghost (Tyranitar),</li>
<li>one Fighting or Ground Pokémon to resist Rock (Groudon).</li>
</ul>
<p>Now, if you remove legendary Pokémon from the pool, you end up with the second most logical choice, the <em>pseudo-legendaries</em>. These are Pokémon whose base stat is significantly larger than most Pokémon yet they don’t officially have the legendary title. For example, the team I got with these constraints (without legendaries) is</p>






























<p>In this team, Tyranitar, Metagross, Salamence and Garchomp are all pseudo-legendary (the other two are very strong ordinary Pokémon). Notice how here, Slaking is a pure Normal Pokémon which contributes almost no resistance (only to Ghost types), which means all the other Pokémon take care of the constraints and Slaking was mostly chosen for its high base stat. This is a really good illustration of how the model is blind to effects it doesn’t know about. Slaking might have a high base stat, but its ability also prevents him from acting 50% of the time, effectively neutering the advantage.</p>
<p>Okay let’s do this one more time, but this time without any legendaries, pseudo-legendaries, and with at most one starter to be realistic (I needed an extra constraint for that, you can try to figure out how to write it out yourself!)</p>






























<p>This is an interesting team: most Pokémon are from gen. III (4 of them), the other two being from gen. I and gen. IV. This makes sense, out of the first four generations, gen. III is famous for introducing some well-typed high base stat Pokémon which will be preferred by our model. It’s easy to see which Pokémon contributes the most to which resistance using our decision variables</p>
<div>
































<div><table><thead><tr><th><strong>Pokémon</strong></th><th><strong>Type resistance</strong></th></tr></thead><tbody><tr><td>Gyarados</td><td>Fire, Ground, Steel, Water</td></tr><tr><td>Swampert</td><td>Electric</td></tr><tr><td>Gardevoir</td><td>Dragon, Fighting, Psychic</td></tr><tr><td>Slaking</td><td>Ghost</td></tr><tr><td>Aggron</td><td>Fairy, Flying, Ice, Normal, Poison</td></tr><tr><td>Lucario</td><td>Bug, Dark, Grass, Rock</td></tr></tbody></table></div></div>
<p>From this table, you can see that Gardevoir, Lucario and Aggron are carrying the team resistance-wise! Gyarados is also contributing a lot, although a generic Water Pokémon would have also helped about the same here. You could easily swap Swampert and Slaking for about any other Pokémon (sacrificing some of the base stat of course) as long as you cover Ghost and Electric types.</p>
<p>This project was overall a fun showcase for OR methods. There are a lot more constraints you can consider before reaching the true perfect Pokémon team, but already the ones we used distilled some very strong combinations which would take you through any game without difficulty. If you are interested in customizing your own team, the CLI tool in the Github repo is also able to complete a partial team, optimizing the remaining seats for you!</p>

  </div></div>
  </body>
</html>
