<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2023/04/8086-microcode-string-operations.html">Original</a>
    <h1>The microcode and hardware in the 8086 processor that perform string operations</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-6370120370244800510" itemprop="description articleBody">



<p>Intel introduced the 8086 microprocessor in 1978. This processor ended up being hugely influential, setting the path
for the x86 architecture that is extensively used today.
One interesting feature of the 8086 was instructions that can efficiently
operate on blocks of memory up to 64K bytes long.<span id="fnref:history"><a href="#fn:history">1</a></span>
These instructions rapidly copy, compare, or scan data and are known as &#34;string&#34; instructions.<span id="fnref:string"><a href="#fn:string">2</a></span></p>
<p>In this blog post, I explain string operations in the 8086, analyze the microcode that it used, and discuss the hardware
circuitry that helped it out.
My analysis is based on reverse-engineering the 8086 from die photos. The photo below shows the chip under a microscope.
I&#39;ve labeled the key functional blocks; the ones that are important to this post are darker.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top
and an Execution Unit (EU) below.
The BIU handles memory accesses, while the Execution Unit (EU) executes instructions.
The microcode ROM at the lower right controls the process.</p>
<!--
This post is part of my [series](https://www.righto.com/search/label/8086) on the internals of the 8086.
-->

<p><a href="https://static.righto.com/images/8086-str/die-labeled.jpg"><img alt="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version." height="624" src="https://static.righto.com/images/8086-str/die-labeled-w600.jpg" title="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version." width="600"/></a></p><p>The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.</p>
<h2>Segments and addressing</h2>
<p>Before I get into the details of the string instructions, I need to give a bit of background on how the 8086 accesses
memory through segments.
Earlier microprocessors such as the Intel 8080 (1974) used 16 bits to specify a memory address, allowing a maximum of 64K of memory.
This memory capacity is absurdly small by modern standards, but at the time when a 4K memory board cost hundreds of dollars, this limit
was not a problem.
However, due to Moore&#39;s Law and the exponential growth in memory capacity, the follow-on 8086 processor needed to support more memory.
At the same time, the 8086 needed to use 16-bit registers for backward compatibility with the 8080.</p>
<p>The much-reviled solution was to create a 1-megabyte (20-bit) address space consisting of 64K segments, with a 16-bit address
specifying a position within the segment.
In more detail, the memory address was specified by a 16-bit offset address along with a particular 16-bit segment register selecting a segment.
The segment register&#39;s value was shifted by 4 bits to give the segment&#39;s 20-bit base address. The 16-bit offset address was added,
yielding a 20-bit memory address.
This gave the processor a 1-megabyte address space, although only 64K could be accessed without changing a segment register.
The 8086 had four segment registers so it could use multiple segments at the same time: the Code Segment, Data Segment, Stack Segment, and Extra Segment.</p>
<p>The 8086 chip is split into
two processing units: the Bus Interface Unit (BIU) that handles segments and memory accesses, and the Execution Unit (EU) that executes instructions.
The Execution Unit is what comes to mind when you think of a processor: it has most of the registers, the arithmetic/logic unit (ALU), and the microcode that implements instructions.
The Bus Interface Unit interacts with memory and other external systems, performing the steps necessary to read and write memory.</p>
<p>Among other things, the Bus Interface Unit has a separate adder for address calculation; this adds the segment register to the base address to
determine the final memory address.
Every memory access uses the address adder at least once to add the segment base and offset.
The address adder is also used to increment the program counter.
Finally, the address adder increments and decrements the index registers used for block operations.
This will be discussed in more detail below.</p>
<h2>Microcode in the 8086</h2>
<p>Most people think of machine instructions as the basic steps that a computer performs.
However, many processors (including the 8086) have another layer of software underneath: microcode.
With microcode, instead of building the control circuitry from complex logic gates, the control logic is largely replaced with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.
This provides a considerable performance improvement for the block operations, which requires many steps in a loop.
Performing this loop in microcode is considerably faster than writing the loop in assembly code.</p>
<!--
The 8086 uses a hybrid approach: although it uses microcode, much of the instruction functionality is implemented with gate logic.
This approach removed duplication from the microcode and kept the microcode small enough for 1978 technology.
In a sense, the microcode is parameterized.
For instance, the microcode can specify a generic Arithmetic/Logic Unit (ALU) operation and a generic register.
The gate logic examines the instruction to determine which specific operation to perform and the appropriate register.
-->

<p>A micro-instruction in the 8086 is encoded into 21 bits as shown below.
Every micro-instruction specifies a move operation from a source register to a destination register, each specified with 5 bits.
The meaning of the remaining bits depends on the type field and can be anything from an ALU operation to a memory read or write to
a change of microcode control flow.
Thus, an 8086 micro-instruction typically does two things in parallel: the move and the action.
For more about 8086 microcode, see my <a href="https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html">microcode blog post</a>.</p>
<p><a href="https://static.righto.com/images/8086-str/microcode-format.jpg"><img alt="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" height="203" src="https://static.righto.com/images/8086-str/microcode-format-w700.jpg" title="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" width="700"/></a></p>
<p>I&#39;ll explain the behavior of an ALU micro-operation since it is important for string operations.
The Arithmetic/Logic Unit (ALU) is the heart of the processor, performing addition, subtraction, and logical operations.
The ALU has three temporary input registers that are invisible to the programmer: tmpA, tmpB, and tmpC.
An ALU operation takes its first argument from any temporary register, while the second argument always comes from tmpB.
Performing an ALU operation requires two micro-instructions.
The first micro-instruction specifies the ALU operation and source register, configuring the ALU. For instance, <code>ADD tmpA</code> configures the ALU to add the tmpA register to the default tmpB register.
In the next micro-instruction (or a later one), the ALU result can be accessed through a special register called <code>Î£</code> (SIGMA) and moved to another register.</p>
<p>I&#39;ll also explain the memory read and write micro-operations.
A memory operation uses two internal registers: <code>IND</code> (Indirect) holds the memory address, while <code>OPR</code> (Operand) holds the word that is read or written.
A typical memory micro-instruction for a read is <code>R DS,BL</code>.
This causes the Bus Interface Unit to compute the memory address by adding the Data Segment (<code>DS</code>) to the <code>IND</code> register
and then perform the read.
The Bus Interface Unit determines if the instruction is performing a byte operation or a word operation and reads a byte or
word as appropriate, going through the necessary bus cycles.
The <code>BL</code> option<span id="fnref:bl"><a href="#fn:bl">3</a></span> causes the Bus Interface Unit to update the <code>IND</code> register as appropriate,<span id="fnref2:bl"><a href="#fn:bl">3</a></span>
incrementing or decrementing it by 1 or 2 depending on the Direction Flag and the
size of the access (byte or word).
All of this complexity happens in the hardware of the Bus Interface Unit and is invisible to the microcode.
The tradeoff is that this simplifies the microcode but makes the chip&#39;s hardware considerably more complicated.</p>
<h2>The string move instruction</h2>
<p>The 8086 has five types of string instructions, operating on blocks of memory:
<code>MOVS</code> (Move String), <code>CMPS</code> (Compare Strings), <code>SCAS</code> (Scan String), <code>LODS</code> (Load String), and <code>STOS</code> (Store String).
Each instruction operates on a byte or word, but by using a <code>REP</code> prefix, the operation can be repeated for up to 64k bytes,
controlled by a counter.
Conditional repetitions can terminate the loop on various conditions.
The string instructions provide a flexible way to operate on blocks of memory, much faster than a loop written in assembly code.</p>
<p>The <code>MOVS</code> (Move String) operation copies one memory region to another.
The <code>CMPS</code> (Compare Strings) operation compares two memory blocks and sets the status flags. In particular, this indicates if
one string is greater, less, or equal to the other.
The <code>SCAS</code> (Scan String) operation scans memory, looking for a particular value.
The <code>LODS</code> (Load String) operation moves an element into the accumulator, generally as part of a more complex loop.
Finally, <code>STOS</code> (Store String) stores the accumulator value, either to initialize a block of memory or as part of a more complex loop.<span id="fnref:morse"><a href="#fn:morse">4</a></span></p>
<p>Like many 8086 instructions, each string instruction has two opcodes: one that operates on bytes and one that operates on words.
One of the interesting features of the 8086 is that the same microcode implements the byte and word instructions, while the
hardware takes care of the byte- or word-sized operations as needed.
Another interesting feature of the string operations is that they can go forward through memory, incrementing the pointers,
or they can go backward, decrementing the points. A special processor flag, the Direction Flag, indicates the direction: 0 for incrementing
and 1 for decrementing.
Thus, there are four possibilities for stepping through memory, part of the flexibility of the string operations.</p>
<p>The flowchart below shows the complexity of these instructions. I&#39;m not going to explain the flowchart at this point, but
the point is that there is a lot going on. This functionality is implemented by the microcode.</p>
<p><a href="https://static.righto.com/images/8086-str/flowchart.png"><img alt="This flowchart shows the operation of a string instruction. From The 8086 Family Users Manual, fig 2-33." height="803" src="https://static.righto.com/images/8086-str/flowchart-w400.png" title="This flowchart shows the operation of a string instruction. From The 8086 Family Users Manual, fig 2-33." width="400"/></a></p>
<p>I&#39;ll start by explaining the <code>MOVS</code> (Move String) instruction, which moves (copies) a block of memory.
Before executing this instruction, the registers should be configured so
the <code>SI</code> Source Index register points to the first block, the <code>DI</code> Destination Index register points to the second block,
and the <code>CX</code> Count register holds the number of bytes or words to move.
The basic action of the <code>MOVS</code> instruction reads a byte (or word) from the <code>SI</code> address and updates <code>SI</code>, writes the value
to the <code>DI</code> address and updates <code>DI</code>, and decrements the <code>CX</code> counter.</p>
<p>The microcode block below is executed for the <code>MOVS</code> (and <code>LODS</code>) instructions.
There&#39;s a lot happening in this microcode with a variety of control paths, so it&#39;s a bit tricky to
understand, but let&#39;s see how it goes.
Each micro-instruction has a register-to-register move on the left and an action on the right, happening in parallel.
The first micro-instruction handles the <code>REP</code> prefix, if any; let&#39;s assume for now that there&#39;s no prefix so it is skipped.
Next is the read from memory, which requires the memory address to be in the <code>IND</code> register.
Thus, the micro-instruction moves <code>SI</code> to <code>IND</code> and starts the read cycle (<code>R DS,BL</code>).
When the read completes, the updated <code>IND</code> register is moved back to <code>SI</code>, updating that register.
Meanwhile, <code>X0</code> tests the opcode and jumps to &#34;8&#34; for <code>LODS</code>.
The <code>MOVS</code> path falls through, getting the address from the <code>DI</code> register and writing to memory the value that we just read.
The updated <code>IND</code> register is moved to <code>DI</code> while another conditional jump goes to &#34;7&#34; if there&#39;s no <code>REP</code> prefix.
Micro-instruction 7 performs an <code>RNI</code> (Run Next Instruction), which ends the microcode and causes the next
machine instruction to be decoded.
As you can see, microcode is very low-level.</p>
<pre> move       action           
           CALL F1 RPTS <span><b>MOVS/LODS:</b> handle REP if active</span>
SI â IND   R DS,BL      <span><b>1:</b> Read byte/word from SI</span>
IND â SI   JMPS X0 8     <span>test instruction bit 3: jump if LODS</span>
DI â IND   W DA,BL       <span>MOVS path: write to DI</span>
IND â DI   JMPS NF1 7   <span><b>4:</b> run next instruction if not REP</span>
Î£ â tmpC   JMP INT RPTI <span><b>5:</b> handle any interrupt</span>
tmpC â CX  JMPS NZ 1     <span>update CX, loop if not zero</span>
           RNI          <span><b>7:</b> run next instruction</span>

OPR â M    JMPS F1 5    <span><b>8:</b> LODS path: store AL/AX, jump back if REP</span>
           RNI           <span>run next instruction</span>
</pre>

<p>Now let&#39;s look at the case with a <code>REP</code> prefix, causing the instruction to loop.
The first step is to test if the count register <code>CX</code> is zero, and bail out of the loop if so.
In more detail, the <code>REP</code> prefix sets an internal flag called <code>F1</code>. The first micro-instruction for <code>MOVS</code> above conditionally calls the <code>RPTS</code> subroutine if <code>F1</code> is set.
The <code>RPTS</code> subroutine below is a bit tricky.
First, it moves the count in <code>CX</code> to the ALU&#39;s temporary C register. It also configures the ALU to pass tmpC through unchanged.
The next move discards the ALU result Î£, but as a side effect, sets a flag if the value is zero.
This micro-instruction also configures the ALU to perform <code>DEC tmpC</code>, but the decrement doesn&#39;t happen yet.
Next, if the value is nonzero (<code>NZ</code>), the microcode execution jumps to 10 and returns from the microcode subroutine,
continuing execution of the <code>MOVS</code> code described above.
On the other hand, if <code>CX</code> is zero, execution falls through to <code>RNI</code> (Run Next Instruction), which terminates execution of
the <code>MOVS</code> instruction.</p>
<pre>CX â tmpC     PASS tmpC   <span><b>RPTS:</b> test CX</span>
Î£ â no dest   DEC tmpC     <span>Set up decrement for later</span>
              JMPS NZ 10   <span>Jump to 10 if CX not zero</span>
              RNI          <span>If 0, run next instruction</span>
              RTN         <span><b>10:</b> return</span>
</pre>

<p>If execution returns to the <code>MOVS</code> microcode, it will execute as described earlier until the <code>NF1</code> test below.
With a <code>REP</code> prefix, the test fails and microcode execution falls through.
The next micro-instruction performs <code>Î£ â tmpC</code>, which puts the ALU result into tmpC.
The ALU was configured back in the <code>RPTS</code> subroutine to decrement tmpC, which holds the count from <code>CX</code>, so the
result is that <code>CX</code> is decremented, put into tmpC, and then put back into <code>CX</code> in the next micro-instruction.
It seems like a roundabout way to decrement the counter, but that&#39;s microcode.
Finally, if the value is nonzero (<code>NZ</code>), microcode execution jumps back to 1 (near the top of the <code>MOVS</code> code earlier), repeating the whole process.
Otherwise, <code>RNI</code> ends processing of the instruction.
Thus, the <code>MOVS</code> instruction repeats until <code>CX</code> is zero.
In the next section, I&#39;ll explain how <code>JMP INT RPTI</code> handles an interrupt.</p>
<pre>IND â DI   JMPS NF1 7   <span><b>4:</b> run next instruction if not REP</span>
Î£ â tmpC   JMP INT RPTI <span><b>5:</b> handle any interrupt</span>
tmpC â CX  JMPS NZ 1     <span>update CX, loop if not zero</span>
           RNI          <span><b>7:</b> run next instruction</span>
</pre>

<p>The <code>NZ</code> (not zero) condition tests a special 16-bit zero flag, not the standard zero status flag.
This allows zero to be tested without messing up the zero status flag.</p>
<h3>Interrupts</h3>
<p>Interrupts pose a problem for the string operations.
The idea behind interrupts is that the computer can be interrupted during processing to handle a high-priority task,
such as an I/O device that needs servicing. The processor stops its current task, executes the interrupt handling code,
and then returns to the original task.
The 8086 processor normally completes the instruction that it is executing before handling the
interrupt, so it can continue from a well-defined state.
However, a string operation can perform up to 64k moves, which could take a large fraction of a second.<span id="fnref:memory"><a href="#fn:memory">5</a></span>
If the 8086 waited for the string operation to complete, interrupt handling would be way too slow and could lose network packets or disk data, for instance.</p>
<p>The solution is that a string instruction can be interrupted in the middle of the instruction, unlike most instructions.
The string instructions are designed to use registers in a way that allows the instruction to be restarted.
The idea is that the <code>CX</code> register holds the current count, while the <code>SI</code> and <code>DI</code> registers hold the current memory
pointers, and these registers are updated as the instruction progresses. If the instruction is interrupted it can simply
continue where it left off.
After the interrupt, the 8086 restarts the string operation by backing the program counter up by two bytes
(one byte for the <code>REP</code> prefix and one byte for the string opcode.)
This causes the interrupted string operation to be re-executed, continuing where it left off.</p>
<p>If there is an interrupt, the <code>RPTI</code> microcode routine below is called to update the program counter.
Updating the program counter is harder than you&#39;d expect because the 8086 prefetches instructions.
The idea is that while the memory bus is idle, instructions are read from memory into a prefetch queue.
Then, when an instruction is needed, the processor can (hopefully) get the instruction immediately from the prefetch
queue instead of waiting for a memory access.
As a result, the program counter in the 8086 points to the memory address of the next instruction to <em>fetch</em>, not the
next instruction to <em>execute</em>.
To get the &#34;real&#34; program counter value, prefetching is first suspended (<code>SUSP</code>). Then the <code>PC</code> value is corrected (<code>CORR</code>) by subtracting the
length of the prefetch queue. At this point, the <code>PC</code> points to the next instruction to execute.</p>
<pre>tmpC â CX   SUSP        <span><b>RPTI:</b> store CX</span>
            CORR         <span>correct PC</span>
PC â tmpB   DEC2 tmpB  
Î£ â PC      FLUSH RNI    <span>PC -= 2, end instruction</span>
</pre>

<p>At last, the microcode gets to the purpose of this subroutine: the <code>PC</code> is decremented by 2 (<code>DEC2</code>) using the ALU.
The prefetch queue is flushed and restarted and the <code>RNI</code> micro-operation terminates the microcode and runs the next instruction.
Normally this would execute the instruction from the new program counter value (which now points to the string operation).
However, since there is an interrupt pending, the interrupt will take place instead, and the interrupt handler will
execute.
After the interrupt handler finishes, the interrupted string operation will be re-executed, continuing where it left off.</p>
<p>There&#39;s another complication, of course.
An 8086 instruction can have multiple prefixes attached,
for example using a segment register prefix to access a different segment.
The approach of backing up two bytes will only execute the
last prefix, ignoring any others, so if you have two prefixes, the instruction doesn&#39;t get restarted correctly.
The 8086 documentation describes this unfortunate behavior.
Apparently a comprehensive solution (e.g. counting the prefixes or providing a buffer to hold prefixes during an interrupt)
was impractical for the 8086. I think this was fixed in the 80286.</p>
<!-- p3-31 of the 8086/88/186/188 manual states this problem. http://www.bitsavers.org/components/intel/80186/210911-001_iAPX86_88_186_188_Programmers_Reference_1983.pdf  But the 286 manual doesn't mention it. -->

<h3>The remaining string instructions</h3>
<p>I&#39;ll discuss the microcode for the other string operations briefly.
The <code>LODS</code> instruction loads from memory into the accumulator. It uses the same microcode routine as <code>MOVS</code>; the code
below is the same code discussed earlier.
However, the path through the microcode is different for <code>LODS</code> since the <code>JMPS X0 8</code> conditional jump will be taken.
(This tests bit 3 of the opcode, which is set for <code>LODS</code>.)
At step 8, a value has been read from memory and is in the <code>OPR</code> (Operand) register. 
This micro-instruction moves the value from <code>OPR</code> to the accumulator (represented by <code>M</code> for complicated reasons<span id="fnref:m"><a href="#fn:m">6</a></span>).
If there is a repeat prefix, the microcode jumps back to the previous flow (5). Otherwise, <code>RNI</code> runs the next instruction.
Thus, <code>LODS</code> shares almost all its microcode with <code>MOVS</code>, making the microcode more compact at the cost of slowing it
down slightly due to the conditional jumps.</p>
<pre> move       action           
           CALL F1 RPTS <span><b>MOVS/LODS:</b> handle REP if active</span>
SI â IND   R DS,BL      <span><b>1:</b> Read byte/word from SI</span>
IND â SI   JMPS X0 8     <span>test instruction bit 3: jump if LODS</span>
DI â IND   W DA,BL       <span>MOVS path: write to DI</span>
IND â DI   JMPS NF1 7   <span><b>4:</b> run next instruction if not REP</span>
Î£ â tmpC   JMP INT RPTI <span><b>5:</b> handle any interrupt</span>
tmpC â CX  JMPS NZ 1     <span>update CX, loop if not zero</span>
           RNI          <span><b>7:</b> run next instruction</span>

OPR â M    JMPS F1 5    <span><b>8:</b> LODS path: store AL/AX, jump back if REP</span>
           RNI           <span>run next instruction</span>
</pre>
<p>The <code>STOS</code> instruction is the opposite of <code>LODS</code>, storing the accumulator value into memory.
The microcode (below) is essentially the second half of the <code>MOVS</code> microcode.
The memory address in <code>DI</code> is moved to the <code>IND</code> register and the value in the accumulator is moved to the <code>OPR</code> register
to set up the write operation. (As with <code>LODS</code>, the <code>M</code> register indicates the accumulator.<span id="fnref2:m"><a href="#fn:m">6</a></span>)
The <code>CX</code> register is decremented using the ALU.</p>
<pre>DI â IND    CALL F1 RPTS   <span><b>STOS:</b> if REP prefix, test if done</span>
M â OPR     W DA,BL        <span><b>1:</b> write the value to memory</span>
IND â DI    JMPS NF1 5      <span>Quit if not F1 (repeat)</span>
Î£ â tmpC    JMP INT RPTI    <span>Jump to RPTI if interrupt</span>
tmpC â CX   JMPS NZ 1       <span>Loop back if CX not zero</span>
            RNI            <span><b>5:</b> run next instruction</span>
</pre>

<p>The <code>CMPS</code> instruction compares strings, while the <code>SCAS</code> instruction looks for a zero or non-zero value, depending on the prefix.
They share the microcode routine below, with the <code>X0</code> condition testing bit 3 of the instruction to select the path.
The difference is that <code>CMPS</code> reads the comparison character
from <code>SI</code>, while <code>SCAS</code> compares against the character in the accumulator. 
The comparison itself is done by subtracting the two values and discarding the result. The <code>F</code> bit in the micro-instruction causes the processor&#39;s status flags to
be updated with the result of the subtraction, indicating less than, equal, or greater than.</p>
<pre>            CALL F1 RPTS   <span><b>CMPS/SCAS:</b> if RPT, quit if done</span>
M â tmpA    JMPS X0 5      <span><b>1:</b>accum to tmpA, jump if SCAS</span>
SI â IND    R DS,BL         <span>CMPS path, read from SI to tmpA</span>
IND â SI                    <span>update SI</span>
OPR â tmpA                  <span>fallthrough</span>
DI â IND    R DA,BL        <span><b>5:</b> both: read from DI to tmpB</span>
OPR â tmpB  SUBT tmpA       <span>subtract to compare</span>
Î£ â no dest DEC tmpC F      <span>update flags, set up DEC</span>
IND â DI    JMPS NF1 12     <span>return if not RPT</span>
Î£ â CX      JMPS F1ZZ 12    <span>update CX, exit if condition</span>
Î£ â tmpC    JMP INT RPTI    <span>if interrupt, jump to RPTI</span>
            JMPS NZ 1       <span>loop if CX â  0</span>
            RNI            <span><b>12:</b> run next instruction</span>
</pre>

<p>One tricky part about the scan and compare instructions is that you can either repeat until the values are equal or until they are unequal,
with the <code>REPE</code> or <code>REPNE</code> prefixes respectively. Rather than implementing this two-part condition in microcode, the <code>F1ZZ</code> condition above
tests the right condition depending on the prefix.</p>
<h2>Hardware support</h2>
<p>Although the 8086 uses microcode to implement instructions, it also uses a considerable amount of hardware to
simplify the microcode.
This hybrid approach was necessary in order to fit the microcode into the small ROM capacity available in 1978.<span id="fnref:microcode"><a href="#fn:microcode">7</a></span>
This section discusses some of the hardware circuitry in the 8086 that supports the string operations.</p>
<h3>Implementing the <code>REP</code> prefixes</h3>
<p>Instruction prefixes, including <code>REPNZ</code> and <code>REPZ</code>, are executed in hardware rather than microcode.
The first step of instruction decoding, before microcode starts, is the Group Decode ROM.
This ROM categorizes instructions into various groups.
For instructions that are categorized as prefixes, the signal from the Group Decode ROM
delays any interrupts (because you don&#39;t want an interrupt between the prefix and the instruction)
and starts the next instruction without executing microcode.
The Group Decode ROM also outputs a <code>REP</code> signal specifically for these two prefixes.
This signal causes the <code>F1</code> latch to be loaded with 1, indicating a <code>REP</code> prefix.
(This latch is also used during multiplication to track the sign.)
This signal also causes the <code>F1Z</code> latch to be loaded with bit 0 of the instruction, which is 0 for <code>REPNZ</code> and 1 for <code>REPZ</code>.
The microcode uses these latches to determine the appropriate behavior of the string instruction.</p>
<h3>Updating <code>SI</code> and <code>DI</code>: the Constant ROM</h3>
<p>The <code>SI</code> and <code>DI</code> index registers are updated during each step to point to the next element.
This update is more complicated than you might expect, though, since
the registers are incremented or decremented based on the Direction Flag.
Moreover, the step size, 1 or 2, varies for a byte or word operation.
Another complication is unaligned word accesses, using an odd memory address to access a word.
The 8086&#39;s bus can only handle aligned words, so an unaligned word access is split into two byte accesses, incrementing
the address after the first access.
If the operation is proceeding downward, the address then needs to be decremented by 3 (not 2) at the end to
cancel out this increment.
The point is that updating the index registers is not trivial but requires an adjustment anywhere between -3 and +2, depending
on the circumstances.</p>
<p>The Bus Interface Unit performs these updates automatically, without requiring the microcode to implement the addition or subtraction.
The arithmetic is not performed by the regular ALU (Arithmetic/Logic Unit) but by the special adder dedicated to addressing
arithmetic.
The increment or decrement value is supplied by a special ROM called the Constant ROM, located next to the adder.
The Constant ROM (shown below) is implemented as a PLA (programmable logic array), a two-level structured arrangement of gates.
The first level (bottom) selects the desired constant, while the second level (middle) generates the bits of the constant: three bits plus a sign bit.
The constant ROM is also used for correcting the program counter value as described earlier.</p>
<p><a href="https://static.righto.com/images/8086-str/constant-die.jpg"><img alt="The Constant ROM, highlighted on the die. The correction constants are used to correct the PC." height="451" src="https://static.righto.com/images/8086-str/constant-die-w400.jpg" title="The Constant ROM, highlighted on the die. The correction constants are used to correct the PC." width="400"/></a></p><p>The Constant ROM, highlighted on the die. The correction constants are used to correct the PC.</p>
<h3>Condition testing</h3>
<p>The microcode supports conditional jumps based on 16 conditions. Several of these conditions are designed to support the 
string operations.
To test if a <code>REP</code> prefix is active, microcode uses the <code>F1</code> test, which tests the <code>F1</code> latch.
The <code>REPZ</code> and <code>REPNZ</code> prefixes loop while the zero flag is 1 or 0 respectively.
This somewhat complicated test is supported in microcode by the <code>F1ZZ</code> condition, which evaluates the zero flag XOR the <code>F1Z</code> latch. Thus, it tests for zero with REPZ (<code>F1Z=0</code>) and nonzero with REPNZ (<code>F1Z=1</code>).</p>
<p>Looping happens as long as the <code>CX</code> register is nonzero. This is tested in microcode with the <code>NZ</code> (Not Zero) condition.
A bit surprisingly, this test doesn&#39;t use the standard zero status flag, but a separate latch that tracks if an ALU result is zero.
(I call this the <code>Z16</code> flag since it tests the 16-bit value, unlike the regular zero flag which tests either a byte or word.)
The <code>Z16</code> flag is only used by the microcode and is invisible to the programmer.
The motivation behind this separate flag is so the string operations can leave the visible zero flag unchanged.<span id="fnref:z16"><a href="#fn:z16">8</a></span></p>
<p>Another important conditional jump is <code>X0</code>, which tests bit 3 of the instruction.
This condition distinguishes between the <code>MOVS</code> and <code>LODS</code> instructions, which differ in bit 3, and similarly for
<code>CMPS</code> versus <code>SCAS</code>.
The test uses the <code>X</code> register which stores part of the instruction during decoding.
Note that the opcodes aren&#39;t arbitrarily assigned to instructions like <code>MOVS</code> and <code>LODS</code>. Instead, the opcodes
are carefully assigned so the instructions can share microcode but be distinguished by <code>X0</code>.
Finally, the string operation microcode also uses the <code>INT</code> condition, which tests if an interrupt is pending.</p>
<p>The conditions are evaluated by the condition PLA (Programmable Logic Array, a grid of gates), shown below.
The four condition bits from the micro-instruction, along with their complements, are fed into the columns.
The PLA has 16 rows, one for each condition. 
Each row is a NOR gate matching one bit combination (i.e. selecting a condition) and the corresponding signal value to
test.
Thus, if a particular condition is specified and is satisfied, that row will be 1.
The 16 row outputs are combined by the 16-input NOR gate at the left.
Thus, if the specified condition is satisfied, this output will be 0, and if the condition is unsatisfied, the
output will be 1.
This signal controls the jump or call micro-instruction:
if the condition is satisfied, the new micro-address is loaded into the microcode address register.
If the condition is not satisfied, the microcode proceeds sequentially.
I discuss the 8086&#39;s conditional circuitry in more detail in <a href="https://www.righto.com/2023/01/reverse-engineering-conditional-jump.html">this post</a>.</p>
<p><a href="https://static.righto.com/images/8086-str/condition-pla.jpg"><img alt="The condition PLA evaluates microcode conditionals." height="467" src="https://static.righto.com/images/8086-str/condition-pla-w300.jpg" title="The condition PLA evaluates microcode conditionals." width="300"/></a></p><p>The condition PLA evaluates microcode conditionals.</p>
<h2>Conclusions</h2>
<!--
These string instructions live on in the modern x86 architecture, mostly the same except they also support operation on double words or quad words (i.e. 32- or 64-bit operands).[^ins]

[^ins]:
    The 80186 added block instructions to support block I/O: `INS` and `OUTS`.
-->

<p>Hopefully you have found this close examination of microcode interesting.
Microcode is implemented at an even lower level than assembly code, so it can be hard to understand.
Moreover, the microcode in the 8086 was carefully optimized to make it compact, so it is even more obscure.</p>
<p>One of the big computer architecture debates of the 1980s was &#34;<a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer">RISC vs CISC</a>&#34;, pitting Reduced Instruction Set Computers against Complex Instruction Set Computers.
Looking at the 8086 in detail has given me more appreciation for the issues in a CISC processor such as the 8086.
The 8086&#39;s string instructions are an example of the complex instructions in the 8086 that reduced the &#34;semantic gap&#34;
between assembly code and high-level languages and minimized code size.
While these instructions are powerful, their complexity spreads through the chip, requiring additional hardware features
described above. These instructions also caused a great deal of complications for interrupt handling, including prefix-handling
bugs that weren&#39;t fixed until later processors.</p>
<p>I&#39;ve written multiple <a href="https://www.righto.com/search/label/8086">posts on the 8086</a> so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter <a href="https://twitter.com/kenshirriff">@kenshirriff</a> or <a href="https://www.righto.com/feeds/posts/default">RSS</a> for updates.
I&#39;ve also started experimenting with Mastodon recently as <a href="https://oldbytes.space/@kenshirriff">@<span data-cfemail="49222c273a21203b3b202f2f0926252d2b303d2c3a673a39282a2c">[emailÂ protected]</span></a>.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
