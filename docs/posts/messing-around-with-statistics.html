<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bytes.zone/micro/thing-a-month-03-01/">Original</a>
    <h1>messing around with statistics</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>Brian Hicks, March 5, 2024</em></p><p>The basic idea behind TagTime is:</p><ol><li>Choose how often you want to be asked what you&#39;re up to. This constant is called λ. Let&#39;s assume that <code>λ = 1</code> for now, which will mean &#34;once per hour.&#34; If you wanted to be asked every 30 minutes (on average) you could set this to 2.</li><li>Schedule pings (instances of being asked what you&#39;re doing) into the future following a Poisson distribution (which means the time between pings follows an exponential distribution with an average of λ.) <span id="continue-reading"></span><ul><li>It seems like the way to do this might be to generate a random value between 0 and 1 and plug it in like so: <code>math.log(random.random()) / lambda * -1</code></li></ul></li><li>Since you know the time between pings averages out to λ, you perform analysis as if each ping was worth λ time (so if it&#39;s 1, and that means 1 per hour, that means each ping is worth one hour.)</li></ol><p>I&#39;m going to try this out and see how it works, just to test my understanding of the math. I&#39;m going to write a Python program simulating someone with a very simple and strict schedule. Specifically:</p><table><thead><tr><th>What</th><th>Start</th><th>End</th></tr></thead><tbody><tr><td>Sleep</td><td>10:00pm</td><td>6:00am</td></tr><tr><td>Morning Activities</td><td>6am</td><td>7:30am</td></tr><tr><td>Commute</td><td>7:30am</td><td>8:00am</td></tr><tr><td>Work</td><td>8:00am</td><td>12:00pm</td></tr><tr><td>Lunch</td><td>12:00pm</td><td>1:00pm</td></tr><tr><td>Work</td><td>1:00pm</td><td>2:30pm</td></tr><tr><td>Afternoon Coffee</td><td>2:30pm</td><td>2:36pm</td></tr><tr><td>Work</td><td>2:36pm</td><td>5:00pm</td></tr><tr><td>Commute</td><td>5:00pm</td><td>5:30pm</td></tr><tr><td>Evening Activities</td><td>5:30pm</td><td>10:00pm</td></tr><tr><td>Some points of interest:</td><td></td><td></td></tr></tbody></table><ul><li>Lots of the schedule doesn&#39;t fall exactly on hour boundaries.</li><li>A few of the activities are shorter than an hour.</li><li>One activity is tiny! Making coffee every day takes 6 minutes exactly (one tenth of an hour.)</li></ul><p>I&#39;m doing that to see how much data this system actually needs to capture smaller changes in activity throughout the day.</p><p>Here&#39;s a Python script that can generate pings according to this schedule:</p><pre data-lang="python"><code data-lang="python"><span>#!/usr/bin/env python3
</span><span>import </span><span>argparse
</span><span>from </span><span>datetime </span><span>import </span><span>datetime, timedelta
</span><span>import </span><span>json
</span><span>import </span><span>math
</span><span>import </span><span>random
</span><span>import </span><span>sys
</span><span>
</span><span>
</span><span>def </span><span>tag</span><span>(</span><span>ping</span><span>):
</span><span>    time </span><span>= </span><span>(ping.hour, ping.minute)
</span><span>
</span><span>    </span><span>if </span><span>time </span><span>&gt;= </span><span>(</span><span>22</span><span>, </span><span>0</span><span>) </span><span>or </span><span>time </span><span>&lt; </span><span>(</span><span>6</span><span>, </span><span>0</span><span>): </span><span># 8 hours
</span><span>        </span><span>return </span><span>&#39;sleep&#39;
</span><span>    </span><span>elif </span><span>time </span><span>&gt;= </span><span>(</span><span>6</span><span>, </span><span>0</span><span>) </span><span>and </span><span>time </span><span>&lt; </span><span>(</span><span>7</span><span>, </span><span>30</span><span>): </span><span># 1.5 hours
</span><span>        </span><span>return </span><span>&#39;morning&#39;
</span><span>    </span><span>elif </span><span>time </span><span>&gt;= </span><span>(</span><span>7</span><span>, </span><span>30</span><span>) </span><span>and </span><span>time </span><span>&lt; </span><span>(</span><span>8</span><span>, </span><span>0</span><span>): </span><span># 0.5 hours
</span><span>        </span><span>return </span><span>&#39;commute&#39;
</span><span>    </span><span>elif </span><span>time </span><span>&gt;= </span><span>(</span><span>8</span><span>, </span><span>0</span><span>) </span><span>and </span><span>time </span><span>&lt; </span><span>(</span><span>12</span><span>, </span><span>0</span><span>): </span><span># 4 hours
</span><span>        </span><span>return </span><span>&#39;work&#39;
</span><span>    </span><span>elif </span><span>time </span><span>&gt;= </span><span>(</span><span>12</span><span>, </span><span>0</span><span>) </span><span>and </span><span>time </span><span>&lt; </span><span>(</span><span>13</span><span>, </span><span>0</span><span>): </span><span># 1 hour
</span><span>        </span><span>return </span><span>&#39;lunch&#39;
</span><span>    </span><span>elif </span><span>time </span><span>&gt;= </span><span>(</span><span>13</span><span>, </span><span>0</span><span>) </span><span>and </span><span>time </span><span>&lt; </span><span>(</span><span>14</span><span>, </span><span>30</span><span>): </span><span># 1.5 hours
</span><span>        </span><span>return </span><span>&#39;work&#39;
</span><span>    </span><span>elif </span><span>time </span><span>&gt;= </span><span>(</span><span>14</span><span>, </span><span>30</span><span>) </span><span>and </span><span>time </span><span>&lt; </span><span>(</span><span>14</span><span>, </span><span>36</span><span>): </span><span># 0.1 hours
</span><span>        </span><span>return </span><span>&#39;coffee&#39;
</span><span>    </span><span>elif </span><span>time </span><span>&gt;= </span><span>(</span><span>14</span><span>, </span><span>36</span><span>) </span><span>and </span><span>time </span><span>&lt; </span><span>(</span><span>17</span><span>, </span><span>0</span><span>): </span><span># 2.4 hours
</span><span>        </span><span>return </span><span>&#39;work&#39;
</span><span>    </span><span>elif </span><span>time </span><span>&gt;= </span><span>(</span><span>17</span><span>, </span><span>0</span><span>) </span><span>and </span><span>time </span><span>&lt; </span><span>(</span><span>17</span><span>, </span><span>30</span><span>): </span><span># 0.5 hours
</span><span>        </span><span>return </span><span>&#39;commute&#39;
</span><span>    </span><span>elif </span><span>time </span><span>&gt;= </span><span>(</span><span>17</span><span>, </span><span>30</span><span>) </span><span>and </span><span>time </span><span>&lt; </span><span>(</span><span>22</span><span>, </span><span>0</span><span>): </span><span># 4.5 hours
</span><span>        </span><span>return </span><span>&#39;evening&#39;
</span><span>    </span><span>else</span><span>:
</span><span>        </span><span>return </span><span>None
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>(</span><span>args</span><span>):
</span><span>    entries </span><span>= </span><span>[]
</span><span>
</span><span>    next_ping </span><span>= </span><span>datetime.</span><span>now</span><span>()
</span><span>    end </span><span>= </span><span>next_ping </span><span>+ </span><span>timedelta</span><span>(</span><span>days </span><span>= </span><span>args.days)
</span><span>
</span><span>    </span><span>while </span><span>next_ping </span><span>&lt;= </span><span>end:
</span><span>        entries.</span><span>append</span><span>({ </span><span>&#34;at&#34;</span><span>: next_ping.</span><span>isoformat</span><span>(), </span><span>&#34;tag&#34;</span><span>: </span><span>tag</span><span>(next_ping) })
</span><span>
</span><span>        next_gap </span><span>= </span><span>math.</span><span>log</span><span>(random.</span><span>random</span><span>()) </span><span>/ </span><span>args.l </span><span>* -</span><span>1
</span><span>        next_ping </span><span>+= </span><span>timedelta</span><span>(</span><span>hours </span><span>= </span><span>next_gap)
</span><span>
</span><span>    json.</span><span>dump</span><span>(entries, sys.stdout, </span><span>indent</span><span>=</span><span>2</span><span>)
</span><span>
</span><span>
</span><span>if </span><span>__name__ </span><span>== </span><span>&#39;__main__&#39;</span><span>:
</span><span>    parser </span><span>= </span><span>argparse.</span><span>ArgumentParser</span><span>()
</span><span>    parser.</span><span>add_argument</span><span>(</span><span>&#39;days&#39;</span><span>, </span><span>type</span><span>=</span><span>int)
</span><span>    parser.</span><span>add_argument</span><span>(</span><span>&#39;-l&#39;</span><span>, </span><span>type</span><span>=</span><span>float, </span><span>default</span><span>=</span><span>&#39;1&#39;</span><span>)
</span><span>
</span><span>    </span><span>main</span><span>(parser.</span><span>parse_args</span><span>())
</span></code></pre><p>Next we assume that each ping is <code>1 / λ</code> hours and calculate both the total time for all the pings. That total time comes out pretty close to what I&#39;d expect: for a week, I&#39;d expect 168 pings if there&#39;s an average of one an hour and I&#39;m getting like 173, 141, 167, 148, etc.</p><p>We sum up the total time per tag, then find out the standard error from the mean for each tag to get a range. Here&#39;s the Python code that slurps up the <code>stdout</code> of the last script:</p><pre data-lang="python"><code data-lang="python"><span>#!/usr/bin/env python3
</span><span>import </span><span>argparse
</span><span>import </span><span>collections
</span><span>from </span><span>datetime </span><span>import </span><span>datetime
</span><span>import </span><span>json
</span><span>import </span><span>math
</span><span>import </span><span>sys
</span><span>
</span><span>
</span><span>class </span><span>Ping</span><span>:
</span><span>    </span><span>def </span><span>__init__</span><span>(</span><span>self</span><span>, </span><span>at</span><span>, </span><span>tag</span><span>):
</span><span>        </span><span>self</span><span>.at </span><span>= </span><span>at
</span><span>        </span><span>self</span><span>.tag </span><span>= </span><span>tag
</span><span>
</span><span>    @</span><span>classmethod
</span><span>    </span><span>def </span><span>from_json</span><span>(</span><span>cls</span><span>, </span><span>obj</span><span>):
</span><span>        </span><span>return </span><span>cls</span><span>(datetime.</span><span>fromisoformat</span><span>(obj[</span><span>&#39;at&#39;</span><span>]), obj[</span><span>&#39;tag&#39;</span><span>])
</span><span>
</span><span>    </span><span>def </span><span>__repr__</span><span>(</span><span>self</span><span>):
</span><span>        </span><span>return f</span><span>&#34;&lt;Ping at=</span><span>{</span><span>repr</span><span>(</span><span>self</span><span>.at)}</span><span> tag=</span><span>{</span><span>repr</span><span>(</span><span>self</span><span>.tag)}</span><span>&gt;&#34;
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>(</span><span>args</span><span>):
</span><span>    pings </span><span>= </span><span>[Ping.</span><span>from_json</span><span>(obj) </span><span>for </span><span>obj </span><span>in </span><span>json.</span><span>load</span><span>(sys.stdin)]
</span><span>
</span><span>    total_hours </span><span>= </span><span>len</span><span>(pings) </span><span>* </span><span>(</span><span>1 </span><span>/ </span><span>args.l)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;From </span><span>{total_hours}</span><span> hours tracked...</span><span>\n</span><span>&#34;</span><span>)
</span><span>
</span><span>    total_hours_by_tag </span><span>= </span><span>collections.</span><span>Counter</span><span>()
</span><span>    </span><span>for </span><span>ping </span><span>in </span><span>pings:
</span><span>        total_hours_by_tag[ping.tag] </span><span>+= </span><span>1 </span><span>/ </span><span>args.l
</span><span>
</span><span>    </span><span>for </span><span>(tag, tag_total) </span><span>in </span><span>total_hours_by_tag.</span><span>most_common</span><span>():
</span><span>        proportion </span><span>= </span><span>tag_total </span><span>/ </span><span>total_hours
</span><span>        other_ping_proportion </span><span>= </span><span>1 </span><span>- </span><span>proportion
</span><span>        sem </span><span>= </span><span>math.</span><span>sqrt</span><span>(proportion </span><span>* </span><span>other_ping_proportion </span><span>/ </span><span>total_hours)
</span><span>
</span><span>        </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{tag}</span><span>\t</span><span>{tag_total}</span><span> hours</span><span>\t</span><span>plus or minus </span><span>{sem </span><span>* </span><span>total_hours</span><span>:.2f</span><span>}</span><span> hours&#34;</span><span>)
</span><span>
</span><span>
</span><span>if </span><span>__name__ </span><span>== </span><span>&#39;__main__&#39;</span><span>:
</span><span>    parser </span><span>= </span><span>argparse.</span><span>ArgumentParser</span><span>()
</span><span>    parser.</span><span>add_argument</span><span>(</span><span>&#39;-l&#39;</span><span>, </span><span>type</span><span>=</span><span>float, </span><span>default</span><span>=</span><span>1</span><span>)
</span><span>
</span><span>    </span><span>main</span><span>(parser.</span><span>parse_args</span><span>())
</span></code></pre><p>That outputs things like this:</p><pre><code><span>From 158.0 hours tracked...
</span><span>
</span><span>sleep	56.0 hours	plus or minus 6.01 hours
</span><span>work	45.0 hours	plus or minus 5.67 hours
</span><span>evening	26.0 hours	plus or minus 4.66 hours
</span><span>morning	12.0 hours	plus or minus 3.33 hours
</span><span>commute	10.0 hours	plus or minus 3.06 hours
</span><span>lunch	9.0 hours	plus or minus 2.91 hours
</span></code></pre><p>Or this:</p><pre><code><span>From 193.0 hours tracked...
</span><span>
</span><span>sleep	67.0 hours	plus or minus 6.61 hours
</span><span>work	58.0 hours	plus or minus 6.37 hours
</span><span>evening	40.0 hours	plus or minus 5.63 hours
</span><span>morning	13.0 hours	plus or minus 3.48 hours
</span><span>lunch	7.0 hours	plus or minus 2.60 hours
</span><span>commute	6.0 hours	plus or minus 2.41 hours
</span><span>coffee	2.0 hours	plus or minus 1.41 hours
</span></code></pre><p>These are reasonably accurate! For any 7-day period, here&#39;s how the &#34;actual&#34; time compared to the statistics:</p><table><thead><tr><th>Tag</th><th>Actual</th><th>Sample 1</th><th>Sample 2</th></tr></thead><tbody><tr><td>sleep</td><td>56h</td><td>✅ 56 ± 6.01</td><td>✅ 67 ± 6.61</td></tr><tr><td>work</td><td>55.3h</td><td>❌ 45 ± 5.67</td><td>✅ 58 ± 6.37</td></tr><tr><td>evening</td><td>31.5h</td><td>❌ 26 ± 4.66</td><td>❌ 40 ± 5.63</td></tr><tr><td>morning</td><td>10.5h</td><td>✅ 12 ± 3.33</td><td>✅ 13 ± 3.48</td></tr><tr><td>commute</td><td>7h</td><td>✅ 10 ± 3.06</td><td>✅ 6 ± 2.41</td></tr><tr><td>lunch</td><td>7h</td><td>✅ 9 ± 2.91</td><td>✅ 7 ± 2.60</td></tr><tr><td>coffee</td><td>0.7h</td><td>❌ did not capture</td><td>✅ 2 ± 1.41</td></tr><tr><td>I put a ✅ when the range covers the actual value and an ❌ when it doesn&#39;t. As you can see, these samples get in the ballpark but the ranges don&#39;t always cover the actual values. However, these would definitely be good enough to get a sense of how you&#39;re spending your life as a whole, so maybe it&#39;s OK!</td><td></td><td></td><td></td></tr></tbody></table><p>I wonder, though, if it gets more accurate if you sample more frequently. An average of a half hour seems like it&#39;d get annoying (because of the exponential distribution, some pings would be very close together) but I wonder about 45 minutes. Let&#39;s try. That&#39;s a λ of 1⅓. Here&#39;s the results:</p><table><thead><tr><th>Tag</th><th>Actual</th><th>Sample 1</th><th>Sample 2</th></tr></thead><tbody><tr><td>sleep</td><td>56h</td><td>✅ 60.75 ± 6.3</td><td>✅ 61.5 ± 6.14</td></tr><tr><td>work</td><td>55.3h</td><td>✅ 59.25 ± 6.26</td><td>❌ 48.75 ± 5.81</td></tr><tr><td>evening</td><td>31.5h</td><td>✅ 27 ± 4.78</td><td>✅ 29.25 ± 4.89</td></tr><tr><td>morning</td><td>10.5h</td><td>✅ 10.5 ± 3.14</td><td>❌ 4.5 ± 2.09</td></tr><tr><td>commute</td><td>7h</td><td>✅ 6.75 ± 2.55</td><td>✅ 8.25 ± 2.8</td></tr><tr><td>lunch</td><td>7h</td><td>✅ 9 ± 2.92</td><td>✅ 6.75 ± 2.54</td></tr><tr><td>coffee</td><td>0.7h</td><td>✅ 1.5 ± 1.22</td><td>❌ did not capture</td></tr><tr><td>That seems about the same. The ranges don&#39;t feel like they&#39;re that much smaller to me. Maybe half an hour really would be better?</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>Tag</th><th>Actual</th><th>Sample 1</th><th>Sample 2</th></tr></thead><tbody><tr><td>sleep</td><td>56h</td><td>✅ 54 ± 6.04</td><td>✅ 52.5 ± 5.98</td></tr><tr><td>work</td><td>55.3h</td><td>✅ 52 ± 5.98</td><td>✅ 49.5 ± 5.89</td></tr><tr><td>evening</td><td>31.5h</td><td>✅ 33.5 ± 5.17</td><td>✅ 34 ± 5.2</td></tr><tr><td>morning</td><td>10.5h</td><td>✅ 10 ± 3.07</td><td>✅ 14 ± 3.58</td></tr><tr><td>commute</td><td>7h</td><td>✅ 7 ± 2.59</td><td>✅ 7 ± 2.59</td></tr><tr><td>lunch</td><td>7h</td><td>✅ 8 ± 2.76</td><td>✅ 7 ± 2.59</td></tr><tr><td>coffee</td><td>0.7h</td><td>✅ 1.5 ± 1.22</td><td>✅ 1 ± 1</td></tr><tr><td>Those two samples happen to be all green, but some of them <em>barely</em> squeaked in. I still think a λ of 30 minutes would be far too annoying, so I&#39;m going to leave it out.</td><td></td><td></td><td></td></tr></tbody></table><p>Next I&#39;m going to go and see if this is the same stuff that the Perl version of TagTime <em>actually</em> uses, and then maybe repeat this analysis!</p></article></div>
  </body>
</html>
