<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://0x80.pl/notesen/2023-03-06-swar-find-any.html">Original</a>
    <h1>SWAR: Find any byte from set</h1>
    
    <div id="readability-page-1" class="page"><div id="swar-find-any-byte-from-set">

<table>
<colgroup><col/>
<col/>
</colgroup><tbody>

<tr><th>Added on:</th><td>2023-03-06</td>
</tr>
</tbody>
</table>

<div id="introduction">

<p>When I was browsing the source code of project <a href="https://github.com/ada-url/ada">Ada</a> (<em>WHATWG-compliant
and fast URL parser written in modern C++</em>) the following procedure
caught my attention:</p>
<pre><span>ada_really_inline</span><span> </span><span>size_t</span><span> </span><span>find_authority_delimiter_special</span><span>(</span><span>std</span><span>::</span><span>string_view</span><span> </span><span>view</span><span>)</span><span> </span><span>noexcept</span><span> </span><span>{</span><span>
  </span><span>auto</span><span> </span><span>has_zero_byte</span><span> </span><span>=</span><span> </span><span>[](</span><span>uint64_t</span><span> </span><span>v</span><span>)</span><span> </span><span>{</span><span>
    </span><span>return</span><span> </span><span>((</span><span>v</span><span> </span><span>-</span><span> </span><span>0x0101010101010101</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>(</span><span>v</span><span>)</span><span>&amp;</span><span>0x8080808080808080</span><span>);</span><span>
  </span><span>};</span><span>
  </span><span>auto</span><span> </span><span>index_of_first_set_byte</span><span> </span><span>=</span><span> </span><span>[](</span><span>uint64_t</span><span> </span><span>v</span><span>)</span><span> </span><span>{</span><span>
    </span><span>return</span><span> </span><span>((((</span><span>v</span><span> </span><span>-</span><span> </span><span>1</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x101010101010101</span><span>)</span><span> </span><span>*</span><span> </span><span>0x101010101010101</span><span>)</span><span> </span><span>&gt;&gt;</span><span> </span><span>56</span><span>)</span><span> </span><span>-</span><span> </span><span>1</span><span>;</span><span>
  </span><span>};</span><span>
  </span><span>auto</span><span> </span><span>broadcast</span><span> </span><span>=</span><span> </span><span>[](</span><span>uint8_t</span><span> </span><span>v</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>uint64_t</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>0x101010101010101</span><span> </span><span>*</span><span> </span><span>v</span><span>;</span><span> </span><span>};</span><span>
  </span><span>size_t</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
  </span><span>uint64_t</span><span> </span><span>mask1</span><span> </span><span>=</span><span> </span><span>broadcast</span><span>(</span><span>&#39;@&#39;</span><span>);</span><span>
  </span><span>uint64_t</span><span> </span><span>mask2</span><span> </span><span>=</span><span> </span><span>broadcast</span><span>(</span><span>&#39;/&#39;</span><span>);</span><span>
  </span><span>uint64_t</span><span> </span><span>mask3</span><span> </span><span>=</span><span> </span><span>broadcast</span><span>(</span><span>&#39;?&#39;</span><span>);</span><span>
  </span><span>uint64_t</span><span> </span><span>mask4</span><span> </span><span>=</span><span> </span><span>broadcast</span><span>(</span><span>&#39;\\&#39;</span><span>);</span><span>

  </span><span>for</span><span> </span><span>(;</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>7</span><span> </span><span>&lt;</span><span> </span><span>view</span><span>.</span><span>size</span><span>();</span><span> </span><span>i</span><span> </span><span>+=</span><span> </span><span>8</span><span>)</span><span> </span><span>{</span><span>
    </span><span>uint64_t</span><span> </span><span>word</span><span>{};</span><span>
    </span><span>memcpy</span><span>(</span><span>&amp;</span><span>word</span><span>,</span><span> </span><span>view</span><span>.</span><span>data</span><span>()</span><span> </span><span>+</span><span> </span><span>i</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>word</span><span>));</span><span>
    </span><span>word</span><span> </span><span>=</span><span> </span><span>swap_bytes_if_big_endian</span><span>(</span><span>word</span><span>);</span><span>
    </span><span>uint64_t</span><span> </span><span>xor1</span><span> </span><span>=</span><span> </span><span>word</span><span> </span><span>^</span><span> </span><span>mask1</span><span>;</span><span>
    </span><span>uint64_t</span><span> </span><span>xor2</span><span> </span><span>=</span><span> </span><span>word</span><span> </span><span>^</span><span> </span><span>mask2</span><span>;</span><span>
    </span><span>uint64_t</span><span> </span><span>xor3</span><span> </span><span>=</span><span> </span><span>word</span><span> </span><span>^</span><span> </span><span>mask3</span><span>;</span><span>
    </span><span>uint64_t</span><span> </span><span>xor4</span><span> </span><span>=</span><span> </span><span>word</span><span> </span><span>^</span><span> </span><span>mask4</span><span>;</span><span>
    </span><span>uint64_t</span><span> </span><span>is_match</span><span> </span><span>=</span><span> </span><span>has_zero_byte</span><span>(</span><span>xor1</span><span>)</span><span> </span><span>|</span><span> </span><span>has_zero_byte</span><span>(</span><span>xor2</span><span>)</span><span> </span><span>|</span><span> </span><span>has_zero_byte</span><span>(</span><span>xor3</span><span>)</span><span> </span><span>|</span><span> </span><span>has_zero_byte</span><span>(</span><span>xor4</span><span>);</span><span>
    </span><span>if</span><span> </span><span>(</span><span>is_match</span><span>)</span><span> </span><span>{</span><span>
      </span><span>return</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>index_of_first_set_byte</span><span>(</span><span>is_match</span><span>);</span><span>
    </span><span>}</span><span>
  </span><span>}</span><span>

  </span><span>if</span><span> </span><span>(</span><span>i</span><span> </span><span>&lt;</span><span> </span><span>view</span><span>.</span><span>size</span><span>())</span><span> </span><span>{</span><span>
    </span><span>uint64_t</span><span> </span><span>word</span><span>{};</span><span>
    </span><span>memcpy</span><span>(</span><span>&amp;</span><span>word</span><span>,</span><span> </span><span>view</span><span>.</span><span>data</span><span>()</span><span> </span><span>+</span><span> </span><span>i</span><span>,</span><span> </span><span>view</span><span>.</span><span>size</span><span>()</span><span> </span><span>-</span><span> </span><span>i</span><span>);</span><span>
    </span><span>word</span><span> </span><span>=</span><span> </span><span>swap_bytes_if_big_endian</span><span>(</span><span>word</span><span>);</span><span>
    </span><span>uint64_t</span><span> </span><span>xor1</span><span> </span><span>=</span><span> </span><span>word</span><span> </span><span>^</span><span> </span><span>mask1</span><span>;</span><span>
    </span><span>uint64_t</span><span> </span><span>xor2</span><span> </span><span>=</span><span> </span><span>word</span><span> </span><span>^</span><span> </span><span>mask2</span><span>;</span><span>
    </span><span>uint64_t</span><span> </span><span>xor3</span><span> </span><span>=</span><span> </span><span>word</span><span> </span><span>^</span><span> </span><span>mask3</span><span>;</span><span>
    </span><span>uint64_t</span><span> </span><span>xor4</span><span> </span><span>=</span><span> </span><span>word</span><span> </span><span>^</span><span> </span><span>mask4</span><span>;</span><span>
    </span><span>uint64_t</span><span> </span><span>is_match</span><span> </span><span>=</span><span> </span><span>has_zero_byte</span><span>(</span><span>xor1</span><span>)</span><span> </span><span>|</span><span> </span><span>has_zero_byte</span><span>(</span><span>xor2</span><span>)</span><span> </span><span>|</span><span> </span><span>has_zero_byte</span><span>(</span><span>xor3</span><span>)</span><span> </span><span>|</span><span> </span><span>has_zero_byte</span><span>(</span><span>xor4</span><span>);</span><span>
    </span><span>if</span><span> </span><span>(</span><span>is_match</span><span>)</span><span> </span><span>{</span><span>
      </span><span>return</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>index_of_first_set_byte</span><span>(</span><span>is_match</span><span>);</span><span>
    </span><span>}</span><span>
  </span><span>}</span><span>

  </span><span>return</span><span> </span><span>view</span><span>.</span><span>size</span><span>();</span><span>
</span><span>}</span>
</pre>
<p>The above procedure finds the position of the first occurrence of a char
from the set <tt>@</tt>, <tt>/</tt>, <tt>?</tt> and <tt>/</tt>. It returns the length
of input string if nothing was found.</p>
<p>The procedure uses <a href="https://en.wikipedia.org/wiki/SWAR">SWAR</a> techniques: it processes several bytes at once,
taking advantage on the current CPUs architecture that process 64-bit values.
The procedure implementation comes from <tt>src/helpers.cpp</tt>, and more
function from that file follow exactly the same SWAR approach.</p>
<p>These two functions are crucial:</p>
<ul>
<li><tt>has_zero_byte</tt> is non-zero if a multi-byte word has at least one zero byte;
note that the procedure also keeps only the most significant bits.</li>
<li><tt>index_of_first_set_byte</tt> returns the index of first non-zero byte; it uses
the fact it is called on word formed with bytes 0x00 and 0x80.</li>
</ul>
<p>The pattern used is quite straightforward. If we bit-xor input bytes with a
word filled with one of bytes from set, then the result has zero byte if the
byte was there.  We check then if it least one result of bit-xor has zero-byte
and if it is true, we&#39;re looking for its position.</p>
<p>While the production code processes multi-word inputs, let&#39;s focus on a basic
building block that processes a single 64-bit word.</p>
<pre><span>int</span><span> </span><span>find_authority_delimiter_special_reference</span><span>(</span><span>uint64_t</span><span> </span><span>word</span><span>)</span><span> </span><span>noexcept</span><span> </span><span>{</span><span>
  </span><span>auto</span><span> </span><span>has_zero_byte</span><span> </span><span>=</span><span> </span><span>[](</span><span>uint64_t</span><span> </span><span>v</span><span>)</span><span> </span><span>{</span><span>
    </span><span>return</span><span> </span><span>((</span><span>v</span><span> </span><span>-</span><span> </span><span>0x0101010101010101</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>(</span><span>v</span><span>)</span><span>&amp;</span><span>0x8080808080808080</span><span>);</span><span>
  </span><span>};</span><span>
  </span><span>auto</span><span> </span><span>index_of_first_set_byte</span><span> </span><span>=</span><span> </span><span>[](</span><span>uint64_t</span><span> </span><span>v</span><span>)</span><span> </span><span>{</span><span>
    </span><span>return</span><span> </span><span>((((</span><span>v</span><span> </span><span>-</span><span> </span><span>1</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x101010101010101</span><span>)</span><span> </span><span>*</span><span> </span><span>0x101010101010101</span><span>)</span><span> </span><span>&gt;&gt;</span><span> </span><span>56</span><span>)</span><span> </span><span>-</span><span> </span><span>1</span><span>;</span><span>
  </span><span>};</span><span>
  </span><span>auto</span><span> </span><span>broadcast</span><span> </span><span>=</span><span> </span><span>[](</span><span>uint8_t</span><span> </span><span>v</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>uint64_t</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>0x101010101010101</span><span> </span><span>*</span><span> </span><span>v</span><span>;</span><span> </span><span>};</span><span>
  </span><span>uint64_t</span><span> </span><span>mask1</span><span> </span><span>=</span><span> </span><span>broadcast</span><span>(</span><span>&#39;@&#39;</span><span>);</span><span>
  </span><span>uint64_t</span><span> </span><span>mask2</span><span> </span><span>=</span><span> </span><span>broadcast</span><span>(</span><span>&#39;/&#39;</span><span>);</span><span>
  </span><span>uint64_t</span><span> </span><span>mask3</span><span> </span><span>=</span><span> </span><span>broadcast</span><span>(</span><span>&#39;?&#39;</span><span>);</span><span>
  </span><span>uint64_t</span><span> </span><span>mask4</span><span> </span><span>=</span><span> </span><span>broadcast</span><span>(</span><span>&#39;\\&#39;</span><span>);</span><span>

  </span><span>uint64_t</span><span> </span><span>xor1</span><span> </span><span>=</span><span> </span><span>word</span><span> </span><span>^</span><span> </span><span>mask1</span><span>;</span><span>
  </span><span>uint64_t</span><span> </span><span>xor2</span><span> </span><span>=</span><span> </span><span>word</span><span> </span><span>^</span><span> </span><span>mask2</span><span>;</span><span>
  </span><span>uint64_t</span><span> </span><span>xor3</span><span> </span><span>=</span><span> </span><span>word</span><span> </span><span>^</span><span> </span><span>mask3</span><span>;</span><span>
  </span><span>uint64_t</span><span> </span><span>xor4</span><span> </span><span>=</span><span> </span><span>word</span><span> </span><span>^</span><span> </span><span>mask4</span><span>;</span><span>
  </span><span>uint64_t</span><span> </span><span>is_match</span><span> </span><span>=</span><span> </span><span>has_zero_byte</span><span>(</span><span>xor1</span><span>)</span><span> </span><span>|</span><span> </span><span>has_zero_byte</span><span>(</span><span>xor2</span><span>)</span><span> </span><span>|</span><span> </span><span>has_zero_byte</span><span>(</span><span>xor3</span><span>)</span><span> </span><span>|</span><span> </span><span>has_zero_byte</span><span>(</span><span>xor4</span><span>);</span><span>
  </span><span>if</span><span> </span><span>(</span><span>is_match</span><span>)</span><span> </span><span>{</span><span>
      </span><span>return</span><span> </span><span>index_of_first_set_byte</span><span>(</span><span>is_match</span><span>);</span><span>
  </span><span>}</span><span>

  </span><span>return</span><span> </span><span>-1</span><span>;</span><span>
</span><span>}</span>
</pre>
<p>The following assembly is produced by GCC 12.2.0 from Debian for the IceLake Server architecture
(<tt>gcc <span>-O3</span> <span>-march=icelake-server</span></tt>).</p>
<pre>movabs $0x2f2f2f2f2f2f2f2f,%rax
movabs $0xfefefefefefefeff,%rsi
xor    %rdi,%rax
movabs $0xd0d0d0d0d0d0d0d0,%rcx
xor    %rdi,%rcx
add    %rsi,%rax
and    %rcx,%rax
movabs $0x4040404040404040,%rcx
mov    %rdi,%rdx
xor    %rdi,%rcx
movabs $0xbfbfbfbfbfbfbfbf,%rdi
xor    %rdx,%rdi
add    %rsi,%rcx
and    %rdi,%rcx
or     %rcx,%rax
movabs $0x3f3f3f3f3f3f3f3f,%rcx
xor    %rdx,%rcx
movabs $0xc0c0c0c0c0c0c0c0,%rdi
add    %rsi,%rcx
xor    %rdx,%rdi
and    %rdi,%rcx
or     %rcx,%rax
movabs $0x5c5c5c5c5c5c5c5c,%rcx
xor    %rdx,%rcx
add    %rsi,%rcx
movabs $0xa3a3a3a3a3a3a3a3,%rsi
xor    %rsi,%rdx
and    %rcx,%rdx
or     %rdx,%rax
movabs $0x8080808080808080,%rdx
and    %rdx,%rax
je     &lt;_Z42find_authority_delimiter_special_referencem+0xc0&gt;
movabs $0x101010101010101,%rdx
dec    %rax
and    %rdx,%rax
imul   %rdx,%rax
shr    $0x38,%rax
dec    %eax
ret
mov    $0xffffffff,%eax
ret
</pre>
<p>The assembly contains:</p>
<ul>
<li>11 x constants,</li>
<li>6 x xor,</li>
<li>6 x and,</li>
<li>4 x add,</li>
<li>3 x or,</li>
<li>1 x multiplication (<tt>imul</tt>),</li>
<li>1 x shift right,</li>
<li>1 x branch.</li>
</ul>
</div>
<div id="faster-swar-procedure">

<p>While the approach used by Ada library is universal and can be used for locating
any byte, there&#39;s faster method that can be used with the set contains only ASCII
chars, i.e. bytes that do not have set the 7th bit. The set <tt>@</tt>, <tt>/</tt>, <tt>?</tt>
and <tt>\\</tt> falls into this category.</p>
<p>In this approach we pretend that the input is 7-bit. If the input has any
8-bit byte (for instance UTF-8 characters) we&#39;ll fix up wrongly detected
bytes at the end.</p>
<p>We also use bit-xor to produce zero bytes for matching bytes. However, we
then convert the result into a bit. The result of bit-xor can be zero
or non zero (<tt>x</tt> - bit 0 or 1, but at least one is 1):</p>
<pre>┌─────────┐ ┌─────────┐
│0000 0000│ │0xxx xxxx│
└─────────┘ └─────────┘
</pre>
<p>If we add <tt>0x7f</tt> = <tt>0b0111_1111</tt> then the result is:</p>
<pre>┌─────────┐ ┌─────────┐
│0111 1111│ │1yyy yyyy│
└─────────┘ └─────────┘
</pre>
<p>We can see that the most significant bit expresses relation &#34;byte is not zero&#34;.
Let&#39;s review the basic algorithm steps, that use the above observation.</p>
<ol start="0">
<li><p>Input 8-byte string is <tt><span>a\\xc0ą@b?c</span></tt>:</p>
<pre> &#39;a&#39;=0x61   \xc0     &#39;ą&#39;=&lt;0xc4, 0x85&gt;    &#39;@&#39;=0x40  &#39;b&#39;=0x62  &#39;?&#39;=0x3f  &#39;c&#39;=0x63
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│0110 0001│1100 0000│1100 0100│1000 0101│0100 0000│0110 0010│0011 1111│0110 0011│ = input
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
</pre>
</li>
</ol>
<ol start="0">
<li><p>And we&#39;re looking for &#39;@&#39; = <tt>0x40</tt>:</p>
<pre>┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│0100 0000│0100 0000│0100 0000│0100 0000│0100 0000│0100 0000│0100 0000│0100 0000│ = byte
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
</pre>
</li>
<li><p>Xor input and mask:</p>
<pre>t0 = word ^ 0x4040404040404040

┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│0010 0001│1000 0000│1000 0100│1100 0101│0000 0000│0010 0010│0111 1111│0010 0011│ = t0
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
     21        80        84        c5        00        22        7f        23
</pre>
</li>
<li><p>Mask MSB from input:</p>
<pre>t1 = t0 &amp; 0x7f7f7f7f7f7f7f7f

┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│0010 0001│0000 0000│0000 0100│0100 0101│0000 0000│0010 0010│0111 1111│0010 0011│ = t1
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
     21        00        04        45        00        22        7f        23
</pre>
</li>
<li><p>Add <tt>0x7f</tt> to locate non-zero bytes. Note that two bytes were found, but the
first one is not valid.:</p>
<pre>t2 = t1 + 0x7f7f7f7f7f7f7f7f

┌─────────┲━━━━━━━━━┱─────────┬─────────┲━━━━━━━━━┱─────────┬─────────┬─────────┐
│1010 0000┃0111 1111┃1000 0011│1100 0100┃0111 1111┃1010 0001│1111 1110│1010 0010│ = t2
└─────────┺━━━━━━━━━┹─────────┴─────────┺━━━━━━━━━┹─────────┴─────────┴─────────┘
     a0        7f        83        c4        7f        a1        fe        a2
</pre>
</li>
<li><p>At this point, MSBs equal zero denote byte position. To fix up the result we
bit-or the t2 with input. If input byte has MSB set, it will discard wrong
results.:</p>
<pre>t3 = t2 | input

┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│1110 0001│1111 1111│1100 0111│1100 0101│0111 1111│1110 0011│1111 1111│1110 0011│ = t3
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
     e1        ff        c7        c5        7f        e3        ff        e3
</pre>
</li>
<li><p>Now, we keep only MSBs:</p>
<pre>t4 = t3 &amp; 0x8080808080808080

┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│1000 0000│1000 0000│1000 0000│1000 0000│0000 0000│1000 0000│1000 0000│1000 0000│ = t4
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
     80        80        80        80        00        80        80        80
</pre>
</li>
<li><p>Negate the MSBs — ones would point found positions. As we can see, now we have
exactly one non-zero byte:</p>
<pre>t5 = t4 ^ 0x8080808080808080

┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│0000 0000│0000 0000│0000 0000│0000 0000│1000 0000│0000 0000│0000 0000│0000 0000│ = t5
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
     00        00        00        00        80        00        00        00
</pre>
</li>
<li><p>To find the position of byte we simply looking for first bit set and divide
result by 8.</p>
</li>
</ol>
<p>The above algorithm was used to code the fully functional procedure.</p>
<pre><span>long</span><span> </span><span>int</span><span> </span><span>find_authority_delimiter_special_better</span><span>(</span><span>uint64_t</span><span> </span><span>word</span><span>)</span><span> </span><span>noexcept</span><span> </span><span>{</span><span>
  </span><span>auto</span><span> </span><span>broadcast</span><span> </span><span>=</span><span> </span><span>[](</span><span>uint8_t</span><span> </span><span>v</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>uint64_t</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>0x101010101010101</span><span> </span><span>*</span><span> </span><span>v</span><span>;</span><span> </span><span>};</span><span>

  </span><span>uint64_t</span><span> </span><span>mask</span><span> </span><span>=</span><span> </span><span>broadcast</span><span>(</span><span>0x7f</span><span>);</span><span>
  </span><span>uint64_t</span><span> </span><span>lo7bits</span><span> </span><span>=</span><span> </span><span>word</span><span> </span><span>&amp;</span><span> </span><span>mask</span><span>;</span><span>

  </span><span>uint64_t</span><span> </span><span>x0</span><span> </span><span>=</span><span> </span><span>(</span><span>lo7bits</span><span> </span><span>^</span><span> </span><span>broadcast</span><span>(</span><span>&#39;@&#39;</span><span>))</span><span> </span><span>+</span><span> </span><span>mask</span><span>;</span><span>
  </span><span>uint64_t</span><span> </span><span>x1</span><span> </span><span>=</span><span> </span><span>(</span><span>lo7bits</span><span> </span><span>^</span><span> </span><span>broadcast</span><span>(</span><span>&#39;/&#39;</span><span>))</span><span> </span><span>+</span><span> </span><span>mask</span><span>;</span><span>
  </span><span>uint64_t</span><span> </span><span>x2</span><span> </span><span>=</span><span> </span><span>(</span><span>lo7bits</span><span> </span><span>^</span><span> </span><span>broadcast</span><span>(</span><span>&#39;?&#39;</span><span>))</span><span> </span><span>+</span><span> </span><span>mask</span><span>;</span><span>
  </span><span>uint64_t</span><span> </span><span>x3</span><span> </span><span>=</span><span> </span><span>(</span><span>lo7bits</span><span> </span><span>^</span><span> </span><span>broadcast</span><span>(</span><span>&#39;\\&#39;</span><span>))</span><span> </span><span>+</span><span> </span><span>mask</span><span>;</span><span>

  </span><span>uint64_t</span><span> </span><span>t0</span><span> </span><span>=</span><span> </span><span>((</span><span>x0</span><span> </span><span>&amp;</span><span> </span><span>x1</span><span> </span><span>&amp;</span><span> </span><span>x2</span><span> </span><span>&amp;</span><span> </span><span>x3</span><span>)</span><span> </span><span>|</span><span> </span><span>word</span><span>);</span><span>
  </span><span>uint64_t</span><span> </span><span>t1</span><span> </span><span>=</span><span> </span><span>t0</span><span> </span><span>&amp;</span><span> </span><span>broadcast</span><span>(</span><span>0x80</span><span>);</span><span>
  </span><span>uint64_t</span><span> </span><span>t2</span><span> </span><span>=</span><span> </span><span>t1</span><span> </span><span>^</span><span> </span><span>broadcast</span><span>(</span><span>0x80</span><span>);</span><span>

  </span><span>if</span><span> </span><span>(</span><span>t2</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
    </span><span>return</span><span> </span><span>__builtin_ctzl</span><span>(</span><span>t2</span><span>)</span><span> </span><span>/</span><span> </span><span>8</span><span>;</span><span>
  </span><span>}</span><span>

  </span><span>return</span><span> </span><span>-1</span><span>;</span><span>
</span><span>}</span>
</pre>
<p>The following assembly is produced by GCC 12.2.0 from Debian for the IceLake Server architecture
(<tt>gcc <span>-O3</span> <span>-march=icelake-server</span></tt>).</p>
<pre>movabs $0x7f7f7f7f7f7f7f7f,%rcx
mov    %rdi,%rax
and    %rcx,%rax
movabs $0x4040404040404040,%rdx
movabs $0x2f2f2f2f2f2f2f2f,%rsi
xor    %rax,%rdx
xor    %rax,%rsi
add    %rcx,%rsi
add    %rcx,%rdx
and    %rsi,%rdx
movabs $0x3f3f3f3f3f3f3f3f,%rsi
xor    %rax,%rsi
add    %rcx,%rsi
and    %rsi,%rdx
movabs $0x5c5c5c5c5c5c5c5c,%rsi
xor    %rsi,%rax
add    %rcx,%rax
and    %rax,%rdx
or     %rdi,%rdx
movabs $0x8080808080808080,%rax
andn   %rax,%rdx,%rdx
xor    %eax,%eax
tzcnt  %rdx,%rax
shr    $0x3,%rax
test   %rdx,%rdx
mov    $0xffffffffffffffff,%rdx
cmove  %rdx,%rax
ret
</pre>
<p>The assembly contains:</p>
<ul>
<li>6 x constants,</li>
<li>5 x xor,</li>
<li>5 x and,</li>
<li>4 x add,</li>
<li>1 x or,</li>
<li>1 x count trailing zeros,</li>
<li>1 x shift right,</li>
<li>1 x condition move.</li>
</ul>
</div>
<div id="comparison">

<div id="reference-implementation">
<h2>Reference implementation</h2>
<p>Since the reference assembly contains the jump instruction, I rewrote it to:</p>
<pre>    movabs $0x2f2f2f2f2f2f2f2f,%rax
    movabs $0xfefefefefefefeff,%rsi
    xor    %rdi,%rax
    movabs $0xd0d0d0d0d0d0d0d0,%rcx
    xor    %rdi,%rcx
    add    %rsi,%rax
    and    %rcx,%rax
    movabs $0x4040404040404040,%rcx
    mov    %rdi,%rdx
    xor    %rdi,%rcx
    movabs $0xbfbfbfbfbfbfbfbf,%rdi
    xor    %rdx,%rdi
    add    %rsi,%rcx
    and    %rdi,%rcx
    or     %rcx,%rax
    movabs $0x3f3f3f3f3f3f3f3f,%rcx
    xor    %rdx,%rcx
    movabs $0xc0c0c0c0c0c0c0c0,%rdi
    add    %rsi,%rcx
    xor    %rdx,%rdi
    and    %rdi,%rcx
    or     %rcx,%rax
    movabs $0x5c5c5c5c5c5c5c5c,%rcx
    xor    %rdx,%rcx
    add    %rsi,%rcx
    movabs $0xa3a3a3a3a3a3a3a3,%rsi
    xor    %rsi,%rdx
    and    %rcx,%rdx
    or     %rdx,%rax
    movabs $0x8080808080808080,%rdx
    and    %rdx,%rax
sete   %cl                      // cl = 1 or 0
    movabs $0x101010101010101,%rdx
    dec    %rax
    and    %rdx,%rax
    imul   %rdx,%rax
    shr    $0x38,%rax
    dec    %eax
testb  %cl,%cl                  // reapply `and` result
    mov    $0xffffffff,%ebx         //
cmove  %rbx,%rax                // and conditionally overwrite rax
    ret
</pre>
<p>For the above procedure <a href="https://uica.uops.info/">uICA</a> give the following analysis.</p>
<pre>Throughput (in cycles per iteration): 13.18
Bottleneck: Predecoder

The following throughputs could be achieved if the given property were the only bottleneck:

  - Predecoder: 13.19
  - Decoder: 11.00
  - Issue: 8.20
  - Ports: 10.25
  - Dependencies: 2.00

┌───────────────────────┬────────┬───────┬─────────────────────────────────────────────────────────────────────────────────────────┐
│ MITE   MS   DSB   LSD │ Issued │ Exec. │ Port 0   Port 1   Port 2   Port 3   Port 4   Port 5   Port 6   Port 7   Port 8   Port 9 │
├───────────────────────┼────────┼───────┼─────────────────────────────────────────────────────────────────────────────────────────┤
│  1                    │   1    │   1   │  0.11     0.11                                0.56     0.22                             │ mov rax, 0x2f2f2f2f2f2f2f2f
│  1                    │   1    │   1   │  0.11     0.39                                0.33     0.17                             │ mov rsi, 0xfefefefefefefeff
│  1                    │   1    │   1   │  0.28     0.33                                0.17     0.22                             │ xor rax, rdi
│  1                    │   1    │   1   │  0.11     0.17                                0.56     0.17                             │ mov rcx, 0xd0d0d0d0d0d0d0d0
│  1                    │   1    │   1   │  0.17     0.44                                0.28     0.11                             │ xor rcx, rdi
│  1                    │   1    │   1   │  0.22     0.44                                0.28     0.06                             │ add rax, rsi
│  1                    │   1    │   1   │  0.17     0.28                                0.28     0.28                             │ and rax, rcx
│  1                    │   1    │   1   │  0.17     0.39                                0.39     0.06                             │ mov rcx, 0x4040404040404040
│  1                    │   1    │   1   │  0.22     0.39                                0.11     0.28                             │ mov rdx, rdi
│  1                    │   1    │   1   │  0.56     0.11                                0.17     0.17                             │ xor rcx, rdi
│  1                    │   1    │   1   │  0.06     0.22                                0.22     0.5                              │ mov rdi, 0xbfbfbfbfbfbfbfbf
│  1                    │   1    │   1   │  0.11     0.33                                0.44     0.11                             │ xor rdi, rdx
│  1                    │   1    │   1   │  0.33     0.33                                0.28     0.06                             │ add rcx, rsi
│  1                    │   1    │   1   │  0.33     0.28                                0.06     0.33                             │ and rcx, rdi
│  1                    │   1    │   1   │  0.17     0.22                                0.11     0.5                              │ or rax, rcx
│  1                    │   1    │   1   │  0.17     0.22                                0.33     0.28                             │ mov rcx, 0x3f3f3f3f3f3f3f3f
│  1                    │   1    │   1   │  0.28     0.28                                0.33     0.11                             │ xor rcx, rdx
│  1                    │   1    │   1   │  0.17     0.44                                0.22     0.17                             │ mov rdi, 0xc0c0c0c0c0c0c0c0
│  1                    │   1    │   1   │  0.44     0.22                                0.22     0.11                             │ add rcx, rsi
│  1                    │   1    │   1   │  0.11     0.17                                0.28     0.44                             │ xor rdi, rdx
│  1                    │   1    │   1   │  0.39     0.22                                0.22     0.17                             │ and rcx, rdi
│  1                    │   1    │   1   │  0.17     0.22                                0.39     0.22                             │ or rax, rcx
│  1                    │   1    │   1   │  0.28     0.33                                0.11     0.28                             │ mov rcx, 0x5c5c5c5c5c5c5c5c
│  1                    │   1    │   1   │  0.33     0.22                                0.11     0.33                             │ xor rcx, rdx
│  1                    │   1    │   1   │  0.22     0.11                                0.28     0.39                             │ add rcx, rsi
│  1                    │   1    │   1   │  0.22     0.11                                0.33     0.33                             │ mov rsi, 0xa3a3a3a3a3a3a3a3
│  1                    │   1    │   1   │  0.11     0.22                                0.39     0.28                             │ xor rdx, rsi
│  1                    │   1    │   1   │  0.39     0.28                                0.11     0.22                             │ and rdx, rcx
│  1                    │   1    │   1   │  0.17     0.06                                0.5      0.28                             │ or rax, rdx
│  1                    │   1    │   1   │  0.22     0.28                                0.33     0.17                             │ mov rdx, 0x8080808080808080
│  1                    │   1    │   1   │  0.28     0.11                                0.17     0.44                             │ and rax, rdx
│  1                    │   1    │   1   │  0.39                                                  0.61                             │ setz cl
│  1                    │   1    │   1   │  0.22     0.17                                0.39     0.22                             │ mov rdx, 0x101010101010101
│  1                    │   1    │   1   │           0.11                                0.39     0.5                              │ dec rax
│  1                    │   1    │   1   │  0.44     0.28                                0.22     0.06                             │ and rax, rdx
│  1                    │   1    │   1   │            1                                                                            │ imul rax, rdx
│  1                    │   1    │   1   │  0.44                                                  0.56                             │ shr rax, 0x38
│  1                    │   1    │   1   │  0.17     0.17                                0.39     0.28                             │ dec eax
│  1                    │   1    │   1   │  0.11     0.17                                0.44     0.28                             │ mov ebx, 0xffffffff
│  1                    │   1    │   1   │  0.17     0.5                                 0.33                                      │ test cl, cl
│  1                    │   1    │   1   │  0.56                                                  0.44                             │ cmovnz rax, rbx
├───────────────────────┼────────┼───────┼─────────────────────────────────────────────────────────────────────────────────────────┤
│  41                   │   41   │  41   │  9.56    10.33                               10.72    10.39                             │ Total
└───────────────────────┴────────┴───────┴─────────────────────────────────────────────────────────────────────────────────────────┘
</pre>
</div>
<div id="faster-swar-procedure-1">
<h2>Faster SWAR procedure</h2>
<p>uICA output:</p>
<pre>Throughput (in cycles per iteration): 8.19
Bottleneck: Predecoder

The following throughputs could be achieved if the given property were the only bottleneck:

  - Predecoder: 8.25
  - Decoder: 7.00
  - Issue: 5.40
  - Ports: 6.50

┌───────────────────────┬────────┬───────┬─────────────────────────────────────────────────────────────────────────────────────────┐
│ MITE   MS   DSB   LSD │ Issued │ Exec. │ Port 0   Port 1   Port 2   Port 3   Port 4   Port 5   Port 6   Port 7   Port 8   Port 9 │
├───────────────────────┼────────┼───────┼─────────────────────────────────────────────────────────────────────────────────────────┤
│  1                    │   1    │   1   │  0.29     0.14                                0.25     0.32                             │ mov rcx, 0x7f7f7f7f7f7f7f7f
│  1                    │   1    │   1   │  0.11     0.14                                0.39     0.36                             │ mov rax, rdi
│  1                    │   1    │   1   │  0.36     0.07                                0.25     0.32                             │ and rax, rcx
│  1                    │   1    │   1   │  0.18     0.11                                0.46     0.25                             │ mov rdx, 0x4040404040404040
│  1                    │   1    │   1   │  0.11     0.36                                0.36     0.18                             │ mov rsi, 0x2f2f2f2f2f2f2f2f
│  1                    │   1    │   1   │  0.32     0.18                                0.32     0.18                             │ xor rdx, rax
│  1                    │   1    │   1   │  0.29     0.29                                0.21     0.21                             │ xor rsi, rax
│  1                    │   1    │   1   │  0.11     0.14                                0.32     0.43                             │ add rsi, rcx
│  1                    │   1    │   1   │  0.32     0.39                                0.21     0.07                             │ add rdx, rcx
│  1                    │   1    │   1   │  0.18     0.11                                0.36     0.36                             │ and rdx, rsi
│  1                    │   1    │   1   │  0.29     0.11                                0.36     0.25                             │ mov rsi, 0x3f3f3f3f3f3f3f3f
│  1                    │   1    │   1   │  0.21     0.39                                0.14     0.25                             │ xor rsi, rax
│  1                    │   1    │   1   │  0.25     0.36                                0.18     0.21                             │ add rsi, rcx
│  1                    │   1    │   1   │  0.36     0.11                                0.29     0.25                             │ and rdx, rsi
│  1                    │   1    │   1   │  0.18     0.36                                0.25     0.21                             │ mov rsi, 0x5c5c5c5c5c5c5c5c
│  1                    │   1    │   1   │  0.36     0.29                                0.25     0.11                             │ xor rax, rsi
│  1                    │   1    │   1   │  0.29     0.11                                0.29     0.32                             │ add rax, rcx
│  1                    │   1    │   1   │  0.11     0.29                                0.29     0.32                             │ and rdx, rax
│  1                    │   1    │   1   │  0.29     0.29                                0.25     0.18                             │ or rdx, rdi
│  1                    │   1    │   1   │  0.25     0.32                                0.18     0.25                             │ mov rax, 0x8080808080808080
│  1                    │   1    │   1   │           0.36                                0.64                                      │ andn rdx, rdx, rax
│  1                    │   1    │       │                                                                                         │ xor eax, eax
│  1                    │   1    │   1   │            1                                                                            │ tzcnt rax, rdx
│  1                    │   1    │   1   │  0.54                                                  0.46                             │ shr rax, 0x3
│  1                    │   1    │   1   │  0.21     0.21                                0.32     0.25                             │ test rdx, rdx
│  1                    │   1    │   1   │  0.21     0.36                                0.29     0.14                             │ mov rdx, 0xffffffffffffffff
│  1                    │   1    │   1   │  0.39                                                  0.61                             │ cmovz rax, rdx
├───────────────────────┼────────┼───────┼─────────────────────────────────────────────────────────────────────────────────────────┤
│  27                   │   27   │  26   │  6.18     6.46                                6.86     6.5                              │ Total
└───────────────────────┴────────┴───────┴─────────────────────────────────────────────────────────────────────────────────────────┘
</pre>
</div>
<div id="benchmark-results">
<h2>Benchmark results</h2>
<p>Microbenchmarks run on an IceLake machine:</p>
<pre>$ cat /proc/cpuinfo | grep &#34;model name&#34; | head -n 1
model name  : Intel(R) Xeon(R) Platinum 8375C CPU @ 2.90GHz

$ g++ -Wall -Wextra -std=c++11 -O3 -march=native benchmark.cpp reference.o better.o -o benchmark
rdtsc_overhead set to 32
reference                           :    16.000 cycle/op (best)   21.878 cycle/op (avg)
better                              :    14.000 cycle/op (best)   20.360 cycle/op (avg)
</pre>
</div>
<div id="summary">
<h2>Summary</h2>
<p>The throughput reported by uICA for the faster procedure is 8.25 cycles,
for original code 13.19 cycles. In theory, we may expected 1.5x speedup
of the procedure, but in practice it&#39;s not that significant.</p>
</div>
</div>
<div id="source-code">

<p>Sample source code is available on <a href="https://github.com/WojciechMula/toys/tree/master/swar-any-equals">Github</a></p>
</div>
</div></div>
  </body>
</html>
