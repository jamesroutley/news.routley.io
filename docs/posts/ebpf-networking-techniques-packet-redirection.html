<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://who.ldelossa.is/posts/ebpf-networking-technique-packet-redirection/">Original</a>
    <h1>eBPF Networking Techniques – Packet Redirection</h1>
    
    <div id="readability-page-1" class="page"><div><p>This is the first post of a many planned to shed light on the various networking techniques eBPF makes available to a Linux network developer.</p><p>I started my career as a network engineer before I found programming interesting.
During this time, I was working with white box networking hardware more often than Linux.
A few years into this role,however, the “commodity hardware” trend took foot, and Linux was being used in the network world far more often.
It has always stood out to me that Linux networking felt different compared to working with traditional network hardware.</p><p>In my opinion, this is because Linux is extremely flexible and, from my experience, aims for maximum flexibility with its networking concepts.
This leads to the often feeling that certain networking concepts learned in the traditional network engineering world do not cleanly map to Linux concepts.</p><p>For instance, wtf is a veth?
You can describe it as a virtual “wire”, but it is also represented as two network interfaces by Linux.
It’s also an I/O pipe, which is a systems programming thing.
Oh, and it can be plugged into a Linux bridge, in which case one side of the interface disappears.
We’ll be using veths a lot in these posts; figured I’d introduce their flexibility now.</p><p>Scenarios like this have driven me to start writing about Linux networking, especially in the context of eBPF.
It doesn’t hurt that it’s also my favorite topic in computer science, so I’m rather motivated to share my knowledge.</p><p>I plan on writing a series of posts, each focusing on a particular eBPF networking technique.
Each post should be “bite-sized” and small enough to read and work through in an hour or two.</p><p>eBPF is a dense topic and the Linux networking subsystem is (maybe) even more dense, so it’s inevitable that some details necessary for a complete understanding of a technique will be glossed over.
I’ll do my best to link to subsequent reading, kernel source code, or other blog posts to fill in the knowledge gaps where possible.</p><p>Without further ado, the first eBPF networking technique I want to cover is packet redirection.</p><h2 id="packet-redirection">Packet Redirection</h2><p>Packet redirection is taking a packet from one network interface and injecting it into another.</p><p>Let’s illustrate this with a diagram that also depicts our lab topology.
<img src="https://who.ldelossa.is/ebpf-packet-redirection-topology.png" alt="ebpf packet redirection topology"/></p><p>The above illustrates the basic form of an eBPF redirect.
The dotted lines represent the packet’s path while solid lines depict veth pairs.</p><p>Our topology consists of two network namespaces bridged together by a veth.
Let’s assume <code>veth1@1</code> is in the host network namespace providing access to <code>netns_1</code> and routing is configured for end-to-end connectivity.</p><p>A packet is sent to the client in <code>netns_2</code> listening on <code>10.0.2.11:7777</code>.
An eBPF program is associated with <code>veth1@2</code> which will run when a packet is received.
This eBPF program performs an eBPF redirect to <code>veth2@1</code> which forwards the packet immediately to <code>veth2@2</code> in <code>netns_2</code>.
From here the Linux network stack will be employed to deliver the packet to the client process (this is called local delivery).</p><p>Notice in <code>netns_1</code> we actually hop over the Linux networking stack when moving the packet towards its final destination.
This is the interesting bit of the technique, we short-circuit packet delivery by jumping over a bunch of kernel functions in the processing of the packet.</p><p>In a typical network flow, pretty much like the one we see in <code>netns_2</code>, the Linux network stack would evaluate the packet, passing it to Layer 2 and Layer 3 processing before determining if the packet should be delivered locally or routed out an interface.
If our eBPF program can glean this knowledge, however, we can skip the Linux network stack completely and inject the packet into the egress interface which moves the packet closer to its destination.</p><h2 id="a-demonstration">A Demonstration</h2><p>Let’s jump into some code.</p><p>I’m going to assume you can build eBPF programs with libbpf, load them, and run them.
If you’re not sure how to do this check out my post <a href="https://who.ldelossa.is/posts/bpf-zero-to-hero/">here</a>.</p><p>You can find the code <a href="https://github.com/ldelossa/ebpf-net/tree/main/packet_redirection">here</a></p><p><code>Makefile</code></p><div><pre tabindex="0"><code data-lang="c"><span><span>MAKEFLAGS <span>+=</span> <span>--</span>no<span>-</span>print<span>-</span>directory 
</span></span><span><span>IP <span>=</span> sudo ip
</span></span><span><span>NETNS <span>=</span> <span>$</span>(IP) netns
</span></span><span><span>EXEC <span>=</span> <span>$</span>(NETNS) exec
</span></span><span><span>NET_1 <span>=</span> <span>&#34;netns_1&#34;</span>
</span></span><span><span>NET_2 <span>=</span> <span>&#34;netns_2&#34;</span>
</span></span><span><span>
</span></span><span><span>up: packet_redirect.bpf.o vmlinux.h
</span></span><span><span>	<span># Purging old environment...
</span></span></span><span><span><span></span>	<span>-</span>make down
</span></span><span><span>	<span># Creating network namespaces...
</span></span></span><span><span><span></span>	<span>$</span>(NETNS) add <span>$</span>(NET_1)
</span></span><span><span>	<span>$</span>(NETNS) add <span>$</span>(NET_2)
</span></span><span><span>	<span># Configuring the following topology...
</span></span></span><span><span><span></span>	<span># |host_ns              |netns_1              |netns_2                |
</span></span></span><span><span><span></span>	<span># |veth1@1 10.0.1.10|---|veth1@2 10.0.1.11    |                       |
</span></span></span><span><span><span></span>	<span># |                     |veth2@1 10.0.2.10|---|veth2@2 10.0.2.11      |
</span></span></span><span><span><span></span>	<span># |                     |                     |server  10.0.2.11:8000 |
</span></span></span><span><span><span></span>	<span>$</span>(IP) link add name veth1<span>@</span><span>1</span> type veth peer name veth1<span>@</span><span>2</span> netns <span>$</span>(NET_1)
</span></span><span><span>	<span>$</span>(IP) addr add <span>10.0.1.10</span><span>/</span><span>24</span> dev veth1<span>@</span><span>1</span>
</span></span><span><span>	<span>$</span>(EXEC) <span>$</span>(NET_1) ip addr add <span>10.0.1.11</span><span>/</span><span>24</span> dev veth1<span>@</span><span>2</span>
</span></span><span><span>	<span>$</span>(EXEC) <span>$</span>(NET_1) ip link add name veth2<span>@</span><span>1</span> type veth peer name veth2<span>@</span><span>2</span> netns <span>$</span>(NET_2)
</span></span><span><span>	<span>$</span>(EXEC) <span>$</span>(NET_1) ip addr add <span>10.0.2.10</span><span>/</span><span>24</span> dev veth2<span>@</span><span>1</span>
</span></span><span><span>	<span>$</span>(EXEC) <span>$</span>(NET_2) ip addr add <span>10.0.2.11</span><span>/</span><span>24</span> dev veth2<span>@</span><span>2</span>
</span></span><span><span>	<span>$</span>(IP) link set veth1<span>@</span><span>1</span> up
</span></span><span><span>	<span>$</span>(EXEC) <span>$</span>(NET_1) ip link set veth1<span>@</span><span>2</span> up
</span></span><span><span>	<span>$</span>(EXEC) <span>$</span>(NET_1) ip link set veth2<span>@</span><span>1</span> up
</span></span><span><span>	<span>$</span>(EXEC) <span>$</span>(NET_2) ip link set veth2<span>@</span><span>2</span> up
</span></span><span><span>	<span>$</span>(IP) route add <span>10.0.2.0</span><span>/</span><span>24</span> dev veth1<span>@</span><span>1</span>
</span></span><span><span>	<span>$</span>(EXEC) <span>$</span>(NET_2) ip route add <span>10.0.1.0</span><span>/</span><span>24</span> dev veth2<span>@</span><span>2</span>
</span></span><span><span>	<span># veth1@2 in netns_1 must proxy ARP requests for host_ns and netns_2 so
</span></span></span><span><span><span></span>	<span># host_ns can resolve MAC addresses for netns_2 and vice versa.
</span></span></span><span><span><span></span>	<span>$</span>(EXEC) <span>$</span>(NET_1) <span>/</span>bin<span>/</span>sh <span>-</span>c <span>&#39;</span>echo <span>1</span> <span>&gt;</span> <span>/</span>proc<span>/</span>sys<span>/</span>net<span>/</span>ipv4<span>/</span>conf<span>/</span>veth1<span>@</span><span>2</span><span>/</span>proxy_arp<span>&#39;</span>
</span></span><span><span>	<span># Hardcode veth2@2 to a dummy MAC for sake of demonstration purposes.
</span></span></span><span><span><span></span>	<span>$</span>(EXEC) <span>$</span>(NET_2) ip link set dev veth2<span>@</span><span>2</span> addr <span>02</span><span>:</span><span>00</span><span>:</span><span>00</span><span>:</span><span>00</span><span>:</span><span>00</span><span>:</span><span>00</span>
</span></span><span><span>	<span># Attaching eBPF program...
</span></span></span><span><span><span></span>	<span>$</span>(EXEC) <span>$</span>(NET_1) tc qdisc replace dev veth1<span>@</span><span>2</span> clsact
</span></span><span><span>	<span>$</span>(EXEC) <span>$</span>(NET_1) tc filter replace dev veth1<span>@</span><span>2</span> ingress bpf direct<span>-</span>action object<span>-</span>file <span>$</span><span>&lt;</span> section tc
</span></span><span><span>	<span># LISTENING FOR UDP PACKET @ 10.0.2.11 7777...
</span></span></span><span><span><span></span>	<span># Use &#39;make listen&#39; to listen for another packet...
</span></span></span><span><span><span></span>	<span>@</span>make listen
</span></span><span><span>
</span></span><span><span>.PHONY:
</span></span><span><span>down:
</span></span><span><span>	<span>$</span>(NETNS) del <span>$</span>(NET_1)
</span></span><span><span>	<span>$</span>(NETNS) del <span>$</span>(NET_2)
</span></span><span><span>
</span></span><span><span>.PHONY:
</span></span><span><span>listen:
</span></span><span><span>	<span>$</span>(EXEC) <span>$</span>(NET_2) nc <span>-</span>u <span>-</span>l <span>10.0.2.11</span> <span>7777</span>
</span></span><span><span>
</span></span><span><span>packet_redirect.bpf.o:
</span></span><span><span>
</span></span><span><span><span>%</span>.bpf.o: <span>%</span>.bpf.c vmlinux.h 
</span></span><span><span>	<span>#</span> Compiling eBPF program...
</span></span><span><span>	clang <span>-</span>O2 <span>-</span>target bpf <span>-</span>g3 <span>-</span>c <span>$</span><span>&lt;</span> <span>-</span>o <span>$@</span>
</span></span><span><span>
</span></span><span><span>vmlinux.h: 
</span></span><span><span>	sudo bpftool btf dump file <span>/</span>sys<span>/</span>kernel<span>/</span>btf<span>/</span>vmlinux format c <span>&gt;</span> vmlinux.h 
</span></span></code></pre></div><p>While this may look a little involved, it compiles our eBPF program, sets up our network topology, configures routing, attaches our eBPF program, and starts a listening UDP server for testing all with our default target <code>up</code>.</p><p>A large chunk of the <code>up</code> target is creating our two network namespaces, wiring veths together, and adding routes.
I think the general topology setup is self explanatory, however I want to explicitly call out two interesting things happening in this Makefile.</p><h3 id="proxy-arp">Proxy ARP</h3><div><pre tabindex="0"><code data-lang="c"><span><span>	<span># veth1@2 in netns_1 must proxy ARP requests for host_ns and netns_2 so
</span></span></span><span><span><span></span>	<span># host_ns can resolve MAC addresses for netns_2 and vice versa.
</span></span></span><span><span><span></span>	<span>$</span>(EXEC) <span>$</span>(NET_1) <span>/</span>bin<span>/</span>sh <span>-</span>c <span>&#39;</span>echo <span>1</span> <span>&gt;</span> <span>/</span>proc<span>/</span>sys<span>/</span>net<span>/</span>ipv4<span>/</span>conf<span>/</span>veth1<span>@</span><span>2</span><span>/</span>proxy_arp<span>&#39;</span>
</span></span></code></pre></div><p>Consider what we’d like to accomplish in our demo.
We want to send a packet to <code>10.0.2.11</code> from the host namespace and have it reach the client in <code>netns_2</code>.
When we try to craft a packet toward <code>10.0.2.11</code> from the host network namespace we need ARP to resolve a MAC address for this IP so it can be placed in the Layer 2 header.
The interface which owns <code>10.0.2.11</code> is only accessible by transiting <code>netns_1</code> however and <code>netns_1</code> has no reason to implicitly forward ARP request or responses for interfaces existing on its local links.
So, we need <code>netns_1</code> to act as a proxy for <code>netns_2</code>, responding on behalf of <code>netns_2</code> when ARP requests for <code>10.0.2.11</code> are encountered.</p><p>You could also just hard-code a mapping between <code>10.0.2.11</code> and the MAC address of <code>veth1@2</code> in the host network namespace neighbor table, but I find proxy ARP a bit more elegant as it works without using static mappings.</p><h3 id="attaching-ebpf-to-tc-classifier">Attaching eBPF to TC Classifier</h3><div><pre tabindex="0"><code data-lang="c"><span><span>	<span>$</span>(EXEC) <span>$</span>(NET_1) tc qdisc replace dev veth1<span>@</span><span>2</span> clsact
</span></span><span><span>	<span>$</span>(EXEC) <span>$</span>(NET_1) tc filter replace dev veth1<span>@</span><span>2</span> ingress bpf direct<span>-</span>action object<span>-</span>file <span>$</span><span>&lt;</span> section tc
</span></span></code></pre></div><p>The Traffic Control subsystem is used for fine-grain packet queuing, policing, and filtering.</p><p>I don’t want to dig too deep into the Traffic Control (TC) subsystem in Linux, as this would be an entire post of its own.
You should read the <a href="https://tldp.org/HOWTO/Traffic-Control-HOWTO/intro.html">Traffic Control HOWTO</a> for a better understanding of what those terms mean.
Suffice it to say the TC subsystem can be entered for every packet that it received or transmitted on an interface, making it a great place for eBPF hooks to be applied.</p><p>Let’s summarize the above two lines:</p><ol><li>We add a <code>qdisc</code> of type <code>clsact</code> to <code>veth1@2</code> where we expect the eBPF redirect to occur<ol><li>The <code>qdisc</code> of type <code>clsact</code> allows us to attach eBPF filters which are triggered for every packet either entering or leaving the network interface.</li></ol></li><li>We then add our eBPF filter to the <code>qdisc</code> on <code>veth1@2</code> in the <code>ingress</code> direction instructing our eBPF program to be triggered on every received packet (as opposed to <code>egress</code> direction for every transmitted packet).<ol><li>The <code>direct-action</code> flag allows our eBPF filter program to actually act like an <code>action</code> which manipulates the packet, instead of a <code>classifier</code> which classifies the packet, allowing our filter to return <code>TC_ACT_REDIRECT</code> in our demonstration.</li></ol></li></ol><p>This attachment process and the flags used can be a bit confusing without a good mental map of the TC subsystem.
I suggesting reading <a href="https://tldp.org/HOWTO/Traffic-Control-HOWTO/intro.html">Traffic Control HOWTO</a> followed by a great post from my colleague: <a href="https://qmonnet.github.io/whirl-offload/2020/04/11/tc-bpf-direct-action/">Understanding tc “direct action” mode for BPF</a>.
The former article helps paint a mental picture of the TC subsystem while the latter will help clear the confusion when you notice how the <code>clsact</code> works differently from traditional <code>qdisc</code> implementations.</p><h3 id="ebpf-redirect-implementation">eBPF Redirect Implementation</h3><p><code>redirect.bpf.c</code></p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&#34;vmlinux.h&#34;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;bpf/bpf_endian.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;bpf/bpf_helpers.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define ETH_P_IP 0x0800 </span><span>/* Internet Protocol packet	*/</span><span>
</span></span></span><span><span><span>#define TC_ACT_OK 0
</span></span></span><span><span><span>#define TC_ACT_REDIRECT 7
</span></span></span><span><span><span></span>
</span></span><span><span><span>// the interface we will redirect to.
</span></span></span><span><span><span></span><span>#define TARGET_INTF 3
</span></span></span><span><span><span></span><span>// the destination IP that determines if we will redirect the packet.
</span></span></span><span><span><span></span><span>#define DEST_IP 0x0a00020b  </span><span>// 10.0.2.11
</span></span></span><span><span><span></span>
</span></span><span><span><span>// look for an IPv4 packet with destination address 10.0.2.11 and redirect
</span></span></span><span><span><span>// it to a target interface.
</span></span></span><span><span><span></span><span>SEC</span>(<span>&#34;tc&#34;</span>)
</span></span><span><span><span>int</span> <span>redirect</span>(<span>struct</span> __sk_buff <span>*</span>ctx) {
</span></span><span><span>    <span>void</span> <span>*</span>data_end <span>=</span> (<span>void</span> <span>*</span>)(__u64)(ctx<span>-&gt;</span>data_end);
</span></span><span><span>    <span>void</span> <span>*</span>data <span>=</span> (<span>void</span> <span>*</span>)(__u64)(ctx<span>-&gt;</span>data);
</span></span><span><span>    <span>struct</span> ethhdr <span>*</span>eth;
</span></span><span><span>    <span>struct</span> iphdr <span>*</span>ipv4;
</span></span><span><span>	<span>int</span> ret;
</span></span><span><span>
</span></span><span><span>	<span>bpf_printk</span>(<span>&#34;redirect: handling packet</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>
</span></span><span><span>    <span>// bounds check for verifier, packet&#39;s data must be at least as large
</span></span></span><span><span><span></span>    <span>// as an ethernet header and the non-variable portion of the IPv4 header.
</span></span></span><span><span><span></span>    <span>if</span> ((data <span>+</span> <span>sizeof</span>(<span>struct</span> ethhdr) <span>+</span> <span>sizeof</span>(<span>struct</span> iphdr) <span>&gt;</span> data_end))
</span></span><span><span>        <span>return</span> TC_ACT_OK;
</span></span><span><span>
</span></span><span><span>    eth <span>=</span> data;
</span></span><span><span>    ipv4 <span>=</span> data <span>+</span> <span>sizeof</span>(<span>struct</span> ethhdr);
</span></span><span><span>
</span></span><span><span>	<span>bpf_printk</span>(<span>&#34;redirect: checking ethernet header for IPv4 proto: %x</span><span>\n</span><span>&#34;</span>, <span>bpf_ntohs</span>(eth<span>-&gt;</span>h_proto));
</span></span><span><span>    <span>if</span> (<span>bpf_ntohs</span>(eth<span>-&gt;</span>h_proto) <span>!=</span> ETH_P_IP) <span>return</span> TC_ACT_OK;
</span></span><span><span>
</span></span><span><span>	<span>bpf_printk</span>(<span>&#34;redirect: checking destination address is 10.0.2.11</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>    <span>if</span> (<span>bpf_ntohl</span>(ipv4<span>-&gt;</span>daddr) <span>!=</span> DEST_IP) <span>return</span> TC_ACT_OK;
</span></span><span><span>
</span></span><span><span>	<span>bpf_printk</span>(<span>&#34;redirect: rewriting destination MAC</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>	eth<span>-&gt;</span>h_dest[<span>0</span>] <span>=</span> <span>0x02</span>;
</span></span><span><span>	eth<span>-&gt;</span>h_dest[<span>1</span>] <span>=</span> <span>0x00</span>;
</span></span><span><span>	eth<span>-&gt;</span>h_dest[<span>2</span>] <span>=</span> <span>0x00</span>;
</span></span><span><span>	eth<span>-&gt;</span>h_dest[<span>3</span>] <span>=</span> <span>0x00</span>;
</span></span><span><span>	eth<span>-&gt;</span>h_dest[<span>4</span>] <span>=</span> <span>0x00</span>;
</span></span><span><span>	eth<span>-&gt;</span>h_dest[<span>5</span>] <span>=</span> <span>0x00</span>;
</span></span><span><span>
</span></span><span><span>	<span>bpf_printk</span>(<span>&#34;redirect: performing redirect</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>	ret <span>=</span> <span>bpf_redirect</span>(TARGET_INTF, <span>0</span>);
</span></span><span><span>
</span></span><span><span>	<span>bpf_printk</span>(<span>&#34;redirect: result: %d</span><span>\n</span><span>&#34;</span>, ret);
</span></span><span><span>	<span>return</span> ret;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>char</span> _license[] <span>SEC</span>(<span>&#34;license&#34;</span>) <span>=</span> <span>&#34;GPL&#34;</span>;
</span></span></code></pre></div><p>The above is our eBPF program which redirects a packet destined to <code>10.0.2.11</code>.
Let’s walk through this code:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&#34;vmlinux.h&#34;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;bpf/bpf_endian.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;bpf/bpf_helpers.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define ETH_P_IP 0x0800 </span><span>/* Internet Protocol packet	*/</span><span>
</span></span></span><span><span><span>#define TC_ACT_OK 0
</span></span></span><span><span><span>#define TC_ACT_REDIRECT 7
</span></span></span><span><span><span></span>
</span></span><span><span><span>// the interface we will redirect to.
</span></span></span><span><span><span></span><span>#define TARGET_INTF 3
</span></span></span><span><span><span></span><span>// the destination IP that determines if we will redirect the packet.
</span></span></span><span><span><span></span><span>#define DEST_IP 0x0a00020b  </span><span>// 10.0.2.11
</span></span></span></code></pre></div><p>We begin by defining some constants we will use later.
Because this is a demonstration we can hard-code some information for simplicity such as the interface ID we plan to redirect our packet to and the destination IP we are snooping for.</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>SEC</span>(<span>&#34;tc&#34;</span>)
</span></span><span><span><span>int</span> <span>redirect</span>(<span>struct</span> __sk_buff <span>*</span>ctx) {
</span></span><span><span>    <span>void</span> <span>*</span>data_end <span>=</span> (<span>void</span> <span>*</span>)(__u64)(ctx<span>-&gt;</span>data_end);
</span></span><span><span>    <span>void</span> <span>*</span>data <span>=</span> (<span>void</span> <span>*</span>)(__u64)(ctx<span>-&gt;</span>data);
</span></span><span><span>    <span>struct</span> ethhdr <span>*</span>eth;
</span></span><span><span>    <span>struct</span> iphdr <span>*</span>ipv4;
</span></span><span><span>	<span>int</span> ret;
</span></span><span><span>
</span></span><span><span>	<span>bpf_printk</span>(<span>&#34;redirect: handling packet</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>
</span></span><span><span>    <span>// bounds check for verifier, packet&#39;s data must be at least as large
</span></span></span><span><span><span></span>    <span>// as an ethernet header and the non-variable portion of the IPv4 header.
</span></span></span><span><span><span></span>    <span>if</span> ((data <span>+</span> <span>sizeof</span>(<span>struct</span> ethhdr) <span>+</span> <span>sizeof</span>(<span>struct</span> iphdr) <span>&gt;</span> data_end))
</span></span><span><span>        <span>return</span> TC_ACT_OK;
</span></span></code></pre></div><p>We are writing a program which runs in the TC subsystem and various loaders (bpftool, tc, libbpf) expect these programs in a ELF section dubbed “tc”, so we put our <code>redirect</code> eBPF program in this section once compiled.</p><p>Within the first few lines of <code>redirect</code> we declare the variables we will use in this function.
We set <code>data</code> and <code>data_end</code> to point to the packet’s data and we’ll use these pointers to parse out information in the packet.</p><p>Finally, we perform a bounds check on our pointers ensuring the packet’s data buffer carries at least a layer 2 and a layer 3 (not including options) header.
This is required before directly accessing packet data as the Kernel must verify your eBPF program only accesses valid memory.</p><div><pre tabindex="0"><code data-lang="c"><span><span>	eth <span>=</span> data;
</span></span><span><span>    ipv4 <span>=</span> data <span>+</span> <span>sizeof</span>(<span>struct</span> ethhdr);
</span></span><span><span>
</span></span><span><span>	<span>bpf_printk</span>(<span>&#34;redirect: checking ethernet header for IPv4 proto: %x</span><span>\n</span><span>&#34;</span>, <span>bpf_ntohs</span>(eth<span>-&gt;</span>h_proto));
</span></span><span><span>    <span>if</span> (<span>bpf_ntohs</span>(eth<span>-&gt;</span>h_proto) <span>!=</span> ETH_P_IP) <span>return</span> TC_ACT_OK;
</span></span><span><span>
</span></span><span><span>	<span>bpf_printk</span>(<span>&#34;redirect: checking destination address is 10.0.2.11</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>    <span>if</span> (<span>bpf_ntohl</span>(ipv4<span>-&gt;</span>daddr) <span>!=</span> DEST_IP) <span>return</span> TC_ACT_OK;
</span></span><span><span>
</span></span><span><span>	<span>bpf_printk</span>(<span>&#34;redirect: rewriting destination MAC</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>	eth<span>-&gt;</span>h_dest[<span>0</span>] <span>=</span> <span>0x02</span>;
</span></span><span><span>	eth<span>-&gt;</span>h_dest[<span>1</span>] <span>=</span> <span>0x00</span>;
</span></span><span><span>	eth<span>-&gt;</span>h_dest[<span>2</span>] <span>=</span> <span>0x00</span>;
</span></span><span><span>	eth<span>-&gt;</span>h_dest[<span>3</span>] <span>=</span> <span>0x00</span>;
</span></span><span><span>	eth<span>-&gt;</span>h_dest[<span>4</span>] <span>=</span> <span>0x00</span>;
</span></span><span><span>	eth<span>-&gt;</span>h_dest[<span>5</span>] <span>=</span> <span>0x00</span>;
</span></span><span><span>
</span></span><span><span>	<span>bpf_printk</span>(<span>&#34;redirect: performing redirect</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>	ret <span>=</span> <span>bpf_redirect</span>(TARGET_INTF, <span>0</span>);
</span></span><span><span>
</span></span><span><span>	<span>bpf_printk</span>(<span>&#34;redirect: result: %d</span><span>\n</span><span>&#34;</span>, ret);
</span></span><span><span>	<span>return</span> ret;
</span></span></code></pre></div><p>After we are sure we can access both the layer 2 and layer 3 headers we can define our pointer variables to them.
Next we do some checks on the headers to ensure this is an IPv4 packet and its destined to <code>10.0.2.11</code>.</p><p>If it is, we need to rewrite the MAC address.
This is necessary because we do a redirect directly from the ingress path on <code>veth1@2</code> to the ingress path of <code>veth2@1</code>.
Because <code>veth2@1</code> is a veth it will immediate forward the packet to <code>veth2@2</code>.
If we do not rewrite the MAC ourselves the packet would arrive at <code>veth2@2</code> with the MAC of <code>veth1@2</code> and will be dropped during ingress processing due to a MAC mismatch between the packet and the interface.
Remember, we hard-code our MAC address of <code>veth2@2</code> in our Makefile so we know exactly what to rewrite the MAC to.</p><div><pre tabindex="0"><code data-lang="c"><span><span>	<span># Hardcode veth2@2 to a dummy MAC for sake of demonstration purposes.
</span></span></span><span><span><span></span>	<span>$</span>(EXEC) <span>$</span>(NET_2) ip link set dev veth2<span>@</span><span>2</span> addr <span>02</span><span>:</span><span>00</span><span>:</span><span>00</span><span>:</span><span>00</span><span>:</span><span>00</span><span>:</span><span>00</span>
</span></span></code></pre></div><p>In a real-world example you’d probably do an eBPF FIB lookup to find the next-hop MAC to rewrite too.</p><p>Finally, we call the <code>bpf_redirect</code> helper to perform the eBPF redirect.
We call it with no flag which indicates we are forwarding to the target interface’s ingress path, much more on in [#Ingress and Egress direction](#Ingress and Egress direction)</p><p>You can start this demonstration by running <code>make up</code> at the root.
If everything went well you shell will be sitting at this prompt:</p><div><pre tabindex="0"><code data-lang="shell"><span><span><span># LISTENING FOR UDP PACKET @ 10.0.2.11 7777...</span>
</span></span><span><span><span># Use &#39;make listen&#39; to listen for another packet...</span>
</span></span><span><span>sudo ip netns exec <span>&#34;netns_2&#34;</span> nc -u -l 10.0.2.11 <span>7777</span>
</span></span></code></pre></div><p>You can then issue this command at the host namespace</p><div><pre tabindex="0"><code data-lang="shell"><span><span>echo <span>&#34;hello&#34;</span> | nc -u 10.0.2.11 <span>7777</span>
</span></span></code></pre></div><p>You should see a ‘hello’ in the terminal where you ran <code>make up</code>.
This indicates the packet successfully redirect to <code>veth2@1</code> and was delivered to the client in <code>netns_2</code>.</p><p>You can edit this code and simply run <code>make up</code> to compile and redeploy it, just make sure you do not have any shells open in either of the namespaces or else the environment cannot be torn down successfully.</p><h2 id="how-it-works-as-of-kernel-v65">How it works (As of Kernel v6.5)</h2><p>Writing the code and seeing the data arrive on your terminal is <a href="https://www.reddit.com/r/oddlysatisfying/comments/10igfs0/getting_out_every_bit_of_cheese/">oddly satisfying</a>, but lets try to understand how it works under the hood.</p><p>First lets look at the signature for <code>bpf_redirect</code> helper itself:</p><div><pre tabindex="0"><code data-lang="c"><span><span> <span>*</span> <span>long</span> <span>bpf_redirect</span>(u32 ifindex, u64 flags)
</span></span><span><span> <span>*</span> 	Description
</span></span><span><span> <span>*</span> 		Redirect the packet to another net device of index <span>*</span>ifindex<span>*</span>.
</span></span><span><span> <span>*</span> 		This helper is somewhat similar to <span>**</span>bpf_clone_redirect<span>**</span>\
</span></span><span><span> <span>*</span> 		(), except that the packet is not cloned, which provides
</span></span><span><span> <span>*</span> 		increased performance.
</span></span><span><span> <span>*</span>
</span></span><span><span> <span>*</span> 		Except <span>for</span> XDP, both ingress and egress interfaces can be used
</span></span><span><span> <span>*</span> 		<span>for</span> redirection. The <span>**</span>BPF_F_INGRESS<span>**</span> value in <span>*</span>flags<span>*</span> is used
</span></span><span><span> <span>*</span> 		to make the <span>distinction</span> (ingress path is selected <span>if</span> the flag
</span></span><span><span> <span>*</span> 		is present, egress path otherwise). Currently, XDP only
</span></span><span><span> <span>*</span> 		supports redirection to the egress interface, and accepts no
</span></span><span><span> <span>*</span> 		flag at all.
</span></span><span><span> <span>*</span>
</span></span><span><span> <span>*</span> 		The same effect can also be attained with the more generic
</span></span><span><span> <span>*</span> 		<span>**</span>bpf_redirect_map<span>**</span><span>\</span> (), which uses a BPF map to store the
</span></span><span><span> <span>*</span> 		redirect target instead of providing it directly to the helper.
</span></span><span><span> <span>*</span> 	Return
</span></span><span><span> <span>*</span> 		For XDP, the helper returns <span>**</span>XDP_REDIRECT<span>**</span> on success or
</span></span><span><span> <span>*</span> 		<span>**</span>XDP_ABORTED<span>**</span> on error. For other program types, the values
</span></span><span><span> <span>*</span> 		are <span>**</span>TC_ACT_REDIRECT<span>**</span> on success or <span>**</span>TC_ACT_SHOT<span>**</span> on
</span></span><span><span> <span>*</span> 		error.
</span></span></code></pre></div><p>So, pretty simple right, ignoring the bits about XDP (we won’t dig into this yet)?
Give it an interface and a direction and we’ll move the packet there.</p><p>But, lets dig into the actual <a href="https://elixir.bootlin.com/linux/v6.5/source/net/core/filter.c#L2503">implementation</a> a bit:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>BPF_CALL_2</span>(bpf_redirect, u32, ifindex, u64, flags)
</span></span><span><span>{
</span></span><span><span>	<span>struct</span> bpf_redirect_info <span>*</span>ri <span>=</span> <span>this_cpu_ptr</span>(<span>&amp;</span>bpf_redirect_info);
</span></span><span><span>
</span></span><span><span>	<span>if</span> (<span>unlikely</span>(flags <span>&amp;</span> (<span>~</span>(BPF_F_INGRESS) <span>|</span> BPF_F_REDIRECT_INTERNAL)))
</span></span><span><span>		<span>return</span> TC_ACT_SHOT;
</span></span><span><span>
</span></span><span><span>	ri<span>-&gt;</span>flags <span>=</span> flags;
</span></span><span><span>	ri<span>-&gt;</span>tgt_index <span>=</span> ifindex;
</span></span><span><span>
</span></span><span><span>	<span>return</span> TC_ACT_REDIRECT;
</span></span><span><span>}
</span></span></code></pre></div><p>Now, because I want to keep these articles focused more on demonstrations rather then Kernel code walks, which can get rather lengthily rather quickly, I won’t explain the entire packet flow.
But it may strike you odd, as it struck me, that this implementation is very simple.
All we are doing is setting some flags and returning the <code>TC_ACT_REDIRECT</code> flag to the TC subsystem.</p><p>Keep in mind that this eBPF program is running within the context of the TC subsystem.
With a focus on the ingress packet path, let’s take a look at the function responsible for running our eBPF TC filter and handling the response.
<a href="">implementation</a></p><div><pre tabindex="0"><code data-lang="c"><span><span>	<span>case</span> TC_ACT_REDIRECT:
</span></span><span><span>		<span>/* skb_mac_header check was done by cls/act_bpf, so
</span></span></span><span><span><span>		 * we can safely push the L2 header back before
</span></span></span><span><span><span>		 * redirecting to another netdev
</span></span></span><span><span><span>		 */</span>
</span></span><span><span>		<span>__skb_push</span>(skb, skb<span>-&gt;</span>mac_len);
</span></span><span><span>		<span>if</span> (<span>skb_do_redirect</span>(skb) <span>==</span> <span>-</span>EAGAIN) {
</span></span><span><span>			<span>__skb_pull</span>(skb, skb<span>-&gt;</span>mac_len);
</span></span><span><span>			<span>*</span>another <span>=</span> true;
</span></span><span><span>			<span>break</span>;
</span></span><span><span>		}
</span></span><span><span>		<span>*</span>ret <span>=</span> NET_RX_SUCCESS;
</span></span><span><span>		<span>return</span> NULL;
</span></span></code></pre></div><p>Focusing on what occurs when the eBPF program returns <code>TC_ACT_DIRECT</code> we can see that the <a href="https://elixir.bootlin.com/linux/v6.5/source/net/core/filter.c#L2468"><code>*skb_do_redirect*</code> function</a> is invoked.</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>int</span> <span>skb_do_redirect</span>(<span>struct</span> sk_buff <span>*</span>skb)
</span></span><span><span>{
</span></span><span><span>	<span>struct</span> bpf_redirect_info <span>*</span>ri <span>=</span> <span>this_cpu_ptr</span>(<span>&amp;</span>bpf_redirect_info);
</span></span><span><span>	<span>struct</span> net <span>*</span>net <span>=</span> <span>dev_net</span>(skb<span>-&gt;</span>dev);
</span></span><span><span>	<span>struct</span> net_device <span>*</span>dev;
</span></span><span><span>	u32 flags <span>=</span> ri<span>-&gt;</span>flags;
</span></span><span><span>...
</span></span><span><span>	       <span>__bpf_redirect</span>(skb, dev, flags);
</span></span></code></pre></div><p>Taking a look at the interesting bits we see that we retrieve the <code>bpf_redirect_info</code> structure that we stashed our flags into during <code>bpf_redirect</code> and in our case we invoke the <code>__bpf_redirect</code> function.</p><p>I’ll leave it to the reader to continue tracing this path our in the code.
It will eventually lead the packet being queued on another network device.</p><p>The key take away from the above is that <code>bpf_redirect</code> occurs outside of the eBPF program and the TC subsystem is designed to redirect the packet, not the actual eBPF program.</p><h2 id="ingress-and-egress">Ingress and Egress</h2><p>So I’ve been throwing these terms ‘ingress’ and ’egress’ around pretty loosely and I think there’s some bits worth explaining here.</p><p>Within the context of TC, specifically with the <code>clsact qdisc</code>, the terms ‘ingress’ and ’egress’ are referring to where your eBPF program is being attached.
The <code>ingress</code> keyword provided to the <code>tc filter replace</code> command will attach your eBPF program such that it runs for every received packet.
Adversely, <code>egress</code> attaches your eBPF program such that it runs for every transmitted packet.</p><p>Within the context of the <code>bpf_redirect</code> helper the terms <code>ingress</code> and <code>egress</code> are really referring to how the Linux subsystem interprets this redirected packet.</p><p>The kernel may look at the packet and determine it was just received by an interface and process it via the normal ingress packet flow, passing the packet up to each protocol handler and toward remote (not for us) or local (listening socket exists locally) delivery.
This is what occurs when the default flag of <code>0</code> is provided to the <code>bpf_redirect</code> helper.</p><p>Another flag exists called <code>BPF_F_EGRESS</code> which instructs the kernel to process this packet as if it was being transmitted.
Instead of the kernel taking the redirected packet and passing it up to protocols, it will pass the packet to the egress packet flow where it will be eventually transmitted by the hardware corresponding to the interface ID passed to the helper.</p><p>Let’s use a great tool contributed by my colleagues called <a href="https://github.com/cilium/pwru.git">Packet Where Are You</a> to demonstrate this.</p><p>I keep this handy alias in my shell for quickly debugging eBPF programs.</p><div><pre tabindex="0"><code data-lang="shell"><span><span>pwr<span>=</span><span>&#39;docker run --privileged --rm -t --pid=host -v /sys/kernel/debug/:/sys/kernel/debug/ cilium/pwru pwru&#39;</span>
</span></span><span><span>	/usr/bin/docker
</span></span></code></pre></div><p>Now run the following in your shell after pasting that alias in (this can be on your host, the kernel is the kernel, and tracing kernel functions isn’t isolated by any namespacing.)</p><div><pre tabindex="0"><code data-lang="shell"><span><span>pwr --output-meta dst 10.0.2.11
</span></span></code></pre></div><p>Now start the demo environment if you don’t have it running with <code>make up</code>.
If you do have it running and you’ve already sent a packet run <code>make listen</code> to listen for another packet (yes I’m too lazy to script this :-p).
Now, send a packet off and you should see output from <code>pwr</code>.</p><div><pre tabindex="0"><code data-lang="shell"><span><span>echo <span>&#34;hello&#34;</span> | nc -u 10.0.2.11 <span>7777</span>
</span></span></code></pre></div><p><em>Note: you may actually catch ARP the first time you run this command. If you see logs like <code>arp_solicited</code>, run it one more time after ARP has been processed. You’ll know you have the right output when you see veths being identified with fields like this <code>iface=3(veth1@1)</code> in the log.</em></p><p>Let’s pick out the relevant functions from the output that demonstrate how ingress and egress flags influence the redirect. Lines irrelevant to our explanation are skipped.</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>0xffff8fc859bc3c00</span>      <span>7</span>    [<span>nc</span>(<span>3184970</span>)]         __dev_queue_xmit netns<span>=</span><span>4026535320</span> mark<span>=</span><span>0x0</span> iface<span>=</span><span>3</span>(veth1<span>@</span><span>1</span>) proto<span>=</span><span>0x0800</span> mtu<span>=</span><span>1500</span> len<span>=</span><span>48</span> <span>// veth1@1 preparing to transmit to its veth1@2 pair
</span></span></span><span><span><span></span>
</span></span><span><span><span>0xffff8fc9d885f300</span>      <span>6</span>    [<span>nc</span>(<span>3195225</span>)]               __netif_rx netns<span>=</span><span>4026535460</span> mark<span>=</span><span>0x0</span> iface<span>=</span><span>2</span> proto<span>=</span><span>0x0800</span> mtu<span>=</span><span>1500</span> len<span>=</span><span>34</span> <span>// veth1@2 receiving the packet
</span></span></span><span><span><span></span>
</span></span><span><span><span>0xffff8fc9d885f300</span>      <span>6</span> [<span>&lt;</span>empty<span>&gt;</span>(<span>3195225</span>)] __netif_receive_skb_one_core netns<span>=</span><span>4026535460</span> mark<span>=</span><span>0x0</span> iface<span>=</span><span>2</span> proto<span>=</span><span>0x0800</span> mtu<span>=</span><span>1500</span> len<span>=</span><span>34</span> <span>// veth2@2 begins ingress packet processing
</span></span></span><span><span><span></span>
</span></span><span><span><span>0xffff8fc9d885f300</span>      <span>6</span> [<span>&lt;</span>empty<span>&gt;</span>(<span>3195225</span>)]             tcf_classify netns<span>=</span><span>4026535460</span> mark<span>=</span><span>0x0</span> iface<span>=</span><span>2</span> proto<span>=</span><span>0x0800</span> mtu<span>=</span><span>1500</span> len<span>=</span><span>34</span> <span>// enter TC subsystem where our eBPF program runs
</span></span></span><span><span><span></span>
</span></span><span><span><span>0xffff8fc9d885f300</span>      <span>6</span> [<span>&lt;</span>empty<span>&gt;</span>(<span>3195225</span>)]          skb_do_redirect netns<span>=</span><span>4026535460</span> mark<span>=</span><span>0x0</span> iface<span>=</span><span>2</span> proto<span>=</span><span>0x0800</span> mtu<span>=</span><span>1500</span> len<span>=</span><span>48</span> <span>// invoke a redirection for this packet
</span></span></span><span><span><span></span>
</span></span><span><span><span>0xffff8fc9d885f300</span>      <span>6</span> [<span>&lt;</span>empty<span>&gt;</span>(<span>3195225</span>)]           __bpf_redirect netns<span>=</span><span>4026535460</span> mark<span>=</span><span>0x0</span> iface<span>=</span><span>2</span> proto<span>=</span><span>0x0800</span> mtu<span>=</span><span>1500</span> len<span>=</span><span>48</span> <span>// use our eBPF structure to perform redirect
</span></span></span><span><span><span></span>
</span></span><span><span><span>0xffff8fc9d885f300</span>      <span>6</span> [<span>&lt;</span>empty<span>&gt;</span>(<span>3195225</span>)]         __dev_queue_xmit netns<span>=</span><span>4026535460</span> mark<span>=</span><span>0x0</span> iface<span>=</span><span>3</span> proto<span>=</span><span>0x0800</span> mtu<span>=</span><span>1500</span> len<span>=</span><span>48</span> <span>// the important part! 
</span></span></span></code></pre></div><p>The above ends with the <code>__dev_queue_xmit</code> function being invoked with <code>iface=3</code>.
In our case this is the <code>veth2@2</code> interface in <code>netns_1</code> which is where we redirect the packet to.
The important part here is we immediately wind up in the transmission function for the device, or in other words the packet will be transmitted on <code>veth2@2</code> after the redirect is processed.</p><p>Now, I want us to change <code>packet_redirect.bpf.c:49</code> to the following:</p><div><pre tabindex="0"><code data-lang="c"><span><span>	ret <span>=</span> <span>bpf_redirect</span>(TARGET_INTF, BPF_F_INGRESS);
</span></span></code></pre></div><p>Run <code>make up</code> to rebuild the environment and follow the same steps to get <code>pwr</code> output.</p><p>Let’s pick up right at <code>skb_do_redirect</code> this time.</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>0xffff8fc8544c3e00</span>      <span>3</span> [<span>&lt;</span>empty<span>&gt;</span>(<span>3223205</span>)]          skb_do_redirect netns<span>=</span><span>4026535561</span> mark<span>=</span><span>0x0</span> iface<span>=</span><span>2</span> proto<span>=</span><span>0x0800</span> mtu<span>=</span><span>1500</span> len<span>=</span><span>48</span>
</span></span><span><span><span>0xffff8fc8544c3e00</span>      <span>3</span> [<span>&lt;</span>empty<span>&gt;</span>(<span>3223205</span>)]           __bpf_redirect netns<span>=</span><span>4026535561</span> mark<span>=</span><span>0x0</span> iface<span>=</span><span>2</span> proto<span>=</span><span>0x0800</span> mtu<span>=</span><span>1500</span> len<span>=</span><span>48</span>
</span></span><span><span><span>0xffff8fc8544c3e00</span>      <span>3</span> [<span>&lt;</span>empty<span>&gt;</span>(<span>3223205</span>)]        netif_rx_internal netns<span>=</span><span>4026535561</span> mark<span>=</span><span>0x0</span> iface<span>=</span><span>3</span> proto<span>=</span><span>0x0800</span> mtu<span>=</span><span>1500</span> len<span>=</span><span>34</span>
</span></span><span><span><span>0xffff8fc8544c3e00</span>      <span>3</span> [<span>&lt;</span>empty<span>&gt;</span>(<span>3223205</span>)]       enqueue_to_backlog netns<span>=</span><span>4026535561</span> mark<span>=</span><span>0x0</span> iface<span>=</span><span>3</span> proto<span>=</span><span>0x0800</span> mtu<span>=</span><span>1500</span> len<span>=</span><span>34</span>
</span></span><span><span><span>0xffff8fc8544c3e00</span>      <span>3</span> [<span>&lt;</span>empty<span>&gt;</span>(<span>3223205</span>)]      __netif_receive_skb netns<span>=</span><span>4026535561</span> mark<span>=</span><span>0x0</span> iface<span>=</span><span>3</span> proto<span>=</span><span>0x0800</span> mtu<span>=</span><span>1500</span> len<span>=</span><span>34</span>
</span></span><span><span><span>0xffff8fc8544c3e00</span>      <span>3</span> [<span>&lt;</span>empty<span>&gt;</span>(<span>3223205</span>)] __netif_receive_skb_one_core netns<span>=</span><span>4026535561</span> mark<span>=</span><span>0x0</span> iface<span>=</span><span>3</span> proto<span>=</span><span>0x0800</span> mtu<span>=</span><span>1500</span> len<span>=</span><span>34</span>
</span></span></code></pre></div><p>Notice now when the <code>BPF_F_INGRESS</code> flag is used we wind up in the ingress packet path of the kernel with <code>iface=3</code> which is <code>veth2@2</code>.
The usage of will result in the packet being “recirculated” into <code>netns_1</code> but with a source interface of <code>veth2@2</code>.</p><p>Keep in mind your <code>veth</code> identifications may be slightly different, since I run my demo environment inside a dedicated eBPF development container.
If you run the demo directly on your host machine the output will vary slightly but the general packet flow should remain the same.</p><h2 id="summing-it-up">Summing it up</h2><p>eBPF packet redirection is a common technique especially in container orchestration software like Kubernetes.
Cilium, which I work on as my day job, uses this all the time to move packets between containers.</p><p>There are a few other ways to perform packet redirection in the Kernel which build on this basic technique.
I’ll be covering those next.
Follow me on the <a href="https://fosstodon.org/@ldelossa">social mediaz</a> if you’re interested in more posts like this.</p></div></div>
  </body>
</html>
