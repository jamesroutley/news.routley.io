<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fosskers.ca/en/blog/rounds-of-lisp">Original</a>
    <h1>A Tour of Lisps</h1>
    
    <div id="readability-page-1" class="page"><div><p>2023 seems to have been the year where I &#34;made the rounds&#34; of a number of major Lisps. There were several elements that lead to this. Firstly must have been my exposure to Elixir in 2022, which introduced me to the idea of debugging live systems and &#34;staying in your program&#34;. Secondly must have been my chief complaint of Rust; although it is a wonderful language and ecosystem in many ways, you can&#39;t say that it&#39;s beautiful, which my previous love Haskell very much was. Thirdly then must been the talk <a href="https://www.youtube.com/watch?v=8Ab3ArE8W3s&amp;pp=ygUnc3RvcCB3cml0aW5nIGRlYWQgcHJvZ3JhbXMgamFjayBkb25vdmFu">Stop Writing Dead Programs</a> by Jack Rusher, which opened my eyes to the prevalence of the write-compile-run development cycle and how we can escape from it. And last was my day-to-day usage of Emacs, whose configuration language is also a Lisp. Thanks Henrik.</p><p>Over the past year I published software in five Lisps: Guile, Common Lisp, Fennel, Clojure, and Emacs Lisp. Based on some questions I received from a Doom Emacs community member, I&#39;ll talk about each of these and reveal where I am now in my views and usage of Lisp languages.</p><h2 id="org8bd351">Questions</h2><h3 id="org92cbde">What was the purpose of doing the rounds?</h3><p>It happened organically, I didn&#39;t plan to do it.</p><p>I mostly switched away from Haskell to Rust during COVID, sometime during 2020. I had some time off, decided to learn both Go and Rust, and was happier with the latter as I found that I could very much &#34;speak Haskell&#34; in it while gaining <a href="https://www.fosskers.ca/en/blog/rust-software-dev">other modern benefits</a> like the Ownership system. Very little compromise for massive gain.</p><p>Yet I&#39;ve always had a love for terser, elegant languages, and I&#39;ve always had a soft spot for Lisps. I like Rust, but somehow it didn&#39;t feel like home. The purpose of the rounds was to once and for all find a language that could satisfy my needs as a working software developer, but also &#34;tickle my fancy&#34; in terms of day-to-day joy and match my values as a person.</p><h3 id="orgf72a8b">What draws you to a Lisp dialect?</h3><p>Beauty in programs is important. I generally believe that beautiful code is less likely to be buggy, since beauty and simplicity are related, simplicity is the dual of complexity, and complexity is the womb from which bugs emerge.</p><p>Lisps are beautiful. Code is generally quite terse thanks to its syntax. And something interesting happens with even a bit of serious Lisp experience: you stop seeing the parentheses. Not that they&#39;d be a bother if you did; the parens allow &#34;structural editing&#34; which can speed up your editing. You&#39;re no longer bound to characters and lines, you can swap and move entire s-expressions freely. And besides, modern editor setups handle the parenthesis balancing for you. I spend no extra time herding parentheses, but I can see how this would have been an issue in the past.</p><p>So I&#39;m clearly drawn to the aesthetics, as I was in my Haskell years. But what drew me to the particular Lisps I tried?</p><p><span>Guile</span> has Scheme&#39;s cleanliness and consistency. It&#39;s also a GNU language and installed by default on many systems, and there was a part of me that loved <i>the
freedom, man, yeah</i>. It was here that I discovered Transducers and fell in love, proceeding to port the paradigm to <a href="https://git.sr.ht/~fosskers/cl-transducers">Common Lisp</a>, <a href="https://git.sr.ht/~fosskers/transducers.fnl">Fennel</a>, and <a href="https://git.sr.ht/~fosskers/transducers.el">Emacs Lisp</a>. Guile though is hard to produce larger projects in if you aren&#39;t using Guix, since there exists no non-Guix-based dependency management.</p><p><span>Common Lisp</span> is the classic. It has its historical warts, but I found an active ecosystem and enthusiastic community. Best-in-class debuggability and interactivity for any language I&#39;ve used. Have you ever wanted to debug external library code, but from within your program? While it&#39;s running? In prod across the network? Well you can. It&#39;s also a compiled language but allows hotswapping like Erlang, and has a static type system if you want it for API-hardening and performance tuning. It&#39;s definitely a power user&#39;s language. There are modern libraries for papering over some of the historical stdlib API oddities, although discovering these is sometimes difficult. There is also no &#34;one Common Lisp&#34;, you need to <a href="https://github.com/CodyReichert/awesome-cl#implementations">pick an implementation</a> to work with. No LSP either, although existing editor integrations are of sufficently high quality and predate the notion of LSPs, so they aren&#39;t particularly missed.</p><p><a href="https://fennel-lang.org/">Fennel</a> is simple and clean. It compiles to Lua, shares its semantics, and can trivially use Lua libraries. The <a href="https://tic80.com/">TIC-80</a> supports it natively for retro game development, which I used to write <a href="https://tic80.com/play?cart=3375">Snake</a> and a port of the classic TI83 game <a href="https://fosskers.itch.io/falldown">Falldown</a>. It&#39;s tooling improves with time and you can produce static binaries with it, but direct vendoring is the recommended dependency management strategy. It also lacks Common Lisp&#39;s debuggability, given that it sits entirely within Lua&#39;s runtime.</p><p><span>Clojure</span> is what happens when a smart, experienced developer sits down for two years and thinks about what a programming language really needs to be to get work done in the real world. And Rich Hickey did an excellent job. Clojure is very clean, has best-in-class ergonomics, and best-in-class tooling. Great data structure literals. Its community is also very strong and <a href="https://www.clojuriststogether.org/">self-funds</a> many of the popular projects. Its heavy integration with the JVM turns a lot of people off (myself included), but there are <a href="https://github.com/babashka/babashka">alternate platforms</a> available, including an upcoming <a href="https://github.com/jank-lang/jank/">C++-based native implementation</a> which I&#39;ve had my eye on for some time. Clojure can definitely be said to have &#34;brought Lisp into the modern age&#34;, and I used it to power the <a href="https://git.sr.ht/~fosskers/faur">AUR data mirror</a> that <a href="https://github.com/fosskers/aura">Aura</a> uses. Unfortunately Clojure does have famously poor error messages, and while it has some of Common Lisp&#39;s prod-debuggability and hotswapping, I always miss having the Condition System.</p><p>And finally, the strength of <span>Emacs Lisp</span> is that it&#39;s always at hand. Best-in-class discoverability due to editor integration, and especially in combination with Org Mode it&#39;s easiest to whip out quick code samples. I write a lot of small script-like functionality in it, which is then always available without leaving the editor and is only one button press away from executing. It also has a very active <a href="https://melpa.org/#/">ecosystem</a> and community projects like <a href="https://github.com/doomemacs/doomemacs/">Doom Emacs</a>. Given how old it is though, senior even to Common Lisp, it has some historical cruft and lacks &#34;obvious&#34; things like first-class async. Makes for some really clean editor config, though!</p><p>As you can see, each dialect has its strengths but is not without drawbacks.</p><h3 id="org8270ce">What have you learned, big-picture-wise, from doing the rounds?</h3><p>Several things.</p><p>First, I learned that I had been obsessing over Order. In things being &#34;just so&#34;, especially with regards to the type system. I&#39;ve overhauled Aura enough times to know that I gain joy from pushing puzzle pieces into place, but that doesn&#39;t necessarily lead to a state of &#34;being done&#34; and freedom in the <a href="https://medium.com/@bre/the-cult-of-done-manifesto-724ca1c2ff13">Getting Stuff Done</a> sense. Type systems are great for maintainability, but especially through my exposure to Clojure-thinking and live, in-editor testing like:</p><div><pre><code><span id="1"><a href="#1"></a>(<span>comment</span></span>
<span id="2"><a href="#2"></a>  (clojure.str/join <span>&#34;foo&#34;</span> <span>&#34;bar&#34;</span>))</span></code></pre></div><p>and leaving a <code>repl.clj</code> or <code>repl.lisp</code> file around in every project filled with little utilities for live testing, I&#39;ve come around to the idea that:</p><blockquote><p>It&#39;s okay to start dynamic and tighten down the API later with gradual-typing
mechanisms once the domain crystalizes.</p></blockquote><p>Some Lisps have such things, such as Common Lisp, Racket, and Clojure. Heck even Simon Peyton-Jones, the inventor of Haskell, has <a href="https://codersatwork.com/">gone on record</a> saying:</p><blockquote><p>...dynamic languages are still interesting and important. There are programs you
can write which can&#39;t be typed by a particular type system but which
nevertheless don&#39;t &#34;go wrong&#34; at runtime, which is the gold standard - don&#39;t
segfault, don&#39;t add integers to characters. They&#39;re just fine.</p><p>I think to try to specify all that a program should do, you get specifications
that are themselves so complicated that you&#39;re not longer confident that they
say what you intended.</p></blockquote><p>The harder it is to test things in-editor, the more you need top-down structure like type systems and unit tests. Lisp makes in-editor testing very easy.</p><p>Now second, I learned that I had never truly debugged before. The tools provided particularly by Common Lisp and to a slightly lesser degree Clojure allow me to <span>be inside my program</span> at all times. Why do print-line-debugging to find out what&#39;s happening at a location in code when you can just be inside your program and inspect everything live as it&#39;s running? I had never known that this existed as a paradigm. The write-compile-run cycle we usually suffer through in other languages is silly, and I do feel this pain in Rust.</p><p>Third, that Lisps are mostly not about writing macros. I have written perhaps two small ones. Functions do the job the vast majority of the time. No, I&#39;d say &#34;the center of Lisp&#34;, if it&#39;s anywhere, is the interactive REPL-based development. And that doesn&#39;t mean you should be typing things into a REPL prompt manually like a Neanderthal; modern setups have you type directly into your editor and <i>send</i> the code to the REPL, receiving the result as an in-editor overlay. It&#39;s quite pretty (see the <code>comment</code> example above).</p><p>And finally fourth, I got confirmation that Lisps are entirely usable in the modern day. Real, working, maintainable software can be written for basically <a href="https://store.steampowered.com/app/1261430/Kandria/">any domain</a>. And did you know salaries for Lisp languages <a href="https://survey.stackoverflow.co/2023/#salary-and-experience-by-language">seem to be quite high</a>?</p><h3 id="org2133ee">What&#39;s your current mental model of an &#34;ideal Lisp&#34;?</h3><p>It would be something like a fusion of Clojure and Common Lisp, but with stronger-yet-still-optional static typing features. Enums are great, traits/typeclasses are great, so let&#39;s have those when we want them. Maybe the latter isn&#39;t as necessary if you&#39;re doing generic-dispatch properly.</p><p>I like Functional Programming, and I&#39;m not married to CLOS. Structs do the job just fine for me, but maybe I&#39;m missing something.</p><p>I&#39;d want the debuggability of Common Lisp for sure, and its ability to compile natively. Rich was both right and wrong about parens; I&#39;m not offended by CL-style paren usage, for example in this <code>let</code>:</p><div><pre>(let* ((foo (bar 5))
       (baz (zoo foo)))
  #(foo baz))</pre></div><p>versus</p><div><pre><code><span id="1"><a href="#1"></a>(<span>let</span> [foo (bar <span>5</span>)</span>
<span id="2"><a href="#2"></a>      bar (zoo foo)]</span>
<span id="3"><a href="#3"></a>  [foo baz])</span></code></pre></div><p>Yet as seen in the second example, I <span>do</span> want special brackets for well-used collections like vectors, maps, and sets.</p><p>After that I&#39;d be happy with good tooling and a talented community.</p><p>As an aside, it should be known that some folks have gone to great lengths to embed other languages inside Common Lisp, namely <a href="https://github.com/coalton-lang/coalton">Coalton</a>, a Haskell-like Lisp, and <a href="https://github.com/phantomics/april">April</a>, which is APL. These can be easily slotted into existing CL programs.</p><h3 id="org3c9725">Do you believe s-expressions are the be-all-end-all of Lisp syntax?</h3><p>Yes, because of structural editing and because Lisp isn&#39;t APL or <a href="https://www.uiua.org/">Uiua</a>. Something is lost when you still want to be a word-based language but insist on whitespace-only like Python or Haskell. Efforts to abandon parentheses for fear that they turn away theoretical new users are misguided. Mature people can see past such surface details. Growth for its own sake is not a virtue.</p><h3 id="org309a3e">How can newcomers get the most out of learning Lisp?</h3><ol><li>Start with a proper setup.</li><li>Embrace the REPL.</li><li>Immerse yourself.</li><li>Get help.</li></ol><p>Immersion is the best way to learn a human language; so too of programming. Configuring your <a href="https://github.com/doomemacs/doomemacs/">Editor</a> (another option: <a href="https://lem-project.github.io/">Lem</a>), your <a href="https://github.com/atlas-engineer/nyxt">Browser</a>, or your <a href="https://guix.gnu.org/">OS</a> in a Lisp is a good way to stay immersed.</p><p>You&#39;ll also want to build something real. Naturally as in any project, if you don&#39;t have a goal in mind you aren&#39;t going to get very far, so I&#39;d also say that the next time you want to build something, just pick a Lisp to do it in.</p><p>Before that though, you&#39;ll want to make sure you have a proper setup. Get the <a href="https://github.com/joaotavora/sly">editor modes</a>, find the LSPs, download the dependency managers, grab the <a href="https://github.com/justinbarclay/parinfer-rust-mode">paren-balancers</a>.</p><p>If you want help, check out the Clojure Slack. They&#39;re very welcoming there. For Common Lisp, see my article on <a href="https://www.fosskers.ca/en/blog/common-lisp">Common Lisp resources</a>. Consider also joining the Doom Emacs Discord server or the Lisp Discord server. Also try to find meetups in your area. You might be surprised at how much is happening in this world.</p><p>If you just want to get your feet wet, consider <a href="https://exercism.org/">Exercism</a>.</p><p>Overall, I&#39;d say start with Clojure, get a feel for the style, then swing over to Common Lisp to see what each is missing. If you&#39;ve built something real in either, you should have gotten a feel for what the paradigm offers. I personally don&#39;t feel you necessarily need to slog through a giant 1000-page textbook to learn a Lisp. That includes the famous <a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs">Structure and Interpretation of Computer
Programs</a>. At the end of the day, you just need to write code, and no amount of reading will ever be a substitute for that.</p><h2 id="orgca5e2f">Conclusion</h2><p>I find myself <a href="https://codeberg.org/fosskers/filepaths">writing Common Lisp</a> lately. I had a moment at work recently where odd behaviour in our Rust application code was likely due to a bug in a library, but I couldn&#39;t debug it <i>right there</i> to confirm the problem. What follows is a clone, patch, push, re-pin, retest, ok, merge, release, re-pin again... you get it. I noticed myself thinking &#34;if this were Common Lisp this debug would have taken 30 seconds.&#34; So here I am, at least for my personal coding.</p><p>Both Common Lisp and Lisps in general are &#34;chill caf√©s&#34;. The communities are small enough to find yourself a nice window seat, and projects are generally well-written. The folks themselves are self-selecting and I&#39;ve had nothing but positive experiences.</p><p>Have I found my &#34;one true language&#34;? Well, no, because there isn&#39;t such a thing. No matter which tool we pick, we&#39;ll always <a href="https://www.fosskers.ca/en/blog/subsetting-your-life">have to choose an inner subset</a> of features to adopt, at least until &#34;the next stage&#34;. And as nice as newer languages like Clojure and Rust are, these aren&#39;t Man&#39;s final programming languages. But I&#39;m happy for now.</p><h2 id="orgc547d5">Feedback</h2><p>Here are my responses to some questions I got regarding the article.</p><blockquote><p>What about other Schemes like Chicken, Chez, Gambit, etc.? Like CL, the Scheme
implementation you pick can affect your day to day experience a lot.</p></blockquote><p>I had tried Chicken a bit in 2022 (I think). It seemed like a decent package, although I turned away nonetheless. Racket I had also tried in the past but moved on for similar reasons.</p><p>To me, the Schemes seem like good languages, but when doing software development the language itself <a href="https://www.fosskers.ca/en/blog/software-dev-langs">isn&#39;t all there is to it</a>.</p><blockquote><p>What about Clojure&#39;s Condition System library, Farolero?</p></blockquote><p><a href="https://github.com/IGJoshua/farolero">I have tried this</a>. It&#39;s a solid attempt at introducing as much of the Condition System as possible given the underlying platform&#39;s capabilities. Although, since it&#39;s not first-class, it isn&#39;t trivial to integrate across libraries. Probably decent for application development.</p></div></div>
  </body>
</html>
