<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://dilawar.ai/2025/06/30/I%27m%20back/">Original</a>
    <h1>Vibe Coding</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p><img src="https://www.nullpt.rs/images/dilawar_michi.jpeg"/>
</p>

<p>After way too long away from this blog, Iâ€™m back (and now with a co-author ğŸ±)! </p>
<p>So where have I been? Barcelona! Why? I somehow landed a job at Apple as a (Lead) Machine Learning Engineer. Still not entirely sure how that happened, but Iâ€™m not complaining.</p>
<p>For the past 4 years, Iâ€™ve been working on some pretty interesting stuff around foundation models, search (specifically Spotlight and Siri), and multilinguality. The team was incredible, full of ridiculously smart and genuinely kind people. I got to work on everything from optimizing on-device transformer models to contributing to Appleâ€™s batch inference infrastructure, and even some LLM work spanning pre-training to post-training.</p>
<p>One highlight was getting to present work on improving on-device models to Tim Cook and the AI/ML Leadership at the Steve Jobs Theater, which was both terrifying and surreal. The project focused on making Siri more performant for real-world use cases, which is way harder than it sounds when youâ€™re dealing with the constraints of mobile hardware.</p>
<p><img src="https://www.nullpt.rs/images/dilawar_thien.jpeg"/>
</p>

<p>The reason I havenâ€™t posted anything here is pretty simple: Apple is very, very secretive. When your work involves things that might show up in millions of devices, you learn to keep quiet about the details.</p>
<p>But now Iâ€™m on a sabbatical and heading to something Iâ€™ve wanted to do for a long time: the <a target="_blank" rel="noopener" href="https://www.recurse.com/">Recurse Center</a> in NYC for their S2â€™25 batch! For those who havenâ€™t heard of it, RC is this amazing self-directed programming retreat where you spend 6-12 weeks working on whatever programming projects excite you, surrounded by other curious programmers. No OKRs, no deadlines, just learning and building.</p>
<p>Iâ€™m planning to dive deep into high performance AI reasoning algorithms, explore functional programming more seriously, and work on a bunch of other projects I never had the bandwidth for. Most exciting is just being around other people who love programming for the sake of programming.</p>
<h2 id="My-thoughts-on-vibe-coding"><a href="#My-thoughts-on-vibe-coding" title="My thoughts on vibe coding"></a>My thoughts on vibe coding</h2><p>Speaking of programming, thereâ€™s this new trend thatâ€™s been making waves called â€œvibe coding.â€ The term was <a target="_blank" rel="noopener" href="https://x.com/karpathy/status/1886192184808149383">coined by Andrej Karpathy</a> and describes a way of programming where you basically let AI generate all your code while you â€œfully give in to the vibes, embrace exponentials, and forget that the code even exists.â€</p>
<p><img src="https://tenor.com/view/vibe-coding-vibes-coding-ai-coding-vibe-coding-meme-gif-4697795754689028301.gif" alt="Vibe coding meme GIF"/></p>
<h3 id="What-is-vibe-coding-exactly"><a href="#What-is-vibe-coding-exactly" title="What is vibe coding, exactly?"></a>What is vibe coding, exactly?</h3><p>The idea is that tools like <a target="_blank" rel="noopener" href="https://cursor.so/">Cursor</a> with Claude Sonnet are getting so good that you can just describe what you want in natural language, hit â€œAccept Allâ€ on whatever the AI spits out, and somehow end up with working software. When things break, you just copy-paste error messages back into the AI and hope it fixes itself.</p>
<p><img src="https://www.reactiongifs.us/wp-content/uploads/2017/01/Debugging-the-code.gif" alt="Debugging struggle"/></p>
<p>Iâ€™ll be honest: Iâ€™ve tried this approach, and Iâ€™m not a fan.</p>
<h3 id="Why-I-use-AI-tools-but-differently"><a href="#Why-I-use-AI-tools-but-differently" title="Why I use AI tools (but differently)"></a>Why I use AI tools (but differently)</h3><p>Donâ€™t get me wrong, I use AI coding tools every day. GitHub Copilotâ€™s autocomplete is genuinely helpful, and Iâ€™ll absolutely ask Claude to help me write regex or debug tricky issues. But thereâ€™s a huge difference between using AI as a smart assistant and letting it drive the entire development process.</p>
<p><img src="https://img.devrant.com/devrant/rant/r_536209_rcy6p.gif" alt="Programming with coffee"/></p>
<h3 id="The-problems-with-pure-vibe-coding"><a href="#The-problems-with-pure-vibe-coding" title="The problems with pure vibe coding"></a>The problems with pure vibe coding</h3><p>Hereâ€™s what bothers me about pure vibe coding:</p>
<p><strong>1. You lose understanding of your own code.</strong> When I write code, even with AI assistance, Iâ€™m thinking about architecture, performance implications, edge cases, and how different components interact. With vibe coding, youâ€™re essentially shipping a black box. Thatâ€™s fine for weekend projects, but terrifying for anything that matters.</p>
<p><img src="https://i.gifer.com/4BJI.gif" alt="Code confusion"/></p>
<p><strong>2. Debugging becomes a nightmare.</strong> When your AI-generated code inevitably breaks in production (and it will), how do you fix it if you donâ€™t understand what itâ€™s doing? Your debugging strategy becomes â€œask the AI to fix it and hope for the best.â€ Thatâ€™s not engineering, thatâ€™s gambling.</p>
<p><img src="https://media.giphy.com/media/QMHoU66sBXqqLqYvGO/giphy.gif" alt="This is fine fire"/></p>
<p><strong>3. You donâ€™t actually learn anything.</strong> Programming is fundamentally about problem-solving and building mental models of how systems work. If youâ€™re always outsourcing that thinking to AI, youâ€™re not developing those skills. Youâ€™re becoming dependent on a tool that might not always be available or might not understand your specific problem.</p>
<h3 id="The-reality-check"><a href="#The-reality-check" title="The reality check"></a>The reality check</h3><p>Iâ€™ve seen some impressive demos of vibe coding, like <a target="_blank" rel="noopener" href="https://x.com/levelsio/status/1901660771505021314">Pieter Levels building games</a> entirely through prompting. But when you look closer, these projects often have <a target="_blank" rel="noopener" href="https://www.reddit.com/r/singularity/comments/1j1tezh/aigenerated_game_exposed_thousands_of_users_to/">obvious security issues</a> or work in very narrow, controlled scenarios.</p>
<p><img src="https://media.tenor.com/h6wJAEQuyxgAAAAM/i-am-not-a-security-threat-security-threat.gif" alt="Security vulnerability detected"/></p>
<p>The reality is that most real software development involves understanding existing codebases, working within constraints, collaborating with teams, and making tradeoffs between competing priorities. These are inherently human problems that require understanding context and exercising judgment.</p>
<h3 id="The-right-way-to-use-AI-coding-tools"><a href="#The-right-way-to-use-AI-coding-tools" title="The right way to use AI coding tools"></a>The right way to use AI coding tools</h3><p>That said, AI coding tools are genuinely transformative when used thoughtfully. The productivity gains from smart autocomplete, code generation for boilerplate, and AI-assisted debugging are real. But thereâ€™s a difference between augmenting your programming with AI and replacing your programming with AI.</p>
<p><img src="https://media.tenor.com/ffxXBrAQw5wAAAAM/robot-attack-saturday-night-live.gif" alt="Robot assistant helping human"/></p>
<p>I think the future is more like what <a target="_blank" rel="noopener" href="https://maximilian-schwarzmueller.com/articles/ai-powered-development-the-good-parts/">Maximilian Schwarzmueller describes</a>: using AI as a copilot, not a pilot. Let it handle the tedious stuff while you focus on the interesting problems of system design, architecture, and understanding user needs.</p>
<h3 id="My-take-Understanding-beats-vibing"><a href="#My-take-Understanding-beats-vibing" title="My take: Understanding beats vibing"></a>My take: Understanding beats vibing</h3><p>Maybe Iâ€™m just old-fashioned, but I believe good software comes from understanding what youâ€™re building and why. Vibe coding might produce working code faster, but I doubt it produces better software or better programmers.</p>
<p><img src="https://media.giphy.com/media/BmmfETghGOPrW/giphy.gif" alt="Thinking programmer"/></p>
<p>The tools will keep getting better, and the line between â€œAI assistanceâ€ and â€œAI replacementâ€ will keep shifting. But for now, Iâ€™d rather understand my code than vibe with it.</p>

  </div></div>
  </body>
</html>
