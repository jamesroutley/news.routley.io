<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cloud.google.com/blog/products/storage-data-transfer/how-the-colossus-stateful-protocol-benefits-rapid-storage">Original</a>
    <h1>Colossus for Rapid Storage</h1>
    
    <div id="readability-page-1" class="page"><div jsname="tx2NYc"><section><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><p><span>As an object storage service, Google </span><a href="https://cloud.google.com/storage"><span>Cloud Storage</span></a><span> is popular for its simplicity and scale, a big part of which is due to the stateless REST protocols that you can use to read and write data. But with the rise of AI and as more customers look to run data-intensive workloads, two major obstacles to using object storage are its higher latency and lack of file-oriented semantics. With the launch of </span><a href="https://cloud.google.com/blog/products/storage-data-transfer/high-performance-storage-innovations-for-ai-hpc"><span>Rapid Storage</span></a><span> on Google Cloud, we’ve added a stateful gRPC-based streaming protocol that provides sub-millisecond read/write latency and the ability to easily append data to an object, while maintaining the high aggregate throughput and scale of object storage. In this post, we’ll share an architectural perspective into how and why we went with this approach, and the new types of workloads it unlocks.</span></p>
<p><span>It all comes back to </span><a href="https://cloud.google.com/blog/products/storage-data-transfer/a-peek-behind-colossus-googles-file-system?e=48754805"><span>Colossus</span></a><span>, Google’s internal zonal cluster-level file system that underpins most (if not all) of our products. As we discussed in a recent blog post, Colossus supports our most demanding performance-focused products with </span><a href="https://cloud.google.com/blog/products/storage-data-transfer/how-colossus-optimizes-data-placement-for-performance"><span>sophisticated SSD placement techniques</span></a><span> that deliver low latency and massive scale. </span></p>
<p><span>Another key ingredient in Colossus’s performance is its stateful protocol — and with Rapid Storage, we’re bringing the power of the Colossus stateful protocol directly to Google Cloud customers. </span></p></span></section><section></section><section><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><p><span>When a Colossus client creates or reads a file, the client first opens the file and gets a </span><span>handle</span><span>, a collection of state that includes all the information about how that file is stored, including which disks the file’s data is stored on. Clients can use this handle when reading or writing to talk directly to the disks via an optimized RDMA-like network protocol, as we previously outlined in our </span><a href="https://research.google/pubs/snap-a-microkernel-approach-to-host-networking/" rel="noopener" target="_blank"><span>Snap networking system paper</span></a><span>.</span></p>
<p><span>Handles can also be used to support ultra-low latency durable appends, which is extremely useful for demanding database and streaming analytics applications. For example, Spanner and Bigtable both write transactions to a log file that requires durable storage and that is on the critical path for database mutations. Similarly, BigQuery supports streaming to a table while massively parallel batch jobs perform computations over recently ingested data. These applications open Colossus files in append mode, and the Colossus client running in the application uses the handle to write their database mutations and table data directly to disks over the network. To ensure the data is stored durably, Colossus replicates its data across several disks, performing writes in parallel and using a quorum technique to avoid waiting on stragglers. </span></p></span></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/1_Colossus_Rapid_Storage_Blog.max-2200x2200.jpg" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/1_Colossus_Rapid_Storage_Blog.max-2200x2200.jpg" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/1_Colossus_Rapid_Storage_Blog.max-2200x2200.jpg" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/1_Colossus_Rapid_Storage_Blog.max-2200x2200.jpg" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><p><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><p>Figure 1: Steps involved in appending data to a file in Colossus.</p></span></p></section></div></section><section><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><p><span>The above image shows the steps that are taken to append data to a file.</span></p>
<ol>
<li>
<p><span>The application opens the file in append mode. The Colossus Curator constructs a handle and sends it to the Colossus Client running in-process, which caches the handle.</span></p>
</li>
<li>
<p><span>The application issues a write call for an arbitrary-sized log entry to the Colossus Client.</span></p>
</li>
<li>
<p><span>The Colossus Client, using the disk addresses in the handle, writes the log entry in parallel to all the disks.</span></p>
</li>
</ol>
<p><span>Rapid Storage builds on Colossus’s stateful protocol, leveraging gRPC-based streaming for the underlying transport. When performing low-latency reads and writes to Rapid Storage objects, the Cloud Storage client establishes a stream, providing the same request parameters used in Cloud Storage’s REST protocols, such as the bucket and object name. Further, all the time-consuming Cloud Storage operations such as user authorization and metadata accesses are front-loaded and performed at stream creation time, so subsequent read and write operations go directly to Colossus without any additional overhead, allowing for appendable writes and repeated ranged reads with sub-millisecond latency.</span></p>
<p><span>This Colossus architecture enables Rapid Storage to support 20 million requests per second in a single bucket — a scale that is extremely useful in a variety of AI/ML applications. For example, when pre-training a model, pre-processed, tokenized training data is fed into GPUs or TPUs, typically in large files that each contain thousands of tokens. But the data is rarely read sequentially, for example, because different random samples are read in different orders as the training progresses. With Rapid Storage’s stateful protocol, a stream can be established at the start of the training run before executing massively parallel ranged-reads at sub-millisecond speeds. This helps to ensure that accelerators aren’t blocked on storage latency.</span></p>
<p><span>Likewise, with appends, Rapid Storage takes advantage of Colossus’s stateful protocol to provide durable writes with sub-millisecond latency, and supports unlimited appends to a single object up to the object size limit.  A major challenge with stateful append protocols is how to handle cases where the client or server hangs or crashes. With Rapid Storage, the client receives a handle from Cloud Storage when creating the stream. If the stream gets interrupted but the client wants to continue reading or appending to the object, the client can re-establish a new stream using this handle, which streamlines this flow and minimizes any latency hiccups. It gets trickier when there is a problem on the client, and the application wants to continue appending to an object from a new client. To simplify this, Rapid Storage guarantees that only one gRPC stream can write to an object at a time; each new stream takes over ownership of the object, transactionally locking out any prior stream. Finally, each append operation includes the offset that’s being written to, ensuring that data correctness is always preserved even in the face of network partitions and replays.</span></p></span></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Colossus_Rapid_Storage_Blog.max-2200x2200.jpg" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Colossus_Rapid_Storage_Blog.max-2200x2200.jpg" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Colossus_Rapid_Storage_Blog.max-2200x2200.jpg" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Colossus_Rapid_Storage_Blog.max-2200x2200.jpg" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><p><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><p>Figure 2: A new client taking over ownership of an object.</p></span></p></section></div></section><section><span jsaction="rcuQ6b:npT2md" jscontroller="YSybTb" data-track-type="" soy-skip="" ssk="5:kbe95"><p><span>In the above image, a new client takes over ownership of an object, locking out the previous owner. </span></p>
<ol>
<li>
<p><span>Initially, client 1 appends data to an object stored on three disks.</span></p>
</li>
<li>
<p><span>The application decides to fail over to client 2, which opens this object in append mode. The Colossus Curator transactionally locks out client 1 by increasing a version number on each object data replica.</span></p>
</li>
<li>
<p><span>Client 1 attempts to append more data to the object, but cannot because its ownership was tied to the old version number.</span></p>
</li>
</ol>
<p><span>To make it as easy as possible to integrate Rapid Storage into your applications, we are also updating our SDKs to support gRPC streaming-based appends and expose a simple application-oriented API. Writing data using handles is a familiar concept in the filesystems world, so we’ve integrated Rapid Storage into </span><a href="https://cloud.google.com/storage/docs/cloud-storage-fuse/overview"><span>Cloud Storage FUSE</span></a><span>, which provides clients with file-like access to Cloud Storage buckets, for low-latency file-oriented workloads. Rapid Storage also natively enables </span><a href="https://cloud.google.com/blog/products/storage-data-transfer/cloud-storage-hierarchical-namespace-improves-aiml-checkpointing?e=13802955"><span>Hierarchical Namespace</span></a><span> as part of its zonal bucket type, providing enhanced performance, consistency, and folder-oriented APIs.</span></p>
<p><span>In short, Rapid Storage combines the sub-millisecond latency of block-like storage, the throughput of a parallel filesystem, and the scalability and ease of use of object storage, and it does all this in large part due to Colossus. Here are some interesting workloads we&#39;ve seen our customers explore during the preview:</span></p>
<ul>
<li>
<p><span>AI/ML data preparation, training, and checkpointing</span></p>
</li>
<li>
<p><span>Distributed database architecture optimization</span></p>
</li>
<li>
<p><span>Batch and streaming analytics processing</span></p>
</li>
<li>
<p><span>Video live-streaming and transcoding</span></p>
</li>
<li>
<p><span>Logging and monitoring</span></p>
</li>
</ul>
<p><span>Interested in trying Rapid Storage? Indicate your interest </span><a href="https://forms.gle/S5kyQGWrcHtduTRN9" rel="noopener" target="_blank"><span>here</span></a><span> or reach out through your Google Cloud representative. </span></p>
<p><span>Visit us at Google Cloud Next and attend the breakout sessions “</span><a href="https://cloud.withgoogle.com/next/25/session-library?session=BRK2-025&amp;utm_source=copylink&amp;utm_medium=unpaidsoc&amp;utm_campaign=FY25-Q2-global-EXP106-physicalevent-er-next25-mc&amp;utm_content=reg-is-live-next-homepage-social-share&amp;utm_term=-" rel="noopener" target="_blank"><span>What’s new with Google Cloud’s Storage</span></a><span>” (BRK2-025), “</span><a href="https://cloud.withgoogle.com/next/25/session-library?session=BRK2-020&amp;utm_source=copylink&amp;utm_medium=unpaidsoc&amp;utm_campaign=FY25-Q2-global-EXP106-physicalevent-er-next25-mc&amp;utm_content=reg-is-live-next-homepage-social-share&amp;utm_term=-" rel="noopener" target="_blank"><span>AI Hypercomputer: Mastering your Storage Infrastructure</span></a><span>” (BRK2-020), and “</span><a href="https://cloud.withgoogle.com/next/25/session-library?session=BRK2-026#all" rel="noopener" target="_blank"><span>Under the Iceberg: Simple, unified Cloud Storage for analytics data lakes</span></a><span>” (BRK2-026) to learn more.</span></p></span></section><section><section><span>Posted in</span><ul><li><a href="https://cloud.google.com/blog/products/storage-data-transfer" track-metadata-position="body" track-metadata-eventdetail="cloud.google.com/blog/products/storage-data-transfer" track-metadata-module="tag list" track-metadata-module_headline="posted in">Storage &amp; Data Transfer</a></li><li><a href="https://cloud.google.com/blog/topics/hpc" track-metadata-position="body" track-metadata-eventdetail="cloud.google.com/blog/topics/hpc" track-metadata-module="tag list" track-metadata-module_headline="posted in">HPC</a></li><li><a href="https://cloud.google.com/blog/products/ai-machine-learning" track-metadata-position="body" track-metadata-eventdetail="cloud.google.com/blog/products/ai-machine-learning" track-metadata-module="tag list" track-metadata-module_headline="posted in">AI &amp; Machine Learning</a></li><li><a href="https://cloud.google.com/blog/topics/google-cloud-next" track-metadata-position="body" track-metadata-eventdetail="cloud.google.com/blog/topics/google-cloud-next" track-metadata-module="tag list" track-metadata-module_headline="posted in">Google Cloud Next</a></li></ul></section></section></div></div>
  </body>
</html>
