<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/leoshimo/vrs">Original</a>
    <h1>Vrs: Personal Software Runtime inspired by Emacs, Plan 9, Erlang, Hypermedia</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto">
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/985d76d44879ae8be5eab864dee264d4ce4f3f7e556b4d7f9746a396041ca210/68747470733a2f2f7261772e6769746875622e636f6d2f6c656f7368696d6f2f7672732f6d61696e2f6173736574732f7672732e706e67"><img width="360" src="https://camo.githubusercontent.com/985d76d44879ae8be5eab864dee264d4ce4f3f7e556b4d7f9746a396041ca210/68747470733a2f2f7261772e6769746875622e636f6d2f6c656f7368696d6f2f7672732f6d61696e2f6173736574732f7672732e706e67" data-canonical-src="https://raw.github.com/leoshimo/vrs/main/assets/vrs.png"/></a>
</p>
<blockquote>
<p dir="auto">In the multiverse, you can live up to your ultimate potential. We discovered a
way to temporarily link your consciousness to another version of yourself,
accessing all of their memories and skills.</p>
<p dir="auto">It&#39;s called verse jumping.</p>
<p dir="auto">‚Äî Alpha Waymond</p>
</blockquote>

<p dir="auto"><a href="https://github.com/leoshimo/vrs">vrs</a> is a personal software runtime - an
opinionated take on my own &#34;endgame&#34; software platform.</p>
<p dir="auto">It considers every aspect of programming - language, execution, environment,
editing, tooling, and more - designing across the end-to-end process of building
software.</p>
<p dir="auto">Its inspirations are Emacs, Erlang, Unix, Plan 9, and Hypermedia systems.  It
hopes to combine powerful ideas from those projects into one cohesive whole for
an empowering, joyful, holistic programming experience.</p>
<p dir="auto">The key principles are: joy, uniformity, simplicity, practicality, and
interactivity.</p>
<p dir="auto">
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b81ef6185c58c2a97ccf665c795f55813e6d6fed9b62043dc649af82c2c89596/68747470733a2f2f7261772e6769746875622e636f6d2f6c656f7368696d6f2f7672732f6d61696e2f6173736574732f7672732d76656e6e2e706e67"><img width="450" src="https://camo.githubusercontent.com/b81ef6185c58c2a97ccf665c795f55813e6d6fed9b62043dc649af82c2c89596/68747470733a2f2f7261772e6769746875622e636f6d2f6c656f7368696d6f2f7672732f6d61696e2f6173736574732f7672732d76656e6e2e706e67" data-canonical-src="https://raw.github.com/leoshimo/vrs/main/assets/vrs-venn.png"/></a>
</p>

<p dir="auto">üöß Under heavy construction
üêâ Here be dragons</p>
<p dir="auto">vrs is a sandbox project, focused on play and experimentation in a pure-fun,
pure-utility environment. While I live-on vrs everyday, the platform is very
volatile in both concepts and implementation.</p>
<p dir="auto"><a href="https://www.youtube.com/watch?v=sCZJblyT_XM&amp;t=310s" rel="nofollow">This software has rough edges</a>. Be warned!</p>

<ul dir="auto">
<li><code>lyric</code>: Embedded Lisp Dialect and Virtual Machine</li>
<li><code>vrsd</code>: A runtime implementation as a system daemon</li>
<li><code>libvrs</code>: The <code>vrs</code> library crate shared by runtime and client implementations</li>
<li><code>vrsctl</code>: A thin CLI client over <code>libvrs</code></li>
<li><code>vrsjmp</code>: A GUI launch bar client</li>
</ul>
<p dir="auto">
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3a38243875da307b7153dff3c15a893e3386ad1bc5c47af096380af5a4df8ff5/68747470733a2f2f7261772e6769746875622e636f6d2f6c656f7368696d6f2f7672732f6d61696e2f6173736574732f7672732d617263682d737461636b2e706e67"><img src="https://camo.githubusercontent.com/3a38243875da307b7153dff3c15a893e3386ad1bc5c47af096380af5a4df8ff5/68747470733a2f2f7261772e6769746875622e636f6d2f6c656f7368696d6f2f7672732f6d61696e2f6173736574732f7672732d617263682d737461636b2e706e67" data-canonical-src="https://raw.github.com/leoshimo/vrs/main/assets/vrs-arch-stack.png"/></a>
</p>
<hr/>


<p dir="auto">The runtime runs software written in Lyric lang:</p>
<div data-snippet-clipboard-copy-content="# Use `def` to define new bindings
# e.g. &#34;hello lyric!&#34; string to symbol `msg`
(def msg &#34;hello lyric!&#34;)

# Update bindings with `set`
(set msg &#34;goodbye lyric!&#34;)

# Basic Primitives - integers, lists, keywords, and more
42                                # integers
:my_keyword                       # keywords start with colon (:)
true                              # booleans are `true` or `false`
(list msg var_number var_keyword) # create new lists with `list` function
&#39;(&#34;a&#34; &#34;b&#34; &#34;c&#34;)                    # quote expression with &#39;

# Function declarationes use `defn`
# Lyric is expression-oriented - last form is returned as value to caller
(defn double (x)
    (+ x x))
    
# Call functions by using bound symbol names within parens, followed by arguments
(double 10) # =&gt; 20

# List Operations
(def l &#39;(1 2 3))
(def first (get l 0))       # get 0th item in `l`
(def last (get l -1))       # get last item in `l`
(contains? l 3)             # check if `l` contains `3`

# Association Lists
(def item &#39;(:title &#34;My Title&#34; :subtitle &#34;My Subtitle&#34;))
(get item :title)      # =&gt; &#34;My Title&#34;
(get item :subtitle)   # =&gt; &#34;My Subtitle&#34;

# Functions (Lambdas) are first class
(defn apply (x fn)
    (fn x))
(apply 41 (lambda (x) (+ x 1)))        # =&gt; 41
(map &#39;(1 2 3) (lambda (x) (+ x x))     # =&gt; &#39;(2, 4, 6)

# Conditionals with `if` - equality with `eq?`
(if (eq? msg &#34;Hello&#34;)
    &#34;msg was hello&#34;
    &#34;msg was not hello&#34;)

# and flip conditions with `not?`
(if (not? false)
    &#34;it was not true&#34;)

# Catch error with `try`. Introspect result with `err?` or `ok?`
(if (err? (try (not_a_function)))
    &#34;failed to call not_a_function&#34;)

# Pattern match with `match`. `_` is a wildcard pattern.
(def result &#39;(:ok &#34;Successful data&#34;))
(match result
    ((:ok msg) msg)
    ((:err err) (:err err))
    (_ &#39;(:err &#34;Unrecognized result&#34;)))

# Destructuring bindings can be used to pattern match against forms:
(def result &#39;(:ok &#34;Success&#34;))
(def (:ok status) result)      # matches :ok, binds status to string &#34;Success&#34;

# As a Lisp, Lyric has `eval` and `read`:
(eval (read &#34;(+ 40 2)&#34;)) # =&gt; 42

# and there are more builtins and symbols in environment, introspectable via `ls_env` and `help`
(ls_env)           # see all symbols defined in environment
(help recv)        # see documentation via `help`"><pre lang="lyric"><code># Use `def` to define new bindings
# e.g. &#34;hello lyric!&#34; string to symbol `msg`
(def msg &#34;hello lyric!&#34;)

# Update bindings with `set`
(set msg &#34;goodbye lyric!&#34;)

# Basic Primitives - integers, lists, keywords, and more
42                                # integers
:my_keyword                       # keywords start with colon (:)
true                              # booleans are `true` or `false`
(list msg var_number var_keyword) # create new lists with `list` function
&#39;(&#34;a&#34; &#34;b&#34; &#34;c&#34;)                    # quote expression with &#39;

# Function declarationes use `defn`
# Lyric is expression-oriented - last form is returned as value to caller
(defn double (x)
    (+ x x))
    
# Call functions by using bound symbol names within parens, followed by arguments
(double 10) # =&gt; 20

# List Operations
(def l &#39;(1 2 3))
(def first (get l 0))       # get 0th item in `l`
(def last (get l -1))       # get last item in `l`
(contains? l 3)             # check if `l` contains `3`

# Association Lists
(def item &#39;(:title &#34;My Title&#34; :subtitle &#34;My Subtitle&#34;))
(get item :title)      # =&gt; &#34;My Title&#34;
(get item :subtitle)   # =&gt; &#34;My Subtitle&#34;

# Functions (Lambdas) are first class
(defn apply (x fn)
    (fn x))
(apply 41 (lambda (x) (+ x 1)))        # =&gt; 41
(map &#39;(1 2 3) (lambda (x) (+ x x))     # =&gt; &#39;(2, 4, 6)

# Conditionals with `if` - equality with `eq?`
(if (eq? msg &#34;Hello&#34;)
    &#34;msg was hello&#34;
    &#34;msg was not hello&#34;)

# and flip conditions with `not?`
(if (not? false)
    &#34;it was not true&#34;)

# Catch error with `try`. Introspect result with `err?` or `ok?`
(if (err? (try (not_a_function)))
    &#34;failed to call not_a_function&#34;)

# Pattern match with `match`. `_` is a wildcard pattern.
(def result &#39;(:ok &#34;Successful data&#34;))
(match result
    ((:ok msg) msg)
    ((:err err) (:err err))
    (_ &#39;(:err &#34;Unrecognized result&#34;)))

# Destructuring bindings can be used to pattern match against forms:
(def result &#39;(:ok &#34;Success&#34;))
(def (:ok status) result)      # matches :ok, binds status to string &#34;Success&#34;

# As a Lisp, Lyric has `eval` and `read`:
(eval (read &#34;(+ 40 2)&#34;)) # =&gt; 42

# and there are more builtins and symbols in environment, introspectable via `ls_env` and `help`
(ls_env)           # see all symbols defined in environment
(help recv)        # see documentation via `help`
</code></pre></div>
<p dir="auto">TODO: Examples for fibers, coroutines, yielding, infinite iterators, macros</p>

<p dir="auto">In VRS, software runs as <em>processes</em> running Lyric lang.</p>
<p dir="auto">These processes are implemented as <a href="https://en.wikipedia.org/wiki/Green_thread" rel="nofollow">green threads</a>,
and are lightweight compared to OS processes. Processes are scheduled on
multiple cores using nonblocking IO.</p>
<p dir="auto">Each process has a single logical thread of execution. CPU-bound and IO-bound
work is transparent at process level, but the runtime schedules work such that a
IO or CPU-bound work do not block cores.</p>
<p dir="auto">While processes are preemptively scheduled, each process can create fibers,
which can be used for cooperative multitasking, coroutines, infinite generators,
etc within a single process.</p>
<p dir="auto">Millions of processes can run on a single machine, without a single process
halting the system altogether.</p>
<p dir="auto">The low cost of processes allows it to serve as a single abstraction to simplify
typical event-based, callback-based, or scheduling idioms used in building
software.</p>
<p dir="auto">For example, annual jobs can be represented as a infinite looping program that
sleeps for a year:</p>
<div data-snippet-clipboard-copy-content="(loop (sleep (duration :years 1))
      (do_a_thing))"><pre lang="lyric"><code>(loop (sleep (duration :years 1))
      (do_a_thing))
</code></pre></div>
<p dir="auto">And user flows can be represented sequentially, without blocking the &#34;main thread&#34;:</p>
<div data-snippet-clipboard-copy-content="(def query (prompt &#34;Enter search term: &#34;)) # block on user response
(def items (search_items query))           # network-bound query
(def selection (select items))             # block on user selection"><pre lang="lyric"><code>(def query (prompt &#34;Enter search term: &#34;)) # block on user response
(def items (search_items query))           # network-bound query
(def selection (select items))             # block on user selection
</code></pre></div>
<p dir="auto">Processes run in isolated environments from one another - symbols bound in one
process cannot be seen by another process.  The only method for communicating
between process is via <em>message passing</em>, covered below.</p>
<div data-snippet-clipboard-copy-content="# See list of running processes in runtime
(ps)

# See this process&#39;s process_id
(self)

# Spawn a new process
(def echo_proc (spawn (lambda ()
    (def (sender msg) (recv))
    (send sender msg))))"><pre lang="lyric"><code># See list of running processes in runtime
(ps)

# See this process&#39;s process_id
(self)

# Spawn a new process
(def echo_proc (spawn (lambda ()
    (def (sender msg) (recv))
    (send sender msg))))
</code></pre></div>

<p dir="auto">Processes are isolated - and communicate through message-passing.</p>
<p dir="auto">Each process has a dedicated mailbox that it can poll to receive messages:</p>
<div data-snippet-clipboard-copy-content="# See messages in mailbox, without blocking or consuming a message
(ls_msgs)

# Poll for new message. This blocks execution until a message is received:
(recv)

# `recv` can poll for messages matching specific patterns
(recv &#39;(:only_poll_for_matching msg))

# A common idiom is a &#34;service loop&#34; - an infinite loop that recv messages and runs some function within the process:
(loop (match (recv)
    ((:event_a ev) (handle_a ev))
    ((:event_b ev) (handle_b ev))
    (_ (error &#34;unexpected message&#34;))))

# Sending messages is done via `(send PID MSG)`.
# Use process id from `(self)`, `(pid PID_NO)`, and `(find_srv SRV_NAME)`
(send (pid 10) :hello)
(send (self) :hello_from_self)

# Message from child back to parent
(def parent_pid (self))
(spawn (lambda ()
    (sleep 10)
    (send parent_pid :hello_from_child)))"><pre lang="lyric"><code># See messages in mailbox, without blocking or consuming a message
(ls_msgs)

# Poll for new message. This blocks execution until a message is received:
(recv)

# `recv` can poll for messages matching specific patterns
(recv &#39;(:only_poll_for_matching msg))

# A common idiom is a &#34;service loop&#34; - an infinite loop that recv messages and runs some function within the process:
(loop (match (recv)
    ((:event_a ev) (handle_a ev))
    ((:event_b ev) (handle_b ev))
    (_ (error &#34;unexpected message&#34;))))

# Sending messages is done via `(send PID MSG)`.
# Use process id from `(self)`, `(pid PID_NO)`, and `(find_srv SRV_NAME)`
(send (pid 10) :hello)
(send (self) :hello_from_self)

# Message from child back to parent
(def parent_pid (self))
(spawn (lambda ()
    (sleep 10)
    (send parent_pid :hello_from_child)))
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Services - Registry, Discovery, Binding</h3><a id="user-content-services---registry-discovery-binding" aria-label="Permalink: Services - Registry, Discovery, Binding" href="#services---registry-discovery-binding"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Services are long-running processes that:</p>
<ul dir="auto">
<li>are discoverable via name in service registry</li>
<li>process messages in mailbox, which may update internal state, and respond to message sender</li>
</ul>
<p dir="auto">Processes (including services) can <em>bind</em> to another service, and communicate over message passing.
There are convenience macros to help define message passing stubs between processes.</p>
<div data-snippet-clipboard-copy-content="# `register` - register a process under name in service registry
(register :echo)

# `ls_srv` - Can list all services running within runtime
(ls_srv)         # =&gt; ((:name :echo :pid &lt;pid XX&gt;))

# `find_srv` - Get PID for registered processes
(find_srv :echo) # =&gt; &lt;pid XX&gt;

# Register has options to overwrite and expose interfaces (as function names)
(defn ping (x) x)
(defn pong (y) y)
(register :service_c :interface &#39;(ping pong) :overwrite)

# `srv` is a macro to:
# - Register process under a identifiable name in registry via `register`
# - Start a service loop (covered under &#34;message passing&#34;)
(defn echo (msg) msg)
(srv :echo :interface &#39;(echo))

# `srv` is blocking - but often it is more convenient to fork into a new service
# `spawn_srv` is a macro to expand into `srv` inside a `spawn` block:
(spawn_srv :echo :interface &#39;(echo))

# `bind_srv` can be used to define matching message-passing stubs within another process to a service process:
(bind_srv :echo)    # defines `(echo msg)` in current process, which messages `:echo` service"><pre lang="lyric"><code># `register` - register a process under name in service registry
(register :echo)

# `ls_srv` - Can list all services running within runtime
(ls_srv)         # =&gt; ((:name :echo :pid &lt;pid XX&gt;))

# `find_srv` - Get PID for registered processes
(find_srv :echo) # =&gt; &lt;pid XX&gt;

# Register has options to overwrite and expose interfaces (as function names)
(defn ping (x) x)
(defn pong (y) y)
(register :service_c :interface &#39;(ping pong) :overwrite)

# `srv` is a macro to:
# - Register process under a identifiable name in registry via `register`
# - Start a service loop (covered under &#34;message passing&#34;)
(defn echo (msg) msg)
(srv :echo :interface &#39;(echo))

# `srv` is blocking - but often it is more convenient to fork into a new service
# `spawn_srv` is a macro to expand into `srv` inside a `spawn` block:
(spawn_srv :echo :interface &#39;(echo))

# `bind_srv` can be used to define matching message-passing stubs within another process to a service process:
(bind_srv :echo)    # defines `(echo msg)` in current process, which messages `:echo` service
</code></pre></div>

<p dir="auto">The runtime has built-in global pubsub mechanism.</p>
<div data-snippet-clipboard-copy-content="# Subscribe to :my_topic
(subscribe :my_topic)

# Publish data to :my_topic
(publish :my_topic &#39;(:hello :world))

# Updates are received via mailbox:
(recv) # =&gt; (:topic_updated :my_topic (:hello :world))"><pre lang="lyric"><code># Subscribe to :my_topic
(subscribe :my_topic)

# Publish data to :my_topic
(publish :my_topic &#39;(:hello :world))

# Updates are received via mailbox:
(recv) # =&gt; (:topic_updated :my_topic (:hello :world))
</code></pre></div>
<hr/>


<div data-snippet-clipboard-copy-content="#!/usr/bin/env vrsctl

# Internal state in process - count
(def count 0)

# Define an interface to increment count and publish over topic
(defn increment (n)
  (set count (+ count n))
  (publish :count count))

# Serve a counter service, with `increment` as exported interface:
(spawn_srv :counter :interface &#39;(increment))"><pre lang="lyric"><code>#!/usr/bin/env vrsctl

# Internal state in process - count
(def count 0)

# Define an interface to increment count and publish over topic
(defn increment (n)
  (set count (+ count n))
  (publish :count count))

# Serve a counter service, with `increment` as exported interface:
(spawn_srv :counter :interface &#39;(increment))
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Example: System Appearance Service</h3><a id="user-content-example-system-appearance-service" aria-label="Permalink: Example: System Appearance Service" href="#example-system-appearance-service"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="#!/usr/bin/env vrsctl
# macOS System Appearance Integration
#

# Get system appearance state
(defn is_darkmode ()
  (def (:ok result) (exec &#34;osascript&#34;
                          &#34;-e&#34; &#34;tell application \&#34;System Events\&#34;&#34;
                          &#34;-e&#34; &#34;tell appearance preferences&#34;
                          &#34;-e&#34; &#34;return dark mode&#34;
                          &#34;-e&#34; &#34;end tell&#34;
                          &#34;-e&#34; &#34;end tell&#34;))
  (eq? result &#34;true&#34;))

# Set system appearance state
(defn set_darkmode (dark)
  (exec &#34;osascript&#34;
        &#34;-e&#34; &#34;on run argv&#34;
        &#34;-e&#34; &#34;tell application \&#34;System Events\&#34;&#34;
        &#34;-e&#34; &#34;tell appearance preferences&#34;
        &#34;-e&#34; (if dark &#34;set dark mode to true&#34; &#34;set dark mode to false&#34;)
        &#34;-e&#34; &#34;end tell&#34;
        &#34;-e&#34; &#34;end tell&#34;
        &#34;-e&#34; &#34;end run&#34;)
  :ok)

# Toggle current state
(defn toggle_darkmode ()
  (set_darkmode (not? (is_darkmode))))

# Fork into service exporting `toggle_darkmode` as service
(spawn_srv :system_appearance :interface &#39;(toggle_darkmode))"><pre lang="lyic"><code>#!/usr/bin/env vrsctl
# macOS System Appearance Integration
#

# Get system appearance state
(defn is_darkmode ()
  (def (:ok result) (exec &#34;osascript&#34;
                          &#34;-e&#34; &#34;tell application \&#34;System Events\&#34;&#34;
                          &#34;-e&#34; &#34;tell appearance preferences&#34;
                          &#34;-e&#34; &#34;return dark mode&#34;
                          &#34;-e&#34; &#34;end tell&#34;
                          &#34;-e&#34; &#34;end tell&#34;))
  (eq? result &#34;true&#34;))

# Set system appearance state
(defn set_darkmode (dark)
  (exec &#34;osascript&#34;
        &#34;-e&#34; &#34;on run argv&#34;
        &#34;-e&#34; &#34;tell application \&#34;System Events\&#34;&#34;
        &#34;-e&#34; &#34;tell appearance preferences&#34;
        &#34;-e&#34; (if dark &#34;set dark mode to true&#34; &#34;set dark mode to false&#34;)
        &#34;-e&#34; &#34;end tell&#34;
        &#34;-e&#34; &#34;end tell&#34;
        &#34;-e&#34; &#34;end run&#34;)
  :ok)

# Toggle current state
(defn toggle_darkmode ()
  (set_darkmode (not? (is_darkmode))))

# Fork into service exporting `toggle_darkmode` as service
(spawn_srv :system_appearance :interface &#39;(toggle_darkmode))
</code></pre></div>
<hr/>

<div dir="auto"><h3 tabindex="-1" dir="auto">REPL-driven workflows via <code>vrsctl</code></h3><a id="user-content-repl-driven-workflows-via-vrsctl" aria-label="Permalink: REPL-driven workflows via vrsctl" href="#repl-driven-workflows-via-vrsctl"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>vrsctl</code> is a CLI client for vrs. When invoked without arguments, it launches into an interactive REPL useful for live programming and debugging:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ vrsctl

# Experiment with lyric:
vrs&gt; (def url &#34;https://github.com/leoshimo/vrs&#34;)
&#34;https://github.com/leoshimo/vrs&#34;
vrs&gt; (open_url url)
(:ok &#34;&#34;)

# Introspect runtime state:
vrs&gt; (ls_srv)
((:name :launcher :pid &lt;pid 28&gt; :interface ((:get_items) (:add_item title cmd)))
 (:name :system_appearance :pid &lt;pid 5&gt; :interface ((:toggle_darkmode))))
 
# Bind and talk to services:
vrs&gt; (bind_srv :launcher)
((:get_items) (:add_item title cmd))
vrs&gt; (add_item &#34;Hello&#34; &#39;(open_url &#34;http://example.com&#34;))
:ok"><pre>$ vrsctl

<span><span>#</span> Experiment with lyric:</span>
vrs<span>&gt;</span> (def url <span><span>&#34;</span>https://github.com/leoshimo/vrs<span>&#34;</span></span>)
<span><span>&#34;</span>https://github.com/leoshimo/vrs<span>&#34;</span></span>
vrs<span>&gt;</span> (open_url url)
(:ok <span><span>&#34;</span><span>&#34;</span></span>)

<span><span>#</span> Introspect runtime state:</span>
vrs<span>&gt;</span> (ls_srv)
<span><span>((</span><span>:</span>name <span>:</span>launcher <span>:</span>pid <span>&lt;</span>pid <span>28</span><span>&gt;</span> <span>:</span>interface ((<span>:</span>get_items) (<span>:</span>add_item title cmd<span>))</span></span>)
 (:name :system_appearance :pid <span>&lt;</span>pid <span>5&gt;</span> :interface <span><span>((</span><span>:</span>toggle_darkmode<span>))</span></span>))
 
<span><span>#</span> Bind and talk to services:</span>
vrs<span>&gt;</span> (bind_srv :launcher)
<span><span>((</span><span>:</span>get_items) (<span>:</span>add_item title cmd<span>))</span></span>
vrs<span>&gt;</span> (add_item <span><span>&#34;</span>Hello<span>&#34;</span></span> <span><span>&#39;</span>(open_url &#34;http://example.com&#34;))</span>
<span>:ok</span></pre></div>
<p dir="auto"><code>vrsctl</code> also offers convenient interfaces and tools to support scripting and
debugging - see <code>vrsctl --help</code> for an overview of available commands.</p>

<p dir="auto">There is an major-mode available for Emacs - <code>lyric-mode</code>.</p>
<p dir="auto">It provides syntax highlighting and bindings useful for bottom-up, interactive,
editor-centric software development.</p>
<p dir="auto">The package is currently not available via package repositories - but is
available in my <a href="https://github.com/leoshimo/dots/blob/527bd86095f7c082e6fd6a7658698c8745c65be0/emacs/.emacs.d/init.org#lyric--vrs">dotfiles repository</a>.</p>
</article></div></div>
  </body>
</html>
