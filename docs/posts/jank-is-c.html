<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jank-lang.org/blog/2025-07-11-jank-is-cpp/">Original</a>
    <h1>jank is C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div><p>If you&#39;ve wondered how much a solo dev can build for seamless C++ interop on a quarter, you&#39;re about to find out. In April, jank was unable to reach into C++ at all. Toward the end of this post, I&#39;ll show some real world examples of what works today. Before that, though, I want to say thank you for the sponsorship this quarter, not only by all of my individual Github sponsors, but also by Clojurists Together. I also want to say thank you to <a href="https://vassil.vassilev.info/">Vassil Vassilev</a> and <a href="https://github.com/lhames">Lang Hames</a> for building the necessary tech in Clang and LLVM for jank to actually do all of this magic. Let&#39;s get into it!</p><h3>Memory management</h3><p>In the past month, I have implemented manual memory management via <code>cpp/new</code> and <code>cpp/delete</code>. This uses jank&#39;s GC allocator (currently bdwgc), rather than <code>malloc</code>, so using <code>cpp/delete</code> isn&#39;t generally needed. However, if <code>cpp/delete</code> is used then memory collection can be eager and more deterministic.</p><p>The implementation has full bdwgc support for destructors as well, so both manual deletion and automatic collection will trigger non-trivial destructors.</p><pre tabindex="0"><code><span><span>(</span><span>let</span><span> [</span><span>i </span><span>(</span><span>cpp/int.</span><span> 500</span><span>)</span></span>
<span><span>      p </span><span>(</span><span>cpp/new</span><span> cpp/int i</span><span>)]</span></span>
<span><span>  (</span><span>assert</span><span> (</span><span>=</span><span> i </span><span>(</span><span>cpp/*</span><span> p</span><span>))))</span></span></code></pre><h3>True and false</h3><p>To avoid any implicit jank object casting, we can now use <code>cpp/true</code> and <code>cpp/false</code>, which are straight up C++ bools. These come in handy when trying to keep the generated IR as lean as possible, compared to using <code>true</code> or <code>false</code> and having jank do automatic conversions from Clojure land into C++ land. Going forward, jank will add support for <code>#cpp</code> reader macros, as an easy way to get C++ literals, similar to <code>#js</code> in ClojureScript and <code>#dart</code> in ClojureDart.</p><h3>Complex type strings</h3><p>It&#39;s possible to represent a lot of possible types using normal Clojure syntax. This month, I also extended that to include pointer types within symbols. For example, <code>cpp/int**</code> will give you a C++ <code>int **</code> type. However, when spaces or commas are required, such as with templates, Clojure&#39;s symbols become too limiting. In those cases, we can now use <code>(cpp/type &#34;std::map&lt;std::string, int&gt;&#34;)</code>. This will evaluate to a type which can be used in type position for <code>cpp/cast</code>, <code>cpp/new</code>, and so on.</p><h3>Complex type constructors</h3><p>With the new complex type syntax, we run into a problem. Clojure uses a <code>.</code> suffix to convey a constructor call, but we don&#39;t want to include a <code>.</code> suffix in <code>cpp/type</code> strings since that&#39;s not valid C++ syntax. To remedy this, jank now treats the <code>.</code> suffix on types to be optional. If you call a type, it&#39;s considered a constructor call. Shout out ClojureDart for doing this first.</p><pre tabindex="0"><code><span><span>(</span><span>let</span><span> [</span><span>l1 </span><span>(</span><span>cpp/long</span><span> 5</span><span>)</span></span>
<span><span>      l2 </span><span>((</span><span>cpp/type</span><span> &#34;long&#34;</span><span>)</span><span> 5</span><span>)]</span></span>
<span><span>  (</span><span>assert</span><span> (</span><span>cpp/==</span><span> l1 l2</span><span>)))</span></span></code></pre><h3>Opaque boxes</h3><p>In the JVM, every class implicitly inherits from <code>Object</code>. This allows Clojure&#39;s data structures to just store <code>Object</code> and not need to worry about all of the possible types which could be used. In the native land, however, every type is standalone by default. Even if you have a base object type in your own code, none of your dependencies will use it. The only way to refer to any type would be a <code>void*</code>. When we do this, though, the type information about that data is <i>lost</i>. It&#39;s up to the developer to correctly add that type information back at a later time, by casting that <code>void*</code> back to some other pointer.</p><p>This month, I built a structure for this, called opaque boxes. The idea is that you can take any raw native pointer and box it into a jank object using <code>cpp/box</code>. From there, that object can be used with jank&#39;s data structures, passed around, compared (by pointer value), etc. When you want to pull it back out, there is a special <code>cpp/unbox</code> form to do so while specifying the type of the data. It&#39;s entirely up to you to do this correctly, as it is in C or C++. Here&#39;s what it looks like, combined with <code>cpp/new</code>, for some pretend C++ k/v store. Note that we don&#39;t need to specify the type to <code>cpp/box</code>, since the compiler already knows the type.</p><pre tabindex="0"><code><span><span>(</span><span>ns</span><span> example.kv</span><span>)</span></span>
<span></span>
<span><span>(</span><span>def</span><span> db </span><span>(</span><span>delay</span><span> (</span><span>cpp/box</span><span> (</span><span>cpp/new</span><span> cpp/my.db</span><span>))))</span></span>
<span></span>
<span><span>(</span><span>defn</span><span> get! </span><span>[</span><span>k</span><span>]</span></span>
<span><span>  (</span><span>let</span><span> [</span><span>db </span><span>(</span><span>cpp/unbox</span><span> cpp/my.db* @db</span><span>)]</span></span>
<span><span>    (</span><span>cpp/.get</span><span> db </span><span>(</span><span>str</span><span> k</span><span>))))</span></span></code></pre><h3>Pre-compiled headers (PCH)</h3><p>Seamless C++ interop with the jank runtime requires Clang to JIT process jank&#39;s C++ headers. This is costly and can affect startup time, so I&#39;ve set up precompilation of those headers. This needs to be done per-machine, so jank will do it after install, when you first run jank. As jank is updated, it will automatically recompile the PCH as needed.</p><h3>Stability</h3><p>A great deal of work has gone into finding ways to break jank&#39;s seamless interop. C++ is such a large language, I have hundreds of interop tests. In the past month, I&#39;ve found various crashes releated to arrays, global pointers, static references, function pointers, variadic C function calls, and both Clang and LLVM-related issues regarding PCHs, IR optimizations, etc. This is an ongoing pursuit, at the bleeding edge of interop tech and jank&#39;s test suite is how I build confidence that the system works well.</p><h2>Static typing</h2><p>As a side note, for anyone who hadn&#39;t considered this yet, every bit of jank&#39;s seamless interop is statically typed. It <em>is</em> C++. There is no runtime reflection, no guess work, and no hints. If the compiler can&#39;t find a member, or a function, or a particular overload, you will get a compiler error. I think that this is an interesting way to start thinking about jank, Clojure, and static types. It also paves the way to start expanding that type info into other parts of the jank program.</p><h2>Interlude</h2><p>Before I show off some practical examples of jank doing C++ things, please consider subscribing to jank&#39;s mailing list. This is going to be the best way to make sure you stay up to date with jank&#39;s releases, jank-related talks, workshops, and so on.</p><h2>Practical examples</h2><p>Now that seamless interop actually <i>works</i>, we can try to do some things we might normally do in C++. The hardest part of this is coming up with good examples which fit well in a blog post!</p><h3>Hello world via streams</h3><p>Basically every C++ developer starts by including <code>iostream</code> and using <code>std::cout</code>. Here, we don&#39;t need to worry about <code>operator &lt;&lt;</code> returning a <code>std::ostream&amp;</code> and that not being convertible to a jank object, since it&#39;s in statement position. If we didn&#39;t have the <code>nil</code> at the end of the function, we&#39;d get a compiler error, since jank would try to automatically box the <code>std::ostream&amp;</code> and would find that there is no way to do it.</p><pre tabindex="0"><code><span><span>(</span><span>cpp/raw</span><span> &#34;#include &lt;iostream&gt;&#34;</span><span>)</span></span>
<span></span>
<span><span>(</span><span>defn</span><span> -main </span><span>[</span><span>&amp; args</span><span>]</span></span>
<span><span>  (</span><span>cpp/&lt;&lt;</span><span> cpp/std.cout </span><span>(</span><span>cpp/cast</span><span> cpp/std.string </span><span>&#34;Hello, world!</span><span>\n</span><span>&#34;</span><span>))</span></span>
<span><span>  nil</span><span>)</span></span></code></pre><p>We don&#39;t yet have the ability to do <code>#cpp &#34;Hello, world\n&#34;</code>, to get a raw C string, but that&#39;s coming soon. That alone will clean up a lot of common string use cases.</p><h3>JSON pretty printer</h3><p>Ok, cranking up the complexity a bit, let&#39;s bring in a third party library. <a href="https://github.com/nlohmann/json">JSON for Modern C++</a> is likely the most popular C++ JSON library there is. It&#39;s header-only, so if we just download the standalone header, we can JIT include it. To turn this into a full program, we can also reach into <code>std::ifstream</code> for file reading. This program will take a JSON file as an argument, parse it, and then output the pretty printed JSON to stdout.</p><pre tabindex="0"><code><span><span>(</span><span>cpp/raw</span><span> &#34;#include &lt;fstream&gt;&#34;</span><span>)</span></span>
<span><span>(</span><span>cpp/raw</span><span> &#34;#include </span><span>\&#34;</span><span>json.hpp</span><span>\&#34;</span><span>&#34;</span><span>)</span></span>
<span></span>
<span><span>(</span><span>defn</span><span> -main </span><span>[</span><span>&amp; args</span><span>]</span></span>
<span><span>  (</span><span>let</span><span> [</span><span>file </span><span>(</span><span>cpp/std.ifstream.</span><span> (</span><span>cpp/cast</span><span> cpp/std.string </span><span>(</span><span>first</span><span> args</span><span>)))</span></span>
<span><span>        json </span><span>(</span><span>cpp/nlohmann.json.parse</span><span> file</span><span>)]</span></span>
<span><span>    (</span><span>println</span><span> (</span><span>cpp/.dump</span><span> json </span><span>2</span><span>))))</span></span></code></pre><p>The thing I love most about this example is how we&#39;re weaving between Clojure and C++ on basically every line. Yet it all just works.</p><h3>FTXUI</h3><p>I&#39;m going to crank things up one more notch, since things are getting fun. Here&#39;s a working program which uses <a href="https://github.com/ArthurSonzogni/FTXUI">ftxui</a> to lay out terminal output using flexbox. However, in the Clojure way, we provide a pure data hiccup interface and the implementation handles the rest. Here, we take advantage of opaque boxing, to move ftxui objects between jank functions, we build up <code>std::vector</code> objects, and we rely on a ton of Clojure goodies to clean it up. So cool!</p><pre tabindex="0"><code><span><span>(</span><span>cpp/raw</span><span> &#34;#include &lt;ftxui/dom/elements.hpp&gt;&#34;</span><span>)</span></span>
<span><span>(</span><span>cpp/raw</span><span> &#34;#include &lt;ftxui/screen/screen.hpp&gt;&#34;</span><span>)</span></span>
<span><span>(</span><span>cpp/raw</span><span> &#34;#include &lt;ftxui/screen/string.hpp&gt;&#34;</span><span>)</span></span>
<span></span>
<span><span>(</span><span>declare</span><span> vbox</span><span>)</span></span>
<span><span>(</span><span>declare</span><span> hbox</span><span>)</span></span>
<span></span>
<span><span>(</span><span>defn</span><span> hiccup-&gt;element </span><span>[</span><span>h</span><span>]</span></span>
<span><span>  (</span><span>case</span><span> (</span><span>first</span><span> h</span><span>)</span></span>
<span><span>    :text</span><span> (</span><span>cpp/box</span><span> (</span><span>-&gt;&gt;</span><span> (</span><span>str</span><span> (</span><span>second</span><span> h</span><span>))</span></span>
<span><span>                        cpp/ftxui.text</span></span>
<span><span>                        (</span><span>cpp/new</span><span> cpp/ftxui.Element</span><span>)))</span></span>
<span><span>    :filler</span><span> (</span><span>cpp/box</span><span> (</span><span>cpp/new</span><span> cpp/ftxui.Element </span><span>(</span><span>cpp/ftxui.filler</span><span>)))</span></span>
<span><span>    :vbox</span><span> (</span><span>apply</span><span> vbox </span><span>(</span><span>rest</span><span> h</span><span>))</span></span>
<span><span>    :hbox</span><span> (</span><span>apply</span><span> hbox </span><span>(</span><span>rest</span><span> h</span><span>))))</span></span>
<span></span>
<span><span>(</span><span>defmacro</span><span> defbox </span><span>[</span><span>name f</span><span>]</span></span>
<span><span>  `(</span><span>defn</span><span> ~name </span><span>[</span><span>&amp; hiccup#</span><span>]</span></span>
<span><span>     (</span><span>let</span><span> [</span><span>elements# </span><span>(</span><span>cpp/ftxui.Elements.</span><span>)]</span></span>
<span><span>       (</span><span>doseq</span><span> [</span><span>h# hiccup#</span><span>]</span></span>
<span><span>         (</span><span>let</span><span> [</span><span>e# </span><span>(</span><span>cpp/*</span><span> (</span><span>cpp/unbox</span><span> cpp/ftxui.Element* </span><span>(</span><span>hiccup-&gt;element</span><span> h#</span><span>)))]</span></span>
<span><span>           (</span><span>cpp/.push_back</span><span> elements# e#</span><span>)))</span></span>
<span><span>       (</span><span>cpp/box</span><span> (</span><span>cpp/new</span><span> cpp/ftxui.Element </span><span>(</span><span>~f</span><span> elements#</span><span>))))))</span></span>
<span><span>(</span><span>defbox</span><span> hbox cpp/ftxui.hbox</span><span>)</span></span>
<span><span>(</span><span>defbox</span><span> vbox cpp/ftxui.vbox</span><span>)</span></span>
<span></span>
<span><span>(</span><span>defn</span><span> render-hiccup </span><span>[</span><span>hiccup</span><span>]</span></span>
<span><span>  (</span><span>let</span><span> [</span><span>document </span><span>(</span><span>-&gt;&gt;</span><span> (</span><span>hiccup-&gt;element</span><span> hiccup</span><span>)</span></span>
<span><span>                      (</span><span>cpp/unbox</span><span> cpp/ftxui.Element*</span><span>)</span></span>
<span><span>                      cpp/*</span><span>)</span></span>
<span><span>        screen </span><span>(</span><span>cpp/ftxui.Screen.Create</span><span> (</span><span>cpp/ftxui.Dimension.Fixed</span><span> 60</span><span>)</span></span>
<span><span>                                        (</span><span>cpp/ftxui.Dimension.Fixed</span><span> 20</span><span>))]</span></span>
<span><span>    (</span><span>cpp/ftxui.Render</span><span> screen document</span><span>)</span></span>
<span><span>    (</span><span>cpp/.Print</span><span> screen</span><span>)</span></span>
<span><span>    (</span><span>println</span><span>)))</span></span>
<span></span>
<span><span>(</span><span>defn</span><span> -main </span><span>[</span><span>&amp; args</span><span>]</span></span>
<span><span>  (</span><span>render-hiccup</span><span> [</span><span>:vbox</span></span>
<span><span>                  [</span><span>:hbox</span></span>
<span><span>                   [</span><span>:text</span><span> &#34;north-west&#34;</span><span>]</span></span>
<span><span>                   [</span><span>:filler</span><span>]</span></span>
<span><span>                   [</span><span>:text</span><span> &#34;north-east&#34;</span><span>]]</span></span>
<span><span>                  [</span><span>:filler</span><span>]</span></span>
<span><span>                  [</span><span>:hbox</span></span>
<span><span>                   [</span><span>:filler</span><span>]</span></span>
<span><span>                   [</span><span>:text</span><span> &#34;center&#34;</span><span>]</span></span>
<span><span>                   [</span><span>:filler</span><span>]]</span></span>
<span><span>                  [</span><span>:filler</span><span>]</span></span>
<span><span>                  [</span><span>:hbox</span></span>
<span><span>                   [</span><span>:text</span><span> &#34;south-west&#34;</span><span>]</span></span>
<span><span>                   [</span><span>:filler</span><span>]</span></span>
<span><span>                   [</span><span>:text</span><span> &#34;south-east&#34;</span><span>]]]))</span></span></code></pre><div><figure><img src="https://jank-lang.org/img/blog/2025-07-11-jank-is-cpp/ftxui.png"/></figure></div><h2>A quick note about Clasp</h2><p>The OG in the C++ Lisp space is <a href="https://github.com/clasp-developers/clasp">Clasp</a>, created by Dr. Christian Schafmeister. Clasp also integrates with LLVM and it uses MPS for a GC. Though jank and Clasp differ greatly, both in that Clasp is Common Lisp and jank is Clojure as well in how they approach C++ interop, they are two bold attempts to bridge two otherwise distant languages. I reached out to Dr. Schafmeister several years ago, when I started on jank, and we discussed C++ and Lisps. His work has been a big inspiration for jank.</p><h3>What&#39;s next?</h3><p>Phew. I&#39;ve accomplished a ton this quarter and I&#39;m extremely pleased with what jank can do now. Still, the work on seamless interop isn&#39;t finished and more work will be needed on it before jank can be released. A big issue is that I didn&#39;t have time to tackle automatic destructor calls for stack allocated C++ objects. I have one of my mentees, <a href="https://github.com/jianlingzhong">Jianling</a>, helping out on the work here, to ensure that we can get it done soon.</p><p>On top of that, the largest issues comes from Clang and LLVM directly. One of the indicators of jank&#39;s seamless interop being unprecedented is the bugs and missing features I&#39;m finding in Clang and LLVM. These are generally quite slow to address, since I&#39;m relying on the volunteer time of the experts in those areas to help me out. jank would not exist without them. There are still cases where some interop code can trigger a crash in Clang and we&#39;ll have to tackle them as they come up. However, one of the best ways to speed this along is more funding, so that I can pay these Clang and LLVM experts for their time. Please consider becoming a <a href="https://github.com/sponsors/jeaye">Github Sponsor</a> <span><i></i></span> to make this more feasible.</p><p>Looking forward to the new quarter, the main focus will be packaging and distribution. I want to make jank easy to build everywhere and even easier to install. On top of that, I need to address all of the small pain points, various bugs, lack of tooling, etc. After packaging and distribution is stabilized, the rest of the year will be spent on bug fixes, tooling, and documentation. After that, we&#39;ll have the alpha launch!</p><h2>Would you like to help out?</h2><ol><li>Join the community on <a href="https://clojurians.slack.com/archives/C03SRH97FDK">Slack</a></li><li>Join the design discussions or pick up a ticket on <a href="https://github.com/jank-lang/jank">GitHub</a></li><li>Considering becoming a <a href="https://github.com/sponsors/jeaye">Sponsor</a> <span><i></i></span></li><li><strong>Better yet, reach out to discuss corporate sponsorship!</strong></li></ol></div></div>
  </body>
</html>
