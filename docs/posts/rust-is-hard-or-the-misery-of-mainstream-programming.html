<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hirrolot.github.io/posts/rust-is-hard-or-the-misery-of-mainstream-programming.html">Original</a>
    <h1>Rust Is Hard, Or: The Misery of Mainstream Programming</h1>
    
    <div id="readability-page-1" class="page">

<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#functions-that-handle-updates-first-try">Functions that
handle updates: First try</a></li>
<li><a href="#second-try-heterogenous-list">Second try: Heterogenous
list</a></li>
<li><a href="#third-try-using-arc">Third try: Using Arc</a></li>
<li><a href="#the-problem-with-rust">The problem with Rust</a></li>
<li><a href="#why-rust-is-so-hard">Why Rust is so hard?</a></li>
<li><a href="#how-things-can-be-different">How things can be
different?</a></li>
<li><a href="#waiting-for-better-future">Waiting for better
future</a></li>
<li><a href="#related-ideas">Related ideas</a></li>
</ul>
</nav>
<div>
<p>
<a href="https://news.ycombinator.com/item?id=31601040">HN</a> · <a href="https://www.reddit.com/r/rust/comments/v3cktw/rust_is_hard_or_the_misery_of_mainstream/">r/rust</a>
· <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/v3clru/rust_is_hard_or_the_misery_of_mainstream/">r/ProgrammingLanguages</a>
</p>
<p><img src="https://www.wildlondon.org.uk/blog/media/rust-is-hard-or-the-misery-of-mainstream-programming/rustaceans-meme.jpeg"/></p>
<p>When you use Rust, it is sometimes outright preposterous how much
knowledge of language, and how much of programming ingenuity and
curiosity you need in order to accomplish the most trivial things. When
you feel particularly desperate, you go to <a href="https://github.com/rust-lang/rust/issues">rust/issues</a> and
search for a solution for your problem. Suddenly, you find an issue with
an explanation that it is theoretically impossible to design your API in
this way, owing to some subtle language bug. The issue is <span><svg style="vertical-align: middle; margin-bottom: 3px;" height="16" viewBox="0 0 16 16" version="1.1" width="16" aria-hidden="true"><path fill="#FFFFFF" d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill="#FFFFFF" fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg>
Open</span> and dated Apr 5, 2017.</p>
<p>I entered Rust four years ago. To this moment, I co-authored <a href="https://github.com/teloxide/teloxide">teloxide</a> and <a href="https://github.com/teloxide/dptree">dptree</a>, wrote several
publications and translated a number of language release announcements.
I also managed to write some production code in Rust, and had a chance
to speak at one online meetup dedicated to Rust. Still, from time to
time I find myself disputing with Rust’s borrow checker and type system
for no practical reason. Yes, I am no longer stupefied by such errors as
<code>cannot return reference to temporary value</code> – over time, I
developed multiple heuristic strategies to cope with lifetimes…</p>
<p>But one recent situation has made me to <em>fail
ignominiously</em>.</p>
</div>
<h2 id="functions-that-handle-updates-first-try">Functions that handle
updates: First try</h2>
<p>We are programming a <del>blazing fast</del> messenger bot to make
people’s lives easier. Using long polling or webhooks, we obtain a
stream of server updates, one-by-one. For all updates, we have a vector
of handlers, each of which accepts a reference to an update and returns
a future resolving to <code>()</code>. <code>Dispatcher</code> owns the
handler vector and on each incoming update, it executes the handlers
sequentially.</p>
<p>Let us try to implement this. We will omit the execution of handlers
and focus only on the <code>push_handler</code> function. First try (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=77fa41ad76bd47211ba3778a7c41d3ae">playground</a>):</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>use</span> <span>futures::future::</span>BoxFuture<span>;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>use</span> <span>std::future::</span><span>Future</span><span>;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span>#[</span>derive<span>(</span><span>Debug</span><span>)]</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span>struct</span> Update<span>;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span>type</span> Handler <span>=</span> <span>Box</span><span>&lt;</span><span>dyn</span> <span>for</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>Fn</span>(<span>&amp;</span><span>&#39;a</span> Update) <span>-&gt;</span> BoxFuture<span>&lt;</span><span>&#39;a</span><span>,</span> ()<span>&gt;</span> <span>+</span> <span>Send</span> <span>+</span> <span>Sync</span><span>&gt;;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span>struct</span> Dispatcher(<span>Vec</span><span>&lt;</span>Handler<span>&gt;</span>)<span>;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span>impl</span> Dispatcher <span>{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> push_handler<span>&lt;</span><span>&#39;a</span><span>,</span> H<span>,</span> Fut<span>&gt;</span>(<span>&amp;</span><span>mut</span> <span>self</span><span>,</span> handler<span>:</span> H)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span>where</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        H<span>:</span> <span>Fn</span>(<span>&amp;</span><span>&#39;a</span> Update) <span>-&gt;</span> Fut <span>+</span> <span>Send</span> <span>+</span> <span>Sync</span> <span>+</span> <span>&#39;a</span><span>,</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        Fut<span>:</span> <span>Future</span><span>&lt;</span>Output <span>=</span> ()<span>&gt;</span> <span>+</span> <span>Send</span> <span>+</span> <span>&#39;a</span><span>,</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span>{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span>self</span><span>.</span><span>0</span><span>.</span>push(<span>Box</span><span>::</span>new(<span>move</span> <span>|</span>upd<span>|</span> <span>Box</span><span>::</span>pin(handler(upd))))<span>;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span>fn</span> main() <span>{</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span>let</span> <span>mut</span> dp <span>=</span> Dispatcher(<span>vec!</span>[])<span>;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    dp<span>.</span>push_handler(<span>|</span>upd<span>|</span> <span>async</span> <span>move</span> <span>{</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span>println!</span>(<span>&#34;{:?}&#34;</span><span>,</span> upd)<span>;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span>}</span>)<span>;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Here we represent each update handler using a dynamically typed
<code>Fn</code> trait restricted by an <a href="https://doc.rust-lang.org/nomicon/hrtb.html">HRTB lifetime</a>
<code>for&lt;&#39;a&gt;</code>, since we want a returning future to depend
on some <code>&#39;a</code> from the <code>&amp;&#39;a Update</code> function
parameter. Later, we define the <code>Dispatcher</code> type holding
<code>Vec&lt;Handler&gt;</code>. Inside <code>push_handler</code>, we
accept a statically typed, generic <code>H</code> returning
<code>Fut</code>; in order to push a value of this type to
<code>self.0</code>, we need to wrap <code>handler</code> into a new
boxed handler and transform the returning future to <a href="https://docs.rs/futures/latest/futures/future/type.BoxFuture.html"><code>BoxFuture</code></a>
from the <code>futures</code> crate using <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.pin"><code>Box::pin</code></a>.
Now let us see if the above solution works:</p>
<pre><code>error[E0312]: lifetime of reference outlives lifetime of borrowed content...
  --&gt; src/main.rs:17:58
   |
17 |         self.0.push(Box::new(move |upd| Box::pin(handler(upd))));
   |                                                          ^^^
   |
note: ...the reference is valid for the lifetime `&#39;a` as defined here...
  --&gt; src/main.rs:12:21
   |
12 |     fn push_handler&lt;&#39;a, H, Fut&gt;(&amp;mut self, handler: H)
   |                     ^^
note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined here
  --&gt; src/main.rs:17:30
   |
17 |         self.0.push(Box::new(move |upd| Box::pin(handler(upd))));
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
<p>Unfortunately, it does not work.</p>
<p>The reason is that <code>push_handler</code> accepts a
<em>concrete</em> lifetime <code>&#39;a</code> that we try to boil down to
an HRTB lifetime <code>for&lt;&#39;a&gt;</code>. By doing so, we try to
prove that <code>for&lt;&#39;a, &#39;b&gt; &#39;a: &#39;b</code> (with <code>&#39;b</code>
being <code>&#39;a</code> from <code>push_handler</code>), which obviously
does not hold.</p>
<p>We can try to approach this differently: instead of the
<code>Fut</code> generic, we can force a user handler to return
<code>BoxFuture</code> bounded by <code>for&lt;&#39;a&gt;</code> (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=241de07a19e739112d57cd8ef8442db2">playground</a>):</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>use</span> <span>futures::future::</span>BoxFuture<span>;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span>#[</span>derive<span>(</span><span>Debug</span><span>)]</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span>struct</span> Update<span>;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span>type</span> Handler <span>=</span> <span>Box</span><span>&lt;</span><span>dyn</span> <span>for</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>Fn</span>(<span>&amp;</span><span>&#39;a</span> Update) <span>-&gt;</span> BoxFuture<span>&lt;</span><span>&#39;a</span><span>,</span> ()<span>&gt;</span> <span>+</span> <span>Send</span> <span>+</span> <span>Sync</span><span>&gt;;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span>struct</span> Dispatcher(<span>Vec</span><span>&lt;</span>Handler<span>&gt;</span>)<span>;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span>impl</span> Dispatcher <span>{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> push_handler<span>&lt;</span>H<span>&gt;</span>(<span>&amp;</span><span>mut</span> <span>self</span><span>,</span> handler<span>:</span> H)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span>where</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        H<span>:</span> <span>for</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>Fn</span>(<span>&amp;</span><span>&#39;a</span> Update) <span>-&gt;</span> BoxFuture<span>&lt;</span><span>&#39;a</span><span>,</span> ()<span>&gt;</span> <span>+</span> <span>Send</span> <span>+</span> <span>Sync</span> <span>+</span> <span>&#39;static</span><span>,</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span>{</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span>self</span><span>.</span><span>0</span><span>.</span>push(<span>Box</span><span>::</span>new(<span>move</span> <span>|</span>upd<span>|</span> <span>Box</span><span>::</span>pin(handler(upd))))<span>;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span>fn</span> main() <span>{</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span>let</span> <span>mut</span> dp <span>=</span> Dispatcher(<span>vec!</span>[])<span>;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    dp<span>.</span>push_handler(<span>|</span>upd<span>|</span> <span>{</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span>Box</span><span>::</span>pin(<span>async</span> <span>move</span> <span>{</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>            <span>println!</span>(<span>&#34;{:?}&#34;</span><span>,</span> upd)<span>;</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span>}</span>)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span>}</span>)<span>;</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>It compiles fine now but the final API is defected: ideally, we do
not want a user to wrap each handler with <code>Box::pin</code>. After
all, this is one of the reasons why <code>push_handler</code> exists: it
transforms a statically typed handler into its functionally equivalent
counterpart in the dynamic type space. But what if we force handlers to
remain static?</p>
<p>We can accomplish it using heterogenous lists.</p>
<h2 id="second-try-heterogenous-list">Second try: Heterogenous list</h2>
<p>A heterogenous list is indeed just a fancy name for a tuple. Thus, we
want something like <code>(H1, H2, H3, ...)</code>, where each
<code>H</code> is a different handler type. But at the same time, the
<code>push_handler</code> and <code>execute</code> operations require us
to be able to iterate on this tuple – a possibility that is missing in
vanilla Rust. It does not mean, though, that we cannot express a similar
thing via some freaky type machinery!</p>
<p>First of all, this is the representation of our heterogenous list (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d311df0efb8136c64b19c9f783e65cd1">playground</a>):</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>struct</span> Dispatcher<span>&lt;</span>H<span>,</span> Tail<span>&gt;</span> <span>{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    handler<span>:</span> H<span>,</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    tail<span>:</span> Tail<span>,</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span>struct</span> DispatcherEnd<span>;</span></span></code></pre></div>
<p>If you think this is a bit senseless, you are not far from true. All
we want is to be able to construct types like
<code>Dispatcher&lt;H1, Dispatcher&lt;H2, Dispatcher&lt;H3, DispatcherEnd&gt;&gt;&gt;</code>,
an equivalent form of the <code>(H1, H2, H3)</code> tuple. With this in
mind, we can now define the <code>push_handler</code> function using
simple type-level induction:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>trait</span> PushHandler<span>&lt;</span>NewH<span>&gt;</span> <span>{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span>type</span> Out<span>;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> push_handler(<span>self</span><span>,</span> handler<span>:</span> NewH) <span>-&gt;</span> <span>Self</span><span>::</span>Out<span>;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span>impl</span><span>&lt;</span>NewH<span>&gt;</span> PushHandler<span>&lt;</span>NewH<span>&gt;</span> <span>for</span> DispatcherEnd <span>{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span>type</span> Out <span>=</span> Dispatcher<span>&lt;</span>NewH<span>,</span> DispatcherEnd<span>&gt;;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> push_handler(<span>self</span><span>,</span> handler<span>:</span> NewH) <span>-&gt;</span> <span>Self</span><span>::</span>Out <span>{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        Dispatcher <span>{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            handler<span>,</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            tail<span>:</span> DispatcherEnd<span>,</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span>}</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span>impl</span><span>&lt;</span>H<span>,</span> Tail<span>,</span> NewH<span>&gt;</span> PushHandler<span>&lt;</span>NewH<span>&gt;</span> <span>for</span> Dispatcher<span>&lt;</span>H<span>,</span> Tail<span>&gt;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span>where</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    Tail<span>:</span> PushHandler<span>&lt;</span>NewH<span>&gt;,</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span>type</span> Out <span>=</span> Dispatcher<span>&lt;</span>H<span>,</span> <span>&lt;</span>Tail <span>as</span> PushHandler<span>&lt;</span>NewH<span>&gt;&gt;</span><span>::</span>Out<span>&gt;;</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> push_handler(<span>self</span><span>,</span> handler<span>:</span> NewH) <span>-&gt;</span> <span>Self</span><span>::</span>Out <span>{</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        Dispatcher <span>{</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            handler<span>:</span> <span>self</span><span>.</span>handler<span>,</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>            tail<span>:</span> <span>self</span><span>.</span>tail<span>.</span>push_handler(handler)<span>,</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        <span>}</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>If you are new to type-level induction, you can think of it as of
regular recursion, but applied to types (traits) instead of values:</p>
<ul>
<li>The <strong>base case</strong> is
<code>impl&lt;NewH&gt; PushHandler&lt;NewH&gt; for DispatcherEnd</code>.
Here we construct a dispatcher with only one handler.</li>
<li>The <strong>step case</strong> is
<code>impl&lt;H, Tail, NewH&gt; PushHandler&lt;NewH&gt; for Dispatcher&lt;H, Tail&gt;</code>.
Here we only propagate our induction to <code>self.tail</code>.</li>
</ul>
<p>We implement <code>execute</code> in the same way:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>trait</span> Execute<span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span>#[</span>must_use<span>]</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> execute(<span>&amp;</span><span>&#39;a</span> <span>self</span><span>,</span> upd<span>:</span> <span>&amp;</span><span>&#39;a</span> Update) <span>-&gt;</span> BoxFuture<span>&lt;</span><span>&#39;a</span><span>,</span> ()<span>&gt;;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> Execute<span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>for</span> DispatcherEnd <span>{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> execute(<span>&amp;</span><span>&#39;a</span> <span>self</span><span>,</span> _upd<span>:</span> <span>&amp;</span><span>&#39;a</span> Update) <span>-&gt;</span> BoxFuture<span>&lt;</span><span>&#39;a</span><span>,</span> ()<span>&gt;</span> <span>{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span>Box</span><span>::</span>pin(<span>async</span> <span>{}</span>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span>impl</span><span>&lt;</span><span>&#39;a</span><span>,</span> H<span>,</span> Fut<span>,</span> Tail<span>&gt;</span> Execute<span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>for</span> Dispatcher<span>&lt;</span>H<span>,</span> Tail<span>&gt;</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span>where</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    H<span>:</span> <span>Fn</span>(<span>&amp;</span><span>&#39;a</span> Update) <span>-&gt;</span> Fut <span>+</span> <span>Send</span> <span>+</span> <span>Sync</span> <span>+</span> <span>&#39;a</span><span>,</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    Fut<span>:</span> <span>Future</span><span>&lt;</span>Output <span>=</span> ()<span>&gt;</span> <span>+</span> <span>Send</span> <span>+</span> <span>&#39;a</span><span>,</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    Tail<span>:</span> Execute<span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>+</span> <span>Send</span> <span>+</span> <span>Sync</span> <span>+</span> <span>&#39;a</span><span>,</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> execute(<span>&amp;</span><span>&#39;a</span> <span>self</span><span>,</span> upd<span>:</span> <span>&amp;</span><span>&#39;a</span> Update) <span>-&gt;</span> BoxFuture<span>&lt;</span><span>&#39;a</span><span>,</span> ()<span>&gt;</span> <span>{</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span>Box</span><span>::</span>pin(<span>async</span> <span>move</span> <span>{</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>            (<span>self</span><span>.</span>handler)(upd)<span>.</span><span>await</span><span>;</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>            <span>self</span><span>.</span>tail<span>.</span>execute(upd)<span>.</span><span>await</span><span>;</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        <span>}</span>)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>But that is not all we need. The final move is to abstract
<code>execute</code> <em>for all</em> lifetimes of updates, since our
implementation of <code>Execute&lt;&#39;a&gt;</code> relies on some concrete
<code>&#39;a</code>, whereas we want our dispatcher to handle updates of
variying lifetimes:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>async</span> <span>fn</span> execute<span>&lt;</span>Dp<span>&gt;</span>(dp<span>:</span> Dp<span>,</span> upd<span>:</span> Update)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span>where</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    Dp<span>:</span> <span>for</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> Execute<span>&lt;</span><span>&#39;a</span><span>&gt;,</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    dp<span>.</span>execute(<span>&amp;</span>upd)<span>.</span><span>await</span><span>;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Fine, now we are ready to test our bizzare solution:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>#[</span><span>tokio::</span>main<span>]</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span>async</span> <span>fn</span> main() <span>{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span>let</span> dp <span>=</span> DispatcherEnd<span>;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span>let</span> dp <span>=</span> dp<span>.</span>push_handler(<span>|</span>upd<span>|</span> <span>async</span> <span>move</span> <span>{</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span>println!</span>(<span>&#34;{:?}&#34;</span><span>,</span> upd)<span>;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span>}</span>)<span>;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    execute(dp<span>,</span> Update)<span>.</span><span>await</span><span>;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>But it does not work either:</p>
<pre><code>error: implementation of `Execute` is not general enough
  --&gt; src/main.rs:83:5
   |
83 |     execute(dp, Update).await;
   |     ^^^^^^^ implementation of `Execute` is not general enough
   |
   = note: `Dispatcher&lt;[closure@src/main.rs:80:30: 82:6], DispatcherEnd&gt;` must implement `Execute&lt;&#39;0&gt;`, for any lifetime `&#39;0`...
   = note: ...but it actually implements `Execute&lt;&#39;1&gt;`, for some specific lifetime `&#39;1`</code></pre>
<p>Still think that programming with borrow checker is easy and
everybody can do it after some practice? Unfortunately, no matter how
much practice you have, you cannot cause the above code to compile. The
reason is this: the closure passed to <code>dp.push_handler</code>
accepts <code>upd</code> of a <em>concrete</em> lifetime
<code>&#39;1</code>, but <code>execute</code> requires <code>Dp</code> to
implement <code>Execute&lt;&#39;0&gt;</code> for <em>any</em> lifetime
<code>&#39;0</code>, due to the HRTB bound introduced in the
<code>where</code> clause. However, if you try your luck with regular
functions, the code will compile:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>#[</span><span>tokio::</span>main<span>]</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span>async</span> <span>fn</span> main() <span>{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span>let</span> dp <span>=</span> DispatcherEnd<span>;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span>async</span> <span>fn</span> dbg_update(upd<span>:</span> <span>&amp;</span>Update) <span>{</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span>println!</span>(<span>&#34;{:?}&#34;</span><span>,</span> upd)<span>;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span>let</span> dp <span>=</span> dp<span>.</span>push_handler(dbg_update)<span>;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    execute(dp<span>,</span> Update)<span>.</span><span>await</span><span>;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>This will print <code>Update</code> to the standard output.</p>
<p>This particular behaviour of borrow checker may seem irrational –
and, in fact, it is; functions and closures differ not only in their
respective traits but also in how they handle lifetimes. While closures
that accept references are bounded by <em>specific</em> lifetimes,
functions such as our <code>dbg_update</code> accept
<code>&amp;&#39;a Update</code> for <em>all</em> lifetimes <code>&#39;a</code>.
This divergence is demonstrated by the following example code (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3ba11772d068d17b428029075308f405">playground</a>):</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>let</span> dbg_update <span>=</span> <span>|</span>upd<span>|</span> <span>{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span>println!</span>(<span>&#34;{:?}&#34;</span><span>,</span> upd)<span>;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span>};</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span>let</span> upd <span>=</span> Update<span>;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    dbg_update(<span>&amp;</span>upd)<span>;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span>let</span> upd <span>=</span> Update<span>;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    dbg_update(<span>&amp;</span>upd)<span>;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Due to calls to <code>dbg_update</code>, we obtain the following
compilation error:</p>
<pre><code>error[E0597]: `upd` does not live long enough
  --&gt; src/main.rs:11:20
   |
11 |         dbg_update(&amp;upd);
   |                    ^^^^ borrowed value does not live long enough
12 |     }
   |     - `upd` dropped here while still borrowed
...
16 |         dbg_update(&amp;upd);
   |         ---------- borrow later used here</code></pre>
<p>This is because the <code>dbg_update</code> closure can handly only
one specific lifetime, whereas the lifetimes of the first and the second
<code>upd</code> are clearly different.</p>
<p>In contrast, <code>dbg_update</code> as a function works perfectly in
this scenario (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6b71d1fde5b00dd361c1e30eab6ea57c">playground</a>):</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>fn</span> dbg_update_fn(upd<span>:</span> <span>&amp;</span>Update) <span>{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span>println!</span>(<span>&#34;{:?}&#34;</span><span>,</span> upd)<span>;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span>let</span> upd <span>=</span> Update<span>;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    dbg_update_fn(<span>&amp;</span>upd)<span>;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span>let</span> upd <span>=</span> Update<span>;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    dbg_update_fn(<span>&amp;</span>upd)<span>;</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>We can even trace the exact signature of this function using the
handy <code>let () = ...;</code> idiom (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=0901c5082bec20168439fdea93cae938">playground</a>):</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>fn</span> dbg_update_fn(upd<span>:</span> <span>&amp;</span>Update) <span>{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span>println!</span>(<span>&#34;{:?}&#34;</span><span>,</span> upd)<span>;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span>let</span> () <span>=</span> dbg_update_fn<span>;</span></span></code></pre></div>
<p>The signature is <code>for&lt;&#39;r&gt; fn(&amp;&#39;r Update)</code>, as
expected:</p>
<pre><code>error[E0308]: mismatched types
 --&gt; src/main.rs:9:9
  |
9 |     let () = dbg_update_fn;
  |         ^^   ------------- this expression has type `for&lt;&#39;r&gt; fn(&amp;&#39;r Update) {dbg_update_fn}`
  |         |
  |         expected fn item, found `()`
  |
  = note: expected fn item `for&lt;&#39;r&gt; fn(&amp;&#39;r Update) {dbg_update_fn}`
           found unit type `()`</code></pre>
<p>That being said, this solution with a heterogenous list is not what
we want either: it is quite flummoxing, boilerplate, hacky, and does not
work with closures at all. Also, I do not recommend going too far with
complex type mechanics in Rust; if you suddenly encounter a type check
failure somewhere near the dispatcher type, I wish you good luck.
Imagine that you are maintaining a production system written in Rust and
you need to fix some critical bug as quickly as possible. You introduce
the necessary changes to your codebase and then see the following
compilation output:</p>
<pre><code>error[E0308]: mismatched types
   --&gt; src/main.rs:123:9
    |
123 |     let () = dp;
    |         ^^   -- this expression has type `Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update0}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update1}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update2}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update3}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update4}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update5}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update6}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update7}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update8}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update9}, DispatcherEnd&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;`
    |         |
    |         expected struct `Dispatcher`, found `()`
    |
    = note: expected struct `Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update0}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update1}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update2}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update3}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update4}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update5}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update6}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update7}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update8}, Dispatcher&lt;for&lt;&#39;_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update9}, DispatcherEnd&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;`
            found unit type `()`</code></pre>
<p>(In a real-world scenario, the above error would probably be <a href="https://www.wildlondon.org.uk/blog/media/rust-is-hard-or-the-misery-of-mainstream-programming/teloxide-error.txt">20x
bigger</a>.)</p>
<h2 id="third-try-using-arc">Third try: Using Arc</h2>
<p><img src="https://www.wildlondon.org.uk/blog/media/rust-is-hard-or-the-misery-of-mainstream-programming/arc-meme.jpeg" width="580px"/></p>
<p>When I was novice in Rust, I used to think that references are
simpler than smart pointers. Now I am using
<code>Rc</code>/<code>Arc</code> almost everywhere where using lifetimes
causes too much pain and performance is not a big deal. Believe or not,
all of the aforementioned problems were caused by that single lifetime
in <code>type Handler</code>, <code>&#39;a</code>.</p>
<p>Let us just replace it with <code>Arc&lt;Update&gt;</code> (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=f2aed7fb232e9fac8743d4986820f3d3">playground</a>):</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>use</span> <span>futures::future::</span>BoxFuture<span>;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span>use</span> <span>std::future::</span><span>Future</span><span>;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span>use</span> <span>std::sync::</span>Arc<span>;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span>#[</span>derive<span>(</span><span>Debug</span><span>)]</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span>struct</span> Update<span>;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span>type</span> Handler <span>=</span> <span>Box</span><span>&lt;</span><span>dyn</span> <span>Fn</span>(Arc<span>&lt;</span>Update<span>&gt;</span>) <span>-&gt;</span> BoxFuture<span>&lt;</span><span>&#39;static</span><span>,</span> ()<span>&gt;</span> <span>+</span> <span>Send</span> <span>+</span> <span>Sync</span><span>&gt;;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span>struct</span> Dispatcher(<span>Vec</span><span>&lt;</span>Handler<span>&gt;</span>)<span>;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span>impl</span> Dispatcher <span>{</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> push_handler<span>&lt;</span>H<span>,</span> Fut<span>&gt;</span>(<span>&amp;</span><span>mut</span> <span>self</span><span>,</span> handler<span>:</span> H)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span>where</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        H<span>:</span> <span>Fn</span>(Arc<span>&lt;</span>Update<span>&gt;</span>) <span>-&gt;</span> Fut <span>+</span> <span>Send</span> <span>+</span> <span>Sync</span> <span>+</span> <span>&#39;static</span><span>,</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>        Fut<span>:</span> <span>Future</span><span>&lt;</span>Output <span>=</span> ()<span>&gt;</span> <span>+</span> <span>Send</span> <span>+</span> <span>&#39;static</span><span>,</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span>{</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>        <span>self</span><span>.</span><span>0</span><span>.</span>push(<span>Box</span><span>::</span>new(<span>move</span> <span>|</span>upd<span>|</span> <span>Box</span><span>::</span>pin(handler(upd))))<span>;</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a><span>fn</span> main() <span>{</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    <span>let</span> <span>mut</span> dp <span>=</span> Dispatcher(<span>vec!</span>[])<span>;</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    dp<span>.</span>push_handler(<span>|</span>upd<span>|</span> <span>async</span> <span>move</span> <span>{</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>        <span>println!</span>(<span>&#34;{:?}&#34;</span><span>,</span> upd)<span>;</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    <span>}</span>)<span>;</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Hell yeah, it compiles! We even do not need to manually specify
<code>Arc&lt;Update&gt;</code> in each closure – type inference will do
the dirty work for us.</p>
<h2 id="the-problem-with-rust">The problem with Rust</h2>
<p>“Fearless concurrency” – a formally correct but nonetheless
misleading statement. Yes, you no longer have <em>fear</em> of data
races, but you have <strong>PAIN</strong>, much pain.</p>
<p>Let me elaborate. In the previous sections, I have not even loaded
you with all the peculiarities and inadequacies of Rust that affected
the final solution – but there were plenty of them. First of all, notice
the heavy use of boxed futures: <em>all</em> of the aforementioned
<code>BoxFuture</code> types, as well as the corresponding
<code>Box::new</code> and <code>Box::pin</code> twiddling, were
irreplaceable by generics. If you know at least a little bit of Rust,
you know that <code>Vec</code> can only contain fixed-sized types, so
the occurrence of <code>BoxFuture</code> inside
<code>type Handler</code> makes sense; however, using
<code>BoxFuture</code> instead of an <code>async</code> function
signature in the <code>Execute</code> trait is not that apparent.</p>
<p>The awesome essay <em>“<a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">Why
async fn in traits are hard</a>”</em> by <a href="https://github.com/nikomatsakis">Niko Matsakis</a> explains why.
In short, at the moment of writing this blog post, it is impossible to
define <code>async fn</code> functions in traits; instead you should use
some type erasure alternative like the <a href="https://lib.rs/crates/async-trait"><code>async-trait</code></a>
crate or boxing futures manually, as in our examples. In fact,
<code>async-trait</code> performs quite a similar thing, but honestly I
avoid using it because it mangles compile-time errors with procedural
macros. The technique of returning <code>BoxFuture</code> also has
disadvantages – one of them is that you need not forget to specify
<code>#[must_use]</code> for <em>each</em> <code>async fn</code>,
otherwise the compiler would not warn you if you call
<code>execute</code> without <code>.await</code>ing it <a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>. In
essence, boxing static entities is so common that the
<code>futures</code> crate exposes other dynamic variants of common
traits, including <a href="https://docs.rs/futures/latest/futures/stream/type.BoxStream.html"><code>BoxStream</code></a>,
<a href="https://docs.rs/futures/latest/futures/future/type.LocalBoxFuture.html"><code>LocalBoxFuture</code></a>,
and <a href="https://docs.rs/futures/latest/futures/prelude/stream/type.LocalBoxStream.html"><code>LocalBoxStream</code></a>
(the last two come without the <code>Send</code> requirement).</p>
<p>Secondly, explicit type annotation for <code>upd</code> breaks
everything (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3b17c3a2e3f0eab0725f5762c49b1eb4">playground</a>):</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>use</span> tokio<span>;</span> <span>// 1.18.2</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span>#[</span>derive<span>(</span><span>Debug</span><span>)]</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span>struct</span> Update<span>;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span>#[</span><span>tokio::</span>main<span>]</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span>async</span> <span>fn</span> main() <span>{</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span>let</span> closure <span>=</span> <span>|</span>upd<span>:</span> <span>&amp;</span>Update<span>|</span> <span>async</span> <span>move</span> <span>{</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        <span>println!</span>(<span>&#34;{:?}&#34;</span><span>,</span> upd)<span>;</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span>};</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    closure(<span>&amp;</span>Update)<span>.</span><span>await</span><span>;</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Compiler output:</p>
<pre><code>error: lifetime may not live long enough
  --&gt; src/main.rs:8:34
   |
8  |       let closure = |upd: &amp;Update| async move {
   |  _________________________-______-_^
   | |                         |      |
   | |                         |      return type of closure `impl Future&lt;Output = ()&gt;` contains a lifetime `&#39;2`
   | |                         let&#39;s call the lifetime of this reference `&#39;1`
9  | |         println!(&#34;{:?}&#34;, upd);
10 | |     };
   | |_____^ returning this value requires that `&#39;1` must outlive `&#39;2`</code></pre>
<p>(Try to remove the type annotation <code>: &amp;Update</code> and the
compilation will succeed.)</p>
<p>If you have no idea what this error means, you are not alone – see <a href="https://github.com/rust-lang/rust/issues/70791">issue #70791</a>.
Looking at the list of issue labels reveals <code>C-Bug</code>, which
classifies the issue as a compiler bug. At the moment of writing this
post, rustc has <a href="https://web.archive.org/save/https://github.com/rust-lang/rust/labels/C-bug">3,107
open <code>C-bug</code> issues</a> and <a href="https://web.archive.org/web/20220601185940/https://github.com/rust-lang/rust/issues?q=is%3Aopen+label%3AC-bug+label%3AA-lifetimes">114
open <code>C-bug</code>+<code>A-lifetimes</code> issues</a>. Remember
that <code>async fn</code> worked for us but an equivalent closure did
not? – this is also a compiler bug, see <a href="https://github.com/rust-lang/rust/issues/70263">issue #70263</a>.
There are also many language-related issues dated earlier than 2020, see
<a href="https://github.com/rust-lang/rust/issues/41078">issue
#41078</a> and <a href="https://github.com/rust-lang/rust/issues/42940">issue
#42940</a>.</p>
<p>You see how our simple task of registering handlers has seamlessly
transcended into wandering in rustc issues with the hope to somehow
circumvent the language. Designing interfaces in Rust is like walking
through a minefield: in order to succeed, you need to balance on your
ideal interface and what features are available to you. Yes, I hear you.
No, it is not like in all other languages. When you program in some
stable production language (not Rust), you can typically foresee how
your imaginary interface would fit with language semantics; but when you
program in Rust, the process of designing APIs is affected by numerous
arbitrary language limitations like those we have seen so far. You
expect that borrow checker will validate your references and type system
will help you to deal with program entities, but you end up throwing
<code>Box</code>, <code>Pin</code>, and <code>Arc</code> here and there
and fighting with type system inexpressiveness.</p>
<p>To finish the section, this is the full implementation in Golang:</p>
<p>
<code>dispatcher.go</code>
</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span>package</span> main</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>&#34;fmt&#34;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span>type</span> Update <span>struct</span><span>{}</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span>type</span> Handler <span>func</span><span>(*</span>Update<span>)</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span>type</span> Dispatcher <span>struct</span> <span>{</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    handlers <span>[]</span>Handler</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>dp <span>*</span>Dispatcher<span>)</span> pushHandler<span>(</span>handler Handler<span>)</span> <span>{</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    dp<span>.</span>handlers <span>=</span> <span>append</span><span>(</span>dp<span>.</span>handlers<span>,</span> handler<span>)</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span>func</span> main<span>()</span> <span>{</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    dp <span>:=</span> Dispatcher<span>{</span>handlers<span>:</span> <span>nil</span><span>}</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    dp<span>.</span>pushHandler<span>(</span><span>func</span><span>(</span>upd <span>*</span>Update<span>)</span> <span>{</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>        fmt<span>.</span>Println<span>(</span>upd<span>)</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    <span>})</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<h2 id="why-rust-is-so-hard">Why Rust is so hard?</h2>
<p>Sometimes it is helpful to understand why shit happens. “Because X is
bad” is not an answer; “Because people that made X are bad” is not an
explanation either.</p>
<p>So why Rust is so hard?</p>
<p><strong>Rust is a systems language.</strong> To be a systems PL, it
is very important not to hide underlying computer memory management from
a programmer. For this reason, Rust pushes programmers to expose many
details that would be otherwise hidden in more high-level languages.
Examples: pointers, references and associated stuff, memory allocators,
different string types, <a href="https://en.wikipedia.org/wiki/Funarg_problem">different
<code>Fn</code> traits</a>, <a href="https://doc.rust-lang.org/std/pin/index.html"><code>std::pin</code></a>,
et cetera.</p>
<p><strong>Rust is a static language.</strong> This is better explained
in my previous essay <em>“<a href="https://www.wildlondon.org.uk/blog/guest-author/why-static-languages-suffer-from-complexity.html">Why Static
Languages Suffer From Complexity</a>”</em>. To restate, languages with
static type systems (or equivalent functionality) tend to duplicate
their features on their <em>static</em> and <em>dynamic</em> levels,
thereby introducing <em>statics-dynamics biformity</em>. Transforming a
static abstraction into its dynamic counterpart is called
<em>upcasting</em>; the inverse process is called <em>downcasting</em>.
Inside <code>push_handler</code>, we have used upcasting to turn a
static handler into the dynamic <code>Handler</code> type to be pushed
to the final vector.</p>
<p>In addition, Rust is committed to making all these things intuitive
and memory safe. This kick-ass combination stresses the <a href="http://www.ats-lang.org/">human bounds</a> of computer language
design. From now it should be completely understandable why Rust feels
like a full of holes from time to time; in fact, it is almost a miracle
that it is functioning at all. A computer language is like a system of
tightly intertwined components: every time you introduce a new
linguistic abstraction, you have to make sure that it plays well with
the rest of the system to avoid bugs and inconsistencies. Perhaps we
should grant free health insurance or other life benefits to those who
develop such languages on full-time.</p>
<h2 id="how-things-can-be-different">How things can be different?</h2>
<p>Now imagine that <strong>all of Rust’s issues dissapear</strong>.
Also, whole rustc and std are formally verified. It would be also fairly
nice to have a complete language specification with multiple tier-1
implementations, the same support for hardware platforms as of GCC,
stable ABI (though it is unclear how to deal with generics), and similar
stuff. That would probably be an ideal language for systems
programming.</p>
<p>Or imagine that <strong>Rust’s issues dissapear and it is now
completely high-level</strong>. That would kick the shit out of all
mainstream programming languages. Rust has adequate defaults, it
supports polymorphism, it has a very convenient package manager. I will
not enumerate here all the faults of mainstream PLs: cursed JavaScript
semantics, enterprise monstrosity of Java, <code>NULL</code> pointer
problems in C, uncontrollable UB of C++, numerous ways of doing the same
job in C#, et cetera. The modern programming language scene is rather a
freak show. Yet, you see, even with all of these drawbacks, people write
working software, while Rust (in its current state) is far from being
the most used PL. Moreover, my prediction is that Rust will never be as
popular as Java or Python. The reason is more social than technical: due
to the innate complexity of the language, there will always be fewer
professional software engineers in Rust than in Java or Python; to make
matters even worse, they will require higher salaries, mind you. As an
employer, you will have much more trouble finding good Rustaceans for
your business.</p>
<p>Finally, imagine that <strong>Rust’s issues dissapear, it is
high-level, and has uniform feature set.</strong> That would presumably
be close to the theoretical ideal of a high-level, general-purpose
programming language for the masses. Funnily enough, designing such a
language might turn out to be a less intimidating task than original
Rust, since we can hide all low-level details under an impenetrable
shell of a language runtime.</p>
<h2 id="waiting-for-better-future">Waiting for better future</h2>
<p>So if I “figured out it all”, why should not I develop a sublime
version of Rust? I do not want to spend my next twenty years trying to
do so, given that the chance that my language will stand out is
infinitely small. I think the current set of most used production
languages is pretty random to some extent – we can always say why a
specific language got popular, but generally we cannot explain why
better alternatives sunk into oblivion. Backing from a big corporation?
Accidentally targeting an IT trend of the future? Again, the reasons are
rather social. Harsh reality: in life, sometimes hope plays a much more
vital role than all of your skills and self-dedication.</p>
<p>If you still want to create a PL of the future, I wish you good luck
and strong mental health. You are endlessly courageous and hopelessly
romantic.</p>
<p><img src="https://www.wildlondon.org.uk/blog/media/rust-is-hard-or-the-misery-of-mainstream-programming/sad-keanu.jpeg"/></p>

<ul>
<li><em>“<a href="https://arxiv.org/pdf/2110.01098.pdf">Garbage
Collection Makes Rust Easier to Use: A Randomized Controlled Trial of
the Bronze Garbage Collector</a>”</em></li>
<li><em>“<a href="https://boats.gitlab.io/blog/post/shifgrethor-i/">Shifgrethor I:
Garbage collection as a Rust library</a>”</em></li>
</ul>
<p>Feel free to contact me if you wish to extend this list.</p>




</div>
  </body>
</html>
