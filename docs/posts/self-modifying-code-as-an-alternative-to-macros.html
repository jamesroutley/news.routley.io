<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io//2022/03/26/self-modifying-code.html">Original</a>
    <h1>Self Modifying Code as an alternative to macros</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
  
  <p>Mar 26, 2022</p>
  <div id="preamble">
<div>
<p>This post has nothing to do with JIT-like techniques for patching machine code on the fly (though they are cool!).
Instead, it describes a cute/horrible trick/hack you can use to generate <em>source</em> code if you are not a huge fan of macros.
The final technique is going to be independent of any particular programming language, but the lead-up is going to be Rust-specific.
The pattern can be applied to a wide variety of tasks, but we’ll use a model problem to study different solutions.</p>
</div>
</div>
<div>
<h2 id="problem"><a href="#problem"></a>Problem</h2>
<div>
<p>I have a field-less enum representing various error conditions:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>#[derive(Debug,</span> <span>Clone,</span> <span>Copy)]</span>
<span>pub</span> <span>enum</span> <span>Error</span> <span>{</span>
  <span>InvalidSignature</span><span>,</span>
  <span>AccountNotFound</span><span>,</span>
  <span>InsufficientBalance</span><span>,</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>This is a type I expect to change fairly often.
I predict that it will grow a lot.
Even the initial version contains half a dozen variants already!
For brevity, I am showing only a subset here.</p>
<p>For the purposes of serialization, I would like to convert this error to and from an error code.
One direction is easy, there’s built in mechanism for this in Rust:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>impl</span> <span>Error</span> <span>{</span>
  <span>pub</span> <span>fn</span> <span>as_code</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>u32</span> <span>{</span>
    <span>self</span> <span>as</span> <span>u32</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>The other direction is more annoying: it isn’t handled by the language automatically yet (although there’s an in-progress PR which adds just that!), so we have to write some code ourselves:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td><pre><span>impl</span> <span>Error</span> <span>{</span>
  <span>pub</span> <span>fn</span> <span>as_code</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>u32</span> <span>{</span>
    <span>self</span> <span>as</span> <span>u32</span>
  <span>}</span>

  <span>pub</span> <span>fn</span> <span>from_code</span><span>(</span><span>code</span><span>:</span> <span>u32</span><span>)</span> <span>-&gt;</span> <span>Option</span><span>&lt;</span><span>Error</span><span>&gt;</span> <span>{</span>
    <span>let</span> <span>res</span> <span>=</span> <span>match</span> <span>code</span> <span>{</span>
      <span>0</span> <span>=&gt;</span> <span>Error</span><span>::</span><span>InvalidSignature</span><span>,</span>
      <span>1</span> <span>=&gt;</span> <span>Error</span><span>::</span><span>AccountNotFound</span><span>,</span>
      <span>2</span> <span>=&gt;</span> <span>Error</span><span>::</span><span>InsufficientBalance</span><span>,</span>
      <span>_</span> <span>=&gt;</span> <span>return</span> <span>None</span><span>,</span>
    <span>};</span>
    <span>Some</span><span>(</span><span>res</span><span>)</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Now, given that I expect this type to change frequently, this is asking for trouble!
It’s very easy for the <code>match</code> and the enum definition to get out of sync!</p>
<p>What should we do? What <em>can</em> we do?</p>
</div>
</div>
<div>
<h2 id="minimalist-solution"><a href="#minimalist-solution"></a>Minimalist Solution</h2>
<div>
<p>Now, seasoned Rust developers are probably already thinking about macros (or maybe even about specific macro crates).
And we’ll get there!
But first, let’s see how I usually solve the problem, when (as I am by default) I am not keen on adding macros.</p>
<p>The idea is to trick the compiler into telling us the number of elements in the enum, which would allow us to implement some sanity checking.
We can do this by adding a fake element at the end of the enum:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td><pre><span>#[derive(Debug,</span> <span>Clone,</span> <span>Copy,</span> <span>PartialEq,</span> <span>Eq)]</span>
<span>pub</span> <span>enum</span> <span>Error</span> <span>{</span>
  <span>InvalidSignature</span><span>,</span>
  <span>AccountNotFound</span><span>,</span>
  <span>InsufficientBalance</span><span>,</span>
  <span>__</span><span>LAST</span><span>,</span>
<span>}</span>

<span>impl</span> <span>Error</span> <span>{</span>
  <span>const</span> <span>ALL</span><span>:</span> <span>[</span><span>Error</span><span>;</span> <span>Error</span><span>::</span><span>__</span><span>LAST</span> <span>as</span> <span>usize</span><span>]</span> <span>=</span> <span>[</span>
    <span>Error</span><span>::</span><span>InvalidSignature</span><span>,</span>
    <span>Error</span><span>::</span><span>AccountNotFound</span><span>,</span>
    <span>Error</span><span>::</span><span>InsufficientBalance</span><span>,</span>
  <span>];</span>

  <span>pub</span> <span>fn</span> <span>from_code</span><span>(</span><span>code</span><span>:</span> <span>u32</span><span>)</span> <span>-&gt;</span> <span>Option</span><span>&lt;</span><span>Error</span><span>&gt;</span> <span>{</span>
    <span>Error</span><span>::</span><span>ALL</span><span>.get</span><span>(</span><span>code</span> <span>as</span> <span>usize</span><span>)</span><span>.copied</span><span>()</span>
  <span>}</span>
  <span>pub</span> <span>fn</span> <span>as_code</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>u32</span> <span>{</span>
    <span>Error</span><span>::</span><span>ALL</span>
      <span>.into_iter</span><span>()</span>
      <span>.position</span><span>(|</span><span>it</span><span>|</span> <span>it</span> <span>==</span> <span>self</span><span>)</span>
      <span>.unwrap_or_default</span><span>()</span> <span>as</span> <span>u32</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Now, if we add a new error variant, but forget to update the <code>ALL</code> array, the code will fail to compile — exactly the reminder we need.
The major drawback here is that <code>__LAST</code> variant has to exist.
This is fine for internal stuff, but something not really great for a public, clean API.</p>
</div>
</div>
<div>
<h2 id="minimalist-macro"><a href="#minimalist-macro"></a>Minimalist Macro</h2>
<div>
<p>Now, let’s get to macros, and let’s start with the simplest possible one I can think of!</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td><pre><span>define_error!</span><span>[</span>
  <span>InvalidSignature</span><span>,</span>
  <span>AccountNotFound</span><span>,</span>
  <span>InsufficientBalance</span><span>,</span>
<span>];</span>

<span>impl</span> <span>Error</span> <span>{</span>
  <span>pub</span> <span>fn</span> <span>as_code</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>u32</span> <span>{</span>
    <span>self</span> <span>as</span> <span>u32</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Pretty simple, heh? Let’s look at the definition of <code>define_error!</code> though:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
</pre></td><td><pre><span>macro_rules!</span> <span>define_error</span> <span>{</span>
  <span>(</span><span>$</span><span>(</span><span>$err:ident</span><span>,)</span><span>*</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>#[derive(Debug,</span> <span>Clone,</span> <span>Copy,</span> <span>PartialEq,</span> <span>Eq)]</span>
    <span>pub</span> <span>enum</span> <span>Error</span> <span>{</span>
      <span>$</span><span>(</span><span>$err</span><span>,)</span><span>*</span>
    <span>}</span>

    <span>impl</span> <span>Error</span> <span>{</span>
      <span>pub</span> <span>fn</span> <span>from_code</span><span>(</span><span>code</span><span>:</span> <span>u32</span><span>)</span> <span>-&gt;</span> <span>Option</span><span>&lt;</span><span>Error</span><span>&gt;</span> <span>{</span>
        <span>#![allow(non_upper_case_globals)]</span>
        <span>$</span><span>(</span><span>const</span> <span>$err</span><span>:</span> <span>u32</span> <span>=</span> <span>Error</span><span>::</span><span>$err</span> <span>as</span> <span>u32</span><span>;)</span><span>*</span>
        <span>match</span> <span>code</span> <span>{</span>
          <span>$</span><span>(</span><span>$err</span> <span>=&gt;</span> <span>Some</span><span>(</span><span>Error</span><span>::</span><span>$err</span><span>),)</span><span>*</span>
          <span>_</span> <span>=&gt;</span> <span>None</span><span>,</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>};</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>That’s …​ quite literally a puzzle!
Declarative macro machinery is comparatively inexpressive, so you need to get creative to get what you want.
Here, ideally I’d write</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>match</span> <span>code</span> <span>{</span>
  <span>0</span> <span>=&gt;</span> <span>Error</span><span>::</span><span>InvalidSignature</span><span>,</span>
  <span>1</span> <span>=&gt;</span> <span>Error</span><span>::</span><span>AccountNotFound</span><span>,</span>
  <span>2</span> <span>=&gt;</span> <span>Error</span><span>::</span><span>InsufficientBalance</span><span>,</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Alas, counting in macro by example is possible, but not trivial.
It’s a subpuzle!
Rather than solving it, I use the following work-around:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>const</span> <span>InvalidSignature</span><span>:</span> <span>u32</span> <span>=</span> <span>Error</span><span>::</span><span>InvalidSignature</span> <span>as</span> <span>u32</span><span>;</span>
<span>match</span> <span>{</span>
  <span>InvalidSignature</span> <span>=&gt;</span> <span>Error</span><span>::</span><span>InvalidSignature</span><span>,</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>And then I have to <code>#![allow(non_upper_case_globals)]</code>, to prevent the compiler from complaining.</p>
</div>
</div>
<div>
<h2 id="idiomatic-macro"><a href="#idiomatic-macro"></a>Idiomatic Macro</h2>
<div>
<p>The big problem with macro is that it’s not only the internal implementation which is baroque!
The call-site is pretty inscrutable as well!
Let’s imagine we are new to a codebase, and come across the following snippet:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td><pre><span>define_error!</span><span>[</span>
  <span>InvalidSignature</span><span>,</span>
  <span>AccountNotFound</span><span>,</span>
  <span>InsufficientBalance</span><span>,</span>
<span>];</span>

<span>impl</span> <span>Error</span> <span>{</span>
  <span>pub</span> <span>fn</span> <span>as_code</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>u32</span> <span>{</span>
    <span>self</span> <span>as</span> <span>u32</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>The question I would ask here would be “what’s that <code>Error</code> thing is?”.
Luckily, we live in the age of powerful IDEs, so we can just “goto definition” to answer that, right?</p>
<div>
<p><img src="https://matklad.github.io/assets/gotodef-macro-1.gif" alt="gotodef macro 1"/>
</p>
</div>
<p>Well, not really.
An IDE says that the <code>Error</code> token is produced by <em>something</em> inside that macro invocation.
That’s a correct answer, if not the most useful one!
So I have to read the definition of the <code>define_error</code> macro and understand how that works internally to get the idea about public API available externally (e.g., that the <code>Error</code> refers to a public enum).
And here the puzzler nature of declarative macros is exacerbated.
It’s hard enough to figure out how to express the idea you want using the restricted language of macros.
It’s doubly hard to understand the idea the macro’s <em>author</em> had when you can’t peek inside their brain and observer only to the implementation of the macro.</p>
<p>One remedy here is to make macro input look more like the code we want to produce.
Something like this:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
</pre></td><td><pre><span>define_error!</span><span>[</span>
  <span>#[derive(Debug,</span> <span>Clone,</span> <span>Copy,</span> <span>PartialEq,</span> <span>Eq)]</span>
  <span>pub</span> <span>enum</span> <span>Error</span> <span>{</span>
    <span>InvalidSignature</span><span>,</span>
    <span>AccountNotFound</span><span>,</span>
    <span>InsufficientBalance</span><span>,</span>
  <span>}</span>
<span>];</span>

<span>impl</span> <span>Error</span> <span>{</span>
  <span>pub</span> <span>fn</span> <span>as_code</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>u32</span> <span>{</span>
    <span>self</span> <span>as</span> <span>u32</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>This indeed is marginally friendlier for IDEs and people to make sense of:</p>
<div>
<p><img src="https://matklad.github.io/assets/gotodef-macro-2.gif" alt="gotodef macro 2"/>
</p>
</div>
<p>The cost for this is a more complicated macro implementation.
Generally, a macro needs to do two things: parse arbitrary token stream input, and emit valid Rust code as output.
Parsing is usually the more complicated task.
That’s why in our minimal attempt we used maximally simple syntax, just a list of identifiers.
However, if we want to make the input of the macro look more like Rust, we have to parse a subset of Rust, and that’s more involved:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td><pre><span>macro_rules!</span> <span>define_error</span> <span>{</span>
  <span>(</span>
    <span>$</span><span>(</span><span>#[</span><span>$</span><span>meta:meta]</span><span>)</span><span>*</span>
    <span>$vis:vis</span> <span>enum</span> <span>$Error:ident</span> <span>{</span>
      <span>$</span><span>(</span><span>$err:ident</span><span>,)</span><span>*</span>
    <span>}</span>
  <span>)</span> <span>=&gt;</span> <span>{</span>
    <span>$</span><span>(</span><span>#[</span><span>$</span><span>meta]</span><span>)</span><span>*</span>
    <span>$vis</span> <span>enum</span> <span>$Error</span> <span>{</span>
      <span>$</span><span>(</span><span>$err</span><span>,)</span><span>*</span>
    <span>}</span>

    <span>impl</span> <span>Error</span> <span>{</span>
      <span>pub</span> <span>fn</span> <span>from_code</span><span>(</span><span>code</span><span>:</span> <span>u32</span><span>)</span> <span>-&gt;</span> <span>Option</span><span>&lt;</span><span>Error</span><span>&gt;</span> <span>{</span>
        <span>#![allow(non_upper_case_globals)]</span>
        <span>$</span><span>(</span><span>const</span> <span>$err</span><span>:</span> <span>u32</span> <span>=</span> <span>$Error</span><span>::</span><span>$err</span> <span>as</span> <span>u32</span><span>;)</span><span>*</span>
        <span>match</span> <span>code</span> <span>{</span>
          <span>$</span><span>(</span><span>$err</span> <span>=&gt;</span> <span>Some</span><span>(</span><span>$Error</span><span>::</span><span>$err</span><span>),)</span><span>*</span>
          <span>_</span> <span>=&gt;</span> <span>None</span><span>,</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>};</span>
<span>}</span>

<span>define_error!</span><span>[</span>
  <span>#[derive(Debug,</span> <span>Clone,</span> <span>Copy,</span> <span>PartialEq,</span> <span>Eq)]</span>
  <span>pub</span> <span>enum</span> <span>Error</span> <span>{</span>
    <span>InvalidSignature</span><span>,</span>
    <span>AccountNotFound</span><span>,</span>
    <span>InsufficientBalance</span><span>,</span>
  <span>}</span>
<span>];</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>We have to carefully deal with all those visibilities and attributes.
Even after we do that, the connection between the input Rust-like syntax and the output Rust is skin-deep.
This is mostly smoke and mirrors, and is not much different from, e.g., using Haskell syntax here:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td><pre><span>macro_rules!</span> <span>define_error</span> <span>{</span>
  <span>(</span>
    <span>data</span> <span>$Error:ident</span> <span>=</span> <span>$err0:ident</span> <span>$</span><span>(|</span> <span>$err:ident</span><span>)</span><span>*</span>
      <span>$</span><span>(</span><span>deriving</span> <span>(</span><span>$</span><span>(</span><span>$derive:ident</span><span>),</span><span>*</span><span>))</span><span>?</span>
  <span>)</span> <span>=&gt;</span> <span>{</span>
    <span>$</span><span>(</span><span>#[derive(</span><span>$</span><span>(</span><span>$</span><span>derive),</span><span>*</span><span>)]</span><span>)</span><span>?</span>
    <span>enum</span> <span>$Error</span> <span>{</span>
      <span>$err0</span><span>,</span>
      <span>$</span><span>(</span><span>$err</span><span>,)</span><span>*</span>
    <span>}</span>

    <span>impl</span> <span>Error</span> <span>{</span>
      <span>pub</span> <span>fn</span> <span>from_code</span><span>(</span><span>code</span><span>:</span> <span>u32</span><span>)</span> <span>-&gt;</span> <span>Option</span><span>&lt;</span><span>Error</span><span>&gt;</span> <span>{</span>
        <span>#![allow(non_upper_case_globals)]</span>
        <span>const</span> <span>$err0</span><span>:</span> <span>u32</span> <span>=</span> <span>$Error</span><span>::</span><span>$err0</span> <span>as</span> <span>u32</span><span>;</span>
        <span>$</span><span>(</span><span>const</span> <span>$err</span><span>:</span> <span>u32</span> <span>=</span> <span>$Error</span><span>::</span><span>$err</span> <span>as</span> <span>u32</span><span>;)</span><span>*</span>
        <span>match</span> <span>code</span> <span>{</span>
          <span>$err0</span> <span>=&gt;</span> <span>Some</span><span>(</span><span>$Error</span><span>::</span><span>$err0</span><span>),</span>
          <span>$</span><span>(</span><span>$err</span> <span>=&gt;</span> <span>Some</span><span>(</span><span>$Error</span><span>::</span><span>$err</span><span>),)</span><span>*</span>
          <span>_</span> <span>=&gt;</span> <span>None</span><span>,</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>};</span>
<span>}</span>

<span>define_error!</span><span>[</span>
  <span>data</span> <span>Error</span> <span>=</span> <span>InvalidSignature</span> <span>|</span> <span>AccountNotFound</span> <span>|</span> <span>InsufficientBalance</span>
    <span>deriving</span> <span>(</span><span>Debug</span><span>,</span> <span>Clone</span><span>,</span> <span>Copy</span><span>,</span> <span>PartialEq</span><span>,</span> <span>Eq</span><span>)</span>

<span>];</span>

<span>impl</span> <span>Error</span> <span>{</span>
  <span>pub</span> <span>fn</span> <span>as_code</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>u32</span> <span>{</span>
    <span>self</span> <span>as</span> <span>u32</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div>
<div>
<h2 id="attribute-macro"><a href="#attribute-macro"></a>Attribute Macro</h2>
<div>
<p>We can meaningfully increase the fidelity between macro input and macro output by switching to a derive macro.
In contrast to function-like macros, derives require that their input is syntactically and even semantically valid Rust.</p>
<p>So the result looks like this:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
</pre></td><td><pre><span>use</span> <span>macros</span><span>::</span><span>FromCode</span><span>;</span>

<span>#[derive(FromCode,</span> <span>Debug,</span> <span>Clone,</span> <span>Copy,</span> <span>PartialEq,</span> <span>Eq)]</span>
<span>enum</span> <span>Error</span> <span>{</span>
  <span>InvalidSignature</span><span>,</span>
  <span>AccountNotFound</span><span>,</span>
  <span>InsufficientBalance</span><span>,</span>
<span>}</span>

<span>impl</span> <span>Error</span> <span>{</span>
  <span>pub</span> <span>fn</span> <span>as_code</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>u32</span> <span>{</span>
    <span>self</span> <span>as</span> <span>u32</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Again, the <code>enum Error</code> here is an honest, simple enum!
It’s not an alien beast which just wears enum’s skin.</p>
<p>And the implementation of the macro doesn’t look too bad either, thanks to @dtolnay’s tasteful API design:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td><pre><span>use</span> <span>proc_macro</span><span>::</span><span>TokenStream</span><span>;</span>
<span>use</span> <span>quote</span><span>::</span><span>quote</span><span>;</span>
<span>use</span> <span>syn</span><span>::{</span><span>parse_macro_input</span><span>,</span> <span>DeriveInput</span><span>};</span>

<span>#[proc_macro_derive(FromCode)]</span>
<span>pub</span> <span>fn</span> <span>from_code</span><span>(</span><span>input</span><span>:</span> <span>TokenStream</span><span>)</span> <span>-&gt;</span> <span>TokenStream</span> <span>{</span>
  <span>let</span> <span>input</span> <span>=</span> <span>parse_macro_input!</span><span>(</span><span>input</span> <span>as</span> <span>DeriveInput</span><span>);</span>
  <span>let</span> <span>error_name</span> <span>=</span> <span>input</span><span>.ident</span><span>;</span>
  <span>let</span> <span>enum_</span> <span>=</span> <span>match</span> <span>input</span><span>.data</span> <span>{</span>
    <span>syn</span><span>::</span><span>Data</span><span>::</span><span>Enum</span><span>(</span><span>it</span><span>)</span> <span>=&gt;</span> <span>it</span><span>,</span>
    <span>_</span> <span>=&gt;</span> <span>panic!</span><span>(</span><span>&#34;expected an enum&#34;</span><span>),</span>
  <span>};</span>

  <span>let</span> <span>arms</span> <span>=</span>
    <span>enum_</span><span>.variants</span><span>.iter</span><span>()</span><span>.enumerate</span><span>()</span><span>.map</span><span>(|(</span><span>i</span><span>,</span> <span>var</span><span>)|</span> <span>{</span>
      <span>let</span> <span>i</span> <span>=</span> <span>i</span> <span>as</span> <span>u32</span><span>;</span>
      <span>let</span> <span>var_name</span> <span>=</span> <span>&amp;</span><span>var</span><span>.ident</span><span>;</span>
      <span>quote!</span> <span>{</span>
        #<span>i</span> <span>=&gt;</span> <span>Some</span><span>(</span>#<span>error_name</span><span>::</span>#<span>var_name</span><span>),</span>
      <span>}</span>
    <span>});</span>

  <span>quote!</span> <span>{</span>
    <span>impl</span> #<span>error_name</span> <span>{</span>
      <span>pub</span> <span>fn</span> <span>from_code</span><span>(</span><span>code</span><span>:</span> <span>u32</span><span>)</span> <span>-&gt;</span> <span>Option</span><span>&lt;</span>#<span>error_name</span><span>&gt;</span> <span>{</span>
        <span>match</span> <span>code</span> <span>{</span>
          #<span>(</span>#<span>arms</span><span>)</span><span>*</span>
          <span>_</span> <span>=&gt;</span> <span>None</span><span>,</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>.into</span><span>()</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Unlike declarative macros, here we just directly express the syntax that we want to emit — a match over consecutive natural numbers.</p>
<p>The biggest drawback here is that on the call-site now we don’t have <em>any</em> idea about the extra API generated by the macro.
If, with declarative macros, you can notice an <code>pub fn from_code</code> in the same file and guess that that’s a part of an API, with a procedural macro that string is in a completely different crate!
While proc-macro can greatly improve the ergonomics of using and implementing macros (inflated compile times notwithstanding), for the reader, they are arguably even more opaque than declarative macros.</p>
</div>
</div>
<div>
<h2 id="self-modifying-code"><a href="#self-modifying-code"></a>Self Modifying Code</h2>
<div>
<p>Finally, let’s see the promised hacky solution :)
While, as you might have noticed, I am not a huge fan of macros, I like plain old code generation — text in, text out.
Text manipulation is much worse-is-betterer than advanced macro systems.</p>
<p>So what we are going to do is:</p>
<div>
<ul>
<li>
<p>Read the file with the enum definition as a string (<code>file!()</code> macro will be useful here).</p>
</li>
<li>
<p>“Parse” enum definition using unsophisticated string splitting (<code>str::split_once</code>, aka <code>cut</code> would be our parser).</p>
</li>
<li>
<p>Generate the code we want by concatenating strings.</p>
</li>
<li>
<p>Paste the resulting code into a specially marked position.</p>
</li>
<li>
<p>Overwrite the file in place, if there are changes.</p>
</li>
<li>
<p>And we are going to use a <code>#[test]</code> to drive the process!</p>
</li>
</ul>
</div>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td><pre><span>#[derive(Debug,</span> <span>Clone,</span> <span>Copy)]</span>
<span>pub</span> <span>enum</span> <span>Error</span> <span>{</span>
  <span>InsufficientBalance</span><span>,</span>
  <span>InvalidSignature</span><span>,</span>
  <span>AccountNotFound</span><span>,</span>
<span>}</span>

<span>impl</span> <span>Error</span> <span>{</span>
  <span>fn</span> <span>as_code</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>u32</span> <span>{</span>
    <span>self</span> <span>as</span> <span>u32</span>
  <span>}</span>

  <span>fn</span> <span>from_code</span><span>(</span><span>code</span><span>:</span> <span>u32</span><span>)</span> <span>-&gt;</span> <span>Option</span><span>&lt;</span><span>Error</span><span>&gt;</span> <span>{</span>
    <span>let</span> <span>res</span> <span>=</span> <span>match</span> <span>code</span> <span>{</span>
      <span>// region:sourcegen</span>
      <span>0</span> <span>=&gt;</span> <span>Error</span><span>::</span><span>InsufficientBalance</span><span>,</span>
      <span>1</span> <span>=&gt;</span> <span>Error</span><span>::</span><span>InvalidSignature</span><span>,</span>
      <span>2</span> <span>=&gt;</span> <span>Error</span><span>::</span><span>AccountNotFound</span><span>,</span>
      <span>// endregion:sourcegen</span>
      <span>_</span> <span>=&gt;</span> <span>return</span> <span>None</span><span>,</span>
    <span>};</span>
    <span>Some</span><span>(</span><span>res</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>#[test]</span>
<span>fn</span> <span>sourcegen_from_code</span><span>()</span> <span>{</span>
  <span>let</span> <span>original_text</span> <span>=</span> <span>std</span><span>::</span><span>fs</span><span>::</span><span>read_to_string</span><span>(</span><span>file!</span><span>())</span><span>.unwrap</span><span>();</span>
  <span>let</span> <span>(</span><span>_</span><span>,</span> <span>variants</span><span>,</span> <span>_</span><span>)</span> <span>=</span>
    <span>split_twice</span><span>(</span><span>&amp;</span><span>original_text</span><span>,</span> <span>&#34;pub enum Error {</span><span>\n</span><span>&#34;</span><span>,</span> <span>&#34;}&#34;</span><span>)</span>
      <span>.unwrap</span><span>();</span>

  <span>let</span> <span>arms</span> <span>=</span> <span>variants</span>
    <span>.lines</span><span>()</span>
    <span>.map</span><span>(|</span><span>line</span><span>|</span> <span>line</span><span>.trim</span><span>()</span><span>.trim_end_matches</span><span>(</span><span>&#39;,&#39;</span><span>))</span>
    <span>.enumerate</span><span>()</span>
    <span>.map</span><span>(|(</span><span>i</span><span>,</span> <span>var</span><span>)|</span> <span>format!</span><span>(</span><span>&#34;      {i} =&gt; Error::{var},</span><span>\n</span><span>&#34;</span><span>))</span>
    <span>.collect</span><span>::</span><span>&lt;</span><span>String</span><span>&gt;</span><span>();</span>

  <span>let</span> <span>new_text</span> <span>=</span> <span>{</span>
    <span>let</span> <span>start_marker</span> <span>=</span> <span>&#34;      // region:sourcegen</span><span>\n</span><span>&#34;</span><span>;</span>
    <span>let</span> <span>end_marker</span> <span>=</span> <span>&#34;      // endregion:sourcegen</span><span>\n</span><span>&#34;</span><span>;</span>
    <span>let</span> <span>(</span><span>prefix</span><span>,</span> <span>_</span><span>,</span> <span>suffix</span><span>)</span> <span>=</span>
      <span>split_twice</span><span>(</span><span>&amp;</span><span>original_text</span><span>,</span> <span>start_marker</span><span>,</span> <span>end_marker</span><span>)</span>
        <span>.unwrap</span><span>();</span>
    <span>format!</span><span>(</span><span>&#34;{prefix}{start_marker}{arms}{end_marker}{suffix}&#34;</span><span>)</span>
  <span>};</span>

  <span>if</span> <span>new_text</span> <span>!=</span> <span>original_text</span> <span>{</span>
    <span>std</span><span>::</span><span>fs</span><span>::</span><span>write</span><span>(</span><span>file!</span><span>(),</span> <span>new_text</span><span>)</span><span>.unwrap</span><span>();</span>
    <span>panic!</span><span>(</span><span>&#34;source was not up-to-date&#34;</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>fn</span> <span>split_twice</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span>(</span>
  <span>text</span><span>:</span> <span>&amp;</span><span>&#39;a</span> <span>str</span><span>,</span>
  <span>start_marker</span><span>:</span> <span>&amp;</span><span>str</span><span>,</span>
  <span>end_marker</span><span>:</span> <span>&amp;</span><span>str</span><span>,</span>
<span>)</span> <span>-&gt;</span> <span>Option</span><span>&lt;</span><span>(</span><span>&amp;</span><span>&#39;a</span> <span>str</span><span>,</span> <span>&amp;</span><span>&#39;a</span> <span>str</span><span>,</span> <span>&amp;</span><span>&#39;a</span> <span>str</span><span>)</span><span>&gt;</span> <span>{</span>
  <span>let</span> <span>(</span><span>prefix</span><span>,</span> <span>rest</span><span>)</span> <span>=</span> <span>text</span><span>.split_once</span><span>(</span><span>start_marker</span><span>)</span><span>?</span><span>;</span>
  <span>let</span> <span>(</span><span>mid</span><span>,</span> <span>suffix</span><span>)</span> <span>=</span> <span>rest</span><span>.split_once</span><span>(</span><span>end_marker</span><span>)</span><span>?</span><span>;</span>
  <span>Some</span><span>((</span><span>prefix</span><span>,</span> <span>mid</span><span>,</span> <span>suffix</span><span>))</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>That’s the whole pattern!
Note how, unlike every other solution, it is crystal clear how the generated code works.
It’s just code which you can goto-definition, or step through in debugging.
You can be completely oblivious about the shady <code>#[test]</code> machinery, and that won’t harm understanding in any way.</p>
<p>The code of the “macro” is also easy to understand — that’s literally string manipulation.
What’s more, you can easily see how it works by just running the test!</p>
<p>The “read and update your own source code” part is a bit mind-bending!
But the implementation is tiny and only uses the standard library, so it should be easy to understand.</p>
<p>Unlike macros, this doesn’t try to enforce at compile time that the generated code is fresh.
If you update the <code>Error</code> definition, you need to re-run test for the generated code to be updated as well.
But this <em>will</em> be caught by the tests.
Note the important detail — the test only tries to update the source code if there are, in fact, changes.
That is, writable <code>src/</code> is required only during development.</p>
<p>That’s all, hope this survey was useful! Discussion on <a href="https://old.reddit.com/r/rust/comments/tp8tmn/blog_post_self_modifying_code/">/r/rust</a>.</p>
</div>
</div>
</article>

  </div></div>
  </body>
</html>
