<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/siyuan-note/siyuan">Original</a>
    <h1>Siyuan: Privacy-first, self-hosted personal knowledge management software</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>After many long years, I am trying to write a small web UI for a side project. It is going to be a single-page application that I would like to be served from my server written in Go. I was introduced to <a target="_blank" rel="noopener" href="https://vite.dev/">vite</a> which gave me a hello world <a target="_blank" rel="noopener" href="https://react.dev/">react</a> app that gave me web assets like</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>webapp/</span></pre></td></tr></tbody></table></figure>
<h2 id="Basic-serve"><a href="#Basic-serve" title="Basic serve"></a>Basic serve</h2><p>In order to serve that app from my Go server, I would initialize it to be a go package that exposes a web server that serves it. That means creating <code>webapp/webapp.go</code> in our vite project.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>package</span> webapp</span></pre></td></tr></tbody></table></figure>
<p>Now our react app is also a Go package which could be consumed from other packages like this</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>webServer := webapp.New(webServerAddr)</span></pre></td></tr></tbody></table></figure>
<h2 id="Searching-for-a-handler"><a href="#Searching-for-a-handler" title="Searching for a handler"></a>Searching for a handler</h2><p>We would like to serve whatever is in our  <code>dist</code> folder when someone hits our web server. So I searched if there were any such handlers and found two such functions in the standard library.  So that we could register the handler in our <code>routes</code> ServeMux.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span><span>func</span> <span>FileServer</span><span>(root FileSystem)</span> <span>Handler</span></span></span></pre></td></tr></tbody></table></figure>
<p>The difference between them is their arguments. <code>FileSystem</code> is part of the <code>net/http</code> library and I found this note about it in the comments:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>// This interface predates the [fs.FS] interface, which can be used instead:</span></span></pre></td></tr></tbody></table></figure>
<p>So it is a deprecated interface in favor of a new interface. That leaves us with <code>fs.FS</code>.</p>
<p>It seems like <code>fs.FS</code> is an interface that represents a file system and is present in the <a target="_blank" rel="noopener" href="https://pkg.go.dev/io/fs">io/fs package</a>. I remember that they introduced the <code>io</code> package in the standard library to deprecate the <code>ioutil</code> package and this should have been a sweet addition that came with it?</p>
<p>Anyway, we will choose <code>FileServerFS</code> now.</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>routes.Handle(<span>&#34;/&#34;</span>, http.FileServerFS(????))</span><br/></pre></td></tr></tbody></table></figure>
<h2 id="A-filesystem"><a href="#A-filesystem" title="A filesystem"></a>A filesystem</h2><p>So we need a filesystem that we can give to our <code>http.FileServerFS()</code> method. I searched through the possible implementations of <code>fs.FS</code> interface and the first one that I was able to surface is <code>os.DirFS</code>.</p>
<p>It is a function that gives <code>fs.FS</code> based on the contents of a file system directory.</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>routes.Handle(<span>&#34;/&#34;</span>, http.FileServerFS(os.DirFS(<span>&#34;/home/vishnu/pers/gokakashi/webapp/dist&#34;</span>)))</span><br/></pre></td></tr></tbody></table></figure>
<p>The problem with this approach is, that we will hit troubles when we ship our server to a machine on the internet. Now, someone has to take care of creating <code>/home/vishnu/pers/gokakashi/webapp/dist</code> on the server machine or point to a directory that contains our web app’s assets. That becomes messy, right?</p>
<p>What I would ideally want is to embed all my HTML, CSS, JS files inside our go server binary itself. That way we ship only the binary and it will be able to serve the web app.</p>
<h2 id="Baking"><a href="#Baking" title="Baking"></a>Baking</h2><p>I have heard of the <code>embed</code> package which could be used for embedding files inside the go binary. There is <code>embed.FS</code> which satisfied <code>fs.FS</code> interface. So we could probably use it to bake in our assets.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>//go:embed dist</span></span></pre></td></tr></tbody></table></figure>
<p>We make use of it like</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>routes.Handle(<span>&#34;/&#34;</span>, http.FileServerFS(WebAssets))</span><br/></pre></td></tr></tbody></table></figure>
<p>This renders:</p>
<p>(not quite, what we want) Instead of embedding what is inside dist folder, we have embedded the <code>dist</code> folder itself. To inspect what got embedded, we could use the <code>go list</code> command like this:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>$ go list -f &#39;{{.EmbedFiles}}&#39; .</span></pre></td></tr></tbody></table></figure>
<p>I tried doing <code>//go:embed dist/*</code> instead of <code>//go:embed dist</code>, that didn’t help as well because (from Go docs)</p>
<blockquote>
<p>The difference is that ‘image/*’ embeds ‘image/.tempfile’ while ‘image’ does not. Neither embeds ‘image/dir/.tempfile’.</p>
</blockquote>
<p>If I used <code>//go:embed dist/index.html</code>, then the file seems to be still embedded with the <code>dist</code> folder.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>$ go list -f &#39;{{.EmbedFiles}}&#39; .</span></pre></td></tr></tbody></table></figure>
<p>I was wondering if there is a way to embed the contents of <code>dist</code> at the root of the FS instead of the FS directory. There seems to be no provision in the <code>embed</code> package to do it. Because it operates at a package level, and it would force us to declare <code>dist</code> as a separate go package and would force us to remove <code>dist</code> folder from <code>.gitignore</code>. That would be messy.</p>
<h2 id="Traverse"><a href="#Traverse" title="Traverse"></a>Traverse</h2><p>We know that we can’t change the root of the file system, but what if we traverse to a folder and get an <code>fs.FS</code> representation that projects the selected directory as the root? I suspected that there might be method to help with that in the <code>io/fs</code> package.</p>
<p>yep, look what I discovered:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>// Sub returns an FS corresponding to the subtree rooted at fsys&#39;s dir.</span></span></pre></td></tr></tbody></table></figure>
<p>Now, we just make use of it like this</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>//go:embed dist</span></span></pre></td></tr></tbody></table></figure>
<p>And boom!</p>
<p><img src="https://github.com/user-attachments/assets/150ae840-d520-47e8-9e87-ddf01713614f" alt="Screenshot from 2024-12-21 12-48-57"/></p>
<h2 id="Compile-time"><a href="#Compile-time" title="Compile time"></a>Compile time</h2><p>The <code>//go:embed dist</code> directive is evaluated during compile time. So when you run <code>go build</code>, the compiler looks for a <code>dist</code> folder and bakes it in the binary.</p>
<p>Let us say we miss generating the <code>dist</code> folder (maybe we failed running <code>npm run build</code>), that would lead to a compile-time error</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>$ go build </span></pre></td></tr></tbody></table></figure>
<p>This way we get the guarantee that no one is able to build our Go app without building the frontend that is intended to be embedded in it.</p>

  </div></div>
  </body>
</html>
