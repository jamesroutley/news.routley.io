<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spacetime.dev/plausibly-deniable-encryption">Original</a>
    <h1>Plausibly deniable encryption (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
<header>

<p> February 20th, 2020</p>
</header>
<p>It is safe to assume that in any useful <a href="https://en.wikipedia.org/wiki/Cryptosystem">cryptosystem</a> <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex"> C_k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>C</span><span><span><span><span><span><span></span><span><span>k</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> there exists at least one person with access to the key <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span>. An adversary with sufficient leverage can bypass the computational cost of a conventional attack by exerting their influence on this person.</p>

<p>The technique is sometimes referred to as <a href="https://en.wikipedia.org/wiki/Rubber-hose_cryptanalysis">rubber-hose cryptanalysis</a> and it gives the adversary some serious creative freedom. The security properties of the cryptosystem now rely not on the assumed difficulty of mathematical <a href="https://en.wikipedia.org/wiki/Trapdoor_function">trapdoor functions</a> but on some person’s tolerance to physical or psychological violence. A thief knows that pointing a gun will unlock a safe much faster than using a drill. An adversarial government will similarly seek information using torture and imprisonment rather than computational power.</p>
<p><a href="https://en.wikipedia.org/wiki/Key_disclosure_law#Legislation_by_nation">Many countries</a> have key-disclosure legislation. In the United Kingdom, <a href="https://en.wikipedia.org/wiki/Regulation_of_Investigatory_Powers_Act_2000">RIPA</a> was <a href="http://news.bbc.co.uk/1/hi/technology/7102180.stm">first used</a> against animal-rights activists to unlock data found on machines seized during a raid on their homes. The penalty for refusing to hand over key material is up to two years in prison.</p>
<p>Say Alice has a cryptosystem <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex"> C_k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>C</span><span><span><span><span><span><span></span><span><span>k</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> whose security properties rely on the secrecy of the key <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span>. To defend against attacks of this form Alice needs some way to keep <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> a secret. She could,</p>
<ol>
<li>Claim that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> is not known. This includes if it has been lost or forgotten.</li>
<li>Claim the ciphertext <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex"> c </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>c</span></span></span></span> is random noise and so is not decryptable.</li>
<li>Provide an alternate key <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex"> j </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>j</span></span></span></span> under which decryption produces a fake plaintext.</li>
</ol>
<p>Suppose Mallory is the adversary who wants <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> and suppose Alice makes a claim <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex"> X </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>X</span></span></span></span> in order to avoid revealing <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span>. Defining success can be tricky as Mallory can ultimately decide not to believe any claim that Alice makes. However we will simply say Mallory wins if she can show <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>X</mi></mrow><annotation encoding="application/x-tex"> \neg X </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>¬</span><span>X</span></span></span></span> and therefore assert that Alice has access to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> and is able to provide it. So for Alice to win, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex"> X </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>X</span></span></span></span> must be unfalsifiable and hence a <em>plausible</em> defence.</p>
<blockquote>
<p>As a side note, if Alice knows and can demonstrate <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>X</mi></mrow><annotation encoding="application/x-tex"> \neg X </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>¬</span><span>X</span></span></span></span> whereas Mallory cannot, then clearly she is missing some necessary information. <a href="https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle">Kerckhoffs’s principle</a> says that the security of a cryptosystem <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex"> C_k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>C</span><span><span><span><span><span><span></span><span><span>k</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> should rely solely on the secrecy of the key <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span>, so in general we want proving <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>X</mi></mrow><annotation encoding="application/x-tex"> \neg X </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>¬</span><span>X</span></span></span></span> to require knowing <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span>.</p>
</blockquote>
<p>We will ignore weaknesses related to <a href="https://en.wikipedia.org/wiki/Operations_security">operational security</a> or <a href="https://en.wikipedia.org/wiki/Vulnerability_(computing)">implementation</a>. For example if Mallory hears Alice admit to Bob that she is lying or if she finds a fragment of plaintext in memory then Alice has lost. However these situations are difficult to cryptographically protect against and so we assume security in this regard.</p>
<p>Pleading ignorance (1) of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> is an easy strategy for Alice as it leaves little room for dispute and it can be deployed as a tactic almost anywhere. Mallory must show that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> <em>is</em> known and this is difficult to do without actually producing it. Perhaps the key was on a USB device that has been lost, or was written down on a piece of paper that burned down along with Alice’s house. Mere forgetfulness however implies that the data does exist and the only barrier to retrieving it is in accessing Alice’s memories. This may not be satisfactory.</p>
<p>Asserting the non-existence (2) of the ciphertext is equivalent to claiming that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> does not exist and so cannot be disclosed. Plausibility comes from the fact that ciphertext is <a href="https://en.wikipedia.org/wiki/Ciphertext_indistinguishability">indistinguishable from random noise</a>. This means that given some potential ciphertext <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex"> c </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>c</span></span></span></span> an adversary cannot say if <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex"> c </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>c</span></span></span></span> is uniformly sampled or if <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><msub><mi>E</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> c = E_k(m) </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>c</span><span></span><span>=</span><span></span></span><span><span></span><span><span>E</span><span><span><span><span><span><span></span><span><span>k</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>m</span><span>)</span></span></span></span> is a valid message <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex"> m </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>m</span></span></span></span> encrypted under some key <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span>. To prove that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex"> c </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>c</span></span></span></span> is not random noise Mallory must produce <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> and compute <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex"> m </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>m</span></span></span></span>, which is assumed to be infeasible.</p>
<p><a href="https://en.wikipedia.org/wiki/TrueCrypt#Plausible_deniability">TrueCrypt</a> and <a href="https://en.wikipedia.org/wiki/VeraCrypt#Plausible_deniability">VeraCrypt</a> allow the creation of <a href="https://www.veracrypt.fr/en/Hidden%20Volume.html">hidden volumes</a> and <a href="https://www.veracrypt.fr/en/VeraCrypt%20Hidden%20Operating%20System.html">hidden operating systems</a>. The idea is that an ordinary encrypted volume will have unused regions of the disk filled with random data, and so a hidden volume can be placed there without revealing its existence.</p>
<div>
<p><img src="https://spacetime.dev/assets/images/hidden_volume_layout.png" alt="hidden volume layout"/></p><center><p>On-disk layout of an encrypted VeraCrypt volume.</p></center>
</div>
<p>Suppose we have a boot drive with a standard volume protected by the key <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex"> k_1 </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>k</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> and a hidden volume protected by the key <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex"> k_2 </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>k</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span>. The existence of the unencrypted boot-loader reveals the fact that the standard volume exists and so Mallory can confidently demand its key. Alice may safely provide Mallory with <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex"> k_1 </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>k</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> thereby revealing the innocuous contents of the standard volume. However when Alice enters <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex"> k_2 </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>k</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span>, the boot-loader fails to unlock the standard region so instead it tries to decrypt at the offset where the hidden volume’s header would reside. If the hidden volume exists and if the provided key is correct, this operation is successful and the boot-loader proceeds to boot the hidden operating system.</p>
<p>This is an example of providing a decoy decryption (3) but you may notice that Alice also had to claim that the remaining “unused” space on the drive is random noise (2) and not valid ciphertext. The necessity of a secondary claim is not a special case but a general property of systems that try to provide deniability in this way.</p>

<p>Providing a plausible reason for the existence of leftover data can be tricky. VeraCrypt relies on the fact that drives are often <a href="https://wiki.archlinux.org/index.php/Disk_encryption#Preparing_the_disk">wiped with random data</a> before being used as encrypted volumes. In other situations we may have to be sneakier.</p>
<p>This strategy does have some practical limitations. If the volume hosts an operating system, the innocuous OS has to be used as frequently as the hidden one to make it seem legitimate. For example if Alice provides the key and Mallory sees that the last login was two years ago, but she knows that Alice logged in the day before, then Mallory can be pretty sure something is off. Also consider what happens if Mallory sees a snapshot of the drive before and after some data is modified in the hidden volume. She then knows that there is data there and that it is not simply the remnants of an earlier wipe.</p>
<h3 id="the-dissident-protocol">The Dissident Protocol</h3>
<p>Imagine a huge library where every book is full of gibberish. There is a librarian who will help you store and retrieve your data within the library. You give her a bunch of data and a master key. She uses the master key to derive an encryption key and a random location oracle. The data is then split into book-sized pieces, each of which is encrypted with the derived key. Finally each encrypted book is stored at a location provided by the oracle.</p>
<blockquote>
<p>More formally, assume “library” means key-value store. Consider a <a href="https://en.wikipedia.org/wiki/Key_derivation_function">key-derivation function</a> <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>:</mo><mi>K</mi><mo>→</mo><mi>K</mi><mo>×</mo><mi>K</mi></mrow><annotation encoding="application/x-tex"> \Phi : K \to K \times K </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Φ</span><span></span><span>:</span><span></span></span><span><span></span><span>K</span><span></span><span>→</span><span></span></span><span><span></span><span>K</span><span></span><span>×</span><span></span></span><span><span></span><span>K</span></span></span></span> and a keyed <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">cryptographic hash function</a> <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>:</mo><mi>K</mi><mo>×</mo><mi mathvariant="double-struck">N</mi><mo>→</mo><mi>K</mi></mrow><annotation encoding="application/x-tex"> H : K \times \mathbb{N} \to K </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>H</span><span></span><span>:</span><span></span></span><span><span></span><span>K</span><span></span><span>×</span><span></span></span><span><span></span><span><span>N</span></span><span></span><span>→</span><span></span></span><span><span></span><span>K</span></span></span></span>, where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex"> K </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>K</span></span></span></span> is the key space. We also define an encryption function <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>:</mo><mi>K</mi><mo>×</mo><mi>M</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex"> E : K \times M \to C </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>E</span><span></span><span>:</span><span></span></span><span><span></span><span>K</span><span></span><span>×</span><span></span></span><span><span></span><span>M</span><span></span><span>→</span><span></span></span><span><span></span><span>C</span></span></span></span> and the corresponding decryption function <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>:</mo><mi>K</mi><mo>×</mo><mi>C</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex"> D : K \times C \to M </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>D</span><span></span><span>:</span><span></span></span><span><span></span><span>K</span><span></span><span>×</span><span></span></span><span><span></span><span>C</span><span></span><span>→</span><span></span></span><span><span></span><span>M</span></span></span></span>, where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex"> M </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>M</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex"> C </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>C</span></span></span></span> are the message space and ciphertext space, respectively.</p>
<p>Alice provides a key <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> which Faythe uses to derive the sub-keys <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mi mathvariant="normal">Φ</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> a, b = \Phi(k) </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span><span>,</span><span></span><span>b</span><span></span><span>=</span><span></span></span><span><span></span><span>Φ</span><span>(</span><span>k</span><span>)</span></span></span></span>. Alice then provides some data <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex"> p </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span> which is split into chunks <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>p</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex"> p_1, p_2, \ldots, p_n </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>p</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span><span>p</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span>…</span><span></span><span>,</span><span></span><span><span>p</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span>, where every <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex"> p_i </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>p</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> is padded to the same length. Finally, Faythe stores the entries <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>H</mi><mi>a</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>:</mo><msub><mi>E</mi><mi>b</mi></msub><mo stretchy="false">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex"> \{ H_a(i) : E_b(p_i) \} </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>{</span><span><span>H</span><span><span><span><span><span><span></span><span><span>a</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>i</span><span>)</span><span></span><span>:</span><span></span></span><span><span></span><span><span>E</span><span><span><span><span><span><span></span><span><span>b</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>p</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>)</span><span>}</span></span></span></span> in the key-value store.</p>
<p>For decryption, again Alice provides the key <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex"> k </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> and Faythe computes the sub-keys <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mi mathvariant="normal">Φ</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> a, b = \Phi(k) </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span><span>,</span><span></span><span>b</span><span></span><span>=</span><span></span></span><span><span></span><span>Φ</span><span>(</span><span>k</span><span>)</span></span></span></span>. She then iterates over <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex"> i \in \mathbb{N} </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>i</span><span></span><span>∈</span><span></span></span><span><span></span><span><span>N</span></span></span></span></span>, retrieving the values <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex"> c_i </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>c</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> corresponding to the keys <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>a</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> H_a(i) </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>H</span><span><span><span><span><span><span></span><span><span>a</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>i</span><span>)</span></span></span></span> and computing <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>b</mi></msub><mo stretchy="false">(</mo><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>D</mi><mi>b</mi></msub><mo stretchy="false">(</mo><msub><mi>E</mi><mi>b</mi></msub><mo stretchy="false">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex"> D_b(c_i) = D_b(E_b(p_i)) = p_i </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>D</span><span><span><span><span><span><span></span><span><span>b</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>c</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span>D</span><span><span><span><span><span><span></span><span><span>b</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>E</span><span><span><span><span><span><span></span><span><span>b</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>p</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>)</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span>p</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span>, stopping at <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> i = n + 1 </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>i</span><span></span><span>=</span><span></span></span><span><span></span><span>n</span><span></span><span>+</span><span></span></span><span><span></span><span>1</span></span></span></span> where the key-value pair does not exist. The plaintext is then <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><msub><mi>p</mi><mn>1</mn></msub><mo mathvariant="normal" lspace="0.22em" rspace="0.22em">∥</mo><msub><mi>p</mi><mn>2</mn></msub><mo mathvariant="normal" lspace="0.22em" rspace="0.22em">∥</mo><mo>…</mo><mo mathvariant="normal" lspace="0.22em" rspace="0.22em">∥</mo><msub><mi>p</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex"> p = p_1 \mathbin\Vert p_2 \mathbin\Vert \ldots \mathbin\Vert p_n </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>=</span><span></span></span><span><span></span><span><span>p</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span><span>∥</span></span><span></span></span><span><span></span><span><span>p</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span><span>∥</span></span><span></span></span><span><span></span><span>…</span><span></span><span><span>∥</span></span><span></span></span><span><span></span><span><span>p</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span>, after unpadding each <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex"> p_i </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>p</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span>.</p>
<p>Some extra consideration has to go into integrity and authentication to prevent attacks where the data Alice stores is not the data she gets back out. We leave this out here for simplicity’s sake.</p>
</blockquote>
<p>Suppose the library contains <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex"> n </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span> books in total. Mallory cannot say anything about Alice’s data apart from that its total size is less than or equal to the amount of data that can be stored within <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex"> n </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span> books. If, under duress, Alice is forced to reveal a decoy key that pieces together data from <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex"> m </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>m</span></span></span></span> books, she needs some way to explain the remaining <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi></mrow><annotation encoding="application/x-tex"> n - m </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>n</span><span></span><span>−</span><span></span></span><span><span></span><span>m</span></span></span></span> books that were not used. She could claim that,</p>
<ol type="A">
<li>The key for those books has been lost or forgotten.</li>
<li>They are composed of random noise and so cannot be decrypted.</li>
<li>They belong to other people and so the key is not known to her.</li>
</ol>
<p>This will look mostly familiar. Alice is trying to avoid revealing her actual data by providing a decoy key that unlocks some innocuous data. She then has to make a secondary claim in order to explain the remaining data that was not decrypted under the provided key.</p>
<p>Claiming ignorance (A) has the same trivial plausibility argument and practical limitation as before (1).</p>
<p>Asserting that the leftover books are composed of random bytes (B) requires an explanation for <em>how</em> they came to be there. She could say simply that she added them but this is a <a href="https://en.wiktionary.org/wiki/can_of_worms">can of worms</a> that we want to keep closed. If some software implementation decides how many decoy books to add, it would necessarily leak information to Mallory about the <em>expected</em> frequency of decoys. This value can be compared with Alice’s claim of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi></mrow><annotation encoding="application/x-tex"> n - m </annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>n</span><span></span><span>−</span><span></span></span><span><span></span><span>m</span></span></span></span> decoys to come up with an indicator of whether Alice is lying.</p>
<p>We have the same problem if the frequency is decided randomly as the value would have to lie within some range. We can get around this by asking Alice herself to decide the frequency, but this is messy and humans are bad at being unpredictable. In any case, this strategy boils down to Alice claiming “I added decoy entries explicitly in order to explain leftover data”, and this would rightly make an adversary extremely suspicious.</p>
<p>A better way to utilise B is for Faythe to replace books that are to be deleted with random data instead of removing them outright. Then Alice can claim that the remaining books have been deleted and therefore the data no longer exists and cannot be decrypted. This way potentially any number of leftover books can be easily explained, but it does mean that the size of our library will only increase over time.</p>
<p>Claim C is new and has some appealing properties but it can’t be used on a personal storage medium—like Alice’s laptop hard drive—as there is unlikely to be a plausible reason for other people’s data to be there. Imagine instead that the “library” is hosted on a service shared by multiple people. Then it is easy for Alice to claim that the remaining entries are not hers. Mallory would need leverage over every other person using the service in order to disprove Alice’s claim. Such a service has to be carefully designed however. For example if it stored how much space Alice is using then this value can be compared with Alice’s claim and Mallory wins.</p>
<p>There are some drawbacks of this scheme. There is an overhead in storing data in discrete, padded chunks. Modifying data in a non-trivial way may be expensive. Overwriting entries instead of removing them uses up storage space that is “wasted” in the sense that it does not hold any useful data. In designing this protocol what I have found is that we have to be <em>extremely careful</em> to avoid losing our deniability. Any implementation has to be verified to ensure that it does not fall short in this regard.</p>
<p>However we now have something that lets you have an arbitrary number of independent “folders” stored amongst numerous indistinguishable packets, with an adversary being unable to infer any information other than the maximum size of the stored data. This is a powerful property but it should be considered as part of the whole picture including your threat model and usability requirements.</p>
<blockquote>
<p>There is an experimental client implementing the spirit of this protocol <a href="https://github.com/awnumar/gravity">here</a>. As of the time of writing, <em>it is not ready for serious use</em>. However there are some exciting ideas I have for making this into a production ready and usable client in the (hopefully) near future.</p>
</blockquote><p>
{<a href="https://spacetime.dev/">home</a> : : <a href="https://spacetime.dev/feed.xml">subscribe with rss/atom</a>}
</p><ul>
<li>2020-12-16 : : <a href="https://spacetime.dev/rosen-censorship-resistant-proxy-tunnel">rosen: censorship-resistant proxy tunnel</a></li>
<li>2019-07-20 : : <a href="https://spacetime.dev/memory-retention-attacks">memory retention attacks</a></li>
<li>2019-07-18 : : <a href="https://spacetime.dev/encrypting-secrets-in-memory">encrypting secrets in memory</a></li>
<li>2019-06-27 : : <a href="https://spacetime.dev/mutable-strings-go">mutable strings in go</a></li>
<li>2019-05-02 : : <a href="https://spacetime.dev/to-slice-or-not-to-slice">to slice or not to slice</a></li>
<li>2017-08-03 : : <a href="https://spacetime.dev/memory-security-go">memory security in go</a></li>
<li>2017-07-30 : : <a href="https://spacetime.dev/quantum-key-exchange">quantum key-exchange</a></li>
</ul>
</div></div>
  </body>
</html>
