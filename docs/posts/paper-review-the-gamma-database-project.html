<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/review-gamma-database-paper/">Original</a>
    <h1>Paper review: The Gamma Database Project</h1>
    
    <div id="readability-page-1" class="page"><article>
    

    <p><strong>Tuesday, October 11, 2022</strong></p>

    <p>Last week, I read <a href="https://scholar.google.com/scholar?cluster=8912521541627865753">&#34;The Gamma Database Project&#34;</a> for a <a href="http://redbook.io">Red Book</a> reading group. Unlike the <a href="https://ntietz.com/blog/review-architecture-of-a-database-system/">last paper</a> for this group, this one was a lot more approachable in length: 19 pages.</p>
<p>I&#39;m putting up some of my notes here from reading the paper.
If you read through to the end, there&#39;s dessert: a quibble I have with the paper.</p>
<hr/>
<p>My understanding is that this paper was very influential in its time.
The architecture it describes is a shared-nothing architecture for distributed databases with very nice scaling properties.
Notably, it has linear scale-up and speed-up.
These are often related, but they&#39;re distinct and both are important to examine.</p>
<ul>
<li><strong>Speed up</strong> here is measuring how much faster particular queries get if we add more hardware. Since Gamma shows linear speed up it means that if we go from 5 to 10 machines, we should see queries run in half the time.</li>
<li><strong>Scale up</strong> here is measuring how much data can be handled by the system with fixed query times. Since Gamma shows linear scale up, it means that if we double the amount of data stored, and we double the machines in the cluster, then we should keep the same speed of queries.</li>
</ul>
<p>They&#39;re related, but not the same: If a query is only hitting one server, adding more servers won&#39;t speed it up, for example.</p>
<p>They presented three key techniques for achieving these properties on commodity hardware:</p>
<ul>
<li>Horizontally partitioning data across the cluster (with some nice resiliency properties)</li>
<li>A good parallel join function based on hashing</li>
<li>Effective scheduling of jobs onto machines to make use of all available hardware</li>
</ul>
<hr/>
<p>The overall architecture is pretty typical for databases; we can refer back to the <a href="https://ntietz.com/blog/review-architecture-of-a-database-system">Architecture of a Database System</a> for the overall architecture and just talk about differences.</p>
<p>The main differences come down to partitioning.
They employ three different partitioning schemes:</p>
<ul>
<li>
<p>Round-robin: this is the default, and distributes records uniformly across all disk drives.
This means that any read <em>must hit all disk drives</em>.</p>
</li>
<li>
<p>Hashed: a hash function is applied to the input to determine which node gets the data.</p>
</li>
<li>
<p>Range partitioned: the operator may select which range of data goes to which machines.</p>
</li>
</ul>
<p>Hashed or range partitioned data may hit a subset of machines for queries, which has benefits (potentially more parallel queries, could be faster, less overhead from distribution) and has some drawbacks (more limitation in speedup and scaleup).</p>
<p>They do say that defaulting to splitting all data across all machines by default was a mistake, and that it would be better to base the amount of distribution on some metric.
I wasn&#39;t clear on <em>why</em> they felt it was a mistake, so I&#39;d like to learn more there.</p>
<hr/>
<p>I went on a nice rabbit hole exploration during reading this paper.</p>
<p>They mentioned they were using commodity hardware, so I was curious what the hardware was and how it has changed to today.
It used cutting edge hardware at the time (they complain about being beta testers for some of it, delaying their project), and today it can largely be beat by a single desktop computer.
My workstation has nearly as much <em>CPU cache</em> as the cluster had main memory.</p>
<p>The paper was released in 1990 but the hardware was acquired in 1988, so that&#39;s 34 years ago.
Hardware today should be about 2^17 times &#34;better&#34;, or 131,000x, but this may be on multiple axes (both increases in performance and decreases in cost, etc.).
(Yes, I know Moore&#39;s Law has ended. Don&#39;t @ me.)</p>
<p>The hardware they had was 30x Intel 80386 processors, which ran at 16 MHz (one core).
(Incidentally, these were still <a href="https://handwiki.org/wiki/Engineering:Intel_80386">manufactured until 2007</a>, as they were used in embedded applications long after personal computers outgrew them.)</p>
<p>Unfortunately, I can&#39;t find much information on cost of this system, but a simliar system was about $300,000 (about $700,000 in 2022). I can buy a system with at least 100x the processing power for at least 1/1000 of the cost, which would be 100,000x improvement, which is right about on the mark for Moore&#39;s law!</p>
<hr/>
<p>Saving the beef for last.
They had one comment that seemed like mostly an aside, but I feel is not well supported.
They state:</p>
<blockquote>
<p>&#34;[...] the response time for each of the five selection queries remains almost constant. The slight increase in response time is due to the overhead of initiating a selection and store operation at each site.&#34;</p>
</blockquote>
<p>I have a few issues with this claim:</p>
<ul>
<li>They don&#39;t provide a word on how much overhead these operations are (and I&#39;m skeptical that they&#39;re high enough overhead to see this effect)</li>
<li>The increases are not consistent!
The times go up, then down, then up again, and it varies with respect to the query being run.</li>
</ul>
<p>It&#39;s not even clear that the experimenters ran the queries multiple times and averaged the results.
There&#39;s little information on how they gathered this data.</p>
<p>I think there&#39;s a much simpler explanation of this relatively minor variance:
Simple probability.</p>
<p>In this case, they&#39;re increasing the number of nodes from 5 to 30. The operations require data from all nodes to return before they can be finalized. This means that the operation will be as slow as the <em>slowest node</em>. If you take the maximum of 5 random numbers in a range, and then you take the maximum of 30 random numbers in a range, you would generally expect the latter to be higher than the formerâ€”but not always!</p>
<p>At any rate, this doesn&#39;t really take away from what&#39;s an excellent paper to read.</p>

  </article><p>If you have comments or find errors, please <a href="mailto:blogfeedback@ntietz.com">email me</a>! For updates when I post new things, I have a lovely <a href="https://ntietz.com/atom.xml">RSS feed</a> you can use.
</p></div>
  </body>
</html>
