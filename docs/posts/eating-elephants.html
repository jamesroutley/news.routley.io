<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://explog.in/notes/elephants.html">Original</a>
    <h1>Eating Elephants</h1>
    
    <div id="readability-page-1" class="page"><div id="content">



<p>
As a software engineer, you&#39;ll almost certainly ramp up on large
projects and code bases: anything from massive proprietary setups to
popular open source projects.
</p>

<p>
The <i>best</i> way to get better at learning a new project is to do it
repeatedly across different contexts and directly building the
appropriate mental muscles. This post is for those of you who haven&#39;t
had that luxury yet: strategies and tactics for managing complexity
and delivering along the way.
<span>YMMV: these are approaches that work for the way <i><i>my</i></i> mind functions.</span>
</p>

<p>
With several bad metaphors thrown in along the way.
</p>

<blockquote>
<p>
How do you eat an elephant?
<i>One bite at a time.</i>
</p>
</blockquote>


<div id="org338f630">
<p><img src="http://lock.cmpxchg8b.com/static/images/elephant.png" alt="elephant.png"/>
</p>
<p><span>Figure 1: </span>No elephants (artificial or real) were harmed in the making of this post. (Generated with DALL-E 2.)</p>
</div>

<div id="outline-container-org5f891b5">
<h2 id="org5f891b5">Be very clear on what you want to achieve</h2>
<div id="text-org5f891b5">
<p>
When faced with a large project, it&#39;s unfortunately easy to fixate on
a specific rabbit hole and end up spending all your time there
while forgetting why you were there in the first place. Always
remember the broader context and constraints! The care with which you
gain context and evaluate approaches will vary dramatically.
</p>

<p>
Let&#39;s make this concrete: If you&#39;re only ramping up to do a quick
bug fix on an old, mostly dead project: you should be laser focused on
the desired behavior, the observed behavior and the safest, smallest
change you can do to make it. &#34;Patch&#34;-fixing might even be acceptable
by tackling the symptom without treating the underlying root cause.
</p>

<p>
On the other hand, if this is something you&#39;re going to be spending a
significant amount of your time on: you want to build significantly
broader context on what the code is doing, how it got to this state, and
building a significantly more detailed mental model.
</p>

<p>
Of course, these aren&#39;t as distinct as they may seem: it&#39;s entirely
likely that you&#39;ll need to to start by setting out fires as quickly as
possible, and then take the time to build deeper and broader context.
</p>
</div>
</div>


<div id="outline-container-org2b535ee">
<h2 id="org2b535ee">Build and refine your mental model</h2>
<p>
I feel comfortable with a system once I have a reasonably accurate
mental model of how it operates. The model should be high resolution
and precise for areas that need to be actively changed soon, while
it&#39;s generally acceptable to treat other parts as black boxes. Ideally
you make the time to peek into those boxes every so often.
</p>

<div id="outline-container-org089099b">
<h3 id="org089099b">Think through how you would have built it</h3>
<p>
To reach a first approximation, imagine how you would build this
system; given the constraints and behaviors you understand. The most
interesting parts are going to be figuring out where reality is
different from how you would have done it, and digging into why.
</p>
</div>


<div id="outline-container-orge2197dc">
<h3 id="orge2197dc">See what <i>is</i>, not what you expect to see</h3>
<div id="text-orge2197dc">
<p>
After conducting more than 500 interviews one extremely common mistake
I see programmers make is to fall prey to confirmation bias: instead
of carefully exploring what the program is actually doing, they assume
it&#39;s doing what they wrote it to. I&#39;m bitter about this because I
repeatedly make the same mistake in my daily life, never quite seeming
to learn from my experience.
</p>

<p>
My favorite approach to counteract this is to actively look for any
signals that suggest I&#39;m wrong. This is hard, and has the added negative
of appearing significantly less confident than you should be – but is
worth the price.
</p>

<p>
Think of it like the sentence with &#39;the&#39; repeated across multiple
lines: sometimes it can be very hard to see the underlying issues.
</p>
</div>
</div>

<div id="outline-container-orgcb88500">
<h3 id="orgcb88500">Hack it up any which way</h3>
<div id="text-orgcb88500">
<p>
<span>This is a recommendation to try and swallow the elephant whole: you&#39;re almost certainly going to fail, but you&#39;ll get a <i>true</i> sense of the magnitude of the task.</span>
</p>

<p>
Even if it is surprisingly counter-intuitive you can minimize the risk
by simply hacking in the changes you&#39;d like to make, without paying
attention to design, maintainability or code quality.
</p>

<p>
Simply getting your changes to <i>work</i> can be very valuable to identify
if there are any large unknown unknowns, significantly reduces the
chances of unpleasant surprises a few weeks to months down the line
and <i>really</i> validates your mental model.
</p>

<p>
I don&#39;t recommend actually deploying the changes of course, nor even
committing them; at best you might use them for a temporary demo to
make sure your team is aligned.
</p>

<p>
You&#39;ll learn a lot even if the attempt at hacking it up fails
completely: at least you&#39;ll know the big questions you need to
answer before you can meaningfully tackle this project.
</p>
</div>
</div>

<div id="outline-container-org35cd391">
<h3 id="org35cd391">Make small changes with confidence</h3>
<div id="text-org35cd391">
<p>
<span>This is the part where you nibble at the edges of the elephant to build up confidence that you&#39;ll be able to actually eat it one day.</span>
</p>

<p>
At the other end of the spectrum, you want to gain confidence in your
knowledge of – and ability to change – the system. Start by kicking
the tires – add unit tests, fix lints, spellings, add examples to the
documentation, and very simple functional or non-functional changes
<i>that will still run in production</i>.
</p>

<p>
Check that you can deploy them smoothly, and they behave as you expect
once you&#39;ve made the changes. Along the way, you&#39;ll gain goodwill from
your team, have something to show for all the time you&#39;ve been
spending ramping up on the system, and get that glow of satisfaction
at actually landing something instead of rotating in place for months.
</p>
</div>
</div>

<div id="outline-container-org4eb7be3">
<h3 id="org4eb7be3">Move from a good working state to a good working state</h3>
<div id="text-org4eb7be3">
<p>
<span>This is a reminder to take small bites, and to not bite off more than you can chew.</span>
</p>

<p>
Because you&#39;re dealing with so many unknowns, you need to move
carefully: always go from a known good state that behaves exactly as
you expect it to the a new good state making one change at a
time. This simple mechanical behavior can save you hours of debugging
and working backwards to identify unintentional consequences.
</p>

<p>
At times, it can take a little bit of humility to constrain yourself
to small changes instead of giant leaps; you&#39;re most likely to learn
the same way I did – which is to fail often enough till I trained
myself to make small but confident steps.
</p>
</div>
</div>

<div id="outline-container-org660da4d">
<h3 id="org660da4d">Believe only in empirical evidence</h3>
<div id="text-org660da4d">
<p>
<span>There are no appropriate elephant analogies here. Carry along.</span>
</p>

<p>
Reading code is one thing, running it is another entirely.
</p>

<blockquote>
<p>
Anybody who thinks &#34;Just read the code and think about it&#34; – that&#39;s an
insane statement – you can&#39;t even read all the code in a big system,
you have to do experiments on the system.
– <a href="https://youtu.be/tzr7hRXcwkw?t=90">John Carmack</a>
</p>
</blockquote>

<p>
Reading code can be fairly misleading: you can&#39;t really be certain if
other abstractions won&#39;t interfere with execution – particularly if
you&#39;re not aware of the context the system lives in.
</p>

<p>
Reaching for an example from something I&#39;ve been working on recently:
PyTorch supports several transforms to make your easy-to-modify but
slow-to-run model into something that&#39;s extremely fast. But <i>if you
didn&#39;t know</i> that it&#39;s going to be traced, you&#39;re going to have
completely broken assumptions on what runs.
</p>

<p>
Lightly modifying the simple example in the torch.fx documentation: I
added a small print statement to forward to always see the value of <code>x</code>.
</p>

<div>
<pre><span>import</span> torch
<span>class</span> <span>MyModule</span>(torch.nn.Module):
    <span>def</span> <span>__init__</span>(<span>self</span>):
        <span>super</span>().__init__()
        <span>self</span>.param = torch.nn.Parameter(torch.rand(3, 4))
        <span>self</span>.linear = torch.nn.Linear(4, 5)

    <span>def</span> <span>forward</span>(<span>self</span>, x):
        <span>print</span>(f<span>&#34;A wild print appeared! {x=}&#34;</span>)
        <span>return</span> <span>self</span>.linear(x + <span>self</span>.param).clamp(<span>min</span>=0.0, <span>max</span>=1.0)
</pre>
</div>

<p>
Reading the code I&#39;d assume the print statement is always going to be
executed: but if this module is FX-traced before execution (and it
probably will be) – it&#39;s going to get elided.
</p>

<p>
If you don&#39;t believe me, you can try running through <a href="https://deepnote.com/workspace/kunal-bhalla-372e292e-4a71-42dc-b95a-fb0bf5e63214/project/Untitled-project-971b8394-46af-46aa-8e03-3ea5ef9279e1/%2Fnotebook.ipynb">this
notebook</a>. Actively running the code through FX and printing out the
generated version makes it much more explicit:
</p>

<div>
<pre><span>def</span> <span>forward</span>(<span>self</span>, x):
    <span>param</span> = <span>self</span>.param
    <span>add</span> = x + param;  <span>x</span> = <span>param</span> = <span>None</span>
    <span>linear</span> = <span>self</span>.linear(add);  <span>add</span> = <span>None</span>
    <span>clamp</span> = linear.clamp(<span>min</span> = 0.0, <span>max</span> = 1.0);  <span>linear</span> = <span>None</span>
    <span>return</span> clamp
</pre>
</div>


<p>
For examples from further in the past I&#39;ll point to optimizing
compilers and other brilliant magic. (Which is why tools like the
<a href="https://godbolt.org/">Godbolt compiler explorer</a> are essential.)
</p>
</div>

<div id="outline-container-org46fc107">
<h4 id="org46fc107">Use a debugger</h4>
<div id="text-org46fc107">
<p>
If you have a good enough setup to easily attach a debugger and run
the program fast enough, step through it – save your breakpoints, and
try playing with the program as it runs.
</p>

<p>
Unfortunately I&#39;ve mostly worked with distributed systems, custom
built PHP debuggers and android: debuggers have been flaky,
occasionally misleading and have slowed down execution to be
impossible.
</p>

<p>
I dislike the fact that the output and state of the debugger is
ephemeral – it&#39;s extremely hard to go back and compare to a previous
state without being extremely disciplined around recording state.
</p>

<p>
Debuggers that can run in reverse solve this, but tend to be extremely
expensive given the amount of data they need to resolve.
</p>
</div>
</div>

<div id="outline-container-org8fc6815">
<h4 id="org8fc6815">Use a REPL</h4>
<div id="text-org8fc6815">
<p>
Getting a live REPL into your code base can be an excellent way to see
what&#39;s going on in small pieces – you can call deeply nested
functions directly to see how they behave and validate behavior.
</p>

<p>
This works particularly well in Python, on notebooks, and other
similar systems to piece-wise sanity check that things are working
properly.
</p>

<p>
If you&#39;re lucky (and nearby security engineers maybe not so
much) you might get a REPL into a live production system to poke
around in it.
</p>
</div>
</div>

<div id="outline-container-orgc85dccb">
<h4 id="orgc85dccb">Sprinkle print statements liberally</h4>
<div id="text-orgc85dccb">
<p>
If you&#39;re dealing with something much more distributed, or something
that happens to slow down to a crawl if you try to debug it <code>print-equivalent</code>
based debugging can work just as well – with the added advantage of
persisting easily between sessions, and all the way into production if
you want it to.
</p>

<p>
Occasionally you&#39;ll find that you don&#39;t own <code>stderr</code> or <code>stdout</code>: they&#39;ve
been redirected, are already overwhelmed with noisy print statements
by inferior programmers, or otherwise used for the program&#39;s
contracted behavior. Open up an extra file instead and write to
it – sometimes several if you want to break up the logs into
something easier to deal with.
</p>
</div>
</div>

<div id="outline-container-orga33ce56">
<h4 id="orga33ce56">Use Tracebacks and exceptions</h4>
<p>
To see how certain functions are used, try explicitly logging a stack
trace at interesting points with the arguments and return
values. That&#39;s been the whole point of one of my open source projects,
<code>Panopticon</code>.
</p>
</div>
</div>

<div id="outline-container-org9f41c9d">
<h3 id="org9f41c9d">Make like Sherlock Holmes</h3>
<div id="text-org9f41c9d">
<p>
This is getting somewhat repetitive, but being extremely conscientious
about collecting and paying attention to every signal is incredibly
valuable.
</p>


<div id="orgd8a3e7f">
<p><img src="http://lock.cmpxchg8b.com/static/images/sherlock.png" alt="sherlock.png"/>
</p>
<p><span>Figure 2: </span>If it looks like an elephant, talks like an elephant, walks like an elephant… (Generated with DALL-E 2.)</p>
</div>
</div>

<div id="outline-container-orge2f152a">
<h4 id="orge2f152a">Look for fingerprints</h4>
<div id="text-orge2f152a">
<p>
Ideally you&#39;ll have good ways to quickly navigate and search through
your code base: the more obvious jump-to-<code>TAGS</code> is always valuable to
explicitly look up class and function names, but do remember to also
pay attention to other unintentional fingerprints as you search
through the code.
</p>

<p>
One of the most surprisingly effective ways I&#39;ve found to navigate a
co-debase is to try and search for the strings that show up all over
the place: either in the ui, or in logs; elide the more obviously
dynamic parts and it becomes surprisingly easy to jump straight to the
code you care about – or a specific constant that you can then work
backwards from.
</p>

<p>
Other fingerprints include CSS class names, ids, etc. – particularly
those that haven&#39;t been minified yet.
</p>
</div>
</div>

<div id="outline-container-org724cc48">
<h4 id="org724cc48">Pay close attention to the logs</h4>
<div id="text-org724cc48">
<p>
Always remember to <i>carefully</i> read all logging: it&#39;s too easy to miss
something obvious right in front of you. Most of the logs correspond
to something someone <i>else</i> thought was interesting about the program&#39;s
behavior; you might as well pay attention as you learn about it.
</p>

<p>
There are several programs that can help you navigate logs more
easily: while there are some excellent UIs and CLIs like
<a href="https://lnav.org/">The LogFile Navigator</a>, I often find myself dropping into Vim with a
copy of the logs. That gives me the ability to search and delete
anything I don&#39;t care to see, reformat some logs; occasionally copy
out a few specific instances and explicitly diff them.
</p>

<p>
In extreme scenarios, I&#39;ll also pull all the logs into a notebook and
convert them to a <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">dataframe</a> for faster manipulation and analysis
(particularly useful for extracting all logs for a specific <i>thread</i> by
breaking them out by pid).
</p>
</div>
</div>

<div id="outline-container-orgf2f176f">
<h4 id="orgf2f176f">Look out for any instrumentation</h4>
<div id="text-orgf2f176f">
<p>
Any live instrumentation that captures the system&#39;s execution is the
last set of data I&#39;d recommend pulling up. Instrumentation should help
you build empathy with how the system executes: do requests take
milliseconds, seconds, or minutes? What does p99, p99.9, p99.99
latency look like? How many resources are consumed? Is this code CPU
bound, I/O bound, or neither?
</p>

<p>
Don&#39;t trust instrumentation at first pass either: look up how it&#39;s
generated, validate it with simple tests, and <i>then</i> you can assume that
it&#39;s probably not broken.
</p>
</div>
</div>
</div>

<div id="outline-container-orge0028fc">
<h3 id="orge0028fc">Learn to speed read code</h3>
<div id="text-orge0028fc">
<p>
Even though relying solely on reading code is misleading, you still
need to be able to skim it really quickly. The same rules for reading
books well fast apply: focus on the interfaces instead of digging
deeply into the implementations, spend your time on critical pieces.
</p>

<p>
You should figure out ways to quickly navigate your code base for this
to work really well: and there are 2 mechanisms you should have.
</p>
</div>

<div id="outline-container-org649f8c2">
<h4 id="org649f8c2">Indexing based navigation</h4>
<div id="text-org649f8c2">
<p>
The ideal is always a system that lets you jump to the precise
function or class you care about, or even with a regular expression. A
search engine / IDE that understands the code well is always amazing.
</p>

<p>
Old school TAGS, shiny new LSPs, or Github&#39;s new code search and
inline links to source code are all good examples.
</p>
</div>
</div>

<div id="outline-container-orgcd85779">
<h4 id="orgcd85779">String based navigation</h4>
<div id="text-orgcd85779">
<p>
At the same time (particularly to navigate using fingerprints) I find
simple text (or regex) based search invaluable. Ideally you have a
system that lets you grep through your code base quickly.
</p>

<p>
At its simplest, hopefully you have a checkout that you can <code>find</code> and
<code>grep</code> your way through with ease; but for particularly large systems
something like <a href="https://oracle.github.io/opengrok/">Open Grok</a> or <a href="https://cs.android.com/">Android Code Search</a> is invaluable.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org8d7b9da">
<h2 id="org8d7b9da">Working with other people</h2>
<p>
Happily enough, you&#39;ll generally work with people who&#39;ve already
consumed this particular elephant and can significantly speed you up
along the way. There are several tactics to learning well from
others.
<span>To the horror of the elephant community.</span>
</p>

<div id="outline-container-orgedb5dc7">
<h3 id="orgedb5dc7">Communicate your progress!</h3>
<div id="text-orgedb5dc7">
<p>
Setting and updating expectations constantly as you ramp up can be one
of the most valuable things you can do. Explain how far you&#39;ve gotten,
how long you think it&#39;ll take and why.
</p>

<p>
Writing down and sharing (<i>much</i> more on this in a minute) what you&#39;ve
found will also help validate that you&#39;re building a good
understanding of the system and act as a bridge for whoever happens to
come after you.
</p>

<p>
Regular communication on an automatic cadence: as opposed to self
identifying specific milestones also significantly reduces pressure on
sharing updates: if you do it every week, then people can rely on
understanding your progress regularly when you <i>push</i> the information;
instead of having to <i>pull</i> it when they get worried.
</p>
</div>
</div>

<div id="outline-container-orgf2323a4">
<h3 id="orgf2323a4">Ship small wins as soon as you can</h3>
<div id="text-orgf2323a4">
<p>
Never under-estimate the value of shipping several small wins quickly:
you&#39;ll build momentum and confidence in yourself, and inspire
confidence in others at the same time.
</p>

<p>
You&#39;re also actively fixing and improving the project you&#39;re working
on, doing good work sooner along the way.
</p>
</div>
</div>

<div id="outline-container-org3a73d70">
<h3 id="org3a73d70">Respect Chesterton&#39;s fence</h3>
<div id="text-org3a73d70">
<p>
As satisfying as it is to rant about past design decisions – and they
may definitely be horrifying – the engineers before you did the best
they could with the constraints they were working under.
</p>

<p>
You need to figure out which of those constraints still apply and
which ones are obsolete, and do this without running headlong into
them. Try to understand the rationale behind questionable design
decisions to make sure they weren&#39;t solving a problem you just haven&#39;t
faced yet.
</p>
</div>
</div>

<div id="outline-container-org61b08c7">
<h3 id="org61b08c7">But don&#39;t be afraid to break it</h3>
<p>
Once you&#39;re sure you have context on past decisions, you should feel
empowered to go and <i>change</i> them. It can be just as damaging to blindly
accept past decisions as it is to change them without thinking through
the consequences.
</p>
</div>

<div id="outline-container-org20d116b">
<h3 id="org20d116b">Ask questions <i>well</i></h3>
<div id="text-org20d116b">
<p>
While there are no stupid questions, you can get much more from your
colleagues by asking <i>good</i> questions <i>well</i>. You want to show that you
did your research, what worked and what didn&#39;t; you want to minimize
the time they need to answer your question – but still get the most
information you can.
</p>

<p>
If someone hands you a fish, also follow up on <i>how</i> to fish – &#34;How did
you solve this?&#34; so that you don&#39;t need to repeatedly ask for the same
things.
</p>

<p>
Of course, there&#39;s also a cost to spending too much time digging
<i>before</i> asking questions. A rule of thumb along the lines of &#34;one hour
of digging&#34; before reaching out can be very valuable instead.
</p>
</div>
</div>

<div id="outline-container-orga08e0d5">
<h3 id="orga08e0d5">Read <i>everything</i></h3>

<div id="outline-container-orgbf0a20b">
<h4 id="orgbf0a20b">Read the documentation</h4>
<div id="text-orgbf0a20b">
<p>
Learning from the engineers who came before you isn&#39;t necessarily
restricted to directly <i>talking</i> to people. There&#39;s a lot of information
available in any reasonable code base.
</p>

<p>
Most obviously, you should quickly navigate and understand the
documentation that&#39;s available: particularly valuable is documentation
that explains the <i>why</i>. I generally recommend reading the code itself
to understand the <i>how</i>; documentation describing the <i>how</i> also tends to
bit-rot the fastest.
</p>
</div>
</div>

<div id="outline-container-orgd51c5dc">
<h4 id="orgd51c5dc">Read the commit history</h4>
<p>
Less obviously, see how the code evolved: go spelunking into the
commit history and look for major decisions for the parts of the
code base you&#39;re interested in. I like to jump to the commit that
introduced that particular file/class/function in the first place to
see the original intent for adding it, without the cruft that might
have grown up around it over the years. Then you can skip along to any
major refactors or structural changes that render it
unrecognizable.
</p>
</div>

<div id="outline-container-org0a56b3c">
<h4 id="org0a56b3c">Look for design documents &amp; discussions</h4>
<p>
Look for any old design documents or discussions that might be hanging
around: this can also act as an excellent reference to find more
people to talk to. One of the most important pieces of context you
should gather is the set of problems that this piece of code was meant
to solve: and then to determine which of those problems is still
applicable or if there are new ones that must be addressed.
</p>
</div>
</div>

<div id="outline-container-org35014d6">
<h3 id="org35014d6">Pair program, or shadow engineers</h3>
<div id="text-org35014d6">
<p>
It can be both inspiring and extremely informative to simply shadow
others who&#39;re comfortable with the system. You can see what it&#39;s going
to be like once you build mastery, and ask live questions along the
way.
</p>

<p>
This may or may not be possible depending on your setup, but can be
one of the fastest ways to get better at ramping up and solving problems.
</p>
</div>
</div>
</div>


<div id="outline-container-org66c855e">
<h2 id="org66c855e">Write <i>everything</i></h2>
<div id="text-org66c855e">
<p>
The single most valuable tool I&#39;ve found for maintaining my
orientation and sense of progress as I work through something complex
is to have a written log of everything I&#39;m trying, what&#39;s worked,
what&#39;s not, links and screenshots.
</p>


<p><img src="http://lock.cmpxchg8b.com/static/images/writeeverything.png" alt="writeeverything.png"/>
</p>
</div>


<div id="outline-container-org021ed24">
<h3 id="org021ed24">Structure</h3>
<p>
There&#39;s a certain structure that works fairly well for me; I recommend
adapting it to one that works well for you:
</p>

<div id="outline-container-org1d9edd7">
<h4 id="org1d9edd7">What&#39;s the goal?</h4>
<p>
Start by writing out the problem you&#39;re solving at the top: <i>why</i> are
you dealing with this? What do you hope to achieve?
Scrolling past the note every morning is extremely useful for
avoiding rabbit holes and focusing on the most valuable ways to
spend your time.
</p>
</div>

<div id="outline-container-orgd228cc3">
<h4 id="orgd228cc3">Open Questions</h4>
<p>
Second, I try to have a list of major open questions I want answers
to that I haven&#39;t found yet: either why a certain subsystem works a
certain way, or where I should make certain changes as
examples. This reminds me to look out for signals I would otherwise ignore.
</p>
</div>

<div id="outline-container-org8c48745">
<h4 id="org8c48745">References</h4>
<p>
Then I keep quick links to references I need to access frequently
that are related to that project; this list can become extremely
large so I&#39;d recommend keeping it to only the most important
references. The rest can live in the daily log.
</p>
</div>


<div id="outline-container-orge1dce39">
<h4 id="orge1dce39">Daily Log</h4>
<div id="text-orge1dce39">
<p>
Finally, a daily log to take notes on progress: I tend to write out
how much time I expect to have today to work on this, then the
actual work I hope to accomplish as headings. I fill this in as I go
through the day, including stack traces, observations, other TODOs
that pop up (particularly second-order tools I could build to make
all of this painless, and why-oh-why has no one else implemented it
yet).
</p>

<p>
The daily log tends to be incredibly valuable as an excellent
replacement for my memory: I can easily return to the project and
start right where I left off. It also helps maintain momentum and
understand my own progress – without concrete results or code it
can be hard to remember the sheer amount of work that goes into
ramping up on something complex or brand new.
</p>
</div>
</div>
</div>


<div id="outline-container-orgebe3988">
<h3 id="orgebe3988">Diagrams!</h3>
<div id="text-orgebe3988">
<p>
A complementary skill to build out is to build mind maps of the
code base: I strongly recommend using something electronic like
<a href="https://kinopio.club">Kinopio</a> or Scapple. That allows you to paste in links and code instead of
writing them down and can help navigate the most confusingly named of
code bases (Android, I&#39;m looking at you!).
</p>

<p>
Be <i>selective</i> about how you structure your diagram: resist the urge to
simply put every single class in – prioritize what&#39;s important and
build a map into the code base that highlights the parts that you
actually care about.
</p>

<p>
I used to lean on Scapple a <i>lot</i> while While I was working on Android:
as an experiment I&#39;d written a web-based Scapple renderer to be able
to share these: you can also pan around <a href="https://explog.in/static/scappled/index.html">the full Scapple</a>.
</p>


<p><img src="http://lock.cmpxchg8b.com/static/images/anrscapple.png" alt="anrscapple.png"/>
</p>
</div>
</div>
</div>


<div id="outline-container-org90fd15b">
<h2 id="org90fd15b">Bon Appetit!</h2>
<div id="text-org90fd15b">
<p>
Once you&#39;re finished with everything, come back to your notes
and diagrams and use them to build solid documentation for the work
you did, as well as on boarding documentation for others that come
after you – blaze a trail!
</p>

<p>
Consider fixing – or at least writing about – all the shortcomings
you experienced while you still remember the pain: one of the
super-powers of a new-joiner is that you&#39;re not affected by
&#34;It&#39;s-always-been-that-way&#34;itis, and have a chance at fixing it before
you become accustomed to the status quo as well.
</p>

<p>
I hope you find great success and build valuable things!
</p>
</div>


<div id="outline-container-org4e7f95f">
<h3 id="org4e7f95f">Comments</h3>
<div id="text-org4e7f95f">
<p>
Add your comments to this Twitter thread, or feel free to drop me an
<a href="mailto:bhalla.kunal@gmail.com">email</a>.
</p>

<blockquote data-dnt="true"><p lang="en" dir="ltr">[New Blog Post!] Recommendations on ramping up on large software projects -- or eating elephants: <a href="https://t.co/4kjK9I1zgh">https://t.co/4kjK9I1zgh</a></p>— Kunal Bhalla (@kunalbhalla) <a href="https://twitter.com/kunalbhalla/status/1561404718932721664?ref_src=twsrc%5Etfw">August 21, 2022</a></blockquote>  

</div>
</div>

<div id="outline-container-org05a579c">
<h3 id="org05a579c">Updates</h3>
<div id="text-org05a579c">
<ul>
<li>2021-08-21: Removing the &#34;DRAFT&#34; title, but I&#39;d still like to
continue editing and revising.</li>
</ul>
</div>
</div>
</div>
</div></div>
  </body>
</html>
