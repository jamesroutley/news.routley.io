<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maxwellrules.com/programming/rusty-python.html">Original</a>
    <h1>Extending Python with Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
    <h2>Extending Python with Rust</h2>

    <p>Sometimes a pure Python script can&#39;t just deliver the performance we need. When
that&#39;s the case we have to resort to writing our logic in a &#34;fast&#34; compiled
language like C or Rust and expose the function with through a Python module.
This way we get the best of both worlds.  Today I focus on how to use Rust for
writing such extensions. I choose Rust over C because it is just nicer to use
and less of a minefield of gotchas waiting for you trip them. Also, since as a
data scientist I spend spend most of the time manipulating Numpy arrays so I
will focus on how to pass them and return them from Rust. To accomplish this
I&#39;ll make use of the <a href="https://github.com/PyO3/pyo3">PyO3</a> and
<a href="https://github.com/PyO3/rust-numpy">Numpy</a> crates.</p>
<p>The code has been borrowed from the
<a href="https://github.com/PyO3/rust-numpy/blob/master/examples/simple-extension/src/lib.rs"><code>rust-numpy</code></a>
examples and it is just to showcase how to write Rust extensions.</p>
<h2>Setup</h2>
<p>In order to get through the following steps you will need to have the <a href="https://doc.rust-lang.org/book/ch01-01-installation.html#installation">Rust
toolchain</a>
and <a href="https://github.com/pyenv/pyenv">pyenv</a> installed.</p>
<p>Let&#39;s start by creating a virtual environment with all the necessary
dependencies and a new Rust library. Our Python dependencies are:</p>
<ul>
<li>Numpy</li>
<li><a href="https://github.com/PyO3/maturin">Maturin</a>: To help with the building process
  of the Rust library.</li>
</ul>
<pre><code>cargo new --lib Rumpy

# Prep virtualenv, Python must be &gt;=3.6
pyenv virtualenv 3.8.5 Rumpy
pyenv activate Rumpy
python -m pip install --upgrade pip
pip install numpy maturin
</code></pre>

<p>Next, to configure our Rust project we update the <code>Cargo.toml</code> file with the
followig dependencies. The name for <code>lib</code> has to match both what we will define
in the Rust code and the name used in <code>import</code> clauses from Python.</p>
<pre><code>[lib]
name = &#34;rust_ext&#34;
crate-type = [&#34;cdylib&#34;]

[dependencies]
numpy = &#34;0.13&#34;
ndarray = &#34;0.14&#34;

[dependencies.pyo3]
version = &#34;0.13&#34;
features = [&#34;extension-module&#34;]
</code></pre>

<p>With all that ready lets have a look at the actual code.</p>
<h2>The library</h2>
<p>The library will provide two simple examples. The first one, <code>axpy</code>, multiplies
an array by a scalar value and adds it to a second array. Our other function,
<code>mult</code>, just multiplies an array by a scalar. </p>
<pre data-src="../code_samples/rumpy.rs"></pre>

<p>First we annotate the function that will ultimately represent the Python module
with the <code>#[pymodule]</code> annotation. This function must takes <code>_py</code> which shows
that we&#39;re holding the GILboth and the module itself. This macro takes of exporting
the initialization function of the module.</p>
<p>When defining functions we will first define the logic that carries out the
function logic, in this case <code>axpy</code> and <code>mult</code>, together with wrapper functions
,<code>axpy_py</code> and <code>mult_py</code>. The wrapper functions which eventually get exported
must be annotated as <code>#[pyfn(m, &#34;axpy&#34;)]</code>. The first argument of the annotation
is the Python module that was passed to the &#34;module&#34; function and the second
one, the name that the exported function will take. This will register the
functions to the module. More details on the details of the PyO3 annotations
can be found on its <a href="https://pyo3.rs/v0.13.1">documentation</a>.</p>
<p>Compilation is as simple as running:</p>
<pre><code>maturin develop --release
</code></pre>

<p>This will take care of compiling the module with optimizations turned on and install
it on your env so you can immediately test it.</p>
<h2>Benchmarks</h2>
<p>Finally, lets do some simple benchmarks to see how well does the Rust
implementation compare against both the natural Numpy solution and a naive
Python implementation. We are just interested on a quick check so the IPython
<code>%%timeit</code> magic is enough here. The IPython session would look something like
this.</p>
<center>
  <img src="https://maxwellrules.com/images/rumpy_benchmark_session.png" height="400" alt="Rumpy Vs Numpy benchmark"/> </center>
<center>
  <img src="https://maxwellrules.com/images/rumpy_benchmark.png" height="300" alt="Rumpy Vs Numpy benchmark"/> </center>
<p>As expected the pure Python implementation is comically slow and won&#39;t be
considered futher. What&#39;s more interesting is that the Rust implementation is
just a factor of 1.23 slower (for large arrays) than just using Numpy. Using
PyO3 apparently introduces zero overhead and for smaller inputs the Rust
implementation was actually marginally faster than Numpy.  In exchange for a
slight loss in performance we get code that reads exactly as the Numpy
implementation and with stronger guarantees about correctness than if we had
written a C algorithm using CFFI.</p>
<p>Of course, you would never go down the route of writing a compiled extension
when the algorithm can be expressed so simply using vectorized Numpy
operations.  However, when writing more complex logic and algorithms that can&#39;t
be simply expressed with Numpy ops I am willing to take the tradeoff a small
(relatively speaking) overhead in exchange for a modern programming language
which is both nicer to use and more secure than C when writing Python
extensions.</p>
<h2>Farewells</h2>
<p>On future blog posts I will explore other alternatives to accelerate Python code such
as: cython, numba, async programming and the multiprocessing library. Stay tuned!!!</p>
</div>
  </div></div>
  </body>
</html>
