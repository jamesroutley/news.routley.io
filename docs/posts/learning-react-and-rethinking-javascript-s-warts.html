<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://moerner.com/posts/rethinking-js-react/">Original</a>
    <h1>Learning React and Rethinking JavaScript&#39;s Warts</h1>
    
    <div id="readability-page-1" class="page"><section><p>There are many ways to do the same thing in every popular programming language,
but not all of them are made equal. (I presume this is a corollary of Turing
completeness.) This is why it is so
important when learning a new language to get a grip on common patterns and
<a href="https://en.wikipedia.org/wiki/Anti-pattern">anti-patterns</a>. Otherwise we risk
making the wrong choices (like assuming that tail recursion is always the optimal
recursive algorithm even though with small inputs the time costs of reversing the result may be larger than
the benefits in space complexity), or being paralyzed by the thought of too
many choices (like I felt when I learned the Node <code>fs</code> module provides <a href="https://nodejs.org/en/learn/manipulating-files/reading-files-with-nodejs">three
interfaces</a>
that all do the same thing).</p>
<p>I’ve spent the last three days starting to learn <a href="https://react.dev/">React</a>,
and I want to trace out how this has already led me to question some of my
older assumptions about warts and anti-patterns in JavaScript.</p>
<p>JavaScript’s flexibility and overall messiness is well-known. It’s now been
<em>seventeen years</em> since the publication of the aptly-named <a href="https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742">JavaScript: The Good Parts</a>. And on the top of the list of the “Awful Parts” of JavaScript is the reliance on global variables (p. 101). Learning patterns to avoid global variables is one of my defining memories of learning JavaScript. Many of these patterns center around retaining state through the use of local variables in functions, closures, callbacks, and factory functions. For example, you might use a closure to create a counter:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span><span>function</span> <span>createCounter</span>() {
</span></span><span><span>    <span>let</span> <span>count</span> <span>=</span> <span>0</span>;
</span></span><span><span>    <span>return</span> () =&gt; <span>++</span><span>count</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>Or you might use a factory function to keep track of state in objects:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span><span>function</span> <span>createUser</span>(<span>name</span>) {
</span></span><span><span>    <span>let</span> <span>winCount</span> <span>=</span> <span>0</span>;
</span></span><span><span>    <span>const</span> <span>getWin</span> <span>=</span> () =&gt; <span>winCount</span>;
</span></span><span><span>    <span>const</span> <span>giveWin</span> <span>=</span> () =&gt; <span>winCount</span><span>++</span>;
</span></span><span><span>
</span></span><span><span>    <span>return</span> { <span>name</span>, <span>getWin</span>, <span>giveWin</span> };
</span></span><span><span>}
</span></span></code></pre></div><p>You can even combine these patterns to build a factory function which assigns
self-incrementing id’s to new objects, as in this old <a href="https://stackoverflow.com/a/33554882">StackOverflow
answer</a>.</p>
<p>Coming from this background, I had the following impression: Support for global
variables is one of the worst “features” of JavaScript, but there is ample
support for an alternative set of patterns which rely on using local state
abstracted inside function expressions.</p>
<p>I felt like my world was turned upside down when I saw that patterns like this
do not work in React:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span><span>export</span> <span>default</span> <span>function</span> <span>Button</span>() {
</span></span><span><span>  <span>let</span> <span>index</span> <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span>  <span>function</span> <span>handleClick</span>() {
</span></span><span><span>    <span>index</span> <span>=</span> <span>index</span> <span>+</span> <span>1</span>;
</span></span><span><span>  }
</span></span><span><span>
</span></span><span><span>  <span>return</span> (
</span></span><span><span>    <span>&lt;</span><span>button</span> <span>onClick</span><span>=</span>{<span>handleClick</span>}<span>&gt;</span><span>Count</span> {<span>index</span>}<span>&lt;</span><span>/button&gt;</span>
</span></span><span><span>  );
</span></span><span><span>}
</span></span></code></pre></div><p>In React, each component is recreated on re-render, so each click recreates the
<code>index</code> variable and re-initializes it at zero. In a case like this, React is smart enough to
not actually change the DOM, because it recognizes that there is no difference
between the newly rendered virtual DOM and the current DOM. To achieve a button
counter, React offers the <code>useState</code> hook instead (<a href="https://react.dev/learn/state-a-components-memory)">https://react.dev/learn/state-a-components-memory)</a>.</p>
<p>It was fairly easy to understand why this doesn’t work in React, but it was
harder for me to fit this into my broader understanding of JavaScript. It
almost felt like React was not a JavaScript library, but rather an entirely
different language with an entirely different set of patterns. What’s going on
here?</p>
<p>Here’s the answer that has satisfied me for now: Part of the core paradigm for
React is to bring immutability to JavaScript. Components are not modified, they
are re-created (re-rendered). Insofar as state is necessary, it must be
carefully and explicitly managed with the use of hooks.</p>
<p>Why is immutability so valuable? Because JavaScript is a language built
for asynchronous coding. Blocking, synchronous code is unacceptable when
users expect their browser to remain responsive while JavaScript code is
running. Side effects and mutability make asynchronous code much more difficult
to manage. There are also performance benefits, because objects that are
immutable can share their shared state via pointer without risk. This is why
the React virtual DOM used for
<a href="https://medium.com/javarevisited/react-reconciliation-algorithm-86e3e22c1b40">reconciliation</a>
is so lightweight and can be (or arguably, for access to pointers, must be)
stored in memory.</p>
<p>Seen from this perspective, “Global variables are bad” is no longer at the core
of the warts of JavaScript. The (ab)use of global variables is actually only an
instance of a deeper problem: “There is a fundamental challenge making performant code that simultaneously involves mutability and async”. I believe that this is
the deeper problem in JavaScript which React is designed to give us better patterns to handle. And this is what starting to learn React has taught me about JavaScript.</p>
<p>Thank you to Luisa Vasquez, Michelle Bernstein, and Pete Vilter for discussing
some of these topics with me in the <a href="https://www.recurse.com/">Recurse Center</a> web
development working group.</p>
</section></div>
  </body>
</html>
