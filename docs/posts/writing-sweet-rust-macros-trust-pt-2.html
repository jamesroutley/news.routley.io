<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://angelolloti.com/blog/trust-2">Original</a>
    <h1>Writing Sweet Rust Macros (trust pt. 2)</h1>
    
    <div id="readability-page-1" class="page"><div>   <div><div> <p><a href="https://angelolloti.com/blog/?tag=macros">macros</a><span>, </span><a href="https://angelolloti.com/blog/?tag=rust">rust</a><span>, </span><a href="https://angelolloti.com/blog/?tag=trust">trust</a><span></span></p><!-- HTML_TAG_START --><p>There is something I haven&#39;t told you yet about trust in <a href="https://angelolloti.com/blog/trust-1">part 1</a>. It is actually a project that I had thought of 2 years ago. Back then, I wanted to do the same thing as what I&#39;m doing now, but I quit once I realized the actual scale of this project. As it turns out, this isn&#39;t an easy project. At the beginning, I found it strange that the Terraria server is just a headless client (meaning the server treats itself as an &#34;invisible&#34; player in the server). After really thinking about it, it makes plenty of sense. All of the game logic (mob spawning, water flowing, entity interactions) have to be fired off by some central authority — the server — and this means we need Terraria&#39;s logic, spawn rates, etc. all in our code. This is definitely a lot to implement and what halted my progress the first time. To put it short, I felt like I was about to open Pandora&#39;s box. I didn&#39;t like that feeling of uncertainty and rather than even begin to start, I gave up then and there. Alas, we are back and my mentality has greatly shifted since then.</p>
<blockquote>
<p>The struggle itself towards the heights is enough to fill a man&#39;s heart. One must imagine Sisyphus happy.</p>
</blockquote>
<h2>Why a Macro?</h2>
<p>Ok, so we have a fairly structured network protocol at this point. Each packet is structured like so.</p>
<table>
<thead>
<tr>
<th>field</th>
<th>type</th>
<th>length</th>
</tr>
</thead>
<tbody><tr>
<td>len</td>
<td>u16</td>
<td>2</td>
</tr>
<tr>
<td>code</td>
<td>u8</td>
<td>1</td>
</tr>
<tr>
<td>msg</td>
<td>bytes</td>
<td>len-3</td>
</tr>
</tbody></table>
<p>Depending on <code>code</code>, <code>msg</code> may contain certain fields. For instance, if <code>code</code> is 3, we have a connection approval message whose fields are contained in <code>msg</code> like so.</p>
<table>
<thead>
<tr>
<th>field</th>
<th>type</th>
<th>length</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>u8</td>
<td>1</td>
</tr>
<tr>
<td>flag</td>
<td>bool</td>
<td>1</td>
</tr>
</tbody></table>
<p><code>id</code> represents the ID that the server assigns the user and <code>flag</code> seems to represent a flag called <code>ServerWantsToRunCheckBytesInClientLoopThread</code>. If this is true, the client calls <code>NetMessage.CheckBytes()</code> inside <code>Main.InnerClientLoop()</code>. Don&#39;t ask me... all I know is that this is hardcoded to be <code>false</code> every time.</p>
<p>Let&#39;s take another example. If <code>code</code> is 5 and client-sent, the client is updating the server about a particular slot in their inventory. If <code>code</code> is 5 and broadcasted by the server, the server is notifying all players of a change in a player&#39;s inventory. <em>Note: internally, an inventory represents all a players items including their armor, dyes, pets, mounts, etc. Not just the items in the top left of their escape menu.</em></p>
<table>
<thead>
<tr>
<th>field</th>
<th>type</th>
<th>length</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>u8</td>
<td>1</td>
</tr>
<tr>
<td>slot_id</td>
<td>i16</td>
<td>2</td>
</tr>
<tr>
<td>amount</td>
<td>i16</td>
<td>2</td>
</tr>
<tr>
<td>prefix</td>
<td>u8</td>
<td>1</td>
</tr>
<tr>
<td>item_id</td>
<td>i16</td>
<td>2</td>
</tr>
</tbody></table>
<p>You get the gist? Anyway, my goal was to be able to write a Rust enum representing each packet so we can use <code>match</code>. I also want it to be aware of the code of each packet to automatically parse and encode it. In the doc comment, I put the packet&#39;s code. Also, let&#39;s not create the read method for server-only packets and write for client-only packets. In the doc comment, <code>-&gt;</code> means send-only, <code>&lt;-</code> means receive-only, and <code>&lt;-&gt;</code> means bidirectional. That would mean our macro should be able to convert this.</p>
<pre><code><span>#[our_cool_proc_macro]</span>
<span>pub</span> <span>enum</span> <span>Message</span>&lt;<span>&#39;a</span>&gt; {
    
    ConnectionApprove {
        client_id: <span>u8</span>,
        flag: <span>bool</span>,
    },
    
    PlayerInventorySlot {
        client_id: <span>u8</span>,
        slot_id: <span>i16</span>,
        amount: <span>i16</span>,
        prefix: <span>u8</span>,
        item_id: <span>i16</span>,
    },
}
</code></pre><p>into this</p>
<pre><code><span>pub</span> <span>struct</span> <span>ConnectionApprove</span> {
    <span>pub</span> client_id: <span>u8</span>,
    <span>pub</span> flag: <span>bool</span>,
}

<span>pub</span> <span>struct</span> <span>PlayerInventorySlot</span> {
    <span>pub</span> client_id: <span>u8</span>,
    <span>pub</span> slot_id: <span>i16</span>,
    <span>pub</span> amount: <span>i16</span>,
    <span>pub</span> prefix: <span>u8</span>,
    <span>pub</span> item_id: <span>i16</span>,
}

<span>#[our_cool_proc_macro]</span>
<span>pub</span> <span>enum</span> <span>Message</span>&lt;<span>&#39;a</span>&gt; {
    <span>ConnectionApprove</span>(ConnectionApprove),
    <span>PlayerInventorySlot</span>(PlayerInventorySlot),
    <span>Unknown</span>(<span>u8</span>, &amp;<span>&#39;a</span> [<span>u8</span>]),
}



<span>fn</span> <span>buffer_to_message</span>(buf: &amp;[<span>u8</span>]) <span>-&gt;</span> Message {
    <span>let</span> <span>r</span> = Reader::<span>new</span>(buf); 
    <span>let</span> <span>code</span> = r.<span>read_byte</span>();
    <span>match</span> code {
        <span>5</span> =&gt; Message::<span>PlayerInventorySlot</span>(PlayerInventorySlot {
            client_id: r.<span>read_byte</span>(),
            slot_id: r.<span>read_i16</span>(),
            amount: r.<span>read_i16</span>(),
            prefix: r.<span>read_byte</span>(),
            item_id: r.<span>read_i16</span>(),
        }),
        _ =&gt; Message::<span>Unknown</span>(code, &amp;buf[<span>1</span>..])
    }
}

<span>fn</span> <span>message_to_buffer</span>(msg: Message) <span>-&gt;</span> &amp;[<span>u8</span>] {
    <span>match</span> Message {
        Message::<span>ConnectionApprove</span>(ca) =&gt; {
            <span>let</span> <span>w</span> = Writer::<span>new</span>(<span>3</span>);
            w.<span>write_byte</span>(client_id);
            w.<span>write_bool</span>(flag);
            w.<span>finalize</span>() 
        }
        Message::<span>PlayerInventorySlot</span>(slot) =&gt; {
            <span>let</span> <span>w</span> = Writer::<span>new</span>(<span>5</span>);
            w.<span>write_byte</span>(slot.client_id);
            w.<span>write_i16</span>(slot.slot_id);
            w.<span>write_i16</span>(slot.amount);
            w.<span>write_byte</span>(slot.prefix);
            w.<span>write_i16</span>(slot.item_id);
            w.<span>finalize</span>()
        }
        _ =&gt; Message::<span>Unknown</span>(code, &amp;buf[<span>1</span>..])
    }
}
</code></pre><p>In case you&#39;re wondering why I don&#39;t want to write the structs outside of the enum myself, it&#39;s because if I do, then this macro will be much more complicated as it won&#39;t just be completely contained within one enum.</p>
<h2>Binary Reader and Writer</h2>
<p>For starters, let&#39;s implement our <code>Reader</code> and <code>Writer</code>. Our reader will look like this,</p>
<pre><code><span>impl</span>&lt;<span>&#39;a</span>&gt; Reader&lt;<span>&#39;a</span>&gt; {
    <span>pub</span> <span>fn</span> <span>new</span>(buf: &amp;<span>&#39;a</span> [<span>u8</span>]) <span>-&gt;</span> <span>Self</span> {
        <span>Self</span> { buf, cur: <span>0</span> }
    }

    <span>pub</span> <span>fn</span> <span>read_bytes</span>(&amp;<span>mut</span> <span>self</span>, amount: <span>usize</span>) <span>-&gt;</span> &amp;[<span>u8</span>] {
        <span>self</span>.cur += amount;
        &amp;<span>self</span>.buf[(<span>self</span>.cur - amount)..<span>self</span>.cur]
    }

    <span>pub</span> <span>fn</span> <span>read_byte</span>(&amp;<span>mut</span> <span>self</span>, amount: <span>usize</span>) <span>-&gt;</span> <span>u8</span> {
        <span>self</span>.<span>read_bytes</span>(<span>1</span>)[<span>0</span>]
    }

    <span>pub</span> <span>fn</span> <span>read_i16</span>(&amp;<span>mut</span> <span>self</span>) <span>-&gt;</span> <span>i16</span> {
        <span>i16</span>::<span>from_le_bytes</span>(<span>self</span>.<span>read_bytes</span>(<span>2</span>).<span>try_into</span>().<span>unwrap</span>())
    }

    
}
</code></pre><p>and our writer will look like this,</p>
<pre><code><span>impl</span> <span>Writer</span> {
    <span>pub</span> <span>fn</span> <span>new</span>(code: <span>u8</span>) <span>-&gt;</span> <span>Self</span> {
        <span>Self</span> { buf: <span>vec!</span>[<span>0</span>, <span>0</span>, code] } 
    }

    
    <span>pub</span> <span>fn</span> <span>finalize</span>(<span>mut</span> <span>self</span>) <span>-&gt;</span> <span>Vec</span>&lt;<span>u8</span>&gt; {
        <span>let</span> [a, b] = (<span>self</span>.buf.<span>len</span>() <span>as</span> <span>u16</span>).<span>to_le_bytes</span>(); 
        <span>self</span>.buf[<span>0</span>] = a; 
        <span>self</span>.buf[<span>1</span>] = b;
        <span>self</span>.buf
    }

    <span>pub</span> <span>fn</span> <span>write_bytes</span>(<span>mut</span> <span>self</span>, bytes: &amp;[<span>u8</span>]) <span>-&gt;</span> <span>Self</span> {
        <span>self</span>.buf.<span>append</span>(&amp;<span>mut</span> bytes.<span>to_vec</span>());
        <span>self</span>
    }

    <span>pub</span> <span>fn</span> <span>write_byte</span>(<span>mut</span> <span>self</span>, byte: <span>u8</span>) <span>-&gt;</span> <span>Self</span> {
        <span>self</span>.buf.<span>push</span>(byte);
        <span>self</span>
    }

    <span>pub</span> <span>fn</span> <span>write_i16</span>(<span>self</span>, num: <span>i16</span>) <span>-&gt;</span> <span>Self</span> {
        <span>self</span>.<span>write_bytes</span>(&amp;num.<span>to_le_bytes</span>())
    }

    
}
</code></pre><p>Makes sense? I&#39;m just trying to get through this quickly since this is mostly boilerplate for the real difficulty which is writing a procedural macro.</p>
<p>As per The Rust Reference,</p>
<blockquote>
<p>Procedural macros allow you to run code at compile time that operates over Rust syntax, both consuming and producing Rust syntax. You can sort of think of procedural macros as functions from an AST to another AST.</p>
</blockquote>
<h2>Set Up a Project for the Macro</h2>
<p>So, we want to parse the AST and generate our own AST. Let&#39;s create a new cargo project called macros (<code>cargo init macros --lib</code>) and include in our main project (which actually hasn&#39;t been established yet) by adding <code>macros = { path = &#34;macros&#34; }</code> to <code>Cargo.toml</code>. In the <code>macros</code> project, we want to add this to <code>Cargo.toml</code>.</p>
<pre><code><span>[dependencies]</span>
<span>syn</span> = { version = <span>&#34;2.0&#34;</span>, features = [<span>&#34;full&#34;</span>] }
<span>proc-macro2</span> = <span>&#34;1.0&#34;</span>
<span>quote</span> = <span>&#34;1.0&#34;</span>

<span>[lib]</span>
<span>proc-macro</span> = <span>true</span>
</code></pre><p><a href="https://docs.rs/syn/latest/syn/">syn</a>, <a href="https://docs.rs/proc-macro2/latest/proc_macro2/">proc-macro2</a>, and <a href="https://docs.rs/quote/latest/quote/">quote</a> seem to be the essentials for creating a proc macro. We want to replace our primary enum with a new enum, more structs, and some <code>impl</code>s. To do this replacement, we use an attribute macro. To get started using an attribute macro, we write the method as follows.</p>
<pre><code><span>#[proc_macro_attribute]</span>
<span>pub</span> <span>fn</span> <span>message_encoder_decoder</span>(_: TokenStream, input: TokenStream) <span>-&gt;</span> TokenStream {
    
}
</code></pre><p>Now what? For simplicity&#39;s sake, I&#39;ll just be talking about the sending half of this macro. The code for the receiving half is predictably similar. Let&#39;s use syn to create a syntax tree from this token stream. To do that, we can do this.</p>
<pre><code><span>let</span> <span>input</span> = parse_macro_input!(input <span>as</span> ItemEnum);
</code></pre><p>Now, let&#39;s start to build the that <code>match</code> statement that we had talked about earlier. To do this, let&#39;s store all the cases and finally construct the <code>match</code> inside of a <code>TryFrom</code>.</p>
<pre><code><span>let</span> <span>mut </span><span>cases</span> = <span>Vec</span>::<span>new</span>();

<span>for</span> <span>variant</span> <span>in</span> input.variants {
    <span>let</span> <span>name</span> = variant.ident;
    
    <span>if</span> name.<span>to_string</span>() == <span>&#34;Unknown&#34;</span> {
        <span>continue</span>;
    }

    
    <span>let</span> <span>doc</span> = variant.attrs.<span>first</span>().<span>unwrap</span>().<span>span</span>().<span>source_text</span>().<span>unwrap</span>();
    
    <span>if</span> !doc.<span>contains</span>(<span>&#34;-&gt;&#34;</span>) {
        <span>continue</span>;
    }

    
    <span>let</span> <span>code</span>: <span>u8</span> = doc.<span>split_whitespace</span>().<span>skip</span>(<span>1</span>).<span>next</span>().<span>unwrap</span>().<span>parse</span>().<span>unwrap</span>();
}
</code></pre><p>In rust there are three kinds of enum variant fields, <code>Named</code>, <code>Unnamed</code>, and <code>Unit</code>. Named means that the variant contains named fields (i.e. <code>X { a: i32, b: f64 }</code>). Unnamed means that the variant is represented by a tuple (i.e. <code>Y(i32, f64, bool)</code>). <code>Unit</code> means the variant doesn&#39;t store any values (i.e. <code>None</code>). For now, we only have <code>Named</code> fields so let&#39;s deal with that.</p>
<pre><code><span>for</span> <span>variant</span> <span>in</span> input.variants {
    

    <span>if</span> <span>let</span> <span>Fields</span>::<span>Named</span>(field) = variant.fields {
        
        <span>let</span> <span>mut </span><span>fns</span> = <span>Vec</span>::<span>new</span>();

        
        <span>for</span> <span>field</span> <span>in</span> fields.named {
            <span>let</span> <span>name</span> = field.ident.<span>as_ref</span>().<span>unwrap</span>();
            <span>if</span> <span>let</span> <span>Type</span>::<span>Path</span>(ty) = &amp;field.ty {
                
                <span>let</span> <span>method</span> = <span>match</span> ty.path.segments.<span>first</span>().<span>unwrap</span>().ident.<span>to_string</span>().<span>as_str</span>() {
                    <span>&#34;bool&#34;</span> =&gt; quote! { .<span>write_bool</span>(data.#name) },
                    <span>&#34;u8&#34;</span> =&gt; quote! { .<span>write_byte</span>(data.#name) },
                    <span>&#34;i16&#34;</span> =&gt; quote! { .<span>write_i16</span>(data.#name) },
                    ty =&gt; quote! { compile_error!(<span>&#34;Unknown type: {}&#34;</span>, #ty) },
                }
                
                fns.<span>push</span>(method)
            }
        }

        
        cases.<span>push</span>(quote! { Message::#<span>name</span>(data) =&gt; <span>Ok</span>(Writer::<span>new</span>(#code)#(#fns)*.<span>finalize</span>()) })
    }
}
</code></pre><p>Cool. What is <code>quote!</code> doing, you may ask. It is taking the Rust code and converting it into a token stream. We now have our cases for each server-sent packet. Let&#39;s finally wrap them up in a match statement and get this show on the road. After our for loop, we are going to have this.</p>
<pre><code><span>let</span> <span>sendable_from</span> = TokenStream::<span>from</span>(quote! {
    <span>impl</span>&lt;<span>&#39;a</span>&gt; TryFrom&lt;Message&lt;<span>&#39;a</span>&gt;&gt; <span>for</span> <span>Vec</span>&lt;<span>u8</span>&gt; {
        <span>type</span> <span>Error</span> = &amp;<span>&#39;static</span> <span>str</span>;

        <span>fn</span> <span>try_from</span>(msg: Message) <span>-&gt;</span> <span>Result</span>&lt;<span>Self</span>, <span>Self</span>::Error&gt; {
            <span>match</span> msg {
                #(#cases),*, 
                
                Message::<span>Unknown</span>(code, buf) =&gt; <span>Ok</span>(Writer::<span>new</span>(code).<span>write_bytes</span>(buf).<span>finalize</span>()),
                _ =&gt; <span>Err</span>(<span>&#34;Unserializable message. Consider using Message::Unknown&#34;</span>),
            }
        }
    }
});
</code></pre><p>At this point, we are pretty much done. We just have to take our named fields and convert them to unnamed fields with the struct defined somewhere else. The rest of the code is just this.</p>
<pre><code><span>let</span> <span>mut </span><span>structs</span> = <span>Vec</span>::<span>new</span>();
<span>let</span> <span>mut </span><span>variants</span> = <span>Vec</span>::<span>new</span>();

<span>for</span> <span>variant</span> <span>in</span> input.variants {
    <span>if</span> <span>let</span> <span>Fields</span>::<span>Named</span>(fields) = variant.fields {
        <span>let</span> <span>fields</span> = fields.named.<span>iter</span>().<span>map</span>(|e| {
            <span>let</span> <span>ident</span> = &amp;e.ident;
            <span>let</span> <span>ty</span> = &amp;e.ty;
            quote!{ <span>pub</span> #ident: #ty }
        }); 
        <span>let</span> <span>name</span> = variant.ident; 
        structs.<span>push</span>(quote! {
            <span>#[derive(Debug, Clone)]</span>
            
            <span>pub</span> <span>struct</span> #name {
                #(#fields),*
            }
        });
        variants.<span>push</span>(quote! { #<span>name</span>(#name) }) 
    } <span>else</span> {
        variants.<span>push</span>(quote! { #variant }) 
    }
}

TokenStream::<span>from</span>(quote! {
    #(#structs)* 
    <span>#[derive(Debug, Clone)]</span>
    <span>pub</span> <span>enum</span> <span>Message</span>&lt;<span>&#39;a</span>&gt; {
        #(#variants),* 
    }
    #sendable_from 
})
</code></pre><p>There is, of course, much more to this. There are more types besides u8, i16, and bool. There&#39;s also more code for handling the client-sent readable packets. All of that is pretty much just doing what we did here but slightly differently. If you are interested in the full code for the <a href="https://github.com/xDimGG/trust/blob/main/macros/src/lib.rs">macro</a>, the <a href="https://github.com/xDimGG/trust/blob/main/src/binary/reader.rs">reader</a>, and the <a href="https://github.com/xDimGG/trust/blob/main/src/binary/writer.rs">writer</a>, it&#39;s all in the <a href="https://github.com/xDimGG/trust">repository</a>.</p>
<h2>Closing Notes</h2>
<p>Macro code can be hard to understand. I created this macro two years ago, and when I came back to it, I couldn&#39;t believe that I wrote it. The whole thing just seemed like gibberish. As a matter of fact, I had no intention to even touch the macro! However, when I tried compiling this project that I haven&#39;t touched in two years with a modern version of Rust, I received the following error.</p>
<pre><code>error[E0512]: cannot transmute between types of different sizes, or dependently-sized types
   --&gt; C:\Users\Dim\.cargo\registry\src\index.crates.io-6f17d22bba15001f\socket2-0.3.12\src\sockaddr.rs:176:9
    |
176 |         mem::transmute::&lt;SocketAddrV4, sockaddr_in&gt;(v4);
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: source type: `SocketAddrV4` (48 bits)
    = note: target type: `SOCKADDR_IN` (128 bits)

For more information about this error, try `rustc --explain E0512`.
</code></pre><p>After a Google search, <a href="https://users.rust-lang.org/t/error-compiling-old-rust-project/83840">this error</a> meant that one of my dependencies is outdated. That dependency turned out to be syn. I was on v1 and needed v2. I upgraded syn to v2, only to find out that the API has slightly changed so some lines were erroring. Because of that, I more or less had to re-understand my entire macro code again, which I really didn&#39;t want to do. Anyway, I did that and fixed it.</p>
<p>However, this got me to thinking. Is there a way I could have made this code more readable? Well, not really. I think proc macros are generally quite hard to read without comments. I could and should probably add a bunch of comments to the code so that when future me has to re-visit this, he&#39;ll at least have a clue of what&#39;s going on... nahhh. Comments are for chumps.</p>
<p>Anyway, that&#39;s all for now. Until we meet again in <a href="https://angelolloti.com/blog/trust-3">part 3</a>.</p>
<!-- HTML_TAG_END --></div></div> 
			
			
		</div></div>
  </body>
</html>
