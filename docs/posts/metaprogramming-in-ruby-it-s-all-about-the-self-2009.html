<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yehudakatz.com/2009/11/15/metaprogramming-in-ruby-its-all-about-the-self/">Original</a>
    <h1>Metaprogramming in Ruby: It&#39;s All About the Self (2009)</h1>
    
    <div id="readability-page-1" class="page"><div>
        <!--kg-card-begin: markdown--><p>After writing my last post on Rails plugin idioms, I realized that Ruby metaprogramming, at its core, is actually quite simple.</p>
<p>It comes down to the fact that all Ruby code is executed code--there is no separate compile or runtime phase. In Ruby, every line of code is executed against a particular <code>self</code>. Consider the following five snippets:</p>
<pre><code>class Person
  def self.species
    &#34;Homo Sapien&#34;
  end
end

class Person
  class &lt;&lt; self
    def species
      &#34;Homo Sapien&#34;
    end
  end
end

class &lt;&lt; Person
  def species
    &#34;Homo Sapien&#34;
  end
end

Person.instance_eval do
  def species
    &#34;Homo Sapien&#34;
  end
end

def Person.species
  &#34;Homo Sapien&#34;
end
</code></pre>
<p>All five of these snippets define a <code>Person.species</code> that returns <code>Homo Sapien</code>. Now consider another set of snippets:</p>
<pre><code>class Person
  def name
    &#34;Matz&#34;
  end
end

Person.class_eval do
  def name
    &#34;Matz&#34;
  end
end
</code></pre>
<p>These snippets all define a method called <code>name</code> on the Person class. So <code>Person.new.name</code> will return &#34;Matz&#34;. For those familiar with Ruby, this isn&#39;t news. When learning about metaprogramming, each of these snippets is presented in isolation: another mechanism for getting methods where they &#34;belong&#34;. In fact, however, there is a single unified reason that all of these snippets work the way they do.</p>
<p>First, it is important to understand how Ruby&#39;s metaclass works. When you first learn Ruby, you learn about the concept of the class, and that each object in Ruby has one:</p>
<pre><code>class Person
end

Person.class #=&gt; Class

class Class
  def loud_name
    &#34;#{name.upcase}!&#34;
  end
end

Person.loud_name #=&gt; &#34;PERSON!&#34;
</code></pre>
<p><code>Person</code> is an instance of <code>Class</code>, so any methods added to <code>Class</code> are available on <code>Person</code> as well. What they don&#39;t tell you, however, is that each object in Ruby also has its own <strong>metaclass</strong>, a <code>Class</code> that can have methods, but is only attached to the object itself.</p>
<pre><code>matz = Object.new
def matz.speak
  &#34;Place your burden to machine&#39;s shoulders&#34;
end
</code></pre>
<p>What&#39;s going on here is that we&#39;re adding the <code>speak</code> method to <code>matz</code>&#39;s <strong>metaclass</strong>, and the <code>matz</code> object inherits from its <strong>metaclass</strong> and then <code>Object</code>. The reason this is somewhat less clear than ideal is that the metaclass is invisible in Ruby:</p>
<pre><code>matz = Object.new
def matz.speak
  &#34;Place your burden to machine&#39;s shoulders&#34;
end

matz.class #=&gt; Object
</code></pre>
<p>In fact, <code>matz</code>&#39;s &#34;class&#34; is its invisible metaclass. We can even get access to the metaclass:</p>
<pre><code>metaclass = class &lt;&lt; matz; self; end
metaclass.instance_methods.grep(/speak/) #=&gt; [&#34;speak&#34;]
</code></pre>
<p>At this point in other articles on this topic, you&#39;re probably struggling to keep all of the details in your head; it seems as though there are so many rules. And what&#39;s this <code>class &lt;&lt; matz</code> thing anyway?</p>
<p>It turns out that all of these weird rules collapse down into a single concept: control over the <code>self</code> in a given part of the code. Let&#39;s go back and take a look at some of the snippets we looked at earlier:</p>
<pre><code>class Person
  def name
    &#34;Matz&#34;
  end
  
  self.name #=&gt; &#34;Person&#34;
end
</code></pre>
<p>Here, we are adding the <code>name</code> method to the <code>Person</code> class. Once we say <code>class Person</code>, the <code>self</code> until the end of the block is the <code>Person</code> class itself.</p>
<pre><code>Person.class_eval do
  def name
    &#34;Matz&#34;
  end

  self.name #=&gt; &#34;Person&#34;
end
</code></pre>
<p>Here, we&#39;re doing exactly the same thing: adding the <code>name</code> method to instances of the Person class. In this case, <code>class_eval</code> is setting the <code>self</code> to <code>Person</code> until the end of the block. This is all perfectly straight forward when dealing with classes, but it&#39;s equally straight forward when dealing with metaclasses:</p>
<pre><code>def Person.species
  &#34;Homo Sapien&#34;
end

Person.name #=&gt; &#34;Person&#34;
</code></pre>
<p>As in the <code>matz</code> example earlier, we are defining the <code>species</code> method on <code>Person</code>&#39;s metaclass. We have not manipulated <code>self</code>, but you can see using <code>def</code> with an object attaches the method to the object&#39;s metaclass.</p>
<pre><code>class Person
  def self.species
    &#34;Homo Sapien&#34;
  end

  self.name #=&gt; &#34;Person&#34;
end
</code></pre>
<p>Here, we have opened the <code>Person</code> class, setting the <code>self</code> to <code>Person</code> for the duration of the block, as in the example above. However, we are defining a method on <code>Person</code>&#39;s metaclass here, since we&#39;re defining the method on an object (<code>self</code>). Also, you can see that <code>self.name</code> while inside the person class is identical to <code>Person.name</code> while outside it.</p>
<pre><code>class &lt;&lt; Person
  def species
    &#34;Homo Sapien&#34;
  end

  self.name #=&gt; &#34;&#34;
end
</code></pre>
<p>Ruby provides a syntax for accessing an object&#39;s metaclass directly. By doing <code>class &lt;&lt; Person</code>, we are setting <code>self</code> to <code>Person</code>&#39;s metaclass for the duration of the block. As a result, the <code>species</code> method is added to <code>Person</code>&#39;s metaclass, rather than the class itself.</p>
<pre><code>class Person
  class &lt;&lt; self
    def species
      &#34;Homo Sapien&#34;
    end
    
    self.name #=&gt; &#34;&#34;
  end
end
</code></pre>
<p>Here, we combine several of the techniques. First, we open <code>Person</code>, making <code>self</code> equal to the <code>Person</code> class. Next, we do <code>class &lt;&lt; self</code>, making <code>self</code> equal to <code>Person</code>&#39;s metaclass. When we then define the <code>species</code> method, it is defined on <code>Person</code>&#39;s metaclass.</p>
<pre><code>Person.instance_eval do
  def species
    &#34;Homo Sapien&#34;
  end

  self.name #=&gt; &#34;Person&#34;
end
</code></pre>
<p>The last case, <code>instance_eval</code>, actually does something interesting. It breaks apart the <code>self</code> into the <code>self</code> that is used to execute methods and the <code>self</code> that is used when new methods are defined. When <code>instance_eval</code> is used, new methods are defined on the <strong>metaclass</strong>, but the <code>self</code> is the object itself.</p>
<p>In some of these cases, the multiple ways to achieve the same thing arise naturally out of Ruby&#39;s semantics. After this explanation, it should be clear that <code>def Person.species</code>, <code>class &lt;&lt; Person; def species</code>, and <code>class Person; class &lt;&lt; self; def species</code> aren&#39;t three ways to achieve the same thing <strong>by design</strong>, but that they arise out of Ruby&#39;s flexibility with regard to specifying what <code>self</code> is at any given point in your program.</p>
<p>On the other hand, <code>class_eval</code> is slightly different. Because it take a block, rather than act as a keyword, it captures the local variables surrounding it. This can provide powerful DSL capabilities, in addition to controlling the <code>self</code> used in a code block. But other than that, they are exactly identical to the other constructs used here.</p>
<p>Finally, <code>instance_eval</code> breaks apart the <code>self</code> into two parts, while also giving you access to local variables defined outside of it.</p>
<p>In the following table, <em>defines a new scope</em> means that code inside the block does <strong>not</strong> have access to local variables outside of the block.</p>
<table>
  <thead>
    <tr><th>mechanism</th><th>method resolution</th><th>method definition</th><th>new scope?</th></tr>
  </thead>
  <tbody>
    <tr><th>class Person</th><td>Person</td><td>same</td><td>yes</td></tr>
    <tr><th>class &lt;&lt; Person</th><td>Person&#39;s metaclass</td><td>same</td><td>yes</td></tr>
    <tr><th>Person.class_eval</th><td>Person</td><td>same</td><td>no</td></tr>
    <tr><th>Person.instance_eval</th><td>Person</td><td>Person&#39;s metaclass</td><td>no</td></tr>
  </tbody>
</table>
<p>Also note that <code>class_eval</code> is only available to <code>Modules</code> (note that Class inherits from Module) and is an alias for <code>module_eval</code>. Additionally, <code>instance_exec</code>, which was added to Ruby in 1.8.7, works exactly like <code>instance_eval</code>, except that it also allows you to send variables into the block.</p>
<p><strong>UPDATE:</strong> Thank you to Yugui of the Ruby core team for <a href="http://yugui.jp/articles/846?ref=yehudakatz.com">correcting the original post</a>, which ignored the fact that <code>self</code> is broken into two in the case of <code>instance_eval</code>.</p>
<!--kg-card-end: markdown-->
    </div></div>
  </body>
</html>
