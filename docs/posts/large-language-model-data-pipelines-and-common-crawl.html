<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.christianperone.com/2023/06/appreciating-llms-data-pipelines/">Original</a>
    <h1>Large language model data pipelines and Common Crawl</h1>
    
    <div id="readability-page-1" class="page"><div>
                <figure id="attachment_4832" aria-describedby="caption-attachment-4832"><img fetchpriority="high" decoding="async" src="https://blog.christianperone.com/wp-content/uploads/2023/06/Desmazieres-biblio-planetes-sm.jpg" alt="" width="1000" height="617" srcset="https://blog.christianperone.com/wp-content/uploads/2023/06/Desmazieres-biblio-planetes-sm.jpg 1000w, https://blog.christianperone.com/wp-content/uploads/2023/06/Desmazieres-biblio-planetes-sm-300x185.jpg 300w, https://blog.christianperone.com/wp-content/uploads/2023/06/Desmazieres-biblio-planetes-sm-700x432.jpg 700w, https://blog.christianperone.com/wp-content/uploads/2023/06/Desmazieres-biblio-planetes-sm-768x474.jpg 768w" sizes="(max-width: 1000px) 100vw, 1000px"/><figcaption id="caption-attachment-4832">Erik Desmazieres’s “La Bibliothèque de Babel”. 1997.</figcaption></figure>
<p>We have been training language models (LMs) for years, but finding valuable resources about the data pipelines commonly used to build the datasets for training these models is paradoxically challenging. It may be because we often take it for granted that these datasets exist (or at least existed? As replicating them is becoming increasingly difficult). However, one must consider the numerous decisions involved in creating such pipelines, as it can significantly impact the final model’s quality, as seen recently in the struggle of models aiming to replicate LLaMA (<a href="https://arxiv.org/abs/2302.13971v1">LLaMA: Open and Efficient Foundation Language Models</a>). It might be tempting to think that now, with large models that can scale well, data is becoming more critical than modeling, since model architectures are not radically changing much. However, data has always been critical.</p>
<p>This article provides a short introduction to the pipeline used to create the data to train LLaMA, but it allows for many variations and I will add details about other similar pipelines when relevant, such as <strong>RefinedWeb</strong> (<a href="https://arxiv.org/abs/2306.01116">The RefinedWeb Dataset for Falcon LLM: Outperforming Curated Corpora with Web Data, and Web Data Only</a>) and <strong>The Pile</strong> (<a href="https://arxiv.org/abs/2101.00027">The Pile: An 800GB Dataset of Diverse Text for Language Modeling</a>). This article is mainly based on the pipeline described in CCNet (<a href="https://aclanthology.org/2020.lrec-1.494/">CCNet: Extracting High Quality Monolingual Datasets from Web Crawl Data</a>) and LLaMA’s paper, both from Meta. CCNet was developed focusing on the data source that is often the largest one, but also the most challenging in terms of quality: <a href="https://commoncrawl.org/">Common Crawl</a>.</p>
<h2>The big picture</h2>
<p>The entire pipeline of CCNet (plus some minor modifications made by LLaMA’s paper) can be seen below. It has the following stages: data source, deduplication, language, filtering, and the “is-reference” filtering which was added in LLaMA. I will go through each one of them in the sections below.</p>
<figure id="attachment_4741" aria-describedby="caption-attachment-4741"><a href="https://blog.christianperone.com/wp-content/uploads/2023/05/ccnet.png"><img decoding="async" src="https://blog.christianperone.com/wp-content/uploads/2023/05/ccnet.png" alt="" width="4624" height="1322" srcset="https://blog.christianperone.com/wp-content/uploads/2023/05/ccnet.png 4624w, https://blog.christianperone.com/wp-content/uploads/2023/05/ccnet-300x86.png 300w, https://blog.christianperone.com/wp-content/uploads/2023/05/ccnet-700x200.png 700w, https://blog.christianperone.com/wp-content/uploads/2023/05/ccnet-768x220.png 768w, https://blog.christianperone.com/wp-content/uploads/2023/05/ccnet-1536x439.png 1536w, https://blog.christianperone.com/wp-content/uploads/2023/05/ccnet-2048x586.png 2048w" sizes="(max-width: 4624px) 100vw, 4624px"/></a><figcaption id="caption-attachment-4741"><em>Visual overview of the CCNet pipeline with some modifications done in LLaMA. Click to enlarge</em>.</figcaption></figure>
<p>Let’s dive into it !</p>

<h2>Common Crawl</h2>
<p><img decoding="async" src="https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_1-300x227.png" alt="" width="300" height="227" srcset="https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_1-300x227.png 300w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_1-700x529.png 700w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_1-768x581.png 768w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_1.png 1330w" sizes="(max-width: 300px) 100vw, 300px"/></p>
<p>Common Crawl (or CC) data is the data coming from a <a href="https://commoncrawl.org/">non-profit organization</a> of the same name that does massive crawling of websites and releases this archive under permissive terms. This is by no means an easy feat, consider the tasks of filtering spam, deciding which URLs to crawl, crawling massive amounts of data from different servers, data formats, etc. That’s why you should <a href="https://commoncrawl.org/donate/">consider donating</a> if you use it.</p>
<p>Common Crawl provides different archival formats that you can use and this format evolved over time. Nowadays they are available in 3 main different formats (besides the index): WARC, WAT, and WET.</p>
<h4>WARC/WAT/WET formats</h4>
<p><strong>WARC</strong>: the <a href="https://commoncrawl.org/the-data/get-started/#WARC-Format">WARC format</a> is the largest one as it is the least processed version of the crawl process, it is the raw data and has a very clever format that records the HTTP response headers, so you can even get information about the server being used on each host. This format is seldom used for NLP as it is really huge and has data that is not used for LLMs training. However, this is the primary data format of CC so it is very rich and might be useful for multimodal datasets, that’s why I think that WARC and WAT (described below) might start to see more uses in the next years.</p>
<p><strong>WAT</strong> and <strong>WET</strong>: these are secondary data sources of CC as they are processed data. These two are the ones that are often used for training LMs and here is where different pipelines start to diverge as well. These formats contain different types of records with the WAT having more metadata than WET and also HTML tags content and links. WET is mainly only a textual format.</p>
<p>If you want to see real examples of WARC/WAT/WET, <a href="https://commoncrawl.org/the-data/get-started/#WARC-Format">take a look at this link</a> as I omitted examples here to keep things short, but they are very interesting formats that are worth a look if you want to use them or understand how to load and parse them.</p>
<p>Now, CCNet (<a href="https://aclanthology.org/2020.lrec-1.494/">CCNet: Extracting High Quality Monolingual Datasets from Web Crawl Data</a>) <strong>uses the WET</strong> format which is purely textual, and that is where we will focus, however, there are <strong>some other pipelines that use WAT</strong> with the argument that to extract high-quality textual data you have to go to WAT instead of WET (bypassing the CommonCrawl processing to extract text). One example of a pipeline that <strong>doesn’t use the WET</strong> files is The Pile (<a href="https://arxiv.org/abs/2101.00027">The Pile: An 800GB Dataset of Diverse Text for Language Modeling</a>), where they use <a href="https://github.com/miso-belica/jusText">jusText</a>. They mentioned that they can extract higher-quality text than using WET files.</p>
<p>You probably realized that we just started with CC and there are already multiple options to extract data from it. Another recent pipeline called <a href="https://huggingface.co/datasets/tiiuae/falcon-refinedweb">RefinedWeb</a> (used in Falcon) also uses WARC directly and skip the CC pipeline for text extraction (the one which generates the WET files). RefinedWeb, however, uses <a href="https://trafilatura.readthedocs.io/en/latest/">trafilatura</a> instead of jusText for text extraction.</p>
<h2>URL Filtering</h2>
<p>Although it is not mentioned in CCNet, many pipelines do URL filtering using public available blocklists of adult/violent/malware/etc websites. In RefinedWeb for example, they filter URLs <strong>using a blocklist of 4.6M domains and also use a word-based filtering of the URL</strong>. You can be very creative here and aggregate multiple blocklists from different sources.</p>
<h2>Deduplication<img loading="lazy" decoding="async" src="https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_21-178x300.png" alt="" width="212" height="357" srcset="https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_21-178x300.png 178w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_21-700x1180.png 700w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_21.png 750w" sizes="(max-width: 212px) 100vw, 212px"/></h2>
<p>Let’s now talk about deduplication, which can be a controversial matter. <a href="https://arxiv.org/abs/2107.06499">In Deduplicating Training Data Makes Language Models Better</a> you can have an idea of what they found. There is, however, Pythia (<a href="https://arxiv.org/abs/2304.01373">Pythia: A Suite for Analyzing Large Language Models Across Training and Scaling</a>) that said that “<em>… deduplication of our training data <strong>has no clear benefit on language modeling performance</strong></em>.” [emphasis added]. Therefore I think it is still an open debate, but given excellent results from LLaMA, I wouldn’t leave deduplication aside for any new model, but we will probably see more works about it in the near future.</p>
<p>Let’s discuss now how deduplication works on CCNet. CC snapshots are big, if we look at the size of WET files for March/April 2023, <strong>WET is 8.7 TiB and WAT is 21.1 TiB</strong> (both compressed already!). The first thing that CCNet does is to break these WET snapshots into 5GB shards that are saved in JSON where each entry corresponds to a crawled web page.</p>
<figure id="attachment_4839" aria-describedby="caption-attachment-4839"><img loading="lazy" decoding="async" src="https://blog.christianperone.com/wp-content/uploads/2023/06/Desmazieres-biblio-alphabet2-sm-206x300.jpg" alt="" width="274" height="399" srcset="https://blog.christianperone.com/wp-content/uploads/2023/06/Desmazieres-biblio-alphabet2-sm-206x300.jpg 206w, https://blog.christianperone.com/wp-content/uploads/2023/06/Desmazieres-biblio-alphabet2-sm.jpg 686w" sizes="(max-width: 274px) 100vw, 274px"/><figcaption id="caption-attachment-4839">Erik Desmazieres’s “La Bibliothèque de Babel”. 1997.</figcaption></figure>
<p>The next step after sharding is paragraph normalization, as deduplication happens at the paragraph level. They normalize each paragraph by lower-casing it, replacing numbers with a placeholder, and removing all <a href="https://github.com/facebookresearch/cc_net/blob/main/cc_net/text_normalizer.py#LL10C1-L10C14">Unicode punctuation</a> (you can also replace them) and accent marks. Next, they compute the SHA1 of each paragraph and use the first 64 bits to deduplicate them. After that, there is the option to do deduplication by comparing among all shards or a fixed number of shards, more details in <a href="https://aclanthology.org/2020.lrec-1.494.pdf">their paper</a> if you are interested in this comparison.</p>
<p>It is interesting to note that on the RefinedWeb dataset, they seem to be <strong>much more aggressive</strong> by employing fuzzy deduplication and using “strict settings” that led to the removal rates “far higher than other datasets have reported” (as a baseline, CCNet reported that duplicated data accounted for 70% of the text). This can certainly have a significant impact on dataset diversity.</p>
<p>Another important aspect of deduplication is described in CCNet paper: this step removes a lot of boilerplate (e.g. navigation menus, cookie warnings, and contact information). It also <strong>removes English content from pages in other languages</strong> and makes language identification which we will discuss next, more robust.</p>
<p>Here is an overview of the process:</p>
<p><img loading="lazy" decoding="async" src="https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_dedup_v2-700x741.png" alt="" width="640" height="677" srcset="https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_dedup_v2-700x741.png 700w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_dedup_v2-283x300.png 283w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_dedup_v2-768x813.png 768w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_dedup_v2.png 1065w" sizes="(max-width: 640px) 100vw, 640px"/></p>
<p>As you can see, it starts by stripping spaces, then lower cases it and replaces the digits with a placeholder (e.g. zero). After that it removes (or replaces) Unicode punctuation, performs a SHA1 hashing, and uses the first 8 bytes for deduplication comparisons (paragraph level). Do not confuse the deduplication process with training data, this is done only to compute the final hash and deduplicate data, not to use this data to train the model.</p>
<p>Now, on RefinedWeb, they followed what was done in <a href="https://arxiv.org/abs/2112.11446">Gopher</a> as well which is to remove repetitions before filtering for deduplication by removing any document with excessive line, paragraph, or n-gram repetitions. After that, they used a deduplication pipeline using MinHash (<a href="https://www.cs.princeton.edu/courses/archive/spring13/cos598C/broder97resemblance.pdf">On the resemblance and containment of documents</a>) which they found to be very effective at removing SEO templates (placeholder SEO text repeated across websites, etc). They also did exact deduplication, but since CC is enormous, they did something similar to what was mentioned as an alternative in CCNet, where it is first sharded and deduplication happens at individual shard level.</p>
<h2>Language</h2>
<p><img loading="lazy" decoding="async" src="https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_3-222x300.png" alt="" width="222" height="300" srcset="https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_3-222x300.png 222w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_3-700x948.png 700w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_3.png 752w" sizes="(max-width: 222px) 100vw, 222px"/> Let’s take a look now at language identification, scoring, and filtering. In CCNet they employed <a href="https://fasttext.cc/docs/en/language-identification.html">fastText</a> (<a href="https://arxiv.org/abs/1607.01759">Bag of Tricks for Efficient Text Classification</a>), which was trained with data from Wikipedia, Tatoeba, and SETimes. fastText supports 176 languages and reports a score for each one of them.</p>
<p>In CCNet, if the score for the most probable language is not higher than 0.5 (50%), they discard the web page, otherwise, the language is classified as being of the most probable language identified.</p>
<p>Note that although the LLaMA dataset filtered non-English data from the CC dataset, it was trained with other datasets that had other languages (e.g. Wikipedia). In my experience, LLaMA is impressively good at other languages as well (e.g. Portuguese).</p>
<p>RefinedWeb pipeline, just like CCNet, also employed fastText to identify languages. One important distinction here is that the RefinedWeb pipeline uses a different threshold of 0.65 instead of 0.5 and they have switched the order of deduplication and language identification, they do language identification before the deduplication, as opposed to CCNet which does the reverse.</p>
<h2>LM Filtering</h2>
<p><img loading="lazy" decoding="async" src="https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_5-204x300.png" alt="" width="230" height="338" srcset="https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_5-204x300.png 204w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_5-700x1028.png 700w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_5-768x1128.png 768w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_5.png 854w" sizes="(max-width: 230px) 100vw, 230px"/>At this point, we have deduplicated data, and language was identified and filtered. It doesn’t mean, however, that the quality is good. That’s the reason why CCNet does another filtering step: they use the perplexity from a language model trained on the target domain language, as they found this score to be a relatively good proxy for quality. They train a 5-gram Kneser-Ney model on the Wikipedia of the same language as the target domain and then use these models to compute per-paragraph perplexity.</p>
<p>With the perplexities in hand, you need to find a threshold. What CCNet paper describes is that they computed 3 parts of equal size (head, middle, tail) from the distribution of perplexities of each language (as different languages showed very different perplexity distributions), however, there is an important excerpt from the paper that I quote below:</p>
<blockquote><p>(…) Some documents despite being valid text ends up in the tail because they have a vocabulary very different from Wikipedia. This includes blog comments with spokenlike text, or very specialized forums with specific jargon. We decided to not remove content based on the LM score because we think that some of it could be useful for specific applications. (…)</p></blockquote>
<p>This means that it really depends on your application, as you might be ending up removing important data by blind thresholding just using an LM trained on Wikipedia. In RefineWeb, they avoided using LM for filtering and relied only on simple rules and heuristics. They used a pipeline very similar to the one used in <a href="https://arxiv.org/abs/2112.11446">Gopher</a>, where outliers are filtered “..<em>. in terms of overall length, symbol-to-word ratio, and other criteria ensuring the document is actual natural language</em>“, they remark that this needs to be done per language as well, the usual issue with using heuristics too tied to the language characteristics.</p>
<h2>“Is reference” filtering</h2>
<p><img loading="lazy" decoding="async" src="https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_6-256x300.png" alt="" width="256" height="300" srcset="https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_6-256x300.png 256w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_6-700x819.png 700w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_6-768x899.png 768w, https://blog.christianperone.com/wp-content/uploads/2023/06/ccnet_6.png 858w" sizes="(max-width: 256px) 100vw, 256px"/> This section is not present in CCNet but it was used as an extra step in the LLaMA dataset so I decided to add it here as well. This step is also not very well described in LLaMA’s paper, but it seems that a simple linear classifier was trained (not sure with which features) to classify pages used as references in Wikipedia v.s. randomly sampled pages, then pages classified as non-reference were discarded.</p>
<p>I think that this step might look simple at first hand, but it can have a significant impact on dataset quality depending on the threshold used. It seems to me that for LLaMA’s dataset, the LM filtering was more conservative to avoid removing relevant data and then they added this extra step to deal with remaining quality issues, but this is me hypothesizing.</p>

<h2>Addendum: RefinedWeb diagram</h2>
<p>RefinedWeb paper has a very nice Sankey diagram of their pipeline:</p>
<figure id="attachment_4861" aria-describedby="caption-attachment-4861"><img loading="lazy" decoding="async" src="https://blog.christianperone.com/wp-content/uploads/2023/06/Screenshot-2023-06-06-at-19.25.20.png" alt="" width="2320" height="1268" srcset="https://blog.christianperone.com/wp-content/uploads/2023/06/Screenshot-2023-06-06-at-19.25.20.png 2320w, https://blog.christianperone.com/wp-content/uploads/2023/06/Screenshot-2023-06-06-at-19.25.20-300x164.png 300w, https://blog.christianperone.com/wp-content/uploads/2023/06/Screenshot-2023-06-06-at-19.25.20-700x383.png 700w, https://blog.christianperone.com/wp-content/uploads/2023/06/Screenshot-2023-06-06-at-19.25.20-768x420.png 768w, https://blog.christianperone.com/wp-content/uploads/2023/06/Screenshot-2023-06-06-at-19.25.20-1536x840.png 1536w, https://blog.christianperone.com/wp-content/uploads/2023/06/Screenshot-2023-06-06-at-19.25.20-2048x1119.png 2048w" sizes="(max-width: 2320px) 100vw, 2320px"/><figcaption id="caption-attachment-4861">Image from: The RefinedWeb Dataset for Falcon LLM: Outperforming Curated Corpora with Web Data, and Web Data Only. Guilherme Penedo et al. 2023. <a href="https://arxiv.org/abs/2306.01116">https://arxiv.org/abs/2306.01116</a>.</figcaption></figure>
<p>This is a very informative figure that tells us how much of the data was discarded. I was personally impressed by the amount of data removed during the repetition removal step.</p>
<h2>Closing remarks</h2>
<figure id="attachment_4844" aria-describedby="caption-attachment-4844"><img loading="lazy" decoding="async" src="https://blog.christianperone.com/wp-content/uploads/2023/06/Desmazieres-biblio-circular-sm-216x300.jpg" alt="" width="271" height="376" srcset="https://blog.christianperone.com/wp-content/uploads/2023/06/Desmazieres-biblio-circular-sm-216x300.jpg 216w, https://blog.christianperone.com/wp-content/uploads/2023/06/Desmazieres-biblio-circular-sm-700x971.jpg 700w, https://blog.christianperone.com/wp-content/uploads/2023/06/Desmazieres-biblio-circular-sm.jpg 721w" sizes="(max-width: 271px) 100vw, 271px"/><figcaption id="caption-attachment-4844">Erik Desmazieres’s “La Bibliothèque de Babel”. 1997.</figcaption></figure>
<p>I hope you enjoyed this article, the main goal was to give a brief overview of the steps and decisions you need to take before being able to train a large language model (LLM). There are obviously many other important aspects, such as proportions of different datasets (mixing), tokenization, etc. Given that CC dataset is usually the largest dataset in LLM training, I decided to focus on the pipelines that directly deal with this particular set before tokenization.</p>
<p>Many design decisions on data pre-processing pipelines are made with performance in mind, as we are dealing with large chunks of data from CC dataset. It seems to me that you can find a better balance by investing a little more of the computing budget on the data side, especially when you consider the cost of LLMs training. It is, however, very difficult to anticipate what would be the impact of different decisions taken in the data pipeline on LLMs after training, that’s why small experiments, manual data inspection, and exploratory data analysis are paramount to get an understanding of what is going on.</p>
<p>In summary, <strong>every company has the dataset it deserves</strong>. It is a long-term investment that requires substantial experimentation, engineering effort, attention to detail, and good intuition to make bets under uncertainty. But it is an investment that pays off in the long run.</p>
<p><em>– Christian S. Perone</em></p>
<h3>Changelog</h3>
<p><strong>6 June 2023</strong>: updated with more information made available by RefinedWeb paper.</p>

            </div></div>
  </body>
</html>
