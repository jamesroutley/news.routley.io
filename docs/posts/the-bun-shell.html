<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bun.sh/blog/the-bun-shell">Original</a>
    <h1>The Bun Shell</h1>
    
    <div id="readability-page-1" class="page"><article><p>JavaScript is the world&#39;s most popular scripting language.</p><p>So why is it hard to run shell scripts in JavaScript?</p><div><div><div><pre><code><span><span>import</span><span> { spawnSync } </span><span>from</span><span> </span><span>&#34;</span><span>child_process</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>// this is a lot more work than it could be</span></span>
<span><span>const</span><span> { status, stdout, stderr } </span><span>=</span><span> </span><span>spawnSync</span><span>(</span><span>&#34;</span><span>ls</span><span>&#34;</span><span>, [</span><span>&#34;</span><span>-l</span><span>&#34;</span><span>, </span><span>&#34;</span><span>*.js</span><span>&#34;</span><span>], {</span></span>
<span><span>  encoding</span><span>:</span><span> </span><span>&#34;</span><span>utf8</span><span>&#34;</span><span>,</span></span>
<span><span>});</span></span>
<span></span></code></pre></div></div></div><p>You could use APIs to do something similar:</p><div><div><div><pre><code><span><span>import</span><span> { readdir } </span><span>from</span><span> </span><span>&#34;</span><span>fs/promises</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>(</span><span>await</span><span> </span><span>readdir</span><span>(</span><span>&#34;</span><span>.</span><span>&#34;</span><span>, { withFileTypes</span><span>:</span><span> </span><span>true</span><span> })).</span><span>filter</span><span>((</span><span>a</span><span>) </span><span>=&gt;</span></span>
<span><span>  a.name.</span><span>endsWith</span><span>(</span><span>&#34;</span><span>.js</span><span>&#34;</span><span>),</span></span>
<span><span>);</span></span>
<span></span></code></pre></div></div></div><p>But, that&#39;s still not quite as simple as a shell script:</p><h2 level="2" anchor-id="why-existing-shells-don-t-work-in-javascript" id="why-existing-shells-don-t-work-in-javascript"><a name="why-existing-shells-don-t-work-in-javascript"></a><a href="#why-existing-shells-don-t-work-in-javascript">Why existing shells don&#39;t work in JavaScript</a></h2><p>Shells like <code>bash</code> or <code>sh</code> have been around for decades.</p><div><p>Shells are a solved problem!!</p><ul><li>Hacker News Commenter, probably.</li></ul></div><p>But, they don&#39;t work well in JavaScript. Why?</p><p>macOS (zsh), Linux (bash), and Windows (cmd) all have slightly different shells with different syntaxes and different commands. The commands available on each platform are different, and even the same command can have different flags and behaviors.</p><p>To date, npm&#39;s solution is to rely on the community to polyfill missing commands with JavaScript implementations.</p><h3 level="3" anchor-id="rm-rf-doesn-t-work-on-windows" id="rm-rf-doesn-t-work-on-windows"><a name="rm-rf-doesn-t-work-on-windows"></a><a href="#rm-rf-doesn-t-work-on-windows"><code>rm -rf</code> doesn&#39;t work on Windows</a></h3><p><code>rimraf</code>, the cross-platform JavaScript implementation of <code>rm -rf</code>, is downloaded 60 million times per week:</p><figure><a href="https://github.com/oven-sh/bun/assets/709451/a201e61c-2131-4982-9be6-ffdf2a37db7e"><img src="https://github.com/oven-sh/bun/assets/709451/a201e61c-2131-4982-9be6-ffdf2a37db7e"/></a></figure><h3 level="3" anchor-id="environment-variables-like-foo-bar-script-doesn-t-work-on-windows" id="environment-variables-like-foo-bar-script-doesn-t-work-on-windows"><a name="environment-variables-like-foo-bar-script-doesn-t-work-on-windows"></a><a href="#environment-variables-like-foo-bar-script-doesn-t-work-on-windows">Environment variables like <code>FOO=bar &lt;script&gt;</code> doesn&#39;t work on Windows</a></h3><p>Setting an environment variable is different on each platform. Instead of running <code>FOO=bar</code>, you probably use &amp; install <code>cross-env</code>:</p><figure><a href="https://github.com/oven-sh/bun/assets/709451/ab42d9b3-0fa7-4abe-beae-ca26a48e9d75"><img src="https://github.com/oven-sh/bun/assets/709451/ab42d9b3-0fa7-4abe-beae-ca26a48e9d75" alt="image" width="398"/></a></figure><h3 level="3" anchor-id="which-is-where-on-windows" id="which-is-where-on-windows"><a name="which-is-where-on-windows"></a><a href="#which-is-where-on-windows"><code>which</code> is <code>where</code> on Windows</a></h3><p>Thus, another package with 60 million weekly downloads was born:</p><figure><a href="https://github.com/oven-sh/bun/assets/709451/e6659440-f322-47a8-99fe-ec9e3bec104e"><img src="https://github.com/oven-sh/bun/assets/709451/e6659440-f322-47a8-99fe-ec9e3bec104e" alt="image" width="413"/></a></figure><h3 level="3" anchor-id="shells-also-take-too-long-to-start" id="shells-also-take-too-long-to-start"><a name="shells-also-take-too-long-to-start"></a><a href="#shells-also-take-too-long-to-start">Shells also take too long to start</a></h3><p>How long does it take to spawn a shell?</p><p>On a Linux x64 Hetzner Arch Linux machine, it takes about 7ms:</p><div><div><div><pre><code><span><span>$ hyperfine --warmup 3 </span><span>&#39;</span><span>bash -c &#34;echo hello&#34;</span><span>&#39;</span><span> </span><span>&#39;</span><span>sh -c &#34;echo hello&#34;</span><span>&#39;</span><span> -N</span></span>
<span></span>
<span><span>Benchmark 1: bash -c </span><span>&#39;</span><span>echo hello</span><span>&#39;</span></span>
<span><span>  Time (mean ± σ):       7.3 ms ±   1.5 ms    [User: 5.1 ms, System: 1.9 ms]</span></span>
<span><span>  Range (min … max):     1.7 ms …   9.4 ms    529 runs</span></span>
<span></span>
<span><span>Benchmark 2: sh -c </span><span>&#39;</span><span>echo hello</span><span>&#39;</span></span>
<span><span>  Time (mean ± σ):       7.2 ms ±   1.6 ms    [User: 4.8 ms, System: 2.1 ms]</span></span>
<span><span>  Range (min … max):     1.5 ms …   9.6 ms    327 runs</span></span>
<span></span></code></pre></div></div></div><p>If your intent is to run a single command, starting the shell can take longer than running the command itself. If you&#39;re running many commands in a loop, that gets expensive quickly.</p><p>You could try embedding a shell, but that&#39;s really complicated and their license may not be compatible with your project.</p><h2 level="2" anchor-id="are-all-these-polyfills-really-necessary" id="are-all-these-polyfills-really-necessary"><a name="are-all-these-polyfills-really-necessary"></a><a href="#are-all-these-polyfills-really-necessary">Are all these polyfills really necessary?</a></h2><p>In the world of 2009 - 2016, when JavaScript was still relatively new and experimental, relying on the community to polyfill missing functionality made a lot of sense. But it&#39;s 2024 now. JavaScript on the server is mature and widely adopted. The JavaScript ecosystem understands the requirements today in a way nobody did in 2009.</p><p>We can do better.</p><h2 level="2" anchor-id="introducing-the-bun-shell" id="introducing-the-bun-shell"><a name="introducing-the-bun-shell"></a><a href="#introducing-the-bun-shell">Introducing the Bun Shell</a></h2><p>The Bun Shell is a new experimental embedded language and interpreter in Bun that allows you to run cross-platform shell scripts in JavaScript &amp; TypeScript.</p><div><div><div><pre><code><span><span>import</span><span> { $ } </span><span>from</span><span> </span><span>&#34;</span><span>bun</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>// to stdout:</span></span>
<span><span>await</span><span> </span><span>$</span><span>`ls *.js`</span><span>;</span></span>
<span></span>
<span><span>// to string:</span></span>
<span><span>const</span><span> text </span><span>=</span><span> </span><span>await</span><span> </span><span>$</span><span>`ls *.js`</span><span>.</span><span>text</span><span>();</span></span>
<span></span></code></pre></div></div></div><p>You can use JavaScript variables in your shell scripts:</p><div><div><div><pre><code><span><span>import</span><span> { $ } </span><span>from</span><span> </span><span>&#34;</span><span>bun</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>const</span><span> resp </span><span>=</span><span> </span><span>await</span><span> </span><span>fetch</span><span>(</span><span>&#34;</span><span>https://example.com</span><span>&#34;</span><span>);</span></span>
<span></span>
<span><span>const</span><span> stdout </span><span>=</span><span> </span><span>await</span><span> </span><span>$</span><span>`gzip -c &lt; </span><span>${</span><span>resp</span><span>}</span><span>`</span><span>.</span><span>arrayBuffer</span><span>();</span></span>
<span></span></code></pre></div></div></div><p>For security, all <strong>template variables are escaped</strong>:</p><div><div><div><pre><code><span><span>const</span><span> filename </span><span>=</span><span> </span><span>&#34;</span><span>foo.js; rm -rf /</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>// This will run `ls &#39;foo.js; rm -rf /&#39;`</span></span>
<span><span>const</span><span> results </span><span>=</span><span> </span><span>await</span><span> </span><span>$</span><span>`ls </span><span>${</span><span>filename</span><span>}</span><span>`</span><span>;</span></span>
<span></span>
<span><span>console.</span><span>log</span><span>(results.exitCode); </span><span>// 1</span></span>
<span><span>console.</span><span>log</span><span>(results.stderr.</span><span>toString</span><span>()); </span><span>// ls: cannot access &#39;foo.js; rm -rf /&#39;: No such file or directory</span></span>
<span></span></code></pre></div></div></div><p>Using Bun Shell feels like regular JavaScript. You can redirect stdout to buffers:</p><div><div><div><pre><code><span><span>import</span><span> { $ } </span><span>from</span><span> </span><span>&#34;</span><span>bun</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>const</span><span> buffer </span><span>=</span><span> Buffer.</span><span>alloc</span><span>(</span><span>1024</span><span>);</span></span>
<span></span>
<span><span>await</span><span> </span><span>$</span><span>`ls *.js &gt; </span><span>${</span><span>buffer</span><span>}</span><span>`</span><span>;</span></span>
<span></span>
<span><span>console.</span><span>log</span><span>(buffer.</span><span>toString</span><span>(</span><span>&#34;</span><span>utf8</span><span>&#34;</span><span>));</span></span>
<span></span></code></pre></div></div></div><p>You can redirect stdout to a file:</p><div><div><div><pre><code><span><span>import</span><span> { $, file } </span><span>from</span><span> </span><span>&#34;</span><span>bun</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>// as a file()</span></span>
<span><span>await</span><span> </span><span>$</span><span>`ls *.js &gt; </span><span>${</span><span>file</span><span>(</span><span>&#34;</span><span>output.txt</span><span>&#34;</span><span>)</span><span>}</span><span>`</span><span>;</span></span>
<span></span>
<span><span>// or as a file path string, if you prefer:</span></span>
<span><span>await</span><span> </span><span>$</span><span>`ls *.js &gt; output.txt`</span><span>;</span></span>
<span><span>await</span><span> </span><span>$</span><span>`ls *.js &gt; </span><span>${</span><span>&#34;</span><span>output.txt</span><span>&#34;</span><span>}</span><span>`</span><span>;</span></span>
<span></span></code></pre></div></div></div><p>You can pipe stdout to another command:</p><div><div><div><pre><code><span><span>import</span><span> { $ } </span><span>from</span><span> </span><span>&#34;</span><span>bun</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>await</span><span> </span><span>$</span><span>`ls *.js | grep foo`</span><span>;</span></span>
<span></span></code></pre></div></div></div><p>You can even use <code>Response</code> as stdin:</p><div><div><div><pre><code><span><span>import</span><span> { $ } </span><span>from</span><span> </span><span>&#34;</span><span>bun</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>const</span><span> buffer </span><span>=</span><span> </span><span>new</span><span> </span><span>Response</span><span>(</span><span>&#34;</span><span>bar</span><span>\n</span><span> foo</span><span>\n</span><span> bar</span><span>\n</span><span> foo</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span></span>
<span><span>await</span><span> </span><span>$</span><span>`grep foo &lt; </span><span>${</span><span>buffer</span><span>}</span><span>`</span><span>;</span></span>
<span></span></code></pre></div></div></div><p>Builtin commands like <code>cd</code>, <code>echo</code>, and <code>rm</code> are available:</p><div><div><div><pre><code><span><span>import</span><span> { $ } </span><span>from</span><span> </span><span>&#34;</span><span>bun</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>await</span><span> </span><span>$</span><span>`cd .. &amp;&amp; rm -rf node_modules/rimraf`</span><span>;</span></span>
<span></span></code></pre></div></div></div><p>It works on Windows, macOS, and Linux. We&#39;ve implemented many common commands and features like globbing, environment variables, redirection, piping, and more.</p><p>It&#39;s designed as a drop-in replacement for simple shell scripts. In Bun for Windows, it will power <code>package.json</code> &#34;scripts&#34; in <code>bun run</code>.</p><p>For fun, you can also use it as a standalone shell script interpreter:</p><div><div><div><pre><code><span><span>echo</span><span> </span><span>&#34;</span><span>cat package.json</span><span>&#34;</span><span> </span><span>&gt;</span><span> script.bun.sh</span></span></code></pre></div></div></div><h3 level="3" anchor-id="how-do-i-install-it" id="how-do-i-install-it"><a name="how-do-i-install-it"></a><a href="#how-do-i-install-it">How do I install it?</a></h3><p><strong>Bun Shell is built into Bun</strong>. If you already have Bun v1.0.24 or later installed, you can use it today:</p><p>If you don&#39;t have Bun installed, you can install it with curl:</p><div><div><div><pre><code><span><span>curl -fsSL https://bun.sh/install </span><span>|</span><span> bash</span></span></code></pre></div></div></div><p>Or with npm:</p></article></div>
  </body>
</html>
