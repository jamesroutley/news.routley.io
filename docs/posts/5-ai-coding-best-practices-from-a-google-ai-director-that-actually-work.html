<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hamy.xyz/blog/2026-01_ai-engineering-best-practices">Original</a>
    <h1>5 AI Coding Best Practices from a Google AI Director (That Actually Work)</h1>
    
    <div id="readability-page-1" class="page"><p>DISCLOSURE: If you buy through affiliate links, I may earn a small commission. <a href="https://www.astralcodexten.com/blog/disclosures">(disclosures)</a></p><div><p>Addy Osmani, a director on Google&#39;s Gemini team, recently shared his <a href="https://addyo.substack.com/p/my-llm-coding-workflow-going-into">AI coding workflow for 2026</a>. I&#39;ve been <a href="https://hamy.xyz/blog/2025-10_how-i-actually-use-ai">using AI to code daily</a> for the past year and have found many of these principles useful in practice.</p>
<p>In this post I&#39;ll distill these into 5 key practices I find useful, add my own takes, and share what&#39;s worked for me - including a spec-driven workflow I&#39;ve developed that helps keep AI on track across multiple sessions.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/No5yW9Q7Wck?si=E1xg_LwsoP4MXdxo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<h2 id="plan-before-you-code-with-spec-driven-development">Plan Before You Code with Spec-Driven Development</h2>
<p>Osmani&#39;s first principle: create a spec before writing any code. He calls it &#34;waterfall in 15 minutes&#34; - rapid structured planning that prevents wasted cycles. The spec includes requirements, architecture decisions, and testing strategy - but crucially no direct implementation details.</p>
<p>This matches my <a href="https://hamy.xyz/blog/2025-07_stop-vibe-coding">Vibe Engineering philosophy</a> of being heavily involved in setting direction. The separation between spec and plan matters because AI is bad at maintaining long-term vision - its context window gets polluted while working on individual tasks and future sessions won&#39;t have previous context.</p>
<p><img src="https://storage.googleapis.com/iamhamy-static/labs/posts/2026/2026-01_ai-engineering-best-practices/2026.01_ai-engineering-best-practices_spec-driven-development.png" alt="Spec-driven development"/></p>
<p>The solution is a spec hierarchy that anchors the AI across sessions:</p>
<pre><code>FEATURE/
  FEATURE_SPEC.md # Long-lived, describes full product / feature

AGENTS/ # Or wherever you want to keep your plans
  changes/
    IDENTIFER_NAME/ # Unique identifier w human readable name for the change
      SPEC.md # Spec you create describing the change
      PLAN.md # The plan for how to implement + progress tracking
</code></pre>
<ul>
<li><strong>Product-level spec</strong> describes what the product does today. It gets updated when features ship. Every AI session starts by reading this so it knows the full context of what the end product is supposed to do so it doesn&#39;t accidentally break something. Small projects may only need one of these at project root but larger projects will often have one for each slice and feature of sufficient size - kind of like a README but for the actual product requirements.</li>
<li><strong>Change-level spec</strong> describes the outcome of a specific change. What should happen, not how. This forces you to articulate what success looks like before you write any code. Plus it can be reused to provide context as you iterate on the plan and implementation.</li>
<li><strong>Change-level plan</strong> is the plan the AI will follow to actually implement the change. Useful to be broken down into phases with each phase being one logical change that leaves the codebase in a working state (think <a href="https://hamy.xyz/blog/2025-07_stacked-commits">atomic commits</a>). Each phase should include relevant context for what it&#39;s trying to accomplish, checklists for what to change and tracking progress between sessions, and verification steps.</li>
</ul>
<p>The workflow:</p>
<ol>
<li>Write change spec describing the desired outcome</li>
<li>AI creates a plan based on both the product and change specs</li>
<li>Break plan into discrete phases and individual tasks</li>
<li>Iterate on each phase / task one by one - review and verify at each stage to improve the code and course correct. I often find it useful to have a new session for each task so that it conserves its context and doesn&#39;t get confused with info from a different task.</li>
<li>When done, update product spec with the new reality</li>
<li>Move to the next change</li>
</ol>
<p>This prevents the common failure mode where AI &#34;helpfully&#34; changes something that breaks an existing feature because it didn&#39;t know that feature existed / what it was supposed to do.</p>
<p>Doing the spec early may seem like it wastes time but it allows you to iterate with AI in the tightest possible loop - getting aligned on the outcome we want without noise from how we&#39;ll implement. Then you keep reusing the spec in each of your prompts for planning and task implementation which improves AI&#39;s ability to one-shot cause it has all the context it needs to stay on track.</p>
<h2 id="work-in-small-chunks">Work in Small Chunks</h2>
<p>Osmani recommends breaking work into focused tasks, committing after each one - treating commits as &#34;save points&#34; you can roll back to.</p>
<p>I wrote about this in <a href="https://hamy.xyz/blog/2025-07_ai-checkpointing">How to Checkpoint Code Projects with AI Agents</a>. The workflow:</p>
<ul>
<li>Give AI one atomic task</li>
<li>Review the code (and <a href="https://hamy.xyz/blog/2025-12_claude-code-review">have AI review in parallel</a> - you&#39;ll catch different things)</li>
<li>Commit if it looks good</li>
<li>Move to the next task</li>
</ul>
<p>This works because AI performs better on focused tasks than &#34;build me this whole feature.&#34; You stay in the loop as the code grows instead of getting handed a 500-line blob you don&#39;t understand. And when something inevitably breaks / AI goes off the rails, rollback is easy - just revert to the last solid state without losing too much unsaved work.</p>
<p>Note that this idea also works great for human coders and often provides higher dev velocity over time - it&#39;s the basis of <a href="https://hamy.xyz/blog/2025-07_stacked-commits">atomic / stacked commits</a>.</p>
<p>Use the time you&#39;ve saved with AI and this workflow to improve the code - review more carefully, add tests / verifications you may have skipped, and do one more refactor. The AI velocity speed up is real but it only compounds if you uphold quality.</p>
<h2 id="give-ai-the-right-context">Give AI the Right Context</h2>
<p>&#34;LLMs are only as good as the context you provide,&#34; Osmani writes. He recommends creating agent files (CLAUDE.md, GEMINI.md, etc) with coding style guidelines and architectural preferences that prime the model before it writes any code.</p>
<p>For small projects, I typically just use an agents file with all my rules in there. But as projects grow, I break documentation out into independent docs located near the logic in question so AIs can choose when loading it into context is worthwhile.</p>
<p>When writing a prompt - I use spec driven development for large features but may just adhoc it for smaller features. In both cases I include context that I&#39;d expect a new engineer to need to know to complete the task:</p>
<ul>
<li>How the codebase is structured (link to existing docs)</li>
<li>How the relevant product should function (link to product and change spec)</li>
<li>Patterns to use and avoid</li>
<li>How to verify the changes</li>
<li>Coding style preferences</li>
</ul>
<p>The more specific you are, the less back-and-forth there is fixing style issues or filling in missing context..</p>
<h2 id="automate-your-safety-net">Automate Your Safety Net</h2>
<p>Osmani emphasizes that &#34;those who get the most out of coding agents tend to be those with strong testing practices.&#34; At AI speed, you need more guardrails, not fewer - when you&#39;re generating code 10x faster, you&#39;re also generating bugs 10x faster.</p>
<p>Some methods I&#39;ve found helpful:</p>
<ul>
<li><strong>Types</strong> catch misalignments at compile time. AI sometimes uses the wrong type or misunderstands an interface - the type checker catches it before you even run the code which allows it to self-correct and achieve more one or few shots. Type-first development is also a useful way to iterate on really huge systems that may not fit into an AI&#39;s context window - lay out the types first then move to implementing the features one at a time within those interfaces. Related: <a href="https://hamy.xyz/blog/2024-09_types-vs-no-types">Types vs No Types - How Types Allow Code to Scale across Developers, Organizations, and Lines of Code</a>.</li>
<li><strong>Linters</strong> enforce patterns automatically. If you have rules about code style, import order, or banned patterns, the linter will flag violations AI doesn&#39;t know about.</li>
<li><strong>Tests</strong> tell AI when it broke something. This is the big one - AI assumes success unless told otherwise. A failing test suite gives it immediate feedback to self-correct. Coupling tests with specs also helps prevent AIs from just changing / deleting the tests to pass - they should (hopefully) understand what the product requirements are and avoid breaking them.</li>
<li><strong>CI/CD</strong> catches things before they merge. Even if AI convinced you the code looks good, the automated pipeline is the final check. This is also a great place to have smoke tests that may not be feasible to run locally as a final safety net. This is especially useful for cloud-based AI workflows that are async by design - without automated checks, it&#39;s very easy to let bad AI code that looks okay into prod.</li>
</ul>
<p>Let machines do what they&#39;re good at - running fast and deterministically. Every guardrail we add allows AIs to see discrepancies earlier in the dev cycle, so they can fix without blocking on a human - ultimately increasing E2E feature velocity.</p>
<h2 id="you-are-the-driver">You are the Driver</h2>
<p>Osmani&#39;s core philosophy: &#34;AI-augmented software engineering, not AI-automated. The human engineer remains the director.&#34;</p>
<p>You&#39;re responsible for what ships. Every bug, every security hole, every poor UX decision - it&#39;s got your name on it. AI wrote the code, but you approved it.</p>
<p>Beyond code quality, you own the product vision. What should we build? What&#39;s the user experience? What are we optimizing for? AI can implement features, but it can&#39;t tell you which features matter. You own the system design too - the architecture, how pieces fit together, what tradeoffs to make. These are judgment calls that require understanding the full context of your users, your business, and your constraints.</p>
<p>This is where humans remain valuable even as AI gets better at implementation. AI can write code faster than you. It might even write better code for well-defined tasks. But deciding what to build, how it should feel, and how the system should evolve - that&#39;s still you.</p>
<p>As I wrote in <a href="https://hamy.xyz/blog/2025-07_stop-vibe-coding">vibe engineering over vibe coding</a>, if you can&#39;t evaluate what AI produces, you can&#39;t improve it. You&#39;re just hoping it works. And if you&#39;re just hoping it works, then <a href="https://hamy.xyz/blog/2025-12_software-engineers-ai">AI might as well replace you</a>.</p>
<p>The bright side is that AI amplifies your abilities. The more you know about design, testing, and architecture the more AI can help you build faster while maintaining quality. Plus it can help you learn new things - you just have to acknowledge you don&#39;t know something and ask AI to help you understand it. AI is a force multiplier, but you still need to be driving to get the most out of it.</p>
<h2 id="next">Next</h2>
<p>Osmani&#39;s principles largely align with the AI engineering practices I&#39;ve found useful this past year.</p>
<p>If you&#39;re getting started:</p>
<ul>
<li>Create a CLAUDE.md (or equivalent) with your coding style and project structure</li>
<li>Review and commit after every logical change (<a href="https://hamy.xyz/blog/2025-07_stacked-commits">atomic commits</a>!)</li>
<li>Write specs before you code - both product-level and change-level</li>
<li>Set up automated checks (tests, linters, types) - use AI to help you do this!</li>
</ul>
<p>AI makes you faster but it doesn&#39;t replace engineering judgment. Use the speedup to write better code, not just more code.</p>
<p>If you liked this post you might also like:</p>
<ul>
<li><a href="https://hamy.xyz/blog/2025-07_stop-vibe-coding">Stop Vibe Coding, Start Power Coding - How To Write Quality Software Faster With Agentic AI</a></li>
<li><a href="https://hamy.xyz/blog/2025-10_how-i-actually-use-ai">How I Actually Code with AI as a Senior Software Engineer</a></li>
<li><a href="https://hamy.xyz/blog/2025-07_ai-checkpointing">How to Checkpoint Code Projects with AI Agents</a></li>
</ul>
</div></div>
  </body>
</html>
