<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blacksmith.sh/blog/cache-is-king-a-guide-for-docker-layer-caching-in-github-actions">Original</a>
    <h1>Cache is King: A guide for Docker layer caching in GitHub Actions</h1>
    
    <div id="readability-page-1" class="page"><div data-framer-name="Content" data-framer-component-type="RichTextContainer"><p>A majority of the GitHub Action workflows we see at Blacksmith use Docker. Whether it is to setup containers to run tests against, or build custom Docker images and push them to a registry, Docker is everywhere. It is also common knowledge that for a healthy Continuous Integration (CI) pipeline, one has to think through an effective caching strategy - there are few things as mind-numbing as watching tests rebuild undifferentiated dependencies on every run.</p><p>A few weeks ago, I was helping a customer setup their Docker workflows, and started reading about the best way to enable caching in GitHub Actions. Surprisingly, I found <em>at least</em> three ways to achieve this, each with its own quirks. This blog is a one-stop shop with everything I learned and will help you choose the most suitable caching strategy for your workflows.</p><h2>Docker caching 101</h2><p>Docker images are best visualized as a stack of layers, where each layer represents a set of filesystem changes resulting from an instruction in the <code>Dockerfile</code>. Each layer only contains the changes from the layer before it. This ensures that there is no duplication of data across layers. A big advantage of the layered structure is that the intermediate filesystems (layers) can be re-used in subsequent Docker builds. This re-using of layers is what forms the basis of Docker caching, and results in much faster, incremental builds, instead of always building the image from scratch.</p><p>The best <code>Dockerfile</code> s are the ones that stack layers in order from least frequently to most frequently mutated. Consolidating the layers that are least likely to change as the base of every Docker build, allows for the most effective re-use of layers when building subsequent Docker images. There are several, much more informed blogs out there about <code>Dockerfile</code> best practices, so that’s the last I’ll speak of it.</p><h2><strong>Starting simple</strong></h2><p>If you are familiar with how a Docker build and push step is written in GitHub Actions, feel free to skip over to the next section that talks about caching.</p><div><div><div><div><div><div><pre translate="no"><code><span>name</span>: Build and Push Docker Image

<span>on</span>:
<span>  push</span>:
<span>    branches</span>:
      - main

<span>jobs</span>:
<span>  build-and-push</span>:
<span>    runs-on</span>: ubuntu-latest
<span>    steps</span>:
      - <span>name</span>: Checkout code
<span>        uses</span>: actions/checkout@v3

      - <span>name</span>: Set up Docker Buildx
<span>        uses</span>: docker/setup-buildx-action@v3

      - <span>name</span>: Build and push Docker image
<span>        uses</span>: docker/build-push-action@v5
<span>        with</span>:
<span>          context</span>: <span>.</span></code></pre></div></div></div></div></div></div><p>This is what a vanilla GitHub Action workflow that builds and pushes a Docker image looks like. This workflow assumes the <code>Dockerfile</code> is in the root of the repository, and uses two popular Docker actions:</p><ul><li data-preset-tag="p"><p><code><a href="https://github.com/docker/setup-buildx-action" target="_blank" rel="noopener">setup-buildx-action</a></code> to configure <a href="https://github.com/docker/buildx" rel="noopener">Docker Buildx</a> to create a builder instance for running the image build</p></li><li data-preset-tag="p"><p><code><a href="https://github.com/docker/build-push-action" target="_blank" rel="noopener">build-push-action</a></code> to build and push the Docker image using the builder configured in the previous step</p></li></ul><p>Notably, there is no caching occurring in this workflow - so, every time the job is run, Docker will have to build the image from scratch!</p><h2>Docker caching with GitHub Actions cache</h2><p>The first caching strategy we are going to explore is caching Docker layer blobs to the native Github Actions <a href="https://github.com/actions/cache" target="_blank" rel="noopener">cache</a>. This approach is the simplest to reconcile, and I’d recommend it as a good starting point to build intuition. There are, however, some limitations to this approach as your codebase scales.</p><ul><li data-preset-tag="p"><p>Each GitHub repository is only given 10GB of cache space, after which, the oldest entries in the cache are evicted. If your Docker image is reasonably large, or has several layers, you will likely run into this limit and not reap the benefits of effective caching.</p></li><li data-preset-tag="p"><p>GitHub’s cache is only scoped to the development branch running the Docker build. Sharing the cached layers across your organization, or with other build systems, is not possible with this approach.</p></li></ul><p>Here is how you would edit the above workflow file to enable caching backed by GitHub’s cache.</p><div><div><div><div><div><div><pre translate="no"><code><span>name</span>: Build and Push Docker Image

<span>on</span>:
<span>  push</span>:
<span>    branches</span>:
      - main

<span>jobs</span>:
<span>  build-and-push</span>:
<span>    runs-on</span>: ubuntu-latest
<span>    steps</span>:
      - <span>name</span>: Checkout code
<span>        uses</span>: actions/checkout@v3

      - <span>name</span>: Set up Docker Buildx
<span>        uses</span>: docker/setup-buildx-action@v3

      - <span>name</span>: Build and push Docker image
<span>        uses</span>: docker/build-push-action@v5
<span>        with</span>:
<span>          context</span>: <span>.</span>
<span>          push</span>: <span>true</span>
<span>          tags</span>: user/app:latest
<span>          cache-from</span>: type=gha
<span>          cache-to</span>

</code></pre></div></div></div></div></div></div><p>Let’s take a second to understand <code>cache-from</code> and <code>cache-to</code>.</p><ul><li data-preset-tag="p"><p><code>cache-from</code> points to the source where the build process will attempt to find a cache to use while building the Docker image</p></li><li data-preset-tag="p"><p><code>cache-to</code> specifies the destination where the cache generated during the build process will be stored</p></li></ul><p>In the above workflow, the first run will be an uncached run, since there is no cache at <code>cache-from</code> to import. At the end of this run, cache blobs will be written to <code>cache-to</code>. Subsequent runs will be able to leverage these cached Docker layers, and just like that, you’re running much faster than you were!</p><h2>Docker caching with a registry backed cache</h2><p>The second flavour of Docker caching we’ll look at uses a Docker registry as the cache backend. A Docker registry is a storage and distribution system for Docker images. There are two ways you can leverage a registry backed cache, each with its own strengths and limitations.</p><h3>1. Inline cache</h3><p>An inline cache is the simplest registry backed cache to setup. This method embeds the build cache artifacts directly into the Docker image. Let’s modify our workflow file before diving in.</p><div><div><div><div><div><div><pre translate="no"><code><span>name</span>: Build and Push Docker Image

<span>on</span>:
<span>  push</span>:
<span>    branches</span>:
      - main

<span>jobs</span>:
<span>  build-and-push</span>:
<span>    runs-on</span>: ubuntu-latest
<span>    steps</span>:
      - <span>name</span>: Checkout code
<span>        uses</span>: actions/checkout@v3

      - <span>name</span>: Set up Docker Buildx
<span>        uses</span>: docker/setup-buildx-action@v3

      - <span>name</span>: Build and push Docker image
<span>        uses</span>: docker/build-push-action@v5
<span>        with</span>:
<span>          context</span>: <span>.</span>
<span>          push</span>: <span>true</span>
<span>          tags</span>: user/app:latest
<span>          cache-from</span>: type=registry,ref=user/app:latest
<span>          cache-to</span>

</code></pre></div></div></div></div></div></div><p>As you can see, our <code>cache-to</code> now points to a different cache backend. The <code>type=inline</code> instructs the Docker builder to embed cache artifacts into the Docker image, and push them to the same location as the Docker image Subsequent runs of this workflow will use the image referenced in <code>cache-from</code> as their base, to significantly speed-up Docker builds.</p><p>So… why is this better than the GitHub Action’s cache backend?</p><ul><li data-preset-tag="p"><p>You are not subject to GitHub’s cache size limits and eviction policies.</p></li><li data-preset-tag="p"><p>You can re-use the cache artifacts across your organization or with other build systems.</p></li></ul><p>So… why aren’t we done yet?</p><p>For this we need to take a slight detour to understand “multi-stage” Docker builds. A <a href="https://docs.docker.com/build/building/multi-stage/" target="_blank" rel="noopener">multi-stage</a> Docker build is one where the <code>Dockerfile</code> is organized into multiple stages. Each stage has its own base image and set of instructions. The author has complete flexibility to decide what artifacts from the previous stage should be copied over to the next stage. For example, you can have a <code>Build</code> stage that includes all the tools and dependancies, but have your <code>Final</code> stage only have the necessary pieces to run your application.</p><div><div><div><div><div><div><pre translate="no"><code>
FROM node:16-alpine AS builder
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm install
COPY . .
RUN npm run build


FROM node:16-alpine
WORKDIR /app
COPY --from=builder /app/build /app
CMD [<span>&#34;node&#34;</span>, <span>&#34;server.js&#34;</span>

</code></pre></div></div></div></div></div></div><p>Having only the necessary files and dependencies copied into the final production image allows for it to be much smaller and more secure, than if the entire <code>Dockerfile</code> were to be written in a single stage.</p><p>The <code>inline</code> cache only supports <code>mode=min</code> . This mode only caches the layers of the final stage, not any of the intermediate layers in a multi-stage Docker build. This significantly reduces the chances of a cache hit in subsequent Docker builds.</p><p>Another shortcoming of the <code>inline</code> cache is that since it embeds the cache artifacts into the Docker image, it can significantly inflate the size of your Docker image. Enter, our final caching solution.</p><h3>2. Registry cache</h3><p>The registry cache backend is the <code>inline</code> cache++. This backend pushes cache artifacts as a separate image than the Docker image to a dedicated location in the registry.</p><div><div><div><div><div><div><pre translate="no"><code><span>name</span>: Build and Push Docker Image

<span>on</span>:
<span>  push</span>:
<span>    branches</span>:
      - main

<span>jobs</span>:
<span>  build-and-push</span>:
<span>    runs-on</span>: ubuntu-latest
<span>    steps</span>:
      - <span>name</span>: Checkout code
<span>        uses</span>: actions/checkout@v3

      - <span>name</span>: Set up Docker Buildx
<span>        uses</span>: docker/setup-buildx-action@v3

      - <span>name</span>: Build and push Docker image
<span>        uses</span>: docker/build-push-action@v5
<span>        with</span>:
<span>          context</span>: <span>.</span>
<span>          push</span>: <span>true</span>
<span>          tags</span>: user/app:latest
<span>          cache-from</span>: type=registry,ref=user/app:buildcache
<span>          cache-to</span>

</code></pre></div></div></div></div></div></div><p>Contrary to the <code>inline</code> cache, the registry cache supports caching of intermediate layers in a multi-stage Docker build when configured with <code>mode=max</code> . This increases the chances of cache hits on subsequent builds. It also supports a host of <a href="https://docs.docker.com/build/cache/backends/registry/" target="_blank" rel="noopener">options</a> to control compression type, levels, and naming of the cache image etc. At the cost of some additional complexity to set up, this is the best-in-class caching solution for Docker builds.</p><p>At Blacksmith, we are always thinking of ways to boost the performance of your CI jobs. Keep your eyes peeled for out-of-the-box Docker layer caching with zero code changes, collocated Docker mirrors, and beefy remote builders from us in the near future! If you need help optimizing your workflows, or want to be notified as new features drop, email us at <a href="mailto:hello@blacksmith.sh" target="_blank" rel="noopener">hello@blacksmith.sh</a>.</p></div></div>
  </body>
</html>
