<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://htmx.org/essays/why-tend-not-to-use-content-negotiation/">Original</a>
    <h1>Why I tend not to use content negotiation</h1>
    
    <div id="readability-page-1" class="page"><div>
    

  
  
    <address>Carson Gross</address>
    <p><time>November 18, 2023</time></p><p>I have written a lot about Hypermedia APIs vs. Data (JSON) APIs, including <a href="https://htmx.org/essays/hypermedia-apis-vs-data-apis/">the differences between the two</a>,
what <a href="https://htmx.org/essays/how-did-rest-come-to-mean-the-opposite-of-rest/">REST “really” means</a> and why <a href="https://htmx.org/essays/hateoas/">HATEOAS</a>
isn’t so bad as long as your API is interacting with a <a href="https://htmx.org/essays/hypermedia-clients/">Hypermedia Client</a>.</p>
<p>Often when I am engaged in discussions with people coming from the “REST is JSON over HTTP” world (that is, the normal
world) I have to navigate a lot of language and conceptual issues:</p>
<ul>
<li>No, I am not advocating you return HTML as a general purpose API, hypermedia makes for a bad general purpose API </li>
<li>Yes, I am advocating <a href="https://htmx.org/essays/two-approaches-to-decoupling/">tightly coupling</a> your web application to your hypermedia API</li>
<li>No, I do not think that we will ever fix how the industry <a href="https://htmx.org/essays/how-did-rest-come-to-mean-the-opposite-of-rest/">uses the term REST</a></li>
<li>Yes, I am advocating you <a href="https://htmx.org/essays/splitting-your-apis/">split your data API and your hypermedia API up</a></li>
</ul>
<p>The last point often strikes people who are used to a single, general purpose JSON API as dumb: why have two APIs when you
can have a single API that can satisfy any number of types of clients?  I tried to answer that question as best I can in the essay
above, but it is certainly a reasonable one to ask.</p>
<p>It seems like (and it is) extra work in some ways when compared to have that one, general API and the associated logic.</p>
<p>At this point in a conversation, someone who agrees broadly with my take on REST, <a href="https://htmx.org/essays/hypermedia-driven-applications/">Hypermedia-Driven Applications</a>,
etc. will often jump in and say something like</p>
<blockquote>
<p>“Oh, it’s easy, you just use <em>content negotiation</em>, it’s baked into HTTP!”</p>
</blockquote>
<p>Not being content with alienating only the general purpose JSON API enthusiasts, let me know proceed to also alienate
my erstwhile hypermedia enthusiast allies by saying: </p>
<p><em>I don’t think content negotiation is typically the right approach to
returning both JSON and HTML for most applications.</em></p>
<h2 id="what-is-content-negotiation"><a href="#what-is-content-negotiation" aria-label="Anchor link for: what-is-content-negotiation">#</a>What Is Content Negotiation?</h2>
<p>First things first, what is “content negotiation”?</p>
<p><a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation">Content negotiation</a> is a feature of HTTP that
allows a client to negotiate the content type of the response from a server.  A full treatment of the implementation 
in HTTP is beyond the scope of this essay, but let us consider the most well known mechanism for content negotiation
in HTTP, the <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation#the_accept_header"><code>Accept</code> Request Header</a>.</p>
<p>The <code>Accept</code> request header allows a client, such as a browser, to indicate the <code>MIME</code> types that it is willing to accept
from the server in a response.</p>
<p>An example value of this header is:</p>
<pre data-lang="http request"><code data-lang="http request"><span>Accept: text/html, application/xhtml+xml, application/xml;q=0.9, image/webp, */*;q=0.8
</span></code></pre>
<p>This <code>Accept</code> header tells the server what formats the client is willing to accept.  Preferences are expressed via the
<code>q</code> weighting factor.  Wildcards are expressed with asterisks <code>*</code>.</p>
<p>In this case, the client is saying:</p>
<blockquote>
<p>I would most like to receive text/html, application/xhtml+xml or image/webp.  Next I would prefer application/xml. Finally, I will accept whatever you give me.</p>
</blockquote>
<p>The server then can take this information and determine the best content type to provide to the client.</p>
<p>This is the act of “content negotiation” and it is certainly an interesting feature of HTTP.</p>
<h2 id="using-content-negotiation-in-apis"><a href="#using-content-negotiation-in-apis" aria-label="Anchor link for: using-content-negotiation-in-apis">#</a>Using Content Negotiation In APIs</h2>
<p>As far as I am aware, it was the <a rel="noopener" target="_blank" href="https://rubyonrails.org/">Ruby On Rails</a> community that first went in in a big way
using content negotiation to provide both HTML and JSON (and other) formats from the same URL.</p>
<p>In Rails, this is accomplished via the <a rel="noopener" target="_blank" href="https://apidock.com/rails/ActionController/MimeResponds/respond_to"><code>respond_to</code></a> helper method available in 
controllers.</p>
<p>Leaving the gory details of Rails aside, you might have a request like an HTTP <code>GET</code> to <code>/contacts</code> that ends up invoking
a function in a <code>ContactsController</code> class that looks like this:</p>
<pre data-lang="ruby"><code data-lang="ruby"><span>def </span><span>index
</span><span>  </span><span>@contacts </span><span>= </span><span>Contacts</span><span>.all
</span><span>
</span><span>  respond_to </span><span>do </span><span>|</span><span>format</span><span>|
</span><span>    </span><span>format</span><span>.html </span><span># default rendering logic
</span><span>    </span><span>format</span><span>.json { render </span><span>json: </span><span>@contacts </span><span>}
</span><span>  </span><span>end
</span><span>end
</span></code></pre>
<p>By making use of the <code>respond_to</code> helper method, if a client makes a request with the <code>Accept</code> header above, the controller
will render an HTML response using the Rails templating systems.</p>
<p>However, if the <code>Accept</code> header from the client has the value <code>application/json</code> instead, Rails will render the contacts 
as a JSON array for the client.</p>
<p>A pretty neat trick: you can keep all your controller logic, like looking up the contacts, the same and just use a 
bit of ruby/Rails magic to render two different response types using content negotiation.  Barely any additional work on 
top of the normal Model/View/Controller logic.</p>
<p>You can see why people like the idea!</p>
<h2 id="so-what-s-the-problem"><a href="#so-what-s-the-problem" aria-label="Anchor link for: so-what-s-the-problem">#</a>So What’s The Problem?</h2>
<p>So why don’t I think this is a good approach to splitting your JSON and HTML APIs up?</p>
<p>It boils down to the <a href="https://htmx.org/essays/why-tend-not-to-use-content-negotiation/hypermedia-apis-vs-data-apis.md">differences between JSON APIs and Hypermedia (HTML) APIs</a> I hinted
at earlier.  In particular:</p>
<ul>
<li>Data APIs should be versioned and should be very stable within a particular version of the API</li>
<li>Data APIs should strive for both regularity and expressiveness due to the arbitrary data needs of consumers</li>
<li>Data APIs typically use some sort of token-based authentication</li>
<li>Data APIs should be rate limited</li>
<li>Hypermedia APIs typically use some sort of session-cookie based authentication</li>
<li>Hypermedia APIs should be driven by the needs of the underlying hypermedia application</li>
</ul>
<p>While all of these differences matter and have an effect on your controller code, pulling it in two different directions,
it is really the first and last items that make me often choose not to use content negotiation in my applications.</p>
<p>Your JSON API needs to be a stable set of endpoint that client code can rely on.</p>
<p>Your hypermedia API, on the other hand, can change dramatically based on the user interface needs of your applications.</p>
<p>These two things don’t mix well.</p>
<p>To give you a concrete example, consider an end point that renders a detail view of a contact, at, say <code>/contacts/:id</code> 
(where <code>:id</code> is a parameter containing the id of the contact to render).  Let’s say that this page has a “related contacts”
section of the UI and, further, computing these related contacts is expensive for some reason.</p>
<p>In this situation you might choose to use the <a rel="noopener" target="_blank" href="https://htmx.org/examples/lazy-load/">Lazy Loading</a> pattern to defer 
loading the related contacts until after the initial contact detail screen has been rendered.  This improves perceived
performance of the page for your users.</p>
<p>If you did this, you might put the lazy loaded content at the end-point <code>/contacts/:id/related</code>.</p>
<p>Now, later on, maybe you are able to optimize the computation of related contacts.  At this point you might choose to 
rip the <code>/contacts/:id/related</code> end-point out and just render the related contacts information in the initial page render.</p>
<p>All of this is fine for your hypermedia API: hypermedia, through <a href="https://htmx.org/essays/hateoas/">the uniform interface &amp; HATEOAS</a>
is <em>designed</em> to handle these sorts of changes.</p>
<p>However, your JSON API… not so much.</p>
<p>Your JSON API should remain stable.  You can’t be adding and removing end-points
willy-nilly.  Yes, you can have <em>some</em> end-points respond with either JSON or HTML and others only respond with HTML, but
it gets messy.  What if you accidentally copy-and-paste in the wrong code somewhere, for example.</p>
<p>Taking all of this into account, as well as things like rate-limiting and so on, I think you can make a strong argument
that there should be a <a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Separation_of_concerns">Separation Of Concerns</a> between the JSON
API and the hypermedia API.</p>
<p>(Yes, I am aware of the irony that the person who coined the term <a href="https://htmx.org/essays/locality-of-behaviour/">Locality of Behaviour</a>
is making a SoC argument.)</p>
<h2 id="so-what-s-the-alternative"><a href="#so-what-s-the-alternative" aria-label="Anchor link for: so-what-s-the-alternative">#</a>So What’s The Alternative?</h2>
<p>The alternative is to, as I advocate in <a href="https://htmx.org/essays/splitting-your-apis/">Splitting Your APIs</a>, erm, splitting your
APIs.  This means providing different paths (or sub-domains, or whatever) for your JSON API and your hypermedia (HTML)
API.</p>
<p>Going back to our contacts API, we might have the following:</p>
<ul>
<li>The JSON API to get all contacts is found at <code>/api/v1/contacts</code></li>
<li>The Hypermedia API to get all contacts is found at <code>/contacts</code></li>
</ul>
<p>This layout implies two different controllers and, I say, that’s a good thing: the JSON API controller can implement the
requirements of a JSON API: rate limiting, stability, maybe an expressive query mechanism like GraphQL.</p>
<p>Meanwhile, your
hypermedia API (really, just your Hypermedia Driven Application endpoints) can change dramatically as your user interface
needs change, with highly tuned database queries, end-points to support special UI needs, etc.</p>
<p>By separating these two concerns, your JSON API can be stable, regular and low-maintenance, and your hypermedia API can
be chaotic, specialized and flexible.  Each gets its own controller environment to thrive in, without conflicting with
one another.</p>
<p>And this is why I prefer to split my JSON and hypermedia APIs up into separate controllers, rather than use HTTP content
negotiation to attempt to reuse controllers for both.</p>

  <p>
    &lt;/&gt;
  </p>
</div></div>
  </body>
</html>
