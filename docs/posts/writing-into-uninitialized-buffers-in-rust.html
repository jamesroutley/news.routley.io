<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sunfishcode.online/writingintouninitializedbuffersinrust/">Original</a>
    <h1>Writing into Uninitialized Buffers in Rust</h1>
    
    <div id="readability-page-1" class="page"><article>
  

  
    <p>Posted on <time datetime="2025-03-11T00:00:00+00:00">March 11, 2025</time></p>
  

  <p>Uninitialized buffers in Rust are a long-standing question, for example:</p>
<ul>
<li><a href="https://rust-lang.github.io/rfcs/2930-read-buf.html">https://rust-lang.github.io/rfcs/2930-read-buf.html</a></li>
<li><a href="https://doc.rust-lang.org/nightly/unstable-book/library-features/core-io-borrowed-buf.html">https://doc.rust-lang.org/nightly/unstable-book/library-features/core-io-borrowed-buf.html</a></li>
<li><a href="https://blog.yoshuawuyts.com/uninit-read-write/">https://blog.yoshuawuyts.com/uninit-read-write/</a></li>
<li><a href="https://internals.rust-lang.org/t/reading-into-uninitialized-buffers-yet-again/13282/4">https://internals.rust-lang.org/t/reading-into-uninitialized-buffers-yet-again/13282/4</a></li>
</ul>
<p>Recently, <a href="https://notgull.net/">John Nunley</a> and <a href="https://alexsaveau.dev/blog">Alex Saveau</a> came up with an idea for a new
approach, using a <code>Buffer</code> trait, which is now <a href="https://docs.rs/rustix/1/rustix/buffer/trait.Buffer.html">in rustix 1.0</a>, which I&#39;ll
describe in this post.</p>
<p>Update: This idea is now available in a standalone published library: <a href="https://crates.io/crates/buffer-trait">buffer-trait</a>.</p>
<h2 id="introducing-the-buffer-trait">Introducing the <code>Buffer</code> trait</h2>
<p>The POSIX <code>read</code> function reads bytes from a file descriptor into a buffer,
and it can read fewer bytes than requested. Using <code>Buffer</code>, <a href="https://docs.rs/rustix/1/rustix/io/fn.read.html"><code>read</code></a> in
rustix looks like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub fn </span><span>read</span><span>&lt;Fd: AsFd, Buf: Buffer&lt;</span><span>u8</span><span>&gt;&gt;(</span><span>fd</span><span>: Fd, </span><span>buf</span><span>: Buf) -&gt; Result&lt;</span><span>Buf::</span><span>Output&gt;
</span></code></pre>
<p>This uses the <code>Buffer</code> trait to describe the buffer argument. The <code>Buffer</code> trait
looks like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub trait </span><span>Buffer&lt;T&gt; {
</span><span>    </span><span>/// The type of the value returned by functions with `Buffer` arguments.
</span><span>    </span><span>type </span><span>Output;
</span><span>
</span><span>    </span><span>/// Return a raw pointer and length to the underlying buffer.
</span><span>    </span><span>fn </span><span>parts_mut</span><span>(&amp;</span><span>mut </span><span>self</span><span>) -&gt; (</span><span>*mut</span><span> T, </span><span>usize</span><span>);
</span><span>
</span><span>    </span><span>/// Assert that `len` elements were written to, and provide a return value.
</span><span>    </span><span>unsafe fn </span><span>assume_init</span><span>(</span><span>self</span><span>, </span><span>len</span><span>: </span><span>usize</span><span>) -&gt; </span><span>Self::</span><span>Output;
</span><span>}
</span></code></pre>
<p>(And thanks to <a href="https://blog.yoshuawuyts.com/">Yoshua Wuyts</a> for feedback on this trait and encouragement
for the overall idea!)</p>
<p>(Rustix&#39;s own <a href="https://docs.rs/rustix/1/rustix/buffer/trait.Buffer.html"><code>Buffer</code> trait</a> is sealed and its functions are private, but
that&#39;s just rustix choosing for now to reserve the ability to evolve the trait
without breaking compatibility, at the expense of not allowing users to use
<code>Buffer</code> for defining their own I/O functions, for now.)</p>
<p><code>Buffer</code> is implemented for <code>&amp;mut [T]</code>, so users can pass <code>read</code> a <code>&amp;mut [u8]</code>
buffer to write into, and it&#39;ll return a <code>Result&lt;usize&gt;</code>, where the <code>usize</code>
indicates how many bytes were actually read, on success. This matches how
<a href="https://docs.rs/rustix/0.38.44/rustix/io/fn.read.html"><code>read</code> in rustix used to work</a>. Using this looks like:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> buf = [</span><span>0_</span><span>u8</span><span>; </span><span>16</span><span>];
</span><span>let</span><span> num_read = </span><span>read</span><span>(fd, &amp;</span><span>mut</span><span> buf)?;
</span><span>use</span><span>(&amp;buf[..num_read]);
</span></code></pre>
<p><code>Buffer</code> is also implemented for <code>&amp;mut [MaybeUninit&lt;T&gt;]</code>, so users can pass
<code>read</code> a <code>&amp;mut [MaybeUninit&lt;u8&gt;]</code>, and in that case, they&#39;ll get back a
<code>Result&lt;(&amp;mut [u8], &amp;mut [MaybeUninit&lt;u8&gt;])&gt;</code>. On success, that provides a pair
of slices which are subslices of the original buffer, containing the range
of bytes that data was read into, and the remaining bytes that remain
uninitialized. Rustix previously had a function called <a href="https://docs.rs/rustix/0.38.44/rustix/io/fn.read_uninit.html"><code>read_uninit</code></a> that
worked this way, and in rustix 1.0 it&#39;s replaced by this new <code>Buffer</code>-enabled
<code>read</code> function. Using this looks like:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> buf = [MaybeUninit::&lt;</span><span>u8</span><span>&gt;::uninit(); </span><span>16</span><span>];
</span><span>let </span><span>(init, uninit) = </span><span>read</span><span>(fd, &amp;</span><span>mut</span><span> buf)?;
</span><span>use</span><span>(init);
</span></code></pre>
<p>This allows reading into uninitialized buffers with a safe API.</p>
<p>And, <code>Buffer</code> also supports a way to read into the spare capacity of a <code>Vec</code>.
The <a href="https://docs.rs/rustix/1/rustix/buffer/fn.spare_capacity.html"><code>spare_capacity</code></a> function takes a <code>&amp;mut Vec&lt;T&gt;</code> and returns a
<a href="https://docs.rs/rustix/1/rustix/buffer/struct.SpareCapacity.html"><code>SpareCapacity</code></a> newtype which implements <code>Buffer</code>, and it automatically
sets the length of the vector to include the number of initialized elements
after the <code>read</code>, encapsulating the unsafety of <code>Vec::set_len</code>. Using this looks like:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> buf = Vec::&lt;</span><span>u8</span><span>&gt;::with_capacity(</span><span>1024</span><span>);
</span><span>let</span><span> num_read = </span><span>read</span><span>(fd, </span><span>spare_capacity</span><span>(&amp;</span><span>mut</span><span> buf))?;
</span><span>use</span><span>(&amp;buf);
</span></code></pre>
<p>In rustix, all functions that previously took <code>&amp;mut [u8]</code> buffers to write into
now take <code>impl Buffer&lt;u8&gt;</code> buffers, so they support writing into uninitialized
buffers.</p>
<h2 id="under-the-covers">Under the covers</h2>
<p><code>read</code> is implemented <a href="https://docs.rs/rustix/1/src/rustix/io/read_write.rs.html#39-44">like this</a>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> len = </span><span>unsafe </span><span>{ backend::io::syscalls::read(fd.</span><span>as_fd</span><span>(), buf.</span><span>parts_mut</span><span>())? };
</span><span>unsafe </span><span>{ Ok(buf.</span><span>assume_init</span><span>(len)) }
</span></code></pre>
<p>First we call the underlying system call, and it returns the number of bytes it
read. We then pass that to <code>assume_init</code>, which computes the <code>Buffer::Output</code> to
return. The output may be just that number, or may be a pair of slices reflecting
that number.</p>
<h2 id="what-if-t-is-not-u8">What if <code>T</code> is not <code>u8</code>?</h2>
<p><code>Buffer</code> uses a type parameter <code>T</code> rather than hard-coding <code>u8</code>, so that it can be
used by functions like <a href="https://docs.rs/rustix/1/rustix/event/epoll/fn.wait.html"><code>epoll::wait</code></a>, <a href="https://docs.rs/rustix/1/x86_64-unknown-freebsd/rustix/event/kqueue/fn.kevent.html"><code>kevent</code></a>, and <a href="https://docs.rs/rustix/1/x86_64-unknown-illumos/rustix/event/port/fn.getn.html"><code>port::get</code></a> to return event
records instead of bytes. Using this can look like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> event_list = Vec::&lt;epoll::Event&gt;::with_capacity(</span><span>16</span><span>);
</span><span>loop </span><span>{
</span><span>    </span><span>let</span><span> _num = epoll::wait(&amp;epoll, </span><span>spare_capacity</span><span>(&amp;</span><span>mut</span><span> event_list), None)?;
</span><span>    </span><span>for</span><span> event in event_list.</span><span>drain</span><span>(..) {
</span><span>        </span><span>handle</span><span>(event);
</span><span>    }
</span><span>}
</span></code></pre>
<p>This drains the <code>Vec</code> with <code>drain</code> so that it&#39;s empty before each <code>wait</code>, because
<code>spare_capacity</code> appends to the <code>Vec</code> rather than overwriting any elements.</p>
<p>There are no dynamic allocations inside the loop; <code>SpareCapacity</code> only uses the
existing spare capacity and only calls <code>set_len</code>, and not <code>resize</code>.</p>
<p>Alternatively, because <code>Buffer</code> also works on slices, this code can be written
without using <code>Vec</code> at all:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> event_list = [MaybeUninit::&lt;epoll::Event&gt;; </span><span>16</span><span>];
</span><span>loop </span><span>{
</span><span>    </span><span>let </span><span>(init, _uninit) = epoll::wait(&amp;epoll, &amp;</span><span>mut</span><span> event_list, None)?;
</span><span>    </span><span>for</span><span> event in init {
</span><span>        </span><span>handle</span><span>(event);
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="error-messages">Error messages</h2>
<p>One downside of the <code>Buffer</code> trait approach is that it sometimes evokes error
messages from rustc which aren&#39;t obvious. This happened enough that we now have
a <a href="https://docs.rs/rustix/1/rustix/buffer/trait.Buffer.html#guide-to-error-messages">section</a> in rustix&#39;s documentation about them, and an <a href="https://github.com/bytecodealliance/rustix/blob/main/examples/buffer_errors.rs">example</a> showing examples
where they come up.</p>
<h2 id="using-buffer-safely">Using <code>Buffer</code> safely</h2>
<p>Rust&#39;s std currently contains an experimental API based on <a href="https://doc.rust-lang.org/stable/std/io/struct.BorrowedBuf.html"><code>BorrowedBuf</code></a>, which
has the nice property of allowing users to use it without using <code>unsafe</code>, and without
doing anything hugely inefficient, such as initializing the full buffer. To
achieve this, <code>BorrowedBuf</code> uses a &#34;double cursor&#34; design to avoid re-initializing
memory that has already been initialized.</p>
<p>The <code>Buffer</code> trait described here is simpler, avoiding the need for a &#34;double cursor&#34;,
however it does have an <code>unsafe</code> required method. Is there a way we could modify it
to support safe use?</p>
<p>A <code>Cursor</code> API like <a href="https://doc.rust-lang.org/stable/std/io/struct.BorrowedCursor.html"><code>BorrowedCursor</code></a> could do it. That supports safely and
incrementally writing into an uninitialized buffer. And a key feature of
<code>BorrowedCursor</code> is that it never requires the full buffer to be eagerly
initialized.</p>
<p>With that, the <code>Buffer</code> trait might look like:</p>
<pre><code><span>pub trait Buffer&lt;T&gt; {
</span><span>    // ... existing contents
</span><span>
</span><span>    /// An alternative to `parts_mut` for use with `init`.
</span><span>    ///
</span><span>    /// Return a `Cursor`.
</span><span>    fn cursor(&amp;mut self) -&gt; Cursor&lt;T&gt; {
</span><span>        Cursor::new(self)
</span><span>    }
</span><span>}
</span><span>
</span><span>impl&lt;T, B: Buffer&lt;T&gt;&gt; Cursor&lt;T, B&gt; {
</span><span>    /// ... cursor API
</span><span>
</span><span>    fn finish(self) -&gt; B::Output {
</span><span>        // SAFETY: `Cursor` ensures that exactly `pos` bytes have been written.
</span><span>        unsafe { self.b.assume_init(selff.pos) }
</span><span>    }
</span><span>}
</span></code></pre>
<p>This way, a user could write their own functions that take <code>Buffer</code> arguments
and implement them using <code>cursor</code>, without using <code>unsafe</code>.</p>
<h2 id="why-parts-mut-and-a-raw-pointer">Why <code>parts_mut</code> and a raw pointer?</h2>
<p>The <code>parts_mut</code> function in the <code>Buffer</code> trait looks like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>parts_mut</span><span>(&amp;</span><span>mut </span><span>self</span><span>) -&gt; (</span><span>*mut</span><span> T, </span><span>usize</span><span>);
</span></code></pre>
<p>Why return a raw pointer and length, instead of a <code>&amp;mut [MaybeUninit&lt;T&gt;]</code>? Because
a <code>&amp;mut [MaybeUninit&lt;T&gt;]</code> would be unsound in a subtle way. We implement <code>Buffer</code>
for <code>&amp;mut [T]</code>, which cannot contain any uninitialized elements, and exposing it
as a <code>&amp;mut [MaybeUninit&lt;T&gt;]</code> would allow uninitialized elements to be written
into it.</p>
<p>With a raw pointer, we put the burden on the <code>assume_init</code> call to guarantee
that the buffer has been written to properly.</p>
<h2 id="looking-forward">Looking forward</h2>
<p>A limited version of this <code>Buffer</code> trait is now <a href="https://docs.rs/rustix/1/rustix/buffer/trait.Buffer.html">in rustix 1.0</a>, so we&#39;ll
see how it goes in practice.</p>
<p>This idea is now also available in a standalone published library: <a href="https://crates.io/crates/buffer-trait">buffer-trait</a>.</p>
<p>If it works out well, I think this <code>Buffer</code> design is worth considering for
Rust&#39;s std, as a replacement for <a href="https://doc.rust-lang.org/stable/std/io/struct.BorrowedBuf.html"><code>BorrowedBuf</code></a> (which is currently unstable).
It&#39;s simpler, as it avoids the &#34;double cursor&#34; pattern, and it has the fun
feature of supporting the <code>Vec</code> spare capacity use case and encapsulating
the unsafe <code>Vec::set_len</code> call.</p>

</article></div>
  </body>
</html>
