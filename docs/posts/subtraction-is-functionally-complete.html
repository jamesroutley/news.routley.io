<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://orlp.net/blog/subtraction-is-functionally-complete/">Original</a>
    <h1>Subtraction is functionally complete</h1>
    
    <div id="readability-page-1" class="page"><article>

<time datetime="2023-09-28">2023-09-28</time>
<p>To be precise, <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE-754</a> floating point
subtraction is <a href="https://en.wikipedia.org/wiki/Functional_completeness">functionally
complete</a>. That means you
can construct any binary circuit using nothing but floating point subtraction.</p>
<p>To see how, we must start at the bottom. I quote the IEEE 754-2019 standard, section 6.3:</p>
<blockquote>
<h3 id="6-3-the-sign-bit"><a href="#6-3-the-sign-bit" aria-label="Anchor link for: 6-3-the-sign-bit">6.3 The sign bit</a></h3>
<p>[…] When neither the inputs nor result are NaN, […]; the sign of a sum, or of a difference $x−y$
regarded as a sum $x+(−y)$, differs from at most one of the addends’ signs; […].
These rules shall apply even when operands or results are zero or infinite.</p>
<p>When the sum of two operands with opposite signs (or the difference of two operands with like
signs) is exactly zero, the sign of that sum (or difference) shall be $+0$ under all rounding-direction
attributes except <code>roundTowardNegative</code>; under that attribute, the sign of an exact zero sum (or
difference) shall be $−0$.</p>
</blockquote>
<p>Let’s dissect that.</p>
<ol>
<li>A subtraction $x - y$ is considered a sum $x + (-y)$.</li>
<li>Zero can have a sign, $-0$ and $0$ are distinct entities (although they compare
equal when testing with <code>==</code>).</li>
<li>If both of the addends have the same sign, the output must have that sign.
However, for $x - y$ that means if $x$ and $y$ have <em>different</em> signs the output
must have the sign of $x$.</li>
<li>If $x$ and $y$ have the same sign, and $x - y$ is zero, the output will be
$+0$ for all rounding modes except <code>roundTowardNegative</code>, then it will be $-0$.</li>
</ol>
<p>Now since the default rounding mode in virtually every context is <code>roundTiesToEven</code>,
we shall assume that from now on. However, everything works analogously even for
<code>roundTowardNegative</code>.</p>
<h2 id="a-truth-table"><a href="#a-truth-table" aria-label="Anchor link for: a-truth-table">A truth table</a></h2>
<p>So, what does that give us when subtracting zeroes?</p>
<pre data-lang="python"><code data-lang="python"><span>-</span><span>0 </span><span>- -</span><span>0 </span><span>= +</span><span>0  </span><span># Same sign, must be +0.
</span><span>-</span><span>0 </span><span>- +</span><span>0 </span><span>= -</span><span>0  </span><span># Different signs, sign from first argument.
</span><span>+</span><span>0 </span><span>- -</span><span>0 </span><span>= +</span><span>0  </span><span># Different signs, sign from first argument.
</span><span>+</span><span>0 </span><span>- +</span><span>0 </span><span>= +</span><span>0  </span><span># Same sign, must be +0.
</span></code></pre>
<p>Interesting… What if we say that $-0$ is false and $+0$ is true?</p>
<pre data-lang="python"><code data-lang="python"><span>A B | O
</span><span>----+--
</span><span>0 0 </span><span>| </span><span>1
</span><span>0 1 </span><span>| </span><span>0
</span><span>1 0 </span><span>| </span><span>1
</span><span>1 1 </span><span>| </span><span>1
</span></code></pre>
<p>Our resulting truth table is equivalent to ${A \vee \neg B}$, or ${B \to A}$ (also known as the
<a href="https://en.wikipedia.org/wiki/IMPLY_gate">IMPLY</a> gate, albeit with the arguments swapped). It turns
out this truth table is <a href="https://en.wikipedia.org/wiki/Functional_completeness">functionally
complete</a>, which means we can make arbitrary
circuits using only this gate.
Technically speaking, it is only functionally complete if given access to the
constant false. This is necessary to produce a NOT gate, and NOT + IMPLY is
a functionally complete set. I don’t know a better term for ‘functionally complete
if given access to some constant value’, however.</p>

<h2 id="subtraction-circuits"><a href="#subtraction-circuits" aria-label="Anchor link for: subtraction-circuits">Subtraction circuits</a></h2>
<p>Let’s build a demo in Python. First we’ll define our constants and allow us to print them nicely.
Note that even though they are distinct entities, $+0$ and $-0$ compare equal in IEEE 754 floating
point, so we must first extract the sign before comparing to 0 to distinguish.</p>
<pre data-lang="python"><code data-lang="python"><span>import </span><span>math
</span><span>
</span><span>f_false = -</span><span>0.0
</span><span>f_true = </span><span>0.0
</span><span>f_repr = </span><span>lambda </span><span>x: </span><span>True </span><span>if </span><span>math.copysign(</span><span>1</span><span>, x) &gt; </span><span>0 </span><span>else </span><span>False
</span></code></pre>
<p>We can now make a NOT gate by using the fact that $-0 - x$ flips the sign of
zero $x$:</p>
<pre data-lang="python"><code data-lang="python"><span>f_not = </span><span>lambda </span><span>x: f_false - x
</span></code></pre>
<p>Let’s test that:</p>
<pre data-lang="python"><code data-lang="python"><span>&gt;&gt;&gt; f_repr(f_not(f_false))
</span><span>True
</span><span>&gt;&gt;&gt; f_repr(f_not(f_true))
</span><span>False
</span></code></pre>
<p>Great! We can also build an OR gate by noticing that if we flip the sign of
the second argument before subtracting, we always get $+0$ (true) unless
both arguments are $-0$ (false):</p>
<pre data-lang="python"><code data-lang="python"><span>f_or = </span><span>lambda </span><span>a, b: a - f_not(b)
</span></code></pre>
<p>Let’s test it out:</p>
<pre data-lang="python"><code data-lang="python"><span>&gt;&gt;&gt; f_repr(f_or(f_false, f_false))
</span><span>False
</span><span>&gt;&gt;&gt; f_repr(f_or(f_true,  f_false))
</span><span>True
</span><span>&gt;&gt;&gt; f_repr(f_or(f_false, f_true))
</span><span>True
</span><span>&gt;&gt;&gt; f_repr(f_or(f_true, f_true))
</span><span>True
</span></code></pre>
<p>Now that we have OR and NOT, we can make all other gates, e.g.:</p>
<pre data-lang="python"><code data-lang="python"><span>f_and = </span><span>lambda </span><span>a, b: f_not(f_or(f_not(a), f_not(b)))
</span><span>f_xor = </span><span>lambda </span><span>a, b: f_or(f_and(f_not(a), b), f_and(a, f_not(b)))
</span></code></pre>
<pre data-lang="python"><code data-lang="python"><span>&gt;&gt;&gt; f_repr(f_and(f_false, f_false))
</span><span>False
</span><span>&gt;&gt;&gt; f_repr(f_and(f_true,  f_false))
</span><span>False
</span><span>&gt;&gt;&gt; f_repr(f_and(f_false, f_true))
</span><span>False
</span><span>&gt;&gt;&gt; f_repr(f_and(f_true, f_true))
</span><span>True
</span><span>
</span><span>&gt;&gt;&gt; f_repr(f_xor(f_false, f_false))
</span><span>False
</span><span>&gt;&gt;&gt; f_repr(f_xor(f_true,  f_false))
</span><span>True
</span><span>&gt;&gt;&gt; f_repr(f_xor(f_false, f_true))
</span><span>True
</span><span>&gt;&gt;&gt; f_repr(f_xor(f_true, f_true))
</span><span>False
</span></code></pre>
<h2 id="software-integers"><a href="#software-integers" aria-label="Anchor link for: software-integers">Software integers</a></h2>
<p>You may have heard of soft-float, software implementations of floating point
using integers. Let’s turn that on its head: an integer implementation done in
software, using only floating point ops. Let’s do it in Rust so we can look at
the final assembly output to see how <del>horrifically slow</del> awesome it is.</p>
<pre data-lang="rust"><code data-lang="rust"><span>type </span><span>Bit = </span><span>f32</span><span>;
</span><span>const </span><span>ZERO</span><span>: Bit = -</span><span>0.0</span><span>;
</span><span>const </span><span>ONE</span><span>: Bit = </span><span>0.0</span><span>;
</span><span>
</span><span>fn </span><span>not(x: Bit) -&gt; Bit { </span><span>ZERO </span><span>- x }
</span><span>fn </span><span>or(a: Bit, b: Bit) -&gt; Bit { a - not(b) }
</span><span>fn </span><span>and(a: Bit, b: Bit) -&gt; Bit { not(or(not(a), not(b))) }
</span><span>fn </span><span>xor(a: Bit, b: Bit) -&gt; Bit { or(and(not(a), b), and(a, not(b))) }
</span><span>fn </span><span>adder(a: Bit, b: Bit, c: Bit) -&gt; (Bit, Bit) {
</span><span>    </span><span>let</span><span> s = xor(xor(a, b), c);
</span><span>    </span><span>let</span><span> c = or(and(xor(a, b), c), and(a, b));
</span><span>    (s, c)
</span><span>}
</span><span>
</span><span>type </span><span>SoftU8 = [Bit; </span><span>8</span><span>];
</span><span>
</span><span>pub </span><span>fn </span><span>softu8_add(a: SoftU8, b: SoftU8) -&gt; SoftU8 {
</span><span>    </span><span>let </span><span>(s0, c) = adder(a[</span><span>0</span><span>], b[</span><span>0</span><span>], </span><span>ZERO</span><span>);
</span><span>    </span><span>let </span><span>(s1, c) = adder(a[</span><span>1</span><span>], b[</span><span>1</span><span>], c);
</span><span>    </span><span>let </span><span>(s2, c) = adder(a[</span><span>2</span><span>], b[</span><span>2</span><span>], c);
</span><span>    </span><span>let </span><span>(s3, c) = adder(a[</span><span>3</span><span>], b[</span><span>3</span><span>], c);
</span><span>    </span><span>let </span><span>(s4, c) = adder(a[</span><span>4</span><span>], b[</span><span>4</span><span>], c);
</span><span>    </span><span>let </span><span>(s5, c) = adder(a[</span><span>5</span><span>], b[</span><span>5</span><span>], c);
</span><span>    </span><span>let </span><span>(s6, c) = adder(a[</span><span>6</span><span>], b[</span><span>6</span><span>], c);
</span><span>    </span><span>let </span><span>(s7, _) = adder(a[</span><span>7</span><span>], b[</span><span>7</span><span>], c);
</span><span>    [s0, s1, s2, s3, s4, s5, s6, s7]
</span><span>}
</span><span>
</span><span>// Hmm? u8? What&#39;s that? Shhhh....
</span><span>pub </span><span>fn </span><span>to_softu8(x: </span><span>u8</span><span>) -&gt; SoftU8 {
</span><span>    std::array::from_fn(|i| </span><span>if </span><span>(x &gt;&gt; i) &amp; </span><span>1 </span><span>== </span><span>1 </span><span>{ </span><span>ONE </span><span>} </span><span>else </span><span>{ </span><span>ZERO </span><span>})
</span><span>}
</span><span>
</span><span>pub </span><span>fn </span><span>from_softu8(x: SoftU8) -&gt; </span><span>u8 </span><span>{
</span><span>    (</span><span>0</span><span>..</span><span>8</span><span>).filter(|i| x[*i].signum() &gt; </span><span>0.0</span><span>).map(|i| </span><span>1 </span><span>&lt;&lt; i).sum()
</span><span>}
</span><span>
</span><span>fn </span><span>main() {
</span><span>    </span><span>let</span><span> a = to_softu8(</span><span>23</span><span>);
</span><span>    </span><span>let</span><span> b = to_softu8(</span><span>19</span><span>);
</span><span>    println!(</span><span>&#34;</span><span>{}</span><span>&#34;</span><span>, from_softu8(softu8_add(a, b)));
</span><span>}
</span></code></pre>
<p>It’s horrible, but it works, it dutifully prints 42. And it <em>only</em> took $\approx 120$
floating point instructions to add two 8-bit integers:</p>

<pre data-lang="asm"><code data-lang="asm"><span>example::softu8_add:
</span><span>        </span><span>mov     </span><span>rax, rdi
</span><span>        </span><span>movups  </span><span>xmm2, xmmword ptr [rsi]
</span><span>        </span><span>movups  </span><span>xmm0, xmmword ptr [rdx]
</span><span>        </span><span>movaps  </span><span>xmm3, xmm2
</span><span>        </span><span>subps   </span><span>xmm3, xmm0
</span><span>        </span><span>movaps  </span><span>xmm4, xmm0
</span><span>        </span><span>subps   </span><span>xmm4, xmm2
</span><span>        </span><span>movaps  </span><span>xmm1, xmmword ptr [rip + .LCPI0_0]
</span><span>        </span><span>xorps   </span><span>xmm4, xmm1
</span><span>        </span><span>subps   </span><span>xmm4, xmm3
</span><span>        </span><span>xorps   </span><span>xmm3, xmm3
</span><span>        </span><span>subss   </span><span>xmm3, xmm4
</span><span>        </span><span>movaps  </span><span>xmm6, xmm0
</span><span>        </span><span>xorps   </span><span>xmm6, xmm1
</span><span>        </span><span>subss   </span><span>xmm6, xmm2
</span><span>        </span><span>xorps   </span><span>xmm6, xmm1
</span><span>        </span><span>subss   </span><span>xmm6, xmm3
</span><span>        </span><span>movaps  </span><span>xmm3, xmm4
</span><span>        </span><span>shufps  </span><span>xmm3, xmm4, </span><span>85
</span><span>        </span><span>movaps  </span><span>xmm5, xmm6
</span><span>        </span><span>subss   </span><span>xmm5, xmm3
</span><span>        </span><span>xorps   </span><span>xmm5, xmm1
</span><span>        </span><span>movaps  </span><span>xmm10, xmm6
</span><span>        </span><span>xorps   </span><span>xmm10, xmm1
</span><span>        </span><span>subss   </span><span>xmm10, xmm3
</span><span>        </span><span>movaps  </span><span>xmm7, xmm0
</span><span>        </span><span>shufps  </span><span>xmm7, xmm0, </span><span>85
</span><span>        </span><span>xorps   </span><span>xmm7, xmm1
</span><span>        </span><span>movaps  </span><span>xmm3, xmm2
</span><span>        </span><span>shufps  </span><span>xmm3, xmm2, </span><span>85
</span><span>        </span><span>subss   </span><span>xmm7, xmm3
</span><span>        </span><span>xorps   </span><span>xmm7, xmm1
</span><span>        </span><span>movaps  </span><span>xmm8, xmm4
</span><span>        </span><span>unpckhpd        </span><span>xmm8, xmm4
</span><span>        </span><span>movaps  </span><span>xmm3, xmm0
</span><span>        </span><span>unpckhpd        </span><span>xmm3, xmm0
</span><span>        </span><span>xorps   </span><span>xmm3, xmm1
</span><span>        </span><span>movaps  </span><span>xmm9, xmm2
</span><span>        </span><span>unpckhpd        </span><span>xmm9, xmm2
</span><span>        </span><span>subss   </span><span>xmm3, xmm9
</span><span>        </span><span>xorps   </span><span>xmm3, xmm1
</span><span>        </span><span>xorps   </span><span>xmm11, xmm11
</span><span>        </span><span>movaps  </span><span>xmm9, xmm4
</span><span>        </span><span>shufps  </span><span>xmm9, xmm4, </span><span>255
</span><span>        </span><span>subss   </span><span>xmm7, xmm10
</span><span>        </span><span>movaps  </span><span>xmm10, xmm7
</span><span>        </span><span>xorps   </span><span>xmm10, xmm1
</span><span>        </span><span>subss   </span><span>xmm10, xmm8
</span><span>        </span><span>subss   </span><span>xmm3, xmm10
</span><span>        </span><span>unpcklps        </span><span>xmm7, xmm3
</span><span>        </span><span>shufps  </span><span>xmm6, xmm7, </span><span>64
</span><span>        </span><span>addps   </span><span>xmm11, xmm4
</span><span>        </span><span>movlhps </span><span>xmm5, xmm4
</span><span>        </span><span>subps   </span><span>xmm4, xmm6
</span><span>        </span><span>movss   </span><span>xmm4, xmm11
</span><span>        </span><span>subps   </span><span>xmm7, xmm8
</span><span>        </span><span>xorps   </span><span>xmm7, xmm1
</span><span>        </span><span>shufps  </span><span>xmm5, xmm7, </span><span>66
</span><span>        </span><span>subps   </span><span>xmm5, xmm4
</span><span>        </span><span>xorps   </span><span>xmm3, xmm1
</span><span>        </span><span>subss   </span><span>xmm3, xmm9
</span><span>        </span><span>shufps  </span><span>xmm0, xmm0, </span><span>255
</span><span>        </span><span>xorps   </span><span>xmm0, xmm1
</span><span>        </span><span>shufps  </span><span>xmm2, xmm2, </span><span>255
</span><span>        </span><span>subss   </span><span>xmm0, xmm2
</span><span>        </span><span>xorps   </span><span>xmm0, xmm1
</span><span>        </span><span>movups  </span><span>xmmword ptr [rdi], xmm5
</span><span>        </span><span>movups  </span><span>xmm2, xmmword ptr [rdx + </span><span>16</span><span>]
</span><span>        </span><span>movaps  </span><span>xmm5, xmm2
</span><span>        </span><span>xorps   </span><span>xmm5, xmm1
</span><span>        </span><span>movups  </span><span>xmm7, xmmword ptr [rsi + </span><span>16</span><span>]
</span><span>        </span><span>subss   </span><span>xmm5, xmm7
</span><span>        </span><span>xorps   </span><span>xmm5, xmm1
</span><span>        </span><span>movaps  </span><span>xmm4, xmm2
</span><span>        </span><span>shufps  </span><span>xmm4, xmm2, </span><span>85
</span><span>        </span><span>xorps   </span><span>xmm4, xmm1
</span><span>        </span><span>movaps  </span><span>xmm6, xmm2
</span><span>        </span><span>movaps  </span><span>xmm8, xmm7
</span><span>        </span><span>movaps  </span><span>xmm9, xmm7
</span><span>        </span><span>subps   </span><span>xmm9, xmm2
</span><span>        </span><span>subps   </span><span>xmm2, xmm7
</span><span>        </span><span>shufps  </span><span>xmm7, xmm7, </span><span>85
</span><span>        </span><span>subss   </span><span>xmm4, xmm7
</span><span>        </span><span>xorps   </span><span>xmm4, xmm1
</span><span>        </span><span>movhlps </span><span>xmm6, xmm6
</span><span>        </span><span>xorps   </span><span>xmm6, xmm1
</span><span>        </span><span>movhlps </span><span>xmm8, xmm8
</span><span>        </span><span>subss   </span><span>xmm6, xmm8
</span><span>        </span><span>xorps   </span><span>xmm6, xmm1
</span><span>        </span><span>xorps   </span><span>xmm2, xmm1
</span><span>        </span><span>subps   </span><span>xmm2, xmm9
</span><span>        </span><span>subss   </span><span>xmm0, xmm3
</span><span>        </span><span>movaps  </span><span>xmm3, xmm0
</span><span>        </span><span>xorps   </span><span>xmm3, xmm1
</span><span>        </span><span>subss   </span><span>xmm3, xmm2
</span><span>        </span><span>subss   </span><span>xmm5, xmm3
</span><span>        </span><span>unpcklps        </span><span>xmm0, xmm5
</span><span>        </span><span>xorps   </span><span>xmm5, xmm1
</span><span>        </span><span>movaps  </span><span>xmm3, xmm2
</span><span>        </span><span>shufps  </span><span>xmm3, xmm2, </span><span>85
</span><span>        </span><span>subss   </span><span>xmm5, xmm3
</span><span>        </span><span>subss   </span><span>xmm4, xmm5
</span><span>        </span><span>movaps  </span><span>xmm3, xmm4
</span><span>        </span><span>xorps   </span><span>xmm3, xmm1
</span><span>        </span><span>movaps  </span><span>xmm5, xmm2
</span><span>        </span><span>unpckhpd        </span><span>xmm5, xmm2
</span><span>        </span><span>subss   </span><span>xmm3, xmm5
</span><span>        </span><span>subss   </span><span>xmm6, xmm3
</span><span>        </span><span>unpcklps        </span><span>xmm4, xmm6
</span><span>        </span><span>movlhps </span><span>xmm0, xmm4
</span><span>        </span><span>movaps  </span><span>xmm3, xmm2
</span><span>        </span><span>subps   </span><span>xmm3, xmm0
</span><span>        </span><span>subps   </span><span>xmm0, xmm2
</span><span>        </span><span>xorps   </span><span>xmm0, xmm1
</span><span>        </span><span>subps   </span><span>xmm0, xmm3
</span><span>        </span><span>movups  </span><span>xmmword ptr [rdi + </span><span>16</span><span>], xmm0
</span><span>        </span><span>ret
</span></code></pre>

</article></div>
  </body>
</html>
