<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sandordargo.com/blog/2025/10/08/cpp26-range-support-for-std-optional">Original</a>
    <h1>C&#43;&#43;26: range support for std:optional</h1>
    
    <div id="readability-page-1" class="page"><div><p>I learned about the new range API of <code>std::optional</code> from Steve Downey at <a href="https://www.sandordargo.com/blog/2025/09/24/trip-report-cppcon-2025">CppCon 2025</a> during his <a href="https://www.sandordargo.com/blog/2025/10/01/cpp26-optional-of-reference">talk about <code>std::optional&lt;T&amp;&gt;</code></a>. To be honest, I found the idea quite strange at first. I wanted to dig deeper to understand the motivation and the implications.</p><p>The first example I encountered was this:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>void</span> <span>doSomething</span><span>(</span><span>std</span><span>::</span><span>string</span> <span>const</span><span>&amp;</span> <span>data</span><span>,</span> 
                 <span>std</span><span>::</span><span>optional</span><span>&lt;</span><span>Logger</span><span>&amp;&gt;</span> <span>logger</span> <span>=</span> <span>{})</span> <span>{</span>
    <span>for</span> <span>(</span><span>auto</span> <span>l</span> <span>:</span> <span>logger</span><span>)</span> <span>{</span>
        <span>l</span><span>.</span><span>log</span><span>(</span><span>data</span><span>);</span>
    <span>}</span>
    <span>return</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>This shows that you can <em>iterate</em> over an <code>optional</code>. In fact, iterating over an optional means the loop will execute either zero or one time. That’s neat — but at first glance, you might ask: why on Earth would anyone want to do that?</p><p>After all, you could just write:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>void</span> <span>doSomething</span><span>(</span><span>std</span><span>::</span><span>string</span> <span>const</span><span>&amp;</span> <span>data</span><span>,</span> 
                 <span>std</span><span>::</span><span>optional</span><span>&lt;</span><span>Logger</span><span>&amp;&gt;</span> <span>logger</span> <span>=</span> <span>{})</span> <span>{</span>
    <span>if</span> <span>(</span><span>logger</span><span>.</span><span>has_value</span><span>())</span> <span>{</span>
        <span>l</span><span>-&gt;</span><span>log</span><span>(</span><span>data</span><span>);</span>
    <span>}</span>
    <span>return</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>Sure, you need pointer semantics, but if you dislike the arrow operator, you can write <code>logger.value().log(data)</code>. It’s slightly longer, but arguably more expressive. So what’s the real value of the range-based approach?</p><p>Well, the people writing the standard are not exactly known for adding features “just because” - they are smart and considerate. I figured there had to be more compelling examples that didn’t fit into a presentation slide. And indeed, there are.</p><h2 id="when-optional-meets-ranges">When <code>optional</code> Meets Ranges</h2><p>A great use case appears when chaining ranges involving optional values. The range API allows us to avoid explicit null checks in pipelines where missing values are simply skipped.</p><p>Here’s an example from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3168r2.html">P3168R2</a>:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td><pre><span>// Example from P3168R2: start from a set of values, apply multiple range operations involving optional values.</span>
<span>std</span><span>::</span><span>unordered_set</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>s</span><span>{</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>};</span>
<span>const</span> <span>auto</span> <span>flt</span> <span>=</span> <span>[</span><span>&amp;</span><span>](</span><span>int</span> <span>i</span><span>)</span> <span>-&gt;</span> <span>std</span><span>::</span><span>optional</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>s</span><span>.</span><span>contains</span><span>(</span><span>i</span><span>))</span> <span>{</span>
        <span>return</span> <span>i</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>{};</span>
    <span>}</span>
<span>};</span>

<span>for</span> <span>(</span><span>auto</span> <span>i</span> <span>:</span> <span>std</span><span>::</span><span>views</span><span>::</span><span>iota</span><span>(</span><span>1</span><span>,</span> <span>10</span><span>)</span> <span>|</span> <span>std</span><span>::</span><span>views</span><span>::</span><span>transform</span><span>(</span><span>flt</span><span>))</span> <span>{</span>
    <span>for</span> <span>(</span><span>auto</span> <span>j</span> <span>:</span> <span>i</span><span>)</span> <span>{</span> <span>// no need to transform</span>
        <span>for</span> <span>(</span><span>auto</span> <span>k</span> <span>:</span> <span>std</span><span>::</span><span>views</span><span>::</span><span>iota</span><span>(</span><span>0</span><span>,</span> <span>j</span><span>))</span> <span>{</span>
            <span>// std::cout &lt;&lt; &#39;\a&#39;; // do not actually log in tests</span>
            <span>std</span><span>::</span><span>ignore</span> <span>=</span> <span>k</span><span>;</span>
        <span>}</span>
        <span>// std::cout &lt;&lt; &#39;\n&#39;; // do not actually log in tests</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>This is where <code>std::optional</code> as a range truly shines — it integrates seamlessly into the range pipeline and eliminates manual <code>if</code> checks. You can find <a href="https://github.com/bemanproject/optional/blob/main/tests/beman/optional/optional_range_support.test.cpp">a broader set of examples in the Beman project unit tests </a>.</p><h2 id="competing-proposals">Competing Proposals</h2><p>Interestingly, there were competing proposals for this functionality. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1255r12.pdf">P1255R12</a> suggested two new views: <code>views::maybe</code> and <code>views::nullable</code>. The former would have represented a view holding zero or one value, while the latter would have adapted types that may or may not contain a value.</p><p>However, the authors of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3168r2.html">P3168R2</a> argued for a simpler, more unified approach. Since <code>std::optional</code> and the proposed <code>maybe_view</code> used identical wording: <em>“may or may not store a value of type T”</em>, introducing another type with the same semantics seemed redundant. In the end, genericity and simplicity won — we didn’t need a new view when <code>optional</code> could just become one.</p><p>You can read the arguments pro and contra in the referenced papers.</p><h2 id="stdoptional-as-a-view"><code>std::optional</code> as a View</h2><p>By adopting this range interface, <code>std::optional</code> effectively becomes a view containing at most one element. The question was how to make it so.</p><p>Two options were considered:</p><ul><li>Inheriting from <code>std::ranges::view_interface&lt;std::optional&lt;T&gt;&gt;</code></li><li>Specializing <code>std::ranges::enable_view&lt;std::optional&lt;T&gt;&gt;</code> to <code>true</code></li></ul><p>The first approach would have introduced unnecessary member functions, contradicting the simplicity goal. So the second option won — <code>std::optional&lt;T&gt;</code> now simply specializes <code>ranges::enable_view</code> in the same spirit as <code>std::string_view</code> and <code>std::span</code>.</p><h2 id="iterator-types">Iterator Types</h2><p>The authors really believe in simplicity. They kept trimming unnecessary parts between revisions. Initially, they considered defining a full suite of iterator algorithms, but realized that the existing <code>ranges::begin()</code>, <code>ranges::cbegin()</code>, et al. already do a big part of the job.</p><p>As a result, <code>std::optional</code> only defines <code>iterator</code> and <code>const_iterator</code>, both of which are implementation-defined. They were originally meant to be raw pointers, but that could have led to misuse — such as applying placement new — so implementers will need to ensure safer behavior.</p><h2 id="conclusion">Conclusion</h2><p><code>std::optional</code>’s new range interface might look unusual at first, but it’s a subtle, useful enhancement. It integrates <code>optional</code> into the range ecosystem, letting it compose cleanly with other views and transformations without explicit branching.</p><p>Rather than introducing yet another view type, the committee went with keeping things simple and making existing abstractions more composable. It might take a while to feel natural, but once you start thinking of optional as “a range of at most one”, it all clicks.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,</li><li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a></li><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</li></ul><p><a href="https://www.patreon.com/sandordargo"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png"/></a></p></div></div>
  </body>
</html>
