<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://texdraft.github.io/lisp-compiler/internals.html">Original</a>
    <h1>The First Lisp Compiler</h1>
    
    <div id="readability-page-1" class="page"><article>
      
      <section id="introduction">
        <h2><a href="#introduction">Introduction</a></h2>
        <p>
This page examines the earliest surviving Lisp compiler, written by Timothy Hart and Michael Levin around 1961.
To avoid repetition of phrases like “the compiler”, we will use the abbreviation
“<abbr title="Hart–Levin compiler">HLC</abbr>” (for “Hart–Levin Compiler”)
to refer to it. The <abbr title="Hart–Levin compiler">HLC</abbr> was introduced in
<a href="ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-039.pdf">M.I.T. <abbr title="A.I. Memo">AIM</abbr>-039</a>
and documented more fully in the <cite><a href="http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf">LISP 1.5 Programmer&#39;s Manual</a></cite>
by McCarthy et al.
        </p>
        <p>
For information about the timeline of Lisp compilers, I refer you to the ques­tion
“<a href="https://retrocomputing.stackexchange.com/a/12279">What was the first Lisp compiler</a>”
on the
<a href="https://retrocomputing.stackexchange.com/">Retrocomputing Stack­Exchange site</a>;
the answer there gives an excellent overview. We will be focusing on implementation details.
It should be mentioned, however, that al­though the title of this page is “The <em>First</em> Lisp Compiler”,
the <abbr title="Hart–Levin compiler">HLC</abbr> is really the <em>second</em> Lisp compiler. A more correct title would be
“The First Good Lisp Com­piler” or “The First Lisp Compiler Whose Source Code is Available”.
        </p>
        <p>
In order to understand the <abbr title="Hart–Levin compiler">HLC</abbr>, a decent amount of prequisite knowledge is required, about the
machine LISP 1.5 ran on and about LISP 1.5 itself. If you aren&#39;t already familiar, I recommend reading
the <cite><a href="http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf">LISP 1.5 Programmer&#39;s Manual</a></cite>
linked above and checking out Jack Harper&#39;s <a href="https://web.archive.org/web/20200630102054/http://www.frobenius.com/7090.htm">site on the IBM 7090</a>.
You might also be interested in <a href="https://github.com/munificent/craftinginterpreters/issues/906">a GitHub issue I wrote a little while ago</a>.
        </p>
      </section>
      <section id="the-source">
        <h2><a href="#the-source">The source</a></h2>
        <p>
The source code of the <abbr title="Hart–Levin compiler">HLC</abbr> comes from
<a href="https://github.com/rcornwell/ctss">an archive of CTSS source code</a>, namely
<a href="https://github.com/rcornwell/ctss/blob/master/extra/lisp/lispset.job#L278">lines 278–592 of file
<span>ctss/lispset.job</span></a>.
Reading the code in its original form is quite difficult, since there is virtually
no indentation or meaningful spacing. Occasionally atoms will start on one line/card and end on the next!
And of course all-uppercase text is not known for being especially readable. Therefore I have prepared a
<a href="https://texdraft.github.io/lisp-compiler/listing.html">formatted and cross-referenced version of the code</a> for easy viewing.
        </p>
        <p>
Even though the code looks pretty, I still find it hard to follow. All destruc­turing is done with
compositions of <span>car</span> and <span>cdr</span>. (I&#39;m not criticizing
the authors here, since it&#39;s not like LISP 1.5 gave them anything better to work with. But it feels like
a step down when compared to Common Lisp, where we have <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/03_d.htm">fancy lambda lists</a>
and <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/m_destru.htm#destructuring-bind"><span>destructuring-bind</span></a>.)
An additional obscurity lies in the choices of function and variable names. For example, the name
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-pi2"><span>pi2</span></a>
provides no clue as to its purpose (which is to construct a <span>setq</span> form). I think this
is an assembly language convention.
        </p>
        <p>
To run the code, you could try <a href="http://www.softwarepreservation.org/projects/LISP/lisp15_family#LISP_I_and_LISP_1.5_for_IBM_704,_709,_7090_">simulating the LISP 1.5 system</a>,
or you can use <a href="https://gist.github.com/texdraft/5570f5e7a9b71f245d8eb1f442c9c47c">my translation to Common Lisp</a>.
Note: This translation does the bare mini­mum to get it running. I make no attempt to use any high-level Common Lisp constructs;
the aim was to leave the code as unchanged as possible except to add indentation. To compile the compiler, uncomment the lines at the bottom.
        </p>
        <p>
The source code of an earlier version of the <abbr title="Hart–Levin compiler">HLC</abbr> also exists, in a document titled
“<a href="http://www.softwarepreservation.org/projects/LISP/lisp1.5/LISP_LIBRARY_NOVEMBER_1963.pdf">LISP LIBRARY NOVEMBER 1963</a>”.
        </p>
      </section>
      <section id="compiler-fundamentals">
        <h2><a href="#compiler-fundamentals">Fundamentals of the <abbr title="Hart–Levin compiler">HLC</abbr></a></h2>
        <p>
Here is how the implementers describe the <abbr title="Hart–Levin compiler">HLC</abbr> (from <a href="ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-039.pdf"><abbr title="A.I. Memo">AIM</abbr>-039</a>):
        </p>
        <blockquote>
          <p>
… It is written entirely in LISP and is the first compiler that has ever
compiled itself by being executed interpretively.
          </p>
        </blockquote>
        <p>
Another early effort that might also claim this honor is Donald Knuth&#39;s
<a href="https://doi.org/10.1145/368481.368507">RUNCIBLE</a>;
Knuth described an algorithm to translate RUNCIBLE expres­sions into assembly language,
and <a href="https://archive.computerhistory.org/resources/text/Knuth_Don_X4100/PDF_index/k-3-pdf/k-3-c1034-DRUNCIBLE-listing.pdf">implemented it in RUNCIBLE itself</a>.
        </p>
        <blockquote>
          <p>
The purpose of the LISP compiler is to replace S-expression def­initions of functions with
efficient machine language subroutines. A subroutine can be expected to run about 40 times
as fast as the interpreter can execute the same function from its S-expres­sion definition.
Subroutines typically take 70–80 per cent of the storage required by their
corresponding S-expressions.
          </p>
        </blockquote>
        <p>
Such a drastic speed-up was possible because the LISP 1.5 interpreter was not especially efficient.
        </p>
        <p>
The <abbr title="Hart–Levin compiler">HLC</abbr> was notable for several aspects:
        </p>
        <ul>
          <li>
            <p>
It was the first compiler to attempt to transform a tail call
into a transfer instruction that doesn&#39;t incur the function call overhead.
However, it recognized only a certain case of tail calls.
            </p>
          </li>
          <li>
            <p>
It created a behavioral distinction between compiled and interpreted Lisp code
that would be the norm until Common Lisp in 1984.
            </p>
          </li>
          <li>
            <p>
It did no control-flow or data-flow optimizations other than the tail call elimination. In particular, it
did not attempt to avoid conversions to and from boxed representations of numeric values;
all arithmetic was still done by function calls. No functions were open-coded.
            </p>
          </li>
          <li id="two-passes">
            <p>
It operated in two clearly separated passes.
            </p>
          </li>
        </ul>
      </section>
      <section id="using-the-compiler">
        <h2><a href="#using-the-compiler">Using the <abbr title="Hart–Levin compiler">HLC</abbr></a></h2>
        <p>
The main entry point to the <abbr title="Hart–Levin compiler">HLC</abbr> is the
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-compile"><span>compile</span></a>
function,
which takes a list of function names and compiles their definitions. In LISP 1.5, function definitions
were stored on the property list of the function&#39;s name, under one of the indica­tors
<span>EXPR</span> (for interpreted definitions), <span>FEXPR</span> (interpreted and
accepting a variable number of arguments), <span>SUBR</span> (implemented in machine code),
or <span>FSUBR</span> (implemented in machine code and accepting a variable number of
arguments). The <abbr title="Hart–Levin compiler">HLC</abbr> replaces an <span>EXPR</span> or <span>FEXPR</span> property with
a <span>SUBR</span> or <span>FSUBR</span> property.
        </p>
        <p>
Code acceptable to the interpreter is not necessarily acceptable to the <abbr title="Hart–Levin compiler">HLC</abbr>. For
managing the values of variables, the interpreter used a simple association list; it had
no concept of scope. On the other hand, compiled code avoids manip­ulation of an
environment by storing values on the push-down list (AKA the stack). Thus
the <abbr title="Hart–Levin compiler">HLC</abbr> effectively supported lexical scoping. The <abbr title="Hart–Levin compiler">HLC</abbr> still allowed variables
with indefinite scope, but they must be explicitly declared as such by using the
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-special"><span>special</span></a>
function. If a special variable was also meant to be shared between
compiled and interpreted functions, it must be declared in a different way, with the
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-common"><span>common</span></a>
function. (Declarations can be reversed by the
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-unspecial"><span>unspecial</span></a>
and
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-uncommon"><span>uncommon</span></a>
functions.) We will see later how the special/common variable mechanism worked internally.
        </p>
        <p>
The <abbr title="Hart–Levin compiler">HLC</abbr> generated code in the form of a symbolic listing and handed it to
<span>lap</span>, the Lisp Assembly Program, which converted the listing into machine code
and “installed” it in the computer&#39;s memory. The <abbr title="Hart–Levin compiler">HLC</abbr> also printed out the listing.
        </p>
    </section>
      <section id="pass-one">
        <h2><a href="#pass-one">Pass one</a></h2>
        <p>
Pass one of the <abbr title="Hart–Levin compiler">HLC</abbr> is encapsulated within the function
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-passone"><span>passone</span></a>.
The goal of the first pass is to transform a Lisp expression into another Lisp expression that is potentially easier for the
compiler to deal with. In some cases, the output of
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-passone"><span>passone</span></a>
is <em>not</em> a valid Lisp expression, but rather a kind of annotation for the second pass to act on.
        </p>
        <p>
The main “worker” in pass one is
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-paform"><span>paform</span></a>,
which is given any form that is to be evaluated. For instance, in a normal function call
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-paform"><span>paform</span></a>
is mapped over all the arguments. Caution must be exercised with operators that don&#39;t follow
ordi­nary evaluation rules: It would be quite incorrect to hand
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-paform"><span>paform</span></a>
the subforms of a <span>cond</span> expression.
        </p>
        <section id="tail-call">
          <h3><a href="#tail-call">Tail call elimination</a></h3>
          <p>
The first transformation applied converts a specific case of recursion into iteration, i.e., it performs (limited) tail call elimination.
This is done by the
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-progiter"><span>progiter</span></a>
subroutine. Suppose that we are defining a function named <span>f</span>. Then
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-progiter"><span>progiter</span></a>
checks to see whether <span>f</span>&#39;s definition is of the form
          </p>
          
          <p>
In other words, it looks for a <span>cond</span> expression that
has at least one clause whose consequent expression is a recursive call to the function
being defined. If such an expression is found, the
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-progiter1"><span>progiter1</span></a>
function is called upon to do the actual transformation.
          </p>
          <p>
Four arguments are given to
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-progiter1"><span>progiter1</span></a>:
          </p>
          <ol>
            <li>
              <var>g1</var>, a fresh, uninterned symbol created by <span>gensym</span>.
This will be used as a <span>prog</span> tag.
            </li>
            <li>
              <var>g2</var>, ditto.
            </li>
            <li>
              <var>vs</var>, the parameters of the function being defined.
            </li>
            <li>
              <var>gs</var>, a list of fresh symbols, one for each parameter.
            </li>
          </ol>
          <p>
The goal is to create a <span>prog</span> form, replacing recursive calls
with <span>go</span> statements and replacing other <span>cond</span>
clauses with <span>return</span> statements. Here is what we might get when
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-member"><span>member</span></a>
is run through
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-progiter"><span>progiter</span></a>
(the generated symbols use Common Lisp syntax):
          </p>
          <div>
            <table>
              <tbody>
                <tr>
                  <td>
                    (λ (<var>u</var> <var>v</var>)
                  </td>
                </tr>
                <tr>
                  <td>
                    <table>
                      <tbody>
                        <tr>
                          <td>(<span>prog</span> </td>
                          <td>(<var>#:g480</var> <var>#:g481</var>)</td>
                        </tr>
                        <tr>
                          <td>#:g478</td>
                          <td>
                            (<span>cond</span>
                            <table>
                              <tbody>
                                <tr>
                                  <td>
                                    (
                                  </td>
                                </tr>
                                <tr>
                                  <td>
                                    (<table>
                                      <tbody>
                                        <tr>
                                          <td>
                                            (<span>equal</span>
                                            (<span>car</span> <var>v</var>) <var>u</var>)
                                          </td>
                                        </tr>
                                        <tr>
                                          <td>
                                            (<span>return</span>
                                            <var>t</var>))
                                          </td>
                                        </tr>
                                      </tbody>
                                    </table>
                                  </td>
                                </tr>
                                <tr>
                                  <td>
                                    (
                                  </td>
                                </tr>
                              </tbody>
                            </table>
                          </td>
                        </tr>
                        <tr>
                          <td>#:g482</td>
                          <td>
                            (<span>setq</span> <var>#:g480</var> <var>u</var>)
                          </td>
                        </tr>
                        <tr>
                          <td></td>
                          <td>
                            (<span>setq</span> <var>#:g481</var>
                            (<span>cdr</span> <var>v</var>))
                          </td>
                        </tr>
                        <tr>
                          <td></td>
                          <td>
                            (<span>go</span>
                            <span>#:g479</span>)
                          </td>
                        </tr>
                        <tr>
                          <td>#:g479</td>
                          <td>
                            (<span>setq</span> <var>u</var> <var>#:g480</var>)
                          </td>
                        </tr>
                        <tr>
                          <td></td>
                          <td>
                            (<span>setq</span> <var>v</var> <var>#:g481</var>)
                          </td>
                        </tr>
                        <tr>
                          <td></td>
                          <td>
                            (<span>go</span>
                            <span>#:g478</span>))).
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
I confess that I am unsure why the tag <span>#:g479</span>
(and the <span>go</span> thereto) is necessary.
However, the extra variables for the parameters are essential to avoid problems with
indefinite scope. For example, let&#39;s say that we have a function <span>g</span>
defined as follows.
          </p>
          
          <p>
If <var>y</var> is declared special, and <span>h</span> modifies <var>y</var>,
then the obvious expansion that directly sets <var>x</var> and <var>y</var> would be incorrect, since
<var>y</var> would be changed before <code>(<span>cdr</span> <var>y</var>)</code> is
evaluated. (In Common Lisp,
<a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/m_psetq.htm#psetq"><span>psetq</span></a> or
<a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/m_setf_.htm#psetf"><span>psetf</span></a>
could be used to achieve the same effect.)
          </p>
        </section>
        <section id="pass-one-special-common">
          <h3><a href="#pass-one-special-common">Special and common variables</a></h3>
          <p>
To make the job of the second pass easier, pass one determines and marks all special and common variables.
Specifically, the following changes are made:
          </p>
          <ul>
            <li>
              <p>
A reference to a special variable <var>x</var> will be turned into
<code>(<span>special</span> <var>x</var>)</code>. Thus the form
<code>(<span>setq</span> <var>x</var> <var>y</var>)</code>, where
<var>x</var> and <var>y</var> have been declared special, becomes
<code>(<span>setq</span> (<span>special</span> <var>x</var>) (<span>special</span> <var>y</var>))</code>.
Note that this code is not valid LISP 1.5; the compiler will deal with it “specially”.
              </p>
            </li>
            <li>
              <p>
A reference to a common variable <var>c</var> will be turned into the expression
<code>(<span>eval</span> (<span>quote</span> c) <var>$alist</var>)</code>.
The effect is to invoke the interpreter to compute the value of <var>c</var>. Of course, this won&#39;t work with
<span>setq</span>, so…
              </p>
            </li>
            <li>
              <p>
A <span>setq</span> of a common variable <var>c</var> becomes a
call to <span>setc</span>, with the variable&#39;s name quoted, as in
<code>(<span>setc</span> (<span>quote</span> c) <var>whatever</var>)</code>.
This <span>setc</span> function is obscure; it is not defined
in the source code of the M.I.T. interpreter.
It is not to be confused with the <span>cset</span> function, which is well documented.
There is a definition of <span>setc</span> in
<a href="http://www.softwarepreservation.org/projects/LISP/stanford/LISP_360_Reference_Manual-SCC024-1972_03.pdf#page=44">the reference manual for a LISP 1.5 interpreter on the IBM 360</a>,
but it is not compatible with the <span>setc</span> here.
              </p>
            </li>
            <li id="specbind-specrstr">
              <p>
Any form that creates a binding of special and/or common variables is radically altered
so that the second pass will generate code to save the current values before the form is
executed and to restore them after­wards. Let&#39;s look at an example first.
Assume that <var>x</var> and <var>y</var> have been declared common, and that
<var>z</var> has been declared special.
              </p>
              <div>
                <table>
                  <tbody>
                    <tr>
                      <td>
                        (<span>lambda</span> (<var>x</var> <var>y</var> <var>z</var>)
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <div>
                                (<span>cond</span>
                                <table>
                                  <tbody>
                                    <tr>
                                      <td>
                                        (<table>
                                          <tbody>
                                            <tr>
                                              <td>
                                                (<span>eq</span> <var>x</var> <var>y</var>)
                                              </td>
                                            </tr>
                                            <tr>
                                              <td>
                                                (<span>prog</span>
                                                <table>
                                                  <tbody>
                                                    <tr>
                                                      <td>
                                                        (<var>z</var>)
                                                      </td>
                                                    </tr>
                                                    <tr>
                                                      <td>
                                                        (<span>setq</span> <var>z</var> <var>x</var>)
                                                      </td>
                                                    </tr>
                                                    <tr>
                                                      <td>
                                                        (<span>return</span>
                                                        <var>t</var>)))
                                                      </td>
                                                    </tr>
                                                  </tbody>
                                                </table>
                                              </td>
                                            </tr>
                                          </tbody>
                                        </table>
                                      </td>
                                    </tr>
                                    <tr>
                                      <td>
                                        (
                                      </td>
                                    </tr>
                                  </tbody>
                                </table>
                              </div>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <p>
Here there are two forms that bind—the overall
<span>lambda</span> expression (though arguably not a “form” in this context)
and the <span>prog</span>. Pass one, via
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-pa4"><span>pa4</span></a>,
produces
              </p>
              <div>
                <table>
                  <tbody>
                    <tr>
                      <td>
                        (<span>λ</span> (<var>x</var> <var>y</var> <var>z</var>)
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <table>
                          <tbody>
                            <tr>
                              <td>
                                (<span>prog</span> 
                              </td>
                              <td>
                                (<var>#:g479</var>)
                              </td>
                            </tr>
                            <tr>
                              <td></td>
                              <td>
                                (<span>combind</span>
                                (<span>quote</span> (x y))
                                (<span>list</span> <var>x</var> <var>y</var>))
                              </td>
                            </tr>
                            <tr>
                              <td></td>
                              <td>
                                (<span>specbind</span>
                                (<span>quote</span> (z)))
                              </td>
                            </tr>
                            <tr>
                              <td></td>
                              <td>
                                (<span>setq</span> <var>#:g479</var>
                                <div>
                                        (<span>cond</span>
                                        <table>
                                          <tbody>
                                            <tr>
                                              <td>
                                                (<table>
                                                  <tbody>
                                                    <tr>
                                                      <td>
                                                        (<span>eq</span>
                                                        <table>
                                                          <tbody>
                                                            <tr>
                                                              <td>
                                                                (<span>eval</span>
                                                                (<span>quote</span> x)
                                                                <var>$alist</var>)
                                                              </td>
                                                            </tr>
                                                            <tr>
                                                              <td>
                                                               (<span>eval</span>
                                                               (<span>quote</span> y)
                                                               <var>$alist</var>))
                                                              </td>
                                                            </tr>
                                                          </tbody>
                                                        </table>
                                                      </td>
                                                    </tr>
                                                    <tr>
                                                      <td>
                                                        <table>
                                                          <tbody>
                                                            <tr>
                                                              <td>
                                                                (<span>prog</span> 
                                                              </td>
                                                              <td>
                                                                (<var>#:g480</var> <var>z</var>)
                                                              </td>
                                                            </tr>
                                                            <tr>
                                                              <td></td>
                                                              <td>
                                                                (<span>specbind</span>
                                                                (<span>quote</span> (z)))
                                                              </td>
                                                            </tr>
                                                            <tr>
                                                              <td></td>
                                                              <td>
                                                                (<span>setq</span> <var>#:g480</var>
                                                                <table>
                                                                  <tbody>
                                                                    <tr>
                                                                      <td>
                                                                        (<span>prog</span> 
                                                                      </td>
                                                                      <td>
                                                                        ( )
                                                                      </td>
                                                                    </tr>
                                                                    <tr>
                                                                      <td></td>
                                                                      <td>
                                                                        (<span>setq</span>
                                                                        (<span>special</span> <var>z</var>)
                                                                        (<span>eval</span>
                                                                        (<span>quote</span> x)
                                                                        <var>$alist</var>))
                                                                      </td>
                                                                    </tr>
                                                                    <tr>
                                                                      <td></td>
                                                                      <td>
                                                                        (<span>return</span>
                                                                        (<span>quote</span> *t*))
                                                                      </td>
                                                                    </tr>
                                                                    <tr>
                                                                      <td></td>
                                                                      <td>
                                                                        (<span>return</span>
                                                                        (<span>quote</span> nil))))
                                                                      </td>
                                                                    </tr>
                                                                  </tbody>
                                                                </table>
                                                              </td>
                                                            </tr>
                                                            <tr>
                                                              <td></td>
                                                              <td>
                                                                (<span>specrstr</span>
                                                                (<span>quote</span> (z)))
                                                              </td>
                                                            </tr>
                                                            <tr>
                                                              <td></td>
                                                              <td>
                                                                (<span>return</span> <var>#:g480</var>)))
                                                              </td>
                                                            </tr>
                                                          </tbody>
                                                        </table>
                                                      </td>
                                                    </tr>
                                                  </tbody>
                                                </table>
                                              </td>
                                            </tr>
                                            <tr>
                                              <td>
                                                (<table>
                                                  <tbody>
                                                    <tr>
                                                      <td>
                                                        (<span>quote</span> *t*)
                                                      </td>
                                                    </tr>
                                                    <tr>
                                                      <td>
                                                        (<span>quote</span> nil))))
                                                      </td>
                                                    </tr>
                                                  </tbody>
                                                </table>
                                              </td>
                                            </tr>
                                          </tbody>
                                        </table>
                                      </div>
                              </td>
                            </tr>
                            <tr>
                              <td></td>
                              <td>
                                (<span>specrstr</span>
                                (<span>quote</span> (z)))
                              </td>
                            </tr>
                            <tr>
                              <td></td>
                              <td>
                                (<span>comrstr</span>
                                (<span>quote</span> 2))
                              </td>
                            </tr>
                            <tr>
                              <td></td>
                              <td>
                                (<span>return</span> <var>#:g479</var>))).
                              </td>
                            </tr>
                          </tbody>
                        </table>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <p>
(Note that this code showcases some pass one transformations that we have not encountered yet; see
<a href="#pass-one-others">below</a>.
Also, generated symbols are ex­pressed in Common Lisp syntax.)
              </p>
            </li>
              <p>
The functions <span>specbind</span>, <span>specrstr</span>,
<span>combind</span>, and <span>comrstr</span> are machine-coded
routines that handle binding special and common variables. No code for them exists in the M.I.T.
interpreter source code available online, unfor­tunately. However, corresponding routines can
be found in other imple­mentations, namely
<a href="http://www.softwarepreservation.org/projects/LISP/other_lisp15#Stanford_Lisp_360_">an interpreter on the IBM 360</a>
and the
<a href="http://www.softwarepreservation.org/projects/LISP/other_lisp15#LISP_1.5_for_AN/FSQ-32/V_">(compiler-only) Lisp on the AN/FSQ-32</a>.
              </p>
              <p>
More specifically, <span>specbind</span> takes a list of symbols whose current special
bindings should be saved, and <span>specrstr</span> takes a list of symbols whose previous
special binding should be restored. The <span>combind</span> function ap­pears to be similar,
although it takes a second argument, which is a list of values to which the common variables should be bound.
Finally, the <span>comrstr</span> function takes the number of common variables bound by
<span>combind</span> and restores their previous binding.
              </p>
            
          </ul>
        </section>
        <section id="pass-one-others">
          <h3><a href="#pass-one-others">Other transformations</a></h3>
          <p>
Here is the rest of what
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-paform"><span>paform</span></a>
does.
          </p>
          <ul>
            <li>
Self-evaluating forms (numbers, <span>nil</span>, and <span>*t*</span>) are quoted.
            </li>
            <li>
The variables <var>t</var> and <var>f</var> are changed to their <span>APVAL</span>s
<span>*t*</span> and <span>nil</span> (quoted).
            </li>
            <li>
A call to <span>not</span> changes into a call to <span>null</span>.
            </li>
            <li>
A call to <span>set</span> changes into a call to <span>setc</span>.
            </li>
            <li>
A <span>csetq</span> form is changed into a <span>cset</span> form, with
the argument quoted.
            </li>
            <li>
The <span>FSUBR</span>s <span>select</span> and <span>conc</span>
are “expanded”—the former into a <span>cond</span>, the latter into a series of
<span>append</span> calls.
            </li>
            <li>
The subforms of <span>list</span>, <span>cond</span>, and
<span>setq</span> forms are
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-paform"><span>paform</span></a>&#39;d
as necessary.
            </li>
            <li>
A <span>prog</span> form is <a href="#pass-one-special-common">treated for special/common binding</a> and
has its non-atomic subforms
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-paform"><span>paform</span></a>&#39;d. The expression
<code>(<span>return</span> (<span>quote</span> nil))</code> is added at the end, so that every
<span>prog</span> has an explicit final return.
            </li>
            <li>
Calls on <span>and</span> and <span>or</span> are left alone, except that
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-paform"><span>paform</span></a> is
applied to their subforms.
            </li>
            <li>
Other <span>FSUBR</span>s, and all <span>FEXPR</span>s, are expanded to reflect
the actual calling convention, where the underlying function is passed a list of the arguments and the current
environment.
            </li>
            <li>
“Funarg” expressions using <span>function</span> are converted into a call to a
myst­erious <span>func</span> function/operator. This does not appear to be docu­mented anywhere,
in any Lisp implementation, and is not defined in the M.I.T. interpreter. It is passed the name of a function and the
current environ­ment; if <span>function</span> is used with a λ expression, the expression is
compiled and a name is generated for it.
            </li>
          </ul>
        </section>
      </section>
      <section id="pass-two">
        <h2><a href="#pass-two">Pass two</a></h2>
        <p>
In the second pass, the Lisp code for a function, as processed by the first pass, is translated into assembly
instructions to be executed by the IBM 704/709/7090/7094 (henceforth referred to as simply “the 7090”). As
Bernard S. Greenburg says, in “<a href="https://www.multicians.org/lcp.html#CHII">The Multics MACLISP Compiler</a>”,
        </p>
        <blockquote>
          <p>
            The contract of a lisp compiler is to produce a machine-language program which, when executed, will have the
            same effect on the lisp environment, and return the same value, as having applied <span>eval</span> to the forms it was
            given to compile.
          </p>
        </blockquote>
        <p>
While the first pass is a grab-bag of assorted, special-purpose functions, the second pass is a bit more structured.
Before we look at the translations of Lisp constructs, we need to be familiar with some variables and functions used
throughout pass two.
        </p>
        <section id="the-listing">
          <h3><a href="#the-listing">The listing</a></h3>
          <p>
The generated code is held in the <var>listing</var> variable, which is a list of <abbr title="Lisp Assembly Program">LAP</abbr>
instructions. New instructions are added by passing a list to
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-attach"><span>attach</span></a>. Note that
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-attach"><span>attach</span></a> puts its argument at the
<em>front</em> of <var>listing</var>; after compilation has concluded, <var>listing</var> is reversed.
          </p>
        </section>
        <section id="locating-values">
          <h3><a href="#locating-values">Locating values</a></h3>
          <p>
Local variables (parameters and <span>prog</span> variables) and compiler-generated temporaries are
stored on the Lisp system&#39;s push-down list or PDL. (Nowadays we would call it “the stack”.) In order to load
the value of such an entity, the compiler must know its position on the <abbr title="Push-down list">PDL</abbr>.
This is accomplished using a variable called <code><var>stomap</var></code> (“storage map”), and a
<abbr title="Lisp Assembly Program">LAP</abbr> symbol defined in each function&#39;s assembly output,
<code><var>*N</var></code>.
          </p>
          <p>
<span id="ir1-highest-pdl">In compiled code, <abbr title="Index register 1">IR1</abbr> always holds the address of the highest
<abbr title="Push-down list">PDL</abbr> cell used by this function.</span> The instruction for loading a variable&#39;s value into
<abbr title="Accumulator register">AC</abbr> normally looks like
(in <abbr title="Lisp Assembly Program">LAP</abbr> format)
            </p>
          
          <p>
In <abbr title="Lisp Assembly Program">LAP</abbr>, the notation “<code>(1 <var>*N</var>)</code>” means to add the constant
<code><span>1</span></code> to the value of the symbol <code><var>*N</var></code>.
For now it suffices to say that the value of <code><var>*N</var></code> is the negative of the total number of
<abbr title="Push-down list">PDL</abbr> cells needed for the function. Because of the way effective addresses are calculated on the 7090,
the above instruction ends up loading the <em>second</em> cell from the top of the <abbr title="Push-down list">PDL</abbr>, which is the
first cell used for local storage. (When we discuss function prologues, we will uncover the true meaning of <code><var>*N</var></code>.)
          </p>
          <p>
The <code><var>stomap</var></code> special variable maps variable names to lists of the form
<code>((<var>m</var> <var>*N</var>) <span>1</span>)</code>, where <var>m</var> is an integer. For example,
the function
          </p>
          
          <p>
Results in the <code><var>stomap</var></code>
          </p>
          <div>
            <div>
                    (<table>
                      <tbody>
                        <tr>
                          <td>
                            (<var>#:g1964</var> 
                          </td>
                          <td>
                            . 
                          </td>
                          <td>
                            ((4 <var>*N</var>) 1))
                          </td>
                        </tr>
                        <tr>
                          <td>
                            (<var>c</var>
                          </td>
                          <td>
                            .
                          </td>
                          <td>
                            ((3 <var>*N</var>) 1))
                          </td>
                        </tr>
                        <tr>
                          <td>
                            (<var>b</var>
                          </td>
                          <td>
                            .
                          </td>
                          <td>
                            ((2 <var>*N</var>) 1))
                          </td>
                        </tr>
                        <tr>
                          <td>
                            (<var>a</var>
                          </td>
                          <td>
                            .
                          </td>
                          <td>
                            ((1 <var>*N</var>) 1))
                          </td>
                        </tr>
                        <tr>
                          <td>
                            (<var>nil</var>
                          </td>
                          <td>
                            .
                          </td>
                          <td>
                            ((0 <var>*N</var>) 1)))
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
          </div>
          <p>
The <code><var>#:g1964</var></code> variable was created by the compiler to hold the result of the inner
<code><span>cons</span></code>; the entry for <code><var>nil</var></code> is always present and never used.
          </p>
          <p>
When the compiler wishes to generate an instruction that refers to a local quantity, it calls
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-locate"><span>locate</span></a>, which searches in
<code><var>stomap</var></code> for a given name and returns the entry&#39;s <code><span>cdr</span></code>.
(It also handles “locating” quoted values, but this is trivial thanks to
<abbr title="Lisp Assembly Program">LAP</abbr>.)
For example, to generate the <abbr title="Clear and add">CLA</abbr> above, we could call
          </p>
          
          <p>
Many functions bind <code><var>stomap</var></code>, so it can gain and then lose entries; the variable
<code><var>length</var></code> holds the greatest size of <code><var>stomap</var></code>.
          </p>
          <p>
Besides <a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-locate"><span>locate</span></a>, only
two functions access <code><var>stomap</var></code> directly:
          </p>
          <ul>
            <li>
              <p>
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-phase2"><span>phase2</span></a> initializes it to
<code>(<span>quote</span> ((nil (0 *n) 1)))</code> and also sets <code><var>length</var></code> to 0.
              </p>
            </li>
            <li>
              <p>
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-store"><span>store</span></a> is a routine
that adds an entry for a variable whose name is given as the first argument. It takes a second argument, which, when true,
causes a <abbr title="Store">STO</abbr> instruction to be emitted. This function takes care of
updating <code><var>length</var></code>.
              </p>
            </li>
          </ul>
          <p>
Finally, the utility routine <a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-lac"><span>lac</span></a>
should be mentioned. It has the simple task of generating a <abbr title="Clear and add">CLA</abbr>
instruction to load a variable of a given name into <abbr title="Accumulator register">AC</abbr>
(unless it is already in the simulated accumulator; see below).
          </p>
        </section>
        <section id="function-prologues-and-epilogues-and-linkage">
          <h3><a href="#function-prologues-and-epilogues-and-linkage">Function prologues and epilogues and linkage</a></h3>
          <p>
Every compiled function begins with the following two instructions:
          </p>
          <div>
            <table>
              <tbody>
                <tr>
                  <td>(<abbr title="Transfer and set index">TSX</abbr>
                  </td>
                  <td><span>*MOVE</span>
                  </td>
                  <td><span>1</span>
                  </td>
                  <td>⟨number of arguments⟩)
                  </td>
                </tr>
                <tr>
                  <td>(<abbr title="Transfer on no index">TNX</abbr>
                  </td>
                  <td>(<span>E</span> ⟨name of this function⟩)
                  </td>
                  <td><span>1</span>
                  </td>
                  <td><var>*MN</var>)
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
The effect is to set up the <abbr title="Push-down list">PDL</abbr>, so that it contains the function&#39;s arguments and
has room for any other local variables needed. Although simple enough in concept, the exact mechanism at play is rather
annoyingly complex.
          </p>
          <p>
First of all, the second instruction isn&#39;t really an instruction at all. It&#39;s more like an argument to the
<code id="move-routine"><span>*MOVE</span></code> routine. The 7090 did not have a hardware stack, and passing arguments
by using additional “instructions” after a
<abbr title="Transfer and set index">TSX</abbr> was one way to avoid the limitation of
keeping everything in the two general-purpose registers. (This sort of thing is nearly unheard of today. If you don&#39;t
know how it would have been done on the 7090, I recommend reading
<a href="https://web.archive.org/web/20210424171134/http://www.frobenius.com/linkage.htm">Jack Harper&#39;s
page about subroutine linkage on the machine</a>; otherwise, the ensuing discussion will probably be confusing.)
          </p>
          <p>
To understand what <code><span>*MOVE</span></code> does, we have to know a bit about the LISP 1.5
system. The <abbr title="Push-down list">PDL</abbr> grows upwards, from a location stored in the decrement part of a
<abbr title="Transfer with index incremented">TXI</abbr> instruction labeled
<code><var>CPPI</var></code>. When a compiled function is called, at least four cells of the
<abbr title="Push-down list">PDL</abbr> are used.
          </p>
          <table>
            <tbody>
              <tr>
                <th>Cell</th>
                <th>Contents</th>
              </tr>
              <tr>
                <td>
                  <var>pdl</var>[0]:
                </td>
                <td>
                  <p>
A <abbr title="Transfer on index lower or equal to">TXL</abbr> instruction with
the return address in its decrement part, and the location of the present function in its address part.
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <var>pdl</var>[1]:
                </td>
                <td>
The contents of <abbr title="Accumulator register">AC</abbr> (normally the first argument).
                </td>
              </tr>
              <tr>
                <td>
                  <var>pdl</var>[2]:
                </td>
                <td>
The contents of <abbr title="Multiplier/quotient">MQ</abbr> (normally the second argument).
                </td>
              </tr>
              <tr>
                <td>
                  <var>pdl</var>[3]:
                </td>
                <td>
First cell of local storage; possibly a third argument.
                </td>
              </tr>
              <tr>
                <td colspan="2">
                  ⋮
                </td>
              </tr>
              <tr>
                <td>
                  <var>pdl</var>[<var>*MN</var>]
                </td>
                <td>
The last cell of local storage.
                </td>
              </tr>
              <tr>
                <td>
                  <var>pdl</var>[<var>*MN</var> + 1]
                </td>
                <td>
An <abbr title="Store location and trap">STR</abbr> instruction with <var>*MN</var>
in its decrement part.
                </td>
              </tr>
            </tbody>
          </table>
          <p>
As you can see, <var>*MN</var> is the total number of cells used for local storage, including the saved
<abbr title="Accumulator register">AC</abbr> and
<abbr title="Multiplier/quotient register">MQ</abbr>. Note that these registers are saved
no matter what, even if the function takes fewer than two arguments. The value of <var>*N</var> is the
negation of <var>*MN</var>.
          </p>
          <p>
The return address needs to be stored so that the function can return, naturally; the name is stored in order
to provide a backtrace in error messages. The
<abbr title="Store location and trap">STR</abbr> instruction is used when unwinding
the stack during such a backtrace or when something fails in an <code><span>errorset</span></code>
form.
          </p>
          <p>
Calling <code><span>*MOVE</span></code> creates a <abbr title="Push-down list">PDL</abbr>
entry in the above format. It also leaves a pointer to the top of the <abbr title="Push-down list">PDL</abbr>
in <abbr title="Index register 1">IR1</abbr>, as stated
<a href="#ir1-highest-pdl">above</a>.
          </p>
          <p>
At the end of every compiled function is an instruction to load the return value into the accumulator,
followed by
          </p>
          
          <p id="return">
The <code><span>*RETURN</span></code> routine restores the decrement part of
<var>CPPI</var> to its previous value, puts the return address in
<abbr title="Index register 4">IR4</abbr>, and then transfers to it.
          </p>
          <p>
But the complexities don&#39;t end there. The code generated for a function call contains an
<abbr title="Store location and trap">STR</abbr> instruction.
On the 7090, <abbr title="Store location and trap">STR</abbr> causes the
computer to transfer unconditionally to location 2, in which a
<abbr title="Trap transfer">TTR</abbr> instruction causes a further
transfer to the <code><span>LINK</span></code> routine. This routine invokes
<code><span>apply</span></code> if the called function is an
<span>EXPR</span> or an <span>FEXPR</span>. If the called
function in a <span>SUBR</span> or an <span>FSUBR</span>,
however, the routine modifies the <abbr title="Store location and trap">STR</abbr>
to be a <abbr title="Transfer and set index">TSX</abbr>
instruction that jumps directly to the function&#39;s address.
          </p>
        </section>
        <section id="compiling-an-expression">
          <h3><a href="#compiling-an-expression">Compiling an expression</a></h3>
          <p>
We now turn to the code generated for the various expressions in Lisp. The most important function is
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comval"><span>comval</span></a>, which,
as its name suggests, compiles an expression that produces a value. (It&#39;s the most important because all
Lisp expressions produce values.) The instructions generated by
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comval"><span>comval</span></a> leave
the result of the expression in <abbr title="Accumulator register">AC</abbr>.
          </p>
          <p>
The <code><var>name</var></code> parameter of
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comval"><span>comval</span></a>
holds a symbol that&#39;s supposed to be the name for the result. Except for the first call, when it&#39;s
<code><span>nil</span></code>, this symbol is always created by
<code><span>gensym</span></code>. Other functions use <code><var>name</var></code> as well.
          </p>
          <p>
<span id="simulated-accumulator">During compilation, the second pass keeps track of the current
contents of <abbr title="Accumulator register">AC</abbr>, using the special variable
<code><var>ac</var></code></span>. (The word “current” is not quite right; the compiler isn&#39;t
actually executing the instructions it produces. Instead, it means “at the time during execution
when the instructions most recently generated by the compiler have been executed“, but that&#39;s
too convoluted to write.)
Once <a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comval"><span>comval</span></a> has
finished, it sets <code><var>ac</var></code> to <code><var>name</var></code>, since
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comval"><span>comval</span></a> puts
the value in <abbr title="Accumulator register">AC</abbr>.
          </p>
          <section id="compiling-atoms-and-variables">
            <h4><a href="#compiling-atoms-and-variables">Compiling atoms and variables</a></h4>
            <p>
Atoms and variables take no effort. The result is a
<abbr title="Clear and add">CLA</abbr> instruction produced by
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-lac"><span>lac</span></a>,
because <abbr title="Lisp Assembly Program">LAP</abbr> takes care of the dirty work.
            </p>
          </section>
          <section id="compiling-assignments">
            <h4><a href="#compiling-assignments">Compiling assignments</a></h4>
            <p>
The code generated for the expression
            </p>
            <div>
              <p>
                      (<span>setq</span> <var>x</var> ⟨expression⟩)
                    </p>
            </div>
            <p>
is
            </p>
            <div>
              <table>
                <tbody>
                  <tr>
                    <td>
                      code for ⟨expression⟩
                    </td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Store">STO</abbr>
                      ⟨location of <var>x</var>⟩),
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
where <code>⟨location of <var>x</var>⟩</code> is the result of calling
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-locate"><span>locate</span></a>
on <code><var>x</var></code>.
            </p>
          </section>
          <section id="compiling-function-calls">
            <h4><a href="#compiling-function-calls">Compiling function calls</a></h4>
            <p>
The instruction that calls a normal compiled or interpreted function <code><span>f</span></code>, generated by
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-call"><span>call</span></a>, is
            </p>
            
            <p>
where <var>n</var> is the number of arguments. Before the <abbr title="Store location and trap">STR</abbr>,
the compiler needs to set up the arguments, if the function requires them. The evaluation of the arguments is handled by
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comlis"><span>comlis</span></a>, which applies
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comval"><span>comval</span></a> to the non-atomic
non-constant subexpressions in the call. Each such subexpression is replaced by a temporary name, which is put on the <var>stomap</var>.
Thus all arguments are symbols or constants, when
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-call"><span>call</span></a> gets hold of them.
            </p>
            <p>
The first argument is passed in <abbr title="Accumulator register">AC</abbr>;
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-call"><span>call</span></a> checks
<code><var>ac</var></code> to avoid an unnecessary <abbr title="Clear and add">CLA</abbr>
instruction. The second argument is passed in <abbr title="Multiplier/quotient register">MQ</abbr>.
            </p>
            <p>
All other arguments are stored in locations <var>$ALIST</var> + 3, <var>$ALIST</var> + 4, etc.
The process for each argument <var>a</var> at position <var>i</var> in the argument list has three cases:
            </p>
            <ol>
              <li>
                <p>
If <var>a</var> is <code><span>nil</span></code>, the output is
                </p>
                
              </li>
              <li>
                <p>
If <var>a</var> is in the accumulator, the output is
                </p>
                
              </li>
              <li>
                <p>
Otherwise, the output is
                </p>
                <div>
                  <table>
                    <tbody>
                      <tr>
                        <td>
                          (<abbr title="Load multiplier/quotient register">LDQ</abbr>
                        </td>
                        <td>
                          ⟨location of <var>a</var>⟩)
                        </td>
                      </tr>
                      <tr>
                        <td>
                          (<abbr title="Store from multiplier/quotient register">STQ</abbr>
                        </td>
                        <td>
                          (<var>$ALIST</var> <var>i</var>)).
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </li>
            </ol>
            <p>
Because <abbr title="Multiplier/quotient register">MQ</abbr> is used in the third case, the second
argument must be reloaded afterwards. If the second argument is in <abbr title="Accumulator register">AC</abbr>
because of <a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comlis"><span>comlis</span></a>,
an <abbr title="Exchange multipler/quotient and accumulator registers">XCA</abbr> instruction is
generated. For example,
            </p>
            
            <p>
results in
            </p>
            <div>
              <table>
                <tbody>
                  <tr>
                    <td>(<abbr title="Clear and add">CLA</abbr></td>
                    <td>(<span>quote</span> <span>2</span>))</td>
                    <td></td>
                    <td></td>
                    <td>; set up argument of <span>g</span> </td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Store location and trap">STR</abbr></td>
                    <td>(<span>E</span> <span>g</span>)</td>
                    <td><span>7</span></td>
                    <td><span>1)</span></td>
                    <td>; call <span>g</span></td>
                  </tr>
                  <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>; the result of <span clas="function">g</span> is now in the accumulator</td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Exchange multipler/quotient and accumulator registers">XCA</abbr>)</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>; but it&#39;s the second argument, so move it to <abbr title="Multiplier/quotient register">MQ</abbr></td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Clear and add">CLA</abbr></td>
                    <td>(<span>quote</span> <span>nil</span>))</td>
                    <td></td>
                    <td></td>
                    <td>; put first argument of <span>f</span> in <abbr title="Accumulator register">AC</abbr></td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Store location and trap">STR</abbr></td>
                    <td>(<span>E</span> <span>f</span>)</td>
                    <td><span>7</span></td>
                    <td><span>1)</span></td>
                    <td>; call <span>f</span></td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
In the common case where the second argument isn&#39;t already in the accumulator, the instruction generated is
            </p>
            <div>
              <table>
                <tbody>
                  <tr>
                    <td>(<abbr title="Load multipler/quotient register">LDQ</abbr></td>
                    <td>⟨result of calling <a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-locate"><span>locate</span></a> on the second argument⟩).</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
There seems to be an unreachable code path in <a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-call"><span>call</span></a>.
It checks whether the first two arguments are the same, and if that value is in the accumulator it generates instructions to
to store it in <code><var>$ALIST</var> + 2</code> and to copy it to <abbr title="Multiplier/quotient register">MQ</abbr>.
However, <a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comlis"><span>comlis</span></a> always generates a unique symbol for
each subexpression and never lets <var>ac</var> contain a name that wasn&#39;t created by <span>gensym</span>. In other words, after
calling <a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comlis"><span>comlis</span></a>, <var>ac</var> will be
a newly-interned symbol. Perhaps this is a remnant of an earlier version.
            </p>
            <p>
The function <span>list</span>, in compiled code, uses an odd calling convention (like
<a href="#move-routine"><span>*MOVE</span></a>), where arguments are passed in instructions following
a <abbr title="Transfer and set index">TSX</abbr>. More specifically, the code
            </p>
            
            <p>
produces
            </p>
            <div>
              <table>
                <tbody>
                  <tr>
                    <td>(<abbr title="Transfer and set index">TSX</abbr></td>
                    <td><span>*LIST</span></td>
                    <td>4)</td>
                  </tr>
                  <tr>
                    <td>
                      (16777216 × <var>n</var> 
                    </td>
                    <td><var>a</var><sub>1</sub>)</td>
                  </tr>
                  <tr>
                    <td>(0</td>
                    <td><var>a</var><sub>2</sub>)
                    </td>
                  </tr>
                  <tr>
                    <td>
                      ⋮
                    </td>
                  </tr>
                  <tr>
                    <td>(0</td>
                    <td><var>a</var><sub><var>n</var></sub></td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
Note that 16777216 is 100000000 in octal. If the <span>list</span> call has no arguments then the compiler
generates an instruction to load the constant <span>nil</span>.
            </p>
            <p>
The other functions with odd calling are <span>specbind</span> and <span>specrstr</span>, which
<a href="#specbind-specrstr">were inserted into the input in pass one</a>. They both use the same convention:
            </p>
            <div>
              <p>
                      (<span>specbind</span>/<span>specrstr</span>
                      (<span>quote</span> (<var>s</var><sub>1</sub> … <var>s</var><sub><var>n</var></sub>)))
                    </p>
            </div>
            <p>
compiles to
            </p>
            <div>
              <table>
                <tbody>
                  <tr>
                    <td>(<abbr title="Transfer and set index">TSX</abbr></td>
                    <td><span>specbind</span>/<span>specrstr</span></td>
                    <td>4)</td>
                  </tr>
                  <tr>
                    <td>
                      (0
                    </td>
                    <td>(⟨offset of <var>s</var><sub>1</sub> on the <abbr title="Push-down list">PDL</abbr>⟩ <var>*N</var>)</td>
                    <td>1</td>
                    <td>(<span>SPECIAL</span> <var>s</var><sub>1</sub>))</td>
                  </tr>
                  <tr>
                    <td>(0
                    </td>
                    <td>(⟨offset of <var>s</var><sub>2</sub> on the <abbr title="Push-down list">PDL</abbr>⟩ <var>*N</var>)</td>
                    <td>1</td>
                    <td>(<span>SPECIAL</span> <var>s</var><sub>2</sub>))</td>
                  </tr>
                  <tr>
                    <td colspan="5">
                      ⋮
                    </td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Store location and trap">STR</abbr></td>
                    <td>(⟨offset of <var>s</var><sub><var>n</var></sub> on the <abbr title="Push-down list">PDL</abbr>⟩ <var>*N</var>)</td>
                    <td>1</td>
                    <td>(<span>SPECIAL</span> <var>s</var><sub><var>n</var></sub>))</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
In LISP 1.5, the <span>car</span> of an expression can be non-atomic, as in
            </p>
            <div>
              <div>(<table>
                        <tbody>
                          <tr>
                            <td>(<span>λ</span> (<var>x</var>) ⟨expression<sub>1</sub>⟩)</td>
                          </tr>
                          <tr><td>⟨expression<sub>2</sub>⟩).</td></tr>
                        </tbody>
                      </table>
                    </div>
            </div>
            <p>
The interpreter will evaluate ⟨expression<sub>1</sub>⟩ in an environment where <var>x</var> is bound to
the result of evaluating ⟨expression<sub>2</sub>⟩. The compiler basically does the exact same thing,
using a helper function named 
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comply"><span>comply</span></a> (perhaps
a portmanteau of “compile” and “apply”). Each argument is compiled; its result is put on the
<var>stomap</var> under the name of the corresponding parameter. Then the local function&#39;s body is compiled with the
new <var>stomap</var> containing entries for the parameters.
            </p>
            
          </section>
          <section id="compiling-prog-forms">
            <h4><a href="#compiling-prog-forms">Compiling prog forms</a></h4>
            <p>
The “program feature” is the least Lispy part of Lisp, so it makes sense that its compilation
is straightforward; the function responsible is
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comprog"><span>comprog</span></a>.
First, <a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comprog"><span>comprog</span></a>
goes through the form, making a list that pairs tags with generated symbols, to avoid naming conflicts with
any inner <span>prog</span>s. This list is stored in the special variable <var>golist</var>,
which is also used by
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comcond"><span>comcond</span></a>,
a function we will discuss momentarily. The symbols in the <var>golist</var> turn into labels in the
<abbr title="Lisp Assembly Program">LAP</abbr> output.
            </p>
            <p>
Code is generated to set the <span>prog</span> variables to 0 (<span>nil</span>),
unless the variable was added in pass one to help save/restore the values of special variables.
            </p>
            <p>
The forms in the body of the <span>prog</span> are then
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comval"><span>comval</span></a>&#39;d, except that
<span>go</span> forms are handled. Namely, the statement
            </p>
            
            <p>
becomes a simple
            </p>
            <div>
              <p>(<abbr title="Transfer">TRA</abbr>
                      ⟨generated label corresponding to <span>x</span>⟩).
                    </p>
            </div>
            <p>
Compiling <span>return</span> expressions is not done by
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comprog"><span>comprog</span></a>,
but by
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-call"><span>call</span></a>.
A <span>return</span> form has two possible translations, depending on whether the
<span>prog</span> in which it occurs is the main body of a function or a subexpression.
In the former case, the output is
            </p>
            <div>
              <table>
                <tbody>
                  <tr>
                    <td>⟨code to load the return value into <abbr title="Accumulator register">AC</abbr>⟩
                    </td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Transfer with index incremented">TXI</abbr>
                      <a href="#return"><span>*RETURN</span></a> <span>1</span> <var>*MN</var>).
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
In the latter case, the output is
            </p>
            <div>
              <table>
                <tbody>
                  <tr>
                    <td>⟨code to load the return value into <abbr title="Accumulator register">AC</abbr>⟩
                    </td>
                  </tr>
                  <tr>
                    <td>(<abbr title="Transfer">TRA</abbr>
                      ⟨a label generated to mark the end of the <span>prog</span>⟩).
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
The last thing <a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comprog"><span>comprog</span></a>
does is <a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-attach"><span>attach</span></a>
that generated label to the assembly output, if it exists.
            </p>
          </section>
          <section id="compiling-conditionals">
            <h4><a href="#compiling-conditionals">Compiling conditionals</a></h4>
            <p>
The routines responsible for compiling conditionals and Boolean expressions are
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comcond"><span>comcond</span></a>,
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-combool"><span>combool</span></a>, and
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-compact"><span>compact</span></a>,
which have (more or less) the following purposes.
            </p>
            <ul>
              <li>
                <p>
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-combool"><span>combool</span></a> compiles
an <span>and</span> or <span>or</span> form.
                </p>
              </li>
              <li>
                <p>
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-compact"><span>compact</span></a> compiles
a form used as a test in a conditional.
                </p>
              </li>
              <li>
                <p>
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comcond"><span>comcond</span></a> compiles
a <span>cond</span> form.
                </p>
              </li>
            </ul>
            <p>
Understanding these routines is complicated somewhat by the fact that
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-combool"><span>combool</span></a> and
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-compact"><span>compact</span></a> call
each other—but this is reasonable because
<span>and</span> and <span>or</span> can be written in terms of
<span>cond</span>.
            </p>
            <p>
The code generated for the expression
            </p>
            
            <p>
is
            </p>
            <div>
              <table>
                <tbody>
                  <tr>
                    <td></td>
                    <td colspan="4">⟨code to evaluate <var>e</var><sub>1</sub>⟩</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero">TZE</abbr></td>
                    <td><span>label</span>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td colspan="4">⟨code to evaluate <var>e</var><sub>2</sub>⟩</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero">TZE</abbr></td>
                    <td><span>label</span>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td colspan="4">⟨code to evaluate <var>e</var><sub>3</sub>⟩</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero">TZE</abbr></td>
                    <td><span>label</span>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Clear and add">CLA</abbr></td>
                    <td>(<span>quote</span> <span>*t*</span>))</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer">TRA</abbr></td>
                    <td>(* <span>2</span>))</td>
                  </tr>
                  <tr>
                    <td><span>label</span></td>
                    <td>(<abbr title="Clear and add">CLA</abbr></td>
                    <td>(<span>quote</span> <span>nil</span>)).</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
The code for
            </p>
            
            <p>
is quite similar.
            </p>
            <div>
              <table>
                <tbody>
                  <tr>
                    <td></td>
                    <td colspan="4">⟨code to evaluate <var>e</var><sub>1</sub>⟩</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on no zero">TNZ</abbr></td>
                    <td><span>label</span>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td colspan="4">⟨code to evaluate <var>e</var><sub>2</sub>⟩</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on no zero">TNZ</abbr></td>
                    <td><span>label</span>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td colspan="4">⟨code to evaluate <var>e</var><sub>3</sub>⟩</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on no zero">TNZ</abbr></td>
                    <td><span>label</span>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Clear and add">CLA</abbr></td>
                    <td>(<span>quote</span> <span>nil</span>))</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer">TRA</abbr></td>
                    <td>(* <span>2</span>))</td>
                  </tr>
                  <tr>
                    <td><span>label</span></td>
                    <td>(<abbr title="Clear and add">CLA</abbr></td>
                    <td>(<span>quote</span> <span>*t*</span>))</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
The label will have been generated by <span>gensym</span>. In real code, some other instructions
will follow the translation, so the <abbr title="Transfer">TRA</abbr> is meaningful.
            </p>
            <p>
In the LISP 1.5 system, the atom <span>nil</span> happens to be stored at location 0. Thus
the code can compare the <abbr title="Accumulator register">AC</abbr> with 0 to test for truth.
            </p>
            <p>
The translations of <span>and</span> and <span>or</span> are different when they
occur in the test (or antecedent) part of a <span>cond</span> clause. In a
<span>cond</span>, the <abbr title="Transfer on no zero">TNZ</abbr>
and <abbr title="Transfer on zero">TZE</abbr> instructions jump to a label
generated by <a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-comcond"><span>comcond</span></a>,
instead of the one generated in
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-combool"><span>combool</span></a> (which ends
up in the assembly output but is never transfered to). Furthermore, the code doesn&#39;t load <span>*t*</span>
or <span>nil</span>.
            </p>
            <p>
A <span>cond</span> form
            </p>
            <div>
              <div>
                      (<span>cond</span>
                      <table>
                        <tbody>
                          <tr>
                            <td>(<var>test</var><sub>1</sub></td>
                            <td><var>consequent</var><sub>1</sub>)
                            </td>
                          </tr>
                          <tr>
                            <td>(<var>test</var><sub>2</sub></td>
                            <td><var>consequent</var><sub>2</sub>)
                            </td>
                          </tr>
                          <tr>
                            <td>((<span>not</span> <var>test</var><sub>3</sub>) </td>
                            <td><var>consequent</var><sub>3</sub>))
                            </td>
                          </tr>
                          <tr>
                            <td>(<span>t</span></td>
                            <td><var>consequent</var><sub>4</sub>))
                            </td>
                          </tr>
                        </tbody>
                      </table>
                    </div>
            </div>
            <p>
results in output like
            </p>
            <div>
              <table>
                <tbody>
                  <tr>
                    <td></td>
                    <td colspan="4">⟨code to evaluate <var>test</var><sub>1</sub>⟩</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero">TZE</abbr></td>
                    <td><span>false-label</span><sub>1</sub>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td colspan="4">⟨code to evaluate <var>consequent</var><sub>1</sub>⟩</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero">TRA</abbr></td>
                    <td><span>end-conditional</span>)</td>
                  </tr>
                  <tr>
                    <td><span>false-label</span><sub>1</sub></td>
                    <td colspan="4">⟨code to evaluate <var>test</var><sub>2</sub>⟩</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero">TZE</abbr></td>
                    <td><span>false-label</span><sub>2</sub>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td colspan="4">⟨code to evaluate <var>consequent</var><sub>2</sub>⟩</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero">TRA</abbr></td>
                    <td><span>end-conditional</span>)</td>
                  </tr>
                  <tr>
                    <td><span>false-label</span><sub>2</sub></td>
                    <td colspan="4">⟨code to evaluate <var>test</var><sub>3</sub>⟩</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on no zero">TNZ</abbr></td>
                    <td><span>false-label</span><sub>3</sub>)</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td colspan="4">⟨code to evaluate <var>consequent</var><sub>2</sub>⟩</td>
                  </tr>
                  <tr>
                    <td></td>
                    <td>(<abbr title="Transfer on zero">TRA</abbr></td>
                    <td><span>end-conditional</span>)</td>
                  </tr>
                  <tr>
                    <td><span>false-label</span><sub>2</sub></td>
                    <td colspan="4">⟨code to evaluate <var>consequent</var><sub>4</sub>⟩</td>
                  </tr>
                  <tr>
                    <td><span>end-conditional</span></td>
                    <td colspan="4">… .</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
As you can see, the code for the final clause does not “test” <span>t</span>; instead
it simply goes on to <var>consequent</var><sub>4</sub>. A call to <span>not</span> is also avoided
by using <abbr title="Transfer on no zero">TNZ</abbr> instead of
<abbr title="Transfer on zero">TZE</abbr>.
Another clever optimization, not shown here, involves
<span>go</span>. When a clause&#39;s consequent is a <span>go</span> expression,
the condition is inverted (by wrapping the test in <span>null</span>) and one of
<a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-compact"><span>compact</span></a>&#39;s arguments
is abused so that a successful test transfers to the <span>go</span> statement&#39;s target.
            </p>
            <p>
There remains only one loose end:
A special case in <a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-compact"><span>compact</span></a>,
using a subroutine named <a href="https://texdraft.github.io/lisp-compiler/listing.html#definition-ceq"><span>ceq</span></a>,
compiles <span>eq</span> expressions into <abbr title="Subtract">SUB</abbr>
instructions.
            </p>
          </section>
        </section>
      </section>
    </article></div>
  </body>
</html>
