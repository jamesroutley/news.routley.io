<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://typeofnan.dev/solid-js-feels-like-what-i-always-wanted-react-to-be/">Original</a>
    <h1>Solid.js feels like what I always wanted React to be</h1>
    
    <div id="readability-page-1" class="page"><div><p>I started working with React professionally about three years ago. This was, coincidentally, right around when React Hooks came out. I was working in a codebase with a lot of class components, which always felt clunky.</p>
<p>Let’s take the following example: a counter that increments every second.</p>
<div data-language="jsx"><pre><code><span>class</span> <span>Counter</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span><span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> count<span>:</span> <span>0</span> <span>}</span><span>;</span>
    <span>this</span><span>.</span>increment <span>=</span> <span>this</span><span>.</span><span>increment</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span>
  <span>}</span>

  <span>increment</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span> count<span>:</span> <span>this</span><span>.</span>state<span>.</span>count <span>+</span> <span>1</span> <span>}</span><span>)</span><span>;</span>
  <span>}</span>

  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>
    <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>this</span><span>.</span><span>increment</span><span>(</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
  <span>}</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>The count is: </span><span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
  <span>}</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>That’s <em>a lot</em> of code to write for an auto-incrementing counter. More boilerplate and ceremony means a higher likelihood for errors and worse developer experience.</p>

<p>When hooks showed up, I was very excited. My counter could be reduced to the following:</p>
<div data-language="jsx"><pre><code><span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setCount</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>The count is: </span><span>{</span>count<span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Wait, that’s not actually right. Our <code>useEffect</code> hook has a <em>stale closure</em> around <code>count</code> because we haven’t included <code>count</code> in the <code>useEffect</code> dependency array. Omitting variables from dependency arrays are such a common mistake with React hooks that there are linting rules that will yell at you if you forget one.</p>
<p>I’ll get back to that in a moment. For now, we’ll add our missing <code>count</code> variable into the dependency array:</p>
<div data-language="jsx"><pre><code><span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setCount</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span>count<span>]</span><span>)</span><span>;</span>

  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>The count is: </span><span>{</span>count<span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>But now we have another problem, as we take a look at running app:</p>
<p><img src="https://www.moderndescartes.com/f3e4ed1c2fc5386ed7f13ab8cd513c72/bad-effect.gif" alt="wild numbers changing"/></p>
<p>Those of you more fluent in React likely know what’s going on because you battle this kind of thing every day: we’re creating too many intervals (a new one each time the effect is re-run, which is every time we increment <code>count</code>). We can solve this problem a few different ways:</p>
<ol>
<li>Return a <em>cleanup function</em> from <code>useEffect</code> hook that clears the interval</li>
<li>Use <code>setTimeout</code> instead of <code>setInterval</code> (good practice still to use a cleanup function)</li>
<li>Use the function form of <code>setCount</code> to prevent needing a direct reference to the current value</li>
</ol>
<p>Indeed any of these will work. We’ll implement the last option here:</p>
<div data-language="jsx"><pre><code><span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setCount</span><span>(</span><span>(</span><span>count</span><span>)</span> <span>=&gt;</span> count <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>

  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>The count is: </span><span>{</span>count<span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>And our counter is fixed! Since nothing’s in the dependency array, we only create one interval. Since we use a callback function for our count setter, we never have a stale closure over the <code>count</code> variable.</p>
<p>This is a pretty contrived example, yet it’s still confusing unless you’ve been working with React for a bit. More complex examples, which many of us encounter on a day-to-day basis, confuse even the most seasoned React developers.</p>

<p>I’ve thought a lot about hooks and why they don’t feel quite right. I found the answer, it turns out, by exploring Solid.js.</p>
<p>The problem with React hooks is that <em>React isn’t truly reactive</em>. If a linter knows when an effect (or callback, or memo) hook is missing a dependency, then why can’t the framework automatically detect dependencies and <em>react</em> to those changes?</p>

<p>The first thing to note about Solid is that it doesn’t try to reinvent the wheel: it looks <em>a lot</em> like React from afar because React has some tremendous patterns: unidirectional, top-down state; JSX; component-driven architecture.</p>
<p>If we started to rewrite our <code>Counter</code> component in Solid, we would start out like this:</p>
<div data-language="jsx"><pre><code><span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>createSignal</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>The count is: </span><span>{</span><span>count</span><span>(</span><span>)</span><span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>We see one big difference so far: <code>count</code> is a function. This is called an <em>accessor</em> and it’s a big part of how Solid works. Of course, we have nothing here about incrementing <code>count</code> on an interval, so let’s add that.</p>
<div data-language="jsx"><pre><code><span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>createSignal</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setCount</span><span>(</span><span>count</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>

  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>The count is: </span><span>{</span><span>count</span><span>(</span><span>)</span><span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Surely this won’t work, right? Wouldn’t new intervals be set each time the component renders?</p>
<p>Nope. <em>It just works</em>.</p>
<p>But why? Well, it turns out that Solid doesn’t need to rerun the <code>Counter</code> function to re-render the new <code>count</code>. In fact, it doesn’t need to rerun the <code>Counter</code> function at all. If we add a <code>console.log</code> statement inside the <code>Counter</code> function, we see that it runs only <em>once</em>.</p>
<div data-language="jsx"><pre><code><span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>createSignal</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setCount</span><span>(</span><span>count</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>

  console<span>.</span><span>log</span><span>(</span><span>&#39;The Counter function was called!&#39;</span><span>)</span><span>;</span>

  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>The count is: </span><span>{</span><span>count</span><span>(</span><span>)</span><span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>In our console, just one lonely log statement:</p>
<div data-language="text"><pre><code>&#34;The Counter function was called!&#34;</code><span aria-hidden="true"><span></span></span></pre></div>
<p>In Solid, code doesn’t run more than once unless we explicitly ask it to.</p>

<p>It turns out I solved our React <code>useEffect</code> hook without having to actually write something that looks like a hook in Solid. Whoops! But that’s okay, we can extend our counter example to explore Solid effects.</p>
<p>What if we want to <code>console.log</code> the <code>count</code> every time it increments? Your first instinct might be to just <code>console.log</code> in the body of our function:</p>
<div data-language="jsx"><pre><code><span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>createSignal</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setCount</span><span>(</span><span>count</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>

  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>The count is </span><span><span>${</span><span>count</span><span>(</span><span>)</span><span>}</span></span><span>`</span></span><span>)</span><span>;</span>

  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>The count is: </span><span>{</span><span>count</span><span>(</span><span>)</span><span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>That doesn’t work though. Remember, the <code>Counter</code> function only runs once! But we can get the <em>effect</em> we’re going for by using Solid’s <code>createEffect</code> function:</p>
<div data-language="jsx"><pre><code><span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>createSignal</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setCount</span><span>(</span><span>count</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>

  <span>createEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>The count is </span><span><span>${</span><span>count</span><span>(</span><span>)</span><span>}</span></span><span>`</span></span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>The count is: </span><span>{</span><span>count</span><span>(</span><span>)</span><span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>This works! And we didn’t even have to tell Solid that the effect was dependent on the <code>count</code> variable. This is <em>true reactivity</em>. If there was a second accessor called inside the <code>createEffect</code> function, it would also cause the effect to run.</p>

<h2>Reactivity, not lifecycle hooks</h2>
<p>If you’ve been in React-land for a while, the following code change might be really eyebrow-raising:</p>
<div data-language="jsx"><pre><code><span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>createSignal</span><span>(</span><span>0</span><span>)</span><span>;</span>

<span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>setCount</span><span>(</span><span>count</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>

<span>createEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>The count is </span><span><span>${</span><span>count</span><span>(</span><span>)</span><span>}</span></span><span>`</span></span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>The count is: </span><span>{</span><span>count</span><span>(</span><span>)</span><span>}</span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span><span>;</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>And the code still works. Our <code>count</code> signal doesn’t need to live in a component function, nor do the effects that rely on it. Everything is just a part of the reactive system and “lifecycle hooks” really don’t play much of a role.</p>
<h2>Fine-grained DOM updates</h2>
<p>So far I’ve been focusing a lot on developer experience (e.g., more easily writing non-buggy code), but Solid is also getting a lot of praise for its performance. One key to its strong performance is that it interacts directly with the DOM (no virtual DOM) and it performs “fine-grained” DOM updates.</p>
<p>Consider the following adjustment to our counter example:</p>
<div data-language="jsx"><pre><code><span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>createSignal</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setCount</span><span>(</span><span>count</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>
      The </span><span>{</span><span>(</span>console<span>.</span><span>log</span><span>(</span><span>&#39;DOM update A&#39;</span><span>)</span><span>,</span> <span>false</span><span>)</span><span>}</span><span> count is:</span><span>{</span><span>&#39; &#39;</span><span>}</span><span>
      </span><span>{</span><span>(</span>console<span>.</span><span>log</span><span>(</span><span>&#39;DOM update B&#39;</span><span>)</span><span>,</span> <span>count</span><span>(</span><span>)</span><span>)</span><span>}</span><span>
    </span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span>
  <span>)</span><span>;</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>If we run this, we get the following logs in our console:</p>
<div data-language="text"><pre><code>DOM update A
DOM update B
DOM update B
DOM update B
DOM update B
DOM update B
DOM update B</code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>In other words, the only thing that gets updated every second is the small piece of the DOM that contains the <code>count</code>. Not even the <code>console.log</code> earlier in the same <code>div</code> is re-run.</p>

<p>I have enjoyed working with React for the past few years; it always felt like the right level of abstraction from working with the actual DOM. That being said, I have also become wary of how error-prone React hooks code often becomes. Solid.js feels like it uses a lot of the ergonomic parts of React while minimizing confusion and errors. I tried to show you some of the parts of Solid that gave me “aha!” moments, but I recommend you check out <a href="https://www.solidjs.com">https://www.solidjs.com</a> and explore the framework for yourself.</p></div><p>If you&#39;d like to support this blog by<!-- --> <a href="https://ko-fi.com/nickscialli">buying me a coffee</a> <!-- -->I&#39;d really appreciate it!</p></div>
  </body>
</html>
