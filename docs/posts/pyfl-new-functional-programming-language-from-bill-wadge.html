<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://billwadge.com/2022/01/13/functional-programming-for-the-rest-of-us-get-pyfl-now/">Original</a>
    <h1>PyFl – new functional programming language from Bill Wadge</h1>
    
    <div id="readability-page-1" class="page"><div>
						<p>It was developed in a secret lab and released, after which it spread rapidly. COVID? (maybe …). But I’m talking about the new PyFL interpreter. It’s finally available for the general public at</p>
<p>pyflang.com</p>
<p>To make things simple, in the form of a zip file   –  I’ll put it  on GitHub if there’s enough interest.</p>
<p>Just read README.txt and follow the instructions. As it says you need Python 3, 3.10.1 being the latest  stable version. . It all should work straight out of the box.</p>
<p><strong>A quick summary of PyFL</strong></p>
<p>It”s all implemented on top of Basic PyFL, a  stripped down lazy functional language. Basic PyFL has the data  types and infix operators of POP-11, lambda expressions, and <em>valof</em> clauses (basically <em>where</em> clauses), and function application. Function application uses conventional mathematical notation, e.g. f(a,b) instead of (f a b) as in Haskell.</p>
<p>Basic PyFL was implemented from scratch using function closures and similar standard techniques. It is  dynamically typed –  no type declarations and no constraints on application (self application in particular              is  supported).</p>
<p>Once Basic PyFL was implemented I proceeded to add more and more extensions, some quite novel.</p>
<p><strong>Conventional function definitions</strong></p>
<p>Mathematicians don’t normally use lambda expressions to define functions. Instead of writing</p>


<pre><code>sumsq = lambda (x,y) x*x+y*y;</code></pre>


<p>they are more likely to write</p>


<pre><code>sumsq(x,y) = x*x+y*y;</code></pre>


<p>This notation is implemented by simple translation – definitions using conventional notation are replaced by the version using lambda. Naturally this involves a complete ‘tree walk’ of the entire program because conventional definitions may occur in values deeply nested in other expressions.</p>
<p>The next feature added is <em>where</em> clauses. These are stylistically more convenient but cause parsing problems and so are not a basic feature. They, too, are implemented by a simple translation. A <em>where</em> clause with subject (head) <em>s</em> and set <em>body</em> of definitions is rewritten as a <em>valof</em> with the same body except that the definition <em>result=s</em> is  added.</p>
<p>With <em>where</em> and <em>lambda</em> we can write a non recursive factorial  program:</p>


<pre><code>fac(7)
 where
  fac = Y(A);
  A(f) = lambda (n) if n==0 then 1 else n*f(n-1) fi;
  Y(a) = g(g) where g(x) = a(x(x));
 end</code></pre>


<p>Notice that no variable is defined directly or indirectly in terms of itself. This definition of the fixed point combinator Y  clearly depends on self-application, which  Haskell’s  type system won’t allow. I was pretty happy when the PyFL interpreter produced 5040, the  correct answer.</p>
<p>Another feature added was multiple returns, so that you can write e.g.</p>
<p>min, max = bounds(x)</p>
<p>This is implemented with a simple translation but I won’t go in to it.</p>
<p>The next feature added was VBOs – variable binding operators, like the existential quantifier ∃ or the sigma (summation) operator ∑. They work exactly like their math counterparts except the ranges are lists and they are expressed in ASCII  notation. Thus we can compute  the primes less than 100   a</p>


<pre><code>res = [2 3 5 7] &lt;&gt;
those n in rg(2,100):
 forall p in [2 3 5 7] :
  n mod p != 0
 end
end
where  
 rg(l,u) = 
    if l&gt;u then [] 
           else l :: rg(l+1,u)
    fi;
end;</code></pre>


<p>These VBOs are disguised loops, even though PyFL is a  functional language. They are implemented by translating into expressions using map, filter, and reduce.</p>
<p>My next step was to jump right in and add genuine <em>while</em> loops. We can use a <em>while</em> clause to compute the primes less than 100 as follows</p>


<pre><code>res =
while n &lt;100
 n = 3 fby n+2;
 nprime = not exist p in primes: n mod p == 0 end;
 primes = [2] fby if nprime then n :: primes else primes fi;
 result = primes;
end</code></pre>



<p>There are three loop variables, <code>n, primes</code>, and <code>nprime</code>. The first is a counter that enumerates the odd numbers starting at 3, the second is a (reverse) list of the primes we have found so far, and <em>prime</em> is  true or false depending on whether or not the current value of <em>n</em> is a prime (not divisible by any prime we’ve found so far).</p>



<p>It looks like Lucid (as intended) but is not Lucid; <code>fby</code> is just a syntax word that separates the initial expression from the next value expression of the recurrence relation. It’s translated into a tail recursion with the loop variables becoming formal parameters of the tail recursively defined function.</p>



<p>Next I took a break from innovating and produced a REPL program – REPL stands for Read, Evaluate, Print, Loop. The REPL is invoked by the command <code>repl</code> and when run it  prints a  welcome message and a   list of real commands. It declares the current input file, if any, then gives a prompt consisting of a % proceeded by the name of the current import, if any. For example you might see</p>



<p><code>exp%</code></p>



<p>which means the current input file is <code>exp.</code></p>



<p>The various commands allow you to manipulate the current import, whose source is stored in the file  <code>buffer</code> and whose name is in the file <code>current</code>import (don’t touch these files directly). For example, to see the source use the command <em>b</em> or better yet,<em> f</em>, which invokes the pretty printer to format it. If you want to edit the file in the buffer use <em>v</em>, which invokes <em>vi.</em></p>



<p>The file in the buffer is a set of definitions, not a program, so it doesn’t make sense to ‘run’ it. Instead, you can evaluate a PyFL expression  and the evaluator will take the definitions into account if need be. What I usually do, as in the program given above, is equate the variable <em>res</em> to the expression of interest and use the command</p>



<p><code>primes% e res</code></p>



<p>The evaluator evaluates the expression following the <em>e</em> and prints the result, followed by some statistics.You can enter any PyFL expression, it doesn’t have to use the definitions in the buffer.</p>



<p>There’s more but you can discover it for yourself. PyFL is well documented by README.txt file, the REPL, and  my numerous blog posts (my blog can now be found at <code>billwadge.com</code>)</p>



<p>A few notes. If you pay attention to the statistics, it’s obvious that for some programs the evaluator is ridiculously inefficient – huge numbers of list operations. This will be fixed in a  future release. Also, I overlooked some vital opportunities for caching. I discovered, to my disgust, that   evaluating res*res takes  twice as long as evaluating res or res**2. This will also be fixed.</p>



<p>I put a lot of  work into catching and handling errors, but not enough.  It’s still easy to crash the  software (generate a traceback). This will get  harder in future releases.</p>



<p>So please download the zip file and try it out. Write your own PyFL programs, and, if you’re feeling adventurous, modify the source of the interpreter for e.g. better error handling or new features. Let me know of any interesting results and I’ll discuss them in my blog and maybe incorporate them in a future release (with appropriate credit given).</p>












































											</div></div>
  </body>
</html>
