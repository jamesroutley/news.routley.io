<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://msinilo.pl/blog2/post/compilers-are-too-smart/">Original</a>
    <h1>Compilers Are (Too) Smart</h1>
    
    <div id="readability-page-1" class="page"><div id="layout">
    

	
	

    <div>
		<section>
            
            
            
            	<span>
                	<span><sup>6</sup></span><span>/</span><span>Jun</span> <span>2024</span>
            	</span>
            	
            
            	
            		
            		




            	
            

			
			
				
			

			

			

            <p>Last week I noticed some unexpected assembly code in a function calling <em>std::unordered_map::find</em> (yes, I know, friends don’t let friends use STL, but that is a topic for another discussion). I decided to investigate a bit and it turned out to be quite a journey.
It was a Clang compiler, ARM-based platform, I will use x64 here as behavior is similar and it is easier to repro in the Compiler Explorer.
What is important however, we should be using <a href="https://libcxx.llvm.org/">libcxx</a> STL (-stdlib=libc++ switch). A minimal example might look like:</p>

<div><pre><code data-lang="cpp"><span>using</span> hmap <span>=</span> std<span>::</span>unordered_map<span>&lt;</span>size_t,<span>void</span><span>*</span>,ident<span>&gt;</span>;
<span>bool</span> <span>foo</span>(<span>const</span> hmap<span>&amp;</span> hm, size_t k)
{
    <span>return</span> hm.find(k) <span>!=</span> hm.end();
}</code></pre></div>

<p>(ident is our version of <em>std::identity</em>, ie. our hash of ‘x’ is just ‘x’, key was pre-hashed, I don’t think it matter, but removes hashing from the equation)
Simple enough, yet if we look at the generated assembly there is this giant blob at the beginning:</p>

<div><pre><code data-lang="asm"><span>mov</span>     <span>rax</span>, <span>r8</span>
<span>shr</span>     <span>rax</span>
<span>movabs</span>  <span>rcx</span>, <span>6148914691236517205</span>
<span>and</span>     <span>rcx</span>, <span>rax</span>
<span>mov</span>     <span>rax</span>, <span>r8</span>
<span>sub</span>     <span>rax</span>, <span>rcx</span>
<span>movabs</span>  <span>rcx</span>, <span>3689348814741910323</span>
<span>mov</span>     <span>rdx</span>, <span>rax</span>
<span>and</span>     <span>rdx</span>, <span>rcx</span>
<span>shr</span>     <span>rax</span>, <span>2</span>
<span>and</span>     <span>rax</span>, <span>rcx</span>
<span>add</span>     <span>rax</span>, <span>rdx</span>
<span>mov</span>     <span>rcx</span>, <span>rax</span>
<span>shr</span>     <span>rcx</span>, <span>4</span>
<span>add</span>     <span>rcx</span>, <span>rax</span>
<span>movabs</span>  <span>rax</span>, <span>1085102592571150095</span>
<span>and</span>     <span>rax</span>, <span>rcx</span>
<span>movabs</span>  <span>r9</span>, <span>72340172838076673</span>
<span>imul</span>    <span>r9</span>, <span>rax</span>
<span>shr</span>     <span>r9</span>, <span>56</span>
<span>cmp</span>     <span>r9</span>, <span>1</span>
<span>ja</span>      <span>.LBB0_3</span></code></pre></div>

<p>It bothered me because it was almost as many instructions as the rest of the function on the fast path! What is going on here? At first I thought it was not eliminating the hash function properly, but it was quickly disproved.
Don’t kick yourself if you can’t tell what that code is doing, it was a bit more obvious in the ARM version as it uses hex constants. What are these weird numbers?
Well, </p><pre>6148914691236517205 = 0x5555555555555555
3689348814741910323 = 0x3333333333333333
1085102592571150095 = 0xf0f0f0f0f0f0f0f
72340172838076673 = 0x101010101010101</pre>
Still not clear? It was not for me either, but it was familiar enough and ‘bit-twiddly’ enough to find an answer with some quick web search - it basically counts the number of set bits (1s) in a word.
I still didn’t understand where did it come from, it was all inlined in optimized builds and obviously looked very different in debug. I tried to step through the C++ code anyway, looking for clues and found <a href="https://github.com/llvm/llvm-project/blob/1118c2e05e67a36ed8ca250524525cdb66a55256/libcxx/include/__hash_table#L1723">this</a> .
<em>find</em> calls <em>constrain_hash</em> (multiple times) – it basically converts a potentially very big hash to 0-&gt;bucket count range…

<div><pre><code data-lang="cpp"><span>inline</span> _LIBCPP_HIDE_FROM_ABI size_t <span>__constrain_hash</span>(size_t __h, size_t __bc) {
  <span>return</span> <span>!</span>(__bc <span>&amp;</span> (__bc <span>-</span> <span>1</span>)) <span>?</span> __h <span>&amp;</span> (__bc <span>-</span> <span>1</span>) <span>:</span> (__h <span>&lt;</span> __bc <span>?</span> <span>__h</span> : __h <span>%</span> __bc);
}</code></pre></div>

<p>As we can see, it tries very hard to avoid division, so if our bucket count (<em>bc</em>) is a power-of-two, we can get away with an <em>AND</em>. x&amp;(x-1)==0 is simply a power of two test, but another way to do it is… to count the set bits, powers of two will only have one.
Why did Clang decide to use? Well, some CPUs have an instruction to do it, in which case it makes a bit more sense. Compare same snippet compiled with -msse4 (you need SSE4 on x64 for <em>popcnt</em>):</p>

<div><pre><code data-lang="asm"><span>popcnt</span>  <span>r9</span>, <span>r8</span>
<span>cmp</span>     <span>r9</span>, <span>1</span>
<span>ja</span>      <span>.LBB0_3</span></code></pre></div>

<p>Now, if you ask me, I’m still not sure it is worth it, yes, it is 1 instruction shorter and needs 1 register less, but <em>popcnt</em> has some latency… not an expert though.
What is interesting, though, it is incredibly finicky. For example, when searching for more information on <em>constrain_hash</em>, I found <a href="https://github.com/llvm/llvm-project/commit/118cb4180f30a5e501a055dc859b326049a24be2">this change</a> . Undoing part of it, ie. going back to:</p>

<div><pre><code data-lang="cpp"><span>inline</span> _LIBCPP_HIDE_FROM_ABI size_t <span>__constrain_hash</span>(size_t __h, size_t __bc) {
  <span>return</span> <span>!</span>(__bc <span>&amp;</span> (__bc <span>-</span> <span>1</span>)) <span>?</span> __h <span>&amp;</span> (__bc <span>-</span> <span>1</span>) <span>:</span> (__h <span>%</span> __bc);
}</code></pre></div>

<p>… is enough to stop Clang from trying to use the <em>popcnt</em> version. I also tried creating a minimal repro, without including <em>unordered_map</em>.
It turns out that <em>constrain_hash</em> in isolation does only the DEC/TEST version, it is only <em>find</em> that calls it (potentially) multiple times that tries to get fancy.
It does make a bit more sense here as we only do <em>popcnt</em> once and then reuse the bitcount to quickly select between DIV and AND. However, it is absolutely possible to get similar optimizations with the other version.
MSVC does a decent job, but it repeats some of the calculations, but if you can convince Clang to drop <em>popcnt</em> (for example by using ‘old’ <em>constrain_hash</em>) it generates a pretty nice code with basically 2 distinct loops.</p>

<p>If you would like to experiment yourself, Compiler Explorer snippet can be found <a href="https://gcc.godbolt.org/z/qGzWo39b6">here</a> (change #if 1 to #if 0 in <em>constrain_hash</em> to observe the effect).
CE has a pretty great feature which lets you see both LLVM IR and the Optimization Pipeline - it is really quite fascinating. For example if you observe the optimization process, you will notice it begins with</p>

<div><pre><code data-lang="asm"><span>%</span><span>sub</span> <span>=</span> <span>sub</span> <span>i64</span> <span>%</span><span>1</span>, <span>1</span>
<span>%</span><span>and</span> <span>=</span> <span>and</span> <span>i64</span> <span>%</span><span>0</span>, <span>%sub</span>
<span>%</span><span>tobool</span> <span>=</span> <span>icmp</span> <span>ne</span> <span>i64</span> <span>%and</span>, <span>0</span></code></pre></div>

<p>… then at some point, during the <em>InstCombinePass</em> it changes to</p>

<div><pre><code data-lang="asm"><span>%0</span> <span>=</span> <span>call</span> <span>range</span>(<span>i64</span> <span>0</span>, <span>65</span>) <span>i64</span> <span>@</span><span>llvm.ctpop.i64</span>(<span>i64</span> <span>%__bc</span>)
<span>%</span><span>tobool.not</span> <span>=</span> <span>icmp</span> <span>ult</span> <span>i64</span> <span>%</span><span>0</span>, <span>2</span></code></pre></div>

<p>…X86 DAG-&gt;DAG (x86-isel) will however implement it as DEC/TEST:</p>

<div><pre><code data-lang="asm"><span>6:</span><span>gr64</span> <span>=</span> <span>DEC64r</span> <span>%</span><span>5</span>:<span>gr64</span>(<span>tied-def</span> <span>0</span>), <span>implicit-def</span> <span>dead</span> <span>$eflags</span><span>; example.cpp:15:17
</span><span></span><span>TEST64rr</span> <span>%</span><span>5</span>:<span>gr64</span>, <span>killed</span> <span>%</span><span>6</span>:<span>gr64</span>, <span>implicit-def</span> <span>$eflags</span><span>;</span> <span>example.cpp</span>:<span>15</span>:<span>17</span></code></pre></div>

<p>This applies to <em>constrain_hash</em> in separation, though. <em>find</em> works differently – it inlines <em>constrain_hash</em> still in the <em>ctpop</em> form (InlinerPass):</p>

<div><pre><code data-lang="asm"><span>%0</span> <span>=</span> <span>call</span> <span>range</span>(<span>i64</span> <span>0</span>, <span>65</span>) <span>i64</span> <span>@</span><span>llvm.ctpop.i64</span>(<span>i64</span> <span>%__bc</span>)
<span>%</span><span>tobool.not.i</span> <span>=</span> <span>icmp</span> <span>ult</span> <span>i64</span> <span>%</span><span>0</span>, <span>2</span></code></pre></div>

<p>… in this case however <em>x86-isel</em> stage will generate the <em>popcnt</em> instruction (or a terribly verbose equivalent). I do think it is a bug in this case,
native <em>popcnt</em> could maybe be defended, but should not be used if compiling for architecture that does not support it.</p>

	
			

			

			
				
            
          </section>
          
          	
          
        
      
    </div>
  </div></div>
  </body>
</html>
