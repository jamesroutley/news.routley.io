<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jaycarlson.net/microcontrollers/">Original</a>
    <h1>$1 Microcontrollers (2017)</h1>
    
    <div id="readability-page-1" class="page"><div><h4>Silcon Labs EFM8: Fantastic value and ease-of-use from the only 8-bit part with a totally-free cross-platform vendor ecosystem</h4><p>The <a href="https://jaycarlson.net/pf/silicon-labs-efm8/">EFM8</a> was the fastest 8-bit part in my round-up, and admittedly, my favorite 8-bit architecture to develop with overall. What these parts lack in brains they make up for in brawns — 14-bit ADCs, 12-bit DACs, lots of timers, and a 72 MHz core clock speed that gives you timing options not found in any other part in the round-up.</p><p>Plus, this is the only 8-bit part with a totally-free, cross-platform, vendor-provided ecosystem. Let that sink in.</p><p>Keil C51 is a silly compiler, but Silicon Labs does an excellent job hiding it under the hood — even when running its Eclipse-based Simplicity Studio on Linux or macOS.</p><p>Simplicity Configurator is the lightest-weight code generator in our round-up, using only 534 bytes of flash to house the entire DMX-512 receiver project. It was one of the easiest to use, and seemed to strike a good balance between abstraction, performance, and ease of use.</p><p>Debugging speeds are snappy with a J-Link debugger, but at $35, the official Silicon Labs USB Debug Adapter is one of the cheapest first-party debugger in the round-up, and clones of the hardware are even cheaper.</p><p>And call me old-fashioned, but I think the 8051 definitely has a place in 2017 — especially among hobbyists and students, where its bit-addressable memory, easy-to-use peripherals, and fuse-free configuration help get students comfortable with microcontrollers quickly.</p><h4>Microchip megaAVR &amp; tinyAVR 1-Series: Different strokes for different folks — still with the best 8-bit toolchain available</h4><p>The <a href="https://jaycarlson.net/pf/atmel-microchip-megaavr/">megaAVR</a> came in surprisingly flat for me: especially when compared with its lower-cost, new sibling, the <a href="https://jaycarlson.net/pf/atmel-microchip-tinyavr-1-series/">tinyAVR 1-Series</a>.</p><p>There’s no comparison when it comes to price: tinyAVR has incredible value — packing in a nice assortment of timers, analog peripherals (including a DAC), and a new 20 MHz internal oscillator — while costing 20-40% less than the megaAVR.</p><p>While the megaAVR has a perplexing debugging experience that requires two completely different interfaces and protocols to work with the part, the new one-wire UPDI interface the tinyAVR sports worked flawlessly in my testing.</p><p>But that’s the crux of the problem for the tinyAVR — by shedding many of its megaAVR roots, Microchip ended up with a wonderful microcontroller that will be challenging to use for a large base of Atmel fans: indie developers and hobbyists who use low-cost, open-source programmers (which don’t support the UPDI interface).</p><p>While the tinyAVR wasn’t the fastest part in the round-up (even among 8-bitters), it was the most efficient – both in terms of active-mode power and clock efficiency. Amazingly, the AVR only uses about twice as many instructions as 16- and 32-bit parts when performing 16-bit math.</p><p>Unfortunately, the AVR system as a whole is not without its issues. The Windows-only Atmel Studio is still buggy (especially with older megaAVR devices and AVR Dragon stuff in my tests), and there isn’t an under-$50 low-cost debugger available (other than hacking apart Xplained Mini dev boards).</p><p>In many ways, there seems to be a tacit demarcation Atmel creates between its hobbyist/indie developers, and the professional shops that use Atmel parts.</p><p>As a professional embedded developer, I most definitely have access to Windows computers, and I have no problem blowing a few billable hours’ worth of pay on a $140 debugger.</p><p>But even as popular as Atmel is among hobbyists, Atmel has largely stayed out of this space directly. Instead, they’ve secured small-volume AVR sales by relying on the open-source community to build their own tools for themselves: turning out a slew of hardware and software used to program the megaAVR devices.</p><p>While I applaud the efforts of these developers, these tools are inferior to Atmel’s. Their programming speeds are terrible, they don’t support the new tinyAVR 1-Series devices, and they have absolutely no debug capability.</p><p>Having said that, both the megaAVR and tinyAVR have the best toolchain available for 8-bit MCU development. The part supports a full, end-to-end Makefile-based GCC toolchain.</p><p>If you love printf() debugging, would never touch a proprietary toolchain, and hate IDEs, megaAVR and old tinyAVR parts are definitely for you. The older ones are still available in DIP packages, and as you probably know, there are a ton of low-cost programmers available across the world. The online community is massive, and as clunky as I find Atmel START to be, I have to applaud its support for Makefile-based project generation.</p><p>Consequently, the megaAVR remains the most open-source 8-bit microcontroller on the market — by a long shot.</p><p>But I’d really like to see Microchip provide a PicKit-priced debugger with UPDI support — and allow off-board debugging the way their PIC Curiosity Boards do.</p><p>I also hope these open-source projects can add UPDI support to their tools, so that hobbyists and indie developers can start integrating the tinyAVR into their projects — it’s a much better part, and if you’re an AVR user with access to Atmel Studio, you really ought to buy an Xplained Mini board and take it for a spin.</p><h4>STM32F0: A low-cost, no-nonsense part with arguably the best Arm development ecosystem tested</h4><p><a href="https://jaycarlson.net/pf/st-stm32f0/">The STM32F0</a> was the lowest-power Arm microcontroller in the round-up, and also one of the easiest to use. STM32CubeMX doesn’t generate the most compact code on Arm (that honor belongs to Cypress PSoC Creator and Infineon DAVE), but it has a snappy interface, and the generated code is easy enough to manipulate for your own goals.</p><p>I love the nearly-stock Eclipse-based environment that System Workbench for STM32 provides, and the ST-Link and excellent Discovery/Nucleo boards seals the deal for me.</p><p>Most pros have used ST parts in their work, but for all these reasons, any hobbyist looking at moving to Arm should probably pick up a dev board from this ecosystem, too. ST has a huge market footprint, so there’s tons of resources online — aimed at both hobbyists and professionals.</p><h4>SAM D10: Killer performance &amp; peripherals, but with runtime library hiccups</h4><p>The Microchip/Atmel <a href="https://jaycarlson.net/pf/atmel-microchip-sam-d10/">SAM D10</a> (and the broader D11/D20/D21 ecosystem) has good value (considering their analog portfolio includes a DAC, and they have good timing options), and the SAM D10 was the most efficient part tested when running at full speed.</p><p>Professionals will like the easy-to-use, well-documented header files, and hobbyists will appreciate the 1.27mm-pitch SOIC package options and GCC compilers that come with the Arm ecosystem. But before I grab this part for a project, Microchip really needs to fix the extremely slow, bloated peripheral library, and update their code-gen tool to do proper error-checking of clock and peripheral configurations.</p><p>As it is, whenever I use Atmel START on the D10, I want to STOP almost immediately. And there are no current, stand-alone peripheral drivers that Microchip has released for this part, so unless you want to do register programming from scratch, you’ll be relying on third-party, open-source projects — like Alex Taradov’s <a href="https://github.com/ataradov/mcu-starter-projects">code examples</a>.</p><h4>Infineon XMC1100: Interesting peripheral perks make this Cortex-M0 stand out</h4><p>The most interesting Arm chip was, without a doubt, the <a href="https://jaycarlson.net/pf/infineon-xmc1100/">Infineon XMC1100</a> — and I think professionals who may be wary of getting out of the ST/NXP/Atmel Arm ecosystem need to take a second look at these XMC1000 (and XMC4000) parts.</p><p>The timer options are amazingly flexible, and you can squeeze fantastic performance out of the USIC module.</p><p>I’m going to go out on a limb and recommend that serious hobbyists who are building motor / lighting control projects look into these parts, too. DAVE makes setting up these complex peripherals painless, and the 38-pin TSSOP chips will be substantially easier to solder than the 0.5mm QFNs and QFPs you usually end up with in these pin counts.</p><p>Like many of the parts reviewed here, the biggest problem for hobbyists and indie developers is the tiny online communities and lack of GitHub repos with open-source projects that use these chips. My advice — be bold, and post in the forums. Infineon employees monitor and usually respond within a day or so.</p><h4>PIC16: Tons of peripherals with a slower, power-efficient core</h4><p>When you compare the <a href="https://jaycarlson.net/pf/microchip-pic16-five-digit-enhanced/">PIC16</a> with other 8-bit parts out there, it’s obviously a part built for low-power applications, and not processing power. And while the development ecosystem is workable, there are other parts more friendlier pathways — especially for smaller shops, hobbyists, and students who need extremely low-cost tools (and free software).</p><p>To add fuel to the PIC-vs-AVR debate, my testing found that a 32 MHz PIC16 is roughly equivalent to an AVR part running at 1.4 MHz (in terms of math performance), and 9 MHz (in terms of bit-shuffling performance).</p><p>Having said that, the DMX-512 receiver seems a perfect match for the PIC16, and that’s where it looks best in my testing: the PIC16 was the lowest-power 8-bit part in my testing.</p><p>It’s also full of timers and digital logic-oriented peripherals that make it suitable for funky special-purpose projects that require some crafty use of configurable logic and and the numerically-controlled oscillator — these peripherals help offload the (relatively slow) CPU, at the expense of requiring more developer familiarity with the device and these peripherals.</p><p>The usual Microchip gotchas apply: clunky IDE, expensive compilers, and expensive debuggers.</p><p>The usual Microchip advantages apply: huge online community, seemingly infinite product lifetime guarantees, and DIP, SOIC, QFP, and QFN package availability.</p><h4>PIC24: An expensive MSP430 wannabe that doesn’t hit the mark</h4><p>The <a href="https://jaycarlson.net/pf/microchip-pic24/">PIC24</a> is nearly forgettable. In the biquad test, it’s marginally faster than the <a href="https://jaycarlson.net/pf/renesas-rl-78/">Renesas RL-78</a> but uses almost three times as much power. In the DMX-512 test, both the RL-78 and MSP430 beat it, too. It was also one of the least-endowed parts in the round-up (which really just means it’s expensive — higher-end PIC24 parts have no shortage of peripherals).</p><p>The usual Microchip gotchas apply: clunky IDE, expensive compilers, and expensive debuggers.</p><p>The usual Microchip advantages apply: huge online community, seemingly infinite product lifetime guarantees, and DIP, SOIC, QFP, and QFN package availability.</p><h4>PIC32: An excellent 32-bit part that balances performance and power consumption</h4><p>The <a href="https://jaycarlson.net/pf/microchip-pic32mm/">PIC32MM</a> was my favorite Microchip part in the review. It brought in the lowest-power performance of every 32-bit part tested. Unfortunately, it was also the least-efficient 32-bit part tested in terms of math performance (well, excluding the couldn’t-care-less-about-power <a href="https://jaycarlson.net/pf/nuvoton-m051/">Nuvoton M051</a>), and it’s pretty spartan on peripherals — it doesn’t even have a hardware I2C controller.</p><p>But PIC32MM parts have good flash / RAM density, and have simpler clocking / peripheral gating configurations than some of the more-flexible Arm parts, which makes them feel easier to program at a register level.</p><p>Plus, they have a lot of headroom: I think the high-end PIC32MZ DA devices have a home among small industrial dev shops that need Linux-like HMI functionality but don’t have the resources to bring a product like that to market.</p><p>The usual Microchip gotchas apply: clunky IDE, expensive compilers, and expensive debuggers.</p><p>The usual Microchip advantages apply: huge online community, seemingly infinite product lifetime guarantees, and DIP, SOIC, QFP, and QFN package availability.</p><h4>Renesas RL-78: An agile, low-power, easy-to-use 16-bit part you really ought to try</h4><p>I had never picked up a Renesas part before, and when I went shopping for dev kits and stumbled on only a smattering of expensive, traditional systems, I was a little anxious. But I found the <a href="https://www.digikey.com/product-detail/en/YRPBRL78L1A/YRPBRL78L1A-ND/6605483?curr=usd&amp;WT.z_cid=ref_octopart_dkc_buynow&amp;site=us">$25 RL78L1A Promotion Board</a>, gave it a shot, and really enjoyed it.</p><p>The <a href="https://jaycarlson.net/pf/renesas-rl-78/">RL-78</a> is a snappy architecture that competes with Arm parts in math performance, yet it’s also relatively inexpensive — especially compared to the <a href="https://jaycarlson.net/pf/texas-instruments-msp430fr/">MSP430</a> and <a href="https://jaycarlson.net/pf/microchip-pic24/">PIC24</a>. It can’t quite hit the MSP430 sleep-mode power consumption figures, but it gets close — and is, by far, the most power-efficient 5V-capable part in the review.</p><p>The code generator tool produces readable yet efficient code, and the IDE, e2studio, is Eclipse-based — and is getting Linux and macOS support in the next release.</p><p>I’d complain about the dev board, but the new <a href="https://www.renesas.com/en-us/products/software-tools/boards-and-kits/renesas-promotion-boards/yrpbrl78g13-for-rl78-g13.html">YRPBRL78G13 RL78/G13 development kit</a> should remedy basically all my complains with it — I can’t wait for U.S. distributors to start carrying these. They could use a more active community and more people publishing code online, but I hope this article will help inspire some remedies for that.</p><h4>N76, HT66, and STM8: Low-cost parts with a smattering of development headaches</h4><p>The <a href="https://jaycarlson.net/pf/st-stm8/">STM8</a> is probably the nicest of the “cheapie” parts. It has nice peripherals and really good performance for an 8-bit part running at its frequency, but I think the entry-level <a href="https://lcsc.com/product-detail/ST-Microelectronics_STMicroelectronics_STM8S103F2P6TR_STM8S103F2P6TR_C8242.html">38-cent STM8S103F2P6</a> is a more compelling part than the higher-end one reviewed here — simply because of its ultra-low price. The part I reviewed here looks a lot like the other 8-bit microcontrollers — but with an ancient-looking IDE that’s not nearly as productive as the competition. And almost everything out there has better power consumption figures.</p><p>Still, this part is relatively cheap to get going (ahoy, $5 ST-Link clones), and the IDE and toolchain are completely free. But in that regard, you get what you pay for: STVD feels trapped in 2002, and there’s no way to set up a more modern development and debugging environment for it <sup id="footnote_plugin_tooltip_15" onclick="footnote_moveToAnchor(&#39;footnote_plugin_reference_15&#39;);">15</sup><span id="footnote_plugin_tooltip_text_15">Though, there’s some emerging SDCC / GDB support for pairing it with an ST-Link in an open-source fashion, which might help it make inroads with the classic tinyAVR and megaAVR users</span>.</p><p>You’ll be forking over quite a bit of money for a Keil C51 license to develop for the <a href="https://jaycarlson.net/pf/nuvoton-n76/">N76</a> — all for a part that doesn’t look much different than some entry-level EFM8s that have a day-and-night difference in ease of development. Still, at <a href="https://lcsc.com/product-detail/NUVOTON_N76E003AT20_C82751.html">23 cents per unit</a>, it’s tough to beat for volume applications — and hobbyists and hackers can probably get by with the 2K code limit of Keil’s evaluation version. SDCC users need not apply: there’s no stand-alone tools for loading code into this part, and I doubt µVision can be coaxed into loading an SDCC-compiled hex file.</p><p>The <a href="https://jaycarlson.net/pf/holtek-ht-66/">Holtek HT-66</a> has terrible processing performance, but barely uses any run-mode current — there’s plenty of application-specific models to choose from, and while the IDE is goofy, I found it to be fairly productive — and it’s completely free. Careful, though: only the more-expensive “V” parts have on-chip debugging.</p><h4>STC8: A neat performance-heavy part for hacking — but probably not for serious, professional work</h4><p>I think every hacker and advanced hobbyist really ought to throw $10 at AliExpress/Taobao and get some STC15 and <a href="https://jaycarlson.net/pf/stcmicro-stc8/">STC8</a> parts — just for fun.</p><p>Both are jam-packed full of peripherals and memory (more than every other part reviewed), and the STC8 is also <em>really </em>fast. There are some interesting projects you can do with a part that hits your C interrupt code 10 clock cycles after an interrupt occurs — that’s 320 nanoseconds. Both these parts support debugging over UART, so there’s no proprietary debugger to purchase.</p><p>I wouldn’t seriously consider using these parts in U.S-based commercial work, as we have no access to STC inventory here, but the part is just plain fun to play with.</p><h4>ON Semiconductor LC-87: Skip</h4><p>You can probably skip over the <a href="https://jaycarlson.net/pf/sanyo-on-semiconductor-lc87/">ON Semiconductor LC87</a>. This is a rare part outside the Japanese market, and it looks like it’s on its way out the door. I called Altium to try to get an evaluation version of the Tasking LC87 toolset, and the person I talked to had never heard of the LC87 before, and was almost positive they hadn’t made a compiler for it for at least three years. This part has terrible power consumption, few peripherals, and the worst development environment I saw in this review. Skip.</p><h4>Kinetis KL03: Sleep-mode specialist not for beginners</h4><p>While the <a href="https://jaycarlson.net/pf/freescale-nxp-kinetis-kl03/">Kinetis KL03</a> has excellent deep-sleep current and ultra-tiny CSP package availability, it definitely feels like a specialized part not useful for the applications I evaluated. It has far fewer peripherals than the other parts reviewed, and despite NXP’s low-power claims, was consistently in the middle of my Arm rankings for the DMX-512 receiver test — though it nearly matches the <a href="https://jaycarlson.net/pf/atmel-microchip-sam-d10/">SAM D10</a> in full-speed active mode.</p><p>Kinetis SDK is awkward to use, and the dev boards are terrible — requiring a lot of reverse-engineering and hacking to get the board doing anything other than running pre-written demos (especially if you’re interested in measuring power consumption). Still, MCUXpresso is a productive, modern Eclipse-based IDE, and the KL03 has some of the lowest-leakage power modes out there, which means you can get 8-bit-like performance when you’re running an RTC or interrupt wake-up project from a coin-cell battery.</p><h4>Kinetis KE04: Decent peripheral assortment with a powerful — yet clunky — code gen tool</h4><p>The <a href="https://jaycarlson.net/pf/freescale-nxp-ke04/">Kinetis KE04</a> had pretty heavy power consumption in my testing — but this was largely due to the heavy-handed Processor Expert code that Kinetis Design Studio generated. This environment is really suited to much larger, faster microcontrollers running RTOSes and not needing especially good low-level I/O performance.</p><p>But, hey, if you don’t really care about performance, the nice thing about Processor Expert is it abstracts the peripherals to such a high level that you’ll never need to crack open a datasheet for the part if you’re using the peripherals in normal configurations.</p><p>Plus, the KE04 (and KE02) are 5V-compatible parts, and they’re available in old-school, easy-to-solder 1.27mm SOIC and 0.8mm packages — so I could imagine hobbyists would find this part useful.</p><h4>LPC811: Few perks, and less interesting than the LPC810</h4><p>The LPC810 drew people in with its odd, 8-pin DIP form-factor. That chip has since been discontinued, but the LPC81x line remains. The <a href="https://jaycarlson.net/pf/nxp-lpc811/">LPC811</a> reviewed here is sparse on peripherals — not even having an ADC — and brought in poor performance. There’s really nothing that this part does that you can’t get from one of the other vendors; but don’t discredit NXP completely — their higher-end offerings have some interesting capabilities (like dual-core Cortex-M4/M0 designs), and their development environment, MCUXpresso, is an inoffensive Eclipse system.</p><h4>PSoC 4000S &amp; MSP430: Bottom-of-the-barrel parts that offer a glimpse into nice ecosystems</h4><p>I hesitated to review the <a href="https://jaycarlson.net/pf/cypress-psoc-4000s/">PSoC</a> and <a href="https://jaycarlson.net/pf/texas-instruments-msp430fr/">MSP430</a> because they tend to be relatively expensive parts, so in a $1 shoot-out, you end up with bottom-end parts that don’t look nearly as useful as their higher-cost relatives. If you really want to get a feel for what the MSP430 or PSoC parts can do, I recommend buying into a higher-end part — preferably on one of the excellent dev boards that these manufacturers make.</p><p>PSoC Creator and the reconfigurable digital and analog blocks in the PSoC line draw many professional and hobbyist users into the architecture — but instead of grabbing the 4000S from this review, reach for a PSoC5 (or soon-to-launch PSoC6) dev board to get a feel for the platform.</p><p>Same with the MSP430. In the DMX-512 test, it dominated in power consumption, but barely put up marks in any other category (this is especially challenging when you have no hardware multiplier, and only a smattering of peripherals).</p><p>Still, the part has a solid development ecosystem with Code Composer Studio and a choice between the proprietary (but now free) TI compiler, and the open-source GCC one. Plus, hobbyists will love the easy Arduino migration path (with Code Composer Studio directly supporting Energia *.ino sketch projects) and $10 dev boards.</p><p>And really, everyone starting a battery-based product needs to go buy an MSP430 Launch Pad and play around with it — these really are amazing parts that still have a lot of relevance in 2017.</p><h4>Nuvoton M051: Ecosystem issues stifle a performance-packed part</h4><p>The <a href="https://jaycarlson.net/pf/nuvoton-m051/">Nuvoton M051</a> — one of the most-endowed parts reviewed — suffers ecosystem issues that Nuvoton could easily remedy in the future, so I’ll reserve judgment. There’s no manufacturer-provided Eclipse-based IDE — instead, the only IDE options are CooCox, and Keil µVision — neither of which I’m particularly fond of.</p><p>I was able to get CooCox working (though the peripheral libraries that are in the CooCox repo are old and full of bugs). The M0 had some of the worst power-consumption figures in the review, but it makes up for that with tons of communications peripherals, beautiful 32-bit control-friendly timers, and easily-digestible runtime libraries and documentation that are far easier to use than other vendors’. When Nuvoton fixes the IDE absence, I’ll definitely move this part from the “meh” to “yeah” column — since it accomplishes all of these feats while remaining one of the lowest-cost Arm microcontrollers out there.</p></div><p>I had a ton of fun playing with all these different parts for the last few months for this microcontroller review, and in many ways, came away thinking what I already knew: there is no perfect microcontroller — no magic bullet that will please all users. What I <em>did </em>learn, however, is it’s getting easier and easier to pick up a new architecture you’ve never used before, and there have never been more exciting ecosystems to choose from.</p><p>And that’s what I want people to think about as they walk away from this microcontroller review. If you’re an Arduino hobbyist looking where to go next, I hope you realize there are a ton of great, easy-to-use choices. And for professional developers and hardcore hackers, perhaps there’s an odd-ball architecture you’ve noticed before, but never quite felt like plunging into — now’s the time.</p><p>It’s an exciting time to be involved with electronics — whatever parts you choose to pick up, I hope you’ve enjoyed learning about what’s out there, and can get inspired to go build something great. Definitely leave a note in the comments below if you’ve got something to contribute to the discussion!</p></div>
  </body>
</html>
