<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/annotating-my-early-code-from-a-robot/">Original</a>
    <h1>I found some of my first code! Annotating and reflecting on robotics code from 2009.</h1>
    
    <div id="readability-page-1" class="page"><div><p>In high school, one of my teachers shattered my plans for my life, in the most beautiful way.
Most of my life, I&#39;d intended to become a math professional of some sort: a math teacher, when that was all I saw math for; an actuary, when I started to learn more; and then a mathematician.
I knew that to get a math degree, I&#39;d probably have to take computer science, so I signed up for a programming class in high school.
If I wanted to be a mathematician, that was a mistake, because it got me hooked.</p>
<p>The first programming classes were good, but didn&#39;t change the course of my life: I still saw them as a useful tool.
But our programming teacher started a <a href="https://en.wikipedia.org/wiki/FIRST_Robotics_Competition">FIRST Robotics Competition</a> team with us.
And that ended up sending my life on a different course.
The magic of writing code that controlled a moving actual thing?
Yeah, that pushed me toward where I am today.</p>
<p>Recently, I found the code from our second season in 2009.
Let&#39;s take a look at what the game was and what made our robot special.
Then we&#39;ll go through the code, and I&#39;ll reflect on things at the end.</p>

<p>The game for the 2009 season of <a href="https://en.wikipedia.org/wiki/FIRST_Robotics_Competition">FRC</a> was called <a href="https://en.wikipedia.org/wiki/Lunacy_(FIRST)">Lunacy</a>.
The core thing for that competition was that each robot had a trailer you were trying to score balls into, and the playing surface and wheels were both regulated to be a low coefficient of friction, similar to playing on the moon.</p>
<p>We went through a few iterations of designs to come up with the robot we had.
It was a monstrosity of PVC and other big box hardware store items, because we did not have access to the kinds of machine shops or fabrication many other teams did, and that many teams do today.
It worked out and looking back, I&#39;d best describe us as scrappy.</p>
<p>The robot we ended up with had three key design features:</p>
<ul>
<li>An opening at the ground level to allow balls to enter, where they&#39;d be pulled up a sort of shaft via a moving belt; this was how we got them loaded to shoot</li>
<li>A hopper and firing chamber where we could use a piston to launch a ball at a particular distance</li>
<li>A traction control system to allow smoother operation on the surface</li>
</ul>
<p>The hopper and firing chamber were something we had to go through the most iterations on to get them reliable, and they ended up failing at the last moment: before our elimination rounds, a valve on the pneumatic piston sheared off, resulting in our robot being largely disabled during those rounds.
But before then, the fact that we made the piston adjustable (something we did not see in general, probably because it&#39;s not recommended!) made for a repeatable and mostly reliable firing mechanism.</p>
<p>The traction control system is something we thought of when we realized how hard it would be to drive on the surface and control the robot.
A simple test showed us that control was very challenging indeed, and so we went about figuring out how to implement traction control.
It&#39;s simple applied physics at the end of the day: calculate how fast you are allowed to accelerate, and calculate your wheels&#39; acceleration, and don&#39;t let those two meet!</p>
<p>We had the only robot in our regional competitions that had traction control and adjustable pneumatics, as far as we know.
These allowed our scrappy robot to <em>place third</em> in the qualifying rounds.
Unfortunately, we were knocked out in the first round of elimination due to that hardware failure, but we did very well especially given our resources.</p>

<p>Let&#39;s take a look at the code.
I&#39;m not going to take a particularly harsh eye or apply today&#39;s standards, because 2009 (and high school) was a very different time.</p>
<p>It starts with importing <a href="https://wpilib.org/blog/2023-kickoff-release-of-wpilib">WPILib</a>.
This was new to us.
The hardware in the kit of parts had changed for the 2009 season, so while we used <a href="https://www.robotc.net/">robotC</a> in 2008, we had to change for 2009.
We opted to use C++ instead of LabVIEW, since we couldn&#39;t wrap our heads around visual programming.
I still don&#39;t get LabVIEW.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"></code></pre>
<p>Yup, just an import.</p>
<p>Now we have this giant comment block.
It&#39;s actually not too bad as far as opening comment blocks go, though it probably should be <em>before</em> the import to be a proper header comment.
I really like that it has sincere thanks for people, though I&#39;m amused that I was <em>so proud</em> of the traction control that I put credit for <em>that specifically</em>.
A few funny things here after we read through it.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>3</td><td>/*
</td></tr><tr><td>4</td><td>Credit due to:
</td></tr><tr><td>5</td><td> TEAM HORNET: 2603
</td></tr><tr><td>6</td><td> (&lt;REDACTED-WEBSITE&gt;)
</td></tr><tr><td>7</td><td>
</td></tr><tr><td>8</td><td>Traction control:
</td></tr><tr><td>9</td><td> Implemented by Nicole Tietz
</td></tr><tr><td>10</td><td> (&lt;REDACTED-EMAIL&gt;)
</td></tr><tr><td>11</td><td>
</td></tr><tr><td>12</td><td>Thanks to:
</td></tr><tr><td>13</td><td> All members and mentors of 2603
</td></tr><tr><td>14</td><td> All members of the CD community
</td></tr><tr><td>15</td><td> Mr. Mxxxxx: teacher, coach, and mentor.
</td></tr><tr><td>16</td><td> Mr. Kxxxxx: teacher, mentor. He checked my calculations
</td></tr><tr><td>17</td><td>
</td></tr><tr><td>18</td><td>Todo:
</td></tr><tr><td>19</td><td> Autonomous code
</td></tr><tr><td>20</td><td>
</td></tr><tr><td>21</td><td>Known bugs:
</td></tr><tr><td>22</td><td> Distance per tick is wrong; it should use 0.1524*pi*(15/22), I forgot to put the pi in. Oddly enough, it works wonderfully.
</td></tr><tr><td>23</td><td>
</td></tr><tr><td>24</td><td>Questions/comments:
</td></tr><tr><td>25</td><td> Please forward to &lt;REDACTED-EMAIL&gt;
</td></tr><tr><td>26</td><td> I would be glad to hear about it if my code can help anyone. (Or if you find some errors.)
</td></tr><tr><td>27</td><td>
</td></tr><tr><td>28</td><td>Anyone is welcome to use this code, but please give due credit.
</td></tr><tr><td>29</td><td>
</td></tr><tr><td>30</td><td> &#34;Mind, Metal, Machine.&#34; 2603.
</td></tr><tr><td>31</td><td>*/
</td></tr><tr><td>32</td><td>
</td></tr></tbody></table></code></pre>
<p>One funny thing is this comment block was apparently my issue tracker.
That&#39;s where I listed a TODO, and we never did get our autonomous mode working.
That&#39;s also our bug tracker, but I... it&#39;s a weird thing, because the code &#34;worked&#34; but it&#39;s listed as a bug, because we were not sure <em>why</em> it worked.
That&#39;s not great!
And we&#39;ll be coming back to that.</p>
<p>I also didn&#39;t understand licenses, so we just said &#34;feel free to use it!&#34; without any proper license.
The intention was something like MIT or BSD, but it wasn&#39;t licensed properly.
Ending with our team motto is just... amusing, since I didn&#39;t even remember it was a thing; clearly not very memorable.</p>
<p>Now we come to the first real code.
A <a href="https://en.wikipedia.org/wiki/Incremental_encoder">rotary encoder</a> is a sort of sensor we used which detects rotation.
Specifically, we used a quadrature encoder which also tells you how fast the thing is turning.
And we wanted to have some kind of wrapper around the class given to us, so we made that.
The first chunk gives us some fields, and is &#34;commented.&#34;</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>33</td><td>class AugmentedEncoder {
</td></tr><tr><td>34</td><td>//augments the functionality of an encoder
</td></tr><tr><td>35</td><td>    Encoder *encoder;
</td></tr><tr><td>36</td><td>    Timer *timer;
</td></tr><tr><td>37</td><td>    float acceleration;
</td></tr><tr><td>38</td><td>    float velocity;
</td></tr><tr><td>39</td><td>    float delta_v; //change in velocity
</td></tr><tr><td>40</td><td>    float delta_d; //change in distance
</td></tr><tr><td>41</td><td>    float delta_t; //change in time
</td></tr><tr><td>42</td><td>    float distance_per_tick; //distance per tick of the encoder
</td></tr></tbody></table></code></pre>
<p>The comments are all, uh, not necessary and should be removed.
Most comments in this code are of that flavor, since I knew I <em>should</em> have comments but not what they should be like.
As for fields, we have pointers to an encoder and to a timer, and then some floats to measure velocity, change in velocity, change in distance, change in time, and how far one tick of the encoder indicates we&#39;ve moved.
Pretty sure those did not need to be pointers, but we will see.</p>
<p>One major change that should have been made here: tell us <strong>what</strong> the class is adding to the encoder!
The fields gave us our first clue, and the actual thing we&#39;re getting is calculation of velocity and acceleration from changes in our position.
Pretty neat, and having those is foundational for our traction control.</p>
<p>Now we have the public methods.
The first one is our constructor, a term I did not know at the time.
It initializes our fields, passing through 3 of the 4 parameters directly to the wrapped class.
The channels are where to read from in the hardware, and reverse is for which direction it&#39;s going so we can use outputs without negating them.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>43</td><td>public:
</td></tr><tr><td>44</td><td>    AugmentedEncoder(int a_channel, int b_channel, float d_p_t, bool reverse = false) {
</td></tr><tr><td>45</td><td>    //initializer for the AugmentedEncoder class
</td></tr><tr><td>46</td><td>        encoder = new Encoder(a_channel, b_channel, reverse);
</td></tr><tr><td>47</td><td>        timer = new Timer();
</td></tr><tr><td>48</td><td>        velocity = 0;
</td></tr><tr><td>49</td><td>        acceleration = 0;
</td></tr><tr><td>50</td><td>        distance_per_tick = d_p_t;
</td></tr><tr><td>51</td><td>    } //end AugmentedEncoder(...)
</td></tr><tr><td>52</td><td>
</td></tr></tbody></table></code></pre>
<p>Next up we have this beauty of a method which is never called.
It passes through and starts the underlying object.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>53</td><td>    void Start() {
</td></tr><tr><td>54</td><td>    //starts the encoder and timer
</td></tr><tr><td>55</td><td>        encoder-&gt;Start();
</td></tr><tr><td>56</td><td>        timer-&gt;Start();
</td></tr><tr><td>57</td><td>    }
</td></tr></tbody></table></code></pre>
<p>Curious that we never call <code>Start</code> on these things, huh?
Well it turns out that later we use <code>Reset</code> which does double duty and starts it if it isn&#39;t started, so this just kind of hung out as code I was afraid to delete.</p>
<p>Now we get to the meat of this class: our <code>Recalculate</code> method.
This is where the <del>magic</del> math happens.
In this aptly named method, we recalculate all of our tracked values.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>58</td><td>    void Recalculate() {
</td></tr><tr><td>59</td><td>    //calculates changes of distance, velocity, and time, as well as absolute velocity and acceleration.
</td></tr><tr><td>60</td><td>        delta_t = timer-&gt;Get(); //time elapsed since last recalculation
</td></tr><tr><td>61</td><td>            timer-&gt;Reset(); //resets the time elapsed
</td></tr><tr><td>62</td><td>        delta_d = encoder-&gt;Get() * distance_per_tick / 4; //quadrature gives 4 times resolution but requires division by 4
</td></tr><tr><td>63</td><td>            encoder-&gt;Reset(); //resets the ticks for the encoder
</td></tr><tr><td>64</td><td>        delta_v = delta_d / delta_t - velocity; //delta_d / delta_t is current velocity
</td></tr><tr><td>65</td><td>        velocity += delta_v; //current velocity is now set to old velocity plus the change
</td></tr><tr><td>66</td><td>        acceleration = delta_v / delta_t; //acceleration is rate of change of velocity
</td></tr><tr><td>67</td><td>    }
</td></tr></tbody></table></code></pre>
<p>So we have just position from the encoder, right?
We can use the change in position to get figure out our approximate velocity.
And the change in velocity gives us the acceleration!</p>
<p>And, yes, the spacing was that bad.
And this is after I&#39;ve corrected the mixing of spaces and tabs...</p>
<p>The rest of the class straightforward, just another unused method and two getter functions.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>68</td><td>    void Reset() {
</td></tr><tr><td>69</td><td>    //resets the augmented encoder
</td></tr><tr><td>70</td><td>        velocity = acceleration = 0.0;
</td></tr><tr><td>71</td><td>        timer-&gt;Reset();
</td></tr><tr><td>72</td><td>        encoder-&gt;Reset();
</td></tr><tr><td>73</td><td>    }
</td></tr><tr><td>74</td><td>    float GetAcceleration()
</td></tr><tr><td>75</td><td>    {
</td></tr><tr><td>76</td><td>        return acceleration; //returns a private member
</td></tr><tr><td>77</td><td>    }
</td></tr><tr><td>78</td><td>    float GetVelocity()
</td></tr><tr><td>79</td><td>    {
</td></tr><tr><td>80</td><td>        return velocity; //returns a private member
</td></tr><tr><td>81</td><td>    }
</td></tr><tr><td>82</td><td>};
</td></tr><tr><td>83</td><td>
</td></tr></tbody></table></code></pre>
<p>To recap, so far we&#39;ve seen monstrous comments and we&#39;ve seen a wrapper around <code>Encoder</code> which will take the outputs and approximate velocity and acceleration for us.
Now we get to move on to the robot itself!</p>
<p>Our base class is <code>IterativeRobot</code> which gives us the main control loop and then we can override hooks into it, which get run periodically.
Our robot was named <code>Sting</code>, because we were the Hornets, so we named the class <code>Sting</code>.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>84</td><td>class Sting : public IterativeRobot
</td></tr><tr><td>85</td><td>{
</td></tr></tbody></table></code></pre>
<p>We start off with our fields again.
<code>robot_drive</code> will let us control our left/right drivetrains, and <code>driver_station</code> is what our joystick is mounted to that we can read remote inputs from.
Since we get remote input, we can see which number the packet is, and we used this to perform actions uniquely per packet received.
<code>packets_in_second</code> is only set and never read, so I think it was from debugging something.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>86</td><td>    RobotDrive *robot_drive;
</td></tr><tr><td>87</td><td>
</td></tr><tr><td>88</td><td>    DriverStation *driver_station;
</td></tr><tr><td>89</td><td>    UINT32 prior_packet_number;
</td></tr><tr><td>90</td><td>    UINT8 packets_in_second;
</td></tr><tr><td>91</td><td>
</td></tr></tbody></table></code></pre>
<p>Now we have a bunch of constants.
We have <code>G</code> since we later compute things based on the friction force between the wheels and the surface.
We also have how many ticks we get per revolution—this is the resolution of our encoders, so we can use that to figure out distance.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>92</td><td>    static const float G = 9.806605; //meters per second squared
</td></tr><tr><td>93</td><td>    static const float ticks_per_rev = 250;
</td></tr></tbody></table></code></pre>
<p>We come back to the infamous &#34;bug&#34;!
This is where I, future math degree-haver, forgot to include <code>pi</code> in our calculation!
I think the reason it ended up working out is because some of the other calculations are sloppy in a compensatory way.
We also have our coefficient of friction (measured experimentally, in fact!) and we have our adjustment constant which is used to ramp speed up or down gently.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>94</td><td>    static const float distance_per_rev = 0.1524 * (15/22); //6&#34; in meters times 15/22 gear ratio
</td></tr><tr><td>95</td><td>    static const float mu = 0.05; //coefficient of friction between wheels and regolith
</td></tr><tr><td>96</td><td>    static const float adjustment = 0.05; //coefficient for adjustment of the current wheel speed to match expected acceleration
</td></tr><tr><td>97</td><td>
</td></tr></tbody></table></code></pre>
<p>Just declaring a bunch of fields now. Joysticks, encoders, motor controller, piston, compressor...</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>98</td><td>    Joystick *left_stick;
</td></tr><tr><td>99</td><td>    Joystick *right_stick;
</td></tr><tr><td>100</td><td>
</td></tr><tr><td>101</td><td>    AugmentedEncoder *left_encoder;
</td></tr><tr><td>102</td><td>    AugmentedEncoder *right_encoder;
</td></tr><tr><td>103</td><td>
</td></tr><tr><td>104</td><td>    Jaguar *shooter;
</td></tr><tr><td>105</td><td>
</td></tr><tr><td>106</td><td>    Solenoid *piston;
</td></tr><tr><td>107</td><td>
</td></tr><tr><td>108</td><td>    Relay *compressor;
</td></tr><tr><td>109</td><td>
</td></tr></tbody></table></code></pre>
<p>An inline struct for some grouped fields about our drivetrain!
The struct is a nice idea, and can&#39;t blame a girl for the inline aspect, I was new and it&#39;s fine.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>110</td><td>    struct {
</td></tr><tr><td>111</td><td>    //describes left and right drive trains
</td></tr><tr><td>112</td><td>        float speed; //current speed
</td></tr><tr><td>113</td><td>        float adjust; //how much to adjust current speed
</td></tr><tr><td>114</td><td>    }left, right;
</td></tr><tr><td>115</td><td>
</td></tr></tbody></table></code></pre>
<p>A ratio for how far to shoot the piston, and an unused variable <code>ratio</code>.
This code has a <em>lot</em> of unused variables.
Probably a side effect of not using version control!</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>116</td><td>    float shoot;
</td></tr><tr><td>117</td><td>    float ratio;
</td></tr><tr><td>118</td><td>
</td></tr></tbody></table></code></pre>
<p>Now some constants for how many buttons or solenoid controls exist, and then creating our controls for those.
The <code>+1</code> is probably because I didn&#39;t understand that things were 0-indexed, and we didn&#39;t use the first or last to run into that.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>119</td><td>    static const int NUM_JOYSTICK_BUTTONS = 16;
</td></tr><tr><td>120</td><td>    bool left_stick_button_state[(NUM_JOYSTICK_BUTTONS+1)];
</td></tr><tr><td>121</td><td>    bool right_stick_button_state[(NUM_JOYSTICK_BUTTONS+1)];
</td></tr><tr><td>122</td><td>
</td></tr><tr><td>123</td><td>    static const int NUM_SOLENOIDS = 8;
</td></tr><tr><td>124</td><td>    Solenoid *solenoid[(NUM_SOLENOIDS+1)];
</td></tr><tr><td>125</td><td>
</td></tr></tbody></table></code></pre>
<p>Some more tracking of info for timing purposes.
We use these to fire events on particular frequencies.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>126</td><td>    UINT32 auto_periodic_loops;
</td></tr><tr><td>127</td><td>    UINT32 disabled_periodic_loops;
</td></tr><tr><td>128</td><td>    UINT32 teleop_periodic_loops;
</td></tr><tr><td>129</td><td>
</td></tr></tbody></table></code></pre>
<p>Now we just initialize our fields.
The constructor isn&#39;t particularly interesting, although I did comment that I was amused <code>0.0</code> looks like a face.
This comment <em>is</em> a good comment, and you should always comment about things that make you happy.
The rest of the comments here are just kind of lacking, they&#39;re shorthand notes for my past self that were not useful even then.
The most notable thing here might be that on lines 145 and 146 we divide the (incorrect) distance-per-revolution by the number of ticks to get the distance per tick, for computing position, velocity, and acceleration.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>130</td><td>public:
</td></tr><tr><td>131</td><td>
</td></tr><tr><td>132</td><td>    Sting() {
</td></tr><tr><td>133</td><td>
</td></tr><tr><td>134</td><td>        robot_drive = new RobotDrive(1,2); // use -&gt;SetLeftRightMotorSpeeds(float left, float right);
</td></tr><tr><td>135</td><td>
</td></tr><tr><td>136</td><td>        driver_station = DriverStation::GetInstance();
</td></tr><tr><td>137</td><td>        prior_packet_number = 0;
</td></tr><tr><td>138</td><td>        packets_in_second = 0;
</td></tr><tr><td>139</td><td>
</td></tr><tr><td>140</td><td>        left_stick = new Joystick(1);
</td></tr><tr><td>141</td><td>        right_stick= new Joystick(2);
</td></tr><tr><td>142</td><td>
</td></tr><tr><td>143</td><td>        left.speed = left.adjust = right.speed = right.adjust = 0.0;
</td></tr><tr><td>144</td><td>
</td></tr><tr><td>145</td><td>        left_encoder = new AugmentedEncoder(1,2,distance_per_rev / ticks_per_rev);
</td></tr><tr><td>146</td><td>        right_encoder = new AugmentedEncoder(3,4,distance_per_rev / ticks_per_rev, true);
</td></tr><tr><td>147</td><td>
</td></tr><tr><td>148</td><td>        shoot = 0.0; //sorry, this looks like a smiley. I just had to comment.
</td></tr><tr><td>149</td><td>
</td></tr><tr><td>150</td><td>        shooter = new Jaguar(3);
</td></tr><tr><td>151</td><td>        piston = new Solenoid(1); //piston solenoid is wired into the first output on the relay module
</td></tr><tr><td>152</td><td>        compressor = new Relay(5); //in d_io 5
</td></tr><tr><td>153</td><td>
</td></tr><tr><td>154</td><td>        UINT8 button_number = 0;
</td></tr><tr><td>155</td><td>        for (button_number = 0; button_number &lt; NUM_JOYSTICK_BUTTONS; button_number++) {
</td></tr><tr><td>156</td><td>            left_stick_button_state[button_number] = false;
</td></tr><tr><td>157</td><td>            right_stick_button_state[button_number] = false;
</td></tr><tr><td>158</td><td>        }
</td></tr><tr><td>159</td><td>
</td></tr><tr><td>160</td><td>        UINT8 solenoid_number = 1;
</td></tr><tr><td>161</td><td>        for (solenoid_number = 1; solenoid_number &lt;= NUM_SOLENOIDS; solenoid_number++) {
</td></tr><tr><td>162</td><td>            solenoid[solenoid_number] = new Solenoid(solenoid_number);
</td></tr><tr><td>163</td><td>        }
</td></tr><tr><td>164</td><td>
</td></tr><tr><td>165</td><td>        auto_periodic_loops = 0;
</td></tr><tr><td>166</td><td>        disabled_periodic_loops = 0;
</td></tr><tr><td>167</td><td>        teleop_periodic_loops = 0;
</td></tr><tr><td>168</td><td>    }
</td></tr><tr><td>169</td><td>
</td></tr></tbody></table></code></pre>
<p>Initializing the robot when it boots, all we need to do is turn on the compressor for our pneumatics.
Everything else was handled in the constructor.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>170</td><td>    void RobotInit(void) {
</td></tr><tr><td>171</td><td>        compressor-&gt;Set(Relay::kOn);
</td></tr><tr><td>172</td><td>    }
</td></tr><tr><td>173</td><td>
</td></tr></tbody></table></code></pre>
<p>There are the three modes for our robot: disabled, autonomous, and teleop.
Each has three functions (init, periodic, and continuous) that are called when going into that mode, periodically, or you can do your own continuous flow.
We just used periodic to simplify our lives.</p>
<p>In disabled mode, all we do is disable the compressor and feed the watchdog so our robot is known to be responsive.
I think if we didn&#39;t do that, the field or driver station would disconnect it, or the robot itself shuts down for safety reasons.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>174</td><td>    void DisabledInit(void) {
</td></tr><tr><td>175</td><td>        disabled_periodic_loops = 0;
</td></tr><tr><td>176</td><td>        compressor-&gt;Set(Relay::kOff);
</td></tr><tr><td>177</td><td>    }
</td></tr><tr><td>178</td><td>    void DisabledPeriodic(void)  {
</td></tr><tr><td>179</td><td>        GetWatchdog().Feed();
</td></tr><tr><td>180</td><td>        disabled_periodic_loops++;
</td></tr><tr><td>181</td><td>    }
</td></tr><tr><td>182</td><td>    void DisabledContinuous(void) {
</td></tr><tr><td>183</td><td>    }
</td></tr><tr><td>184</td><td>
</td></tr></tbody></table></code></pre>
<p>The comment at the beginning was not wrong: we had no autonomous mode.
The game in the 2009 season wasn&#39;t one where our team was particularly equipped to do anything useful autonomously.
We would have needed to use sensors more effectively, which we didn&#39;t.
The one idea we had was attempt to pin another team&#39;s robot in autonomous mode, but we ran out of time to try it and we had no other robot to attempt to pin in testing.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>185</td><td>    void AutonomousInit(void) {
</td></tr><tr><td>186</td><td>        auto_periodic_loops = 0;
</td></tr><tr><td>187</td><td>        compressor-&gt;Set(Relay::kOn);
</td></tr><tr><td>188</td><td>    }
</td></tr><tr><td>189</td><td>    void AutonomousPeriodic(void) {
</td></tr><tr><td>190</td><td>        // feed the user watchdog at every period when in autonomous
</td></tr><tr><td>191</td><td>        GetWatchdog().Feed();
</td></tr><tr><td>192</td><td>        auto_periodic_loops++;
</td></tr><tr><td>193</td><td>
</td></tr><tr><td>194</td><td>        if (auto_periodic_loops == 1) {
</td></tr><tr><td>195</td><td>            //start doing something
</td></tr><tr><td>196</td><td>        }
</td></tr><tr><td>197</td><td>        if (auto_periodic_loops == (2 * GetLoopsPerSec())) {
</td></tr><tr><td>198</td><td>            //do something else after two seconds
</td></tr><tr><td>199</td><td>        }
</td></tr><tr><td>200</td><td>    }
</td></tr><tr><td>201</td><td>    void AutonomousContinuous(void)    {
</td></tr><tr><td>202</td><td>    }
</td></tr><tr><td>203</td><td>
</td></tr></tbody></table></code></pre>
<p>Now we get to the teleop mode code, where we have a lot more fun!
The meat of it is just inside the <code>TeleopPeriodic</code> function; before then we turn on the compressor and reset some variables.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>204</td><td>    void TeleopInit(void) {
</td></tr><tr><td>205</td><td>        teleop_periodic_loops = 0;
</td></tr><tr><td>206</td><td>        packets_in_second = 0;
</td></tr><tr><td>207</td><td>        compressor-&gt;Set(Relay::kOn);
</td></tr><tr><td>208</td><td>    }
</td></tr></tbody></table></code></pre>
<p>This function gets called 200 times a second, so we are able to use that frequency to do things which have to happen on a particular interval.
The motor controllers have particular frequencies you can update them, so more frequent doesn&#39;t really help you any and is wasted work.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>209</td><td>    void TeleopPeriodic(void) {
</td></tr><tr><td>210</td><td>        GetWatchdog().Feed();
</td></tr><tr><td>211</td><td>        teleop_periodic_loops++;
</td></tr><tr><td>212</td><td>        // put 200Hz Jaguar control here
</td></tr><tr><td>213</td><td>
</td></tr><tr><td>214</td><td>        if ((teleop_periodic_loops % 2) == 0) {
</td></tr><tr><td>215</td><td>            // put 100Hz Victor control here
</td></tr><tr><td>216</td><td>            //left_encoder-&gt;Recalculate();
</td></tr><tr><td>217</td><td>            //right_encoder-&gt;Recalculate();
</td></tr><tr><td>218</td><td>        }
</td></tr></tbody></table></code></pre>
<p>And then 50 times a second, we recalculate our position/velocity/acceleration and then invoke the <code>ArcadeDrive</code> function to adjust our motor speeds and be able to, well, drive the robot!
The implementation of <code>ArcadeDrive</code> is below and we&#39;ll see it soon.
Its name refers to the <a href="https://docs.wpilib.org/en/stable/docs/software/hardware-apis/motors/wpi-drive-classes.html#drive-modes">drive mode</a> where you control speed and rotation, in contrast to tank drive which controls speed of each drivetrain independently or curvature drive which is like a car.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>219</td><td>        if ((teleop_periodic_loops % 4) == 0) {
</td></tr><tr><td>220</td><td>            // put 50Hz servo control here
</td></tr><tr><td>221</td><td>            left_encoder-&gt;Recalculate();
</td></tr><tr><td>222</td><td>            right_encoder-&gt;Recalculate();
</td></tr><tr><td>223</td><td>            ArcadeDrive(left_stick-&gt;GetY(), left_stick-&gt;GetX());
</td></tr><tr><td>224</td><td>        }
</td></tr><tr><td>225</td><td>
</td></tr></tbody></table></code></pre>
<p>Now we read from the driver station, but only if we haven&#39;t handled the current packet before!
This lets us avoid setting some of these things multiple times, and doing less work is always good.
I don&#39;t recall if it actually caused us problems if we do, or if this was some optimization.</p>
<p>The main thing here is looking at the button states and reading the trigger and other distance buttons, so you could adjust the strength of the shot based on either a preset button (one of the top 4 buttons on the joystick) or based on the adjustable Z-axis dial. Then after reading those, it triggers the piston to open.</p>
<p>We were using pneumatics in definitely-not-recommended ways here, opening a pneumatic valve with a PWM controller to modulate the strength of it.
This may have ultimately contributed to the connector for the piston shearing off, or that was just our own bad luck and poor engineering (I think there was stress on that connector).
At any rate, it was pretty cool and it&#39;s another thing we didn&#39;t see other regional teams near us doing!</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>226</td><td>        if (driver_station-&gt;GetPacketNumber() != prior_packet_number) {
</td></tr><tr><td>227</td><td>            prior_packet_number = driver_station-&gt;GetPacketNumber();
</td></tr><tr><td>228</td><td>            packets_in_second++;
</td></tr><tr><td>229</td><td>            if (left_stick-&gt;GetTrigger() == true) {
</td></tr><tr><td>230</td><td>                if (left_stick-&gt;GetTop() == true) {
</td></tr><tr><td>231</td><td>                    shoot = 1.0;
</td></tr><tr><td>232</td><td>                } else if (left_stick-&gt;GetRawButton(2)) {
</td></tr><tr><td>233</td><td>                    shoot = 0.70;
</td></tr><tr><td>234</td><td>                } else if (left_stick-&gt;GetRawButton(3)) {
</td></tr><tr><td>235</td><td>                    shoot = 0.50;
</td></tr><tr><td>236</td><td>                } else if (left_stick-&gt;GetRawButton(4)) {
</td></tr><tr><td>237</td><td>                    shoot = 0.40;
</td></tr><tr><td>238</td><td>                } else if (left_stick-&gt;GetZ() &gt; 0) {
</td></tr><tr><td>239</td><td>                    shoot = sq(left_stick-&gt;GetZ());
</td></tr><tr><td>240</td><td>                }
</td></tr><tr><td>241</td><td>            } else {
</td></tr><tr><td>242</td><td>                shoot = 0.0;
</td></tr><tr><td>243</td><td>            }
</td></tr><tr><td>244</td><td>            if (shoot) {
</td></tr><tr><td>245</td><td>                shooter-&gt;Set(shoot);
</td></tr><tr><td>246</td><td>            }
</td></tr><tr><td>247</td><td>            else {
</td></tr><tr><td>248</td><td>                shooter-&gt;Set(0.0);
</td></tr><tr><td>249</td><td>            }
</td></tr><tr><td>250</td><td>            if (right_stick-&gt;GetTop()) {
</td></tr><tr><td>251</td><td>                piston-&gt;Set(true);
</td></tr><tr><td>252</td><td>            } else {
</td></tr><tr><td>253</td><td>                piston-&gt;Set(false);
</td></tr><tr><td>254</td><td>            }
</td></tr><tr><td>255</td><td>        }
</td></tr><tr><td>256</td><td>
</td></tr><tr><td>257</td><td>        if ((teleop_periodic_loops % (UINT32)GetLoopsPerSec()) == 0) {
</td></tr><tr><td>258</td><td>            packets_in_second = 0;
</td></tr><tr><td>259</td><td>        }
</td></tr><tr><td>260</td><td>    }
</td></tr><tr><td>261</td><td>    void TeleopContinuous(void) {
</td></tr><tr><td>262</td><td>    }
</td></tr><tr><td>263</td><td>
</td></tr></tbody></table></code></pre>
<p>Here we have a rather confusing comment: <code>mixes arcade input to be tank input</code>???
I think it&#39;s saying it&#39;s converting from the input to arcade drive and turning it into the inputs that tank drive would expect.
We take in the x/y position of the joystick then combine them to get the expected left and right drivetrain speeds.
Neat.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>264</td><td>    void ArcadeDrive(float y, float x) {
</td></tr><tr><td>265</td><td>        Drive(Limit(y+x), Limit(y-x)); //mixes arcade input to be tank input
</td></tr><tr><td>266</td><td>    }
</td></tr></tbody></table></code></pre>
<p>And here&#39;s what we were looking for!
This is where we control our traction.
We check if our acceleration is faster than what we should have according to our coefficient of friction and, if so, we lower our speed.
Otherwise, we still have room to go, so we can increase it!
A nice improvement be to clamp the increase such that we don&#39;t go over the max acceleration ever; this worked but crosses that threshold often.</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>267</td><td>    void Drive(float suggested_left, float suggested_right) {
</td></tr><tr><td>268</td><td>        ratio = left_encoder-&gt;GetAcceleration() / (mu*G);
</td></tr><tr><td>269</td><td>        if (sq(left_encoder-&gt;GetAcceleration()) &gt; sq(mu*G)) {
</td></tr><tr><td>270</td><td>            left.speed -= adjustment;
</td></tr><tr><td>271</td><td>        }
</td></tr><tr><td>272</td><td>        else {
</td></tr><tr><td>273</td><td>            left.speed += (suggested_left - left.speed)*(adjustment);
</td></tr><tr><td>274</td><td>        }
</td></tr><tr><td>275</td><td>
</td></tr><tr><td>276</td><td>        if (sq(right_encoder-&gt;GetAcceleration()) &gt; sq(mu*G)) {
</td></tr><tr><td>277</td><td>            right.speed -= adjustment;
</td></tr><tr><td>278</td><td>        }
</td></tr><tr><td>279</td><td>        else {
</td></tr><tr><td>280</td><td>            right.speed += (suggested_right - right.speed)*(adjustment);
</td></tr><tr><td>281</td><td>        }
</td></tr><tr><td>282</td><td>        robot_drive-&gt;SetLeftRightMotorSpeeds(left.speed,right.speed);
</td></tr><tr><td>283</td><td>    }
</td></tr></tbody></table></code></pre>
<p>I want to say again I&#39;m not sure why this code worked, because the calculations are wrong, but I think they&#39;re all just wrong in similar ways that cancel each other out.
For example, in the traction control code, we don&#39;t include the mass of the robot! So we&#39;re estimating probably a much lower max acceleration than possible.</p>
<p>I did not know about libraries, nor the clamp function.
I&#39;m pretty certain I did not need to implement <code>sq</code> myself (and also, it was fine).</p>
<pre data-linenos="" data-lang="cpp"><code data-lang="cpp"><table><tbody><tr><td>284</td><td>    float sq(float x)
</td></tr><tr><td>285</td><td>    {
</td></tr><tr><td>286</td><td>        return x*x;
</td></tr><tr><td>287</td><td>    }
</td></tr><tr><td>288</td><td>    float Limit(float x)
</td></tr><tr><td>289</td><td>    {
</td></tr><tr><td>290</td><td>        return (x&gt;1)?1:(x&lt;-1)?-1:x;
</td></tr><tr><td>291</td><td>    }
</td></tr><tr><td>292</td><td>};
</td></tr><tr><td>293</td><td>
</td></tr><tr><td>294</td><td>START_ROBOT_CLASS(Sting);
</td></tr></tbody></table></code></pre>
<p>And that&#39;s it.
294 lines of high school Nicole&#39;s code.
The origin of an engineer.</p>

<p>Reading through this code has been a trip down memory lane for me.
I&#39;m remembering the team members I had, our coach, our mentors.
I&#39;m remembering the fun we had.
I&#39;m remembering the tears we shared when we saw the sheared pneumatics component.</p>
<p>In terms of moments that made me the engineer I am today, I think that this season of FRC ranks as one of the top things that got me there.
It&#39;s not because it taught me a lot directly (though it did), but because it showed me that I can be—that I <em>am</em>—an engineer.</p>
<p>The problem solving we used in the 2009 season was exactly the kind of problem solving that you do as an engineer, or at least that I do as a software engineer.
One of the greatest things we did, I think, is that we figured out what would <em>be difficult for the user</em>, the driver, and added compensatory systems to make the user interface easier.
Traction control really was, for us, a UX improvement more than anything else.</p>
<p>Our robot was far from the most impressive one on the field.
But getting to go through that design process with a team, getting to build it together, getting to struggle together?
Oh yeah, that made me love engineering and made me understand the joys and pains of building things.</p>
<p>I&#39;m not sure that I&#39;d be a software engineer today if not for FRC, if not for the teacher/coach we had who brought it into our school.
Thank you, so much.
You changed my life for the better.</p>
<hr/>




</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts, subscribe to the <a href="https://ntietz.com/newsletter">newsletter</a> or use the <a href="https://ntietz.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
