<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lesleylai.info/en/fifty_shades_of_oop/">Original</a>
    <h1>Fifty Shades of OOP</h1>
    
    <div id="readability-page-1" class="page"><div data-pagefind-body="" data-pagefind-filter="type:Blog Post" data-astro-cid-qd3i4e6s="">  <div data-astro-cid-qd3i4e6s=""> <p><span data-astro-cid-qd3i4e6s=""> <span data-pagefind-meta="created:November 24, 2025" data-astro-cid-qd3i4e6s="">Created: November 24, 2025</span> <span data-astro-cid-qd3i4e6s=""></span> </span> <span data-astro-cid-qd3i4e6s=""> <ul data-astro-cid-lga65v7i="">  <li data-pagefind-filter="tag:Coding" data-astro-cid-lga65v7i=""> <a title="Coding" href="http://tinylogger.com/en/tags/code" data-astro-cid-lga65v7i=""> Coding  </a> </li><li data-pagefind-filter="tag:Object-Oriented Programming" data-astro-cid-lga65v7i=""> <a title="Object-Oriented Programming" href="http://tinylogger.com/en/tags/oop" data-astro-cid-lga65v7i=""> OOP  </a> </li><li data-pagefind-filter="tag:Opinion" data-astro-cid-lga65v7i=""> <a title="Opinion" href="http://tinylogger.com/en/tags/opinion" data-astro-cid-lga65v7i=""> Opinion  </a> </li><li data-pagefind-filter="tag:Programming Language Theory and Design" data-astro-cid-lga65v7i=""> <a title="Programming Language Theory and Design" href="http://tinylogger.com/en/tags/plt" data-astro-cid-lga65v7i=""> PLT  </a> </li> </ul>  </span> </p></div> <p>OOP-bashing seems fashionable nowadays. I decided to write this article after seeing two OOP-related articles on <a href="https://lobste.rs/" rel="noopener" target="_blank">Lobsters<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> in quick succession. I’m not interested in defending or attacking OOP, but I do want to throw in my two cents and offer a more nuanced view.</p>
<p>The industry and the academy have used the term “object-oriented” to mean so many different things. One thing that makes conversations around OOP so unproductive is the lack of consensus on what OOP is.</p>
<p>What is Object-Oriented Programming? <a href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener" target="_blank">Wikipedia defines it<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> as “a programming paradigm based on the concept of objects.” This definition is unsatisfactory, as it requires a definition of an “object” and fails to encompass the disparate ways the term is used in the industry. There is also <a href="http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en" rel="noopener" target="_blank">Alan Kay’s vision of OOP<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>. However, the way most people use the term has drifted apart, and I don’t want to fall into <a href="https://en.wikipedia.org/wiki/Essentialism" rel="noopener" target="_blank">essentialism<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> or <a href="https://en.wikipedia.org/wiki/Etymological_fallacy" rel="noopener" target="_blank">etymological fallacy<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> by insisting on a “true” meaning.</p>
<p>Instead, I think it is better to treat OOP as a mixed bag of interrelated ideas and examine them individually. Below, I will survey some ideas related to OOP and mention their pros and cons (in my subjective mind).</p>
<h2 id="classes"><a aria-label="classes permalink" href="#classes"><span></span></a>Classes</h2>
<blockquote>
<p>Object-oriented programming is a method of implementation in which programs are organized as cooperative collections of objects, each of which represents an instance of some class, and whose classes are all members of a hierarchy of classes united via inheritance relationships. — Grady Booch</p>
</blockquote>
<p>Classes extend the idea of a “struct” or “record” with support for the method syntax, information hiding, and inheritance. We will talk about those specific features later.</p>
<p>Classes can also be viewed as blueprints for objects. It is not the only way to do that, and <em>prototypes</em> is an alternative pioneered by <a href="https://en.wikipedia.org/wiki/Self_(programming_language)" rel="noopener" target="_blank">Self<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> and, most famously, used by JavaScript. Personally, I feel that prototypes are harder to wrap one’s head around compared to classes. Even JavaScript tries to hide its usage of prototypes from newcomers with ES6 classes.</p>

<h2 id="method-syntax"><a aria-label="method-syntax permalink" href="#method-syntax"><span></span></a>Method Syntax</h2>
<blockquote>
<p>In Japanese, we have sentence chaining, which is similar to method chaining in Ruby — <a href="https://evrone.com/blog/yukihiro-matsumoto-interview" rel="noopener" target="_blank">Yukihiro Matsumoto<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a></p>
</blockquote>
<p>The method syntax is one of the less controversial OOP features. It captures common programming use cases involving operations on a specific subject. Even in languages without methods, it is common to see functions effectively serve as methods by taking the relevant data as their first argument (or last, in languages with currying).</p>

<p>The syntax involves method definitions and method calls. Usually, languages supporting methods have both, unless you consider the “pipe operators” in functional languages as a form of method call.</p>
<p>The method call syntax aids IDE autocompletion, and method chaining is often more ergonomic than nested function calls (similar to the pipe operator in functional languages).</p>
<p>There are some debatable aspects of the method syntax, too. First, in many languages, methods are often not definable outside of a class, which causes a power imbalance compared to functions. There are certain exceptions, such as Rust (methods are always defined outside of the struct), Scala, Kotlin, and C# (extension methods).</p>
<p>Second, in many languages, <code>this</code> or <code>self</code> is implicit. This keeps the code more concise, but it can also introduce confusion and increase the risk of accidental name shadowing. Another drawback of an implicit this is that it is always passed as a pointer, and its type cannot be changed. This means you cannot pass it as a copy, and sometimes this indirection leads to performance issues. More importantly, because the type of this is fixed, you cannot write generic functions that accept different <code>this</code> types. Python and Rust got <em>this</em> right from the start, and C++ just fixed this issue in C++23 with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html" rel="noopener" target="_blank">deducing this<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>.</p>
<p>Third, in languages with both “free functions” and methods, they become two incompatible ways to do the same thing. This can cause problems in generic code. Rust addresses this issue by <a href="https://doc.rust-lang.org/stable/reference/expressions/call-expr.html#disambiguating-function-calls" rel="noopener" target="_blank">allowing fully qualifying a method name and treating it as a function<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>.</p>
<p>Fourth, the dot notation is used for both instance variable accesses and method calls in most languages. This is an intentional choice to make methods look more <a href="https://en.wikipedia.org/wiki/Uniform_access_principle" rel="noopener" target="_blank">uniform<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> with objects. In certain dynamically typed languages where <em>methods are instance variables</em>, this is fine and pretty much not even a choice. On the other hand, in languages like C++ or Java, this can cause confusion and shadowing problems.</p>
<h2 id="information-hiding"><a aria-label="information-hiding permalink" href="#information-hiding"><span></span></a>Information Hiding</h2>
<blockquote>
<p>Its interface or definition was chosen to reveal as little as possible about its inner workings — <a href="https://dl.acm.org/doi/10.1145/361598.361623" rel="noopener" target="_blank">[Parnas, 1972b]<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a></p>
</blockquote>
<p>In Smalltalk, all instance variables are not directly accessible from outside the object, and all methods are exposed. More modern OOP languages support information hiding via access specifiers like <code>private</code> at the class level. Even non-OOP languages usually support information hiding in some way, be it module systems, opaque types, or even C’s header separation.</p>
<p>Information hiding is a good way to prevent <a href="https://en.wikipedia.org/wiki/Class_invariant" rel="noopener" target="_blank">invariant<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> from being violated. It is also a good way to separate frequently changed implementation details from a stable interface.</p>

<p>Nevertheless, aggressively hiding information may cause unnecessary boilerplate or <a href="https://en.wikipedia.org/wiki/Abstraction_inversion" rel="noopener" target="_blank">abstraction inversion<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>. Another criticism comes from functional programmers, who argue that you don’t need to maintain invariants and thus don’t need much information hiding if data is <em>immutable</em>. And, in a sense, OOP encourages people to write mutable objects that must be maintained as invariants.</p>

<p>Information hiding also encourages people to create small, self-contained objects that “know how to handle themselves,” which leads directly into the topic of encapsulation.</p>
<h2 id="encapsulation"><a aria-label="encapsulation permalink" href="#encapsulation"><span></span></a>Encapsulation</h2>
<blockquote>
<p>If you can, just move all of that behavior into the class it helps. After all, OOP is about letting objects take care of themselves. — Bob Nystrom, <a href="https://gameprogrammingpatterns.com/singleton.html" rel="noopener" target="_blank">Game Programming Patterns<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a></p>
</blockquote>
<p>Encapsulation is often confused with information hiding, but the two are distinct. Encapsulation refers to bundling data with the functions that operate on it. OOP languages directly support encapsulation with classes and the method syntax, but there are other approaches (e.g., <a href="https://ocaml.org/docs/modules" rel="noopener" target="_blank">the module system in OCaml<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>).</p>
<p><a href="https://en.wikipedia.org/wiki/Data-oriented_design" rel="noopener" target="_blank">Data-oriented design<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> has a lot to say about bundling data and functionality. When many objects exist, it is often much more efficient to process them in batches rather than individually. Having small objects with distinct behaviors can lead to poor data locality, more indirection, and fewer opportunities for parallelism. Of course, advocates of data-oriented design don’t reject encapsulation outright, but they encourage a more coarse-grained form of it, <a href="https://youtu.be/wo84LFzx5nI?si=ONwbHrfi0XVdSh3U" rel="noopener" target="_blank">organized around how the code is actually used rather than how the domain model is conceptually structured<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>.</p>
<h2 id="interfaces"><a aria-label="interfaces permalink" href="#interfaces"><span></span></a>Interfaces</h2>
<blockquote>
<p>“No part of a complex system should depend on the internal details of any other part.” — Daniel, Ingalls. “<a href="https://wiki.squeak.org/squeak/uploads/400/Smalltalk-76.pdf" rel="noopener" target="_blank">The Smalltalk-76 Programming System Design and Implementation<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>”</p>
</blockquote>
<p>Separation of interface and implementation is an old idea closely related to information hiding, encapsulation, and <a href="https://en.wikipedia.org/wiki/Abstract_data_type" rel="noopener" target="_blank">abstract data type<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>. In some sense, even C’s header files can be considered an interface, but OOP usage of “interface” most often refers to a specific set of language constructs that support polymorphism (typically implemented via inheritance). Usually, an interface can’t contain data, and in more restricted languages (e.g., early versions of Java), they can’t contain method implementations either. The same idea of an interface is also common in non-OOP languages: Haskell type classes, Rust traits, and Go interfaces all serve the role of specifying an abstract set of operations independent of implementations.</p>
<p>Interface is often considered a simpler, more disciplined alternative to full-blown class inheritance. It is a single-purpose feature and doesn’t suffer from the same diamond problem that plagues multiple inheritance.</p>
<p>Interface is also extremely useful in combination with <a href="https://en.wikipedia.org/wiki/Parametric_polymorphism" rel="noopener" target="_blank">parametric polymorphism<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>, since it allows you to constrain the operations a type parameter must support. Dynamically-typed languages (and C++/D template) achieve something similar through <a href="https://en.wikipedia.org/wiki/Duck_typing" rel="noopener" target="_blank">duck-typing<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>, but even languages with duck-typing introduce interface constructs later to express constraints more explicitly (e.g., C++ concepts or TypeScript interfaces).</p>
<p>The interface as implemented in OOP languages often has a runtime cost, but that’s not always the case. For example, <a href="https://en.cppreference.com/w/cpp/language/constraints.html" rel="noopener" target="_blank">C++ concepts<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> is an example that only supports compile-time, and Rust’s trait only has opt-in runtime polymorphism support via <code>dyn</code>.</p>
<h2 id="late-binding"><a aria-label="late-binding permalink" href="#late-binding"><span></span></a>Late Binding</h2>
<blockquote>
<p>OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things — <a href="https://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en" rel="noopener" target="_blank">Alan Kay<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a></p>
</blockquote>
<p>Late binding refers to delaying the lookup of a method or a member until runtime. It is the default of most dynamic-typed languages, where method calls are often implemented as a hash table lookup, but can also be achieved with other means, such as dynamic loading or function pointers.</p>
<p>A key aspect of late binding is that behaviour can be changed while the software is still running, enabling all kinds of hot-reloading and monkey-patching workflows.</p>
<p>The downside of late binding is its non-trivial performance cost. Moreover, it can also be a footgun for breaking invariants or even interface mismatches. Its mutable nature can also introduce subtler issues, for example, the “late binding closures” pitfall in Python.</p>
<h2 id="dynamic-dispatch"><a aria-label="dynamic-dispatch permalink" href="#dynamic-dispatch"><span></span></a>Dynamic Dispatch</h2>
<blockquote>
<p>A programming paradigm in C++ using Polymorphism based on runtime function dispatch using virtual functions — <a href="https://youtu.be/32tDTD9UJCE?si=OqBHJ3PecCEvidoL" rel="noopener" target="_blank">Back to Basics: Object-Oriented Programming - Jon Kalb - CppCon 2019<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a></p>
</blockquote>
<p>A concept related to late binding is dynamic dispatch, in which the implementation of a polymorphic operation is selected at runtime. The two concepts overlap, though dynamic dispatch focuses more on selecting multiple known polymorphic operations rather than on name lookup.</p>
<p>In a dynamically typed language, dynamic dispatch is the default since everything is late-bound. In statically typed languages, it is usually implemented as a virtual function table that looks something like this under the hood:</p>
<div><figure><pre data-language="cpp"><code><div><p><span>struct</span><span> </span><span>VTable</span><span> {</span></p></div><div><p><span><span>  </span></span><span>// function pointer to destroy the base</span></p></div><div><p><span>  </span><span>void</span><span><span> (*</span><span>destroy</span><span>)(</span></span><span>Base</span><span>&amp;</span><span>);</span></p></div><div></div><div><p><span><span>  </span></span><span>// function pointer to one method implementation</span></p></div><div><p><span>  </span><span>void</span><span><span> (*</span><span>foo</span><span>)();</span></span></p></div><div></div><div><p><span><span>  </span></span><span>// function pointer to another method implementation</span></p></div><div><p><span>  </span><span>int</span><span><span> (*</span><span>bar</span><span>)(</span></span><span>int</span><span>);</span></p></div><div><p><span>};</span></p></div><div></div><div><p><span>struct</span><span> </span><span>BaseClass</span><span> {</span></p></div><div><p><span><span>  </span></span><span>VTable</span><span>*</span><span> vtable;</span></p></div><div><p><span>};</span></p></div></code></pre></figure></div>
<p>These languages also provide compile-time guarantees that the vtable contains valid operations for the type.</p>
<p>Dynamic dispatch can be decoupled from inheritance, whether by manually implementing a v-table (e.g., C++‘s “type-erased types” such as <a href="https://en.cppreference.com/w/cpp/utility/functional/function" rel="noopener" target="_blank"><code>std::function</code><span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>) or an interface/trait/typeclass kind of constructs. When not paired with inheritance, dynamic dispatch alone is usually not considered “OOP.”</p>
<p>Another thing to note is that the pointer to the v-table can be directly inside the object (e.g., C++) or embedded in “fat pointers” (e.g., Go and Rust).</p>
<p>Complaints about dynamic dispatch are usually about its performance. Although a virtual function call itself can be pretty fast, it <a href="https://johnnysswlab.com/the-true-price-of-virtual-functions-in-c/" rel="noopener" target="_blank">opens room for missing compiler inlining opportunities, cache misses, and branch mispredictions<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>.</p>
<h2 id="inheritance"><a aria-label="inheritance permalink" href="#inheritance"><span></span></a>Inheritance</h2>
<blockquote>
<p>programming using class hierarchies and virtual functions to allow manipulation of objects of a variety of types through well-defined interfaces and to allow a program to be extended incrementally through derivation  — <a href="https://www.stroustrup.com/bs_faq.html#oop" rel="noopener" target="_blank">Bjarne Stroustrup<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a></p>
</blockquote>
<p>Inheritance has a long history, way backed to <a href="https://en.wikipedia.org/wiki/Simula" rel="noopener" target="_blank">Simula 67<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>. It is probably the most iconic feature of OOP. Almost every language marketed as “object-oriented” includes it, while languages that avoid OOP typically omit it.</p>
<p>It can be damn <em>convenient</em>. In many cases, using an alternative approach will result in significantly more boilerplate.</p>

<p>On the other hand, inheritance is a very <a href="https://en.wikipedia.org/wiki/Orthogonality_(programming)" rel="noopener" target="_blank">non-orthogonal<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> feature. It is a single mechanism that enables dynamic dispatch, subtyping polymorphism, interface/implementation segregation, and code reuse. It is flexible, though that flexibility makes it easy to misuse. For that reason, some languages nowadays replace it with more restrictive alternative constructs.</p>
<p>There are some other problems with inheritance. First, using inheritance almost certainly means you are paying the performance cost of dynamic dispatch and heap allocation. In some languages, such as C++, you can use inheritance without dynamic dispatch and heap allocation, and there are some valid use cases (e.g., code reuse with <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern" rel="noopener" target="_blank">CRTP<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>), but the majority of uses of inheritance are for runtime polymorphism (and thus rely on dynamic dispatch).</p>
<p>Second, inheritance implements subtyping in an unsound way, requiring programmers to manually enforce the <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noopener" target="_blank">Liskov substitution principle<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>.</p>
<p>Finally, inheritance hierarchies are rigid. They suffer from issues like the diagonal problem, and that inflexibility is one of the main reasons people prefer composition over inheritance. The <a href="https://gameprogrammingpatterns.com/component.html" rel="noopener" target="_blank">component pattern chapter of Game Programming Patterns<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> provides a good example.</p>
<h2 id="subtyping-polymorphism"><a aria-label="subtyping-polymorphism permalink" href="#subtyping-polymorphism"><span></span></a>Subtyping Polymorphism</h2>
<blockquote>
<p>If for each object <mjx-container jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.085ex" height="1.337ex" role="img" focusable="false" viewBox="0 -441 921.6 591" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use data-c="1D45C" xlink:href="#MJX-1-TEX-I-1D45C"></use></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g></g></g></svg></mjx-container> of type <mjx-container jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.459ex" height="1.645ex" role="img" focusable="false" viewBox="0 -705 645 727" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D446" xlink:href="#MJX-2-TEX-I-1D446"></use></g></g></g></svg></mjx-container> there is another object <mjx-container jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.085ex" height="1.337ex" role="img" focusable="false" viewBox="0 -441 921.6 591" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-3-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-3-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use data-c="1D45C" xlink:href="#MJX-3-TEX-I-1D45C"></use></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><use data-c="32" xlink:href="#MJX-3-TEX-N-32"></use></g></g></g></g></svg></mjx-container> of type <mjx-container jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.593ex" height="1.532ex" role="img" focusable="false" viewBox="0 -677 704 677" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-4-TEX-I-1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D447" xlink:href="#MJX-4-TEX-I-1D447"></use></g></g></g></svg></mjx-container> such that for all programs <mjx-container jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.699ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 751 683" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-5-TEX-I-1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D443" xlink:href="#MJX-5-TEX-I-1D443"></use></g></g></g></svg></mjx-container> defined in terms of <mjx-container jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.593ex" height="1.532ex" role="img" focusable="false" viewBox="0 -677 704 677" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-6-TEX-I-1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D447" xlink:href="#MJX-6-TEX-I-1D447"></use></g></g></g></svg></mjx-container>, the behavior of <mjx-container jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.699ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 751 683" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-7-TEX-I-1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D443" xlink:href="#MJX-7-TEX-I-1D443"></use></g></g></g></svg></mjx-container> is unchanged when <mjx-container jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.085ex" height="1.337ex" role="img" focusable="false" viewBox="0 -441 921.6 591" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-8-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-8-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use data-c="1D45C" xlink:href="#MJX-8-TEX-I-1D45C"></use></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><use data-c="31" xlink:href="#MJX-8-TEX-N-31"></use></g></g></g></g></svg></mjx-container> is substituted for <mjx-container jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.085ex" height="1.337ex" role="img" focusable="false" viewBox="0 -441 921.6 591" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-9-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-9-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use data-c="1D45C" xlink:href="#MJX-9-TEX-I-1D45C"></use></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><use data-c="32" xlink:href="#MJX-9-TEX-N-32"></use></g></g></g></g></svg></mjx-container>, then <mjx-container jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.459ex" height="1.645ex" role="img" focusable="false" viewBox="0 -705 645 727" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-10-TEX-I-1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D446" xlink:href="#MJX-10-TEX-I-1D446"></use></g></g></g></svg></mjx-container> is a subtype of <mjx-container jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.593ex" height="1.532ex" role="img" focusable="false" viewBox="0 -677 704 677" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-11-TEX-I-1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D447" xlink:href="#MJX-11-TEX-I-1D447"></use></g></g></g></svg></mjx-container>. — Barbara Liskov, “<a href="https://www.cs.tufts.edu/~nr/cs257/archive/barbara-liskov/data-abstraction-and-hierarchy.pdf" rel="noopener" target="_blank">Data Abstraction and Hierarchy<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>”</p>
</blockquote>
<p>Subtyping describes an “is a” relation between two types. The <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noopener" target="_blank">Liskov substitution principle<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> defines the property that safe subtyping relationships must uphold.</p>
<p>OOP languages often support subtyping via inheritance, but note that inheritance doesn’t always model subtyping, and it is not the only form of subtyping either. Various interface/trait constructs in non-OOP languages often support subtyping. And besides <em>nominal subtyping</em>, where one explicitly declares the subtyping relationship, there are also <em>structural subtyping</em>, where the subtyping is implicit if one type contains all the features of another type. Good examples of structural subtyping include OCaml (<a href="https://dev.realworldocaml.org/objects.html" rel="noopener" target="_blank">objects<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> and polymorphic variants) and TypeScript interfaces. Subtyping also shows in all kinds of little places, such as Rust lifetime and TypeScript’s coercion from a non-nullable type to its nullable counterpart.</p>
<p>A related concept to subtyping is <a href="https://en.wikipedia.org/wiki/Type_variance" rel="noopener" target="_blank">variance<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> (not related to class-invariant), which bridges parametric polymorphism and subtyping. I won’t bother explaining variance here, as this topic probably needs an entire blog post to explain well. It is a great ergonomic boost (e.g., C++ pointers will be unusable for polymorphic use if it is not covariant), but most languages only implement a limited, hard-coded version, because it is hard to understand and also error-prone. In particular, mutable data types usually should be invariant, and Java/C#‘s covariant arrays are a primary example on this got wrong. There are a few languages that support programmers explicitly control variance, including <a href="https://docs.scala-lang.org/tour/variances.html" rel="noopener" target="_blank">Scala<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> and <a href="https://kotlinlang.org/docs/generics.html" rel="noopener" target="_blank">Kotlin<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>.</p>
<p>Type conversion via subtyping relationships is often implicit. Implicit conversion has a bad reputation. Though doing it with subtyping is ergonomic, and is probably the least surprising kind of implicit conversion. Another way to view subtyping is as the dual of implicit conversions. We can “fake” a subtyping relation with implicit conversion. For example, C++ templated types are invariant, but <code>std::unique_ptr</code> achieves covariance with an implicit conversion from <code>std::unique_ptr&lt;Derived&gt;</code> to <code>std::unique_ptr&lt;Base&gt;</code>. <a href="https://journal.stuffwithstuff.com/2023/10/19/does-go-have-subtyping/" rel="noopener" target="_blank">Does Go Have Subtyping?<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> is a good article to further explore this idea.</p>
<p>One reason that language designers often try to avoid subtyping is the implementation complexity. Integrating bidirectional type inference and subtyping is notoriously difficult. Stephen Dolan’s 2016 thesis <a href="https://www.cs.tufts.edu/~nr/cs257/archive/stephen-dolan/thesis.pdf" rel="noopener" target="_blank">Algebraic Subtyping<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> makes good progress addressing this issue.</p>
<h2 id="message-passing"><a aria-label="message-passing permalink" href="#message-passing"><span></span></a>Message Passing</h2>
<blockquote>
<p>I thought of objects being like biological cells and/or individual computers on a network, only able to communicate with messages — <a href="https://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en" rel="noopener" target="_blank">Alan Kay<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a></p>
</blockquote>
<p>Message passing means using objects that send each other “messages” as a way of execution. It is the centric theme of Alan Kay’s vision of OOP, though the definition can be pretty vague. An important point is that message names are late-bound, and the structures of these messages are not necessarily fixed at compile time.</p>
<p>Many early object-oriented concepts were influenced by distributed and simulation systems, where message passing is natural. However, in the era where most people work on single-threaded code, the message was gradually forgotten in languages such as C++ and Java. The method syntax only has limited benefit compared to the original message-passing idea (Bjarne Stroustrup was definitely aware of the idea from Simula, but there is practical constraint on how to make it fast). There was still some genuine message passing, but only in specific areas such as inter-process communication or highly event-driven systems.</p>
<p>Message passing gains a Renaissance in concurrent programming, ironically through non-OOP languages like Erlang and Golang, with constructs such as actors and channels. This kind of <a href="https://en.wikipedia.org/wiki/Shared-nothing_architecture" rel="noopener" target="_blank">shared-nothing concurrency<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> removed a whole range of data race and race condition bugs. In combination with supervision, actors also provide fault tolerance, so that the failure of one actor will not affect the entire program.</p>
<h2 id="open-recursion"><a aria-label="open-recursion permalink" href="#open-recursion"><span></span></a>Open-recursion</h2>
<p>Originating in the famous <a href="https://www.cis.upenn.edu/~bcpierce/tapl/" rel="noopener" target="_blank">Types and Programming Languages<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a>, <em>open recursion</em> is probably the least well-known and understood term in this blog post. Nevertheless, it just describes a familiar property of object-oriented systems: methods for an object can call each other, even if they are defined in different classes in the inheritance hierarchy.</p>
<p>The term is somewhat misleading, as there may not be recursive function calls, but here “recursion” means “mutually recursive.” The word “open” refers to “open to extension,” typically empowered by inheritance.</p>
<p>It’s easiest to see with an example:</p>
<div><figure><pre data-language="cpp"><code><div><p><span>struct</span><span> </span><span>Animal</span><span> {</span></p></div><div><p><span>  </span><span>void</span><span> </span><span>print_name</span><span>() </span><span>const</span><span> {</span></p></div><div><p><span><span>    </span></span><span>// Note that we call `name` here, although it is not defined in Animal</span></p></div><div><p><span>    </span><span>std</span><span>::</span><span>print</span><span>(</span><span>&#34;{}</span><span>\n</span><span>&#34;</span><span>, </span><span>name</span><span>());</span></p></div><div><p><span><span>  </span></span><span>}</span></p></div><div></div><div><p><span>  </span><span>virtual</span><span> </span><span>std</span><span>::</span><span>string</span><span> </span><span>name</span><span>() </span><span>const</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p></div><div><p><span>};</span></p></div><div></div><div><p><span>struct</span><span> </span><span>Cat</span><span>: Animal {</span></p></div><div><p><span>  </span><span>std</span><span>::</span><span>string</span><span> </span><span>name</span><span>() </span><span>const</span><span> </span><span>override</span><span> {</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>&#34;Kitty&#34;</span><span>;</span></p></div><div><p><span><span>  </span></span><span>}</span></p></div><div><p><span>};</span></p></div><div></div><div><p><span>int</span><span> </span><span>main</span><span>() {</span></p></div><div><p><span><span>  </span></span><span>Cat cat;</span></p></div><div><p><span><span>  </span></span><span>// note we call print_name here, although it is not defined in Cat</span></p></div><div><p><span><span>  </span></span><span>cat</span><span>.</span><span>print_name</span><span>();</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>

<p>For anyone with some familiarity with OOP, we probably take open recursion for granted, even though we may not be aware of its name. But not all language constructs have this property. For example, in many languages, functions are not mutually recursive by default:</p>
<div><figure><pre data-language="cpp"><code><div><p><span>// This won&#39;t compile in C++ because `name` is not defined</span></p></div><div><p><span>void</span><span> </span><span>print_name</span><span>(</span><span>const</span><span> </span><span>Animal</span><span>&amp;</span><span> </span><span>animal</span><span>) {</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>name</span><span>(animal);</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>std</span><span>::</span><span>string</span><span> </span><span>name</span><span>(</span><span>const</span><span> </span><span>Cat</span><span>&amp;</span><span> </span><span>cat</span><span>) {</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>&#34;Kitty&#34;</span><span>;</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Now, in languages with late-bound functions, functions in the same module can always call each other (e.g., Python, JavaScript). There are other languages where functions are mutually recursive by default (e.g., Rust), or have forward declarations (C) or a <code>letrec</code> construct (Scheme and ML family) to make functions mutually recursive. This solves the “recursion” part, but still not the “open” part yet:</p>
<div><figure><pre data-language="cpp"><code><div><p><span>std</span><span>::</span><span>string</span><span> </span><span>name</span><span>(</span><span>const</span><span> </span><span>Cat</span><span>&amp;</span><span> </span><span>cat</span><span>);</span></p></div><div></div><div><p><span>void</span><span> </span><span>print_name</span><span>(</span><span>const</span><span> </span><span>Animal</span><span>&amp;</span><span> </span><span>animal</span><span>) {</span></p></div><div><p><span><span>    </span></span><span>// This still won&#39;t compile because we can&#39;t downcast an Animal to a Cat</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>name</span><span>(animal);</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>std</span><span>::</span><span>string</span><span> </span><span>name</span><span>(</span><span>const</span><span> </span><span>Cat</span><span>&amp;</span><span> </span><span>cat</span><span>) {</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>&#34;Kitty&#34;</span><span>;</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Let’s fix this problem by using a callback:</p>
<div><figure><pre data-language="cpp"><code><div><p><span>struct</span><span> </span><span>Animal</span><span> {</span></p></div><div><p><span>  </span><span>std</span><span>::function</span><span>&lt;</span><span>std</span><span>::</span><span>string</span><span>()</span><span>&gt;</span><span> get_name;</span></p></div><div></div><div><p><span>  </span><span>void</span><span> </span><span>print_name</span><span>() </span><span>const</span><span> {</span></p></div><div><p><span>    </span><span>std</span><span>::</span><span>print</span><span>(</span><span>&#34;{}</span><span>\n</span><span>&#34;</span><span>, </span><span>get_name</span><span>());</span></p></div><div><p><span><span>  </span></span><span>}</span></p></div><div><p><span>};</span></p></div><div></div><div><p><span>Animal</span><span> </span><span>make_cat</span><span>() {</span></p></div><div><p><span>    </span><span>return</span><span> Animal {</span></p></div><div><p><span><span>      </span></span><span>.get_name </span><span>=</span><span> []() { </span><span>return</span><span> </span><span>&#34;Kitty&#34;</span><span>; },</span></p></div><div><p><span><span>    </span></span><span>};</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>int</span><span> </span><span>main</span><span>() {</span></p></div><div><p><span><span>  </span></span><span>Animal cat </span><span>=</span><span> </span><span>make_cat</span><span>();</span></p></div><div><p><span><span>  </span></span><span>cat</span><span>.</span><span>print_name</span><span>();</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Tada, we just reinvented prototype-style dispatch!</p>
<p>Anyway, with my quick example above, I want to show that open recursion is a property that OOP gives for free, but reproducing it in languages without built-in support can be tricky. Open recursion allows interdependent parts of an object to be defined separately, and this property is used in many instances, for example, the entire idea of <a href="https://en.wikipedia.org/wiki/Decorator_pattern" rel="noopener" target="_blank">decorator pattern<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> depends on open recursion.</p>
<h2 id="oop-best-practices"><a aria-label="oop-best-practices permalink" href="#oop-best-practices"><span></span></a>OOP Best Practices</h2>
<p>Perhaps the more common complaints about OOP are not about specific language features, but rather about the programming styles it encourages. Many practices are taught as universal best practices, sometimes with rationales, but their downsides are often omitted. Some examples popped into my mind are</p>



































<table><thead><tr><th>Practice</th><th>Advantages</th><th>Disadvantage</th></tr></thead><tbody><tr><td>preferring polymorphism over tagged union/if/switch/pattern matching</td><td>Open to extension, easier to add new cases.</td><td>Performance hit; Related behaviors get scattered in multiple places; harder to see the whole controll flow in one place</td></tr><tr><td>making all data members private</td><td>Protect class invariants</td><td>More boilerplates; Often unnecessary to hide data without invariants; Getter/setter pairs work less well compared to direct access in languages without property syntax</td></tr><tr><td>preferring small “self-managed” objects over central “managers”</td><td>Harder to violate invariants, cleaner code organization</td><td>Potential bad data locality, missing parallelism opportunities, and duplicated references to common data (“back pointer”)</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener" target="_blank">preferring extension rather than modification<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a></td><td>Prevent new features from breaking the old one. Prevent API break</td><td>No reason to “close” a non-public module where you own its usage. Leads to unnecessary complexity and inheritance chain; poorly designed interfaces are not changed; Can cause abstraction inversion</td></tr><tr><td>preferring abstraction over concrete implementations</td><td>Making more system swappable and testable</td><td>Overuse sacrifices readability and debuggability. Performance cost of extra indirection</td></tr></tbody></table>
<p>This blog post is long enough, so I will not go into more details. Feel free to disagree with my “advantages and disadvantages”. What I want to convey is that almost all those practices come with trade-offs.</p>
<h2 id="in-the-end"><a aria-label="in-the-end permalink" href="#in-the-end"><span></span></a>In the End</h2>
<p>Congratulations on making it to the end of this article! There are other topics I’d love to discuss, such as <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" rel="noopener" target="_blank">RAII<span aria-hidden="true"><svg><symbol id="ai:mdi:open-in-new" viewBox="0 0 24 24"><path fill="currentColor" d="M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"></path></symbol><use href="#ai:mdi:open-in-new"></use></svg></span></a> and design patterns. However, this article is long enough, so I will leave those for you to explore on your own.</p> </div></div>
  </body>
</html>
