<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/steve-m/Pico-100BASE-TX">Original</a>
    <h1>Pico-100BASE-TX: Bit-Banged 100 MBit/s Ethernet and UDP Framer for RP2040/RP2350</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">This library allows to stream out data with around 11 MByte/s from a RP2040 or RP2350 MCU using the PIO to bit-bang a 100 MBit/s Fast Ethernet connection.
It is somewhat similar to <a href="https://github.com/kingyoPiyo/Pico-10BASE-T">Pico-10BASE-T</a>, which implemented TX-only 10 MBit/s Ethernet.</p>
<p dir="auto"><strong>Warning: Do not connect to any POE capable equipment!</strong></p>
<p dir="auto">Ideally use a pulse transformer with proper matching circuitry, or at least the 47 + 470 Ohms resistors as seen <a href="https://github.com/kingyoPiyo/Pico-10BASE-T?tab=readme-ov-file#setup">here</a>. In my experiments I directly connected the two GPIOs to an old ethernet cable and it worked with most devices I&#39;ve tested - only do that at your <strong>own risk</strong>. You also could use some old Ethernet switch and connect it in between the Pico and your machine to be safe.
ASUS mainboards with LANGuard only work when using the resistors or a pulse transformer.</p>
<p dir="auto">Demo digitizing some WBFM IF signal with the internal ADC and streaming it out via Fast Ethernet:</p>
<details open="">
  <summary>
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path d="M16 3.75v8.5a.75.75 0 0 1-1.136.643L11 10.575v.675A1.75 1.75 0 0 1 9.25 13h-7.5A1.75 1.75 0 0 1 0 11.25v-6.5C0 3.784.784 3 1.75 3h7.5c.966 0 1.75.784 1.75 1.75v.675l3.864-2.318A.75.75 0 0 1 16 3.75Zm-6.5 1a.25.25 0 0 0-.25-.25h-7.5a.25.25 0 0 0-.25.25v6.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-6.5ZM11 8.825l3.5 2.1v-5.85l-3.5 2.1Z"></path>
</svg>
    <span>Pico-100BASE-TX.mp4</span>
    <span></span>
  </summary>

  <video src="https://private-user-images.githubusercontent.com/522310/502770099-e150bc89-122c-4669-ae62-b9b03f8b2769.mp4?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NjI0NjQxNDIsIm5iZiI6MTc2MjQ2Mzg0MiwicGF0aCI6Ii81MjIzMTAvNTAyNzcwMDk5LWUxNTBiYzg5LTEyMmMtNDY2OS1hZTYyLWI5YjAzZjhiMjc2OS5tcDQ_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUxMTA2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MTEwNlQyMTE3MjJaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1hZmU1OWIxYWVkMGQxMmM3ODFhMmM2MjE1YTVhNDlhYTk3ZTdjYWQ3YWY3NTRiZjMzZjU5ZmY5YmVlMDA2ZDk3JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.iDkJjRsW8Lw-trpsD14C3qVeMro1Ou8W3bEuRTt5XTA" data-canonical-src="https://private-user-images.githubusercontent.com/522310/502770099-e150bc89-122c-4669-ae62-b9b03f8b2769.mp4?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NjI0NjQxNDIsIm5iZiI6MTc2MjQ2Mzg0MiwicGF0aCI6Ii81MjIzMTAvNTAyNzcwMDk5LWUxNTBiYzg5LTEyMmMtNDY2OS1hZTYyLWI5YjAzZjhiMjc2OS5tcDQ_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUxMTA2JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MTEwNlQyMTE3MjJaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1hZmU1OWIxYWVkMGQxMmM3ODFhMmM2MjE1YTVhNDlhYTk3ZTdjYWQ3YWY3NTRiZjMzZjU5ZmY5YmVlMDA2ZDk3JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.iDkJjRsW8Lw-trpsD14C3qVeMro1Ou8W3bEuRTt5XTA" controls="controls" muted="muted">

  </video>
</details>


<p dir="auto">10BASE-T is rather trivial to implement using an SPI peripheral, as it only uses two voltage levels and Manchester encoding. 100BASE-TX transmission however is harder to implement, it uses <a href="https://en.wikipedia.org/wiki/MLT-3_encoding" rel="nofollow">MLT-3</a> encoding, is scrambled, uses a <a href="https://en.wikipedia.org/wiki/4B5B" rel="nofollow">4B5B</a> line code, and is transmitted at 125 MHz symbol rate.</p>

<p dir="auto">There are three levels this code sequentially cycles through, -1, 0 and +1. If there is a zero to be transmitted, the state remains identical to the last symbol. For a one, it moves to the next state. For a row of ones, the output would be -1, 0, +1, 0, -1, 0 and so on.</p>
<p dir="auto">Using the side-set feature of the PIO, MLT-3 encoding is implemented on two GPIOs that output either 0b01, 0b00 or 0b10 for each MLT-3 symbol, respectively. As the twisted pair is connected between those two GPIOs, the three voltage levels are obtained.</p>

<p dir="auto">The scrambler is implemented using an <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register" rel="nofollow">LFSR</a> that is 11 bits wide and has taps at the 11th and 9th bit (x^11 + x^9 + 1). This results in a pseudorandom sequence that repeats after 2047 bits. We pre-compute a lookup-table that contains 30 bits of the sequence per entry, and uses 2047 entries (plus the maximum size of a frame for convenience). This takes around 10 KB of RAM in the MCU.</p>

<p dir="auto">Each 4-bit nibble is encoded using the <a href="https://en.wikipedia.org/wiki/4B5B" rel="nofollow">4B5B</a> line code resulting in 5 bits. Special 5-bit symbols J, K as well as T and R are reserved to signal the start and end of an Ethernet frame, furthermore there is an idle symbol consisting of all ones.
For efficiency purposes, we use a LUT with 256 entries, containing two 4B5B symbols per entry. This allows to encode each byte of the Ethernet frame with only one access into the table.</p>

<p dir="auto">The Ethernet FCS (Frame Check Sequence) is calculated by using the DMA CRC sniffer in CRC32 mode, the (optional) UDP checksum also uses the DMA sniffer in sum mode.</p>

<p dir="auto">With pre-inversion of the scrambling code (already containg the idle symbol), we can directly send the stream of idle symbols to the PIO by DMA. So we only have to use CPU cycles if we really want to transmit a frame.</p>
<p dir="auto"><a href="https://2007.blog.dest-unreach.be/2009/06/11/ethernet-100base-tx/" rel="nofollow">This page</a> also contains some useful information in addition to <a href="https://2007.blog.dest-unreach.be/wp-content/uploads/2017/12/802.3-2005-sec2.pdf" rel="nofollow">IEEE 802.3</a>.</p>

<p dir="auto">Make sure you have the latest version of the <a href="https://github.com/raspberrypi/pico-sdk">pico-sdk</a> installed together with an appropriate compiler. You should be able to build the <a href="https://github.com/raspberrypi/pico-examples">pico-examples</a>.</p>
<p dir="auto">To build Pico-100BASE-TX for a Pico2:</p>
<div data-snippet-clipboard-copy-content="git clone https://github.com/steve-m/Pico-100BASE-TX.git
mkdir Pico-100BASE-TX/build
cd Pico-100BASE-TX/build
export PICO_SDK_PATH=/&lt;path-to&gt;/pico-sdk
cmake -DPICO_PLATFORM=rp2350 -DPICO_BOARD=pico2 ../
make -j 8"><pre><code>git clone https://github.com/steve-m/Pico-100BASE-TX.git
mkdir Pico-100BASE-TX/build
cd Pico-100BASE-TX/build
export PICO_SDK_PATH=/&lt;path-to&gt;/pico-sdk
cmake -DPICO_PLATFORM=rp2350 -DPICO_BOARD=pico2 ../
make -j 8
</code></pre></div>
<p dir="auto">After the build succeeds you can copy the resulting *.uf2 file of the application you want to run to the board.</p>

<p dir="auto">The repository contains a library - libpico100basetx - which implements the main functionality. It reads the data from a ringbuffer, and streams it out via the 100BASE-TX UDP frames.
In addition to that, the apps folder contains a couple of example applications:</p>

<p dir="auto">This application uses the PIO to generate a 16-bit counter value which is written to a DMA ringbuffer, which is then streamed out via UDP datagrams.</p>

<p dir="auto">The data from the internal ADC is streamed out.</p>

<p dir="auto">This app streams the audio data from a PCM1802 audio ADC board. The used pinout is the same as on this <a href="https://github.com/Sev5000/Pico2_12bitADC_PCMAudio">adapter PCB</a>, and the audio samplerate is 75 kHz.</p>

<p dir="auto">Pico-100BASE-TX is developed by Steve Markgraf, and is loosely based on <a href="https://github.com/steve-m/hsdaoh-rp2350">hsdaoh-rp2350</a>.</p>
</article></div></div>
  </body>
</html>
