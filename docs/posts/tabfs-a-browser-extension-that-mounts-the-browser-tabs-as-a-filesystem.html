<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://omar.website/tabfs/">Original</a>
    <h1>TabFS – a browser extension that mounts the browser tabs as a filesystem</h1>
    
    <div id="readability-page-1" class="page"><div>
      <!-- I'm setting this page in Verdana-on-gray so I feel more comfortable -->
<!-- jotting random notes and stuff down. -->

<p><a href="https://github.com/osnr/TabFS">TabFS</a> is a browser extension that
mounts your browser tabs as a filesystem on your computer.</p>
<p>Out of the box, it supports Chrome and (to a lesser extent<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>)
Firefox and Safari, on macOS and Linux.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p>
<p>(<strong>update</strong>: You can now <strong><a href="https://github.com/sponsors/osnr">sponsor me to help support further
development of TabFS</a></strong> :-)</p>
<p>Each of your open tabs is mapped to a folder.</p>
<div>
<p><a href="https://omar.website/tabfs/doc/00-browser.png"><img src="https://omar.website/tabfs/doc/00-browser.png"/></a>
<a href="https://omar.website/tabfs/doc/00-finder.png"><img src="https://omar.website/tabfs/doc/00-finder.png"/></a></p><p>I have 3 tabs open, and
they map to 3 folders in TabFS</p>
</div>
<p>The files inside a tab&#39;s folder directly reflect (and can control) the
state of that tab in your browser.</p>
<div>
<video autoplay="" loop="" muted="">
  <source src="doc/finder-contents.mp4" type="video/mp4"/>
</video>
<p>Going through the files inside a tab&#39;s folder. For
example, the url.txt, text.txt, and title.txt files tell me those live
properties of this tab</p>
</div>
<!-- for now, I am copying routes.html into web/ locally before I -->
<!-- deploy the site. need to find a better way? -->
<p><strong><a href="https://omar.website/tabfs/routes.html">(Read more up-to-date documentation for all of
TabFS&#39;s files here.)</a></strong></p>
<p>This gives you a <em>ton</em> of power, because now you can apply <a href="https://twitter.com/rsnous/status/1018570020324962305">all the
existing tools</a>
on your computer that already know how to deal with files -- terminal
commands, scripting languages, point-and-click explorers, etc -- and
use them to control and communicate with your browser.</p>
<p>Now you don&#39;t need to <a href="https://twitter.com/rsnous/status/1261392522485526528">code up a browser extension from
scratch</a> every
time you want to do anything. You can write a script that talks to
your browser in, like, a melange of Python and bash, and you can save
it as <a href="https://twitter.com/rsnous/status/1308588645872435202">a single ordinary
file</a> that you
can run whenever, and it&#39;s no different from scripting any other part
of your computer.</p>
<h3 id="table-of-contents">table of contents</h3>


<h2 id="examples-of-stuff-you-can-doexamples">Examples of stuff you can do!<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></h2>
<p>(assuming your current directory is the <code>fs</code> subdirectory of the git
repo and you have the extension running)</p>
<h3 id="list-the-titles-of-all-the-tabs-you-have-open">List the titles of all the tabs you have open</h3>
<pre tabindex="0"><code>$ cat mnt/tabs/by-id/*/title.txt
GitHub
Extensions
TabFS/install.sh at master · osnr/TabFS
Alternative Extension Distribution Options - Google Chrome
Web Store Hosting and Updating - Google Chrome
Home / Twitter
...
</code></pre><h3 id="cull-tabs-like-any-other-files">Cull tabs like any other files</h3>
<div>
<video autoplay="" loop="" muted="">
  <source src="doc/delete.mp4" type="video/mp4"/>
</video>
<p>Selecting and deleting a bunch of tabs in my file manager</p>
</div>
<p>I&#39;m using Dired in Emacs here, but you could use whatever tools you
already feel comfortable managing your files with.</p>
<h3 id="close-all-stack-overflow-tabs">Close all Stack Overflow tabs</h3>
<pre tabindex="0"><code>$ rm mnt/tabs/by-title/*Stack_Overflow*
</code></pre><p>or (older / more explicit)</p>
<pre tabindex="0"><code>$ echo remove | tee -a mnt/tabs/by-title/*Stack_Overflow*/control
</code></pre><h4 id="btw">btw</h4>
<p>(this task, removing all tabs whose titles contain some string, is a
little contrived, but it&#39;s not that unrealistic, right?)</p>
<p>(now... how would you do this <em>without</em> TabFS?  I honestly have no
idea, off the top of my head. like, how do you even get the titles of
tabs? how do you tell the browser to close them?)</p>
<p>(I looked up the APIs, and, OK, if you&#39;re already in a browser
extension, in a &#39;background script&#39; inside the extension, <em>and</em> your
extension has the <code>tabs</code> permission -- this already requires you to
make 2 separate files and hop between your browser and your text
editor to set it all up! -- you can do
<a href="https://developer.chrome.com/docs/extensions/reference/tabs/#method-query">this</a>:
<code>chrome.tabs.query({}, tabs =&gt; chrome.tabs.remove(tabs.filter(tab =&gt; tab.title.includes(&#39;Stack Overflow&#39;)).map(tab =&gt; tab.id)))</code>)</p>
<p>(not <em>terrible</em>, but look at all that upfront overhead to get it set
up. and it&#39;s not all that discoverable. and what if you want to reuse
this later, or plug it into some larger pipeline of tools on your
computer, or give it a visual interface? the jump in complexity once
you need to communicate with anything -- possibly setting up a
WebSocket, setting up handlers and a state machine -- is pretty
horrifying)</p>
<p>(but to be honest, I wouldn&#39;t even have conceived of this as a thing I
could do in the first place)</p>
<h3 id="save-text-of-all-tabs-to-a-file">Save text of all tabs to a file</h3>
<pre tabindex="0"><code>$ cat mnt/tabs/by-id/*/text.txt &gt; text-of-all-tabs.txt
</code></pre><h3 id="evaluate-javascript-on-a-page--watch-expressions-demohttpstwittercomrsnousstatus1364008241588363264">Evaluate JavaScript on a page / watch expressions: <a href="https://twitter.com/rsnous/status/1364008241588363264">demo</a></h3>
<p>(was <code>evals</code> in linked demo, is now renamed to <code>watches</code>)</p>
<pre tabindex="0"><code>$ touch mnt/tabs/last-focused/watches/&#39;document.body.style.background = &#34;green&#34;&#39;

$ touch mnt/tabs/last-focused/watches/&#39;alert(&#34;hi!&#34;)&#39;

$ touch mnt/tabs/last-focused/watches/&#39;2 + 2&#39;
$ cat mnt/tabs/last-focused/watches/&#39;2 + 2&#39;
4
</code></pre><pre tabindex="0"><code>$ touch mnt/tabs/last-focused/watches/window.scrollY
</code></pre><p>Now you can <code>cat window.scrollY</code> and see where you are scrolled on the
page at any time.</p>
<p>Could make an <a href="https://twitter.com/rsnous/status/1080878682275803137">ad-hoc
dashboard</a>
around a Web page: a bunch of terminal windows floating around your
screen, each sitting in a loop and using <code>cat</code> to monitor a different
variable.</p>
<h3 id="get-images--scripts--other-resource-files-from-page">Get images / scripts / other resource files from page</h3>
<p>(TODO: <a href="https://github.com/osnr/TabFS/issues/5">document better</a>, put in screenshots)</p>
<p>The <a href="https://github.com/osnr/TabFS/blob/fef9289e3a7f82cda6319d5f19d5a5f13f3cc44b/extension/background.js#L355"><code>debugger/</code>
subdirectory</a>
in each tab folder has synthetic files that let you access loaded
resources (in <code>debugger/resources/</code>) and scripts (in
<code>debugger/scripts/</code>).</p>
<p>Images will show up as actual PNG or JPEG files, scripts as actual JS
files, and so on. (this is experimental.)</p>
<p>(TODO: edit the images in place? you can already kinda edit the
scripts in place)</p>
<h3 id="retrieve-whats-playing-on-youtube-music-youtube-music-tabfshttpsgithubcomjunhoyeoyoutube-music-tabfs">Retrieve what&#39;s playing on YouTube Music: <a href="https://github.com/junhoyeo/youtube-music-tabfs">youtube-music-tabfs</a></h3>
<p><a href="https://www.reddit.com/r/programming/comments/kok4dw/tabfs_mount_your_browser_tabs_as_a_filesystem/ghtbgw1/">thanks</a> to <a href="https://github.com/junhoyeo">Junho Yeo</a>!</p>
<h3 id="reload-an-extension-when-you-edit-its-source-code">Reload an extension when you edit its source code</h3>
<p>Suppose you&#39;re working on a Chrome extension (apart from this
one). It&#39;s a pain to reload the extension (and possibly affected Web
pages) every time you change its code. There&#39;s a <a href="https://stackoverflow.com/questions/2963260/how-do-i-auto-reload-a-chrome-extension-im-developing">Stack Overflow
post</a>
with ways to automate this, but they&#39;re all sort of hacky. You need
yet another extension, or you need to tack weird permissions onto your
work-in-progress extension, and you don&#39;t just get a command you can
trigger from your editor or shell to refresh the extension.</p>
<p>TabFS lets you do all this in <a href="https://github.com/osnr/playgroundize-devtools-protocol/blob/main/go.sh">an ordinary shell
script</a>.
You don&#39;t have to write any browser-side code at all.</p>
<p>This script turns an extension (this one&#39;s title is &#34;Playgroundize
DevTools Protocol&#34;) off, then turns it back on, then reloads any tabs
that have the relevant pages open (in this case, I decided it&#39;s tabs
whose titles start with &#34;Chrome Dev&#34;):</p>
<pre tabindex="0"><code>#!/bin/bash -eux
echo false &gt; mnt/extensions/Playg*/enabled
echo true &gt; mnt/extensions/Playg*/enabled
echo reload | tee mnt/tabs/by-title/Chrome_Dev*/control
</code></pre><p>I mapped this script to Ctrl-. in my text editor, and now I just hit
that every time I want to reload my extension code.</p>
<h3 id="todo-live-edit-a-running-web-page">TODO: Live edit a running Web page</h3>
<p>edit <code>page.html</code> in the tab folder. I guess it could just stomp
outerHTML at first, eventually could do something more sophisticated</p>
<p>then you can use your existing text editor! and you&#39;ll always know
that if the file saved, then it&#39;s up to date in the browser. no flaky
watcher that you&#39;re not sure if it&#39;s working</p>
<p>(it would be cool to have a persistent storage story here
also. I like the idea of being able to put arbitrary files anywhere in
the subtree, actually, because then you could use git and emacs
autosave and stuff for free... hmm)</p>
<h3 id="todo-import-data-json-xls-js">TODO: Import data (JSON? XLS? JS?)</h3>
<p>drag a JSON file <code>foo.json</code> into the <code>imports</code> subfolder of the tab
and it shows up as the object <code>imports.foo</code> in JS. (modify
<code>imports.foo</code> in JS and then read <code>imports/foo.json</code> and you read the
changes back?)</p>
<p>import a plotting library or whatever the same way? dragging
<code>plotlib.js</code> into <code>imports/plotlib.js</code> and then calling
<code>imports.plotlib()</code> to invoke that JS file</p>
<p>the browser has a lot of potential power as an interactive programming
environment, one where graphics come <a href="https://twitter.com/rsnous/status/1295828978477932544">as
naturally</a> as
console I/O do in most programming languages. i think something that
holds it back that is underexplored is lack of ability to just... drag
files in and manage them with decent tools. many Web-based &#39;IDEs&#39; have
to reinvent file management, etc from scratch, and it&#39;s like a
separate universe from the rest of your computer, and migrating
between one and the other is a real pain (if you want to use some
Python library to munge some data and then have a Web-based
visualization of it, for instance, or if you want to version files
inside it, or make snapshots so you <a href="https://twitter.com/rsnous/status/1288725175895068673">feel
comfortable</a>
trying stuff, etc).</p>
<p>(what would the persistent storage story here be? localStorage? it&#39;s
interesting because I almost want each tab to be <a href="https://twitter.com/rsnous/status/1344753559007420416">less of a
commodity</a>,
less
<a href="https://twitter.com/rsnous/status/1270192308772691968">disposable</a>,
since now it&#39;s the site I&#39;m dragging stuff to and it might have some
persistent state attached. like, if I&#39;m programming and editing stuff
and saving inside a tab&#39;s folder, that tab suddenly really
<a href="https://twitter.com/rsnous/status/1251863115022491653">matters</a>; I
want it to survive as long as a normal file would, unlike most browser
tabs today)</p>
<p>(the combination of these last 3 TODOs may be a very powerful, open,
dynamic, flexible programming environment where you can bring whatever
external tools you want to bear, everything is live in your browser,
you never need to restart...)</p>
<h2 id="setup">Setup</h2>
<p><strong>disclaimer</strong>: this extension is an experiment. I think it&#39;s cool and
useful and provocative, and I usually leave it on, but I make no
promises about functionality or, especially, security. applications
may freeze, your browser may freeze, there may be ways for Web pages
to use the extension to escape and hurt your computer ... In some
sense, the <a href="https://twitter.com/rsnous/status/1338932056743546880">whole
point</a> of this
extension is to create a gigantic new surface area of communication
between stuff inside your browser and software on the rest of your
computer.</p>
<p>(The installation process is pretty involved right now. I&#39;d like to
simplify it, but I also don&#39;t want a seamless installation process
that does a bad job of managing people&#39;s expectations. And it&#39;s
important to me that users <a href="https://twitter.com/rsnous/status/1345113873792126976">feel
comfortable</a>
looking at <a href="#design">how TabFS works</a> -- it&#39;s pretty much just two
files! -- and that they can mess around with it; it shouldn&#39;t be a
black box.)</p>
<p>Before doing anything, clone <a href="https://github.com/osnr/TabFS">this repository</a>:</p>
<pre tabindex="0"><code>$ git clone https://github.com/osnr/TabFS.git
</code></pre><p>First, install the browser extension.</p>
<p>Then, install the C filesystem.</p>
<h3 id="1-install-the-browser-extension">1. Install the browser extension</h3>
<h4 id="in-chrome-chromium-and-related-browsers">in Chrome, Chromium, and related browsers</h4>
<p>(including Brave and Vivaldi)</p>
<p>Go to the <a href="chrome://extensions">Chrome extensions page</a>. Enable
Developer mode (top-right corner).</p>
<p>Load-unpacked the <code>extension/</code> folder in this repo.</p>
<p><strong>Make a note of the extension ID Chrome assigns.</strong> Mine is
<code>jimpolemfaeckpjijgapgkmolankohgj</code>. We&#39;ll use this later.</p>
<h4 id="in-safari-wip">in Safari (WIP)</h4>
<p>See <a href="https://github.com/osnr/TabFS/tree/master/extension/safari">the Safari
instructions</a>. You
should compile the C filesystem (as below) before trying to run the extension.</p>
<h4 id="in-firefox">in Firefox</h4>
<p>You&#39;ll need to install as a &#34;temporary extension&#34;, so it&#39;ll only last
in your current FF session. (If you want to install permanently, see
<a href="https://github.com/osnr/TabFS/issues/4#issuecomment-753447380">this
issue</a>.)</p>
<p>Go to <a href="about:debugging#/runtime/this-firefox">about:debugging#/runtime/this-firefox</a>.</p>
<p>Load Temporary Add-on...</p>
<p>Choose manifest.json in the extension subfolder of this repo.</p>
<h3 id="2-install-the-c-filesystem">2. Install the C filesystem</h3>
<p>First, make sure you have FUSE and FUSE headers. On Linux, for example,
<code>sudo apt install libfuse-dev</code> or equivalent. On macOS, get
<a href="https://osxfuse.github.io/">macFUSE</a>. (on macOS, also see <a href="https://github.com/osnr/TabFS/issues/11">this
-bug</a> -- TODO work out the
best path to explain here)</p>
<p>Then compile the C filesystem:</p>
<pre tabindex="0"><code>$ cd fs
$ mkdir mnt
$ make
</code></pre><p>(GNU Make is required, so use gmake on FreeBSD)</p>
<p>Now install the native messaging host into your browser, so the
extension can launch and talk to the filesystem:</p>
<h4 id="chrome-chromium-and-related-browsers">Chrome, Chromium, and related browsers</h4>
<p>Substitute the extension ID you copied earlier for
<code>jimpolemfaeckpjijgapgkmolankohgj</code> in the command below.</p>
<pre tabindex="0"><code>$ ./install.sh chrome jimpolemfaeckpjijgapgkmolankohgj
</code></pre><p>(For Chromium, say <code>chromium</code> instead of <code>chrome</code>. For Vivaldi, say
<code>vivaldi</code> instead. For Brave, say <code>chrome</code>. You can look at the
contents of
<a href="https://github.com/osnr/TabFS/blob/master/install.sh">install.sh</a> for
the latest on browser and OS support.)</p>
<h4 id="safari-wip">Safari (WIP)</h4>
<p>See <a href="https://github.com/osnr/TabFS/tree/master/extension/safari">the Safari
instructions</a>.</p>
<h4 id="firefox">Firefox</h4>
<pre tabindex="0"><code>$ ./install.sh firefox
</code></pre><h3 id="3-ready">3. Ready!</h3>
<p>Go back to <code>chrome://extensions</code> or
<code>about:debugging#/runtime/this-firefox</code> and reload the extension.</p>
<p>Now your browser tabs should be mounted in <code>fs/mnt</code>!</p>
<p>Open the background page inspector to see the filesystem operations
stream in. (in Chrome, click &#34;background page&#34; next to &#34;Inspect views&#34;
in the extension&#39;s entry in the Chrome extensions page; in Firefox,
click &#34;Inspect&#34;)</p>
<p><a href="https://omar.website/tabfs/doc/inspector.png"><img src="https://omar.website/tabfs/doc/inspector.png"/></a>
</p>
<p>This console is also incredibly helpful for debugging anything that
goes wrong, which probably will happen. (If you get a generic I/O
error at the shell when running a command on TabFS, that probably
means that an exception happened which you can check here.)</p>
<p>(My OS and applications are pretty chatty. They do a lot of
operations, even when I don&#39;t feel like I&#39;m actually doing
anything. My sense is that macOS is generally chattier than Linux.)</p>
<h2 id="design">Design</h2>
<ul>
<li><code>fs/</code>: Native FUSE filesystem, written in C
<ul>
<li><a href="https://github.com/osnr/TabFS/tree/master/fs/tabfs.c"><code>tabfs.c</code></a>:
Talks to FUSE, implements fs operations, talks to extension. I
rarely have to change this file; it essentially is just a stub
that forwards everything to the browser extension.</li>
</ul>
</li>
<li><code>extension/</code>: Browser extension, written in JS
<ul>
<li><a href="https://github.com/osnr/TabFS/tree/master/extension/background.js"><code>background.js</code></a>:
<strong>The most interesting file</strong>. Defines all the synthetic files and
what browser operations they invoke behind the scenes.<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></li>
</ul>
</li>
</ul>
<p>My understanding is that when you, for example, <code>cat mnt/tabs/by-id/6377/title.txt</code> in the tab filesystem:</p>
<ol>
<li>
<p><code>cat</code> on your computer does a system call <code>open()</code> down into macOS
or Linux,</p>
</li>
<li>
<p>macOS/Linux sees that this path is part of a FUSE filesystem, so it
forwards the <code>open()</code> to the FUSE kernel module,</p>
</li>
<li>
<p>FUSE forwards it to the <code>tabfs_open</code> implementation in our
userspace filesystem in <code>fs/tabfs.c</code>,</p>
</li>
<li>
<p>then <code>tabfs_open</code> rephrases the request as a JSON string and
forwards it to our browser extension over stdout (<a href="https://developer.chrome.com/docs/apps/nativeMessaging/">&#39;native
messaging&#39;</a>),</p>
</li>
<li>
<p>our browser extension in <code>extension/background.js</code> gets the
incoming message; it triggers the route for
<code>/tabs/by-id/*/title.txt</code>, which calls the browser extension API
<code>browser.tabs.get</code> to get the data about tab ID <code>6377</code>, including
its title,</p>
</li>
<li>
<p>so when <code>cat</code> does <code>read()</code> later, the title can get sent back in
a JSON native message to <code>tabfs.c</code> and finally back to FUSE and the
kernel and <code>cat</code>.</p>
</li>
</ol>
<p>(very little actual work happened here, tbh. it&#39;s all just
marshalling)</p>
<p>TODO: make diagrams?</p>
<h2 id="license">License</h2>
<p>GPLv3</p>

<p>Thanks to <a href="https://github.com/sponsors/osnr">all the project sponsors</a>. Special
thanks to:</p>
<p><a href="https://oss.capital/"><img src="https://omar.website/tabfs/oss-capital.png"/></a></p>
<h2 id="things-that-couldshould-be-done">things that could/should be done</h2>
<p>(maybe you can do these? lots of people are <a href="https://github.com/osnr/TabFS">already pitching in on
GitHub</a>; I wish it was easier for me to
keep up listing them all here!)</p>
<ul>
<li>
<p><a href="https://twitter.com/rsnous/status/1345113873792126976">add more synthetic files!! (it&#39;s just
JavaScript)</a>
view DOM nodes, snapshot current HTML of page, spelunk into living
objects. see what your code is doing. make more files writable also</p>
</li>
<li>
<p>build more (GUI and CLI) tools on top, on both sides</p>
</li>
<li>
<p>more persistence stuff. as I said earlier, it would also be cool if
you could put arbitrary files in the subtrees, so .git, Mac extended
attrs, editor temp files, etc all work. make it able to behave like
a &#39;real&#39; filesystem. also as I said earlier, some weirdness in the
fact that tabs are so disposable; they have a very different
lifecycle from most parts of my real filesystem. how to nudge that?</p>
</li>
<li>
<p>why can&#39;t Preview open images? GUI programs often struggle with the
filesystem for some reason. CLI more reliable</p>
</li>
<li>
<p><del>multithreading. the key constraint is that I pass <code>-s</code> to
<code>fuse_main</code> in <code>tabfs.c</code>, which makes everything
single-threaded. but I&#39;m not clear on how much it would improve
performance? maybe a lot, but not sure. maybe workload-dependent?</del></p>
<p><del>the extension itself (and the stdin/stdout comm between the fs
and the extension) would still be single-threaded, but you could
interleave requests since most of that stuff is async. like the
screenshot request that takes like half a second, you could do other
stuff while waiting for the browser to get back to you on that (?)</del>
<em>update: <a href="https://github.com/osnr/TabFS/pull/29">we are
multithreaded</a> now, thanks to
<a href="https://github.com/huglovefan">huglovefan</a>!</em></p>
<p>another issue is that <em>applications</em> tend to hang if any
individual request hangs anyway; they&#39;re not expecting the
filesystem to be so slow (and to be fair to them, they really have
<a href="https://twitter.com/whitequark/status/1133905587819941888">no way</a>
to). some of these problems may be inevitable for any FUSE
filesystem, even ones you&#39;d assume are reasonably battle-tested and
well-engineered like sshfs?</p>
</li>
<li>
<p>other performance stuff -- remembering when we&#39;re already attached
to things, reference counting, minimizing browser roundtrips. not
sure impact of these</p>
</li>
<li>
<p>TypeScript (how to do with the minimum amount of build system and
package manager nonsense?) (now realizing that if I had gone with
TypeScript, I would then have to ask people to install npm and
webpack and the TS compiler and whatever just to get this
running. really, really glad I didn&#39;t.) maybe we can just do dynamic
type checking at the fs op call boundaries?</p>
</li>
<li>
<p><a href="https://github.com/osnr/TabFS/issues?q=is%3Aopen+is%3Aissue+label%3Aport">look into support for Firefox / Windows / Safari /
etc.</a>
best FUSE equiv for Windows? can you bridge to the remote debugging
APIs that all of them already have to get the augmented
functionality? or just implement it all with JS monkey patching?</p>
</li>
<li>
<p>window management. tab management where you can move tabs. &#39;merge
all windows&#39;. <a href="https://anildash.com/2021/01/03/keeping-tabs-on-your-abstractions/">history management</a></p>
</li>
</ul>
<h2 id="hmm">hmm</h2>
<ul>
<li>
<p><a href="https://lucasvr.gobolinux.org/etc/Killian84-Procfs-USENIX.pdf">Processes as Files
(1984)</a>,
<a href="https://drawings.jvns.ca/proc/">Julia Evans /proc comic</a> lay out the
original <code>/proc</code> filesystem. it&#39;s very cool!  very elegant in how it
reapplies the existing interface of files to the new domain of Unix
processes. but how much do I care about Unix processes now? most
<a href="https://twitter.com/rsnous/status/1176587656915849218">programs</a> that
I care about running on my computer these days are Web pages, <a href="https://twitter.com/rsnous/status/1076229968017772544">not
Unix
processes</a>. so
I want to take the approach of <code>/proc</code> -- &#39;expose the stuff you care
about as a filesystem&#39; -- and apply it to something
<a href="https://twitter.com/rsnous/status/1251342095698112512">modern</a>: the
inside of the browser. &#39;browser tabs as files&#39;</p>
</li>
<li>
<p>there are two &#39;operating systems&#39; on my computer, the browser and
Unix, and Unix is by far the more accessible and programmable and
cohesive as a computing environment (it has concepts that compose!
shell, processes, files), even though it&#39;s arguably the less important
to my daily life. <a href="https://twitter.com/jcreed/status/1344982366243213312">how can the browser take on more of the properties
of Unix?</a></p>
</li>
<li>
<p>it&#39;s <a href="https://twitter.com/rsnous/status/1342236988938719232">way too
hard</a> to make a
browser extension. even &#39;make an extension&#39; is a bad framing; it
suggests making an extension is a whole Thing, a whole Project. like,
why can&#39;t I just take a minute to ask my browser a question or tell it
to automate something? lightness</p>
</li>
<li>
<p>&#34;files are a sort of approachable &#39;bridge&#39; that everyone knows how
to interact with&#34; / files are like one of the first things you learn
if you know any programming language / <a href="https://twitter.com/rsnous/status/1345490658836926464">&#34;because of this fs thing any
beginner coding thing can make use of it now&#34;</a></p>
</li>
<li>
<p>a lot of existing uses of these browser control APIs are in an
automation context: testing your code on a robotic browser as part
of some pipeline. I&#39;m much more interested in an interactive,
end-user context. augmenting the way I use my everyday
browser. that&#39;s why this is an extension. it doesn&#39;t require your
browser to run in some weird remote debugging mode that you&#39;d always
forget to turn on. it just <a href="https://twitter.com/rsnous/status/1340150818553561094">stays
running</a></p>
</li>
<li>
<p><a href="https://jvns.ca/strace-zine-v2.pdf">system call tracing</a> (dtruss or
strace) super useful when anything is going wrong. (need to disable
SIP on macOS, though.)  the combination of dtruss (application side)
&amp; console logging fs request/response (filesystem side) gives a huge
amount of insight into basically any problem, end to end</p>
<ul>
<li>there is sort of this sequence that I learned to try with
anything. first, either simple shell commands or pure C calls --
shell commands are more ergonomic, C calls have the clearest
mental model of what syscalls they actually invoke. only then do
you move to the text editor or the Mac Finder, which are a lot
fancier and throw a lot more stuff at the filesystem at once (so
more can go wrong)</li>
</ul>
</li>
<li>
<p>for a lot of things in the extension API, the browser can notify you
of updates but there&#39;s no apparent way to query the full current
state. so we&#39;d need to sit in a lot of these places from the
beginning and accumulate the incoming events to know, like, the last
time a tab was updated, or the list of scripts currently running on
a tab</p>
</li>
<li>
<p>async/await was absolutely vital to making this readable</p>
</li>
<li>
<p>filesystem as &#39;open input space&#39; where there are things you can say
beyond what this particular filesystem cares about. (it reminds me
of my <a href="https://screenotate.com">Screenotate</a> -- screenshots give you
this open field where you can <a href="https://twitter.com/rsnous/status/1221687986510680064">carry
through</a>
stuff that the OCR doesn&#39;t necessarily recognize or care about. same
for the real world in Dynamicland; you can scribble notes or
whatever even if the computer doesn&#39;t see them)</p>
</li>
<li>
<p>now you have this whole &#39;language&#39;, this whole toolset, to control
and automate your browser. there&#39;s this built-up existing capital
where lots of people and lots of application software and lots of
programming languages ... already know the operations to work with
files</p>
</li>
<li>
<p>this project is cool bc i immediately get <a href="https://twitter.com/rsnous/status/1084166291793965056">a dataset i care
about</a>. I
found myself using it &#39;authentically&#39; pretty quickly -- to clear out
my tabs, to help me develop other things in the browser so I&#39;d have
actions I could trigger from my editor, ...</p>
</li>
<li>
<p>stuff that looks cool / is related:</p>
<ul>
<li>
<p><a href="https://www.sqlite.org/vtablist.html">SQLite virtual tables</a>
have some of the same energy as FUSE synthetic filesystems to
me, except instead of &#39;file operations&#39;, &#39;SQL&#39; is the well-known
interface / knowledge base / ecosystem that they
<a href="https://twitter.com/rsnous/status/1237986368812224513">piggyback</a>
on. <a href="https://osquery.readthedocs.io/en/stable/">osquery</a> seems
particularly cool</p>
</li>
<li>
<p>Plan 9. I think a lot about <a href="https://mostlymaths.net/2013/03/extensibility-programming-acme-text-editor.html/">extensibility in the Acme text
editor</a>,
where
<a href="https://twitter.com/geoffreylitt/status/1265384495542415360">instead</a>
of a &#39;plugin API&#39;, the editor just provides a synthetic
filesystem</p>
</li>
<li>
<p>my <a href="https://www.youtube.com/watch?v=pfHpDDXJQVg">fake filesystems talk</a></p>
</li>
<li>
<p><a href="https://luciopaiva.com/witchcraft/">Witchcraft</a> has the right
idea for how to set up userscripts. just make files -- don&#39;t
make <a href="https://twitter.com/rsnous/status/1196536798312140800">your own weird UI to add and remove
them</a>. (I
guess there is a political or audience
<a href="https://twitter.com/rsnous/status/1290031845363466242">tradeoff</a>
here, where <a href="https://twitter.com/rsnous/status/1039036578427891713">some
kinds</a> of
users might be comfortable with managing files, but you might
alienate others. hmm)</p>
</li>
</ul>
</li>
<li>
<p><a href="https://twitter.com/rsnous/status/1107427906832089088">rmdir a non-empty
directory</a>
-- when I was thinking if you should be able to <code>rm by-id/TABID</code>
even though <code>TABID</code> is a folder. I feel like a new OS, something
like Plan 9, should
<a href="https://twitter.com/rsnous/status/1070830656005988352">generalize</a>
its file I/O APIs just enough to avoid problems like this. like
design them with the disk in mind but also a few concrete cases of
synthetic filesystems, very slow remote filesystems, etc</p>
</li>
</ul>
<p>do you like setting up sockets? I don&#39;t</p>


    </div></div>
  </body>
</html>
