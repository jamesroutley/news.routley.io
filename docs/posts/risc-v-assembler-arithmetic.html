<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://projectf.io/posts/riscv-arithmetic/">Original</a>
    <h1>RISC-V Assembler: Arithmetic</h1>
    
    <div id="readability-page-1" class="page"><div><article><header><p>Published
<time>15 Jan 2024</time>
<span>¬∑</span>
<span>Updated
<time>01 Feb 2024</time></span></p></header><section><blockquote><p>‚ÄúRISC architecture is going to change everything.‚Äù ‚Äî <a href="https://tvtropes.org/pmwiki/pmwiki.php/Film/Hackers">Acid Burn</a></p></blockquote><p>In the last few years, we‚Äôve seen an explosion of RISC-V CPU designs, especially on FPGA. Thankfully, RISC-V is ideal for assembly programming with its compact, easy-to-learn instruction set. This mini-series will help you learn and understand 32-bit RISC-V instructions (RV32) and the RISC-V ABI. The first part looks at load immediate, addition, and subtraction. We‚Äôll also cover sign extension and pseudoinstructions. These instructions are included in <strong>RV32I</strong>, the base integer instruction set.</p><p>Share your thoughts with @WillFlux on <a href="https://mastodon.social/@WillFlux">Mastodon</a> or <a href="https://twitter.com/WillFlux">Twitter</a>. If you like what I do, <a href="https://github.com/sponsors/WillGreen">sponsor me</a>. üôè</p><h2 id="cpu-registers">CPU Registers</h2><p>The base integer instruction set (RV32I) has 32 x 32-bit registers: <strong>x0</strong> to <strong>x31</strong>.</p><p><strong>x0</strong> is hard-wired to <strong>0</strong>. Use the other registers as you see fit, but there is an <strong>ABI</strong> (application binary interface) that makes life easier for programmers. My examples use the temporary registers <strong>t0-t6</strong>. I‚Äôll explain the ABI registers in an upcoming post, but you can see a list in <a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md#general-registers">RISC-V ABI registers</a>.</p><p>It‚Äôs simple to load an immediate (constant) value into a register with load immediate:</p><p><code>rd</code> is the destination register, and <code>imm</code> is a 32-bit immediate.</p><p>Load immediate examples:</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>li</span> <span>t0</span>, <span>2</span>
</span></span><span><span><span>li</span> <span>t1</span>, <span>42</span>
</span></span><span><span><span>li</span> <span>t2</span>, -<span>1</span>
</span></span><span><span><span>li</span> <span>t3</span>, <span>0x100000</span>
</span></span><span><span><span>li</span> <span>t4</span>, <span>4100</span>
</span></span><span><span><span>li</span> <span>t5</span>, <span>0xFACE</span>
</span></span></code></pre></div><p><em>ProTip: Hexadecimal literals are prefixed with <strong>0x</strong>.</em></p><h3 id="pseudoinstructions">Pseudoinstructions</h3><p>RISC-V registers are 32 bits wide. RISC-V instructions are 32 bits wide. An instruction needs room for an opcode and registers, so it can‚Äôt hold a 32-bit immediate. How does <strong>li</strong> manage it? Load immediate is not a RISC-V instruction but a <strong>pseudoinstruction</strong>.</p><p>Pseudoinstructions are translated into one or more real instructions by the assembler. Pseudoinstructions are syntactic sugar that makes assembly code easier to write <em>and</em> easier to understand. We‚Äôll see many examples in this series, and you can see a complete list in <a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md#-a-listing-of-standard-risc-v-pseudoinstructions">standard RISC-V pseudoinstructions</a>.</p><p>Don‚Äôt worry if this doesn‚Äôt make sense right now. We‚Äôll come back to load immediate once we‚Äôve discussed RISC-V arithmetic.</p><h2 id="addition">Addition</h2><p>RISC-V has two add instructions: for adding registers together and adding an immediate to a register.</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>add</span>  <span>rd</span>, <span>rs1</span>, <span>rs2</span>  <span># rd = rs1 + rs2
</span></span></span><span><span><span></span><span>addi</span> <span>rd</span>, <span>rs</span>, <span>imm</span>   <span># rd = rs + imm
</span></span></span></code></pre></div><p>Where <code>rd</code> is the destination register, <code>rs rs1 rs2</code> are source registers, and <code>imm</code> is a 12-bit immediate.</p><p>Examples of adding registers:</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>li</span>  <span>t0</span>, <span>2</span>       <span># t0 =  2
</span></span></span><span><span><span></span><span>li</span>  <span>t1</span>, <span>46</span>      <span># t1 = 46
</span></span></span><span><span><span></span><span>li</span>  <span>t2</span>, <span>10</span>      <span># t2 = 10
</span></span></span><span><span><span></span>
</span></span><span><span><span>add</span> <span>t3</span>, <span>t0</span>, <span>t0</span>  <span># t3 =  2 +  2 =  4
</span></span></span><span><span><span></span><span>add</span> <span>t4</span>, <span>t0</span>, <span>t1</span>  <span># t4 =  2 + 46 = 48
</span></span></span><span><span><span></span><span>add</span> <span>t4</span>, <span>t4</span>, <span>t2</span>  <span># t4 = 48 + 10 = 58  ; t4 is a source and the destination
</span></span></span></code></pre></div><p>Examples of adding an immediate to a register:</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>li</span>   <span>t0</span>, <span>48</span>       <span># t0 = 48
</span></span></span><span><span><span></span>
</span></span><span><span><span>addi</span> <span>t1</span>, <span>t0</span>,   <span>1</span>  <span># t1 = 48 + 1  = 49  ; increment
</span></span></span><span><span><span></span><span>addi</span> <span>t2</span>, <span>t0</span>,  -<span>1</span>  <span># t2 = 48 - 1  = 47  ; decrement
</span></span></span><span><span><span></span>
</span></span><span><span><span>addi</span> <span>t3</span>, <span>t0</span>,  <span>12</span>  <span># t3 = 48 + 12 = 60
</span></span></span><span><span><span></span><span>addi</span> <span>t4</span>, <span>t0</span>, -<span>12</span>  <span># t4 = 48 - 12 = 36
</span></span></span><span><span><span></span><span>addi</span> <span>t4</span>, <span>t4</span>,  <span>32</span>  <span># t4 = 36 + 32 = 68  ; t4 is the source and destination
</span></span></span></code></pre></div><p><strong>addi</strong> can add an immediate value in the range -2048 to 2047. RISC-V has no increment or decrement instructions; <strong>addi</strong> handles them too.</p><p>Not content with addition and subtraction, addi is also behind two common pseudoinstructions:</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>mv</span>  <span>rd</span>, <span>rs</span>  <span># rd = rs
</span></span></span><span><span><span></span><span>nop</span>         <span># no operation
</span></span></span></code></pre></div><p>The <strong>mv</strong> (move) instruction copies one register to another. <strong>mv</strong> is <strong>addi</strong> with an immediate value of 0, so nothing is added. The move instruction can only copy between registers, it can‚Äôt access memory.</p><p>Move example (note the destination is the first register given):</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span># these two examples generate the same machine code
</span></span></span><span><span><span></span><span>mv</span>   <span>t0</span>, <span>t1</span>     <span># t0 = t1
</span></span></span><span><span><span></span><span>addi</span> <span>t0</span>, <span>t1</span>, <span>0</span>  <span># t0 = t1 + 0
</span></span></span></code></pre></div><p>The <strong>nop</strong> instruction advances the program counter but makes no other changes. We have a standard <strong>nop</strong> encoding to make programmer intent clear and avoid the instruction being optimised away.</p><h3 id="sign-extension">Sign Extension</h3><p>RISC-V immediates are sign-extended. The most significant bit (MSB) fills the remaining bits to create a 32-bit value. A 12-bit RISC-V immediate can represent -2048 to 2047 inclusive.</p><p>Sign extension of -2047 decimal (MSB=1):</p><p><code>1000 0000 0000 -&gt; 1111 1111 1111 1111 1111 1000 0000 0000</code></p><p>Sign extension of 1033 decimal (MSB=0):</p><p><code>0100 0000 1001 -&gt; 0000 0000 0000 0000 0000 0100 0000 1001</code></p><p>Using a signed immediate, we can add and subtract with <strong>addi</strong> (see examples above) or jump forwards or backwards in our code (discussed in a later post).</p><p>RISC-V‚Äôs designers made several small decisions that have an oversized impact on the simplicity and power of the instruction set: sign extending immediates is one of them.</p><h2 id="subtraction">Subtraction</h2><p>The <strong>sub</strong> instruction subtracts registers. Subtracting an immediate is handled by <strong>addi</strong> (above).</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>sub</span> <span>rd</span>, <span>rs1</span>, <span>rs2</span>  <span># rd = rs1 - rs2
</span></span></span><span><span><span></span><span>neg</span> <span>rd</span>, <span>rs</span>        <span># rd = -rs (pseudoinstruction)
</span></span></span></code></pre></div><p>The <strong>neg</strong> pseudoinstruction negates a register value: positive numbers become negative and vice-versa. Negate only takes one source register because it uses <strong>sub</strong> with the zero register <strong>x0</strong> as the first source.</p><p>Subtraction examples:</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>li</span>  <span>t0</span>, <span>2</span>       <span># t0 =  2
</span></span></span><span><span><span></span><span>li</span>  <span>t1</span>, <span>46</span>      <span># t1 = 46
</span></span></span><span><span><span></span><span>li</span>  <span>t2</span>, <span>10</span>      <span># t2 = 10
</span></span></span><span><span><span></span>
</span></span><span><span><span>sub</span> <span>t3</span>, <span>t1</span>, <span>t0</span>  <span># t3 = 46 -  2 = 44
</span></span></span><span><span><span></span><span>sub</span> <span>t4</span>, <span>t0</span>, <span>t2</span>  <span># t4 =  2 - 10 = -8
</span></span></span><span><span><span></span>
</span></span><span><span><span># these two examples generate the same machine code
</span></span></span><span><span><span></span><span>neg</span> <span>t5</span>, <span>t0</span>      <span># t5 = -2
</span></span></span><span><span><span></span><span>sub</span> <span>t6</span>, <span>x0</span>, <span>t0</span>  <span># t6 = 0 - 2 = -2  ; The x0 register is always zero
</span></span></span></code></pre></div><p><em>ProTip: the destination register comes first in RISC-V assembler.</em></p><p>Load upper immediate sets the upper 20 bits of a register with an immediate value and zeros the lower 12 bits. Another way of looking at <strong>lui</strong> is that it left shifts the immediate by 12 bits.</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>lui</span> <span>rd</span>, <span>imm</span>      <span># rd = imm &lt;&lt; 12
</span></span></span></code></pre></div><p>This is best seen with some examples:</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>lui</span> <span>t0</span>, <span>1</span>       <span># t0 = 1 &lt;&lt; 12 = 0x1000 = 4096
</span></span></span><span><span><span></span><span>lui</span> <span>t1</span>, <span>3</span>       <span># t1 = 3 &lt;&lt; 12 = 0x3000 = 12288
</span></span></span><span><span><span></span><span>lui</span> <span>t2</span>, <span>0x100</span>   <span># t2 = 0x100 &lt;&lt; 12 = 0x100000 = 1048576
</span></span></span></code></pre></div><p><strong>lui</strong> accepts immediates in the range 0x00000-0xFFFFF.</p><p>Your assembler will error if you use numbers outside this range, including negative numbers.</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>lui</span> <span>t0</span>, <span>0x100000</span>  <span># 21-bit value is out of range!
</span></span></span><span><span><span></span><span>lui</span> <span>t1</span>, -<span>1</span>        <span># negative value is out of range!
</span></span></span></code></pre></div><p>If out of range, GNU assembler returns <code>Error: lui expression not in range 0..1048575</code></p><p>Now we‚Äôve met <strong>addi</strong> and <strong>lui</strong>, we‚Äôre ready to deconstruct <strong>li</strong>.</p><p>Load upper immediate <strong>lui</strong> sets the upper 20 bits and add immediate <strong>addi</strong> adds a 12-bit immediate. Together these two instructions can load a 32-bit immediate into a register.</p><p>Let‚Äôs see how the assembler does this for our earlier <strong>li</strong> examples:</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>li</span> <span>t0</span>, <span>2</span>
</span></span><span><span><span>li</span> <span>t1</span>, <span>42</span>
</span></span><span><span><span>li</span> <span>t2</span>, -<span>1</span>
</span></span><span><span><span>li</span> <span>t3</span>, <span>0x100000</span>  <span># hexadecimal literal
</span></span></span><span><span><span></span><span>li</span> <span>t4</span>, <span>4100</span>
</span></span><span><span><span>li</span> <span>t5</span>, <span>0xFACE</span>
</span></span></code></pre></div><p>The first three examples fit into 12 bits, so they only need <strong>addi</strong>:</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>addi</span> <span>t0</span>, <span>x0</span>, <span>2</span>
</span></span><span><span><span>addi</span> <span>t1</span>, <span>x0</span>, <span>42</span>
</span></span><span><span><span>addi</span> <span>t2</span>, <span>x0</span>, -<span>1</span>
</span></span></code></pre></div><p>Remember that the <strong>x0</strong> register is hard-wired to 0 (zero).</p><p>The <code>t3</code> (0x100000) example fits in the upper 20 bits, so it only needs <strong>lui</strong>:</p><p>The <code>t4</code> (4100) example is a little too large for 12 bits, so we need <strong>lui</strong> followed by <strong>addi</strong>:</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>lui</span>  <span>t4</span>, <span>0x1</span>
</span></span><span><span><span>addi</span> <span>t4</span>, <span>t4</span>, <span>4</span>
</span></span></code></pre></div><p>The <code>t5</code> (0xFACE) example is a sneaky one:</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>lui</span>  <span>t5</span>, <span>0x10</span>
</span></span><span><span><span>addi</span> <span>t5</span>, <span>t5</span>, -<span>1330</span>
</span></span></code></pre></div><p>The obvious answer of adding 0xACE to 0xF won‚Äôt work because <strong>addi</strong> sign extends the 12-bit immediate. Looking at 0xACE in binary, we see the most significant bit is 1:</p><p><code>1010 1100 1110 -&gt; 1111 1111 1111 1111 1111 1010 1100 1110</code></p><p>The result of the sign extension is negative: -1330 (-0x532).</p><p><code>0xF000 - 0x532 = 0xEACE</code></p><p>To correct for the sign extension, we need to add 1 to the <strong>lui</strong> immediate, thus <code>lui t5, 0x10</code>.</p><p>Any 12-bit immediate whose most significant bit is 1 will suffer from this issue.</p><p>However, the solution is simple: use <strong>li</strong> and the assembler will take care of it for you. :)</p><h2 id="whats-next">What‚Äôs Next?</h2><p>I hope you enjoyed this first instalment. The next part of <em>RISC-V Assembler</em> covers <a href="https://projectf.io/posts/riscv-logical">logical instructions</a>.</p><p>Check out my <a href="https://projectf.io/tutorials/">FPGA &amp; RISC-V Tutorials</a> and my series on early <a href="https://systemtalk.org/post/macintosh-history-8510/">Macintosh History</a>.</p><h3 id="acknowledgements">Acknowledgements</h3><p>Thanks to <a href="https://mastodon.social/@jtruk">jtruk</a> and <a href="http://danielmangum.com">Daniel Mangum</a> for suggestions and corrections.</p><h3 id="references">References</h3><ul><li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Technical Specifications</a> (riscv.org)</li></ul></section></article></div><div><p><a href="https://projectf.io">Project F</a>: A little oasis for FPGA and RISC-V design.
¬© 2024 Will Green.</p></div></div>
  </body>
</html>
