<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://without.boats/blog/a-four-year-plan/">Original</a>
    <h1>A four year plan for async Rust</h1>
    
    <div id="readability-page-1" class="page"><section><p>Four years ago today, the Rust async/await feature was released in version 1.39.0. The announcement
<a href="https://blog.rust-lang.org/2019/11/07/Async-await-stable.html">post</a> says that “this work has been a long time in development – the key
ideas for zero-cost futures, for example, were first proposed by Aaron Turon and Alex Crichton in
2016”. It’s now been longer since the release of async/await than the time between the first design
work that underlies async/await. Despite this, and despite the fact that async/await syntax was
explicitly shipped as a “minimum viable product,” the Rust project has shipped almost no extensions
to async/await in the four years since the MVP was released.</p><p>This fact has been noticed, and I contend it is the primary controllable reason that async Rust has
developed a negative reputation (other reasons, like its <a href="https://without.boats/blog/why-async-rust">essential complexity</a>, are
not in the project’s control). It’s encouraging to see project leaders like Niko Matsakis
<a href="https://smallcultfollowing.com/babysteps/blog/2023/10/14/eurorust-reflections/">recognize</a> the problem as well. I want to outline the features that I think async Rust needs
to consider improve its user experience. I’ve organized these features into features that I think
the project could ship in the short term (say, in the next 18 months), to those that will take
longer (up to three years), and finally a section on a potential change to the language that I think
would take years to plan and prepare for.</p><p>These features are all features that I believe the Rust project would be able to ship within the
next year or two. They all require relatively small changes to the compiler, because they depend on
abstractive capabilities that are already implemented, and they involve relatively small changes to
the surface syntax, largely new syntax implied already by the existing syntax. I think these are the
things the project should focus its attention on, because they should be easier to ship and easier
to build a consensus around.</p><h2 id="asynciterator-and-async-generators">AsyncIterator and async generators</h2><p>I’ve <a href="https://without.boats/blog/patterns-and-abstractions">harped on</a> the importance of generators to Rust repeatedly in the past, so I won’t
devote a lot of attention here. I’ve also highlighted before that the original plan for iterators
<a href="https://web.archive.org/web/20140716172928/https://mail.mozilla.org/pipermail/rust-dev/2013-June/004599.html">included</a> shipping generator syntax. Briefly, my opinion is that the absence of generators
has left Rust in a confused state, in which the relationship between asynchrony and iteration is
unclear (I elaborate more in my linked blog post). I want to focus specifically on <em>async</em> iterators
and <em>async</em> generators, and the features that are needed to complete these.</p><p>An async generator is a natural transformation from a generator: just like functions, generators
can be marked async, and now you can use the await operator inside of them. Using my preferred
syntax, this would look something like this:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>async</span><span> </span><span>gen</span><span> </span><span>fn</span> <span>sum_pairs</span><span>(</span><span>rx</span>: <span>Receiver</span><span>&lt;</span><span>i32</span><span>&gt;</span><span>)</span><span> </span><span>yields</span><span> </span><span>i32</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>left</span><span> </span><span>=</span><span> </span><span>rx</span><span>.</span><span>next</span><span>().</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>right</span><span> </span><span>=</span><span> </span><span>rx</span><span>.</span><span>next</span><span>().</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>yield</span><span> </span><span>left</span><span> </span><span>+</span><span> </span><span>right</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The composition of these features falls out naturally from these syntaxes. Unlike a generator, an
async generator compiles to an <code>AsyncIterator</code>.</p><p>There is one other piece of syntax that is needed: <code>for await</code> loops. These can be called from
within any async context, and consume items from the <code>AsyncIterator</code>, yielding control when the
<code>AsyncIterator</code> yields pending:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>for</span><span> </span><span>await</span><span> </span><span>item</span><span> </span><span>in</span><span> </span><span>async_iter</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34;</span><span>{}</span><span>&#34;</span><span>,</span><span> </span><span>item</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>When I was working on async Rust, this syntax was held up on two different design tangents. On the
one hand, Taylor Cramer thought that the feature was a poor choice because users should instead be
using <code>for_each_concurrent</code>, to get some concurrency. I do not agree with that: it’s not always the
case that users want to use <code>for_each_concurrent</code>, adding more internal concurrency to your async
function is a decision that needs to be considered with care, and there should be an obvious syntax
for when you don’t want that, which <code>for await</code> is. On the other hand, there was some speculation
about making “await patterns” that destructure futures and then somehow making that work here; I
think this would imprudent and leaving await as an expression, and <code>for await</code> as a special
expression for handling <code>AsyncIterator</code>, is the most sensible choice.</p><p>Revisiting the table from my previous blog post, you could add this column for async iteration:</p><table><thead><tr><th></th><th>Asynchronous Iteration</th></tr></thead><tbody><tr><td><strong>Context</strong></td><td><code>async gen</code></td></tr><tr><td><strong>Effect</strong> (iteration)</td><td><code>yield</code></td></tr><tr><td><strong>Forward</strong> (asynchrony)</td><td><code>await</code></td></tr><tr><td><strong>Complete</strong> (iteration)</td><td><code>for await</code></td></tr></tbody></table><p>The biggest thing blocking this is an issue on the library side: how should the <code>AsyncIterator</code>
interface be expressed. I’ve already <a href="https://doc.rust-lang.org/std/async_iter/trait.AsyncIterator.html">written</a> about my preference for stabilizing
<code>AsyncIterator</code> as-is, with the <code>poll_next</code> method. This remains a subject of some controversy,
so I will return to it, but not in this post.</p><p>For now I’ll just say that I think the failure to stabilize <code>AsyncIterator</code> over the past 4 years
(which was absolutely not our intention when we planned the async MVP) has been harmful to async
Rust, because APIs based on async iteration have been relegated to unstable features and
side-libraries, leaving users confused and poorly supported when they need to deal with repetitious
asynchronous events, a very common pattern. The single best thing the Rust project could do for
users is stabilize <code>AsyncIterator</code> so the ecosystem can build on it, and it could do that tomorrow.</p><p>The good news is that work is already <a href="https://github.com/rust-lang/rfcs/pull/3513">underway</a> on reserving the <code>gen</code> keyword in the next
edition, so that generators could be implemented. This feature is using the same state machine
transform that async functions already use, and by analogy should be feasible to implement without
big changes to the compiler. The only big unresolved questions with generators (and which doesn’t
apply to async generators, if <code>AsyncIterator</code> is stabilized as is) is how to make them
self-referential. I’ll return to that question later in this post.</p><h2 id="coroutine-methods">Coroutine methods</h2><p>Orthogonal to the introduction of these additional kinds of coroutines is their integration into the
trait system. Right now, you cannot define an async trait method in stable Rust. The good news is
that this is changing, and in a soon-to-be-released version of Rust, it will be possible to write an
async trait method. As other coroutines, generators and async generators should not require any
special support to use them in traits that wasn’t already implemented for async functions. So when
generators and async generators are implemented and stabilized, they should be supported as methods
out of the box.</p><p>The only thing that remains to be implemented for coroutine methods is the concept of “Return Type
Notation” (or RTN). The problem is that adding a coroutine method to a trait adds an anonymous
associated type to that trait, which is the return type of that method. Sometimes (most importantly:
when spawning that method in a task on a work-stealing executor or otherwise moving it to another
thread) users need to add additional bounds to that anonymous associated type. So Rust needs some
syntax for declaring that. This is RTN. For example:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>trait</span><span> </span><span>Foo</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>async</span><span> </span><span>fn</span> <span>foo</span><span>(</span><span>&amp;</span><span>self</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// later:
</span></span></span><span><span><span></span><span>where</span><span> </span><span>F</span>: <span>Foo</span><span> </span><span>+</span><span> </span><span>Send</span><span>,</span><span>
</span></span></span><span><span><span>      </span><span>F</span>::<span>foo</span><span>()</span>: <span>Send</span>
</span></span></code></pre></div><p>In my opinion, it is important to ship RTN because of a design principle I call the “Can you fix
it?” principle. If an upstream dependency of yours has an async method, and you need to add a <code>Send</code>
bound to the return type, can you fix it, or do you need to fork the library? Without the ability to
add RTN bounds to where clauses, you cannot express the bounds that you require without changing the
upstream code, even if your code is all perfectly valid (i.e. even if the async method you want to
call <em>is</em> <code>Send</code>). It’s very frustrating for users to encounter a problem in which their code should
compile fine, but the only way to satisfy the compiler is to fork a dependency.</p><p>Fortunately, the project is already focusing on this feature, and I expect it to be shipped in the
next year. There seems to be some discussion around the exact syntax for this feature: I would
encourage contributors not to be too obstinate over syntax differences that don’t substantially
change the feature.</p><h2 id="coroutine-closures">Coroutine closures</h2><p>Another aspect of Rust’s language design in which coroutines are currently not well-supported is
closures. Niko Matsakis has explored this issue in two recent blog posts, focusing only on async
closures and not on generative or asynchronously generative closures. In the <a href="https://smallcultfollowing.com/babysteps/blog/2023/03/29/thoughts-on-async-closures/">first</a>, he
proposed treating async closures as a new hierarchy of function traits (i.e. adding <code>AsyncFn</code>,
<code>AsyncFnMut</code>, and <code>AsyncFnOnce</code>). In the <a href="https://smallcultfollowing.com/babysteps/blog/2023/05/09/giving-lending-and-async-closures/">second</a>, he instead explores the idea of modeling
async closures as closures returning <code>impl Future</code> (e.g. <code>F: Fn() -&gt; impl Future</code>).</p><p>I prefer the second approach, because it does not result in a proliferation of more traits. This
becomes especially apparent when you consider generative closures and asynchronously generative
closures: if the function trait for each of these things were distinct, instead of 3 function
traits, Rust would have 12. In contrast, by modeling coroutine closures as closures returning an
<code>impl Trait</code>, no new traits are needed. It has the additional benefit that it involves modeling
them in the exact way that Rust already desugars normal async functions.</p><p>As Niko highlights in his blog post, this would require adapting the <code>Fn</code> traits to allow their
return type to capture input lifetimes. There are a few things that Niko calls out in his post that
require changing Rust’s syntax, possibly across an edition boundary:</p><ul><li>Adding a lifetime to the <code>Output</code> parameter of the <code>Fn</code> traits</li><li>Desugaring <code>-&gt; impl Trait</code> to a bound on the associated type projection instead of a new
variable</li></ul><p>Because these may require an edition change, the project should work through the specifics of these
changes immediately. But they do not seem like extremely thorny problems to work out.</p><p>There is one other thing I would add to this feature, though. Once you have <code>Fn() -&gt; impl Future</code>
and so on, it would be natural to extend the syntax to have a kind of “async sugar” (and “gen
sugar”) just like functions do. That is to say, special syntax sugar should be added to the <code>Fn</code>
traits that makes it possible to write closure bounds like this:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>where</span><span> </span><span>F</span>: <span>async</span><span> </span><span>FnOnce</span><span>()</span><span> </span>-&gt; <span>T</span><span>
</span></span></span><span><span><span></span><span>// equivalent to:
</span></span></span><span><span><span></span><span>where</span><span> </span><span>F</span>: <span>FnOnce</span><span>()</span><span> </span>-&gt; <span>impl</span><span> </span><span>Future</span><span>&lt;</span><span>Output</span><span> </span><span>=</span><span> </span><span>T</span><span>&gt;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>where</span><span> </span><span>F</span>: <span>gen</span><span> </span><span>FnOnce</span><span>()</span><span> </span><span>yields</span><span> </span><span>T</span><span>
</span></span></span><span><span><span></span><span>// equivalent to:
</span></span></span><span><span><span></span><span>where</span><span> </span><span>F</span>: <span>FnOnce</span><span>()</span><span> </span>-&gt; <span>impl</span><span> </span><span>Iterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>T</span><span>&gt;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>where</span><span> </span><span>F</span>: <span>async</span><span> </span><span>gen</span><span> </span><span>FnOnce</span><span>()</span><span> </span><span>yields</span><span> </span><span>T</span><span>
</span></span></span><span><span><span></span><span>// equivalent to
</span></span></span><span><span><span></span><span>where</span><span> </span><span>F</span>: <span>FnOnce</span><span>()</span><span> </span>-&gt; <span>impl</span><span> </span><span>AsyncIterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>T</span><span>&gt;</span><span>
</span></span></span></code></pre></div><p>What’s nice about this is that it isn’t some new general-purpose abstractive concept like “trait
transformers” or “effect generics:” it’s just a little bit of sugar that is a natural extension of
sugar that already exists from one place (function declarations) to another (function trait bounds).
And these function traits already have special syntax, because they use parens and arrows for their
parameters and return type. This wouldn’t require a lot of implementation work or consensus on a
controversial new feature.</p><p>The features in the previous section were all features that I believe could be shipped without a
huge amount of implementation effort, and which don’t have many thorny open questions in their
design. The features in this section, on the other hand, are more difficult. It’s good that people
are already investigating them now, but they don’t seem very close to shipping and I wouldn’t expect
them in the next year or two.</p><h2 id="object-safe-coroutine-methods">Object-safe coroutine methods</h2><p>Though async trait methods will soon be a stable feature, they will not initially be object-safe. I
think this was the right decision, but it would be ideal if someday they could be. The problem with
object-safety is this: each coroutine method implies an anonymous associated type, which would have
a different size and layout in each implementation. In order to erase the static type of the trait
object, you also need to erase the type of that method’s anonymous return type: in other words, it
also needs to somehow be a trait object.</p><p>For our examples, we’ll consider this trait:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>trait</span><span> </span><span>Foo</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>async</span><span> </span><span>fn</span> <span>foo</span><span>(</span><span>&amp;</span><span>self</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>If I want to make a trait object of <code>Foo</code>, I need to specify the return type of <code>Foo::foo</code>.
Thankfully, RTN starts to unravel this problem by allowing us this syntax: <code>Box&lt;dyn Foo&lt;foo() = Something&gt;&gt;</code> But what is <code>Something</code>? It can’t be a specific type, or else that limits the trait
object to implementations that return that type: in practice, this means limiting it to a single
specific type, and now it isn’t even a meaningful trait object at all. That’s why it needs to be a
trait object itself.</p><p>For example, that might be <code>Box&lt;dyn Foo&lt;foo() = Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;&gt;&gt;</code>. Of course,
that is incredibly verbose. There are basically two problems at play which shape the design space:</p><ul><li>There needs to be some kind of transformer that takes your implementation of <code>Foo</code>, and includes
the glue to allocate the future in the heap.</li><li>Some members of the project leadership have the very strongly held view that heap allocations
should be “explicit,” where explicit means there should be more syntax required to do it.</li></ul><p>As a result, the project has considered a new wrapper type that would be required, which would
“explicitly” indicate (by virtue of being a different type) that the future type will be heap
allocated. My understanding is that something like what I’ve written above would be <code>Box&lt;Boxed&lt;dyn Foo&gt;&gt;</code>, or maybe just <code>Boxed&lt;dyn Foo&gt;</code> (it’s not clear to me from the material I have available).</p><p>My own opinion is different. I think its reasonable to make the default behavior of a heap allocated
trait object (i.e. <code>Box&lt;dyn Foo&gt;</code>, <code>Rc&lt;dyn Foo&gt;</code> and <code>Arc&lt;dyn Foo&gt;</code>) to allocate the state machine
with the same allocator as that type. For non-owned trait objects, like <code>&amp;mut dyn Foo</code>, I would also
be fine making the default behavior allocating them with the global allocator, though here I see the
point more (especially because this wouldn’ be possible in <code>no_std</code> contexts).</p><p>Regardless, I agree it would be important to allow users to override this behavior with some
alternative glue mechanism. This requires an interface for writing your own glue code, which might
do something else (like use <code>alloca</code> to allocate a dynamically sized type on the stack). I just
think that there should be a reasonable default behavior, which for heap allocated trait objects is
probably heap allocating that state. In my opinion, this is not “implicit” any more than requiring
all users to use an adapter is “implicit,” it just involves setting a reasonable default. Still,
resolving this controversy to everyone’s satisfaction would be a blocker on this feature, as well as
developing the interface for the glue code.</p><p>I want to make one other note in this section: previous discussions of this issue treat the unstable
<a href="https://smallcultfollowing.com/babysteps/blog/2022/03/29/dyn-can-we-make-dyn-sized"><code>dyn*</code></a> feature as a prerequisite for object-safe coroutine methods. I do not believe
this is the case. What <code>dyn*</code> does is create an existential type that all of the different trait
object pointer types would implement, by virtualizing also their destructor code; if you can accept
that trait objects using different allocation strategies for their virtual coroutine methods are
different types, there’s no dependence on <code>dyn*</code> at all. I personally think the <code>dyn*</code> feature is a
questionable direction for the Rust project to pursue.</p><h2 id="async-destructors">Async destructors</h2><p>Another very thorny issue is the problem of async destructors. Sometimes, a destructor might need to
perform some kind of IO operation or otherwise block the current thread; it is desirable to support
non-blocking destructors which instead yield control, so that other tasks can run concurrently.
Unfortunately, there are several problems with this.</p><p>The first problem is that running the async destructor is best effort, even more-so than running any
destructor. This is because if you drop a type with an async destructor in a non-async context,
there’s no possibility of running the destructor because this is not in an async context. There have
been a couple of different ideas about how to solve this, such as using <code>let async</code> bindings to
indicate variables that can’t be moved into a non-async context, or just accepting it and treating
the async destructor as only an optimization over the non-async destructor.</p><p>The second problem is actually very similar to the problem with trait objects: if the async
destructor needs to use some sort of state, where do you store it? One option is to disallow async
destructors from having state, using a poll method. This is simple, but it is problematic for things
like data structures: a <code>Vec</code> for example has no way of storing which items it has polled already,
and has to keep polling their destructors in a loop. This would be pretty unacceptable, probably. But
then dealing with the state raises the same issues as trait objects.</p><p>The third problem with async destructors is how to handle their interaction with unwinding. In
particular, if you are unwinding through an async destructor, which returns <code>Pending</code>, what happens?
There would need to be some kind of asynchronous version of <code>catch_unwind</code> that the pending calls
can jump to, so that other tasks can run. This problem I think is easier to solve than the other
two, but it needs to be specced out.</p><p>I go back and forth between thinking that the difficulty with async destructors is one of the worst
things about async Rust and thinking that maybe async destructors aren’t that useful anyway.
Regardless of where you land, there is a lot of design work needed for this feature to be shippable,
and I don’t think it will come soon.</p><p>In contrast to the near-term and medium-term features, there are certain larger problems with the
design of Rust that I think should be considered carefully, such that they could not be addressed in
the next few years. Still, the work of considering them must begin at some point, so that they can
eventually be closed. I’m talking about <a href="https://without.boats/blog/changing-the-rules-of-rust">“changing”</a> the rules of Rust.</p><p>As of right now, there are a few valuable kinds of types that Rust cannot really support:</p><ul><li><strong>Immoveable types:</strong> types which can’t be moved once their address has been witnessed.</li><li><strong>Unforgetable types:</strong> types which can’t go out of scope without running their destructor or
destructuring them.</li><li><strong>Undroppable types:</strong> types which can’t be dropped or forgotten but must be destructured.</li></ul><p>(The latter two are usually grouped together as “linear types” when people talk about them, but
there are very important differences.)</p><p>I think evidence has shown that there is a strong motivation for at least the first two categories.</p><p>To support self-referential coroutines and intrusive data structures, Rust needs some support for
types that are known never to move again. Because Rust doesn’t support immovable types, we added
this functionality using the <code>Pin</code> API. But the <code>Pin</code> API has a few big flaws: one is that the API
is clunky and difficult to work with. More important, though, is that it requires an interface to
explicitly <em>opt in</em> to supporting immovable types; traits that existed before <code>Pin</code> can’t gain the
ability to work with immovable types.</p><p>There are two specific traits for which this is a big problem:</p><ul><li><code>Iterator</code>: because iterator doesn’t support immovable types, the project is at an impasse about
how to support immovable generators.</li><li><code>Drop</code>: because drop doesn’t support immovable types, an arcane implication is that you need
crates like <code>pin-project</code> to access fields of pinned types. This is all very baroque and
confusing, and wouldn’t be necessary if <code>Drop</code> supported immovable types.</li></ul><p>On the other hand, if Rust had the <code>Move</code> trait, these problems would go away. Self-referential
generators would just not implement <code>Move</code>, and work naturally. The <code>Pin</code> type could be completely
deprecated, and a reference to a type that doesn’t implement <code>Move</code> would have the same semantics as
a pinned reference to a type that doesn’t implement <code>Unpin</code>. Of course, this would require pretty
major edition-crossing changes.</p><p>The <a href="https://without.boats/blog/the-scoped-task-trilemma">scoped task trilemma</a> presents a strong argument for types which cannot be forgotten.
Stackless coroutines cannot use the destructor-based concurrent borrow trick: the only way to make
it work is to use a closure-passing “internal” style, which is what Rust opted against when it went
for stackless coroutines. This incompatibility between these two desirable aspects of Rust’s design
makes a strong case that the decision not to support unforgettable types was the wrong decision.</p><p>I titled this post “a four year plan” for a reason: if Rust were to adopt these fundamental changes,
it would have to be done across an edition boundary, and I strongly doubt that it could be done as
part of the 2024 edition. This leaves the 2027 edition, four years from now, as the target for such
a change. But the project should commit to a decision about this change sometime soon, in the next
two years, and that should include a temporary solution for generators, such as requiring them to be
pinned before they can be used as iterators.</p><p>I’ve been exploring what would be required to do this change on my blog this year because I think it
is something the Rust project should seriously consider changing. I intend to continue to focus on
this issue next year, because I think the implications of all of the different options needs to be
fully understood. I’m trying to find ways to make this a collaborative process, but my options are
limited. My goal isn’t really even to make a particular recommendation (though I will surely have
opinions), but just to understand the full space of options for resolving these issues.</p><p>What are the exact trade offs between different options to handle the problem of self-referential
generators? What different requirements would there be to support “unforgettable” types as opposed
to “undroppable” types? If <code>Move</code> were to be added, how could <code>Pin</code> be removed across an edition
boundary? These are the kinds of questions I want to answer.</p><p>However, I recognize that adding support for these kinds of types would be the biggest change to
Rust since it was stabilized in 2015, and that making this change would bring with it enormous costs
for both the project and the community. I also recognize that there are valid arguments why
supporting these kinds of types isn’t really worth it (like the painful interaction with trait
objects). For these reasons, the Rust project should build into its consideration of this idea the
possibility that <em>not doing anything</em> may ultimately be the right outcome.</p><p>In general, my instinct is to doubt big changes to Rust at this point in its design process. What I
think Rust needs is to finish integrating the features it has already committed to - features like
external iterators, stackless coroutines, monomorphized generics, and unsized trait object types. I
specifically feel changing the rules around moveability and linear types is justified because of the
implications for the integration of these existing features.</p><p>This post has once again gotten very long. I decided to focus this post on changes to the language;
in another post to come I will focus my attention on the standard library and the async library
ecosystem, as well as devote a specific post to the <code>AsyncIterator</code> interface. I want to make one
other remark, which I tried to find a place for in this post and the previous one, but couldn’t. It
concerns the controversy around the final syntax for the await operator which played out in 2019.</p><p>For those who don’t know, there was a big debate whether the await operator in Rust should be a
prefix operator (as it is in other languages) or a postfix operator (as it ultimately was). This
attracted an inordinate amount of attention - over 1000 comments. The way it played out was that
almost everyone on the language team had reached a consensus that the operator should be postfix,
but I was the lone hold out. At this point, it was clear that no new argument was going to appear,
and no one was going to change their mind. I allowed this state of affairs to linger for several
months. I regret this decision of mine. It was clear that there was no way to ship except for me to
yield to the majority, and yet I didn’t for some time. In doing so, I allowed the situation to
spiral with more and more “community feedback” reiterating the same points that had already been
made, burning everyone out but especially me.</p><p>The lesson I learned from this experience is to distinguish between factors that are truly critical
and factors that don’t matter. If you’re going to be obstinate about some issue, you’d better be
able to articulate a deep reason why it is important, and it had better be something more pressing
than the slight differences in affordances and aesthetics between syntax options. I’ve tried to
take this to heart in how I engage in technical questions since then.</p><p>I worry that the Rust project took the wrong lesson from this experience. The project continues in
its norm (as Graydon mentioned <a href="https://graydon2.dreamwidth.org/307105.html">here</a>) that with enough ideation and brainstorming,
eventually a win-win solution to every controversy can be discovered. Rather than accepting that
sometimes a hard decision has to be made, the project’s solution to the burnout of that comes from
allowing these controversies to hang open indefinitely has been to turn inward. Design decisions are
now documented primarily in unindexed formats like Zulip threads and HackMD documents. To the extent
that there is a public expression of the design, it is one of a half dozen different blogs belonging
to different contributors. As an outsider, it is nearly impossible to understand what the project
considers a priority, and what the current state of any of these things are.</p><p>I’ve never seen the project’s relationship with its community be in a worse state. But that
community contains invaluable expertise; closing yourselves off is not the solution. I want to see
the relationships of mutual trust and respect rebuilt between project members and community members,
instead of the present situation of hostility and dissatisfaction. To this, I want to thank those
from the project who have reached out and engaged with me on design issues over the last few months.</p></section></div>
  </body>
</html>
