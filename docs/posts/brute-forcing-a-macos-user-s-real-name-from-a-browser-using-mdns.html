<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fingerprint.com/blog/apple-macos-mdns-brute-force/">Original</a>
    <h1>Brute-forcing a macOS user’s real name from a browser using mDNS</h1>
    
    <div id="readability-page-1" class="page"><div><p><em>This article is the second in a series that explores potential privacy vulnerabilities in Apple devices. In the <a href="https://fingerprint.com/blog/apple-id-region-leak/" target="_blank" rel="noopener noreferrer">first article</a>, we discussed detecting a system Apple ID region. This article presents a technique for revealing a user&#39;s first name without permissions using the mDNS protocol.</em></p>
<h2 id="introduction">Introduction</h2>
<p>In this article, we explain how the real name of a macOS user can be leaked through a browser without permissions. The proof of concept <a href="https://mdns-name-guesser.vercel.app/" target="_blank" rel="noopener noreferrer">demo</a> is optimized for performance rather than accuracy and results may be affected by device or network configuration.</p>
<p>The name brute-forcing technique uses a pre-made list of the 50 most popular gender-specific names from a specific country origin. Our experiments showed that this is enough to detect a macOS user’s name correctly in 65% of the cases on average. </p>
<h2 id="multicast-dns-protocol-and-apple-bonjour">Multicast DNS protocol and Apple Bonjour </h2>
<p>The exploit implementation relies on the <a href="https://en.wikipedia.org/wiki/Multicast_DNS" target="_blank" rel="noopener noreferrer">multicast DNS</a> (mDNS) protocol. In simple terms, the mDNS protocol is designed to register, discover, or broadcast device names over a local network. </p>
<p>For instance, when a specific device, such as a printer, wants to be discovered on a local network, it sends a registration UDP packet to the reserved internal IP address <code>224.0.0.251</code>, which contains a hostname like <code>HP_LaserJet_Printer.local</code>. The <code>.local</code> domain TLD indicates that the hostname should be resolved using the mDNS protocol.</p>
<p>Such packets are automatically broadcast by a router to other devices in a local network, so they can cache the hostname. Alternatively, devices can send query packets to the same reserved IP address and try to discover a specifically named device, which may not exist in the network.</p>
<p>Some examples of mDNS hostnames are:</p>
<ol>
<li><code>johns-mac-mini.local</code></li>
<li><code>david-ZenBook-UX431DA-UM431DA.local</code></li>
<li><code>james-iphone.local</code> </li>
<li><code>canon-mf644c.local</code></li>
<li><code>bedroom-appletv.local</code></li>
<li><code>dlinkrouter.local</code></li>
</ol>
<p>The multicast DNS protocol is widely used on Apple devices as part of the <a href="https://developer.apple.com/bonjour/" target="_blank" rel="noopener noreferrer">Apple Bonjour</a> feature.</p>
<p>By default, Apple devices expose the first name of a user in their local hostnames, which we are going to use for the name brute-forcing technique. You can view or change your macOS local hostname in the <strong>Sharing</strong> section of <strong>System Settings.</strong></p>
<p><span>
      <span></span>
  <img alt="apple sharing settings window" title="apple sharing settings window" src="https://bea.goth.cafe/static/ef46cb52422b2dee4bc352f1699dd670/f7616/1.png" srcset="/static/ef46cb52422b2dee4bc352f1699dd670/8514f/1.png 192w,
/static/ef46cb52422b2dee4bc352f1699dd670/d0c94/1.png 383w,
/static/ef46cb52422b2dee4bc352f1699dd670/f7616/1.png 766w,
/static/ef46cb52422b2dee4bc352f1699dd670/72372/1.png 1149w,
/static/ef46cb52422b2dee4bc352f1699dd670/d0ab7/1.png 1532w,
/static/ef46cb52422b2dee4bc352f1699dd670/9f9a4/1.png 1560w" sizes="(max-width: 766px) 100vw, 766px" loading="lazy" decoding="async"/>
    </span></p>
<h2 id="resolving-mdns-hostnames-from-a-browser">Resolving mDNS hostnames from a browser</h2>
<p>Unfortunately, the multicast DNS protocol is based on UDP packets. Browser JavaScript environments do not support arbitrary UDP sockets, so it is not possible to use the mDNS protocol directly in a browser.</p>
<p>However, we can resolve hostnames from browsers by using a timing workaround. Let’s make two regular <code>fetch</code> GET requests to existing <code>device-1.local</code> and non-existing <code>device-2.local</code> mDNS addresses:</p>
<p><span>
      <span></span>
  <img alt="2" title="" src="https://bea.goth.cafe/static/26c7e56f5f5d571c768d19409122b586/f7616/2.png" srcset="/static/26c7e56f5f5d571c768d19409122b586/8514f/2.png 192w,
/static/26c7e56f5f5d571c768d19409122b586/d0c94/2.png 383w,
/static/26c7e56f5f5d571c768d19409122b586/f7616/2.png 766w,
/static/26c7e56f5f5d571c768d19409122b586/72372/2.png 1149w,
/static/26c7e56f5f5d571c768d19409122b586/d0ab7/2.png 1532w,
/static/26c7e56f5f5d571c768d19409122b586/beade/2.png 2266w" sizes="(max-width: 766px) 100vw, 766px" loading="lazy" decoding="async"/>
    </span></p>
<p>The browser will try to resolve the hostname provided in a URL address. If the address is resolved, it will send a TCP packet to the 80 port, which in our case will most likely be closed. On the screenshot above you can see two different error messages:</p>
<ul>
<li><code>ERR_CONNECTION_REFUSED</code> for the existing <code>device-1.local</code></li>
<li><code>ERR_NAME_NOT_RESOLVED</code> for non-existing <code>device-2.local</code></li>
</ul>
<p>Both errors will be mapped into the same <code>Failed to fetch</code> JavaScript error, so we can’t rely on the error type, but we can perform a timing attack. Local networks are fast, so the valid mDNS hostname registered in the network will be resolved in a reasonable time frame, which is significantly faster than the default connection timeout. In the example above, the difference is four milliseconds for a valid address versus five seconds for an invalid one. </p>
<p>This approach is consistent enough for the proof of concept solution and works similarly in all major browsers. In practice, you can use any network JavaScript API, such as <code>iframe</code>, <code>Image</code> or <code>WebRTC</code>, to perform timing attacks for DNS resolving.</p>
<h2 id="macos-user-name-brute-forcing">MacOS user name brute-forcing</h2>
<p>As illustrated earlier, the default macOS local hostname contains the user&#39;s first name and device name. Moreover, the hostname depends on a system language locale:</p>
<ul>
<li>English: <code>&lt;name&gt;s-macbook-pro.local</code></li>
<li>French: <code>macbook-air-de-&lt;name&gt;.local</code></li>
<li>Russian: <code>mac-mini-&lt;name&gt;.local</code></li>
</ul>
<p>For example, we can take the top 1,000 names, the top 10 locales, and five common macOS device names. In this scenario, it would be necessary to test 50,000 distinct hostnames, which might take over an hour. A more efficient strategy would be to limit the search scope to a single locale, a single device, and the 50 most common names within that specific locale. While this affects accuracy, it makes the attack more feasible in practical terms and significantly faster in general.</p>
<p>The locale selection can be based on a browser time zone, language, or IP address location. Safari browser, for example, reveals the system locale with the <code>navigator.language</code> property, which is typically consistent with the targeted hostname locale. Also, there are other workarounds to discover the user&#39;s country of origin, such as the <a href="https://fingerprint.com/blog/apple-id-region-leak/" target="_blank" rel="noopener noreferrer">Apple ID region detection</a> method discussed previously.</p>
<p>The device options can be narrowed down by using the screen resolution. For instance, the <code>1728x1117</code> resolution is most likely a 16-inch Macbook Pro. An extended screen can be detected by using the <code>screen.isExtended</code> property, which will fallback the device options to three to five of the most commonly used Apple macOS devices.</p>
<p>The <a href="https://mdns-name-guesser.vercel.app/" target="_blank" rel="noopener noreferrer">proof of concept demo</a> has a name country origin and name gender selectors, which results in 50-100 potential hostnames that can be enumerated within seconds. Among the 100 FingerprintJS employees who participated in an internal test, the demo successfully predicted the name in 65% of instances. <a href="https://github.com/fingerprintjs/blog-macos-mdns-brute-force" target="_blank" rel="noopener noreferrer">The source code is available on GitHub.</a></p>
<p><span>
      <span></span>
  <img alt="are you david demo" title="are you david demo" src="https://bea.goth.cafe/static/5605d724002d3f35cb5f88c40460f7de/f7616/areyoudavid.png" srcset="/static/5605d724002d3f35cb5f88c40460f7de/8514f/areyoudavid.png 192w,
/static/5605d724002d3f35cb5f88c40460f7de/d0c94/areyoudavid.png 383w,
/static/5605d724002d3f35cb5f88c40460f7de/f7616/areyoudavid.png 766w,
/static/5605d724002d3f35cb5f88c40460f7de/72372/areyoudavid.png 1149w,
/static/5605d724002d3f35cb5f88c40460f7de/d0ab7/areyoudavid.png 1532w,
/static/5605d724002d3f35cb5f88c40460f7de/06868/areyoudavid.png 1974w" sizes="(max-width: 766px) 100vw, 766px" loading="lazy" decoding="async"/>
    </span></p>
<p>It&#39;s important to mention that the proof of concept demo is simply a demonstration of the attack and may not be successful in some cases. Some of the factors that could impact the results are:</p>
<ul>
<li>The presence of rare or unique names or non-standard macOS hostnames</li>
<li>Particular network configurations or VPN networks</li>
<li>Enabled firewall in macOS network settings</li>
</ul>
<p>If the demo does not work for you, consider using the advanced configuration settings to verify the list of the probed names and the device name pattern applied. If you use a VPN, consider testing it with and without VPN, because the result may change.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Considering the inherent weaknesses and numerous limitations, this attack isn&#39;t practical. It can be effortlessly detected in the network tab of browser developer tools unless there is deliberate intent from a website owner to de-anonymize its visitors.</p>
<p>This series of articles merely explores the boundaries of internet privacy and relies on unconventional privacy breaching techniques. As another example, by combining this method with <a href="https://fingerprint.com/blog/external-protocol-flooding/" target="_blank" rel="noopener noreferrer">detection of installed applications</a>, there’s a potential to develop a harmful website capable of displaying your real name and job title, based on the list of professional applications used, all without requiring any permissions.</p>
<p>Even though this article mentions Apple devices running macOS, the mDNS discovery technique can be utilized in variety of ways. For instance, it could be used to perform a local network scan to detect devices such as printers, smart TVs, smart speakers, and other home IoT devices.</p>
<p>This method is also applicable to iPhones and iPads, given that <a href="https://support.apple.com/guide/mac-help/wi-fi-syncing-mchlada1d602/mac" target="_blank" rel="noopener noreferrer">sync over Wi-Fi</a> or Safari remote debug features are activated.</p></div></div>
  </body>
</html>
