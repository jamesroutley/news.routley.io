<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://motif.land/blog/syncing-text-files-using-yjs-and-the-file-system-access-api">Original</a>
    <h1>Syncing files between browser and disk using Yjs and the File System Access API</h1>
    
    <div id="readability-page-1" class="page"><div><p>In this post, we look at the newly introduced <a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API" target="_blank" rel="noreferrer">File System Access API</a>, which lets the browser read and write files on a computer. This enables apps to offer a browser-first experience, all while syncing its data with a folder on disk. We believe that <strong>the content you create should not be tied to the tool you use to create it</strong>. Software applications should, whenever possible, push for freeing their data, and make it available for other applications to use as well, without vendor lock-in.</p>


<p>By making data available as files with two-way sync, apps instantly become endowed with new, exciting features: data can be stored anywhere (GitHub, Dropbox, Google Drive, …) and version-controlled (e.g. Git); in the case of plain text data, it can be edited with your editor of choice (VS Code, Obsidian, …); content produced with other apps (a bunch of Markdown notes, a folder full of photos, …) can be easily and continuously integrated, no tedious “upload” or “import” steps required.</p>
<p>The point is: by freeing the data from the tool, apps actually become more powerful, because they are now part of <strong>a collective of tools working hand-in-hand</strong>, augmenting one another with what they do best (like the <a href="https://en.wikipedia.org/wiki/List_of_Unix_commands" target="_blank" rel="noreferrer">POSIX utilities</a>). Software developers know this. Why is this design paradigm not more broadly adopted, for the benefit of everyone?</p>
<p><img src="https://res.cloudinary.com/djp21wtxm/image/upload/v1651646350/YFS_wfo1t9.gif"/></p><p>Two-way sync between the browser and the local file system is now possible thanks to the File System Access API.</p>
<p>With the emergence of browser-first apps, such as Figma and Google Docs, a new era of collaboration has seen the light. Everyone can just open up a browser, enter a URL, and start contributing. The barrier to entry has been lowered, and many more people can participate in the work and play. Browser-first apps offer a level of convenience that is unmatched in their standalone desktop counterparts. However, with cloud-based apps, data is typically stored in the cloud and controlled by the service provider, often in opaque and proprietary formats optimized for the tool itself (because why not? only the tool needs to understand the format!). Unless an API exposes the data, it is basically locked within the tool. And if the API is turned off, if the service stops working, or if the user moves on to another tool, the data is stuck in limbo.</p>
<p>With the File System Access API, we see an opportunity to come full circle: we can offer the convenience, availability, and collaborative aspects of a browser-first app, all while keeping the data free from the tool, unlocking its full potential. This is in line with the vision presented by Geoffrey Litt in his article <a href="https://www.geoffreylitt.com/2021/03/05/bring-your-own-client.html" target="_blank" rel="noreferrer">Bring your own client</a>. Let’s see how this can be achieved in practice for text files!</p>
<h2 id="towards-hybrid-browser-cloud-file-data-architectures">Towards hybrid browser-cloud-file data architectures</h2>
<p>Here is a typical hybrid browser-cloud-file architecture (this is for instance the one Motif is based on):</p>
<p><img src="https://res.cloudinary.com/djp21wtxm/image/upload/v1651629718/Cloud_im7lov.svg"/></p><p>In Motif, four data sources need to be merged: live clients via WebRTC, cloud storage, local storage, and now, the file system.</p>
<p>Specifically:</p>
<ul>
<li>The client application can be accessed in a browser, no installation required. Like any web application, this lowers the barrier to entry to get started (users just need to open a browser and enter the URL of the app), and ensures broad availability across platforms and devices.</li>
<li>Continuing in the web app paradigm, the client synchronizes its data with a cloud database, making data accessible across clients, and enabling asynchronous collaboration and synchronization.</li>
<li>To make this data available instantly and while offline, browser storage, such as IndexedDB, can be used. In Motif, we use <a href="https://replicache.dev/" target="_blank" rel="noreferrer">Replicache</a> to sync local and remote states.</li>
<li>When two clients open the same document at the same time, they instantiate a WebRTC connection and exchange data in real-time.</li>
<li>Finally, if file sync is enabled, all content in the client is synced to a folder on the file system. Changes in the file system get seamlessly merged with the client, and vice-versa.</li>
</ul>
<p>The challenge in such a setup is to make sure that no data gets lost, and that all clients eventually reach the same state. For instance, when two users edit the same part of a document, either in real time (data transits via WebRTC), or asynchronously (data transits via a cloud database), we expect that these changes get merged seamlessly.</p>
<p>In order to address this, we are using a <a href="https://crdt.tech/" target="_blank" rel="noreferrer">Conflict-free Replicated Data Type (CRDT)</a> as the underlying data model. More specifically, in this blog post, we are using the <a href="https://yjs.dev/" target="_blank" rel="noreferrer">Yjs</a> implementation, which is optimized for large documents, and in general, has <a href="https://blog.kevinjahns.de/are-crdts-suitable-for-shared-editing/" target="_blank" rel="noreferrer">great performance characteristics</a> (another notable option is <a href="https://github.com/automerge/automerge" target="_blank" rel="noreferrer">Automerge</a>). But while the client apps, the cloud storage, and the local IndexedDB storage can hold the Yjs documents as CRDTs in their entirety, which is required for merging changes, the files on disk only hold their textual representations. With files, we lose the CRDT info, and thereby, the built-in merge capabilities.</p>
<p>Of course, we are not satisfied with a solution that simply overwrites changes. Not only do we risk losing data, e.g. if a change comes in from the file system and from a remote client at the same time, but it would also push us to add an extra layer of complexity in order to figure out what version comes in last (timestamps are hard to deal with in a distributed setup).</p>
<p>The solution that we present here turns out to be fairly straightforward, by simply adopting a “CRDT mindset” when thinking about the problem. If we can somehow manage to make the disk files behave as if they were CRDTs as well, we can then treat the file system as just another data source in our CRDT architecture, providing nothing but delta updates. As illustrated below, this can be achieved by keeping a version of the “last-write-to-disk” in a persistent cache, and computing the diff with the disk version as it comes in.</p>
<h2 id="how-it-works">How it works</h2>
<p>Let’s walk through the implementation. The full source is <a href="https://github.com/motifland/yfs" target="_blank" rel="noreferrer">available on GitHub</a>. You can <a href="#syncing-between-data-sources">skip to the sync part</a> if you are already familiar with the File System Access API.</p>
<h3 id="preparing-for-write-access">Preparing for write access</h3>
<p>First, let’s make the browser client ready for reading and writing files. We need to check that the File System Access API is supported:</p>
<pre><code><span>const</span> <span>isSupported</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>typeof</span> <span>window</span><span>.</span><span>showDirectoryPicker</span> <span>===</span> <span>&#39;function&#39;</span>
<span>}</span>
</code></pre>
<p>As of May 2022, the File System Access API is supported on Chrome 86+, Edge 86+ and Opera 72+.</p>
<p>Next, let’s set the root directory in which to sync our files, and grant read and write permissions:</p>
<pre><code><span>const</span> readWriteOptions <span>=</span> <span>{</span> mode<span>:</span> <span>&#39;readwrite&#39;</span> <span>}</span>

<span>const</span> <span>setRootDirectory</span> <span>=</span> <span>async</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> handle<span>:</span> <span>any</span> <span>=</span> <span>await</span> <span>(</span><span>window</span> <span>as</span> <span>any</span><span>)</span><span>.</span><span>showDirectoryPicker</span><span>(</span><span>)</span>
  <span>if</span> <span>(</span><span>!</span>handle<span>)</span> <span>{</span>
    <span>return</span> <span>undefined</span>
  <span>}</span>
  <span>let</span> granted <span>=</span> <span>(</span><span>await</span> handle<span>.</span><span>queryPermission</span><span>(</span>readWriteOptions<span>)</span><span>)</span> <span>===</span> <span>&#39;granted&#39;</span>
  <span>if</span> <span>(</span><span>!</span>granted<span>)</span> <span>{</span>
    granted <span>=</span> <span>(</span><span>await</span> handle<span>.</span><span>requestPermission</span><span>(</span>readWriteOptions<span>)</span><span>)</span> <span>===</span> <span>&#39;granted&#39;</span>
  <span>}</span>
  <span>return</span> <span>{</span> handle<span>,</span> granted <span>}</span>
<span>}</span>
</code></pre>
<p>This function will trigger a browser dialog:</p>
<p><img src="https://res.cloudinary.com/djp21wtxm/image/upload/v1651708428/i1440x438-p6CeaRsgPBQx_fvcs0l.png"/></p><p>If permissions are successfully granted, we now have a directory handle that we can use to read from and write to the file system. For the sake of simpliticy, this blog post will only deal with syncing a single file. Handling multiple files, subfolders, renaming and moving adds an extra layer of complexity that is out of the scope of this post. Our repo contains <a href="https://github.com/motifland/yfs/blob/main/src/helpers.ts" target="_blank" rel="noreferrer">helper functions</a> though, which you can use to deal with these situations.</p>
<p>Let’s create a function for obtaining the handle to the file we want to sync our content with. As mentioned, we are only dealing with the case of a fixed file at the base of our root folder.</p>
<pre><code><span>const</span> getFileHandle <span>=</span> <span>async</span> <span>(</span>
    name<span>:</span> <span>string</span><span>,</span>
    directoryHandle<span>:</span> <span>FileSystemDirectoryHandle</span>
<span>)</span><span>:</span> <span>Promise</span><span>&lt;</span><span>FileSystemFileHandle</span> <span>|</span> <span>undefined</span><span>&gt;</span> <span>=&gt;</span> <span>{</span>
  <span>for</span> <span>await</span> <span>(</span><span>const</span> handle <span>of</span> <span>(</span>directoryHandle <span>as</span> <span>any</span><span>)</span><span>.</span><span>values</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    <span>const</span> relativePath <span>=</span> <span>(</span><span>await</span> directoryHandle<span>.</span><span>resolve</span><span>(</span>handle<span>)</span><span>)</span> <span>||</span> <span>[</span><span>]</span>
    <span>if</span> <span>(</span>relativePath<span>?.</span>length <span>===</span> <span>1</span> <span>&amp;&amp;</span> relativePath<span>[</span><span>0</span><span>]</span> <span>===</span> name<span>)</span> <span>{</span>
      <span>return</span> handle
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>undefined</span>
<span>}</span>
</code></pre>
<p>If the file is not present in the directory, let’s create it, using the following function:</p>
<pre><code><span>const</span> createFileHandle <span>=</span> <span>async</span> <span>(</span>
    name<span>:</span> <span>string</span><span>,</span>
    directoryHandle<span>:</span> <span>FileSystemDirectoryHandle</span>
<span>)</span><span>:</span> <span>Promise</span><span>&lt;</span><span>FileSystemFileHandle</span> <span>|</span> <span>undefined</span><span>&gt;</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>await</span> directoryHandle<span>.</span><span>getFileHandle</span><span>(</span>name<span>,</span> <span>{</span> create<span>:</span> <span>true</span> <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<p>Finally, let’s create a function for writing content to our file:</p>
<pre><code><span>const</span> <span>writeContentToFile</span> <span>=</span> <span>async</span> <span>(</span>
  fileHandle<span>:</span> <span>FileSystemFileHandle</span><span>,</span>
  content<span>:</span> <span>string</span>
<span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> writable <span>=</span> <span>await</span> <span>(</span>fileHandle <span>as</span> <span>any</span><span>)</span><span>.</span><span>createWritable</span><span>(</span><span>)</span>
  <span>await</span> writable<span>.</span><span>write</span><span>(</span>content<span>)</span>
  <span>await</span> writable<span>.</span><span>close</span><span>(</span><span>)</span>
<span>}</span>
</code></pre>
<h3 id="syncing-between-data-sources">Syncing between data sources</h3>
<p>Now that we can write to our file, we can set up the sync mechanism. The challenge lies in seamlessly merging different versions of the content, as we don’t just want to overwrite one version with another. Indeed, changes can come asynchronously from the cloud, another client over WebRTC, or from the file system. With Yjs, we have a framework for doing this, granted that we can work with the full CRDT. In the file system, however, we only have a raw content file, not the entire CRDT. Let’s see how we can mitigate this.</p>
<p>First, let’s create a <a href="https://docs.yjs.dev/api/y.doc" target="_blank" rel="noreferrer">Yjs document</a>, which acts as the authorative source for our content in the client, and let’s insert some content programmatically.</p>
<pre><code><span>import</span> <span>*</span> <span>as</span> <span>Y</span> <span>from</span> <span>&#39;yjs&#39;</span>

<span>const</span> doc <span>=</span> <span>new</span> <span><span>Y</span></span><span>.</span><span><span>Doc</span></span><span>(</span><span>)</span>
doc<span>.</span><span>getText</span><span>(</span><span>)</span><span>.</span><span>insert</span><span>(</span><span>0</span><span>,</span> <span>&#39;Hello world&#39;</span><span>)</span>
</code></pre>
<p>In practice, the editing of a Yjs document is done using an editor binding such as <a href="https://github.com/yjs/y-prosemirror" target="_blank" rel="noreferrer">y-prosemirror</a> or <a href="https://github.com/yjs/y-monaco" target="_blank" rel="noreferrer">y-monaco</a>. For an example using Monaco, check out our <a href="https://github.com/motifland/yfs/tree/main/examples/single-file-sync" target="_blank" rel="noreferrer">sample Next.js application on GitHub</a>.</p>
<p>Next, let’s get a hold of the file on disk. We’ll use the name <code>test-file.txt</code> for this demo. If it doesn’t exist, we create it:</p>
<pre><code><span>const</span> name <span>=</span> <span>&#34;test-file.txt&#34;</span>



<span>let</span> fileHandle <span>=</span> <span>await</span> <span>getFileHandle</span><span>(</span>name<span>,</span> directoryHandle<span>)</span>

<span>if</span> <span>(</span><span>!</span>fileHandle<span>)</span> <span>{</span>
  
  fileHandle <span>=</span> <span>await</span> <span>createFileHandle</span><span>(</span>name<span>,</span> directoryHandle<span>)</span>
<span>}</span>
</code></pre>
<p>Now, the trick for being able to leverage the CRDT features of our Yjs document is to write its content to a local persistent cache, in addition to writing it to disk. In that way, subsequent changes to the file system can be compared with the cached version. Here is our function for writing the file to disk, alongside the cache. We use IndexedDB for the cache, using the handy <a href="https://github.com/jakearchibald/idb-keyval" target="_blank" rel="noreferrer">IDB-Keyval</a> library.</p>
<pre><code><span>import</span> <span><span>{</span> set <span>}</span></span> <span>from</span> <span>&#39;idb-keyval&#39;</span>

<span>const</span> <span>updateFileContent</span> <span>=</span> <span>async</span> <span>(</span>
  file<span>:</span> globalThis<span>.</span><span><span>File</span></span><span>,</span>
  fileHandle<span>:</span> <span>FileSystemFileHandle</span><span>,</span>
  content<span>:</span> <span>string</span>
<span>)</span> <span>=&gt;</span> <span>{</span>
  
  
  <span>await</span> <span>writeContentToFile</span><span>(</span>fileHandle<span>,</span> content<span>)</span>
  <span>await</span> <span>set</span><span>(</span>
    file<span>.</span><span>name</span><span>,</span>
    <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>{</span>
      name<span>:</span> file<span>.</span><span>name</span><span>,</span>
      content<span>,</span>
      lastModified<span>:</span> file<span>.</span><span>lastModified</span> <span>}</span><span>)</span>
  <span>)</span>
<span>}</span>
</code></pre>
<p>We update our previous code to include saving the content of our Yjs document to our newly created file:</p>
<pre><code><span>const</span> name <span>=</span> <span>&#34;test-file.txt&#34;</span>



<span>let</span> fileHandle <span>=</span> <span>await</span> <span>getFileHandle</span><span>(</span>name<span>,</span> directoryHandle<span>)</span>


<span>const</span> content <span>=</span> doc<span>.</span><span>getText</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span>

<span>if</span> <span>(</span><span>!</span>fileHandle<span>)</span> <span>{</span>
  
  fileHandle <span>=</span> <span>await</span> <span>createFileHandle</span><span>(</span>name<span>,</span> directoryHandle<span>)</span>
  
  <span>const</span> newFile <span>=</span> <span>await</span> newFileHandle<span>.</span><span>getFile</span><span>(</span><span>)</span>  
  
  
  <span>await</span> <span>updateFileContent</span><span>(</span>newFile<span>,</span> fileHandle<span>,</span> content<span>)</span>
  <span>return</span>
<span>}</span>
</code></pre>
<p>Now, after the initial file creation, and for any subsequent file write operations, we keep track of what is being written to disk. The next step is to handle the case where the file already exists. If the last modified timestamps between the file and the cache are equal, we can safely assume that no change has occured on disk, and the only change would come from the Yjs document, which we can write to disk as-is:</p>
<pre><code><span>import</span> <span><span>{</span> get <span>}</span></span> <span>from</span> <span>&#39;idb-keyval&#39;</span>



<span>const</span> content <span>=</span> doc<span>.</span><span>getText</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span>

<span>if</span> <span>(</span><span>!</span>fileHandle<span>)</span> <span>{</span>
  
  <span>return</span>
<span>}</span>



<span>const</span> lastWriteCacheData <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>await</span> <span>get</span><span>(</span>name<span>)</span><span>)</span>
<span>const</span> file <span>=</span> <span>await</span> fileHandle<span>.</span><span>getFile</span><span>(</span><span>)</span>

<span>if</span> <span>(</span>file<span>.</span><span>lastModified</span> <span>===</span> lastWriteCacheData<span>.</span><span>lastModified</span><span>)</span> <span>{</span>
  
  
  <span>await</span> <span>updateFileContent</span><span>(</span>file<span>,</span> fileHandle<span>,</span> content<span>)</span>
  <span>return</span>
<span>}</span>
</code></pre>
<p>And now to the crux of the implementation: a change has occured to the file on disk. This is the case if <code>file.lastModified</code> differs from <code>lastWriteCacheData.lastModified</code>. We can determine exactly what has changed by comparing the two versions. <em>À fortiori</em>, since any write to disk is tracked in the cache, the file version is more recent than the cache version. So, we want to track the diff between the two, and build a set of <a href="https://docs.yjs.dev/api/delta-format" target="_blank" rel="noreferrer">Yjs delta operations</a> that will take us from the cached version to the newer disk version. This can be readily achieved using a diffing library such as <a href="https://github.com/kpdecker/jsdiff" target="_blank" rel="noreferrer">jsdiff</a>.</p>
<pre><code><span>import</span> <span><span>*</span> <span>as</span> <span>Diff</span></span> <span>from</span> <span>&#39;diff&#39;</span>

<span>type</span> <span><span>YDelta</span></span> <span>=</span> <span>{</span> retain<span>:</span> <span>number</span> <span>}</span> <span>|</span> <span>{</span> <span>delete</span><span>:</span> <span>number</span> <span>}</span> <span>|</span> <span>{</span> insert<span>:</span> <span>string</span> <span>}</span>

<span>export</span> <span>const</span> getDeltaOperations <span>=</span> <span>(</span>
  initialText<span>:</span> <span>string</span><span>,</span>
  finalText<span>:</span> <span>string</span><span>)</span><span>:</span> <span>YDelta</span><span>[</span><span>]</span> <span>=&gt;</span> <span>{</span>
  <span>if</span> <span>(</span>initialText <span>===</span> finalText<span>)</span> <span>{</span>
    <span>return</span> <span>[</span><span>]</span>
  <span>}</span>

  <span>const</span> edits <span>=</span> <span>Diff</span><span>.</span><span>diffChars</span><span>(</span>initialText<span>,</span> finalText<span>)</span>
  <span>let</span> prevOffset <span>=</span> <span>0</span>
  <span>let</span> deltas<span>:</span> <span>YDelta</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span>

  
  <span>for</span> <span>(</span><span>const</span> edit <span>of</span> edits<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>edit<span>.</span><span>removed</span> <span>&amp;&amp;</span> edit<span>.</span><span>value</span><span>)</span> <span>{</span>
      deltas <span>=</span> <span>[</span>
        <span>...</span>deltas<span>,</span>
        <span>...</span><span>[</span>
          <span>...</span><span>(</span>prevOffset <span>&gt;</span> <span>0</span> <span>?</span> <span>[</span><span>{</span> retain<span>:</span> prevOffset <span>}</span><span>]</span> <span>:</span> <span>[</span><span>]</span><span>)</span><span>,</span>
          <span>{</span> <span>delete</span><span>:</span> edit<span>.</span><span>value</span><span>.</span><span>length</span> <span>}</span>
        <span>]</span>
      <span>]</span>
      prevOffset <span>=</span> <span>0</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>edit<span>.</span><span>added</span> <span>&amp;&amp;</span> edit<span>.</span><span>value</span><span>)</span> <span>{</span>
      deltas <span>=</span> <span>[</span>
          <span>...</span>deltas<span>,</span>
          <span>...</span><span>[</span><span>{</span> retain<span>:</span> prevOffset <span>}</span><span>,</span> <span>{</span> insert<span>:</span> edit<span>.</span><span>value</span> <span>}</span><span>]</span>
        <span>]</span>
      prevOffset <span>=</span> edit<span>.</span><span>value</span><span>.</span><span>length</span>
    <span>}</span> <span>else</span> <span>{</span>
      prevOffset <span>=</span> edit<span>.</span><span>value</span><span>.</span><span>length</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> deltas
<span>}</span>
</code></pre>
<p>We are now ready to merge the disk version of the file with the Yjs document (which may also have changed!). Once we have the delta operations, we can apply them using the <code>applyDelta()</code> function on the <code>Y.Text</code> value of the document.</p>
<pre><code><span>import</span> <span><span>{</span> get <span>}</span></span> <span>from</span> <span>&#39;idb-keyval&#39;</span>



<span>const</span> content <span>=</span> doc<span>.</span><span>getText</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span>

<span>if</span> <span>(</span><span>!</span>fileHandle<span>)</span> <span>{</span>
  
  <span>return</span>
<span>}</span>

<span>const</span> lastWriteCacheData <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>await</span> <span>get</span><span>(</span>name<span>)</span><span>)</span>
<span>const</span> file <span>=</span> <span>await</span> fileHandle<span>.</span><span>getFile</span><span>(</span><span>)</span>

<span>if</span> <span>(</span>file<span>.</span><span>lastModified</span> <span>===</span> lastWriteCacheData<span>.</span><span>lastModified</span><span>)</span> <span>{</span>
  
  <span>return</span>
<span>}</span>



<span>const</span> fileContent <span>=</span> <span>await</span> file<span>.</span><span>text</span><span>(</span><span>)</span>
<span>const</span> lastWriteFileContent <span>=</span> lastWriteCacheData<span>.</span><span>content</span>
<span>const</span> deltas <span>=</span> <span>getDeltaOperations</span><span>(</span>lastWriteFileContent<span>,</span> fileContent<span>)</span>

<span>if</span> <span>(</span>deltas<span>.</span><span>length</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>
  
  
  <span>await</span> <span>updateFileContent</span><span>(</span>file<span>,</span> fileHandle<span>,</span> docContent<span>)</span>
  <span>return</span>
<span>}</span>



doc<span>.</span><span>getText</span><span>(</span><span>)</span><span>.</span><span>applyDelta</span><span>(</span>deltas<span>)</span>

<span>const</span> mergedContent <span>=</span> doc<span>.</span><span>getText</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span>
<span>await</span> <span>updateFileContent</span><span>(</span>file<span>,</span> fileHandle<span>,</span> mergedContent<span>)</span>
</code></pre>
<p>That’s it! Thanks to the idempotent and commutative nature of the CRDT, we don’t need to worry about timestamps, or whether the Yjs document has changed (e.g. from a remote client) at the same time as the disk version. We can now simply start polling the file system at regular intervals, and Yjs will do the magic!</p>
<h2 id="demo">Demo</h2>
<p>You can try out a demo running the Monaco editor in the browser and performing live sync on a single file here:</p>

<p>And here is a demo of how it looks in Motif, including full directory sync:</p>
<p><iframe src="https://www.youtube.com/embed/VqDak8UKWkA" frameborder="0"></iframe></p>
<h2 id="current-caveats">Current caveats</h2>
<p>There are a few minor inconveniences which will hopefully be addressed as the File System Access API matures and becomes more broadly available.</p>
<ul>
<li>Only latest versions of Chrome, Edge and Opera support it. <a href="https://webkit.org/blog/12257/the-file-system-access-api-with-origin-private-file-system/" target="_blank" rel="noreferrer">Safari is starting to add support</a>, but currently, it only allows writing to the origin private file system, and not to an actual folder that we can access outside of the browser.</li>
<li>The operations for <a href="https://web.dev/file-system-access/#renaming-and-moving-files-and-folders" target="_blank" rel="noreferrer">renaming and moving a file or a folder</a> are only supported when writing to the origin private file system. This makes the implementation tedious, especially for subfolders, since we need to manually create, copy and delete items. Copying, rather than moving, also poses the risk of running out of disk space. We don’t worry about this in Motif, since we’re dealing with text files, so <em>à priori</em> small payloads.</li>
<li>When the browser app is closed, the read and write permissions are revoked. This means that the next time the user opens the app and wants to perform file synchronization, they need to grant the permissions again. To make this process as painless as possible in Motif, we show a discrete notification at the bottom of the editor, asking to resume syncing. We have found this solution to work quite well in practice.</li>
</ul>
<p><img src="https://res.cloudinary.com/djp21wtxm/image/upload/v1651711171/i1196x332-HmtD5Uh7tbfb_aqomra.png"/></p><p>Despite these shortcomings, all in all, the sync feature works great for what it is mainly intended for: easily storing browser data in the file system, editing a file with another editor, and bulk importing files into the browser app by simply dropping them into a folder.</p>
<h2 id="next-steps">Next steps</h2>
<p>For a fully functional browser-based IDE like Motif, we want to sync many files and folders, not just a single file. Although in this post we solely focus on the latter scenario, the former is conceptually the same. In addition to syncing, we also want to be able to handle:</p>
<ul>
<li>Moving, renaming and deleting files and folders. In our <a href="https://github.com/motifland/yfs" target="_blank" rel="noreferrer">YFS repo</a>, you will find most of the methods required to fulfill this.</li>
<li>Background sync, so that all files are always up to date. For instance, if a user updates a global CSS file, another live user should immediately see the effect on the page they are working on. You would probably want to use a longer interval for syncing files other than the one that is currently open.</li>
<li>Opening files from outside of the app, by leveraging the <a href="https://w3c.github.io/web-share-target/" target="_blank" rel="noreferrer">Web Share Target API</a>. In Motif, files can have dependencies on other files (e.g. an MDX file importing a JSX component defined in another file), so we want to keep track of the project that the file is in. In order to do that, we would need more context about the file, e.g. a root parent handle. We haven’t investigated much in that direction yet.</li>
</ul>
<h2 id="source-code">Source code</h2>
<p>The source code for this library, and an <a href="https://yfs.vercel.app/" target="_blank" rel="noreferrer">example implementation</a> using the Monaco editor, is <a href="https://github.com/motifland/yfs" target="_blank" rel="noreferrer">available on GitHub</a>.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Thanks to <a href="https://twitter.com/kevin_jahns" target="_blank" rel="noreferrer">Kevin Jahns</a>, <a href="https://twitter.com/geoffreylitt" target="_blank" rel="noreferrer">Geoffrey Litt</a>, <a href="https://twitter.com/wooorm" target="_blank" rel="noreferrer">Titus Wormer</a>, <a href="https://twitter.com/ellenchisa" target="_blank" rel="noreferrer">Ellen Chisa</a>, <a href="https://twitter.com/nickrttn" target="_blank" rel="noreferrer">Nick Rutten</a>, <a href="https://twitter.com/remcohaszing" target="_blank" rel="noreferrer">Remco Haszing</a>, <a href="https://twitter.com/pacocoursey" target="_blank" rel="noreferrer">Paco Coursey</a>, <a href="https://twitter.com/becomingbabyman" target="_blank" rel="noreferrer">Chris Smothers</a>, <a href="https://twitter.com/ankrgyl" target="_blank" rel="noreferrer">Ankur Goyal</a> and <a href="https://twitter.com/tangjeff0" target="_blank" rel="noreferrer">Jeff Tang</a> for their insights and valuable feedback.</p>

<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="https://www.geoffreylitt.com/2021/03/05/bring-your-own-client.html" target="_blank" rel="noreferrer">Bring your own client</a>, by <a href="https://twitter.com/geoffreylitt" target="_blank" rel="noreferrer">Geoffrey Litt</a></li>
<li><a href="https://jenson.org/files/" target="_blank" rel="noreferrer">The future needs files</a>, by <a href="https://twitter.com/scottjenson" target="_blank" rel="noreferrer">Scott Jenson</a></li>
<li><a href="https://jenson.org/files2/" target="_blank" rel="noreferrer">The present needs files</a>, by <a href="https://twitter.com/scottjenson" target="_blank" rel="noreferrer">Scott Jenson</a></li>
<li><a href="https://sive.rs/plaintext" target="_blank" rel="noreferrer">Write plain text files</a>, by <a href="https://twitter.com/sivers" target="_blank" rel="noreferrer">Derek Sivers</a></li>
<li><a href="https://craigmod.com/essays/fast_software/" target="_blank" rel="noreferrer">Fast software, the best software</a>, by <a href="https://twitter.com/craigmod" target="_blank" rel="noreferrer">Craig Mod</a></li>
<li><a href="https://blog.kevinjahns.de/are-crdts-suitable-for-shared-editing/" target="_blank" rel="noreferrer">Are CRDTs suitable for shared editing?</a>, by <a href="https://twitter.com/kevin_jahns" target="_blank" rel="noreferrer">Kevin Jahns</a></li>
<li><a href="https://blog.excalidraw.com/browser-fs-access/" target="_blank" rel="noreferrer">Reading and writing files and directories with the browser-fs-access library</a>, by <a href="https://twitter.com/tomayac" target="_blank" rel="noreferrer">Thomas Steiner</a></li>
</ul>
<h2 id="interested-in-working-on-similar-problems">Interested in working on similar problems?</h2>
<p>If you like working on CRDTs, text editors, JavaScript build systems, DM me (<a href="https://twitter.com/michaelfester" target="_blank" rel="noreferrer">@michaelfester</a>) on Twitter! If you are an Open Source contributor in these areas, we’d like to know, and we could fund you.</p>
<hr/>
<p>To keep up to date with our progress, make sure to follow <a href="https://twitter.com/motifland" target="_blank" rel="noreferrer">@motifland</a> on Twitter.</p>

</div></div>
  </body>
</html>
