<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yosefk.com/blog/my-history-with-forth-stack-machines.html">Original</a>
    <h1>My history with Forth and stack machines (2010)</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<p><em><span><span><span><span><span><span>My VLSI tools take a chip from conception through testing. Perhaps 500 lines
of source code. Cadence, Mentor Graphics do the same, more or less. With how much source/object
code?</span></span></span></span></span></span></em></p>
<p><em>– <a href="http://www.colorforth.com/1percent.html">Chuck Moore</a>, the inventor of Forth</em></p>
</div>
<p>This is a personal account of my experience implementing and using the Forth programming language and the stack machine
architecture. &#34;Implementing and using&#34; – in that order, pretty much; a somewhat typical order, as will become apparent.</p>
<p>It will also become clear why, having defined the instruction set of a processor designed to run Forth that went into
production, I don&#39;t consider myself a competent Forth programmer (now is the time to warn that my understanding of Forth is just
that – my own understanding; wouldn&#39;t count on it too much.)</p>
<p>Why the epigraph about Chuck Moore&#39;s VLSI tools? Because Forth is very radical. Black Square kind of radical. An approach to
programming seemingly leaving out most if not all of programming:</p>
<blockquote>
<p>...Forth does it differently. There is no syntax, no redundancy, no typing. There are no errors that can be detected.
...there are no parentheses. No indentation. No hooks, no compatibility. ...No files. No operating system.</p>
</blockquote>
<p><img alt="Black Square by Kazimir Malevich" height="218" src="https://yosefk.com/img/n/black-square.jpg" width="220"/></p>
<p>I&#39;ve never been a huge fan of suprematism or modernism in general. However, a particular modernist can easily get my
attention if he&#39;s a genius in a traditional sense, with superpowers. Say, he memorizes note sheets upon the first brief glance
like Shostakovich did.</p>
<p>Now, I&#39;ve seen chip design tools by the likes of Cadence and Mentor Graphics. Astronomically costly licenses. Geological run
times. And nobody quite knows what they do. To me, VLSI tools in 500 lines qualify as a superpower, enough to grab my
attention.</p>
<p>So, here goes.</p>
<p>***</p>
<p>I was intrigued with Forth ever since I read about it in Bruce Eckel&#39;s book on C++, a 198-something edition; he said there
that &#34;extensibility got a bad reputation due to languages like Forth, where a programmer could change everything and effectively
create a programming language of his own&#34;. WANT!</p>
<p>A couple of years later, I looked for info on the net, which seemed somewhat scarce. An unusually looking language.
Parameters and results passed implicitly on a stack. 2 3 + instead of 2+3. Case-insensitive. Nothing about the extensibility
business though.</p>
<p>I thought of nothing better than to dive into the source of an implementation, <a href="http://www.softsynth.com/pforth/" title="Portable Forth in &#39;C&#39;. Why do Forth programmers put C in quotes?">pForth</a> – and I didn&#39;t need anything better,
as my mind was immediately blown away by the following passage right at the top of <a href="https://pforth.googlecode.com/svn/trunk/fth/system.fth">system.fth</a>, the part of pForth implemented in Forth on top of
the C interpreter:</p>
<blockquote>
<pre><code>: (   41 word drop ; immediate
( That was the definition for the comment word. )
( Now we can add comments to what we are doing! )</code></pre>
</blockquote>
<p>Now. we. can. add. comments. to. what. we. are. doing.</p>
<p>What this does is define a word (Forth&#39;s name for a function) called &#34;(&#34;. &#34;(&#34; is executed at compile time (as directed by
IMMEDIATE). It tells the compiler to read bytes from the source file (that&#39;s what the word called, um, WORD is doing), until a
&#34;)&#34; – ASCII 41 – is found. Those bytes are then ignored (the pointer to them is removed from the stack with DROP). So
effectively, everything inside &#34;( ... )&#34; becomes a comment.</p>
<p><em>Wow.</em> Yeah, you definitely can&#39;t do that in C++. (You <a href="http://www.lispworks.com/documentation/lw51/CLHS/Body/f_set_ma.htm#set-macro-character">can</a> in Lisp but they don&#39;t
teach you those parts at school. They teach the pure functional parts, where you <em>can&#39;t</em> do things that you <em>can</em>
in C++. Bastards.)</p>
<p>Read some more and...</p>
<blockquote>
<pre><code> conditional primitives
: IF     ( -- f orig )  ?comp compile 0branch  conditional_key &gt;mark     ; immediate
: THEN   ( f orig -- )  swap ?condition  &gt;resolve   ; immediate
: BEGIN  ( -- f dest )  ?comp conditional_key &lt;mark   ; immediate
: AGAIN  ( f dest -- )  compile branch  swap ?condition  &lt;resolve  ; immediate
: UNTIL  ( f dest -- )  compile 0branch swap ?condition  &lt;resolve  ; immediate
: AHEAD  ( -- f orig )  compile branch   conditional_key &gt;mark     ; immediate</code></pre>
</blockquote>
<p>Conditional <em>primitives</em>?! Looks like conditional primitives aren&#39;t – they <em>define</em> them here. This COMPILE
BRANCH business modifies the code of a function that uses IF or THEN, at compile time. THEN – one part of the conditional –
writes (RESOLVEs) a branch offset to a point in code saved (MARKed) by IF, the other part of the conditional.</p>
<p>It&#39;s as if a conventional program modified the assembly instructions generated from it at compile time. What? How? Who? How
do I wrap my mind around this?</p>
<p>Shocked, I read the source of pForth.</p>
<p>Sort of understood how Forth code was represented and interpreted. Code is this array of &#34;execution tokens&#34; – function
pointers, numbers and a few built-ins like branches, basically. A Forth interpreter keeps an instruction pointer into this array
(ip), a data stack (ds), and a return stack (rs), and does this:</p>
<pre><strong>while</strong>(<strong>true</strong>) {
 <strong>switch</strong>(*ip) {
  <em>//arithmetics (+,-,*...):</em>
  <strong>case </strong>PLUS: ds.push(ds.pop() + ds.pop()); ++ip;
  <em>//stack manipulation (drop,swap,rot...):</em>
  <strong>case </strong>DROP: ds.pop(); ++ip;
  <em>//literal numbers (1,2,3...):</em>
  <strong>case </strong>LITERAL: ds.push(ip[1]); ip+=2;
  <em>//control flow:</em>
  <strong>case </strong>COND_BRANCH: <strong>if</strong>(!ds.pop()) ip+=ip[1]; <strong>else </strong>ip+=2;
  <strong>case </strong>RETURN: ip = rs.pop();
  <em>//user-defined words: save return address &amp; jump</em>
  <strong>default</strong>: rs.push(ip+1); ip = *ip;
 }
}</pre>
<p>That&#39;s it, pretty much. Similar, say, to the virtual stack machine used to implement Java. One difference is that compiling a
Forth program is basically writing to the code array in a WYSIWYG fashion. COMPILE SOMETHING simply appends the address of the
word SOMETHING to the end of the code array. So does plain SOMETHING when Forth is compiling rather than interpreting, as it is
between a colon and a semicolon, that is, when a word is defined.</p>
<p>So</p>
<pre>: DRAW-RECTANGLE 2DUP UP RIGHT DOWN LEFT ;</pre>
<p>simply appends {&amp;2dup,&amp;up,&amp;right,&amp;down,&amp;left,RETURN} to the code array. Very straightforward. There are
no parameters or declaration/expression syntax as in...</p>
<pre><strong>void </strong>drawRectangle(<strong>int </strong>width, <strong>int </strong>height) {
  up(height);
  right(width);
  down(height);
  left(width);
}</pre>
<p>...to make it less than absolutely clear how the source code maps to executable code. &#34;C maps straightforwardly to assembly&#34;?
Ha! <em>Forth</em> maps straightforwardly to assembly. Well, to the assembly language of a virtual stack machine, but still. So
one can understand how self-modifying code like IF and THEN works.</p>
<p>On the other hand, compared to drawRectangle, it is somewhat unclear what DRAW-RECTANGLE <em>does</em>. What are those 2
values on the top of the stack that 2DUP duplicates before meaningful English names appear in DRAW-RECTANGLE&#39;s definition? This
is supposed to be ameliorated by stack comments:</p>
<pre>: DRAW-RECTANGLE <em>( width height -- )</em> ... ;</pre>
<p>...tells us that DRAW-RECTANGLE expects to find height at the top of the stack, and width right below it.</p>
<p>I went on to sort of understand CREATE/DOES&gt; – a further extension of this compile-time self-modifying code business that
you use to &#34;define defining words&#34; (say, CONSTANT, VARIABLE, or CLASS). The CREATE part says what should be done when words
(say, class names) are defined by your new defining word. The DOES&gt; part says what should be done when those words are used.
For example:</p>
<pre>: CONSTANT
   CREATE ,
   DOES&gt; @
;
<em>\ usage example:</em>
7 CONSTANT DAYS-IN-WEEK
DAYS-IN-WEEK 2 + . <em>\ should print 9</em></pre>
<p>CREATE means that every time CONSTANT is called, a name is read from the source file (similarly to what WORD would have
done). Then a new word is created with that name (as a colon would have done). This word records the value of HERE – something
like sbrk(0), a pointer past the last allocated data item. When the word is executed, it pushes the saved address onto the data
stack, then calls the code after DOES&gt;. The code after CREATE can put some data after HERE, making it available later to the
DOES&gt; part.</p>
<p>With CONSTANT, the CREATE part just saves its input (in our example, 7) – the comma word does this: *HERE++ = ds.pop(); The
DOES&gt; part then fetches the saved number – the @ sign is the fetch word: ds.push( *ds.pop() );</p>
<p>CONSTANT works somewhat similarly to a class, CREATE defining its constructor and DOES&gt; its single method:</p>
<pre>class Constant
  def initialize(x) @x=x end
  def does() @x end
end
daysInWeek = Constant.new(7)
print daysInWeek.does() + 2</pre>
<p>...But it&#39;s much more compact on all levels.</p>
<p>Another example is defining C-like structs. Stripped down to their bare essentials (and in Forth things tend to be stripped
down to their bare essentials), you can say that:</p>
<pre><strong>struct </strong>Rectangle {
  <strong>int </strong>width;
  <strong>int </strong>height;
};</pre>
<p>...simply gives 8 (the structure size) a new name Rectangle, and gives 0 and 4 (the members&#39; offsets) new names, width and
height. Here&#39;s <a href="http://wiki.laptop.org/go/Forth_Lesson_18">one way to implement structs in Forth</a>:</p>
<pre>struct
  cell field width
  cell field height
constant rectangle

<em>\ usage example:</em>
<em>\ here CREATE is used just for allocation</em>
create r1 rectangle allot <em>\ r1=HERE; HERE+=8</em>
2 r1 width !
3 r1 height !
: area dup width @ swap height @ * ;
r1 area . <em>\ should print 6</em></pre>
<p>CELL is the size of a word; we could say &#34;4 field width&#34; instead of &#34;cell field width&#34; on 32b machines. Here&#39;s the definition
of FIELD:</p>
<pre> : field <em>( struct-size field-size -- new-struct-size )</em>
    create over , +
    does&gt; @ +
 ;</pre>
<p>Again, pretty compact. The CREATE part stores the offset, a.k.a current struct size (OVER does ds.push(ds[1]), comma does
*HERE++=ds.pop()), then adds the field size to the struct size, updating it for the next call to FIELD. The DOES&gt; part
fetches the offset, and adds it to the top of the stack, supposedly containing the object base pointer, so that &#34;rect width&#34; or
&#34;rect height&#34; compute &amp;rect.width or &amp;rect.height, respectively. Then you can access this address with @ or !
(fetch/store). STRUCT simply pushes 0 to the top of the data stack (initial size value), and at the end, CONSTANT consumes the
struct size:</p>
<pre>struct <em>\ data stack: 0</em>
  cell <em>( ds: 0 4 )</em> field width  <em>( ds: 4 )</em>
  cell <em>( ds: 4 4 )</em> field height <em>( ds: 8 )</em>
constant rectangle <em>( ds: as before STRUCT )</em></pre>
<p>You can further extend this to support polymorphic methods – METHOD would work similarly to FIELD, fetching a function
pointer (&#34;execution token&#34;) through a vtable pointer and an offset kept in the CREATEd part. <a href="http://www.jwdt.com/~paysan/screenful.html">A basic object system in Forth</a> can thus be implemented in one screen (a
Forth code size unit – 16 lines x 64 characters).</p>
<p>To this day, I find it shocking that you can <em>define defining words</em> like CONSTANT, FIELD, CLASS, METHOD – something
reserved to built-in keywords and syntactic conventions in most languages – and you can do it so compactly using such crude
facilities so trivial to implement. Back when I first saw this, I didn&#39;t know about DEFMACRO and how it could be used to
implement the defining words of CLOS such as DEFCLASS and DEFMETHOD (another thing about Lisp they don&#39;t teach in schools). So
Forth was completely mind-blowing.</p>
<p>And then I put Forth aside.</p>
<p>It seemed more suited for number crunching/&#34;systems programming&#34; than text processing/&#34;scripting&#34;, whereas it is scripting
that is the best trojan horse for pushing a language into an organization. Scripting is usually mission-critical without being
acknowledged as such, and many scripts are small and standalone. Look how many popular &#34;scripting languages&#34; there are as
opposed to &#34;systems programming languages&#34;. Then normalize it by the amount of corporate backing a language got on its way to
popularity. Clearly scripting is the best trojan horse.</p>
<p>In short, there were few opportunities to play with Forth at work, so I didn&#39;t. I fiddled with the interpreter and with the
metaprogramming and then left it at that without doing any real programming.</p>
<p>Here&#39;s what Jeff Fox, a prominent member of the Forth community who&#39;ve worked with Chuck Moore for years, has to say about
people like me:</p>
<blockquote>
<p>Forth seems to mean programming applications to some and porting Forth or dissecting Forth to others. And these groups don&#39;t
seem to have much in common.</p>
<p>...One learns one set of things about frogs from studying them in their natural environment or by getting a doctorate in
zoology and specializing in frogs. And people who spend an hour dissecting a dead frog in a pan of formaldehyde in a biology
class learn something else about frogs.</p>
<p>...One of my favorite examples was that one notable colorforth [a Forth dialect] <a href="https://yosefk.com/cgi-bin/comments.cgi?post=blog/my-history-with-forth-stack-machines#comment-2536" title="The &#34;enthusiast&#39;s&#34; reply; his perspective is different.">enthusiast</a> who had spent years studying it,
disassembling it, reassembling it and modifying it, and made a lot of public comments about it, but had never bothered running
it and in two years of &#39;study&#39; had not been able to figure out how to do something in colorforth as simple as:</p>
<pre><code>1 dup +</code></pre>
<p>...[such Forth users] seem to have little interest in what it does, how it is used, or what people using it do with it. But
some spend years doing an autopsy on dead code that they don&#39;t even run.</p>
<p>Live frogs are just very different than dead frogs.</p>
</blockquote>
<p>Ouch. Quite an assault not just on a fraction of a particular community, but on language geeks in general.</p>
<blockquote>
<p>I guess I feel that I could say that if it isn&#39;t solving a significant real problem in the real world it isn&#39;t really
Forth.</p>
</blockquote>
<p>True, I guess, and equally true from the viewpoint of someone extensively using any non-mainstream language and claiming
enormous productivity gains for experts. Especially true for the core (hard core?) of the Forth community, Forth being their
only weapon. They actually live in Forth; it&#39;s DIY taken to the extreme, something probably unparalleled in the history of
computing, except, perhaps, the case of Lisp environments and Lisp machines (again).</p>
<p>Code running on Forth chips. Chips designed with Forth CAD tools. Tools developed in a Forth environment running on the bare
metal of the desktop machine. No standard OS, file system or editor. All in recent years when absolutely nobody else would
attempt anything like it. They <a href="http://www.colorforth.com/1percent.html">claim to be 10x to 100x more productive</a>
than C programmers (a generic pejorative term for non-Forth programmers; Jeff Fox is careful to put &#34;C&#34; in quotes, presumably
either to make the term more generic or more pejorative).</p>
<blockquote>
<p>...people water down the Forth they do by not exercising most of the freedom it offers... by using Forth only as debugger or
a yet another inefficient scripting language to be used 1% of the time.</p>
<p>Forth is about the freedom to change the language, the compiler, the OS or even the hardware design and is very different
than programming languages that are about fitting things to a fixed language syntax in a narrow work context.</p>
</blockquote>
<p>What can be said of this? If, in order to &#34;really&#34; enter a programming culture, I need to both &#34;be solving a significant real
problem in the real world&#34; <em>and</em> exercising &#34;the freedom to change the language, the compiler, the OS or even the
hardware design&#34;, then there are very few options for entering this culture indeed. The requirement for &#34;real world work&#34; is
almost by definition incompatible with &#34;the freedom to change the language, the compiler, the OS and the hardware design&#34;.</p>
<p>And then it so happened that I started working on a real-world project about as close to Forth-level DIY as possible. It was
our own hardware, with our own OS, our own compilers, designed to be running our own application. We did use standard CAD tools,
desktop operating systems and editors, and had standard RISC cores in the chip and standard C++ cross compilers for them. Well,
everyone has weaknesses. Still, the system was custom-tailored, embedded, optimized, standalone, with lots of freedom to
exercise – pretty close to the Forth way, in one way.</p>
<p>One part of the system was an image processing co-processor, a variation on the VLIW theme. Its memory access and control
flow was weird and limited, to the effect that you could neither access nor jump to an arbitrary memory address. It worked fine
for the processing-intensive parts of our image processing programs.</p>
<p>We actually intended to glue those parts together with a few &#34;control instructions&#34; setting up the plentiful control
registers of this machine. When I tried, it quickly turned out, as was to be expected, that those &#34;control instructions&#34; must be
able to do, well, everything – arithmetic, conditions, loops. In short, we needed a CPU.</p>
<p>We thought about buying a CPU, but it was unclear how we could use an off-the-shelf product. We needed to dispatch VLIW
instructions from the same instruction stream. We also needed a weird mixture of features. No caches, no interrupts, no need for
more than 16 address bits, but for accessing 64 data bits, and 32-bit arithmetic.</p>
<p>We thought about making our own CPU. The person with the overall responsibility for the hardware design gently told me that I
was out of my mind. CPUs have register files and pipeline and pipeline stalls and dependency detection to avoid those stalls and
it&#39;s too complicated.</p>
<p>And then I asked, how about a stack machine? No register file. Just a 3-stage pipeline – fetch, decode, execute. No problem
with register dependencies, always pop inputs from the top of the stack, push the result.</p>
<p>He said it sounded easy enough alright, we could do that. &#34;It&#39;s just like my RPN calculator. How would you program it?&#34; &#34;In
Forth!&#34;</p>
<p>I defined the instruction set in a couple of hours. It mapped to Forth words as straightforwardly as possible, plus it had a
few things Forth doesn&#39;t have that C might need, as a kind of insurance (say, access to 16-bit values in memory).</p>
<p>This got approved and implemented; not that it became the schedule bottleneck, but it was harder than we thought. Presumably
that was partly the result of <em>not</em> reading &#34;<a href="http://www.ece.cmu.edu/~koopman/stack_computers/index.html">Stack
Computers: the new wave</a>&#34;, and <em>not</em> studying the chip designs of Forth&#39;s creator Chuck Moore, either. I have a
feeling that knowledgable people would have sneered at this machine: it was trivial to compile Forth to it, but at the cost of
complicating the hardware.</p>
<p>But I was satisfied – I got a general-purpose CPU for setting up my config regs at various times through my programs, and as
a side effect, I got a Forth target. And even if it wasn&#39;t the most cost-effective Forth target imaginable, it was definitely a
time to start using Forth at work.</p>
<p>(Another area of prior art on stack machines that I failed to study in depth was <a href="http://www.jwdt.com/~paysan/4stack.html">4stack</a> – an actual VLIW stack machine, with 4 data stacks as suggested by its
name. I was very interested in it, especially during the time when we feared implementation problems with the multi-port
register file feeding our multiple execution units. I didn&#39;t quite figure out how programs would map to 4stack and what the
efficiency drop would be when one had to spill stuff from the data stacks to other memory because of data flow complications. So
we just went for a standard register file and it worked out.)</p>
<p>The first thing I did was write a Forth cross-compiler for the machine – a 700-line C++ file (and for reasons unknown, the
slowest-compiling C++ code that I have ever seen).</p>
<p>I left out all of the metaprogramming stuff. For instance, none of the Forth examples above, the ones that drove me to Forth,
could be made to work in my own Forth. No WORD, no COMPILE, no IMMEDIATE, no CREATE/DOES&gt;, no nothing. Just colon
definitions, RPN syntax, flow control words built into the compiler. &#34;Optimizations&#34; – trivial constant folding so that 1 2 +
becomes 3, and inlining – :INLINE 1 + ; works just like : 1 + ; but is inlined into the code of the caller. (I was working on
the bottlenecks so saving a CALL and a RETURN was a big deal.) So I had that, plus inline assembly for the VLIW instructions.
Pretty basic.</p>
<p>I figured I didn&#39;t need the more interesting metaprogramming stuff for my first prototype programs, and I could add it later
if it turned out that I was wrong. It was wierd to throw away everything I originally liked the most, but I was all set to start
writing real programs. Solving real problems in the real world.</p>
<p>It was among the most painful programming experiences in my life.</p>
<p>All kinds of attempts at libraries and small test programs aside, my biggest program was about 700 lines long (that&#39;s 1 line
of compiler code for 1 line of application code). Here&#39;s a sample function:</p>
<pre><strong>: mean_std</strong> <em>( sum2 sum inv_len -- mean std )
</em>  <em>\ precise_mean = sum * inv_len;</em>
  <strong>tuck u*</strong> <em>\ sum2 inv_len precise_mean</em>
  <em>\ mean = precise_mean &gt;&gt; FRAC;</em>
  <strong>dup FRAC rshift -rot3</strong> <em>\ mean sum2 inv_len precise_mean</em>
  <em>\ var = (((unsigned long long)sum2 * inv_len) &gt;&gt; FRAC) - (precise_mean * precise_mean &gt;&gt; (FRAC*2));</em>
  <strong>dup um* nip FRAC 2 * 32 - rshift -rot</strong> <em>\ mean precise_mean^2 sum2 inv_len</em>
  <strong>um* 32 FRAC - lshift swap FRAC rshift or</strong> <em>\ mean precise_mean^2 sum*inv_len</em>
  <strong>swap - isqrt</strong> <em>\ mean std</em>
<strong>;</strong></pre>
<p>Tuck u*.</p>
<p>This computes the mean and the standard deviation of a vector given the sum of its elements, the sum of their squares, and
the inverse of its length. It uses scaled integer arithmetic: inv_len is an integer keeping (1&lt;&lt;FRAC)/length. How it
arranges the data on the stack is beyond me. It was beyond me at the time when I wrote this function, as indicated by the
plentiful comments documenting the stack state, amended by wimpy C-like comments (&#34;C&#34;-like comments) explaining the meaning of
the postfix expressions.</p>
<p>This nip/tuck business in the code? Rather than a reference to the drama series on plastic surgery, these are names of Forth
stack manipulation words. You can look them up in the standard. I forgot what they do, but it&#39;s, like, ds.insert(2,ds.top()),
ds.remove(1), this kind of thing.</p>
<p>Good Forth programmers reportedly don&#39;t use much of those. Good Forth programmers arrange things so that they <em>flow</em>
on the stack. Or they use local variables. My DRAW-RECTANGLE definition above, with a 2DUP, was reasonably flowing by my
standards: you get width and height, duplicate both, and have all 4 data items – width,height,width,height – consumed by the
next 4 words. Compact, efficient – little stack manipulation. Alternatively we could write:</p>
<pre>: DRAW-RECTANGLE { width height }
  height UP
  width RIGHT
  height DOWN
  width LEFT
;</pre>
<p>Less compact, but very readable – not really, if you think about it, since nobody knows how much stuff UP leaves on the stack
and what share of that stuff RIGHT consumes, but readable enough if you assume the obvious. One reason not to use locals is that
Chuck Moore hates them:</p>
<blockquote>
<p>I remain adamant that local variables are not only useless, they are harmful.</p>
<p>If you are writing code that needs them you are writing non-optimal code. Don&#39;t use local variables. Don&#39;t come up with new
syntax for describing them and new schemes for implementing them. You can make local variables very efficient especially if you
have local registers to store them in, but don&#39;t. It&#39;s bad. It&#39;s wrong.</p>
<p>It is necessary to have [global] variables. ... I don&#39;t see any use for [local] variables which are accessed
instantaneously.</p>
</blockquote>
<p>Another reason not to use locals is that it takes time to store and fetch them. If you have two items on a data stack on a
hardware stack machine, + will add them in one cycle. If you use a local, then it will take a cycle to store its value with {
local_name }, and a cycle to fetch its value every time you mention local_name. On the first version of our machine, it was
worse as fetching took 2 cycles. So when I wrote my Forth code, I had to make it &#34;flow&#34; for it to be fast.</p>
<p>The abundance of DUP, SWAP, -ROT and -ROT3 in my code shows that making it flow wasn&#39;t very easy. One problem is that every
stack manipulation instruction <em>also</em> costs a cycle, so I started wondering whether I was already past the point where I
had a net gain. The other problem was that I couldn&#39;t quite follow this flow.</p>
<p>Another feature of good Forth code, which supposedly helps achieve the first good feature (&#34;flow&#34; on the stack), is
factoring. Many small definitions.</p>
<blockquote>
<p>Forth is highly factored code. I don&#39;t know anything else to say except that Forth is definitions. If you have a lot of small
definitions you are writing Forth. In order to write a lot of small definitions you have to have a stack.</p>
</blockquote>
<p>In order to have <em>really</em> small definitions, you do need a stack, I guess – or some other implicit way of passing
parameters around; if you do that <em>explicitly</em>, definitions get bigger, right? That&#39;s how you can get somewhat Forth-y
with Perl – passing things through the implicit variable $_: call chop without arguments, and you will have chopped $_.</p>
<p>Anyway, I tried many small definitions:</p>
<pre><strong>:inline num_rects params @ ;
:inline sum  3 lshift gray_sums + ;
:inline sum2 3 lshift gray_sums 4 + + ;
:inline rect_offset 4 lshift ;
:inline inv_area rect_offset rects 8 + + @ ;
:inline mean_std_stat </strong><em>( lo hi -- stat )</em>
  <strong>FRAC lshift swap 32 FRAC - rshift or
;
: mean_std_loop</strong>
 <em>\ inv_global_std = (1LL &lt;&lt; 32) / MAX(global_std, 1);
</em> <strong>dup 1 max 1 swap u/mod-fx32 drop</strong> <em>\ 32 frac bits</em>

 <strong>num_rects </strong><em>\ start countdown</em>
 <strong>begin</strong>
  <strong>1 - </strong><em>\ rects--</em>
  <strong>dup sum2 @
  over sum @
  pick2 inv_area
  mean_std </strong><em>\ global_mean global_std inv_global_std rectind mean std</em>
  <strong>rot dup { rectind } 2 NUM_STATS * * stats_arr OFT 2 * + + { stats }</strong>
  <em>\ stats[OFT+0] = (short)( ((mean - global_mean) * inv_global_std) &gt;&gt; (32 - FRAC) );
  \ stats[OFT+1] = (short)( std * inv_global_std &gt;&gt; (32 - FRAC) );</em>
  <strong>pick2       um* mean_std_stat stats 2 + h! </strong><em>\ global_mean global_std inv_global_std mean</em>
  <strong>pick3 - over m* mean_std_stat stats h!
  rectind ?dup 0 = </strong><em>\ quit at rect 0</em>
<strong> until
 drop 2drop
;</strong></pre>
<p>I had a bunch of those short definitions, and yet I couldn&#39;t get rid of heavy functions with DUP and OVER and PICK and &#34;C&#34;
comments to make any sense of it. This stack business just wasn&#39;t for me.</p>
<blockquote>
<p>Stacks are not popular. It&#39;s strange to me that they are not. There is just a lot of pressure from vested interests that
don&#39;t like stacks, they like registers.</p>
</blockquote>
<p>But I actually had a vested interest in stacks, and I began to like registers more and more. The thing is, expression
<em>trees</em> map perfectly to stacks: (a+b)*(c-d) becomes a b + c d – *. Expression <em>graphs</em>, however, start to get
messy: (a+b)*a becomes a dup b + *, and this dup cluttering things up is a moderate example. And an &#34;expression graph&#34; simply
means that you use something more than once. How come this clutters up my code? This is <em>reuse</em>. A kind of
<em>factoring</em>, if you like. Isn&#39;t factoring <em>good</em>?</p>
<p>In fact, now that I thought of it, I didn&#39;t understand <em>why stacks were so popular</em>. Vested interests, perhaps? Why is
the JVM bytecode and the .NET bytecode and even CPython&#39;s bytecode all target stack VMs? Why not use registers the way LLVM
does?</p>
<p>Speaking of which. I started to miss a C compiler. I downloaded LLVM. (7000 files plus a huge precompiled gcc binary. 1 hour
to build from scratch. So?) I wrote a working back-end for the stack machine within a <em>week</em>. Generating horrible code.
Someone else wrote an optimizing back-end in about two months.</p>
<p>After a while, the optimizing back-end&#39;s code wasn&#39;t any worse than my hand-coded Forth. Its job was somewhat easier than
mine since by the time it arrived, it only took 1 cycle to load a local. On the other hand, loads were fast as long as they
weren&#39;t interleaved with stores – some pipeline thing. So the back-end was careful to reorder things so that huge sequences of
loads went first and then huge sequences of stores. Would be a pity to have to do that manually in Forth.</p>
<p>You have no idea how much fun it is to just splatter named variables all over the place, use them in expressions in whatever
order you want, and have the compiler schedule things. Although you do it all day. And that was pretty much the end of Forth on
that machine; we wrote everything in C.</p>
<p>What does this say about Forth? Not much except that it isn&#39;t for me. Take Prolog. I know few things more insulting than
having to code in Prolog. Whereas Armstrong developed Erlang in Prolog and liked it much better than reimplementing Erlang in C
for speed. I can&#39;t imagine how this could be, but this is how it was. People are different.</p>
<p>Would a good Forth programmer do better than me? Yes, but not just at the level of writing the code differently. Rather, at
the level of doing <em>everything</em> differently. Remember the freedom quote? &#34;Forth is about the freedom to change the
language, the compiler, the OS or even the hardware design&#34;.</p>
<p>...And the freedom to change the <em>problem</em>.</p>
<p>Those computations I was doing? In Forth, they wouldn&#39;t just write it <em>differently</em>. They wouldn&#39;t implement them
<em>at all</em>. In fact, we didn&#39;t implement them after all, either. The algorithms which made it into production code were
very different – in our case, <em>more</em> complicated. In the Forth case, they would have been <em>less</em> complicated. Much
less.</p>
<p>Would less complicated algorithms work? I don&#39;t know. Probably. Depends on the problem though. Depends on how you define
&#34;work&#34;, too.</p>
<p>The tiny VLSI toolchain from the epigraph? I showed <a href="http://www.colorforth.com/vlsi.html">Chuck Moore&#39;s
description</a> of that to an ASIC hacker. He said it was very simplistic – no way you could do with that what people are doing
with standard tools.</p>
<p>But Chuck Moore <em>isn&#39;t</em> doing <em>that</em>, under the assumption that you <em>need not to</em>. Look at the <a href="http://greenarraychips.com/home/products/index.html">chips</a> he&#39;s making. 144-core, but the cores (nodes) are tiny – why
would you want them big, if you feel that you can do anything with almost no resources? And they use 18-bit words. Presumably
under the assumption that 18 bits is a good quantity, not too small, not too large. Then they write <a href="http://www.greenarraychips.com/home/documents/pub/AP001-MD5.html">an application note</a> about imlpementing the MD5 hash
function:</p>
<blockquote>
<p>MD5 presents a few problems for programming a Green Arrays device. For one thing it depends on modulo 32 bit addition and
rotation. Green Arrays chips deal in 18 bit quantities. For another, MD5 is complicated enough that neither the code nor the set
of constants required to implement the algorithm will fit into one or even two or three nodes of a Green Arrays computer.</p>
</blockquote>
<p>Then they solve these problems by manually implementing 32b addition and splitting the code across nodes. But if MD5 weren&#39;t
a standard, you could implement your own hash function without going to all this trouble.</p>
<p>In his chip design tools, Chuck Moore naturally did not use the standard equations:</p>
<blockquote>
<p>Chuck showed me the equations he was using for transistor models in OKAD and compared them to the SPICE equations that
required solving several differential equations. He also showed how he scaled the values to simplify the calculation. It is
pretty obvious that he has sped up the inner loop a hundred times by simplifying the calculation. He adds that his calculation
is not only faster but more accurate than the standard SPICE equation. ... He said, &#34;I originally chose mV for internal units.
But using 6400 mV = 4096 units replaces a divide with a shift and requires only 2 multiplies per transistor. ... Even the
multiplies are optimized to only step through as many bits of precision as needed.</p>
</blockquote>
<p><em>This</em> is Forth. Seriously. Forth is <em>not</em> the language. Forth the language captures nothing, it&#39;s a moving
target. Chuck Moore constantly tweaks the language and largely dismisses the ANS standard as rooted in the past and bloated.
Forth is the approach to engineering aiming to produce as small, simple and optimal system as possible, by shaving off as many
requirements of every imaginable kind as you can.</p>
<p><em>That&#39;s</em> why its metaprogramming is so amazingly compact. It&#39;s similar to Lisp&#39;s metaprogramming in much the same way
bacterial genetic code is similar to that of humans – both reproduce. Humans also do many other things that bacteria can&#39;t
(...No compatibility. No files. No operating system). And have a ton of useless junk in their DNA, their bodies and their
habitat.</p>
<p>Bacteria have no junk in their DNA. Junk slows down the copying of the DNA which creates a reproduction bottleneck so junk
mutations can&#39;t compete. If it <em>can</em> be eliminated, it <em>should</em>. Bacteria are small, simple, optimal systems, with
as many requirements shaved off as possible. They won&#39;t conquer space, but they&#39;ll survive a nuclear war.</p>
<p>This stack business? Just a tiny aspect of the matter. You have complicated expression graphs? <em>Why</em> do you have
complicated expression graphs? The reason Forth the language doesn&#39;t have variables is because you <em>can</em> eliminate
them<em>,</em> therefore they are <em>junk</em>, therefore you <em>should</em> eliminate them. What about those expressions in
your Forth program? Junk, most likely. <em>Delete!</em></p>
<p>I can&#39;t do that.</p>
<p>I can&#39;t face people and tell them that they have to use 18b words. In fact I take pride in the support for all the data types
people are used to from C in our VLIW machine. You can add signed bytes, and unsigned shorts, and you even have instructions
adding bytes to shorts. Why? Do I believe that people actually need all those combinations? Do I believe that they can&#39;t force
their 16b unsigned shorts into 15b signed shorts to save hardware the trouble?</p>
<p>OF COURSE NOT.</p>
<p>They just don&#39;t want to. They want their 16 bits. They whine about their 16th bit. Why do they want 16 and not 18? Because
they grew up on C. &#34;C&#34;. It&#39;s completely ridiculous, but nevertheless, people are like that. And I&#39;m not going to fight that,
because <em>I</em> am not responsible for algorithms, other people are, and I want them happy, at least to a reasonable extent,
and if they can be made happier at a reasonable cost, I gladly pay it. (I&#39;m not saying you can&#39;t market a machine with a limited
data type support, just using this as an example of the kind of junk I&#39;m willing to carry that in Forth it is not recommended to
carry.)</p>
<p>Why pay this cost? Because I don&#39;t do algorithms, other people do, so I <em>have</em> to trust them and respect their
judgment to a large extent. Because you need superhuman abilities to work without layers. My minimal stack of layers is –
problem, software, hardware. People working on the problem (algorithms, UI, whatever) can&#39;t do software, not really. People
doing software can&#39;t do hardware, not really. And people doing hardware can&#39;t do software, etc.</p>
<p>The Forth way of focusing on just the problem you need to solve seems to more or less require that the same person or a very
tightly united group focus on all three of these things, and pick the right algorithms, the right computer architecture, the
right language, the right word size, etc. I don&#39;t know how to make this work.</p>
<p>My experience is, you try to compress the 3 absolutely necessary layers to 2, you get a disaster. Have your algorithms people
talk directly to your hardware people, without going through software people, and you&#39;ll get a disaster. Because neither
understands software very well, and you&#39;ll end up with an unusable machine. Something with elaborate computational capabilities
that can&#39;t be put together into anything meaningful. Because gluing it together, dispatching, that&#39;s the software part.</p>
<p>So you need at least 3 teams, or people, or hats, that are to an extent ignorant about each other&#39;s work. <em>Even if</em>
you&#39;re doing everything in-house, which, according to Jeff Fox, was essentially a precondition to &#34;doing Forth&#34;. So there&#39;s
another precondtion – having people being able to do what at least 3 people in their respective areas normally do, and
concentrating on those 3 things at the same time. Doing the cross-layer global optimization.</p>
<p>It&#39;s not how I work. I don&#39;t have the brain nor the knowledge nor the love for prolonged meditation. I compensate with, um,
people skills. I find out what people need, that is, what they <em>think</em> they need, and I negotiate, and I find reasonable
compromises, and I include my narrow understanding of my part – software tools and such – into those compromises. This drags
junk in. I live with that.</p>
<blockquote>
<p>I wish I knew what to tell you that would lead you to write good Forth. I can demonstrate. I have demonstrated in the past,
ad nauseam, applications where I can reduce the amount of code by 90% and in some cases 99%. It can be done, but in a case by
case basis. The general principle still eludes me.</p>
</blockquote>
<p>And I think he can, especially when compatibility isn&#39;t a must. But not me.</p>
<p>I still find Forth amazing, and I&#39;d gladly hack on it upon any opportunity. It still gives you the most bang for the buck –
it implements the most functionality in the least space. So still a great fit for tiny targets, and unlikely to be surpassed.
Both because it&#39;s optimized so well and because the times when only bacteria survived in the amounts of RAM available are
largely gone so there&#39;s little competition.</p>
<p>As to using Forth as a source of ideas on programming and language design in general – not me. I find that those ideas grow
out of an approach to problem solving that I could never apply.</p>
<p><strong>Update (July 2014)</strong>: Jeff Fox&#39;s &#34;dead frog dissector&#34; explained his view of the matter in a <a href="https://yosefk.com/cgi-bin/comments.cgi?post=blog/my-history-with-forth-stack-machines#comment-2536">comment</a> to this article, telling us
why <em>the frog</em> (colorForth) died in his hands in the first place... A rather enlightening incident, this little
story.</p>
</div></div>
  </body>
</html>
