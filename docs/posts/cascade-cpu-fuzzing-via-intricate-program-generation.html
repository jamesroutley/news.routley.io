<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://comsec.ethz.ch/research/hardware-design-security/cascade-cpu-fuzzing-via-intricate-program-generation/">Original</a>
    <h1>Cascade: CPU Fuzzing via Intricate Program Generation</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
			<!-- If has sidebar start -->
	<main id="main">
		<div>
			<!-- If has sidebar end -->
							<article id="post-1180" class="page">
										<!-- .entry-header -->
					<div>
						
<h3>TL;DR</h3>



<p><strong>Cascade</strong> is a RISC-V CPU fuzzer that generates <strong>valid</strong>, <strong>long</strong> and <strong>complex</strong> programs, and relies on a termination cascade-effect for bug detection. It detected 37 <strong>new</strong> bugs (29 new CVEs) in 5 RISC-V CPUs, which is more than all the existing fuzzers, combined. You can read a paper we wrote on Cascade <a href="https://comsec.ethz.ch/wp-content/files/cascade_sec24.pdf">here</a> and try it out <a href="https://github.com/comsec-group/cascade-artifacts">here</a>. Below is a video demo of it finding a bug in CVA6:</p>



<figure><p>
<iframe title="Cascade finding a bug in the CVA6 RISC-V CPU" width="780" height="439" src="https://www.youtube.com/embed/rz4M7uY_1NM?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</p></figure>



<h2>Motivation</h2>



<p>Fuzzing CPUs is akin to generating interesting programs, and observing expressions of buggy behaviors. An effective CPU fuzzing campaign must have some fundamental properties.</p>



<ul>
<li>Programs must be long to increase fuzzing throughput.</li>



<li>Programs must be complex to increase the probability of triggering a bug.</li>



<li>The fuzzer must reliably and efficiently detect bugs, once triggered.</li>
</ul>



<h2>Pitfalls of existing fuzzers</h2>



<p>Existing CPU fuzzers do not comply with these fundamental properties. Fuzzers may have the following shortcomings:</p>



<ul>
<li>Programs are short by design with trivial control flows.</li>



<li>The executed portion of the programs are short because the control flow is poorly managed.</li>



<li>Most instructions are not randomized and correspond to initialization and finalization.</li>



<li>Only a small part of the ISA is covered.</li>



<li>The CPU state is checked at instruction granularity, significantly impacting the fuzzing performance.</li>



<li>Bugs have a high chance of being shadowed because their expression is eventually overwritten in the control flow.</li>
</ul>



<p>Ultimately, a fuzzer with such pitfalls will suffer from critical weaknesses which will likely make fuzzing campaigns ineffective or inefficient.</p>



<h2>Cascade</h2>



<p>Cascade is a RISC-V CPU fuzzer that generates valid, long and complex programs, and relies on a cascade-effect termination for bug detection. Fuzzing proceeds as follows:</p>



<ul>
<li>Intermediate program construction: First, Cascade builds an intermediate program with complex data and control flows, the latter being independent of the former.</li>



<li>Ultimate program construction: Cascade simulates the program using a golden model of the ISA to collect feedback about the behavior of the data flow. From this feedback, it entangles the data flow into the control flow to build the ultimate version of the program.</li>



<li>Ultimate program execution: Cascade executes the program on the CPU under test. Non-terminations indicate that a bug has been triggered by a program.</li>
</ul>



<p>Below you can see a design diagram of Cascade:</p>


<div>
<figure><img decoding="async" fetchpriority="high" width="1024" height="401" src="https://comsec.ethz.ch/wp-content/uploads/2023/10/cascade-1024x401.png" alt="" srcset="/wp-content/uploads/2023/10/cascade-1024x401.png 1024w, /wp-content/uploads/2023/10/cascade-300x117.png 300w, /wp-content/uploads/2023/10/cascade-768x301.png 768w, /wp-content/uploads/2023/10/cascade-1536x602.png 1536w, /wp-content/uploads/2023/10/cascade-1560x611.png 1560w, /wp-content/uploads/2023/10/cascade.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure></div>


<h2>Bug detection</h2>



<p>A common but unsatisfying way of detecting whether a bug has been triggered is to compare, instruction by instruction, whether the CPU state matches with the golden model state. This method is difficult to implement and expensive in terms of performance.</p>



<p>In Cascade-generated programs, due to the entanglement of data and control flow, a bug in the data flow will have a very high chance of altering the control flow, causing non-termination.</p>



<h2>Asynchronous ISA pre-simulation</h2>



<p>To transform an intermediate program into an ultimate program, i.e., to entangle the data flow into the control flow, Cascade uses the feedback from spike, a golden model of the RISC-V ISA to determine some <em>dependent</em> register values generated by critical points in the program. Knowing these values allows correcting them at a later point of the program to achieve the same control-flow and exceptional behavior as in the intermediate program, while entangling the data flow into the control flow. While there may be many dependent values and control-flow changes in a program, we show that a single careful execution of the ISA golden model suffices to entangle the data flow into the control flow at all points of the program.</p>



<h2>Reduction of buggy programs</h2>



<p>Cascade found tens of new bugs, but the programs that trigger them are long and complex. Cascade features a new mechanism that reduces bug-triggering programs into very few instructions, while preserving the bug-preserving behavior. Here is the Cascade’s bug reduction mechanism in action:</p>



<figure><p>
<iframe title="Cascade fuzzer reducing a program that triggers a bug to minimal instructions" width="780" height="585" src="https://www.youtube.com/embed/E0a65qcQN9U?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</p></figure>



<h2>Discovered vulnerabilities</h2>



<p>Cascade found 37 new bugs (29 new CVEs) in 5 RISC-V CPUs. We reported them to their respective maintainers and fixed some of them ourselves. The discovered bugs have many security implications, ranging from information leakage to denial of service from user mode by a specific operation executed under speculation. Please look at the <a href="https://comsec.ethz.ch/wp-content/files/cascade_sec24.pdf">paper</a> if you want to know more about the bugs. The figure below summarizes the security impact of these bugs:</p>


<div>
<figure><img decoding="async" loading="lazy" width="1024" height="343" src="https://comsec.ethz.ch/wp-content/uploads/2023/10/Screenshot-from-2023-10-23-10-47-54-1024x343.png" alt="" srcset="/wp-content/uploads/2023/10/Screenshot-from-2023-10-23-10-47-54-1024x343.png 1024w, /wp-content/uploads/2023/10/Screenshot-from-2023-10-23-10-47-54-300x100.png 300w, /wp-content/uploads/2023/10/Screenshot-from-2023-10-23-10-47-54-768x257.png 768w, /wp-content/uploads/2023/10/Screenshot-from-2023-10-23-10-47-54.png 1249w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure></div>


<h2>Paper and code:</h2>



<p><a href="https://comsec.ethz.ch/wp-content/files/cascade_sec24.pdf">Cascade</a> will be presented at USENIX Security ‘24, and is readily open-source <a href="https://github.com/comsec-group/cascade-artifacts">here</a>! Use it on your CPU if you want to make sure your RISC-V CPU does not suffer from security bugs and let us know if you found new bugs! Bing created the following logo for Cascade:</p>


<div>
<figure><img decoding="async" loading="lazy" width="300" height="300" src="https://comsec.ethz.ch/wp-content/uploads/2023/10/cascade_logo-300x300.jpeg" alt="" srcset="/wp-content/uploads/2023/10/cascade_logo-300x300.jpeg 300w, /wp-content/uploads/2023/10/cascade_logo-150x150.jpeg 150w, /wp-content/uploads/2023/10/cascade_logo-768x768.jpeg 768w, /wp-content/uploads/2023/10/cascade_logo.jpeg 1024w" sizes="(max-width: 300px) 100vw, 300px"/></figure></div>


<h2>Frequently Asked Questions</h2>



<p><strong>Cascade found many bugs. Is RISC-V insecure?<br/></strong>Given today’s highly manual RTL design flows, the appearance of bugs is very likely, regardless of the ISA. Note that more than 1000 errata were released in Intel Core and AMD CPUs in recent years (see <a href="https://comsec.ethz.ch/research/hardware-design-security/rememberr/">RemembERR</a>). Hence, from Cascade’s findings, there is no reason to consider RISC-V to be inherently less secure than other ISAs.</p>



<p><strong>I am a consumer, should I worry that Cascade finds bugs in my CPU?</strong></p>



<p><strong>Is Cascade only for RISC-V?</strong></p>



<p><strong>Can I use Cascade in CI/CD?</strong></p>



<p><strong>After fixing all the reported bugs, my CPU is now validated by Cascade. Is my CPU now perfectly safe and functional?</strong></p>



<p><strong>What RISC-V extensions are currently being fuzzed by Cascade?<br/></strong>Cascade fuzzes rv[32-64]imfd, including exceptions, MSU privilege transitions and many CSR interactions. We plan to add new fuzzing features such as memory virtualization and compressed instructions in the future. Feel free to contribute?</p>



<p><strong>How can I contribute to Cascade?</strong></p>



<h2>Acknowledgements</h2>



<p>This work was supported in part by a Microsoft Swiss JRC grant and by the Swiss State Secretariat for Education, Research and Innovation under contract number MB22.00057 (ERC-StG PROMISE).</p>
					</div><!-- .entry-content -->
				</article><!-- #post -->
							<!-- If has sidebar start -->
		</div>
				<!-- If has sidebar end -->
		</main><!-- .site-main -->
	</div></div>
  </body>
</html>
