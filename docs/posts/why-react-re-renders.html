<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.joshwcomeau.com/react/why-react-re-renders/">Original</a>
    <h1>Why React Re-Renders</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><a id="introduction"><h2>Introduction</h2></a><p>So, I&#39;ll be honest. I had been working professionally with React <em>for years</em> without really understanding how React&#39;s re-rendering process worked. üòÖ</p><p>I think this is true for lots of React developers. We understand enough to get by, but if you ask a group of React developers a question like <em>‚ÄúWhat triggers a re-render in React?‚Äù</em>, you&#39;ll likely get a handful of different hand-wavy answers.</p><p>There are a lot of misconceptions out there about this topic, and it can lead to a lot of uncertainty. If we don&#39;t understand React&#39;s render cycle, how can we understand how to use <code>React.memo</code>, or when we should wrap our functions in <code>useCallback</code>??</p><p>In this tutorial, we&#39;re going to build a mental model for when and why React re-renders. We&#39;ll also learn how to tell <em>why</em> a specific component re-rendered, using the React devtools.</p><p>So, let&#39;s start with a fundamental truth: <strong>Every re-render in React starts with a state change.</strong> It&#39;s the only ‚Äútrigger‚Äù in React for a component to re-render.<span></span></p><p>Now, that probably doesn&#39;t sound right... after all, don&#39;t components re-render when their props change? What about context??</p><p>Here&#39;s the thing: when a component re-renders, <strong>it also re-renders all of its descendants.</strong></p><p>Let&#39;s look at an example:</p><div><div data-id="basic-example" data-can-be-annotated="false"><div data-is-fullscreened="false"><div><div><header><p>Code Playground<!-- --> </p></header><div><div><div><div><div aria-describedby="enter-instructions-:Rq2taim:" aria-label="Code Editor for App.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span><span>;</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>Counter</span> <span>/&gt;</span>
      <span>&lt;</span><span>footer</span><span>&gt;</span>
        <span>&lt;</span><span>p</span><span>&gt;</span>Copyright 2022 Big Count Inc.<span>&lt;/</span><span>p</span><span>&gt;</span>
      <span>&lt;/</span><span>footer</span><span>&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>count</span><span>,</span> <span>setCount</span><span>]</span> = <span>React</span>.<span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>main</span><span>&gt;</span>
      <span>&lt;</span><span>BigCountNumber</span> <span>count</span>=<span>{</span><span>count</span><span>}</span> <span>/&gt;</span>
      <span>&lt;</span><span>button</span> <span>onClick</span>=<span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setCount</span><span>(</span><span>count</span> + <span>1</span><span>)</span><span>}</span><span>&gt;</span>
        Increment
      <span>&lt;/</span><span>button</span><span>&gt;</span>
    <span>&lt;/</span><span>main</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>BigCountNumber</span><span>(</span><span>{</span> <span>count</span> <span>}</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>p</span><span>&gt;</span>
      <span>&lt;</span><span>span</span> <span>className</span>=<span>&#34;prefix&#34;</span><span>&gt;</span>Count:<span>&lt;/</span><span>span</span><span>&gt;</span>
      <span>{</span><span>count</span><span>}</span>
    <span>&lt;/</span><span>p</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>App</span><span>;</span></pre></div></div></div></div></div></div></div></div></div></div><p>In this example, we have 3 components: <code>App</code> at the top, which renders <code>Counter</code>, which renders <code>BigCountNumber</code>.</p><p>In React, every state variable is attached to a particular component instance. In this example, we have a single piece of state, <code>count</code>, which is associated with the <code>Counter</code> component.</p><p>Whenever this state changes, <code>Counter</code> re-renders. And because <code>BigCountNumber</code> is being rendered by <code>Counter</code>, it too will re-render.</p><p>Here&#39;s an <em color="var(--color-secondary)">interactive graph</em> that shows this mechanic in action. Click the ‚ÄúIncrement‚Äù button to trigger a state change:</p><div><div><div id="bigcountnumber"><p>BigCountNumber</p><p>Props:<!-- --> { <!-- -->count<!-- --> }</p></div></div></div><p>(The <span>green flash</span> signifies that a component is <em>re-rendering.</em>)</p><p>Alright, let&#39;s clear away <em color="var(--color-secondary)">Big Misconception #1</em>: <strong>The entire app re-renders whenever a state variable changes.</strong></p><p>I know some developers believe that every state change in React forces an application-wide render, but this isn&#39;t true. Re-renders only affect the component that owns the state + its descendants (if any). The <code>App</code> component, in this example, doesn&#39;t have to re-render when the <code>count</code> state variable changes.</p><p>Rather than memorize this as a rule, though, let&#39;s take a step back and see if we can figure out <em>why</em> it works this way.</p><p>React&#39;s ‚Äúmain job‚Äù is to keep the application UI in sync with the React state. The point of a re-render is to <strong>figure out what needs to change.</strong></p><p>Let&#39;s consider the ‚ÄúCounter‚Äù example above. When the application first mounts, React renders all of our components and comes up with the following sketch for what the DOM should look like:</p><pre></pre><p>When the user clicks on the button, the <code>count</code> state variable flips from <code>0</code> to <code>1</code>. How does this affect the UI? Well, that&#39;s what we hope to learn from doing another render!</p><p>React re-runs the code for the <code>Counter</code> and <code>BigCountNumber</code> components, and we generate a new sketch of the DOM we want:</p><pre></pre><p>Each render is a snapshot, like a photo taken by a camera, that shows what the UI <em>should</em> look like, based on the current application state.</p><p>React plays a ‚Äúfind the differences‚Äù game to figure out what&#39;s changed between these two snapshots. In this case, it sees that our paragraph has a text node that changed from <code>0</code> to <code>1</code>, and so it edits the text node to match the snapshot. Satisfied that its work is done, React settles back and waits for the next state change.</p><p><strong>This is the core React loop.</strong></p><p>With this framing in mind, let&#39;s look again at our render graph:</p><div><div><div id="bigcountnumber"><p>BigCountNumber</p><p>Props:<!-- --> { <!-- -->count<!-- --> }</p></div></div></div><p>Our <code>count</code> state is associated with the <code>Counter</code> component. Because data can&#39;t flow &#34;up&#34; in a React application, we know that this state change can&#39;t possibly affect <code>&lt;App /&gt;</code>. And so we don&#39;t need to re-render that component.</p><p>But we <em>do</em> need to re-render <code>Counter</code>&#39;s child, <code>BigCountNumber</code>. This is the component that actually displays the <code>count</code> state. If we <em>don&#39;t</em> render it, we won&#39;t know that our paragraph&#39;s text node should change from <code>0</code> to <code>1</code>. We need to include this component in our sketch.</p><p>The point of a re-render is to figure out how a state change should affect the user interface. And so we need to re-render all potentially-affected components, to get an accurate snapshot.</p><div><h2><a name="its-not-about-the-props" id="its-not-about-the-props" href="#its-not-about-the-props"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>It&#39;s not about the props</h2></div><p>Alright, let&#39;s talk about <em color="var(--color-secondary)">Big Misconception #2</em>: <strong>A component will re-render because its props change.</strong></p><p>Let&#39;s explore with an updated example.</p><p>In the code below, our ‚ÄúCounter‚Äù app has been given a brand new component, <code>Decoration</code>:</p><div><div data-id="decoration-separate-files" data-can-be-annotated="false"><div data-is-fullscreened="false"><div><div><header><p>Code Playground<!-- --> </p></header><div><div><div><div><div aria-describedby="enter-instructions-:Rq9taim:" aria-label="Code Editor for Counter.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span><span>;</span>

<span>import</span> <span>Decoration</span> <span>from</span> <span>&#39;./Decoration&#39;</span><span>;</span>
<span>import</span> <span>BigCountNumber</span> <span>from</span> <span>&#39;./BigCountNumber&#39;</span><span>;</span>

<span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>count</span><span>,</span> <span>setCount</span><span>]</span> = <span>React</span>.<span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>main</span><span>&gt;</span>
      <span>&lt;</span><span>BigCountNumber</span> <span>count</span>=<span>{</span><span>count</span><span>}</span> <span>/&gt;</span>
      <span>&lt;</span><span>button</span> <span>onClick</span>=<span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setCount</span><span>(</span><span>count</span> + <span>1</span><span>)</span><span>}</span><span>&gt;</span>
        Increment
      <span>&lt;/</span><span>button</span><span>&gt;</span>
      
      <span>{</span>}
      <span>&lt;</span><span>Decoration</span> <span>/&gt;</span>
    <span>&lt;/</span><span>main</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>Counter</span><span>;</span></pre></div></div></div></div></div></div></div></div></div></div><p>(It was getting a bit crowded, having all of the components in a single big file, so I took the liberty of re-organizing. But the overall component structure is the same, aside from the new <code>Decoration</code> component.)</p><p>Our counter now has a cute lil‚Äô sailboat in the corner, rendered by the <code>Decoration</code> component. It doesn&#39;t depend on <code>count</code>, so it probably won&#39;t re-render when <code>count</code> changes, right?</p><p>Well, er, not quite.</p><div><div><div id="bigcountnumber"><p>BigCountNumber</p><p>Props:<!-- --> { <!-- -->count<!-- --> }</p></div></div></div><p>When a component re-renders, it tries to re-render <em>all</em> descendants, regardless of whether they&#39;re being passed a particular state variable through props or not.</p><p>Now, this seems counter-intuitive... If we aren&#39;t passing <code>count</code> as a prop to <code>&lt;Decoration&gt;</code>, why would it need to re-render??</p><p>Here&#39;s the answer: it&#39;s hard for React to know, with 100% certainty, whether <code>&lt;Decoration&gt;</code> depends, directly or indirectly, on the <code>count</code> state variable.</p><p>In an ideal world, React components would always be ‚Äúpure‚Äù. A pure component is one that <strong>always</strong> produces the same UI when given the same props.</p><p>In the real world, many of our components are impure. It&#39;s surprisingly easy to create an impure component:</p><pre></pre><p>This component will display a different value whenever it&#39;s rendered, since it relies on the current time!</p><p>A sneakier version of this problem has to do with refs. If we pass a ref as a prop, React won&#39;t be able to tell whether or not we&#39;ve mutated it since the last render. And so it chooses to re-render, to be on the safe side.</p><p>React&#39;s #1 goal is to make sure that the UI that the user sees is kept ‚Äúin sync‚Äù with the application state. And so, React will err on the side of <em>too many</em> renders. It doesn&#39;t want to risk showing the user a stale UI.</p><p>So, to go back to our misconception: <strong>props have nothing to do with re-renders.</strong> Our <code>&lt;BigCountNumber&gt;</code> component isn&#39;t re-rendering because the <code>count</code> prop changed.</p><p>When a component re-renders, because one of its state variables has been updated, that re-render will cascade all the way down the tree, in order for React to fill in the details of this new sketch, to capture a new snapshot.</p><p>This is the standard operating procedure, but there <em>is</em> a way to tweak it a bit.</p><div><h3><a name="creating-pure-components" id="creating-pure-components" href="#creating-pure-components"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Creating pure components</h3></div><p>You might be familiar with <code>React.memo</code>, or the <code>React.PureComponent</code> class component. These two tools allow us to <em>ignore certain re-render requests.</em></p><p>Here&#39;s what it looks like:</p><pre></pre><p>By wrapping our <code>Decoration</code> component with <code>React.memo</code>, we&#39;re telling React ‚ÄúHey, I <em>know</em> that this component is pure. You don&#39;t need to re-render it unless its props change.‚Äù</p><p>This uses a technique known as <em>memoization</em>.</p><p>It&#39;s missing the R, but we can sorta think of it as ‚Äúmemo<strong>r</strong>ization‚Äù. The idea is that React will remember the previous snapshot. If none of the props have changed, React will re-use that stale snapshot rather than going through the trouble of generating a brand new one.</p><p>Let&#39;s suppose I wrap both <code>BigCountNumber</code> and <code>Decoration</code> with the <code>React.memo</code> helper. Here&#39;s how this would affect the re-renders:</p><div><div><div id="bigcountnumber"><p>BigCountNumber</p><p>Props:<!-- --> { <!-- -->count<!-- --> }</p><p>Pure Component</p></div></div></div><p>When <code>count</code> changes, we re-render <code>Counter</code>, and React will try to render both descendant components.</p><p>Because <code>BigCountNumber</code> takes <code>count</code> as a prop, and because that prop has changed, <code>BigCountNumber</code> is re-rendered. But because <code>Decoration</code>&#39;s props haven&#39;t changed (on account of it not having any), the <em>original</em> snapshot is used instead.</p><p>I like to pretend that <code>React.memo</code> is a bit like a lazy photographer. If you ask it to take 5 photos of the exact same thing, it&#39;ll take 1 photo and give you 5 copies of it. The photographer will only snap a new picture when your instructions change.</p><p>Here&#39;s a live-code version, if you&#39;d like to poke at it yourself. Each memoized component has a <code>console.info</code> call added, so you can see in the console exactly when each component renders:</p><div><div data-id="with-react-memo" data-can-be-annotated="false"><div data-is-fullscreened="false"><div><div><header><p>Code Playground<!-- --> </p></header><div><div><div><div><div aria-describedby="enter-instructions-:Rqhdaim:" aria-label="Code Editor for Decoration.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span><span>;</span>

<span>function</span> <span>Decoration</span><span>(</span><span>)</span> <span>{</span>
  <span>console</span>.<span>info</span><span>(</span><span>&#39;Decoration render&#39;</span><span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>div</span> <span>className</span>=<span>&#34;decoration&#34;</span><span>&gt;</span>
      ‚õµÔ∏è
    <span>&lt;/</span><span>div</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>React</span>.<span>memo</span><span>(</span><span>Decoration</span><span>)</span><span>;</span></pre></div></div></div></div></div></div></div></div></div></div><p>You might be wondering: <strong>why isn&#39;t this the default behaviour??</strong> Isn&#39;t this what we want, most of the time? Surely we&#39;d improve performance if we skipped rendering components that don&#39;t need to be rendered?</p><p>I think as developers, we tend to overestimate how expensive re-renders are. In the case of our <code>Decoration</code> component, re-renders are lightning quick.</p><p>If a component has a bunch of props and not a lot of descendants, it can actually be <em>slower</em> to check if any of the props have changed compared to re-rendering the component.<span></span></p><p>And so, it would be counter-productive to memoize every single component we create. React is designed to capture these snapshots really quickly! But in specific circumstances, for components with a lot of descendants <em>or</em> components that do a ton of internal work, this helper can help quite a bit.</p><p>We haven&#39;t talked at all about context yet, but fortunately, it doesn&#39;t complicate this stuff too much.</p><p>By default, all descendants of a component will re-render if that component&#39;s state changes. And so, it doesn&#39;t really change anything if we provide that state to all descendants via context; either way, those components are gonna re-render!</p><p>Now in terms of <em>pure</em> components, context is sorta like ‚Äúinvisible props‚Äù, or maybe ‚Äúinternal props‚Äù.</p><p>Let&#39;s look at an example. Here we have a pure component that consumes a <code>UserContext</code> context:</p><pre></pre><p>In this example, <code>GreetUser</code> is a pure component with no props, but it has an ‚Äúinvisible‚Äù or ‚Äúinternal‚Äù dependency: the <code>user</code> being stored in React state, and passed around through context.</p><p>If that <code>user</code> state variable changes, a re-render will occur, and <code>GreetUser</code> will generate a new snapshot, rather than relying on a stale picture. React can tell that this component is consuming this particular context, and so it treats it as if it was a prop.</p><p>It&#39;s more-or-less equivalent to this:</p><pre></pre><p>Play with a live example:</p><div><div data-id="context-example" data-can-be-annotated="false"><div data-is-fullscreened="false"><div><div><header><p>Code Playground<!-- --> </p></header><div><div><div><div><div aria-describedby="enter-instructions-:Rqllaim:" aria-label="Code Editor for App.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span><span>;</span>

<span>const</span> <span>UserContext</span> = <span>React</span>.<span>createContext</span><span>(</span><span>)</span><span>;</span>

<span>function</span> <span>UserProvider</span><span>(</span><span>{</span> <span>children</span> <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>user</span><span>,</span> <span>setUser</span><span>]</span> = <span>React</span>.<span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>

  <span>React</span>.<span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    
    
    <span>window</span>.<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setUser</span><span>(</span><span>{</span> <span>name</span><span>:</span> <span>&#39;Kiara&#39;</span> <span>}</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>UserContext</span>.<span>Provider</span> <span>value</span>=<span>{</span><span>user</span><span>}</span><span>&gt;</span>
      <span>{</span><span>children</span><span>}</span>
    <span>&lt;/</span><span>UserContext</span>.<span>Provider</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>UserProvider</span><span>&gt;</span>
      <span>&lt;</span><span>GreetUser</span> <span>/&gt;</span>
    <span>&lt;/</span><span>UserProvider</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>GreetUser</span> = <span>React</span>.<span>memo</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>user</span> = <span>React</span>.<span>useContext</span><span>(</span><span>UserContext</span><span>)</span><span>;</span>

  <span>if</span> <span>(</span>!<span>user</span><span>)</span> <span>{</span>
    <span>return</span> <span>&#34;Hi there!&#34;</span><span>;</span>
  <span>}</span>

  <span>return</span> <span>`Hello </span><span>${</span><span>user</span>.<span>name</span><span>}</span><span>!`</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>export</span> <span>default</span> <span>App</span><span>;</span></pre></div></div></div></div></div></div></div></div></div></div><p>Note that this only happens if the pure component <em>consumes the context</em> with the <code>React.useContext</code> hook. You don&#39;t have to worry about context breaking a bunch of pure components that don&#39;t try to consume it.</p><div><h2><a name="profiling-with-the-react-devtools" id="profiling-with-the-react-devtools" href="#profiling-with-the-react-devtools"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Profiling with the React Devtools</h2></div><p>If you&#39;ve worked with React for a while, you&#39;ve likely had the frustrating experience of trying to figure out <em>why</em> a particular component is re-rendering. In a real-world situation, it often isn&#39;t obvious at all! Fortunately, the React Devtools can help.</p><p>First, you&#39;ll need to download the React Devtools browser extension. It&#39;s currently available for <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" rel="noopener noreferrer" target="_blank">Chrome</a> and <a href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/" rel="noopener noreferrer" target="_blank">Firefox</a>. For the purposes of this tutorial, I&#39;ll assume you&#39;re using Chrome, though the instructions won&#39;t vary much.</p><p>Pop open the devtools with <code>Ctrl</code> + <code>Alt</code> + <code>I</code> (or <code>‚åò</code> + <code>Option</code> + <code>I</code> on MacOS). You should see two new tabs appear:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271762%27%20height=%27822%27/%3e"/></span><img alt="Screenshot showing two new tabs in the Chrome devtools, ‚ÄúComponents‚Äù and ‚ÄúProfiler‚Äù" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>We&#39;re interested in the ‚ÄúProfiler‚Äù. Select that tab.</p><p>Click the little gear icon, and enable the option labeled <em>‚ÄúRecord why each component rendered while profiling‚Äù</em>:</p><p>The general flow looks like this:</p><ol><li><p>Start recording by hitting the little blue ‚Äúrecord‚Äù circle.</p></li><li><p>Perform some actions in your application.</p></li><li><p>Stop recording.</p></li><li><p>View the recorded snapshots to learn more about what happened.</p></li></ol><p>Each render is captured as a separate snapshot, and you can browse through them using the arrows. The information about why a component rendered is available in the sidebar:</p><p>By clicking through to the component you&#39;re interested in, you can see exactly why a particular component re-rendered. In the case of a pure component, it will let us know which prop(s) are responsible for this update.</p><p>I don&#39;t personally use this tool often, but when I do, it&#39;s a lifesaver!</p><p>One of the things that you&#39;ll notice when you start using the profiler: sometimes, pure components re-render even when nothing <em>appears</em> to have changed!</p><p>One of the subtle mind-bending things about React is that components are JavaScript functions. When we render a component, we&#39;re calling the function.<span></span></p><p>This means that anything defined inside a React component is re-created on every single render.</p><p>As a quick example, consider this:</p><pre></pre><p>Every single time we render this <code>App</code> component, we&#39;re generating a brand new object. This can wreck havoc on our pure components; this <code>DogProfile</code> child is going to re-render whether or not we wrap it with <code>React.memo</code>!</p><p>In a couple weeks, I&#39;ll be publishing a ‚ÄúPart II‚Äù to this blog post. We&#39;ll dig into two famously-inscrutable React hooks, <code>useMemo</code> and <code>useCallback</code>. And we&#39;ll see how to use them to solve this problem.</p><p><strong>I also have a confession to make:</strong> these tutorials have been plucked straight from my upcoming course, <a href="https://joyofreact.com/" rel="noopener noreferrer" target="_blank">‚ÄúThe Joy of React‚Äù</a>.</p><p>I&#39;ve been building with React for over 7 years now, and I&#39;ve learned a lot about how to use it effectively. I absolutely love working with React; I&#39;ve tried just about every front-end framework under the sun, and nothing makes me feel as productive as React.</p><p>In ‚ÄúThe Joy of React‚Äù, we&#39;ll build a mental model for how React really works, digging into concepts like we have in this tutorial. Unlike the posts on this blog, however, my courses use a ‚Äúmulti-modality‚Äù approach, mixing written content like this with video content, exercises, interactive explorables, and even some minigames!</p><p>I&#39;m looking forward to pre-launching my course in the next couple months. If you&#39;re interested, you can <a href="https://joyofreact.com/" rel="noopener noreferrer" target="_blank">sign up for updates</a> on the course homepage. üíñ</p><div><h2><a name="bonus-performance-tips" id="bonus-performance-tips" href="#bonus-performance-tips"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Bonus: Performance tips</h2></div><p>Performance optimization in React is a huge topic, and I could easily write several blog posts about it. Hopefully, this tutorial has helped build a solid foundation upon which you can learn about React performance!</p><p>That said, I&#39;ll share a few quick tips I&#39;ve learned about React performance optimization:</p><ul><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>The React Profiler shows the number of milliseconds that a render took, but <strong>this number isn&#39;t trustworthy.</strong> We generally profile things in ‚Äúdevelopment mode‚Äù, and React is <em>much, much faster</em> in ‚Äúproduction mode‚Äù. To <em>truly</em> understand how performant your application is, you should measure using the ‚ÄúPerformance‚Äù tab against the deployed production application. This will show you real-world numbers not just for re-renders, but also the layout/paint changes.</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>I strongly recommend testing your applications on lower-end hardware, to see what the 90th-percentile experience is like. For example, I periodically test things on a Xiaomi Redmi 8, a budget smartphone popular in India a few years ago. I <a href="https://twitter.com/JoshWComeau/status/1322552961973821441" rel="noopener noreferrer" target="_blank">shared this experience on Twitter</a>.</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>Lighthouse performance scores are <em>not</em> an accurate reflection of true user experience. I trust the qualitative experience of using the application much more than the stats shown by any automated tool.</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>I gave a talk a few years ago at React Europe all about performance in React! It focuses more on the &#34;post-load&#34; experience, an area lots of developers neglect. You can <a href="https://www.youtube.com/watch?v=viPhwbusWuE" rel="noopener noreferrer" target="_blank">watch it on YouTube</a>.</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p><strong>Don&#39;t over-optimize!</strong> It&#39;s tempting, when learning about the React profiler, to go on an optimization spree, with the goal of reducing the # of renders as much as possible‚Ä¶ but honestly, React is already very optimized out of the box. These tools are best used <em>in response to a performance problem,</em> if things start feeling a bit sluggish.</p></li></ul></article></div></div></div>
  </body>
</html>
