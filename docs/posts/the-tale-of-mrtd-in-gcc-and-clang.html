<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://m680x0.github.io/blog/2023/05/the-tale-of-mrtd.html">Original</a>
    <h1>The tale of &#34;-mrtd&#34; in GCC and Clang</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        <time datetime="2023-05-06T23:00:00+00:00">May 6, 2023</time>
      </span>
    

    

    
  </p>


        </header>
      

      <section itemprop="text">
        
        <p>Recently I’ve been working on an <a href="https://github.com/llvm/llvm-project/issues/60554">issue</a> about supporting the <a href="https://m680x0.github.io/ref/integer-instructions.html#pf10e"><code>RTD</code></a> instruction in m68k LLVM backend (well, it turned out to be not directly related to the instruction itself but we will talk about that shortly).
The gist of that issue goes like this: the backend bailed out when it tried to lower a certain kind of return statement to <code>RTD</code>, if we’re targeting 68020 or later<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<p><code>RTD</code> is a variant of return instruction that subtracts some bytes, whose quantity is indicated by the instruction’s operand, from stack pointer (which effectively pops the stack) before returning.
It can be used to implement a special kind of calling convention in which the callee has to clean out the space allocated for arguments passed from the stack.
Though you don’t <em>have</em> to use <code>RTD</code> to implement the said calling convention, as long as you pop the arguments upon returning.</p>

<p>In m68k GCC, this calling convention is not enabled by default unless the <code>-mrtd</code> flag is present.
Since this project is aiming to be compatible with its GCC counterpart (and the fact that this calling convention was not commonly used even in the good ol’ days), we want to implement the same behavior.</p>

<p>Cool, I guess we need to add <code>-mrtd</code> to Clang. Because given “rtd” being such an odd name and sounds really 68k-specific, there is no way it’s already there…</p>

<blockquote>
  <p>“So, I have been digging into this now and what I found is that <code>-mno-rtd</code> is actually already handled by Clang:</p>

  <p><code>def mrtd: Flag&lt;[&#34;-&#34;], &#34;mrtd&#34;&gt;, Group&lt;m_Group&gt;;</code></p>

  <p>and</p>

  <p><code>def mno_rtd: Flag&lt;[&#34;-&#34;], &#34;mno-rtd&#34;&gt;, Group&lt;m_Group&gt;;</code></p>

  <p>Also documented here: https://clang.llvm.org/docs/ClangCommandLineReference.html”</p>
</blockquote>

<p><em>– Quoted (and slightly edited) from <a href="https://github.com/llvm/llvm-project/issues/60554#issuecomment-1519005515">one of the comments</a> by Adrian.</em></p>

<p>So <code>-mrtd</code> is <em>already</em> there? That’s a little weird…</p>

<p>It seems like X86 is the only user of that flag. Specifically, only the 32-bit i386 which uses it to enable the <code>stdcall</code> calling convention, a CC that also requires callee functions to pop out incoming arguments on the stack.
<code>stdcall</code> is primarily adopted by Win32 API.</p>

<p>Aside from <code>stdcall</code>’s similarity with our special CC mentioned earlier, it’s not quite obvious why the flag is named after something unrelated to i386.</p>

<p>Rest of this post is served to answer a simple question: <em>why do i386 Clang and GCC use the name “(m)rtd?”</em>.
It’s important to note that this article is <strong>NOT</strong> meant to criticize / compare any naming choice or convention made in the past between different compiler backends and implementations, but merely a historical study.</p>



<p>The first assumption I came out was that maybe there <em>is</em> an instruction called “rtd” in i386, specifically the old 80386 processor.
Given how iron-fisting Intel is on maintaining backward compatibility, it’s nearly impossible that any instruction has been removed from the ISA since 80386. Therefore, looking up a relatively modern 32-bit x86 ISA manual should suffice.</p>

<p>Unfortunately, a simple search will tell you that i386 only has <code>RET</code> and <code>RETI</code> (return from interrupt).
<code>RET</code> <em>does</em> have a variant that takes an immediate-value operand, acting just like <code>RTD</code> in 68k we mentioned earlier. But, well, it’s still called “ret” rather than “rtd”.</p>

<p>Now, maybe there are some clues in the patch that introduced this flag to Clang or even GCC – time to dig into the past.</p>



<p>Let’s start from the Clang/LLVM side. The <code>-mrtd</code> flag was added to Clang by <a href="https://github.com/llvm/llvm-project/commit/65b88cdb3bd34e5000b30533fa1599c959029719">65b88cd</a> in 2011.
Unfortunately, there wasn’t any commit message or code comment attached to shed some lights on the choice of flag name.
But luckily Clang, as a compiler driver, is supposed to be <a href="https://clang.llvm.org/docs/DriverInternals.html#gcc-compatibility">compatible with GCC</a>. So one can safely assume that this flag is originated from GCC.</p>

<p>Digging into GCC’s source code, at hindsight <a href="https://gcc.gnu.org/git/?p=gcc.git;a=commit;h=6ac49599123d5d649107b8d7fd0674a8fb1afdbe">6ac4959</a> added <code>-mrtd</code> to i386 GCC in 2005, residing in file <code>config/i386/i386.opt</code>.
But if we look closer, that patch was merely transferring flag declarations to the newer generator-based approach with *.opt files.
The <a href="https://gcc.gnu.org/git?p=gcc.git;a=blob;f=gcc/config/i386/i386.h;h=5854944c8ec2b7b054a6c9f3aacb35778c46e67c;hb=0e5d569cd56e49dd5be9a67d553f0c007ff5436c#l357">original definition</a> of <code>-mrtd</code> flag in <code>config/i386/i386.h</code> can actually be traced all the way back to the <em>initial</em> version of i386 backend!
Specifically, <a href="https://gcc.gnu.org/git/?p=gcc.git;a=commit;h=c98f874233428d7e6ba83def7842fd703ac0ddf1">c98f874</a> authored on <strong>Feb 9th 1992</strong>.</p>



<p>Here was my assumption:</p>
<blockquote>
  <p>The name “-mrtd” in i386 GCC was reused or copied from its m68k counterpart.</p>
</blockquote>

<p>So I looked into the first commit that introduced <code>-mrtd</code> to m68k GCC, which was <a href="https://gcc.gnu.org/git/?p=gcc.git;a=commit;h=3d339ad2b6fa7849631f4cf485efb71638687981">3d339ad</a>.
But the timestamp showed that it was authored on <strong>Feb 18th 1992</strong>, 9 days <em>after</em> the first file in the initial version of i386 GCC!</p>

<p>Is it possible that m68k GCC’s <code>-mrtd</code> was actually copied <em>from</em> i386 GCC?</p>

<h2 id="lookmanovcs_finalv94finalfinalrev87psd">“LookMaNoVCS_FINALv9.4FINALFINALrev87.psd”</h2>

<p>It turns out GCC not only has used several different VCS (Version Control System) <a href="https://mpoquet.github.io/blog/2020-08-vcs-adoption-in-floss/index.html">in the past</a>, it was not even managed with a VCS at the very beginning.
According to <a href="https://gcc.gnu.org/wiki/History">GCC’s History</a>, the first (beta) <a href="https://groups.google.com/g/mod.compilers/c/ynAVuwR7dPw/m/-IirjtgwPxsJ">release</a> was put…on a FTP server located in MIT.</p>

<p>So the Feb 9th 1992 date we just mentioned was merely the time i386 backend was checked into GCC’s VCS from a plain source tree. Same for the Feb 18th 1992 date of its m68k counterpart.
In other words, it’s highly likely that the code for i386 and m68k backend was already there before any VCS adoption.
The best way to answer this is to grab GCC’s pre-VCS era source code. Unfortunately, while the <a href="http://prep.ai.mit.edu/gnu/">FTP server</a> that originally hosted GCC is still there, I no longer can find that particular copy of source code.
We can only make some educated guesses now.</p>

<p>There are three pieces of clues I found useful here:</p>
<ol>
  <li><code>-mrtd</code> was also used for one of the obselete (and ancient) architectures called Gmicro. A comment about <code>-mrtd</code> in Gmicro backend <a href="https://gcc.gnu.org/git?p=gcc.git;a=blob;f=gcc/config/gmicro/gmicro.h;h=3d50048a13a0dded561039162d15e0acd4ec6e91;hb=44f0c3edadbe3baa3ed045a4a9917719dd65029b#l461">said</a>: <em>“…On the m68k this is an RTD option, so I use the same name for the Gmicro. The option name may be changed in the future.”</em></li>
  <li>The initial version of <code>config/i386/i386.h</code> and <code>config/m68k/m68k.h</code> shared a nearly identical line of the comments related to <code>-mrtd</code> handlings (<a href="https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/config/i386/i386.h;h=c0cd287b3d2f0c5d66baf1b8ed168239639771e9;hb=c98f874233428d7e6ba83def7842fd703ac0ddf1#l517">i386 line</a> v.s. <a href="https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/config/m68k/m68k.h;h=2fea1a12357cfc0ca2cce6fc3351cebc3c9429a8;hb=3d339ad2b6fa7849631f4cf485efb71638687981#l739">m68k line</a>). The only difference between them is the supported processor name (i.e. “80386” v.s. “68010”).</li>
  <li>From the <a href="https://groups.google.com/g/mod.compilers/c/ynAVuwR7dPw/m/-IirjtgwPxsJ">announcement</a> of the first GCC beta release made by RMS (circa March 1987), it’s high likely that m68k and <a href="https://en.wikipedia.org/wiki/VAX">VAX</a> were the only two supported targets.</li>
</ol>

<p>Item (1) suggests that reusing a flag name, despite having little to do with the respective instruction name (in Gmicro the corresponding instruction is called <code>EXITN</code> not <code>RTD</code>) was a thing, and might even be a common practice;
item (2) is likely to be a trail of boilerplate copy-n-paste on not just the comment but also the code, as well as the flag.
Finally, item (3) further affirms that if both (1) and (2) hold, it’s likely that <code>-mrtd</code> was reused or copied from m68k to i386 GCC rather than the other way around.</p>


<p>Though there isn’t any direct evidence<sup id="fnref:about_email" role="doc-noteref"><a href="#fn:about_email" rel="footnote">2</a></sup> showing that <code>-mrtd</code> was borrowed from m68k GCC to i386 GCC (and eventually rippled to Clang), from the <em>artifacts</em> I presented it’s very likely the case.</p>

<p>But in any case, should patch <a href="https://reviews.llvm.org/D149864">D149864</a> and <a href="https://reviews.llvm.org/D149867">D149867</a> be accepted, m68k Clang/LLVM will finally have the ability to recognize <code>-mrtd</code> — nearly <strong>40 years</strong> after its debute in GCC.</p>

<p>A small victory for the m68k LLVM community nonetheless!</p>



        
      </section>

      

      


      
  

    </div></div>
  </body>
</html>
