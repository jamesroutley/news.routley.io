<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.silennai.com/claude-code">Original</a>
    <h1>I was a top 0.01% Cursor user, then switched to Claude Code 2.0</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><div><p>You have 6-7 articles bookmarked about Claude Code. You&#39;ve seen the wave. You want to be a part of it. Here&#39;s a comprehensive guide from someone who&#39;s been using coding AI since 2021 and read all those Claude Code guides so you don&#39;t have to.</p><figure><img src="https://hamy.xyz/articles/claude-code/curve-cursor-claude.jpeg" alt="Cursor vs Claude Code"/><figcaption>You&#39;ll be on the right side after reading this</figcaption></figure><figure><img src="https://hamy.xyz/articles/claude-code/curve-cursor-claude.jpeg" alt="Cursor vs Claude Code"/><figcaption>You&#39;ll be on the right side after reading this</figcaption></figure><p>This is a guide that combines:</p><ol><li>my experience from 5 years of coding with AI</li><li>my experience with Claude Code</li><li>10+ articles and countless X posts I consolidated about Claude Code (references at the bottom)</li><li>my setup</li><li>advanced tips</li></ol><p>After this article, the only limit to be your own ideas.</p></div><h2 id="the-journey">The journey</h2><div><div><div><p>It&#39;s March of 2023. Github Copilot is our frontier of AI coding.</p><p>ChatGPT is still a novelty. Model improvement isn&#39;t taken for granted.</p><p>GPT-4 gets released.</p><p>Instantly it&#39;s clear that this is paradigm shifting.</p><p>We could create a loop of AI thinking with some tools to search the web and write code for us. The smell of AGI is in the air!</p><p>We decide to call these loops &#34;agents&#34;. I was lucky enough to help build the first AI agent<!-- --> <a href="https://github.com/Significant-Gravitas/AutoGPT" target="_blank" rel="noopener noreferrer">AutoGPT</a>which went mega viral and is to this day the fastest growing repo to 100k stars.</p><p>But it didn&#39;t really work. If you got lucky, every once in a while you could get an almost working tic tac toe game.</p><p>For anything more complex? Forget about it.</p><p>Cursor came along in 2023 with promises. I tried and churned in October 2023 and again in May 2024. Good old copy and paste from ChatGPT was still better.</p><p>Then in September 2024 Cursor Composer came out.</p><p>From that moment, 90% of my code became AI generated.</p><p>I lived in that editor. I pushed it to its limits, wrote an internal guide on best practices that I never published, and figured out every trick: surgical cursor placement, context window management,<!-- --> <a target="_blank" rel="noopener noreferrer" href="https://x.com/silennai/status/1891236312113401913?s=20">Cursor rules</a>,<!-- --> <a href="https://x.com/silennai/status/1920221901202358760?s=20" target="_blank" rel="noopener noreferrer">the spiky edges of model capability</a>.</p><p><a target="_blank" rel="noopener noreferrer" href="https://x.com/silennai/status/1923114661253411203?s=20">I had found the answer to all my problems.<!-- --> </a>I even got an email from the team that I was a top 0.01% Cursor user.<!-- --> </p><figure><img src="https://hamy.xyz/articles/claude-code/top-cursor-users.png" alt="Cursor Top 0.01%"/><figcaption><a href="https://x.com/silennai/status/1907540814890521023?s=20" target="_blank" rel="noopener noreferrer">Tweet link</a></figcaption></figure><p>I tried Claude Code earlier this year. Churned.</p><p>The workflow felt like a step backward from what I had built with Cursor. The model wasn&#39;t quite there yet, I still needed to know what was going on in the code more often than not.</p><p><b>Why would I ever use a tool that&#39;s barely as good and a 10x worst UX?</b></p></div></div></div><h2 id="whats-changed">What&#39;s changed</h2><h3 id="cc-vs-cursor">Why I switched</h3><div><div><p>A skeptic on Twitter<!-- --> <a href="https://x.com/ohabryka/status/2007322150886367719" target="_blank" rel="noopener noreferrer">asks</a>:</p><div><div><p>&#34;Can someone explain to me why people use Claude Code instead of Cursor?&#34;</p><p>— @ohabryka</p></div></div><p>Until a month ago, I shared the sentiment. Here&#39;s my answer:</p><div><ul><li><strong>Async first mindset:</strong> Being in the IDE lends to instinctive code review and perfection. But we&#39;ve ascended to the next level of abstraction. And the terminal native workflow is a forcing function for taking that next step.</li><li><strong>RLHF&#39;d for its own scaffold:</strong> Claude models (especially Opus 4.5+) perform noticeably better in Claude Code. File searching, tool use, everything is tuned for this interface.</li><li><strong>Cost efficiency:</strong> <a href="https://x.com/fiddyresearch/status/2010708872323895303" target="_blank" rel="noopener noreferrer">Claude Code costs seem to be more bang per token</a> <!-- -->compared to Cursor plans.</li><li><strong>Customizability:</strong> <a href="https://x.com/skeptrune/status/2007441928779116663" target="_blank" rel="noopener noreferrer">DIY is native and composability is built in.</a></li></ul></div><h3 id="when-cursor">When to use Cursor</h3><ul><li><strong>Pixel perfect frontend:</strong> Often I find myself in the loop still to get a pixel perfect UI.</li><li><strong>Learning:</strong> When iterating on something educational for yourself, the feedback loop is much quicker.</li><li><strong>Prevent context pollution:</strong> If it&#39;s a small change unrelated to any of my Claude Code terminals, it&#39;s easiest to do it in Cursor.</li></ul><div><p><strong>Recommendation:</strong> Use Cursor as your default if you&#39;re</p><p>a) an organic coder who finds abstracting all code away to behavior scary, or</p><p>Use Claude Code if you</p><p>a) never plan on learning and just care about outputs, or</p><p>There is a VSCode extension for Claude Code which can ease your transition. But the UX still isn&#39;t near as good as Cursor. And it defeats the purpose.</p><p>You should be abstraction maxxing.</p></div><h3 id="my-setup">My current setup</h3><div><p><strong>Claude Code with Opus 4.5</strong> for most tasks. Planning, code generation, complex refactors, architectural decisions.</p><p><strong>Cursor with GPT 5.2 / Sonnet 4.5</strong> when I need tight feedback loops. Learning, UI perfection, small changes.</p><p><strong>ChatGPT</strong> for a few things: (a) programming related questions that don&#39;t need project context (like setting up an A100 VM in Azure), (b) second opinions on plans, and (c) when I don&#39;t understand an output or need clarification on something Claude said.</p><p><strong><a href="https://ghostty.org/" target="_blank" rel="noopener noreferrer">Ghostty</a></strong> <!-- -->as my terminal. Made by the cofounder of HashiCorp. Fast, no flickering, natively supports terminal splitting, better text editing experience, and native image support.</p><p><strong>Wispr</strong> for voice to text. If you work from home or have your own office, not having to type all the time is valuable. Begone Carpal tunnel. I need to be in a certain mood to use it.</p></div></div></div><h2 id="pillars-of-agentic-coding">The 5 pillars of agentic coding</h2><div><div><div><p>Capture the Alpha</p><div><p>Don&#39;t worry about taking in depth notes. To make your life easier, I&#39;ve encoded the entire alpha of this article in these two commands:</p><!-- --> <p><a href="https://gist.github.com/SilenNaihin/3f6b6ccdc1f24911cfdec78dbc334547" target="_blank" rel="noopener noreferrer"><code>/setup-claude-code</code></a></p><!-- --><p>(global, run once per machine) and</p><!-- --> <p><a href="https://gist.github.com/SilenNaihin/e402188c89aab94de61df3da1c10d6ca" target="_blank" rel="noopener noreferrer"><code>/setup-repo</code></a></p><!-- --><p>(per project). They interview you for what you need and set everything up. Just paste this into your Claude Code chat and run it:</p><div><pre>Download these commands to ~/.claude/commands/:

1. /setup-claude-code (run once per machine - installs all other commands):
https://gist.github.com/SilenNaihin/3f6b6ccdc1f24911cfdec78dbc334547

2. /setup-repo (run once per project):
https://gist.github.com/SilenNaihin/e402188c89aab94de61df3da1c10d6ca

Fetch each gist and save as [command-name].md in ~/.claude/commands/

Then run /setup-claude-code to install everything else.</pre></div></div></div><p>It was written in the scriptures. Buckle up.</p></div></div><figure><img src="https://hamy.xyz/articles/claude-code/5-pillars.jpeg" alt="Agentic Tradeoffs"/></figure><div><div><h3 id="context-optimization">Context</h3><div><p>Here&#39;s some tips I&#39;ve picked up over time on context management:</p><ol><li><code>&#34;spawn a subagent to do deep research on this topic&#34;</code> <!-- -->Spawn subagents for parallel work. They do not pollute the main agent&#39;s context. They can individually do work and add just the valuable context from their work to the main agent&#39;s context.<!-- --> </li><li><code>/compact</code> - Others are iffy about compacting, but often the tradeoff to stay in the same chat and eat the compacting is worth it.<!-- --> <a href="https://x.com/talraviv/status/2010692991401300190" target="_blank" rel="noopener noreferrer">Their system for compacting is smart.</a></li><li><code>/transfer-context</code> That said, after compacting enough times or doing any task not directly related, quality will degrade. Don&#39;t be afraid to create new chats. If you need to transfer context, just tell the model to give you a prompt to put into another model with the related context for the task with the files (for anything advanced create md files, although I find managing these md files to be annoying).<!-- --> <a href="https://gist.github.com/SilenNaihin/e4be0e8750343d9cbafdaab88366115c" target="_blank" rel="noopener noreferrer">Here&#39;s a gist of my <code>/transfer-context</code> <!-- -->command</a>.</li><li><code>/context</code>Shows you how much context you have left. You&#39;ll get a report like this:<!-- --> <figure><img src="https://hamy.xyz/articles/claude-code/context.png" alt="Context Report"/></figure> <!-- -->Claude will also tell you when you&#39;re running low on context.<!-- --> <figure><img src="https://hamy.xyz/articles/claude-code/compacting.png" alt="Context Report"/><figcaption>This is in the bottom right of the terminal.</figcaption></figure> <!-- -->Make the decision to compact or to switch chats at this point. Don&#39;t wait until it hits 0% as it will degrade your outputs, and if it compacts in the middle of a task it will forget potentially relevant context that you&#39;ve given it even in the last chat.</li><li>Maintain focus: one chat = roughly one task. If a chat is focused on a single task it will have more relevant context. The definition of a &#39;task&#39; is miles broader than what it used to be. Test the limits and see what works for you.</li><li>Generating things in a chat that already has context will always perform best, whether it&#39;s docs, tests, or related code. Sometimes for one off changes (like a bug fix), I&#39;ll do them within the chat context, commit changes, and then rewind the conversation back to save context.</li></ol><p>Use <code>/resume</code> to continue from a previous chat.</p><p><strong>Note on context limits:</strong> Claude Code has a 200k context limit. You hit the wall faster than alternatives like Codex (400k) or Gemini (1M).</p></div><h3 id="planning-leverage">Planning</h3><div><p>Your time spent planning is directly proportional to agent output.</p><p>Rule of thumb: a good prompt will save you 3 minutes of time on follow up prompts and debugging for every 1 minute you spend planning.</p><p><strong>Shift+Tab twice:</strong> Enter plan mode. I use it, but only for larger tasks or when the exact shape of what I want it to be is unclear. Note: plan mode saves to a <code>.md</code> in the global <code>~/.claude</code> folder, which isn&#39;t accessible within your repo. I&#39;ll either ask Claude to create a <code>plan.md</code> in the repo after plan mode, or skip plan mode entirely and plan in-chat.</p></div><h4 id="planning-approaches">Three Approaches</h4><ol><li><strong>Plan mode dialogue:</strong> Start a conversation, ask questions, let it explore code, create a plan together. When you&#39;re happy, say &#34;write plan to docs/*.md and start coding.&#34; or if in plan mode, &#34;yes, and bypass permissions.&#34;</li><li><strong>Sprint-style todo list:</strong> For larger projects, set up a progress.txt and structured task list (prd.json). More on this in the Advanced section.</li><li><strong>Generate revert plan:</strong> Run your prompt, see what it generates, then revert and keep planning for the final plan.</li></ol><figure><img src="https://hamy.xyz/articles/claude-code/planning-nano.jpeg" alt="Planning principles"/></figure><div><p>After creating your plan, use our<!-- --> <a href="https://gist.github.com/SilenNaihin/0733adf5e8deea4242878938c3bdc9fb" target="_blank" rel="noopener noreferrer"><code>/interview-me-planmd</code></a> <!-- -->command which interviews you in depth about your plan before building. (See<!-- --> <a href="https://x.com/trq212/status/2005315275026260309?s=20" target="_blank" rel="noopener noreferrer">this X post</a>, I&#39;ve also tried it myself and found it genuinely effective.)</p><p>Read @plan.md and interview me in detail using the AskUserQuestionTool about literally anything: technical implementation, UI &amp; UX, concerns, tradeoffs, etc. Make sure the questions are not obvious. Be very in-depth and continue interviewing me continually until it&#39;s complete, then write the plan to the file.</p><p>Opus 4.5 is amazing at explaining things and makes stellar ASCII diagrams. My exploration involves asking lots of questions, clarifying requirements, understanding where/how/why to make changes.</p><p><strong>Backwards compatibility:</strong> Models are currently, RLHF&#39;d so far into oblivion that you need to<!-- --> <strong>explicitly ask it to</strong> not maintain backwards compatibility.</p><p><strong>Watch out for overengineering:</strong> Claude models love to do too much. Extra files, flexibility you didn&#39;t ask for, unnecessary abstractions. Be as explicit with what NOT to do as possible. Pete puts it well:<!-- --> <em>&#34;We want the simplest change possible. We don&#39;t care about migration. Code readability matters most, and we&#39;re happy to make bigger changes to achieve it.&#34;</em></p><p><strong>Keep in mind:</strong> Coding agents are better at creating new files than editing existing ones. It can often be valuable to tweak the seed prompt and reset all the code from scratch.</p></div><h3 id="closing-the-loop">Closing the loop</h3><p>There&#39;s a classic XKCD about programmers spending a week automating a task that takes 5 minutes.</p><div><p>With agentic coding, this equation has flipped.<!-- --> <strong>Closing the loop is now almost always worth it.</strong> <!-- -->The cost of automation has collapsed. What used to take a week now takes a conversation.</p><p>If you find yourself doing something more than once, close the loop. If you spend a lot of time doing x thing, close the loop.</p><ul><li>Make commands for repeated prompts</li><li>Make agents for repeated work</li><li>Update your claude.md</li><li>Make prompts in .mds (like Cursor rules!)</li><li>Change tsconfig and other config files</li></ul></div><h3 id="verifiability-vs-trust">Verifiability</h3><div><p>The only way you or the model know that you&#39;re right is if you can verify the outputs.</p><p>Before, you had to be in the code. Then with Cursor, you had to approve every edit. Now, just test behaviors with interface tests.</p><p>Interface tests are the ability to know what&#39;s wrong and explaining it.</p><p>For UI this means looking, for UX this means clicking around, for API this means making requests. And checking the responses.</p><p>A good way to think about closing the loop is to make it easy for you to verify by making it easy for the agent to verify.</p><p><strong>For large refactors:</strong> Ask Claude to build comprehensive interface tests beforehand. This ensures you got the refactor right. The tests become your verification layer.</p><p><strong>Writing tests:</strong> The best tests are written in the same context as the code they are testing.</p><p><strong>Let Jesus take the wheel.</strong> For production apps, test in staging or dev on a PR. Integration tests are your safety net. If they pass, ship it.</p></div><h3 id="ai-code-vs-debugging">Debugging</h3><p>AI writes code fast, but debugging AI code requires different skills than debugging your own. You didn&#39;t write it, so you don&#39;t have the mental model.</p><h4 id="debugging-loop">The debugging loop</h4><p>When something fails, use systematic debugging. I have a<!-- --> <a href="https://gist.github.com/SilenNaihin/6833c01f597c82912af5aca4e3467a35" target="_blank" rel="noopener noreferrer"><code>/debug</code> command</a> <!-- -->that triggers thorough investigation:</p><ol><li>Create hypotheses for what&#39;s wrong</li><li>Read ALL related code (take your time)</li><li>Add strategic logging to verify assumptions</li><li>Tackle it differently in a new chat</li><li>Try a different model</li><li>Revert and try again</li><li>Worst case: dive into the code yourself</li></ol><div><p><strong>The rule of three:</strong> If you&#39;ve explained the same thing three times and Claude still isn&#39;t getting it, more explaining won&#39;t help. Change something.</p><p><strong>Show instead of tell:</strong> If Claude keeps misunderstanding, show it a minimal example of what you want the output to look like. Claude is good at following examples.</p><p><strong>Start fresh:</strong> If you&#39;re making lots of changes to your plan, start a new session. Get the agent to summarize the situation, what has been tried, and learnings. Copy paste into a new Claude session.</p></div><h4 id="multi-model-debugging">Council of models</h4><p>Different models have different blind spots. When stuck, get fresh perspectives:</p><ul><li><a href="https://gist.github.com/SilenNaihin/3e9b43522b61e155bd256fe7193493cd" target="_blank" rel="noopener noreferrer"><code>/ensemble-opinion</code></a>: Get multi-model opinions on a problem. Runs Claude, Gemini, and Codex in parallel, then synthesizes their responses.<!-- --> <a href="https://x.com/tenobrus/status/2010428123310129487" target="_blank" rel="noopener noreferrer">Inspired by this</a>.</li><li><a href="https://gist.github.com/SilenNaihin/ff19b2d65d17137b0ee1f609f25205c5" target="_blank" rel="noopener noreferrer"><code>/codex-delegate</code></a>: Delegate tasks to OpenAI Codex for autonomous execution.</li></ul><div><p>You can automatically review your PRs and commits. Claude can catch issues, suggest improvements, and provide context aware feedback before human review even begins.</p><p>You can do this via a Stop hook (more on these later) with Claude code in headless mode (<code>-p</code>) that triggers on every commit, or via prs. When I&#39;ve used automated reviewing it was always at the via PR level.</p><p>If you have access, <strong>use Codex for PR review.</strong> <!-- -->You don&#39;t want the same inductive biases that wrote the code reviewing it. Codex catches things Claude misses and vice versa.</p></div><h4 id="refactoring">Refactoring and cleanup</h4><p>Tools to use:</p><ul><li><a href="https://github.com/kucherenko/jscpd" target="_blank" rel="noopener noreferrer"><strong>jscpd:</strong></a> <!-- -->Code duplication detection</li><li><a href="https://github.com/webpro/knip" target="_blank" rel="noopener noreferrer"><strong>knip:</strong></a> <!-- -->Dead code removal</li><li><strong>code-simplifier plugin:</strong> Simplifies complex code at end of sessions.<!-- --> <a href="https://x.com/bcherny/status/2009450715081789767" target="_blank" rel="noopener noreferrer">Recommended by the founder of Claude Code.</a></li></ul><div><p>Run<!-- --> <a href="https://gist.github.com/SilenNaihin/cd321a0ada16963867ad8984f44922cf" target="_blank" rel="noopener noreferrer"><code>/refactor</code></a> <!-- -->to do a focused cleanup session with these tools.</p><p>I refactor when I either feel pain because Claude is making mistakes, or after large additions to codebases. I&#39;m not the only one of the opinion that doing this continuously kills momentum. Treat it as a distinct phase.</p><p>Claude won&#39;t understand your preferences around code cleanliness. Over time, add context to your Claude.md that reveals your preferences and reduces refactoring time.</p></div></div></div><h2 id="cc-specifics">Tips for an effective Claude Coder</h2><div><div><div><p>Always bias towards using the most powerful models. Use<!-- --> <code>/model</code> to switch to Opus 4.5. The cost difference is negligible compared to the quality difference.</p><p>Use <code>@</code> to mention files directly in your prompt. Sometimes you need to type <code>@/</code> to get the full file list to appear.</p></div><h3 id="keyboard-shortcuts">Keyboard shortcuts I use the most</h3><div><p><strong>Shift+Tab twice:</strong> Plan mode.</p><p><strong>Ctrl+R:</strong> Search through prompt history (similar to terminal backsearch).</p><p><strong>Esc+Esc:</strong> Access <code>/rewind</code> <!-- -->checkpointing. Reverts to a previous checkpoint when Claude messes something up. Can rewind both code and conversation.</p><p><strong><code>!</code>:</strong> <!-- -->You can type any bash command in the chat by prefixing your message with <code>!</code>.</p><figure><img src="https://hamy.xyz/articles/claude-code/rewind.png" alt="Rewind"/></figure><p><strong>Useful Mac shortcuts:</strong></p></div><ul><li><strong>Shift+Enter:</strong> Add newlines without sending the message.</li><li><strong>Cmd+Option+C (<a href="https://www.raycast.com/" target="_blank" rel="noopener noreferrer">Raycast</a>):</strong> <!-- -->Access full clipboard history. Essential for copying multiple things.</li><li><strong>Option+Arrow:</strong> Skip by words.<!-- --> <strong>Cmd+Arrow:</strong> Jump to start/end of line.</li></ul><h3 id="ask-claude">The &#34;just ask Claude&#34; mindset</h3><div><p>You can often ask Claude to do things you think you have to do manually. Changing default permissions, configuration, anything file-related.</p><p>Get in the mindset:just ask Claude. It knows how to do things like creating custom commands (it will search the web and figure it out if it doesn&#39;t know).</p></div><h3 id="blast-radius">Using 12 parallel terminals at once</h3><div><p>I often don&#39;t even have an IDE open for a repo anymore. I have 12 terminals open at once, actively working from on 1-8 at any given time. Typically 2 per project: one for context management or Ralph, one for active multithreading.</p><figure><img src="https://hamy.xyz/articles/claude-code/terminals-4.png" alt="Parallel terminals"/></figure><p>Making real progress in 4 projects at once requires the projects to be more execution than thinking. And I have to be locked in off a Celsius and a pack of Zyns (metaphorically, I don&#39;t consume either. Just hard drugs like life).</p><p>The natural instinct is to use git worktrees to isolate parallel work.</p><p>But hammering the same branch is the best approach when running multiple instances. For speed and simplicity. In practice if you do this right you&#39;ll rarely need to use worktrees.<!-- --> <a href="https://x.com/mitsuhiko/status/2011773404207337549" target="_blank" rel="noopener noreferrer">Armin agrees.</a> <a href="https://x.com/steipete/status/2011880333348913355" target="_blank" rel="noopener noreferrer">So does Pete.</a></p><p>Think in terms of the <strong>&#34;blast radius&#34;</strong> <!-- -->of one of your terminals. Evaluate the scope of your changes prior to sending your prompt. If it overlaps with another instance, you should be getting Claude to do it in that instance. You&#39;ll find that it&#39;s truly rare that this mindset doesn&#39;t work.</p><p>Worst case if there are errors or you miscalculated, you can always revert or fix it. The cost of the rare times this happens is worth it.</p><p>Our<!-- --> <a href="https://gist.github.com/SilenNaihin/d4b3870178667475b08e1f48d6cdbc30" target="_blank" rel="noopener noreferrer"><code>/commit-smart</code></a> <!-- -->command helps to make contextual commits. It only commits files that the Claude Code instance touched which allows me to revert a specific change without losing unrelated work.</p><p>For solo projects I just push to <code>main</code> directly. When working with others</p><ol><li>if it&#39;s one person I&#39;ll have a branch called<!-- --> <code>silen</code> which I periodically create a PR for and merge in, or</li><li>if it&#39;s multiple collaborators I&#39;ll create branches and check out the Claude instances on that branch, and</li><li>if it&#39;s a more established repo I&#39;ll create a second worktree, and have two terminals associated with two different branches.</li></ol><p>Another tip is when I have one session doing something like a refactor but I already have your next prompt typed out for a feature add, you can do <code>!sleep 600</code> in that second instance and then send in your prompt.</p></div></div></div><h3 id="claude-md">Your CLAUDE.md</h3><div><div><div><p>The default <code>/init</code> command analyzes your project and generates a starter configuration. Our<!-- --> <a href="https://gist.github.com/SilenNaihin/e402188c89aab94de61df3da1c10d6ca" target="_blank" rel="noopener noreferrer"><code>/setup-repo</code></a> <!-- -->command goes further to configure your repo in the first place. It includes best practices (also referencing the<!-- --> <code>/init</code> command) for agentic repos, and interviews you for what you need.</p><p>Generally, what you include should be driven by pain. Outside of the basic template that <code>/setup-repo</code> gives you:</p></div><ul><li><strong>Project summary + directory structure:</strong> Gives Claude immediate orientation.</li><li><strong>Main dependencies and patterns:</strong> If you use domain-driven design, microservices, specific frameworks, document it.</li><li><strong>Non-standard organizational choices:</strong> Anything that would confuse someone (or Claude) new to the codebase.</li><li><strong>Tooling and repo layout info:</strong> Minimize the amount the agent needs to search.</li><li><strong>Comments only where needed</strong> (minimize<!-- --> <a href="https://fs.blog/chestertons-fence/" target="_blank" rel="noopener noreferrer">Chesterton&#39;s fence</a> <!-- -->errors): Add comments on code that&#39;s referenced elsewhere or would be hard to understand without context. You don&#39;t need human-readable documentation everywhere, you can generate that later if needed.</li><li><strong>Monorepos need extra guidance:</strong> Claude is worse at monorepos. Be explicit about which package you&#39;re working in, use full paths from repo root, and document package-specific scripts.</li></ul><p>Use<!-- --> <a href="https://gist.github.com/SilenNaihin/916e4f2cbcd96f487b2845edaed469a3" target="_blank" rel="noopener noreferrer"><code>/update-claudemd</code></a> <!-- -->in the same chat as you discover a gotcha, add a new pattern, or change the project structure. It aims to update conservatively, only the signal.</p></div></div><h2 id="domain-playbooks">Domain playbooks</h2><h3 id="frontend">Frontend</h3><div><div><div><p>Great prompting and guidelines help most. UI is hard to explain and difficult to verify.</p><p>I found giving access to take screenshots of the UI was slow and imperfect but it&#39;s possible this won&#39;t be the case a month down the line.</p><p>The interactions with the books and podcasts sections on<!-- --> <a href="https://silennai.com/content" target="_blank" rel="noopener noreferrer">my website</a> <!-- -->took forever. Human judgment, screenshots, explaining, and organic coding.</p></div><ul><li><strong>Keep leaf components presentational:</strong> Business logic lives in parent components. Separating concerns makes it easy to audit props and spot irregularities. It also helps the agent find patterns to follow.</li></ul><ul><li><strong>For the last mile, jump into your IDE:</strong> AI struggles with pixel perfect work. You&#39;ll likely need some organic coding to make it perfect.</li><li><strong>Responsiveness gets forgotten:</strong> Models are bad at remembering responsiveness matters. Tell it to keep it in mind from the start, and expect to do some organic coding to make it perfect.</li><li><strong>frontend-design plugin:</strong> From the Claude Code plugin store. Helps with design decisions and component structure. Just ask Claude to install it.</li></ul><h4 id="screenshots">Screenshots</h4><div><p>Drag screenshots into chat.</p><p><a href="https://steipete.me" target="_blank" rel="noopener noreferrer">Pete</a> <!-- -->mentions that at least 50% of his prompts contain screenshots. I use them sparingly. They can be powerful for UI fixes but are slow and imperfect for iterative frontend work.</p><p>I like to generate UIs or visual components in Nano Banana Pro and paste the screenshot to get Claude to generate it.</p></div><h4 id="frontend-gotchas">Gotchas</h4><ul><li><strong>Silencing linters:</strong> There&#39;s been times agents biased towards shutting the linter up with<!-- --> <code>eslint-disable</code> instead of fixing issues. If you notice this happening, use<!-- --> <code>eslint-comments/no-restricted-disable</code>.</li><li><strong>Make styling reference docs:</strong> Create styling components and component reference markdown files. Reference them always. Set up <code>tailwind.config</code> with main colors, spacing tokens, etc.</li><li><strong>Install Vercel&#39;s React best practices skill:</strong> <a href="https://vercel.com/blog/introducing-react-best-practices" target="_blank" rel="noopener noreferrer">Vercel released a skill</a> <!-- -->that encodes React patterns and conventions. Worth installing for any React/Next.js project.</li></ul></div></div><h3 id="backend">Backend</h3><div><div><p>Verifiability is straightforward here. Some advice:</p><ul><li><strong>Use an ORM for schema-as-context:</strong> The entire DB schema in a file that AI understands. There&#39; other ways to do this but I&#39;ve loved using Prisma with coding agents.</li><li><strong>Realistic seed data:</strong> Invest in tooling to keep your local DB populated with realistic data. This lets agents self verify in a realistic way.</li><li><strong>Generate API docs and Postman workspaces:</strong> When working with APIs, ask Claude to generate documentation and a Postman collection so you can easily test endpoints yourself.</li></ul></div></div><h3 id="research">AI research</h3><div><div><div><p>I&#39;m just starting to experiment with this. I&#39;ve given Claude access to a VM with an A100 to see what experiments it performs.</p><p>Karpathy<!-- --> <a href="https://x.com/karpathy/status/2005421816110862601" target="_blank" rel="noopener noreferrer">shared his experience</a>:</p></div><div><div><p>Claude has been running my nanochat experiments since morning. It writes implementations, debugs them with toy examples, writes tests and makes them fail/pass, launches training runs, babysits them by tailing logs and pulling stats from wandb, keeps a running markdown file of highlights, keeps a running record of runs and results so far, presents results in nice tables, we just finished some profiling, noticed inefficiencies in the optimizer resolved them and measured improvements.</p><p>It&#39;s not perfect but I&#39;m used to doing all of these things manually, so just seeing it running on the side cranking away at larger scope problems and coordinating all these flows in relatively coherent ways is definitely a new experience and a complete change of workflow.</p><p>— Andrej Karpathy</p></div></div><div><p>So far it seems to me that models are able to grok pretty much anything and are great partners to think through things. Paste in a document about your hypothesis, and they can help you execute on it.</p><p>Have fun. But remember, extraordinary claims require extraordinary evidence. Avoid getting one shotted into psychosis land.</p></div></div></div><h3 id="learning">Learning</h3><div><div><p>Claude Code is great for generating IPYNBs and using a<!-- --> <a href="https://silen.notion.site/My-prompt-for-learning-new-computational-concepts-2d72b9e381378056beced8f7ff14878f" target="_blank" rel="noopener noreferrer">large prompt for learning concepts</a>. But when you&#39;re sitting there trying to grok things and want to stay in the loop, Cursor&#39;s Cmd+K and chat is best (along with ChatGPT).</p><ul><li><strong>Questioning your assumptions:</strong> Ask it to challenge your understanding.</li><li><strong>Fill-in-the-blank code:</strong> Instead of generating everything, have it create scaffolding with gaps for you to fill.</li></ul></div></div><h2 id="scaling-up">Advanced Claude Code usage</h2><div><div><div><p>On Mac, run <code>caffeinate -dimsu</code> to prevent your laptop from sleeping while Claude works. Start a task, close your laptop, go places.</p><p>When you paste something longer, Claude simplifies this in the terminal to <code>[Pasted text #x +x lines]</code>. 9/10 times I like this.</p><p>The other 10% here&#39;s my workaround: I send a bash command like <code>!sleep 100</code>, then I click enter on my prompt, then the up arrow. This will bring the fully expanded queued prompt into your terminal.</p><p>We used to have shiny rainbow text whenever we typed &#39;ultrathink&#39; which would maximize Claude&#39;s thinking.</p><figure><img src="https://hamy.xyz/articles/claude-code/ultrathink.png" alt="ultrathink old"/></figure><p>But it&#39;s &#39;on&#39; by default now.</p><figure><img src="https://hamy.xyz/articles/claude-code/deprecated.png" alt="ultrathink deprecated"/></figure></div><h3 id="ralph">Ralph for larger projects</h3><div><p>Unfortunately, for almost everything,<!-- --> <a href="https://x.com/ryancarson/status/2008548371712135632" target="_blank" rel="noopener noreferrer">Ralph</a> <!-- -->is more of a pain to get working than it&#39;s worth. Sorry to disappoint the hype.</p><p>Ralph basically puts a bunch of Claude codes into a loop and coordinates them using a <code>prd.json</code> and<!-- --> <code>progress.txt</code>. I do sometimes use it when I&#39;m starting a new project.</p><p>If you are brave enough to give it a shot, the<!-- --> <a href="https://gist.github.com/SilenNaihin/e370eb10c468916b98e4df57cf042c9a" target="_blank" rel="noopener noreferrer"><code>/setup-ralph</code> command</a> <!-- -->sets up all the Ralph files for you.</p><p>Ralph exits early when it detects keywords like &#34;done&#34;, &#34;complete&#34;, or &#34;finished&#34; in your progress files. Use status terms like<!-- --> <code>PASSED</code>/<code>PENDING</code> instead to avoid premature exits.<!-- --> </p><p>Also, Claude can confuse itself into thinking it&#39;s advising<!-- --> <em>about</em> Ralph rather than <em>being</em> the agent. Make your PROMPT.md direct: &#34;You are the agent. Do the work.&#34;</p><p>The key to Ralph: keep an accompanying chat open to guide it and check on progress. Ralph runs in the background; you steer from the side. When starting Ralph, I tell my monitoring chat: &#34;Sleep for 30 seconds, then check if Ralph is executing correctly. Repeat 3 times.&#34; This catches early issues before you walk away.</p></div><h3 id="phone-coding">Code on your phone</h3><div><p>Use<!-- --> <a href="https://vibetunnel.sh" target="_blank" rel="noopener noreferrer">vibetunnel.sh</a> <!-- -->with Tailscale to code from your phone and you can run Claude Code on your phone from anywhere.</p><figure><img src="https://hamy.xyz/articles/claude-code/vibetunnel.png" alt="Phone coding"/><figcaption><a href="https://github.com/amantus-ai/vibetunnel" target="_blank" rel="noopener noreferrer">The VibeTunnel desktop connection</a></figcaption></figure></div><h3 id="hooks">Hooks, Subagents, Skills, and MCP</h3><div><p><strong><a href="https://code.claude.com/docs/en/sub-agents" target="_blank" rel="noopener noreferrer">Custom Subagents</a></strong> <!-- -->are spawned instances that don&#39;t pollute your main context but can report back directly to it. I have a custom agents for different types of deep research, and a<!-- --> <code>claude-critic</code> agent for opinions. A friend uses a<!-- --> <code>/f</code> command in a subagent to find relevant files and context without cluttering the main agent.</p><p>Use cases: large refactoring (subagent for each logical group of files), code review pipelines (style-checker, security-scanner, test-coverage in parallel), research tasks (explore subagent for unfamiliar codebases).</p><p><strong><a href="https://code.claude.com/docs/en/hooks-guide#hook-events-overview" target="_blank" rel="noopener noreferrer">Hooks</a></strong> <!-- -->execute on specific events (tool call, stop, etc.). I&#39;ve experimented but nothing has stuck. One use case: running Prettier on <code>.ts</code> files after Claude finishes. A good mental model for when to use hooks: a) specific things you do at a certain point (like after chat) often, and b) it can be done through a bash command.</p><p>I&#39;ve heard about running a &#34;Do more&#34; prompt when Claude finishes via the Stop hook to keep it working for hours.</p><p><strong><a href="https://code.claude.com/docs/en/skills" target="_blank" rel="noopener noreferrer">Skills</a></strong> <!-- -->are folders where the LLM decides when or what to load. Files with scripts, prompts, etc. They&#39; a superset of commands, coming with their own executable code and many potential prompt files. Use cases: code review standards, commit message conventions, database query patterns, API documentation formats.<!-- --> <a href="https://vercel.com/blog/introducing-react-best-practices" target="_blank" rel="noopener noreferrer">Vercel&#39;s React best practices skill</a> <!-- -->is worth installing for React/Next.js projects.</p><p><strong><a href="https://code.claude.com/docs/en/mcp" target="_blank" rel="noopener noreferrer">MCP (Model Context Protocol)</a></strong> <!-- -->lets Claude talk to external services directly. Connect to GitHub, Slack, databases, issue trackers. Use cases: implement features from JIRA issues, query PostgreSQL directly, integrate Figma designs, draft Gmail responses, summarize Slack threads. Run <code>/mcp</code> to see your connections.</p><figure><img src="https://hamy.xyz/articles/claude-code/advanced-concepts.jpeg" alt="Advanced Concepts"/></figure><p><a href="https://x.com/eyad_khrais/status/2010810802023141688" target="_blank" rel="noopener noreferrer">Here&#39;s a guide that goes more in depth on these</a>. I think you should get started without reading it. If you feel something is missing or you try to close the loop some other way and it doesn&#39;t work, come back and read it.</p></div><h3 id="headless-mode">Headless Mode</h3><div><p>The <code>-p</code> flag runs Claude Code in headless mode. It runs your prompt and outputs the result without entering the interactive interface. This means you can script it, pipe output to other tools, chain it with bash commands, integrate into automated workflows.</p><p>People use this for automatic PR reviews, automatic support ticket responses, documentation updates. All logged and auditable.</p></div></div></div><h2 id="baseline">The bottom line</h2><div><p>To make your life easier, I&#39;ve encoded the entire alpha of this article in these two commands:</p><!-- --> <p><a href="https://gist.github.com/SilenNaihin/3f6b6ccdc1f24911cfdec78dbc334547" target="_blank" rel="noopener noreferrer"><code>/setup-claude-code</code></a></p><!-- --><p>(global, run once per machine) and</p><!-- --> <p><a href="https://gist.github.com/SilenNaihin/e402188c89aab94de61df3da1c10d6ca" target="_blank" rel="noopener noreferrer"><code>/setup-repo</code></a></p><!-- --><p>(per project). They interview you for what you need and set everything up. Just paste this into your Claude Code chat and run it:</p><div><pre>Download these commands to ~/.claude/commands/:

1. /setup-claude-code (run once per machine - installs all other commands):
https://gist.github.com/SilenNaihin/3f6b6ccdc1f24911cfdec78dbc334547

2. /setup-repo (run once per project):
https://gist.github.com/SilenNaihin/e402188c89aab94de61df3da1c10d6ca

Fetch each gist and save as [command-name].md in ~/.claude/commands/

Then run /setup-claude-code to install everything else.</pre></div></div><div><div><p>This will all change. Quickly. Here&#39;s what I believe will persist:</p><ul><li><strong>Planning leverage will only increase.</strong> As models get better, a well-structured prompt/repo pays off even more.</li><li><strong>The ability to quickly verify work will remain important.</strong> </li><li><strong>Close the loop.</strong> If you do something more than once, abstract it. Commands, docs, components. This principle predates AI.</li><li><strong>Don&#39;t be lazy.</strong> Figure out what needs to be done logically. You don&#39;t actually have to code, but do the hard thinking. A lot of times you&#39;ll realize what you&#39;re trying to do is either simpler or harder than you think.</li><li><strong>There&#39;s no &#34;right answer.&#34;</strong> The only way to create your best system is to create it yourself by being in the loop. Best is biased by taste and experience. Experiment, iterate, and discover what works for you.</li></ul></div></div><h2 id="links">Links and Credits</h2><h2 id="command-summary">Command Summary</h2><div><div><p>All commands I recommend, organized by type and frequency.</p><div><table><thead><tr><th>Command</th><th>Type</th><th>Usage</th></tr></thead><tbody><tr><td>/compact</td><td>Default</td><td>Every chat</td></tr><tr><td>/context</td><td>Default</td><td>Every chat</td></tr><tr><td>/rewind</td><td>Default</td><td>Situational</td></tr><tr><td>/resume</td><td>Default</td><td>Situational</td></tr><tr><td>/agents</td><td>Default</td><td>Situational</td></tr><tr><td>/clear</td><td>Default</td><td>Situational</td></tr></tbody></table></div><p><strong>Custom commands</strong> (gists linked):</p><div><table><thead><tr><th>Command</th><th>Usage</th><th>Link</th></tr></thead><tbody><tr><td>/setup-claude-code</td><td>Once per machine</td><td><span><a href="https://gist.github.com/SilenNaihin/3f6b6ccdc1f24911cfdec78dbc334547">gist</a></span></td></tr><tr><td>/setup-repo</td><td>Once per project</td><td><span><a href="https://gist.github.com/SilenNaihin/e402188c89aab94de61df3da1c10d6ca">gist</a></span></td></tr><tr><td>/setup-ralph</td><td>When using Ralph</td><td><span><a href="https://gist.github.com/SilenNaihin/e370eb10c468916b98e4df57cf042c9a">gist</a></span></td></tr><tr><td>/commit-smart</td><td>Every commit</td><td><span><a href="https://gist.github.com/SilenNaihin/d4b3870178667475b08e1f48d6cdbc30">gist</a></span></td></tr><tr><td>/interview-me-planmd</td><td>Planning</td><td><span><a href="https://gist.github.com/SilenNaihin/0733adf5e8deea4242878938c3bdc9fb">gist</a></span></td></tr><tr><td>/update-claudemd</td><td>End of session</td><td><span><a href="https://gist.github.com/SilenNaihin/916e4f2cbcd96f487b2845edaed469a3">gist</a></span></td></tr><tr><td>/transfer-context</td><td>When context degrades</td><td><span><a href="https://gist.github.com/SilenNaihin/e4be0e8750343d9cbafdaab88366115c">gist</a></span></td></tr><tr><td>/debug</td><td>When stuck</td><td><span><a href="https://gist.github.com/SilenNaihin/6833c01f597c82912af5aca4e3467a35">gist</a></span></td></tr><tr><td>/refactor</td><td>After large additions</td><td><span><a href="https://gist.github.com/SilenNaihin/cd321a0ada16963867ad8984f44922cf">gist</a></span></td></tr><tr><td>/ensemble-opinion</td><td>Rarely (multi-model)</td><td><span><a href="https://gist.github.com/SilenNaihin/3e9b43522b61e155bd256fe7193493cd">gist</a></span></td></tr><tr><td>/codex-delegate</td><td>Rarely (requires Codex CLI)</td><td><span><a href="https://gist.github.com/SilenNaihin/ff19b2d65d17137b0ee1f609f25205c5">gist</a></span></td></tr><tr><td>/gemini-delegate</td><td>Rarely (requires Gemini CLI)</td><td><span><a href="https://gist.github.com/SilenNaihin/0c27ee7816da489c4ce110bf115f5ab6">gist</a></span></td></tr></tbody></table></div></div></div><p>This guide captures a moment in time. The tools will change, the models will improve, but the principles of planning, verifiability, and closing the loop will persist. Take what works, leave what doesn&#39;t, and develop your own workflow through experimentation.</p></div></div></div></div></div>
  </body>
</html>
