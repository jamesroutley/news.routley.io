<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://varun.ca/ray-march-sdf/">Original</a>
    <h1>Show HN: Iridescent crystal with raymarching and signed distance fields</h1>
    
    <div id="readability-page-1" class="page"><div display="none,none,block"><h3 id="basic-shader-scene" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#basic-shader-scene" aria-label="basic shader scene permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Basic shader scene</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">My goto tool for creative coding is <a href="https://github.com/mattdesl/canvas-sketch" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">canvas-sketch</a>. It offers a <a href="https://github.com/mattdesl/canvas-sketch-util/blob/master/docs/shader.md#shader--createshaderopt" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">utility function</a> that creates a full-screen GLSL shader renderer using <a href="https://regl.party/" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">regl</a>. You can pass in your shader code and uniforms and it takes care of the rest. Here’s an example of a shader that renders a gradient.</p><div data-language="js"><pre><code><span>const</span> canvasSketch <span>=</span> <span>require</span><span>(</span><span>&#39;canvas-sketch&#39;</span><span>)</span><span>;</span>
<span>const</span> createShader <span>=</span> <span>require</span><span>(</span><span>&#39;canvas-sketch-util/shader&#39;</span><span>)</span><span>;</span>
<span>const</span> glsl <span>=</span> <span>require</span><span>(</span><span>&#39;glslify&#39;</span><span>)</span><span>;</span>

<span>const</span> settings <span>=</span> <span>{</span>
  dimensions<span>:</span> <span>[</span><span>1080</span><span>,</span> <span>1080</span><span>]</span><span>,</span>
  context<span>:</span> <span>&#39;webgl&#39;</span><span>,</span>
  animate<span>:</span> <span>true</span><span>,</span>
<span>}</span><span>;</span>

<span>const</span> frag <span>=</span> <span>glsl</span><span>(</span><span><span>`</span><span>
  precision highp float;

  uniform float time;
  varying vec2 vUv;

  void main () {
    vec3 col = 0.5 + 0.5 * cos(time + vUv.xyx + vec3(0,2,4));
    gl_FragColor = vec4(col, 1.0);
  }
</span><span>`</span></span><span>)</span><span>;</span>

<span>const</span> <span>sketch</span> <span>=</span> <span>(</span><span><span>{</span> gl<span>,</span> canvas <span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>createShader</span><span>(</span><span>{</span>
    gl<span>,</span>
    frag<span>,</span>
    uniforms<span>:</span> <span>{</span>
      <span>resolution</span><span>:</span> <span>(</span><span><span>{</span> width<span>,</span> height <span>}</span></span><span>)</span> <span>=&gt;</span> <span>[</span>width<span>,</span> height<span>]</span><span>,</span>
      <span>time</span><span>:</span> <span>(</span><span><span>{</span> time <span>}</span></span><span>)</span> <span>=&gt;</span> time<span>,</span>
      <span>playhead</span><span>:</span> <span>(</span><span><span>{</span> playhead <span>}</span></span><span>)</span> <span>=&gt;</span> playhead<span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>canvasSketch</span><span>(</span>sketch<span>,</span> settings<span>)</span><span>;</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3">Couple of things to note here. <code>createShader</code> bootstraps a default vertex shader (see below) that provides a varying <code>vUv</code>. This essentially maps the pixel coordinates to a value between 0 and 1. You can override this by specifying a custom vertex shader. But for most cases, this is sufficient.</p><p>vert.glsl</p><div data-language="glsl"><pre><code><span>precision</span> <span>highp</span> <span>float</span><span>;</span>
<span>attribute</span> <span>vec3</span> position<span>;</span>
<span>varying</span> <span>vec2</span> vUv<span>;</span>

<span>void</span> <span>main</span> <span>(</span><span>)</span> <span>{</span>
  gl_Position <span>=</span> <span>vec4</span><span>(</span>position<span>.</span>xyz<span>,</span> <span>1.0</span><span>)</span><span>;</span>
  vUv <span>=</span> gl_Position<span>.</span>xy <span>*</span> <span>0.5</span> <span>+</span> <span>0.5</span><span>;</span>
<span>}</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3">I’m also using a tool called <code>glslify</code> to wrap the shader code. This enables us to import GLSL modules into our shader. We’ll use it to import SDF functions and other raymarching utilities.</p><h3 id="the-raymarching-algorithm" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#the-raymarching-algorithm" aria-label="the raymarching algorithm permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>The Raymarching Algorithm</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">Below is an implementation of the ray marching algorithm. The camera is positioned as the <code>rayOrigin</code>, and pointed towards the <code>rayTarget</code>—the center of the scene.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">The <code>rayDirection</code> is a vector that points from the origin towards a a pixel on the screen, while accounting for the camera’s orientation and field of view. It requires a bit of fancy math to figure out this direction. We’ll be using the <code>glsl-camera-ray</code> module to run that calculation.</p><p><img src="https://erikarow.land/static/ray-direction-8b0a68215b4c83cd9236ca43e204a9da.svg" alt="Ray starts at the camera, goes through the pixel on the screen and moves through the scene" display="block"/></p><p font-family="systemSans" color="neutral.0" font-size="2,3">Once we obtain the ray direction, we proceed along it, checking for collisions. If a collision is detected, the distance to the surface is returned. Otherwise, we return <code>-1.0</code> to signify that no collision was found.</p><div data-language="glsl"><pre><code><span>precision</span> <span>highp</span> <span>float</span><span>;</span>
<span>varying</span> <span>vec2</span> vUv<span>;</span>
<span>uniform</span> <span>float</span> lensLength<span>;</span>

<span><span>#</span><span>pragma</span> <span>glslify<span>:</span> camera <span>=</span> <span>require</span><span>(</span></span><span>&#39;glsl-camera-ray&#39;</span><span><span>)</span></span></span>

<span>float</span> <span>sdSphere</span><span>(</span><span>vec3</span> point<span>,</span> <span>float</span> radius<span>)</span> <span>{</span>
  <span>return</span> <span>length</span><span>(</span>point<span>)</span> <span>-</span> radius<span>;</span>
<span>}</span>

<span>const</span> <span>int</span> steps <span>=</span> <span>90</span><span>;</span>
<span>const</span> <span>float</span> maxdist <span>=</span> <span>20.0</span><span>;</span>
<span>const</span> <span>float</span> precis <span>=</span> <span>0.001</span><span>;</span>

<span>float</span> <span>raymarch</span><span>(</span><span>vec3</span> rayOrigin<span>,</span> <span>vec3</span> rayDir<span>)</span> <span>{</span>
  <span>float</span> latest <span>=</span> precis <span>*</span> <span>2.0</span><span>;</span>
  <span>float</span> dist <span>=</span> <span>0.0</span><span>;</span>
  <span>float</span> res <span>=</span> <span>-</span><span>1.0</span><span>;</span>

  
  <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> steps<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    
    <span>if</span> <span>(</span>latest <span>&lt;</span> precis <span>||</span> dist <span>&gt;</span> maxdist<span>)</span> <span>break</span><span>;</span>
    
    <span>float</span> latest <span>=</span> <span>sdSphere</span><span>(</span>rayOrigin <span>+</span> rayDir <span>*</span> dist<span>,</span> <span>1.0</span><span>)</span><span>;</span>
    
    dist <span>+=</span> latest<span>;</span>
  <span>}</span>
  
  
  <span>if</span> <span>(</span>dist <span>&lt;</span> maxdist<span>)</span> <span>{</span>
    res <span>=</span> dist<span>;</span>
  <span>}</span>

  <span>return</span> res<span>;</span>
<span>}</span>

<span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
  <span>vec3</span> color <span>=</span> <span>vec3</span><span>(</span><span>0.0</span><span>)</span><span>;</span>

  
  <span>vec3</span> rayOrigin <span>=</span> <span>vec3</span><span>(</span><span>3.5</span><span>,</span> <span>0.</span><span>,</span> <span>3.5</span><span>)</span><span>;</span>
  <span>vec3</span> rayTarget <span>=</span> <span>vec3</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
  
  <span>vec2</span> screenPos <span>=</span> vUv <span>*</span> <span>2.0</span> <span>-</span> <span>1.</span><span>;</span>
  <span>vec3</span> rayDirection <span>=</span> <span>camera</span><span>(</span>rayOrigin<span>,</span> rayTarget<span>,</span> screenPos<span>,</span> lensLength<span>)</span><span>;</span>

  <span>float</span> collision <span>=</span> <span>raymarch</span><span>(</span>rayOrigin<span>,</span> rayDirection<span>)</span><span>;</span>

  
  <span>if</span> <span>(</span>collision <span>&gt;</span> <span>-</span><span>0.5</span><span>)</span> <span>{</span>
    color <span>=</span> <span>vec3</span><span>(</span><span>0.678</span><span>,</span> <span>0.106</span><span>,</span> <span>0.176</span><span>)</span><span>;</span>
  <span>}</span>

  gl_FragColor <span>=</span> <span>vec4</span><span>(</span>color<span>,</span> <span>1</span><span>)</span><span>;</span>
<span>}</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3"><code>lensLength</code> here determines the field of view. Try changing it to see how it affects the scene.</p><h3 id="using-glsl-modules-for-raymarching" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#using-glsl-modules-for-raymarching" aria-label="using glsl modules for raymarching permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Using GLSL modules for raymarching</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">Implementing your own raymarching function is cool. It’s especially useful when you want to tweak the inner workings to achieve a specific effect. However, in most cases, you can probably just use an off-the-shelf module.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">Below, I’ve updated the sketch to use the <code>glsl-raytrace</code> module. Additionally, I’m using a <code>glsl-sdf-primitives</code> module to generate a torus and <code>glsl-rotate</code> to rotate it.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">The mechanics remain largely similar. The key difference is that geometry is now defined within a function called <code>doModel</code>, and raymarch returns a <code>vec2</code> containing the distance and material index. This is useful if you want to render multiple types of objects in a scene.</p><div data-language="glsl"><pre><code><span>precision</span> <span>highp</span> <span>float</span><span>;</span>
<span>varying</span> <span>vec2</span> vUv<span>;</span>
<span>uniform</span> <span>float</span> lensLength<span>;</span>
<span>uniform</span> <span>float</span> time<span>;</span>

<span>vec2</span> <span>doModel</span><span>(</span><span>vec3</span> p<span>)</span><span>;</span>

<span><span>#</span><span>pragma</span> <span>glslify<span>:</span> camera <span>=</span> <span>require</span><span>(</span></span><span>&#39;glsl-camera-ray&#39;</span><span><span>)</span></span></span>
<span><span>#</span><span>pragma</span> <span>glslify<span>:</span> raymarch <span>=</span> <span>require</span><span>(</span></span><span>&#39;glsl-raytrace&#39;</span><span><span>,</span> map <span>=</span> doModel<span>,</span> steps <span>=</span> <span>90</span><span>)</span></span></span>
<span><span>#</span><span>pragma</span> <span>glslify<span>:</span> sdTorus <span>=</span> <span>require</span><span>(</span></span><span>&#39;glsl-sdf-primitives/sdTorus&#39;</span><span><span>)</span></span></span>
<span><span>#</span><span>pragma</span> <span>glslify<span>:</span> rotate <span>=</span> <span>require</span><span>(</span></span><span>&#39;glsl-rotate/rotate&#39;</span><span><span>)</span></span></span>

<span>vec2</span> <span>doModel</span><span>(</span><span>vec3</span> p<span>)</span> <span>{</span>
  
  p<span>.</span>xy <span>=</span> <span>rotate</span><span>(</span>p<span>.</span>xy<span>,</span> time<span>)</span><span>;</span>
  p<span>.</span>yz <span>=</span> <span>rotate</span><span>(</span>p<span>.</span>yz<span>,</span> time<span>)</span><span>;</span>
  
  <span>float</span> d <span>=</span> <span>sdTorus</span><span>(</span>p<span>,</span> <span>vec2</span><span>(</span><span>0.75</span><span>,</span> <span>0.35</span><span>)</span><span>)</span><span>;</span>
  <span>return</span> <span>vec2</span><span>(</span>d<span>,</span> <span>0.0</span><span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
  <span>vec3</span> color <span>=</span> <span>vec3</span><span>(</span><span>0.0</span><span>)</span><span>;</span>
  
  <span>vec3</span> rayOrigin <span>=</span> <span>vec3</span><span>(</span><span>3.5</span><span>,</span> <span>0</span><span>,</span> <span>3.5</span><span>)</span><span>;</span>
  <span>vec3</span> rayTarget <span>=</span> <span>vec3</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
  
  <span>vec2</span> screenPos <span>=</span> vUv <span>*</span> <span>2.0</span> <span>-</span> <span>1.</span><span>;</span>
  <span>vec3</span> rayDirection <span>=</span> <span>camera</span><span>(</span>rayOrigin<span>,</span> rayTarget<span>,</span> screenPos<span>,</span> lensLength<span>)</span><span>;</span>

  <span>vec2</span> collision <span>=</span> <span>raymarch</span><span>(</span>rayOrigin<span>,</span> rayDirection<span>)</span><span>;</span>

  
  <span>if</span> <span>(</span>collision<span>.</span>x <span>&gt;</span> <span>-</span><span>0.5</span><span>)</span> <span>{</span>
    color <span>=</span> <span>vec3</span><span>(</span><span>0.678</span><span>,</span> <span>0.106</span><span>,</span> <span>0.176</span><span>)</span><span>;</span>
  <span>}</span>

  gl_FragColor <span>=</span> <span>vec4</span><span>(</span>color<span>,</span> <span>1</span><span>)</span><span>;</span>
<span>}</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3">Check it out! We’ve got a spinning donut 🍩 But it looks kinda flat. Let’s add some depth to the scene.</p><h3 id="calculating-normals" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#calculating-normals" aria-label="calculating normals permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Calculating normals</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">For the classic material and lighting combination, we need to calculate surface normals. That is, a vector that points away from the surface at a given point.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">With SDFs, we calculate the normal by taking the gradient of the SDF function (f) at a specific point, denoted as ∇f. I don’t know about you, but the last time I took a gradient was in <a href="https://apps.ualberta.ca/catalogue/course/mec_e/537" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">MEC E 537 - Aerodynamics</a>. And that was a while ago 😅</p><p font-family="systemSans" color="neutral.0" font-size="2,3">Luckily for us, we can use the <code>glsl-sdf-normal</code> module to compute normals for us. The module uses the same <code>doModel</code> function that we defined for raymarching. If you’re curious about the underlying math, check out <a href="https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">Jamie Wong’s explanation</a>.</p><div data-language="glsl"><pre><code><span><span>#</span><span>pragma</span> <span>glslify<span>:</span> normal <span>=</span> <span>require</span><span>(</span></span><span>&#39;glsl-sdf-normal&#39;</span><span><span>,</span> map <span>=</span> doModel<span>)</span></span></span>



<span>if</span> <span>(</span>collision<span>.</span>x <span>&gt;</span> <span>-</span><span>0.5</span><span>)</span> <span>{</span>
  
  <span>vec3</span> pos <span>=</span> rayOrigin <span>+</span> rayDirection <span>*</span> collision<span>.</span>x<span>;</span>
  
  <span>vec3</span> nor <span>=</span> <span>normal</span><span>(</span>pos<span>)</span><span>;</span>
  
  color <span>=</span> nor <span>*</span> <span>0.5</span> <span>+</span> <span>0.5</span><span>;</span>
<span>}</span>

</code></pre></div><h3 id="phong-lighting" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#phong-lighting" aria-label="phong lighting permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Phong lighting</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">My personal philosophy is very much:</p><p><img alt="Fuck around find out" src="https://erikarow.land/static/fuck-around-find-out-cc2e14bf2895e5634f02f2f2475d8531.jpg" display="block"/></p><p font-family="systemSans" color="neutral.0" font-size="2,3">It’s important to understand how things work, but I’m less focused on implementing everything from scratch and more intrigued by applying those concepts to create my own sketches and scenes. That’s why I was super excited to come across <a href="http://stack.gl/packages" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">stack.gl/packages</a>.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">The stackgl ecosystem is full of little GLSL modules that you can glue these together to create all kinds of effects.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">Interested in adding lighting to the scene? What type would you prefer? Lambert, Phong, Beckmann, or Specular? Just grab the associated module and plug it into the scene.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">I chose <code>glsl-specular-blinn-phong</code></p><div data-language="glsl"><pre><code><span><span>#</span><span>pragma</span> <span>glslify<span>:</span> blinnPhongSpec <span>=</span> <span>require</span><span>(</span></span><span>&#39;glsl-specular-blinn-phong&#39;</span><span><span>)</span></span></span>



<span>vec3</span> lightPos <span>=</span> <span>vec3</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>)</span><span>;</span>
<span>vec3</span> tint <span>=</span> <span>vec3</span><span>(</span><span>0.05</span><span>,</span> <span>0.0</span><span>,</span> <span>0.97</span><span>)</span><span>;</span> 

<span>vec2</span> collision <span>=</span> <span>raymarch</span><span>(</span>rayOrigin<span>,</span> rayDirection<span>)</span><span>;</span>


<span>if</span> <span>(</span>collision<span>.</span>x <span>&gt;</span> <span>-</span><span>0.5</span><span>)</span> <span>{</span>
  
  <span>vec3</span> pos <span>=</span> rayOrigin <span>+</span> rayDirection <span>*</span> collision<span>.</span>x<span>;</span>
  
  <span>vec3</span> nor <span>=</span> <span>normal</span><span>(</span>pos<span>)</span><span>;</span>

  
  <span>vec3</span> eyeDirection <span>=</span> <span>normalize</span><span>(</span>rayOrigin <span>-</span> pos<span>)</span><span>;</span>
  <span>vec3</span> lightDirection <span>=</span> <span>normalize</span><span>(</span>lightPos <span>-</span> pos<span>)</span><span>;</span>
  <span>float</span> power <span>=</span> <span>blinnPhongSpec</span><span>(</span>lightDirection<span>,</span> eyeDirection<span>,</span> nor<span>,</span> <span>0.5</span><span>)</span><span>;</span>
  
  color <span>=</span> power <span>*</span> tint<span>;</span>
<span>}</span></code></pre></div><h3 id="iridescent-material" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#iridescent-material" aria-label="iridescent material permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Iridescent material</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">Stackgl isn’t the only place where you can find useful code. My other favourite option is Shadertoy. I’m not going to lie, most things on shadertoy were too daunting for me. I couldn’t even begin to figure out what the code was doing.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">That is, until I discovered that most work on shadertoy uses a combo of raymarching + SDF. This was certainly a lightbulb moment for me. It’s like suddenly this cryptic code was deciphered and I could understand what it said.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">I’ve been obsessed with iridescence and have been bookmarking cool shaders. Once I learnt the raymarching technique, that was it. I could revisit these shaders and try to understand how they work.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">One such shader was <a href="https://www.shadertoy.com/view/llcXWM" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">Thomas Hooper’s Crystals</a>. It’s way more complex than our scene but the general structure is the same. There’s a function for generating the geometry, there’s raymarching loop and after checking for collision is the bit where the iridescence effect is applied.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">Let’s add that to our scene.</p><div data-language="glsl"><pre><code><span>vec3</span> <span>pal</span><span>(</span> <span>in</span> <span>float</span> t<span>,</span> <span>in</span> <span>vec3</span> a<span>,</span> <span>in</span> <span>vec3</span> b<span>,</span> <span>in</span> <span>vec3</span> c<span>,</span> <span>in</span> <span>vec3</span> d <span>)</span> <span>{</span>
  <span>return</span> a <span>+</span> b<span>*</span><span>cos</span><span>(</span> <span>6.28318</span><span>*</span><span>(</span>c<span>*</span>t<span>+</span>d<span>)</span> <span>)</span><span>;</span>
<span>}</span>

<span>vec3</span> <span>spectrum</span><span>(</span><span>float</span> n<span>)</span> <span>{</span>
  <span>return</span> <span>pal</span><span>(</span> n<span>,</span> <span>vec3</span><span>(</span><span>0.5</span><span>,</span><span>0.5</span><span>,</span><span>0.5</span><span>)</span><span>,</span><span>vec3</span><span>(</span><span>0.5</span><span>,</span><span>0.5</span><span>,</span><span>0.5</span><span>)</span><span>,</span><span>vec3</span><span>(</span><span>1.0</span><span>,</span><span>1.0</span><span>,</span><span>1.0</span><span>)</span><span>,</span><span>vec3</span><span>(</span><span>0.0</span><span>,</span><span>0.33</span><span>,</span><span>0.67</span><span>)</span> <span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>float</span> GAMMA <span>=</span> <span>2.2</span><span>;</span>

<span>vec3</span> <span>gamma</span><span>(</span><span>vec3</span> color<span>,</span> <span>float</span> g<span>)</span> <span>{</span>
  <span>return</span> <span>pow</span><span>(</span>color<span>,</span> <span>vec3</span><span>(</span>g<span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>vec3</span> <span>linearToScreen</span><span>(</span><span>vec3</span> linearRGB<span>)</span> <span>{</span>
  <span>return</span> <span>gamma</span><span>(</span>linearRGB<span>,</span> <span>1.0</span> <span>/</span> GAMMA<span>)</span><span>;</span>
<span>}</span>



<span>if</span> <span>(</span>collision<span>.</span>x <span>&gt;</span> <span>-</span><span>0.5</span><span>)</span> <span>{</span>
  
  <span>vec3</span> pos <span>=</span> rayOrigin <span>+</span> rayDirection <span>*</span> collision<span>.</span>x<span>;</span>
  <span>vec3</span> nor <span>=</span> <span>normal</span><span>(</span>pos<span>)</span><span>;</span>

  <span>vec3</span> eyeDirection <span>=</span> <span>normalize</span><span>(</span>rayOrigin <span>-</span> pos<span>)</span><span>;</span>
  <span>vec3</span> lightDirection <span>=</span> <span>normalize</span><span>(</span>lightPos <span>-</span> pos<span>)</span><span>;</span>

  
  <span>vec3</span> reflection <span>=</span> <span>reflect</span><span>(</span>rayDirection<span>,</span> nor<span>)</span><span>;</span>
  <span>vec3</span> dome <span>=</span> <span>vec3</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>)</span><span>;</span>
  
  <span>vec3</span> perturb <span>=</span> <span>sin</span><span>(</span>pos <span>*</span> <span>10.</span><span>)</span><span>;</span>
  color <span>=</span> <span>spectrum</span><span>(</span><span>dot</span><span>(</span>nor <span>+</span> perturb <span>*</span> <span>.05</span><span>,</span> eyeDirection<span>)</span> <span>*</span> <span>2.</span><span>)</span><span>;</span>
  
  <span>float</span> specular <span>=</span> <span>clamp</span><span>(</span><span>dot</span><span>(</span>reflection<span>,</span> lightDirection<span>)</span><span>,</span> <span>0.</span><span>,</span> <span>1.</span><span>)</span><span>;</span>
  specular <span>=</span> <span>pow</span><span>(</span><span>(</span><span>sin</span><span>(</span>specular <span>*</span> <span>20.</span> <span>-</span> <span>3.</span><span>)</span> <span>*</span> <span>.5</span> <span>+</span> <span>.5</span><span>)</span> <span>+</span> <span>.1</span><span>,</span> <span>32.</span><span>)</span> <span>*</span> specular<span>;</span>
  specular <span>*=</span> <span>.1</span><span>;</span>
  specular <span>+=</span> <span>pow</span><span>(</span><span>clamp</span><span>(</span><span>dot</span><span>(</span>reflection<span>,</span> lightDirection<span>)</span><span>,</span> <span>0.</span><span>,</span> <span>1.</span><span>)</span> <span>+</span> <span>.3</span><span>,</span> <span>8.</span><span>)</span> <span>*</span> <span>.1</span><span>;</span>
  
  <span>float</span> shadow <span>=</span> <span>pow</span><span>(</span><span>clamp</span><span>(</span><span>dot</span><span>(</span>nor<span>,</span> dome<span>)</span> <span>*</span> <span>.5</span> <span>+</span> <span>1.2</span><span>,</span> <span>0.</span><span>,</span> <span>1.</span><span>)</span><span>,</span> <span>3.</span><span>)</span><span>;</span>
  color <span>=</span> color <span>*</span> shadow <span>+</span> specular<span>;</span>

  
  color <span>=</span> <span>linearToScreen</span><span>(</span>color<span>)</span><span>;</span>
<span>}</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3">There are three layers to the iridescent material: the base layer (the funky gradients), a little bit of shadow and specular (the concentric light bands). Try toggling them on and off with the slider see their effects.</p><h3 id="mix-phong-and-iridescence" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#mix-phong-and-iridescence" aria-label="mix phong and iridescence permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Mix Phong and Iridescence</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">One last little tweak with the lighting. We can actually blend the phong and iridescence effects. Which enables you to have tinted iridescent objects.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">There’s not a whole lot to it. Calculate the colors for the two effects and then blend them with the <code>mix</code> function.</p><div data-language="glsl"><pre><code><span>if</span> <span>(</span>collision<span>.</span>x <span>&gt;</span> <span>-</span><span>0.5</span><span>)</span> <span>{</span>
  
  
  <span>float</span> power <span>=</span> <span>blinnPhongSpec</span><span>(</span>lightDirection<span>,</span> eyeDirection<span>,</span> nor<span>,</span> <span>0.5</span><span>)</span><span>;</span>
  <span>vec3</span> baseColor <span>=</span> power <span>*</span> tint<span>;</span>

  
  
  color <span>=</span> color <span>*</span> shadow <span>+</span> specular<span>;</span>

  
  color <span>=</span> <span>mix</span><span>(</span>baseColor<span>,</span> color<span>,</span> mixBaseAndIridescent<span>)</span><span>;</span>
  
  color <span>=</span> <span>linearToScreen</span><span>(</span>color<span>)</span><span>;</span>
<span>}</span></code></pre></div><h3 id="crystal-geometry" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#crystal-geometry" aria-label="crystal geometry permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Crystal geometry</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">We’ve nailed the look, but what about the crystal shape?</p><p font-family="systemSans" color="neutral.0" font-size="2,3">You can file this under “stuff I don’t quite understand, but that’s not going to stop me from using it.” The crystal geometry is a Rhombic Triacontahedron, which I discovered in a <a href="https://www.youtube.com/watch?v=0RWaR7zApEo&amp;t=50s" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">The Art Of Code tutorial</a>.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">This shape is created by folding a plane onto itself using some “magic numbers” and along a “magic direction.” We repeat the process a few times until we achieve the desired crystal shape.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">Try using the slider to observe how the shape changes with each fold.</p><div data-language="glsl"><pre><code><span>float</span> <span>sdCrystal</span><span>(</span><span>vec3</span> p<span>)</span> <span>{</span>
  <span>float</span> c <span>=</span> <span>cos</span><span>(</span><span>3.1415</span><span>/</span><span>5.</span><span>)</span><span>,</span> s<span>=</span><span>sqrt</span><span>(</span><span>0.75</span><span>-</span>c<span>*</span>c<span>)</span><span>;</span> 
  <span>vec3</span> n <span>=</span> <span>vec3</span><span>(</span><span>-</span><span>0.5</span><span>,</span> <span>-</span>c<span>,</span> s<span>)</span><span>;</span> 

  
  p <span>=</span> <span>abs</span><span>(</span>p<span>)</span><span>;</span>
  
  p <span>-=</span> <span>2.</span><span>*</span><span>min</span><span>(</span><span>0.</span><span>,</span> <span>dot</span><span>(</span>p<span>,</span> n<span>)</span><span>)</span><span>*</span>n<span>;</span>

  
  p<span>.</span>xy <span>=</span> <span>abs</span><span>(</span>p<span>.</span>xy<span>)</span><span>;</span>
  p <span>-=</span> <span>2.</span><span>*</span><span>min</span><span>(</span><span>0.</span><span>,</span> <span>dot</span><span>(</span>p<span>,</span> n<span>)</span><span>)</span><span>*</span>n<span>;</span>

  
  p<span>.</span>xy <span>=</span> <span>abs</span><span>(</span>p<span>.</span>xy<span>)</span><span>;</span>
  p <span>-=</span> <span>2.</span><span>*</span><span>min</span><span>(</span><span>0.</span><span>,</span> <span>dot</span><span>(</span>p<span>,</span> n<span>)</span><span>)</span><span>*</span>n<span>;</span>

  
  <span>float</span> d <span>=</span> p<span>.</span>z <span>-</span> <span>1.</span><span>;</span>
  <span>return</span> d<span>;</span>
<span>}</span></code></pre></div></div><div display="block,block,none"><h3 id="basic-shader-scene" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#basic-shader-scene" aria-label="basic shader scene permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Basic shader scene</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">My goto tool for creative coding is <a href="https://github.com/mattdesl/canvas-sketch" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">canvas-sketch</a>. It offers a <a href="https://github.com/mattdesl/canvas-sketch-util/blob/master/docs/shader.md#shader--createshaderopt" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">utility function</a> that creates a full-screen GLSL shader renderer using <a href="https://regl.party/" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">regl</a>. You can pass in your shader code and uniforms and it takes care of the rest. Here’s an example of a shader that renders a gradient.</p><div data-language="js"><pre><code><span>const</span> canvasSketch <span>=</span> <span>require</span><span>(</span><span>&#39;canvas-sketch&#39;</span><span>)</span><span>;</span>
<span>const</span> createShader <span>=</span> <span>require</span><span>(</span><span>&#39;canvas-sketch-util/shader&#39;</span><span>)</span><span>;</span>
<span>const</span> glsl <span>=</span> <span>require</span><span>(</span><span>&#39;glslify&#39;</span><span>)</span><span>;</span>

<span>const</span> settings <span>=</span> <span>{</span>
  dimensions<span>:</span> <span>[</span><span>1080</span><span>,</span> <span>1080</span><span>]</span><span>,</span>
  context<span>:</span> <span>&#39;webgl&#39;</span><span>,</span>
  animate<span>:</span> <span>true</span><span>,</span>
<span>}</span><span>;</span>

<span>const</span> frag <span>=</span> <span>glsl</span><span>(</span><span><span>`</span><span>
  precision highp float;

  uniform float time;
  varying vec2 vUv;

  void main () {
    vec3 col = 0.5 + 0.5 * cos(time + vUv.xyx + vec3(0,2,4));
    gl_FragColor = vec4(col, 1.0);
  }
</span><span>`</span></span><span>)</span><span>;</span>

<span>const</span> <span>sketch</span> <span>=</span> <span>(</span><span><span>{</span> gl<span>,</span> canvas <span>}</span></span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>createShader</span><span>(</span><span>{</span>
    gl<span>,</span>
    frag<span>,</span>
    uniforms<span>:</span> <span>{</span>
      <span>resolution</span><span>:</span> <span>(</span><span><span>{</span> width<span>,</span> height <span>}</span></span><span>)</span> <span>=&gt;</span> <span>[</span>width<span>,</span> height<span>]</span><span>,</span>
      <span>time</span><span>:</span> <span>(</span><span><span>{</span> time <span>}</span></span><span>)</span> <span>=&gt;</span> time<span>,</span>
      <span>playhead</span><span>:</span> <span>(</span><span><span>{</span> playhead <span>}</span></span><span>)</span> <span>=&gt;</span> playhead<span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>canvasSketch</span><span>(</span>sketch<span>,</span> settings<span>)</span><span>;</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3">Couple of things to note here. <code>createShader</code> bootstraps a default vertex shader (see below) that provides a varying <code>vUv</code>. This essentially maps the pixel coordinates to a value between 0 and 1. You can override this by specifying a custom vertex shader. But for most cases, this is sufficient.</p><p>vert.glsl</p><div data-language="glsl"><pre><code><span>precision</span> <span>highp</span> <span>float</span><span>;</span>
<span>attribute</span> <span>vec3</span> position<span>;</span>
<span>varying</span> <span>vec2</span> vUv<span>;</span>

<span>void</span> <span>main</span> <span>(</span><span>)</span> <span>{</span>
  gl_Position <span>=</span> <span>vec4</span><span>(</span>position<span>.</span>xyz<span>,</span> <span>1.0</span><span>)</span><span>;</span>
  vUv <span>=</span> gl_Position<span>.</span>xy <span>*</span> <span>0.5</span> <span>+</span> <span>0.5</span><span>;</span>
<span>}</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3">I’m also using a tool called <code>glslify</code> to wrap the shader code. This enables us to import GLSL modules into our shader. We’ll use it to import SDF functions and other raymarching utilities.</p><h3 id="the-raymarching-algorithm" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#the-raymarching-algorithm" aria-label="the raymarching algorithm permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>The Raymarching Algorithm</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">Below is an implementation of the ray marching algorithm. The camera is positioned as the <code>rayOrigin</code>, and pointed towards the <code>rayTarget</code>—the center of the scene.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">The <code>rayDirection</code> is a vector that points from the origin towards a a pixel on the screen, while accounting for the camera’s orientation and field of view. It requires a bit of fancy math to figure out this direction. We’ll be using the <code>glsl-camera-ray</code> module to run that calculation.</p><p><img src="https://erikarow.land/static/ray-direction-8b0a68215b4c83cd9236ca43e204a9da.svg" alt="Ray starts at the camera, goes through the pixel on the screen and moves through the scene" display="block"/></p><p font-family="systemSans" color="neutral.0" font-size="2,3">Once we obtain the ray direction, we proceed along it, checking for collisions. If a collision is detected, the distance to the surface is returned. Otherwise, we return <code>-1.0</code> to signify that no collision was found.</p><div data-language="glsl"><pre><code><span>precision</span> <span>highp</span> <span>float</span><span>;</span>
<span>varying</span> <span>vec2</span> vUv<span>;</span>
<span>uniform</span> <span>float</span> lensLength<span>;</span>

<span><span>#</span><span>pragma</span> <span>glslify<span>:</span> camera <span>=</span> <span>require</span><span>(</span></span><span>&#39;glsl-camera-ray&#39;</span><span><span>)</span></span></span>

<span>float</span> <span>sdSphere</span><span>(</span><span>vec3</span> point<span>,</span> <span>float</span> radius<span>)</span> <span>{</span>
  <span>return</span> <span>length</span><span>(</span>point<span>)</span> <span>-</span> radius<span>;</span>
<span>}</span>

<span>const</span> <span>int</span> steps <span>=</span> <span>90</span><span>;</span>
<span>const</span> <span>float</span> maxdist <span>=</span> <span>20.0</span><span>;</span>
<span>const</span> <span>float</span> precis <span>=</span> <span>0.001</span><span>;</span>

<span>float</span> <span>raymarch</span><span>(</span><span>vec3</span> rayOrigin<span>,</span> <span>vec3</span> rayDir<span>)</span> <span>{</span>
  <span>float</span> latest <span>=</span> precis <span>*</span> <span>2.0</span><span>;</span>
  <span>float</span> dist <span>=</span> <span>0.0</span><span>;</span>
  <span>float</span> res <span>=</span> <span>-</span><span>1.0</span><span>;</span>

  
  <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> steps<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    
    <span>if</span> <span>(</span>latest <span>&lt;</span> precis <span>||</span> dist <span>&gt;</span> maxdist<span>)</span> <span>break</span><span>;</span>
    
    <span>float</span> latest <span>=</span> <span>sdSphere</span><span>(</span>rayOrigin <span>+</span> rayDir <span>*</span> dist<span>,</span> <span>1.0</span><span>)</span><span>;</span>
    
    dist <span>+=</span> latest<span>;</span>
  <span>}</span>
  
  
  <span>if</span> <span>(</span>dist <span>&lt;</span> maxdist<span>)</span> <span>{</span>
    res <span>=</span> dist<span>;</span>
  <span>}</span>

  <span>return</span> res<span>;</span>
<span>}</span>

<span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
  <span>vec3</span> color <span>=</span> <span>vec3</span><span>(</span><span>0.0</span><span>)</span><span>;</span>

  
  <span>vec3</span> rayOrigin <span>=</span> <span>vec3</span><span>(</span><span>3.5</span><span>,</span> <span>0.</span><span>,</span> <span>3.5</span><span>)</span><span>;</span>
  <span>vec3</span> rayTarget <span>=</span> <span>vec3</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
  
  <span>vec2</span> screenPos <span>=</span> vUv <span>*</span> <span>2.0</span> <span>-</span> <span>1.</span><span>;</span>
  <span>vec3</span> rayDirection <span>=</span> <span>camera</span><span>(</span>rayOrigin<span>,</span> rayTarget<span>,</span> screenPos<span>,</span> lensLength<span>)</span><span>;</span>

  <span>float</span> collision <span>=</span> <span>raymarch</span><span>(</span>rayOrigin<span>,</span> rayDirection<span>)</span><span>;</span>

  
  <span>if</span> <span>(</span>collision <span>&gt;</span> <span>-</span><span>0.5</span><span>)</span> <span>{</span>
    color <span>=</span> <span>vec3</span><span>(</span><span>0.678</span><span>,</span> <span>0.106</span><span>,</span> <span>0.176</span><span>)</span><span>;</span>
  <span>}</span>

  gl_FragColor <span>=</span> <span>vec4</span><span>(</span>color<span>,</span> <span>1</span><span>)</span><span>;</span>
<span>}</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3"><code>lensLength</code> here determines the field of view. Try changing it to see how it affects the scene.</p><h3 id="using-glsl-modules-for-raymarching" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#using-glsl-modules-for-raymarching" aria-label="using glsl modules for raymarching permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Using GLSL modules for raymarching</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">Implementing your own raymarching function is cool. It’s especially useful when you want to tweak the inner workings to achieve a specific effect. However, in most cases, you can probably just use an off-the-shelf module.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">Below, I’ve updated the sketch to use the <code>glsl-raytrace</code> module. Additionally, I’m using a <code>glsl-sdf-primitives</code> module to generate a torus and <code>glsl-rotate</code> to rotate it.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">The mechanics remain largely similar. The key difference is that geometry is now defined within a function called <code>doModel</code>, and raymarch returns a <code>vec2</code> containing the distance and material index. This is useful if you want to render multiple types of objects in a scene.</p><div data-language="glsl"><pre><code><span>precision</span> <span>highp</span> <span>float</span><span>;</span>
<span>varying</span> <span>vec2</span> vUv<span>;</span>
<span>uniform</span> <span>float</span> lensLength<span>;</span>
<span>uniform</span> <span>float</span> time<span>;</span>

<span>vec2</span> <span>doModel</span><span>(</span><span>vec3</span> p<span>)</span><span>;</span>

<span><span>#</span><span>pragma</span> <span>glslify<span>:</span> camera <span>=</span> <span>require</span><span>(</span></span><span>&#39;glsl-camera-ray&#39;</span><span><span>)</span></span></span>
<span><span>#</span><span>pragma</span> <span>glslify<span>:</span> raymarch <span>=</span> <span>require</span><span>(</span></span><span>&#39;glsl-raytrace&#39;</span><span><span>,</span> map <span>=</span> doModel<span>,</span> steps <span>=</span> <span>90</span><span>)</span></span></span>
<span><span>#</span><span>pragma</span> <span>glslify<span>:</span> sdTorus <span>=</span> <span>require</span><span>(</span></span><span>&#39;glsl-sdf-primitives/sdTorus&#39;</span><span><span>)</span></span></span>
<span><span>#</span><span>pragma</span> <span>glslify<span>:</span> rotate <span>=</span> <span>require</span><span>(</span></span><span>&#39;glsl-rotate/rotate&#39;</span><span><span>)</span></span></span>

<span>vec2</span> <span>doModel</span><span>(</span><span>vec3</span> p<span>)</span> <span>{</span>
  
  p<span>.</span>xy <span>=</span> <span>rotate</span><span>(</span>p<span>.</span>xy<span>,</span> time<span>)</span><span>;</span>
  p<span>.</span>yz <span>=</span> <span>rotate</span><span>(</span>p<span>.</span>yz<span>,</span> time<span>)</span><span>;</span>
  
  <span>float</span> d <span>=</span> <span>sdTorus</span><span>(</span>p<span>,</span> <span>vec2</span><span>(</span><span>0.75</span><span>,</span> <span>0.35</span><span>)</span><span>)</span><span>;</span>
  <span>return</span> <span>vec2</span><span>(</span>d<span>,</span> <span>0.0</span><span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
  <span>vec3</span> color <span>=</span> <span>vec3</span><span>(</span><span>0.0</span><span>)</span><span>;</span>
  
  <span>vec3</span> rayOrigin <span>=</span> <span>vec3</span><span>(</span><span>3.5</span><span>,</span> <span>0</span><span>,</span> <span>3.5</span><span>)</span><span>;</span>
  <span>vec3</span> rayTarget <span>=</span> <span>vec3</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
  
  <span>vec2</span> screenPos <span>=</span> vUv <span>*</span> <span>2.0</span> <span>-</span> <span>1.</span><span>;</span>
  <span>vec3</span> rayDirection <span>=</span> <span>camera</span><span>(</span>rayOrigin<span>,</span> rayTarget<span>,</span> screenPos<span>,</span> lensLength<span>)</span><span>;</span>

  <span>vec2</span> collision <span>=</span> <span>raymarch</span><span>(</span>rayOrigin<span>,</span> rayDirection<span>)</span><span>;</span>

  
  <span>if</span> <span>(</span>collision<span>.</span>x <span>&gt;</span> <span>-</span><span>0.5</span><span>)</span> <span>{</span>
    color <span>=</span> <span>vec3</span><span>(</span><span>0.678</span><span>,</span> <span>0.106</span><span>,</span> <span>0.176</span><span>)</span><span>;</span>
  <span>}</span>

  gl_FragColor <span>=</span> <span>vec4</span><span>(</span>color<span>,</span> <span>1</span><span>)</span><span>;</span>
<span>}</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3">Check it out! We’ve got a spinning donut 🍩 But it looks kinda flat. Let’s add some depth to the scene.</p><h3 id="calculating-normals" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#calculating-normals" aria-label="calculating normals permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Calculating normals</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">For the classic material and lighting combination, we need to calculate surface normals. That is, a vector that points away from the surface at a given point.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">With SDFs, we calculate the normal by taking the gradient of the SDF function (f) at a specific point, denoted as ∇f. I don’t know about you, but the last time I took a gradient was in <a href="https://apps.ualberta.ca/catalogue/course/mec_e/537" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">MEC E 537 - Aerodynamics</a>. And that was a while ago 😅</p><p font-family="systemSans" color="neutral.0" font-size="2,3">Luckily for us, we can use the <code>glsl-sdf-normal</code> module to compute normals for us. The module uses the same <code>doModel</code> function that we defined for raymarching. If you’re curious about the underlying math, check out <a href="https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">Jamie Wong’s explanation</a>.</p><div data-language="glsl"><pre><code><span><span>#</span><span>pragma</span> <span>glslify<span>:</span> normal <span>=</span> <span>require</span><span>(</span></span><span>&#39;glsl-sdf-normal&#39;</span><span><span>,</span> map <span>=</span> doModel<span>)</span></span></span>



<span>if</span> <span>(</span>collision<span>.</span>x <span>&gt;</span> <span>-</span><span>0.5</span><span>)</span> <span>{</span>
  
  <span>vec3</span> pos <span>=</span> rayOrigin <span>+</span> rayDirection <span>*</span> collision<span>.</span>x<span>;</span>
  
  <span>vec3</span> nor <span>=</span> <span>normal</span><span>(</span>pos<span>)</span><span>;</span>
  
  color <span>=</span> nor <span>*</span> <span>0.5</span> <span>+</span> <span>0.5</span><span>;</span>
<span>}</span>

</code></pre></div><h3 id="phong-lighting" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#phong-lighting" aria-label="phong lighting permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Phong lighting</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">My personal philosophy is very much:</p><p><img alt="Fuck around find out" src="https://erikarow.land/static/fuck-around-find-out-cc2e14bf2895e5634f02f2f2475d8531.jpg" display="block"/></p><p font-family="systemSans" color="neutral.0" font-size="2,3">It’s important to understand how things work, but I’m less focused on implementing everything from scratch and more intrigued by applying those concepts to create my own sketches and scenes. That’s why I was super excited to come across <a href="http://stack.gl/packages" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">stack.gl/packages</a>.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">The stackgl ecosystem is full of little GLSL modules that you can glue these together to create all kinds of effects.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">Interested in adding lighting to the scene? What type would you prefer? Lambert, Phong, Beckmann, or Specular? Just grab the associated module and plug it into the scene.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">I chose <code>glsl-specular-blinn-phong</code></p><div data-language="glsl"><pre><code><span><span>#</span><span>pragma</span> <span>glslify<span>:</span> blinnPhongSpec <span>=</span> <span>require</span><span>(</span></span><span>&#39;glsl-specular-blinn-phong&#39;</span><span><span>)</span></span></span>



<span>vec3</span> lightPos <span>=</span> <span>vec3</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>)</span><span>;</span>
<span>vec3</span> tint <span>=</span> <span>vec3</span><span>(</span><span>0.05</span><span>,</span> <span>0.0</span><span>,</span> <span>0.97</span><span>)</span><span>;</span> 

<span>vec2</span> collision <span>=</span> <span>raymarch</span><span>(</span>rayOrigin<span>,</span> rayDirection<span>)</span><span>;</span>


<span>if</span> <span>(</span>collision<span>.</span>x <span>&gt;</span> <span>-</span><span>0.5</span><span>)</span> <span>{</span>
  
  <span>vec3</span> pos <span>=</span> rayOrigin <span>+</span> rayDirection <span>*</span> collision<span>.</span>x<span>;</span>
  
  <span>vec3</span> nor <span>=</span> <span>normal</span><span>(</span>pos<span>)</span><span>;</span>

  
  <span>vec3</span> eyeDirection <span>=</span> <span>normalize</span><span>(</span>rayOrigin <span>-</span> pos<span>)</span><span>;</span>
  <span>vec3</span> lightDirection <span>=</span> <span>normalize</span><span>(</span>lightPos <span>-</span> pos<span>)</span><span>;</span>
  <span>float</span> power <span>=</span> <span>blinnPhongSpec</span><span>(</span>lightDirection<span>,</span> eyeDirection<span>,</span> nor<span>,</span> <span>0.5</span><span>)</span><span>;</span>
  
  color <span>=</span> power <span>*</span> tint<span>;</span>
<span>}</span></code></pre></div><h3 id="iridescent-material" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#iridescent-material" aria-label="iridescent material permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Iridescent material</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">Stackgl isn’t the only place where you can find useful code. My other favourite option is Shadertoy. I’m not going to lie, most things on shadertoy were too daunting for me. I couldn’t even begin to figure out what the code was doing.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">That is, until I discovered that most work on shadertoy uses a combo of raymarching + SDF. This was certainly a lightbulb moment for me. It’s like suddenly this cryptic code was deciphered and I could understand what it said.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">I’ve been obsessed with iridescence and have been bookmarking cool shaders. Once I learnt the raymarching technique, that was it. I could revisit these shaders and try to understand how they work.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">One such shader was <a href="https://www.shadertoy.com/view/llcXWM" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">Thomas Hooper’s Crystals</a>. It’s way more complex than our scene but the general structure is the same. There’s a function for generating the geometry, there’s raymarching loop and after checking for collision is the bit where the iridescence effect is applied.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">Let’s add that to our scene.</p><div data-language="glsl"><pre><code><span>vec3</span> <span>pal</span><span>(</span> <span>in</span> <span>float</span> t<span>,</span> <span>in</span> <span>vec3</span> a<span>,</span> <span>in</span> <span>vec3</span> b<span>,</span> <span>in</span> <span>vec3</span> c<span>,</span> <span>in</span> <span>vec3</span> d <span>)</span> <span>{</span>
  <span>return</span> a <span>+</span> b<span>*</span><span>cos</span><span>(</span> <span>6.28318</span><span>*</span><span>(</span>c<span>*</span>t<span>+</span>d<span>)</span> <span>)</span><span>;</span>
<span>}</span>

<span>vec3</span> <span>spectrum</span><span>(</span><span>float</span> n<span>)</span> <span>{</span>
  <span>return</span> <span>pal</span><span>(</span> n<span>,</span> <span>vec3</span><span>(</span><span>0.5</span><span>,</span><span>0.5</span><span>,</span><span>0.5</span><span>)</span><span>,</span><span>vec3</span><span>(</span><span>0.5</span><span>,</span><span>0.5</span><span>,</span><span>0.5</span><span>)</span><span>,</span><span>vec3</span><span>(</span><span>1.0</span><span>,</span><span>1.0</span><span>,</span><span>1.0</span><span>)</span><span>,</span><span>vec3</span><span>(</span><span>0.0</span><span>,</span><span>0.33</span><span>,</span><span>0.67</span><span>)</span> <span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>float</span> GAMMA <span>=</span> <span>2.2</span><span>;</span>

<span>vec3</span> <span>gamma</span><span>(</span><span>vec3</span> color<span>,</span> <span>float</span> g<span>)</span> <span>{</span>
  <span>return</span> <span>pow</span><span>(</span>color<span>,</span> <span>vec3</span><span>(</span>g<span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>vec3</span> <span>linearToScreen</span><span>(</span><span>vec3</span> linearRGB<span>)</span> <span>{</span>
  <span>return</span> <span>gamma</span><span>(</span>linearRGB<span>,</span> <span>1.0</span> <span>/</span> GAMMA<span>)</span><span>;</span>
<span>}</span>



<span>if</span> <span>(</span>collision<span>.</span>x <span>&gt;</span> <span>-</span><span>0.5</span><span>)</span> <span>{</span>
  
  <span>vec3</span> pos <span>=</span> rayOrigin <span>+</span> rayDirection <span>*</span> collision<span>.</span>x<span>;</span>
  <span>vec3</span> nor <span>=</span> <span>normal</span><span>(</span>pos<span>)</span><span>;</span>

  <span>vec3</span> eyeDirection <span>=</span> <span>normalize</span><span>(</span>rayOrigin <span>-</span> pos<span>)</span><span>;</span>
  <span>vec3</span> lightDirection <span>=</span> <span>normalize</span><span>(</span>lightPos <span>-</span> pos<span>)</span><span>;</span>

  
  <span>vec3</span> reflection <span>=</span> <span>reflect</span><span>(</span>rayDirection<span>,</span> nor<span>)</span><span>;</span>
  <span>vec3</span> dome <span>=</span> <span>vec3</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>)</span><span>;</span>
  
  <span>vec3</span> perturb <span>=</span> <span>sin</span><span>(</span>pos <span>*</span> <span>10.</span><span>)</span><span>;</span>
  color <span>=</span> <span>spectrum</span><span>(</span><span>dot</span><span>(</span>nor <span>+</span> perturb <span>*</span> <span>.05</span><span>,</span> eyeDirection<span>)</span> <span>*</span> <span>2.</span><span>)</span><span>;</span>
  
  <span>float</span> specular <span>=</span> <span>clamp</span><span>(</span><span>dot</span><span>(</span>reflection<span>,</span> lightDirection<span>)</span><span>,</span> <span>0.</span><span>,</span> <span>1.</span><span>)</span><span>;</span>
  specular <span>=</span> <span>pow</span><span>(</span><span>(</span><span>sin</span><span>(</span>specular <span>*</span> <span>20.</span> <span>-</span> <span>3.</span><span>)</span> <span>*</span> <span>.5</span> <span>+</span> <span>.5</span><span>)</span> <span>+</span> <span>.1</span><span>,</span> <span>32.</span><span>)</span> <span>*</span> specular<span>;</span>
  specular <span>*=</span> <span>.1</span><span>;</span>
  specular <span>+=</span> <span>pow</span><span>(</span><span>clamp</span><span>(</span><span>dot</span><span>(</span>reflection<span>,</span> lightDirection<span>)</span><span>,</span> <span>0.</span><span>,</span> <span>1.</span><span>)</span> <span>+</span> <span>.3</span><span>,</span> <span>8.</span><span>)</span> <span>*</span> <span>.1</span><span>;</span>
  
  <span>float</span> shadow <span>=</span> <span>pow</span><span>(</span><span>clamp</span><span>(</span><span>dot</span><span>(</span>nor<span>,</span> dome<span>)</span> <span>*</span> <span>.5</span> <span>+</span> <span>1.2</span><span>,</span> <span>0.</span><span>,</span> <span>1.</span><span>)</span><span>,</span> <span>3.</span><span>)</span><span>;</span>
  color <span>=</span> color <span>*</span> shadow <span>+</span> specular<span>;</span>

  
  color <span>=</span> <span>linearToScreen</span><span>(</span>color<span>)</span><span>;</span>
<span>}</span></code></pre></div><p font-family="systemSans" color="neutral.0" font-size="2,3">There are three layers to the iridescent material: the base layer (the funky gradients), a little bit of shadow and specular (the concentric light bands). Try toggling them on and off with the slider see their effects.</p><h3 id="mix-phong-and-iridescence" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#mix-phong-and-iridescence" aria-label="mix phong and iridescence permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Mix Phong and Iridescence</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">One last little tweak with the lighting. We can actually blend the phong and iridescence effects. Which enables you to have tinted iridescent objects.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">There’s not a whole lot to it. Calculate the colors for the two effects and then blend them with the <code>mix</code> function.</p><div data-language="glsl"><pre><code><span>if</span> <span>(</span>collision<span>.</span>x <span>&gt;</span> <span>-</span><span>0.5</span><span>)</span> <span>{</span>
  
  
  <span>float</span> power <span>=</span> <span>blinnPhongSpec</span><span>(</span>lightDirection<span>,</span> eyeDirection<span>,</span> nor<span>,</span> <span>0.5</span><span>)</span><span>;</span>
  <span>vec3</span> baseColor <span>=</span> power <span>*</span> tint<span>;</span>

  
  
  color <span>=</span> color <span>*</span> shadow <span>+</span> specular<span>;</span>

  
  color <span>=</span> <span>mix</span><span>(</span>baseColor<span>,</span> color<span>,</span> mixBaseAndIridescent<span>)</span><span>;</span>
  
  color <span>=</span> <span>linearToScreen</span><span>(</span>color<span>)</span><span>;</span>
<span>}</span></code></pre></div><h3 id="crystal-geometry" font-family="systemSans" color="neutral.0" font-size="3,4" font-weight="7"><a href="#crystal-geometry" aria-label="crystal geometry permalink" color="brand.main" font-family="systemSans"><svg aria-hidden="true" focusable="false" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a>Crystal geometry</h3><p font-family="systemSans" color="neutral.0" font-size="2,3">We’ve nailed the look, but what about the crystal shape?</p><p font-family="systemSans" color="neutral.0" font-size="2,3">You can file this under “stuff I don’t quite understand, but that’s not going to stop me from using it.” The crystal geometry is a Rhombic Triacontahedron, which I discovered in a <a href="https://www.youtube.com/watch?v=0RWaR7zApEo&amp;t=50s" target="_blank" rel="noopener noreferrer" color="brand.main" font-family="systemSans">The Art Of Code tutorial</a>.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">This shape is created by folding a plane onto itself using some “magic numbers” and along a “magic direction.” We repeat the process a few times until we achieve the desired crystal shape.</p><p font-family="systemSans" color="neutral.0" font-size="2,3">Try using the slider to observe how the shape changes with each fold.</p><div data-language="glsl"><pre><code><span>float</span> <span>sdCrystal</span><span>(</span><span>vec3</span> p<span>)</span> <span>{</span>
  <span>float</span> c <span>=</span> <span>cos</span><span>(</span><span>3.1415</span><span>/</span><span>5.</span><span>)</span><span>,</span> s<span>=</span><span>sqrt</span><span>(</span><span>0.75</span><span>-</span>c<span>*</span>c<span>)</span><span>;</span> 
  <span>vec3</span> n <span>=</span> <span>vec3</span><span>(</span><span>-</span><span>0.5</span><span>,</span> <span>-</span>c<span>,</span> s<span>)</span><span>;</span> 

  
  p <span>=</span> <span>abs</span><span>(</span>p<span>)</span><span>;</span>
  
  p <span>-=</span> <span>2.</span><span>*</span><span>min</span><span>(</span><span>0.</span><span>,</span> <span>dot</span><span>(</span>p<span>,</span> n<span>)</span><span>)</span><span>*</span>n<span>;</span>

  
  p<span>.</span>xy <span>=</span> <span>abs</span><span>(</span>p<span>.</span>xy<span>)</span><span>;</span>
  p <span>-=</span> <span>2.</span><span>*</span><span>min</span><span>(</span><span>0.</span><span>,</span> <span>dot</span><span>(</span>p<span>,</span> n<span>)</span><span>)</span><span>*</span>n<span>;</span>

  
  p<span>.</span>xy <span>=</span> <span>abs</span><span>(</span>p<span>.</span>xy<span>)</span><span>;</span>
  p <span>-=</span> <span>2.</span><span>*</span><span>min</span><span>(</span><span>0.</span><span>,</span> <span>dot</span><span>(</span>p<span>,</span> n<span>)</span><span>)</span><span>*</span>n<span>;</span>

  
  <span>float</span> d <span>=</span> p<span>.</span>z <span>-</span> <span>1.</span><span>;</span>
  <span>return</span> d<span>;</span>
<span>}</span></code></pre></div></div></div>
  </body>
</html>
