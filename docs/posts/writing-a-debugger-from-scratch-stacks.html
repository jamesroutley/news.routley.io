<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.timdbg.com/posts/writing-a-debugger-from-scratch-part-6/">Original</a>
    <h1>Writing a Debugger from Scratch: Stacks</h1>
    
    <div id="readability-page-1" class="page"><div><article><div><p>(New to this series? Consider starting from <a href="https://www.timdbg.com/posts/writing-a-debugger-from-scratch-part-1">part 1</a>)</p><p>At the end of the <a href="https://www.timdbg.com/posts/writing-a-debugger-from-scratch-part-5">last post</a>, DbgRs could finally set breakpoints. That was the last really critical feature needed for controlling execution of a program. Now that it can stop on an arbitrary function or code location, the next step is to find more information about the state of the program. In my opinion, the single most useful piece of information is the call stack, so that’s what this post will be about. Walking call stacks is the most complicated piece of DbgRs so far, and as such this post is somewhat longer than the others. Stick through to the end, though, it’s worth the payoff! To keep this post as readable as I can, I’ve used footnotes for anything that isn’t strictly needed to understand how the stack walking works.</p><p>The code for this post is in the <a href="https://github.com/TimMisiak/dbgrs/tree/part6">part6 branch on github</a>. You can also view the <a href="https://github.com/TimMisiak/dbgrs/compare/part5...part6">changes from part5</a>. If you see any mistakes or ways to improve the code, feel free to <a href="https://github.com/TimMisiak/dbgrs/issues">create issues</a> on the GitHub repo or submit a PR. I’ve had a few folks contribute changes and I really appreciate it!</p><p>Disclaimer: Everything in this post is very specific to x64 Windows code. Stack walking is very different from architecture to architecture and OS to OS. On many platforms, stack walking is significantly simpler. But since DbgRs is specifically an x64 Windows debugger, that’s what this post is going to talk about.</p><p>When we talk about a <em>call stack</em> (sometimes called backtrace), what we’re actually talking about are a stack of <em>frames</em> for a thread. You can think of a frame as the state of a function as it is executing. If function A calls function B, then function A needs to save its state (like local variables) somewhere so that when function B returns, function A can continue executing where it left off. In most cases, this state is saved on a stack. While each frame contains local variables, they also contain the <em>return address</em>, which is the next instruction to be executed when a function returns from a call. When a debugger displays a stack trace, it is enumerating the frames to find the list of return addresses and local variables from each frame. And in reality, both the instruction pointer and local variables are determined from a <em>register context</em>, so we can think of the stack walk as starting with the register context for a thread as the “top” of the stack, and repeatedly “unwinding” that register context to get the register context of the calling function.</p><p>So the fundamental operation we need to implement is to take a register context and the memory of a process and transform that into the register context of the calling function. Start with the “top” of the stack, which is just the current context of a thread, and apply this <a aria-describedby="footnote-label" href="#unwind-or-walk">“stack walk”</a> operation repeatedly (printing the names of each function we find at RIP), and we have our basic stack walk!</p><p>So how do we walk from one frame to the next? For those of you that have taken an operating systems class, you might be thinking “use frame pointers!”. So then, what is a frame pointer? While the stack pointer (RSP) points to the “top” of the stack, the frame pointer (RBP) points to the start of the current function’s frame. Using a frame pointer means we can find all of the local variables and other saved state for a function call as constant offsets from RBP.</p><p>A stack pointer is used for tracking the location of the last data that was “pushed” on the stack, and a frame pointer tracks the start of the stack for a function call, also know as the function’s “frame”. A frame contains all of the data for the invocation of a function, potentially including locals, arguments, and saved copies of <a aria-describedby="footnote-label" href="#nonvolatile-registers">nonvolatile registers</a>. Local variables are referenced as constant offsets to the frame pointer.</p><p>When a function uses frame pointers, the first few instructions will push the frame pointer onto the stack, and then set up the new frame pointer with the current stack pointer with some code that might look something like <a aria-describedby="footnote-label" href="#frame-pointer">this</a>.</p><pre tabindex="0"><code>00007ffa`7144b824 55              push    rbp
00007ffa`7144b825 488bec          mov     rbp,rsp
</code></pre><p>When returning from the function, the caller’s base pointer is popped off the stack, and then execution is returned with a ‘ret’.</p><pre tabindex="0"><code>00007ffa`7144b824 5d              pop     rbp
00007ffa`7144b825 c3              ret
</code></pre><p>When every function does this, the frame pointers form a linked list, with the return address immediately preceding the frame pointer on the stack. This makes it very easy to walk the list on the stack, using the current frame pointer (EBP on x86) as the head pointer of the list.</p><p><img src="https://www.timdbg.com/frame_pointers.png" alt="Following frame pointers"/></p><p>If everyone used frame pointers, this blog post would be <em>extremely</em> short. But if you’ve glanced at your scroll bar, you’ve figured out that frame pointers aren’t the end of the story. And that’s because of a little thing called “Frame Pointer Omission” (FPO).</p><p>In a typical function that allocates a static amount of memory on the stack, the frame pointer is redundant. The compiler knows that a function consumes N bytes of stack, so it adds N to the stack pointer when returning, and all locals can be referenced relative to the stack pointer instead of a frame pointer. And if some part of a function uses some additional stack, such as pushing parameters onto the stack for another function, the compiler can still determine <strong>at compile time</strong> how the offsets of these local variables shift at each instruction of the function. By referencing locals off the stack pointer instead of a frame pointer, it means that an entire register is freed up to be used for <a aria-describedby="footnote-label" href="#fpo-speed">other purposes</a>. On Windows, nearly all <del>64-bit</del> x64 code is compiled with FPO enabled. (CORRECTION: As <a href="https://twitter.com/aaronsgiles/status/1727506942787199015">Aaron Giles points out</a>, FPO is off by default on ARM64, so this is specific to x64, not all 64-bit Windows code)</p><p>That’s a problem for diagnostic tools that want to do stack walks, because they can no longer determine the location of the return address or calling function’s frame address from a frame pointer. Luckily, there’s a solution.</p><p>What makes FPO possible is that compilers always know the size of a frame at a given instruction. It lets the compiler generate offsets to local variables correctly, and it also lets the compiler generate a correct prolog of a function to correctly return to the caller. So to enable diagnostic tools (and exception handling) to do the same thing, this information is stored <em>with</em> an executable file! On Windows, this data is stored in a section called “.pdata”. Since the OS uses this information for exception handling, much of the documentation can be found in the <a href="https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170">MSDN docs for exception handling</a>. The “.pdata” section does not exist for 32-bit x86 executables, and I won’t be discussing here how stack walking works for 32-bit x86 code (short version: it’s messy).</p><p>So let’s take a short tour of what pdata looks like using WinDbg to examine the data. We’ll start a debugging session of an x64 process and take a look at the pdata for kernel32. I’m using cmd.exe here, but any x64 process should work. We can use the “!dh” extension command (Dump Header) as our starting point.</p><pre tabindex="0"><code>0:000&gt; !dh kernel32

File Type: DLL
FILE HEADER VALUES
    8664 machine (X64)
       7 number of sections
D05C34F8 time date stamp Wed Oct  9 05:50:00 2080

...

   C2000 [     520] address [size] of Resource Directory
   BB000 [    5508] address [size] of Exception Directory
   C3000 [    4160] address [size] of Security Directory

...

SECTION HEADER #4
  .pdata name
    5508 virtual size
   BB000 virtual address
    6000 size of raw data
   BA000 file pointer to raw data
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
40000040 flags
         Initialized Data
         (no align specified)
         Read Only
</code></pre><p>Note the address of the “Exception Directory” and the address of the “.pdata” section are both 0xBB000. These are both names for the same data, although the Exception Directory is the authorative source here. If we dump data at that address, we see a collection of <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-runtime_function">RUNTIME_FUNCTION</a> structures.</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>typedef</span> <span>struct</span> <span>_IMAGE_RUNTIME_FUNCTION_ENTRY</span> {
</span></span><span><span>  DWORD BeginAddress;
</span></span><span><span>  DWORD EndAddress;
</span></span><span><span>  <span>union</span> {
</span></span><span><span>    DWORD UnwindInfoAddress;
</span></span><span><span>    DWORD UnwindData;
</span></span><span><span>  } DUMMYUNIONNAME;
</span></span><span><span>} RUNTIME_FUNCTION, <span>*</span>PRUNTIME_FUNCTION, _IMAGE_RUNTIME_FUNCTION_ENTRY, <span>*</span>_PIMAGE_RUNTIME_FUNCTION_ENTRY;
</span></span></code></pre></div><pre tabindex="0"><code>0:000&gt; dd kernel32+BB000
00007ffa`2bf9b000  00001010 0000115a 00098428 00001160
00007ffa`2bf9b010  0000119f 00098444 00001210 00001406
00007ffa`2bf9b020  0009844c 00001440 00001613 00098470
</code></pre><p>Each structure is a 32-bit offset to the start of a function (relative to the base address), followed by a 32-bit offset to the end of the function (one byte past the end actually), and finally a 32-bit offset to the unwind data itself. The structures are packed together, so you can see a pattern repeated every three dwords. If you look closely, you’ll also see that the “BeginAddress” field is increasing for each entry, meaning that this table is sorted. We’ll focus on the first entry in this table, which is the first three dwords.</p><pre tabindex="0"><code>0:000&gt; dd kernel32+BB000 L3
00007ffa`2bf9b000  00001010 0000115a 00098428
</code></pre><p>That gives us a BeginAddress of 0x1010, an EndAddress of 0x115a, and an UnwindInfoAddress of 0x98428. Adding the module base address to the BeginAddress gives us the address of the function this entry is annotating, which happens to be kernel32!Module32NextW.</p><pre tabindex="0"><code>0:000&gt; u kernel32+00001010
KERNEL32!Module32NextW:
00007ffa`2bee1010 4c8bdc          mov     r11,rsp
00007ffa`2bee1013 49895b08        mov     qword ptr [r11+8],rbx
00007ffa`2bee1017 57              push    rdi
00007ffa`2bee1018 4883ec50        sub     rsp,50h
00007ffa`2bee101c 33ff            xor     edi,edi
</code></pre><p>Using the UnwindInfoAddress of 0x98428, we can find the <strong>unwind data</strong> which contains the information we need to unwind this function. The data stored here is described by the <a href="https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170">UNWIND_INFO structure</a>.</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>typedef</span> <span>struct</span> <span>_UNWIND_INFO</span> {
</span></span><span><span>    UBYTE Version       : <span>3</span>;
</span></span><span><span>    UBYTE Flags         : <span>5</span>;
</span></span><span><span>    UBYTE SizeOfProlog;
</span></span><span><span>    UBYTE CountOfCodes;
</span></span><span><span>    UBYTE FrameRegister : <span>4</span>;
</span></span><span><span>    UBYTE FrameOffset   : <span>4</span>;
</span></span><span><span>    UNWIND_CODE UnwindCode[<span>1</span>];
</span></span><span><span><span>/*  UNWIND_CODE MoreUnwindCode[((CountOfCodes + 1) &amp; ~1) - 1];
</span></span></span><span><span><span>*   union {
</span></span></span><span><span><span>*       OPTIONAL ULONG ExceptionHandler;
</span></span></span><span><span><span>*       OPTIONAL ULONG FunctionEntry;
</span></span></span><span><span><span>*   };
</span></span></span><span><span><span>*   OPTIONAL ULONG ExceptionData[]; */</span>
</span></span><span><span>} UNWIND_INFO, <span>*</span>PUNWIND_INFO;
</span></span></code></pre></div><p>We can dump the memory for this structure using <code>db</code></p><pre tabindex="0"><code>0:000&gt; db kernel32+98428
00007ffa`2bf78428  01 0c 04 00 0c 34 0c 00-0c 92 08 70 21 00 00 00  .....4.....p!...
</code></pre><p>This data is a bit harder to decode by hand, but I’ll point out the interesting values here. The first byte is a combination of version and flags. Version is always 1, according to the docs, but the flags can have the following values:</p><table><thead><tr><th>Name</th><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td><code>UNW_FLAG_NHANDLER</code></td><td><code>0x0</code></td><td>The function has no handler.</td></tr><tr><td><code>UNW_FLAG_EHANDLER</code></td><td><code>0x1</code></td><td>The function has an exception handler that should be called.</td></tr><tr><td><code>UNW_FLAG_UHANDLER</code></td><td><code>0x2</code></td><td>The function has a termination handler that should be called when unwinding an exception.</td></tr><tr><td><code>UNW_FLAG_CHAININFO</code></td><td><code>0x4</code></td><td>The FunctionEntry member is the contents of a previous function table entry.</td></tr></tbody></table><p>For this entry, there are no flags set. For the purposes of walking the call stack, we can ignore exception handlers, although eventually we will need to handle. The next value is SizeOfProlog, which is 0xC. Looking at the disassembly again, and we can see this corresponds to the address of the first instruction after the “sub rsp, 50h” instruction:</p><pre tabindex="0"><code>0:000&gt; u kernel32+00001010
KERNEL32!Module32NextW:
00007ffa`2bee1010 4c8bdc          mov     r11,rsp
00007ffa`2bee1013 49895b08        mov     qword ptr [r11+8],rbx
00007ffa`2bee1017 57              push    rdi
00007ffa`2bee1018 4883ec50        sub     rsp,50h
00007ffa`2bee101c 33ff            xor     edi,edi
</code></pre><p>The third byte is CountOfCodes, which is 0x4 here. We’ll look at that more in a moment. Finally, the fourth byte indicates which frame register is used (if any) and what offset to apply (if any). Here, the value is zero, which means that no frame register is used.</p><p>Immediately following the UNWIND_INFO structure are the “unwind codes”. These describe the operations in the prolog, and can be used to “undo” the state of the prolog, getting the state of a stack and context back to the <a aria-describedby="footnote-label" href="#initial-state">initial state</a> when the function was called, making it possible to find the return address and register state for the caller. While the <a href="https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170#struct-unwind_code">UNWIND_CODE</a> structure is 16 bits, some operations consume multiple “slots”. The “count of codes” field from UNWIND_INFO actually describes the number of slots consumed, rather than the number of operations. Here’s the C description of the codes, taken from the documentation page:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>typedef</span> <span>enum</span> <span>_UNWIND_OP_CODES</span> {
</span></span><span><span>    UWOP_PUSH_NONVOL <span>=</span> <span>0</span>, <span>/* info == register number */</span>
</span></span><span><span>    UWOP_ALLOC_LARGE,     <span>/* no info, alloc size in next 2 slots */</span>
</span></span><span><span>    UWOP_ALLOC_SMALL,     <span>/* info == size of allocation / 8 - 1 */</span>
</span></span><span><span>    UWOP_SET_FPREG,       <span>/* no info, FP = RSP + UNWIND_INFO.FPRegOffset*16 */</span>
</span></span><span><span>    UWOP_SAVE_NONVOL,     <span>/* info == register number, offset in next slot */</span>
</span></span><span><span>    UWOP_SAVE_NONVOL_FAR, <span>/* info == register number, offset in next 2 slots */</span>
</span></span><span><span>    UWOP_SAVE_XMM128 <span>=</span> <span>8</span>, <span>/* info == XMM reg number, offset in next slot */</span>
</span></span><span><span>    UWOP_SAVE_XMM128_FAR, <span>/* info == XMM reg number, offset in next 2 slots */</span>
</span></span><span><span>    UWOP_PUSH_MACHFRAME   <span>/* info == 0: no error-code, 1: error-code */</span>
</span></span><span><span>} UNWIND_CODE_OPS;
</span></span><span><span>
</span></span><span><span><span>typedef</span> <span>unsigned</span> <span>char</span> UBYTE;
</span></span><span><span>
</span></span><span><span><span>typedef</span> <span>union</span> <span>_UNWIND_CODE</span> {
</span></span><span><span>    <span>struct</span> {
</span></span><span><span>        UBYTE CodeOffset;
</span></span><span><span>        UBYTE UnwindOp : <span>4</span>;
</span></span><span><span>        UBYTE OpInfo   : <span>4</span>;
</span></span><span><span>    };
</span></span><span><span>    USHORT FrameOffset;
</span></span><span><span>} UNWIND_CODE, <span>*</span>PUNWIND_CODE;
</span></span></code></pre></div><p>The UNWIND_INFO structure is 4 bytes, so we can add 4 to the UnwindInfoAddress to get the array of unwind codes. As we determined from the CountOfCodes field, there are 4 slots. Each slot is 16 bits, so we’ll dump the next 8 bytes.</p><pre tabindex="0"><code>0:000&gt; db kernel32+98428+4 L8
00007ffa`2bf7842c  0c 34 0c 00 0c 92 08 70                          .4.....p
</code></pre><p>The first code here “0C 34” has an offset of 0xC, an unwind operation of 0x4, and an “OpInfo” field of 0x3. Operation 4 is UWOP_SAVE_NONVOL, so the OpInfo field corresponds to the register being saved, which for 0x3 <a href="https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170#operation-info">corresponds to RBX</a>. For UWOP_SAVE_NONVOL, the subsequent slot is used as the offset from the stack pointer (scaled by 8, since all access is 64-bit aligned). The 16-bit value following the first slot is 0xC (remember, this is little endian so 0C 00 bytes become 0x000C as a 16-bit value). Scaling by 8, we get 0xC * 8 == 0x60. Looking at the prolog again you can see RBX is saved to the stack as the second instruction in the prolog at offset RSP+8. With the other operations of the prolog updating RSP, the address of this location ends up being RSP+0x60. See the annotated assembly below to see how this happens.</p><pre tabindex="0"><code>0:000&gt; u kernel32+00001010 L6
KERNEL32!Module32NextW:
00007ffa`2bee1010 4c8bdc          mov     r11,rsp                # Copies RSP into R11
00007ffa`2bee1013 49895b08        mov     qword ptr [r11+8],rbx  # Writes RBX to the stack at [RSP+8]
00007ffa`2bee1017 57              push    rdi                    # Decrements RSP by 8, so RBX is now at [RSP+0x10]
00007ffa`2bee1018 4883ec50        sub     rsp,50h                # Decrements RSP by 0x50, so RBX is now at [RSP+0x60]
00007ffa`2bee101c 33ff            xor     edi,edi                # This is offset 0xC into the function
00007ffa`2bee101e 488bda          mov     rbx,rdx                # This is where the original RBX is overwritten
</code></pre><p>Decoding these by hand is <strong>exhausting</strong>, but luckily there’s an easy shortcut when using WinDbg. The <code>.fnent</code> command will decode all of the unwind operations in an easy to read format!</p><pre tabindex="0"><code>0:000&gt; .fnent kernel32!Module32NextW
Debugger function entry 000001cb`f8df4aa0 for:
(00007ffa`2bee1010)   KERNEL32!Module32NextW   |  (00007ffa`2bee1160)   KERNEL32!ThpCopyAnsiToUnicode
Exact matches:
    KERNEL32!Module32NextW (void)

BeginAddress      = 00000000`00001010
EndAddress        = 00000000`0000115a
UnwindInfoAddress = 00000000`00098428

Unwind info at 00007ffa`2bf78428, c bytes
  version 1, flags 0, prolog c, codes 4
  00: offs c, unwind op 4, op info 3	UWOP_SAVE_NONVOL FrameOffset: 60 reg: rbx.
  02: offs c, unwind op 2, op info 9	UWOP_ALLOC_SMALL.
  03: offs 8, unwind op 0, op info 7	UWOP_PUSH_NONVOL reg: rdi.
</code></pre><p>The operations are listed in reverse order, which is very convenient when unwinding the stack, since the operations need to be applied in reverse order to reverse the operations of the prolog. Unwinding the stack while in the middle of a prolog is also possible. We just need to skip any of the unwind operations that occur after the current instruction.</p><h2 id="what-about-the-epilog">What about the epilog???</h2><p>It might seem strange to you that we have so much metadata about the prolog, but nothing about the epilog! If code is currently executing in the middle of an epilog, we don’t know which prolog operations have already been reversed, so attempting to follow the unwind operations could get us into a completely bogus state. And the answer might be a little surprising. To unwind the stack while in an epilog, we need to <a href="https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170#unwind-procedure">read the code stream</a> to determine if we are in an epilog, and if so, we simply emulate the remaining portion of the epilog. This is feasible only because epilogs have <a href="https://learn.microsoft.com/en-us/cpp/build/prolog-and-epilog?view=msvc-170#epilog-code">very strict rules</a> that make it easy to detect and simulate epilogs. The epilog must always:</p><ol><li>Deallocate the “fixed part” of the stack</li><li>Pop all nonvolatile registers</li><li>Return control to the caller (via “ret”)</li></ol><p>The deallocation of the fixed part of the stack must only use an <code>ADD</code> or <code>LEA</code> instruction, and the nonvolatile pops must use the <code>POP &lt;reg&gt;</code> instructions. To detect an epilog, we start reading code bytes and stop if we ever hit an instruction that is not legal inside an epilog or if we hit a <code>ret</code> instruction. Hitting a <code>ret</code> before any instructions invalid for an epilog means the current instruction is in a valid epilog.</p><p>All of this is enough information for us to unwind a register context. Our main function will simply be called “unwind_context” and will take a context and optionally return a new context if a calling frame is found. We need to include memory (for reading the stack) and the process information where we keep track of modules.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span> <span>fn</span> <span>unwind_context</span>(process: <span>&amp;</span><span>mut</span> Process, context: <span>CONTEXT</span>, memory_source: <span>&amp;</span><span>dyn</span> MemorySource) -&gt; Result<span>&lt;</span>Option<span>&lt;</span><span>CONTEXT</span><span>&gt;</span>, <span>&amp;</span>&#39;static <span>str</span><span>&gt;</span> {
</span></span></code></pre></div><p>If we find a module for the instruction pointer, we’ll use that to find the “exception” directory where the function table lives.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>    <span>let</span> module <span>=</span> process.get_containing_module_mut(context.Rip);
</span></span><span><span>    <span>if</span> <span>let</span> Some(module) <span>=</span> module {
</span></span><span><span>        <span>let</span> data_directory <span>=</span> module.get_data_directory(<span>IMAGE_DIRECTORY_ENTRY_EXCEPTION</span>);
</span></span><span><span>        <span>if</span> data_directory.VirtualAddress <span>!=</span> <span>0</span> <span>&amp;&amp;</span> data_directory.Size <span>!=</span> <span>0</span> {
</span></span><span><span>            <span>let</span> count <span>=</span> data_directory.Size <span>as</span> <span>usize</span> <span>/</span> std::mem::size_of::<span>&lt;</span><span>RUNTIME_FUNCTION</span><span>&gt;</span>();
</span></span><span><span>            <span>let</span> table_address <span>=</span> module.address <span>+</span> data_directory.VirtualAddress <span>as</span> <span>u64</span>;
</span></span><span><span>            <span>// Note: In a real debugger you might want to cache these.
</span></span></span><span><span><span></span>            <span>let</span> functions: Vec<span>&lt;</span><span>RUNTIME_FUNCTION</span><span>&gt;</span> <span>=</span> read_memory_full_array(memory_source, table_address, count)<span>?</span>;
</span></span></code></pre></div><p>All of the <code>RUNTIME_FUNCTION</code> entries describe functions as relative virtual address, which are relative to the module base. So we’ll subtract the module base to get the rva of our instruction pointer. From there, we can do a search of the table, which can be done using a binary search bcause the functions entries are always in order. (The implementation of <a href="https://github.com/TimMisiak/dbgrs/blob/part6/src/stack.rs#L65">find_runtime_function is here</a>)</p><div><pre tabindex="0"><code data-lang="rust"><span><span>            <span>let</span> rva <span>=</span> context.Rip <span>-</span> module.address;
</span></span><span><span>            <span>let</span> func <span>=</span> find_runtime_function(rva <span>as</span> <span>u32</span>, <span>&amp;</span>functions);
</span></span></code></pre></div><p>If we find a match, we’ll read the unwind info and operations so we can apply them to the context. Once we’ve parsed out the information from the main UNWIND_INFO structure, we can use the UNWIND_INFO::count_of_codes field to determine how many 16-bit codes should be read. Remember that this isn’t the number of operations, as many operations take multiple “code slots”. Once we have the Vec of u16 codes, we’ll pass it to <code>get_unwind_ops</code> which will convert the codes into the Vec of logical operations.</p><p>Note that I’m using a macro here called <code>split_up!</code> which I made to simplify breaking up bitfields. The version_flags field, for instance, is equivalent to the bitfields for the version and flags fields of <code>UNWIND_INFO</code> and can be split using <code>split_up!(info.version_flags =&gt; 3, 5)</code>.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>            <span>if</span> <span>let</span> Some(func) <span>=</span> func {
</span></span><span><span>                <span>// We have unwind data!
</span></span></span><span><span><span></span>                <span>let</span> info_addr <span>=</span> module.address <span>+</span> func.UnwindInfo <span>as</span> <span>u64</span>;
</span></span><span><span>                <span>let</span> info <span>=</span> read_memory_data::<span>&lt;</span><span>UNWIND_INFO</span><span>&gt;</span>(memory_source, info_addr)<span>?</span>;
</span></span><span><span>                <span>let</span> (_version, flags) <span>=</span> split_up!(info.version_flags <span>=&gt;</span> <span>3</span>, <span>5</span>);
</span></span><span><span>                <span>let</span> (frame_register, frame_offset) <span>=</span> split_up!(info.frame_register_offset <span>=&gt;</span> <span>4</span>, <span>4</span>);
</span></span><span><span>                <span>let</span> frame_offset <span>=</span> (frame_offset <span>as</span> <span>u16</span>) <span>*</span> <span>16</span>;
</span></span><span><span>                <span>// The codes are UNWIND_CODE, but we&#39;ll have to break them up in different ways anyway based on the operation, so we might as well just
</span></span></span><span><span><span></span>                <span>// read them as u16 and then parse out the fields as needed.
</span></span></span><span><span><span></span>                <span>let</span> codes <span>=</span> read_memory_full_array::<span>&lt;</span><span>u16</span><span>&gt;</span>(memory_source, info_addr <span>+</span> <span>4</span>, info.count_of_codes <span>as</span> <span>usize</span>)<span>?</span>;
</span></span><span><span>                <span>let</span> unwind_ops <span>=</span> get_unwind_ops(<span>&amp;</span>codes, frame_register, frame_offset)<span>?</span>;
</span></span></code></pre></div><p>While there are 9 different <code>UWOP_*</code> constants, many of these are just different encodings for the same logical operations, so there are really only 6 operations we need to handle after we’ve parsed the unwind codes.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[derive(Debug)]</span>
</span></span><span><span><span>enum</span> <span>UnwindOp</span> {
</span></span><span><span>    PushNonVolatile { reg: <span>u8</span> },
</span></span><span><span>    Alloc { size: <span>u32</span> },
</span></span><span><span>    SetFpreg { frame_register: <span>u8</span>, frame_offset: <span>u16</span> },
</span></span><span><span>    SaveNonVolatile { reg: <span>u8</span>, offset: <span>u32</span> },
</span></span><span><span>    SaveXmm128 { reg: <span>u8</span>, offset: <span>u32</span> },
</span></span><span><span>    PushMachFrame { error_code: <span>bool</span> }
</span></span><span><span>}
</span></span></code></pre></div><p>Parsing the codes into an array of <code>UnwindOp</code>s is straightforward, but needs to account for the variable length encoding. Each operation starts with a 16 bit code slot that describes the offset (from the beginning of the function), an operation, and an “info” field that gets interpreted in different ways depending on the operation. (Full code for <a href="https://github.com/TimMisiak/dbgrs/blob/part6/src/stack.rs#L102">get_unwind_ops is here</a>)</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>get_unwind_ops</span>(code_slots: <span>&amp;</span>[<span>u16</span>], frame_register: <span>u8</span>, frame_offset: <span>u16</span>) -&gt; Result<span>&lt;</span>Vec<span>&lt;</span>UnwindCode<span>&gt;</span>, <span>&amp;</span>&#39;static <span>str</span><span>&gt;</span> {
</span></span><span><span>    <span>let</span> <span>mut</span> ops <span>=</span> Vec::<span>&lt;</span>UnwindCode<span>&gt;</span>::new();
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>mut</span> i <span>=</span> <span>0</span>;
</span></span><span><span>    <span>while</span> i <span>&lt;</span> code_slots.len() {
</span></span><span><span>        <span>let</span> (code_offset, unwind_op, op_info) <span>=</span> split_up!(code_slots[i] <span>=&gt;</span> <span>8</span>, <span>4</span>, <span>4</span>);
</span></span><span><span>        <span>let</span> code_offset <span>=</span> code_offset <span>as</span> <span>u8</span>;
</span></span><span><span>        <span>let</span> unwind_op <span>=</span> unwind_op <span>as</span> <span>u8</span>;
</span></span><span><span>        <span>let</span> op_info <span>=</span> op_info <span>as</span> <span>u8</span>;
</span></span></code></pre></div><p>Now we can have a big “match” to map the codes to the logical operations.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>        <span>match</span> unwind_op {
</span></span><span><span>            <span>UWOP_PUSH_NONVOL</span> <span>=&gt;</span> {
</span></span><span><span>                ops.push(UnwindCode { code_offset, op: <span>UnwindOp</span>::PushNonVolatile { reg: <span>op_info</span> } });
</span></span><span><span>            }
</span></span></code></pre></div><p>For operations that take multiple code slots, we’ll check that we have enough code slots left and increment the index to account for the slots consumed.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>            <span>UWOP_SAVE_NONVOL</span> <span>=&gt;</span> {
</span></span><span><span>                <span>if</span> i <span>+</span> <span>1</span> <span>&gt;=</span> code_slots.len() {
</span></span><span><span>                    <span>return</span> Err(<span>&#34;UWOP_SAVE_NONVOL was incomplete&#34;</span>);
</span></span><span><span>                }
</span></span><span><span>                <span>let</span> offset <span>=</span> code_slots[i <span>+</span> <span>1</span>] <span>as</span> <span>u32</span>;
</span></span><span><span>                ops.push(UnwindCode { code_offset, op: <span>UnwindOp</span>::SaveNonVolatile { reg: <span>op_info</span>, offset } });
</span></span><span><span>                i <span>+=</span> <span>1</span>;
</span></span><span><span>            }
</span></span></code></pre></div><p>Now that we have the list of logical unwind operations, we’ll find <a aria-describedby="footnote-label" href="#epilog-apply">the operations</a> that are applicable given the instruction pointer. Keep in mind that the unwind operations are described in terms of the “forward operation” of the prolog, and we need to execute the reverse of each of them. So for the “Push” operation, we’ll pop a register. For the “alloc” operation, we’ll deallocate space on the stack. Since the list of operations is already in reverse order we can iterate through the list and undo each operation. We <em>do</em> need to check the <code>code_offset</code> field to make sure that the operation has already been executed. If the current instruction is in the middle of the prolgue, we’ll skip any unwind operations that haven’t actually <a aria-describedby="footnote-label" href="#taken-effect">taken effect yet</a>.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>
</span></span><span><span><span>fn</span> <span>apply_unwind_ops</span>(context: <span>&amp;</span><span>CONTEXT</span>, unwind_ops: <span>&amp;</span>[UnwindCode], func_address: <span>u64</span>, memory_source: <span>&amp;</span><span>dyn</span> MemorySource) -&gt; Result<span>&lt;</span>Option<span>&lt;</span><span>CONTEXT</span><span>&gt;</span>, <span>&amp;</span>&#39;static <span>str</span><span>&gt;</span> {
</span></span><span><span>    <span>let</span> <span>mut</span> unwound_context <span>=</span> context.clone();
</span></span><span><span>    <span>for</span> unwind <span>in</span> unwind_ops.iter() {
</span></span><span><span>        <span>let</span> func_offset <span>=</span> unwound_context.Rip <span>-</span> func_address;
</span></span><span><span>        <span>if</span> unwind.code_offset <span>as</span> <span>u64</span> <span>&lt;=</span> func_offset {
</span></span><span><span>            <span>match</span> unwind.op {
</span></span></code></pre></div><p>The UWOP_ALLOC_SMALL and UWOP_ALLOC_LARGE are both easy to reverse. Allocating memory on the stack means subtracting from the stack pointer. So deallocating is just adding to the stack pointer.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>                UnwindOp::Alloc { size } <span>=&gt;</span> {
</span></span><span><span>                    unwound_context.Rsp <span>+=</span> size <span>as</span> <span>u64</span>;
</span></span><span><span>                }
</span></span></code></pre></div><p>Similarly, to reverse a push, we need to pop a value. That means that we read the 64-bit value at the current RSP, <a aria-describedby="footnote-label" href="#push-ordering">store it to the indicated register</a>, and then add 8 to the RSP. We’ll have a helper function called <a href="https://github.com/TimMisiak/dbgrs/blob/part6/src/stack.rs#L178"><code>get_op_register</code> that will map the numeric register value</a> to a u64 reference for the indicated register inside the unwound_context.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>                UnwindOp::PushNonVolatile { reg } <span>=&gt;</span> {
</span></span><span><span>                    <span>let</span> addr <span>=</span> unwound_context.Rsp;
</span></span><span><span>                    <span>let</span> val <span>=</span> read_memory_data::<span>&lt;</span><span>u64</span><span>&gt;</span>(memory_source, addr)<span>?</span>;
</span></span><span><span>                    <span>*</span>get_op_register(<span>&amp;</span><span>mut</span> unwound_context, reg) <span>=</span> val;
</span></span><span><span>                    unwound_context.Rsp <span>+=</span> <span>8</span>;
</span></span><span><span>                }
</span></span></code></pre></div><p>A “save nonvolatile” operation is basically the same as a push except we don’t need to worry about updating the stack pointer, so it’s a bit simpler. This operation can have an offset, so we need to take that into account.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>                UnwindOp::SaveNonVolatile { reg, offset } <span>=&gt;</span> {
</span></span><span><span>                    <span>let</span> addr <span>=</span> unwound_context.Rsp <span>+</span> offset <span>as</span> <span>u64</span>;
</span></span><span><span>                    <span>let</span> val <span>=</span> read_memory_data::<span>&lt;</span><span>u64</span><span>&gt;</span>(memory_source, addr)<span>?</span>;
</span></span><span><span>                    <span>*</span>get_op_register(<span>&amp;</span><span>mut</span> unwound_context, reg) <span>=</span> val;
</span></span><span><span>                }
</span></span></code></pre></div><p>Finally, the UWOP_SET_FPREG operation is a bit different. This operation means that the frame pointer is assigned the value of RSP plus an offset. The register being “saved” is actually RSP (typically because RSP will change by a variable amount, such as by using alloca). So to reverse this operation, we need to restore RSP by subtracting the frame_offset from the current value of the frame pointer. The frame pointer doesn’t have to be RBP, so we use get_op_register again.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>                UnwindOp::SetFpreg { frame_register, frame_offset } <span>=&gt;</span> {
</span></span><span><span>                    unwound_context.Rsp <span>=</span> <span>*</span>get_op_register(<span>&amp;</span><span>mut</span> unwound_context, frame_register) <span>-</span> (frame_offset <span>as</span> <span>u64</span>);
</span></span><span><span>                }
</span></span><span><span>                <span>// Not implemented: UWOP_SAVE_XMM and UWOP_PUSH_MACFRAME
</span></span></span><span><span><span></span>                _ <span>=&gt;</span> panic!(<span>&#34;NYI unwind op&#34;</span>)
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>    Ok(Some(unwound_context))
</span></span><span><span>}
</span></span></code></pre></div><p>Still with me? We’re almost done! We’ve rewound the prolog, but we still haven’t rewound the “CALL” instruction that kicked everything off, so that will be the last step. This part is also the <em>only</em> thing we need to do in the case of a leaf function, so back in the unwind_context function we’ll take care of both of those cases.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>    <span>let</span> <span>mut</span> ctx <span>=</span> ctx;
</span></span><span><span>    ctx.Rip <span>=</span> read_memory_data::<span>&lt;</span><span>u64</span><span>&gt;</span>(memory_source, ctx.Rsp)<span>?</span>;
</span></span><span><span>    ctx.Rsp <span>+=</span> <span>8</span>;
</span></span></code></pre></div><p>And that’s it! All we need now is a new debugger command that <a href="https://github.com/TimMisiak/dbgrs/blob/part6/src/main.rs#L228">repeatedly walks frames</a> using the unwind_context function and <a aria-describedby="footnote-label" href="#when-to-stop">we’re done</a>!</p><p>Finally, we have a “k” command. Does it work?</p><pre tabindex="0"><code>&gt; k
 #   RSP              Call Site
00 0x00000038E310FC48 hello.exe!func3+0x3
01 0x00000038E310FC50 hello.exe!func2+0x4A
02 0x00000038E310FD10 hello.exe!func1+0x9
03 0x00000038E310FD50 hello.exe!main+0x9
</code></pre><p>It does! It’s certainly not perfect, as there are a lot of missing cases still. But one really important case we’ve missed is how to unwind the stack when we’re in the epilog. But to do that correctly, we need to be able to unassemble x64 instructions. And really, what good is a debugger if it can’t show you assembly instructions? So I think you know what I’ll be doing in the next part of this series.</p><p>This series has been building towards this for a while, and I hope those of you that have been reading along found this interesting! Have a question or suggestion? Let me know! You can find me on <a href="https://twitter.com/timmisiak">Twitter</a>, <a href="https://dbg.social/@tim">Mastodon</a>, and <a href="https://bsky.app/profile/timdbg.com">Bluesky</a>.</p></div></article></div></div>
  </body>
</html>
