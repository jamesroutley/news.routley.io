<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://benhoyt.com/writings/awk-make/">Original</a>
    <h1>The Awk book’s 60-line version of Make</h1>
    
    <div id="readability-page-1" class="page"><div id="container">



<div id="content">

<p>September 2023</p>

<blockquote>
  <p><strong>Go to:</strong> <a href="#original-awk-version">AWK Make</a> | <a href="#how-it-works">How it works</a> | <a href="#python-version">Python Make</a> | <a href="#conclusion">Conclusion</a></p>
</blockquote>

<p>In the wonderful book <em>The AWK Programming Language</em> by Aho, Weinberger, and Kernighan, there are a few pages at the end of chapter 7 that present a simplified version of the Make utility – written in a single page of AWK code.</p>

<p>Before we look at that, I want to mention that the <a href="https://awk.dev/">second edition</a> of the AWK book is coming out next month. Brian Kernighan’s done a great job of updating it, most notably with a new chapter on <a href="https://en.wikipedia.org/wiki/Exploratory_data_analysis">exploratory data analysis</a>, and adding proper CSV support to AWK to enable this. I was honoured to be asked to review a draft of the second edition.</p>

<p>AWK still shines for exploring data in 2023, especially with the new <code>--csv</code> option. CSV mode has also been <a href="https://git.savannah.gnu.org/cgit/gawk.git/tree/NEWS">added to Gawk</a> (GNU AWK), the most widely-installed version of AWK. My own <a href="https://github.com/benhoyt/goawk">GoAWK</a> implementation has had <a href="https://benhoyt.com/writings/goawk-csv/">proper CSV support</a> for some time, and I’ve added the <code>--csv</code> option to match the others.</p>

<p>The second edition of the book still includes the Make program, though it’s been made more readable with the <a href="https://github.com/benhoyt/awkmake/commit/a5793b2b55168959f3f2e976d1e409401cd8aac4">addition</a> of some “spacing and bracing” – this took it from 50 lines to 62 lines.</p>

<p>This article presents the Make program, to show how AWK is not just great for one-liners, but <a href="https://maximullaris.com/awk.html">can be used</a> as a scripting language too – though whether you <em>should</em> or not is another question.</p>

<p>I’m then going to compare what the same program would look like in Python, and briefly discuss when you’d choose AWK or Python for this kind of thing.</p>

<p>It should go without saying, but I intend this purely as a learning exercise (for me and my readers), not a program I’d recommend you use to build your projects!</p>

<h2 id="original-awk-version">Original AWK version</h2>

<p>The second edition of the book introduces the Make program as follows. (For what it’s worth, I find the term “target” confusing here – I think “source” or “dependency” would fit better.)</p>

<blockquote>
  <p>This section develops a
rudimentary updating program, patterned after the Unix <code>make</code> command, that
is based on the depth-first search technique of the previous section.</p>

  <p>To use the updater, one must explicitly describe what the components of the
system are, how they depend upon one another, and what commands are needed
to construct them. We’ll assume these dependencies and commands are stored
in a file, called a <code>makefile</code>, that contains a sequence of rules of the form</p>

  <div><div><pre><code>name:   t1 t2 ... tn
        commands
</code></pre></div>  </div>

  <p>The first line of a rule is a dependency relation that states that the program or
file <em>name</em> depends on the targets <em>t1</em>, <em>t2</em>, …, <em>tn</em> where each <em>ti</em> is a filename or
another <em>name</em>. Following each dependency relation may be one or more lines of
<em>commands</em> that list the commands necessary to generate <em>name</em>. Here is an
example of a <code>makefile</code> for a small program with two C files called <code>a.c</code> and <code>b.c</code>, and a <code>yacc</code>
grammar file <code>c.y</code>, a typical program-development application.</p>

  <div><div><pre><code>prog:   a.o b.o c.o
        gcc a.o b.o c.o -ly -o prog
a.o:    prog.h a.c
        gcc -c prog.h a.c
b.o:    prog.h b.c
        gcc -c prog.h b.c
c.o:    c.c
        gcc -c c.c
c.c:    c.y
        yacc c.y
        mv y.tab.c c.c
print:
        pr prog.h a.c b.c c.y
</code></pre></div>  </div>

  <p>The first line states that <code>prog</code> depends on the target files <code>a.o</code>, <code>b.o</code>, and <code>c.o</code>.
The second line says that <code>prog</code> is generated by using the C compiler command
<code>gcc</code> to link <code>a.o</code>, <code>b.o</code>, <code>c.o</code>, and a <code>yacc</code> library <code>y</code> into the file <code>prog</code>. The next rule
(third line) states that <code>a.o</code> depends on the targets <code>prog.h</code> and <code>a.c</code> and is
created by compiling these targets; <code>b.o</code> is the same. The file <code>c.o</code> depends on
<code>c.c</code>, which in turn depends on <code>c.y</code>, which has to be processed by the <code>yacc</code>
parser generator. Finally, the name <code>print</code> does not depend on any target; by
convention, for targetless names <code>make</code> will always perform the associated action,
in this case printing all the source files with the command <code>pr</code>.</p>

  <p>The dependency relations in the <code>makefile</code> can be represented by a graph
in which there is an edge from node <em>x</em> to node <em>y</em> whenever there is a dependency
rule with <em>x</em> on the left side and <em>y</em> one of the targets on the right. For a rule
with no targets, a successorless node with the name on the left is created. For
the <code>makefile</code> above, we have the following dependency graph:</p>

  <div><div><pre><code>                  prog                 print
                /   |   \
               /    |    \
            a.o    b.o    c.o
           /   \  /   \      \
          /     \/     \      \
        a.c   prog.h   b.c     c.c
                                |
                               c.y
</code></pre></div>  </div>
</blockquote>

<p>It’s a highly-simplified version of Make, of course, but still has the core concepts of outputs, dependencies, and build commands.</p>

<p>Before we look at how it works, I’ve included the full source code below, as it appears in the second edition of the AWK book. Click on the bold text to expand it, or skip down to “How it works” to see the code explained in detail.</p>

<details>
  <summary><strong>The AWK book’s Make program (full source code).</strong></summary>

  <div><div><pre><code><span>BEGIN</span> <span>{</span>
    <span>while</span> <span>(</span><span>getline</span> <span>&lt;</span><span>&#34;makefile&#34;</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>$0</span> <span>~</span> <span>/^</span><span>[</span><span>A-Za-z</span><span>]</span><span>/</span><span>)</span> <span>{</span>  <span>#  $1: $2 $3 ...</span>
            <span>sub</span><span>(</span><span>/:/</span><span>,</span> <span>&#34;&#34;</span><span>)</span>
            <span>if</span> <span>(</span><span>++</span><span>names</span><span>[</span><span>nm</span> <span>=</span> <span>$1</span><span>]</span> <span>&gt;</span> <span>1</span><span>)</span>
                <span>error</span><span>(</span><span>nm</span> <span>&#34; is multiply defined&#34;</span><span>)</span>
            <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>2</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>NF</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span># remember targets</span>
                <span>slist</span><span>[</span><span>nm</span><span>,</span> <span>++</span><span>scnt</span><span>[</span><span>nm</span><span>]]</span> <span>=</span> <span>$i</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>$0</span> <span>~</span> <span>/^</span><span>\t</span><span>/</span><span>)</span> <span>{</span>      <span># remember cmd for</span>
            <span>cmd</span><span>[</span><span>nm</span><span>]</span> <span>=</span> <span>cmd</span><span>[</span><span>nm</span><span>]</span> <span>$0</span> <span>&#34;\n&#34;</span> <span>#   current name</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>NF</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>error</span><span>(</span><span>&#34;illegal line in makefile: &#34;</span> <span>$0</span><span>)</span>
        <span>}</span>
    <span>}</span>

    <span>ages</span><span>()</span>      <span># compute initial ages</span>

    <span>if</span> <span>(</span><span>ARGV</span><span>[</span><span>1</span><span>]</span> <span>in</span> <span>names</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>update</span><span>(</span><span>ARGV</span><span>[</span><span>1</span><span>])</span> <span>==</span> <span>0</span><span>)</span>
            <span>print</span> <span>ARGV</span><span>[</span><span>1</span><span>]</span> <span>&#34; is up to date&#34;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>error</span><span>(</span><span>ARGV</span><span>[</span><span>1</span><span>]</span> <span>&#34; is not in makefile&#34;</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>function</span> <span>ages</span><span>(</span>      <span>f</span><span>,</span><span>n</span><span>,</span><span>t</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>t</span> <span>=</span> <span>1</span><span>;</span> <span>(</span><span>&#34;ls -t&#34;</span> <span>|</span> <span>getline</span> <span>f</span><span>)</span> <span>&gt;</span> <span>0</span><span>;</span> <span>t</span><span>++</span><span>)</span>
        <span>age</span><span>[</span><span>f</span><span>]</span> <span>=</span> <span>t</span>         <span># all existing files get an age</span>
    <span>close</span><span>(</span><span>&#34;ls -t&#34;</span><span>)</span>

    <span>for</span> <span>(</span><span>n</span> <span>in</span> <span>names</span><span>)</span>
        <span>if</span> <span>(</span><span>!</span><span>(</span><span>n</span> <span>in</span> <span>age</span><span>))</span>   <span># if n has not been created</span>
            <span>age</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>9999</span>  <span># make n really old</span>
<span>}</span>

<span>function</span> <span>update</span><span>(</span><span>n</span><span>,</span>   <span>changed</span><span>,</span><span>i</span><span>,</span><span>s</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span><span>n</span> <span>in</span> <span>age</span><span>))</span>
        <span>error</span><span>(</span><span>n</span> <span>&#34; does not exist&#34;</span><span>)</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span><span>n</span> <span>in</span> <span>names</span><span>))</span>
        <span>return</span> <span>0</span>
    <span>changed</span> <span>=</span> <span>0</span>
    <span>visited</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>1</span>
    <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>scnt</span><span>[</span><span>n</span><span>];</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>visited</span><span>[</span><span>s</span> <span>=</span> <span>slist</span><span>[</span><span>n</span><span>,</span> <span>i</span><span>]]</span> <span>==</span> <span>0</span><span>)</span>
            <span>update</span><span>(</span><span>s</span><span>)</span>
        <span>else</span> <span>if</span> <span>(</span><span>visited</span><span>[</span><span>s</span><span>]</span> <span>==</span> <span>1</span><span>)</span>
            <span>error</span><span>(</span><span>s</span> <span>&#34; and &#34;</span> <span>n</span> <span>&#34; are circularly defined&#34;</span><span>)</span>
        <span>if</span> <span>(</span><span>age</span><span>[</span><span>s</span><span>]</span> <span>&lt;=</span> <span>age</span><span>[</span><span>n</span><span>])</span>
            <span>changed</span><span>++</span>
    <span>}</span>
    <span>visited</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>2</span>
    <span>if</span> <span>(</span><span>changed</span> <span>||</span> <span>scnt</span><span>[</span><span>n</span><span>]</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>printf</span><span>(</span><span>&#34;%s&#34;</span><span>,</span> <span>cmd</span><span>[</span><span>n</span><span>])</span>
        <span>system</span><span>(</span><span>cmd</span><span>[</span><span>n</span><span>])</span>  <span># execute cmd associated with n</span>
        <span>ages</span><span>()</span>          <span># recompute all ages</span>
        <span>age</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>0</span>      <span># make n very new</span>
        <span>return</span> <span>1</span>
    <span>}</span>
    <span>return</span> <span>0</span>
<span>}</span>

<span>function</span> <span>error</span><span>(</span><span>s</span><span>)</span> <span>{</span> <span>print</span> <span>&#34;error: &#34;</span> <span>s</span><span>;</span> <span>exit</span> <span>}</span>
</code></pre></div>  </div>
</details>

<h2 id="how-it-works">How it works</h2>

<p>There’s an explanation of how the program works in the book, but I’ll explain it in my own words here, focussing on the aspects I find interesting.</p>

<p>The <code>BEGIN</code> block is the main entry point for a program like this. Unlike most AWK programs which implicitly read lines from standard input, this one uses an explicit loop with <code>getline</code> to read the <code>makefile</code>:</p>

<div><div><pre><code><span>BEGIN</span> <span>{</span>
    <span>while</span> <span>(</span><span>getline</span> <span>&lt;</span><span>&#34;makefile&#34;</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>$0</span> <span>~</span> <span>/^</span><span>[</span><span>A-Za-z</span><span>]</span><span>/</span><span>)</span> <span>{</span>  <span>#  $1: $2 $3 ...</span>
            <span>sub</span><span>(</span><span>/:/</span><span>,</span> <span>&#34;&#34;</span><span>)</span>
            <span>if</span> <span>(</span><span>++</span><span>names</span><span>[</span><span>nm</span> <span>=</span> <span>$1</span><span>]</span> <span>&gt;</span> <span>1</span><span>)</span>
                <span>error</span><span>(</span><span>nm</span> <span>&#34; is multiply defined&#34;</span><span>)</span>
            <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>2</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>NF</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span># remember targets</span>
                <span>slist</span><span>[</span><span>nm</span><span>,</span> <span>++</span><span>scnt</span><span>[</span><span>nm</span><span>]]</span> <span>=</span> <span>$i</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>$0</span> <span>~</span> <span>/^</span><span>\t</span><span>/</span><span>)</span> <span>{</span>      <span># remember cmd for</span>
            <span>cmd</span><span>[</span><span>nm</span><span>]</span> <span>=</span> <span>cmd</span><span>[</span><span>nm</span><span>]</span> <span>$0</span> <span>&#34;\n&#34;</span> <span>#   current name</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>NF</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>error</span><span>(</span><span>&#34;illegal line in makefile: &#34;</span> <span>$0</span><span>)</span>
        <span>}</span>
    <span>}</span>
    <span>...</span>
<span>}</span>
</code></pre></div></div>

<p>The <code>getline &lt;filename</code> is a redirect clause that opens <code>makefile</code> (the first time) and reads it line-by-line until the end. If the line (<code>$0</code>) starts with a letter (<code>/^[A-Za-z]/</code>), it’s considered a <code>name: targets</code> rule.</p>

<p>The <code>sub(/:/, &#34;&#34;)</code> call removes the colon from the current line (the <code>$0</code> is implicit in the two-argument form of <code>sub</code>).</p>

<p>We then ensure that this rule hasn’t already been defined by checking the <code>names</code> array. An AWK array is actually an <em>associative array</em>, an old-school term for a key-value map.</p>

<p>The inner <code>for</code> loop adds each target (or dependency) to the <code>slist</code> / <code>scnt</code> data structure. This is really a map of lists, but it’s flattened to work around the fact that AWK doesn’t support nested collections. The body of the loop is very terse:</p>

<div><div><pre><code><span>for</span> <span>(</span><span>i</span> <span>=</span> <span>2</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>NF</span><span>;</span> <span>i</span><span>++</span><span>)</span>
    <span>slist</span><span>[</span><span>nm</span><span>,</span> <span>++</span><span>scnt</span><span>[</span><span>nm</span><span>]]</span> <span>=</span> <span>$i</span>
</code></pre></div></div>

<p>This loops through each dependency: every field <code>$i</code> from field 2 to <code>NF</code> (the number of fields in the line).</p>

<p>For each dependency, it increments <code>scnt[nm]</code>, the count of sources for the current rule (<code>nm</code>). Then, store the dependency <code>$i</code> in <code>slist</code>, indexed by the multi-key name and count. AWK simulates multi-dimensional or multi-key arrays by creating a concatenated key where each key is separated by the <code>SUBSEP</code> separator (which defaults to <code>&#34;\x1c&#34;</code>).</p>

<p>After the loop, in the <code>prog</code> example we’d end up with <code>slist</code> and <code>scnt</code> looking like this:</p>

<div><div><pre><code>slist
    a.o,1:  prog.h
    a.o,2:  a.c
    b.o,1:  prog.h
    b.o,2:  b.c
    c.c,1:  c.y
    c.o,1:  c.c
    prog,1: a.o
    prog,2: b.o
    prog,3: c.o

scnt
    a.o:  2
    b.o:  2
    c.c:  1
    c.o:  1
    prog: 3
</code></pre></div></div>

<p>Coming back up, if the line starts with a tab, it’s a command, so we append it to the name’s command string:</p>

<div><div><pre><code><span>cmd</span><span>[</span><span>nm</span><span>]</span> <span>=</span> <span>cmd</span><span>[</span><span>nm</span><span>]</span> <span>$0</span> <span>&#34;\n&#34;</span>
</code></pre></div></div>

<p>Otherwise, if the line is not a blank line (<code>NF &gt; 0</code>), it’s a <code>makefile</code> error.</p>

<p>Finally, after reading the <code>makefile</code> in the <code>while</code> loop, we uses <code>ages()</code> to compute the ages of all files in the current directory, and then call <code>update(ARGV[1])</code> to update the rule passed on the command line:</p>

<div><div><pre><code><span>BEGIN</span> <span>{</span>
    <span>...</span>
    <span>ages</span><span>()</span>      <span># compute initial ages</span>

    <span>if</span> <span>(</span><span>ARGV</span><span>[</span><span>1</span><span>]</span> <span>in</span> <span>names</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>update</span><span>(</span><span>ARGV</span><span>[</span><span>1</span><span>])</span> <span>==</span> <span>0</span><span>)</span>
            <span>print</span> <span>ARGV</span><span>[</span><span>1</span><span>]</span> <span>&#34; is up to date&#34;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>error</span><span>(</span><span>ARGV</span><span>[</span><span>1</span><span>]</span> <span>&#34; is not in makefile&#34;</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The <code>ages</code> function is where things start to get interesting:</p>

<div><div><pre><code><span>function</span> <span>ages</span><span>(</span>      <span>f</span><span>,</span><span>n</span><span>,</span><span>t</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>t</span> <span>=</span> <span>1</span><span>;</span> <span>(</span><span>&#34;ls -t&#34;</span> <span>|</span> <span>getline</span> <span>f</span><span>)</span> <span>&gt;</span> <span>0</span><span>;</span> <span>t</span><span>++</span><span>)</span>
        <span>age</span><span>[</span><span>f</span><span>]</span> <span>=</span> <span>t</span>         <span># all existing files get an age</span>
    <span>close</span><span>(</span><span>&#34;ls -t&#34;</span><span>)</span>

    <span>for</span> <span>(</span><span>n</span> <span>in</span> <span>names</span><span>)</span>
        <span>if</span> <span>(</span><span>!</span><span>(</span><span>n</span> <span>in</span> <span>age</span><span>))</span>   <span># if n has not been created</span>
            <span>age</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>9999</span>  <span># make n really old</span>
<span>}</span>
</code></pre></div></div>

<p>The parameter names <code>f</code>, <code>n</code>, and <code>t</code> are prefixed with a bunch of spaces to show they’re actually local variables, and not expected as arguments. This is an AWK quirk (which Kernighan regrets): the only way to define local variables is as function parameters, and if a function is called with fewer arguments than it has parameters, the extras take on the default value (0 for numbers, <code>&#34;&#34;</code> for strings). So you’ll see these extra spaces a lot in AWK function definitions.</p>

<p>The next thing is quite neat: AWK supports shell-like <code>|</code> syntax to pipe the output of a program, one <code>getline</code> at a time, to a variable (in this case <code>f</code>). The <code>ls -t</code> command lists files in the current directory ordered by modification time, newest first.</p>

<p>After the loop that’s assigned each file’s age to <code>age[f]</code>, we call <code>close</code> to close the <code>ls -t</code> pipe and avoid too many open file handles.</p>

<p>Finally, we loop through the rule names and assign an arbitrary large number to <code>age[n]</code> to pretend that files that haven’t been created are really old and need to be updated.</p>

<p>Next is the recursive <code>update</code> function, where the meat of the algorithm lives:</p>

<div><div><pre><code><span>function</span> <span>update</span><span>(</span><span>n</span><span>,</span>   <span>changed</span><span>,</span><span>i</span><span>,</span><span>s</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span><span>n</span> <span>in</span> <span>age</span><span>))</span>
        <span>error</span><span>(</span><span>n</span> <span>&#34; does not exist&#34;</span><span>)</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span><span>n</span> <span>in</span> <span>names</span><span>))</span>
        <span>return</span> <span>0</span>
    <span>changed</span> <span>=</span> <span>0</span>
    <span>visited</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>1</span>
    <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>scnt</span><span>[</span><span>n</span><span>];</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>visited</span><span>[</span><span>s</span> <span>=</span> <span>slist</span><span>[</span><span>n</span><span>,</span> <span>i</span><span>]]</span> <span>==</span> <span>0</span><span>)</span>
            <span>update</span><span>(</span><span>s</span><span>)</span>
        <span>else</span> <span>if</span> <span>(</span><span>visited</span><span>[</span><span>s</span><span>]</span> <span>==</span> <span>1</span><span>)</span>
            <span>error</span><span>(</span><span>s</span> <span>&#34; and &#34;</span> <span>n</span> <span>&#34; are circularly defined&#34;</span><span>)</span>
        <span>if</span> <span>(</span><span>age</span><span>[</span><span>s</span><span>]</span> <span>&lt;=</span> <span>age</span><span>[</span><span>n</span><span>])</span>
            <span>changed</span><span>++</span>
    <span>}</span>
    <span>visited</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>2</span>
    <span>if</span> <span>(</span><span>changed</span> <span>||</span> <span>scnt</span><span>[</span><span>n</span><span>]</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>printf</span><span>(</span><span>&#34;%s&#34;</span><span>,</span> <span>cmd</span><span>[</span><span>n</span><span>])</span>
        <span>system</span><span>(</span><span>cmd</span><span>[</span><span>n</span><span>])</span>  <span># execute cmd associated with n</span>
        <span>ages</span><span>()</span>          <span># recompute all ages</span>
        <span>age</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>0</span>      <span># make n very new</span>
        <span>return</span> <span>1</span>
    <span>}</span>
    <span>return</span> <span>0</span>
<span>}</span>
</code></pre></div></div>

<p>Once again you’ll note the parameter list: <code>n</code> is an expected argument (the name to update), and <code>changed,i,s</code> are the locals.</p>

<p>After initial checks, we loop through the list of dependencies by iterating from <code>slist[n, 1]</code> to <code>slist[n, scnt[n]]</code>. If we haven’t visited this dependency yet, we perform a depth-first traversal of the dependency graph by recursively calling <code>update</code> to see if we need to update that dependency first:</p>

<div><div><pre><code><span>if</span> <span>(</span><span>visited</span><span>[</span><span>s</span> <span>=</span> <span>slist</span><span>[</span><span>n</span><span>,</span> <span>i</span><span>]]</span> <span>==</span> <span>0</span><span>)</span>
    <span>update</span><span>(</span><span>s</span><span>)</span>
</code></pre></div></div>

<p>The recursion is terminated by the <code>if (!(n in names)) return 0</code> block near the top. We stop when the file being updated isn’t in the list of rule names – which is a leaf node in the dependency graph.</p>

<p>The block <code>if (age[s] &lt;= age[n]) changed++</code> increments the <code>changed</code> count if any dependency is newer than the age of the current file being updated.</p>

<p>After the traversal loop, if any of the dependencies or sub-dependencies had changed, we run the associated command using <code>system()</code>, recompute the ages of all files, and <code>return 1</code> to the caller to indicate we did make an update.</p>

<p>The <code>scnt[n] == 0</code> clause handles the case where the rule being updated doesn’t have any dependencies specified, like the <code>print</code> rule in the example. In that case, always re-run its command.</p>

<p>And there you have it! A minimalist Make in one page of AWK.</p>

<h2 id="python-version">Python version</h2>

<p>For interest, I ported the book’s AWK Make to Python, and have included it below. Once again, click the bold text to expand the program.</p>

<details>
  <summary><strong>My Python port of the Make program (full source code).</strong></summary>

  <div><div><pre><code><span>import</span> <span>os</span><span>,</span> <span>re</span><span>,</span> <span>sys</span>

<span>slist</span> <span>=</span> <span>{}</span>  <span># slist[name] is list of rule&#39;s sources
</span><span>cmd</span> <span>=</span> <span>{}</span>    <span># cmd[name] is shell command to run for rule
</span>
<span>def</span> <span>main</span><span>():</span>
    <span>for</span> <span>line</span> <span>in</span> <span>open</span><span>(</span><span>&#39;makefile&#39;</span><span>):</span>
        <span>if</span> <span>re</span><span>.</span><span>match</span><span>(</span><span>&#39;[A-Za-z]&#39;</span><span>,</span> <span>line</span><span>):</span>
            <span>line</span> <span>=</span> <span>line</span><span>.</span><span>replace</span><span>(</span><span>&#39;:&#39;</span><span>,</span> <span>&#39;&#39;</span><span>)</span>
            <span>fields</span> <span>=</span> <span>line</span><span>.</span><span>split</span><span>()</span>
            <span>nm</span> <span>=</span> <span>fields</span><span>[</span><span>0</span><span>]</span>
            <span>if</span> <span>nm</span> <span>in</span> <span>slist</span><span>:</span>
                <span>error</span><span>(</span><span>f</span><span>&#39;</span><span>{</span><span>nm</span><span>}</span><span> is multiply defined&#39;</span><span>)</span>
            <span>slist</span><span>[</span><span>nm</span><span>]</span> <span>=</span> <span>fields</span><span>[</span><span>1</span><span>:]</span>    <span># remember targets
</span>        <span>elif</span> <span>line</span><span>.</span><span>startswith</span><span>(</span><span>&#39;</span><span>\t</span><span>&#39;</span><span>):</span>   <span># remember cmd for current name
</span>            <span>cmd</span><span>[</span><span>nm</span><span>]</span> <span>=</span> <span>cmd</span><span>.</span><span>get</span><span>(</span><span>nm</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>+</span> <span>line</span>
        <span>elif</span> <span>line</span><span>.</span><span>strip</span><span>():</span>
            <span>error</span><span>(</span><span>f</span><span>&#39;illegal line in makefile: </span><span>{</span><span>line</span><span>}</span><span>&#39;</span><span>)</span>
    <span>if</span> <span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>]</span> <span>in</span> <span>slist</span><span>:</span>
        <span>if</span> <span>not</span> <span>update</span><span>(</span><span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>]):</span>
            <span>print</span><span>(</span><span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>],</span> <span>&#39;is up to date&#39;</span><span>)</span>
    <span>else</span><span>:</span>
        <span>error</span><span>(</span><span>f</span><span>&#39;</span><span>{</span><span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>]</span><span>}</span><span> is not in makefile&#39;</span><span>)</span>

<span>def</span> <span>mtime</span><span>(</span><span>n</span><span>):</span>
    <span>try</span><span>:</span>
        <span>return</span> <span>os</span><span>.</span><span>stat</span><span>(</span><span>n</span><span>).</span><span>st_mtime</span>
    <span>except</span> <span>FileNotFoundError</span><span>:</span>
        <span>return</span> <span>0</span>  <span># mark as old if it doesn&#39;t exist
</span>
<span>def</span> <span>update</span><span>(</span><span>n</span><span>,</span> <span>visited</span><span>=</span><span>{}):</span>
    <span>ntime</span> <span>=</span> <span>mtime</span><span>(</span><span>n</span><span>)</span>
    <span>if</span> <span>n</span> <span>not</span> <span>in</span> <span>slist</span> <span>and</span> <span>ntime</span> <span>==</span> <span>0</span><span>:</span>
        <span>error</span><span>(</span><span>f</span><span>&#39;</span><span>{</span><span>n</span><span>}</span><span> does not exist&#39;</span><span>)</span>
    <span>if</span> <span>n</span> <span>not</span> <span>in</span> <span>slist</span><span>:</span>
        <span>return</span> <span>0</span>
    <span>changed</span> <span>=</span> <span>False</span>
    <span>visited</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>1</span>
    <span>for</span> <span>s</span> <span>in</span> <span>slist</span><span>.</span><span>get</span><span>(</span><span>n</span><span>,</span> <span>[]):</span>
        <span>if</span> <span>s</span> <span>not</span> <span>in</span> <span>visited</span><span>:</span>
            <span>update</span><span>(</span><span>s</span><span>)</span>
        <span>elif</span> <span>visited</span><span>[</span><span>s</span><span>]</span> <span>==</span> <span>1</span><span>:</span>
            <span>error</span><span>(</span><span>f</span><span>&#39;</span><span>{</span><span>s</span><span>}</span><span> and </span><span>{</span><span>n</span><span>}</span><span> are circularly defined&#39;</span><span>)</span>
        <span>if</span> <span>mtime</span><span>(</span><span>s</span><span>)</span> <span>&gt;</span> <span>ntime</span><span>:</span>
            <span>changed</span> <span>=</span> <span>True</span>
    <span>visited</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>2</span>
    <span>if</span> <span>changed</span> <span>or</span> <span>len</span><span>(</span><span>slist</span><span>.</span><span>get</span><span>(</span><span>n</span><span>,</span> <span>[]))</span> <span>==</span> <span>0</span><span>:</span>
        <span>print</span><span>(</span><span>cmd</span><span>[</span><span>n</span><span>],</span> <span>end</span><span>=</span><span>&#39;&#39;</span><span>)</span>
        <span>os</span><span>.</span><span>system</span><span>(</span><span>cmd</span><span>[</span><span>n</span><span>])</span>  <span># execute cmd associated with n
</span>        <span>return</span> <span>1</span>
    <span>return</span> <span>0</span>

<span>def</span> <span>error</span><span>(</span><span>msg</span><span>):</span>
    <span>print</span><span>(</span><span>&#39;error:&#39;</span><span>,</span> <span>msg</span><span>,</span> <span>file</span><span>=</span><span>sys</span><span>.</span><span>stderr</span><span>)</span>
    <span>sys</span><span>.</span><span>exit</span><span>(</span><span>1</span><span>)</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>main</span><span>()</span>
</code></pre></div>  </div>
</details>

<p>It’s very similar in structure to the original AWK version, though I made two simplifications which I think make it somewhat easier to understand:</p>

<ol>
  <li>Simpler data structures to avoid the <code>slist</code> / <code>scnt</code> quirkiness – in Python we can just use a dictionary of lists. (<a href="https://github.com/benhoyt/awkmake/commit/490e5d210bdd4a7ce61292c73f1ec3f06da090eb">See diff.</a>)</li>
  <li>Determine ages more directly using <code>os.stat()</code> to fetch file modification times (mtimes), rather than using the <code>ls -t</code> trick. This also removes the need for the <code>age</code> map and the <code>ages</code> function. (<a href="https://github.com/benhoyt/awkmake/commit/7bb6a6de06a329551678fb90073a268342baf049">See diff.</a>)</li>
</ol>

<p>I didn’t plan for this, but even if you include the <code>import</code> line and the <code>if __name__ == &#39;__main__&#39;</code> dance, it’s 58 lines of code – basically the same length as the AWK program.</p>

<p>When making the Python version, I realized we could simplify the AWK version in a similar way:</p>

<ol>
  <li>It’s conceptually simpler to store the <code>slist</code> directly as an AWK array: a key-value map where the key is the rule name and the value is the list of dependencies as a space-separated string (just like in the <code>makefile</code>). We can use <code>split</code> as needed to turn the dependencies string into a list (an array from 1 to the number of dependencies). This avoids the need for <code>scnt</code> and <code>names</code> altogether. (<a href="https://github.com/benhoyt/awkmake/pull/2/commits/45b5c4de5ec4c5b09830fdf06b00f4e0c7f7886e">See diff.</a>)</li>
  <li>Similar to the Python version, we can get the mtime directly by shelling out to <code>stat</code>, instead of listing all files in age order with <code>ls -t</code>. I’ve used <code>stat --format %y</code> to do this. I believe this is a GNU extension, so it’s not as portable as <code>ls -t</code>, but it’s simpler and avoids the need for recomputing the <code>age</code> array. (<a href="https://github.com/benhoyt/awkmake/pull/2/commits/d5cd8cc3cdeebce953dc2b15c9fedca3eef5ceca">See diff.</a>)</li>
</ol>

<p>For what it’s worth, the modified version is four lines shorter than the original. I think the simpler <code>slist</code> is clearer, and I like the more direct approach to fetching mtimes, though I realize the lack of portability of <code>stat --format</code> is a downside (macOS’s <code>stat</code> looks <a href="https://ss64.com/osx/stat.html">quite different</a>).</p>

<h2 id="conclusion">Conclusion</h2>

<p>The AWK Make program is a neat little piece of code that shows how useful a language AWK is, even for medium-sized scripts.</p>

<p>However, Python is definitely a nicer language for this kind of thing: it has much richer data types, better tools like <code>os.stat</code>, and local variables without quirky syntax.</p>

<p>I consider AWK amazing, but I think it should remain where it excels: for exploratory data analysis and for one-liner data extraction scripts.</p>

<p>As the author of GoAWK, which has had native CSV support for a while, I’m especially pleased to see both Kernighan’s “one true AWK” and Gawk gain proper CSV support in the form of the <code>--csv</code> option. Kernighan’s <a href="https://github.com/onetrueawk/awk/commit/c76017e59eb71b5403d44fb974a83bf71462eb39#diff-b335630551682c19a781afebcf4d07bf978fb1f8ac04c6bf87428ed5106870f5">AWK updates</a> will be merged soon, and Gawk will <a href="http://git.savannah.gnu.org/cgit/gawk.git/tree/NEWS">include this feature in version 5.3.0</a>, which is coming out soon.</p>

<p>You can also view my <a href="https://github.com/benhoyt/awkmake">awkmake</a> repo on GitHub, which contains the full source for both the AWK book’s Make program and my Python version, as well as a runnable example project based on the example in the AWK book.</p>

<p>I’d love it if you <a href="https://github.com/sponsors/benhoyt/">sponsored me on GitHub</a> – it will motivate me to work on my open source projects and write more good content. Thanks!</p>


</div>

</div></div>
  </body>
</html>
