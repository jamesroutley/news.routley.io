<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lamport.azurewebsites.net/tla/high-level-view.html">Original</a>
    <h1>A High-Level View of TLA&#43;</h1>
    
    <div id="readability-page-1" class="page"><div>
<td id="main_leftcolumn">

</td>
<td id="main_contentcolumn">

<table>
<tbody><tr>
<td>
 



<p>
Leslie Lamport</p><p>
<SPAN size="-1"><i> Last modified on 10 August 2021</i></SPAN>
</p></td>
<td>
</td>
</tr>

</tbody></table>
<hr/> 



<p><b>
   You&#39;ll miss a lot on this web site unless you enable Javascript
   in your browser. </b></p>

<h2 id="h2intro" onclick="showHide(&#39;hide-intro&#39;,&#39;intro&#39;)">Introduction 
          
     <SPAN id="hide-intro">
      [show]</SPAN>
</h2>

<div id="intro">  <!-- style="display:none"--><p>

TLA+ is a language for modeling software above the code level and
hardware above the circuit level.  It has an IDE (Integrated
Development Environment) for writing models and running tools to check
them.  The tool most commonly used by engineers is the TLC model
checker, but there is also a proof checker.  TLA+ is based on
mathematics and does not resemble any programming language. 
Most engineers will find PlusCal, described below, to be the easiest way to
start using TLA+.

</p><p>

TLA+ models are usually called <em>specifications</em>.   They are called
<SPAN id="model-popup" color="blue" onclick="popup(&#39;model-popup.html&#39;,175)">
  <b>models</b></SPAN>
in this introduction.
</p></div>

<h2 id="h2pluscal" onclick="showHide(&#39;hide-pluscal&#39;,&#39;pluscal&#39;)"><a name="pluscal">PlusCal</a>
          
     <SPAN id="hide-pluscal">        [show]</SPAN>   
</h2>

<div id="pluscal"> <!-- style="display:block"-->   
<!-- style="display:none"--><p>

PlusCal is a language for writing algorithms—especially
concurrent and distributed ones.  It is meant to replace
pseudocode with precise, testable code.  PlusCal looks like a
simple toy programming language, but with constructs for describing
concurrency and nondeterminacy.  It is infinitely more expressive
than any programming language because any mathematical formula can be
used as a PlusCal expression.  
A PlusCal algorithm is translated into a
TLA+ model that can be checked with the TLA+ tools. 
Because it looks like a programming language, most engineers find PlusCal
easier to learn than TLA+.  But because it looks like a
programming language, PlusCal cannot structure complex models as well as
TLA+ can.

</p><p>

<a href="https://lamport.azurewebsites.net/tla/peterson.html?back-link=high-level-view.html#pluscal?unhideBut@EQhide-pluscal@AMPunhideDiv@EQpluscal">Click here</a> for an example of 
an algorithm written in PlusCal.



</p></div>


<h2 id="h2models" onclick="showHide(&#39;hide-models&#39;,&#39;models&#39;)">Models
          
     <SPAN id="hide-models">
      [show]</SPAN>
</h2>

<div id="models"> <!-- style="display:none"--><p>  

Computers and computer networks are physical objects whose behaviors
are described by continuous physical laws.   They differ from most
other kinds of physical objects in that their behaviors are naturally 
modeled as sets of discrete events.   Programming, software
engineering, and most of computer science is concerned with models in
which a behavior of a system is described as a set of discrete events.
No model is a completely accurate description of a real system. 
A model is a description of some aspect of the system, written for
some purpose.   

</p><!--
   We all use one or more ways of modeling the behavior of a computer
   systems as a set of discrete events.  Often, people think their
   model is the actual system, not just a model of it.  When
   presented with a different model, they may think it's wrong or perhaps
   just incomplete because it doesn't describe things that are in their
   model.  No model is a completely accurate description of a real
   system.  A model should be judged not by how accurate it is, but
   by how useful it is; and that depends on what you're using it for.
-->


<p> 


TLA+ is state-based, meaning that it models an execution of a system
as a sequence of states, where an event is represented by a pair of
consecutive states.  We call a sequence of states a
<em>behavior</em>; and we call a pair of consecutive states a
<em>step</em> rather than an event. 
A system is modeled as the set of behaviors describing all of its
possible executions.
</p></div>

<h2 id="h2above" onclick="showHide(&#39;hide-above-code&#39;,&#39;above-code&#39;)">
    Modeling Above the Code Level
          
     <SPAN id="hide-above-code">
      [show]</SPAN>
</h2>

<div id="above-code"> <!-- style="display:bloxk"--><p>


TLA+ is used to model systems above the code level. 

To see what this, means consider Euclid&#39;s algorithm for computing
</p><nobr> <code>GCD(M,N)</code> ,</nobr><p> the greatest
common divisor of two positive integers  <code>M</code> 
and  <code>N</code> .  Here is the algorithm:

</p><ul>
<li> 
   Let  <code>x</code>  equal
    <code>M</code>  and  <code>y</code> 
   equal  <code>N</code> .
</li>

<li> 
   Repeated subtract the smaller of  <code>x</code>  and
    <code>y</code>  from the larger.
</li>

<li> 
   Stop when  <code>x</code>  and
    <code>y</code>  have the same value.  That value is the
   GCD of  <code>M</code>  and
    <code>N</code> .
</li>
</ul><p>

This description is above the code level. 

Code to compute </p><nobr> <code>GCD(M,N)</code> </nobr><p>
would have to specify additional details such as the type of
 <code>M</code>  and  <code>N</code>  (is
it  <code>int</code>?
 <code>long</code>?
 <code>BigInteger</code>?)  and what to do if
 <code>M</code>  or  <code>N</code>  is
not positive (throw an exception?  return an error value?).  </p><p>

A programmer who didn&#39;t know Euclid&#39;s algorithm might decide to compute 
 <nobr> <code>GCD(M,N)</code> </nobr> 
by a naive algorithm that sets  <code>x</code>  to the
minimum of  <code>M</code>  and
 <code>N</code>  and keeps decreasing
 <code>x</code>  until it divides both
 <code>M</code>  and
 <code>N</code> .  The best coder in the world will
not produce a good GCD program by coding the naive algorithm. 
Moreover, thinking in terms of code makes it harder for a programmer
to find a better algorithm.  Finding a good algorithm requires
thinking above the code level.

 </p><p>


No one writes a piece of code without first having a high-level model
of what the code should do and how it should do it.  A programmer
never starts by deciding to declare some variables, adding a
 <b>while</b>  statement, then adding an
 <b>if</b>  statement, and so on—only discovering
when finished that she&#39;s written a sorting program.  But
programmers rarely start with a <em>precise</em> model of the code.
Having only a vague, incomplete model leads to basic design errors
that the best coding won&#39;t correct.  </p><p> 
TLA+ is a language for writing precise high-level models of what
code does and how it does it.   

 <!-- 
   It looks nothing like a programming language because programming
   languages are designed for writing code, not for thinking above the
   code level.  Instead, TLA+ is based on mathematics, the universal
   language of science and engineering.
 -->


Most programmers believe that precise models are good only for
tiny well-defined problems like computing the GCD, but are useless for
implementing complex systems.   They&#39;re wrong.   The more
complex a system is, the more important it is to make it as simple as
possible.   In complex systems, simplicity isn&#39;t achieved by coding
tricks.   It&#39;s achieved by rigorous thinking above the code level.

</p><p>

In 
  <a href="https://lamport.azurewebsites.net/tla/industrial-use.html?unhideBut=hide-rtos&amp;unhideDiv=rtos&amp;back-link=high-level-view.html#language?unhideBut@EQhide-above-code@AMPunhideDiv@EQabove-code">
     one industrial project</a>,
starting with a TLA+ model reduced the size of a real-time
operating system&#39;s code by a factor of ten. 
Such a reduction in
code size isn&#39;t obtained by better coding; it comes from thinking
rigorously above the code level. 

 </p><p>

Writing a model above the code level doesn&#39;t prevent coding
errors.  Many methods and tools have been developed for finding
coding errors, and they should be used.  But they are not good
for finding errors in the high-level model from which the code is
derived.  And it&#39;s impossible to test that a high-level model is
implemented correctly if the model is just a vague idea in the
programmer&#39;s mind, with no precise description.

</p><p>

Testing the code is not an effective way to find fundamental design
errors—especially in concurrent and distributed systems. 
Moreover, a design error found after the code has been written is
usually fixed with an <em>ad hoc</em> patch that is unlikely to
eliminate all instances of the problem and is likely to introduce new
errors.  Design errors should be caught by writing a precise
high-level model, before the code is written.

</p></div>

<h2 id="h2concurrent" onclick="showHide(&#39;hide-concurrent&#39;,&#39;concurrent&#39;)">
  Modeling Concurrent Systems 
          
     <SPAN id="hide-concurrent">
      [show]</SPAN>
</h2>

<div id="concurrent"><p> 

A concurrent system is one that we think of as composed of multiple
concurrently operating components called 
   </p><SPAN id="process-popup" class="show-hide" onclick="popup(&#39;process-popup.html&#39;,220)">
      <b><SPAN color="blue">processes</SPAN></b>
   </SPAN><p>. 

</p><!--
 (Contrary to popular belief, being composed of multiple processes is
   not an inherent property of a system, but rather a result of how we
   view it.)   
--><p>

A distributed system is a concurrent system in which we
think of the processes as being spatially separated, usually communicating
with one other by sending messages.


</p><p>


In a state-based model, a state represents the entire physical state
of a system.  Some people find it hard to believe that one can or
should model a distributed system in terms of a single global
state.  Over 40 years of experience has taught me that this is
the most generally useful way to model distributed algorithms and
systems.

</p></div>

<h2 id="h2machines" onclick="showHide(&#39;hide-state-machines&#39;,&#39;state-machines&#39;)">State Machines
          
     <SPAN id="hide-state-machines">
      [show]</SPAN>
</h2>

<div id="state-machines"> <!-- style="display:none"--><p>

Like many state-based methods, TLA+ describes a set of
behaviors with two things:

</p><ol> <li> An <em>initial condition</em> that specifies the 
        possible starting states.</li> 

     <li>A <em>next-state relation</em> that
        specifies the possible steps (pairs of successive states). </li>
</ol><p>

They specify the set of behaviors whose first state satisfies the
initial condition and whose every step 
satisfies the next-state relation. 

</p><p>

This kind of model is often called a <em>state machine</em>.  (A
finite-state machine is a state machine with a finite set of possible
states.  Finite-state machines are not nearly as useful as
general state machines.)  A Turing machine is an example of a
state machine.  In a deterministic Turing machine, the next-state
relation allows at most one next state for any state, and it allows no
next state for a terminating state. 

</p><p>

The simplest and most practical method of precisely describing the
semantics of a programming language, called operational semantics,
essentially consists of showing how to <q>compile</q> a program in the
language to a state machine.  Given an operational semantics, any
program in the language can be viewed as a state machine.  I
suspect that most programmers intuitively think of a program in that
way.

</p><p> The next-state action specifies what steps <em>may</em> happen; it
doesn&#39;t specify what steps, if any, <em>must</em> happen.  That
requires an additional condition, called a <em>fairness</em>
property.  A state machine that models a sequential program
usually includes the fairness property that some step must be taken
(the behavior must not stop) if the next-state relation allows a step
to be taken.  Models of concurrent and distributed programs often
have more complicated fairness properties.



<!--
Most people find it natural to consider an initial condition and
next-state relation to describe only behaviors that cannot end in a
state in which there exists a possible next state.  This is fine
for modeling sequential systems, but not concurrent ones.  For
example, it's not a natural way of modeling a client-server system in
which clients can stop sending requests.  TLA+ considers the
next-state relation to describe what steps are allowed to happen, but
to say nothing about what steps must happen.  For example, it
never rules out a behavior that stops in its initial state.  What
steps must happen are described by an additional
condition—usually what is called a <em>fairness</em>
condition.  That a behavior doesn't stop in a state from which
the next-state relation allows a step is a fairness condition.
-->

</p><p>

A state-machine model without a fairness condition can be used to
catch errors of <q>commission</q>, in which the system does something
wrong.  It can&#39;t be used to catch errors of <q>omission</q>, in
which the system fails to do something.  In practice, errors of
commission are more numerous and harder to find than errors of
omission.  Often, engineers don&#39;t bother adding fairness
conditions.  Therefore, you should first learn to write the
initial condition and next-state relation in your TLA+ models. 
Later, you can learn to write fairness conditions.

</p></div>

<h2 id="h2checking" onclick="showHide(&#39;hide-checking&#39;,&#39;checking&#39;)"><a name="checking">Checking Properties</a>
          
     <SPAN id="hide-checking">
      [show]</SPAN>
</h2>

<div id="checking"> <!-- style="display:none"--><p>

One reason for modeling a system is to check if it does what we want
it to.  We do that by checking if the model satisfies properties
that we believe assert that the system does what it should.  TLA+
can assert, and its tools can check, only that some property of an
individual behavior is true of every possible behavior of the
model.  Thus, TLA+ cannot assert that 99% of all possible
behaviors terminate in a correct state.  However, it can assert
(and its tools can check) that every possible behavior terminates in a
correct state if its initial state belongs to a particular set
containing 99% of all possible initial states.


</p><p> 

The most useful type of property to check is an invariance property,
which asserts that something is true of every state of every possible
behavior.  Often, an engineer will check only invariance
properties of a model.

</p><p>

For a model containing a fairness condition, you should also check
simple properties asserting that something eventually happens—for
example, that every execution eventually halts.   Those properties,
called <em>liveness properties</em>, are easily expressed in TLA+.

</p><p>


The rich variety of properties that we want to check for concurrent
systems can&#39;t all be expressed as invariance and simple liveness
properties.   They can be expressed as state machines (possibly with
fairness conditions).   

A state machine can be viewed as the property that is satisfied by the
possible behaviors of the state machine.  We can check whether
another state machine satisfies this property.  If it does, we
say that the other state machine <em>implements</em> the state
machine.


</p><p>

In TLA+ there is no formal distinction between a state machine and a
property.   Both are described by mathematical formulas.   

A state machine is a formula having a particular <q>shape</q>, 
different from the shape of an invariance or liveness property. 


Both <em>satisfying a property</em> and <em>implementing a state
machine</em> mean that one formula implies another.


</p><p>


Today, most engineers check only invariance properties and simple
liveness properties. 

However, even if you never do it, knowing how it is done explains
what it means for a program to implement a model, which can help you
avoid making errors in your code.  

</p></div>



<h2 id="h2language" onclick="showHide(&#39;hide-language&#39;,&#39;language&#39;)">
   <a name="language">The TLA+ Language</a>
          
     <SPAN id="hide-language">
      [show]</SPAN>
</h2>

<div id="language"> <!-- style="display:none"--><p>

TLA+ is based on mathematics and does not resemble a programming
language.  Most engineers are familiar with programming
languages, but not with precise mathematical notation.  We
naturally find what we&#39;re familiar with to be simpler than anything
else.  It&#39;s hard for me to believe that English is not inherently
simpler than German.  Upon first seeing a TLA+ model, some
engineers find TLA+ intimidating.   Read the
  <a href="https://lamport.azurewebsites.net/tla/industrial-use.html?back-link=high-level-view.html#language?unhideBut@EQhide-language@AMPunhideDiv@EQlanguage">
      Industrial Use of TLA+</a> 
page to see that TLA+ is not very hard to learn.

</p><p>

Using TLA+ teaches you that math is inherently more expressive than
programming languages because it can describe a value without having
to describe how the value is computed.  For example, it can
describe the greatest common divisor (GCD) of two numbers as the
largest positive integer that divides both numbers.  This makes
it possible to write a model for a specific purpose, abstracting away
irrelevant details such as how to calculate the GCD.  (Putting
code in a procedure doesn&#39;t abstract it away;  it just makes you
go elsewhere to read the code, requiring that you understand the
semantics of procedure call as well as the code.) 

</p><p>

Starting with PlusCal provides a gentle entry to TLA+.  Even if you
know TLA+, it&#39;s easier to write some models in PlusCal rather
than directly in TLA+.  But to get the full benefit of thinking
mathematically above the code level, you should learn TLA+.



</p></div>
</td>
</div></div>
  </body>
</html>
