<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://shopify.engineering/ruby-yjit-is-production-ready">Original</a>
    <h1>Ruby 3.2â€™s YJIT is Production-Ready</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
  
<p>Back in July 2020, I joined the Ruby &amp; Rails Infrastructure (R&amp;RI) team at Shopify. Our team focuses on making sure that Ruby as well as Ruby on Rails, central to the infrastructure behind all Shopify stores and much of the modern web, run as smoothly and efficiently as possible.</p>
<p>As part of the R&amp;RI team, I got to meet skilled engineers that were doing open source work, directly contributing patches to CRuby itself. Since my background is in compiler design, I started to discuss with my manager the possibility that we could build a relatively simple Just-In-Time (JIT) compiler for Ruby. To my surprise, my manager and two colleagues were immediately on board with this idea, and what would become the <a href="https://shopify.engineering/yjit-just-in-time-compiler-cruby" target="_blank" title="YJIT: Building a New JIT Compiler for CRuby"> YJIT</a>Â project was born.</p>
<p>Building YJIT was hard work. There were many long, intense debugging sessions involved, but within just over a year, weâ€™d managed to deliver roughly <a href="https://speed.yjit.org/benchmarks/bench-2021-10-13-070947" target="_blank" title="Details for Benchmarks at 2021-10-13 07:09:47" rel="nofollow noopener noreferrer"> 20% speedups</a>Â on <a href="https://github.com/Shopify/yjit-bench/tree/main/benchmarks/railsbench" target="_blank" title="This is a Rails benchmark created with Rails&#39;s scafold generator. It&#39;s not very real-world, but it still shares some code with real-world Rails apps." rel="nofollow noopener noreferrer"> railsbench</a>. Following that, the CRuby core contributors invited us to <a href="https://bugs.ruby-lang.org/issues/18229" target="_blank" title="Feature #18229 -  Proposal to merge YJIT" rel="nofollow noopener noreferrer"> upstream YJIT</a>, and so YJIT was released as an official part of Ruby 3.1 in December of 2021. Upstreaming YJIT had been an aspirational goal for the team from the start, but we had never thought it would happen this fast. Iâ€™ll take this opportunity to say that Iâ€™m very thankful to Shopify for letting us take on some risks, and to the Ruby community for being so open-minded.</p>

<p>A lot has happened for YJIT in 2022. For one thing, weâ€™ve expanded the team. We wrote about job openings in the YJIT team on this blog last year, and we were flooded with applications from people excited to work on a Ruby JIT, all of them with impressive CVs and a long list of systems programming skills. We ended up recruiting three skilled engineers which became part of the YJIT dream team. One of these new recruits is no other than Takashi Kokubun, long-time CRuby core member and maintainer of MJIT.</p>
<p>The YJIT team has made multiple improvements to YJIT which are now available <a href="https://www.ruby-lang.org/en/news/2022/12/25/ruby-3-2-0-released/" target="_blank" title="Ruby 3.2 Released" rel="nofollow noopener noreferrer"> as part of Ruby 3.2</a>. The good news is that, as you might expect, the new version of YJIT brings better performance, both on benchmarks and on real workloads, but I would say that the broader theme for 3.2 has been to make YJIT more robust, more maintainable, and generally more production-ready.</p>
<h2>Rewriting YJIT to Rust</h2>
<p>To start 2021, we decided to <a href="https://shopify.engineering/porting-yjit-ruby-compiler-to-rust" target="_blank"> port YJIT from C99 to Rust</a>. The motivation for this was twofold. Rust provides additional safety guarantees that C doesnâ€™t, which is important when doing <a href="https://shopify.engineering/shopify-rust-systems-programming" target="_blank" title="Shopify Embraces Rust for Systems Programming">low-level systems programming</a> with many constraints, as in a JIT compiler. The secondary motivating factor was that we felt that, as the complexity of YJIT increases, we needed better tools to manage that complexity. Writing C code, we had to resort to implementing our own dynamic arrays in terms of C macros, which felt both unsafe and awkward. Rust provides a much richer standard library and many nice and fast abstractions. It took Noah Gibbs, Alan Wu, andÂ me about three months to port YJIT to Rust, and Iâ€™m happy to say that our new Rust codebase does feel much easier to maintain.</p>
<h2>Improved Memory Usage</h2>
<p>One of the challenges with JIT compilers is that they always incur some amount of memory overhead over interpreters. At the most basic level, a JIT compiler needs to generate executable machine code, which an interpreter doesnâ€™t, so JIT compilers must use more memory than interpreters. On top of that, however, JIT compilers also need to allocate memory for auxiliary data structure (metadata), which can also add quite a bit of extra memory overhead.</p>
<p>We were unhappy with how much extra memory YJIT used in Ruby 3.1. We felt that the amount of memory needed back then made it difficult to deploy in production at Shopify, and so weâ€™ve made multiple improvements to reduce memory usage. The good news is that, thanks to the hard work of Alan and Takashi, the overhead has been cut down to approximately one third of what it was for 3.1, which helps make YJIT a lot more usable in production. To achieve this, weâ€™ve optimized how much space our metadata takes, weâ€™ve implemented a garbage collector for machine code that is no longer used, and weâ€™ve made it so YJIT will lazily allocate memory pages for machine code as opposed to allocating and initializing a large block of memory up front.</p>
<h2>Improved Performance</h2>
<figure><a href="https://speed.yjit.org/" target="_blank" rel="nofollow noopener noreferrer"><img alt="Depiction of matching performed on two sets of samples based on their propensity scores." data-src="https://cdn.shopify.com/s/files/1/0779/4361/files/yjit-improved_performance.png?format=jpg&amp;quality=90&amp;v=1673883706"/> </a>
<figcaption>YJITâ€™s performance vs the interpreter in Ruby 3.2 (higher is better). <em>Image source: <a href="https://speed.yjit.org/" target="_blank" rel="nofollow noopener noreferrer">speed.yjit.org</a></em></figcaption>
</figure>
<p>YJIT 3.2 doesnâ€™t just use less memory though, itâ€™s also faster. We now <a href="https://speed.yjit.org/benchmarks/bench-2023-01-10-201001" target="_blank" title="Details for Benchmarks at 2023-01-10 20:10:01" rel="nofollow noopener noreferrer"> speed up railsbench</a>Â by about 38% over the interpreter, but this is on top of the Ruby 3.2 interpreter, which is already faster than the interpreter from Ruby 3.1. According to <a href="https://gist.github.com/k0kubun/10ae929640aabf933fb93f2059b9fa35" target="_blank" title="yjit-bench: railsbench peak speedup from Ruby 3.1" rel="nofollow noopener noreferrer"> the numbers</a>Â gathered by Takashi, the cumulative improvement makes YJIT 57% faster than the Ruby 3.1.3 interpreter. Itâ€™s not just our numbers <a href="https://twitter.com/maciejmensfeld/status/1612851439620997123" target="_blank" title="Tweet by @maciejmensfeld" rel="nofollow noopener noreferrer"> that show</a>Â that the <a href="https://gettalong.org/blog/2022/benchmarking-rubies.html" target="_blank" rel="nofollow noopener noreferrer"> new YJIT delivers</a>Â great <a href="https://twitter.com/_beauraF/status/1612801258641055745?cxt=HHwWgoDTqeSM6eEsAAAA" target="_blank" title="Tweet from @_beauraF" rel="nofollow noopener noreferrer"> performance</a>, the Ruby community has done <a href="https://twitter.com/rafael_falco/status/1607395317661458432" target="_blank" rel="nofollow noopener noreferrer"> their own benchmarking</a>Â as well.</p>
<meta charset="utf-8"/>
<figure><a href="https://twitter.com/rafael_falco/status/1607395317661458432" target="_blank" rel="nofollow noopener noreferrer"><img alt="â€œTweet" by="" rafael_falco="" data-src="https://cdn.shopify.com/s/files/1/0779/4361/files/rubycommunity2.png?format=jpg&amp;quality=90&amp;v=1673885549"/> </a>
<figcaption>Source: <a href="https://twitter.com/rafael_falco/status/1607395317661458432" target="_blank" rel="nofollow noopener noreferrer">@rafael_falco</a> on Twitter.</figcaption>
</figure>
<h2>ARM64 Support</h2>
<p>Another major change in YJIT 3.2 is that we now have <a href="https://www.youtube.com/watch?v=BbLGqTxTRp0" target="_blank" title="YouTube: Building a Lightweight IR and Backend for YJIT / Maxime Chevalier-Boisvert @maximecb" rel="nofollow noopener noreferrer"> a new backend</a>Â that can generate machine code for multiple CPU platforms, which enables us to support ARM64 CPUs. In 3.1, we only supported x86-64 on Mac and Linux. With developers at Shopify migrating to Apple M1/M2 laptops, we found ourselves in the awkward situation where we could only run YJIT locally through emulation with Rosetta. With Ruby 3.2, itâ€™s now possible to run YJIT natively on Apple M1 &amp; M2, AWS Graviton 1 &amp; 2, and even on <a href="https://github.com/Shopify/ruby/issues/453" target="_blank" title="YJIT: check if YJIT can easily compile and run on a Raspberry Pi 4 ðŸ¤” and benchmark it" rel="nofollow noopener noreferrer"> Raspberry Pis!</a>Â Interestingly, YJIT gets an even bigger speedup on Mac M1 hardware than it does on Intel x86-64 CPUs. We hope that this will encourage people to try out YJIT locally on their development machines.</p>
<h2>Additional Improvements</h2>
<p>Ruby 3.2 also includes another major change that has been in the works for a while. Jemma Issroff and Aaron Patterson have done an impressive amount of work in order to reimplement Rubyâ€™s internal representation for objects, which is now based on the concept of <a href="https://www.youtube.com/watch?v=2aVyTtxs0GU" target="_blank" title="Implementing Object Shapes in CRuby by Jemma Issroff" rel="nofollow noopener noreferrer"> object shapes</a>. This allows both the interpreter and YJIT to benefit from faster instance variable accesses.</p>
<p>In addition to this, <span>Â Eileen Uchitelle implemented a tool to </span><a href="https://speakerdeck.com/eileencodes/exit-ing-through-the-yjit?slide=43" target="_blank" rel="nofollow noopener noreferrer"><span>trace YJIT exits</span></a><span>,Â </span>Jimmy Miller worked on improving YJIT support for various types of Ruby method calls, and Kevin Newton implemented a <a href="https://bugs.ruby-lang.org/issues/18589" target="_blank" title="Feature #18589 - Finer-grained constant invalidation" rel="nofollow noopener noreferrer"> finer-grained constant cache invalidation</a>Â mechanism. This change was brought about to address a situation we had seen in production where constants being redefined would cause YJIT to recompile a lot of code.Â </p>
<p>Last but not least, Peter Zhu and Matthew Valentine-House have made improvements to Ruby 3.2â€™s garbage collector, and made it possible to allocate <a href="https://www.youtube.com/watch?v=7C3bdT6Ri2Q" target="_blank" title="[EN] Variable Width Allocation: Optimizing Ruby&#39;s Memory Layout / @peterzhu2118 and @eightbitraptor" rel="nofollow noopener noreferrer"> variable-sized objects</a>. This improves Rubyâ€™s memory usage and also significantly improves the interpreterâ€™s performance. It also makes it possible to allocate larger objects which are more cache-friendly.</p>

<p>The main reason why Shopify chose to invest in the development of YJIT is of course that Shopify runs a large amount of infrastructure built on top of Ruby and Ruby on Rails. Multiple large clusters of servers distributed across the world, capable of serving over <a href="https://twitter.com/ShopifyEng/status/1597983926126977024" target="_blank" title="Tweet from @ShopifyEng" rel="nofollow noopener noreferrer"> 75 million requests per minute</a>. From the start, the objective was to eventually be able to use YJIT to improve the efficiency of Shopifyâ€™s Storefront Renderer (SFR).</p>
<p>Given that YJIT 3.1 had significant memory overhead and was still marked as experimental, we didnâ€™t want to deploy it globally right away. However, starting about a year ago, weâ€™ve started to run a few SFR nodes using YJIT. This has been extremely valuable to us, because itâ€™s enabled us to gather statistics and see how YJIT and our codebase behave under a real-world deployment with real traffic, which has exposed some performance issues we couldnâ€™t see on benchmarks.Â </p>
<p><a href="https://twitter.com/tobi/status/1605656985185226753?s=20&amp;t=PXC8BLfdMj9sCvEJWDnkPQ" target="_blank" rel="nofollow noopener noreferrer"><img alt="" data-src="https://cdn.shopify.com/s/files/1/0779/4361/files/yjit-tobi.png?format=jpg&amp;quality=90&amp;v=1673894033"/></a></p>
<p>This year, with Ruby 3.2, YJIT has improved enough that weâ€™ve deemed it production-ready, and Shopify has proceeded to deploy it globally on its entire SFR infrastructure. Weâ€™re able to measure real speedups ranging from 5% to 10% (depending on time of day) on our total end-to-end request completion time measurements.</p>
<figure><img alt="â€œYJIT" speedup="" over="" the="" ruby="" interpreter="" on="" our="" sfr="" deployment="" data-src="https://cdn.shopify.com/s/files/1/0779/4361/files/yjitsfr.png?format=jpg&amp;quality=90&amp;v=1673893933"/>
<figcaption>YJIT speedup over the Ruby 3.2 interpreter on our SFR deployment.</figcaption>
</figure>
<p>I want to be honest and say that YJIT is still not perfect. It still has some memory overhead, but we think itâ€™s worth the speedups, and of course, we intend on improving the situation further. One of the key advantages of YJIT is its very fast compilation times. At Shopify, we deploy continuously, often multiple times every day, sometimes multiple times in a single hour. That means YJIT has to be able to compile code very quickly, otherwise some Shopify customers might see their request time out whenever a deployment occurs. Itâ€™s not just the speed of the code we compile that matters, itâ€™s also how fast we can compile code.</p>
<p>Weâ€™ve successfully deployed YJIT in production at Shopify, but the YJIT team has relatively little visibility into how many people are using YJIT in practice outside of interacting with people on Twitter or at conferences. If youâ€™re using YJIT in production, for your dev environment, or even for a hobby project, please <a href="https://twitter.com/shopifyeng" target="_blank" title="@ShopifyEng on Twitter" rel="nofollow noopener noreferrer"> let us know</a>Â and share your feedback! Weâ€™d love to hear your YJIT success stories (or pain points, for that matter).</p>

<p>The year 2023 has just begun and we already have a long list of new improvements we want to bring to YJIT. Since weâ€™ve just deployed YJIT, I think itâ€™s important that we continue to remain grounded and use statistics from our real-world deployment to address the biggest pain points. YJITâ€™s biggest flaw is still its memory footprint, and this is something we need to continue working to further improve.</p>
<p>In terms of the biggest opportunities for speedups, Ruby is method calls all the way down. That is, loop iteration as well as most basic operations in Ruby are method calls, and typical Ruby code contains many calls to small Ruby methods. As such, the most obvious area for potential improvements would be to make method calls faster. There are a few avenues we&#39;re exploring to achieve this, such as potentially implementing a more efficient calling convention, and also inlining method calls.</p>
<p>In addition to optimizing the performance of method calls, weâ€™d also like to better optimize the machine code that YJIT generates. We still donâ€™t have a proper register allocator, and we donâ€™t really optimize across basic blocks. Finally, we may also want to optimize the way YJIT and CRuby perform various hash and string operations, as these are very common in web workloads.</p>

<p>If youâ€™re interested in trying out Ruby 3.2, the release notes and tarball packages can be found <a href="https://www.ruby-lang.org/en/news/2022/12/25/ruby-3-2-0-released/" target="_blank" title="Ruby 3.2.0 Released" rel="nofollow noopener noreferrer"> here</a>, itâ€™s also possible to directly install Ruby 3.2 via brew if youâ€™re on macOS, or using the <a href="https://github.com/postmodern/ruby-install#readme" target="_blank" title="Installs Ruby, JRuby, Rubinius, TruffleRuby (native / GraalVM), or mruby." rel="nofollow noopener noreferrer"> ruby-install</a>Â tool. In order to make sure that YJIT is available, you just need to make sure that you have rustc 1.58.0 or newer (or <a href="https://rustup.rs/" target="_blank" title="rustup is an installer for the systems programming language Rust" rel="nofollow noopener noreferrer"> the Rust toolchain</a>) installed on your machine before you install/build Ruby using your favorite tool (brew, ruby-build, ruby-install, etc.). You can then run Ruby with YJIT enabled by passing the <code>--yjit</code> command-line flag to Ruby, or by setting the <code>RUBY_YJIT_ENABLE</code> environment variable.</p>
<p>For more information on YJITâ€™s design or how to use it, you can check out our <a href="https://github.com/ruby/ruby/blob/master/doc/yjit/yjit.md" target="_blank" title="YJIT documentation on GitHub" rel="nofollow noopener noreferrer"> documentation</a>, or one of theÂ resources below.</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=EMchdR9C8XM" target="_blank" rel="nofollow noopener noreferrer">Alan Wuâ€™s RubyKaigi 2022 keynote: Stories from developing YJIT (RubyKaigi 2022)</a></li>
<li><a href="https://www.youtube.com/watch?v=BbLGqTxTRp0" target="_blank" rel="nofollow noopener noreferrer">Building a Lightweight IR and Backend for YJIT (RubyKaigi 2022)</a></li>
<li><a href="https://shopify.engineering/ruby-variable-width-allocation" target="_blank"> Optimizing Rubyâ€™s Memory Layout: Variable Width AllocationÂ by Peter Zhu</a></li>
<li><a href="https://www.youtube.com/watch?v=zO9_uTaELCw" target="_blank" rel="nofollow noopener noreferrer">YJIT - Building a new JIT Compiler inside CRuby (RubyConf 2021)</a></li>
<li><a href="https://topenddevs.com/podcasts/ruby-rogues/episodes/mjit-yjit-and-haml-with-takashi-kokubun-ruby-573" target="_blank" rel="nofollow noopener noreferrer">MJIT, YJIT, and HAML with Takashi Kokubun - Ruby Rogues #573</a></li>
<li><a href="https://www.youtube.com/watch?v=PT888djgDLI" target="_blank" rel="nofollow noopener noreferrer">Parsers, Interpreters, and YJIT with Kevin Newton</a></li>
<li>
<a href="https://shopify.engineering/yjit-just-in-time-compiler-cruby" target="_blank"><span>YJIT: Building a New JIT Compiler for CRuby</span></a>Â </li>
<li><a href="https://shopify.engineering/porting-yjit-ruby-compiler-to-rust" target="_blank">Our Experience Porting the YJIT Ruby Compiler to Rust</a></li>
</ul>
<p>Iâ€™d like to conclude with a big thank you to the YJIT team, and everyone that has contributed to this projectâ€™s success, including: Alan Wu, Aaron Patterson, Jemma Issroff, Eileen Uchitelle, Kevin Newton, Noah Gibbs, Jimmy Miller, Takashi Kokubun, Ufuk Kayserilioglu, Mike Dalessio, Jean Boussier, John Hawthorn, Rafael FranÃ§a, and more!</p>
<p><strong>Maxime Chevalier-Boisvert</strong> obtained a PhD in compiler design at the University of Montreal in 2016, where she developed Basic Block Versioning (BBV), a JIT compiler architecture optimized for dynamically-typed programming languages. SheÂ leads the YJIT project at Shopify.</p>
<p>Open source software plays a vital and integral part at Shopify. If being a part of an Engineering organization thatâ€™s <a href="https://shopify.engineering/shopify-open-source-philosophy" target="_blank">committed</a> to the support and stewardship of open source software sounds exciting to you, visit our <a href="http://www.shopify.com/careers/specialties/engineering?itcat=EngBlog&amp;itterm=Post" target="_blank">Engineering career page</a> to find out about our open positions and learn about <a href="https://www.shopify.com/careers/work-anywhere?itcat=EngBlog&amp;itterm=CCTA-DD" target="_blank">Digital by Design</a>.</p>
</div></div>
  </body>
</html>
