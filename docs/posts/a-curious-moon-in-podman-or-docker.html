<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://moerner.com/posts/docker-postgres-makefile/">Original</a>
    <h1>A Curious Moon in Podman or Docker</h1>
    
    <div id="readability-page-1" class="page"><section><p>I recently started working through <a href="https://sales.bigmachine.io/curious-moon">A Curious Moon</a>, a wonderfully clever data science “mystery” in PostgreSQL. The setup in the book uses Postgres on bare metal, but I wanted to use Postgres in <a href="https://docs.podman.io/en/latest/">Podman</a>, which is like Docker. One interesting suggestion in the book is to use a Makefile to organize ETL. But this needed a little massaging work with Podman on Fedora, which I want to share here.</p>
<p>Here is my Compose file:</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>services</span>:
</span></span><span><span>  <span>cassini-pg</span>:
</span></span><span><span>    <span>image</span>: <span>postgres:17</span>
</span></span><span><span>    <span>restart</span>: <span>unless-stopped</span>
</span></span><span><span>    <span>container_name</span>: <span>cassini-pg</span>
</span></span><span><span>    <span>environment</span>:
</span></span><span><span>      - <span>POSTGRES_USER=cassini</span>
</span></span><span><span>      - <span>POSTGRES_PASSWORD=super_secret_password</span>
</span></span><span><span>      - <span>UID=1000</span>
</span></span><span><span>      - <span>GID=1000</span>
</span></span><span><span>    <span>volumes</span>:
</span></span><span><span>      - <span>./curious_data:/curious_data:z</span>
</span></span><span><span>      - <span>./scripts:/scripts:z</span>
</span></span></code></pre></div><p>On a system with enforcing SELinux like Fedora, you’ll need to add the <code>:z</code> to
the end of the volume mounts. This will ensure the volume is shared with the
correct SELinux labels. Otherwise, you will receive a permissions error when
trying to access the directory.</p>
<p>And here is my Makefile:</p>
<div><pre tabindex="0"><code data-lang="make"><span><span>CONTAINER<span>=</span>cassini-pg
</span></span><span><span>USER<span>=</span>cassini
</span></span><span><span>DB<span>=</span>enceladus
</span></span><span><span>LOCALPATH<span>=</span><span>${</span>CURDIR<span>}</span>/
</span></span><span><span>DOCKERPATH<span>=</span>/
</span></span><span><span>SCRIPTS<span>=</span>scripts
</span></span><span><span>CSV<span>=</span><span>&#39;/curious_data/data/master_plan.csv&#39;</span>
</span></span><span><span>MASTER<span>=</span><span>$(</span>SCRIPTS<span>)</span>/import.sql
</span></span><span><span>NORMALIZE<span>=</span><span>$(</span>SCRIPTS<span>)</span>/normalize.sql
</span></span><span><span>BUILD<span>=</span><span>$(</span>SCRIPTS<span>)</span>/build.sql
</span></span><span><span>
</span></span><span><span><span>all</span><span>:</span> normalize
</span></span><span><span>	podman exec -it <span>$(</span>CONTAINER<span>)</span> psql <span>$(</span>DB<span>)</span> -U <span>$(</span>USER<span>)</span> -f <span>$(</span>DOCKERPATH<span>)$(</span>BUILD<span>)</span> <span>&amp;&amp;</span> podman exec -it <span>$(</span>CONTAINER<span>)</span> psql <span>$(</span>DB<span>)</span> -U <span>$(</span>USER<span>)</span>
</span></span><span><span>
</span></span><span><span><span>master</span><span>:</span>
</span></span><span><span>	@cat <span>$(</span>LOCALPATH<span>)$(</span>MASTER<span>)</span> &gt;&gt; <span>$(</span>LOCALPATH<span>)$(</span>BUILD<span>)</span>
</span></span><span><span>
</span></span><span><span><span>import</span><span>:</span> master
</span></span><span><span>	@echo <span>&#34;COPY import.master_plan FROM </span><span>$(</span>CSV<span>)</span><span> WITH DELIMITER &#39;,&#39; HEADER CSV;&#34;</span> &gt;&gt; <span>$(</span>LOCALPATH<span>)$(</span>BUILD<span>)</span>
</span></span><span><span>
</span></span><span><span><span>normalize</span><span>:</span> import
</span></span><span><span>	@cat <span>$(</span>LOCALPATH<span>)$(</span>NORMALIZE<span>)</span> &gt;&gt; <span>$(</span>LOCALPATH<span>)$(</span>BUILD<span>)</span>
</span></span><span><span>
</span></span><span><span><span>clean</span><span>:</span>
</span></span><span><span>	@rm -rf <span>$(</span>LOCALPATH<span>)$(</span>BUILD<span>)</span>
</span></span><span><span>
</span></span><span><span><span>createdb</span><span>:</span>
</span></span><span><span>	podman exec -it <span>$(</span>CONTAINER<span>)</span> createdb <span>$(</span>DB<span>)</span> -U <span>$(</span>USER<span>)</span>
</span></span><span><span>
</span></span><span><span><span>psql</span><span>:</span>
</span></span><span><span>	podman exec -it <span>$(</span>CONTAINER<span>)</span> psql <span>$(</span>DB<span>)</span> -U <span>$(</span>USER<span>)</span>
</span></span></code></pre></div><p>A few things to note here. First, when using containers (at least at the start)
you will often want to completely blow up and recreate a container. This means
being prepared to re-run <code>createdb</code>. I wanted to make this a target of <code>all</code>
and <code>psql</code>, but it appears that Postgres does not have an easy-to-use command
like <code>CREATE DATABASE IF NOT EXISTS</code>. So instead error messages on a new
container should point you to the need to re-run the <code>createdb</code> target.</p>
<p>Second, the default make target should leave us in an interactive <code>psql</code>
session. However, just passing a script to the container drops us into what
appears to be a <code>psql</code> session (you can type in it), but it is not usable
(“Enter” does not execute a command). Therefore, in the <code>all</code> target we first
load the build script and then execute a separate <code>psql</code> interactive session.</p>
<p>Third, the paths are a bit messy because we need to use a mixture of paths
outside of the container and paths within the container. This
could be simplified by using absolute paths and adjusting the container volume
mounts to be identical. I did not pursue this, however, because hard-coding absolute paths in the volumes seems fragile and exposes more information than is necessary to the container.</p>
<p>I look forward to sharing more of my journey through this book here on my blog.
One more thing: The link to the data included in the book itself seems to be
dead, but the data is still available here: <a href="https://archive.redfour.io/">https://archive.redfour.io/</a></p>
</section></div>
  </body>
</html>
