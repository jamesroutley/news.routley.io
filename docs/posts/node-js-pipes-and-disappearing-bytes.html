<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sxlijin.github.io/2024-10-09-node-stdout-disappearing-bytes">Original</a>
    <h1>Node.js, Pipes, and Disappearing Bytes</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
    
    <p>2024 Oct 09</p>
    <hr/>
    <p>Someone in one of my online communities recently asked about why
    their Node command was dropping output when piped to another
    command:</p>
    <blockquote>
    <p>[command] spits out 2319 lines of valid json to stdout. If I
    redirect it into a file then I can open that file and yes, see all
    2319 lines and well formatted json.</p>
    <p>But when I pipe it to <code>jq</code>, it complains that the json
    terminates on line 1394</p>
    <p>If I pipe to <code>wc</code> then it reports there are 1394
    lines</p>
    <p>If I pipe to <code>tee</code> to write it to a file and then pipe
    <strong>that</strong> to <code>wc</code> it reports 1394 and the
    file indeed cuts off my json part way through the 1394th line</p>
    <p>There is nothing unusual about this line</p>
    <p>What could be going on?</p>
    </blockquote>
    <p>A mystery! And I still have chores and work to do, so what better
    time to get nerdsniped<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>?</p>
    <h2 id="digging-in">Digging in</h2>
    <p>I&#39;d seen something like this before years ago, but didn&#39;t really
    remember any details from that besides that Node does some weird
    things with pipes.</p>
    <p>If it&#39;s truncating output from 2k+ lines to ~1.5k lines of JSON,
    well, hm - depending on how big those lines are, it seems very
    likely that there&#39;s some kind of &#34;pipe is full&#34; limit getting
    triggered in some shape or fashion here.</p>
    <blockquote>
    <p>me: what do you get when piping to <code>wc -c</code>?</p>
    </blockquote>
    <blockquote>
    <p>them: actual character count is <code>104283</code> with the pipe
    its <code>65536</code></p>
    </blockquote>
    <p>Aha! A power of two - ✨magic✨ numbers are always a good time.
    (Seriously. It&#39;s so much easier once you have a hint about what to
    look for.)</p>
    <p>Indeed, looking at <a href="https://man7.org/linux/man-pages/man7/pipe.7.html"><code>man(7) pipe</code></a>:</p>
    <blockquote>
    <p>Before Linux 2.6.11, the capacity of a pipe was the same as the
    system page size (e.g., 4096 bytes on i386). Since Linux 2.6.11, the
    pipe capacity is 16 pages (i.e., 65,536 bytes in a system with a
    page size of 4096 bytes).</p>
    </blockquote>
    <h2 id="but-i-know-i-can-pipe-more-than-64kib">But I know I can pipe
    more than 64KiB!</h2>
    <p>So do I. It&#39;s pretty easy to test too:</p>
    <pre><code>$ node -e &#34;process.stdout.write(&#39;@&#39;.repeat(128 * 1024));&#34; | wc -c
  131072</code></pre>
    <p>...but if pipes are capped at 64KiB, how does this work?</p>
    <p>If you&#39;ve looked up the documentation for <code>printf</code> or
    <code>std::cout</code> or <code>process.stdout.write</code> enough
    times, you&#39;ll notice - and hopefully remember - that they all make
    some mention of buffering and blocking, which you usually just gloss
    over because it&#39;s entirely irrelevant to what you&#39;re doing.</p>
    <p>This, though, seems like something where that might be
    relevant!</p>
    <p>Let&#39;s look at the Node.js docs for <a href="https://nodejs.org/api/process.html#a-note-on-process-io"><code>process.stdout</code></a>:</p>
    <blockquote>
    <p><code>process.stdout</code> and <code>process.stderr</code>
    differ from other Node.js streams in important ways:</p>
    <p>[...]</p>
    <ol start="2" type="1">
    <li>Writes may be synchronous depending on what the stream is
    connected to and whether the system is Windows or POSIX:
    <ul>
    <li>Files: <em>synchronous</em> on Windows and POSIX</li>
    <li>TTYs (Terminals): <em>asynchronous</em> on Windows,
    <em>synchronous</em> on POSIX</li>
    <li>Pipes (and sockets): <em>synchronous</em> on Windows,
    <em>asynchronous</em> on POSIX</li>
    </ul></li>
    </ol>
    </blockquote>
    <p>Huh. So on POSIX, <code>process.stdout.write</code> is
    synchronous when writing to a file or terminal, but asynchronous
    when writing to a pipe? Interesting. Let&#39;s read on:</p>
    <blockquote>
    <p>These behaviors are partly for historical reasons, as changing
    them would create backward incompatibility, but they are also
    expected by some users.</p>
    <p>Synchronous writes avoid problems such as output written with
    <code>console.log()</code> or <code>console.error()</code> being
    unexpectedly interleaved, or not written at all if
    <code>process.exit()</code> is called before an asynchronous write
    completes. See <code>process.exit()</code> for more information.</p>
    <p><em><strong>Warning</strong></em>: Synchronous writes block the
    event loop until the write has completed. This can be near
    instantaneous in the case of output to a file, but under high system
    load, pipes that are not being read at the receiving end, or with
    slow terminals or file systems, it&#39;s possible for the event loop to
    be blocked often enough and long enough to have severe negative
    performance impacts. This may not be a problem when writing to an
    interactive terminal session, but consider this particularly careful
    when doing production logging to the process output streams.</p>
    </blockquote>
    <p>Oho. This looks promising: without even reading it, just looking
    at how much information there is, it&#39;s pretty clear that Here Be
    Dragons.</p>
    <p>Essentially, what this is saying is two things:</p>
    <ol type="1">
    <li><code>process.stdout.write(data)</code> will buffer data in
    Node.js and block if <code>stdout</code> is a file or terminal until
    <code>data</code> is written, but</li>
    <li>if <code>stdout</code> is a pipe, and the pipe is full,
    <code>process.stdout.write(data)</code> will immediately return
    <code>false</code> and will not block until <code>data</code> is
    written to the pipe.</li>
    </ol>
    <p>Frustratingly, you have to go to the docs about <a href="https://nodejs.org/api/stream.html#buffering">stream
    buffering</a> and <a href="https://nodejs.org/api/stream.html#writablewritechunk-encoding-callback"><code>writable.write</code></a>
    to actually understand this.</p>
    <h2 id="so-how-do-you-actually-trigger-this">So... how do you
    actually trigger this?</h2>
    <p>This took me a second to figure out.</p>
    <p>I thought <code>gpt-4o</code> and <code>o1-preview</code> would
    be able to do this pretty easily, but surprisingly not. They did
    both point out that to fix this, there&#39;s a <a href="https://nodejs.org/api/stream.html#event-drain"><code>drain</code>
    event</a> that you can subscribe to, so you can resume writing to
    <code>stdout</code> after <code>process.stdout</code> has filled up;
    but nothing that either suggested was repro&#39;ing this issue.</p>
    <p>So I went back and re-read the docs about
    <code>process.stdout</code>, and this bit jumped out at me:</p>
    <blockquote>
    <p>Synchronous writes avoid problems such as output [not being]
    written at all if <code>process.exit()</code> is called before an
    asynchronous write completes.</p>
    </blockquote>
    <p>Let&#39;s try that:</p>
    <pre><code>$ node -e &#34;process.stdout.write(&#39;@&#39;.repeat(128 * 1024)); process.exit(0);&#34; | wc -c
  65536</code></pre>
    <p>And what if we write to a file?</p>
    <pre><code>$ node -e &#34;process.stdout.write(&#39;@&#39;.repeat(128 * 1024)); process.exit(0);&#34; &gt;node-stdout-test.out &amp;&amp; wc -c node-stdout-test.out
  131072 node-stdout-test.out</code></pre>
    <p>Well, there we go.</p>
    <p>(Verified on both <code>darwin-arm64</code> and
    <code>linux-x86_64</code><a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>.)</p>
    
  </div></div>
  </body>
</html>
