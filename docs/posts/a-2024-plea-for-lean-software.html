<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://berthub.eu/articles/posts/a-2024-plea-for-lean-software/">Original</a>
    <h1>A 2024 Plea for Lean Software</h1>
    
    <div id="readability-page-1" class="page"><article lang="en">
  

  
  

  <div>
  <blockquote>
<p>This post is dedicated to the memory of <a href="https://ethz.ch/en/news-and-events/eth-news/news/2024/01/computer-pioneer-niklaus-wirth-has-died.html">Niklaus Wirth</a>, a computing pioneer who passed away January 1st. In 1995 he wrote an influential article called “<a href="https://cr.yp.to/bib/1995/wirth.pdf">A Plea for Lean Software</a>”, and in what follows, I try to make the same case nearly 30 years later, updated for today’s computing horrors.</p>
</blockquote>
<p>The really short version: the way we build/ship software these days is mostly ridiculous, leading to <a href="https://hub.docker.com/r/grafana/grafana">350MB packages that draw graphs</a>, and simple products importing <a href="https://github.com/SashenJayathilaka/Photo-Sharing-Application">1600 dependencies of unknown provenance</a>. Software security is dire, which is a function both of the quality of the code and the sheer amount of it. Many of us know the current situation is untenable. Many programmers (and their management) sadly haven’t ever experienced anything else. And for the rest of us, we rarely get the time to do a better job.</p>
<p>In this post I briefly go over the terrible state of software security, and then spend some time on why it is so bad. I also mention some regulatory/legislative things going on that we might use to make software quality a priority again. Finally, I talk about <a href="https://berthub.eu/articles/trifecta">an actual useful piece of software I wrote</a> as a reality check of the idea that one can still make <a href="https://berthub.eu/articles/posts/trifecta-technology">minimal and simple yet modern software</a>.</p>
<p>I hope that this post provides some mental and moral support for suffering programmers and technologists who want to improve things. <strong>It is not just you, we are not merely suffering from nostalgia: software really is very weird today</strong>.</p>
<center>
<p><img src="https://berthub.eu/articles/old-man.jpeg" alt=""/></p>
</center>
<h2 id="the-state-of-software">The state of software</h2>
<p>Without going all ‘<a href="https://knowyourmeme.com/memes/old-man-yells-at-cloud">old man (48) yells at cloud</a>’, let me restate some obvious things. The state of software is DIRE. If we only look at the past year, if you ran industry standard software like <a href="https://www.ncsc.gov.uk/news/exploitation-ivanti-vulnerabilities">Ivanti</a>, <a href="https://en.wikipedia.org/wiki/2023_MOVEit_data_breach">MoveIT</a>, <a href="https://www.bleepingcomputer.com/news/microsoft/russian-hackers-exploiting-outlook-bug-to-hijack-exchange-accounts/">Outlook</a>,  <a href="https://confluence.atlassian.com/security/cve-2023-22518-improper-authorization-vulnerability-in-confluence-data-center-and-server-1311473907.html">Confluence</a>, <a href="https://www.mandiant.com/resources/blog/barracuda-esg-exploited-globally">Barracuda Email Security Gateway</a>, <a href="https://www.mandiant.com/resources/blog/remediation-netscaler-adc-gateway-cve-2023-4966">Citrix NetScaler ADC and NetScaler Gateway</a>, chances are you got hacked. Even companies with near infinite resources (like Apple and Google) made <a href="https://www.schneier.com/blog/archives/2023/09/critical-vulnerability-in-libwebp-library.html">trivial “worst practice” security mistakes</a> which put <a href="https://www.bleepingcomputer.com/news/security/apple-zero-click-imessage-exploit-used-to-infect-iphones-with-spyware/">their customers in danger</a>. Yet we continue to rely on all these products.</p>
<p>Software is now (rightfully) considered so dangerous that we tell everyone not to run it themselves. Instead, you are supposed to leave that to an “as a service” provider, or perhaps to “the cloud”. Compare this to a hypothetical situation where cars are so likely to catch fire that the advice is not to drive a car yourself, but to leave that to professionals who are always accompanied by professional firefighters.</p>
<p>The assumption is then that “the cloud” is somehow able to turn insecure software into a secure service. Yet even the past year, we’ve learned that Microsoft’s <a href="https://thehackernews.com/2023/09/outlook-breach-microsoft-reveals-how.html">email platform was thoroughly hacked</a>, down to classified government email. There are also <a href="https://www.lastweekinaws.com/blog/azures-terrible-security-posture-comes-home-to-roost/">well-founded worries about the security of the Azure cloud</a>. Meanwhile, industry darling <a href="https://www.reuters.com/technology/cybersecurity/okta-says-hackers-stole-data-all-customer-support-users-cyber-breach-2023-11-29/">Okta, which provides <strong>LOG IN SOLUTIONS</strong> got comprehensively owned</a>. This was their second breach within a year. Also, there was a suspicious spate of Okta users getting hacked subsequently.</p>
<p>Clearly we need better software.</p>
<blockquote>
<p>The EU has launched three pieces of legislation to this extent (<a href="https://digital-strategy.ec.europa.eu/en/policies/nis2-directive">NIS2 for important services</a>, the Cyber Resilience Act for almost all commercial software and things with plugs, a revamped <a href="https://www.euractiv.com/section/digital/news/eu-updates-product-liability-regime-to-include-software-artificial-intelligence/">Product Liability Directive</a> that extends to software). Legislation is always hard, and it remains to be seen <a href="https://berthub.eu/articles/posts/eu-cra-what-does-it-mean-for-open-source/">if they got it right</a>. But that software security is terrible enough these days to warrant legislation seems obvious.</p>
</blockquote>
<h2 id="why-software-is-so-bad">Why software is so bad</h2>
<p>I briefly want to touch on incentives. The situation today is clearly working well for commercial operators. Making more secure software takes time and is a lot of work, and the current security incidents all don’t appear to be impacting the bottom line or stock prices. You can <a href="https://www.microsoft.com/en-us/research/publication/software-components-only-the-giants-survive/">speed up time to market by cutting corners</a>. So from an economic standpoint, what we see is what you would expect. Legislation could be very important in changing this equation.</p>
<p>The security of software depends on two factors - the <strong>density</strong> of security issues in the source code, and <strong>the sheer amount of exposed code</strong>. As the US defense community loved to point out in the 1980s, <a href="https://www.quora.com/Who-said-Quantity-has-a-quality-all-its-own">quantity has a quality all of its own</a>. The reverse applies to software - the more you have of it, the more risks you run.</p>
<p>As a case in point, Apple iPhone users got repeatedly hacked over many years because of the huge <em>attack surface</em> exposed by iMessage. It is possible to send an unsolicited iMessage to an Apple user, and the phone will then immediately process that message so it can preview it. The problem is that Apple in its wisdom decided that such unsolicited messages needed to support a vast array of image formats, accidentally <a href="https://googleprojectzero.blogspot.com/2021/12/a-deep-dive-into-nso-zero-click.html">including PDFs, including PDFs with weird embedded compressed fonts using an ancient format that effectively included a programming language</a>.</p>
<p>In this way, attackers were able to benefit from security bugs in probably millions of lines of code. You don’t need a high bug density to find an exploitable hole in millions of lines of code. And <a href="https://www.europarl.europa.eu/meetdocs/2014_2019/plmrep/COMMITTEES/PEGA/DV/2023/05-08/REPORTcompromises_EN.pdf">nation state suppliers have found lots</a>.</p>
<p>The weird thing is that Apple could have easily prevented this situation by restricting previews to a far smaller range of image formats. It is their platform, they don’t need to interoperate with anything. They could have made sending devices convert previews to a single known good image format.</p>
<p>But they didn’t. And to make matters worse, in 2023 they decided to add support for a new image format, which apparently was so important it had to be added outside of the security sandbox. <a href="https://news.ycombinator.com/item?id=37600852">This was again exploited</a>.</p>
<p>Apple could have saved themselves an enormous amount of pain simply by <a href="https://github.com/berthubert/sbox#sbox">exposing fewer lines of code</a> to attackers. Incidentally, the EU Cyber Resilience Act <a href="https://berthub.eu/articles/posts/eu-cra-secure-coding-solution/">explicitly tells vendors to minimise the attack surface</a>.</p>
<p>Please do note that Apple is (by far) not the worst offender in this field. But it is a widely respected and well resourced company that usually thinks through what they do. And even they got it wrong by needlessly shipping and exposing too much code.</p>
<h2 id="could-we-not-write-better-code">Could we not write better code?</h2>
<p>It is not just the <em>amount</em> of code that is worrying. It is also the quality, or put another way, the density of bugs. There are many interesting things happening on this front, like the use of <a href="https://www.nsa.gov/Press-Room/Press-Releases-Statements/Press-Release-View/Article/3608324/us-and-international-partners-issue-recommendations-to-secure-software-products/">memory safe languages</a> like <a href="https://www.rust-lang.org/">Rust</a>. Other languages are <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">also upping their security game</a>. <a href="https://en.wikipedia.org/wiki/Fuzzing">Fuzzers</a> are also getting ever more advanced.</p>
<p>But many security problems are not so much bad code but more bad logic. A recent example is a super duper security issue in GitLab where accounts could be <a href="https://berthub.eu/articles/pwned-gitlab.png">trivially taken over</a> through the <a href="https://about.gitlab.com/releases/2024/01/11/critical-security-release-gitlab-16-7-2-released/#account-takeover-via-password-reset-without-user-interactions">‘forgot password’ functionality</a>. Similarly, the Barracuda exploit consisted of them relying on a third party library <a href="https://www.cvedetails.com/cve/CVE-2023-7101/">that would actually execute code in scanned Excel sheets</a>. The recent Ivanti exploit is <a href="https://attackerkb.com/topics/AdUh6by52K/cve-2023-46805/rapid7-analysis">similarly logic related</a> (and extremely embarrassing).</p>
<p>Less progress is being made on improving the <a href="https://labs.watchtowr.com/the-second-wednesday-of-the-first-month-of-every-quarter-juniper-0day-revisited/">logic bugs situation</a> than on the code security front.</p>
<p>I’m all for writing more secure code, but as a first step, let’s look what code we are actually shipping. And do we even know?</p>
<h2 id="the-state-of-shipping-software">The state of shipping software</h2>
<p>I mean, wow, software has gotten HUGE. It is exceptionally painful to read <a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a>’s article <a href="https://cr.yp.to/bib/1995/wirth.pdf">A Plea for Lean Software</a> from 1995, which laments that 1995 era software needed whole megabytes, and then goes on to describe the <a href="https://en.wikipedia.org/wiki/Oberon_(operating_system)">Oberon Operating System</a> which he built which needed only 200KB, including an editor and a compiler. There are now likely projects that have more than 200KB of YAML alone.</p>
<p>A typical app is now built on <a href="https://www.electronjs.org/">Electron JS</a> which incorporates both Chromium (“Chrome”) and Node.JS. From what I read, I estimate this entails at least 50 million lines of code if you include dependencies. Perhaps more. The app meanwhile likely pulls in hundreds or thousands of Node modules. Many frameworks used will also, by default, snitch on your users to advertisers and other data brokers. Incidentally, dependencies pull in further dependencies and exactly what gets included in the build can change on a daily basis, and no one really knows.</p>
<p>If this app controls anything in your house, it will also connect to a software stack over at Amazon, probably also powered by Node.JS, again pulling in many dependencies. And as usual, no one is even sure what it pulls in exactly as this changes from day to day.</p>
<p>But wait, there’s more. We used to ship software as the output of a compiler, or perhaps as a bunch of files to be interpreted. Such software then had to be <em>installed</em> and <em>configured</em> to work right. Getting your code packaged to ship like this is a lot of work. But it was good work since it forced people to think about what was in their “package”. This software package would then integrate with an operating system and with local services, based on the configuration.</p>
<p>Since the software ran on a fundamentally different computer then it was developed on, people really had to know what they shipped and think it through. And sometimes it didn’t work, leading to the joke where a developer tells the operations people “Well, it works on my system”, and the retort “back up your email, we’re taking your laptop in production!”.</p>
<p>This used to be a joke, but these days we often ship software as (Docker or other) containers, and this frequently entails effectively shipping a complete computer image. Including all the stuff that happened to be included in the build. This again vastly expands the amount of code being deployed. Note that you can do good things with Docker (see below), but there are a lot of 350+MB images on the <a href="https://hub.docker.com/explore">Docker Hub</a>.</p>
<p>But, all in all, we are likely looking at 50 million+ lines of code active to open a garage door, running several operating system images on multiple servers.</p>
<p>Now, even if all the included dependencies are golden, are we sure that their security updates are making it to your garage door opener app? I wonder how many Electron apps are still shipping with the vulnerable <a href="https://www.schneier.com/blog/archives/2023/09/critical-vulnerability-in-libwebp-library.html">libwebp version</a> in there. We don’t even know.</p>
<p>But even worse, it is a known fact that all these dependencies are not golden. The Node.js ecosystem has a <a href="https://thehackernews.com/2023/02/researchers-hijack-popular-npm-package.html">comical history</a> of repositories <a href="https://snyk.io/blog/npm-security-preventing-supply-chain-attacks/">being taken over</a>, hijacked or resurrected under the same name by someone else, someone with <a href="https://www.theregister.com/2023/06/19/npm_s3_buckets_malware/">dire plans for your security</a>. <a href="https://www.theregister.com/2023/06/02/novel_pypi_attack_reversinglabs/">PyPI</a> has suffered from <a href="https://www.theregister.com/2023/01/04/pypi_pytorch_dependency_attack/">similar problems</a>. Dependencies always need scrutiny, but no one can reasonably be expected to <a href="https://medium.com/graph-commons/analyzing-the-npm-dependency-network-e2cf318c1d0d">check thousands of them frequently</a>. But we prefer not to think about this and type ’npm install’ and observe 1600 dependencies being pulled.</p>
<p>Note that one should also not overshoot and needlessly reimplement everything yourself to prevent dependencies. There are very good dependencies that <a href="https://sqlite.org">likely are more secure</a> than what you <a href="https://en.wikipedia.org/wiki/Lightning_Memory-Mapped_Database">could type in on your own</a>.</p>
<p>Rounding off a bit, I posit that the world is 1) shipping far too much code 2) where we don’t even know what we ship and 3) we aren’t looking hard enough (or at all) at what we know we ship.</p>
<h2 id="trifecta">Trifecta</h2>
<p>Writing has been called <a href="https://fs.blog/writing-to-think/">the process by which you find out you don’t know what you are talking about</a>. Actually doing stuff meanwhile is the process by which find out you also did not know what you were writing about.</p>
<p>In a very small re-enactment of Wirth’s Oberon Project, I too wrote some code to prove a point, but also to reassure myself I still know what I am talking and writing about. Can you still make useful and modern software “the old way”?</p>
<p>Trifecta is <a href="https://berthub.eu/articles/trifecta/">actual stand-alone software</a> that you can use to paste and drag images to, for easy sharing. It has pained me for years that I had to use <a href="https://imgur.com">imgur</a> for this purpose. Not only does imgur install lots of cookies and trackers on my browser, I also force these trackers onto the people that view the images that I share.</p>
<p>If you want to self-host a service like this, you also don’t want to get hacked. Most image sharing solutions I found that you could run yourself are based on huge frameworks that I don’t trust too much (given the dependency reasons outlined above). And perhaps that is my background, <a href="https://berthub.eu/articles/bio">I used to work with a lot of classified data, and I’ve been very exposed to what the very best state sponsored hackers can do</a>.</p>
<p>So, also to make a point, I decided to create a minimalistic but also useful image sharing solution that I could trust. And more important, that other people could trust as well, because you can check out the whole code within a few hours. It consists of <a href="https://berthub.eu/articles/posts/trifecta-technology">1600 lines of new source code</a>, plus around 5 important dependencies (line number sizes are included in the linked article).</p>
<p>And this is what you then end up with:</p>
<p><img src="https://berthub.eu/trifecta/i/qT5j9y6LOF4" alt=""/></p>
<p>To contrast, <a href="https://github.com/CaramelFur/Picsur/pkgs/container/picsur">one other image sharing solution</a> ships as a 311MB Docker image, although admittedly it looks better and has some more features. But not 308MB worth of them. Another comparison is <a href="https://github.com/SashenJayathilaka/Photo-Sharing-Application">this Node based picture sharing solution</a> which clocks in at 1600 dependencies, apparently totaling 4+ million lines of JavaScript.</p>
<p>Trifecta is a self-contained solution with just a handful of dependencies that gives you a feature complete image sharing site:</p>
<ul>
<li>Full user and session management</li>
<li>Drag and drop multiple images at the same time</li>
<li>Posts can contain multiple images
<ul>
<li>Each post has an optional title, each image an optional caption</li>
<li>Posts can be public, or time limited public</li>
</ul>
</li>
<li>Passwordless accounts are possible (log in using a temporary sign-in email link)
<ul>
<li>Lost password email flow</li>
</ul>
</li>
<li>One cookie, locked tight to the site</li>
<li>Comes as source, binary, <a href="https://hub.docker.com/r/berthubert/trifecta">docker</a>, or .deb or .rpm</li>
<li><a href="https://github.com/berthubert/trifecta">Source code</a> small enough you could read all of it in a day</li>
<li>Source code <a href="https://github.com/berthubert/trifecta/blob/main/support.cc">also reusable for other web frameworks</a></li>
</ul>
<p>Note that this is not intended as a public site where random people can share images, as this does not tend to end well. It is however very suitable for company or personal use. You can read more about the project <a href="https://berthub.eu/articles/trifecta">here</a>, and there is also <a href="https://berthub.eu/articles/posts/trifecta-technology">a page about the technology used to deliver such a tiny self-contained solution</a>.</p>
<h2 id="response">Response</h2>
<p>This has been rather interesting. As noted earlier in this post, we have gone quite mad that we need 50+ million lines of code for a garage door opener. That we find this normal must come with some pathology.</p>
<blockquote>
<p>Some years ago I did a talk at a local university on cybersecurity, titled “<a href="https://berthub.eu/cyber-mad/Cyber%20and%20information%20security.pdf">Have we all gone mad</a>”. It is still worth reading today since we have gone quite mad collectively.</p>
</blockquote>
<p>The most common response to Trifecta so far has been that I should use a whole bag of AWS services to deploy it. This is an exceedingly odd response to a project with the clearly stated goal of providing standalone software that does not rely on external services. I’m not sure what is going on here.</p>
<p>Another reaction has been that I treat Docker unfairly, and that you could definitely use containers for good. And I agree wholeheartedly. But I also look at what people are actually doing (also with other forms of containers/VMs), and that’s not so great.</p>
<p>I want to end this post with some observations from <a href="https://cr.yp.to/bib/1995/wirth.pdf">Niklaus Wirth’s 1995 paper</a>.</p>
<ul>
<li>“To Some, complexity equals power. (…) Increasingly, people seem to <strong>misinterpret complexity as sophistication</strong>, which is baffling - the incomprehensible should cause suspicion rather than admiration.”</li>
</ul>
<p>I’ve similarly observed that some people prefer complicated systems. As <a href="https://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a> noted long ago, “There are two methods in software design. One is to make the program so simple, there are obviously no errors. The other is to make it so complicated, there are no obvious errors”. If you can’t do the first variant, the second way starts looking awfully attractive perhaps.</p>
<ul>
<li>“Time pressure is probably the foremost reason behind the emergence of bulky software. The time pressure that designers endure discourages careful planning. It also discourages improving acceptable solutions; instead, it encourages quickly conceived software additions and corrections. <strong>Time pressure gradually corrupts an engineer’s standard of quality and perfection. It has a detrimental effect on people as well as products</strong>.”</li>
</ul>
<p>Why spend weeks paring down your software when you can also ship a whole pre-installed operating system image that just works?</p>
<ul>
<li>“The plague of software explosion is not a ’law of nature’. It is avoidable, and it is the software engineer’s task to curtail it”</li>
</ul>
<p>Now, I once studied physics, and I’m not so sure if an increase in complexity is not a law of nature. However, I do know that decreasing entropy will always cost energy. And if this is indeed on the shoulders of software people, we should perhaps demand more time for it.</p>
<h2 id="summarising">Summarising</h2>
<p>The world ships too much code, most of it by third parties, sometimes unintended, most of it uninspected. Because of this there is a huge <em>attack surface</em> full of mediocre code. Efforts are ongoing to improve the quality of code itself, but many exploits are due to logic bugs, and less progress has been made scanning for those. Meanwhile, great strides could be made by paring down just how much code we expose to the world. This will increase time to market for products, but legislation is around the corner that should force vendors to take security more seriously.</p>
<p>Trifecta is, like Wirth’s Oberon Project mentioned above, meant as a verification that you can still deliver a lot of functionality based on a limited amount of code and dependencies.</p>
<p>With effort and legislation, maybe the future could again bring sub-50 million line garage door openers. Let’s try to make it happen.</p>

</div>

  



</article></div>
  </body>
</html>
