<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danluu.com/cli-complexity/">Original</a>
    <h1>The growth of command line options, 1979-Present (2020)</h1>
    
    <div id="readability-page-1" class="page"><i><b><a href="https://patreon.com/danluu">I&#39;m trying some experimental tiers on Patreon</a></b> to see if I can get to <a href="https://twitter.com/danluu/status/1456346963691991041">substack-like levels of financial support for this blog without moving to substack</a>!</i>
<hr/>
<strong>The growth of command line options, 1979-Present</strong>


<p><a href="https://www.xkcd.com/1795/">My hobby</a>: opening up <a href="https://danluu.com/mcilroy-unix/">McIlroy’s UNIX philosophy</a> on one monitor while reading manpages on the other.</p>

<p>The first of McIlroy&#39;s dicta is often paraphrased as &#34;do one thing and do it well&#34;, which is <a href="https://danluu.com/mcilroy-unix/">shortened from</a> &#34;Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new &#39;features.&#39;&#34;</p>

<p>McIlroy&#39;s example of this dictum is:</p>

<blockquote>
<p>Surprising to outsiders is the fact that UNIX compilers produce no listings: printing can be done better and more flexibly by a separate program.</p>
</blockquote>

<p>If you open up a manpage for <code>ls</code> on mac, you’ll see that it starts with</p>

<pre><code>ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1] [file ...]
</code></pre>

<p>That is, the one-letter flags to <code>ls</code> include every lowercase letter except for <code>{jvyz}</code>, 14 uppercase letters, plus <code>@</code> and <code>1</code>. That’s 22 + 14 + 2 = 38 single-character options alone.</p>

<p>On ubuntu 17, if you read the manpage for coreutils <code>ls</code>, you don’t get a nice summary of options, but you’ll see that <code>ls</code> has 58 options (including <code>--help</code> and <code>--version</code>).</p>

<p>To see if <code>ls</code> is an aberration or if it&#39;s normal to have commands that do this much stuff, we can look at some common commands, sorted by frequency of use.</p>

<table>
<tbody><tr>
<th>command</th><th>1979</th><th>1996</th><th>2015</th><th>2017</th></tr>
<tr>
<td>ls</td><td>11</td><td><SPAN color="white">42</SPAN></td><td><SPAN color="white">58</SPAN></td><td><SPAN color="white">58</SPAN></td></tr>
<tr>
<td>rm</td><td>3</td><td>7</td><td>11</td><td>12</td></tr>
<tr>
<td>mkdir</td><td>0</td><td>4</td><td>6</td><td>7</td></tr>
<tr>
<td>mv</td><td>0</td><td>9</td><td>13</td><td>14</td></tr>
<tr>
<td>cp</td><td>0</td><td>18</td><td><SPAN color="white">30</SPAN></td><td><SPAN color="white">32</SPAN></td></tr>
<tr>
<td>cat</td><td>1</td><td>12</td><td>12</td><td>12</td></tr>
<tr>
<td>pwd</td><td>0</td><td>2</td><td>4</td><td>4</td></tr>
<tr>
<td>chmod</td><td>0</td><td>6</td><td>9</td><td>9</td></tr>
<tr>
<td>echo</td><td>1</td><td>4</td><td>5</td><td>5</td></tr>
<tr>
<td>man</td><td>5</td><td>16</td><td><SPAN color="white">39</SPAN></td><td><SPAN color="white">40</SPAN></td></tr>
<tr>
<td>which</td><td></td><td>0</td><td>1</td><td>1</td></tr>
<tr>
<td>sudo</td><td></td><td>0</td><td>23</td><td>25</td></tr>
<tr>
<td>tar</td><td>12</td><td><SPAN color="white">53</SPAN></td><td><SPAN color="white">134</SPAN></td><td><SPAN color="white">139</SPAN></td></tr>
<tr>
<td>touch</td><td>1</td><td>9</td><td>11</td><td>11</td></tr>
<tr>
<td>clear</td><td></td><td>0</td><td>0</td><td>0</td></tr>
<tr>
<td>find</td><td>14</td><td><SPAN color="white">57</SPAN></td><td><SPAN color="white">82</SPAN></td><td><SPAN color="white">82</SPAN></td></tr>
<tr>
<td>ln</td><td>0</td><td>11</td><td>15</td><td>16</td></tr>
<tr>
<td>ps</td><td>4</td><td>22</td><td><SPAN color="white">85</SPAN></td><td><SPAN color="white">85</SPAN></td></tr>
<tr>
<td>ping</td><td></td><td>12</td><td>12</td><td><SPAN color="white">29</SPAN></td></tr>
<tr>
<td>kill</td><td>1</td><td>3</td><td>3</td><td>3</td></tr>
<tr>
<td>ifconfig</td><td></td><td>16</td><td>25</td><td>25</td></tr>
<tr>
<td>chown</td><td>0</td><td>6</td><td>15</td><td>15</td></tr>
<tr>
<td>grep</td><td>11</td><td>22</td><td><SPAN color="white">45</SPAN></td><td><SPAN color="white">45</SPAN></td></tr>
<tr>
<td>tail</td><td>1</td><td>7</td><td>12</td><td>13</td></tr>
<tr>
<td>df</td><td>0</td><td>10</td><td>17</td><td>18</td></tr>
<tr>
<td>top</td><td></td><td>6</td><td>12</td><td>14</td></tr>
</tbody></table>

<p>This table has the number of command line options for various commands for v7 Unix (1979), slackware 3.1 (1996), ubuntu 12 (2015), and ubuntu 17 (2017). Cells are darker and blue-er when they have more options (log scale) and are greyed out if no command was found.</p>

<p>We can see that the number of command line options has dramatically increased over time; entries tend to get darker going to the right (more options) and there are no cases where entries get lighter (fewer options). </p>

<p><a href="https://archive.org/details/DougMcIlroy_AncestryOfLinux_DLSLUG">McIlroy has long decried the increase in the number of options, size, and general functionality of commands</a>:</p>

<blockquote>
<p>Everything was small and my heart sinks for Linux when I see the size [inaudible]. The same utilities that used to fit in eight k[ilobytes] are a meg now. And the manual page, which used to really fit on, which used to really be a manual <em>page</em>, is now a small volume with a thousand options... We used to sit around in the UNIX room saying &#34;what can we throw out? Why is there this option?&#34; It&#39;s usually, it&#39;s often because there&#39;s some deficiency in the basic design — you didn&#39;t really hit the right design point. Instead of putting in an option, figure out why, what was forcing you to add that option. This viewpoint, which was imposed partly because there was very small hardware ... has been lost and we&#39;re not better off for it.</p>
</blockquote>

<p>Ironically, one of the reasons for the rise in the number of command line options is another McIlroy dictum, &#34;Write programs to handle text streams, because that is a universal interface&#34; (see <code>ls</code> for one example of this).</p>

<p>If structured data or objects were passed around, formatting could be left to a final formatting pass. But, with plain text, the formatting and the content are intermingled; because formatting can only be done by parsing the content out, it&#39;s common for commands to add formatting options for convenience. Alternately, formatting can be done when the user leverages their knowledge of the structure of the data and encodes that knowledge into arguments to <code>cut</code>, <code>awk</code>, <code>sed</code>, etc. (also using their knowledge of how those programs handle formatting; it&#39;s different for different programs and the user is expected to, for example, <a href="https://unix.stackexchange.com/a/132322/261842">know how <code>cut -f4</code> is different from <code>awk &#39;{ print $4 }&#39;</code></a>). That&#39;s a lot more hassle than passing in one or two arguments to the last command in a sequence and it pushes the complexity from the tool to the user.</p>

<p>People sometimes say that they don&#39;t want to support structured data because they&#39;d have to support multiple formats to make a universal tool, but they already have to support multiple formats to make a universal tool. Some standard commands can&#39;t read output from other commands because they use different formats, <code>wc -w</code> doesn&#39;t handle Unicode correctly, etc. Saying that &#34;text&#34; is a universal format is like saying that &#34;binary&#34; is a universal format.</p>

<p>I&#39;ve heard people say that there isn&#39;t really any alternative to this kind of complexity for command line tools, but people who say that have never really tried the alternative, something like PowerShell. I have plenty of complaints about PowerShell, but passing structured data around and easily being able to operate on structured data without having to hold metadata information in my head so that I can pass the appropriate metadata to the right command line tools at that right places the pipeline isn&#39;t among my complaints.</p>

<p>The sleight of hand that&#39;s happening when someone says that we can keep software simple and compatible by making everything handle text is the pretense that text data doesn&#39;t have a structure that needs to be parsed. In some cases, we can just think of everything as a single space separated line, or maybe a table with some row and column separators that we specify (<a href="https://unix.stackexchange.com/a/132322/261842">with some behavior that isn&#39;t consistent across tools, of course</a>). That adds some hassle when it works, and then there are the cases where serializing data to a flat text format adds considerable complexity since the structure of data means that simple flattening requires significant parsing work to re-ingest the data in a meaningful way.</p>

<p>Another reason commands now have more options is that people have added convenience flags for functionality that could have been done by cobbling together a series of commands. These go all the way back to v7 unix, where <code>ls</code> has an option to reverse the sort order (which could have been done by passing the output to something like <code>tac</code> had they written <code>tac</code> instead of adding a special-case reverse option).</p>

<p>Over time, more convenience options have been added. For example, to pick a command that originally has zero options, <code>mv</code> can move <em>and</em> create a backup (three options; two are different ways to specify a backup, one of which takes an argument and the other of which takes zero explicit arguments and reads an implicit argument from the <code>VERSION_CONTROL</code> environment variable; one option allows overriding the default backup suffix). <code>mv</code> now also has options to never overwrite and to only overwrite if the file is newer.</p>

<p><code>mkdir</code> is another program that used to have no options where, excluding security things for SELinux or SMACK as well as help and version options, the added options are convenience flags: setting the permissions of the new directory and making parent directories if they don&#39;t exist.</p>

<p>If we look at <code>tail</code>, which originally had one option (<code>-number</code>, telling <code>tail</code> where to start), it&#39;s added both formatting and convenience options For formatting, it has <code>-z</code>, which makes the line delimiter <code>null</code> instead of a newline. Some examples of convenience options are <code>-f</code> to print when there are new changes, <code>-s</code> to set the sleep interval between checking for <code>-f</code> changes, <code>--retry</code> to retry if the file isn&#39;t accessible.</p>

<p>McIlroy says &#34;we&#39;re not better off&#34; for having added all of these options but I&#39;m better off. I&#39;ve never used some of the options we&#39;ve discussed and only rarely use others, but that&#39;s the beauty of command line options — unlike with a GUI, adding these options doesn&#39;t clutter up the interface. The manpage can get cluttered, but in the age of google and stackoverflow, I suspect many people just search for a solution to what they&#39;re trying to do without reading the manpage anyway.</p>

<p>This isn&#39;t to say there&#39;s no cost to adding options — more options means more maintenance burden, but that&#39;s a cost that maintainers pay to benefit users, which isn&#39;t obviously unreasonable considering the ratio of maintainers to users. This is analogous to Gary Bernhardt&#39;s comment that it&#39;s reasonable to practice a talk fifty times since, if there&#39;s a three hundred person audience, the ratio of time spent watching to the talk to time spent practicing will still only be 1:6. In general, this ratio will be even more extreme with commonly used command line tools.</p>

<p>Someone might argue that all these extra options create a burden for users. That&#39;s not exactly wrong, but that complexity burden was always going to be there, it&#39;s just a question of where the burden was going to lie. If you think of the set of command line tools along with a shell as forming a language, a language where anyone can write a new method and it effectively gets added to the standard library if it becomes popular, where standards are defined by dicta like &#34;write programs to handle text streams, because that is a universal interface&#34;, the language was always going to turn into a write-only incoherent mess when taken as a whole. At least with tools that bundle up more functionality and options than is UNIX-y users can replace a gigantic set of wildly inconsistent tools with a merely large set of tools that, while inconsistent with each other, may have some internal consistency.</p>

<p>McIlroy implies that the problem is that people didn&#39;t think hard enough, the old school UNIX mavens would have sat down in the same room and thought longer and harder until they came up with a set of consistent tools that has &#34;unusual simplicity&#34;. But that was never going to scale, the philosophy made the mess we&#39;re in inevitable. It&#39;s not a matter of not thinking longer or harder; it&#39;s a matter of having a philosophy that cannot scale unless you have a relatively small team with a shared cultural understanding, able to to sit down in the same room.</p>

<p>If anyone can write a tool and the main instruction comes from &#34;the unix philosophy&#34;, people will have different opinions about what &#34;<a href="https://twitter.com/hillelogram/status/1174714902151421952">simplicity</a>&#34; or &#34;doing one thing&#34; means, what the right way to do things is, and inconsistency will bloom, resulting in the kind of complexity you get when dealing with a wildly inconsistent language, like PHP. People make fun of PHP and javascript for having all sorts of warts and weird inconsistencies, but as a language and a standard library, any commonly used shell plus the collection of widely used *nix tools taken together is much worse and contains much more accidental complexity due to inconsistency even within a single Linux distro and there&#39;s no other way it could have turned out. If you compare across Linux distros, BSDs, Solaris, AIX, etc.,  the amount of accidental complexity that users have to hold in their heads when switching systems dwarfs PHP or javascript&#39;s incoherence. The most widely mocked programming languages are paragons of great design by comparison.</p>

<p><a id="maven"></a>To be clear, I&#39;m not saying that I or anyone else could have done better with the knowledge available in the 70s in terms of making a system that was practically useful at the time that would be elegant today. It&#39;s easy to look back and find issues with the benefit of hindsight. What I disagree with are comments from Unix mavens speaking today; comments like McIlroy&#39;s, which imply that we just forgot or don&#39;t understand the value of simplicity, or <a href="https://twitter.com/danluu/status/885214004649615360">Ken Thompson saying that C is as safe a language as any and if we don&#39;t want bugs we should just write bug-free code</a>. These kinds of comments imply that there&#39;s not much to learn from hindsight; in the 70s, we were building systems as effectively as anyone can today; five decades of collective experience, tens of millions of person-years, have taught us nothing; if we just go back to building systems like the original Unix mavens did, all will be well. I respectfully disagree.</p>

<h3 id="appendix-memory">Appendix: memory</h3>

<p>Although addressing McIlroy&#39;s complaints about binary size bloat is a bit out of scope for this, I will note that, in 2017, I bought a Chromebook that had 16GB of RAM for $300. A 1 meg binary might have been a serious problem in 1979, when a standard Apple II had 4KB. An Apple II cost $1298 in 1979 dollars, or $4612 in 2020 dollars. You can get a low end Chromebook that costs less than 1/15th as much which has four million times more memory. Complaining that memory usage grew by a factor of one thousand when a (portable!) machine that&#39;s more than an order of magnitude cheaper has four million times more memory seems a bit ridiculous.</p>

<p>I prefer slimmer software, which is why I optimized my home page down to two packets (it would be a single packet if my CDN served high-level brotli), but that&#39;s purely an aesthetic preference, something I do for fun. The bottleneck for command line tools isn&#39;t memory usage and spending time optimizing the memory footprint of a tool that takes one meg is like getting a homepage down to a single packet. Perhaps a fun hobby, but not something that anyone should prescribe.</p>

<h3 id="methodology-for-table">Methodology for table</h3>

<p>Command frequencies were sourced from public command history files on github, not necessarily representative of your personal usage. Only &#34;simple&#34; commands were kept, which ruled out things like curl, git, gcc (which has &gt; 1000 options), and wget. What&#39;s considered simple is arbitrary. <a href="https://en.wikipedia.org/wiki/Shell_builtin">Shell builtins</a>, like <code>cd</code> weren&#39;t included.</p>

<p>Repeated options aren&#39;t counted as separate options. For example, <code>git blame -C</code>, <code>git blame -C -C</code>, and <code>git blame -C -C -C</code> have different behavior, but these would all be counted as a single argument even though <code>-C -C</code> is effectively a different argument from <code>-C</code>.</p>

<p>The table counts sub-options as a single option. For example, <code>ls</code> has the following:</p>

<blockquote>
<p>--format=WORD
across -x, commas -m,  horizontal  -x,  long  -l,  single-column  -1,  verbose  -l, vertical -C</p>
</blockquote>

<p>Even though there are seven format options, this is considered to be only one option.</p>

<p>Options that are explicitly listed as not doing anything are still counted as options, e.g., <code>ls -g</code>, which reads <code>Ignored; for Unix compatibility.</code> is counted as an option.</p>

<p>Multiple versions of the same option are also considered to be one option. For example, with <code>ls</code>, <code>-A</code> and <code>--almost-all</code> are counted as a single option.</p>

<p>In cases where the manpage says an option is supposed to exist, but doesn&#39;t, the option isn&#39;t counted. For example, the v7 <code>mv</code> manpage says</p>

<blockquote>
<p>BUGS</p>

<p>If file1 and file2 lie on different file systems, mv must copy the file and delete the original.  In this case the owner name becomes that of the copying process and any linking relationship with other files is lost.</p>

<p>Mv should take <strong>-f</strong> flag, like rm, to suppress the question if the target exists and is not writable.</p>
</blockquote>

<p><code>-f</code> isn&#39;t counted as a flag in the table because the option doesn&#39;t actually exist.</p>

<p>The latest year in the table is 2017 because I wrote the first draft for this post in 2017 and didn&#39;t get around to cleaning it up until 2020.</p>



<p><a href="https://blog.plover.com/Unix/tools.html">mjd on the Unix philosophy, with an aside into the mess of /usr/bin/time vs. built-in time</a>.</p>

<p><a href="https://groups.google.com/forum/m/#!topic/rec.humor.funny/Q-HG4LpW564">mjd making a joke about the proliferation of command line options in 1991</a>.</p>

<p>On HN:</p>

<blockquote>
<blockquote>
<p>p1mrx:</p>

<p><a href="https://unix.stackexchange.com/q/112125/261842">It&#39;s strange that ls has grown to 58 options, but still can&#39;t output \0-terminated filenames</a></p>

<p>As an exercise, try to sort a directory by size or date, and pass the result to xargs, while supporting any valid filename. I eventually just gave up and made my script ignore any filenames containing \n.</p>
</blockquote>

<p>whelming_wave:</p>

<p>Here you go: sort all files in the current directory by modification time, whitespace-in-filenames-safe.
The <code>printf (od -&gt; sed)&#39; construction converts back out of null-separated characters into newline-separated, though feel free to replace that with anything accepting null-separated input. Granted,</code>sort --zero-terminated&#39; is a GNU extension and kinda cheating, but it&#39;s even available on macOS so it&#39;s probably fine.</p>
</blockquote>

<pre><code>      printf &#39;%b&#39; $(
        find . -maxdepth 1 -exec sh -c &#39;
          printf &#39;\&#39;&#39;%s %s\0&#39;\&#39;&#39; &#34;$(stat -f &#39;\&#39;&#39;%m&#39;\&#39;&#39; &#34;$1&#34;)&#34; &#34;$1&#34;
        &#39; sh {} \; | \
        sort --zero-terminated | \
        od -v -b | \
        sed &#39;s/^[^ ]*//
      s/ *$//
      s/  */ \\/g
      s/\\000/\\012/g&#39;)
</code></pre>

<blockquote>
<p>If you&#39;re running this under zsh, you&#39;ll need to prefix it with `command&#39; to use the system executable: zsh&#39;s builtin printf doesn&#39;t support printing octal escape codes for normally printable characters, and you may have to assign the output to a variable and explicitly word-split it.</p>

<p>This is all POSIX as far as I know, except for the sort.</p>
</blockquote>

<p><a href="https://en.wikipedia.org/wiki/The_Unix-Haters_Handbook">The Unix haters handbook</a>.</p>

<p><a href="http://www.oilshell.org/blog/2018/01/28.html">Why create a new shell</a>?</p>

<p><small>
Thanks to Leah Hanson, Hillel Wayne, Wesley Aptekar-Cassels, Mark Jason Dominus, Travis Downs, and Yuri Vishnevsky for comments/corrections/discussion.
</small></p>





</div>
  </body>
</html>
