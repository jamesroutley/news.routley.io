<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://home.expurple.me/posts/why-use-structured-errors-in-rust-applications/">Original</a>
    <h1>Why Use Structured Errors in Rust Applications?</h1>
    
    <div id="readability-page-1" class="page"><div><header></header><main><p>TL;DR I prefer <code>thiserror</code> enums over <code>anyhow</code>, even for application code that
simply propagates errors. Custom error types require additional effort, but make
the code easier to reason about and maintain down the road.</p><h2 id="using-thiserror-for-libraries-and-anyhow-for-applications">“Using <code>thiserror</code> for libraries and <code>anyhow</code> for applications”
</h2><p>In 2025, this is the conventional error handling practice in the Rust community.
Let’s quickly recap the main ideas:</p><ul><li>Libraries should expose error types that provide as much information as
possible. This allows the callers to detect and handle specific error
conditions. A specific error code is more useful than “Oops, something went
wrong”. Structured <sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> error types facilitate statically-checked
pattern matching, which is more reliable than runtime reflection, downcasting,
or regex-matching an error message. They also provide nice autogenerated docs,
which is very important for libraries.</li><li>Unfortunately, propagating structured errors in Rust is associated with the
boilerplate of manually writing out wrapper error types, their <code>impl</code>s and
conversions. <sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></li><li><a href="https://github.com/dtolnay/thiserror" target="_blank"><code>thiserror</code></a>
removes the boilerplate
around implementing
<a href="https://doc.rust-lang.org/std/fmt/trait.Display.html" target="_blank"><code>Display</code></a>
,
<a href="https://doc.rust-lang.org/std/error/trait.Error.html" target="_blank"><code>Error</code></a>
and
<a href="https://doc.rust-lang.org/std/convert/trait.From.html" target="_blank"><code>From</code></a>
for your error
types. Using it is a no-brainer for libraries that can “afford” proc macro
dependencies. Although, you still need to define and annotate the wrapper
types themselves, which there are usually plenty.</li><li>End applications often don’t care about the specific cause of an error and
simply propagate errors up the stack until they reach some kind of a
“catch-all” point. For this use case, even <code>thiserror</code>-assisted error types
are often considered too cumbersome and not worth it.</li><li>Instead, application developers commonly use
<a href="https://github.com/dtolnay/anyhow" target="_blank"><code>anyhow</code></a>
. It provides a “universal”
dynamic error type, along with helper methods that make dealing with it even
easier than returning a string. <sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></li></ul><p>If you google “error handling in Rust”, the typical introductory posts are going
to start with the basics of <code>panic</code>, <code>Option</code> and <code>Result</code>, then explain these
two libraries, give this rule of thumb to choose bethween them, show some code,
and stop right here.</p><h2 id="pattern-matching-isnt-the-only-reason-to-use-structured-errors">Pattern matching isn’t the only reason to use structured errors
</h2><p>At work, my team has written a ~50k LoC web server in Rust. We’ve been
maintaining it full-time for over a year. It mostly follows the same pattern of
“just propagate the error” and almost never pattern-matches specific error
conditions. The main benefit of structured errors is not applicable. It sounds
like we should be using something like <code>anyhow</code> instead of spending time on
maintaining our own error types. But I found many other benefits of doing so:</p><ul><li>Custom error types allow you to see all potential failure modes of a function
at a glance, without (recursively) inspecting its implementation or
maintaining fragile hand-written docs that can’t be fully trusted anyway. In a
code review, you can easily notice when some error variant doesn’t make sense
and should be handled locally, or comes from an action that shouldn’t be
performed at all. Interfaces become more descriptive.</li><li>When the error type is narrow and descriptive enough, you can understand the
function just by looking at its signature, without even going to the error
definition:<div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>foo</span>(<span>..</span>) -&gt; Result<span>&lt;..</span>, TheOnlyPossibleFailure<span>&gt;</span>
</span></span></code></pre></div></li><li>You don’t repeat yourself when the same error is thrown from multiple places.
Each error message is specified once when you define the type
<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>. This results in a more consistent user experience, as
well as better developer experience. Now your domain errors have IDE
integration, with operations like “find references” and so on.</li><li>The logic is less littered with error messages or adding context.
<code>return Err(MyType)</code>, <code>?</code> or <code>map_err</code> are usually more compact than full
error text formatting. There may be more code overall, but the error-related
code is moved “out of the way” to the type definition.</li><li>Although <code>anyhow</code> provides convenience methods for adding context to errors,
in practice it’s easy to forget, and <code>?</code> works happily without context. I had
to debug such cases multiple times. In contrast, <code>thiserror</code> derive forces you
to think about this, because you have to explicitly put <em>something</em> in the
<code>#[error(...)]</code> annotation. Even if you roll with <code>#[error(transparent)]</code> (no
context), that’s now an explicit choice that can be questioned in a code
review, etc.</li><li>Custom error types can be enriched with additional data and
functionality<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>:<ul><li>You can slap on
<a href="https://docs.rs/serde/1.0.219/serde/trait.Serialize.html" target="_blank"><code>#[derive(Serialize)]</code></a>
to log/return nested JSON data along with an error.</li><li>You can implement
<a href="https://doc.rust-lang.org/stable/std/process/trait.Termination.html" target="_blank"><code>std::process::Termination</code></a>
to give your error an associated
<a href="https://doc.rust-lang.org/stable/std/process/struct.ExitCode.html" target="_blank">ExitCode</a>
.</li><li>You can implement
<a href="https://docs.rs/axum/0.8.1/axum/response/trait.IntoResponse.html" target="_blank"><code>axum::IntoResponse</code></a>
to give your error an associated <a href="https://docs.rs/http/1.2.0/http/response/struct.Response.html#method.status" target="_blank">HTTP status
code</a>
.</li><li>You can implement something like this to have localized error messages:<div><pre tabindex="0"><code data-lang="rust"><span><span><span>trait</span> Localize {
</span></span><span><span>    <span>fn</span> <span>localize</span>(<span>&amp;</span>self, language: <span>Language</span>) -&gt; String;
</span></span><span><span>}
</span></span></code></pre></div></li></ul></li></ul><h2 id="the-tradeoffs">The tradeoffs
</h2><p>Custom errors have their drawbacks:</p><ul><li>It’s more code and more types <sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>.</li><li>To combat the boilerplate, you usually introduce a third-party dependency like
<code>thiserror</code>. <sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup></li><li>You need to put thought into structuring the code, because otherwise no one
will find and reuse your existing error types.</li><li>You need to come up with names for error types and enum variants. These names
may not be as clear as full error messages. So, in order to understand the
code, you may end up jumping to the message anyway. I
<a href="https://github.com/rust-lang/rust-analyzer/issues/16945" target="_blank">requested</a>
a feature
in <code>rust-analyzer</code> that would allow previewing <code>#[error(..)]</code> attributes
without jumping away from the code that I’m working on.</li><li>You also need to maintain these names as the codebase evolves! In my team, we
often forgot to update the type/variant name when updating an error message.</li><li>You have to maintain the error types as your functions begin or stop returning
certain error variants. This adds maintainance overhead, but can be seen as an
advantage (see the points about code reviews, descriptive interfaces,
enforcing context on errors). I see a parallel with adding/removing <code>Result</code>
from the signature, which is widely considered a “necessary evil”.</li><li>If your error is in a separate file, you jump back-and-forth between the files
when coding. <sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup></li><li>If an error enum is public in its crate, the compiler doesn’t warn about
unused variants. This means that sometimes unused variants may accumulate and
you need to manually notice and trim them. <sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup></li><li>If you want your errors to include a backtrace, you need to explicitly add a
<a href="https://doc.rust-lang.org/std/backtrace/struct.Backtrace.html" target="_blank"><code>Backtrace</code></a>
field. <sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup></li></ul><p>If your application is performance-sensitive, there are also performance
considerations that don’t present a clear winner:</p><ul><li>Should your errors be cheap to create? Are your errors frequently discarded
without ever being displayed? Are your errors displayed multiple times? Do you
need a backtrace? Currently, the contents of <code>anyhow::Error</code> are
heap-allocated, the arguments to <code>anyhow!</code> are <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=41af825d68e5b1d7bafdbaa9d768787d" target="_blank">eagerly
formatted</a>
,
and a
<a href="https://docs.rs/anyhow/1.0.95/anyhow/struct.Error.html#method.backtrace" target="_blank">backtrace</a>
may be captured depending on environment variables<sup id="fnref:11"><a href="#fn:11" role="doc-noteref">11</a></sup>. Typical
custom errors avoid allocations, are lazily formatted, and don’t capture a
backtrace. But you can change all of that.</li><li>Should your errors be small and cheap to propagate? Currently, <code>anyhow::Error</code>
is always a single pointer, while custom errors range from
<a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts" target="_blank">zero-sized</a>
unit structs to large collections of values that are waiting to be formatted.
You may need to box and/or preformat your custom errors.</li></ul><p>Custom errors can even have surprising downsides in libraries (e.g.,
<a href="https://www.reddit.com/r/rust/comments/1kx0ak8/why_use_structured_errors_in_rust_applications/muvblzn/" target="_blank">semver-related</a>
).
But I don’t duscuss libraries today!</p><p>Assessing the tradeoff is up to you. Structured errors are worth it in my
application.</p><h2 id="to-be-continued">To be continued
</h2><p>To present the full picture, I also wanted to cover:</p><ul><li>How to actually manage your custom error types to maximize the benefits and
minimize the maintenance cost.</li><li>A concrete example of error types helping me reason about the requirements in
my application.</li></ul><p>But this saga takes too long, so these topics go to their own separate posts and
this post ends here. 🚧</p><p>I have to be <em>✨ agile ✨</em> in order to actually publish anything.</p><hr/><p>Check out my first post about error handling:</p><ul><li><a href="https://home.expurple.me/posts/rust-solves-the-issues-with-exceptions/">Rust Solves The Issues With Exceptions</a></li></ul><p>I’ve also found these good posts about structured errors in Go and Haskell, but
they’re quite detailed and the actual approach in the code is quite different
from mine:</p><ul><li><a href="https://southcla.ws/structured-errors-in-go" target="_blank">Structured errors in Go</a></li><li><a href="https://jelv.is/blog/Structure-your-Errors/" target="_blank">Structure your Errors</a></li></ul><p>I’ll discuss mine in the next post in the series.</p><h2 id="discuss">Discuss
</h2><ul><li><a href="https://www.reddit.com/r/rust/comments/1kx0ak8/why_use_structured_errors_in_rust_applications/?" target="_blank"><span><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M201.5 305.5c-13.8.0-24.9-11.1-24.9-24.6.0-13.8 11.1-24.9 24.9-24.9 13.6.0 24.6 11.1 24.6 24.9.0 13.6-11.1 24.6-24.6 24.6zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-132.3-41.2c-9.4.0-17.7 3.9-23.8 10-22.4-15.5-52.6-25.5-86.1-26.6l17.4-78.3 55.4 12.5c0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.3 24.9-24.9s-11.1-24.9-24.9-24.9c-9.7.0-18 5.8-22.1 13.8l-61.2-13.6c-3-.8-6.1 1.4-6.9 4.4l-19.1 86.4c-33.2 1.4-63.1 11.3-85.5 26.8-6.1-6.4-14.7-10.2-24.1-10.2-34.9.0-46.3 46.9-14.4 62.8-1.1 5-1.7 10.2-1.7 15.5.0 52.6 59.2 95.2 132 95.2 73.1.0 132.3-42.6 132.3-95.2.0-5.3-.6-10.8-1.9-15.8 31.3-16 19.8-62.5-14.9-62.5zM302.8 331c-18.2 18.2-76.1 17.9-93.6.0-2.2-2.2-6.1-2.2-8.3.0-2.5 2.5-2.5 6.4.0 8.6 22.8 22.8 87.3 22.8 110.2.0 2.5-2.2 2.5-6.1.0-8.6-2.2-2.2-6.1-2.2-8.3.0zm7.7-75c-13.6.0-24.6 11.1-24.6 24.9.0 13.6 11.1 24.6 24.6 24.6 13.8.0 24.9-11.1 24.9-24.6.0-13.8-11-24.9-24.9-24.9z"></path></svg>
</span>r/rust</a></li></ul><nav><a href="https://home.expurple.me/posts/the-optimal-post-size/"><span>« Prev</span></a></nav></main></div></div>
  </body>
</html>
