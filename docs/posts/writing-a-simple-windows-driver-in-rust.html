<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scorpiosoftware.net/2025/02/08/writing-a-simple-driver-in-rust/">Original</a>
    <h1>Writing a simple windows driver in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>The Rust language ecosystem is growing each day, its popularity increasing, and with good reason. It’s the only mainstream language that provides memory and concurrency safety at compile time, with a powerful and rich build system (cargo), and a growing number of packages (crates).</p>



<p>My daily driver is still C++, as most of my work is about low-level system and kernel programming, where the Windows C and COM APIs are easy to consume. Rust is a system programming language, however, which means it plays, or at least can play, in the same playground as C/C++. The main snag is the verbosity required when converting C types to Rust. This “verbosity” can be alleviated with appropriate wrappers and macros. I decided to try writing a simple WDM driver that is not useless – it’s a Rust version of the “Booster” driver I demonstrate in my book (<a href="https://www.amazon.com/Windows-Kernel-Programming-Pavel-Yosifovich/dp/1977593372" target="_blank" rel="noreferrer noopener">Windows Kernel Programming</a>), that allows changing the priority of any thread to any value.</p>



<h2>Getting Started</h2>



<p>To prepare for building drivers, consult <a href="https://github.com/microsoft/windows-drivers-rs" target="_blank" rel="noreferrer noopener">Windows Drivers-rs</a>, but basically you should have a WDK installation (either normal or the <a href="https://learn.microsoft.com/en-us/legal/windows/hardware/enterprise-wdk-license-2022" target="_blank" rel="noreferrer noopener">EWDK</a>). Also, the docs require installing <a href="https://llvm.org/" target="_blank" rel="noreferrer noopener">LLVM</a>, to gain access to the <a href="https://clang.llvm.org/" target="_blank" rel="noreferrer noopener">Clang </a>compiler. I am going to assume you have these installed if you’d like to try the following yourself.</p>



<p>We can start by creating a new Rust library project (as a driver is a technically a DLL loaded into kernel space):</p>





<p>We can open the booster folder in VS Code, and begin are coding. First, there are some preparations to do in order for actual code to compile and link successfully. We need a <strong>build.rs</strong> file to tell cargo to link statically to the CRT. Add a <strong>build.rs</strong> file to the root booster folder, with the following code:</p>


<div><pre title="">fn main() -&gt; Result&lt;(), wdk_build::ConfigError&gt; {
    std::env::set_var(&#34;CARGO_CFG_TARGET_FEATURE&#34;, &#34;crt-static&#34;);
    wdk_build::configure_wdk_binary_build()
}
</pre></div>


<p>(Syntax highlighting is imperfect because the WordPress editor I use does not support syntax highlighting for Rust)</p>



<p>Next, we need to edit <strong>cargo.toml</strong> and add all kinds of dependencies. The following is the minimum I could get away with:</p>


<div><pre title="">[package]
name = &#34;booster&#34;
version = &#34;0.1.0&#34;
edition = &#34;2021&#34;

[package.metadata.wdk.driver-model]
driver-type = &#34;WDM&#34;

[lib]
crate-type = [&#34;cdylib&#34;]
test = false

[build-dependencies]
wdk-build = &#34;0.3.0&#34;

[dependencies]
wdk = &#34;0.3.0&#34;       
wdk-macros = &#34;0.3.0&#34;
wdk-alloc = &#34;0.3.0&#34; 
wdk-panic = &#34;0.3.0&#34; 
wdk-sys = &#34;0.3.0&#34;   

[features]
default = []
nightly = [&#34;wdk/nightly&#34;, &#34;wdk-sys/nightly&#34;]

[profile.dev]
panic = &#34;abort&#34;
lto = true

[profile.release]
panic = &#34;abort&#34;
lto = true
</pre></div>


<p>The important parts are the WDK crates dependencies. It’s time to get to the actual code in <strong>lib.rs</strong>. </p>



<h2>The Code</h2>



<p>We start by removing the standard library, as it does not exist in the kernel:</p>





<p>Next, we’ll add a few <code>use</code> statements to make the code less verbose:</p>


<div><pre title="">use core::ffi::c_void;
use core::ptr::null_mut;
use alloc::vec::Vec;
use alloc::{slice, string::String};
use wdk::*;
use wdk_alloc::WdkAllocator;
use wdk_sys::ntddk::*;
use wdk_sys::*;
</pre></div>


<p>The <code>wdk_sys</code> crate provides the low level interop kernel functions. the <code>wdk</code> crate provides higher-level wrappers. <code>alloc::vec::Vec</code> is an interesting one. Since we can’t use the standard library, you would think the types like <code>std::vec::Vec&lt;&gt;</code> are not available, and technically that’s correct. However, <code>Vec</code> is actually defined in a lower level module named <code>alloc::vec</code>, that can be used outside the standard library. This works because the only requirement for <code>Vec</code> is to have a way to allocate and deallocate memory. Rust exposes this aspect through a global allocator object, that anyone can provide. Since we have no standard library, there is no global allocator, so one must be provided. Then, <code>Vec</code> (and <code>String</code>) can work normally:</p>


<div><pre title="">#[global_allocator]
static GLOBAL_ALLOCATOR: WdkAllocator = WdkAllocator;
</pre></div>


<p>This is the global allocator provided by the WDK crates, that use <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-exallocatepool2" target="_blank" rel="noreferrer noopener"><code>ExAllocatePool2</code> </a>and <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-exfreepool" target="_blank" rel="noreferrer noopener"><code>ExFreePool</code> </a>to manage allocations, just like would do manually.</p>



<p>Next, we add two <code>extern</code> crates to get the support for the allocator and a panic handler – another thing that must be provided since the standard library is not included. <strong>Cargo.toml</strong> has a setting to abort the driver (crash the system) if any code panics:</p>


<div><pre title="">extern crate wdk_panic;
extern crate alloc;
</pre></div>


<p>Now it’s time to write the actual code. We start with <code>DriverEntry</code>, the entry point to any Windows kernel driver:</p>


<div><pre title="">#[export_name = &#34;DriverEntry&#34;]
pub unsafe extern &#34;system&#34; fn driver_entry(
    driver: &amp;mut DRIVER_OBJECT,
    registry_path: PUNICODE_STRING,
) -&gt; NTSTATUS {
</pre></div>


<p>Those familiar with kernel drivers will recognize the function signature (kind of). The function name is <code>driver_entry</code> to conform to the snake_case Rust naming convention for functions, but since the linker looks for <code>DriverEntry</code>, we decorate the function with the <code>export_name</code> attribute. You could use <code>DriverEntry</code> and just ignore or disable the compiler’s warning, if you prefer.</p>



<p>We can use the familiar <code>println!</code> macro, that was reimplemented by calling <code>DbgPrint</code>, as you would if you were using C/C++. You can still call <code>DbgPrint</code>, mind you, but <code>println!</code> is just easier:</p>


<div><pre title="">println!(&#34;DriverEntry from Rust! {:p}&#34;, &amp;driver);
let registry_path = unicode_to_string(registry_path);
println!(&#34;Registry Path: {}&#34;, registry_path);
</pre></div>


<p>Unfortunately, it seems <code>println!</code> does not yet support a <code>UNICODE_STRING</code>, so we can write a function named <code>unicode_to_string</code> to convert a <code>UNICODE_STRING</code> to a normal Rust string:</p>


<div><pre title="">fn unicode_to_string(str: PCUNICODE_STRING) -&gt; String {
    String::from_utf16_lossy(unsafe {
        slice::from_raw_parts((*str).Buffer, (*str).Length as usize / 2)
    })
}
</pre></div>


<p>Back in <code>DriverEntry</code>, our next order of business is to create a device object with the name “\Device\Booster”:</p>


<div><pre title="">let mut dev = null_mut();
let mut dev_name = UNICODE_STRING::default();
string_to_ustring(&#34;\\Device\\Booster&#34;, &amp;mut dev_name);

let status = IoCreateDevice(
    driver,
    0,
    &amp;mut dev_name,
    FILE_DEVICE_UNKNOWN,
    0,
    0u8,
    &amp;mut dev,
);
</pre></div>


<p>The <code>string_to_ustring</code> function converts a Rust string to a <code>UNICODE_STRING</code>:</p>


<div><pre title="">fn string_to_ustring&lt;&#39;a&gt;(s: &amp;str, uc: &amp;&#39;a mut UNICODE_STRING) -&gt; Vec&lt;u16&gt; {
    let mut wstring: Vec&lt;_&gt; = s.encode_utf16().collect();
    uc.Length = wstring.len() as u16 * 2;
    uc.MaximumLength = wstring.len() as u16 * 2;
    uc.Buffer = wstring.as_mut_ptr();
    wstring
}
</pre></div>


<p>This may look more complex than we would like, but think of this as a function that is written once, and then just used all over the place. In fact, maybe there is such a function already, and just didn’t look hard enough. But it will do for this driver.</p>



<p>If device creation fails, we return a failure status:</p>


<div><pre title="">if !nt_success(status) {
    println!(&#34;Error creating device 0x{:X}&#34;, status);
    return status;
}
</pre></div>


<p><code>nt_success</code> is similar to the <code>NT_SUCCESS</code> macro provided by the WDK headers.</p>



<p>Next, we’ll create a symbolic link so that a standard <code>CreateFile</code> call could open a handle to our device:</p>


<div><pre title="">let mut sym_name = UNICODE_STRING::default();
let _ = string_to_ustring(&#34;\\??\\Booster&#34;, &amp;mut sym_name);
let status = IoCreateSymbolicLink(&amp;mut sym_name, &amp;mut dev_name);
if !nt_success(status) {
    println!(&#34;Error creating symbolic link 0x{:X}&#34;, status);
    IoDeleteDevice(dev);
    return status;
}
</pre></div>


<p>All that’s left to do is initialize the device object with support for Buffered I/O (we’ll use <code>IRP_MJ_WRITE</code> for simplicity), set the driver unload routine, and the major functions we intend to support:</p>


<div><pre title="">    (*dev).Flags |= DO_BUFFERED_IO;

    driver.DriverUnload = Some(boost_unload);
    driver.MajorFunction[IRP_MJ_CREATE as usize] = Some(boost_create_close);
    driver.MajorFunction[IRP_MJ_CLOSE as usize] = Some(boost_create_close);
    driver.MajorFunction[IRP_MJ_WRITE as usize] = Some(boost_write);

    STATUS_SUCCESS
}
</pre></div>


<p>Note the use of the Rust <code>Option&lt;&gt;</code> type to indicate the presence of a callback.</p>



<p>The unload routine looks like this:</p>


<div><pre title="">unsafe extern &#34;C&#34; fn boost_unload(driver: *mut DRIVER_OBJECT) {
    let mut sym_name = UNICODE_STRING::default();
    string_to_ustring(&#34;\\??\\Booster&#34;, &amp;mut sym_name);
    let _ = IoDeleteSymbolicLink(&amp;mut sym_name);
    IoDeleteDevice((*driver).DeviceObject);
}
</pre></div>


<p>We just call <code>IoDeleteSymbolicLink</code> and <code>IoDeleteDevice</code>, just like a normal kernel driver would. </p>



<h2>Handling Requests</h2>



<p>We have three request types to handle – <code>IRP_MJ_CREATE</code>, <code>IRP_MJ_CLOSE</code>, and <code>IRP_MJ_WRITE</code>. Create and close are trivial – just complete the IRP successfully:</p>


<div><pre title="">unsafe extern &#34;C&#34; fn boost_create_close(_device: *mut DEVICE_OBJECT, irp: *mut IRP) -&gt; NTSTATUS {
    (*irp).IoStatus.__bindgen_anon_1.Status = STATUS_SUCCESS;
    (*irp).IoStatus.Information = 0;
    IofCompleteRequest(irp, 0);
    STATUS_SUCCESS
}
</pre></div>


<p>The <code>IoStatus</code> is an <code>IO_STATUS_BLOCK</code> but it’s defined with a <code>union</code> containing <code>Status</code> and <code>Pointer</code>. This seems to be incorrect, as <code>Information</code> should be in a <code>union</code> with <code>Pointer</code> (not <code>Status</code>). Anyway, the code accesses the <code>Status</code> member through the “auto generated” union, and it looks ugly. Definitely something to look into further. But it works.</p>



<p>The real interesting function is the <code>IRP_MJ_WRITE</code> handler, that does the actual thread priority change. First, we’ll declare a structure to represent the request to the driver:</p>


<div><pre title="">#[repr(C)]
struct ThreadData {
    pub thread_id: u32,
    pub priority: i32,
}
</pre></div>


<p>The use of <code>repr(C)</code> is important, to make sure the fields are laid out in memory just as they would with C/C++. This allows non-Rust clients to talk to the driver. In fact, I’ll test the driver with a C++ client I have that used the C++ version of the driver. The driver accepts the thread ID to change and the priority to use. Now we can start with <code>boost_write</code>:</p>


<div><pre title="">unsafe extern &#34;C&#34; fn boost_write(_device: *mut DEVICE_OBJECT, irp: *mut IRP) -&gt; NTSTATUS {
    let data = (*irp).AssociatedIrp.SystemBuffer as *const ThreadData;
</pre></div>


<p>First, we grab the data pointer from the <code>SystemBuffer</code> in the IRP, as we asked for Buffered I/O support. This is a kernel copy of the client’s buffer. Next, we’ll do some checks for errors:</p>


<div><pre title="">let status;
loop {
    if data == null_mut() {
        status = STATUS_INVALID_PARAMETER;
        break;
    }
    if (*data).priority &lt; 1 || (*data).priority &gt; 31 {
        status = STATUS_INVALID_PARAMETER;
        break;
    }
</pre></div>


<p>The <code>loop</code> statement creates an infinite block that can be exited with a <code>break</code>. Once we verified the priority is in range, it’s time to locate the thread object:</p>


<div><pre title="">let mut thread = null_mut();
status = PsLookupThreadByThreadId(((*data).thread_id) as *mut c_void, &amp;mut thread);
if !nt_success(status) {
    break;
}
</pre></div>


<p><code><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-pslookupthreadbythreadid" target="_blank" rel="noreferrer noopener">PsLookupThreadByThreadId</a></code> is the one to use. If it fails, it means the thread ID probably does not exist, and we break. All that’s left to do is set the priority and complete the request with whatever status we have:</p>


<div><pre title="">        KeSetPriorityThread(thread, (*data).priority);
        ObfDereferenceObject(thread as *mut c_void);
        break;
    }
    (*irp).IoStatus.__bindgen_anon_1.Status = status;
    (*irp).IoStatus.Information = 0;
    IofCompleteRequest(irp, 0);
    status
}
</pre></div>


<p>That’s it!</p>



<p>The only remaining thing is to sign the driver. It seems that the crates support signing the driver if an INF or INX files are present, but this driver is not using an INF. So we need to sign it manually before deployment. The following can be used from the root folder of the project:</p>


<div><pre title="">signtool sign /n wdk /fd sha256 target\debug\booster.dll
</pre></div>


<p>The <code>/n wdk</code> uses a WDK test certificate typically created automatically by Visual Studio when building drivers. I just grab the first one in the store that starts with “wdk” and use it.</p>



<p>The silly part is the file extension – it’s a DLL and there currently is no way to change it automatically as part of cargo build. If using an INF/INX, the file extension does change to SYS. In any case, file extensions don’t really mean that much – we can rename it manually, or just leave it as DLL. </p>



<h2>Installing the Driver</h2>



<p>The resulting file can be installed in the “normal” way for a software driver, such as using the <strong>sc.exe</strong> tool (from an elevated command window), on a machine with test signing on. Then <code>sc start</code> can be used to load the driver into the system:</p>


<div><pre title="">sc.exe sc create booster type= kernel binPath= c:\path_to_driver_file
sc.exe start booster
</pre></div>


<h2>Testing the Driver</h2>



<p>I used an existing C++ application that talks to the driver and expects to pass the correct structure. It looks like this:</p>


<div><pre title="">#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;

struct ThreadData {
	int ThreadId;
	int Priority;
};

int main(int argc, const char* argv[]) {
	if (argc &lt; 3) {
		printf(&#34;Usage: boost &lt;tid&gt; &lt;priority&gt;\n&#34;);
		return 0;
	}

	int tid = atoi(argv[1]);
	int priority = atoi(argv[2]);

	HANDLE hDevice = CreateFile(L&#34;\\\\.\\Booster&#34;,
		GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0,
		nullptr);

	if (hDevice == INVALID_HANDLE_VALUE) {
		printf(&#34;Failed in CreateFile: %u\n&#34;, GetLastError());
		return 1;
	}

	ThreadData data;
	data.ThreadId = tid;
	data.Priority = priority;
	DWORD ret;
	if (WriteFile(hDevice, &amp;data, sizeof(data),
		&amp;ret, nullptr))
		printf(&#34;Success!!\n&#34;);
	else
		printf(&#34;Error (%u)\n&#34;, GetLastError());

	CloseHandle(hDevice);

	return 0;
}
</pre></div>


<p>Here is the result when changing a thread’s priority to 26 (ID 9408):</p>



<figure><img data-attachment-id="2919" data-permalink="https://scorpiosoftware.net/2025/02/08/writing-a-simple-driver-in-rust/image-41/" data-orig-file="https://scorpiosoftware.net/wp-content/uploads/2025/02/image.png" data-orig-size="976,579" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://scorpiosoftware.net/wp-content/uploads/2025/02/image.png?w=300" data-large-file="https://scorpiosoftware.net/wp-content/uploads/2025/02/image.png?w=660" width="976" height="579" src="https://scorpiosoftware.net/wp-content/uploads/2025/02/image.png?w=976" alt=""/></figure>



<h2>Conclusion</h2>



<p>Writing kernel drivers in Rust is possible, and I’m sure the support for this will improve quickly. The WDK crates are at version 0.3, which means there is still a way to go. To get the most out of Rust in this space, safe wrappers should be created so that the code is less verbose, does not have <code>unsafe</code> blocks, and enjoys the benefits Rust can provide. Note, that I may have missed some wrappers in this simple implementation.</p>



<p>You can find a couple of more samples for KMDF Rust drivers <a href="https://github.com/microsoft/Windows-rust-driver-samples" target="_blank" rel="noreferrer noopener">here</a>.</p>



<p>The code for this post can be found at <a href="https://github.com/zodiacon/Booster">https://github.com/zodiacon/Booster</a>.</p>




	</div></div>
  </body>
</html>
