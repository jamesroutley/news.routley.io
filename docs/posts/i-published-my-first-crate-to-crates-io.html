<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://samuelselleck.com/blog/published-my-first-rust-crate/">Original</a>
    <h1>I Published my First Crate to crates.io</h1>
    
    <div id="readability-page-1" class="page"><div><p>In the last week I published my first rust create to <a href="https://crates.io">creates.io</a>. The create idea was a result of another collaborative project I am working on with an awesome group at the Recurse Center.</p><p>I’m so happy I got around to actually publishing a create, if nothing else to realize how easy it was! There is of course a lot of things I would like to improve about it, both feature set wise and in the public API. But if there is anything I need to learn it is to say “good enough for now”, and I managed to this time.</p><h2 id="the-crate">The Crate</h2><p>The create is called <a href="https://crates.io/crates/mesh-rand">mesh-rand</a> and is meant to evolve into a suite for sampling all kinds of random distributions on the surface or in the volume of a 3D mesh. At the moment the only feature available is to generate random uniform points on the surface, but I hope to get around to adding more soon.</p><p>The create idea came from the need in the <a href="https://github.com/samuelselleck/holographit/tree/main">original project</a> to generate a 3d point cloud to represent a 3d mesh. In the case of a high poly model one easy way is to just use the verticie data, but this does not work for models that contain large triangles. I looked around for a while online, but couldn’t find a library that seemed to do what we need, and so decided to build the feature separately to be able to publish it as a crate.</p><h2 id="what-i-learned">What I Learned</h2><p>The process of publishing was surprisingly smooth! I just followed the instructions <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">here</a>. The largest part was going through the <a href="https://rust-lang.github.io/api-guidelines/checklist.html">rust API guidelines</a> (still have a couple of points that could for sure be improved upon).</p><p>I’m really happy I managed to find a project with a very small scope, to get my feet wet and not have to many decisions to make when going through the process of publishing.</p><h3 id="doc-examples">Doc Examples</h3><p>I learned a bit about doc comment code examples. Within a doc comment code block, lines can be excluded from the doc, but included in the doc tests, by adding a # to the beginning of doc lines:</p><pre data-lang="rust"><code data-lang="rust"><span>///```
</span><span>/// let a = 5;
</span><span>/// # assert_eq!(a, 5);
</span><span>///```
</span></code></pre><p>This both allows for adding assertions that are not visible in the examples as above, but also makes it possible to use the question mark operator inside examples by wrapping them like this:</p><pre data-lang="rust"><code data-lang="rust"><span>///```
</span><span>/// # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span>/// ... your code here ...
</span><span>/// # Ok(())
</span><span>/// # }
</span><span>///```
</span></code></pre><p>One feeling I went away with is that there really should exist a macro crate for defining more ergonomic rust doc examples. Why not auto-generate the above wrapper, and as a bonus not have to worry about including “///” at the beginning of each line by doing this:</p><pre data-lang="rust"><code data-lang="rust"><span>doc_example! </span><span>{
</span><span>    </span><span>//code here, syntax highlighted and all!
</span><span>}
</span></code></pre><p>Maybe even a way of referencing the entirety or parts of test methods? Would love to hear your thoughts on this.</p><h2 id="un-answered-questions">Un-answered Questions</h2><ul><li>How can I in a nice way support both f32 and f64 types in a library? I did look at the num_traits create Float type, but the problem is that I’m using a dependency that only accepts a handful of numeric primitives (f32, f64, i32 etc.). One solution would be a feature flag that defines a Float type, but that seems weird. Another idea is through some sort of build step, but it just seems like there should be a better way of doing this.</li><li>How to choose input/output types in the best way possible? The distributions in the library needs mesh data. Right now I opted for a arbitrary way of representing this using rust primitives, as it seemed the most flexible for the caller. I did start to research what other crates exist that have mesh types defined - in the hope of realizing they were all using some common format. Not the case. Adding all these other crates as a dependency just to implement “from” methods feels bad. Maybe behind feature flags? But there would be so many…</li></ul><h2 id="next-steps">Next steps</h2><p>Would like to implement poisson disc sampling on mesh surfaces using some combination/variant of these methods:</p><ul><li><a href="https://www.researchgate.net/publication/266396705_Efficient_maximal_Poisson-disk_sampling_and_remeshing_on_surfaces">Efficient maximal Poisson-disk sampling and remeshing on surfaces</a></li><li><a href="https://www.liyiwei.org/papers/sample-siga10/paper.pdf">Parallel Poisson Disk Sampling with Spectrum Analysis on Surfaces</a></li></ul></div></div>
  </body>
</html>
