<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.appsignal.com/2022/06/22/state-machines-in-ruby-an-introduction.html">Original</a>
    <h1>State Machines in Ruby: An Introduction</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>A state machine can hold all possible states of <em>something</em> and the allowed transitions between these states.
For example, the state machine for a door would have only two states (<code>open</code> and <code>closed</code>) and only two transitions (<code>opening</code> and <code>closing</code>).</p><p>On the other hand, complex state machines can have several different states with hundreds of transitions between them.
In fact, if you look around, you will notice finite state machines surrounding you — when you buy from a website, get a pack of crisps from the vending machine, or even just withdraw money from an ATM.</p><p>In this post, we&#39;ll look at how to set up a state machine in Ruby and use the state machines gem.</p><div><h2>State Machines in Development</h2><p>When do we need a state machine in development? The simple answer is whenever you want to model multiple rules for state transitions or perform side-effects on some transitions.
The key here is to identify parts of your application that would benefit from a state machine.
A good example that always works for me is an <code>Order</code> in the context of an e-commerce application.</p><p>For a simple application selling products online, an <code>Order</code> can be in one of several states:</p><ul><li><code>created</code></li><li><code>processing</code></li><li><code>ready</code></li><li><code>shipped</code></li><li><code>delivered</code></li><li><code>void</code></li></ul><p>You can see the allowed transitions in the following diagram.</p><div data-rmiz-wrap="visible"><figure><span><span></span><img alt="State machine diagram" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive"/></span></figure></div><p>Visualizing the order in the form of a state machine immediately allows us to clearly understand the full flow, from ordering the product to delivery.
And for us developers, it enables clear, set steps on what can and cannot be done at particular points in that flow.</p><p>That being said, it is easy to jump down a rabbit hole by picking this up for a very wide problem and then end up with hundreds of states that are difficult to reason about and follow through.
So always have a top-level idea and a state chart for your proposed state machine before implementing it.</p></div><div><h2>Our First State Machine in Ruby</h2><p>Let&#39;s try to implement our <code>OrderStateMachine</code> with Ruby.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="rb" data-theme="default"><span><span>class</span><span> </span><span>OrderStateMachine</span></span>
<span><span>  </span><span>def</span><span> </span><span>initialize</span><span>(</span><span>order</span><span>)</span></span>
<span><span>    </span><span>@order</span><span> </span><span>=</span><span> order</span></span>
<span><span>    </span><span>@order</span><span>.state </span><span>=</span><span> </span><span>:</span><span>created</span><span> </span><span>if</span><span> </span><span>@order</span><span>.state.blank?</span></span>
<span><span>  </span><span>end</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>mark_as_paid!</span></span>
<span><span>    </span><span>raise</span><span> </span><span>&#34;Invalid state </span><span>#{</span><span>@order</span><span>.state</span><span>}</span><span>&#34;</span><span> </span><span>unless</span><span> </span><span>@order</span><span>.created?</span></span>
<span> </span>
<span><span>    </span><span>@order</span><span>.state </span><span>=</span><span> </span><span>:</span><span>processing</span></span>
<span><span>  </span><span>end</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>packed!</span></span>
<span><span>    </span><span>raise</span><span> </span><span>&#34;Invalid state </span><span>#{</span><span>@order</span><span>.state</span><span>}</span><span>&#34;</span><span> </span><span>unless</span><span> </span><span>@order</span><span>.processing?</span></span>
<span> </span>
<span><span>    </span><span>@order</span><span>.state </span><span>=</span><span> </span><span>:</span><span>ready</span></span>
<span><span>  </span><span>end</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>shipped!</span></span>
<span><span>    </span><span>raise</span><span> </span><span>&#34;Invalid state </span><span>#{</span><span>@order</span><span>.state</span><span>}</span><span>&#34;</span><span> </span><span>unless</span><span> </span><span>@order</span><span>.ready?</span></span>
<span> </span>
<span><span>    </span><span>@order</span><span>.state </span><span>=</span><span> </span><span>:</span><span>shipped</span></span>
<span><span>  </span><span>end</span></span>
<span> </span>
<span><span>  </span><span># ...</span></span>
<span><span>end</span></span></code></pre></div><p>That&#39;s a simple enough implementation.
For each possible transition in the state machine, we define a new method that does some sanity checks and performs the transition.</p><p>The great thing about the above implementation is that everything is explicit: any new developer can very quickly understand the full extent of the state machine.</p><p>Let&#39;s see how we can add some side-effects to the transitions.
We&#39;ll automatically ship orders that are packed and deliverable:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="rb" data-theme="default"><span><span>class</span><span> </span><span>OrderStateMachine</span></span>
<span><span>  </span><span># ...</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>packed!</span></span>
<span><span>    </span><span>raise</span><span> </span><span>&#34;Invalid state </span><span>#{</span><span>@order</span><span>.state</span><span>}</span><span>&#34;</span><span> </span><span>unless</span><span> </span><span>@order</span><span>.processing?</span></span>
<span> </span>
<span><span>    </span><span>@order</span><span>.state </span><span>=</span><span> </span><span>:</span><span>ready</span></span>
<span><span>    ship_order </span><span>if</span><span> </span><span>@order</span><span>.deliverable?</span></span>
<span><span>  </span><span>end</span></span>
<span> </span>
<span><span>  </span><span># ...</span></span>
<span> </span>
<span><span>  </span><span>private</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>ship_order</span></span>
<span><span>    </span><span>DeliveryService</span><span>.create_consigment!(</span><span>@order</span><span>)</span></span>
<span><span>    shipped!</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span></code></pre></div><p>While a naïve implementation works great, it is overly verbose, especially when we have a lot of transitions and conditions.</p><p>A quick check on <a href="https://www.ruby-toolbox.com/categories/state_machines">Ruby Toolbox</a> brings up several gems for state machines.
<a href="https://github.com/state-machines/state_machines"><code>state_machines</code></a> and <a href="https://github.com/aasm/aasm"><code>aasm</code></a> are the most popular ones, and both come with an ActiveRecord adapter if you want to use them with Rails.
Both are thoroughly tested and production-ready, so do check them out if you need to implement a state machine.</p></div><div><h2>Using the State Machines Gem in Ruby</h2><p>For this post, I will describe how we can model the state machine for our <code>Order</code> using the <code>state_machines</code> gem.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="rb" data-theme="default"><span><span>class</span><span> </span><span>Order</span></span>
<span><span>  state_machine </span><span>:</span><span>state</span><span>, </span><span>initial</span><span>:</span><span> </span><span>:</span><span>created</span><span> </span><span>do</span></span>
<span><span>    event </span><span>:</span><span>confirm_payment</span><span> </span><span>do</span></span>
<span><span>      transition </span><span>created</span><span>:</span><span> </span><span>:</span><span>processing</span></span>
<span><span>    </span><span>end</span></span>
<span><span>    event </span><span>:</span><span>pack</span><span> </span><span>do</span></span>
<span><span>      transition </span><span>processing</span><span>:</span><span> </span><span>:</span><span>ready</span></span>
<span><span>    </span><span>end</span></span>
<span><span>    event </span><span>:</span><span>cancel</span><span> </span><span>do</span></span>
<span><span>      transition </span><span>%</span><span>i[created processing ready] =&gt; </span><span>:</span><span>void</span></span>
<span><span>    </span><span>end</span></span>
<span><span>    event </span><span>:</span><span>return</span><span> </span><span>do</span></span>
<span><span>      transition </span><span>delivered</span><span>:</span><span> </span><span>:</span><span>void</span></span>
<span><span>    </span><span>end</span></span>
<span><span>    event </span><span>:</span><span>ship</span><span> </span><span>do</span></span>
<span><span>      transition </span><span>ready</span><span>:</span><span> </span><span>:</span><span>shipped</span></span>
<span><span>    </span><span>end</span></span>
<span><span>    event </span><span>:</span><span>fail_delivery</span><span> </span><span>do</span></span>
<span><span>      transition </span><span>shipped</span><span>:</span><span> </span><span>:</span><span>processing</span></span>
<span><span>    </span><span>end</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span></code></pre></div><p>The above class defines our simple state machine and all of its possible transitions.
On top of this, it also automatically exposes a lot of utility methods on an order:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="rb" data-theme="default"><span><span>order.state           </span><span># =&gt; &#34;created&#34;</span></span>
<span><span>order.state_name      </span><span># =&gt; :created</span></span>
<span><span>order.created?        </span><span># =&gt; true</span></span>
<span><span>order.can_pack?       </span><span># =&gt; false (since payment has not been confirmed yet)</span></span>
<span><span>order.confirm_payment </span><span># =&gt; true (and transitions to `processing`)</span></span>
<span><span>order.can_pack?       </span><span># =&gt; true</span></span></code></pre></div></div><div><h2>Execute Side-Effects with the State Machines Gem in Ruby</h2><p>As is usual for any real-world system, many transitions in a state machine will come with side-effects.
The <code>state_machines</code> gem makes it easy to define and execute them.
Let&#39;s add two side-effects:</p><ol><li>On all transitions to <code>ready</code>, create a delivery consignment if the order is <code>deliverable</code>.</li><li>On all <code>fail_delivery</code> events, send an email to the user notifying them of the event.</li></ol><div data-rehype-pretty-code-fragment=""><pre><code data-language="rb" data-theme="default"><span><span>class</span><span> </span><span>Order</span></span>
<span><span>  </span><span>attr_accessor</span><span> </span><span>:</span><span>deliverable</span></span>
<span> </span>
<span><span>  state_machine </span><span>:</span><span>state</span><span>, </span><span>initial</span><span>:</span><span> </span><span>:</span><span>created</span><span> </span><span>do</span></span>
<span><span>    </span><span># ...</span></span>
<span> </span>
<span><span>    after_transition </span><span>to</span><span>:</span><span> </span><span>:</span><span>ready</span><span>, </span><span>do</span><span>:</span><span> </span><span>:</span><span>create_delivery_consignment</span><span>, </span><span>if</span><span>:</span><span> </span><span>:</span><span>deliverable</span></span>
<span><span>    after_transition </span><span>on</span><span>:</span><span> </span><span>:</span><span>fail_delivery</span><span>, </span><span>do</span><span>:</span><span> </span><span>:</span><span>notify_delivery_failure</span></span>
<span><span>  </span><span>end</span></span>
<span> </span>
<span><span>  </span><span>private</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>create_delivery_consignment</span></span>
<span><span>    </span><span>DeliveryService</span><span>.create_consigment!(</span><span>self</span><span>)</span></span>
<span><span>    ship</span></span>
<span><span>  </span><span>end</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>notify_delivery_failure</span></span>
<span><span>    </span><span>UserMailer</span><span>.delivery_failure_email(</span><span>self</span><span>).deliver_later</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span></code></pre></div><p>We can perform transitions as usual in the order:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="rb" data-theme="default"><span><span>order.deliverable </span><span>=</span><span> </span><span>true</span></span>
<span><span>order.pack            </span><span># =&gt; true</span></span>
<span><span>order.state           </span><span># =&gt; &#34;shipped&#34; (through side-effect)</span></span></code></pre></div><p>I would suggest checking out the <a href="https://github.com/state-machines/state_machines">Github page for the <code>state_machines</code> gem</a> to learn about all the possible options the gem offers.</p></div><div><h2>Use the State Machines Gem with ActiveRecord in Ruby on Rails</h2><p>As discussed before, both <code>state_machines</code> and <code>aasm</code> support ActiveRecord.
When you use the <code>state_machines</code> gem with ActiveRecord, not a lot of things change with the implementation. You can continue using most of what we&#39;ve already discussed in the previous sections of this post.</p><p>Here are some additional features that you get:</p><ol><li>Side-effects happen inside a transaction.
This means that if you do some database operations inside transition hooks and the transaction fails, the state change won&#39;t be committed.
<a href="https://www.rubydoc.info/github/state-machines/state_machines-activerecord/StateMachines/Integrations/ActiveRecord#label-Transactions">See <code>use_transactions</code></a> if you want to disable this behavior.</li><li>Like all other ActiveRecord callbacks, if you want to update the attributes of the current model from a transition, you must do this inside a <code>before_transition</code> callback.
To update attributes inside <code>after_transition</code>, you need to save the model again.
Check out the following example:</li></ol><div data-rehype-pretty-code-fragment=""><pre><code data-language="rb" data-theme="default"><span><span>class</span><span> </span><span>Order</span><span> &lt; </span><span>ActiveRecord::Base</span></span>
<span><span>  state_machine </span><span>initial</span><span>:</span><span> </span><span>:</span><span>created</span><span> </span><span>do</span></span>
<span> </span>
<span><span>    before_transition any =&gt; </span><span>:</span><span>processing</span><span> </span><span>do</span><span> |</span><span>order</span><span>|</span></span>
<span><span>      </span><span># You can just update the attribute here and it will be saved.</span></span>
<span><span>      order.processing_start_at </span><span>=</span><span> </span><span>Time</span><span>.zone.now</span></span>
<span><span>    </span><span>end</span></span>
<span> </span>
<span><span>    after_transition any =&gt; </span><span>:</span><span>shipped</span><span> </span><span>do</span><span> |</span><span>order</span><span>|</span></span>
<span><span>      </span><span># Call update! to update the order.</span></span>
<span><span>      </span><span># Just setting the attribute like above would not work here.</span></span>
<span><span>      order.update!(</span><span>shipped_at</span><span>:</span><span> </span><span>Time</span><span>.zone.now)</span></span>
<span><span>    </span><span>end</span></span>
<span><span>  </span><span>end</span></span>
<span><span>end</span></span></code></pre></div><ol start="3"><li>The gem automatically provides scopes to filter models by their state.
For example, you can do <code>Order.with_state(:processing)</code> to find all the processing orders or <code>Order.without_state(:processing)</code> to find all orders that are not under processing.</li><li>If a state change is attempted without a matching transition (for example, from <code>processing</code> to <code>delivered</code>), the record will fail to save, and an error will be added to the validation errors.
To internationalize the generated error messages, just add some keys to provide translations for states and events inside the config files (for example, <code>en.yml</code>):</li></ol><div data-rehype-pretty-code-fragment=""><pre><code data-language="yaml" data-theme="default"><span><span>en</span><span>:</span></span>
<span><span>  </span><span>activerecord</span><span>:</span></span>
<span><span>    </span><span>state_machines</span><span>:</span></span>
<span><span>      </span><span>order</span><span>:</span></span>
<span><span>        </span><span>states</span><span>:</span></span>
<span><span>          </span><span>created</span><span>: </span><span>Created</span></span>
<span><span>          </span><span>processing</span><span>: </span><span>Under Processing</span></span>
<span><span>          </span><span># ...</span></span>
<span><span>        </span><span>events</span><span>:</span></span>
<span><span>          </span><span>return</span><span>: </span><span>Return Order</span></span>
<span><span>          </span><span># ...</span></span></code></pre></div><p><em>Side note</em>: <a href="https://blog.appsignal.com/2021/02/24/troubleshooting-activerecord-performance.html">Check out this post to troubleshoot ActiveRecord performance issues</a>.</p></div><div><h2>Wrap Up: Build State Machines in Ruby</h2><p>In this post, we explored why we&#39;d use a state machine in development, before building a simple state machine. Finally, we looked at using the state machines gem in Ruby and Ruby on Rails.</p><p>Now that you have a basic understanding of a state machine, I am sure you will recognize several scenarios around you that already use a state machine or will benefit greatly from one.</p><p>Until next time, I wish you luck building state machines!</p><p><strong>P.S. If you&#39;d like to read Ruby Magic posts as soon as they get off the press, <a href="https://blog.appsignal.com/ruby-magic">subscribe to our Ruby Magic newsletter and never miss a single post</a>!</strong></p></div></div></div></div>
  </body>
</html>
