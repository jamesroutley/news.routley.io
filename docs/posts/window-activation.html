<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.broulik.de/2025/08/on-window-activation/">Original</a>
    <h1>Window Activation</h1>
    
    <div id="readability-page-1" class="page"><article id="post-2579">
	
	<!-- .entry-header -->

	<div>
		
<p>You click a link in your chat app, your browser with a hundred tabs comes to the front and opens that page. How hard can it be? Well, you probably know by now that Wayland, unlike X, doesn’t let one application force its idiot wishes on everyone else. In order for an application to bring its window to the front, it needs to make use of the <a href="https://wayland.app/protocols/xdg-activation-v1" data-type="link" data-id="https://wayland.app/protocols/xdg-activation-v1" target="_blank" rel="noreferrer noopener">XDG Activation</a> protocol.</p>



<figure><a href="https://blog.broulik.de/wp-content/uploads/2025/07/Bildschirmfoto_20250731_143103.png"><img fetchpriority="high" decoding="async" width="1024" height="740" src="https://blog.broulik.de/wp-content/uploads/2025/07/Bildschirmfoto_20250731_143103-1024x740.png" alt="KWrite (text editor) window, window has no focus (colors are softened). Task bar with a couple of apps, KWrite icon has an orange background behind it, indicating KWrite is demanding attention" srcset="https://blog.broulik.de/wp-content/uploads/2025/07/Bildschirmfoto_20250731_143103-1024x740.png 1024w, https://blog.broulik.de/wp-content/uploads/2025/07/Bildschirmfoto_20250731_143103-300x217.png 300w, https://blog.broulik.de/wp-content/uploads/2025/07/Bildschirmfoto_20250731_143103-768x555.png 768w, https://blog.broulik.de/wp-content/uploads/2025/07/Bildschirmfoto_20250731_143103.png 1130w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>A KWrite window that failed to activate and instead is weeping bitterly for attention in the task bar</figcaption></figure>



<p>In essence, an application cannot <em>take</em> focus, it can only <em>receive</em> focus. In the example above, your chat app would request an XDG Activation token from the compositor. It then asks the system to open the given URL (typically launching the web browser) and sends along the token. The browser can then use this token to activate its window.</p>



<p>This token is just a magic string, it doesn’t matter how it gets from one application to another. Typically, a new application is launched with the <em>XDG_ACTIVATION_TOKEN</em> variable in its environment. When activating an existing one, an <em>activation-token</em> property is added to the <em>platform_data</em> dict sent via DBus. There’s also older protocols that weren’t designed with this in mind, such as Notifications, StatusNotifierItem (tray icons), or PolKit requests where we cannot change the existing method signatures. Here we instead added some way to set a token just before the actual call.</p>



<p>However, just because you have a token doesn’t mean you can raise your window! The compositor can invalidate your token at any time and reject your activation request. The idea is that the compositor gets enough information to decide whether the request is genuine or some application popping up a dialog in the middle of you typing something. A token request can include the surface that requests the activation, the input serial from the focus or mouse event that resulted in this request, and/or the application ID of the application that should be activated. While all of this is optional (and there can be valid reasons why you don’t have a particular piece of information at this time), the compositor is more likely to decline activation if the information is incomplete or doesn’t match what the requesting application provided.</p>



<p>A lot of places in Qt, KDE Frameworks, and other toolkits and applications have already been adjusted to this workflow and work seamlessly. For example, calling <em>requestActivate</em> on a <em>QWindow</em> will check if there is an <em>XDG_ACTIVATION_TOKEN</em> in the environment and use it, otherwise request one. Qt also does this automatically when the window opens to match the behavior of other platforms. Likewise, things like <em>ApplicationLauncherJob</em> and <em>OpenUrlJob</em> will automatically request a token before proceeding. On the other hand, <em>KDBusService</em> (for implementing single instance applications) automatically sets the corresponding environment variable when it received a token via DBus. Together this makes sure that most KDE applications just work out of the box.</p>



<p>You might be wondering: didn’t KWin-X11 have “focus stealing prevention”? It sure does. There’s a complicated set of heuristics based on <em>_NET_WM_USER_TIME</em> to judge whether the new window appeared as a result of explicit user interaction or is unsolicited. Remember how back in ye olde days, KWin’s focus stealing prevention would keep the Adobe Flash Player fullscreen window from showing ontop of the YouTube video you’re watching? Yeah, it’s not perfect. KWin can also only react on things that have already happened. For instance, when an application uses <em>XSetInputFocus</em> on a window from a different application, KWin will detect that and consider it a malicious request and restore previous focus but for a split second focus did change. If you want to know more, there’s a 200+ lines comment in <em>activation.cpp</em> in <a href="https://invent.kde.org/plasma/kwin-x11" data-type="link" data-id="https://invent.kde.org/plasma/kwin-x11" target="_blank" rel="noreferrer noopener">KWin’s git repo</a> that explains it all. But then again the application could just do whatever it wants and bypass all of this.</p>



<figure><a href="https://blog.broulik.de/wp-content/uploads/2025/07/Screenshot_20250802_100046.png"><img decoding="async" width="1024" height="658" src="https://blog.broulik.de/wp-content/uploads/2025/07/Screenshot_20250802_100046-1024x658.png" alt="“Window Behavior” configuration dialog, various window-related tabs and options, mouse cursor pointing at a combo box “Focus stealing prevention” whose current item is “Extreme”" srcset="https://blog.broulik.de/wp-content/uploads/2025/07/Screenshot_20250802_100046-1024x658.png 1024w, https://blog.broulik.de/wp-content/uploads/2025/07/Screenshot_20250802_100046-300x193.png 300w, https://blog.broulik.de/wp-content/uploads/2025/07/Screenshot_20250802_100046-768x493.png 768w, https://blog.broulik.de/wp-content/uploads/2025/07/Screenshot_20250802_100046.png 1113w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>Xtreme Focus Stealing Prevention™</figcaption></figure>



<p>Unfortunately, there’s still a few places that don’t do XDG Activation correctly. It didn’t matter much under X – in doubt we could just <em>forceActiveWindow</em> – but now we have to fix those scenarios properly! In order to test whether your application is well-behaved, use the latest git master branch of KWin and set “Focus Stealing Prevention” in Window Management settings to “Extreme”. This will make KWin activate a window if and only if it requests activation with a valid token.</p>



<p>Using this, over the past couple of days <a href="https://zamundaaa.github.io/" data-type="link" data-id="https://zamundaaa.github.io/" target="_blank" rel="noreferrer noopener">Xaver Hugl</a> of KWin fame and I fixed a bunch of issues, including but not limited to:</p>



<ul>
<li>Dolphin threw away its token before activating its main window when launching a new instance (activating an existing one worked fine)</li>



<li>KRunner, Kickoff, and other Plasmoid popups did not request activation at all</li>



<li>LayerShell-Qt now requests activation on show (to match Qt behavior)</li>



<li>LayerShell-Qt didn’t read the <em>XDG_ACTIVATION_TOKEN</em> from the environment when provided</li>



<li>Privileged clients, like Plasma and KGlobalAccel, were unable to request tokens in some situations</li>



<li>Modifier key presses no longer count towards focus stealing prevention: they’re often used as part of a <em>global</em> keyboard shortcut and don’t necessarily mean the user is interacting with the active window</li>
</ul>



<p>Furthermore, the DBusRunner specification gained a <em>SetActivationToken</em> method which is called just before <em>Run</em>. Baloo (desktop search) runner now uses this to ensure opening files in an existing application window works. Likewise for the <a href="https://blog.broulik.de/2025/04/be-free-to-have-multiple-clocks/" data-type="post" data-id="2362">KClock runner</a> bringing KClock to the front properly. I further improved the recent documents runner and places runner to send the file type to the <em>OpenUrlJob</em> so it doesn’t have to determine it again. This makes the job much quicker and avoids KRunner closing before the activation token is requested by the job. However, we have yet to find a proper solution for this in KRunner.</p>



<p>With all of this in place, we’ll likely switch on KWin’s focus stealing on Wayland at a low level and make it gradually stricter as applications are being fixed. </p>
	</div><!-- .entry-content -->

	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
