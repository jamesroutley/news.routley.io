<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ckochis.com/building-a-vector-map-from-scratch">Original</a>
    <h1>I built a vector map from scratch</h1>
    
    <div id="readability-page-1" class="page"><div id="__next" data-reactroot=""><div><div><div><p>I‚Äôve always been fascinated with maps, and they‚Äôre one of my favorite type of UX on the web. So when I wanted to learn a bit more about 3D programming and WebGL, it made sense to try and implement something I was already familiar with; a vector map.</p><p>This article covers my process of building a vector-tile map from the ground up. I&#39;ve broken it up into three main parts:</p><ul><li><a href="#rendering-and-interaction">Part 1: WebGL Rendering and Interaction</a></li><li><a href="#vector-tiles">Part 2: Vector Tiles</a></li><li><a href="#optimization-and-cleanup">Part 3: Optimization and Cleanup</a></li></ul><p><em>TL;DR - You can also head straight to the <a href="https://github.com/kochis/webgl-map">source</a> or check out the <a href="https://ckochis.com/webgl-map-demo">final product</a>.</em></p><h2 id="rendering-and-interaction">Part 1: WebGL Rendering and Interaction</h2><p>If you&#39;ve ever wondered exactly <em>how</em> vector maps like Mapbox or Google Maps are rendered, this aticle should break down a few of the lower-level concepts for what goes on under the hood when using a vector based map. The implementation details in these examples won‚Äôt match exactly what other maps do, but the concepts should still be more-or-less the same.</p><p>I&#39;m also still fairly new 3D programming, so feel free to shoot me a note if there are any suggestions or improvements to the code. üòÖ</p></div><div id="web-mercator-projection"><p>To start, we should probably talk a bit about map projections, in particular the <a href="https://en.wikipedia.org/wiki/Mercator_projection" target="_blank">Mercator projection</a>. It‚Äôs the standard projection you‚Äôll see in almost all web-based maps. One thing to note, is the distance between latitudes becomes greater near the poles, so there‚Äôs a decent amount of distortion the further north and south points are.</p><div><div><p><img src="https://ckochis.com/images/mercator-distortion.svg" alt="circles indicate level of distortion near the poles."/></p><p>circles indicate level of distortion near the poles.</p></div></div><p>The <a href="https://en.wikipedia.org/wiki/Web_Mercator_projection" target="_blank">Web Mercator projection</a> is a slight variation on Mercator, but the formulas still mostly apply. For web maps, the origin (0, 0) is considered to be at the top-left, with x+ increasing to the right, and y+ increasing downwards.</p><div><p><img src="https://ckochis.com/images/mercator-xy.png" srcset="/images/mercator-xy.png 1x, /images/mercator-xy@2x.png 2x" alt="mercator coordinate system"/></p></div><p>So we can use the projection formulas convert our latitude &amp; longitude values to an XY value on the map. For these examples, I‚Äôm going to use code from the <a href="https://github.com/mapbox/mapbox-gl-js/blob/main/src/geo/mercator_coordinate.js#L81" target="_blank">MercatorCoordinate</a> class that is a part of the Mapbox GL JS library.</p><p><span><code>class MercatorCoordinate {
  static mercatorXfromLng(lng) {
    return (180 + lng) / 360;
  }

  static mercatorYfromLat(lat) {
    return (180 - (180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360)))) / 360;
  }

  static fromLngLat(lngLat) {
    const x = MercatorCoordinate.mercatorXfromLng(lngLat[0]);
    const y = MercatorCoordinate.mercatorYfromLat(lngLat[1]);
    return [x, y];
  }
}</code></span></p><p>So if we take an example point <span>[-73.9911, 40.7343]</span> (NYC), we can convert it to a point in the XY space. We&#39;ll call this coordinate system the &#34;world space&#34;. We can think of this as a single map tile at zoom level 0.</p><p><span><code>const [x, y] = MercatorCoordinate.fromLngLat([-73.9911, 40.7343]);
x // 0.294469
y // 0.375901</code></span></p><div><div><p><img src="https://ckochis.com/images/world-xy.png" srcset="/images/world-xy.png 1x, /images/world-xy@2x.png 2x" alt="lat/lng coordinates converted to XY world space."/></p><p>lat/lng coordinates converted to XY world space.</p></div></div></div><div id="webgl-clip-space"><p>Now that we have our ‚Äúworld space‚Äù coordinates, we can convert them to the ‚Äúclip space‚Äù coordinates that WebGL uses to render a scene. The clip space is slightly different than our world space, in that the origin is at the center, and going from [-1, 1] on the axes.</p><div><div><p><img src="https://ckochis.com/images/clip-space.png" srcset="/images/clip-space.png 1x, /images/clip-space@2x.png 2x" alt="webgl clip space"/></p><p>webgl clip space</p></div></div><p>So we can convert our world space -&gt; clip space with some pretty basic math. This can also be done via a matrix transformation (which we‚Äôll cover later), but for simplicity we can just do this conversion in our MercatorCoordinate utility.</p><p><span><code>static fromLngLat(lngLat) {
  let x = MercatorCoordinate.mercatorXfromLng(lngLat[0]);
  let y = MercatorCoordinate.mercatorYfromLat(lngLat[1]);

  // adjust so relative to origin at center of viewport, instead of top-left
  x = -1 + (x * 2);
  y = 1 - (y * 2);

  return [x, y];
}</code></span></p><div><div><p><img src="https://ckochis.com/images/clip-xy.png" srcset="/images/clip-xy.png 1x, /images/clip-xy@2x.png 2x" alt="lat/lng coordinates converted to webgl clip space."/></p><p>lat/lng coordinates converted to webgl clip space.</p></div></div></div><div id="rendering-a-bounding-box"><p>Now that we have a way to convert latitude &amp; longitude to our WebGL coordinate space, lets go ahead and draw something! We‚Äôll start simple and draw a basic bounding box.</p><p>Since our initial view is zoomed all the way out (zoom level 0), we‚Äôll use a box large enough to see, so we‚Äôll <a href="http://geojson.io/#data=data:application/json,%7B%22type%22%3A%22Feature%22%2C%22properties%22%3A%7B%22bbox%22%3A%22usa%22%7D%2C%22geometry%22%3A%7B%22type%22%3A%22Polygon%22%2C%22coordinates%22%3A%5B%5B%5B-126.03515625%2C23.079731762449878%5D%2C%5B-60.1171875%2C23.079731762449878%5D%2C%5B-60.1171875%2C50.233151832472245%5D%2C%5B-126.03515625%2C50.233151832472245%5D%2C%5B-126.03515625%2C23.079731762449878%5D%5D%5D%7D%7D" target="_blank">bound the continental US</a>.</p><p><span><code>const USA_BBOX = [
  [-126.03515625, 23.079731762449878],
  [-60.1171875, 23.079731762449878],
  [-60.1171875, 50.233151832472245],
  [-126.03515625, 50.233151832472245]
];</code></span></p><p>In order to render a box in WebGL, we need to convert it into a set of triangles, which is the smallest primitive type for rendering a surface. A rectangle is a pretty simple shape, which can be drawn with two triangles. Since the box has 4 coordinates, we can arrange them like so to form a rectangle from two triangles.</p><p><img src="https://ckochis.com/images/info-icon.svg" width="14" height="14"/><b>Note:</b> Since WebGL only supports a few primitives, this is generally where something like three.js would come in handy, as it has better abstractions for <a href="https://r105.threejsfundamentals.org/threejs/lessons/threejs-primitives.html" target="_blank">drawing shapes</a>.</p><div><div><p><img src="https://ckochis.com/images/bbox-triangle.svg" alt="a webgl box can be formed with two triangles."/></p><p>a webgl box can be formed with two triangles.</p></div></div><p>To render the triangles, we‚Äôll convert each lat/lng from our box into clip-space, and construct an array with each of the vertices for the triangles (so 6 points in total).</p><p><span><code>const [nw_x, nw_y] = MercatorCoordinate.fromLngLat(USA_BBOX[0]);
const [ne_x, ne_y] = MercatorCoordinate.fromLngLat(USA_BBOX[1]);
const [se_x, se_y] = MercatorCoordinate.fromLngLat(USA_BBOX[2]);
const [sw_x, sw_y] = MercatorCoordinate.fromLngLat(USA_BBOX[3]);

const positions = [
  // triangle 1
  nw_x, nw_y,
  ne_x, ne_y,
  se_x, se_y,

  // triangle 2
  se_x, se_y,
  sw_x, sw_y,
  nw_x, nw_y,
];</code></span></p><p>Now that we have our vertices, we need to render it to a <span>&lt;canvas&gt;</span>.</p><p>Unfortunately, there is a lot of boilerplate needed to setup a WebGL scene, so I‚Äôll document most of this in the code snippet below. But the gist is:</p><ul><li>Get a WebGL context from our canvas element</li><li>Compile the shaders, and setup our program</li><li>Convert our lat/lng‚Äôs to clip-space vertices</li><li>Tell WebGL to render the triangles</li></ul><p>After doing all that, you can see the rectangle in the upper-left quadrant of the grid. This is where we&#39;d expect it to be based on the image we&#39;ve been using as a reference so far. You can also toggle the map on to check that it&#39;s rendered correctly.</p><div><div><p><img src="https://ckochis.com/images/map-tile.jpg" alt="map reference image" width="512" height="512"/></p><canvas id="part1bbox" width="512" height="512"></canvas><p><label for="showMap1">Show map</label></p></div></div><div><p>+ See Code</p><div id="collapsible-content-1660876679967" role="region" aria-labelledby="collapsible-trigger-1660876679967"><div><div><ul><li><span>script.js</span></li><li><span>mercator-coordinate.js</span></li><li><span>webgl-utils.js</span></li></ul><div><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span><span>58
</span><span>59
</span><span>60
</span><span>61
</span><span>62
</span><span>63
</span><span>64
</span><span>65
</span><span>66
</span><span>67
</span><span>68
</span><span>69
</span><span>70
</span><span>71
</span><span>72
</span><span>73
</span><span>74
</span><span>75
</span><span>76
</span><span>77
</span><span>78
</span><span>79
</span><span>80
</span><span>81
</span><span>82
</span><span>83
</span><span>84
</span><span>85
</span><span>86
</span><span>87
</span><span>88
</span><span>89
</span><span>90
</span><span>91
</span><span>92
</span><span>93
</span><span>94
</span><span>95
</span><span>96
</span><span>97
</span><span>98
</span><span>99
</span><span>100
</span><span>101
</span><span>102
</span></code><code>import MercatorCoordinate from &#39;./mercator-coordinate&#39;;
import { createShader, createProgram } from &#39;./webgl-utils&#39;;

//////////////////////
// constants
//////////////////////
const USA_BBOX = [
  [-126.03515625, 23.079731762449878],
  [-60.1171875, 23.079731762449878],
  [-60.1171875, 50.233151832472245],
  [-126.03515625, 50.233151832472245]
];

//////////////////////
// shaders
//////////////////////

// vertex shader just passes through the position,
// no modification to the vertices
const vertexShaderSource = `
  attribute vec2 a_position;

  void main() {
    gl_Position = vec4(a_position, 0, 1);
  }
`;

// color is constant for all vertices
const fragmentShaderSource =`
  precision mediump float;

  void main() {
    gl_FragColor = vec4(1, 0, 0.5, 0.5);
  }
`;

//////////////////////
// main program
//////////////////////
const run = (canvasId) =&gt; {
  // get GL context from canvas
  const canvas = document.getElementById(canvasId);
  const gl = canvas.getContext(&#34;webgl&#34;);

  // setup viewport
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // compile shaders
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  // init gl program
  const program = createProgram(gl, vertexShader, fragmentShader);
  gl.clearColor(0, 0, 0, 0);
  gl.useProgram(program);

  // create buffer for vertices
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  // add vertices to buffer
  const [nw_x, nw_y] = MercatorCoordinate.fromLngLat(USA_BBOX[0]);
  const [ne_x, ne_y] = MercatorCoordinate.fromLngLat(USA_BBOX[1]);
  const [se_x, se_y] = MercatorCoordinate.fromLngLat(USA_BBOX[2]);
  const [sw_x, sw_y] = MercatorCoordinate.fromLngLat(USA_BBOX[3]);

  const positions = [
    // triangle 1
    nw_x, nw_y,
    ne_x, ne_y,
    se_x, se_y,

    // triangle 2
    se_x, se_y,
    sw_x, sw_y,
    nw_x, nw_y,
  ];
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

  // enable on the position attribute
  const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
  gl.enableVertexAttribArray(positionAttributeLocation);

  const draw = () =&gt; {
    // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
    const size = 2;
    const type = gl.FLOAT;
    const normalize = false;
    const stride = 0;
    let offset = 0; 
    gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

    // draw
    const primitiveType = gl.TRIANGLES;
    offset = 0;
    const count = 6;
    gl.drawArrays(primitiveType, offset, count);
  }
  draw();
};

export default run;
</code></span></p></div></div></div></div></div></div><div id="adding-interactivity"><p>To have a useful map, we‚Äôll also want the ability to move around. We can add some basic map behaviors such as pan &amp; zoom.</p><p>To do this, we‚Äôll need to introduce the idea of a ‚Äúcamera‚Äù for moving the viewport around the scene. This differs from a traditional camera, in that instead of moving the camera around, we‚Äôll actually move the <em>world</em> around the camera. For instance, if we want to pan to the left, we‚Äôll actually move all the vertices in our scene to the right by that same amount (we‚Äôre basically inverting the behavior we‚Äôd expect).</p><p>For our purposes, the camera will keep track of the XY position, and the current zoom level. These will then be represented as vectors, that when applied to a matrix (ie. the <em>projection matrix</em>) will make up the final state of the scene.</p><p>We can think of each vertex on our map as vector with three points: [x, y, z]. The idea behind using a matrix is that we can multiply the vector by the matrix to get the <em>new</em> vector position. For instance, if we take our vertices from above and multiply them by the identity matrix, we can see we get the same result (ie. no transformation).</p><div><p><img src="https://ckochis.com/images/part-1-identity-matrix.png" alt="identity matrix"/></p></div><p><img src="https://ckochis.com/images/info-icon.svg" width="14" height="14"/><b>Note:</b> since WebGL is a 3D interface, it expects vertices to have <em>x</em>, <em>y</em>, and <em>z</em> values. Since we‚Äôre only dealing with <em>xy</em> values, <em>z</em> can mostly be ignored.</p><p>If we wanted to pan the map to the right, we need to translate all of the vertices by the same amount the mouse has moved (in this case, in the x+ direction). So if the map was panned 20 pixels to the right, we‚Äôd convert that 20px to clip-space (0.92), and can represent the translation with the following matrix.</p><div><p><img src="https://ckochis.com/images/part-1-translate-matrix.png" alt="translate matrix"/></p></div><p>Similarly, if we wanted to apply a zoom, we can add a scale factor that gets multiplied to the vertices. For zooming, that factor is 2<sup>zoom</sup>. So if we at a zoom level of 1, our scale factor is 2.</p><div><p><img src="https://ckochis.com/images/part-1-scale-matrix.png" alt="scale matrix"/></p></div><p>One other caveat with zoom, if we want to zoom in on the mouse position, we&#39;ll need to grab the pre &amp; post transformation positions of where the mouse is, and translate accordingly. There&#39;s a <a href="https://webglfundamentals.org/webgl/lessons/webgl-qna-how-to-implement-zoom-from-mouse-in-2d-webgl.html" target="_blank">great article</a> at <a href="https://webglfundamentals.org/" target="_blank">webglfundamentals.org</a> that covers this in depth, so I won&#39;t go into too much detail there.</p><p>The matrix containing the scale and translation values is what we‚Äôll then pass into our vertex shader, so these vertex computations can be done on the GPU.</p><p><span><code>attribute vec2 a_position;

uniform mat3 u_matrix; // 3 X 3 matrix

void main() {
  vec2 position = (u_matrix * vec3(a_position, 1)).xy;
  gl_Position = vec4(position, 0, 1);
}</code></span></p><p>Once we setup the event handlers and update our matrix, we should be able to pan &amp; zoom the bounding box. I&#39;m using the <a href="https://glmatrix.net/" target="_blank">glMatrix</a> library to handle the matrix math.</p><div><p>+ See Code</p><div id="collapsible-content-1660876679970" role="region" aria-labelledby="collapsible-trigger-1660876679970"><div><div><ul><li><span>script.js</span></li><li><span>mercator-coordinate.js</span></li><li><span>webgl-utils.js</span></li></ul><div><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span><span>58
</span><span>59
</span><span>60
</span><span>61
</span><span>62
</span><span>63
</span><span>64
</span><span>65
</span><span>66
</span><span>67
</span><span>68
</span><span>69
</span><span>70
</span><span>71
</span><span>72
</span><span>73
</span><span>74
</span><span>75
</span><span>76
</span><span>77
</span><span>78
</span><span>79
</span><span>80
</span><span>81
</span><span>82
</span><span>83
</span><span>84
</span><span>85
</span><span>86
</span><span>87
</span><span>88
</span><span>89
</span><span>90
</span><span>91
</span><span>92
</span><span>93
</span><span>94
</span><span>95
</span><span>96
</span><span>97
</span><span>98
</span><span>99
</span><span>100
</span><span>101
</span><span>102
</span><span>103
</span><span>104
</span><span>105
</span><span>106
</span><span>107
</span><span>108
</span><span>109
</span><span>110
</span><span>111
</span><span>112
</span><span>113
</span><span>114
</span><span>115
</span><span>116
</span><span>117
</span><span>118
</span><span>119
</span><span>120
</span><span>121
</span><span>122
</span><span>123
</span><span>124
</span><span>125
</span><span>126
</span><span>127
</span><span>128
</span><span>129
</span><span>130
</span><span>131
</span><span>132
</span><span>133
</span><span>134
</span><span>135
</span><span>136
</span><span>137
</span><span>138
</span><span>139
</span><span>140
</span><span>141
</span><span>142
</span><span>143
</span><span>144
</span><span>145
</span><span>146
</span><span>147
</span><span>148
</span><span>149
</span><span>150
</span><span>151
</span><span>152
</span><span>153
</span><span>154
</span><span>155
</span><span>156
</span><span>157
</span><span>158
</span><span>159
</span><span>160
</span><span>161
</span><span>162
</span><span>163
</span><span>164
</span><span>165
</span><span>166
</span><span>167
</span><span>168
</span><span>169
</span><span>170
</span><span>171
</span><span>172
</span><span>173
</span><span>174
</span><span>175
</span><span>176
</span><span>177
</span><span>178
</span><span>179
</span><span>180
</span><span>181
</span><span>182
</span><span>183
</span><span>184
</span><span>185
</span><span>186
</span><span>187
</span><span>188
</span><span>189
</span><span>190
</span><span>191
</span><span>192
</span><span>193
</span><span>194
</span><span>195
</span><span>196
</span><span>197
</span><span>198
</span><span>199
</span><span>200
</span><span>201
</span><span>202
</span><span>203
</span><span>204
</span><span>205
</span><span>206
</span><span>207
</span><span>208
</span><span>209
</span><span>210
</span><span>211
</span><span>212
</span><span>213
</span><span>214
</span><span>215
</span><span>216
</span><span>217
</span><span>218
</span><span>219
</span><span>220
</span><span>221
</span><span>222
</span><span>223
</span><span>224
</span><span>225
</span><span>226
</span><span>227
</span><span>228
</span><span>229
</span><span>230
</span><span>231
</span><span>232
</span><span>233
</span><span>234
</span><span>235
</span><span>236
</span><span>237
</span><span>238
</span><span>239
</span><span>240
</span><span>241
</span><span>242
</span><span>243
</span><span>244
</span><span>245
</span><span>246
</span><span>247
</span><span>248
</span><span>249
</span><span>250
</span><span>251
</span><span>252
</span><span>253
</span><span>254
</span><span>255
</span><span>256
</span><span>257
</span><span>258
</span><span>259
</span><span>260
</span><span>261
</span><span>262
</span><span>263
</span><span>264
</span><span>265
</span><span>266
</span><span>267
</span><span>268
</span><span>269
</span><span>270
</span><span>271
</span><span>272
</span><span>273
</span><span>274
</span><span>275
</span><span>276
</span><span>277
</span><span>278
</span></code><code>import { mat3, vec3 } from &#39;gl-matrix&#39;;
import MercatorCoordinate from &#39;./mercator-coordinate&#39;;
import { createShader, createProgram } from &#39;./webgl-utils&#39;;

//////////////////////
// constants
//////////////////////
const MIN_ZOOM = 0;
const MAX_ZOOM = 16;

const USA_BBOX = [
  [-126.03515625, 23.079731762449878],
  [-60.1171875, 23.079731762449878],
  [-60.1171875, 50.233151832472245],
  [-126.03515625, 50.233151832472245]
];

//////////////////////
// shaders
//////////////////////

// vertex shader just passes through the position,
// no modification to the vertices
const vertexShaderSource = `
  attribute vec2 a_position;

  uniform mat3 u_matrix; // 3 X 3 matrix

  void main() {
    vec2 position = (u_matrix * vec3(a_position, 1)).xy;
    gl_Position = vec4(position, 0, 1);
  }
`;

// color is constant for all vertices
const fragmentShaderSource =`
  precision mediump float;

  void main() {
    gl_FragColor = vec4(1, 0, 0.5, 0.5);
  }
`;

//////////////////////
// map state
//////////////////////
const camera = {
  x: 0,
  y: 0,
  zoom: 0,
};

let matrix;
function updateMatrix() {
  const cameraMat = mat3.create();

  // translate
  mat3.translate(cameraMat, cameraMat, [camera.x, camera.y]);

  // scale
  const zoomScale = 1 / Math.pow(2, camera.zoom);
  mat3.scale(cameraMat, cameraMat, [zoomScale, zoomScale]);

  // update matrix
  matrix = mat3.multiply(
    [],
    mat3.create(), // identity matrix
    mat3.invert([], cameraMat) // invert camera position
  );
}
updateMatrix();

//////////////////////
// helpers
//////////////////////
function getClipSpacePosition(e, canvas) {
  // handle mouse and touch events
  const [x, y] = [
    e.center?.x || e.clientX,
    e.center?.y || e.clientY
  ];

  // get canvas relative css position
  const rect = canvas.getBoundingClientRect();
  const cssX = x - rect.left;
  const cssY = y - rect.top;

  // get normalized 0 to 1 position across and down canvas
  const normalizedX = cssX / canvas.clientWidth;
  const normalizedY = cssY / canvas.clientHeight;

  // convert to clip space
  const clipX = normalizedX *  2 - 1;
  const clipY = normalizedY * -2 + 1;

  return [clipX, clipY];
}

//////////////////////
// main program
//////////////////////
const run = (canvasId) =&gt; {
  // get GL context from canvas
  const canvas = document.getElementById(canvasId);
  const gl = canvas.getContext(&#34;webgl&#34;);

  // setup viewport
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // compile shaders
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  // init gl program
  const program = createProgram(gl, vertexShader, fragmentShader);
  gl.clearColor(0, 0, 0, 0);
  gl.useProgram(program);

  // create buffer for vertices
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  // add vertices to buffer
  const [nw_x, nw_y] = MercatorCoordinate.fromLngLat(USA_BBOX[0]);
  const [ne_x, ne_y] = MercatorCoordinate.fromLngLat(USA_BBOX[1]);
  const [se_x, se_y] = MercatorCoordinate.fromLngLat(USA_BBOX[2]);
  const [sw_x, sw_y] = MercatorCoordinate.fromLngLat(USA_BBOX[3]);

  const positions = [
    // triangle 1
    nw_x, nw_y,
    ne_x, ne_y,
    se_x, se_y,

    // triangle 2
    se_x, se_y,
    sw_x, sw_y,
    nw_x, nw_y,
  ];
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

  // enable on the position attribute
  const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
  gl.enableVertexAttribArray(positionAttributeLocation);

  const draw = () =&gt; {

    // set matrix as uniform
    const matrixLocation = gl.getUniformLocation(program, &#34;u_matrix&#34;);
    gl.uniformMatrix3fv(matrixLocation, false, matrix);

    // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
    const size = 2;
    const type = gl.FLOAT;
    const normalize = false;
    const stride = 0;
    let offset = 0; 
    gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

    // draw
    const primitiveType = gl.TRIANGLES;
    offset = 0;
    const count = 6;
    gl.drawArrays(primitiveType, offset, count);
  }
  draw(); // initial draw


  ////////////////////////
  // interaction handlers
  ////////////////////////

  // handle touch events
  const Hammer = require(&#39;hammerjs&#39;);
  const hammer = new Hammer(canvas);
  hammer.get(&#39;pan&#39;).set({ direction: Hammer.DIRECTION_ALL });
  hammer.get(&#39;pinch&#39;).set({ enable: true });

  // handle pan events
  let startX;
  let startY;

  // handle drag changes while mouse is still down
  const handleMove = (moveEvent) =&gt; {
    const [x, y] = getClipSpacePosition(moveEvent, canvas);

    // compute the previous position in world space
    const [preX, preY] = vec3.transformMat3(
      [],
      [startX, startY, 0],
      mat3.invert([], matrix)
    );

    // compute the new position in world space
    const [postX, postY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // move that amount, because how much the position changes depends on the zoom level
    const deltaX = preX - postX;
    const deltaY = preY - postY;
    if (isNaN(deltaX) || isNaN(deltaY)) {
      return; // abort
    }

    // only update within world limits
    camera.x += deltaX;
    camera.y += deltaY;

    // save current pos for next movement
    startX = x;
    startY = y;

    // update matrix with new camera and redraw scene
    updateMatrix();
    draw();
  };

  const handlePan = (startEvent) =&gt; {
    // get position of initial drag
    [startX, startY] = getClipSpacePosition(startEvent, canvas);
    canvas.style.cursor = &#39;grabbing&#39;;

    window.addEventListener(&#39;mousemove&#39;, handleMove);
    hammer.on(&#39;pan&#39;, handleMove);

    // clear on release
    const clear = (event) =&gt; {
      canvas.style.cursor = &#39;grab&#39;;
      window.removeEventListener(&#39;mousemove&#39;, handleMove);
      window.removeEventListener(&#39;mouseup&#39;, clear);
      hammer.off(&#39;pan&#39;, handleMove);
      hammer.off(&#39;panend&#39;, clear);
    };
    window.addEventListener(&#39;mouseup&#39;, clear);
    hammer.on(&#39;panend&#39;, clear);
  }
  canvas.addEventListener(&#39;mousedown&#39;, handlePan);
  hammer.on(&#39;panstart&#39;, handlePan);

  // handle zoom events
  const handleZoom = (wheelEvent) =&gt; {
    wheelEvent.preventDefault();
    const [x, y] = getClipSpacePosition(wheelEvent, canvas);

    // get position before zooming
    const [preZoomX, preZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // update current zoom state
    const zoomDelta = -wheelEvent.deltaY * (1 / 300);
    camera.zoom += zoomDelta;
    camera.zoom = Math.max(MIN_ZOOM, Math.min(camera.zoom, MAX_ZOOM));
    updateMatrix();

    // get new position after zooming
    const [postZoomX, postZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // camera needs to be translated the difference of before and after
    camera.x += preZoomX - postZoomX;
    camera.y += preZoomY - postZoomY;
    updateMatrix();
    draw();
  }
  canvas.addEventListener(&#39;wheel&#39;, handleZoom);
  hammer.on(&#39;pinch&#39;, handleZoom);
};

export default run;
</code></span></p></div></div></div></div></div></div><div id="rendering-geojson"><p>Let‚Äôs now take a stab at rendering something a little more complex than a rectangle. For instance, this <a href="https://gist.github.com/kochis/4c6b0eb4468a8700db45044b70cefe86">polygon of Washington state</a> (my home state!)</p><div><div><p><img src="https://ckochis.com/images/washington-geojson.png" alt="geojson polygon for washington state"/></p><p>geojson polygon for washington state</p></div></div><p>Like the rectangle, we‚Äôll also need to divide the shape up into triangles, though it‚Äôs a little less obvious how to do that for a shape of this complexity. Fortunately, there are a number of libraries that do just that. We‚Äôll use <a href="https://github.com/mapbox/earcut" target="_blank">Mapbox‚Äôs earcut</a>, since it has support for GeoJSON geometries out-of-the-box.</p><p>To use earcut, we‚Äôll first need to flatten the polygon into a single array of coordinates, and then pass that into the earcut for triangulation. The result is an array of indices for how to draw the triangles. One thing to note, each point in triangles array is for <em>both</em> the latitude &amp; longitude, so you‚Äôll need to get the vertices from <span>vertices[i]</span> and <span>vertices[i + 1]</span>.</p><p><span><code>// convert a GeoJSON geometry to webgl vertices
const geometryToVertices = (geometry) =&gt; {
  const data = earcut.flatten(geometry.coordinates);
  const triangles = earcut(data.vertices, data.holes, 2);

  const vertices = new Float32Array(triangles.length * 2);
  for (let i = 0; i &lt; triangles.length; i++) {
    const point = triangles[i];
    const lng = data.vertices[point * 2];
    const lat = data.vertices[point * 2 + 1];
    const [x, y] = MercatorCoordinate.fromLngLat([lng, lat]);
    vertices[i * 2] = x;
    vertices[i * 2 + 1] = y;
  }
  return vertices;
}</code></span></p><p>Now that we have  our vertices, let‚Äôs swap that out for our bounding box from earlier. We&#39;ll also need to set the initial camera position to be closer to the actual geometry. We can see the triangles by changing the primitive type to <span>gl.LINES</span>.</p><div><p>+ See Code</p><div id="collapsible-content-1660876679977" role="region" aria-labelledby="collapsible-trigger-1660876679977"><div><div><ul><li><span>script.js</span></li><li><span>mercator-coordinate.js</span></li><li><span>webgl-utils.js</span></li></ul><div><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span><span>58
</span><span>59
</span><span>60
</span><span>61
</span><span>62
</span><span>63
</span><span>64
</span><span>65
</span><span>66
</span><span>67
</span><span>68
</span><span>69
</span><span>70
</span><span>71
</span><span>72
</span><span>73
</span><span>74
</span><span>75
</span><span>76
</span><span>77
</span><span>78
</span><span>79
</span><span>80
</span><span>81
</span><span>82
</span><span>83
</span><span>84
</span><span>85
</span><span>86
</span><span>87
</span><span>88
</span><span>89
</span><span>90
</span><span>91
</span><span>92
</span><span>93
</span><span>94
</span><span>95
</span><span>96
</span><span>97
</span><span>98
</span><span>99
</span><span>100
</span><span>101
</span><span>102
</span><span>103
</span><span>104
</span><span>105
</span><span>106
</span><span>107
</span><span>108
</span><span>109
</span><span>110
</span><span>111
</span><span>112
</span><span>113
</span><span>114
</span><span>115
</span><span>116
</span><span>117
</span><span>118
</span><span>119
</span><span>120
</span><span>121
</span><span>122
</span><span>123
</span><span>124
</span><span>125
</span><span>126
</span><span>127
</span><span>128
</span><span>129
</span><span>130
</span><span>131
</span><span>132
</span><span>133
</span><span>134
</span><span>135
</span><span>136
</span><span>137
</span><span>138
</span><span>139
</span><span>140
</span><span>141
</span><span>142
</span><span>143
</span><span>144
</span><span>145
</span><span>146
</span><span>147
</span><span>148
</span><span>149
</span><span>150
</span><span>151
</span><span>152
</span><span>153
</span><span>154
</span><span>155
</span><span>156
</span><span>157
</span><span>158
</span><span>159
</span><span>160
</span><span>161
</span><span>162
</span><span>163
</span><span>164
</span><span>165
</span><span>166
</span><span>167
</span><span>168
</span><span>169
</span><span>170
</span><span>171
</span><span>172
</span><span>173
</span><span>174
</span><span>175
</span><span>176
</span><span>177
</span><span>178
</span><span>179
</span><span>180
</span><span>181
</span><span>182
</span><span>183
</span><span>184
</span><span>185
</span><span>186
</span><span>187
</span><span>188
</span><span>189
</span><span>190
</span><span>191
</span><span>192
</span><span>193
</span><span>194
</span><span>195
</span><span>196
</span><span>197
</span><span>198
</span><span>199
</span><span>200
</span><span>201
</span><span>202
</span><span>203
</span><span>204
</span><span>205
</span><span>206
</span><span>207
</span><span>208
</span><span>209
</span><span>210
</span><span>211
</span><span>212
</span><span>213
</span><span>214
</span><span>215
</span><span>216
</span><span>217
</span><span>218
</span><span>219
</span><span>220
</span><span>221
</span><span>222
</span><span>223
</span><span>224
</span><span>225
</span><span>226
</span><span>227
</span><span>228
</span><span>229
</span><span>230
</span><span>231
</span><span>232
</span><span>233
</span><span>234
</span><span>235
</span><span>236
</span><span>237
</span><span>238
</span><span>239
</span><span>240
</span><span>241
</span><span>242
</span><span>243
</span><span>244
</span><span>245
</span><span>246
</span><span>247
</span><span>248
</span><span>249
</span><span>250
</span><span>251
</span><span>252
</span><span>253
</span><span>254
</span><span>255
</span><span>256
</span><span>257
</span><span>258
</span><span>259
</span><span>260
</span><span>261
</span><span>262
</span><span>263
</span><span>264
</span><span>265
</span><span>266
</span><span>267
</span><span>268
</span><span>269
</span><span>270
</span><span>271
</span><span>272
</span><span>273
</span><span>274
</span><span>275
</span><span>276
</span><span>277
</span><span>278
</span><span>279
</span><span>280
</span><span>281
</span></code><code>import { mat3, vec3 } from &#39;gl-matrix&#39;;
import earcut from &#39;earcut&#39;;
import MercatorCoordinate from &#39;./mercator-coordinate&#39;;
import { createShader, createProgram } from &#39;./webgl-utils&#39;;

//////////////////////
// constants
//////////////////////
import WASHINGTON from &#39;../data/washington.json&#39;;

const MIN_ZOOM = 0;
const MAX_ZOOM = 16;

//////////////////////
// shaders
//////////////////////

// vertex shader just passes through the position,
// no modification to the vertices
const vertexShaderSource = `
  attribute vec2 a_position;

  uniform mat3 u_matrix; // 3 X 3 matrix

  void main() {
    vec2 position = (u_matrix * vec3(a_position, 1)).xy;
    gl_Position = vec4(position, 0, 1);
  }
`;

// color is constant for all vertices
const fragmentShaderSource =`
  precision mediump float;

  void main() {
    gl_FragColor = vec4(1, 0, 0.5, 0.9);
  }
`;

//////////////////////
// map state
//////////////////////
const camera = {
  x: 0,
  y: 0,
  zoom: 0,
};

// initial transformation
camera.x = -0.6718187712249346;
camera.y = 0.29662864586475735;
camera.zoom = 5;

let matrix;
function updateMatrix() {
  const cameraMat = mat3.create();

  // translate
  mat3.translate(cameraMat, cameraMat, [camera.x, camera.y]);

  // scale
  const zoomScale = 1 / Math.pow(2, camera.zoom);
  mat3.scale(cameraMat, cameraMat, [zoomScale, zoomScale]);

  // update matrix
  matrix = mat3.multiply(
    [],
    mat3.create(), // identity matrix
    mat3.invert([], cameraMat) // invert camera position
  );
}
updateMatrix();

//////////////////////
// helpers
//////////////////////
function getClipSpacePosition(e, canvas) {
  // handle mouse and touch events
  const [x, y] = [
    e.center?.x || e.clientX,
    e.center?.y || e.clientY
  ];

  // get canvas relative css position
  const rect = canvas.getBoundingClientRect();
  const cssX = x - rect.left;
  const cssY = y - rect.top;

  // get normalized 0 to 1 position across and down canvas
  const normalizedX = cssX / canvas.clientWidth;
  const normalizedY = cssY / canvas.clientHeight;

  // convert to clip space
  const clipX = normalizedX *  2 - 1;
  const clipY = normalizedY * -2 + 1;

  return [clipX, clipY];
}

// convert a GeoJSON geometry to webgl vertices
function geometryToVertices(geometry) {
  const data = earcut.flatten(geometry.coordinates);
  const triangles = earcut(data.vertices, data.holes, 2);

  const vertices = new Float32Array(triangles.length * 2);
  for (let i = 0; i &lt; triangles.length; i++) {
    const point = triangles[i];
    const lng = data.vertices[point * 2];
    const lat = data.vertices[point * 2 + 1];
    const [x, y] = MercatorCoordinate.fromLngLat([lng, lat]);
    vertices[i * 2] = x;
    vertices[i * 2 + 1] = y;
  }
  return vertices;
}

//////////////////////
// main program
//////////////////////
const run = (canvasId) =&gt; {
  // get GL context from canvas
  const canvas = document.getElementById(canvasId);
  const gl = canvas.getContext(&#34;webgl&#34;);

  // setup viewport
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // compile shaders
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  // init gl program
  const program = createProgram(gl, vertexShader, fragmentShader);
  gl.clearColor(0, 0, 0, 0);
  gl.useProgram(program);

  // create buffer for vertices
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  // add vertices to buffer
  const vertices = geometryToVertices(WASHINGTON);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

  // enable on the position attribute
  const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
  gl.enableVertexAttribArray(positionAttributeLocation);

  const draw = () =&gt; {

    // set matrix as uniform
    const matrixLocation = gl.getUniformLocation(program, &#34;u_matrix&#34;);
    gl.uniformMatrix3fv(matrixLocation, false, matrix);

    // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
    const size = 2;
    const type = gl.FLOAT;
    const normalize = false;
    const stride = 0;
    let offset = 0; 
    gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

    // draw
    const primitiveType = gl.LINES;
    offset = 0;
    const count = vertices.length / 2;
    gl.drawArrays(primitiveType, offset, count);
  }
  draw(); // initial draw


  ////////////////////////
  // interaction handlers
  ////////////////////////

  // handle touch events
  const Hammer = require(&#39;hammerjs&#39;);
  const hammer = new Hammer(canvas);
  hammer.get(&#39;pan&#39;).set({ direction: Hammer.DIRECTION_ALL });
  hammer.get(&#39;pinch&#39;).set({ enable: true });

  // handle pan events
  let startX;
  let startY;

  // handle drag changes while mouse is still down
  const handleMove = (moveEvent) =&gt; {
    const [x, y] = getClipSpacePosition(moveEvent, canvas);

    // compute the previous position in world space
    const [preX, preY] = vec3.transformMat3(
      [],
      [startX, startY, 0],
      mat3.invert([], matrix)
    );

    // compute the new position in world space
    const [postX, postY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // move that amount, because how much the position changes depends on the zoom level
    const deltaX = preX - postX;
    const deltaY = preY - postY;
    if (isNaN(deltaX) || isNaN(deltaY)) {
      return; // abort
    }

    // only update within world limits
    camera.x += deltaX;
    camera.y += deltaY;

    // save current pos for next movement
    startX = x;
    startY = y;

    // update matrix with new camera and redraw scene
    updateMatrix();
    draw();
  }

  const handlePan = (startEvent) =&gt; {
    // get position of initial drag
    [startX, startY] = getClipSpacePosition(startEvent, canvas);
    canvas.style.cursor = &#39;grabbing&#39;;

    window.addEventListener(&#39;mousemove&#39;, handleMove);
    hammer.on(&#39;pan&#39;, handleMove);

    // clear on release
    const clear = (event) =&gt; {
      canvas.style.cursor = &#39;grab&#39;;
      window.removeEventListener(&#39;mousemove&#39;, handleMove);
      window.removeEventListener(&#39;mouseup&#39;, clear);
      hammer.off(&#39;pan&#39;, handleMove);
      hammer.off(&#39;panend&#39;, clear);
    };
    window.addEventListener(&#39;mouseup&#39;, clear);
    hammer.on(&#39;panend&#39;, clear);
  }
  canvas.addEventListener(&#39;mousedown&#39;, handlePan);
  hammer.on(&#39;panstart&#39;, handlePan);

  // handle zoom events
  const handleZoom = (wheelEvent) =&gt; {
    wheelEvent.preventDefault();
    const [x, y] = getClipSpacePosition(wheelEvent, canvas);

    // get position before zooming
    const [preZoomX, preZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // update current zoom state
    const zoomDelta = -wheelEvent.deltaY * (1 / 300);
    camera.zoom += zoomDelta;
    camera.zoom = Math.max(MIN_ZOOM, Math.min(camera.zoom, MAX_ZOOM));
    updateMatrix();

    // get new position after zooming
    const [postZoomX, postZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // camera needs to be translated the difference of before and after
    camera.x += preZoomX - postZoomX;
    camera.y += preZoomY - postZoomY;
    updateMatrix();
    draw();
  }
  canvas.addEventListener(&#39;wheel&#39;, handleZoom);
  hammer.on(&#39;pinch&#39;, handleZoom);
};

export default run;
</code></span></p></div></div></div></div></div><p>And if we want to do render a MultiPolygon, we can just combine the vertices from each polygon into a single array.</p><p><span><code>const geometryToVertices = (geometry) =&gt; {
  const verticesFromPolygon = (coordinates, n) =&gt; {
    const data = earcut.flatten(coordinates);
    const triangles = earcut(data.vertices, data.holes, 2);

    const vertices = new Float32Array(triangles.length * 2);
    for (let i = 0; i &lt; triangles.length; i++) {
      const point = triangles[i];
      const lng = data.vertices[point * 2];
      const lat = data.vertices[point * 2 + 1];
      const [x, y] = MercatorCoordinate.fromLngLat([lng, lat]);
      vertices[i * 2] = x;
      vertices[i * 2 + 1] = y;
    }
    return vertices;
  }

  if (geometry.type === &#39;Polygon&#39;) {
    return verticesFromPolygon(geometry.coordinates);
  }

  // concat all vertices from each polygon
  if (geometry.type === &#39;MultiPolygon&#39;) {
    const positions = [];
    geometry.coordinates.forEach((polygon, i) =&gt; {
      positions.push(...verticesFromPolygon([polygon[0]], i));
    });
    return Float32Array.from(positions);
  }

  // only support Polygon &amp; Multipolygon for now
  return new Float32Array();
}</code></span></p><div><p>+ See Code</p><div id="collapsible-content-1660876679981" role="region" aria-labelledby="collapsible-trigger-1660876679981"><div><div><ul><li><span>script.js</span></li><li><span>mercator-coordinate.js</span></li><li><span>webgl-utils.js</span></li></ul><div><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span><span>58
</span><span>59
</span><span>60
</span><span>61
</span><span>62
</span><span>63
</span><span>64
</span><span>65
</span><span>66
</span><span>67
</span><span>68
</span><span>69
</span><span>70
</span><span>71
</span><span>72
</span><span>73
</span><span>74
</span><span>75
</span><span>76
</span><span>77
</span><span>78
</span><span>79
</span><span>80
</span><span>81
</span><span>82
</span><span>83
</span><span>84
</span><span>85
</span><span>86
</span><span>87
</span><span>88
</span><span>89
</span><span>90
</span><span>91
</span><span>92
</span><span>93
</span><span>94
</span><span>95
</span><span>96
</span><span>97
</span><span>98
</span><span>99
</span><span>100
</span><span>101
</span><span>102
</span><span>103
</span><span>104
</span><span>105
</span><span>106
</span><span>107
</span><span>108
</span><span>109
</span><span>110
</span><span>111
</span><span>112
</span><span>113
</span><span>114
</span><span>115
</span><span>116
</span><span>117
</span><span>118
</span><span>119
</span><span>120
</span><span>121
</span><span>122
</span><span>123
</span><span>124
</span><span>125
</span><span>126
</span><span>127
</span><span>128
</span><span>129
</span><span>130
</span><span>131
</span><span>132
</span><span>133
</span><span>134
</span><span>135
</span><span>136
</span><span>137
</span><span>138
</span><span>139
</span><span>140
</span><span>141
</span><span>142
</span><span>143
</span><span>144
</span><span>145
</span><span>146
</span><span>147
</span><span>148
</span><span>149
</span><span>150
</span><span>151
</span><span>152
</span><span>153
</span><span>154
</span><span>155
</span><span>156
</span><span>157
</span><span>158
</span><span>159
</span><span>160
</span><span>161
</span><span>162
</span><span>163
</span><span>164
</span><span>165
</span><span>166
</span><span>167
</span><span>168
</span><span>169
</span><span>170
</span><span>171
</span><span>172
</span><span>173
</span><span>174
</span><span>175
</span><span>176
</span><span>177
</span><span>178
</span><span>179
</span><span>180
</span><span>181
</span><span>182
</span><span>183
</span><span>184
</span><span>185
</span><span>186
</span><span>187
</span><span>188
</span><span>189
</span><span>190
</span><span>191
</span><span>192
</span><span>193
</span><span>194
</span><span>195
</span><span>196
</span><span>197
</span><span>198
</span><span>199
</span><span>200
</span><span>201
</span><span>202
</span><span>203
</span><span>204
</span><span>205
</span><span>206
</span><span>207
</span><span>208
</span><span>209
</span><span>210
</span><span>211
</span><span>212
</span><span>213
</span><span>214
</span><span>215
</span><span>216
</span><span>217
</span><span>218
</span><span>219
</span><span>220
</span><span>221
</span><span>222
</span><span>223
</span><span>224
</span><span>225
</span><span>226
</span><span>227
</span><span>228
</span><span>229
</span><span>230
</span><span>231
</span><span>232
</span><span>233
</span><span>234
</span><span>235
</span><span>236
</span><span>237
</span><span>238
</span><span>239
</span><span>240
</span><span>241
</span><span>242
</span><span>243
</span><span>244
</span><span>245
</span><span>246
</span><span>247
</span><span>248
</span><span>249
</span><span>250
</span><span>251
</span><span>252
</span><span>253
</span><span>254
</span><span>255
</span><span>256
</span><span>257
</span><span>258
</span><span>259
</span><span>260
</span><span>261
</span><span>262
</span><span>263
</span><span>264
</span><span>265
</span><span>266
</span><span>267
</span><span>268
</span><span>269
</span><span>270
</span><span>271
</span><span>272
</span><span>273
</span><span>274
</span><span>275
</span><span>276
</span><span>277
</span><span>278
</span><span>279
</span><span>280
</span><span>281
</span><span>282
</span><span>283
</span><span>284
</span><span>285
</span><span>286
</span><span>287
</span><span>288
</span><span>289
</span><span>290
</span><span>291
</span><span>292
</span><span>293
</span><span>294
</span><span>295
</span><span>296
</span><span>297
</span><span>298
</span><span>299
</span><span>300
</span><span>301
</span><span>302
</span><span>303
</span><span>304
</span></code><code>import { mat3, vec3 } from &#39;gl-matrix&#39;;
import earcut from &#39;earcut&#39;;
import MercatorCoordinate from &#39;./mercator-coordinate&#39;;
import { createShader, createProgram } from &#39;./webgl-utils&#39;;

//////////////////////
// constants
//////////////////////
import USA from &#39;../data/usa_polygon.json&#39;;

const MIN_ZOOM = 0;
const MAX_ZOOM = 16;

//////////////////////
// shaders
//////////////////////

// vertex shader just passes through the position,
// no modification to the vertices
const vertexShaderSource = `
  attribute vec2 a_position;

  uniform mat3 u_matrix; // 3 X 3 matrix

  void main() {
    vec2 position = (u_matrix * vec3(a_position, 1)).xy;
    gl_Position = vec4(position, 0, 1);
  }
`;

// color is constant for all vertices
const fragmentShaderSource =`
  precision mediump float;

  void main() {
    gl_FragColor = vec4(1, 0, 0.5, 0.5);
  }
`;

//////////////////////
// map state
//////////////////////
const camera = {
  x: 0,
  y: 0,
  zoom: 0,
};

// initial transformation
camera.x = -0.6585079014803341;
camera.y = 0.3261614716054737;
camera.zoom = 1.64;

let matrix;
function updateMatrix() {
  const cameraMat = mat3.create();

  // translate
  mat3.translate(cameraMat, cameraMat, [camera.x, camera.y]);

  // scale
  const zoomScale = 1 / Math.pow(2, camera.zoom);
  mat3.scale(cameraMat, cameraMat, [zoomScale, zoomScale]);

  // update matrix
  matrix = mat3.multiply(
    [],
    mat3.create(), // identity matrix
    mat3.invert([], cameraMat) // invert camera position
  );
}
updateMatrix();

//////////////////////
// helpers
//////////////////////
function getClipSpacePosition(e, canvas) {
  // handle mouse and touch events
  const [x, y] = [
    e.center?.x || e.clientX,
    e.center?.y || e.clientY
  ];

  // get canvas relative css position
  const rect = canvas.getBoundingClientRect();
  const cssX = x - rect.left;
  const cssY = y - rect.top;

  // get normalized 0 to 1 position across and down canvas
  const normalizedX = cssX / canvas.clientWidth;
  const normalizedY = cssY / canvas.clientHeight;

  // convert to clip space
  const clipX = normalizedX *  2 - 1;
  const clipY = normalizedY * -2 + 1;

  return [clipX, clipY];
}

// convert a GeoJSON geometry to webgl vertices
function geometryToVertices(geometry) {
  const verticesFromPolygon = (coordinates, n) =&gt; {
    const data = earcut.flatten(coordinates);
    const triangles = earcut(data.vertices, data.holes, 2);

    const vertices = new Float32Array(triangles.length * 2);
    for (let i = 0; i &lt; triangles.length; i++) {
      const point = triangles[i];
      const lng = data.vertices[point * 2];
      const lat = data.vertices[point * 2 + 1];
      const [x, y] = MercatorCoordinate.fromLngLat([lng, lat]);
      vertices[i * 2] = x;
      vertices[i * 2 + 1] = y;
    }
    return vertices;
  }

  if (geometry.type === &#39;Polygon&#39;) {
    return verticesFromPolygon(geometry.coordinates);
  }

  if (geometry.type === &#39;MultiPolygon&#39;) {
    const positions = [];
    geometry.coordinates.forEach((polygon, i) =&gt; {
      const vertices = verticesFromPolygon([polygon[0]], i);

      // doing an array.push with too many values can cause
      // stack size errors, so we manually iterate and append
      vertices.forEach((vertex) =&gt; {
        positions[positions.length] = vertex;
      });
    });
    return Float32Array.from(positions);
  }

  // only support Polygon &amp; Multipolygon for now
  return new Float32Array();
}

//////////////////////
// main program
//////////////////////
const run = (canvasId) =&gt; {
  // get GL context from canvas
  const canvas = document.getElementById(canvasId);
  const gl = canvas.getContext(&#34;webgl&#34;);

  // setup viewport
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // compile shaders
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  // init gl program
  const program = createProgram(gl, vertexShader, fragmentShader);
  gl.clearColor(0, 0, 0, 0);
  gl.useProgram(program);

  // create buffer for vertices
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  // add vertices to buffer
  const vertices = geometryToVertices(USA.geometry);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

  // enable on the position attribute
  const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
  gl.enableVertexAttribArray(positionAttributeLocation);

  const draw = () =&gt; {

    // set matrix as uniform
    const matrixLocation = gl.getUniformLocation(program, &#34;u_matrix&#34;);
    gl.uniformMatrix3fv(matrixLocation, false, matrix);

    // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
    const size = 2;
    const type = gl.FLOAT;
    const normalize = false;
    const stride = 0;
    let offset = 0; 
    gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

    // draw
    const primitiveType = gl.TRIANGLES;
    offset = 0;
    const count = vertices.length / 2;
    gl.drawArrays(primitiveType, offset, count);
  }
  draw(); // initial draw


  ////////////////////////
  // interaction handlers
  ////////////////////////

  // handle touch events
  const Hammer = require(&#39;hammerjs&#39;);
  const hammer = new Hammer(canvas);
  hammer.get(&#39;pan&#39;).set({ direction: Hammer.DIRECTION_ALL });
  hammer.get(&#39;pinch&#39;).set({ enable: true });

  // handle pan events
  let startX;
  let startY;

  // handle drag changes while mouse is still down
  const handleMove = (moveEvent) =&gt; {
    const [x, y] = getClipSpacePosition(moveEvent, canvas);

    // compute the previous position in world space
    const [preX, preY] = vec3.transformMat3(
      [],
      [startX, startY, 0],
      mat3.invert([], matrix)
    );

    // compute the new position in world space
    const [postX, postY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // move that amount, because how much the position changes depends on the zoom level
    const deltaX = preX - postX;
    const deltaY = preY - postY;
    if (isNaN(deltaX) || isNaN(deltaY)) {
      return; // abort
    }

    // only update within world limits
    camera.x += deltaX;
    camera.y += deltaY;

    // save current pos for next movement
    startX = x;
    startY = y;

    // update matrix with new camera and redraw scene
    updateMatrix();
    draw();
  }

  const handlePan = (startEvent) =&gt; {
    // get position of initial drag
    [startX, startY] = getClipSpacePosition(startEvent, canvas);
    canvas.style.cursor = &#39;grabbing&#39;;

    window.addEventListener(&#39;mousemove&#39;, handleMove);
    hammer.on(&#39;pan&#39;, handleMove);

    // clear on release
    const clear = (event) =&gt; {
      canvas.style.cursor = &#39;grab&#39;;
      window.removeEventListener(&#39;mousemove&#39;, handleMove);
      window.removeEventListener(&#39;mouseup&#39;, clear);
      hammer.off(&#39;pan&#39;, handleMove);
      hammer.off(&#39;panend&#39;, clear);
    };
    window.addEventListener(&#39;mouseup&#39;, clear);
    hammer.on(&#39;panend&#39;, clear);
  }
  canvas.addEventListener(&#39;mousedown&#39;, handlePan);
  hammer.on(&#39;panstart&#39;, handlePan);

  // handle zoom events
  const handleZoom = (wheelEvent) =&gt; {
    wheelEvent.preventDefault();
    const [x, y] = getClipSpacePosition(wheelEvent, canvas);

    // get position before zooming
    const [preZoomX, preZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // update current zoom state
    const zoomDelta = -wheelEvent.deltaY * (1 / 300);
    camera.zoom += zoomDelta;
    camera.zoom = Math.max(MIN_ZOOM, Math.min(camera.zoom, MAX_ZOOM));
    updateMatrix();

    // get new position after zooming
    const [postZoomX, postZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // camera needs to be translated the difference of before and after
    camera.x += preZoomX - postZoomX;
    camera.y += preZoomY - postZoomY;
    updateMatrix();
    draw();
  }
  canvas.addEventListener(&#39;wheel&#39;, handleZoom);
  hammer.on(&#39;pinch&#39;, handleZoom);
};

export default run;
</code></span></p></div></div></div></div></div><p>At this point, we have a pretty solid foundation for our map. We can pan, zoom, and render complex geometries. In Part 2, will cover adding vector tile support.</p></div><div><h2 id="vector-tiles">Part 2: Vector Tiles</h2><p>In <a href="#rendering-and-interaction">Part 1</a> we created a map that can render GeoJSON polygons. While this is fine if you‚Äôre rendering a handful of geometries, it doesn‚Äôt scale well if you want to render many more layers, and across the whole planet. For instance, if we wanted to display every building in the US, we&#39;d need to load and render millions (or hundreds of millions) of vertices for the scene.</p><p>This is where tiling comes in. I cover this a bit in <a href="https://ckochis.com/vector-tiles">previous articles</a>, but the idea is the world is broken down into a grid at each zoom level, so we only need to load the data visible in our viewport.</p><p>For these examples, we&#39;ll be using a tile size of 512px (meaning each tile is 512 X 512 pixels).</p><div><p><img src="https://ckochis.com/images/vector-tile-pyramid.png" srcset="/images/vector-tile-pyramid.png 1x, /images/vector-tile-pyramid@2x.png 2x" alt="Web tile pyramid"/></p></div></div><div><p>The first thing to do, is figure out which tiles are in view given our viewport. To do this, we can figure out the lat/lng position of each corner of our viewport (we‚Äôll need to do some conversion math to go from the screen pixel to lat/lng). Once we have a lat/lng and zoom level, we can use that to determine which tile it‚Äôs in.</p><p>Mapbox has a nice utility library <a href="https://github.com/mapbox/tilebelt" target="_blank">tilebelt</a> for doing these lookups. We can use <span>pointToTile</span> to lookup the min &amp; max tiles once we know the bounding box of our viewport.</p><div><ul><li><span>getTilesInView()</span></li><li><span>getBounds()</span></li></ul><div><p><span><code>// get bbox from viewport
const bbox = getBounds();

// find min and max tiles
const z = Math.min(Math.trunc(camera.zoom), MAX_TILE_ZOOM);
const minTile = tilebelt.pointToTile(bbox[0], bbox[3], z); // top-left
const maxTile = tilebelt.pointToTile(bbox[2], bbox[1], z); // bottom-right

// tiles visible in viewport
tilesInView = [];
const [minX, maxX] = [Math.max(minTile[0], 0), maxTile[0]];
const [minY, maxY] = [Math.max(minTile[1], 0), maxTile[1]];
for (let x = minX; x &lt;= maxX; x++) {
  for (let y = minY; y &lt;= maxY; y++) {
    tilesInView.push([x, y, z]);
  }
}</code></span></p></div></div><p>One thing to keep in mind, is our viewport might be larger than 2 tiles (&gt; 1024px) so we‚Äôll probably want to consider all tiles between the min and max as ‚Äúin view‚Äù. For example, we could have something like the image below, where the viewport bounding box spans 12 tiles.</p><div><p><img src="https://ckochis.com/images/world-mercator-viewport.png" srcset="/images/world-mercator-viewport.png 1x, /images/world-mercator-viewport@2x.png 2x" alt="web tiles visible in viewport"/></p></div><p>As we move the map around, the tiles in view should update. Panning left &amp; right should change the tiles in view once we cross a border.</p><p>Zooming in &amp; out though is where the real ‚Äúmagic‚Äù of a vector map comes into play. Instead of jumping between discrete levels (1, 2, 3 etc‚Ä¶) we can just scale the geometries according to the zoom values in between integers (ie. 1.25 ‚Ä¶ 1.98). Once we cross into a new zoom integer, we‚Äôll need load a new set of tiles based on that level.</p><p>The best way to see how this works in action is to render the tile boundaries as we move around the map. We can use the code above for finding the tiles in view, and run them through <span>tilebel.tileToGeoJSON</span> to render them on the map.</p><p><img src="https://ckochis.com/images/info-icon.svg" width="14" height="14"/><b>Note:</b> the demo here is using a 256px tile size for demonstration purposes.</p></div><div><p>Now that we have a way to determine which tiles are in view, we can go ahead and fetch the vector data from a tileserver.</p><p>I covered <a href="https://ckochis.com/vector-tiles-from-osm">setting up a vector tile server</a> in a previous article, so I‚Äôm going to reuse the existing tile server from there. We just need to replace the x, y, and z values in the URL to fetch the correct tiles.</p><p><span><code>`https://maps.ckochis.com/data/v3/${z}/${x}/${y}.pbf`</code></span></p><p>You‚Äôll notice the URL ends with <span>.pbf</span>, so we‚Äôll be getting the data back in <a href="https://developers.google.com/protocol-buffers" target="_blank">Protobuf</a> format.  This is a binary format, that we‚Äôll need to deserialize into an object that we can use. Fortunately mapbox has a library that does this for us. <a href="https://github.com/mapbox/vector-tile-js" target="_blank">@mapbox/vector-tile</a> can deserialize PBF data into a VectorTile object according to the <a href="https://github.com/mapbox/vector-tile-spec" target="_blank">vector tile spec</a>.</p><p><span><code>const [x, y, z] = tile;

const res = await axios.get(`https://maps.ckochis.com/data/v3/${z}/${x}/${y}.pbf`, {
  responseType: &#39;arraybuffer&#39;,
});

const pbf = new Protobuf(res.data);
const vectorTile = new VectorTile(pbf);</code></span></p><p>If we inspect a tile, we can see a <span>.layers</span> field, which contains all the different layers we can potentially render for that tile.</p><p><span><code>Object.keys(vectorTile.layers);
//¬†[&#39;water&#39;, &#39;waterway&#39;, &#39;landcover&#39;, &#39;landuse&#39;, &#39;park&#39;, &#39;boundary&#39;, &#39;transportation&#39;, &#39;building&#39;, &#39;water_name&#39;, &#39;transportation_name&#39;, &#39;place&#39;, &#39;poi&#39;, &#39;aerodrome_label&#39;]</code></span></p><p>You‚Äôll notice VectorTile also has a <a href="https://github.com/mapbox/vector-tile-js#methods-1" target="_blank">toGeoJSON</a> function that we can call on each feature in the layer. As we demonstrated in Part 1, we have the ability to render a GeoJSON polygon using earcut. Given that, we should be able to render tiles using the following process:</p><ul><li>Detect changes to <span>tilesInView</span></li><li>Fetch each tile in view from the server</li><li>Convert the features to GeoJSON</li><li>Render the feature</li></ul><div><p>+ See Code</p><div id="collapsible-content-1660876680011" role="region" aria-labelledby="collapsible-trigger-1660876680011"><div><div><ul><li><span>script.js</span></li><li><span>mercator-coordinate.js</span></li><li><span>webgl-utils.js</span></li></ul><div><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span><span>58
</span><span>59
</span><span>60
</span><span>61
</span><span>62
</span><span>63
</span><span>64
</span><span>65
</span><span>66
</span><span>67
</span><span>68
</span><span>69
</span><span>70
</span><span>71
</span><span>72
</span><span>73
</span><span>74
</span><span>75
</span><span>76
</span><span>77
</span><span>78
</span><span>79
</span><span>80
</span><span>81
</span><span>82
</span><span>83
</span><span>84
</span><span>85
</span><span>86
</span><span>87
</span><span>88
</span><span>89
</span><span>90
</span><span>91
</span><span>92
</span><span>93
</span><span>94
</span><span>95
</span><span>96
</span><span>97
</span><span>98
</span><span>99
</span><span>100
</span><span>101
</span><span>102
</span><span>103
</span><span>104
</span><span>105
</span><span>106
</span><span>107
</span><span>108
</span><span>109
</span><span>110
</span><span>111
</span><span>112
</span><span>113
</span><span>114
</span><span>115
</span><span>116
</span><span>117
</span><span>118
</span><span>119
</span><span>120
</span><span>121
</span><span>122
</span><span>123
</span><span>124
</span><span>125
</span><span>126
</span><span>127
</span><span>128
</span><span>129
</span><span>130
</span><span>131
</span><span>132
</span><span>133
</span><span>134
</span><span>135
</span><span>136
</span><span>137
</span><span>138
</span><span>139
</span><span>140
</span><span>141
</span><span>142
</span><span>143
</span><span>144
</span><span>145
</span><span>146
</span><span>147
</span><span>148
</span><span>149
</span><span>150
</span><span>151
</span><span>152
</span><span>153
</span><span>154
</span><span>155
</span><span>156
</span><span>157
</span><span>158
</span><span>159
</span><span>160
</span><span>161
</span><span>162
</span><span>163
</span><span>164
</span><span>165
</span><span>166
</span><span>167
</span><span>168
</span><span>169
</span><span>170
</span><span>171
</span><span>172
</span><span>173
</span><span>174
</span><span>175
</span><span>176
</span><span>177
</span><span>178
</span><span>179
</span><span>180
</span><span>181
</span><span>182
</span><span>183
</span><span>184
</span><span>185
</span><span>186
</span><span>187
</span><span>188
</span><span>189
</span><span>190
</span><span>191
</span><span>192
</span><span>193
</span><span>194
</span><span>195
</span><span>196
</span><span>197
</span><span>198
</span><span>199
</span><span>200
</span><span>201
</span><span>202
</span><span>203
</span><span>204
</span><span>205
</span><span>206
</span><span>207
</span><span>208
</span><span>209
</span><span>210
</span><span>211
</span><span>212
</span><span>213
</span><span>214
</span><span>215
</span><span>216
</span><span>217
</span><span>218
</span><span>219
</span><span>220
</span><span>221
</span><span>222
</span><span>223
</span><span>224
</span><span>225
</span><span>226
</span><span>227
</span><span>228
</span><span>229
</span><span>230
</span><span>231
</span><span>232
</span><span>233
</span><span>234
</span><span>235
</span><span>236
</span><span>237
</span><span>238
</span><span>239
</span><span>240
</span><span>241
</span><span>242
</span><span>243
</span><span>244
</span><span>245
</span><span>246
</span><span>247
</span><span>248
</span><span>249
</span><span>250
</span><span>251
</span><span>252
</span><span>253
</span><span>254
</span><span>255
</span><span>256
</span><span>257
</span><span>258
</span><span>259
</span><span>260
</span><span>261
</span><span>262
</span><span>263
</span><span>264
</span><span>265
</span><span>266
</span><span>267
</span><span>268
</span><span>269
</span><span>270
</span><span>271
</span><span>272
</span><span>273
</span><span>274
</span><span>275
</span><span>276
</span><span>277
</span><span>278
</span><span>279
</span><span>280
</span><span>281
</span><span>282
</span><span>283
</span><span>284
</span><span>285
</span><span>286
</span><span>287
</span><span>288
</span><span>289
</span><span>290
</span><span>291
</span><span>292
</span><span>293
</span><span>294
</span><span>295
</span><span>296
</span><span>297
</span><span>298
</span><span>299
</span><span>300
</span><span>301
</span><span>302
</span><span>303
</span><span>304
</span><span>305
</span><span>306
</span><span>307
</span><span>308
</span><span>309
</span><span>310
</span><span>311
</span><span>312
</span><span>313
</span><span>314
</span><span>315
</span><span>316
</span><span>317
</span><span>318
</span><span>319
</span><span>320
</span><span>321
</span><span>322
</span><span>323
</span><span>324
</span><span>325
</span><span>326
</span><span>327
</span><span>328
</span><span>329
</span><span>330
</span><span>331
</span><span>332
</span><span>333
</span><span>334
</span><span>335
</span><span>336
</span><span>337
</span><span>338
</span><span>339
</span><span>340
</span><span>341
</span><span>342
</span><span>343
</span><span>344
</span><span>345
</span><span>346
</span><span>347
</span><span>348
</span><span>349
</span><span>350
</span><span>351
</span><span>352
</span><span>353
</span><span>354
</span><span>355
</span><span>356
</span><span>357
</span><span>358
</span><span>359
</span><span>360
</span><span>361
</span><span>362
</span><span>363
</span><span>364
</span><span>365
</span><span>366
</span><span>367
</span><span>368
</span><span>369
</span><span>370
</span><span>371
</span><span>372
</span><span>373
</span><span>374
</span><span>375
</span><span>376
</span><span>377
</span><span>378
</span><span>379
</span><span>380
</span><span>381
</span><span>382
</span><span>383
</span><span>384
</span><span>385
</span><span>386
</span><span>387
</span><span>388
</span><span>389
</span><span>390
</span><span>391
</span><span>392
</span><span>393
</span><span>394
</span><span>395
</span><span>396
</span><span>397
</span><span>398
</span><span>399
</span><span>400
</span><span>401
</span><span>402
</span><span>403
</span><span>404
</span><span>405
</span><span>406
</span><span>407
</span><span>408
</span><span>409
</span><span>410
</span><span>411
</span><span>412
</span><span>413
</span><span>414
</span><span>415
</span><span>416
</span><span>417
</span><span>418
</span><span>419
</span><span>420
</span><span>421
</span><span>422
</span><span>423
</span><span>424
</span><span>425
</span><span>426
</span><span>427
</span><span>428
</span><span>429
</span><span>430
</span><span>431
</span><span>432
</span><span>433
</span><span>434
</span><span>435
</span><span>436
</span><span>437
</span><span>438
</span><span>439
</span><span>440
</span><span>441
</span><span>442
</span><span>443
</span><span>444
</span><span>445
</span><span>446
</span><span>447
</span><span>448
</span><span>449
</span><span>450
</span><span>451
</span><span>452
</span><span>453
</span><span>454
</span><span>455
</span><span>456
</span><span>457
</span><span>458
</span><span>459
</span><span>460
</span><span>461
</span><span>462
</span><span>463
</span><span>464
</span><span>465
</span><span>466
</span><span>467
</span><span>468
</span><span>469
</span><span>470
</span><span>471
</span><span>472
</span><span>473
</span><span>474
</span><span>475
</span><span>476
</span><span>477
</span><span>478
</span><span>479
</span><span>480
</span><span>481
</span><span>482
</span><span>483
</span><span>484
</span><span>485
</span><span>486
</span><span>487
</span><span>488
</span><span>489
</span><span>490
</span><span>491
</span><span>492
</span><span>493
</span><span>494
</span><span>495
</span><span>496
</span><span>497
</span><span>498
</span><span>499
</span><span>500
</span><span>501
</span><span>502
</span><span>503
</span><span>504
</span><span>505
</span><span>506
</span><span>507
</span><span>508
</span><span>509
</span><span>510
</span><span>511
</span><span>512
</span><span>513
</span><span>514
</span><span>515
</span><span>516
</span><span>517
</span><span>518
</span><span>519
</span><span>520
</span><span>521
</span><span>522
</span></code><code>import axios from &#39;axios&#39;;
import Protobuf from &#39;pbf&#39;;
import { mat3, vec3 } from &#39;gl-matrix&#39;;
import earcut from &#39;earcut&#39;;
import tilebelt from &#39;@mapbox/tilebelt&#39;;
import { VectorTile } from &#39;@mapbox/vector-tile&#39;;
import MercatorCoordinate from &#39;./mercator-coordinate&#39;;
import { createShader, createProgram } from &#39;./webgl-utils&#39;;
import config from &#39;../config&#39;;

//////////////////////
// constants
//////////////////////
const TILE_SIZE = 512;
const MAX_TILE_ZOOM = 14;
const MIN_ZOOM = 0;
const MAX_ZOOM = 16;

//////////////////////
// shaders
//////////////////////

// vertex shader just passes through the position,
// no modification to the vertices
const vertexShaderSource = `
  attribute vec2 a_position;

  uniform mat3 u_matrix; // 3 X 3 matrix

  void main() {
    vec2 position = (u_matrix * vec3(a_position, 1)).xy;
    gl_Position = vec4(position, 0, 1);
  }
`;

// set color via uniform
const fragmentShaderSource =`
  precision mediump float;

  uniform vec4 u_color;

  void main() {
    gl_FragColor = u_color;
  }
`;

//////////////////////
// map state
//////////////////////
const camera = {
  x: 0,
  y: 0,
  zoom: 0,
};

// initial transformation (Brooklyn)
camera.x = -0.41101919888888894;
camera.y = 0.2478952993354263;
camera.zoom = 13;

// DOM elements
let canvas;
let overlay;

const LAYERS = {
  water: [180, 240, 250, 255],
  landcover: [202, 246, 193, 255],
  park: [202, 255, 193, 255],
};

let tileKey;
let tilesInView = [];
let tileData = {}; // tile -&gt; layers
async function updateTiles() {
  const bbox = getBounds();
  const z = Math.min(Math.trunc(camera.zoom), MAX_TILE_ZOOM);
  const minTile = tilebelt.pointToTile(bbox[0], bbox[3], z);
  const maxTile = tilebelt.pointToTile(bbox[2], bbox[1], z);

  // tiles visible in viewport
  tilesInView = [];
  const [minX, maxX] = [Math.max(minTile[0], 0), maxTile[0]];
  const [minY, maxY] = [Math.max(minTile[1], 0), maxTile[1]];
  for (let x = minX; x &lt;= maxX; x++) {
    for (let y = minY; y &lt;= maxY; y++) {
      tilesInView.push([x, y, z]);
    }
  }

  // load tile features from server
  const key = tilesInView.map(t =&gt; t.join(&#39;/&#39;)).join(&#39;;&#39;);
  if (tileKey !== key) { // tile changed
    tileData = {};

    // process each tile
    const tileReqs = tilesInView.map(async (tile) =&gt; {
      const [x, y, z] = tile;

      const res = await axios.get(`https://maps.ckochis.com/data/v3/${z}/${x}/${y}.pbf?apiKey=${config(&#39;mapsApiKey&#39;)}`, {
        responseType: &#39;arraybuffer&#39;,
      });

      const pbf = new Protobuf(res.data);
      const vectorTile = new VectorTile(pbf);

      // process only the layers we are using
      const layers = {}; // layers -&gt; features
      Object.keys(LAYERS).forEach((layer) =&gt; {
        if (vectorTile?.layers?.[layer]) {
          const numFeatures = vectorTile.layers[layer]?._features?.length || 0;

          const features = [];
          for (let i = 0; i &lt; numFeatures; i++) {
            // get geojson representation of tile
            const geojson = vectorTile.layers[layer].feature(i).toGeoJSON(x, y, z);

            // vertices for feature
            const vertices = geometryToVertices(geojson.geometry);

            // add to features
            features.push(vertices);
          }
          // store features in layer
          layers[layer] = features;
        }
      });
      // store layers for tile
      tileData[tile.join(&#39;/&#39;)] = layers;
    });
    await Promise.all(tileReqs); // run concurrently
    tileKey = key;
  }
}

let matrix;
function updateMatrix() {
  const cameraMat = mat3.create();

  // translate
  mat3.translate(cameraMat, cameraMat, [camera.x, camera.y]);

  // scale
  const zoomScale = 1 / Math.pow(2, camera.zoom);
  const widthScale = TILE_SIZE / canvas.width;
  const heightScale = TILE_SIZE / canvas.height;
  mat3.scale(cameraMat, cameraMat, [zoomScale / widthScale, zoomScale / heightScale]);

  // update matrix
  matrix = mat3.multiply(
    [],
    mat3.create(), // identity matrix
    mat3.invert([], cameraMat) // invert camera position
  );
}

//////////////////////
// helpers
//////////////////////
function getClipSpacePosition(e) {
  // handle mouse and touch events
  const [x, y] = [
    e.center?.x || e.clientX,
    e.center?.y || e.clientY
  ];

  // get canvas relative css position
  const rect = canvas.getBoundingClientRect();
  const cssX = x - rect.left;
  const cssY = y - rect.top;

  // get normalized 0 to 1 position across and down canvas
  const normalizedX = cssX / canvas.clientWidth;
  const normalizedY = cssY / canvas.clientHeight;

  // convert to clip space
  const clipX = normalizedX *  2 - 1;
  const clipY = normalizedY * -2 + 1;

  return [clipX, clipY];
}

// convert a GeoJSON geometry to webgl vertices
function geometryToVertices(geometry) {
  const verticesFromPolygon = (coordinates, n) =&gt; {
    const data = earcut.flatten(coordinates);
    const triangles = earcut(data.vertices, data.holes, 2);

    const vertices = new Float32Array(triangles.length * 2);
    for (let i = 0; i &lt; triangles.length; i++) {
      const point = triangles[i];
      const lng = data.vertices[point * 2];
      const lat = data.vertices[point * 2 + 1];
      const [x, y] = MercatorCoordinate.fromLngLat([lng, lat]);
      vertices[i * 2] = x;
      vertices[i * 2 + 1] = y;
    }
    return vertices;
  }

  if (geometry.type === &#39;Polygon&#39;) {
    return verticesFromPolygon(geometry.coordinates);
  }

  if (geometry.type === &#39;MultiPolygon&#39;) {
    const positions = [];
    geometry.coordinates.forEach((polygon, i) =&gt; {
      const vertices = verticesFromPolygon([polygon[0]], i);

      // doing an array.push with too many values can cause
      // stack size errors, so we manually iterate and append
      vertices.forEach((vertex) =&gt; {
        positions[positions.length] = vertex;
      });
    });
    return Float32Array.from(positions);
  }

  // only support Polygon &amp; Multipolygon for now
  return new Float32Array();
}

// get bbox coordinates for viewport
function getBounds() {
  const zoomScale = Math.pow(2, camera.zoom);

  // undo clip-space
  const px = (1 + camera.x) / 2;
  const py = (1 - camera.y) / 2;

  // get world coord in px
  const wx = px * TILE_SIZE;
  const wy = py * TILE_SIZE;

  // get zoom px
  const zx = wx * zoomScale;
  const zy = wy * zoomScale;

  // get bottom-left and top-right pixels
  let x1 = zx - (canvas.width / 2);
  let y1 = zy + (canvas.height / 2);
  let x2 = zx + (canvas.width / 2);
  let y2 = zy - (canvas.height / 2);

  // convert to world coords
  x1 = x1 / zoomScale / TILE_SIZE;
  y1 = y1 / zoomScale / TILE_SIZE;
  x2 = x2 / zoomScale / TILE_SIZE;
  y2 = y2 / zoomScale / TILE_SIZE;

  // get LngLat bounding box
  const bbox = [
    Math.max(MercatorCoordinate.lngFromMercatorX(x1), -180),
    Math.max(MercatorCoordinate.latFromMercatorY(y1), -85.05),
    Math.min(MercatorCoordinate.lngFromMercatorX(x2), 180),
    Math.min(MercatorCoordinate.latFromMercatorY(y2), 85.05),
  ];

  return bbox;
}

function atLimits() {
  const bbox = getBounds();
  return bbox[0] === -180 || bbox[1] === -85.05 || bbox[2] === 180 || bbox[3] === 85.05;
}

//////////////////////
// main program
//////////////////////
const run = (canvasId) =&gt; {
  // get GL context from canvas
  canvas = document.getElementById(canvasId);
  const gl = canvas.getContext(&#34;webgl&#34;);

  // get overlay
  overlay = document.getElementById(`${canvasId}-overlay`);

  // setup initial state
  updateMatrix();

  // setup viewport
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // compile shaders
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  // init gl program
  const program = createProgram(gl, vertexShader, fragmentShader);
  gl.clearColor(0, 0, 0, 0);
  gl.useProgram(program);

  const draw = async () =&gt; {
    await updateTiles(); // load tiles

    // set matrix as uniform
    const matrixLocation = gl.getUniformLocation(program, &#34;u_matrix&#34;);
    gl.uniformMatrix3fv(matrixLocation, false, matrix);

    // render tiles
    Object.keys(tileData).forEach((tile) =&gt; {
      Object.keys(LAYERS).forEach((layer) =&gt; {
        const features = tileData[tile][layer];
        const color = LAYERS[layer].map((n) =&gt; n / 255); // RGBA to WebGL color

        // set color uniform for layer
        const colorLocation = gl.getUniformLocation(program, &#34;u_color&#34;);
        gl.uniform4fv(colorLocation, color);

        // render each feature
        (features || []).forEach((feature) =&gt; {
          // create buffer for vertices
          const positionBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, feature, gl.STATIC_DRAW);

          // setup position attribute
          const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
          gl.enableVertexAttribArray(positionAttributeLocation);

          // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
          const size = 2;
          const type = gl.FLOAT;
          const normalize = false;
          const stride = 0;
          let offset = 0; 
          gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

          // draw
          const primitiveType = gl.TRIANGLES;
          offset = 0;
          const count = feature.length / 2;
          gl.drawArrays(primitiveType, offset, count);
        });
      });
    });

    overlay.replaceChildren(); // clear labels to redraw

    // render boundaries and label for tiles in view
    tilesInView.forEach((tile) =&gt; {
      const colorLocation = gl.getUniformLocation(program, &#34;u_color&#34;);
      gl.uniform4fv(colorLocation, [1, 0, 0, 1]);

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

      const tileVertices = geometryToVertices(tilebelt.tileToGeoJSON(tile));
      gl.bufferData(gl.ARRAY_BUFFER, tileVertices, gl.STATIC_DRAW);

      // setup position attribute
      const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
      gl.enableVertexAttribArray(positionAttributeLocation);

      // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
      const size = 2;
      const type = gl.FLOAT;
      const normalize = false;
      const stride = 0;
      let offset = 0; 
      gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

      // draw
      const primitiveType = gl.LINES;
      offset = 0;
      const count = tileVertices.length / 2;
      gl.drawArrays(primitiveType, offset, count);

      // draw tile labels
      const tileCoordinates = tilebelt.tileToGeoJSON(tile).coordinates;
      const topLeft = tileCoordinates[0][0];
      const [x, y] = MercatorCoordinate.fromLngLat(topLeft);

      const [clipX, clipY] = vec3.transformMat3(
        [],
        [x, y, 1],
        matrix,
      );

      const wx = ((1 + clipX) / 2) * canvas.width;
      const wy = ((1 - clipY) / 2) * canvas.height;
      const div = document.createElement(&#34;div&#34;);
      div.className = &#34;tile-label&#34;;
      div.style.left = (wx + 8) + &#34;px&#34;;
      div.style.top  = (wy + 8) + &#34;px&#34;;
      div.style.position = &#39;absolute&#39;;
      div.style.zIndex = 1000;
      div.appendChild(document.createTextNode(tile.join(&#39;/&#39;)));
      overlay.appendChild(div);
    });
  }
  draw(); // initial draw


  ////////////////////////
  // interaction handlers
  ////////////////////////

  // handle touch events
  const Hammer = require(&#39;hammerjs&#39;);
  const hammer = new Hammer(canvas);
  hammer.get(&#39;pan&#39;).set({ direction: Hammer.DIRECTION_ALL });
  hammer.get(&#39;pinch&#39;).set({ enable: true });

  // handle pan events
  let startX;
  let startY;

  // handle drag changes while mouse is still down
  const handleMove = (moveEvent) =&gt; {
    const [x, y] = getClipSpacePosition(moveEvent);

    // compute the previous position in world space
    const [preX, preY] = vec3.transformMat3(
      [],
      [startX, startY, 0],
      mat3.invert([], matrix)
    );

    // compute the new position in world space
    const [postX, postY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // move that amount, because how much the position changes depends on the zoom level
    const deltaX = preX - postX;
    const deltaY = preY - postY;
    if (isNaN(deltaX) || isNaN(deltaY)) {
      return; // abort
    }

    // only update within world limits
    camera.x += deltaX;
    camera.y += deltaY;

    // update matrix with new camera
    updateMatrix();

    // prevent further pan if at limits
    if (atLimits()) {
      camera.x -= deltaX;
      camera.y -= deltaY;
      updateMatrix();
      return; // abort
    }

    // save current pos for next movement
    startX = x;
    startY = y;

    updateMatrix();
    draw();
  }

  const handlePan = (startEvent) =&gt; {
    // get position of initial drag
    [startX, startY] = getClipSpacePosition(startEvent);
    canvas.style.cursor = &#39;grabbing&#39;;

    window.addEventListener(&#39;mousemove&#39;, handleMove);
    hammer.on(&#39;pan&#39;, handleMove);

    // clear on release
    const clear = (event) =&gt; {
      canvas.style.cursor = &#39;grab&#39;;
      window.removeEventListener(&#39;mousemove&#39;, handleMove);
      window.removeEventListener(&#39;mouseup&#39;, clear);
      hammer.off(&#39;pan&#39;, handleMove);
      hammer.off(&#39;panend&#39;, clear);
    };
    window.addEventListener(&#39;mouseup&#39;, clear);
    hammer.on(&#39;panend&#39;, clear);
  }
  canvas.addEventListener(&#39;mousedown&#39;, handlePan);
  hammer.on(&#39;panstart&#39;, handlePan);

  // handle zoom events
  const handleZoom = (wheelEvent) =&gt; {
    wheelEvent.preventDefault();
    const [x, y] = getClipSpacePosition(wheelEvent);

    // get position before zooming
    const [preZoomX, preZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // update current zoom state
    const prevZoom = camera.zoom;
    const zoomDelta = -wheelEvent.deltaY * (1 / 500);
    camera.zoom += zoomDelta;
    camera.zoom = Math.max(MIN_ZOOM, Math.min(camera.zoom, MAX_ZOOM));
    updateMatrix();

    // prevent further zoom if at limits
    if (atLimits()) {
      camera.zoom = prevZoom
      updateMatrix();
      return;
    }

    // get new position after zooming
    const [postZoomX, postZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // camera needs to be translated the difference of before and after
    camera.x += preZoomX - postZoomX;
    camera.y += preZoomY - postZoomY;
    updateMatrix();
    draw();
  }
  canvas.addEventListener(&#39;wheel&#39;, handleZoom);
  hammer.on(&#39;pinch&#39;, handleZoom);
};

export default run;

</code></span></p></div></div></div></div></div><p>If you‚Äôre familiar with New York City, you should be able to make out the outline of the waterways and the parks. You‚Äôll also notice some flashing, and lag when maneuvering around some of the more complex shapes. This is still a pretty rough implementation, and we‚Äôll cover some performance enhancements and optimizations in Part 3.</p></div><div><h2 id="optimization-and-cleanup">Part 3: Optimization and Cleanup</h2><p>Part 2 of this series left off with a working map that can render geometries from a vector tile server. However, the experience is still rather laggy and has some unpleasant flashes of content. Up to this point, we‚Äôve also just been writing the map code as one-off scripts, with most the values hard-coded.</p><p>In this part, we‚Äôll address these performance issues, as well as refactor our code into a more generic, reusable library.</p></div><div><p>Up to now, we‚Äôve just been re-rendering the map whenever there is an interaction, such as a pan or zoom. While this does save us some CPU cycles to not have the canvas constantly re-drawing, it does have some UX implications, especially when it comes to loading the tiles asynchronously.</p><p>Rather than calling <span>draw()</span> whenever a state change happens, we‚Äôll just use <span>window.requestAnimationFrame</span> to let the browser render the frame when ready. So when panning &amp; zooming, we‚Äôll just make updates to the camera &amp; matrix values, and those changes will get picked up in the next loop.</p><p>A similar approach can also be used for loading the tiles. Instead of <span>await</span>ing for <em>all</em> the responses to complete and blocking the loop, we can just update the tile data for each request as it completes. So tile requests that are quicker, will get rendered earlier.</p><div><p>+ See Code</p><div id="collapsible-content-1660876680015" role="region" aria-labelledby="collapsible-trigger-1660876680015"><div><div><ul><li><span>script.js</span></li></ul><div><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span><span>58
</span><span>59
</span><span>60
</span><span>61
</span><span>62
</span><span>63
</span><span>64
</span><span>65
</span><span>66
</span><span>67
</span><span>68
</span><span>69
</span><span>70
</span><span>71
</span><span>72
</span><span>73
</span><span>74
</span><span>75
</span><span>76
</span><span>77
</span><span>78
</span><span>79
</span><span>80
</span><span>81
</span><span>82
</span><span>83
</span><span>84
</span><span>85
</span><span>86
</span><span>87
</span><span>88
</span><span>89
</span><span>90
</span><span>91
</span><span>92
</span><span>93
</span><span>94
</span><span>95
</span><span>96
</span><span>97
</span><span>98
</span><span>99
</span><span>100
</span><span>101
</span><span>102
</span><span>103
</span><span>104
</span><span>105
</span><span>106
</span><span>107
</span><span>108
</span><span>109
</span><span>110
</span><span>111
</span><span>112
</span><span>113
</span><span>114
</span><span>115
</span><span>116
</span><span>117
</span><span>118
</span><span>119
</span><span>120
</span><span>121
</span><span>122
</span><span>123
</span><span>124
</span><span>125
</span><span>126
</span><span>127
</span><span>128
</span><span>129
</span><span>130
</span><span>131
</span><span>132
</span><span>133
</span><span>134
</span><span>135
</span><span>136
</span><span>137
</span><span>138
</span><span>139
</span><span>140
</span><span>141
</span><span>142
</span><span>143
</span><span>144
</span><span>145
</span><span>146
</span><span>147
</span><span>148
</span><span>149
</span><span>150
</span><span>151
</span><span>152
</span><span>153
</span><span>154
</span><span>155
</span><span>156
</span><span>157
</span><span>158
</span><span>159
</span><span>160
</span><span>161
</span><span>162
</span><span>163
</span><span>164
</span><span>165
</span><span>166
</span><span>167
</span><span>168
</span><span>169
</span><span>170
</span><span>171
</span><span>172
</span><span>173
</span><span>174
</span><span>175
</span><span>176
</span><span>177
</span><span>178
</span><span>179
</span><span>180
</span><span>181
</span><span>182
</span><span>183
</span><span>184
</span><span>185
</span><span>186
</span><span>187
</span><span>188
</span><span>189
</span><span>190
</span><span>191
</span><span>192
</span><span>193
</span><span>194
</span><span>195
</span><span>196
</span><span>197
</span><span>198
</span><span>199
</span><span>200
</span><span>201
</span><span>202
</span><span>203
</span><span>204
</span><span>205
</span><span>206
</span><span>207
</span><span>208
</span><span>209
</span><span>210
</span><span>211
</span><span>212
</span><span>213
</span><span>214
</span><span>215
</span><span>216
</span><span>217
</span><span>218
</span><span>219
</span><span>220
</span><span>221
</span><span>222
</span><span>223
</span><span>224
</span><span>225
</span><span>226
</span><span>227
</span><span>228
</span><span>229
</span><span>230
</span><span>231
</span><span>232
</span><span>233
</span><span>234
</span><span>235
</span><span>236
</span><span>237
</span><span>238
</span><span>239
</span><span>240
</span><span>241
</span><span>242
</span><span>243
</span><span>244
</span><span>245
</span><span>246
</span><span>247
</span><span>248
</span><span>249
</span><span>250
</span><span>251
</span><span>252
</span><span>253
</span><span>254
</span><span>255
</span><span>256
</span><span>257
</span><span>258
</span><span>259
</span><span>260
</span><span>261
</span><span>262
</span><span>263
</span><span>264
</span><span>265
</span><span>266
</span><span>267
</span><span>268
</span><span>269
</span><span>270
</span><span>271
</span><span>272
</span><span>273
</span><span>274
</span><span>275
</span><span>276
</span><span>277
</span><span>278
</span><span>279
</span><span>280
</span><span>281
</span><span>282
</span><span>283
</span><span>284
</span><span>285
</span><span>286
</span><span>287
</span><span>288
</span><span>289
</span><span>290
</span><span>291
</span><span>292
</span><span>293
</span><span>294
</span><span>295
</span><span>296
</span><span>297
</span><span>298
</span><span>299
</span><span>300
</span><span>301
</span><span>302
</span><span>303
</span><span>304
</span><span>305
</span><span>306
</span><span>307
</span><span>308
</span><span>309
</span><span>310
</span><span>311
</span><span>312
</span><span>313
</span><span>314
</span><span>315
</span><span>316
</span><span>317
</span><span>318
</span><span>319
</span><span>320
</span><span>321
</span><span>322
</span><span>323
</span><span>324
</span><span>325
</span><span>326
</span><span>327
</span><span>328
</span><span>329
</span><span>330
</span><span>331
</span><span>332
</span><span>333
</span><span>334
</span><span>335
</span><span>336
</span><span>337
</span><span>338
</span><span>339
</span><span>340
</span><span>341
</span><span>342
</span><span>343
</span><span>344
</span><span>345
</span><span>346
</span><span>347
</span><span>348
</span><span>349
</span><span>350
</span><span>351
</span><span>352
</span><span>353
</span><span>354
</span><span>355
</span><span>356
</span><span>357
</span><span>358
</span><span>359
</span><span>360
</span><span>361
</span><span>362
</span><span>363
</span><span>364
</span><span>365
</span><span>366
</span><span>367
</span><span>368
</span><span>369
</span><span>370
</span><span>371
</span><span>372
</span><span>373
</span><span>374
</span><span>375
</span><span>376
</span><span>377
</span><span>378
</span><span>379
</span><span>380
</span><span>381
</span><span>382
</span><span>383
</span><span>384
</span><span>385
</span><span>386
</span><span>387
</span><span>388
</span><span>389
</span><span>390
</span><span>391
</span><span>392
</span><span>393
</span><span>394
</span><span>395
</span><span>396
</span><span>397
</span><span>398
</span><span>399
</span><span>400
</span><span>401
</span><span>402
</span><span>403
</span><span>404
</span><span>405
</span><span>406
</span><span>407
</span><span>408
</span><span>409
</span><span>410
</span><span>411
</span><span>412
</span><span>413
</span><span>414
</span><span>415
</span><span>416
</span><span>417
</span><span>418
</span><span>419
</span><span>420
</span><span>421
</span><span>422
</span><span>423
</span><span>424
</span><span>425
</span><span>426
</span><span>427
</span><span>428
</span><span>429
</span><span>430
</span><span>431
</span><span>432
</span><span>433
</span><span>434
</span><span>435
</span><span>436
</span><span>437
</span><span>438
</span><span>439
</span><span>440
</span><span>441
</span><span>442
</span><span>443
</span><span>444
</span><span>445
</span><span>446
</span><span>447
</span><span>448
</span><span>449
</span><span>450
</span><span>451
</span><span>452
</span><span>453
</span><span>454
</span><span>455
</span><span>456
</span><span>457
</span><span>458
</span><span>459
</span><span>460
</span><span>461
</span><span>462
</span><span>463
</span><span>464
</span><span>465
</span><span>466
</span><span>467
</span><span>468
</span><span>469
</span><span>470
</span><span>471
</span><span>472
</span><span>473
</span><span>474
</span><span>475
</span><span>476
</span><span>477
</span><span>478
</span><span>479
</span><span>480
</span><span>481
</span><span>482
</span><span>483
</span><span>484
</span><span>485
</span><span>486
</span><span>487
</span><span>488
</span><span>489
</span><span>490
</span><span>491
</span><span>492
</span><span>493
</span><span>494
</span><span>495
</span><span>496
</span><span>497
</span><span>498
</span><span>499
</span><span>500
</span><span>501
</span><span>502
</span><span>503
</span><span>504
</span><span>505
</span><span>506
</span><span>507
</span><span>508
</span><span>509
</span><span>510
</span><span>511
</span><span>512
</span><span>513
</span><span>514
</span><span>515
</span><span>516
</span><span>517
</span><span>518
</span><span>519
</span><span>520
</span><span>521
</span><span>522
</span><span>523
</span><span>524
</span><span>525
</span><span>526
</span><span>527
</span><span>528
</span><span>529
</span><span>530
</span><span>531
</span><span>532
</span><span>533
</span><span>534
</span><span>535
</span><span>536
</span><span>537
</span><span>538
</span><span>539
</span><span>540
</span><span>541
</span><span>542
</span><span>543
</span><span>544
</span><span>545
</span><span>546
</span><span>547
</span><span>548
</span><span>549
</span><span>550
</span><span>551
</span><span>552
</span><span>553
</span><span>554
</span><span>555
</span><span>556
</span><span>557
</span><span>558
</span><span>559
</span><span>560
</span><span>561
</span><span>562
</span><span>563
</span><span>564
</span><span>565
</span><span>566
</span><span>567
</span><span>568
</span><span>569
</span><span>570
</span><span>571
</span><span>572
</span><span>573
</span><span>574
</span><span>575
</span><span>576
</span><span>577
</span><span>578
</span><span>579
</span><span>580
</span><span>581
</span><span>582
</span><span>583
</span><span>584
</span><span>585
</span><span>586
</span><span>587
</span><span>588
</span><span>589
</span><span>590
</span><span>591
</span><span>592
</span><span>593
</span><span>594
</span><span>595
</span><span>596
</span><span>597
</span><span>598
</span></code><code>import axios from &#39;axios&#39;;
import Protobuf from &#39;pbf&#39;;
import { mat3, vec3 } from &#39;gl-matrix&#39;;
import earcut from &#39;earcut&#39;;
import tilebelt from &#39;@mapbox/tilebelt&#39;;
import { VectorTile } from &#39;@mapbox/vector-tile&#39;;
import MercatorCoordinate from &#39;./mercator-coordinate&#39;;
import Stats from &#39;stats.js&#39;;
import { createShader, createProgram } from &#39;./webgl-utils&#39;;
import config from &#39;../config&#39;;

//////////////////////
// constants
//////////////////////
const TILE_SIZE = 512;
const MAX_TILE_ZOOM = 14;
const MIN_ZOOM = 0;
const MAX_ZOOM = 16;

//////////////////////
// shaders
//////////////////////

// vertex shader just passes through the position,
// no modification to the vertices
const vertexShaderSource = `
  attribute vec2 a_position;

  uniform mat3 u_matrix; // 3 X 3 matrix

  void main() {
    vec2 position = (u_matrix * vec3(a_position, 1)).xy;
    gl_Position = vec4(position, 0, 1);
  }
`;

// set color via uniform
const fragmentShaderSource =`
  precision mediump float;

  uniform vec4 u_color;

  void main() {
    gl_FragColor = u_color;
  }
`;

//////////////////////
// map state
//////////////////////
let loopRunning = true;

const camera = {
  x: 0,
  y: 0,
  zoom: 0,
};

// initial transformation (Brooklyn)
camera.x = -0.41101919888888894;
camera.y = 0.2478952993354263;
camera.zoom = 13;

// DOM elements
let canvas;
let overlay;
let statsWidget;

const LAYERS = {
  water: [180, 240, 250, 255],
  landcover: [202, 246, 193, 255],
  park: [202, 255, 193, 255],
};

let tileKey;
let tilesInView = [];
let tileData = {}; // tile -&gt; layers
function updateTiles() {
  const bbox = getBounds();
  const z = Math.min(Math.trunc(camera.zoom), MAX_ZOOM);
  const minTile = tilebelt.pointToTile(bbox[0], bbox[3], z);
  const maxTile = tilebelt.pointToTile(bbox[2], bbox[1], z);

  // tiles visible in viewport
  tilesInView = [];
  const [minX, maxX] = [Math.max(minTile[0], 0), maxTile[0]];
  const [minY, maxY] = [Math.max(minTile[1], 0), maxTile[1]];
  for (let x = minX; x &lt;= maxX; x++) {
    for (let y = minY; y &lt;= maxY; y++) {
      tilesInView.push([x, y, z]);
    }
  }

  // load tile features from server
  const key = tilesInView.map(t =&gt; t.join(&#39;/&#39;)).join(&#39;;&#39;);
  if (tileKey !== key) { // tile changed
    tileData = {};

    // process each tile concurrently, and update data on complete
    tilesInView.forEach(async (tile) =&gt; {
      const [x, y, z] = tile;

      const reqStart = Date.now();
      const res = await axios.get(`https://maps.ckochis.com/data/v3/${z}/${x}/${y}.pbf?apiKey=${config(&#39;mapsApiKey&#39;)}`, {
        responseType: &#39;arraybuffer&#39;,
      });

      const pbf = new Protobuf(res.data);
      const vectorTile = new VectorTile(pbf);

      // process only the layers we are using
      const layers = {}; // layers -&gt; features
      Object.keys(LAYERS).forEach((layer) =&gt; {
        if (vectorTile?.layers?.[layer]) {
          const numFeatures = vectorTile.layers[layer]?._features?.length || 0;

          const features = [];
          for (let i = 0; i &lt; numFeatures; i++) {
            // get geojson representation of tile
            const geojson = vectorTile.layers[layer].feature(i).toGeoJSON(x, y, z);

            // vertices for feature
            const vertices = geometryToVertices(geojson.geometry);

            // add to features
            features.push(vertices);
          }
          // store features in layer
          layers[layer] = features;
        }
      });
      // store layers for tile
      tileData[tile.join(&#39;/&#39;)] = layers;
    });
    tileKey = key;
  }
}

let matrix;
function updateMatrix() {
  const cameraMat = mat3.create();

  // translate
  mat3.translate(cameraMat, cameraMat, [camera.x, camera.y]);

  // scale
  const zoomScale = 1 / Math.pow(2, camera.zoom);
  const widthScale = TILE_SIZE / canvas.width;
  const heightScale = TILE_SIZE / canvas.height;
  mat3.scale(cameraMat, cameraMat, [zoomScale / widthScale, zoomScale / heightScale]);

  // update matrix
  matrix = mat3.multiply(
    [],
    mat3.create(), // identity matrix
    mat3.invert([], cameraMat) // invert camera position
  );
}

//////////////////////
// helpers
//////////////////////
function getClipSpacePosition(e) {
  // handle mouse and touch events
  const [x, y] = [
    e.center?.x || e.clientX,
    e.center?.y || e.clientY
  ];

  // get canvas relative css position
  const rect = canvas.getBoundingClientRect();
  const cssX = x - rect.left;
  const cssY = y - rect.top;

  // get normalized 0 to 1 position across and down canvas
  const normalizedX = cssX / canvas.clientWidth;
  const normalizedY = cssY / canvas.clientHeight;

  // convert to clip space
  const clipX = normalizedX *  2 - 1;
  const clipY = normalizedY * -2 + 1;

  return [clipX, clipY];
}

// convert a GeoJSON geometry to webgl vertices
function geometryToVertices(geometry) {
  const verticesFromPolygon = (coordinates, n) =&gt; {
    const data = earcut.flatten(coordinates);
    const triangles = earcut(data.vertices, data.holes, 2);

    const vertices = new Float32Array(triangles.length * 2);
    for (let i = 0; i &lt; triangles.length; i++) {
      const point = triangles[i];
      const lng = data.vertices[point * 2];
      const lat = data.vertices[point * 2 + 1];
      const [x, y] = MercatorCoordinate.fromLngLat([lng, lat]);
      vertices[i * 2] = x;
      vertices[i * 2 + 1] = y;
    }
    return vertices;
  }

  if (geometry.type === &#39;Polygon&#39;) {
    return verticesFromPolygon(geometry.coordinates);
  }

  if (geometry.type === &#39;MultiPolygon&#39;) {
    const positions = [];
    geometry.coordinates.forEach((polygon, i) =&gt; {
      positions.push(...verticesFromPolygon([polygon[0]], i));
    });
    return Float32Array.from(positions);
  }

  // only support Polygon &amp; Multipolygon for now
  return new Float32Array();
}

// get bbox coordinates for viewport
function getBounds() {
  const zoomScale = Math.pow(2, camera.zoom);

  // undo clip-space
  const px = (1 + camera.x) / 2;
  const py = (1 - camera.y) / 2;

  // get world coord in px
  const wx = px * TILE_SIZE;
  const wy = py * TILE_SIZE;

  // get zoom px
  const zx = wx * zoomScale;
  const zy = wy * zoomScale;

  // get bottom-left and top-right pixels
  let x1 = zx - (canvas.width / 2);
  let y1 = zy + (canvas.height / 2);
  let x2 = zx + (canvas.width / 2);
  let y2 = zy - (canvas.height / 2);

  // convert to world coords
  x1 = x1 / zoomScale / TILE_SIZE;
  y1 = y1 / zoomScale / TILE_SIZE;
  x2 = x2 / zoomScale / TILE_SIZE;
  y2 = y2 / zoomScale / TILE_SIZE;

  // get LngLat bounding box
  const bbox = [
    Math.max(MercatorCoordinate.lngFromMercatorX(x1), -180),
    Math.max(MercatorCoordinate.latFromMercatorY(y1), -85.05),
    Math.min(MercatorCoordinate.lngFromMercatorX(x2), 180),
    Math.min(MercatorCoordinate.latFromMercatorY(y2), 85.05),
  ];

  return bbox;
}

function atLimits() {
  const bbox = getBounds();
  return bbox[0] === -180 || bbox[1] === -85.05 || bbox[2] === 180 || bbox[3] === 85.05;
}

//////////////////////
// main program
//////////////////////
let handlePan;
let handleZoom;

let timestamp;
let slowCount;
let frameStats;

const run = (canvasId, mobile, abort) =&gt; {
  // setup loop state
  loopRunning = true;
  timestamp = 0;
  slowCount = 0;

  // create stats object for widget
  const stats = new Stats();

  // get GL context from canvas
  canvas = document.getElementById(canvasId);
  const gl = canvas.getContext(&#34;webgl&#34;);

  // get overlay
  overlay = document.getElementById(`${canvasId}-overlay`);

  // setup initial state
  updateMatrix();
  updateTiles();

  // setup viewport
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // compile shaders
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  // init gl program
  const program = createProgram(gl, vertexShader, fragmentShader);
  gl.clearColor(0, 0, 0, 0);
  gl.useProgram(program);

  // create buffer
  const positionBuffer = gl.createBuffer();

  const draw = () =&gt; {
    frameStats = { drawCalls: 0, vertices: 0, features: 0 };
    stats.begin();

    // set matrix as uniform
    const matrixLocation = gl.getUniformLocation(program, &#34;u_matrix&#34;);
    gl.uniformMatrix3fv(matrixLocation, false, matrix);

    // render tiles
    Object.keys(tileData).forEach((tile) =&gt; {
      Object.keys(LAYERS).forEach((layer) =&gt; {
        const features = tileData[tile][layer];
        const color = LAYERS[layer].map((n) =&gt; n / 255); // RGBA to WebGL color

        // set color uniform for layer
        const colorLocation = gl.getUniformLocation(program, &#34;u_color&#34;);
        gl.uniform4fv(colorLocation, color);

        // render each feature
        (features || []).forEach((feature) =&gt; {
          frameStats.features++;

          // create buffer for vertices
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, feature, gl.STATIC_DRAW);

          // setup position attribute
          const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
          gl.enableVertexAttribArray(positionAttributeLocation);

          // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
          const size = 2;
          const type = gl.FLOAT;
          const normalize = false;
          const stride = 0;
          let offset = 0; 
          gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

          // draw
          const primitiveType = gl.TRIANGLES;
          offset = 0;
          const count = feature.length / 2;
          gl.drawArrays(primitiveType, offset, count);

          frameStats.drawCalls++;
          frameStats.vertices+= feature.length;
        });
      });
    });

    overlay.replaceChildren(); // clear labels to redraw

    // render boundaries and label for tiles in view
    tilesInView.forEach((tile) =&gt; {
      const colorLocation = gl.getUniformLocation(program, &#34;u_color&#34;);
      gl.uniform4fv(colorLocation, [1, 0, 0, 1]);

      const tileVertices = geometryToVertices(tilebelt.tileToGeoJSON(tile));
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, tileVertices, gl.STATIC_DRAW);

      // setup position attribute
      const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
      gl.enableVertexAttribArray(positionAttributeLocation);

      // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
      const size = 2;
      const type = gl.FLOAT;
      const normalize = false;
      const stride = 0;
      let offset = 0; 
      gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

      // draw
      const primitiveType = gl.LINES;
      offset = 0;
      const count = tileVertices.length / 2;
      gl.drawArrays(primitiveType, offset, count);

      // draw tile labels
      const tileCoordinates = tilebelt.tileToGeoJSON(tile).coordinates;
      const topLeft = tileCoordinates[0][0];
      const [x, y] = MercatorCoordinate.fromLngLat(topLeft);

      const [clipX, clipY] = vec3.transformMat3(
        [],
        [x, y, 1],
        matrix,
      );

      const wx = ((1 + clipX) / 2) * canvas.width;
      const wy = ((1 - clipY) / 2) * canvas.height;
      const div = document.createElement(&#34;div&#34;);
      div.className = &#34;tile-label&#34;;
      div.style.left = (wx + 8) + &#34;px&#34;;
      div.style.top  = (wy + 8) + &#34;px&#34;;
      div.style.position = &#39;absolute&#39;;
      div.style.zIndex = 1000;
      div.appendChild(document.createTextNode(tile.join(&#39;/&#39;)));
      overlay.appendChild(div);
    });

    // kill loop on mobile
    if (mobile) {
      stop();
      if (abort) {
        abort();
      }
      return;
    }

    // kill loop if gets too slow
    // 5 frames under 10 FPS
    const now = performance.now();
    const fps = 1 / ((now - timestamp) / 1000);
    if (fps &lt; 10) {
      slowCount++;

      if (slowCount &gt; 5) {
        console.warn(`Too slow. Killing loop for ${canvasId}.`);
        stop();
        if (abort) {
          abort();
        }
      }
    }
    timestamp = now;

    // end of loop
    stats.end();
    if (loopRunning) {
      window.requestAnimationFrame(draw);
    }
  }
  window.requestAnimationFrame(draw); // start loop


  ////////////////////////
  // interaction handlers
  ////////////////////////

  // handle touch events
  const Hammer = require(&#39;hammerjs&#39;);
  const hammer = new Hammer(canvas);
  hammer.get(&#39;pan&#39;).set({ direction: Hammer.DIRECTION_ALL });
  hammer.get(&#39;pinch&#39;).set({ enable: true });

  // handle pan events
  let startX;
  let startY;

  // handle drag changes while mouse is still down
  const handleMove = (moveEvent) =&gt; {
    const [x, y] = getClipSpacePosition(moveEvent);

    // compute the previous position in world space
    const [preX, preY] = vec3.transformMat3(
      [],
      [startX, startY, 0],
      mat3.invert([], matrix)
    );

    // compute the new position in world space
    const [postX, postY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // move that amount, because how much the position changes depends on the zoom level
    const deltaX = preX - postX;
    const deltaY = preY - postY;
    if (isNaN(deltaX) || isNaN(deltaY)) {
      return; // abort
    }

    // only update within world limits
    camera.x += deltaX;
    camera.y += deltaY;

    // update matrix with new camera
    updateMatrix();

    // prevent further pan if at limits
    if (atLimits()) {
      camera.x -= deltaX;
      camera.y -= deltaY;
      updateMatrix();
      return; // abort
    }

    // save current pos for next movement
    startX = x;
    startY = y;

    updateMatrix();
    updateTiles();
  }

  handlePan = (startEvent) =&gt; {
    // get position of initial drag
    [startX, startY] = getClipSpacePosition(startEvent);
    canvas.style.cursor = &#39;grabbing&#39;;

    window.addEventListener(&#39;mousemove&#39;, handleMove);
    hammer.on(&#39;pan&#39;, handleMove);

    // clear on release
    const clear = (event) =&gt; {
      canvas.style.cursor = &#39;grab&#39;;
      window.removeEventListener(&#39;mousemove&#39;, handleMove);
      window.removeEventListener(&#39;mouseup&#39;, clear);
      hammer.off(&#39;pan&#39;, handleMove);
      hammer.off(&#39;panend&#39;, clear);
    };
    window.addEventListener(&#39;mouseup&#39;, clear);
    hammer.on(&#39;panend&#39;, clear);
  }
  canvas.addEventListener(&#39;mousedown&#39;, handlePan);
  hammer.on(&#39;panstart&#39;, handlePan);

  // handle zoom events
  handleZoom = (wheelEvent) =&gt; {
    wheelEvent.preventDefault();
    const [x, y] = getClipSpacePosition(wheelEvent);

    // get position before zooming
    const [preZoomX, preZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // update current zoom state
    const prevZoom = camera.zoom;
    const zoomDelta = -wheelEvent.deltaY * (1 / 500);
    camera.zoom += zoomDelta;
    camera.zoom = Math.max(MIN_ZOOM, Math.min(camera.zoom, MAX_TILE_ZOOM));
    updateMatrix();

    // prevent further zoom if at limits
    if (atLimits()) {
      camera.zoom = prevZoom
      updateMatrix();
      return;
    }

    // get new position after zooming
    const [postZoomX, postZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // camera needs to be translated the difference of before and after
    camera.x += preZoomX - postZoomX;
    camera.y += preZoomY - postZoomY;
    updateMatrix();
    updateTiles();
  }
  canvas.addEventListener(&#39;wheel&#39;, handleZoom);
  hammer.on(&#39;pinch&#39;, handleZoom);

  // setup stats widget
  stats.showPanel(0); // frame rate
  statsWidget = stats.dom;
  statsWidget.style.position = &#39;absolute&#39;;
  statsWidget.style.left = mobile ? 0 : &#39;-100px&#39;;
  statsWidget.style.zIndex = &#39;0&#39;;
  canvas.parentElement.appendChild(statsWidget);
};

export const stop = () =&gt; {
  loopRunning = false;

  // clear event handlers
  if (canvas) {
    canvas.removeEventListener(&#39;wheel&#39;, handleZoom);
    canvas.removeEventListener(&#39;mousedown&#39;, handlePan);
    overlay.replaceChildren();
    statsWidget.remove();
  }
};

// get the latest frame stats
export const getFrameStats = () =&gt; {
  return frameStats;
}

export default run;
</code></span></p></div></div></div></div></div><p>Now that we‚Äôre loading the tiles concurrently, you&#39;ll notice the flashing happening on a per-tile basis, rather than all-at-once. However, you might have got into a state where the map was killed (trying not to crash your browser!).</p><p>Since we‚Äôre now calling draw many times per second (ideally 60), we are making a ton of calls to shuffle data into GPU. For instance, here are the stats for the most recent frame that was rendered:</p><pre>// last render stats
no. of gl draw calls: undefined
no. of vertices: undefined</pre><p>That means for each frame, it needs to buffer data into WebGL <span></span> times. Which is (probably) a lot, considering we&#39;re trying to aim for 60 frames per second.</p><p>To fix this, we can cut down the number of times we&#39;re buffering data into the GPU.</p></div><div><p>In the current approach, we‚Äôre storing the vertices for each individual feature, for each layer, for each tile. In other words our <span>tileData</span>, which is storing the data per-tile, looks something like:</p><pre>tileData: {
  &#39;1/1/1&#39;: {
    layer_1: [
      feature_1 vertices,
      feature_2 vertices,
      ‚Ä¶
      feature_n vertices,
    ],
    ‚Ä¶ // more layers
  },
  &#39;1/1/2&#39;: {
    ‚Ä¶
  }
  ‚Ä¶ // more tiles
}</pre><p>Since all the features for a given layer are rendered the same (ie. same color), we can just combine all of the feature vertices into a single array for the layer. This will cut down the number of times we need to reset the buffers and call <span>gl.drawArrays</span> to once per layer, per tile. So our new tileData structure will look something like:</p><pre>tileData: {
  &#39;1/1/1&#39;: [
    { layer: ‚Äòlayer_1‚Äô, vertices: [‚Ä¶] },
    { layer: ‚Äòlayer_2‚Äô, vertices: [‚Ä¶] },
    ‚Ä¶
  ]
  ‚Ä¶
}</pre><p>And the updated code that processes the tile:</p><p><span><code>const layers = [];
Object.keys(LAYERS).forEach((layer) =&gt; {
  if (vectorTile?.layers?.[layer]) {
    const numFeatures = vectorTile.layers[layer]?._features?.length || 0;

    // concat vertices for all features of layer so they can all be rendered at once
    const vertices = [];
    for (let i = 0; i &lt; numFeatures; i++) {
      const geojson = vectorTile.layers[layer].feature(i).toGeoJSON(x, y, z);
      vertices.push(...geometryToVertices(geojson.geometry)); // concat all vertices
    }
    layers.push({ layer, vertices: Float32Array.from(vertices) });
  }
});</code></span></p><div><p>+ See Code</p><div id="collapsible-content-1660876680019" role="region" aria-labelledby="collapsible-trigger-1660876680019"><div><div><ul><li><span>script.js</span></li></ul><div><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span><span>58
</span><span>59
</span><span>60
</span><span>61
</span><span>62
</span><span>63
</span><span>64
</span><span>65
</span><span>66
</span><span>67
</span><span>68
</span><span>69
</span><span>70
</span><span>71
</span><span>72
</span><span>73
</span><span>74
</span><span>75
</span><span>76
</span><span>77
</span><span>78
</span><span>79
</span><span>80
</span><span>81
</span><span>82
</span><span>83
</span><span>84
</span><span>85
</span><span>86
</span><span>87
</span><span>88
</span><span>89
</span><span>90
</span><span>91
</span><span>92
</span><span>93
</span><span>94
</span><span>95
</span><span>96
</span><span>97
</span><span>98
</span><span>99
</span><span>100
</span><span>101
</span><span>102
</span><span>103
</span><span>104
</span><span>105
</span><span>106
</span><span>107
</span><span>108
</span><span>109
</span><span>110
</span><span>111
</span><span>112
</span><span>113
</span><span>114
</span><span>115
</span><span>116
</span><span>117
</span><span>118
</span><span>119
</span><span>120
</span><span>121
</span><span>122
</span><span>123
</span><span>124
</span><span>125
</span><span>126
</span><span>127
</span><span>128
</span><span>129
</span><span>130
</span><span>131
</span><span>132
</span><span>133
</span><span>134
</span><span>135
</span><span>136
</span><span>137
</span><span>138
</span><span>139
</span><span>140
</span><span>141
</span><span>142
</span><span>143
</span><span>144
</span><span>145
</span><span>146
</span><span>147
</span><span>148
</span><span>149
</span><span>150
</span><span>151
</span><span>152
</span><span>153
</span><span>154
</span><span>155
</span><span>156
</span><span>157
</span><span>158
</span><span>159
</span><span>160
</span><span>161
</span><span>162
</span><span>163
</span><span>164
</span><span>165
</span><span>166
</span><span>167
</span><span>168
</span><span>169
</span><span>170
</span><span>171
</span><span>172
</span><span>173
</span><span>174
</span><span>175
</span><span>176
</span><span>177
</span><span>178
</span><span>179
</span><span>180
</span><span>181
</span><span>182
</span><span>183
</span><span>184
</span><span>185
</span><span>186
</span><span>187
</span><span>188
</span><span>189
</span><span>190
</span><span>191
</span><span>192
</span><span>193
</span><span>194
</span><span>195
</span><span>196
</span><span>197
</span><span>198
</span><span>199
</span><span>200
</span><span>201
</span><span>202
</span><span>203
</span><span>204
</span><span>205
</span><span>206
</span><span>207
</span><span>208
</span><span>209
</span><span>210
</span><span>211
</span><span>212
</span><span>213
</span><span>214
</span><span>215
</span><span>216
</span><span>217
</span><span>218
</span><span>219
</span><span>220
</span><span>221
</span><span>222
</span><span>223
</span><span>224
</span><span>225
</span><span>226
</span><span>227
</span><span>228
</span><span>229
</span><span>230
</span><span>231
</span><span>232
</span><span>233
</span><span>234
</span><span>235
</span><span>236
</span><span>237
</span><span>238
</span><span>239
</span><span>240
</span><span>241
</span><span>242
</span><span>243
</span><span>244
</span><span>245
</span><span>246
</span><span>247
</span><span>248
</span><span>249
</span><span>250
</span><span>251
</span><span>252
</span><span>253
</span><span>254
</span><span>255
</span><span>256
</span><span>257
</span><span>258
</span><span>259
</span><span>260
</span><span>261
</span><span>262
</span><span>263
</span><span>264
</span><span>265
</span><span>266
</span><span>267
</span><span>268
</span><span>269
</span><span>270
</span><span>271
</span><span>272
</span><span>273
</span><span>274
</span><span>275
</span><span>276
</span><span>277
</span><span>278
</span><span>279
</span><span>280
</span><span>281
</span><span>282
</span><span>283
</span><span>284
</span><span>285
</span><span>286
</span><span>287
</span><span>288
</span><span>289
</span><span>290
</span><span>291
</span><span>292
</span><span>293
</span><span>294
</span><span>295
</span><span>296
</span><span>297
</span><span>298
</span><span>299
</span><span>300
</span><span>301
</span><span>302
</span><span>303
</span><span>304
</span><span>305
</span><span>306
</span><span>307
</span><span>308
</span><span>309
</span><span>310
</span><span>311
</span><span>312
</span><span>313
</span><span>314
</span><span>315
</span><span>316
</span><span>317
</span><span>318
</span><span>319
</span><span>320
</span><span>321
</span><span>322
</span><span>323
</span><span>324
</span><span>325
</span><span>326
</span><span>327
</span><span>328
</span><span>329
</span><span>330
</span><span>331
</span><span>332
</span><span>333
</span><span>334
</span><span>335
</span><span>336
</span><span>337
</span><span>338
</span><span>339
</span><span>340
</span><span>341
</span><span>342
</span><span>343
</span><span>344
</span><span>345
</span><span>346
</span><span>347
</span><span>348
</span><span>349
</span><span>350
</span><span>351
</span><span>352
</span><span>353
</span><span>354
</span><span>355
</span><span>356
</span><span>357
</span><span>358
</span><span>359
</span><span>360
</span><span>361
</span><span>362
</span><span>363
</span><span>364
</span><span>365
</span><span>366
</span><span>367
</span><span>368
</span><span>369
</span><span>370
</span><span>371
</span><span>372
</span><span>373
</span><span>374
</span><span>375
</span><span>376
</span><span>377
</span><span>378
</span><span>379
</span><span>380
</span><span>381
</span><span>382
</span><span>383
</span><span>384
</span><span>385
</span><span>386
</span><span>387
</span><span>388
</span><span>389
</span><span>390
</span><span>391
</span><span>392
</span><span>393
</span><span>394
</span><span>395
</span><span>396
</span><span>397
</span><span>398
</span><span>399
</span><span>400
</span><span>401
</span><span>402
</span><span>403
</span><span>404
</span><span>405
</span><span>406
</span><span>407
</span><span>408
</span><span>409
</span><span>410
</span><span>411
</span><span>412
</span><span>413
</span><span>414
</span><span>415
</span><span>416
</span><span>417
</span><span>418
</span><span>419
</span><span>420
</span><span>421
</span><span>422
</span><span>423
</span><span>424
</span><span>425
</span><span>426
</span><span>427
</span><span>428
</span><span>429
</span><span>430
</span><span>431
</span><span>432
</span><span>433
</span><span>434
</span><span>435
</span><span>436
</span><span>437
</span><span>438
</span><span>439
</span><span>440
</span><span>441
</span><span>442
</span><span>443
</span><span>444
</span><span>445
</span><span>446
</span><span>447
</span><span>448
</span><span>449
</span><span>450
</span><span>451
</span><span>452
</span><span>453
</span><span>454
</span><span>455
</span><span>456
</span><span>457
</span><span>458
</span><span>459
</span><span>460
</span><span>461
</span><span>462
</span><span>463
</span><span>464
</span><span>465
</span><span>466
</span><span>467
</span><span>468
</span><span>469
</span><span>470
</span><span>471
</span><span>472
</span><span>473
</span><span>474
</span><span>475
</span><span>476
</span><span>477
</span><span>478
</span><span>479
</span><span>480
</span><span>481
</span><span>482
</span><span>483
</span><span>484
</span><span>485
</span><span>486
</span><span>487
</span><span>488
</span><span>489
</span><span>490
</span><span>491
</span><span>492
</span><span>493
</span><span>494
</span><span>495
</span><span>496
</span><span>497
</span><span>498
</span><span>499
</span><span>500
</span><span>501
</span><span>502
</span><span>503
</span><span>504
</span><span>505
</span><span>506
</span><span>507
</span><span>508
</span><span>509
</span><span>510
</span><span>511
</span><span>512
</span><span>513
</span><span>514
</span><span>515
</span><span>516
</span><span>517
</span><span>518
</span><span>519
</span><span>520
</span><span>521
</span><span>522
</span><span>523
</span><span>524
</span><span>525
</span><span>526
</span><span>527
</span><span>528
</span><span>529
</span><span>530
</span><span>531
</span><span>532
</span><span>533
</span><span>534
</span><span>535
</span><span>536
</span><span>537
</span><span>538
</span><span>539
</span><span>540
</span><span>541
</span><span>542
</span><span>543
</span><span>544
</span><span>545
</span><span>546
</span><span>547
</span><span>548
</span><span>549
</span><span>550
</span><span>551
</span><span>552
</span><span>553
</span><span>554
</span><span>555
</span><span>556
</span><span>557
</span><span>558
</span><span>559
</span><span>560
</span><span>561
</span><span>562
</span><span>563
</span><span>564
</span><span>565
</span><span>566
</span><span>567
</span><span>568
</span><span>569
</span><span>570
</span><span>571
</span><span>572
</span><span>573
</span><span>574
</span><span>575
</span><span>576
</span><span>577
</span><span>578
</span><span>579
</span><span>580
</span><span>581
</span><span>582
</span></code><code>import axios from &#39;axios&#39;;
import Protobuf from &#39;pbf&#39;;
import { mat3, vec3 } from &#39;gl-matrix&#39;;
import earcut from &#39;earcut&#39;;
import tilebelt from &#39;@mapbox/tilebelt&#39;;
import { VectorTile } from &#39;@mapbox/vector-tile&#39;;
import MercatorCoordinate from &#39;./mercator-coordinate&#39;;
import Stats from &#39;stats.js&#39;;
import { createShader, createProgram } from &#39;./webgl-utils&#39;;
import config from &#39;../config&#39;;

//////////////////////
// constants
//////////////////////
const TILE_SIZE = 512;
const MAX_TILE_ZOOM = 14;
const MIN_ZOOM = 0;
const MAX_ZOOM = 16;

//////////////////////
// shaders
//////////////////////

// vertex shader just passes through the position,
// no modification to the vertices
const vertexShaderSource = `
  attribute vec2 a_position;

  uniform mat3 u_matrix; // 3 X 3 matrix

  void main() {
    vec2 position = (u_matrix * vec3(a_position, 1)).xy;
    gl_Position = vec4(position, 0, 1);
  }
`;

// set color via uniform
const fragmentShaderSource =`
  precision mediump float;

  uniform vec4 u_color;

  void main() {
    gl_FragColor = u_color;
  }
`;

//////////////////////
// map state
//////////////////////
let loopRunning = true;

const camera = {
  x: 0,
  y: 0,
  zoom: 0,
};

// initial transformation (Brooklyn)
camera.x = -0.41101919888888894;
camera.y = 0.2478952993354263;
camera.zoom = 13;

// DOM elements
let canvas;
let overlay;
let statsWidget;

const LAYERS = {
  water: [180, 240, 250, 255],
  landcover: [202, 246, 193, 255],
  park: [202, 255, 193, 255],
  building: [185, 175, 139, 191],
};

let tileKey;
let tilesInView = [];
let tileData = {}; // tile -&gt; layers
function updateTiles() {
  const bbox = getBounds();
  const z = Math.min(Math.trunc(camera.zoom), MAX_TILE_ZOOM);
  const minTile = tilebelt.pointToTile(bbox[0], bbox[3], z);
  const maxTile = tilebelt.pointToTile(bbox[2], bbox[1], z);

  // tiles visible in viewport
  tilesInView = [];
  const [minX, maxX] = [Math.max(minTile[0], 0), maxTile[0]];
  const [minY, maxY] = [Math.max(minTile[1], 0), maxTile[1]];
  for (let x = minX; x &lt;= maxX; x++) {
    for (let y = minY; y &lt;= maxY; y++) {
      tilesInView.push([x, y, z]);
    }
  }

  // load tile features from server
  const key = tilesInView.map(t =&gt; t.join(&#39;/&#39;)).join(&#39;;&#39;);
  if (tileKey !== key) { // tile changed
    tileData = {};

    // process each tile concurrently, and update data on complete
    tilesInView.forEach(async (tile) =&gt; {
      const [x, y, z] = tile;

      const reqStart = Date.now();
      const res = await axios.get(`https://maps.ckochis.com/data/v3/${z}/${x}/${y}.pbf?apiKey=${config(&#39;mapsApiKey&#39;)}`, {
        responseType: &#39;arraybuffer&#39;,
      });

      const pbf = new Protobuf(res.data);
      const vectorTile = new VectorTile(pbf);

      // process only the layers we are using
      const layers = [] // layers -&gt; features
      Object.keys(LAYERS).forEach((layer) =&gt; {
        if (vectorTile?.layers?.[layer]) {
          const numFeatures = vectorTile.layers[layer]?._features?.length || 0;

          const vertices = [];
          for (let i = 0; i &lt; numFeatures; i++) {
            const geojson = vectorTile.layers[layer].feature(i).toGeoJSON(x, y, z);
            vertices.push(...geometryToVertices(geojson.geometry));
          }
          layers.push({ layer, vertices: Float32Array.from(vertices) });
        }
      });
      // store layers for tile
      tileData[tile.join(&#39;/&#39;)] = layers;
    });
    tileKey = key;
  }
}

let matrix;
function updateMatrix() {
  const cameraMat = mat3.create();

  // translate
  mat3.translate(cameraMat, cameraMat, [camera.x, camera.y]);

  // scale
  const zoomScale = 1 / Math.pow(2, camera.zoom);
  const widthScale = TILE_SIZE / canvas.width;
  const heightScale = TILE_SIZE / canvas.height;
  mat3.scale(cameraMat, cameraMat, [zoomScale / widthScale, zoomScale / heightScale]);

  // update matrix
  matrix = mat3.multiply(
    [],
    mat3.create(), // identity matrix
    mat3.invert([], cameraMat) // invert camera position
  );
}

//////////////////////
// helpers
//////////////////////
function getClipSpacePosition(e) {
  // handle mouse and touch events
  const [x, y] = [
    e.center?.x || e.clientX,
    e.center?.y || e.clientY
  ];

  // get canvas relative css position
  const rect = canvas.getBoundingClientRect();
  const cssX = x - rect.left;
  const cssY = y - rect.top;

  // get normalized 0 to 1 position across and down canvas
  const normalizedX = cssX / canvas.clientWidth;
  const normalizedY = cssY / canvas.clientHeight;

  // convert to clip space
  const clipX = normalizedX *  2 - 1;
  const clipY = normalizedY * -2 + 1;

  return [clipX, clipY];
}

// convert a GeoJSON geometry to webgl vertices
function geometryToVertices(geometry) {
  const verticesFromPolygon = (coordinates, n) =&gt; {
    const data = earcut.flatten(coordinates);
    const triangles = earcut(data.vertices, data.holes, 2);

    const vertices = new Float32Array(triangles.length * 2);
    for (let i = 0; i &lt; triangles.length; i++) {
      const point = triangles[i];
      const lng = data.vertices[point * 2];
      const lat = data.vertices[point * 2 + 1];
      const [x, y] = MercatorCoordinate.fromLngLat([lng, lat]);
      vertices[i * 2] = x;
      vertices[i * 2 + 1] = y;
    }
    return vertices;
  }

  if (geometry.type === &#39;Polygon&#39;) {
    return verticesFromPolygon(geometry.coordinates);
  }

  if (geometry.type === &#39;MultiPolygon&#39;) {
    const positions = [];
    geometry.coordinates.forEach((polygon, i) =&gt; {
      positions.push(...verticesFromPolygon([polygon[0]], i));
    });
    return Float32Array.from(positions);
  }

  // only support Polygon &amp; Multipolygon for now
  return new Float32Array();
}

// get bbox coordinates for viewport
function getBounds() {
  const zoomScale = Math.pow(2, camera.zoom);

  // undo clip-space
  const px = (1 + camera.x) / 2;
  const py = (1 - camera.y) / 2;

  // get world coord in px
  const wx = px * TILE_SIZE;
  const wy = py * TILE_SIZE;

  // get zoom px
  const zx = wx * zoomScale;
  const zy = wy * zoomScale;

  // get bottom-left and top-right pixels
  let x1 = zx - (canvas.width / 2);
  let y1 = zy + (canvas.height / 2);
  let x2 = zx + (canvas.width / 2);
  let y2 = zy - (canvas.height / 2);

  // convert to world coords
  x1 = x1 / zoomScale / TILE_SIZE;
  y1 = y1 / zoomScale / TILE_SIZE;
  x2 = x2 / zoomScale / TILE_SIZE;
  y2 = y2 / zoomScale / TILE_SIZE;

  // get LngLat bounding box
  const bbox = [
    Math.max(MercatorCoordinate.lngFromMercatorX(x1), -180),
    Math.max(MercatorCoordinate.latFromMercatorY(y1), -85.05),
    Math.min(MercatorCoordinate.lngFromMercatorX(x2), 180),
    Math.min(MercatorCoordinate.latFromMercatorY(y2), 85.05),
  ];

  return bbox;
}

function atLimits() {
  const bbox = getBounds();
  return bbox[0] === -180 || bbox[1] === -85.05 || bbox[2] === 180 || bbox[3] === 85.05;
}

//////////////////////
// main program
//////////////////////
let handlePan;
let handleZoom;

let timestamp;
let slowCount;
let frameStats;

const run = (canvasId, mobile, abort) =&gt; {
  // setup loop state
  loopRunning = true;
  timestamp = 0;
  slowCount = 0;

  // create stats object for widget
  const stats = new Stats();

  // get GL context from canvas
  canvas = document.getElementById(canvasId);
  const gl = canvas.getContext(&#34;webgl&#34;);

  // get overlay
  overlay = document.getElementById(`${canvasId}-overlay`);

  // setup initial state
  updateMatrix();
  updateTiles();

  // setup viewport
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // compile shaders
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  // init gl program
  const program = createProgram(gl, vertexShader, fragmentShader);
  gl.clearColor(0, 0, 0, 0);
  gl.useProgram(program);

  // create buffer
  const positionBuffer = gl.createBuffer();

  const draw = () =&gt; {
    frameStats = { drawCalls: 0, vertices: 0 };
    stats.begin();

    // set matrix as uniform
    const matrixLocation = gl.getUniformLocation(program, &#34;u_matrix&#34;);
    gl.uniformMatrix3fv(matrixLocation, false, matrix);

    // render tiles
    Object.keys(tileData).forEach((tile) =&gt; {
      tileData[tile].forEach((tileLayer) =&gt; {
        const { layer, vertices } = tileLayer;

        if (LAYERS[layer]) {
          const color = LAYERS[layer].map(n =&gt; n / 255);

          // set color uniform for layer
          const colorLocation = gl.getUniformLocation(program, &#34;u_color&#34;);
          gl.uniform4fv(colorLocation, color);

          // create buffer for vertices
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

          // setup position attribute
          const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
          gl.enableVertexAttribArray(positionAttributeLocation);

          // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
          const size = 2;
          const type = gl.FLOAT;
          const normalize = false;
          const stride = 0;
          let offset = 0; 
          gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

          // draw
          const primitiveType = gl.TRIANGLES;
          offset = 0;
          const count = vertices.length / 2;
          gl.drawArrays(primitiveType, offset, count);

          frameStats.drawCalls++;
          frameStats.vertices+= vertices.length;
        }
      });
    });

    overlay.replaceChildren(); // clear labels to redraw

    // render boundaries and label for tiles in view
    tilesInView.forEach((tile) =&gt; {
      const colorLocation = gl.getUniformLocation(program, &#34;u_color&#34;);
      gl.uniform4fv(colorLocation, [1, 0, 0, 1]);

      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

      const tileVertices = geometryToVertices(tilebelt.tileToGeoJSON(tile));
      gl.bufferData(gl.ARRAY_BUFFER, tileVertices, gl.STATIC_DRAW);

      // setup position attribute
      const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
      gl.enableVertexAttribArray(positionAttributeLocation);

      // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
      const size = 2;
      const type = gl.FLOAT;
      const normalize = false;
      const stride = 0;
      let offset = 0; 
      gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

      // draw
      const primitiveType = gl.LINES;
      offset = 0;
      const count = tileVertices.length / 2;
      gl.drawArrays(primitiveType, offset, count);

      // draw tile labels
      const tileCoordinates = tilebelt.tileToGeoJSON(tile).coordinates;
      const topLeft = tileCoordinates[0][0];
      const [x, y] = MercatorCoordinate.fromLngLat(topLeft);

      const [clipX, clipY] = vec3.transformMat3(
        [],
        [x, y, 1],
        matrix,
      );

      const wx = ((1 + clipX) / 2) * canvas.width;
      const wy = ((1 - clipY) / 2) * canvas.height;
      const div = document.createElement(&#34;div&#34;);
      div.className = &#34;tile-label&#34;;
      div.style.left = (wx + 8) + &#34;px&#34;;
      div.style.top  = (wy + 8) + &#34;px&#34;;
      div.style.position = &#39;absolute&#39;;
      div.style.zIndex = 1000;
      div.appendChild(document.createTextNode(tile.join(&#39;/&#39;)));
      overlay.appendChild(div);
    });

    // kill loop if gets too slow
    // 10 frames under 10 FPS
    const now = performance.now();
    const fps = 1 / ((now - timestamp) / 1000);
    if (fps &lt; 10) {
      slowCount++;

      if (slowCount &gt; 10) {
        console.warn(`Too slow. Killing loop for ${canvasId}.`);
        stop();
        if (abort) {
          abort();
        }
      }
    }
    timestamp = now;

    // end of loop
    stats.end();
    if (loopRunning) {
      window.requestAnimationFrame(draw);
    }
  }
  window.requestAnimationFrame(draw); // start loop


  ////////////////////////
  // interaction handlers
  ////////////////////////

  // handle touch events
  const Hammer = require(&#39;hammerjs&#39;);
  const hammer = new Hammer(canvas);
  hammer.get(&#39;pan&#39;).set({ direction: Hammer.DIRECTION_ALL });
  hammer.get(&#39;pinch&#39;).set({ enable: true });

  // handle pan events
  let startX;
  let startY;

  // handle drag changes while mouse is still down
  const handleMove = (moveEvent) =&gt; {
    const [x, y] = getClipSpacePosition(moveEvent);

    // compute the previous position in world space
    const [preX, preY] = vec3.transformMat3(
      [],
      [startX, startY, 0],
      mat3.invert([], matrix)
    );

    // compute the new position in world space
    const [postX, postY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // move that amount, because how much the position changes depends on the zoom level
    const deltaX = preX - postX;
    const deltaY = preY - postY;
    if (isNaN(deltaX) || isNaN(deltaY)) {
      return; // abort
    }

    // only update within world limits
    camera.x += deltaX;
    camera.y += deltaY;

    // update matrix with new camera
    updateMatrix();

    // prevent further pan if at limits
    if (atLimits()) {
      camera.x -= deltaX;
      camera.y -= deltaY;
      updateMatrix();
      return; // abort
    }

    // save current pos for next movement
    startX = x;
    startY = y;

    updateMatrix();
    updateTiles();
  }

  handlePan = (startEvent) =&gt; {
    // get position of initial drag
    [startX, startY] = getClipSpacePosition(startEvent);
    canvas.style.cursor = &#39;grabbing&#39;;

    window.addEventListener(&#39;mousemove&#39;, handleMove);
    hammer.on(&#39;pan&#39;, handleMove);

    // clear on release
    const clear = (event) =&gt; {
      canvas.style.cursor = &#39;grab&#39;;
      window.removeEventListener(&#39;mousemove&#39;, handleMove);
      window.removeEventListener(&#39;mouseup&#39;, clear);
      hammer.off(&#39;pan&#39;, handleMove);
      hammer.off(&#39;panend&#39;, clear);
    };
    window.addEventListener(&#39;mouseup&#39;, clear);
    hammer.on(&#39;panend&#39;, clear);
  }
  canvas.addEventListener(&#39;mousedown&#39;, handlePan);
  hammer.on(&#39;panstart&#39;, handlePan);

  // handle zoom events
  handleZoom = (wheelEvent) =&gt; {
    wheelEvent.preventDefault();
    const [x, y] = getClipSpacePosition(wheelEvent);

    // get position before zooming
    const [preZoomX, preZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // update current zoom state
    const prevZoom = camera.zoom;
    const zoomDelta = -wheelEvent.deltaY * (1 / 500);
    camera.zoom += zoomDelta;
    camera.zoom = Math.max(MIN_ZOOM, Math.min(camera.zoom, MAX_ZOOM));
    updateMatrix();

    // prevent further zoom if at limits
    if (atLimits()) {
      camera.zoom = prevZoom
      updateMatrix();
      return;
    }

    // get new position after zooming
    const [postZoomX, postZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // camera needs to be translated the difference of before and after
    camera.x += preZoomX - postZoomX;
    camera.y += preZoomY - postZoomY;
    updateMatrix();
    updateTiles();
  }
  canvas.addEventListener(&#39;wheel&#39;, handleZoom);
  hammer.on(&#39;pinch&#39;, handleZoom);

  // setup stats widget
  stats.showPanel(0); // frame rate
  statsWidget = stats.dom;
  statsWidget.style.position = &#39;absolute&#39;;
  statsWidget.style.left = mobile ? 0 : &#39;-100px&#39;;
  statsWidget.style.zIndex = &#39;0&#39;;
  canvas.parentElement.appendChild(statsWidget);
};

export const stop = () =&gt; {
  loopRunning = false;

  // clear event handlers
  if (canvas) {
    canvas.removeEventListener(&#39;wheel&#39;, handleZoom);
    canvas.removeEventListener(&#39;mousedown&#39;, handlePan);
    overlay.replaceChildren();
    statsWidget.remove();
  }
};

// get the latest frame stats
export const getFrameStats = () =&gt; {
  return frameStats;
}

export default run;
</code></span></p></div></div></div></div></div><p>You‚Äôll notice the frame rate is consistently much higher, and navigating is much smoother. In fact, the jump in performance was high enough that we easily added an additional buildings layer (the brown-ish rectangles rendered at high zoom levels).</p><pre>// last render stats
no. of gl draw calls: undefined
no. of vertices: undefined</pre><p>Even though the frame rate is higher, we‚Äôre still getting some flashing when loading the tiles, so let‚Äôs address that next.</p></div><div><p>The tile flashing is a relatively simple fix. In our <span>updateTiles</span> code, we just need to check if we‚Äôve already loaded that tile at some point, and just re-use the data if it already exists (instead of fetching it from the server).</p><p><span><code>// process each tile concurrently, and update data on complete
tilesInView.forEach(async (tile) =&gt; {
  if (tileData[tile.join(&#39;/&#39;)]) {
    return; // already loaded, no need to fetch
  }

  const [x, y, z] = tile;

  const res = await axios.get(`https://maps.ckochis.com/data/v3/${z}/${x}/${y}.pbf`, {
    responseType: &#39;arraybuffer&#39;,
  });
  ...</code></span></p><div><p>+ See Code</p><div id="collapsible-content-1660876680025" role="region" aria-labelledby="collapsible-trigger-1660876680025"><div><div><ul><li><span>script.js</span></li></ul><div><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span><span>58
</span><span>59
</span><span>60
</span><span>61
</span><span>62
</span><span>63
</span><span>64
</span><span>65
</span><span>66
</span><span>67
</span><span>68
</span><span>69
</span><span>70
</span><span>71
</span><span>72
</span><span>73
</span><span>74
</span><span>75
</span><span>76
</span><span>77
</span><span>78
</span><span>79
</span><span>80
</span><span>81
</span><span>82
</span><span>83
</span><span>84
</span><span>85
</span><span>86
</span><span>87
</span><span>88
</span><span>89
</span><span>90
</span><span>91
</span><span>92
</span><span>93
</span><span>94
</span><span>95
</span><span>96
</span><span>97
</span><span>98
</span><span>99
</span><span>100
</span><span>101
</span><span>102
</span><span>103
</span><span>104
</span><span>105
</span><span>106
</span><span>107
</span><span>108
</span><span>109
</span><span>110
</span><span>111
</span><span>112
</span><span>113
</span><span>114
</span><span>115
</span><span>116
</span><span>117
</span><span>118
</span><span>119
</span><span>120
</span><span>121
</span><span>122
</span><span>123
</span><span>124
</span><span>125
</span><span>126
</span><span>127
</span><span>128
</span><span>129
</span><span>130
</span><span>131
</span><span>132
</span><span>133
</span><span>134
</span><span>135
</span><span>136
</span><span>137
</span><span>138
</span><span>139
</span><span>140
</span><span>141
</span><span>142
</span><span>143
</span><span>144
</span><span>145
</span><span>146
</span><span>147
</span><span>148
</span><span>149
</span><span>150
</span><span>151
</span><span>152
</span><span>153
</span><span>154
</span><span>155
</span><span>156
</span><span>157
</span><span>158
</span><span>159
</span><span>160
</span><span>161
</span><span>162
</span><span>163
</span><span>164
</span><span>165
</span><span>166
</span><span>167
</span><span>168
</span><span>169
</span><span>170
</span><span>171
</span><span>172
</span><span>173
</span><span>174
</span><span>175
</span><span>176
</span><span>177
</span><span>178
</span><span>179
</span><span>180
</span><span>181
</span><span>182
</span><span>183
</span><span>184
</span><span>185
</span><span>186
</span><span>187
</span><span>188
</span><span>189
</span><span>190
</span><span>191
</span><span>192
</span><span>193
</span><span>194
</span><span>195
</span><span>196
</span><span>197
</span><span>198
</span><span>199
</span><span>200
</span><span>201
</span><span>202
</span><span>203
</span><span>204
</span><span>205
</span><span>206
</span><span>207
</span><span>208
</span><span>209
</span><span>210
</span><span>211
</span><span>212
</span><span>213
</span><span>214
</span><span>215
</span><span>216
</span><span>217
</span><span>218
</span><span>219
</span><span>220
</span><span>221
</span><span>222
</span><span>223
</span><span>224
</span><span>225
</span><span>226
</span><span>227
</span><span>228
</span><span>229
</span><span>230
</span><span>231
</span><span>232
</span><span>233
</span><span>234
</span><span>235
</span><span>236
</span><span>237
</span><span>238
</span><span>239
</span><span>240
</span><span>241
</span><span>242
</span><span>243
</span><span>244
</span><span>245
</span><span>246
</span><span>247
</span><span>248
</span><span>249
</span><span>250
</span><span>251
</span><span>252
</span><span>253
</span><span>254
</span><span>255
</span><span>256
</span><span>257
</span><span>258
</span><span>259
</span><span>260
</span><span>261
</span><span>262
</span><span>263
</span><span>264
</span><span>265
</span><span>266
</span><span>267
</span><span>268
</span><span>269
</span><span>270
</span><span>271
</span><span>272
</span><span>273
</span><span>274
</span><span>275
</span><span>276
</span><span>277
</span><span>278
</span><span>279
</span><span>280
</span><span>281
</span><span>282
</span><span>283
</span><span>284
</span><span>285
</span><span>286
</span><span>287
</span><span>288
</span><span>289
</span><span>290
</span><span>291
</span><span>292
</span><span>293
</span><span>294
</span><span>295
</span><span>296
</span><span>297
</span><span>298
</span><span>299
</span><span>300
</span><span>301
</span><span>302
</span><span>303
</span><span>304
</span><span>305
</span><span>306
</span><span>307
</span><span>308
</span><span>309
</span><span>310
</span><span>311
</span><span>312
</span><span>313
</span><span>314
</span><span>315
</span><span>316
</span><span>317
</span><span>318
</span><span>319
</span><span>320
</span><span>321
</span><span>322
</span><span>323
</span><span>324
</span><span>325
</span><span>326
</span><span>327
</span><span>328
</span><span>329
</span><span>330
</span><span>331
</span><span>332
</span><span>333
</span><span>334
</span><span>335
</span><span>336
</span><span>337
</span><span>338
</span><span>339
</span><span>340
</span><span>341
</span><span>342
</span><span>343
</span><span>344
</span><span>345
</span><span>346
</span><span>347
</span><span>348
</span><span>349
</span><span>350
</span><span>351
</span><span>352
</span><span>353
</span><span>354
</span><span>355
</span><span>356
</span><span>357
</span><span>358
</span><span>359
</span><span>360
</span><span>361
</span><span>362
</span><span>363
</span><span>364
</span><span>365
</span><span>366
</span><span>367
</span><span>368
</span><span>369
</span><span>370
</span><span>371
</span><span>372
</span><span>373
</span><span>374
</span><span>375
</span><span>376
</span><span>377
</span><span>378
</span><span>379
</span><span>380
</span><span>381
</span><span>382
</span><span>383
</span><span>384
</span><span>385
</span><span>386
</span><span>387
</span><span>388
</span><span>389
</span><span>390
</span><span>391
</span><span>392
</span><span>393
</span><span>394
</span><span>395
</span><span>396
</span><span>397
</span><span>398
</span><span>399
</span><span>400
</span><span>401
</span><span>402
</span><span>403
</span><span>404
</span><span>405
</span><span>406
</span><span>407
</span><span>408
</span><span>409
</span><span>410
</span><span>411
</span><span>412
</span><span>413
</span><span>414
</span><span>415
</span><span>416
</span><span>417
</span><span>418
</span><span>419
</span><span>420
</span><span>421
</span><span>422
</span><span>423
</span><span>424
</span><span>425
</span><span>426
</span><span>427
</span><span>428
</span><span>429
</span><span>430
</span><span>431
</span><span>432
</span><span>433
</span><span>434
</span><span>435
</span><span>436
</span><span>437
</span><span>438
</span><span>439
</span><span>440
</span><span>441
</span><span>442
</span><span>443
</span><span>444
</span><span>445
</span><span>446
</span><span>447
</span><span>448
</span><span>449
</span><span>450
</span><span>451
</span><span>452
</span><span>453
</span><span>454
</span><span>455
</span><span>456
</span><span>457
</span><span>458
</span><span>459
</span><span>460
</span><span>461
</span><span>462
</span><span>463
</span><span>464
</span><span>465
</span><span>466
</span><span>467
</span><span>468
</span><span>469
</span><span>470
</span><span>471
</span><span>472
</span><span>473
</span><span>474
</span><span>475
</span><span>476
</span><span>477
</span><span>478
</span><span>479
</span><span>480
</span><span>481
</span><span>482
</span><span>483
</span><span>484
</span><span>485
</span><span>486
</span><span>487
</span><span>488
</span><span>489
</span><span>490
</span><span>491
</span><span>492
</span><span>493
</span><span>494
</span><span>495
</span><span>496
</span><span>497
</span><span>498
</span><span>499
</span><span>500
</span><span>501
</span><span>502
</span><span>503
</span><span>504
</span><span>505
</span><span>506
</span><span>507
</span><span>508
</span><span>509
</span><span>510
</span><span>511
</span><span>512
</span><span>513
</span><span>514
</span><span>515
</span><span>516
</span><span>517
</span><span>518
</span><span>519
</span><span>520
</span><span>521
</span><span>522
</span><span>523
</span><span>524
</span><span>525
</span><span>526
</span><span>527
</span><span>528
</span><span>529
</span><span>530
</span><span>531
</span><span>532
</span><span>533
</span><span>534
</span><span>535
</span><span>536
</span><span>537
</span><span>538
</span><span>539
</span><span>540
</span><span>541
</span><span>542
</span><span>543
</span><span>544
</span><span>545
</span><span>546
</span><span>547
</span><span>548
</span><span>549
</span><span>550
</span><span>551
</span><span>552
</span><span>553
</span><span>554
</span><span>555
</span><span>556
</span><span>557
</span><span>558
</span><span>559
</span><span>560
</span><span>561
</span><span>562
</span><span>563
</span><span>564
</span><span>565
</span><span>566
</span><span>567
</span><span>568
</span><span>569
</span><span>570
</span><span>571
</span><span>572
</span><span>573
</span><span>574
</span><span>575
</span><span>576
</span><span>577
</span><span>578
</span><span>579
</span><span>580
</span><span>581
</span><span>582
</span></code><code>import axios from &#39;axios&#39;;
import Protobuf from &#39;pbf&#39;;
import { mat3, vec3 } from &#39;gl-matrix&#39;;
import earcut from &#39;earcut&#39;;
import tilebelt from &#39;@mapbox/tilebelt&#39;;
import { VectorTile } from &#39;@mapbox/vector-tile&#39;;
import MercatorCoordinate from &#39;./mercator-coordinate&#39;;
import Stats from &#39;stats.js&#39;;
import { createShader, createProgram } from &#39;./webgl-utils&#39;;
import config from &#39;../config&#39;;

//////////////////////
// constants
//////////////////////
const TILE_SIZE = 512;
const MAX_TILE_ZOOM = 14;
const MIN_ZOOM = 0;
const MAX_ZOOM = 16;

//////////////////////
// shaders
//////////////////////

// vertex shader just passes through the position,
// no modification to the vertices
const vertexShaderSource = `
  attribute vec2 a_position;

  uniform mat3 u_matrix; // 3 X 3 matrix

  void main() {
    vec2 position = (u_matrix * vec3(a_position, 1)).xy;
    gl_Position = vec4(position, 0, 1);
  }
`;

// set color via uniform
const fragmentShaderSource =`
  precision mediump float;

  uniform vec4 u_color;

  void main() {
    gl_FragColor = u_color;
  }
`;

//////////////////////
// map state
//////////////////////
let loopRunning = true;

const camera = {
  x: 0,
  y: 0,
  zoom: 0,
};

// initial transformation (Brooklyn)
camera.x = -0.41101919888888894;
camera.y = 0.2478952993354263;
camera.zoom = 13;

// DOM elements
let canvas;
let overlay;
let statsWidget;

const LAYERS = {
  water: [180, 240, 250, 255],
  landcover: [202, 246, 193, 255],
  park: [202, 255, 193, 255],
  building: [185, 175, 139, 191],
};

let tilesInView = [];
let tileData = {}; // tile -&gt; layers
let cacheStats = { tilesLoaded: 0, cacheHits: 0 };
function updateTiles() {
  const bbox = getBounds();
  const z = Math.min(Math.trunc(camera.zoom), MAX_TILE_ZOOM);
  const minTile = tilebelt.pointToTile(bbox[0], bbox[3], z);
  const maxTile = tilebelt.pointToTile(bbox[2], bbox[1], z);

  // tiles visible in viewport
  tilesInView = [];
  const [minX, maxX] = [Math.max(minTile[0], 0), maxTile[0]];
  const [minY, maxY] = [Math.max(minTile[1], 0), maxTile[1]];
  for (let x = minX; x &lt;= maxX; x++) {
    for (let y = minY; y &lt;= maxY; y++) {
      tilesInView.push([x, y, z]);
    }
  }

  // process each tile concurrently, and update data on complete
  tilesInView.forEach(async (tile) =&gt; {
    if (tileData[tile.join(&#39;/&#39;)]) {
      cacheStats.cacheHits++;
      return; // already loaded, no need to fetch
    }

    const [x, y, z] = tile;

    const res = await axios.get(`https://maps.ckochis.com/data/v3/${z}/${x}/${y}.pbf?apiKey=${config(&#39;mapsApiKey&#39;)}`, {
      responseType: &#39;arraybuffer&#39;,
    });
    cacheStats.tilesLoaded++;

    const pbf = new Protobuf(res.data);
    const vectorTile = new VectorTile(pbf);

    // process only the layers we are using
    const layers = [] // layers -&gt; features
    Object.keys(LAYERS).forEach((layer) =&gt; {
      if (vectorTile?.layers?.[layer]) {
        const numFeatures = vectorTile.layers[layer]?._features?.length || 0;

        const vertices = [];
        for (let i = 0; i &lt; numFeatures; i++) {
          const geojson = vectorTile.layers[layer].feature(i).toGeoJSON(x, y, z);
          vertices.push(...geometryToVertices(geojson.geometry));
        }
        layers.push({ layer, vertices: Float32Array.from(vertices) });
      }
    });
    // store layers for tile
    tileData[tile.join(&#39;/&#39;)] = layers;
  });
}

let matrix;
function updateMatrix() {
  const cameraMat = mat3.create();

  // translate
  mat3.translate(cameraMat, cameraMat, [camera.x, camera.y]);

  // scale
  const zoomScale = 1 / Math.pow(2, camera.zoom);
  const widthScale = TILE_SIZE / canvas.width;
  const heightScale = TILE_SIZE / canvas.height;
  mat3.scale(cameraMat, cameraMat, [zoomScale / widthScale, zoomScale / heightScale]);

  // update matrix
  matrix = mat3.multiply(
    [],
    mat3.create(), // identity matrix
    mat3.invert([], cameraMat) // invert camera position
  );
}

//////////////////////
// helpers
//////////////////////
function getClipSpacePosition(e) {
  // handle mouse and touch events
  const [x, y] = [
    e.center?.x || e.clientX,
    e.center?.y || e.clientY
  ];

  // get canvas relative css position
  const rect = canvas.getBoundingClientRect();
  const cssX = x - rect.left;
  const cssY = y - rect.top;

  // get normalized 0 to 1 position across and down canvas
  const normalizedX = cssX / canvas.clientWidth;
  const normalizedY = cssY / canvas.clientHeight;

  // convert to clip space
  const clipX = normalizedX *  2 - 1;
  const clipY = normalizedY * -2 + 1;

  return [clipX, clipY];
}

// convert a GeoJSON geometry to webgl vertices
function geometryToVertices(geometry) {
  const verticesFromPolygon = (coordinates, n) =&gt; {
    const data = earcut.flatten(coordinates);
    const triangles = earcut(data.vertices, data.holes, 2);

    const vertices = new Float32Array(triangles.length * 2);
    for (let i = 0; i &lt; triangles.length; i++) {
      const point = triangles[i];
      const lng = data.vertices[point * 2];
      const lat = data.vertices[point * 2 + 1];
      const [x, y] = MercatorCoordinate.fromLngLat([lng, lat]);
      vertices[i * 2] = x;
      vertices[i * 2 + 1] = y;
    }
    return vertices;
  }

  if (geometry.type === &#39;Polygon&#39;) {
    return verticesFromPolygon(geometry.coordinates);
  }

  if (geometry.type === &#39;MultiPolygon&#39;) {
    const positions = [];
    geometry.coordinates.forEach((polygon, i) =&gt; {
      positions.push(...verticesFromPolygon([polygon[0]], i));
    });
    return Float32Array.from(positions);
  }

  // only support Polygon &amp; Multipolygon for now
  return new Float32Array();
}

// get bbox coordinates for viewport
function getBounds() {
  const zoomScale = Math.pow(2, camera.zoom);

  // undo clip-space
  const px = (1 + camera.x) / 2;
  const py = (1 - camera.y) / 2;

  // get world coord in px
  const wx = px * TILE_SIZE;
  const wy = py * TILE_SIZE;

  // get zoom px
  const zx = wx * zoomScale;
  const zy = wy * zoomScale;

  // get bottom-left and top-right pixels
  let x1 = zx - (canvas.width / 2);
  let y1 = zy + (canvas.height / 2);
  let x2 = zx + (canvas.width / 2);
  let y2 = zy - (canvas.height / 2);

  // convert to world coords
  x1 = x1 / zoomScale / TILE_SIZE;
  y1 = y1 / zoomScale / TILE_SIZE;
  x2 = x2 / zoomScale / TILE_SIZE;
  y2 = y2 / zoomScale / TILE_SIZE;

  // get LngLat bounding box
  const bbox = [
    Math.max(MercatorCoordinate.lngFromMercatorX(x1), -180),
    Math.max(MercatorCoordinate.latFromMercatorY(y1), -85.05),
    Math.min(MercatorCoordinate.lngFromMercatorX(x2), 180),
    Math.min(MercatorCoordinate.latFromMercatorY(y2), 85.05),
  ];

  return bbox;
}

function atLimits() {
  const bbox = getBounds();
  return bbox[0] === -180 || bbox[1] === -85.05 || bbox[2] === 180 || bbox[3] === 85.05;
}

//////////////////////
// main program
//////////////////////
let handlePan;
let handleZoom;

let timestamp;
let slowCount;
let frameStats;

const run = (canvasId, mobile, abort) =&gt; {
  // setup loop state
  loopRunning = true;
  timestamp = 0;
  slowCount = 0;

  // create stats object for widget
  const stats = new Stats();

  // get GL context from canvas
  canvas = document.getElementById(canvasId);
  const gl = canvas.getContext(&#34;webgl&#34;);

  // get overlay
  overlay = document.getElementById(`${canvasId}-overlay`);

  // setup initial state
  updateMatrix();
  updateTiles();

  // setup viewport
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // compile shaders
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  // init gl program
  const program = createProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  gl.clearColor(0, 0, 0, 0);

  // create buffer
  const positionBuffer = gl.createBuffer();

  const draw = () =&gt; {
    frameStats = { drawCalls: 0, vertices: 0 };
    stats.begin();

    // set matrix as uniform
    const matrixLocation = gl.getUniformLocation(program, &#34;u_matrix&#34;);
    gl.uniformMatrix3fv(matrixLocation, false, matrix);

    // render tiles
    tilesInView.forEach((tile) =&gt; {
      const data = tileData[tile.join(&#39;/&#39;)];

      (data || []).forEach((tileLayer) =&gt; {
        const { layer, vertices } = tileLayer;

        if (LAYERS[layer]) {
          const color = LAYERS[layer].map(n =&gt; n / 255);

          // set color uniform for layer
          const colorLocation = gl.getUniformLocation(program, &#34;u_color&#34;);
          gl.uniform4fv(colorLocation, color);

          // create buffer for vertices
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

          // setup position attribute
          const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
          gl.enableVertexAttribArray(positionAttributeLocation);

          // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
          const size = 2;
          const type = gl.FLOAT;
          const normalize = false;
          const stride = 0;
          let offset = 0; 
          gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

          // draw
          const primitiveType = gl.TRIANGLES;
          offset = 0;
          const count = vertices.length / 2;
          gl.drawArrays(primitiveType, offset, count);

          frameStats.drawCalls++;
          frameStats.vertices+= vertices.length;
        }
      });
    });

    overlay.replaceChildren(); // clear labels to redraw

    // render boundaries and label for tiles in view
    tilesInView.forEach((tile) =&gt; {
      const colorLocation = gl.getUniformLocation(program, &#34;u_color&#34;);
      gl.uniform4fv(colorLocation, [1, 0, 0, 1]);

      const tileVertices = geometryToVertices(tilebelt.tileToGeoJSON(tile));
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, tileVertices, gl.STATIC_DRAW);

      // setup position attribute
      const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
      gl.enableVertexAttribArray(positionAttributeLocation);

      // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
      const size = 2;
      const type = gl.FLOAT;
      const normalize = false;
      const stride = 0;
      let offset = 0; 
      gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

      // draw
      const primitiveType = gl.LINES;
      offset = 0;
      const count = tileVertices.length / 2;
      gl.drawArrays(primitiveType, offset, count);

      // draw tile labels
      const tileCoordinates = tilebelt.tileToGeoJSON(tile).coordinates;
      const topLeft = tileCoordinates[0][0];
      const [x, y] = MercatorCoordinate.fromLngLat(topLeft);

      const [clipX, clipY] = vec3.transformMat3(
        [],
        [x, y, 1],
        matrix,
      );

      const wx = ((1 + clipX) / 2) * canvas.width;
      const wy = ((1 - clipY) / 2) * canvas.height;
      const div = document.createElement(&#34;div&#34;);
      div.className = &#34;tile-label&#34;;
      div.style.left = (wx + 8) + &#34;px&#34;;
      div.style.top  = (wy + 8) + &#34;px&#34;;
      div.style.position = &#39;absolute&#39;;
      div.style.zIndex = 1000;
      div.appendChild(document.createTextNode(tile.join(&#39;/&#39;)));
      overlay.appendChild(div);
    });

    // kill loop if gets too slow
    // 10 frames under 10 FPS
    const now = performance.now();
    const fps = 1 / ((now - timestamp) / 1000);
    if (fps &lt; 10) {
      slowCount++;

      if (slowCount &gt; 10) {
        console.warn(`Too slow. Killing loop for ${canvasId}.`);
        stop();
        if (abort) {
          abort();
        }
      }
    }
    timestamp = now;

    // end of loop
    stats.end();
    if (loopRunning) {
      window.requestAnimationFrame(draw);
    }
  }
  window.requestAnimationFrame(draw); // start loop


  ////////////////////////
  // interaction handlers
  ////////////////////////

  // handle touch events
  const Hammer = require(&#39;hammerjs&#39;);
  const hammer = new Hammer(canvas);
  hammer.get(&#39;pan&#39;).set({ direction: Hammer.DIRECTION_ALL });
  hammer.get(&#39;pinch&#39;).set({ enable: true });

  // handle pan events
  let startX;
  let startY;

  // handle drag changes while mouse is still down
  const handleMove = (moveEvent) =&gt; {
    const [x, y] = getClipSpacePosition(moveEvent);

    // compute the previous position in world space
    const [preX, preY] = vec3.transformMat3(
      [],
      [startX, startY, 0],
      mat3.invert([], matrix)
    );

    // compute the new position in world space
    const [postX, postY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // move that amount, because how much the position changes depends on the zoom level
    const deltaX = preX - postX;
    const deltaY = preY - postY;
    if (isNaN(deltaX) || isNaN(deltaY)) {
      return; // abort
    }

    // only update within world limits
    camera.x += deltaX;
    camera.y += deltaY;

    // update matrix with new camera
    updateMatrix();

    // prevent further pan if at limits
    if (atLimits()) {
      camera.x -= deltaX;
      camera.y -= deltaY;
      updateMatrix();
      return; // abort
    }

    // save current pos for next movement
    startX = x;
    startY = y;

    updateMatrix();
    updateTiles();
  }

  handlePan = (startEvent) =&gt; {
    // get position of initial drag
    [startX, startY] = getClipSpacePosition(startEvent);
    canvas.style.cursor = &#39;grabbing&#39;;

    window.addEventListener(&#39;mousemove&#39;, handleMove);
    hammer.on(&#39;pan&#39;, handleMove);

    // clear on release
    const clear = (event) =&gt; {
      canvas.style.cursor = &#39;grab&#39;;
      window.removeEventListener(&#39;mousemove&#39;, handleMove);
      window.removeEventListener(&#39;mouseup&#39;, clear);
      hammer.off(&#39;pan&#39;, handleMove);
      hammer.off(&#39;panend&#39;, clear);
    };
    window.addEventListener(&#39;mouseup&#39;, clear);
    hammer.on(&#39;panend&#39;, clear);
  }
  canvas.addEventListener(&#39;mousedown&#39;, handlePan);
  hammer.on(&#39;panstart&#39;, handlePan);

  // handle zoom events
  handleZoom = (wheelEvent) =&gt; {
    wheelEvent.preventDefault();
    const [x, y] = getClipSpacePosition(wheelEvent);

    // get position before zooming
    const [preZoomX, preZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // update current zoom state
    const prevZoom = camera.zoom;
    const zoomDelta = -wheelEvent.deltaY * (1 / 500);
    camera.zoom += zoomDelta;
    camera.zoom = Math.max(MIN_ZOOM, Math.min(camera.zoom, MAX_ZOOM));
    updateMatrix();

    // prevent further zoom if at limits
    if (atLimits()) {
      camera.zoom = prevZoom
      updateMatrix();
      return;
    }

    // get new position after zooming
    const [postZoomX, postZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // camera needs to be translated the difference of before and after
    camera.x += preZoomX - postZoomX;
    camera.y += preZoomY - postZoomY;
    updateMatrix();
    updateTiles();
  }
  canvas.addEventListener(&#39;wheel&#39;, handleZoom);
  hammer.on(&#39;pinch&#39;, handleZoom);

  // setup stats widget
  stats.showPanel(0); // frame rate
  statsWidget = stats.dom;
  statsWidget.style.position = &#39;absolute&#39;;
  statsWidget.style.left = mobile ? 0 : &#39;-100px&#39;;
  statsWidget.style.zIndex = &#39;0&#39;;
  canvas.parentElement.appendChild(statsWidget);
};

export const stop = () =&gt; {
  loopRunning = false;

  // clear event handlers
  if (canvas) {
    canvas.removeEventListener(&#39;wheel&#39;, handleZoom);
    canvas.removeEventListener(&#39;mousedown&#39;, handlePan);
    overlay.replaceChildren();
    statsWidget.remove();
  }
};

// get the latest frame stats
export const getCacheStats = () =&gt; {
  return cacheStats;
}

export default run;

</code></span></p></div></div></div></div></div><p>As we move around, we can see how many requests we&#39;re saving by not refetching tiles already loaded. There&#39;s still some flashing the first time a tile is loaded, but cached tiles should render seamlessly when moving between them.</p><pre>tiles loaded: undefined
cache hits: undefined</pre></div><div><p>Now that we‚Äôve solved the issue of repeatedly flashing tiles, let&#39;s clean up the flash on the initial load, that can sometimes be seen when moving the map quickly.</p><p>We know that cached tiles will render seamlessly when moved back into view, so we can actually pre-load tiles that are near the viewport (ie. tiles we will likely navigate into).</p><p>We just need to configure how much we want to buffer. For now, let&#39;s just load an additional tile in each direction <span>(min - 1, max + 1)</span> to make sure the nearest tiles are covered for panning, as well as the parent (tiles above). We&#39;ll talk about the child tiles in the next section.</p><div><p>+ See Code</p><div id="collapsible-content-1660876680038" role="region" aria-labelledby="collapsible-trigger-1660876680038"><div><div><ul><li><span>script.js</span></li></ul><div><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span><span>58
</span><span>59
</span><span>60
</span><span>61
</span><span>62
</span><span>63
</span><span>64
</span><span>65
</span><span>66
</span><span>67
</span><span>68
</span><span>69
</span><span>70
</span><span>71
</span><span>72
</span><span>73
</span><span>74
</span><span>75
</span><span>76
</span><span>77
</span><span>78
</span><span>79
</span><span>80
</span><span>81
</span><span>82
</span><span>83
</span><span>84
</span><span>85
</span><span>86
</span><span>87
</span><span>88
</span><span>89
</span><span>90
</span><span>91
</span><span>92
</span><span>93
</span><span>94
</span><span>95
</span><span>96
</span><span>97
</span><span>98
</span><span>99
</span><span>100
</span><span>101
</span><span>102
</span><span>103
</span><span>104
</span><span>105
</span><span>106
</span><span>107
</span><span>108
</span><span>109
</span><span>110
</span><span>111
</span><span>112
</span><span>113
</span><span>114
</span><span>115
</span><span>116
</span><span>117
</span><span>118
</span><span>119
</span><span>120
</span><span>121
</span><span>122
</span><span>123
</span><span>124
</span><span>125
</span><span>126
</span><span>127
</span><span>128
</span><span>129
</span><span>130
</span><span>131
</span><span>132
</span><span>133
</span><span>134
</span><span>135
</span><span>136
</span><span>137
</span><span>138
</span><span>139
</span><span>140
</span><span>141
</span><span>142
</span><span>143
</span><span>144
</span><span>145
</span><span>146
</span><span>147
</span><span>148
</span><span>149
</span><span>150
</span><span>151
</span><span>152
</span><span>153
</span><span>154
</span><span>155
</span><span>156
</span><span>157
</span><span>158
</span><span>159
</span><span>160
</span><span>161
</span><span>162
</span><span>163
</span><span>164
</span><span>165
</span><span>166
</span><span>167
</span><span>168
</span><span>169
</span><span>170
</span><span>171
</span><span>172
</span><span>173
</span><span>174
</span><span>175
</span><span>176
</span><span>177
</span><span>178
</span><span>179
</span><span>180
</span><span>181
</span><span>182
</span><span>183
</span><span>184
</span><span>185
</span><span>186
</span><span>187
</span><span>188
</span><span>189
</span><span>190
</span><span>191
</span><span>192
</span><span>193
</span><span>194
</span><span>195
</span><span>196
</span><span>197
</span><span>198
</span><span>199
</span><span>200
</span><span>201
</span><span>202
</span><span>203
</span><span>204
</span><span>205
</span><span>206
</span><span>207
</span><span>208
</span><span>209
</span><span>210
</span><span>211
</span><span>212
</span><span>213
</span><span>214
</span><span>215
</span><span>216
</span><span>217
</span><span>218
</span><span>219
</span><span>220
</span><span>221
</span><span>222
</span><span>223
</span><span>224
</span><span>225
</span><span>226
</span><span>227
</span><span>228
</span><span>229
</span><span>230
</span><span>231
</span><span>232
</span><span>233
</span><span>234
</span><span>235
</span><span>236
</span><span>237
</span><span>238
</span><span>239
</span><span>240
</span><span>241
</span><span>242
</span><span>243
</span><span>244
</span><span>245
</span><span>246
</span><span>247
</span><span>248
</span><span>249
</span><span>250
</span><span>251
</span><span>252
</span><span>253
</span><span>254
</span><span>255
</span><span>256
</span><span>257
</span><span>258
</span><span>259
</span><span>260
</span><span>261
</span><span>262
</span><span>263
</span><span>264
</span><span>265
</span><span>266
</span><span>267
</span><span>268
</span><span>269
</span><span>270
</span><span>271
</span><span>272
</span><span>273
</span><span>274
</span><span>275
</span><span>276
</span><span>277
</span><span>278
</span><span>279
</span><span>280
</span><span>281
</span><span>282
</span><span>283
</span><span>284
</span><span>285
</span><span>286
</span><span>287
</span><span>288
</span><span>289
</span><span>290
</span><span>291
</span><span>292
</span><span>293
</span><span>294
</span><span>295
</span><span>296
</span><span>297
</span><span>298
</span><span>299
</span><span>300
</span><span>301
</span><span>302
</span><span>303
</span><span>304
</span><span>305
</span><span>306
</span><span>307
</span><span>308
</span><span>309
</span><span>310
</span><span>311
</span><span>312
</span><span>313
</span><span>314
</span><span>315
</span><span>316
</span><span>317
</span><span>318
</span><span>319
</span><span>320
</span><span>321
</span><span>322
</span><span>323
</span><span>324
</span><span>325
</span><span>326
</span><span>327
</span><span>328
</span><span>329
</span><span>330
</span><span>331
</span><span>332
</span><span>333
</span><span>334
</span><span>335
</span><span>336
</span><span>337
</span><span>338
</span><span>339
</span><span>340
</span><span>341
</span><span>342
</span><span>343
</span><span>344
</span><span>345
</span><span>346
</span><span>347
</span><span>348
</span><span>349
</span><span>350
</span><span>351
</span><span>352
</span><span>353
</span><span>354
</span><span>355
</span><span>356
</span><span>357
</span><span>358
</span><span>359
</span><span>360
</span><span>361
</span><span>362
</span><span>363
</span><span>364
</span><span>365
</span><span>366
</span><span>367
</span><span>368
</span><span>369
</span><span>370
</span><span>371
</span><span>372
</span><span>373
</span><span>374
</span><span>375
</span><span>376
</span><span>377
</span><span>378
</span><span>379
</span><span>380
</span><span>381
</span><span>382
</span><span>383
</span><span>384
</span><span>385
</span><span>386
</span><span>387
</span><span>388
</span><span>389
</span><span>390
</span><span>391
</span><span>392
</span><span>393
</span><span>394
</span><span>395
</span><span>396
</span><span>397
</span><span>398
</span><span>399
</span><span>400
</span><span>401
</span><span>402
</span><span>403
</span><span>404
</span><span>405
</span><span>406
</span><span>407
</span><span>408
</span><span>409
</span><span>410
</span><span>411
</span><span>412
</span><span>413
</span><span>414
</span><span>415
</span><span>416
</span><span>417
</span><span>418
</span><span>419
</span><span>420
</span><span>421
</span><span>422
</span><span>423
</span><span>424
</span><span>425
</span><span>426
</span><span>427
</span><span>428
</span><span>429
</span><span>430
</span><span>431
</span><span>432
</span><span>433
</span><span>434
</span><span>435
</span><span>436
</span><span>437
</span><span>438
</span><span>439
</span><span>440
</span><span>441
</span><span>442
</span><span>443
</span><span>444
</span><span>445
</span><span>446
</span><span>447
</span><span>448
</span><span>449
</span><span>450
</span><span>451
</span><span>452
</span><span>453
</span><span>454
</span><span>455
</span><span>456
</span><span>457
</span><span>458
</span><span>459
</span><span>460
</span><span>461
</span><span>462
</span><span>463
</span><span>464
</span><span>465
</span><span>466
</span><span>467
</span><span>468
</span><span>469
</span><span>470
</span><span>471
</span><span>472
</span><span>473
</span><span>474
</span><span>475
</span><span>476
</span><span>477
</span><span>478
</span><span>479
</span><span>480
</span><span>481
</span><span>482
</span><span>483
</span><span>484
</span><span>485
</span><span>486
</span><span>487
</span><span>488
</span><span>489
</span><span>490
</span><span>491
</span><span>492
</span><span>493
</span><span>494
</span><span>495
</span><span>496
</span><span>497
</span><span>498
</span><span>499
</span><span>500
</span><span>501
</span><span>502
</span><span>503
</span><span>504
</span><span>505
</span><span>506
</span><span>507
</span><span>508
</span><span>509
</span><span>510
</span><span>511
</span><span>512
</span><span>513
</span><span>514
</span><span>515
</span><span>516
</span><span>517
</span><span>518
</span><span>519
</span><span>520
</span><span>521
</span><span>522
</span><span>523
</span><span>524
</span><span>525
</span><span>526
</span><span>527
</span><span>528
</span><span>529
</span><span>530
</span><span>531
</span><span>532
</span><span>533
</span><span>534
</span><span>535
</span><span>536
</span><span>537
</span><span>538
</span><span>539
</span><span>540
</span><span>541
</span><span>542
</span><span>543
</span><span>544
</span><span>545
</span><span>546
</span><span>547
</span><span>548
</span><span>549
</span><span>550
</span><span>551
</span><span>552
</span><span>553
</span><span>554
</span><span>555
</span><span>556
</span><span>557
</span><span>558
</span><span>559
</span><span>560
</span><span>561
</span><span>562
</span><span>563
</span><span>564
</span><span>565
</span><span>566
</span><span>567
</span><span>568
</span><span>569
</span><span>570
</span><span>571
</span><span>572
</span><span>573
</span><span>574
</span><span>575
</span><span>576
</span><span>577
</span><span>578
</span><span>579
</span><span>580
</span><span>581
</span><span>582
</span><span>583
</span><span>584
</span><span>585
</span><span>586
</span><span>587
</span><span>588
</span><span>589
</span><span>590
</span><span>591
</span><span>592
</span><span>593
</span><span>594
</span><span>595
</span><span>596
</span><span>597
</span><span>598
</span><span>599
</span><span>600
</span><span>601
</span><span>602
</span><span>603
</span><span>604
</span><span>605
</span><span>606
</span><span>607
</span><span>608
</span><span>609
</span><span>610
</span><span>611
</span><span>612
</span><span>613
</span><span>614
</span><span>615
</span><span>616
</span><span>617
</span><span>618
</span><span>619
</span><span>620
</span><span>621
</span></code><code>import axios from &#39;axios&#39;;
import Protobuf from &#39;pbf&#39;;
import { mat3, vec3 } from &#39;gl-matrix&#39;;
import earcut from &#39;earcut&#39;;
import tilebelt from &#39;@mapbox/tilebelt&#39;;
import { VectorTile } from &#39;@mapbox/vector-tile&#39;;
import MercatorCoordinate from &#39;./mercator-coordinate&#39;;
import Stats from &#39;stats.js&#39;;
import { createShader, createProgram } from &#39;./webgl-utils&#39;;
import config from &#39;../config&#39;;

//////////////////////
// constants
//////////////////////
const TILE_SIZE = 512;
const MAX_TILE_ZOOM = 14;
const MIN_ZOOM = 0;
const MAX_ZOOM = 16;

//////////////////////
// shaders
//////////////////////

// vertex shader just passes through the position,
// no modification to the vertices
const vertexShaderSource = `
  attribute vec2 a_position;

  uniform mat3 u_matrix; // 3 X 3 matrix

  void main() {
    vec2 position = (u_matrix * vec3(a_position, 1)).xy;
    gl_Position = vec4(position, 0, 1);
  }
`;

// set color via uniform
const fragmentShaderSource =`
  precision mediump float;

  uniform vec4 u_color;

  void main() {
    gl_FragColor = u_color;
  }
`;

//////////////////////
// map state
//////////////////////
let loopRunning = true;

const camera = {
  x: 0,
  y: 0,
  zoom: 0,
};

// initial transformation (Brooklyn)
camera.x = -0.41101919888888894;
camera.y = 0.2478952993354263;
camera.zoom = 13;

// DOM elements
let canvas;
let overlay;
let statsWidget;

const LAYERS = {
  water: [180, 240, 250, 255],
  landcover: [202, 246, 193, 255],
  park: [202, 255, 193, 255],
  building: [185, 175, 139, 191],
};

const TILE_BUFFER = 1; // 1 tile in each direction

let tilesInView = [];
let tileData = {}; // tile -&gt; layers
let cacheStats = { tilesLoaded: 0, cacheHits: 0 };
function updateTiles() {
  const bbox = getBounds();
  const z = Math.min(Math.trunc(camera.zoom), MAX_TILE_ZOOM);
  const minTile = tilebelt.pointToTile(bbox[0], bbox[3], z);
  const maxTile = tilebelt.pointToTile(bbox[2], bbox[1], z);

  // tiles visible in viewport
  tilesInView = [];
  const [minX, maxX] = [Math.max(minTile[0], 0), maxTile[0]];
  const [minY, maxY] = [Math.max(minTile[1], 0), maxTile[1]];
  for (let x = minX; x &lt;= maxX; x++) {
    for (let y = minY; y &lt;= maxY; y++) {
      tilesInView.push([x, y, z]);
    }
  }

  // load additional tiles outside of viewport
  const bufferedTiles = [];
  for (let bufX = minX - TILE_BUFFER; bufX &lt;= maxX + TILE_BUFFER; bufX++) {
    for (let bufY = minY - TILE_BUFFER; bufY &lt;= maxY + TILE_BUFFER; bufY++) {
      bufferedTiles.push([bufX, bufY, z]); // buffer in xy direction

      // load parent tiles 2 levels up
      bufferedTiles.push(tilebelt.getParent([bufX, bufY, z]));
      bufferedTiles.push(tilebelt.getParent(tilebelt.getParent([bufX, bufY, z])));
    }
  }

  // remove dupes (and convert to strings)
  let tilesToLoad = [
    ...new Set([
      ...tilesInView.map(t =&gt; t.join(&#39;/&#39;)),
      ...bufferedTiles.map(t =&gt; t.join(&#39;/&#39;))
    ])
  ];

  // make sure tiles are in range
  tilesToLoad = tilesToLoad.filter((tile) =&gt; {
    const [x, y, z] = tile.split(&#39;/&#39;).map(Number);
    const N = Math.pow(2, z);
    const validX = x &gt;= 0 &amp;&amp; x &lt; N;
    const validY = y &gt;= 0 &amp;&amp; y &lt; N;
    const validZ = z &gt;= 0 &amp;&amp; z &lt;= MAX_TILE_ZOOM;
    return validX &amp;&amp; validY &amp;&amp; validZ;
  });

  // process each tile concurrently, and update data on complete
  tilesToLoad.forEach(async (tile) =&gt; {
    if (tileData[tile]) {
      cacheStats.cacheHits++;
      return; // already loaded, no need to fetch
    } else {
      tileData[tile] = []; // temp hold for request
    }

    try {
      const [x, y, z] = tile.split(&#39;/&#39;).map(Number);

      const res = await axios.get(`https://maps.ckochis.com/data/v3/${z}/${x}/${y}.pbf?apiKey=${config(&#39;mapsApiKey&#39;)}`, {
        responseType: &#39;arraybuffer&#39;,
      });
      cacheStats.tilesLoaded++;

      const pbf = new Protobuf(res.data);
      const vectorTile = new VectorTile(pbf);

      // process only the layers we are using
      const layers = [] // layers -&gt; features
      Object.keys(LAYERS).forEach((layer) =&gt; {
        if (vectorTile?.layers?.[layer]) {
          const numFeatures = vectorTile.layers[layer]?._features?.length || 0;

          const vertices = [];
          for (let i = 0; i &lt; numFeatures; i++) {
            const geojson = vectorTile.layers[layer].feature(i).toGeoJSON(x, y, z);
            vertices.push(...geometryToVertices(geojson.geometry));
          }
          layers.push({ layer, vertices: Float32Array.from(vertices) });
        }
      });
      // store layers for tile
      tileData[tile] = layers;

    } catch (e) {
      console.warn(`Tile ${tile} request failed.`, e);
      tileData[tile] = undefined; // release hold
    }
  });
}

let matrix;
function updateMatrix() {
  const cameraMat = mat3.create();

  // translate
  mat3.translate(cameraMat, cameraMat, [camera.x, camera.y]);

  // scale
  const zoomScale = 1 / Math.pow(2, camera.zoom);
  const widthScale = TILE_SIZE / canvas.width;
  const heightScale = TILE_SIZE / canvas.height;
  mat3.scale(cameraMat, cameraMat, [zoomScale / widthScale, zoomScale / heightScale]);

  // update matrix
  matrix = mat3.multiply(
    [],
    mat3.create(), // identity matrix
    mat3.invert([], cameraMat) // invert camera position
  );
}

//////////////////////
// helpers
//////////////////////
function getClipSpacePosition(e) {
  // handle mouse and touch events
  const [x, y] = [
    e.center?.x || e.clientX,
    e.center?.y || e.clientY
  ];

  // get canvas relative css position
  const rect = canvas.getBoundingClientRect();
  const cssX = x - rect.left;
  const cssY = y - rect.top;

  // get normalized 0 to 1 position across and down canvas
  const normalizedX = cssX / canvas.clientWidth;
  const normalizedY = cssY / canvas.clientHeight;

  // convert to clip space
  const clipX = normalizedX *  2 - 1;
  const clipY = normalizedY * -2 + 1;

  return [clipX, clipY];
}

// convert a GeoJSON geometry to webgl vertices
function geometryToVertices(geometry) {
  const verticesFromPolygon = (coordinates, n) =&gt; {
    const data = earcut.flatten(coordinates);
    const triangles = earcut(data.vertices, data.holes, 2);

    const vertices = new Float32Array(triangles.length * 2);
    for (let i = 0; i &lt; triangles.length; i++) {
      const point = triangles[i];
      const lng = data.vertices[point * 2];
      const lat = data.vertices[point * 2 + 1];
      const [x, y] = MercatorCoordinate.fromLngLat([lng, lat]);
      vertices[i * 2] = x;
      vertices[i * 2 + 1] = y;
    }
    return vertices;
  }

  if (geometry.type === &#39;Polygon&#39;) {
    return verticesFromPolygon(geometry.coordinates);
  }

  if (geometry.type === &#39;MultiPolygon&#39;) {
    const positions = [];
    geometry.coordinates.forEach((polygon, i) =&gt; {
      positions.push(...verticesFromPolygon([polygon[0]], i));
    });
    return Float32Array.from(positions);
  }

  // only support Polygon &amp; Multipolygon for now
  return new Float32Array();
}

// get bbox coordinates for viewport
function getBounds() {
  const zoomScale = Math.pow(2, camera.zoom);

  // undo clip-space
  const px = (1 + camera.x) / 2;
  const py = (1 - camera.y) / 2;

  // get world coord in px
  const wx = px * TILE_SIZE;
  const wy = py * TILE_SIZE;

  // get zoom px
  const zx = wx * zoomScale;
  const zy = wy * zoomScale;

  // get bottom-left and top-right pixels
  let x1 = zx - (canvas.width / 2);
  let y1 = zy + (canvas.height / 2);
  let x2 = zx + (canvas.width / 2);
  let y2 = zy - (canvas.height / 2);

  // convert to world coords
  x1 = x1 / zoomScale / TILE_SIZE;
  y1 = y1 / zoomScale / TILE_SIZE;
  x2 = x2 / zoomScale / TILE_SIZE;
  y2 = y2 / zoomScale / TILE_SIZE;

  // get LngLat bounding box
  const bbox = [
    Math.max(MercatorCoordinate.lngFromMercatorX(x1), -180),
    Math.max(MercatorCoordinate.latFromMercatorY(y1), -85.05),
    Math.min(MercatorCoordinate.lngFromMercatorX(x2), 180),
    Math.min(MercatorCoordinate.latFromMercatorY(y2), 85.05),
  ];

  return bbox;
}

function atLimits() {
  const bbox = getBounds();
  return bbox[0] === -180 || bbox[1] === -85.05 || bbox[2] === 180 || bbox[3] === 85.05;
}

//////////////////////
// main program
//////////////////////
let handlePan;
let handleZoom;

let frameStats;
let slowCount;
let timestamp;

const run = (canvasId, mobile, abort) =&gt; {
  // setup loop state
  loopRunning = true;
  timestamp = 0;
  slowCount = 0;

  // create stats object for widget
  const stats = new Stats();

  // get GL context from canvas
  canvas = document.getElementById(canvasId);
  const gl = canvas.getContext(&#34;webgl&#34;);

  // get overlay
  overlay = document.getElementById(`${canvasId}-overlay`);

  // setup initial state
  updateMatrix();
  updateTiles();

  // setup viewport
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // compile shaders
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  // init gl program
  const program = createProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  gl.clearColor(0, 0, 0, 0);

  // create buffer
  const positionBuffer = gl.createBuffer();

  const draw = () =&gt; {
    frameStats = { drawCalls: 0, vertices: 0 };
    stats.begin();

    // set matrix as uniform
    const matrixLocation = gl.getUniformLocation(program, &#34;u_matrix&#34;);
    gl.uniformMatrix3fv(matrixLocation, false, matrix);

    // render tiles
    tilesInView.forEach((tile) =&gt; {
      const data = tileData[tile.join(&#39;/&#39;)];

      (data || []).forEach((tileLayer) =&gt; {
        const { layer, vertices } = tileLayer;

        if (LAYERS[layer]) {
          const color = LAYERS[layer].map(n =&gt; n / 255);

          // set color uniform for layer
          const colorLocation = gl.getUniformLocation(program, &#34;u_color&#34;);
          gl.uniform4fv(colorLocation, color);

          // create buffer for vertices
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

          // setup position attribute
          const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
          gl.enableVertexAttribArray(positionAttributeLocation);

          // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
          const size = 2;
          const type = gl.FLOAT;
          const normalize = false;
          const stride = 0;
          let offset = 0; 
          gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

          // draw
          const primitiveType = gl.TRIANGLES;
          offset = 0;
          const count = vertices.length / 2;
          gl.drawArrays(primitiveType, offset, count);

          frameStats.drawCalls++;
          frameStats.vertices+= vertices.length;
        }
      });
    });

    overlay.replaceChildren(); // clear labels to redraw

    // render boundaries and label for tiles in view
    tilesInView.forEach((tile) =&gt; {
      const colorLocation = gl.getUniformLocation(program, &#34;u_color&#34;);
      gl.uniform4fv(colorLocation, [1, 0, 0, 1]);

      const tileVertices = geometryToVertices(tilebelt.tileToGeoJSON(tile));
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, tileVertices, gl.STATIC_DRAW);

      // setup position attribute
      const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
      gl.enableVertexAttribArray(positionAttributeLocation);

      // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
      const size = 2;
      const type = gl.FLOAT;
      const normalize = false;
      const stride = 0;
      let offset = 0; 
      gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

      // draw
      const primitiveType = gl.LINES;
      offset = 0;
      const count = tileVertices.length / 2;
      gl.drawArrays(primitiveType, offset, count);

      // draw tile labels
      const tileCoordinates = tilebelt.tileToGeoJSON(tile).coordinates;
      const topLeft = tileCoordinates[0][0];
      const [x, y] = MercatorCoordinate.fromLngLat(topLeft);

      const [clipX, clipY] = vec3.transformMat3(
        [],
        [x, y, 1],
        matrix,
      );

      const wx = ((1 + clipX) / 2) * canvas.width;
      const wy = ((1 - clipY) / 2) * canvas.height;
      const div = document.createElement(&#34;div&#34;);
      div.className = &#34;tile-label&#34;;
      div.style.left = (wx + 8) + &#34;px&#34;;
      div.style.top  = (wy + 8) + &#34;px&#34;;
      div.style.position = &#39;absolute&#39;;
      div.style.zIndex = 1000;
      div.appendChild(document.createTextNode(tile.join(&#39;/&#39;)));
      overlay.appendChild(div);
    });

    // kill loop if gets too slow
    // 10 frames under 10 FPS
    const now = performance.now();
    const fps = 1 / ((now - timestamp) / 1000);
    if (fps &lt; 10) {
      slowCount++;

      if (slowCount &gt; 10) {
        console.warn(`Too slow. Killing loop for ${canvasId}.`);
        stop();
        if (abort) {
          abort();
        }
      }
    }
    timestamp = now;

    // end of loop
    stats.end();
    if (loopRunning) {
      window.requestAnimationFrame(draw);
    }
  }
  window.requestAnimationFrame(draw); // start loop


  ////////////////////////
  // interaction handlers
  ////////////////////////

  // handle touch events
  const Hammer = require(&#39;hammerjs&#39;);
  const hammer = new Hammer(canvas);
  hammer.get(&#39;pan&#39;).set({ direction: Hammer.DIRECTION_ALL });
  hammer.get(&#39;pinch&#39;).set({ enable: true });

  // handle pan events
  let startX;
  let startY;

  // handle drag changes while mouse is still down
  const handleMove = (moveEvent) =&gt; {
    const [x, y] = getClipSpacePosition(moveEvent);

    // compute the previous position in world space
    const [preX, preY] = vec3.transformMat3(
      [],
      [startX, startY, 0],
      mat3.invert([], matrix)
    );

    // compute the new position in world space
    const [postX, postY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // move that amount, because how much the position changes depends on the zoom level
    const deltaX = preX - postX;
    const deltaY = preY - postY;
    if (isNaN(deltaX) || isNaN(deltaY)) {
      return; // abort
    }

    // only update within world limits
    camera.x += deltaX;
    camera.y += deltaY;

    // update matrix with new camera
    updateMatrix();

    // prevent further pan if at limits
    if (atLimits()) {
      camera.x -= deltaX;
      camera.y -= deltaY;
      updateMatrix();
      return; // abort
    }

    // save current pos for next movement
    startX = x;
    startY = y;

    updateMatrix();
    updateTiles();
  }

  handlePan = (startEvent) =&gt; {
    // get position of initial drag
    [startX, startY] = getClipSpacePosition(startEvent);
    canvas.style.cursor = &#39;grabbing&#39;;

    window.addEventListener(&#39;mousemove&#39;, handleMove);
    hammer.on(&#39;pan&#39;, handleMove);

    // clear on release
    const clear = (event) =&gt; {
      canvas.style.cursor = &#39;grab&#39;;
      window.removeEventListener(&#39;mousemove&#39;, handleMove);
      window.removeEventListener(&#39;mouseup&#39;, clear);
      hammer.off(&#39;pan&#39;, handleMove);
      hammer.off(&#39;panend&#39;, clear);
    };
    window.addEventListener(&#39;mouseup&#39;, clear);
    hammer.on(&#39;panend&#39;, clear);
  }
  canvas.addEventListener(&#39;mousedown&#39;, handlePan);
  hammer.on(&#39;panstart&#39;, handlePan);

  // handle zoom events
  handleZoom = (wheelEvent) =&gt; {
    wheelEvent.preventDefault();
    const [x, y] = getClipSpacePosition(wheelEvent);

    // get position before zooming
    const [preZoomX, preZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // update current zoom state
    const prevZoom = camera.zoom;
    const zoomDelta = -wheelEvent.deltaY * (1 / 500);
    camera.zoom += zoomDelta;
    camera.zoom = Math.max(MIN_ZOOM, Math.min(camera.zoom, MAX_ZOOM));
    updateMatrix();

    // prevent further zoom if at limits
    if (atLimits()) {
      camera.zoom = prevZoom
      updateMatrix();
      return;
    }

    // get new position after zooming
    const [postZoomX, postZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // camera needs to be translated the difference of before and after
    camera.x += preZoomX - postZoomX;
    camera.y += preZoomY - postZoomY;
    updateMatrix();
    updateTiles();
  }
  canvas.addEventListener(&#39;wheel&#39;, handleZoom);
  hammer.on(&#39;pinch&#39;, handleZoom);

  // setup stats widget
  stats.showPanel(0); // frame rate
  statsWidget = stats.dom;
  statsWidget.style.position = &#39;absolute&#39;;
  statsWidget.style.left = mobile ? 0 : &#39;-100px&#39;;
  statsWidget.style.zIndex = &#39;0&#39;;
  canvas.parentElement.appendChild(statsWidget);
};

export const stop = () =&gt; {
  loopRunning = false;

  // clear event handlers
  if (canvas) {
    canvas.removeEventListener(&#39;wheel&#39;, handleZoom);
    canvas.removeEventListener(&#39;mousedown&#39;, handlePan);
    overlay.replaceChildren();
    statsWidget.remove();
  }
};

// get the latest frame stats
export const getCacheStats = () =&gt; {
  return cacheStats;
}

export default run;
</code></span></p></div></div></div></div></div><p>With the exception of zooming in/out really quickly, the flashing should be greatly reduced when moving around. But we can take it a step further by scaling the data we already have to fill in missing tiles.</p></div><div><p>The last thing we‚Äôll do to prevent the flashing you see when zooming, is to just keep scaling the data that we already have in place of tiles that are still downloading.</p><p>Take zooming in for example. If we‚Äôre on zoom <em>level 8</em>, we will keep scaling the tiles up until we hit zoom <em>level 9</em>, at which point we render the level 9 tiles in view. But if those aren‚Äôt done being downloaded and parsed yet, we‚Äôll see a white square in its place. So what we can do, is continue to scale the level 8 tile up in its place, until we have the data for the correct tile (ie. we‚Äôll still be rendering the level 8 tile at 9+).</p><p>Similarly with zooming out, we can render all of the children for a tile if the one at the lower level isn‚Äôt available. This one is a bit more noticeable, since as we zoom out, we might only have partial children available for a parent tile. Take the screenshot below for instance, notice that not all of the child tiles are available. So while still not perfect, it‚Äôs slight improvement on the <em>whole</em> tile being blank.</p><div><div><p><img src="https://ckochis.com/images/child-tiles.png" alt="rendering a tile with partially loaded child tiles"/></p><p>rendering a tile with partially loaded child tiles</p></div></div><p>To accomplish this, we just need to introduce some fallback behavior for when tile data from <span>tileInView</span> is not available. We‚Äôll favor the case where the parent tile is available, since that will always cover more area, but we can still fallback to the child tiles in cases where we‚Äôre zooming out.</p><p>We can leverage the tilebelt library again for determining the parent <span>tilebel.getParent</span> and children <span>tilebelt.getChildren</span> tiles.</p><p><span><code>function getPlaceholderTile(tile) {
  // use parent if available
  const parent = tilebelt.getParent(tile)?.join(&#39;/&#39;);
  const parentFeatureSet = tileData[parent];
  if (parentFeatureSet?.length &gt; 0) {
    return parentFeatureSet;
  }

  // use whatever children are available
  const childFeatureSets = [];
  const children = (tilebelt.getChildren(tile) || []).map(t =&gt; t.join(&#39;/&#39;));
  children.forEach((child) =&gt; {
    const featureSet = tileData[child];
    if (featureSet?.length &gt; 0) {
      childFeatureSets.push(...featureSet);
    }
  });
  return childFeatureSets;
}

...

// in draw:
tilesInView.forEach((tile) =&gt; {
  let data = tileData[tile.join(&#39;/&#39;)];

  // use placehodler if tile in view is not available
  if (data?.length === 0) {
    data = getPlaceholderTile(tile);
  }

  (data || []).forEach((tileLayer) =&gt; {
    // ... render code
  }</code></span></p><p>And adding this fallback behavior to our code, should provide a smoother experience (ie. fewer flashes) as we move around the map.</p><div><p>+ See Code</p><div id="collapsible-content-1660876680062" role="region" aria-labelledby="collapsible-trigger-1660876680062"><div><div><ul><li><span>script.js</span></li><li><span>map-utils.js</span></li></ul><div><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span><span>58
</span><span>59
</span><span>60
</span><span>61
</span><span>62
</span><span>63
</span><span>64
</span><span>65
</span><span>66
</span><span>67
</span><span>68
</span><span>69
</span><span>70
</span><span>71
</span><span>72
</span><span>73
</span><span>74
</span><span>75
</span><span>76
</span><span>77
</span><span>78
</span><span>79
</span><span>80
</span><span>81
</span><span>82
</span><span>83
</span><span>84
</span><span>85
</span><span>86
</span><span>87
</span><span>88
</span><span>89
</span><span>90
</span><span>91
</span><span>92
</span><span>93
</span><span>94
</span><span>95
</span><span>96
</span><span>97
</span><span>98
</span><span>99
</span><span>100
</span><span>101
</span><span>102
</span><span>103
</span><span>104
</span><span>105
</span><span>106
</span><span>107
</span><span>108
</span><span>109
</span><span>110
</span><span>111
</span><span>112
</span><span>113
</span><span>114
</span><span>115
</span><span>116
</span><span>117
</span><span>118
</span><span>119
</span><span>120
</span><span>121
</span><span>122
</span><span>123
</span><span>124
</span><span>125
</span><span>126
</span><span>127
</span><span>128
</span><span>129
</span><span>130
</span><span>131
</span><span>132
</span><span>133
</span><span>134
</span><span>135
</span><span>136
</span><span>137
</span><span>138
</span><span>139
</span><span>140
</span><span>141
</span><span>142
</span><span>143
</span><span>144
</span><span>145
</span><span>146
</span><span>147
</span><span>148
</span><span>149
</span><span>150
</span><span>151
</span><span>152
</span><span>153
</span><span>154
</span><span>155
</span><span>156
</span><span>157
</span><span>158
</span><span>159
</span><span>160
</span><span>161
</span><span>162
</span><span>163
</span><span>164
</span><span>165
</span><span>166
</span><span>167
</span><span>168
</span><span>169
</span><span>170
</span><span>171
</span><span>172
</span><span>173
</span><span>174
</span><span>175
</span><span>176
</span><span>177
</span><span>178
</span><span>179
</span><span>180
</span><span>181
</span><span>182
</span><span>183
</span><span>184
</span><span>185
</span><span>186
</span><span>187
</span><span>188
</span><span>189
</span><span>190
</span><span>191
</span><span>192
</span><span>193
</span><span>194
</span><span>195
</span><span>196
</span><span>197
</span><span>198
</span><span>199
</span><span>200
</span><span>201
</span><span>202
</span><span>203
</span><span>204
</span><span>205
</span><span>206
</span><span>207
</span><span>208
</span><span>209
</span><span>210
</span><span>211
</span><span>212
</span><span>213
</span><span>214
</span><span>215
</span><span>216
</span><span>217
</span><span>218
</span><span>219
</span><span>220
</span><span>221
</span><span>222
</span><span>223
</span><span>224
</span><span>225
</span><span>226
</span><span>227
</span><span>228
</span><span>229
</span><span>230
</span><span>231
</span><span>232
</span><span>233
</span><span>234
</span><span>235
</span><span>236
</span><span>237
</span><span>238
</span><span>239
</span><span>240
</span><span>241
</span><span>242
</span><span>243
</span><span>244
</span><span>245
</span><span>246
</span><span>247
</span><span>248
</span><span>249
</span><span>250
</span><span>251
</span><span>252
</span><span>253
</span><span>254
</span><span>255
</span><span>256
</span><span>257
</span><span>258
</span><span>259
</span><span>260
</span><span>261
</span><span>262
</span><span>263
</span><span>264
</span><span>265
</span><span>266
</span><span>267
</span><span>268
</span><span>269
</span><span>270
</span><span>271
</span><span>272
</span><span>273
</span><span>274
</span><span>275
</span><span>276
</span><span>277
</span><span>278
</span><span>279
</span><span>280
</span><span>281
</span><span>282
</span><span>283
</span><span>284
</span><span>285
</span><span>286
</span><span>287
</span><span>288
</span><span>289
</span><span>290
</span><span>291
</span><span>292
</span><span>293
</span><span>294
</span><span>295
</span><span>296
</span><span>297
</span><span>298
</span><span>299
</span><span>300
</span><span>301
</span><span>302
</span><span>303
</span><span>304
</span><span>305
</span><span>306
</span><span>307
</span><span>308
</span><span>309
</span><span>310
</span><span>311
</span><span>312
</span><span>313
</span><span>314
</span><span>315
</span><span>316
</span><span>317
</span><span>318
</span><span>319
</span><span>320
</span><span>321
</span><span>322
</span><span>323
</span><span>324
</span><span>325
</span><span>326
</span><span>327
</span><span>328
</span><span>329
</span><span>330
</span><span>331
</span><span>332
</span><span>333
</span><span>334
</span><span>335
</span><span>336
</span><span>337
</span><span>338
</span><span>339
</span><span>340
</span><span>341
</span><span>342
</span><span>343
</span><span>344
</span><span>345
</span><span>346
</span><span>347
</span><span>348
</span><span>349
</span><span>350
</span><span>351
</span><span>352
</span><span>353
</span><span>354
</span><span>355
</span><span>356
</span><span>357
</span><span>358
</span><span>359
</span><span>360
</span><span>361
</span><span>362
</span><span>363
</span><span>364
</span><span>365
</span><span>366
</span><span>367
</span><span>368
</span><span>369
</span><span>370
</span><span>371
</span><span>372
</span><span>373
</span><span>374
</span><span>375
</span><span>376
</span><span>377
</span><span>378
</span><span>379
</span><span>380
</span><span>381
</span><span>382
</span><span>383
</span><span>384
</span><span>385
</span><span>386
</span><span>387
</span><span>388
</span><span>389
</span><span>390
</span><span>391
</span><span>392
</span><span>393
</span><span>394
</span><span>395
</span><span>396
</span><span>397
</span><span>398
</span><span>399
</span><span>400
</span><span>401
</span><span>402
</span><span>403
</span><span>404
</span><span>405
</span><span>406
</span><span>407
</span><span>408
</span><span>409
</span><span>410
</span><span>411
</span><span>412
</span><span>413
</span><span>414
</span><span>415
</span><span>416
</span><span>417
</span><span>418
</span><span>419
</span><span>420
</span><span>421
</span><span>422
</span><span>423
</span><span>424
</span><span>425
</span><span>426
</span><span>427
</span><span>428
</span><span>429
</span><span>430
</span><span>431
</span><span>432
</span><span>433
</span><span>434
</span><span>435
</span><span>436
</span><span>437
</span><span>438
</span><span>439
</span><span>440
</span><span>441
</span><span>442
</span><span>443
</span><span>444
</span><span>445
</span><span>446
</span><span>447
</span><span>448
</span><span>449
</span><span>450
</span><span>451
</span><span>452
</span><span>453
</span><span>454
</span><span>455
</span><span>456
</span><span>457
</span><span>458
</span><span>459
</span><span>460
</span><span>461
</span><span>462
</span><span>463
</span><span>464
</span><span>465
</span><span>466
</span><span>467
</span><span>468
</span><span>469
</span><span>470
</span><span>471
</span><span>472
</span><span>473
</span><span>474
</span><span>475
</span><span>476
</span><span>477
</span><span>478
</span><span>479
</span><span>480
</span><span>481
</span><span>482
</span><span>483
</span><span>484
</span><span>485
</span><span>486
</span><span>487
</span><span>488
</span><span>489
</span><span>490
</span><span>491
</span><span>492
</span><span>493
</span><span>494
</span><span>495
</span><span>496
</span><span>497
</span><span>498
</span><span>499
</span><span>500
</span><span>501
</span><span>502
</span><span>503
</span><span>504
</span><span>505
</span><span>506
</span><span>507
</span><span>508
</span><span>509
</span><span>510
</span><span>511
</span><span>512
</span><span>513
</span><span>514
</span><span>515
</span><span>516
</span><span>517
</span><span>518
</span><span>519
</span><span>520
</span><span>521
</span><span>522
</span><span>523
</span><span>524
</span><span>525
</span><span>526
</span><span>527
</span><span>528
</span><span>529
</span><span>530
</span><span>531
</span><span>532
</span><span>533
</span><span>534
</span><span>535
</span><span>536
</span><span>537
</span><span>538
</span><span>539
</span><span>540
</span><span>541
</span><span>542
</span><span>543
</span><span>544
</span><span>545
</span><span>546
</span><span>547
</span><span>548
</span><span>549
</span><span>550
</span><span>551
</span><span>552
</span><span>553
</span><span>554
</span><span>555
</span><span>556
</span><span>557
</span><span>558
</span><span>559
</span><span>560
</span><span>561
</span><span>562
</span><span>563
</span><span>564
</span><span>565
</span><span>566
</span><span>567
</span><span>568
</span><span>569
</span><span>570
</span><span>571
</span><span>572
</span><span>573
</span><span>574
</span><span>575
</span><span>576
</span><span>577
</span><span>578
</span><span>579
</span><span>580
</span><span>581
</span><span>582
</span><span>583
</span><span>584
</span><span>585
</span><span>586
</span><span>587
</span><span>588
</span><span>589
</span><span>590
</span><span>591
</span><span>592
</span><span>593
</span><span>594
</span><span>595
</span><span>596
</span><span>597
</span><span>598
</span><span>599
</span><span>600
</span><span>601
</span><span>602
</span><span>603
</span><span>604
</span><span>605
</span><span>606
</span><span>607
</span><span>608
</span><span>609
</span><span>610
</span><span>611
</span><span>612
</span><span>613
</span><span>614
</span><span>615
</span><span>616
</span><span>617
</span><span>618
</span><span>619
</span><span>620
</span><span>621
</span><span>622
</span><span>623
</span><span>624
</span><span>625
</span><span>626
</span><span>627
</span><span>628
</span><span>629
</span><span>630
</span><span>631
</span><span>632
</span><span>633
</span><span>634
</span><span>635
</span><span>636
</span><span>637
</span><span>638
</span><span>639
</span><span>640
</span><span>641
</span><span>642
</span><span>643
</span><span>644
</span><span>645
</span></code><code>import axios from &#39;axios&#39;;
import Protobuf from &#39;pbf&#39;;
import { mat3, vec3 } from &#39;gl-matrix&#39;;
import earcut from &#39;earcut&#39;;
import tilebelt from &#39;@mapbox/tilebelt&#39;;
import { VectorTile } from &#39;@mapbox/vector-tile&#39;;
import MercatorCoordinate from &#39;./mercator-coordinate&#39;;
import Stats from &#39;stats.js&#39;;
import { createShader, createProgram } from &#39;./webgl-utils&#39;;
import config from &#39;../config&#39;;

//////////////////////
// constants
//////////////////////
const TILE_SIZE = 512;
const MAX_TILE_ZOOM = 14;
const MIN_ZOOM = 0;
const MAX_ZOOM = 16;

//////////////////////
// shaders
//////////////////////

// vertex shader just passes through the position,
// no modification to the vertices
const vertexShaderSource = `
  attribute vec2 a_position;

  uniform mat3 u_matrix; // 3 X 3 matrix

  void main() {
    vec2 position = (u_matrix * vec3(a_position, 1)).xy;
    gl_Position = vec4(position, 0, 1);
  }
`;

// set color via uniform
const fragmentShaderSource =`
  precision mediump float;

  uniform vec4 u_color;

  void main() {
    gl_FragColor = u_color;
  }
`;

//////////////////////
// map state
//////////////////////
let loopRunning = true;

const camera = {
  x: 0,
  y: 0,
  zoom: 0,
};

// initial transformation (Brooklyn)
camera.x = -0.41101919888888894;
camera.y = 0.2478952993354263;
camera.zoom = 13;

// DOM elements
let canvas;
let overlay;
let statsWidget;

const LAYERS = {
  water: [180, 240, 250, 255],
  landcover: [202, 246, 193, 255],
  park: [202, 255, 193, 255],
  building: [185, 175, 139, 191],
};

const TILE_BUFFER = 1; // 1 tile in each direction

let tilesInView = [];
let tileData = {}; // tile -&gt; layers
let cacheStats = { tilesLoaded: 0, cacheHits: 0 };
function updateTiles() {
  const bbox = getBounds();
  const z = Math.min(Math.trunc(camera.zoom), MAX_TILE_ZOOM);
  const minTile = tilebelt.pointToTile(bbox[0], bbox[3], z);
  const maxTile = tilebelt.pointToTile(bbox[2], bbox[1], z);

  // tiles visible in viewport
  tilesInView = [];
  const [minX, maxX] = [Math.max(minTile[0], 0), maxTile[0]];
  const [minY, maxY] = [Math.max(minTile[1], 0), maxTile[1]];
  for (let x = minX; x &lt;= maxX; x++) {
    for (let y = minY; y &lt;= maxY; y++) {
      tilesInView.push([x, y, z]);
    }
  }

  // load additional tiles outside of viewport
  const bufferedTiles = [];
  for (let bufX = minX - TILE_BUFFER; bufX &lt;= maxX + TILE_BUFFER; bufX++) {
    for (let bufY = minY - TILE_BUFFER; bufY &lt;= maxY + TILE_BUFFER; bufY++) {
      bufferedTiles.push([bufX, bufY, z]); // buffer in xy direction

      // load parent tiles 2 levels up
      bufferedTiles.push(tilebelt.getParent([bufX, bufY, z]));
      bufferedTiles.push(tilebelt.getParent(tilebelt.getParent([bufX, bufY, z])));
    }
  }

  // remove dupes (and convert to strings)
  let tilesToLoad = [
    ...new Set([
      ...tilesInView.map(t =&gt; t.join(&#39;/&#39;)),
      ...bufferedTiles.map(t =&gt; t.join(&#39;/&#39;))
    ])
  ];

  // make sure tiles are in range
  tilesToLoad = tilesToLoad.filter((tile) =&gt; {
    const [x, y, z] = tile.split(&#39;/&#39;).map(Number);
    const N = Math.pow(2, z);
    const validX = x &gt;= 0 &amp;&amp; x &lt; N;
    const validY = y &gt;= 0 &amp;&amp; y &lt; N;
    const validZ = z &gt;= 0 &amp;&amp; z &lt;= MAX_TILE_ZOOM;
    return validX &amp;&amp; validY &amp;&amp; validZ;
  });

  // process each tile concurrently, and update data on complete
  tilesToLoad.forEach(async (tile) =&gt; {
    if (tileData[tile]) {
      cacheStats.cacheHits++;
      return; // already loaded, no need to fetch
    } else {
      tileData[tile] = []; // temp hold for request
    }

    try {
      const [x, y, z] = tile.split(&#39;/&#39;).map(Number);

      const res = await axios.get(`https://maps.ckochis.com/data/v3/${z}/${x}/${y}.pbf?apiKey=${config(&#39;mapsApiKey&#39;)}`, {
        responseType: &#39;arraybuffer&#39;,
      });
      cacheStats.tilesLoaded++;

      const pbf = new Protobuf(res.data);
      const vectorTile = new VectorTile(pbf);

      // process only the layers we are using
      const layers = [] // layers -&gt; features
      Object.keys(LAYERS).forEach((layer) =&gt; {
        if (vectorTile?.layers?.[layer]) {
          const numFeatures = vectorTile.layers[layer]?._features?.length || 0;

          const vertices = [];
          for (let i = 0; i &lt; numFeatures; i++) {
            const geojson = vectorTile.layers[layer].feature(i).toGeoJSON(x, y, z);
            vertices.push(...geometryToVertices(geojson.geometry));
          }
          layers.push({ layer, vertices: Float32Array.from(vertices) });
        }
      });
      // store layers for tile
      tileData[tile] = layers;

    } catch (e) {
      console.warn(`Tile ${tile} request failed.`, e);
      tileData[tile] = undefined; // release hold
    }
  });
}

function getPlaceholderTile(tile) {
  // use parent if available
  const parent = tilebelt.getParent(tile)?.join(&#39;/&#39;);
  const parentFeatureSet = tileData[parent];
  if (parentFeatureSet?.length &gt; 0) {
    return parentFeatureSet;
  }

  // use whatever children are available
  const childFeatureSets = [];
  const children = (tilebelt.getChildren(tile) || []).map(t =&gt; t.join(&#39;/&#39;));
  children.forEach((child) =&gt; {
    const featureSet = tileData[child];
    if (featureSet?.length &gt; 0) {
      childFeatureSets.push(...featureSet);
    }
  });
  return childFeatureSets;
}

let matrix;
function updateMatrix() {
  const cameraMat = mat3.create();

  // translate
  mat3.translate(cameraMat, cameraMat, [camera.x, camera.y]);

  // scale
  const zoomScale = 1 / Math.pow(2, camera.zoom);
  const widthScale = TILE_SIZE / canvas.width;
  const heightScale = TILE_SIZE / canvas.height;
  mat3.scale(cameraMat, cameraMat, [zoomScale / widthScale, zoomScale / heightScale]);

  // update matrix
  matrix = mat3.multiply(
    [],
    mat3.create(), // identity matrix
    mat3.invert([], cameraMat) // invert camera position
  );
}

//////////////////////
// helpers
//////////////////////
function getClipSpacePosition(e) {
  // handle mouse and touch events
  const [x, y] = [
    e.center?.x || e.clientX,
    e.center?.y || e.clientY
  ];

  // get canvas relative css position
  const rect = canvas.getBoundingClientRect();
  const cssX = x - rect.left;
  const cssY = y - rect.top;

  // get normalized 0 to 1 position across and down canvas
  const normalizedX = cssX / canvas.clientWidth;
  const normalizedY = cssY / canvas.clientHeight;

  // convert to clip space
  const clipX = normalizedX *  2 - 1;
  const clipY = normalizedY * -2 + 1;

  return [clipX, clipY];
}

// convert a GeoJSON geometry to webgl vertices
function geometryToVertices(geometry) {
  const verticesFromPolygon = (coordinates, n) =&gt; {
    const data = earcut.flatten(coordinates);
    const triangles = earcut(data.vertices, data.holes, 2);

    const vertices = new Float32Array(triangles.length * 2);
    for (let i = 0; i &lt; triangles.length; i++) {
      const point = triangles[i];
      const lng = data.vertices[point * 2];
      const lat = data.vertices[point * 2 + 1];
      const [x, y] = MercatorCoordinate.fromLngLat([lng, lat]);
      vertices[i * 2] = x;
      vertices[i * 2 + 1] = y;
    }
    return vertices;
  }

  if (geometry.type === &#39;Polygon&#39;) {
    return verticesFromPolygon(geometry.coordinates);
  }

  if (geometry.type === &#39;MultiPolygon&#39;) {
    const positions = [];
    geometry.coordinates.forEach((polygon, i) =&gt; {
      positions.push(...verticesFromPolygon([polygon[0]], i));
    });
    return Float32Array.from(positions);
  }

  // only support Polygon &amp; Multipolygon for now
  return new Float32Array();
}

// get bbox coordinates for viewport
function getBounds() {
  const zoomScale = Math.pow(2, camera.zoom);

  // undo clip-space
  const px = (1 + camera.x) / 2;
  const py = (1 - camera.y) / 2;

  // get world coord in px
  const wx = px * TILE_SIZE;
  const wy = py * TILE_SIZE;

  // get zoom px
  const zx = wx * zoomScale;
  const zy = wy * zoomScale;

  // get bottom-left and top-right pixels
  let x1 = zx - (canvas.width / 2);
  let y1 = zy + (canvas.height / 2);
  let x2 = zx + (canvas.width / 2);
  let y2 = zy - (canvas.height / 2);

  // convert to world coords
  x1 = x1 / zoomScale / TILE_SIZE;
  y1 = y1 / zoomScale / TILE_SIZE;
  x2 = x2 / zoomScale / TILE_SIZE;
  y2 = y2 / zoomScale / TILE_SIZE;

  // get LngLat bounding box
  const bbox = [
    Math.max(MercatorCoordinate.lngFromMercatorX(x1), -180),
    Math.max(MercatorCoordinate.latFromMercatorY(y1), -85.05),
    Math.min(MercatorCoordinate.lngFromMercatorX(x2), 180),
    Math.min(MercatorCoordinate.latFromMercatorY(y2), 85.05),
  ];

  return bbox;
}

function atLimits() {
  const bbox = getBounds();
  return bbox[0] === -180 || bbox[1] === -85.05 || bbox[2] === 180 || bbox[3] === 85.05;
}

//////////////////////
// main program
//////////////////////
let handlePan;
let handleZoom;

let timestamp;
let slowCount;
let frameStats;

const run = (canvasId, mobile, abort) =&gt; {
  // setup loop state
  loopRunning = true;
  timestamp = 0;
  slowCount = 0;

  // create stats object for widget
  const stats = new Stats();

  // get GL context from canvas
  canvas = document.getElementById(canvasId);
  const gl = canvas.getContext(&#34;webgl&#34;);

  // get overlay
  overlay = document.getElementById(`${canvasId}-overlay`);

  // setup initial state
  updateMatrix();
  updateTiles();

  // setup viewport
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // compile shaders
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  // init gl program
  const program = createProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  gl.clearColor(0, 0, 0, 0);

  // create buffer
  const positionBuffer = gl.createBuffer();

  const draw = () =&gt; {
    frameStats = { drawCalls: 0, vertices: 0 };
    stats.begin();

    // set matrix as uniform
    const matrixLocation = gl.getUniformLocation(program, &#34;u_matrix&#34;);
    gl.uniformMatrix3fv(matrixLocation, false, matrix);

    // render tiles
    tilesInView.forEach((tile) =&gt; {
      let data = tileData[tile.join(&#39;/&#39;)];

      if (data?.length === 0) {
        data = getPlaceholderTile(tile);
      }

      (data || []).forEach((tileLayer) =&gt; {
        const { layer, vertices } = tileLayer;

        if (LAYERS[layer]) {
          const color = LAYERS[layer].map(n =&gt; n / 255);

          // set color uniform for layer
          const colorLocation = gl.getUniformLocation(program, &#34;u_color&#34;);
          gl.uniform4fv(colorLocation, color);

          // create buffer for vertices
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

          // setup position attribute
          const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
          gl.enableVertexAttribArray(positionAttributeLocation);

          // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
          const size = 2;
          const type = gl.FLOAT;
          const normalize = false;
          const stride = 0;
          let offset = 0; 
          gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

          // draw
          const primitiveType = gl.TRIANGLES;
          offset = 0;
          const count = vertices.length / 2;
          gl.drawArrays(primitiveType, offset, count);

          frameStats.drawCalls++;
          frameStats.vertices+= vertices.length;
        }
      });
    });

    overlay.replaceChildren(); // clear labels to redraw

    // render boundaries and label for tiles in view
    tilesInView.forEach((tile) =&gt; {
      const colorLocation = gl.getUniformLocation(program, &#34;u_color&#34;);
      gl.uniform4fv(colorLocation, [1, 0, 0, 1]);

      const tileVertices = geometryToVertices(tilebelt.tileToGeoJSON(tile));
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, tileVertices, gl.STATIC_DRAW);

      // setup position attribute
      const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
      gl.enableVertexAttribArray(positionAttributeLocation);

      // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
      const size = 2;
      const type = gl.FLOAT;
      const normalize = false;
      const stride = 0;
      let offset = 0; 
      gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

      // draw
      const primitiveType = gl.LINES;
      offset = 0;
      const count = tileVertices.length / 2;
      gl.drawArrays(primitiveType, offset, count);

      // draw tile labels
      const tileCoordinates = tilebelt.tileToGeoJSON(tile).coordinates;
      const topLeft = tileCoordinates[0][0];
      const [x, y] = MercatorCoordinate.fromLngLat(topLeft);

      const [clipX, clipY] = vec3.transformMat3(
        [],
        [x, y, 1],
        matrix,
      );

      const wx = ((1 + clipX) / 2) * canvas.width;
      const wy = ((1 - clipY) / 2) * canvas.height;
      const div = document.createElement(&#34;div&#34;);
      div.className = &#34;tile-label&#34;;
      div.style.left = (wx + 8) + &#34;px&#34;;
      div.style.top  = (wy + 8) + &#34;px&#34;;
      div.style.position = &#39;absolute&#39;;
      div.style.zIndex = 1000;
      div.appendChild(document.createTextNode(tile.join(&#39;/&#39;)));
      overlay.appendChild(div);
    });

    // kill loop if gets too slow
    // 10 frames under 10 FPS
    const now = performance.now();
    const fps = 1 / ((now - timestamp) / 1000);
    if (fps &lt; 10) {
      slowCount++;

      if (slowCount &gt; 10) {
        console.warn(`Too slow. Killing loop for ${canvasId}.`);
        stop();
        if (abort) {
          abort();
        }
      }
    }
    timestamp = now;

    // end of loop
    stats.end();
    if (loopRunning) {
      window.requestAnimationFrame(draw);
    }
  }
  window.requestAnimationFrame(draw); // start loop


  ////////////////////////
  // interaction handlers
  ////////////////////////

  // handle touch events
  const Hammer = require(&#39;hammerjs&#39;);
  const hammer = new Hammer(canvas);
  hammer.get(&#39;pan&#39;).set({ direction: Hammer.DIRECTION_ALL });
  hammer.get(&#39;pinch&#39;).set({ enable: true });

  // handle pan events
  let startX;
  let startY;

  // handle drag changes while mouse is still down
  const handleMove = (moveEvent) =&gt; {
    const [x, y] = getClipSpacePosition(moveEvent);

    // compute the previous position in world space
    const [preX, preY] = vec3.transformMat3(
      [],
      [startX, startY, 0],
      mat3.invert([], matrix)
    );

    // compute the new position in world space
    const [postX, postY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // move that amount, because how much the position changes depends on the zoom level
    const deltaX = preX - postX;
    const deltaY = preY - postY;
    if (isNaN(deltaX) || isNaN(deltaY)) {
      return; // abort
    }

    // only update within world limits
    camera.x += deltaX;
    camera.y += deltaY;

    // update matrix with new camera
    updateMatrix();

    // prevent further pan if at limits
    if (atLimits()) {
      camera.x -= deltaX;
      camera.y -= deltaY;
      updateMatrix();
      return; // abort
    }

    // save current pos for next movement
    startX = x;
    startY = y;

    updateMatrix();
    updateTiles();
  }

  handlePan = (startEvent) =&gt; {
    // get position of initial drag
    [startX, startY] = getClipSpacePosition(startEvent);
    canvas.style.cursor = &#39;grabbing&#39;;

    window.addEventListener(&#39;mousemove&#39;, handleMove);
    hammer.on(&#39;pan&#39;, handleMove);

    // clear on release
    const clear = (event) =&gt; {
      canvas.style.cursor = &#39;grab&#39;;
      window.removeEventListener(&#39;mousemove&#39;, handleMove);
      window.removeEventListener(&#39;mouseup&#39;, clear);
      hammer.off(&#39;pan&#39;, handleMove);
      hammer.off(&#39;panend&#39;, clear);
    };
    window.addEventListener(&#39;mouseup&#39;, clear);
    hammer.on(&#39;panend&#39;, clear);
  }
  canvas.addEventListener(&#39;mousedown&#39;, handlePan);
  hammer.on(&#39;panstart&#39;, handlePan);

  // handle zoom events
  handleZoom = (wheelEvent) =&gt; {
    wheelEvent.preventDefault();
    const [x, y] = getClipSpacePosition(wheelEvent);

    // get position before zooming
    const [preZoomX, preZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // update current zoom state
    const prevZoom = camera.zoom;
    const zoomDelta = -wheelEvent.deltaY * (1 / 500);
    camera.zoom += zoomDelta;
    camera.zoom = Math.max(MIN_ZOOM, Math.min(camera.zoom, MAX_ZOOM));
    updateMatrix();

    // prevent further zoom if at limits
    if (atLimits()) {
      camera.zoom = prevZoom
      updateMatrix();
      return;
    }

    // get new position after zooming
    const [postZoomX, postZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // camera needs to be translated the difference of before and after
    camera.x += preZoomX - postZoomX;
    camera.y += preZoomY - postZoomY;
    updateMatrix();
    updateTiles();
  }
  canvas.addEventListener(&#39;wheel&#39;, handleZoom);
  hammer.on(&#39;pinch&#39;, handleZoom);

  // setup stats widget
  stats.showPanel(0); // frame rate
  statsWidget = stats.dom;
  statsWidget.style.position = &#39;absolute&#39;;
  statsWidget.style.left = mobile ? 0 : &#39;-100px&#39;;
  statsWidget.style.zIndex = &#39;0&#39;;
  canvas.parentElement.appendChild(statsWidget);
};

export const stop = () =&gt; {
  loopRunning = false;

  // clear event handlers
  if (canvas) {
    canvas.removeEventListener(&#39;wheel&#39;, handleZoom);
    canvas.removeEventListener(&#39;mousedown&#39;, handlePan);
    overlay.replaceChildren();
    statsWidget.remove();
  }
};

// get the latest frame stats
export const getCacheStats = () =&gt; {
  return cacheStats;
}

export default run;
</code></span></p></div></div></div></div></div><p>One issue with the current approach, is the CPU overhead of running lots of requests concurrently, and parsing the geometries (which is a CPU blocking operation). For instance, the initial load of the map fires off ~30 requests to load all the buffered tiles.</p><pre>tiles loaded: undefined
cache hits: undefined</pre><p>Since a lot of this is work that can happen in the background, we can offload it to a Web Worker to free up resources on the main thread.</p></div><div><p>The most resource heavy part of our code right now is probably the HTTP request to fetch a tile, followed by converting the geometries to vertices &amp; triangles. Luckily, both these tasks are part of the same operation (fetch then parse), so we can pretty easily move this code to a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank">WebWorker</a>, which leaves the main thread free to handle the render loop, and other map interactions.</p><p>If we abstract a way the fetching / parsing code into a <span>fetchTile</span> helper, our worker is pretty simple:</p><p><span><code>import { fetchTile } from &#39;./map-utils&#39;;

addEventListener(&#39;message&#39;, async (event) =&gt; {
  const { tile, layers, url } = event.data;

  try {
    const tileData = await fetchTile({ tile, layers, url });
    postMessage({ tile, tileData });

  } catch (e) {
    console.warn(&#39;Worker error.&#39;, e);
    postMessage({ tile }); // undefined tileData will unset cache hold
  }
});
</code></span></p><p>And then when looping through our updated tiles, we can hand them off to the worker for processing</p><p><span><code>tileWorker = new Worker(new URL(&#39;./tile-worker.js&#39;, import.meta.url));
tileWorker.onmessage = (event) =&gt; {
  const { tile, tileData } = event.data;
  tiles[tile] = tileData;
};

...

tilesToLoad.forEach(async (tile) =&gt; {
  if (tiles[tile]) {
    return; // already loaded, no need to fetch
  }
  tiles[tile] = []; // temp hold for request

  // load buffered tiles in web worker
  tileWorker.postMessage({ tile, layers: LAYERS, url: TILE_SERVER_URL });
});</code></span></p><div><p>+ See Code</p><div id="collapsible-content-1660876680064" role="region" aria-labelledby="collapsible-trigger-1660876680064"><div><div><ul><li><span>script.js</span></li><li><span>tile-worker.js</span></li><li><span>map-utils.js</span></li></ul><div><p><span><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span><span>58
</span><span>59
</span><span>60
</span><span>61
</span><span>62
</span><span>63
</span><span>64
</span><span>65
</span><span>66
</span><span>67
</span><span>68
</span><span>69
</span><span>70
</span><span>71
</span><span>72
</span><span>73
</span><span>74
</span><span>75
</span><span>76
</span><span>77
</span><span>78
</span><span>79
</span><span>80
</span><span>81
</span><span>82
</span><span>83
</span><span>84
</span><span>85
</span><span>86
</span><span>87
</span><span>88
</span><span>89
</span><span>90
</span><span>91
</span><span>92
</span><span>93
</span><span>94
</span><span>95
</span><span>96
</span><span>97
</span><span>98
</span><span>99
</span><span>100
</span><span>101
</span><span>102
</span><span>103
</span><span>104
</span><span>105
</span><span>106
</span><span>107
</span><span>108
</span><span>109
</span><span>110
</span><span>111
</span><span>112
</span><span>113
</span><span>114
</span><span>115
</span><span>116
</span><span>117
</span><span>118
</span><span>119
</span><span>120
</span><span>121
</span><span>122
</span><span>123
</span><span>124
</span><span>125
</span><span>126
</span><span>127
</span><span>128
</span><span>129
</span><span>130
</span><span>131
</span><span>132
</span><span>133
</span><span>134
</span><span>135
</span><span>136
</span><span>137
</span><span>138
</span><span>139
</span><span>140
</span><span>141
</span><span>142
</span><span>143
</span><span>144
</span><span>145
</span><span>146
</span><span>147
</span><span>148
</span><span>149
</span><span>150
</span><span>151
</span><span>152
</span><span>153
</span><span>154
</span><span>155
</span><span>156
</span><span>157
</span><span>158
</span><span>159
</span><span>160
</span><span>161
</span><span>162
</span><span>163
</span><span>164
</span><span>165
</span><span>166
</span><span>167
</span><span>168
</span><span>169
</span><span>170
</span><span>171
</span><span>172
</span><span>173
</span><span>174
</span><span>175
</span><span>176
</span><span>177
</span><span>178
</span><span>179
</span><span>180
</span><span>181
</span><span>182
</span><span>183
</span><span>184
</span><span>185
</span><span>186
</span><span>187
</span><span>188
</span><span>189
</span><span>190
</span><span>191
</span><span>192
</span><span>193
</span><span>194
</span><span>195
</span><span>196
</span><span>197
</span><span>198
</span><span>199
</span><span>200
</span><span>201
</span><span>202
</span><span>203
</span><span>204
</span><span>205
</span><span>206
</span><span>207
</span><span>208
</span><span>209
</span><span>210
</span><span>211
</span><span>212
</span><span>213
</span><span>214
</span><span>215
</span><span>216
</span><span>217
</span><span>218
</span><span>219
</span><span>220
</span><span>221
</span><span>222
</span><span>223
</span><span>224
</span><span>225
</span><span>226
</span><span>227
</span><span>228
</span><span>229
</span><span>230
</span><span>231
</span><span>232
</span><span>233
</span><span>234
</span><span>235
</span><span>236
</span><span>237
</span><span>238
</span><span>239
</span><span>240
</span><span>241
</span><span>242
</span><span>243
</span><span>244
</span><span>245
</span><span>246
</span><span>247
</span><span>248
</span><span>249
</span><span>250
</span><span>251
</span><span>252
</span><span>253
</span><span>254
</span><span>255
</span><span>256
</span><span>257
</span><span>258
</span><span>259
</span><span>260
</span><span>261
</span><span>262
</span><span>263
</span><span>264
</span><span>265
</span><span>266
</span><span>267
</span><span>268
</span><span>269
</span><span>270
</span><span>271
</span><span>272
</span><span>273
</span><span>274
</span><span>275
</span><span>276
</span><span>277
</span><span>278
</span><span>279
</span><span>280
</span><span>281
</span><span>282
</span><span>283
</span><span>284
</span><span>285
</span><span>286
</span><span>287
</span><span>288
</span><span>289
</span><span>290
</span><span>291
</span><span>292
</span><span>293
</span><span>294
</span><span>295
</span><span>296
</span><span>297
</span><span>298
</span><span>299
</span><span>300
</span><span>301
</span><span>302
</span><span>303
</span><span>304
</span><span>305
</span><span>306
</span><span>307
</span><span>308
</span><span>309
</span><span>310
</span><span>311
</span><span>312
</span><span>313
</span><span>314
</span><span>315
</span><span>316
</span><span>317
</span><span>318
</span><span>319
</span><span>320
</span><span>321
</span><span>322
</span><span>323
</span><span>324
</span><span>325
</span><span>326
</span><span>327
</span><span>328
</span><span>329
</span><span>330
</span><span>331
</span><span>332
</span><span>333
</span><span>334
</span><span>335
</span><span>336
</span><span>337
</span><span>338
</span><span>339
</span><span>340
</span><span>341
</span><span>342
</span><span>343
</span><span>344
</span><span>345
</span><span>346
</span><span>347
</span><span>348
</span><span>349
</span><span>350
</span><span>351
</span><span>352
</span><span>353
</span><span>354
</span><span>355
</span><span>356
</span><span>357
</span><span>358
</span><span>359
</span><span>360
</span><span>361
</span><span>362
</span><span>363
</span><span>364
</span><span>365
</span><span>366
</span><span>367
</span><span>368
</span><span>369
</span><span>370
</span><span>371
</span><span>372
</span><span>373
</span><span>374
</span><span>375
</span><span>376
</span><span>377
</span><span>378
</span><span>379
</span><span>380
</span><span>381
</span><span>382
</span><span>383
</span><span>384
</span><span>385
</span><span>386
</span><span>387
</span><span>388
</span><span>389
</span><span>390
</span><span>391
</span><span>392
</span><span>393
</span><span>394
</span><span>395
</span><span>396
</span><span>397
</span><span>398
</span><span>399
</span><span>400
</span><span>401
</span><span>402
</span><span>403
</span><span>404
</span><span>405
</span><span>406
</span><span>407
</span><span>408
</span><span>409
</span><span>410
</span><span>411
</span><span>412
</span><span>413
</span><span>414
</span><span>415
</span><span>416
</span><span>417
</span><span>418
</span><span>419
</span><span>420
</span><span>421
</span><span>422
</span><span>423
</span><span>424
</span><span>425
</span><span>426
</span><span>427
</span><span>428
</span><span>429
</span><span>430
</span><span>431
</span><span>432
</span><span>433
</span><span>434
</span><span>435
</span><span>436
</span><span>437
</span><span>438
</span><span>439
</span><span>440
</span><span>441
</span><span>442
</span><span>443
</span><span>444
</span><span>445
</span><span>446
</span><span>447
</span><span>448
</span><span>449
</span><span>450
</span><span>451
</span><span>452
</span><span>453
</span><span>454
</span><span>455
</span><span>456
</span><span>457
</span><span>458
</span><span>459
</span><span>460
</span><span>461
</span><span>462
</span><span>463
</span><span>464
</span><span>465
</span><span>466
</span><span>467
</span><span>468
</span><span>469
</span><span>470
</span><span>471
</span><span>472
</span><span>473
</span><span>474
</span><span>475
</span><span>476
</span><span>477
</span><span>478
</span><span>479
</span><span>480
</span><span>481
</span><span>482
</span><span>483
</span><span>484
</span><span>485
</span><span>486
</span><span>487
</span><span>488
</span><span>489
</span><span>490
</span><span>491
</span><span>492
</span><span>493
</span><span>494
</span><span>495
</span><span>496
</span><span>497
</span><span>498
</span><span>499
</span><span>500
</span><span>501
</span><span>502
</span><span>503
</span><span>504
</span><span>505
</span><span>506
</span><span>507
</span><span>508
</span><span>509
</span><span>510
</span><span>511
</span><span>512
</span><span>513
</span><span>514
</span><span>515
</span><span>516
</span><span>517
</span><span>518
</span><span>519
</span><span>520
</span><span>521
</span><span>522
</span><span>523
</span><span>524
</span><span>525
</span><span>526
</span><span>527
</span><span>528
</span><span>529
</span><span>530
</span><span>531
</span><span>532
</span><span>533
</span><span>534
</span><span>535
</span><span>536
</span><span>537
</span><span>538
</span><span>539
</span><span>540
</span><span>541
</span><span>542
</span><span>543
</span><span>544
</span><span>545
</span><span>546
</span><span>547
</span><span>548
</span><span>549
</span><span>550
</span><span>551
</span><span>552
</span><span>553
</span><span>554
</span><span>555
</span><span>556
</span><span>557
</span><span>558
</span><span>559
</span><span>560
</span><span>561
</span><span>562
</span><span>563
</span><span>564
</span><span>565
</span><span>566
</span><span>567
</span><span>568
</span><span>569
</span><span>570
</span><span>571
</span><span>572
</span><span>573
</span><span>574
</span><span>575
</span><span>576
</span></code><code>import { mat3, vec3 } from &#39;gl-matrix&#39;;
import tilebelt from &#39;@mapbox/tilebelt&#39;;
import MercatorCoordinate from &#39;./mercator-coordinate&#39;;
import Stats from &#39;stats.js&#39;;
import { createShader, createProgram } from &#39;./webgl-utils&#39;;
import { geometryToVertices, fetchTile } from &#39;./map-utils&#39;;
import config from &#39;../config&#39;;

//////////////////////
// constants
//////////////////////
const TILE_SERVER_URL = `https://maps.ckochis.com/data/v3/{z}/{x}/{y}.pbf?apiKey=${config(&#39;mapsApiKey&#39;)}`;
const TILE_SIZE = 512;
const MAX_TILE_ZOOM = 14;
const MIN_ZOOM = 0;
const MAX_ZOOM = 16;

//////////////////////
// shaders
//////////////////////

// vertex shader just passes through the position,
// no modification to the vertices
const vertexShaderSource = `
  attribute vec2 a_position;

  uniform mat3 u_matrix; // 3 X 3 matrix

  void main() {
    vec2 position = (u_matrix * vec3(a_position, 1)).xy;
    gl_Position = vec4(position, 0, 1);
  }
`;

// set color via uniform
const fragmentShaderSource =`
  precision mediump float;

  uniform vec4 u_color;

  void main() {
    gl_FragColor = u_color;
  }
`;

//////////////////////
// map state
//////////////////////
let loopRunning = true;

const camera = {
  x: 0,
  y: 0,
  zoom: 0,
};

// initial transformation (Brooklyn)
camera.x = -0.41101919888888894;
camera.y = 0.2478952993354263;
camera.zoom = 13;

// DOM elements
let canvas;
let overlay;
let statsWidget;

const LAYERS = {
  water: [180, 240, 250, 255],
  landcover: [202, 246, 193, 255],
  park: [202, 255, 193, 255],
  building: [185, 175, 139, 191],
};

const TILE_BUFFER = 1; // 1 tile in each direction

let tiles = {}; // tile -&gt; layers
let tilesInView = [];
let tileWorker;
function updateTiles() {
  const bbox = getBounds();
  const z = Math.min(Math.trunc(camera.zoom), MAX_TILE_ZOOM);
  const minTile = tilebelt.pointToTile(bbox[0], bbox[3], z);
  const maxTile = tilebelt.pointToTile(bbox[2], bbox[1], z);

  // tiles visible in viewport
  tilesInView = [];
  const [minX, maxX] = [Math.max(minTile[0], 0), maxTile[0]];
  const [minY, maxY] = [Math.max(minTile[1], 0), maxTile[1]];
  for (let x = minX; x &lt;= maxX; x++) {
    for (let y = minY; y &lt;= maxY; y++) {
      tilesInView.push([x, y, z]);
    }
  }

  // load additional tiles outside of viewport
  let bufferedTiles = [];
  for (let bufX = minX - TILE_BUFFER; bufX &lt;= maxX + TILE_BUFFER; bufX++) {
    for (let bufY = minY - TILE_BUFFER; bufY &lt;= maxY + TILE_BUFFER; bufY++) {
      bufferedTiles.push([bufX, bufY, z]); // buffer in xy direction

      // load parent tiles 2 levels up
      bufferedTiles.push(tilebelt.getParent([bufX, bufY, z]));
      bufferedTiles.push(tilebelt.getParent(tilebelt.getParent([bufX, bufY, z])));
    }
  }

  // remove dupes from in view
  let tilesToLoad = [
    ...new Set([
      ...tilesInView.map(t =&gt; t.join(&#39;/&#39;)),
      ...bufferedTiles.map(t =&gt; t.join(&#39;/&#39;))
    ])
  ];

  // make sure tiles are in range
  tilesToLoad = tilesToLoad.filter((tile) =&gt; {
    const [x, y, z] = tile.split(&#39;/&#39;).map(Number);
    const N = Math.pow(2, z);
    const validX = x &gt;= 0 &amp;&amp; x &lt; N;
    const validY = y &gt;= 0 &amp;&amp; y &lt; N;
    const validZ = z &gt;= 0 &amp;&amp; z &lt;= MAX_TILE_ZOOM;
    return validX &amp;&amp; validY &amp;&amp; validZ;
  });

  // process each tile concurrently, and update data on complete
  const inView = tilesInView.map(t =&gt; t.join(&#39;/&#39;));
  tilesToLoad.forEach(async (tile) =&gt; {
    if (tiles[tile]) {
      return; // already loaded, no need to fetch
    } 

    tiles[tile] = []; // temp hold for request
    try {
      if (inView.includes(tile)) {
        // prioritize tiles in-view on main thread (I dont know if this actually helps...)
        const tileData = await fetchTile({ tile, layers: LAYERS, url: TILE_SERVER_URL });
        tiles[tile] = tileData;
      } else {
        // load buffered tiles in worker
        tileWorker.postMessage({ tile, layers: LAYERS, url: TILE_SERVER_URL }); // handle with web worker
      }
    } catch (e) {
      console.warn(`Error loading tile ${tile}`. e);
      tiles[tile] = undefined; // release hold
    }
  });
}

let matrix;
function updateMatrix() {
  const cameraMat = mat3.create();

  // translate
  mat3.translate(cameraMat, cameraMat, [camera.x, camera.y]);

  // scale
  const zoomScale = 1 / Math.pow(2, camera.zoom);
  const widthScale = TILE_SIZE / canvas.width;
  const heightScale = TILE_SIZE / canvas.height;
  mat3.scale(cameraMat, cameraMat, [zoomScale / widthScale, zoomScale / heightScale]);

  // update matrix
  matrix = mat3.multiply(
    [],
    mat3.create(), // identity matrix
    mat3.invert([], cameraMat) // invert camera position
  );
}

//////////////////////
// helpers
//////////////////////
function getClipSpacePosition(e) {
  // handle mouse and touch events
  const [x, y] = [
    e.center?.x || e.clientX,
    e.center?.y || e.clientY
  ];

  // get canvas relative css position
  const rect = canvas.getBoundingClientRect();
  const cssX = x - rect.left;
  const cssY = y - rect.top;

  // get normalized 0 to 1 position across and down canvas
  const normalizedX = cssX / canvas.clientWidth;
  const normalizedY = cssY / canvas.clientHeight;

  // convert to clip space
  const clipX = normalizedX *  2 - 1;
  const clipY = normalizedY * -2 + 1;

  return [clipX, clipY];
}

// get bbox coordinates for viewport
function getBounds() {
  const zoomScale = Math.pow(2, camera.zoom);

  // undo clip-space
  const px = (1 + camera.x) / 2;
  const py = (1 - camera.y) / 2;

  // get world coord in px
  const wx = px * TILE_SIZE;
  const wy = py * TILE_SIZE;

  // get zoom px
  const zx = wx * zoomScale;
  const zy = wy * zoomScale;

  // get bottom-left and top-right pixels
  let x1 = zx - (canvas.width / 2);
  let y1 = zy + (canvas.height / 2);
  let x2 = zx + (canvas.width / 2);
  let y2 = zy - (canvas.height / 2);

  // convert to world coords
  x1 = x1 / zoomScale / TILE_SIZE;
  y1 = y1 / zoomScale / TILE_SIZE;
  x2 = x2 / zoomScale / TILE_SIZE;
  y2 = y2 / zoomScale / TILE_SIZE;

  // get LngLat bounding box
  const bbox = [
    Math.max(MercatorCoordinate.lngFromMercatorX(x1), -180),
    Math.max(MercatorCoordinate.latFromMercatorY(y1), -85.05),
    Math.min(MercatorCoordinate.lngFromMercatorX(x2), 180),
    Math.min(MercatorCoordinate.latFromMercatorY(y2), 85.05),
  ];

  return bbox;
}

function atLimits() {
  const bbox = getBounds();
  return bbox[0] === -180 || bbox[1] === -85.05 || bbox[2] === 180 || bbox[3] === 85.05;
}

//////////////////////
// main program
//////////////////////
let handlePan;
let handleZoom;

let timestamp;
let slowCount;
let frameStats;

const run = (canvasId, mobile, abort) =&gt; {
  // setup loop state
  loopRunning = true;
  timestamp = 0;
  slowCount = 0;

  // create stats object for widget
  const stats = new Stats();

  // get GL context from canvas
  canvas = document.getElementById(canvasId);
  const gl = canvas.getContext(&#34;webgl&#34;);

  // get overlay
  overlay = document.getElementById(`${canvasId}-overlay`);

  // setup tile worker
  tileWorker = new Worker(new URL(&#39;./tile-worker.js&#39;, import.meta.url));
  tileWorker.onmessage = (event) =&gt; {
    const { tile, tileData } = event.data;
    tiles[tile] = tileData;
  };
  tileWorker.onerror = (error) =&gt; {
    console.error(&#39;Uncaught worker error.&#39;, error);
  };

  // setup initial state
  updateMatrix();
  updateTiles();

  // setup viewport
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // compile shaders
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  // init gl program
  const program = createProgram(gl, vertexShader, fragmentShader);
  gl.useProgram(program);
  gl.clearColor(0, 0, 0, 0);

  // create buffer
  const positionBuffer = gl.createBuffer();

  const draw = () =&gt; {
    frameStats = { drawCalls: 0, vertices: 0 };
    stats.begin();

    // set matrix as uniform
    const matrixLocation = gl.getUniformLocation(program, &#34;u_matrix&#34;);
    gl.uniformMatrix3fv(matrixLocation, false, matrix);

    // render tiles
    tilesInView.forEach((tile) =&gt; {
      const tileData = tiles[tile.join(&#39;/&#39;)];

      (tileData || []).forEach((tileLayer) =&gt; {
        const { layer, vertices } = tileLayer;

        if (LAYERS[layer]) {
          const color = LAYERS[layer].map(n =&gt; n / 255);

          // set color uniform for layer
          const colorLocation = gl.getUniformLocation(program, &#34;u_color&#34;);
          gl.uniform4fv(colorLocation, color);

          // create buffer for vertices
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

          // setup position attribute
          const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
          gl.enableVertexAttribArray(positionAttributeLocation);

          // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
          const size = 2;
          const type = gl.FLOAT;
          const normalize = false;
          const stride = 0;
          let offset = 0; 
          gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

          // draw
          const primitiveType = gl.TRIANGLES;
          offset = 0;
          const count = vertices.length / 2;
          gl.drawArrays(primitiveType, offset, count);

          frameStats.drawCalls++;
          frameStats.vertices+= vertices.length;
        }
      });
    });

    overlay.replaceChildren(); // clear labels to redraw

    // render boundaries and label for tiles in view
    tilesInView.forEach((tile) =&gt; {
      const colorLocation = gl.getUniformLocation(program, &#34;u_color&#34;);
      gl.uniform4fv(colorLocation, [1, 0, 0, 1]);

      const tileVertices = geometryToVertices(tilebelt.tileToGeoJSON(tile));
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, tileVertices, gl.STATIC_DRAW);

      // setup position attribute
      const positionAttributeLocation = gl.getAttribLocation(program, &#34;a_position&#34;);
      gl.enableVertexAttribArray(positionAttributeLocation);

      // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
      const size = 2;
      const type = gl.FLOAT;
      const normalize = false;
      const stride = 0;
      let offset = 0; 
      gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

      // draw
      const primitiveType = gl.LINES;
      offset = 0;
      const count = tileVertices.length / 2;
      gl.drawArrays(primitiveType, offset, count);

      // draw tile labels
      const tileCoordinates = tilebelt.tileToGeoJSON(tile).coordinates;
      const topLeft = tileCoordinates[0][0];
      const [x, y] = MercatorCoordinate.fromLngLat(topLeft);

      const [clipX, clipY] = vec3.transformMat3(
        [],
        [x, y, 1],
        matrix,
      );

      const wx = ((1 + clipX) / 2) * canvas.width;
      const wy = ((1 - clipY) / 2) * canvas.height;
      const div = document.createElement(&#34;div&#34;);
      div.className = &#34;tile-label&#34;;
      div.style.left = (wx + 8) + &#34;px&#34;;
      div.style.top  = (wy + 8) + &#34;px&#34;;
      div.style.position = &#39;absolute&#39;;
      div.style.zIndex = 1000;
      div.appendChild(document.createTextNode(tile.join(&#39;/&#39;)));
      overlay.appendChild(div);
    });

    // kill loop if gets too slow
    // 10 frames under 10 FPS
    const now = performance.now();
    const fps = 1 / ((now - timestamp) / 1000);
    if (fps &lt; 10) {
      slowCount++;

      if (slowCount &gt; 10) {
        console.warn(`Too slow. Killing loop for ${canvasId}.`);
        stop();
        if (abort) {
          abort();
        }
      }
    }
    timestamp = now;

    // end of loop
    stats.end();
    if (loopRunning) {
      window.requestAnimationFrame(draw);
    }
  }
  window.requestAnimationFrame(draw); // start loop


  ////////////////////////
  // interaction handlers
  ////////////////////////

  // handle touch events
  const Hammer = require(&#39;hammerjs&#39;);
  const hammer = new Hammer(canvas);
  hammer.get(&#39;pan&#39;).set({ direction: Hammer.DIRECTION_ALL });
  hammer.get(&#39;pinch&#39;).set({ enable: true });

  // handle pan events
  let startX;
  let startY;

  // handle drag changes while mouse is still down
  const handleMove = (moveEvent) =&gt; {
    const [x, y] = getClipSpacePosition(moveEvent);

    // compute the previous position in world space
    const [preX, preY] = vec3.transformMat3(
      [],
      [startX, startY, 0],
      mat3.invert([], matrix)
    );

    // compute the new position in world space
    const [postX, postY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // move that amount, because how much the position changes depends on the zoom level
    const deltaX = preX - postX;
    const deltaY = preY - postY;
    if (isNaN(deltaX) || isNaN(deltaY)) {
      return; // abort
    }

    // only update within world limits
    camera.x += deltaX;
    camera.y += deltaY;

    // update matrix with new camera
    updateMatrix();

    // prevent further pan if at limits
    if (atLimits()) {
      camera.x -= deltaX;
      camera.y -= deltaY;
      updateMatrix();
      return; // abort
    }

    // save current pos for next movement
    startX = x;
    startY = y;

    updateMatrix();
    updateTiles();
  }

  handlePan = (startEvent) =&gt; {
    // get position of initial drag
    [startX, startY] = getClipSpacePosition(startEvent);
    canvas.style.cursor = &#39;grabbing&#39;;

    window.addEventListener(&#39;mousemove&#39;, handleMove);
    hammer.on(&#39;pan&#39;, handleMove);

    // clear on release
    const clear = (event) =&gt; {
      canvas.style.cursor = &#39;grab&#39;;
      window.removeEventListener(&#39;mousemove&#39;, handleMove);
      window.removeEventListener(&#39;mouseup&#39;, clear);
      hammer.off(&#39;pan&#39;, handleMove);
      hammer.off(&#39;panend&#39;, clear);
    };
    window.addEventListener(&#39;mouseup&#39;, clear);
    hammer.on(&#39;panend&#39;, clear);
  }
  canvas.addEventListener(&#39;mousedown&#39;, handlePan);
  hammer.on(&#39;panstart&#39;, handlePan);

  // handle zoom events
  handleZoom = (wheelEvent) =&gt; {
    wheelEvent.preventDefault();
    const [x, y] = getClipSpacePosition(wheelEvent);

    // get position before zooming
    const [preZoomX, preZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // update current zoom state
    const prevZoom = camera.zoom;
    const zoomDelta = -wheelEvent.deltaY * (1 / 500);
    camera.zoom += zoomDelta;
    camera.zoom = Math.max(MIN_ZOOM, Math.min(camera.zoom, MAX_ZOOM));
    updateMatrix();

    // prevent further zoom if at limits
    if (atLimits()) {
      camera.zoom = prevZoom
      updateMatrix();
      return;
    }

    // get new position after zooming
    const [postZoomX, postZoomY] = vec3.transformMat3(
      [],
      [x, y, 0],
      mat3.invert([], matrix)
    );

    // camera needs to be translated the difference of before and after
    camera.x += preZoomX - postZoomX;
    camera.y += preZoomY - postZoomY;
    updateMatrix();
    updateTiles();
  }
  canvas.addEventListener(&#39;wheel&#39;, handleZoom);
  hammer.on(&#39;pinch&#39;, handleZoom);

  // setup stats widget
  stats.showPanel(0); // frame rate
  statsWidget = stats.dom;
  statsWidget.style.position = &#39;absolute&#39;;
  statsWidget.style.left = mobile ? 0 : &#39;-100px&#39;;
  statsWidget.style.zIndex = &#39;0&#39;;
  canvas.parentElement.appendChild(statsWidget);
};

export const stop = () =&gt; {
  loopRunning = false;

  // clear event handlers
  if (canvas) {
    canvas.removeEventListener(&#39;wheel&#39;, handleZoom);
    canvas.removeEventListener(&#39;mousedown&#39;, handlePan);
    overlay.replaceChildren();
    statsWidget.remove();
  }
};

// get the latest frame stats
export const getCacheStats = () =&gt; {
  return cacheStats;
}

export default run;

</code></span></p></div></div></div></div></div><p>The results aren‚Äôt that indistinguishable from the previous buffered example, probably due to the bottleneck being the latency on the http request, which is the same regardless. We could probably measure the difference in CPU, but it‚Äôs likely negligible given we‚Äôre only rendering a few layers.</p></div><div><p>Up until this point, I‚Äôve been using a one-off JS script for every map. While this is fine for quick prototyping, it‚Äôs not very reusable, and makes it difficult to configure settings on-the-fly since most values are hard-coded.</p><p>The last piece, is wrapping this all up into a reusable library with a standard map-like interface than we can instantiate with our configuration, and easily update.</p><p><span><code>const map = new WebGLMap({
  id: &#39;myCanvasId&#39;,
  tileServerURL: &#39;https://maps.ckochis.com/data/v3/{z}/{x}/{y}.pbf&#39;,
  width: 800,
  height: 600,
  center: [-73.9834558, 40.6932723],
  minZoom: 4,
  maxZoom: 18,
  zoom: 13,
  debug: true,
  layers: {
    water: [180, 240, 250, 255],
    landcover: [202, 246, 193, 255],
    park: [202, 255, 193, 255],
    building: [185, 175, 139, 191],
  }
});

...

map.setOptions({ zoom: 10, debug: false });</code></span></p><p>You can find the code for it at <a href="https://github.com/kochis/webgl-map" target="_blank">webgl-map</a> on Github as well as the <a href="https://ckochis.com/webgl-map-demo">demo-page</a> built with the library.</p><p>If you‚Äôve followed along, I hope you‚Äôve enjoyed, or at least found it helpful. If you have any questions or comments, feel free to <a href="https://ckochis.com/contact">get in touch</a>.</p></div></div></div></div></div>
  </body>
</html>
