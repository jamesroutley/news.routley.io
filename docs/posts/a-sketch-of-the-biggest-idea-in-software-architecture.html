<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.oilshell.org/blog/2022/03/backlog-arch.html">Original</a>
    <h1>A sketch of the biggest idea in software architecture</h1>
    
    <div id="readability-page-1" class="page">
  <!-- INSERT LATCH HTML -->

<p>
   |
<a href="https://www.oilshell.org/blog/">blog</a> | <a href="https://www.oilshell.org/">oilshell.org</a></p>

<p><span>
    2022-03-12
  </span>
  <span>
  (Last updated 2022-05-25)
  </span>
</p>
<p>This post was called <em>Backlog: Software Architecture</em> until I edited it and saw
a coherent theme emerge.</p>
<p>It elaborates on <a href="https://www.oilshell.org/cross-ref.html?tag=narrow-waist#narrow-waist">narrow waists</a>: an idea in
#<a href="https://www.oilshell.org/blog/tags.html?tag=software-architecture#software-architecture">software-architecture</a> that relates to networking, operating
systems, language design, compilers, and distributed systems.</p>
<p>Another title I considered is <em>An Overview of Software Composition at Runtime</em>.
That is, you can contrast these two styles of building software out of parts:</p>
<ol>
<li>Fine-grained static types, build-time composition, static linking,
<a href="https://www.oilshell.org/cross-ref.html?tag=API#API">APIs</a>, and version numbers</li>
<li>Coarse-grained <strong>&#34;waists&#34;</strong>, runtime composition, <a href="https://www.oilshell.org/cross-ref.html?tag=ABI#ABI">ABIs</a>,
<a href="https://www.oilshell.org/cross-ref.html?tag=IPC#IPC">IPC</a>, and versionless protocols</li>
</ol>
<p>Many programmers are familiar with the first style.  This post is about the
<strong>second style</strong>, which you see at large scales and long time horizons.</p>
<p>This post is <strong>long and dense</strong> with links, so you may want to read it in
multiple sittings.  Let me know what you think <a href="https://old.reddit.com/r/oilshell/comments/tcy7ko/a_sketch_of_the_biggest_idea_in_software/?">in the comments</a>!
I especially welcome references to similar material.</p>
 
<a name="background"></a>
<h2>Background</h2>
<p>I&#39;m happy that there was great discussion on the last post, <a href="https://www.oilshell.org/blog/2022/02/diagrams.html">The Internet Was
Designed With a Narrow Waist</a>:</p>
<ul>
<li><a href="https://news.ycombinator.com/item?id=30483914">Hacker News</a></li>
<li><a href="https://lobste.rs/s/o3rjb0/internet_was_designed_with_narrow_waist">lobste.rs</a></li>
<li>Reddit <a href="https://old.reddit.com/r/linux/comments/t2vztr/the_internet_was_designed_with_a_narrow_waist/">/r/linux</a>  and <a href="https://old.reddit.com/r/ProgrammingLanguages/comments/t2bmf2/the_internet_was_designed_with_a_narrow_waist/">/r/ProgrammingLanguages</a></li>
</ul>
<p>I wrote about abstract ideas, but readers understood and applied them.  And a
reader answered my question about the history of the <a href="https://www.oilshell.org/cross-ref.html?tag=narrow-waist#narrow-waist">narrow waist</a>, which I
repeat in the <em>Call to Action</em> below.</p>
<p>On the other hand, there were a few responses that exhibited exactly the
misconceptions I want to push back on.  In particular, the lack of
consideration for tradeoffs:</p>
<ul>
<li><strong>Local</strong> convenience vs. <strong>global</strong> economy, flexibility, generality, and
extension</li>
<li>The <strong>code</strong> perspective vs. the <strong>system</strong> perspective</li>
<li>Fine-grained <strong>types</strong> vs. coarse-grained <strong>&#34;waists&#34;</strong></li>
</ul>
<p>To be convincing about this, I would dive into examples: show code, analyze
existing designs, and propose new designs.  I collected a great deal of
material on <a href="https://github.com/oilshell/oil/wiki/Perlis-Thompson-Principle">the wiki</a> and in <a href="https://www.oilshell.org/cross-ref.html?tag=Zulip#Zulip">Zulip</a>.</p>
<p>But I probably shouldn&#39;t spend months writing and arguing about
#<a href="https://www.oilshell.org/blog/tags.html?tag=software-architecture#software-architecture">software-architecture</a>.  It&#39;s better to <strong>build</strong> something with
the principles I&#39;m espousing.</p>
<p>So I&#39;m squeezing many topics into this single post.  I state the main points,
with some justification.</p>

<a name="motivating-design-questions"></a>
<h2>Motivating Design Questions</h2>
<p>To be concrete, here are some questions that these ideas will help us with:</p>
<ol>
<li>
<p>Should shells have <strong>two tiers</strong>?</p>
<ul>
<li>Both external processes and internal &#34;functions&#34;?  Both pipelines of bytes
and pipelines of structured data?</li>
<li>I argue that processes and byte streams should still be &#34;primary&#34; because
it makes the shell more interoperable and useful.  They are both
fundamental <a href="https://www.oilshell.org/cross-ref.html?tag=narrow-waist#narrow-waist">narrow waists</a>.  Last January: <a href="https://www.oilshell.org/blog/2021/01/philosophy-design.html#shells-should-shell-out">&#34;Shells Should
Shell
Out&#34;</a>.</li>
</ul>
</li>
<li>
<p>Is <a href="https://www.oilshell.org/cross-ref.html?tag=JSON#JSON">JSON</a> the new narrow waist for shell?</p>
<ul>
<li>It&#39;s <strong>a</strong> narrow waist, but it&#39;s not as universal as text or byte
streams.  For example, HTML and CSV are not the same as JSON, and they
shouldn&#39;t be.</li>
</ul>
</li>
<li>
<p>How can we design a better distributed OS?</p>
<ul>
<li>We need a simple,  extensible OS designed around a few <a href="/cross-ref.html?tag=narrow
waists#narrow
waists">narrow
waists</a>.  This is the claim in <a href="https://www.oilshell.org/blog/2021/07/blog-backlog-2.html">Kubernetes is Our Generation&#39;s
Multics</a>.</li>
<li>For example, <a href="http://www.oilshell.org/blog/2021/07/blog-backlog-2.html#images-and-feelings">this
diagram</a>
indicates several <a href="https://www.oilshell.org/cross-ref.html?tag=m-by-n-explosion#m-by-n-explosion">O(M × N) code explosions</a>.  Narrow waists
would make the system simultaneously smaller and more powerful.</li>
<li>This problem is out of scope for Oil, but these ideas may be useful to
others.</li>
</ul>
</li>
<li>
<p>Is <a href="https://www.oilshell.org/cross-ref.html?tag=docker#docker">Docker</a> designed well?  How could it be improved?</p>
<ul>
<li>I bring up this example because I&#39;ve seen the claim that &#34;the Unix
philosophy is obvious&#34; and has been absorbed into standard practice.</li>
<li>This couldn&#39;t be further from the truth: <a href="https://www.oilshell.org/cross-ref.html?tag=Docker#Docker">Docker</a> is a recent
design, and its style is profoundly anti-Unix.  (Oil&#39;s build now uses
<a href="https://www.oilshell.org/cross-ref.html?tag=podman#podman">podman</a>, which is a nice, compatible improvement.)</li>
<li>But despite its design, Docker solved a real problem, and has <a href="https://lobste.rs/s/ftkfnu/secure_containerized_browser#c_r6xgbh">notable
innovations</a>.</li>
</ul>
</li>
</ol>
<p>So I believe the ideas below are relevant to the biggest forces and
developments in the industry.  I&#39;m glad that Docker is being &#34;refactored away&#34;
into something more Unix-y on two fronts: into <a href="https://www.oilshell.org/cross-ref.html?tag=OCI#OCI">OCI</a> by Red Hat and
others, and out of Kubernetes.  (Related: <a href="https://www.tariqislam.com/posts/kubernetes-docker-dep/">Docker&#39;s Second
Death</a>)</p>
<a name="what-is-a-narrow-waist"></a>
<h2>What Is a Narrow Waist?</h2>
<p>Most readers understood the <a href="https://www.oilshell.org/blog/2022/02/diagrams.html">last post</a>: I borrowed the <a href="https://www.oilshell.org/cross-ref.html?tag=narrow-waist#narrow-waist">narrow
waist</a> term from networking and extended it to software.</p>
<p>But it&#39;s become clear to me that not all narrow waists are alike.  It&#39;s worth
distinguishing these categories, and more:</p>
<ol>
<li>Small, simple mechanisms like the <a href="https://en.wikipedia.org/wiki/Internet_Protocol">Internet
Protocol</a>,
<a href="https://www.oilshell.org/cross-ref.html?tag=utf8#utf8">UTF-8</a>, and <a href="https://www.oilshell.org/cross-ref.html?tag=JSON#JSON">JSON</a>.
<ul>
<li>These waists are &#34;narrow&#34; in a strong sense.  It&#39;s not a coincidence that
Jon Postel, Ken Thompson, and Doug Crockford were their &#34;editors&#34; or
creators.</li>
</ul>
</li>
<li>Language standards like <a href="https://www.oilshell.org/cross-ref.html?tag=posix-shell-spec#posix-shell-spec">POSIX shell</a>, JavaScript,
and C++.
<ul>
<li>These are big and hard to reimplement.  I know this first hand from
working on Oil!</li>
<li>These are narrow waists because they solve the interoperability problem of
{user programs ...} × {language implementations ...}</li>
</ul>
</li>
<li>&#34;Accidental&#34; waists like <a href="https://en.wikipedia.org/wiki/Windows_API">Win32</a> and <a href="https://en.wikipedia.org/wiki/X86">x86</a>.
<ul>
<li>Their evolution isn&#39;t guided by a standards body.  They&#39;re also big and
hard to reimplement.</li>
</ul>
</li>
<li>APIs like <a href="https://llvm.org">LLVM</a>.  As the home page says, LLVM isn&#39;t a
virtual machine.  It&#39;s really a software library that changes with
each release, requiring consumers to change their code.  This makes it
different than the other narrow waists, which are more about runtime
composition.</li>
<li>... ?</li>
</ol>
<p>So it&#39;s worth being more specific, and the posts below will refine definitions
and explore related concepts.</p>
<p>The clearest objection I see to the narrow waist idea is that a narrow waist is
simply a <strong>standard</strong>!  Standards enable interoperability.</p>
<p>But standards have to come from somewhere.  A narrow waist may or may not
become a standard.  Also, LLVM is not a standard, and isn&#39;t intended to be one.</p>
<p>The hourglass metaphor also suggests why the idea is powerful, and what to aim
for.  You want something small that interfaces with many other things.</p>
<a name="precisely-defining-the-unix-philosophy"></a>
<h3>Precisely Defining &#34;The Unix Philosophy&#34;</h3>
<p>I spent a week drafting a post called <em>Diagrams of Three Narrow Waists in
Unix</em>.  The first sentence is:</p>
<blockquote>
<p>Have you heard vague claims about &#34;the Unix Philosophy&#34;, and are you confused
or skeptical about it?</p>
</blockquote>
<p>This is a valuable post, because surprisingly the <a href="https://www.oilshell.org/cross-ref.html?tag=narrow-waist#narrow-waist">narrow waist</a>
idea <strong>says something new</strong> and more specific about Unix!  I justify this with
references, including the classic ones <a href="https://en.wikipedia.org/wiki/Unix_philosophy">on this
Wikipedia page</a>.</p>
<p>I have diagrams of these 3 narrow waists:</p>
<ol>
<li><strong>Processes</strong>
<ul>
<li>{native code, shebang script, shell function, ...} × { start, kill,
pipe, redirect, run with privileges, ... }</li>
</ul>
</li>
<li><strong>File Descriptors</strong>
<ul>
<li>{file, pipe, terminal, socket, ... } × {read, write, ioctl, ... }</li>
</ul>
</li>
<li>Tree-Shaped <strong>Namespaces</strong> of unstructured data (file systems)
<ul>
<li>{disk, SSD, memory with tmpfs, file with loopback, ... } × { ls,
mount, version with git, serve over HTTP, ... }</li>
</ul>
</li>
</ol>
<p>The diagrams show that Unix uses multiple narrow waists to achieve dynamic and
extensible <strong>polymorphism</strong>.</p>
<p>The file descriptor case shows both sides of the tradeoff.  You don&#39;t
statically know what syscalls are valid on a descriptor.  You also don&#39;t know
what errors you&#39;ll get!  I re-learned this lesson with:</p>
<ul>
<li><a href="https://www.oilshell.org/blog/2022/01/notes-themes.html#oil-096-on-december-30th">A bug in Oil
0.9.6</a>:
<code>write()</code> can fail with <code>EISDIR</code> if the descriptor returned by <code>open()</code>
points to a directory.</li>
<li><a href="https://blog.sunfishcode.online/bugs-in-hello-world/">Bugs in Hello World</a>:
<code>write()</code> can fail with <code>ENOSPC</code> if the descriptor points to a disk file.
Python 2 has the bug but Python 3 fixed it.</li>
</ul>
<p>Nevertheless, the polymorphic design of file descriptors makes Unix compose,
and is one reason why shell is powerful!  I give examples in the post.</p>
<p>Go addresses this problem with single function interfaces like <code>Reader</code> and
<code>Writer</code>, and more generally the <code>-er</code> pattern.  Here&#39;s an interesting quote:</p>
<blockquote>
<p>It would be nice if Haskell had [open polymorphism], possibly using Go as a
model.</p>
<p>— <a href="https://youtu.be/Dq0WFigax_c?t=912">Philip Wadler: Featherweight Go</a></p>
</blockquote>
<p>More:</p>
<ul>
<li>I mention the relationship to Plan 9 (fixing the composition bugs in Unix)
and REST (the <a href="https://en.wikipedia.org/wiki/Representational_state_transfer#Architectural_constraints">uniform interface
constraint</a>).</li>
<li>I link to two important academic papers, and related analysis of Unix.</li>
<li>I also noticed that <strong>Lines of Text</strong> is distinct narrow waist from <strong>Text</strong>,
which the <a href="https://www.oilshell.org/blog/2022/02/diagrams.html">last post</a> depicted.
<ul>
<li>In fact Oil&#39;s <a href="https://www.oilshell.org/cross-ref.html?tag=QSN#QSN">QSN</a> format takes advantage of this narrow waist,
while the GNU&#39;s NUL-delimited format doesn&#39;t.  (This the format <code>xargs -0</code>
accepts , mentioned in <a href="https://www.oilshell.org/blog/2021/08/xargs.html">the xargs
post</a>.)</li>
<li>In particular, <code>wc -l</code>, <code>head</code>, <code>tail</code>, and <code>tail -f</code> work &#34;for free&#34; with
<a href="https://www.oilshell.org/cross-ref.html?tag=QSN#QSN">QSN</a>, but you need more code like to support the NUL-delimited
format, like <code>head -z</code> and <code>tail -z</code>.</li>
</ul>
</li>
</ul>
<p>This post isn&#39;t done, but it&#39;s the one I want to publish the most.</p>
<a name="characteristics-of-narrow-waists"></a>
<h3>Characteristics of Narrow Waists</h3>
<p>In software, the most important characteristic of a <a href="https://www.oilshell.org/cross-ref.html?tag=narrow-waist#narrow-waist">narrow
waist</a> is that it reduces an <a href="https://www.oilshell.org/cross-ref.html?tag=m-by-n-explosion#m-by-n-explosion">O(M x N) code explosion</a>,
allowing interoperability and code reuse.</p>
<p>I also realized that there are two distinct senses of the word &#34;narrow&#34;:</p>
<ol>
<li>In terms of architectural <strong>connection</strong> (topology).
<ul>
<li>For example, applications and physical networks are decoupled by the the
Internet&#39;s narrow waist.  They don&#39;t interface directly with each other.</li>
</ul>
</li>
<li>In terms of the <strong>size</strong> of the concept.
<ul>
<li>IP is a small concept, and Unix is a small handful of concepts.</li>
<li>But the web is a large set of concepts (HTTP, HTML, SVG, etc.).  C++ and
shell are also large.</li>
</ul>
</li>
</ol>
<p>So this issue deserves some more thought, and perhaps more terminology.</p>
<p>Here are more ways to characterize narrow waists:</p>
<ol>
<li>They are <strong>compromises</strong>.  They make systems economical and possible, not
necessarily optimal.
<ul>
<li>If you have a small or specialized network, you can design something more
efficient than the Internet.</li>
</ul>
</li>
<li>They arise through a mix of explicit <strong>design</strong> and implicit <strong>evolution</strong>.
<ul>
<li>Both the Internet and the web were designed and subject to evolution.  But
I&#39;d say the web evolved more.</li>
</ul>
</li>
<li>The design can be done <strong>well or poorly</strong>.  The evolution can be guided or
haphazard.
<ul>
<li><a href="https://www.oilshell.org/cross-ref.html?tag=JSON#JSON">JSON</a> was an explicit design, and it&#39;s much better than CSV.</li>
<li>We should try to do better at design, because the resulting network
effects mean we often get &#34;stuck&#34; with bad designs.</li>
</ul>
</li>
</ol>
<p>Regarding evolution:</p>
<ol start="4">
<li>Narrow waists can last for decades, usually evolving in a <strong>versionless</strong>
manner.
<ul>
<li>For example, Unix shell is one of the oldest languages in wide use, and
there&#39;s continuous compatibility between <a href="https://www.oilshell.org/cross-ref.html?tag=thompson-shell#thompson-shell">Thompson
shell</a>, <a href="https://www.oilshell.org/cross-ref.html?tag=bourne-shell#bourne-shell">Bourne Shell</a>, <a href="https://www.oilshell.org/cross-ref.html?tag=ksh#ksh">Korn
shell</a>, <a href="https://www.oilshell.org/cross-ref.html?tag=bash#bash">bash</a>, <a href="https://www.oilshell.org/cross-ref.html?tag=osh-language#osh-language">OSH</a>, and
<a href="https://www.oilshell.org/cross-ref.html?tag=oil-language#oil-language">Oil</a>.</li>
<li>A narrow waist has an amount of <strong>inertia</strong> that&#39;s proportional to the
amount of functionality that hinges on it.</li>
</ul>
</li>
<li>But narrow waists can also <strong>move</strong>!
<ul>
<li>TCP/IP → HTTP</li>
<li>POSIX C APIs → Linux x86 ABI</li>
</ul>
</li>
<li>They&#39;re subject to extreme <strong>economic pressure</strong> and network effects.  For
example:
<ul>
<li>Windows 10 emulates Linux with
<a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux">WSL</a>.
(Windows also had <a href="https://en.wikipedia.org/wiki/Microsoft_POSIX_subsystem">a different kind of Unix
emulation</a>
decades earlier.)</li>
<li>Linux emulates Windows with
<a href="https://en.wikipedia.org/wiki/Wine_(software)">WINE</a>.</li>
</ul>
</li>
<li>The downside of inertia is that narrow waists can <strong>inhibit innovation</strong>.
<ul>
<li>For example, <a href="https://lobste.rs/s/o3rjb0/internet_was_designed_with_narrow_waist#c_xqdhwh">hardware-software co-design is
inhibited</a>
because of decades-old ISAs.</li>
</ul>
</li>
<li>Narrow waists are often <strong>overextended</strong> to new applications.
<ul>
<li>The web was arguably overextended from a network of hyperlinked documents
to an application delivery platform (<a href="https://en.wikipedia.org/wiki/Single-page_application">single-page
apps</a> in
JavaScript)</li>
<li>It was also extended to a desktop UI framework via <a href="https://www.electronjs.org/">Electron</a>.</li>
<li>Linux was arguably overextended to embedded devices, especially those with
real-time requirements.</li>
</ul>
</li>
</ol>
<p>Some recent narrow waists include <a href="https://www.oilshell.org/cross-ref.html?tag=docker#docker">Docker</a> / <a href="https://www.oilshell.org/cross-ref.html?tag=OCI#OCI">OCI</a>, the
<a href="https://en.wikipedia.org/wiki/Language_Server_Protocol">Language Server
Protocol</a>, and
<a href="https://en.wikipedia.org/wiki/WebAssembly">WebAssembly</a>.   I should be more
specific about their varying degrees of success with respect to design and user
adoption.  For example, I think WebAssembly is useful, but <a href="https://news.ycombinator.com/item?id=28581634">less general than
what&#39;s been recently claimed</a>.
It&#39;s a deep compromise which involves winners and losers.</p>
<a name="fallacies"></a>
<h3>Fallacies</h3>
<p>Here are some common objections to the idea.</p>
<p>(1) <em>Textual data is hard to manipulate with programs</em>.</p>
<p>This is <strong>not</strong> an objection to the narrow waist principle!  The main claims of
the principle are about interoperability and economy of implementation.</p>
<p>I want to make a <strong>Simple vs. Easy</strong> argument.  Narrow waists are <em>simple</em> in
Rich Hickey&#39;s terms (not &#34;complected&#34;), but not necessarily <em>easy</em> to use.  For
example, Unix shell can be hard to learn, but its power results in a small,
extensible operating system.</p>
<p>(2) <em>The web is really messy, and thus unreliable</em>.</p>
<p>I make a strong <strong>Messy vs. Stable</strong> distinction.  Messy systems aren&#39;t
necessarily unreliable.  Quite the contrary — the need for stability is
the <strong>cause of</strong> the mess!  Continuous backward compatibility (like the
the many iterations of CSS) makes a mess, but keeps the system working.</p>
<p>This relates to another concept I&#39;ve been having a hard time describing:
<strong>versionless evolution</strong>, which I describe below.</p>
<a name="related-ideas"></a>
<h3>Related Ideas</h3>
<p>We can understand the <a href="https://www.oilshell.org/cross-ref.html?tag=narrow-waist#narrow-waist">narrow waist</a> more precisely by relating
it to these ideas:</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Metcalfe%27s_law">Metcalfe&#39;s Law</a> states that
the value of a network is proportional to N<sup>2</sup>, where N is the
number of nodes.
<ul>
<li>This is related to, but distinct from, the M × N <em>architectural</em>
connections of a narrow waist.  Architectural connections are not network
node connections.</li>
<li>Thinking about the architectural hierarchy of narrow waists may clarify
this.  For example, CSV, JSON, and HTML are narrow waists at &#34;level 1&#34;.
And each of them <strong>is</strong> literally text, which is at &#34;level 0&#34;.  Generic
operations are &#34;inherited&#34;, which makes the system smaller.  (This idea
really needs diagrams.)</li>
</ul>
</li>
<li>The Internet Protocol follows the <a href="https://en.wikipedia.org/wiki/End-to-end_principle">End-to-End
Principle</a> <strong>and</strong> it&#39;s
a <a href="https://www.oilshell.org/cross-ref.html?tag=narrow-waist#narrow-waist">narrow waist</a>.
<ul>
<li>This doesn&#39;t mean the two principles are the same.  I view the narrow
waist as more descriptive and predictive when applied to software.</li>
</ul>
</li>
</ol>
<a name="examples-and-elaboration"></a>
<h2>Examples and Elaboration</h2>
<p>Let&#39;s apply these principles to real world systems.  Again, I claim the <a href="https://www.oilshell.org/cross-ref.html?tag=narrow-waist#narrow-waist">narrow
waist</a> is the <strong>most important</strong> idea in software architecture,
because it describes the biggest and longest-lived systems.</p>
<a name="the-web-evolved-in-a-versionless-manner"></a>
<h3>The Web Evolved In A Versionless Manner</h3>
<p>I&#39;d like to elaborate on the &#34;versionless&#34; property of many narrow waists.  You
can contrast two philosophies of versioning:</p>
<ol>
<li>Version numbers that indicate breaking changes, e.g. <a href="https://semver.org/">Semantic
Versioning</a>.
<ul>
<li>Linux distros and package managers <a href="https://docs.npmjs.com/about-semantic-versioning">like
NPM</a> like often pair
semantic versioning with ad hoc constraint solvers to find a set of
compatible versions for dependencies.  This model can be <strong>brittle</strong>
because you may end up running a set of versions that&#39;s never been tested
together.</li>
</ul>
</li>
<li>Continuous backward compatibility, i.e. <strong>versionless</strong> evolution.
<ul>
<li>There are also version numbers here, but they indicate feature additions
rather than breaking changes.</li>
</ul>
</li>
</ol>
<p>For example, the web doesn&#39;t have incompatible versions, and <a href="https://www.oilshell.org/cross-ref.html?tag=JSON#JSON">JSON</a> was
explicitly designed by Doug Crockford to be versionless.</p>
<p>History proves this rule. In <a href="https://www.oilshell.org/blog/2021/12/backlog-project.html#three-analogies-dont-break-x">Don&#39;t Break
X</a>,
I mentioned that XHTML and ECMAScript 4 both tried to <strong>break the web</strong> with
radical changes, but they failed because of the inertia of narrow waists.</p>
<p>In contrast, HTML5 and ECMAScript 5 evolved the web in a compatible way.  We
should study and disseminate the history of the web avoid repeating mistakes we
get &#34;stuck with&#34;.</p>
<hr/>
<p>Here&#39;s a good way of thinking about versionless evolution:</p>
<blockquote>
<p>Relaxing a requirement should be a compatible change.  Strengthening a
promise should be a compatible change.</p>
<p>— Rich Hickey in <a href="https://www.youtube.com/watch?v=YR5WdGrpoug">Maybe Not</a> (2018, YouTube)</p>
</blockquote>
<p>Examples:</p>
<ul>
<li>HTML5 defined <code>&lt;hr&gt;</code> and <code>&lt;hr /&gt;</code> to mean the same
thing, whereas previous versions of HTML were stricter.  (This is the
<a href="http://xahlee.info/js/html5_non-closing_tag.html">self-closing tag issue</a>.)
So HTML5 <strong>relaxes a requirement</strong> on web page authors, which is a compatible
change.</li>
<li>Adding a new feature <strong>strengthens the promise</strong> that the browser makes to
the web page author.  For example, HTML5 added a <code>&lt;video&gt;</code> tag, which is a
compatible change.</li>
</ul>

<ul>
<li>Related: <a href="https://github.com/oilshell/oil/wiki/Feature-Detection-Is-Better-than-Version-Detection">Feature Detection Is Better Than Version
Detection</a>.
Web pages often use feature detection in JavaScript, sometimes via
<a href="https://developer.mozilla.org/en-US/docs/Glossary/Polyfill">polyfills</a>.</li>
</ul>
<a name="bytes-and-text-are-essential-narrow-waists"></a>
<h3>Bytes and Text Are Essential Narrow Waists</h3>
<p>I have a recurring debate about &#34;text vs. fine-grained types&#34;, mostly with
people who are frustrated with ad hoc, incorrect #<a href="https://www.oilshell.org/blog/tags.html?tag=parsing#parsing">parsing</a> in
shell.</p>
<p>I think that a shell with support for <a href="https://www.oilshell.org/cross-ref.html?tag=JSON#JSON">JSON</a>, <a href="https://www.oilshell.org/cross-ref.html?tag=QSN#QSN">QSN</a>, <a href="https://www.oilshell.org/cross-ref.html?tag=QTT#QTT">QTT</a>
and HTML will address this problem.  It will reduce the amount of parsing in
shell programs, and make it correct.</p>
<p>I also claim that parsing is an O(M + N) problem, while types can create O(M
× N) problems — and often do.</p>
<p>To give more color on that, here&#39;s an important comment which I mentioned in
<a href="https://www.oilshell.org/blog/2021/01/audio-and-graphics.html">January</a>,
<a href="https://www.oilshell.org/blog/2021/06/hotos-shell-panel.html#conclusion">June</a>,
<a href="https://www.oilshell.org/blog/2021/07/blog-backlog-1.html#concepts">July</a>, and
<a href="https://www.oilshell.org/blog/2021/08/history-trivia.html#the-first-paper-about-unix-shell-thompson">August</a>:</p>

<p>I make the M × N argument, and use concrete examples like IntelliJ and
WebAssembly&#39;s text format:</p>
<blockquote>
<p>You have M formats and N operations, and writing M × N tools is
infeasible, even for the entire population of programmers in the world.</p>
</blockquote>
<p>I also note the tradeoff:</p>
<blockquote>
<p>It&#39;s not an absolute; in reality people do try to fill out every cell in the
M × N grid [in certain domains].  They get partway there, and there are
some advantages to that for sure.</p>
</blockquote>
<p>I also quote Rust designer Graydon Hoare on text.  While his &#34;rant&#34; is mostly
about the information density of text, it also touches on the wide range of
operations that text supports.</p>

<blockquote>
<p>[Text] can be compared, diffed, clustered, corrected, summarized and filtered
algorithmically. It permits multiparty editing. It permits branching
conversations, lurking, annotation, quoting, reviewing, summarizing,
structured responses, exegesis, even fan fic. The breadth, scale and depth of
ways people use text is unmatched by anything.</p>
</blockquote>
<p>I note a problematic M × N explosion in code <strong>generated</strong> by protocol
buffers (as opposed to source code).</p>

<p>For example, equality becomes <strong>schema-dependent</strong> rather than generic.  This
is worth it in many systems, but it&#39;s a tradeoff.</p>
<a name="slogan-text-is-the-only-thing-you-can-agree-on"></a>
<h3>Slogan: Text Is The Only Thing You Can Agree On</h3>
<p>Here are two variations of a slogan.  It&#39;s meant to drive home the point of
text as a narrow waist.</p>
<blockquote>
<p>The lowest common denominator between a <a href="https://en.wikipedia.org/wiki/PowerShell">PowerShell</a>, <a href="https://elv.sh/">Elvish</a>, <a href="https://docs.racket-lang.org/rash/">Rash</a>, and <a href="https://www.nushell.sh/">nushell</a> script is a Bourne shell script (and eventually an Oil script).</p>
</blockquote>
<p>This is because each alternative shell chooses a <em>different</em> kind of structured
data as its narrow waist (.NET objects, tree-structured data, Racket data
structures, and tables, respectively).  <strong>Text</strong> is the most structured format
they all agree on, and <strong>shell</strong> is the language of coarse-grained composition
with text.</p>
<p>I predict that this will be a real thing, and isn&#39;t theoretical!  I have no
doubt that there are already bash scripts invoking PowerShell scripts out
there, and more complex agglomerations will arise as alternative shells become
popular.</p>
<p>It doesn&#39;t mean those shells aren&#39;t worth using, or more
potentially more convenient. But it highlights the need for a better
Bourne-style shell.</p>

<p>and</p>

<p>A second phrasing:</p>
<blockquote>
<p>The lowest common denominator between a <a href="https://common-lisp.net/">Common
Lisp</a>, <a href="https://clojure.org/">Clojure</a>, and
<a href="https://racket-lang.org/">Racket</a> program is a Bourne shell script (and
eventually an Oil script).</p>
</blockquote>
<p>Again, these languages are similar, but have incompatible data models.
(It&#39;s not just the compound data structures; Clojure&#39;s notion of numbers and
strings is borrowed from the JVM.)</p>

<p>These two slogans are really another way of phrasing a slogan from the <a href="https://www.oilshell.org/blog/2022/02/diagrams.html">last
post</a>:</p>
<blockquote>
<p>Unix is equally inconvenient for every programmer, and that&#39;s a good thing.</p>
</blockquote>
<a name="csv-json-html-tables-records-documents"></a>
<h3>CSV, JSON, HTML - Tables, Records, Documents</h3>
<p>The full title of this post is:</p>
<blockquote>
<p>CSV, JSON, and HTML are Different Because Tables, Records, and Documents Are
Different</p>
</blockquote>
<p>This is again pushing back on the notion that <a href="https://www.oilshell.org/cross-ref.html?tag=JSON#JSON">JSON</a> is &#34;the&#34; new narrow
waist of shell.  Tables and documents are essential structures in software, and
expressing them in JSON is awkward.</p>
<p>I can give examples of this, e.g.</p>
<pre><code>{&#34;name&#34;: &#34;alice&#34;, &#34;age&#34;: 42}
{&#34;name&#34;: &#34;bob&#34;, &#34;age&#34;: 43}
</code></pre>
<p>and</p>
<pre><code> [&#34;a&#34;, {&#34;href&#34;: &#34;/home&#34;}, [&#34;anchor text&#34;]]
</code></pre>
<p>This framing comes from the paper <a href="https://www.microsoft.com/en-us/research/publication/unifying-tables-objects-and-documents/">Unifying Tables, Objects, and
Documents</a>
(Meijer and Schulte, 2003), but the technical details differ.</p>
<a name="tradeoffs-between-dynamic-and-static-types-faq"></a>
<h3>Tradeoffs Between Dynamic and Static Types (FAQ)</h3>
<p>Text as a narrow waist is at odds with fine-grained, static types.  My goal is
to highlight tradeoffs, and analyze situations where each style is natural and
efficient.</p>
<p>Many programmers seem to think there is no tradeoff — or at least they
<em>say</em> that on the Internet.  I believe that when they create working systems
they often use the dynamic, coarse-grained view!</p>
<p><a href="https://old.reddit.com/r/ProgrammingLanguages/comments/t0lzeq/types_considered_harmful_pdf_2008/hyfhhu2/">This recent comment</a> links to typical responses, which by now form a FAQ:</p>
<ul>
<li><a href="https://old.reddit.com/r/ProgrammingLanguages/comments/nqm6rf/on_the_merits_of_low_hanging_fruit/h0cqvuy/">In distributed systems, types are local
illusions</a>.
They allow reasoning about a <em>single</em> address space.
<ul>
<li>Big systems are written in multiple languages.  The bigger the system, the
more heterogeneous the code.</li>
<li>Big systems can&#39;t be upgraded atomically.  They&#39;re often running a mix of
inconsistent schema versions.</li>
</ul>
</li>
<li><a href="https://lobste.rs/s/zdvg9y/maybe_not_rich_hickey">In distributed systems, field presence is
dynamic</a>. Discussion about
<em>Maybe Not</em> by Rich Hickey.</li>
<li><a href="https://lobste.rs/s/9rrxbh/on_types#c_uigsel">When models and reality collide,
reality wins</a>. Discussion about
<em>On Types</em>.
<ul>
<li>Static types are models; <strong>data</strong> from network/disk is reality.</li>
<li><a href="https://en.wikipedia.org/wiki/Map%E2%80%93territory_relation">The map is not the
territory</a>.</li>
</ul>
</li>
<li>Static types and <a href="https://www.oilshell.org/cross-ref.html?tag=metaprogramming#metaprogramming">metaprogramming</a> are at odds, and metaprogramming is
useful.
<ul>
<li>I wrote about this in 2016: <a href="https://www.oilshell.org/blog/2016/12/05.html">Type Checking vs. Metaprogramming; ML vs.
Lisp</a>.</li>
<li>Now I also frame it as <a href="https://news.ycombinator.com/item?id=26378696">Rust vs.
Zig</a>.  Rust favors type
checking, Zig favors metaprogramming, and we don&#39;t know how to reconcile
this.</li>
<li>A new reference: <a href="https://old.reddit.com/r/ProgrammingLanguages/comments/placo6/don_syme_explains_the_downsides_of_type_classes/">F# Designer Don Syme Explains the Downsides of Type-Level
Programming</a></li>
</ul>
</li>
<li>A recent thought: <strong>Extensibility is Inherently Dynamic</strong>.
<ul>
<li>This came from an interesting post <a href="https://acko.net/blog/on-variance-and-extensibility/">On Variance and
Extensibility</a>, which
was brought up in the <a href="https://news.ycombinator.com/item?id=30484921">discussion of the last
post</a>.</li>
<li><em>How can a piece of code do anything useful with data it does not
understand?</em>  This relates to the static build and &#34;atomic upgrade&#34;
problem.  If you have a static view of all operations on a kind of data
(like images), you should take advantage of it.  But often you don&#39;t.</li>
</ul>
</li>
</ul>
<p>Here&#39;s a related, fantastic video which I want to signal-boost:</p>

<p>I don&#39;t know the F# language, but it apparently has a very Clojure-like view of
data, despite being statically typed.  The &#34;type provider&#34; mechanism addresses
the problem of types that are only available runtime, e.g. in SQL schemas, or
implicitly in JSON and CSV files.</p>
<p>Overall, the fallacy is that we use dynamic typing when we&#39;re &#34;too lazy to
write down the types&#34;.  There are many useful programs that aren&#39;t 100%
statically typed, and I claim this trend is increasing.  (Slogan: <em>Poorly
Factored Software is Eating the World</em>.)</p>
<p>The real issues are <strong>scale</strong> in space and time, heterogeneity, and
extensibility!</p>
<a name="refinements"></a>
<h2>Refinements</h2>
<p>In the discussion of the extensibility post, I said that I&#39;m getting at
<em>theory and guidelines for runtime composition and versionless evolution</em>.
Shell is about software composition at runtime, as opposed composition via
static linking.</p>
<p>So in addition to the <a href="https://www.oilshell.org/cross-ref.html?tag=perlis-thompson#perlis-thompson">Perlis-Thompson Principle</a>,
<a href="https://www.oilshell.org/cross-ref.html?tag=narrow-waist#narrow-waist">narrow waists</a>, and <a href="https://www.oilshell.org/cross-ref.html?tag=m-by-n-explosion#m-by-n-explosion">O(M × N) code explosions</a>,
here are some more concepts that are worth exploring.</p>
<a name="projection-to-waists"></a>
<h3>Projection to Waists</h3>
<p>I need a name for the idea of <strong>code reuse</strong> by changing the representation of
data to a narrow waist.  Examples:</p>
<ol>
<li>The <code>/proc</code> file system projects kernel metadata onto the narrow waist of
the file system.
<ul>
<li>Now you can use existing tools like <code>ls</code> and <code>open()</code> to explore the state
of processes.</li>
</ul>
</li>
<li>Any system that uses
<a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE</a> is also like
this, e.g. Michael Greenberg&#39;s <a href="https://mgree.github.io/ffs/">File File
System</a> projects <a href="https://www.oilshell.org/cross-ref.html?tag=JSON#JSON">JSON</a> onto a virtual
file system.  This allows reuse of tools like <code>cd</code> and <code>ls</code>.</li>
<li>The <a href="https://github.com/tomnomnom/gron">gron</a> tool projects tree-like
<a href="https://www.oilshell.org/cross-ref.html?tag=JSON#JSON">JSON</a> onto the narrow waist of &#34;lines of text&#34;.  This allows reuse
of tools like <a href="https://www.oilshell.org/cross-ref.html?tag=grep#grep">grep</a> and <a href="https://www.oilshell.org/cross-ref.html?tag=awk#awk">awk</a>.</li>
</ol>
<p>Notice that <a href="https://www.oilshell.org/cross-ref.html?tag=JSON#JSON">JSON</a> is a narrow waist, but it&#39;s been projected onto two
others: the file system, and lines of text.  Which one is appropriate (if any)
depends on what set of tools helps you solve a particular problem.</p>
<a name="emulation-of-waists"></a>
<h3>Emulation of Waists</h3>
<p>This is the most straightforward one.  As mentioned above, there&#39;s a big
incentive for Windows to emulate Linux, and vice versa.  The platform gets
thousands and thousands of applications &#34;for free&#34;.</p>

<p>Another example is when Illumos borrowed FreeBSD&#39;s Linux syscall ABI emulation
in order to run user-uploaded <a href="https://www.oilshell.org/cross-ref.html?tag=docker#docker">Docker</a> containers.  This is
<strong>dynamic, runtime</strong> composition with <a href="https://www.oilshell.org/cross-ref.html?tag=ABI#ABI">ABIs</a>, not static composition
by compiling code against kernel <a href="https://www.oilshell.org/cross-ref.html?tag=API#API">APIs</a> expressed as C header files.</p>
<a name="extension-of-waists"></a>
<h3>Extension of Waists</h3>
<p>I think &#34;waist extension&#34; is a good term for the following ideas:</p>
<ul>
<li>The web is a humble and brilliant <strong>extension of Unix</strong>, adding simple
networking and hyperlinks (from <a href="https://news.ycombinator.com/item?id=26865164">this recent
comment</a>; <a href="https://news.ycombinator.com/item?id=6131335">a longer
comment</a> from 2013).
<ul>
<li>This design was not obvious!   There is a long history of hypertext systems
that were <strong>not</strong> built on Unix.  It would be nice to research explain the
history.</li>
<li><a href="https://apenwarr.ca/log/20061201">apenwarr in 2006</a>: <em>The web works
because it mostly just paraphrases Unix&#39;s cleverness</em>.  (&#34;Working&#34; is an
important property that a lot of software lacks.)</li>
<li><a href="https://www.oilshell.org/blog/2020/02/good-parts-sketch.html#web-sites-are-naturally-made-with-shell-scripts">Web Sites Are Naturally Made With Shell
Scripts</a>
(2020)</li>
</ul>
</li>
<li><a href="https://www.oilshell.org/cross-ref.html?tag=git#git">git</a> is a distributed extension of the Unix file system.
<ul>
<li>Again, earlier systems were <strong>not</strong> like this, e.g. CVS and SVN.  As with
the web, the idea is only obvious in hindsight.  It&#39;s obvious when it
becomes &#34;air&#34;, but someone had to invent it.</li>
<li>git has a messy UI, but a clean <a href="https://www.oilshell.org/cross-ref.html?tag=narrow-waist#narrow-waist">narrow waist</a>.  This article
seems like a good explanation, but there may be better ones: <a href="https://blog.jayway.com/2013/03/03/git-is-a-purely-functional-data-structure/">Git is a
purely functional data
structure</a>.</li>
</ul>
</li>
</ul>
<a name="composition-between-waists"></a>
<h3>Composition Between Waists</h3>
<p>Unix has multiple waists: processes, file descriptors, file systems, lines of
text, unstructured text, and bytes.  Each of them allows M × N things to
compose, but they also must compose <strong>amongst themselves</strong>.</p>
<p>&#34;A few things that compose&#34; is tantamount to the <a href="https://www.oilshell.org/cross-ref.html?tag=perlis-thompson#perlis-thompson">Perlis-Thompson
Principle</a>.  When I started this series, I wasn&#39;t sure
if this term and &#34;narrow waist&#34; were necessary — maybe they&#39;re both
tantamount to &#34;simplicity&#34;.</p>
<p>But after working through examples, I see them as distinct but related.  So it
would be nice to write more clearly about how narrow waists relate.  This seems
like a distinct style of long-lived architecture.</p>
<p>Again, let me know if you have references.  I <strong>don&#39;t</strong> want to write about
ideas that other people have already explained, or invent new terms when there
are existing ones.</p>
<a name="addition-of-waists"></a>
<h3>Addition of Waists</h3>
<p>It&#39;s common to create a new, larger narrow waist out of existing smaller ones.</p>
<p>For example, the <a href="https://en.wikipedia.org/wiki/Language_Server_Protocol">Language Server Protocol</a> uses JSON-RPC <a href="https://microsoft.github.io/language-server-protocol/overviews/lsp/overview/">for
notifications and
responses</a>.</p>
<p>In turn, <a href="https://en.wikipedia.org/wiki/JSON-RPC">JSON-RPC</a> is built on top of
<a href="https://www.oilshell.org/cross-ref.html?tag=JSON#JSON">JSON</a> and a transport like TCP/IP or pipes.</p>
<a name="hierarchy-among-waists"></a>
<h3>Hierarchy Among Waists</h3>
<p>There&#39;s a clear hierarchy among data representations in Unix, which affects
which operations are valid:</p>
<ul>
<li>In the <a href="https://www.oilshell.org/blog/2022/02/diagrams.html">last post</a>, I mentioned that <strong>text</strong> (ASCII, UTF-8)
is a special case of <strong>bytes</strong>, and inherits <a href="https://www.oilshell.org/blog/2022/02/diagrams.html#bytes-flat-files">operations on
bytes</a>.</li>
<li>I mentioned above the <strong>Lines of Text</strong> is a special case of <strong>text</strong>.</li>
<li>Likewise, JSON, CSV, and HTML are all <strong>text</strong>.  and inherit <a href="https://www.oilshell.org/blog/2022/02/diagrams.html#text-narrow-waist-of-unix-architecture">operations on
text</a>.</li>
</ul>
<a name="call-to-action"></a>
<h2>Call to Action</h2>
<a name="jon-postel-made-the-internets-waist-narrow"></a>
<h3>Jon Postel Made the Internet&#39;s Waist Narrow</h3>
<p>After a very helpful reader e-mail, I added <a href="https://www.oilshell.org/blog/2022/02/diagrams.html#addendum-february-28th">an appendix to the last
post</a>.  I
want to transcribe the first 10 minutes of <a href="https://www.youtube.com/watch?v=69p78tfm29o">the video of Van
Jacobsen</a>.  He describes the role
of <a href="https://en.wikipedia.org/wiki/Jon_Postel">Jon Postel</a> as Internet
specification editor — specifically, his <strong>relentless, decades-long drive
for minimalism</strong> in the Internet&#39;s design:</p>
<blockquote>
<p>This narrow waist is not something that God gives you.  It&#39;s something that
you make. It&#39;s hard engineering.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>We unfortunately don&#39;t have a lot of Jon Postel&#39;s in the world.  It would be
nice to get one on nearly every project.</p>
</blockquote>
<p>This reminds me of the sentiments by Ken Thompson quoted in <a href="https://www.oilshell.org/blog/2021/08/history-trivia.html">Unix Shell:
History and Trivia</a>.  They
share a taste for minimalism that unlocks enormous functionality.</p>
<p>I also enjoyed reading these memorials:</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc2468">RFC 2468: I Remember IANA</a>
(1998) by Vint Cerf.   <a href="https://news.ycombinator.com/item?id=30509660">Submitted to Hacker
News</a>.</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc2441">RFC 2441: Working with Jon</a>
(1998)</li>
</ul>
<p>The point is that <strong>people</strong> have to behave differently to create valuable,
interoperable systems!</p>
<a name="conclusion"></a>
<h2>Conclusion</h2>
<p>After <a href="https://www.oilshell.org/blog/2021/12/review-arch.html">more than a year</a> of
circling these #<a href="https://www.oilshell.org/blog/tags.html?tag=software-architecture#software-architecture">software-architecture</a> topics, I feel pretty good
about them.  They&#39;ve informed Oil&#39;s design and will continue to.  It helps to
be precise about definitions and support claims with examples.</p>
<p>I hope this outline was also useful to you.  I wish I could have written a
shorter post, but I didn&#39;t have time :-)</p>
<p>And again, <a href="https://old.reddit.com/r/oilshell/comments/tcy7ko/a_sketch_of_the_biggest_idea_in_software/?">please send</a> related references.  They will help with
future articles on these ideas.  (I was surprised that the <a href="https://www.oilshell.org/blog/2022/02/diagrams.html#whats-the-history-of-this-idea">history of the
narrow
waist in
networking</a>
is not well documented or agreed upon.)</p>
<hr/>
<p>Now I want to switch gears to something more &#34;tactical&#34;: translating Oil to
C++!  That has been on hold for a full year, since <a href="https://www.oilshell.org/blog/2021/03/release-0.8.8.html">the last milestone in March
2021</a>.</p>
<p>I also want to expand the project.  Please donate to my new <a href="https://github.com/sponsors/oilshell">Github
Sponsors</a> page if you think we need a new, principled shell.  I&#39;ll
ask for donations again in upcoming blog posts.  All of the money will go to
contributors and &#34;employees&#34;, <strong>not</strong> to me!</p>
<a name="appendices"></a>
<h2>Appendices</h2>
<a name="the-lambda-calculus-is-a-narrow-waist"></a>
<h3>The Lambda Calculus Is a Narrow Waist</h3>
<p>This a &#34;fun&#34; post to help us with the definition.  It&#39;s based on this quote
from chapter 5 of <a href="https://mitpress.mit.edu/books/types-and-programming-languages">Types and Programming Languages</a>:</p>
<blockquote>
<p>[The importance of the <a href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda
calculus</a>] arises from the
fact that it can be viewed simultaneously as a simple programming language
<strong>in which</strong> computations can be described and as  a mathematical object
<strong>about which</strong> rigorous statements can be proved.</p>
</blockquote>
<ul>
<li>In other words, it reduces an M × N explosion of {arbitrary algorithms
...} × {inductive cases in proofs about them}.</li>
<li><strong>Derived forms</strong> with respect to lambda calculus are like <strong>intermediate
representations</strong> in compilers.  Proofs about languages are laborious for a
very similar reason that implementing compilers is laborious!</li>
</ul>
<a name="wiki-zulip"></a>
<h3>Wiki, Zulip</h3>
<p>This post was long, but there are still important things I left out.  As
mentioned in the <em>Motivating Design Questions</em> section, these ideas relate to
the design of foundational cloud software like Docker and Kubernetes.</p>
<p>But I want Oil to be in better shape before I continue writing about these
topics.  For now here are my Wiki pages and Zulip links.  (I really wish I had
a single brainstorming and research app.)</p>
<ul>
<li><a href="https://github.com/oilshell/oil/wiki/Perlis-Thompson-Principle">https://github.com/oilshell/oil/wiki/Perlis-Thompson-Principle</a>
<ul>
<li><a href="https://old.reddit.com/r/ProgrammingLanguages/comments/lliyuo/are_there_any_interesting_programming_languages/gnpx0so/">Everything is an
X</a>
is an important narrow waist argument that deserves more diagrams.  Every
good language is derives its power from <strong>composition</strong>.  The composition
comes from the <a href="https://www.oilshell.org/cross-ref.html?tag=narrow-waist#narrow-waist">narrow waist</a> of its core data structures.
(This is another case where a narrow waist differs from a <strong>standard</strong>.)</li>
</ul>
</li>
<li><a href="https://github.com/oilshell/oil/wiki/M-by-N-Code-Explosions">https://github.com/oilshell/oil/wiki/M-by-N-Code-Explosions</a>
<ul>
<li>An ongoing list of real problems that narrow waists can solve!  The
cornucopia of Linux distros and language package managers annoys me.</li>
</ul>
</li>
<li><a href="https://github.com/oilshell/oil/wiki/Composable-Distributed-OS">https://github.com/oilshell/oil/wiki/Composable-Distributed-OS</a>
<ul>
<li>An elaboration on another <a href="https://lobste.rs/s/ww7fw4/unix_shell_history_trivia#c_mjcz7m">lobste.rs
subthread</a>
of <em>Unix Shell: History and Trivia</em>.</li>
</ul>
</li>
</ul>
<p>I also mentioned the #<a href="https://oilshell.zulipchat.com/#narrow/stream/308821-containers">containers</a> Zulip stream in December.
Here is a (sloppily sketched) overview thread:</p>
<ul>
<li><a href="https://oilshell.zulipchat.com/#narrow/stream/308821-containers/topic/Docker.20Summary/near/264915992">Docker
Summary</a>.
The Value of Docker, and its anti-Unix design.  Other threads substantiate
these claims with experience.</li>
</ul>






</div>
  </body>
</html>
