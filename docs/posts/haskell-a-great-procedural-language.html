<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://entropicthoughts.com/haskell-procedural-programming">Original</a>
    <h1>Haskell: A Great Procedural Language</h1>
    
    <div id="readability-page-1" class="page"><div>
                

<p>
There are many catchphrases about Haskell.
</p>

<ul>
<li>Haskell is useless.</li>
<li>Haskell aims to avoid success at all costs.</li>
<li>Haskell is the best procedural language in the world.</li>
</ul>

<p>
These sound like dismissals or absurdities from the outside, but once you learn
what they really mean, they take on a new light. In this article, I want to
explain the third. (See the appendix if you are curious about the first two.)
</p>

<p>
This article really, really tried to become a monad <abbr>i/o</abbr> tutorial, but I think
I stopped it in time.<span><sup>1</sup> By that I mean I had to rewrite it twice and delete
large chunks of monad <abbr>i/o</abbr> tutorial material.</span> Here, we are going to jump right
in and focus on the interesting stuff.
</p>
<section id="outline-container-side-effects-as-first-class-values">

<div id="text-orgd4b0318">
<p>
Effectful computations in Haskell are first class values. This means we can
store them in variables or data structures for later use. There is a Haskell
function
</p>

<p><label>In[1]:</label></p><div>
<pre><span>randomRIO</span> <span>::</span> (<span>Int</span>, <span>Int</span>) <span>-&gt;</span> <span>IO</span> <span>Int</span>
</pre>
</div>

<p>
which, when given two integers as arguments, picks a random integer between
them. We can put calls to this function into a list, like so:
</p>

<p><label>In[2]:</label></p><div>
<pre><span>some_dice</span> <span>=</span> [ randomRIO(1, 6), randomRIO(1, 6) ]
</pre>
</div>

<p>
This is a list of two calls to <code>randomRIO</code>. What surprises non-Haskellers is
that when this list is created, no random numbers are generated. Coming from
other programming languages, we are used to side effects (such as random
generation) being executed directly when the side effectful function is
called.<span><sup>2</sup> You may think Haskell is different here due to laziness, but that’s
also not true. Even if we put these calls into a strict data structure, no
randomness would happen.</span>
</p>

<p>
We can add more random generation to the list:
</p>

<p><label>In[3]:</label></p><div>
<pre><span>more_dice</span> <span>=</span> some_dice <span>&lt;&gt;</span> [ randomRIO(1, 6) ]
</pre>
</div>

<p>
and still no random numbers will be generated. We can go ahead and manipulate
this list in all sorts of ways, and <i>still</i> no random numbers would be
generated.
</p>

<p>
To be clear, the <code>randomRIO</code> function could well be called<span><sup>3</sup> Whether this
actually happens is a question of lazy evaluation, optimisation, etc.</span>, and when
it is called it returns a value of type <code>IO Int</code>. It’s just that this value <i>is
not an integer</i>. If anything, we can think of it as a set of instructions for
eventually, somehow, getting an integer. It’s not an actual integer. It’s an
object encapsulating a side effect. When this side effect object executes, it
will produce a random integer, but the object itself just describes the
computation, it is not an integer.
</p>

<p>
In other words, in Haskell, it is not enough to call a side effectful function
to execute its side effects. When we call the side effectful function, it
produces an object encapsulating the side effect, and this object can be
executed in the future to produce the result of the side effect.<span><sup>4</sup> Readers
familiar with JavaScript promises will recognise this concept. Indeed,
promises are modeled after side effects in Haskell.</span>
</p>

<p>
The common way we teach beginners to do execute side effect objects is by
calling them from a <code>do</code> block, using the special <code>&lt;-</code> assignment operator to
extract their result. As a first approximation, we can think of the following
code as the way to force side effects to execute.
</p>

<p><label>In[4]:</label></p><div>
<pre><span>dice_print</span> <span>=</span> <span>do</span>
  side <span>&lt;-</span> randomRIO(1, 6)
  printf <span>&#34;It landed on %d\n&#34;</span> side
</pre>
</div>

<p>
We can imagine that the <code>&lt;-</code> arrow executes the side effect object returned by
<code>randomRIO</code> and captures the value it produces. Similarly, the side effect
object returned by <code>printf</code> gets executed, but we don’t capture the result; we
don’t care about the value produced by it, we only care about the side effect
itself.
</p>

<p>
The lie-to-children here is that we pretend the <code>do</code> block is magical and that
when it executes, it also executes side effects of functions called in it. This
mental model will take the beginner a long way, but at some point, one will want
to break free of it. That is when Haskell starts to really shine as a procedural
language.
</p>

<p>
This article features another lie-to-children: it will have type signatures
specialised to <code>IO a</code> and <code>[a]</code>. All the functions I mention are more generic
than I’m letting on.
</p>

<ul>
<li>Anywhere this article says <code>IO a</code> it will work with any type of side effect
(like <code>Maybe a</code>, <code>Rand g a</code>, <code>StateT s m a</code>, etc.)</li>
<li>Anywhere this article says <code>[a]</code> it probably also works with other
collection/container types (like <code>Maybe a</code>, <code>Array i a</code>, <code>HashMap k a</code>, <code>Tree
  a</code>, etc.)</li>
</ul>

<p>
The reason this article uses more direct type signatures is to hopefully be
readable also to someone who does not use Haskell.<span><sup>5</sup> If the reader has never
seen <abbr>ml</abbr> style syntax before, I think the most important thing to know is that
function calls aren’t written like <code>isInfixOf(&#34;llo&#34;, &#34;hello, world\n&#34;)</code> but
rather with spaces, as in <code>isInfixOf &#34;llo&#34; &#34;hello, world\n&#34;</code>.</span>
</p>
</div>
</section>
<section id="outline-container-de-mystifying-do-blocks">

<p>
In order to drive the point home, we’ll start by seeing what it is the <code>do</code>
block actually does, because it’s not magic at all. In fact, every do block can
be converted to just two operators. If you
already know this, skip ahead to the next section.
</p>
<div id="outline-container-then">
<h2 id="then">then</h2>
<div id="text-orgef76d50">
<p>
If we want to combine two side effects into one, we can use the <code>*&gt;</code> operator,
which is pronounced <i>then</i> or <i>sequence right</i>. It takes two side effect objects
and creates a new side effect object that executes both when itself is executed.
The value produced by this new composite object is going to be the value
produced by the second object its constructed from. In that sense, the <code>*&gt;</code>
operator is a lot like the comma operator in C: it chains together statements,
and returns the result of the last.
</p>

<p><label>In[5]:</label></p><div>
<pre>(<span>*&gt;</span>) <span>::</span> <span>IO</span> a <span>-&gt;</span> <span>IO</span> b <span>-&gt;</span> <span>IO</span> b
</pre>
</div>

<p>
For example, here we combine two print statements into a single side effectful
function.
</p>

<p><label>In[6]:</label></p><div>
<pre><span>greeting</span> <span>::</span> <span>IO</span> <span>()</span>
<span>greeting</span> <span>=</span>
  putStr <span>&#34;hello, &#34;</span> <span>*&gt;</span> putStrLn <span>&#34;world&#34;</span>
</pre>
</div>

<p>
This is a single side effect object called <code>greeting</code>, but its execution will
involve the execution of two separate print statements.
</p>

<p>
We teach beginners to write this as
</p>

<p><label>In[7]:</label></p><div>
<pre><span>greeting</span> <span>=</span> <span>do</span>
  putStr <span>&#34;hello, &#34;</span>
  putStrLn <span>&#34;world&#34;</span>
</pre>
</div>

<p>
which is the exact same thing, although arguably easier to read. The interesting
thing is the implication for how we look at <code>do</code> blocks. It turns out they may
not be magical at all; maybe they are just inserting implicit commas, i.e. a
pretty way of taking multiple side effect objects and combining them into a
single, bigger, side effect object.
</p>
</div>
</div>
<div id="outline-container-bind">
<h2 id="bind">bind</h2>
<div id="text-org642d69b">
<p>
The one thing we cannot do with <code>*&gt;</code> is take the result from the left-hand side
effect and use it to influence the right-hand side function call, because the
<code>*&gt;</code> operator discards the first result before executing the second effect –
just like the comma operator in C. The die throwing code we saw previously,
</p>

<p><label>In[8]:</label></p><div>
<pre><span>dice_print</span> <span>=</span> <span>do</span>
  side <span>&lt;-</span> randomRIO(1, 6)
  printf <span>&#34;It landed on %d\n&#34;</span> side
</pre>
</div>

<p>
cannot be implemented with just <code>*&gt;</code>. We need the additional operator <code>&gt;&gt;=</code>
which takes a side effect object and plugs the value it produces into another
side effectful function.<span><sup>6</sup> This operator is widely known as <i>bind</i>.</span>
</p>

<p><label>In[9]:</label></p><div>
<pre>(<span>&gt;&gt;=</span>) <span>::</span> <span>IO</span> a <span>-&gt;</span> (a <span>-&gt;</span> <span>IO</span> b) <span>-&gt;</span> <span>IO</span> b
</pre>
</div>

<p>
Using this operator, we could write the above do block as
</p>

<p><label>In[10]:</label></p><div>
<pre><span>print_side</span> <span>::</span> <span>Int</span> <span>-&gt;</span> <span>IO</span> <span>()</span>
<span>print_side</span> side <span>=</span>
  printf <span>&#34;It landed on %d\n&#34;</span> side

<span>dice_print</span> <span>::</span> <span>IO</span> <span>()</span>
<span>dice_print</span> <span>=</span>
  randomRIO(1, 6) <span>&gt;&gt;=</span> print_side
</pre>
</div>

<p>
and this would take the result of executing the side effect of <code>randomRIO</code> and
plugging it into another side effectful function, namely <code>print_side</code>.
</p>
</div>
</div>
<div id="outline-container-two-operators-are-all-of-do-blocks">
<h2 id="two-operators-are-all-of-do-blocks">Two operators are all of do blocks</h2>
<div id="text-org71d7321">
<p>
This illustrates that <code>do</code> blocks are built from only two operators. If we stick
with <code>do</code> blocks for all side effects, we will never learn why Haskell is the
greatest procedural programming language in the world, because we are limiting
ourselves to just two operators for dealing with side effects.
</p>

<p>
Let’s lift our gaze and see what happens when we look beyond those. There are
more functions for dealing with side effects.
</p>
</div>
</div>
</section>
<section id="outline-container-functions-that-operate-on-side-effects">

<p>
We’ll start with the basics and work our way up.
</p>
<div id="outline-container-pure">
<h2 id="pure">pure</h2>
<div id="text-orgc2ed192">
<p>
If we want to construct a new side effect object that always produces a
specific value, we can use the function <code>pure</code>.
</p>

<p><label>In[11]:</label></p>

<p>
For example, this creates a side effect object that always produces the integer 4.
</p>

<p><label>In[12]:</label></p><div>
<pre><span>loaded_die</span> <span>::</span> <span>IO</span> <span>Int</span>
<span>loaded_die</span> <span>=</span>
  <span>-- </span><span>Chosen by fair dice roll.</span>
  <span>-- </span><span>Guaranteed to be random.</span>
  pure 4
</pre>
</div>

<p>
Creating side effect objects that always produce a known value might not seem
very useful, but it comes up all the time when bridging the worlds of pure code
and side effects.
</p>
</div>
</div>
<div id="outline-container-fmap">
<h2 id="fmap">fmap</h2>
<div id="text-orgd7cf409">
<p>
One of the most used functions when working with side effects in Haskell is
<code>fmap</code>.
</p>

<p><label>In[13]:</label></p><div>
<pre><span>fmap</span> <span>::</span> (a <span>-&gt;</span> b) <span>-&gt;</span> <span>IO</span> a <span>-&gt;</span> <span>IO</span> b
</pre>
</div>

<p>
This takes a pure function, and a side effect object, and returns a new side effect
object that is similar to the one it got, except the value produced will be
transformed by the function first.
Transforming the results of side effects is
so common that <code>fmap</code> has an operator alias: <code>&lt;$&gt;</code>. For example, to get the
length of the path to the user’s home directory, we can do
</p>

<p><label>In[14]:</label></p><div>
<pre><span>path_length</span> <span>::</span> <span>IO</span> <span>Int</span>
<span>path_length</span> <span>=</span> length <span>&lt;$&gt;</span> getEnv <span>&#34;HOME&#34;</span>
<span>-- </span><span>equivalent to</span>
<span>-- </span><span>path_length = fmap length (getEnv &#34;HOME&#34;)</span>
</pre>
</div>

<p>
This creates a new side effect object which will produce the result of applying
the <code>length</code> function to the result of the side effect of <code>getEnv</code>.
</p>
</div>
</div>
<div id="outline-container-lifta2--lifta3---">
<h2 id="lifta2--lifta3---">liftA2, liftA3, …</h2>
<div id="text-org7e05c97">
<p>
Where <code>fmap</code> allows us to transform the value produced by a single side effect,
sometimes we need to create a side effect object that produces something based
on multiple other side effects.
This is where <code>liftA2</code> and friends come in.
</p>

<p><label>In[15]:</label></p><div>
<pre><span>liftA2</span> <span>::</span> (a <span>-&gt;</span> b <span>-&gt;</span> c)      <span>-&gt;</span> <span>IO</span> a <span>-&gt;</span> <span>IO</span> b <span>-&gt;</span> <span>IO</span> c
<span>liftA3</span> <span>::</span> (a <span>-&gt;</span> b <span>-&gt;</span> c <span>-&gt;</span> d) <span>-&gt;</span> <span>IO</span> a <span>-&gt;</span> <span>IO</span> b <span>-&gt;</span> <span>IO</span> c <span>-&gt;</span> <span>IO</span> d
</pre>
</div>

<p>
These can be thought of like fmap, except they don’t transform the result of
just one side effect, but they combine the results of multiple side effects with
one function, and create a new side effect object that produces the return value
of that function.
This is also common enough that it can be written with two
operators: the <code>&lt;$&gt;</code> we already saw for the first argument, and then <code>&lt;*&gt;</code> for
the rest of the arguments. To check if a user’s home directory contains the user
name, we do
</p>

<p><label>In[16]:</label></p><div>
<pre><span>home_username</span> <span>::</span> <span>IO</span> <span>Bool</span>
<span>home_username</span> <span>=</span> isInfixOf <span>&lt;$&gt;</span> getEnv <span>&#34;LOGNAME&#34;</span> <span>&lt;*&gt;</span> getEnv <span>&#34;HOME&#34;</span>
<span>-- </span><span>equivalent to</span>
<span>-- </span><span>home_username = liftA2 isInfixOf (getEnv &#34;LOGNAME&#34;) (getEnv &#34;HOME&#34;)</span>
</pre>
</div>

<p>
This has created a new side effect object that will produce true if <code>$LOGNAME</code>
is a part of <code>$HOME</code>, and false otherwise.
</p>
</div>
</div>
<div id="outline-container-intermission--what-s-the-point-">
<h2 id="intermission--what-s-the-point-">Intermission: what’s the point?</h2>
<div id="text-org88fd136">
<p>
I am raving ecstatic about this. Combining the results of side effects through
<code>liftA2</code> and friends is such a fundamental technique that the favicon of this
website is a stylised version of the <code>&lt;*&gt;</code> operator.
</p>

<p>
But the reader may understandably be a little underwhelmed. It seems like we
have only learned to do in Haskell what we can do in Python and every other
programming language already. All popular programming languages let us use the
results of side effects as arguments to other functions. There are already two
reasons we should care about Haskell, though, even before we see what’s to come.
These are refactorability and discipline.
</p>



<p>
Biggest benefit is probably refactorability. We might have the following code
that throws two dice and sums them up:
</p>

<p><label>In[17]:</label></p><div>
<pre><span>sum_dice</span> <span>::</span> <span>IO</span> <span>Int</span>
<span>sum_dice</span> <span>=</span>
  liftA2 (<span>+</span>) (randomRIO(1,6)) (randomRIO(1,6))
</pre>
</div>

<p>
and we think the repetition is annoying, so we put the actual die-tossing code
into a variable.
</p>

<p><label>In[18]:</label></p><div>
<pre><span>sum_dice</span> <span>::</span> <span>IO</span> <span>Int</span>
<span>sum_dice</span> <span>=</span>
  <span>let</span>
    toss_die <span>=</span> randomRIO(1,6)
  <span>in</span>
    liftA2 (<span>+</span>) toss_die toss_die
</pre>
</div>

<p>
If we did this in Python, we would accidentally store the <i>result</i> of the die
toss in the <code>toss_dice</code> variable! If the die lands on 3, we will compute 3+3,
rather than the intention of summing two different tosses. With the way side
effects are first class values in Haskell, we are always free to blindly (!)
extract code into a variable name, and this will never change how the code
runs.<span><sup>7</sup> This is called <i>equational reasoning</i> and it’s incredibly powerful and one of
the things that make Haskell such a strong enterprise language, and so nice to
work with procedural code in.</span>
</p>

<p>
A second benefit is that by being structured in how we allow side effects to
affect subsequent computation, we have a lower risk of accidentally introducing
side effects where they were not intended. We also have greater control over
what can affect what, reducing the risk of interaction bugs.
</p>

<p>
The reader might, for example, argue that the previous refactoring example works
just fine in Python, by using an anonymous function as a faux side effect object:
</p>

<p><label>In[19]:</label></p><div>
<pre><span>def</span> <span>sum_dice</span>():
    <span>toss_die</span> = <span>lambda</span>: random.randint(1, 7)
    <span>return</span> toss_die() + toss_die()
</pre>
</div>

<p>
but this (a) requires being careful in refactoring, (b) does not prevent
accidentally triggering the side effect where it was not intended, and (c)
requires a language feature (<i>sequence points</i>) to disambiguate in which order
side effects get executed. With Haskell, we just don’t have to care. We can rest
easy in knowing that the compiler and libraries have our backs.
</p>
</div>
</div>
<div id="outline-container-sequencea">
<h2 id="sequencea">sequenceA</h2>
<div id="text-org0d35ca6">
<p>
We are starting to see the benefits of side effects as first class values, so
let’s shift to a higher gear. We have seen that Haskell allows us to store side
effect objects in variables without accidentally executing their effects. The
next step is storing these side effect objects in data structures.
</p>

<p>
We could, for example, create a list of three different ways to get the username
of the currently logged in user.
</p>

<p><label>In[20]:</label></p><div>
<pre><span>getting_usernames</span> <span>::</span> [<span>IO</span> (<span>Maybe</span> <span>String</span>)]
<span>getting_usernames</span> <span>=</span> [lookupEnv <span>&#34;USER&#34;</span>, lookupEnv <span>&#34;LOGNAME&#34;</span>, lookupEnv <span>&#34;SUDO_USER&#34;</span>]
</pre>
</div>

<p>
This list cannot be executed for its side effects directly, because the list
itself is not a side effect – it’s a list of side effects. There are library
functions to deal with this, though. One is
</p>

<p><label>In[21]:</label></p><div>
<pre><span>sequenceA</span> <span>::</span> [<span>IO</span> a] <span>-&gt;</span> <span>IO</span> [a]
</pre>
</div>

<p>
This is what we need in this case: it takes a list of side effect objects and
creates a new side effect object that executes all the side effects of the list,
and then produces a list of all the values produced by those side effects. To
make a side effect that produces a list of candidate usernames, we define
</p>

<p><label>In[22]:</label></p><div>
<pre><span>actual_usernames</span> <span>::</span> <span>IO</span> [<span>Maybe</span> <span>String</span>]
<span>actual_usernames</span> <span>=</span> sequenceA getting_usernames
</pre>
</div>

<p>
If we execute this side effect and print the result (either by connecting it up
with <code>print</code> using the <code>&gt;&gt;=</code> operator, or in a <code>do</code> block), then on my system we
get the result
</p>

<p><label>Out[1]:</label></p><pre>[Just &#34;kqr&#34;, Just &#34;kqr&#34;, Nothing]
</pre>


<p>
Sometimes we have a list of side effects but we don’t care about the value they
produce. This might be the case if we have collected a bunch of log statements
from a pure function. We want to execute their side effects (the actual logging
action) but we don’t care about what the log function itself returns (it is
usually a void or unit-type value.)
</p>

<p><label>In[23]:</label></p><div>
<pre><span>log_statements</span> <span>::</span> [<span>IO</span> <span>()</span>]
<span>log_statements</span> <span>=</span> [
    log <span>Info</span> <span>&#34;Creating user&#34;</span>,
    log <span>Warn</span> <span>&#34;User already found&#34;</span>
    log <span>Info</span> <span>&#34;Updating user&#34;</span>
]
</pre>
</div>

<p>
As a reminder: these function calls to the <code>log</code> function do not cause anything
to be logged. The <code>log</code> function returns a side effect object that, when
executed, makes the logging happen. The <code>log_statements</code> variable contains a
list of such side effect objects – it is not itself a side effect object.
</p>

<p>
To execute these, we can again combine the side effects in the list into one
side effect object with <code>sequenceA</code>. When we do so, we get a side effect object
that produces the value <code>[(), (), ()]</code>. To get the code to type check, we may
have to discard this value. We already know how to do this, because discarding
values is what the <code>*&gt;</code> operator does.
</p>

<p><label>In[24]:</label></p><div>
<pre><span>execute_logged</span> <span>::</span> <span>IO</span> <span>()</span>
<span>execute_logged</span> <span>=</span>
  sequenceA log_statements <span>*&gt;</span> pure <span>()</span>
</pre>
</div>

<p>
When the side effect of <code>execute_logged</code> runs, it will run the side effects of
the log statements and then discard the dummy values produced in the process.
</p>

<p>
Remember that loaded die from before? Now we can check that it indeed always
returns the same number. First we create a list by repeating the same
side effect object an infinite number of times.
</p>

<p><label>In[25]:</label></p><div>
<pre><span>many_loaded_dice</span> <span>::</span> [<span>IO</span> <span>Int</span>]
<span>many_loaded_dice</span> <span>=</span>
  repeat loaded_die
</pre>
</div>

<p>
Then we construct a side effect object that executes the first few of these and
keeps the values they produced.
</p>

<p><label>In[26]:</label></p><div>
<pre><span>some_thrown_dice</span> <span>::</span> <span>IO</span> [<span>Int</span>]
<span>some_thrown_dice</span> <span>=</span>
  sequenceA (take 20 many_loaded_dice)
</pre>
</div>

<p>
If we connect this up with a print (again, <code>do</code> block or the <code>&gt;&gt;=</code>
operator) and execute it, we get
</p>

<p><label>Out[2]:</label></p><pre>[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4]
</pre>


<p>
We could do the same thing with a better die:
</p>

<p><label>In[27]:</label></p><div>
<pre><span>many_good_dice</span> <span>::</span> [<span>IO</span> <span>Int</span>]
<span>many_good_dice</span> <span>=</span>
  repeat (randomRIO (1,6))

<span>some_thrown_dice</span> <span>::</span> <span>IO</span> [<span>Int</span>]
<span>some_thrown_dice</span> <span>=</span>
  sequenceA (take 20 many_good_dice)
</pre>
</div>

<p>
If we print this once, we get
</p>

<p><label>Out[3]:</label></p><pre>[2,1,4,1,3,2,2,2,1,4,6,4,1,4,6,4,5,3,4,6]
</pre>


<p>
If we print it again, we might get
</p>

<p><label>Out[4]:</label></p><pre>[4,5,3,2,4,2,5,4,6,1,1,5,1,3,6,4,4,5,1,4]
</pre>


<p>
Even though we constructed the list by repeating <i>the same</i> side effect object,
we get a fresh set of random numbers every time the composite side effect object
is executed. This is additional proof that what we store in the list is not the
result of the side effect, but the side effect itself.
</p>

<p>
But also note what we did. We used list functions (<code>repeat</code>, <code>take 20</code>) to
manipulate a data structure of side effect objects as if they were regular
values – because they are! Then we used a side effect manipulation function
(<code>sequenceA</code>) to combine the side effects in the list into one new side effect
object that executes all of them. This is a kind of meta programming, except
it’s not using a special macro language but performed at the level of regular
values.
</p>
</div>
</div>
<div id="outline-container-interlude--convenience-functions">
<h2 id="interlude--convenience-functions">Interlude: convenience functions</h2>
<div id="text-org4d4d886">
<p>
The Haskell standard libraries also contain a few convenience functions to do
what we have done above except easier. For example, when we discarded the value
produced by a side effect, we used <code>object *&gt; pure ()</code>. This exists as a
shortcut function called <code>void</code>:
</p>

<p><label>In[28]:</label></p>

<p>
We could wrap the call in this instead:
</p>

<p><label>In[29]:</label></p><div>
<pre><span>execute_logged</span> <span>::</span> <span>IO</span> <span>()</span>
<span>execute_logged</span> <span>=</span>
  void (sequenceA log_statements)
</pre>
</div>

<p>
But there is an even more convenient way to do it. Many of the functions I will
show have a variant that ends with underscore. These variants throw away the
result. So we could instead have written
</p>

<p><label>In[30]:</label></p><div>
<pre><span>execute_logged</span> <span>::</span> <span>IO</span> <span>()</span>
<span>execute_logged</span> <span>=</span>
  sequenceA_ log_statements
</pre>
</div>

<p>
and this would run the effects and throw away the results. One benefit of using
this variant is that it actually works with slightly more collection types than
the one without underscore but the drawback is, of course, that we don’t get the
results produced, only the side effects.<span><sup>8</sup> See the appendix for more details.</span>
</p>

<p>
Separately, we used list manipulation functions <code>repeat</code> and <code>take 20</code> to create
an appropriately-sized list of side effect objects, and then executed it with
<code>sequenceA</code>. This specific combination is common enough to exist as a library
function
</p>

<p><label>In[31]:</label></p><div>
<pre><span>replicateM</span> <span>::</span> <span>Int</span> <span>-&gt;</span> <span>IO</span> a <span>-&gt;</span> <span>IO</span> [a]
</pre>
</div>

<p>
With this, we can draw 20 loaded dice quite succinctly.
</p>

<p><label>In[32]:</label></p><div>
<pre><span>some_thrown_dice</span> <span>::</span> <span>IO</span> [<span>Int</span>]
<span>some_thrown_dice</span> <span>=</span>
  replicateM 20 loaded_die
</pre>
</div>

<p>
This also exist as a result-discarding variant that runs a side effect object
\(n\) times but does not collect the values produced by the side effect.
</p>

<p><label>In[33]:</label></p><div>
<pre><span>replicateM_</span> <span>::</span> <span>Int</span> <span>-&gt;</span> <span>IO</span> a <span>-&gt;</span> <span>IO</span> <span>()</span>
</pre>
</div>

<p>
Back when I was in university I had a coursemate who had just learned
programming and found the following joke very funny:
</p>

<blockquote>
<p>
Teacher: Write “I will not cheat again” 500 times on the blackboard. That should
get you to learn your lesson.
</p>

<p>
Student: <code>for (int counter = 0; counter &lt; 500; counter++) {
System.out.println(&#34;I will not cheat again.&#34;); }</code>
</p>
</blockquote>

<p>
I didn’t find it funny – I found it sad. Is this really the type of low-level
programming we are teaching students? Here’s how it should go.
</p>

<blockquote>
<p>
Teacher: Write “I will not cheat again” 500 times on the blackboard. That should
get you to learn your lesson.
</p>

<p>
Student: <code>replicateM_ 500 (putStrLn &#34;I will not cheat again.&#34;)</code>
</p>
</blockquote>

<p>
As a programmer, I do not want to babysit my computer and instruct it in exactly
how to count to perform a side effect 500 times. I just want to tell it to
perform the side effect 500 times and the standard libraries should know what
the detailed steps are.
</p>

<p>
Anyway, let’s get back to the good stuff. Now we’re going into advanced
techniques.
</p>
</div>
</div>
<div id="outline-container-traverse">
<h2 id="traverse">traverse</h2>
<div id="text-org1ebf799">
<p>
In a previous example, we had code that amounted to
</p>

<p><label>In[34]:</label></p><div>
<pre><span>usernames</span> <span>::</span> <span>IO</span> [<span>Maybe</span> <span>String</span>]
<span>usernames</span> <span>=</span>
  sequenceA [lookupEnv <span>&#34;USER&#34;</span>, lookupEnv <span>&#34;LOGNAME&#34;</span>, lookupEnv <span>&#34;SUDO_USER&#34;</span>]
</pre>
</div>

<p>
This contains some duplication, namely the application of <code>lookupEnv</code> to each of
the strings. We could write this instead as
</p>

<p><label>In[35]:</label></p><div>
<pre><span>usernames</span> <span>::</span> <span>IO</span> [<span>Maybe</span> <span>String</span>]
<span>usernames</span> <span>=</span>
  sequenceA (fmap lookupEnv [<span>&#34;USER&#34;</span>, <span>&#34;LOGNAME&#34;</span>, <span>&#34;SUDO_USER&#34;</span>])
</pre>
</div>

<p>
relying on the fact that <code>fmap</code> works on lists as well<span><sup>9</sup> For a brief
explanation of this, see the appendix.</span>, but there is a more efficient way to
express this, though, and it’s using the function
</p>

<p><label>In[36]:</label></p><div>
<pre><span>traverse</span> <span>::</span> (a <span>-&gt;</span> <span>IO</span> b) <span>-&gt;</span> [a] <span>-&gt;</span> <span>IO</span> [b]
</pre>
</div>

<p>
which constructs a side effect object that produces the result of applying a
side effectful function to each element in a collection. The above side effect
object could then be constructed as
</p>

<p><label>In[37]:</label></p><div>
<pre><span>usernames</span> <span>::</span> <span>IO</span> [<span>Maybe</span> <span>String</span>]
<span>usernames</span> <span>=</span>
  traverse lookupEnv [<span>&#34;USER&#34;</span>, <span>&#34;LOGNAME&#34;</span>, <span>&#34;SUDO_USER&#34;</span>]
</pre>
</div>

<p>
This is a fairly fundamental operation, and we can define e.g. <code>sequenceA</code> in
terms of <code>traverse</code>:
</p>

<p><label>In[38]:</label></p><div>
<pre><span>sequenceA</span> <span>::</span> [<span>IO</span> a] <span>-&gt;</span> <span>IO</span> [a]
<span>sequenceA</span> <span>=</span> traverse identity
</pre>
</div>

<p>
where <code>identity</code> is the identity function that returns its argument unchanged.
</p>

<p>
As with <code>sequenceA</code>, there exists an underscored version of <code>traverse</code> that
throws away the values produced by the side effect, for cases where we are only
interested in the side effect itself.
</p>

<p><label>In[39]:</label></p><div>
<pre><span>traverse_</span> <span>::</span> (a <span>-&gt;</span> <span>IO</span> b) <span>-&gt;</span> [a] <span>-&gt;</span> <span>IO</span> <span>()</span>
</pre>
</div>

<p>
We can use this e.g. to create a side effect object that emits several log
messages when it executes.
</p>

<p><label>In[40]:</label></p><div>
<pre><span>mass_log</span> <span>::</span> <span>IO</span> <span>()</span>
<span>mass_log</span> <span>=</span>
  traverse_ (log <span>Info</span>) [
    <span>&#34;System startup in experimental mode.&#34;</span>
    <span>&#34;This means it will attempt to divine in which order to run startup scripts.&#34;</span>
    <span>&#34;The startup procedure may crash if things are performed in the wrong order.&#34;</span>
    <span>&#34;Please see the manual for more details.&#34;</span>
  ]
</pre>
</div>
</div>
</div>
<div id="outline-container-for">
<h2 id="for">for</h2>
<div id="text-orga458cb5">
<p>
We have learned that when we have a collection of things, and we want to perform
some side effectful work for each of those things, we use <code>traverse</code>. However,
when we call <code>traverse</code> we have to give the function first, and the collection
second. Sometimes it’s convenient to be able to pass the arguments the other way
around, and for this, we have an alias called <code>for</code> that is exactly like
<code>traverse</code> except with its arguments swapped around. In other words, this takes
a collection as its first argument, and the scare-quotes “loop body” last.
</p>

<p><label>In[41]:</label></p><div>
<pre><span>for</span> <span>::</span> [a] <span>-&gt;</span> (a <span>-&gt;</span> <span>IO</span> b) <span>-&gt;</span> <span>IO</span> [b]
</pre>
</div>

<p>
As with <code>traverse</code>, it exists in an underscored version that throws away the
values produced by the side effect.
</p>

<p><label>In[42]:</label></p><div>
<pre><span>for_</span> <span>::</span> [a] <span>-&gt;</span> (a <span>-&gt;</span> <span>IO</span> b) <span>-&gt;</span> <span>IO</span> <span>()</span>
</pre>
</div>

<p>
This swapped-parameters version of <code>traverse</code> is convenient whenever we need
something that resembles a for loop in other languages. The general pattern of
the Haskell <code>for</code> loop is
</p>

<p><label>In[43]:</label></p><div>
<pre><span>for</span> collection <span>$</span> <span>\</span>item <span>-&gt;</span> <span>do</span>
  things
</pre>
</div>

<p>
This, again, highlights how side-effects-as-first-class-values lets us do meta
programming. The <code>for</code> loop is not syntax. There is nothing (other than side
effects) built into the language supporting this construct. It is made entirely
from library functions.
</p>

<p>
My imagination is running dry, so we will use a convoluted example to illustrate
this. We are trying to break weak cryptography, and we have a list of numbers
for which we want to get the largest prime factor of each. This is a pure
function (no side effects) at its core, but we know factorisation is expensive,
and we suspect we will receive the same numbers repeatedly, so we will cache the
results of the computation. Once we involve the cache, the function becomes side
effectful. Here’s a first draft of such a function.
</p>

<p><label>In[44]:</label></p><div>
<pre><span>factorise</span> <span>::</span> [<span>Int</span>] <span>-&gt;</span> <span>IO</span> [(<span>Int</span>, <span>Maybe</span> <span>Int</span>)]
<span>factorise</span> numbers <span>=</span> <span>do</span>
  <span>-- </span><span>Create a mutable variable with an empty dictionary.</span>
  cache <span>&lt;-</span> newIORef M.empty
  <span>-- </span><span>Loop through all numbers we received.</span>
  for numbers <span>$</span> <span>\</span>n <span>-&gt;</span> <span>do</span>
    <span>-- </span><span>Get what&#39;s in the cache for this number.</span>
    cached <span>&lt;-</span> M.lookup n <span>&lt;$&gt;</span> readIORef cache

    factor <span>&lt;-</span> <span>case</span> cached <span>of</span>
      <span>-- </span><span>If the cache contained the factor for n, use it</span>
      <span>-- </span><span>as it is.</span>
      <span>Just</span> f <span>-&gt;</span> pure f
      <span>-- </span><span>If the cache did not contain the factor, compute</span>
      <span>-- </span><span>it fresh and cache it.</span>
      <span>Nothing</span> <span>-&gt;</span> <span>do</span>
        <span>let</span> f <span>=</span> greatest_factor n
        modifyIORef cache (M.insert n f)
        pure f

    <span>-- </span><span>If the greatest factor is the number itself, it is</span>
    <span>-- </span><span>prime. Otherwise, it can be divided by factor.</span>
    <span>if</span> factor <span>==</span> n <span>then</span>
      pure (n, <span>Nothing</span>)
    <span>else</span>
      pure (n, <span>Just</span> factor)
</pre>
</div>

<p>
This seems rather … procedural. Even though we get all the nice guarantees of
working with side effectful functions in Haskell, the code itself reads like any
other procedural language would. With Haskell, we get the best of both worlds.
</p>
</div>
</div>
</section>
<section id="outline-container-leaning-into-the-first-classiness-of-effects">

<div id="text-orge387ca8">
<p>
We can really lean into this and simplify the code further, though.
</p>

<ul>
<li>We create the helper function <code>caching_compute</code> which computes the
greatest factor of a number, inserts it into the cache, and then returns the
computed factor. This allows us to replace the big pattern match with a call
to the <code>maybe</code> function. This works because – you guessed it – side effects
are first class values in Haskell.</li>
<li>We reduce duplication in the last few lines, by recognising that the first
part of the return tuple is always the number we started with, and the second
is either <code>Just factor</code> or <code>Nothing</code> based on a condition.</li>
</ul>

<p><label>In[45]:</label></p><div>
<pre><span>factorise</span> <span>::</span> [<span>Int</span>] <span>-&gt;</span> <span>IO</span> [(<span>Int</span>, <span>Maybe</span> <span>Int</span>)]
<span>factorise</span> numbers <span>=</span>
  <span>let</span>
    caching_compute cache n <span>=</span> <span>do</span>
      <span>let</span> computed_factor <span>=</span> greatest_factor n
      <span>-- </span><span>Cache the computed factor and return it.</span>
      modifyIORef cache (M.insert n computed_factor)
      pure computed_factor
  <span>in</span> <span>do</span>
    cache <span>&lt;-</span> newIORef M.empty
    for numbers <span>$</span> <span>\</span>n <span>-&gt;</span> <span>do</span>
      <span>-- </span><span>Get the cached factor if it exists, otherwise compute it.</span>
      cached <span>&lt;-</span> M.lookup n <span>&lt;$&gt;</span> readIORef cache
      factor <span>&lt;-</span> maybe (caching_compute cache n) pure cached
      <span>-- </span><span>Return n along with a Maybe value containing the factor</span>
      <span>-- </span><span>if the number is composite.</span>
      pure (n, guard (factor <span>/=</span> n) <span>$&gt;</span> factor)
</pre>
</div>

<p>
We’ll note that we don’t actually perform any side effect other than keep a
mutable variable around. There is a special type of side effect object designed
for keeping a mutable variable around, and it’s called <code>State</code>.<span><sup>10</sup> <code>State</code> is
actually just one of many options, depending on what guarantees one wants around
backtracking, multithreading, atomicity, etc. Notably, <code>State</code> is not the
highest-performance alternative, but in our case the factorisation is what takes
time, not state management.</span> We can switch to that type of mutable state instead
of <code>IO</code>, to make it harder to accidentally launch missiles from this function.
</p>

<p>
This will make the <code>cache</code> variable the implicit target of our mutation
(<code>modify</code> and <code>gets</code>), and it will also allow for streaming results. That means
we can plug an infinite list into this function, and it will keep emitting
results one element at a time.<span><sup>11</sup> This depends a little on our choice of data
structure for the cache as well as the type of side effect object we choose for
keeping the mutable variable around. Some combinations will not allow streaming
results, and they tend to have better behaviour and performance characteristics
for finite inputs.</span>
</p>

<p><label>In[46]:</label></p><div>
<pre><span>type</span> <span>FactorCache</span> <span>=</span> <span>M.Map</span> <span>Int</span> <span>Int</span>

<span>factorise</span> <span>::</span> [<span>Int</span>] <span>-&gt;</span> <span>State</span> <span>FactorCache</span> [(<span>Int</span>, <span>Maybe</span> <span>Int</span>)]
<span>factorise</span> numbers <span>=</span>
  for numbers <span>$</span> <span>\</span>n <span>-&gt;</span>
    <span>let</span>
      <span>-- </span><span>Rely on laziness to not compute this value other than</span>
      <span>-- </span><span>where it is used, which is only when the cache is dry.</span>
      computed <span>=</span> greatest_factor n
    <span>in</span> <span>do</span>
      cached <span>&lt;-</span> gets (M.lookup n)
      factor <span>&lt;-</span> maybe (modify (M.insert n computed) <span>$&gt;</span> computed)
        pure cached
      pure (n, guard (factor <span>/=</span> n) <span>$&gt;</span> factor)
</pre>
</div>

<p>
Since we are no longer using <code>IO</code>, we cannot extract the result from this side
effectful function the way we are used to. Instead, can convert its result to a
pure value with the <code>evalState</code> function, seeding the state with an empty
dictionary:
</p>

<p><label>In[47]:</label></p><div>
<pre><span>factored</span> <span>::</span> [(<span>Int</span>, <span>Maybe</span> <span>Int</span>)]
<span>factored</span> <span>=</span> evalState (factorise some_numbers) M.empty
</pre>
</div>

<p>
The result here is a pure, streaming list, meaning we can feed this function an
infinite sequence of numbers and it will keep categorising them – although it
will go faster and faster as its cache fills up.
</p>

<p>
This also illustrates another reason to go for something like <code>State</code> rather
than <code>IO</code>: we can guarantee that any side effects executed as part of a <code>State</code>
object are only visible within that <code>State</code> object, which in turn means we can
convert the side effectful function to a pure function. Haskell is happy to let
us have side effects inside pure functions – as long as we can prove to the
compiler that the side effects will not affect anything outside of those
functions.<span><sup>12</sup> There are many of these specialised side effect types in Haskell
which we can use to get local side effects but which look pure from the
outside.</span>
</p>

<p>
Since <code>numbers</code> is given as an argument to this function and then immediately
used as an argument to <code>for</code>, I’d be tempted at this point to actually go back
to <code>traverse</code> and eta reduce, resulting in the following definition.
</p>

<p><label>In[48]:</label></p><div>
<pre><span>factorise</span> <span>::</span> [<span>Int</span>] <span>-&gt;</span> <span>State</span> <span>FactorCache</span> [(<span>Int</span>, <span>Maybe</span> <span>Int</span>)]
<span>factorise</span> <span>=</span> traverse <span>$</span> <span>\</span>n <span>-&gt;</span>
  <span>let</span>
    computed <span>=</span> greatest_factor n
  <span>in</span> <span>do</span>
    cached <span>&lt;-</span> gets (M.lookup n)
    factor <span>&lt;-</span> maybe (modify (M.insert n computed) <span>$&gt;</span> computed)
      pure cached
    pure (n, guard (factor <span>/=</span> n) <span>$&gt;</span> factor)
</pre>
</div>

<p>
This no longer looks anything like procedural code in other languages. This is
procedural on a higher level: it’s defining a stateful traversal. A stateful
traversal is a distinctly procedural operation, but most other procedural
languages don’t have support for defining stateful traversals. Haskell does,
because Haskell is the greatest procedural language in the world.
</p>
</div>
</section>
<section id="outline-container-things-you-never-need-to-care-about">

<div id="text-org6e7b6ae">
<p>
There are some historic functions you might run across in this context. You
never need these, and you can almost always translate them into their modern,
better equivalents.
</p>

<ul>
<li><code>&gt;&gt;</code> is an old name for <code>*&gt;</code>.</li>
<li><code>return</code> is an old name for <code>pure</code>.</li>
<li><code>map</code> and <code>liftM</code> are old names for <code>fmap</code>.</li>
<li><code>liftM2</code>, <code>liftM3</code>, etc. are old names for <code>liftA2</code>, <code>liftA3</code>, etc.</li>
<li><code>ap</code> is an old name for the <code>&lt;*&gt;</code> operator.</li>
<li><code>msum</code> is an old name for <code>asum</code>.</li>
<li><code>sequence</code> and <code>sequence_</code> are old names for <code>sequenceA</code> and <code>sequenceA_</code>.</li>
<li><code>mapM</code> and <code>mapM_</code> are old names for <code>traverse</code> and <code>traverse_</code>.</li>
<li><code>forM</code> and <code>forM_</code> are old names for <code>for</code> and <code>for_</code>.</li>
</ul>

<p>
Back in the dark ages of the 1990s, we thought monads were the greatest thing
since sorting machines for punch cards. It turns out it is possible extract a
highly useful subset of monads, called <i>applicative functors</i>, and they are
responsible for many of the cool things we did with monads. These old names
generally come from the time before we learned about applicative functors.
</p>
</div>
</section>
<section id="outline-container-appendix-a--avoiding-success-and-uselessness">

<div id="text-org1320073">
<p>
It is sometimes said the Haskell community is ready to do anything to avoid
success. This is a misreading of “avoid success at all costs”. What the phrase
really means is that some languages are ready to sacrifice their values to
become more successful – they aim for success at all costs – and Haskell does
not. It prefers to stick to its values rather than chucking them out for a
moment of fame.
</p>

<p>
“Haskell is useless” was said in a discussion on how different programming
languages approach giving authority to the programmer. At the time it was said,
the popular approach to programming language design was to assume that the
programmer was always right, good, and should be given maximum authority over
their code.<span><sup>13</sup> Think <abbr>php</abbr>, Ruby, Python 2, JavaScript.</span> It has long been
recognised that this sort of freedom often leads to programmers shooting
themselves in the foot, so languages restrict this flexibility by adding
prohibitions into their design. The idea is “you are allowed to do everything
except X, Y, Z.” Some examples:
</p>

<ul>
<li>In C, we can no longer jump to abitrary addresses like we could in
assembly.<span><sup>14</sup> Popular C compilers do have support for this, but it’s not in
the language standard.</span></li>
<li>In Ada, we can no longer think of a pointer as a trenchcoated integer.</li>
<li>In Java, we are no longer allowed to manually deallocate memory.</li>
<li>In Python 3, we can no longer treat a sequence of bytes as text.</li>
</ul>

<p>
With every generation, more restrictions are piled onto previous ones, making
the language safer, but also less powerful – or, some would say, less useful.
</p>

<p>
Haskell approached this from the other direction. It started by saying no to
arbitrary side effects: when computing a return value, a function is only
allowed to rely on its arguments, nothing else. Functions cannot read from the
system environment, and certainly not write to it. This eliminates a large class
of safety problems, but it also makes the language completely useless for almost
everything practical.
</p>

<p>
Then Haskell went on and found a way to allow code to describe side effects
without actually executing them in such a way that they can be executed in the
right order by an external runtime, and Haskell gained some usefulness. This is
in contrast to other languages that started out useful but lost some of their
usefulness with time, in the name of safety: Haskell started out useless, but
has since gained usefulness.
</p>
</div>
</section>
<section id="outline-container-appendix-b--why-fmap-maps-over-both-side-effects-and-lists">

<div id="text-org78141c3">
<p>
We have already seen that
</p>

<p><label>In[49]:</label></p><div>
<pre><span>fmap</span> <span>::</span> (a <span>-&gt;</span> b) <span>-&gt;</span> <span>IO</span> a <span>-&gt;</span> <span>IO</span> b
</pre>
</div>

<p>
but it is <i>equally true</i> that
</p>

<p><label>In[50]:</label></p><div>
<pre><span>fmap</span> <span>::</span> (a <span>-&gt;</span> b) <span>-&gt;</span> [a] <span>-&gt;</span> [b]
</pre>
</div>

<p>
I.e. <code>fmap</code> can take a pure function and apply it to all elements of a list.
</p>

<p>
The way it works is that <code>fmap</code> is not written to work specifically with side
effects, or lists, or anything else. It is written to work against anything that
is a functor. Its most general type signature is actually
</p>

<p><label>In[51]:</label></p><div>
<pre><span>fmap</span> <span>::</span> <span>Functor</span> f <span>=&gt;</span> (a <span>-&gt;</span> b) <span>-&gt;</span> f a <span>-&gt;</span> f b
</pre>
</div>

<p>
The name <i>functor</i> is a bit nondescriptive, but we can think of it as the name
for all types that support being “mapped over”, in some sense.
</p>

<ul>
<li>Mapping over a side effect object means transforming the result it produces.</li>
<li>Mapping over a list means transforming each element of the list.</li>
<li>Mapping over a nullable value means transforming the value of it, if it exists,
otherwise doing nothing.</li>
</ul>

<p>
Lists, side effect objects, and nullable values are, therefore, functors. Thus,
they all support the <code>fmap</code> operation.
</p>
</div>
</section>
<section id="outline-container-appendix-c--foldable-and-traversable">

<div id="text-orga432767">
<p>
The result-preserving variants of the functions we’ve discussed – <code>sequenceA</code>,
<code>traverse</code>, etc. – guarantee that the data structure produced by side effect
they create will have the same shape as the original data structure we passed
in. This is easy e.g. in the case of a list, because given the same number of
items, the list has the same shape regardless of what we put into it. However,
for some data structures, this is a more severe requirement. Typical examples
are sets and search trees: their structure depends on their contents. When we
<code>traverse</code> a search tree and construct a new search tree with the values
produced by the side effect, we might end up getting a completely different tree
shape than what we started from.
</p>

<p>
In contrast, if we are not interested in getting back the values produced by
side effects, we don’t need to be able to reconstruct the same data structure we
started with. All that takes is being able to iterate the elements of the data
structure, and this can be supported by more data structures – including sets
and search trees. This is why <code>sequenceA_</code>, <code>traverse_</code>, and friends can work
with more collection types.
</p>

<p>
One hack if we want the values produced by the side effect, but do not care
about the structure, is to first convert the collection to a list (this only
requires being able to iterate the collection) and then call <code>traverse</code> on that
list. Then we have retained the results, but lost the original structure of the
collection. Such is life if we work with structures that do not support traversal.
</p>

<p>
The technical names here are <i>foldable</i> (can produce elements one at a time in a
specified order) and <i>traversable</i> (can reconstruct its structure even when
given new elements.) All traversables are foldable, but not all foldables are
traversable.
</p>
</div>
</section>

            </div></div>
  </body>
</html>
