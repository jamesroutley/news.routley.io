<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.qodo.ai/blog/deepcodebench-real-world-codebase-understanding-by-qa-benchmarking/">Original</a>
    <h1>DeepCodeBench: Real-World Codebase Understanding by Q&amp;A Benchmarking</h1>
    
    <div id="readability-page-1" class="page"><div data-post-content="">
									<figure>
						<img width="1024" height="687" src="https://www.qodo.ai/wp-content/uploads/2025/09/DeepCodeBench_-Real-World-Codebase-Understanding-by-QA-Benchmarking-1024x687.png" alt=""/>					</figure>
					<p>At Qodo, we’ve created a new benchmark dataset of real-world questions derived from large, complex code repositories. We are excited to release the dataset, methodology, and prompts used in its creation to support further research and development.</p>
<h2 id="motivation">Motivation</h2>
<p>Enterprises often maintain massive codebases that are difficult for any individual developer to navigate and fully understand. Whether onboarding, doing routine development, or using AI-assisted workflows, teams often have questions about their codebase. To effectively address this, we’ve developed specialized retrieval capabilities within our research agents. However, to benchmark and validate these systems effectively, we require a robust set of real-world questions and answers.</p>
<h2 id="prior-work">Prior Work</h2>
<p>Existing benchmarks, such as<a href="https://arxiv.org/pdf/2109.08365"> CodeQA</a>, primarily contain artificially generated code with questions limited to provided code snippets, requiring no retrieval from broader contexts. Another recent work (<a href="https://arxiv.org/html/2407.02883v1">arXiv:2407.02883</a>) involves real-world scenarios but focuses on retrieval from databases rather than code repositories, which does not adequately represent common real-world use-cases.</p>
<p>To address this gap, we propose a new approach. We introduce a benchmark based on realistic questions derived from pull requests that require retrieval across multiple files in a codebase.</p>
<h2 id="dataset-generation">Dataset Generation</h2>
<p>To effectively challenge retrieval systems, questions in our benchmark must:</p>
<ol>
<li>Require deep retrieval, often spanning multiple interconnected files.</li>
<li>Reflect realistic questions developers encounter when solving actual issues.</li>
</ol>
<p>We identified that pull requests (PRs) are good sources for complex code changes with proper context that can be used for question and answer generation. PRs naturally link related code, not always through explicit imports or function calls, but through functional changes made together. We leveraged this insight to generate context:</p>
<ul>
<li>For each code change within a PR, we retrieved its containing method, class or file from the current default branch.</li>
<li>We bundled these retrieved code snippets along with the PR’s title and description to form a meaningful context..</li>
</ul>
<p>Using the above mentioned PR data as context, we prompt large language models (LLMs) to generate questions relevant to real developer workflows, ensuring authenticity and practical value (see prompt in Appendix). The same context is also used to generate the ground-true answer.</p>
<p><img loading="lazy" src="https://www.qodo.ai/wp-content/uploads/2025/09/Data-set-generation.png" alt="" width="742" height="222" srcset="https://www.qodo.ai/wp-content/uploads/2025/09/Data-set-generation.png 742w, https://www.qodo.ai/wp-content/uploads/2025/09/Data-set-generation-300x90.png 300w, https://www.qodo.ai/wp-content/uploads/2025/09/Data-set-generation-107x32.png 107w, https://www.qodo.ai/wp-content/uploads/2025/09/Data-set-generation-58x17.png 58w, https://www.qodo.ai/wp-content/uploads/2025/09/Data-set-generation-160x48.png 160w" sizes="auto, (max-width: 742px) 100vw, 742px"/></p>
<h2><b>Example</b></h2>
<p>Consider <a href="https://github.com/huggingface/transformers/pull/39363">PR 39363</a> of Hugging Face’s Transformers repository. This PR touches 4 files in different places, including methods such as:</p>
<ul>
<li><code>BaseImageProcessorFast.__init__ (src/transformers/image_processing_utils_fast.py)</code></li>
<li><code>BaseVideoProcessor.__init__  (src/transformers/video_processing_utils.py)</code></li>
</ul>
<p>We are not concerned with the exact code changes in the PR. Instead, we use the PR as a signal to locate blocks of code that are functionally related and should be considered together.</p>
<p>We try to find these methods in the updated code to avoid asking questions about irrelevant code. We don’t always find them, due to renames and refactors, but in this PR we found both <a href="https://github.com/huggingface/transformers/blob/b9282355bea846b54ed850a066901496b19da654/src/transformers/image_processing_utils_fast.py#L214">BaseImageProcessorFast</a> and <a href="https://github.com/huggingface/transformers/blob/b9282355bea846b54ed850a066901496b19da654/src/transformers/video_processing_utils.py#L180">BaseVideoProcessor</a>.</p>
<p>In the next step, we pass the complete methods, along with the PR title, description, and the prompt in Appendix A, to an LLM, asking it to generate a question.</p>
<p>For this PR, the generated question is:</p>
<p><i>How do the fast image and video processor base classes prevent shared mutable state when instantiating multiple instances?</i></p>
<p>And the answer is:</p>
<p><i>Both the fast image and video processor bases deep-copy their mutable defaults when you instantiate them. In BaseImageProcessorFast.__init__ (src/transformers/image_processing_utils_fast.py) and BaseVideoProcessor.__init__ (src/transformers/video_processing_utils.py) they loop over all valid kwargs and do:</i></p>
<ul>
<li><i> If you passed a value, use it;</i></li>
<li><i>Otherwise, setattr(self, key, deepcopy(getattr(self, key))), </i><i>and they rebuild size/crop_size via get_size_dict.</i></li>
</ul>
<p><i> By deep-copying every default dict/list on init, no two instances share the same mutable object.</i></p>
<h2 id="dataset-statistics">Dataset Statistics</h2>
<p>We generated 1,144 questions derived from eight open-source repositories. Below are detailed insights into the characteristics of the dataset:</p>
<h3><b>Context Distribution</b></h3>
<p>The histograms illustrate the distribution of context used for each question:</p>
<ul>
<li><b>Number of Context Blocks:</b> Indicates how many individual code blocks were involved in generating each question.</li>
<li><b>Number of Context Files:</b> Reflects the number of distinct files utilized per question.</li>
</ul>
<p>In the example above, there are two blocks across two files. However, PRs often touch multiple methods within the same file, resulting in more blocks than files.</p>
<p><img loading="lazy" src="https://www.qodo.ai/wp-content/uploads/2025/09/unnamed-1.png" alt="" width="512" height="256" srcset="https://www.qodo.ai/wp-content/uploads/2025/09/unnamed-1.png 512w, https://www.qodo.ai/wp-content/uploads/2025/09/unnamed-1-300x150.png 300w, https://www.qodo.ai/wp-content/uploads/2025/09/unnamed-1-64x32.png 64w, https://www.qodo.ai/wp-content/uploads/2025/09/unnamed-1-58x29.png 58w, https://www.qodo.ai/wp-content/uploads/2025/09/unnamed-1-96x48.png 96w" sizes="auto, (max-width: 512px) 100vw, 512px"/></p>
<h3><b>Categorical Breakdown</b></h3>
<p><b>Scope:</b></p>
<ul>
<li><b>Deep:</b> Questions focusing on specific, detailed aspects of a single block of code.</li>
<li><b>Broad:</b> Questions involving interactions or relationships across multiple code blocks or files.</li>
</ul>
<p><b>Core Questions: </b>Questions targeting fundamental, core functionality versus those focusing on peripheral technical details.</p>
<p><b>Searchable Questions: </b>Questions containing specific keywords or identifiers that facilitate direct searches within the codebase.</p>
<p><img loading="lazy" src="https://www.qodo.ai/wp-content/uploads/2025/09/QAW-Breakdown.png" alt="" width="548" height="550" srcset="https://www.qodo.ai/wp-content/uploads/2025/09/QAW-Breakdown.png 548w, https://www.qodo.ai/wp-content/uploads/2025/09/QAW-Breakdown-300x300.png 300w, https://www.qodo.ai/wp-content/uploads/2025/09/QAW-Breakdown-150x150.png 150w, https://www.qodo.ai/wp-content/uploads/2025/09/QAW-Breakdown-32x32.png 32w, https://www.qodo.ai/wp-content/uploads/2025/09/QAW-Breakdown-58x58.png 58w, https://www.qodo.ai/wp-content/uploads/2025/09/QAW-Breakdown-48x48.png 48w" sizes="auto, (max-width: 548px) 100vw, 548px"/></p>
<h2 id="evaluation-mechanism-llm-as-a-judge">Evaluation Mechanism: LLM as a Judge</h2>
<p><img loading="lazy" src="https://www.qodo.ai/wp-content/uploads/2025/09/LLM-as-judge.png" alt="" width="800" height="263" srcset="https://www.qodo.ai/wp-content/uploads/2025/09/LLM-as-judge.png 800w, https://www.qodo.ai/wp-content/uploads/2025/09/LLM-as-judge-300x99.png 300w, https://www.qodo.ai/wp-content/uploads/2025/09/LLM-as-judge-768x252.png 768w, https://www.qodo.ai/wp-content/uploads/2025/09/LLM-as-judge-97x32.png 97w, https://www.qodo.ai/wp-content/uploads/2025/09/LLM-as-judge-58x19.png 58w, https://www.qodo.ai/wp-content/uploads/2025/09/LLM-as-judge-146x48.png 146w" sizes="auto, (max-width: 800px) 100vw, 800px"/></p>
<p>Evaluating model predictions requires an objective and scalable approach.Rather than relying solely on subjective LLM judgment, we:</p>
<ul>
<li>Extracted discrete, verifiable facts from each ground-truth (GT) answer.</li>
<li>Checked whether each fact appeared in the predicted answer using a simple LLM call.</li>
</ul>
<p>This method, that we call “fact recall,” was introduced in the <b>2003 TREC (Text REtrieval Conference) QA Track</b> (<a href="https://aclanthology.org/N03-2037.pdf?utm_source=chatgpt.com">paper</a>,<a href="https://trec.nist.gov/pubs/trec12/papers/QA.OVERVIEW.pdf?utm_source=chatgpt.com"> overview</a>) and is widely used today – for example in<a href="https://arxiv.org/abs/2403.18802?utm_source=chatgpt.com"> Google/DeepMind’s SAFE</a> and in the TREC 2024 RAG Track (e.g., MSR/Waterloo’s<a href="https://arxiv.org/abs/2411.09607?utm_source=chatgpt.com"> AutoNuggetizer</a>). It ensures robust, objective, and scalable assessment of model performance.</p>
<h2 id="baselines">Baselines</h2>
<p>To better understand our dataset, we established several baseline evaluations:</p>
<ul>
<li><b>Ground Truth (GT) answers:</b> Verifies both the accuracy of fact extraction and the reliability of the automated fact verification method</li>
<li><b>LLM with full context:</b> Provides an LLM with all context used to generate the questions, setting an upper-bound performance baseline.</li>
<li><b>LLM with no context:</b> Evaluates how well an LLM could answer questions using only the repository name, capturing inherent model knowledge and setting a lower-bound baseline.</li>
</ul>
<p>These baselines help evaluate the quality of the dataset, validate our evaluation methods, and measure the inherent knowledge of different LLMs.</p>
<h2 id="results">Results</h2>
<p>We evaluated <b>Codex <a title="CLI" href="https://www.qodo.ai/blog/best-cli-tools/" data-wpil-keyword-link="linked" data-wpil-monitor-id="208">CLI</a></b>, <b>Claude Code</b>, and our <a href="https://www.qodo.ai/products/qodo-aware/"><b>Deep Research agent in Qodo Aware</b></a>.</p>
<ul>
<li><b>Overall: </b>Qodo’s deep-research agent achieves the best fact recall (~76%), just ahead of OpenAI’s Codex (~74%), while being about twice as fast. Also, with the high reasoning feature, we reached (~80%) with a tradeoff on runtimes, where we see a 10-second optimization for our agent. Both outperform Claude (~64%) and Gemini (~45%).</li>
<li><b>Searchable:</b> All agents improved with searchable keywords in the question, but our DeepResearch’s gain was smallest thanks to strong semantic search.</li>
<li><b>Scope:</b> Codex and Claude preferred <i>deep</i> over <i>broad</i> questions, while DeepResearch performed equally well on both due to wide search capabilities.</li>
</ul>

<p><img loading="lazy" src="https://www.qodo.ai/wp-content/uploads/2025/09/unnamed-2.png" alt="" width="512" height="331" srcset="https://www.qodo.ai/wp-content/uploads/2025/09/unnamed-2.png 512w, https://www.qodo.ai/wp-content/uploads/2025/09/unnamed-2-300x194.png 300w, https://www.qodo.ai/wp-content/uploads/2025/09/unnamed-2-49x32.png 49w, https://www.qodo.ai/wp-content/uploads/2025/09/unnamed-2-58x37.png 58w, https://www.qodo.ai/wp-content/uploads/2025/09/unnamed-2-74x48.png 74w" sizes="auto, (max-width: 512px) 100vw, 512px"/></p>
<h2><b>Results by data segment</b></h2>
<table>
<tbody>
<tr>
<td>
<p><b>scope</b></p>
</td>
<td><b>codex-cli</b></td>
<td><b>claude-code</b></td>
<td><b>gemini-cli</b></td>
<td>
<p><b>deep-research (Qodo)</b></p>
</td>
</tr>
<tr>
<td>
<p>broad</p>
</td>
<td>0.72</td>
<td>0.6</td>
<td>0.41</td>
<td>0.76</td>
</tr>
<tr>
<td>deep</td>
<td>0.76</td>
<td>0.67</td>
<td>0.48</td>
<td>
<p>0.77</p>
</td>
</tr>
</tbody>
</table>

<table>
<tbody>
<tr>
<td>
<p><b>Searchable </b></p>
</td>
<td><b>codex-cli</b></td>
<td><b>claude-code</b></td>
<td><b>gemini-cli</b></td>
<td><b>deep-research(Qodo)</b></td>
</tr>
<tr>
<td>False</td>
<td>0.73</td>
<td>0.59</td>
<td>0.43</td>
<td>0.76</td>
</tr>
<tr>
<td>True</td>
<td>0.76</td>
<td>0.68</td>
<td>0.47</td>
<td>0.77</td>
</tr>
</tbody>
</table>
<h2 id="what-we-8217-re-releasing">What We’re Releasing</h2>
<ul>
<li><b>Dataset:</b> 1,144 carefully curated question-answer pairs – <a href="https://huggingface.co/datasets/Qodo/deep_code_bench">deep_code_bench</a>.</li>
<li><b>Metadata and context</b>: Each question is linked to the pull request (PR) it was generated from and tagged with category labels (e.g., broad/deep, is searchable).</li>
<li><b>Prompts:</b> The exact prompts used to guide question and answer generation.</li>
</ul>
<h2 id="appendix-a-8211-prompt-for-question-generation">Appendix A – prompt for question generation</h2>
<h3 id="system-prompt">System Prompt</h3>
<p>You are helping build a high-quality dataset of real-world codebase questions to test our search AI agents. Each question should require the agent to search through the codebase to find the relevant code.</p>
<h3 id="guidelines">Guidelines</h3>
<p>Your task is to generate exactly ONE onboarding question adhering to these guidelines:</p>
<ul>
<li>The question must be clearly grounded in the provided code context.</li>
<li>Do not include exact file paths, line numbers, or raw code snippets in the question text.</li>
<li>Prefer questions involving relationships across multiple functions, components, or files.</li>
<li>Keep the wording concise, clear, and readable.</li>
<li>Avoid vague reference to code elements like ‘the function’ or ‘that class’.</li>
<li>Don’t make identifier references (function names, class names, variables, etc.) too obvious, so that the search will be as challenging as possible.</li>
<li>Despite the above, the question should still be answerable, and the context should be unambiguous.</li>
<li>The question should be answerable with a short, concise response—ideally, a single short sentence.</li>
</ul>
<h3 id="scopes">Scopes</h3>
<p>There are 2 kinds of scopes. When provided with only 1–2 short code blocks, generate a DEEP question: a highly specific question that explores internal logic, error handling, edge cases, or detailed behaviors. When provided with multiple code blocks or a larger context, generate a BROAD question: a higher-level question about architecture, overall flow, interactions between modules, or general system design.</p>
<h3 id="core-questions">Core questions</h3>
<p>Core questions targeting fundamental, core functionality versus non-core questions which are focusing on peripheral technical aspects.</p>
<h3 id="pr-details">PR details</h3>
<p>If a PR title and description are provided, use them only to infer the high-level subject of the question. Think of questions that the developer needs to know in order to address the PR. The question must still be answerable using the code context. If the PR text lacks details, base the question solely on the code.</p>
<h3 id="examples">Examples</h3>
<p>Here are examples to illustrate the desired style and scope:</p>
<h4>Broad question examples:</h4>
<ul>
<li>What is the general workflow for training and deploying a transformer-based language model?</li>
<li>Can you describe the internal steps involved in performing hyperparameter tuning with a grid search?</li>
<li>What’s the end-to-end flow involved in generating images using diffusion-based models?</li>
</ul>
<h4>Deep question examples:</h4>
<ul>
<li>How are gradient updates managed when training gradient-boosted decision trees on sparse data?</li>
<li>Which parameter directly controls the number of leaves permitted in each decision tree of a gradient boosting algorithm?</li>
<li>How does a functional deep learning API internally handle merging layers with multiple input tensors?</li>
</ul>
<h4>Core question examples:</h4>
<ul>
<li>How are token and positional embeddings combined and fed into the BERT model?</li>
<li>How does the Keras Layer base class manage weight creation and the build/call lifecycle?</li>
<li>What happens in one XGBoost boosting iteration—how are new trees grown and combined?</li>
</ul>
<h3 id="output-format">Output format</h3>
<p>Return the question, its type, whether it is a core question, and the relevant NODE IDENTIFIER headers from the context as a JSON object with keys ‘question’, ‘scope’, ‘is_core_question’, and ‘nodes’ (a list of strings). Wrap the JSON in triple backticks.</p>
<h3 id="user-message-prompt">User message prompt</h3>
<p><strong>PR info:</strong></p>
<p><code>{pr_context}</code></p>
<p><strong>Code context:</strong></p>
<p><code>{context}</code></p>
<p>Based on the PR information and code above, write ONE question and return only the requested JSON.</p>

				<div data-post-modal="">
					<figure data-modal-figure="">
						<img src="" alt="" data-modal-img=""/>
					</figure>
				</div>
			</div></div>
  </body>
</html>
