<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.slice.zone/blog/nix-in-practice">Original</a>
    <h1>An Overview of Nix in Practice</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div data-apply-variations="true"><div>
<!-- -->
<!-- -->
<!-- -->

<blockquote>
<p><code>&lt;skip&gt;</code> i would really appreciate it if someone who knows nix could help tho
<span role="img" aria-label="pleading face emoji">ü•∫</span></p>
<small>‚Äî July 25, 2021</small>
</blockquote>
<p>I was introduced to Nix in late 2021 by a friend in a Discord channel, but it
wasn‚Äôt my first encounter with the operating system/package
manager/configuration system/programming language hodgepodge.</p>
<p>As a Linux-obsessed child who constantly hopped between distributions, it
inevitably registered on my radar. I was always looking for the next ISO file to
victimize and copy onto my tired USB stick, which would probably suffocate me in
my sleep if it grew arms. But NixOS was never one of those distros. It looked
too <em>weird</em> to my 14-year-old brain.</p>
<p>I still believe this. NixOS, and Nix in general, is <em>really</em> weird. I‚Äôve
described it as what ends up writhing out of a malfunctioning industrial mixer
that someone accidentally dropped Haskell and Bash into. When I, like many other
computer programmers, tell my friends who don‚Äôt write code that ‚Äúit‚Äôs a miracle
that modern technology even works‚Äù, Nix is one of those things that I‚Äôm
referring to.</p>
<p>Despite this, NixOS is the only distro I install on my servers. I‚Äôm dual-booting
it on my MacBook<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup>. I build and set up the development environments for all of
my projects with Nix. I use Nix to set up my dotfiles and take care of my shell
configuration and personal set of installed packages. Nix makes it unflinchingly
simple to replicate my cozy user environment anywhere Nix is available, so I can
feel at home no matter where I am. Nix even turned building ffmpeg into a
cakewalk for that one time I needed
<a href="https://en.wikipedia.org/wiki/Fraunhofer_FDK_AAC">better AAC encoding</a><sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="true" aria-describedby="footnote-label">2</a></sup>.</p>
<p>Nix is a really neat (in my opinion), but the learning ‚Äúcurve‚Äù is comparable to
climbing a brick wall with nothing but your fingernails, determination, and the
incredibly thin shred that is your remaining patience. I‚Äôm still not great at
Nix, and I‚Äôm terrified to submit anything to the official package collection,
but I hope to demystify it and emphasize what makes it so dang useful.</p>
<h2 id="behind-the-curtain">Behind the curtain<a aria-hidden="true" tabindex="-1" href="#behind-the-curtain"><span>#</span></a></h2>
<p>‚ÄúNix‚Äù, generally speaking, refers to any or all of these things:</p>
<ol>
<li>A ~purely functional programming language with immutability, laziness, floaty
Haskellesque syntax, and some interesting design choices to make
configuration and configuration-adjacent tasks particularly easy.</li>
<li>A package manager and build system with the primary goal of reproducibility
that consumes package definitions and build instructions written in the Nix
programming language.</li>
<li>A massive repository that houses more than 80,000 Nix package definitions
written and maintained by over 5,000 contributors, called ‚Äúnixpkgs‚Äù.</li>
<li>A Linux distribution (‚ÄúNixOS‚Äù) that uses Nix<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="true" aria-describedby="footnote-label">3</a></sup> to declaratively specify the
total configuration of the system, such as: which packages are to be
installed, which user accounts exist on the system, and what services are
active.</li>
</ol>
<p>All of these puzzle pieces fit together to create something that is truly unique
and terrifying. Hooray!</p>
<p>Nix is different from other package managers in that it‚Äôs truly and utterly
obsessed with making things entirely self-contained. When Nix builds a package,
the build environment is isolated such that nothing outside of what you declare
is accessible. Having globally installed libraries that are recognized by
<code>configure</code> scripts, CMake, etc. can be a massive pain, especially when you need
a specific version or find yourself needing to apply bespoke patches. Sometimes
the exact version of a library you require just isn‚Äôt available easily. Having
multiple versions installed can be either difficult or nigh impossible.</p>
<p>Nix avoids this by having binaries reference their dependencies <em>explicitly</em>.
List the shared libraries needed by a binary that was built by Nix, and you‚Äôll
see something like this:</p>

<pre><code>$ ldd &#34;$(which curl)&#34;
	linux-vdso.so.1 (0x00007fffeeb86000)
	libcurl.so.4 =&gt; /nix/store/rirzp6ijbcwnxlf0b2n286n587r3z9jw-curl-7.86.0/lib/libcurl.so.4 (0x00007ffb5ce40000)
	libssl.so.3 =&gt; /nix/store/4mxnw95jcm5a27qk60z7yc0gvxp42b9a-openssl-3.0.7/lib/libssl.so.3 (0x00007ffb5cd93000)
	libcrypto.so.3 =&gt; /nix/store/4mxnw95jcm5a27qk60z7yc0gvxp42b9a-openssl-3.0.7/lib/libcrypto.so.3 (0x00007ffb5c914000)
	libz.so.1 =&gt; /nix/store/026hln0aq1hyshaxsdvhg0kmcm6yf45r-zlib-1.2.13/lib/libz.so.1 (0x00007ffb5c8f6000)
	libc.so.6 =&gt; /nix/store/4nlgxhb09sdr51nc9hdm8az5b08vzkgx-glibc-2.35-163/lib/libc.so.6 (0x00007ffb5c6ed000)
	libnghttp2.so.14 =&gt; /nix/store/qz400bwshaqikj5s2qyvh0c9qffgmqik-nghttp2-1.49.0-lib/lib/libnghttp2.so.14 (0x00007ffb5c6bc000)
	libidn2.so.0 =&gt; /nix/store/5mh5019jigj0k14rdnjam1xwk5avn1id-libidn2-2.3.2/lib/libidn2.so.0 (0x00007ffb5c69a000)
	libssh2.so.1 =&gt; /nix/store/vqq9s0d6fw6kqf3sr5nrzqbys9rhygqd-libssh2-1.10.0/lib/libssh2.so.1 (0x00007ffb5c659000)
	libgssapi_krb5.so.2 =&gt; /nix/store/r7gl900my2fw6k33nxh2r7rzv8nv0s25-libkrb5-1.20/lib/libgssapi_krb5.so.2 (0x00007ffb5c606000)
	libzstd.so.1 =&gt; /nix/store/w10in9diaqrcqqxi5lg20n3q2jfpk6pq-zstd-1.5.2/lib/libzstd.so.1 (0x00007ffb5c540000)
	libbrotlidec.so.1 =&gt; /nix/store/9iy1ng7h1l6jdmjk157jra8n4hkrfdj1-brotli-1.0.9-lib/lib/libbrotlidec.so.1 (0x00007ffb5c532000)
	libdl.so.2 =&gt; /nix/store/4nlgxhb09sdr51nc9hdm8az5b08vzkgx-glibc-2.35-163/lib/libdl.so.2 (0x00007ffb5c52d000)
	libpthread.so.0 =&gt; /nix/store/4nlgxhb09sdr51nc9hdm8az5b08vzkgx-glibc-2.35-163/lib/libpthread.so.0 (0x00007ffb5c528000)
	/nix/store/4nlgxhb09sdr51nc9hdm8az5b08vzkgx-glibc-2.35-163/lib/ld-linux-x86-64.so.2 =&gt; /nix/store/4nlgxhb09sdr51nc9hdm8az5b08vzkgx-glibc-2.35-163/lib64/ld-linux-x86-64.so.2 (0x00007ffb5cee7000)
	libunistring.so.2 =&gt; /nix/store/34xlpp3j3vy7ksn09zh44f1c04w77khf-libunistring-1.0/lib/libunistring.so.2 (0x00007ffb5c37a000)
	libkrb5.so.3 =&gt; /nix/store/r7gl900my2fw6k33nxh2r7rzv8nv0s25-libkrb5-1.20/lib/libkrb5.so.3 (0x00007ffb5c29f000)
	libk5crypto.so.3 =&gt; /nix/store/r7gl900my2fw6k33nxh2r7rzv8nv0s25-libkrb5-1.20/lib/libk5crypto.so.3 (0x00007ffb5c270000)
	libcom_err.so.3 =&gt; /nix/store/r7gl900my2fw6k33nxh2r7rzv8nv0s25-libkrb5-1.20/lib/libcom_err.so.3 (0x00007ffb5c26a000)
	libkrb5support.so.0 =&gt; /nix/store/r7gl900my2fw6k33nxh2r7rzv8nv0s25-libkrb5-1.20/lib/libkrb5support.so.0 (0x00007ffb5c25a000)
	libkeyutils.so.1 =&gt; /nix/store/816qwr4xy058451rbxr0ccyh1v1akhb6-keyutils-1.6.3-lib/lib/libkeyutils.so.1 (0x00007ffb5c251000)
	libresolv.so.2 =&gt; /nix/store/4nlgxhb09sdr51nc9hdm8az5b08vzkgx-glibc-2.35-163/lib/libresolv.so.2 (0x00007ffb5c23f000)
	libm.so.6 =&gt; /nix/store/4nlgxhb09sdr51nc9hdm8az5b08vzkgx-glibc-2.35-163/lib/libm.so.6 (0x00007ffb5c15f000)
	libbrotlicommon.so.1 =&gt; /nix/store/9iy1ng7h1l6jdmjk157jra8n4hkrfdj1-brotli-1.0.9-lib/lib/libbrotlicommon.so.1 (0x00007ffb5c13c000)
</code></pre>
<p>Assuming that the package is built correctly and you aren‚Äôt playing any runtime
linker tricks on your end, it‚Äôs virtually impossible to run into library errors.
Having multiple versions of a library installed is a nonissue, and dependency
hell falls into irrelevancy.</p>

<p>Binaries are vacuum packed in that they only ever refer to exactly what they
need, and this applies for both runtime and build dependencies alike.</p>
<p>Because the Nix store is essentially an append-only graph database<sup><a href="#user-content-fn-4" id="user-content-fnref-4" data-footnote-ref="true" aria-describedby="footnote-label">4</a></sup> with
nodes being packages and edges being dependency relations, I can even query it
to see e.g. ffmpeg‚Äôs runtime dependencies, both direct and indirect:</p>
<figure><img alt="An end-to-end graph of ffmpeg&#39;s dependencies." title="An end-to-end graph of ffmpeg&#39;s dependencies." loading="lazy" width="550" height="321" decoding="async" data-nimg="1" sizes="(max-width: 800px) 90vw, (min-width: 800px) 570px" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fffmpeg-graph.993e883a.png&amp;w=640&amp;q=75 640w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fffmpeg-graph.993e883a.png&amp;w=750&amp;q=75 750w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fffmpeg-graph.993e883a.png&amp;w=828&amp;q=75 828w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fffmpeg-graph.993e883a.png&amp;w=1080&amp;q=75 1080w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fffmpeg-graph.993e883a.png&amp;w=1200&amp;q=75 1200w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fffmpeg-graph.993e883a.png&amp;w=1920&amp;q=75 1920w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fffmpeg-graph.993e883a.png&amp;w=2048&amp;q=75 2048w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fffmpeg-graph.993e883a.png&amp;w=3840&amp;q=75 3840w" src="https://vrklovespaper.substack.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fffmpeg-graph.993e883a.png&amp;w=3840&amp;q=75"/><p>Brought to you by <code>nix-store</code> and <code>graphviz</code>.</p></figure>

<p>At the top, we see <code>CoreFoundation</code>, which is a core macOS system framework that
a lot of packages depend on. We can also spot <code>dejavu-fonts-minimal</code>, which is
needed by <code>fontconfig</code>, which is needed by <code>libass</code> to render subtitles, which
is needed by this default configuration of <code>ffmpeg</code>. Emphasis on default: we can
override options provided by the package definition and specify <code>.patch</code> files
to be applied to the source code.</p>
<p>To maximize reproducibility, Nix works on the source code of a package. But
because every package is built in its own universe, it is extremely cacheable.
Nix package installations are capital F <em>Fast</em>, because there‚Äôs no dependency
resolution to be done. It amounts to downloading data from a CDN and unpacking
it, and it can‚Äôt get any faster than that.</p>

<p>Executing ‚Äúover 350,000 builds each week‚Äù, the NixOS foundation maintains
<a href="https://hydra.nixos.org/">a massive Nix build farm for <code>x86-64</code> and <code>aarch64</code> Linux and macOS</a>,
uploading the build artifacts to
<a href="https://cache.nixos.org/">a widely-available binary cache</a>.</p>
<p>As Nix evaluates the build instructions locally, it hashes the result and
queries the cache for it. In theory<sup><a href="#user-content-fn-5" id="user-content-fnref-5" data-footnote-ref="true" aria-describedby="footnote-label">5</a></sup>, between systems of the same platform,
there‚Äôs no difference between building the desired package and copying the
results from the cache. Taking an extreme amount of care to isolate builds from
one another makes this practical.</p>
<p>This means that in ordinary circumstances, you won‚Äôt have to build packages from
scratch. If you impose an override onto a package that changes the resulting
build instructions, Nix doesn‚Äôt find a cached result from the cache due to the
differing hashes, and the package is built locally.</p>
<p>Nix‚Äôs approach to builds also has some other neat effects:</p>
<ol>
<li><a href="https://nix.dev/tutorials/cross-compilation">Cross-compilation becomes easier</a>,
which unfortunately complicates the overall infrastructure but makes
approaching this problem comparatively less scary‚Ä¶probably.</li>
<li><a href="https://nixos.org/manual/nix/stable/advanced-topics/distributed-builds.html">Remote build</a>
support lets you evaluate a package‚Äôs (potentially customized) build
instructions on your local box, then send them to a more powerful machine
over the network to build. This is not only cool, but also necessary should
the package not be supported on your local platform. Distributed builds, CI,
et cetera! The sky is the limit.</li>
<li><a href="https://nixos.org/manual/nix/stable/command-ref/nix-copy-closure.html"><code>nix-copy-closure</code></a>
copies the results of a build and its total runtime dependency tree (called a
‚Äúclosure‚Äù) between machines of the same platform, avoiding unnecessary work.</li>
<li>Cache your own stuff!
<a href="https://nixos.wiki/wiki/Binary_Cache">Host your own binary cache</a>, or use a
service like <a href="https://www.cachix.org/">Cachix</a> to avoid rebuilding.</li>
</ol>
<h2 id="ephemerality">Ephemerality<a aria-hidden="true" tabindex="-1" href="#ephemerality"><span>#</span></a></h2>
<figure><img alt="xkcd 1987" title="xkcd 1987" loading="lazy" width="550" height="545" decoding="async" data-nimg="1" sizes="(max-width: 800px) 90vw, (min-width: 800px) 570px" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fxkcd-1987.6b704c51.png&amp;w=640&amp;q=75 640w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fxkcd-1987.6b704c51.png&amp;w=750&amp;q=75 750w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fxkcd-1987.6b704c51.png&amp;w=828&amp;q=75 828w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fxkcd-1987.6b704c51.png&amp;w=1080&amp;q=75 1080w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fxkcd-1987.6b704c51.png&amp;w=1200&amp;q=75 1200w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fxkcd-1987.6b704c51.png&amp;w=1920&amp;q=75 1920w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fxkcd-1987.6b704c51.png&amp;w=2048&amp;q=75 2048w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fxkcd-1987.6b704c51.png&amp;w=3840&amp;q=75 3840w" src="https://vrklovespaper.substack.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fxkcd-1987.6b704c51.png&amp;w=3840&amp;q=75"/><p>This sums it up, I think.</p></figure>

<p>Managing Python environments is not only painful, but actively damaging to the
psyche.</p>
<p>Setting up an ephemeral Python environment with OpenCV can be done in Nix like
so:</p>
<pre><code>$ nix-shell --pure -p &#34;python3.withPackages(packages: [ packages.opencv4 ])&#34; --run python3
Python 3.10.10 (main, Feb 17 2023, 05:25:10) [Clang 11.1.0 ] on darwin
Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.
&gt;&gt;&gt; import cv2
&gt;&gt;&gt;
</code></pre>
<p>I can run a similar command to drop myself into a REPL with NumPy or SciPy, or
any package in general: a certain version of Java, or even a Node or Haskell
environment.</p>
<p>Dissecting the command:</p>
<ol>
<li>
<p>The <code>--pure</code> flag clears the environment before dropping you into the shell,
preventing e.g. <code>$PATH</code> from leaking through.</p>
</li>
<li>
<p><code>-p</code> specifies which package(s) we are interested in. In this case, <code>python3</code>
(which currently resolves to <code>python310</code> on the 22.11 channel). We use
<code>withPackages</code> to indicate that we‚Äôd like to create an environment with the
<code>opencv4</code> Python package available.</p>
<pre><code><span>python3</span><span>.</span><span>withPackages</span>(<span>packages</span>: [ <span>packages</span><span>.</span><span>opencv4</span> ])
</code></pre>
<p>This is Nix <em>code</em> that uses package definitions from nixpkgs, which has
specific infrastructure for Python, Python packages, and managing Python
environments. Nix has similar infrastructure for Rust, Node.js, etc.</p>
</li>
<li>
<p><code>--run</code> drops us directly into the Python REPL instead of Bash.</p>
</li>
</ol>
<p>Invoking this command causes Nix to compute which packages is needed and what
Python environment trickery needs to be done. If the necessary packages aren‚Äôt
in my Nix store already, they‚Äôre downloaded from the binary cache. When I exit
the shell, my local Python user environment remains completely untouched. The
fundamental nature of Nix allows this to happen in a frictionless way‚Äîno
<code>virtualenv</code> futzing required.</p>
<p>Nix‚Äôs modular nature allows it to cooperate with other technologies, too. Take
Docker, for instance:
<a href="https://xeiaso.net/blog/i-was-wrong-about-nix-2020-02-10">Nix is seemingly better at generating smaller images</a>;
because
<a href="https://grahamc.com/blog/nix-and-layered-docker-images/">it knows everything about every package</a>,
it can purge superfluous data down to the nanometer and keep only the bits that
matter.</p>
<h2 id="declarative-systems">Declarative systems<a aria-hidden="true" tabindex="-1" href="#declarative-systems"><span>#</span></a></h2>
<p>NixOS takes wacky declarative package management to its next logical conclusion
by using the same technology to determine to service topology of your Linux
system. In essence, your system configuration becomes a package that is managed
and installed by Nix just like any other.</p>
<p>This is what a minimal NixOS configuration looks like (in practice, real
configurations are much larger):</p>
<pre><code>{ <span>config</span><span>,</span> <span>pkgs</span><span>,</span> <span>... </span>}: {
  <span>imports</span> <span>=</span> [
    <span># Import another Nix module that contains the results of the hardware scan.</span>
    <span># (Includes important kernel modules for hardware, the filesystem table, etc.)</span>
    <span>./hardware-configuration.nix</span>
  ];

  <span># Enable a bootloader for UEFI systems.</span>
  <span>boot</span>.<span>loader</span>.<span>systemd-boot</span>.<span>enable</span> <span>=</span> <span>true</span>;

  <span># Enable the OpenSSH server.</span>
  <span>services</span>.<span>sshd</span>.<span>enable</span> <span>=</span> <span>true</span>;

  <span># Add some useful packages for everyone.</span>
  <span>environment</span>.<span>systemPackages</span> <span>=</span> <span>with</span> <span>pkgs</span>; [ <span>git</span> <span>curl</span> <span>wget</span> ];

  <span># ...</span>
}
</code></pre>
<p>As someone with ADHD and relatively poor memory retention, NixOS is a godsend
for managing my fleet of servers. After not having logged into a box for a
while, I easily forget what services exist on the server. I‚Äôm too lazy to
maintain this in writing, but it‚Äôs OK because Nix enables declarative management
of these services. It acts as the definitive source of truth.</p>
<p>Figuring out exactly what a server does without fear of documentation
desynchronizing with what actually exists on the server is a single
<code>$EDITOR /etc/nixos/configuration.nix</code> away.</p>
<p>NixOS differs from something like Ansible in that it‚Äôs inherently declarative,
through and through. If you remove the <code>services.sshd.enable = true;</code> line from
your configuration, NixOS will tear down the OpenSSH server upon a rebuild.
It‚Äôll be as if it was never there (subtracting any leftover data), because there
isn‚Äôt a practical difference between installing NixOS for the first time and
building it again. Ansible has the notion of ‚Äúidempotency‚Äù, but Nix (and NixOS)
is idempotent by nature.</p>
<p>NixOS isn‚Äôt special:</p>
<ol>
<li>
<p>You can build a NixOS system and copy the closure to another machine to use.</p>
</li>
<li>
<p>You can
<a href="https://nixos.wiki/wiki/Creating_a_NixOS_live_CD">make a custom version of the NixOS installer ISO</a>
with your desired customizations to craft your ideal Linux rescue USB.</p>
</li>
<li>
<p>You can
<a href="https://nixos.org/manual/nixos/stable/#sec-changing-config">test experimental changes to your system</a>
by sandboxing it within a QEMU virtual machine:</p>
<pre><code>$ nixos-rebuild build-vm

<span># Run your new system inside of a VM to see if something broke.</span>
$ ./result/bin/run-<span>*</span>-vm
</code></pre>
</li>
<li>
<p>Because virtualization is made easy with declarative configurations, NixOS
maintainers
<a href="https://nixos.org/manual/nixos/stable/index.html#sec-nixos-tests">test their own code with it</a>.</p>
</li>
<li>
<p>Because Nix packages are fully self-contained,
<a href="https://nixos.org/manual/nix/stable/package-management/profiles.html">previous generations of the system are tracked</a>,
so you can rollback anytime in the boot menu. I used this once after I
accidentally hosed my network configuration and wasn‚Äôt sure how to fix it.</p>
</li>
<li>
<p>Not only are previous generations kept around, system upgrades are
essentially fully atomic. New version of <code>libc</code> (or other Important<span role="img" aria-label="tm emoji">‚Ñ¢Ô∏è</span>
library)? On an ordinary system, replacing the file without rebooting would
probably summon flesh-eating demons. But with Nix, this isn‚Äôt an
issue‚Äîevery package was already referencing the version it depended on
through an absolute path into the Nix store.</p>
</li>
</ol>
<p>Saving disk space is easy, too. Being a feature of Nix in general,
<a href="https://nixos.org/manual/nix/stable/command-ref/nix-collect-garbage.html">the garbage collector</a>
can clean up computed build instructions, old profile/system generations, and
other build dependencies that aren‚Äôt needed for a functioning system. This runs
pretty fast and is a nice crutch for those times you just need more room.</p>
<pre><code>$ sudo nix-collect-garbage -d
<span># ...</span>
16730 store paths deleted, 11828.97 MiB freed <span># :O</span>
</code></pre>
<h2 id="declarative-modular-systems">Declarative, modular systems<a aria-hidden="true" tabindex="-1" href="#declarative-modular-systems"><span>#</span></a></h2>

<p>nixpkgs comes with a huge number of included modules that port other software
and services to be usable with NixOS.</p>
<p>Something that is genuinely terrifying to set up to me is GitLab. It just has
too many moving parts. To deploy it with NixOS, I have this in my configuration:</p>
<pre><code>{
  <span>services</span>.<span>gitlab</span> <span>=</span> <span>let</span>
    <span>secretFile</span> <span>=</span> <span><span>&#34;</span>/var/lib/gitlab-secret<span>&#34;</span></span>;
    <span>rsaSecretFile</span> <span>=</span> <span><span>&#34;</span>/var/lib/gitlab-secret-rsa<span>&#34;</span></span>;
    <span>initialRootPasswordFile</span> <span>=</span> <span><span>&#34;</span>/var/lib/gitlab-initial-root-password<span>&#34;</span></span>;
  <span>in</span> {
    <span>enable</span> <span>=</span> <span>true</span>;
    <span>host</span> <span>=</span> <span>...</span>;
    <span>port</span> <span>=</span> <span>80</span>;
    <span>https</span> <span>=</span> <span>true</span>;
    <span>inherit</span> <span>initialRootPasswordFile</span>;
    <span>secrets</span> <span>=</span> {
      <span>secretFile</span> <span>=</span> <span>secretFile</span>;
      <span>dbFile</span> <span>=</span> <span>secretFile</span>;
      <span>otpFile</span> <span>=</span> <span>secretFile</span>;
      <span>jwsFile</span> <span>=</span> <span>rsaSecretFile</span>;
    };
  };
}
</code></pre>
<p>Other than specifying some paths to files containing secrets (a caveat which
I‚Äôll elaborate on later), this is all I need for a functioning GitLab setup. If
I change my mind on this in the future, all I have to do is flip
<code>enable = true;</code> to <code>false</code>, or outright evict this code block from my
configuration.</p>
<p>By doing this, all required services immediately stop and become disabled. If I
run the garbage collector, all GitLab packages are deleted. All that remains is
any user data that was created by the services in question. This is seriously
awesome to me, because GitLab is exemplary of being somewhat of a behemoth to
set up, despite <a href="https://docs.gitlab.com/omnibus/">Omnibus</a>.</p>
<p>What is even better is the inherent benefit of a modular and declarative
configuration. For example, one of my servers is also responsible for hosting an
authoritative DNS server, which has a corresponding NixOS module in nixpkgs:</p>
<pre><code>{
  <span>services</span>.<span>nsd</span> <span>=</span> {
    <span>enable</span> <span>=</span> <span>true</span>;
    <span>interfaces</span> <span>=</span> [ <span><span>&#34;</span>0.0.0.0<span>&#34;</span></span> ];
    <span>verbosity</span> <span>=</span> <span>2</span>;
    <span>zones</span>.<span>howl</span>.<span>children</span> <span>=</span> {
      <span><span>&#34;</span>howl.<span>&#34;</span></span>.<span>data</span> <span>=</span> <span><span>&#39;&#39;</span></span>
<span>        $ORIGIN howl.</span>
<span>        $TTL 3600</span>
<span></span>
<span>        @ IN SOA howl. tinyslices@gmail.com. ( 2021122201 28800 7200 864000 60 )</span>
<span>        @ IN NS louie.howl.</span>
<span></span>
<span>        <span>${</span><span>lib</span><span>.</span><span>concatStringsSep</span> <span>&#34;</span><span>\n</span><span>&#34;</span> <span>config</span><span>.</span><span>howl</span><span>.</span><span>records</span><span>}</span></span>
<span>      <span>&#39;&#39;</span></span>;
    };
  };
}
</code></pre>
<p>An authoritative DNS server vends records instead of simply resolving and
caching them. Here, I‚Äôm directing
<a href="https://www.nlnetlabs.nl/projects/nsd/about/"><code>nsd</code></a> (the DNS server in
question) to listen on the unspecified address<sup><a href="#user-content-fn-6" id="user-content-fnref-6" data-footnote-ref="true" aria-describedby="footnote-label">6</a></sup>. I‚Äôm using it with
<a href="https://tailscale.com/">Tailscale</a>, which is a really neat service that enables
a zero-config mesh VPN between all of my servers and devices. (NixOS also has a
module for it‚Äîjust <code>services.tailscale.enable = true;</code>.)</p>
<p>Most importantly, I‚Äôm defining a custom NixOS option: <code>howl.records</code>, which lets
me easily add lines to the zone from other modules. This is important.</p>
<pre><code>{
  <span>options</span>.<span>howl</span> <span>=</span> <span>with</span> <span>lib</span>; {
    <span>records</span> <span>=</span> <span>mkOption</span> {
      <span>type</span> <span>=</span> <span>types</span><span>.</span><span>listOf</span> <span>types</span><span>.</span><span>str</span>;
      <span>description</span> <span>=</span>
        <span><span>&#34;</span>Authoritative DNS records exposed to every device in the tailnet<span>&#34;</span></span>;
    };
  };
}
</code></pre>

<p>When I write the code to enable the <code>nsd</code> module above, I make sure to reference
the final value of this custom option (as <code>config.howl.records</code>) in the zone
configuration, which is collected from all instances of the option being
modified in other modules. Nix‚Äôs lazy evaluation crucially enables this.</p>
<p>Now, in another NixOS module‚Äîsay, <code>monitoring.nix</code>, I can enable Grafana and
other services such as Prometheus. I can also tweak Nginx and tell it to expose
its status page, and also create virtual hosts for Grafana and Prometheus. And
in the same breath, I can create DNS records for all of these new services, so
every device connected to the tailnet can access them painlessly:</p>

<pre><code>{ <span>lib</span><span>,</span> <span>... </span>}:

<span>let</span>
  <span>inherit</span> (<span>import</span> <span>./net.nix</span>) <span>localhost</span> <span>internal</span> <span>ports</span>;
<span>in</span>
{
  <span>services</span>.<span>grafana</span> <span>=</span> {
    <span>enable</span> <span>=</span> <span>true</span>;
    <span>port</span> <span>=</span> <span>ports</span><span>.</span><span>grafana</span>;
    <span>domain</span> <span>=</span> <span><span>&#34;</span>grafana.howl<span>&#34;</span></span>;
    <span>rootUrl</span> <span>=</span> <span><span>&#34;</span>http://grafana.howl<span>&#34;</span></span>;
  };

  <span>services</span>.<span>prometheus</span> <span>=</span> {
    <span>enable</span> <span>=</span> <span>true</span>;
    <span>port</span> <span>=</span> <span>ports</span><span>.</span><span>prometheus</span><span>.</span><span>prometheus</span>;
    <span>globalConfig</span>.<span>scrape_interval</span> <span>=</span> <span><span>&#34;</span>10s<span>&#34;</span></span>;
    <span>scrapeConfigs</span> <span>=</span> [{
      <span># ...</span>
    }];
    <span>exporters</span> <span>=</span> {
      <span># ...</span>
      <span>nginx</span>.<span>enable</span> <span>=</span> <span>true</span>;
    };
  };

  <span># Instruct Nginx to expose its status page for Prometheus.</span>
  <span>services</span>.<span>nginx</span>.<span>statusPage</span> <span>=</span> <span>true</span>;

  <span># Configure Nginx vhosts for these new services.</span>
  <span>services</span>.<span>nginx</span>.<span>virtualHosts</span>.<span><span>&#34;</span>grafana.howl<span>&#34;</span></span>.<span>locations</span>.<span><span>&#34;</span>/<span>&#34;</span></span> <span>=</span> <span>internal</span> {
    <span>proxyPass</span> <span>=</span> <span>localhost</span> <span>ports</span><span>.</span><span>grafana</span>;
  };
  <span>services</span>.<span>nginx</span>.<span>virtualHosts</span>.<span><span>&#34;</span>prometheus.howl<span>&#34;</span></span>.<span>locations</span>.<span><span>&#34;</span>/<span>&#34;</span></span> <span>=</span> <span>internal</span> {
    <span>proxyPass</span> <span>=</span> <span>localhost</span> <span>ports</span><span>.</span><span>prometheus</span><span>.</span><span>prometheus</span>;
  };

  <span># Add lines to the DNS zone for these new services.</span>
  <span>howl</span>.<span>records</span> <span>=</span> [
    <span><span>&#34;</span>grafana.howl. IN CNAME louie.howl.<span>&#34;</span></span>
    <span><span>&#34;</span>prometheus.howl. IN CNAME louie.howl.<span>&#34;</span></span>
  ];
}
</code></pre>
<p>I import this new module in my main configuration:</p>
<pre><code>{
  <span># ...</span>
  <span>imports</span> <span>=</span> [
    <span># ...</span>
    <span>./monitoring.nix</span>
  ];
}
</code></pre>
<p>And after a rebuild, Nix pulls in the required packages and builds the system
closure, enabling and configuring every service that I declared to be active.</p>
<p>In my opinion, this is where NixOS really shines. I‚Äôm able to enable and
configure Grafana, Prometheus, Nginx, and the DNS records that have to do with
those services in a single file. I‚Äôm defining shared constants in a separate
place and using them across configurations that are written in <em>completely
different languages and syntaxes</em>.</p>

<p>With traditional server management, I‚Äôd have to install the correct packages,
look up the paths to their configuration files, and maybe even run some commands
to modify some mutable state. I‚Äôll forget all of this in a few days or even
hours, but Nix lets me authoritatively describe it in code.</p>
<p>If I decide to stop importing that file in my configuration, then the DNS and
Nginx virtual hosts are removed; Nginx stops exposing its status page;
Prometheus and Grafana‚Äôs <code>systemd</code> units are disabled; and all unneeded packages
are no longer reachable from a garbage collector root, making them eligible for
deletion.</p>
<p>NixOS lets me unify and modularize what would otherwise be disconnected
configurations across packages in a highly idempotent, cacheable, and
declarative way, essentially homogenizing every service on the system. <strong>That‚Äôs
amazing to me.</strong></p>
<h2 id="diving-in">Diving in<a aria-hidden="true" tabindex="-1" href="#diving-in"><span>#</span></a></h2>
<p>I‚Äôm intentionally avoiding the details here because I believe it‚Äôs important to
first grasp the big picture behind Nix and NixOS, and understand what it‚Äôs truly
useful for.</p>
<p>I write and maintain a few Discord bots. To ease the maintenance and deployment
of these critters, I‚Äôve created a base that lets me share the same development
environment and automatically generate a NixOS module for all of them, with
customization and extension points whenever necessary. I‚Äôm interested in writing
some detailed case studies on how I accomplished this, but this post is getting
really long, and we still aren‚Äôt finished!</p>
<p>For now, here are some resources that I personally recommend for perusal should
you be interested:</p>
<ol>
<li><a href="https://zero-to-nix.com/">Zero to Nix</a>: New kid on the block; gentle and
more detailed introduction to using Nix in practice.</li>
<li><a href="https://www.youtube.com/watch?v=6iVXaqUfHi4">‚ÄúNix: What Even is it Though‚Äù</a>,
a presentation by Burke Libbey.</li>
<li><a href="https://nixos.org/guides/nix-pills/">Nix Pills</a>: Learn Nix from the bottom
up.</li>
<li>The
<a href="https://nixos.org/manual/nix/stable/introduction.html">Nix Reference Manual</a></li>
<li><a href="https://nixos.org/manual/nixpkgs/stable/">nixpkgs manual</a> and
<a href="https://nixos.org/manual/nixos/stable/">NixOS manual</a>: The official
documentation for those projects.</li>
<li><a href="https://nix.dev/">nix.dev</a>: An opinionated handbook and ‚Äúsurvival guide‚Äù.</li>
<li><a href="https://search.nixos.org/packages">NixOS Search</a>: An invaluable tool for
quickly looking up packages and NixOS options. Keep this on speed dial.</li>
<li><a href="https://noogle.dev/">noogle</a> eases the looking up of library functions.</li>
</ol>
<p>When docs aren‚Äôt amazing, learning becomes akin to patchwork: you slowly and
incrementally stitch squares into your quilt until you reach a certain point
where everything becomes clear, and you end up with something nice and soft to
keep you warm during winter.</p>
<h2 id="rougher-edges">Rougher edges<a aria-hidden="true" tabindex="-1" href="#rougher-edges"><span>#</span></a></h2>
<p>Every technology involves a set of tradeoffs, and Nix is no exception.</p>
<p>One particular pain point is managing secrets: the Nix store is world-readable,
and this includes any configuration files that may or may not contain secret
keys and passwords. This problem is tackled via projects such as <a href="https://github.com/ryantm/agenix">agenix</a> and
others, but keep this in mind when blueprinting your system. I‚Äôve experimented
with committing my nixfiles with their encrypted secrets in public before, but
this ended up being such a massive pain that I gave up. Maybe I‚Äôll try again
soon.</p>
<p>When it comes to libraries and scaffolding your own projects with Nix, it can be
hard to find what‚Äôs appropriate for use.</p>
<p>Two good examples: packaging Rust code, and deploying NixOS. I used to wield
<a href="https://github.com/nix-community/naersk">Naersk</a> to blast my Rust packages with the Nix beam, but was later recommended
<a href="https://crane.dev/">Crane</a> by a friend, which seems to require less ceremony. I never would‚Äôve
found out about it otherwise. nixpkgs also seems to have built-in support for
Rust via <code>buildRustPackage</code>. I‚Äôm not sure which one is the best to use; it‚Äôs
unclear to me, but I‚Äôve settled on Crane for now.</p>
<figure><img alt="A screenshot of a successful colmena command invocation." title="A screenshot of a successful colmena command invocation." loading="lazy" width="550" height="102" decoding="async" data-nimg="1" sizes="(max-width: 800px) 90vw, (min-width: 800px) 570px" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcolmena.2ebc19dc.png&amp;w=640&amp;q=75 640w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcolmena.2ebc19dc.png&amp;w=750&amp;q=75 750w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcolmena.2ebc19dc.png&amp;w=828&amp;q=75 828w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcolmena.2ebc19dc.png&amp;w=1080&amp;q=75 1080w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcolmena.2ebc19dc.png&amp;w=1200&amp;q=75 1200w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcolmena.2ebc19dc.png&amp;w=1920&amp;q=75 1920w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcolmena.2ebc19dc.png&amp;w=2048&amp;q=75 2048w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcolmena.2ebc19dc.png&amp;w=3840&amp;q=75 3840w" src="https://vrklovespaper.substack.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcolmena.2ebc19dc.png&amp;w=3840&amp;q=75"/><p>Build and apply your Nix config with a single command.</p></figure>
<p>Deployment to other servers from your own box is peak comfort. There are many
Nix deployment solutions, but I‚Äôve settled on <a href="https://github.com/zhaofengli/colmena">Colmena</a>, because it supports
macOS and Flakes. There‚Äôs also <a href="https://github.com/rapenne-s/bento">Bento</a> (which tries to keep it simple), as well
as <a href="https://github.com/DBCDK/morph">Morph</a> and <a href="https://github.com/NixOS/nixops">nixops</a>. And there‚Äôs probably more I‚Äôm missing. There‚Äôs a lot of
choice here.</p>
<p>I run into a similar feeling when I write Nix code myself. The documentation
story here could use some improvement: finding the right function to use can
feel like navigating a dense jungle with a machete. I feel like reading other
people‚Äôs Nix code is one of the most effective ways to learn Nix, because you
get to see how its used (and how people solve their specific problems) in
practice.</p>
<p><a href="https://github.com/features/code-search/">GitHub‚Äôs code search</a> is an
invaluable tool here, as well as poking around in nixpkgs and asking questions
in community channels. A lot of learning Nix is done hands-on; you‚Äôll need to
throw things at a wall to see what sticks, and that‚Äôs going to be frustrating at
first.</p>
<h2 id="the-nature-of-nix">The nature of Nix<a aria-hidden="true" tabindex="-1" href="#the-nature-of-nix"><span>#</span></a></h2>
<p>Nix is infectious, which can be both good and bad. Having a universal,
omnipresent existence on your system is what enables Nix‚Äôs niceties, but also
can make it frustrating to just <em>do things</em>.</p>
<p>You can‚Äôt follow <code>README</code> instructions verbatim anymore: if you want to use
something, it has to be packaged by Nix. Or, at least, it should. If there
happens to be a Nix package maintained by someone in nixpkgs, great! If not, you
better be in a mood to write some Nix code.</p>
<p>My dotfiles are Nix-managed, too. This means that my entire user environment is
easily reproducible everywhere Nix is available. However, this means that I need
to rebuild my user package every time I make a change, because the
configurations need to be built, copied into the Nix store, and then symlinked
into my own home directory.</p>
<p>Any change I make‚Äîbig or small‚Äîhas to go through Nix before programs take
notice, which can be annoying.</p>
<p>Fortunately, you aren‚Äôt forced to adopt Nix to such a high degree. You can even
install it on other Linux distributions, since it‚Äôs just a package manager. By
doing this, you get to pick and choose what falls under Nix‚Äôs reign. The more
you decide to use, though, the more you‚Äôll have to zap things with the Nix ray.</p>
<p>Take black box binaries, for example: tarballs of pre-built blobs, sans source
code, that you ‚Äújust‚Äù have to unpack and run. Nix inherently doesn‚Äôt play well
with these, and that can make certain things harder to do (see: games).</p>
<p>If patching the binaries in question is viable, <a href="https://nixos.org/manual/nixpkgs/stable/#setup-hook-autopatchelfhook">patchelf</a> can come to the
rescue. A friend of mine who is trying out NixOS is using it to patch binaries
in order to run Garry‚Äôs Mod servers, which are able to interface with external
3rd-party plugins via <code>dlsym</code> and other runtime loading.</p>
<p>When patching is unfeasible, such as programs that perform integrity checking or
simply make too many assumptions about the outside world,
<a href="https://nixos.org/manual/nixpkgs/stable/#sec-fhs-environments"><code>buildFHSUserEnv</code></a> enables you to run lightweight sandboxes
that are compatible with the Filesystem Hierarchy Standard (<code>/usr/lib</code> and
friends), made possible through Linux namespaces. This is done to <a href="https://github.com/NixOS/nixpkgs/tree/nixos-22.11/pkgs/games/steam">support
Steam</a>, which is pretty damn clever.</p>
<p>Steam has always felt pretty fragile to me. For example, it requires its own
bespoke set of libraries that it downloads and maintains outside of the system
package manager. This sucks, but it‚Äôs cool that it was possible for Nix to shove
it into a reproducible box of sorts that basically can‚Äôt break (let‚Äôs hope I
don‚Äôt jinx it).</p>
<p>When packaging other software that we have a reduced amount of control over,
things can get a little wonky. When I installed NixOS on my Mac, I ran into an
issue where <a href="https://github.com/ArmCord/ArmCord">ArmCord</a>‚Äîa neat little project that wraps Discord natively for
ARM devices‚Äîwouldn‚Äôt open links in my web browser.</p>
<p>After some poking around with Chromium‚Äôs logging levels, I eventually got it to
spew out enough debug information to see why <code>xdg-open</code> (which is what is being
spawned to open my web browser) was failing:</p>
<pre><code>XPCOMGlueLoad error for file /nix/store/5mndwvvbdz07kllj6bs0pp1n82cx260i-firefox-110.0.1/lib/firefox/libxul.so:
/nix/store/p9ggv8qkdv0s7pckz2xkxxs68ras07g3-nss-3.79.4/lib/libssl3.so: version `NSS_3.80&#39; not found (required by /nix/store/5mndwvvbdz07kllj6bs0pp1n82cx260i-firefox-110.0.1/lib/firefox/libxul.so)
Couldn&#39;t load XPCOM.
/home/slice/.nix-profile/bin/xdg-open: line 881: x-www-browser: command not found
XPCOMGlueLoad error for file /nix/store/5mndwvvbdz07kllj6bs0pp1n82cx260i-firefox-110.0.1/lib/firefox/libxul.so:
/nix/store/p9ggv8qkdv0s7pckz2xkxxs68ras07g3-nss-3.79.4/lib/libssl3.so: version `NSS_3.80&#39; not found (required by /nix/store/5mndwvvbdz07kllj6bs0pp1n82cx260i-firefox-110.0.1/lib/firefox/libxul.so)
Couldn&#39;t load XPCOM.
</code></pre>
<p>To my surprise, there were‚Ä¶ linking errors going on! Firefox seemed to be
loading the incorrect version of OpenSSL for some reason. I thought Nix was
supposed to be reproducible, self-contained, etc. etc. This shouldn‚Äôt be
happening!</p>
<p>More investigation led to the realization that the ArmCord package actually
<a href="https://github.com/NixOS/nixpkgs/blob/cd749f58ba83f7155b7062dd49d08e5e47e44d50/pkgs/applications/networking/instant-messengers/armcord/default.nix#L112">injects <code>LD_LIBRARY_PATH</code> at runtime</a> so that it can find the
right libraries‚Äîneeded because the package reuses the <code>.deb</code> binaries‚Äîand it
was bleeding into the <code>xdg-open</code> subprocess that was being spawned. Whoops.</p>
<p>I was able to fix this by <a href="https://github.com/ArmCord/ArmCord/issues/354#issuecomment-1480432789">wrapping <code>xdg-open</code> with a pristine script that unset
<code>LD_LIBRARY_PATH</code>, and overriding the ArmCord package to add a wrapper that
invoked the main binary with the pristine script prepended to <code>PATH</code> before
anything else</a>. Then, when <code>xdg-open</code> was spawned by Chromium,
<code>LD_LIBRARY_PATH</code> would no longer be clobbered.</p>
<p>In this situation, overriding the package definition here was enough to solve my
problem, but that might not always be the case: NixOS modules, and Nix packages
in general, are only as flexible as they are written to be<sup><a href="#user-content-fn-7" id="user-content-fnref-7" data-footnote-ref="true" aria-describedby="footnote-label">7</a></sup>. So far, I‚Äôve
never had to straight-up fork a package or NixOS module definition, but I‚Äôm
definitely not ruling that out from ever happening.</p>
<p>Luckily, there tends to be a lot of escape hatches: nixpkgs is very configurable
and extensible with support for overlays, overrides, and source code patches.
It‚Äôs also totally possible to do something such as creating a package that
solely takes the output of another package and patches it in a certain complex
way (however you want!)</p>
<p>Lastly, I‚Äôd like to reiterate that because Nix is a lazily evaluated (and
dynamically typed) language, it‚Äôs very possible to run into fairly cryptic
errors often, especially when recursion is involved. Lazy evaluation means that
it‚Äôs possible to introduce a ticking time bomb that can be detonated from
seemingly unrelated code.</p>
<p>While this can be a pain, it‚Äôs also what enables Nix to avoid unnecessary
computation: the root of nixpkgs is a huge tree of every package contained
within the repository, but only those that are actually needed are ever
evaluated. Deferring evaluation to the last possible moment is what makes things
such as overrides and overlays possible.</p>
<h2 id="bottom-line">Bottom line<a aria-hidden="true" tabindex="-1" href="#bottom-line"><span>#</span></a></h2>
<p>Nix is quirky, unique, and a little rough around the edges. Debugging it, like a
lot of other things, is frustrating. But the benefits I get from using it
currently outweigh the disadvantages, providing enough incentive for me to keep
on investing in it.</p>
<p>What I find to be most useful for me is declarative system management via NixOS.
My memory span is virtually nonexistent nowadays, and having a way to declare my
servers completely idempotently is an incredible way to avoid confusion and
stress. I like having that philosophy extended to my personal projects and user
environment, as it ensures a level of consistency and reproducibility that I
haven‚Äôt found anywhere else.</p>
<hr/>
</div></div></div></div></div></div>
  </body>
</html>
