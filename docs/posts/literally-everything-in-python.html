<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://404wolf.com/posts/literallyeverything/">Original</a>
    <h1>Literally Everything (in Python)</h1>
    
    <div id="readability-page-1" class="page"><div><p><span>Literally Everything (in Python)</span><span></span></p></div><div><astro-slot> <div>  
<p>Last Tuesday, on July 2nd, 2024, I implemented everything in python. There is
literally nothing left to implement, I’ve now done it all.</p>
<p>Here is the <a href="https://github.com/404Wolf/everything">Github</a> and the
<a href="https://pypi.org/project/dothething/">PyPi</a></p>
<p>And here’s a real world demo…</p>
<pre tabindex="0" data-language="py"><code><span><span>from</span><span> everything </span><span>import</span><span> sort_list, stylized_greeting</span></span>
<span></span>
<span><span># Print a greeting for Wolf</span></span>
<span><span>print</span><span>(stylized_greeting(</span><span>&#34;Wolf&#34;</span><span>, </span><span>&#34;Angry&#34;</span><span>))</span></span>
<span></span>
<span><span># Sort a list</span></span>
<span><span>print</span><span>(sort_list([</span><span>3</span><span>, </span><span>2</span><span>, </span><span>1</span><span>, </span><span>0</span><span>, </span><span>-</span><span>5</span><span>, </span><span>2.5</span><span>]))</span></span></code></pre>
<pre tabindex="0" data-language="cmd"><code><span><span>&gt;&gt;</span><span> pip install dothething</span></span>
<span><span>&gt;&gt;</span><span> OPENAI_API_TOKEN</span><span>=</span><span>...</span></span>
<span><span>&gt;&gt;</span><span> python example.py</span></span>
<span><span>WHAT </span><span>DO</span><span> YOU WANT, WOLF?</span><span>!</span></span>
<span><span>[</span><span>-5</span><span>, </span><span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>2.5</span><span>, </span><span>3</span><span>]</span></span></code></pre>
<p>It is, in a word, everything.</p>
<h2 id="inspiration">Inspiration</h2>
<p>The idea hit out of the blue, quite literally, in a conversation with a friend
about abstractions for parallel computing. It hit me, why not be able to use
your own abstractions created on a whim at runtime?</p>
<p><img src="https://static.404wolf.com/2024-07-05-20240705020336355_0001.webp" alt="The idea!"/></p>

<p>When you import &lt;anything&gt; from everything, dothething will use Python’s AST
library to scan your source code, and find all usages of &lt;anything&gt;. I’ve
defined methods that will search for all usages of given functions, and can then
grab parts of the code. Python’s AST library is really nice because it provides
line numbers with references to the exact location in the source code of
different elements. It then will merge a few lines of context on both sides of
every function call, along with the call itself. Then, it will use OpenAI’s
gpt-4o model to generate a Python function, which you can then use in your code.</p>
<p><img src="https://static.404wolf.com/everythingcli_0001.png" alt="Everything CLI"/></p>
<p>It also works in a <code>repl</code>, and scans the history of the interactive shell to see
if there’s any relevant context. This part is a bit glitchy, and is probably
shell and terminal dependent to some extent. It’s using python’s <code>readline</code>
library to get access to shell environment stuff.</p>
<h3 id="execs">Execs</h3>
<p>To actually bring the LLM code into the codebase, I’m using <code>exec</code> and a
context, where I dump the function into a localized environment and then wrap
the function, and call the resulting function with the wrapper. Here’s where I
actually inject the LLM code…</p>
<pre tabindex="0" data-language="py"><code><span><span>function_name </span><span>=</span><span> re.findall(</span><span>r</span><span>&#34;def </span><span>(\w[\w\d]</span><span>+</span><span>)</span><span>\(</span><span>&#34;</span><span>, generated_function.split(</span><span>&#34;</span><span>\n</span><span>&#34;</span><span>)[</span><span>0</span><span>])</span></span>
<span><span>    function_name </span><span>=</span><span> function_name[</span><span>0</span><span>] </span><span>if</span><span> function_name </span><span>is</span><span> not</span><span> None</span><span> else</span><span> &#34;error&#34;</span></span>
<span><span>    _LOGGER</span><span>.debug(</span><span>f</span><span>&#34;Function generated had name </span><span>{</span><span>function_name</span><span>}</span><span>&#34;</span><span>)</span></span>
<span></span>
<span><span>    def</span><span> the_thing</span><span>(</span><span>*</span><span>args, </span><span>**</span><span>kwargs):</span></span>
<span><span>        exec</span><span>(generated_function)</span></span>
<span><span>        context </span><span>=</span><span> locals</span><span>()</span></span>
<span><span>        exec</span><span>(</span><span>f</span><span>&#34;result = </span><span>{</span><span>function_name</span><span>}</span><span>(*args,**kwargs)&#34;</span><span>, context)</span></span>
<span><span>        return</span><span> context[</span><span>&#34;result&#34;</span><span>]</span></span></code></pre>
<h3 id="dynamic-imports">Dynamic Imports</h3>
<p>To actually handle being able to import anything, under the hood I’ve modified
the <em>module’s</em> <code>__getattr__</code>, so that it can create the function when it is
imported. My <code>__init__.py</code> for the module looks something like this…</p>
<pre tabindex="0" data-language="py"><code><span><span># __init__.py</span></span>
<span><span>&#34;&#34;&#34;Top-level package for everything.&#34;&#34;&#34;</span></span>
<span></span>
<span><span>__author__ </span><span>=</span><span> &#34;&#34;&#34;Wolf Mermelstein&#34;&#34;&#34;</span></span>
<span><span>__email__ </span><span>=</span><span> &#34;wolfmermelstein@gmail.com&#34;</span></span>
<span><span>__version__</span><span> =</span><span> &#34;0.1.0&#34;</span></span>
<span></span>
<span></span>
<span><span>def</span><span> __getattr__</span><span>(name: </span><span>str</span><span>):</span></span>
<span><span>    from</span><span> .makethething </span><span>import</span><span> make_the_thing</span></span>
<span></span>
<span><span>    return</span><span> make_the_thing(name)</span></span></code></pre>
<p><code>__init__.py</code> files are files that are a directive to python that a given folder
is a <code>module</code>, and they are run when you load the module.</p>
<p>Because of how module caching works, if you import the same name in different
places in your project, it will only generate the function once and then will
reuse it multiple times.</p>
<p><img src="https://static.404wolf.com/thePep_0001.png" alt="pep 562"/></p>
<p>But, as it turns out, this is a relatively new feature that was added in
<a href="https://peps.python.org/pep-0562/">PEP562</a> (PEP = project enhancement
protocol). Previously, you had to rely on a hack that the creator of Python
himself suggested, overwriting the module with a class that overrides the
<code>__getattr__</code>.</p>
<pre tabindex="0" data-language="python"><code><span><span>&#34;&#34;&#34;Top-level package for everything.&#34;&#34;&#34;</span></span>
<span></span>
<span><span>__author__ </span><span>=</span><span> &#34;&#34;&#34;Wolf Mermelstein&#34;&#34;&#34;</span></span>
<span><span>__email__ </span><span>=</span><span> &#34;wolfmermelstein@gmail.com&#34;</span></span>
<span><span>__version__</span><span> =</span><span> &#34;0.1.0&#34;</span></span>
<span></span>
<span></span>
<span><span>from</span><span> typing </span><span>import</span><span> Callable</span></span>
<span><span>from</span><span> everything.generator </span><span>import</span><span> runtime_generate_function</span></span>
<span><span>import</span><span> sys</span></span>
<span></span>
<span><span>class</span><span> Everything</span><span>:</span></span>
<span><span>    def</span><span> __getattr__</span><span>(name: </span><span>str</span><span>) -&gt; Callable:</span></span>
<span><span>        return</span><span> runtime_generate_function(name)</span></span>
<span></span>
<span><span>sys.modules[</span><span>__name__</span><span>] </span><span>=</span><span> Everything()</span></span></code></pre>

<p>Now that it’s working, I’ve had the idea to take it to the next level by adding
a compilation step. Basically, I want to be able to import <code>everything</code>
throughout my codebase, and even submodules like <code>everything.finance.irr</code>, and
have my program <em>build</em> a library for you based on the way you use it.</p>
<p>The idea is that you can use a library that doesn’t exist as you want, and then
<code>everything</code> can “poof” it into existence by running something like
<code>everything build</code>. It would generate a <code>everything</code> folder with all the content
in it, so you could modify the code if necessary (but that’s against the spirit
of the library).</p>
<h2 id="improvements">Improvements</h2>
<p>There’s a lot of open questions on what I’d need to do to get this to work, and
how I can make it better. For one, I want to figure out how to give OpenAi
generated functions access to arbitrary Python libraries on PyPi. I also want to
be able to lint and verify the code, and black the code to format it.</p>

<p>So, I was thinking, wouldn’t it be so awesome if you literally could
<code>pip install everything</code>? Currently it’s
<a href="https://pypi.org/project/dothething/">dothething</a> on PyPi, which is kinda lame.</p>
<p>I looked into it, and it appears that <code>everything</code> was not taken on PyPi!
However, it’s reserved, probably to prevent name hoarding or abuse. I did a lot
of research on this, and found out about
<a href="https://peps.python.org/pep-0541/">PEP 541</a>, which is an approved Python PEP
(project enhancement proposal) for reclaiming unused or unmaintained namespaces
on PyPi. I made a request <a href="https://github.com/pypi/support/issues/4320">here</a>,
as a github issue, which is the method they suggest, and am currently waiting to
hear back.</p>
<p><img src="https://static.404wolf.com/2024-07-04-20240705021721024_0001.webp" alt="The guy!"/>
<img src="https://static.404wolf.com/2024-07-04-20240705021825560_0001.webp" alt="Reaching out"/></p>
<p>A bit more research scanning similar requests though, it doesn’t seem like PyPi
really handles 541 requests anymore. The requests pile up, but only the admins
can actually resolve them. This led me on a search to try to find an admin that
I might be able to contact directly to get the name <code>everything</code>. After a bit of
searching, I found Ee, the head of infrastructure for the Python Foundation, and
learned that he was a Recurse Center alum too. I reached out to him to see if
he’d be able to help, and current am waiting for a response.</p>  </div> </astro-slot></div></div>
  </body>
</html>
