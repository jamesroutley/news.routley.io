<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://colah.github.io/posts/2015-08-Backprop/">Original</a>
    <h1>Calculus on Computational Graphs: Backpropagation</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
                <div>
                    <div>
                        <div>
                            
                            <p>Posted on August 31, 2015</p>
<!--
The problem with just “summing over the paths” is that it’s very easy to get a combinatorial explosion in the number of possible paths.

<div style="width:70%; margin-left:auto; margin-right:auto; margin-bottom:17px; margin-top:17px;">
<img src="img/chain-def.png" alt="">
</div>

In the above diagram, there are three paths from $X$ to $Y$, and a further three paths from $Y$ to $Z$. If we want to get the derivative $\frac{\partial Z}{\partial X}$ by summing over all paths, we need to sum over $3*3 = 9$  paths:

$$\frac{\partial Z}{\partial X} = ad + ae + af + bd + be+bf + cd + ce + cf$$

The above only has nine paths, but it would be easy to have the number of paths to grow exponentially as the graph becomes more complicated.

Instead of just naively summing over the paths, it would be much better to factor them:

$$\frac{\partial Z}{\partial X} = (a+b+c)(d+e+f)$$

This is where "forward-mode differentiation" and "reverse-mode differentiation" come in. They’re algorithms for efficiently computing the sum by factoring the paths. Instead of summing over all of the paths explicitly, they compute the same sum more efficiently by merging paths back together as possible. In fact, both algorithms touch each edge exactly once!

Forward-mode differentiation starts at an input to the graph and moves towards the end. At every node, it sums all the paths feeding in. Each of those paths represents one way in which the input affects that node. By adding them up, we get the total way in which the node is affected by the input, it’s derivative.

<div style="width:70%; margin-left:auto; margin-right:auto; margin-bottom:17px; margin-top:17px;">
<img src="img/chain-forward.png" alt="">
</div>

Though you probably didn’t think of it in terms of graphs, forward-mode differentiation is very similar to what you implicitly learned to do if you took an introduction to calculus class.

Reverse-mode differentiation, on the other hand, starts at an output of the graph and moves towards the beginning. At each node, it merges all paths which originated at that node.

<div style="width:70%; margin-left:auto; margin-right:auto; margin-bottom:17px; margin-top:17px;">
<img src="img/chain-reverse.png" alt="">
</div>

Forward-mode differentiation tracks how one input affects every node. Reverse-mode differentiation tracks how every node affects one output. That is, forward-mode differentiation applies the operator $\frac{\partial}{\partial X}$ to every node, while reverse mode differentiation applies the operator $\frac{\partial Z}{\partial}$ to every node.[^DynamicProgramming]

[^DynamicProgramming]: This might feel a bit like [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming). That's because it is!
-->











































                        </div>
                        
                    </div>
                </div>
            </div></div>
  </body>
</html>
