<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jbaker.io/2022/06/09/vectors-in-java/">Original</a>
    <h1>SIMD accelerated sorting in Java – how it works and why it was 3x faster</h1>
    
    <div id="readability-page-1" class="page"><div>
        <div>
  
  <p><span>09 Jun 2022</span></p><p>In this post I explain a little about how to use Java’s Vector APIs, attempt to explain how they turn out fast, and then use them to implement a sorting algorithm 3x faster than <code>Arrays.sort</code>. I then explain some problems I found, and how I resolved them. Supporting code is published <a href="https://github.com/j-baker/vector-experiments">here</a>.</p>

<p>I’m an occasional reader of <a href="https://lemire.me">Daniel Lemire’s blog</a>. Many of his posts follow a standard pattern, where he takes some standard operation (json parsing, bitsets, existence filters, sorting, integer encoding), reforms it using vector operations and makes it vastly faster due to increasing the data level parallelism. It’s a fun read, and the numbers are scary high (most of us can only dream of writing code that processes 1GB/sec with a single core, let alone doing something useful in that time). Especially not in Java, where scalar code has usually been the only practical option in most cases.</p>

<p>There’s an ongoing OpenJDK project called <a href="https://openjdk.java.net/projects/panama/">Project Panama</a> which has been working on improving interop between the JVM and more ‘native’ APIs. One of their subprojects has focused on providing vectorized intrinsics within the JVM, and I decided to test out these APIs by trying to use them to implement sorting on integer arrays. Given there was a <a href="https://opensource.googleblog.com/2022/06/Vectorized%20and%20performance%20portable%20Quicksort.html">recent Google blogpost on a similar topic</a>, it seems like a good comparison point.</p>



<p>Java’s Vector API is currently distributed as a preview with recent versions of Java. To use it, you must append <code>--enable-preview --add-modules jdk.incubator.vector</code> to your <code>java</code> and <code>javac</code> commands.</p>

<p>With the exception of char, Java supports each numerical primitive type as a vector (byte, short, int, long, float, double), with the corresponding vector type being <code>*Vector</code>, like <code>IntVector</code>. In order to use vectors, one must choose a ‘species’, which represents the width. Java presently supports up to 512 bit vectors, so one might choose a specific width like <code>IntVector.SPECIES_256</code>, the maximum with <code>IntVector.SPECIES_MAX</code> or the maximum hardware accelerated size with <code>IntVector.SPECIES_PREFERRED</code>.</p>

<p>One can then use code like the below to process data.</p>

<div><div><pre><code><span>static</span> <span>final</span> <span>VectorSpecies</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>SPECIES</span> <span>=</span> <span>IntVector</span><span>.</span><span>SPECIES_256</span><span>;</span>

<span>void</span> <span>multiply</span><span>(</span><span>int</span><span>[]</span> <span>array</span><span>,</span> <span>int</span> <span>by</span><span>)</span> <span>{</span>
    <span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span>
    <span>int</span> <span>bound</span> <span>=</span> <span>SPECIES</span><span>.</span><span>loopBound</span><span>(</span><span>array</span><span>.</span><span>length</span><span>);</span>
    <span>IntVector</span> <span>byVector</span> <span>=</span> <span>IntVector</span><span>.</span><span>broadcast</span><span>(</span><span>SPECIES</span><span>,</span> <span>by</span><span>);</span>
    <span>for</span> <span>(;</span> <span>i</span> <span>&lt;</span> <span>bound</span><span>;</span> <span>i</span> <span>+=</span> <span>SPECIES</span><span>.</span><span>length</span><span>())</span> <span>{</span>
        <span>IntVector</span> <span>vec</span> <span>=</span> <span>IntVector</span><span>.</span><span>fromArray</span><span>(</span><span>SPECIES</span><span>,</span> <span>array</span><span>,</span> <span>i</span><span>);</span>
        <span>IntVector</span> <span>multiplied</span> <span>=</span> <span>vec</span><span>.</span><span>mul</span><span>(</span><span>byVector</span><span>);</span>
        <span>multiplied</span><span>.</span><span>intoArray</span><span>(</span><span>array</span><span>,</span> <span>i</span><span>);</span>
    <span>}</span>
    <span>for</span> <span>(;</span> <span>i</span> <span>&lt;</span> <span>array</span><span>.</span><span>length</span><span>;</span> <span>i</span><span>++)</span> <span>{</span>
        <span>array</span><span>[</span><span>i</span><span>]</span> <span>*=</span> <span>by</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>There are two other useful primitives. The first is <code>VectorMask</code> which you can think of as an array of booleans. Many of the methods can take masks to switch on or off behaviour on specific vector lanes, and predicates return masks.</p>

<div><div><pre><code><span>VectorSpecies</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>species</span> <span>=</span> <span>IntVector</span><span>.</span><span>SPECIES_64</span><span>;</span>
<span>IntVector</span> <span>vector</span> <span>=</span> <span>IntVector</span><span>.</span><span>broadcast</span><span>(</span><span>species</span><span>,</span> <span>1</span><span>);</span>
<span>VectorMask</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>mask</span> <span>=</span> <span>VectorMask</span><span>.</span><span>ofValues</span><span>(</span><span>species</span><span>,</span> <span>true</span><span>,</span> <span>false</span><span>);</span>
<span>IntVector</span> <span>result</span> <span>=</span> <span>vector</span><span>.</span><span>mul</span><span>(</span><span>0</span><span>,</span> <span>mask</span><span>);</span>
<span>assertThat</span><span>(</span><span>result</span><span>).</span><span>isEqualTo</span><span>(</span><span>IntVector</span><span>.</span><span>fromValues</span><span>(</span><span>species</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>));</span>
</code></pre></div></div>

<p>The second other useful type is <code>VectorShuffle</code>. This can be used to rearrange vector lanes. For example:</p>

<div><div><pre><code><span>VectorSpecies</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>species</span> <span>=</span> <span>IntVector</span><span>.</span><span>SPECIES_128</span><span>;</span>
<span>IntVector</span> <span>vector</span> <span>=</span> <span>IntVector</span><span>.</span><span>fromArray</span><span>(</span><span>species</span><span>,</span> <span>new</span> <span>int</span><span>[]</span> <span>{</span><span>12</span><span>,</span> <span>34</span><span>,</span> <span>56</span><span>,</span> <span>78</span><span>});</span>
<span>assertThat</span><span>(</span><span>vector</span><span>.</span><span>rearrange</span><span>(</span><span>VectorShuffle</span><span>.</span><span>fromValues</span><span>(</span><span>species</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>))).</span><span>isEqualTo</span><span>(</span><span>IntVector</span><span>.</span><span>fromArray</span><span>(</span><span>species</span><span>,</span> <span>new</span> <span>int</span><span>[]</span> <span>{</span><span>78</span><span>,</span> <span>56</span><span>,</span> <span>34</span><span>,</span> <span>12</span><span>}));</span>
</code></pre></div></div>



<p>The benefit of SIMD code is that we can process more data within a single instruction; for example with 256 bit instructions we can perhaps process 8 ints per cycle instead of 1. In the multiply example above, we have a
vectorized loop and a scalar loop. If the two loops are identical except in the scalar case we see an x86 <code>MUL</code> instruction being run and in the vectorized case we see a <code>PMULQ</code> instruction being run, we might expect to see the full benefit of the vectorization. However, the loop is represented as a number of new Java objects, and if we have to run even only 8 additional instructions to initialize the new objects, we’ve given away our advantage. Java’s vector APIs put a lot of effort into working well in this regard, and rely heavily on the following optimizations.</p>

<h2 id="inlining">Inlining</h2>

<p>Inlining is a simple, easy to understand compiler technique that can dramatically improve performance.</p>

<h3 id="what-is-inlining">What is inlining?</h3>

<p>When we inline a method, we are replacing a function call to that method with the definition of the function we are calling.</p>

<div><div><pre><code><span>boolean</span> <span>notInlined</span><span>(</span><span>String</span> <span>string</span><span>)</span> <span>{</span>
    <span>return</span> <span>string</span><span>.</span><span>isEmpty</span><span>()</span> <span>||</span> <span>string</span><span>.</span><span>length</span><span>()</span> <span>==</span> <span>1</span><span>;</span>
<span>}</span>

<span>boolean</span> <span>inlined</span><span>(</span><span>String</span> <span>string</span><span>)</span> <span>{</span>
    <span>return</span> <span>string</span><span>.</span><span>value</span><span>.</span><span>length</span> <span>==</span> <span>0</span> <span>||</span> <span>string</span><span>.</span><span>value</span><span>.</span><span>length</span> <span>==</span> <span>1</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h2 id="when-does-java-inline-functions">When does Java inline functions?</h2>

<p>There are a <a href="https://github.com/openjdk/jdk/blob/9583e3657e43cc1c6f2101a64534564db2a9bd84/src/hotspot/share/opto/bytecodeInfo.cpp#L116">number of heuristics</a> within Java that decide whether or not a function should be inlined. Some are as follows:</p>

<ul>
  <li>If a method has thrown many times, it is inlined. Presumably this is because the try-catch loop can be optimized.</li>
  <li>If a method A calls a method B many times more frequently (default 20x) than the outer method is called, it is inlined unless its definition is very large (&gt; 335 JVM opcodes).</li>
  <li>If a method is very small (&lt;=35 opcodes) it is inlined.</li>
</ul>

<p>Virtual methods make this all harder, but various other analyses help with this.</p>

<p>There is also a magic Java-internal annotation that helps with inlining; <code>@ForceInline</code>. If this annotation is applied, and the class it is applied to comes from the ‘boot classloader’ (your application does not), then the data will be inlined.</p>

<h2 id="why-is-it-so-much-better-when-a-function-can-be-inlined">Why is it so much better when a function can be inlined?</h2>

<p>There are two key improvements that inlining can lead to. The first is that it avoids the function call overhead. Calling a function is cheap but not free because various book-keeping must be done (flushing registers to the stack, moving the program counter to the other function, restoring when it completes, etc). Once we’ve inlined a function, these costs disappear.</p>

<p>The second improvement is arguably far more important (and is why inlining is sometimes referred to as ‘the mother of all optimizations’) - because we’ve inlined the function, the compiler possibly has more information, enabling further optimizations. For example, in the above case in psuedo-Java, the method ‘inlined’ is equivalent to:</p>

<div><div><pre><code><span>boolean</span> <span>inlined</span><span>(</span><span>String</span> <span>string</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>string</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>();</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>arrayLength</span><span>(</span><span>string</span><span>.</span><span>value</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span> <span>// let&#39;s assume the compiler knows that String.value is never null, because the constructors never let it be so.</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>arrayLength</span><span>(</span><span>string</span><span>.</span><span>value</span><span>)</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>In this instance, the compiler will likely be able to intuit that arrayLength will not change between the two calls. It will likely also know that an array length cannot be less than 0. The compiler therefore may execute this code as:</p>

<div><div><pre><code><span>boolean</span> <span>inlined</span><span>(</span><span>String</span> <span>string</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>string</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>();</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>arrayLength</span><span>(</span><span>string</span><span>.</span><span>value</span><span>)</span> <span>&lt;=</span> <span>1</span><span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>which ensures that not only is the function call overhead avoided, but also that the method is simpler. This optimization is used all over the place; null checks can be avoided when it’s known that the value is not null, shared parts of methods can avoid being re-executed, etc.</p>

<h2 id="escape-analysis-and-scalar-replacement">Escape analysis and scalar replacement</h2>

<p>Escape analysis is a compiler technique that can be used to gain information about the lifetimes of objects. When we create an object inside a function, its lifetime is either shorter than the scope of the function, or longer. If it is possibly longer, we say that it <code>escapes</code>. If we know that an object does not escape, there are other optimizations we can do. One that Java performs is called ‘scalar replacement’ - roughly, it can entirely avoid creating the object and instead allocate any containing fields as stack variables.</p>

<p>For example, these two methods are semantically identical, and might be compiled as such.</p>

<div><div><pre><code><span>Optional</span><span>&lt;</span><span>String</span><span>&gt;</span> <span>withoutScalarReplacement</span><span>(</span><span>String</span> <span>someString</span><span>)</span> <span>{</span>
    <span>return</span> <span>Optional</span><span>.</span><span>ofNullable</span><span>(</span><span>someString</span><span>).</span><span>map</span><span>(</span><span>String:</span><span>:</span><span>trim</span><span>).</span><span>filter</span><span>(</span><span>String:</span><span>:</span><span>isEmpty</span><span>);</span>
<span>}</span>

<span>Optional</span><span>&lt;</span><span>String</span><span>&gt;</span> <span>withScalarReplacement</span><span>(</span><span>String</span> <span>someString</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>someString</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>Optional</span><span>.</span><span>empty</span><span>();</span>
    <span>}</span>
    <span>String</span> <span>trimmed</span> <span>=</span> <span>someString</span><span>.</span><span>trim</span><span>();</span>
    <span>if</span> <span>(</span><span>trimmed</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>Optional</span><span>.</span><span>empty</span><span>();</span>
    <span>}</span>
    <span>if</span> <span>(!</span><span>trimmed</span><span>.</span><span>isEmpty</span><span>())</span> <span>{</span>
        <span>return</span> <span>Optional</span><span>.</span><span>empty</span><span>();</span>
    <span>}</span>
    <span>return</span> <span>Optional</span><span>.</span><span>of</span><span>(</span><span>trimmed</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>In this example, we are able to fully avoid allocating two different intermediate <code>Optional</code> objects. Scalar replacement can mostly only be useful when inlining occurs. For example, in the above, <code>Optional.ofNullable</code> possibly allocates an <code>Optional</code>, which escapes. The implementation cannot avoid this allocation. If it is inlined, the object may no longer escape and therefore the scalar replacement may be viable.</p>

<h2 id="intrinsics">Intrinsics</h2>

<p>In the Java standard library, many methods have a pure-Java implementation, and an ‘intrinsic’ implementation. Sometimes the intrinsic might be pure C++, sometimes assembly. The rough idea is that certain methods are called so frequently in Java or are so important to be fast, that we shouldn’t rely on the compiler producing the right code; the JVM should contain a native implementation that is known to have the right properties that is to be used instead. When these methods are compiled, the intrinsic is substituted in. The availability of an intrinsic can be denoted via the <code>@IntrinsicCandidate</code> annotation.</p>



<p>Each <code>IntVector</code> object in Java contains an <code>int[]</code> which represents the vector. There are pure Java implementations of each of the vector operations - check <code>IntVector.binaryOperations(int)</code> for the definitions of the binary lanewise operations. However, these are designed to be only a fallback - they are primarily called by methods like <code>VectorSupport.binaryOp</code> which has the magic annotation <code>@IntrinsicCandidate</code>. In other words, if these vectorized methods are run on a system with relevant SIMD functionality (e.g. when AVX2 or NEON is supported), then they will be replaced with native implementations.</p>

<p>Furthermore, all of the relevant vector methods (<code>fromArray</code>, <code>intoArray</code>, <code>mul</code>, <code>rearrange</code>, …) have <code>@ForceInline</code> applied to them, so the definitions will be dropped directly into the code that calls them, enabling the scalar replacement. At this point, the fake <code>int[]</code> buffer can also be dropped at the time of register allocation, and made a stack variable, in the same way as other primitives.</p>

<p>In conclusion, when we use the vector API, everything gets inlined. This gives the compiler the most it can have to work with so as to remove enough function call overhead to actually compile a vector operation to only a couple of instructions. Practically speaking, you end up with code that looks like it creates many objects, but actually compiles to code that allocates no memory. It is extremely disconcerting.</p>



<p>For purposes of this exercise, I’m going to expend my effort primarily on the operation of partitioning. I select the pivots by sampling 8 elements and using their median. I also decided to not go down the path of empirically trying to find patterns, because my goal is to exercise the SIMD operations and not to build a production sorting algorithm.</p>

<p>A simple in-place quicksort algorithm can be summarized as follows:</p>

<div><div><pre><code><span>void</span> <span>quicksort</span><span>(</span><span>int</span><span>[]</span> <span>array</span><span>,</span> <span>int</span> <span>from</span><span>,</span> <span>int</span> <span>to</span><span>)</span> <span>{</span>
    <span>int</span> <span>size</span> <span>=</span> <span>to</span> <span>-</span> <span>from</span><span>;</span>
    <span>if</span> <span>(</span><span>size</span> <span>&lt;=</span> <span>1</span><span>)</span> <span>{</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>int</span> <span>pivot</span> <span>=</span> <span>partition</span><span>(</span><span>array</span><span>,</span> <span>from</span><span>,</span> <span>to</span><span>);</span>
    <span>quicksort</span><span>(</span><span>array</span><span>,</span> <span>from</span><span>,</span> <span>pivot</span><span>);</span>
    <span>quicksort</span><span>(</span><span>array</span><span>,</span> <span>pivot</span> <span>+</span> <span>1</span><span>,</span> <span>to</span><span>);</span>
<span>}</span>

<span>int</span> <span>partition</span><span>(</span><span>int</span><span>[]</span> <span>array</span><span>,</span> <span>int</span> <span>from</span><span>,</span> <span>int</span> <span>to</span><span>)</span> <span>{</span>
    <span>int</span> <span>pivot</span> <span>=</span> <span>array</span><span>[</span><span>to</span> <span>-</span> <span>1</span><span>];</span>
    <span>int</span> <span>boundary</span> <span>=</span> <span>partition</span><span>(</span><span>array</span><span>,</span> <span>pivot</span><span>,</span> <span>from</span><span>,</span> <span>to</span> <span>-</span> <span>1</span><span>);</span>
    <span>int</span> <span>temp</span> <span>=</span> <span>array</span><span>[</span><span>boundary</span><span>];</span>
    <span>array</span><span>[</span><span>to</span> <span>-</span> <span>1</span><span>]</span> <span>=</span> <span>temp</span><span>;</span>
    <span>array</span><span>[</span><span>boundary</span><span>]</span> <span>=</span> <span>pivot</span><span>;</span>
    <span>return</span> <span>boundary</span><span>;</span>
<span>}</span>

<span>int</span> <span>partition</span><span>(</span><span>int</span><span>[]</span> <span>array</span><span>,</span> <span>int</span> <span>pivot</span><span>,</span> <span>int</span> <span>lowerPointer</span><span>,</span> <span>int</span> <span>upperPointer</span><span>)</span> <span>{</span>
    <span>while</span> <span>(</span><span>lowerPointer</span> <span>&lt;</span> <span>upperPointer</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>array</span><span>[</span><span>lowerPointer</span><span>]</span> <span>&lt;</span> <span>pivot</span><span>)</span> <span>{</span>
            <span>lowerPointer</span><span>++;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>array</span><span>[</span><span>upperPointer</span> <span>-</span> <span>1</span><span>]</span> <span>&gt;=</span> <span>pivot</span><span>)</span> <span>{</span>
            <span>upperPointer</span><span>--;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>int</span> <span>tmp</span> <span>=</span> <span>array</span><span>[</span><span>lowerPointer</span><span>];</span>
            <span>int</span> <span>index</span> <span>=</span> <span>--</span><span>upperPointer</span><span>;</span>
            <span>array</span><span>[</span><span>lowerPointer</span><span>++]</span> <span>=</span> <span>array</span><span>[</span><span>index</span><span>];</span>
            <span>array</span><span>[</span><span>index</span><span>]</span> <span>=</span> <span>tmp</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>lowerPointer</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>For purposes of vectorizing, I’m primarily looking at reimplementing the ‘partition’ method. I also implement a special sorting function for regions &lt;= 8 elements using a sorting network.</p>

<h2 id="vectorizing-the-partition-method">Vectorizing the partition method</h2>

<p>We’re trying to replace the partition method. The purpose is to reorder a list of items such that it contains a contiguous region of items less than the pivot argument, followed by a contiguous region of items greater than the pivot argument. If we can partition a single vector, we can expand this to the whole array.</p>

<h3 id="partitioning-a-single-8-lane-vector">Partitioning a single 8-lane vector</h3>

<p>There is an AVX512 instruction which is absolutely perfect for this specific task. It’s called <code>VPCOMPRESSQ</code> and development versions of Java expose it as <code>.compress()</code>, like:</p>

<div><div><pre><code><span>IntVector</span> <span>vec</span><span>;</span>
<span>VectorMask</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>lessThan</span> <span>=</span> <span>vec</span><span>.</span><span>lt</span><span>(</span><span>pivot</span><span>);</span>
<span>IntVector</span> <span>lt</span> <span>=</span> <span>vec</span><span>.</span><span>compress</span><span>(</span><span>lessThan</span><span>);</span>
<span>IntVector</span> <span>gte</span> <span>=</span> <span>vec</span><span>.</span><span>compress</span><span>(</span><span>lessThan</span><span>.</span><span>not</span><span>());</span>
</code></pre></div></div>

<p>My computer does not have AVX512 and without hardware acceleration it executes incredibly slowly (&gt;20ns rather than the 0.25ns I’d expect). So, we must work around! To work around, we can leverage the fact that for any mask, there is a permutation of the lanes which leads to all the ‘trues’ in the mask appearing before all the ‘falses’. For example, if the mask reads <code>FFFFFFFT</code>, such a permutation might be <code>[7, 1, 2, 3, 4, 5, 6, 0]</code>. We can create such a mask using the following code:</p>

<div><div><pre><code><span>VectorShuffle</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>partitioner</span><span>(</span><span>VectorMask</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>vectorMask</span><span>)</span> <span>{</span>
    <span>VectorSpecies</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>species</span> <span>=</span> <span>vectorMask</span><span>.</span><span>species</span><span>();</span>
    <span>int</span> <span>numTrues</span> <span>=</span> <span>vectorMask</span><span>.</span><span>trueCount</span><span>();</span>

    <span>int</span> <span>mask</span> <span>=</span> <span>(</span><span>int</span><span>)</span> <span>vectorMask</span><span>.</span><span>toLong</span><span>();</span> <span>// bit 2^n is set to true iff lane n is set in the mask.</span>
    <span>int</span><span>[]</span> <span>ret</span> <span>=</span> <span>new</span> <span>int</span><span>[</span><span>species</span><span>.</span><span>length</span><span>()];</span>
    <span>int</span> <span>unmatchedIndex</span> <span>=</span> <span>numTrues</span><span>;</span>
    <span>int</span> <span>matchedIndex</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>species</span><span>.</span><span>length</span><span>();</span> <span>i</span><span>++)</span> <span>{</span>
        <span>if</span> <span>((</span><span>mask</span> <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>ret</span><span>[</span><span>unmatchedIndex</span><span>++]</span> <span>=</span> <span>i</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>ret</span><span>[</span><span>matchedIndex</span><span>++]</span> <span>=</span> <span>i</span><span>;</span>
        <span>}</span>
        <span>mask</span> <span>&gt;&gt;=</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>VectorShuffle</span><span>.</span><span>fromValues</span><span>(</span><span>species</span><span>,</span> <span>ret</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>We have an 8-lane vector, so the total possible number of such shuffles is <code>2^8 = 256</code>. Each shuffle is conceptually 8 bytes, and so cumulatively this would need around 1kB, probably around 4kB with overheads, easily small enough to fit in L1 cache as a lookup table.</p>

<p>We can therefore implement a similar partitioning process using:</p>

<div><div><pre><code><span>IntVector</span> <span>vec</span><span>;</span>
<span>VectorMask</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>lessThan</span> <span>=</span> <span>vec</span><span>.</span><span>lt</span><span>(</span><span>pivot</span><span>);</span>
<span>IntVector</span> <span>rearranged</span> <span>=</span> <span>vec</span><span>.</span><span>rearrange</span><span>(</span><span>partitions</span><span>[(</span><span>int</span><span>)</span> <span>lessThan</span><span>.</span><span>toLong</span><span>()]);</span>
</code></pre></div></div>

<h3 id="partitioning-two-partitioned-8-lane-vectors">Partitioning two partitioned 8-lane vectors</h3>

<p>n.b. this approach can also be used to partition a single 16 lane vector without a giant lookup table.</p>

<p>If we have two partitioned vectors and know how many elements less than the pivot each contains, we can easily merge them into a single partitioned vector.</p>

<div><div><pre><code><span>IntVector</span> <span>vec1</span><span>;</span>
<span>int</span> <span>numTrues1</span><span>;</span>
<span>IntVector</span> <span>vec2</span><span>;</span>
<span>int</span> <span>numTrues2</span><span>;</span>

<span>IntVector</span> <span>rotatedVec2</span> <span>=</span> <span>vec2</span><span>.</span><span>rearrange</span><span>(</span><span>rotate</span><span>(</span><span>numTrues1</span><span>));</span>
<span>VectorMask</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>mask</span> <span>=</span> <span>VectorMask</span><span>.</span><span>fromLong</span><span>(</span><span>species</span><span>,</span> <span>(</span><span>1L</span> <span>&lt;&lt;</span> <span>numTrues1</span><span>)</span> <span>-</span> <span>1</span><span>).</span><span>not</span><span>();</span>
<span>IntVector</span> <span>left</span> <span>=</span> <span>vec1</span><span>.</span><span>blend</span><span>(</span><span>rotatedVec2</span><span>,</span> <span>mask</span><span>);</span> <span>// blend takes the elements that the mask allows from the argument and the others from the base vector</span>
<span>IntVector</span> <span>right</span> <span>=</span> <span>rotatedVec2</span><span>.</span><span>blend</span><span>(</span><span>vec1</span><span>,</span> <span>mask</span><span>);</span>
</code></pre></div></div>

<h3 id="extending-partitioning-16-elements-to-a-whole-array">Extending partitioning 16 elements to a whole array</h3>

<p>The best approach I was able to come up here is one where I tried to avoid doing any unnecessary vector operations. From the left of the array, I read two vectors and partition them. At this point (example has 8 lanes), inside them there are either &gt;8 (1) or &lt;=8 (2) elements that are less than the pivot.</p>

<p>In case 1, every element in the left vector is less than the pivot. We can write it back into the array and increment the <code>from</code> pointer like in the simplified algorithm above. Some elements in the right array are less than and some are greater than the pivot. In case 2, we have the opposite - all elements on the right side are greater than the pivot, and so we swap that vector to the back and continue. Special casing the case where we can process two vectors at a time did not improve performance. This can be thought of as being very similar to the scalar algorithm.</p>

<div><div><pre><code><span>IntVector</span> <span>compareTo</span> <span>=</span> <span>IntVector</span><span>.</span><span>broadcast</span><span>(</span><span>SPECIES</span><span>,</span> <span>pivot</span><span>);</span>

<span>IntVector</span> <span>cachedVector</span><span>;</span>
<span>int</span> <span>cachedNumTrues</span><span>;</span>
<span>boolean</span> <span>initialize</span> <span>=</span> <span>true</span><span>;</span>
<span>while</span> <span>(</span><span>index</span> <span>+</span> <span>SPECIES</span><span>.</span><span>length</span><span>()</span> <span>&lt;</span> <span>upperBound</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>initialize</span><span>)</span> <span>{</span>
        <span>initialize</span> <span>=</span> <span>false</span><span>;</span>
        <span>// load our first vector and partition it</span>
        <span>cachedVector</span> <span>=</span> <span>IntVector</span><span>.</span><span>fromArray</span><span>(</span><span>SPECIES</span><span>,</span> <span>array</span><span>,</span> <span>index</span><span>);</span>
        <span>VectorMask</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>cachedMask</span> <span>=</span> <span>cachedVector</span><span>.</span><span>lt</span><span>(</span><span>compareTo</span><span>);</span>
        <span>cachedVector</span> <span>=</span> <span>cachedVector</span><span>.</span><span>rearrange</span><span>(</span><span>IntVectorizedQuickSort</span><span>.</span><span>compress</span><span>(</span><span>cachedMask</span><span>));</span>
        <span>cachedNumTrues</span> <span>=</span> <span>cachedMask</span><span>.</span><span>trueCount</span><span>();</span>
    <span>}</span>

    <span>// partition our second vector</span>
    <span>int</span> <span>index2</span> <span>=</span> <span>index</span> <span>+</span> <span>SPECIES</span><span>.</span><span>length</span><span>();</span>
    <span>IntVector</span> <span>vector2</span> <span>=</span> <span>IntVector</span><span>.</span><span>fromArray</span><span>(</span><span>SPECIES</span><span>,</span> <span>array</span><span>,</span> <span>index2</span><span>);</span>
    <span>VectorMask</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>mask2</span> <span>=</span> <span>vector2</span><span>.</span><span>lt</span><span>(</span><span>compareTo</span><span>);</span>
    <span>int</span> <span>numTrues2</span> <span>=</span> <span>mask2</span><span>.</span><span>trueCount</span><span>();</span>
    <span>IntVector</span> <span>rearranged2</span> <span>=</span> <span>vector2</span><span>.</span><span>rearrange</span><span>(</span><span>IntVectorizedQuickSort</span><span>.</span><span>compress</span><span>(</span><span>mask2</span><span>));</span>

    <span>// merge our two partitioned vectors</span>
    <span>VectorMask</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>mask</span> <span>=</span> <span>IntVectorizedQuickSort</span><span>.</span><span>lowerOverflowMask</span><span>(</span><span>cachedNumTrues</span><span>);</span>
    <span>IntVector</span> <span>rotated</span> <span>=</span> <span>rearranged2</span><span>.</span><span>rearrange</span><span>(</span><span>IntVectorizedQuickSort</span><span>.</span><span>rotateRight</span><span>(</span><span>cachedNumTrues</span><span>));</span>
    <span>IntVector</span> <span>merged1</span> <span>=</span> <span>cachedVector</span><span>.</span><span>blend</span><span>(</span><span>rotated</span><span>,</span> <span>mask</span><span>);</span>
    <span>IntVector</span> <span>merged2</span> <span>=</span> <span>rotated</span><span>.</span><span>blend</span><span>(</span><span>cachedVector</span><span>,</span> <span>mask</span><span>);</span>

    <span>int</span> <span>totalTrues</span> <span>=</span> <span>cachedNumTrues</span> <span>+</span> <span>numTrues2</span><span>;</span>
    <span>if</span> <span>(</span><span>totalTrues</span> <span>&lt;</span> <span>SPECIES</span><span>.</span><span>length</span><span>())</span> <span>{</span> <span>// merged2 contains only elements greater than the pivot. Swap it to the end of the array and continue</span>
        <span>cachedVector</span> <span>=</span> <span>merged1</span><span>;</span>
        <span>cachedNumTrues</span> <span>=</span> <span>totalTrues</span><span>;</span>
        <span>upperBound</span> <span>-=</span> <span>SPECIES</span><span>.</span><span>length</span><span>();</span>
        <span>IntVector</span> <span>newData</span> <span>=</span> <span>IntVector</span><span>.</span><span>fromArray</span><span>(</span><span>SPECIES</span><span>,</span> <span>array</span><span>,</span> <span>upperBound</span><span>);</span>
        <span>newData</span><span>.</span><span>intoArray</span><span>(</span><span>array</span><span>,</span> <span>index2</span><span>);</span>
        <span>merged2</span><span>.</span><span>intoArray</span><span>(</span><span>array</span><span>,</span> <span>upperBound</span><span>);</span>
    <span>}</span> <span>else</span> <span>{</span> <span>// merged1 contains only elements less than the pivot. Move forwards</span>
        <span>cachedVector</span> <span>=</span> <span>merged2</span><span>;</span>
        <span>cachedNumTrues</span> <span>=</span> <span>totalTrues</span> <span>-</span> <span>SPECIES</span><span>.</span><span>length</span><span>();</span>
        <span>merged1</span><span>.</span><span>intoArray</span><span>(</span><span>array</span><span>,</span> <span>index</span><span>);</span>
        <span>index</span> <span>+=</span> <span>SPECIES</span><span>.</span><span>length</span><span>();</span>
    <span>}</span>
</code></pre></div></div>

<p>The rest is just edge cases.</p>

<h3 id="what-about-a-non-in-place-version">What about a non-in-place version?</h3>

<p>The sorting algorithm I describe above is an in-place algorithm, so it requires no additional memory. If we allow ourselves O(n) extra memory, we have a simpler algorithm. Here, the critical loop looks like:</p>

<div><div><pre><code><span>int</span> <span>leftOffset</span> <span>=</span> <span>from</span><span>;</span>
<span>int</span> <span>rightOffset</span> <span>=</span> <span>0</span><span>;</span>
<span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>from</span><span>;</span> <span>i</span> <span>&lt;</span> <span>upperBound</span><span>;</span> <span>i</span> <span>+=</span> <span>SPECIES</span><span>.</span><span>length</span><span>())</span> <span>{</span>
    <span>IntVector</span> <span>vec</span> <span>=</span> <span>IntVector</span><span>.</span><span>fromArray</span><span>(</span><span>SPECIES</span><span>,</span> <span>array</span><span>,</span> <span>i</span><span>);</span>
    <span>VectorMask</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>mask</span> <span>=</span> <span>compareTo</span><span>.</span><span>compare</span><span>(</span><span>VectorOperators</span><span>.</span><span>GT</span><span>,</span> <span>vec</span><span>);</span>
    <span>IntVector</span> <span>matching</span> <span>=</span> <span>compress</span><span>(</span><span>mask</span><span>,</span> <span>vec</span><span>);</span>
    <span>IntVector</span> <span>notMatching</span> <span>=</span> <span>reverse</span><span>(</span><span>vec</span><span>);</span>
    <span>matching</span><span>.</span><span>intoArray</span><span>(</span><span>array</span><span>,</span> <span>leftOffset</span><span>);</span>
    <span>notMatching</span><span>.</span><span>intoArray</span><span>(</span><span>buffer</span><span>,</span> <span>rightOffset</span><span>);</span>
    <span>int</span> <span>matchCount</span> <span>=</span> <span>mask</span><span>.</span><span>trueCount</span><span>();</span>
    <span>leftOffset</span> <span>+=</span> <span>matchCount</span><span>;</span>
    <span>rightOffset</span> <span>+=</span> <span>SPECIES</span><span>.</span><span>length</span><span>()</span> <span>-</span> <span>matchCount</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>In words, we’re moving the lower elements into their final position and the upper elements into a buffer. Once we’re done processing, we can copy the upper elements into their appropriate place. This algorithm is somewhat faster, to the tune of 10 cycles per iteration (~1 cycle per int per partitioning operation), although it appears to be much faster only on larger arrays.</p>



<p>Great! YMMV, but on my Zen3 desktop (using AVX2 with no AVX512 functionality), I saw the following results:</p>

<div><div><pre><code>Benchmark               (length)   Mode  Cnt           Score          Error  Units
jdk              8  thrpt    5   170714899.546 ±   1763875.997  ops/s
jdk             10  thrpt    5   154264407.313 ±    500819.241  ops/s
jdk            100  thrpt    5    69536931.152 ±   5248268.260  ops/s
jdk           1000  thrpt    5    46402055.294 ±    174077.215  ops/s
jdk          10000  thrpt    5    34134138.728 ±    188221.976  ops/s
jdk         100000  thrpt    5    28013585.553 ±     49562.094  ops/s
jdk        1000000  thrpt    5    23439276.552 ±     21704.859  ops/s
buffered         8  thrpt    5  2426909167.588 ±  14904754.115  ops/s
buffered        10  thrpt    5   200646786.158 ±  46948027.100  ops/s
buffered       100  thrpt    5   107955736.666 ±    968960.902  ops/s
buffered      1000  thrpt    5    89037645.967 ±   1329267.539  ops/s
buffered     10000  thrpt    5    79148716.685 ±    105261.243  ops/s
buffered    100000  thrpt    5    70237129.982 ±    149517.060  ops/s
buffered   1000000  thrpt    5    65537322.850 ±   3437058.994  ops/s
inplace          8  thrpt    5  2507547203.755 ± 383141136.258  ops/s
inplace         10  thrpt    5   215032676.207 ±    320366.428  ops/s
inplace        100  thrpt    5   114147458.514 ±    843670.046  ops/s
inplace       1000  thrpt    5    77580105.869 ±  10698901.290  ops/s
inplace      10000  thrpt    5    66624691.684 ±    197844.229  ops/s
inplace     100000  thrpt    5    54046743.796 ±   4568646.180  ops/s
inplace    1000000  thrpt    5    41139103.464 ±    464187.831  ops/s
hybrid           8  thrpt    5  2495687921.669 ± 186468040.821  ops/s
hybrid          10  thrpt    5   227652656.154 ±    382682.821  ops/s
hybrid         100  thrpt    5   108415081.740 ±    274307.588  ops/s
hybrid        1000  thrpt    5    92006274.816 ±    389174.105  ops/s
hybrid       10000  thrpt    5    82193216.008 ±     84009.870  ops/s
hybrid      100000  thrpt    5    74267051.943 ±   9385926.923  ops/s
hybrid     1000000  thrpt    5    69021089.102 ±   7740152.825  ops/s
</code></pre></div></div>

<p>The units are ‘ints sorted per second’, so 10M with a length of 1M means that we can sort 10 arrays per second. Here, <code>jdk</code> is the standard <code>Arrays.sort</code> whereas <code>inplace</code> uses solely in-place partitioning, <code>buffered</code> prioritizes sequential access at the cost of more memory moves, and <code>hybrid</code> uses buffered for larger partition operations, inplace for smaller ones. There’s a nice SIMD speedup at every level, with large arrays in the region of 3x faster than the JDK method and a 2x improvement on all but the smallest arrays.</p>



<p>Programming against the vector APIs without shooting myself in the foot was a huge challenge. Getting to the scores achieved required me to be comfortable with a variety of tools including:</p>

<ol>
  <li>Java Microbenchmarking Harness (JMH) (used to run benchmarks).</li>
  <li>Java Flight Recorder/Java Mission Control (used to check for any stray memory allocations from IntVector objects that weren’t optimized away).</li>
  <li>Linux Perf (to check if my improvements actually led to the number of cycles dropping).</li>
  <li>Java’s ability to print its compiler output as assembly (to see what’s actually going on under the hood).</li>
</ol>

<p>This took a while - it took me many iterations to get the algorithm to good, I learned a bunch about what works and what I found challenging and feel that I know how Java works considerably better.</p>

<h2 id="inlining-can-optimize-code-but-not-memory-layouts">Inlining can optimize code, but not memory layouts!</h2>

<p>Our single vector partition operation ends up with this chunk:</p>

<div><div><pre><code><span>v1</span> <span>=</span> <span>v1</span><span>.</span><span>rearrange</span><span>(</span><span>compressions</span><span>[(</span><span>int</span><span>)</span> <span>mask1</span><span>.</span><span>toLong</span><span>()]);</span>
</code></pre></div></div>

<p>If we unbox all the object references, it looks more like:</p>

<div><div><pre><code><span>v1</span> <span>=</span> <span>v1</span><span>.</span><span>rearrange</span><span>(</span><span>compressions</span><span>[(</span><span>int</span><span>)</span> <span>mask1</span><span>.</span><span>toLong</span><span>()].</span><span>array</span><span>)</span>
</code></pre></div></div>

<p>so we have a non-ideal pointer follow. Worse, the mask is stored in memory as a byte array, but in order for the rearrange instruction (<code>vpermd</code>) to properly operate, the mask must be encoded as an 8-element vector, too, which means it must be reformatted.</p>

<p>So the sequence of instructions we end up with looks like</p>

<div><div><pre><code>movabsq ; load the reference to the mask stored in compressions
vmovq ; load the (64-bit) shuffle into a 128 bit register
vpmovzxbd ; expand the 8-bit numbers into the 256 bit register, ready for the permutation
vpermd ; actually run the permutation operation
</code></pre></div></div>

<p>The part that is sub-optimal is the <code>vpmovzxbd</code> instruction. This instruction takes 4 cycles on my processor. If we could store the bytes pre-unpacked in RAM (since the overall amount of memory is small) we could have the instructions look more like:</p>

<div><div><pre><code>vmovdqu ; just straight up load the relevant offsets
vpermd ;
</code></pre></div></div>

<p>My suspicion is that the vector APIs are probably more optimized towards numerical operations like matrix multiplication, and less towards integer bit twiddling type approaches, which is why we see lookup tables underperform. My suspicion was that a <code>VectorShuffleList</code> or <code>VectorMaskList</code> could be helpful for this purpose. To test this approach I <a href="https://github.com/j-baker/jdk/commit/700679eabdf4dfa1af387e658961655713c025a8">modified the JDK</a> to add a new <code>VectorOperators.PERM</code> which does not require the boxing. Hacky, yes, but required only 48 lines of diff to prove the concept.</p>

<p>The performance improvement varied. In the tightest loops, there was very little change. In these cases, the instruction count went down considerably, but the cycle count did not change, indicating the processor simply picking up slack. When ILP is already high and we’re bound by execution ports, we see a much bigger difference. When applied to in-place sorting, the performance difference was around 10% overall, which is a significant number of cycles.</p>

<p>I had the same problem with masks, but it turned out to be simple to recompute the mask on each iteration.</p>

<h2 id="lengthvalidity-checks-slow-everything-down-especially-vector-shuffles">Length/validity checks slow everything down (especially vector shuffles)</h2>

<p>There’s a parallel between this issue and the previous one. As is usual in Java, various validity checks occur at runtime. In usual cases, solid CPU engineering (superscalar execution, branch prediction, etc) means that these checks do not massively affect runtime. However, shuffles have extra validity checks which are always performed. Specifically, running</p>

<div><div><pre><code><span>vector</span><span>.</span><span>rearrange</span><span>(</span><span>someShuffle</span><span>);</span>
</code></pre></div></div>

<p>is equivalent to</p>

<div><div><pre><code><span>checkState</span><span>(!</span><span>someShuffle</span><span>.</span><span>toVector</span><span>().</span><span>lt</span><span>(</span><span>0</span><span>).</span><span>anyTrue</span><span>());</span> <span>// make sure that none of the shuffle indices are &#39;exceptional&#39; aka negative.</span>
<span>vector</span><span>.</span><span>rearrange</span><span>(</span><span>someShuffle</span><span>);</span>
</code></pre></div></div>

<p>and this is expensive in a tight loop because it adds a non-trivial number of instructions. In fact, the cost is serious enough that there is a system property (<code>jdk.incubator.vector.VECTOR_ACCESS_OOB_CHECK</code>) which when set to 0 disables these checks. With the checks, it takes an average of 12.14 cycles and 50 instructions to partition a single vector. Without, it takes 7.7 cycles and 32 instructions. Unfortunately, disabling the checks is unsafe; out of bounds accesses can trigger segfaults.</p>

<p>This is another example where the type hierarchy used hurts the implementation. With a shufflelist or similar, the validation could occur at construction time.</p>

<h2 id="forceinline-for-thee-but-not-for-me"><code>@ForceInline</code> for thee but not for me?</h2>

<p>For the small cases (&lt;=8 elements) I implemented a sorting network using a single vector. As a part of this implementation, I implemented a ‘compare and exchange’ method as follows.</p>

<div><div><pre><code><span>IntVector</span> <span>compareAndExchange</span><span>(</span><span>IntVector</span> <span>vector</span><span>,</span> <span>VectorShuffle</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>shuffle</span><span>,</span> <span>VectorMask</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>mask</span><span>)</span> <span>{</span>
    <span>IntVector</span> <span>vector1</span> <span>=</span> <span>vector</span><span>.</span><span>rearrange</span><span>(</span><span>shuffle</span><span>);</span>
    <span>return</span> <span>vector</span><span>.</span><span>min</span><span>(</span><span>vector1</span><span>).</span><span>blend</span><span>(</span><span>vector</span><span>.</span><span>max</span><span>(</span><span>vector1</span><span>),</span> <span>mask</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Here, the shuffle and mask have been precomputed - shuffle connects the lanes as necessary, and mask selects the lower or higher outputs as necessary, leading to a method that might look like:</p>

<div><div><pre><code><span>static</span> <span>void</span> <span>sort16</span><span>(</span><span>int</span><span>[]</span> <span>array</span><span>,</span> <span>int</span> <span>from</span><span>)</span> <span>{</span>
    <span>IntVector</span> <span>v0</span> <span>=</span> <span>IntVector</span><span>.</span><span>fromArray</span><span>(</span><span>SPECIES_16</span><span>,</span> <span>array</span><span>,</span> <span>from</span><span>);</span>
    <span>IntVector</span> <span>v1</span> <span>=</span> <span>compareAndExchange</span><span>(</span><span>v0</span><span>,</span> <span>COMPARISON_16_1_S</span><span>,</span> <span>COMPARISON_16_1_M</span><span>);</span>
    <span>IntVector</span> <span>v2</span> <span>=</span> <span>compareAndExchange</span><span>(</span><span>v1</span><span>,</span> <span>COMPARISON_16_2_S</span><span>,</span> <span>COMPARISON_16_2_M</span><span>);</span>
    <span>IntVector</span> <span>v3</span> <span>=</span> <span>compareAndExchange</span><span>(</span><span>v2</span><span>,</span> <span>COMPARISON_16_3_S</span><span>,</span> <span>COMPARISON_16_3_M</span><span>);</span>
    <span>IntVector</span> <span>v4</span> <span>=</span> <span>compareAndExchange</span><span>(</span><span>v3</span><span>,</span> <span>COMPARISON_16_4_S</span><span>,</span> <span>COMPARISON_16_4_M</span><span>);</span>
    <span>IntVector</span> <span>v5</span> <span>=</span> <span>compareAndExchange</span><span>(</span><span>v4</span><span>,</span> <span>COMPARISON_16_5_S</span><span>,</span> <span>COMPARISON_16_5_M</span><span>);</span>
    <span>IntVector</span> <span>v6</span> <span>=</span> <span>compareAndExchange</span><span>(</span><span>v5</span><span>,</span> <span>COMPARISON_16_6_S</span><span>,</span> <span>COMPARISON_16_6_M</span><span>);</span>
    <span>IntVector</span> <span>v7</span> <span>=</span> <span>compareAndExchange</span><span>(</span><span>v6</span><span>,</span> <span>COMPARISON_16_7_S</span><span>,</span> <span>COMPARISON_16_7_M</span><span>);</span>
    <span>IntVector</span> <span>v8</span> <span>=</span> <span>compareAndExchange</span><span>(</span><span>v7</span><span>,</span> <span>COMPARISON_16_8_S</span><span>,</span> <span>COMPARISON_16_8_M</span><span>);</span>
    <span>IntVector</span> <span>v9</span> <span>=</span> <span>compareAndExchange</span><span>(</span><span>v8</span><span>,</span> <span>COMPARISON_16_9_S</span><span>,</span> <span>COMPARISON_16_9_M</span><span>);</span>
    <span>IntVector</span> <span>v10</span> <span>=</span> <span>compareAndExchange</span><span>(</span><span>v9</span><span>,</span> <span>COMPARISON_16_10_S</span><span>,</span> <span>COMPARISON_16_10_M</span><span>);</span>
    <span>v10</span><span>.</span><span>intoArray</span><span>(</span><span>array</span><span>,</span> <span>from</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>I found performance of this strangely poor until I discovered the reason - the <code>compareAndExchange</code> method that I’d written wasn’t being inlined, and so the <code>IntVector</code> objects could not be optimized away. Each run of this method creates many objects, many int arrays, and in general it just causes a lot of garbage collector pressure due to how hot the method was. Inlining <code>compareAndExchange</code> manually worked and restored good performance, but is ugly.</p>

<p>In general what I’d be concerned about is that without some mechanism of doing so, creating performant reusable code is very difficult because there’s no clear way to combine code and ensure it’s properly inlined at the user level without very carefully testing it. Even with the manual inlining, very occasionally Java will allocate objects on the very last step of the sorting network.</p>

<p>My suspicion is that it would be easier to use these APIs performantly if the inlining threshold were higher when vector methods are used.</p>

<h2 id="masking-loads-and-stores-added-memory-allocations">Masking loads and stores added memory allocations</h2>

<p>In the above ‘sort16’ implementation there is no ‘to’ - ideally this would allow us to sort <em>up to</em> 16 elements. What I discovered that this was a risky proposition because again it became an easy deoptimization. If you are trying to load a smaller number of elements into a vector, you can do something like:</p>

<div><div><pre><code><span>VectorMask</span><span>&lt;</span><span>Integer</span><span>&gt;</span> <span>mask</span> <span>=</span> <span>VectorMask</span><span>.</span><span>fromValues</span><span>(</span><span>SPECIES</span><span>,</span> <span>true</span><span>,</span> <span>false</span><span>,</span> <span>false</span><span>,</span> <span>false</span><span>);</span>
<span>int</span><span>[]</span> <span>array</span> <span>=</span> <span>new</span> <span>int</span><span>[]</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>};</span>
<span>IntVector</span> <span>vector</span> <span>=</span> <span>IntVector</span><span>.</span><span>fromArray</span><span>(</span><span>SPECIES</span><span>,</span> <span>array</span><span>,</span> <span>3</span><span>,</span> <span>mask</span><span>);</span>
<span>assertThat</span><span>(</span><span>vector</span><span>).</span><span>isEqualTo</span><span>(</span><span>IntVector</span><span>.</span><span>fromArray</span><span>(</span><span>SPECIES</span><span>,</span> <span>new</span> <span>int</span><span>[]</span> <span>{</span><span>4</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>}));</span>
</code></pre></div></div>

<p>This code works, but behind the scenes this will allocate an int array (reading the code, it looks like the mask’s validity is checked by creating a mask, and this is the culprit of the allocations), increasing GC overhead. In the end I observed that in quicksort, if you’re trying to sort elements 3 to 5, it’s equally safe to sort 3 to 11 because of the recursive nature of partitioning, and so I just oversort (and use <code>Arrays.sort</code> on the last vector in the array instead of the sorting network).</p>

<p>It was entirely non-obvious that this might occur, and again, this was disconcerting because the code change required to fix the method seemed so minor. There’s so much scalar replacement happening when you use these APIs that small permutations that break the optimization make things a lot more challenging.</p>

<h2 id="species_preferred-considered-harmful"><code>SPECIES_PREFERRED</code> considered harmful?</h2>

<p>I primarily tested on my modern desktop, which supports <code>AVX2</code>. At a late stage, I wanted to see how well the code would work with an <code>AVX512</code> server. I used GCP and requested an Ice Lake architecture processor. The performance crashed; using 512 bit vectors in <em>any</em> part of the code appeared to cause the throughput to drop by a factor of 3. The purpose of <code>SPECIES_PREFERRED</code> seems to be to let the user pick the widest species with hardware acceleration and not have to specialize their code for each specific architecture, but (and I didn’t dig in enough here) if derating causes performance to dive bomb that much, it becomes harder to author the code reliably.</p>



<p>Google recently published a library for running vectorized sorting in C++. This was measured at around 800MB/sec on an older Xeon processor. My processor is probably faster, and could handle around 300MB/sec on the same size arrays as compared to 100MB/sec from the standard library. Clearly there is a gap, but I think this is a reasonable outcome. Java’s vector support is impressive, the implementation is interesting, and generally I had fun. I think there’s some room for improvement with regards to some runtime checks, errant memory allocations, and lookup table support, but this is what preview apis are for! Code can be found <a href="https://github.com/j-baker/vector-experiments">here</a>.</p>



<p>Here’s one simple example I encountered recently. It’s common in columnar database code to ‘dictionary encode’ lists of values. Here, for some subset of the stored data, we store a dictionary containing the unique values that exist, assigning unique indices to each value, and we store a list of pointers into the list to represent each element.</p>

<div><div><pre><code><span>record</span> <span>DictionaryEncoded</span><span>&lt;</span><span>T</span><span>&gt;(</span><span>List</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>dictionary</span><span>,</span> <span>int</span><span>[]</span> <span>ordinals</span><span>)</span> <span>{}</span>

<span>DictionaryEncoded</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>encode</span><span>(</span><span>List</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>buffer</span><span>)</span> <span>{</span>
    <span>Map</span><span>&lt;</span><span>T</span><span>,</span> <span>Integer</span><span>&gt;</span> <span>itemToIndex</span> <span>=</span> <span>new</span> <span>HashMap</span><span>&lt;&gt;();</span>
    <span>List</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>indexToItem</span> <span>=</span> <span>new</span> <span>ArrayList</span><span>&lt;&gt;();</span>
    <span>// this need not be an int[] type - if the dictionary ends up having fewer than 256 elements, it could be a byte[]! There are lots of encoding schemes that help here, e.g. https://github.com/lemire/JavaFastPFOR</span>
    <span>int</span><span>[]</span> <span>ordinals</span> <span>=</span> <span>new</span> <span>int</span><span>[</span><span>buffer</span><span>.</span><span>size</span><span>()];</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>ordinals</span><span>.</span><span>length</span><span>;</span> <span>i</span><span>++)</span> <span>{</span>
        <span>ordinals</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>itemToIndex</span><span>.</span><span>computeIfAbsent</span><span>(</span><span>element</span><span>,</span> <span>key</span> <span>-&gt;</span> <span>{</span>
            <span>int</span> <span>index</span> <span>=</span> <span>indexToItem</span><span>.</span><span>size</span><span>();</span>
            <span>indexToItem</span><span>.</span><span>add</span><span>(</span><span>key</span><span>);</span>
            <span>return</span> <span>index</span><span>;</span>
        <span>});</span>
    <span>}</span>
    <span>return</span> <span>new</span> <span>DictionaryEncoded</span><span>&lt;&gt;(</span><span>indexToItem</span><span>,</span> <span>ordinals</span><span>);</span>
<span>}</span>

<span>&lt;</span><span>T</span><span>&gt;</span> <span>T</span> <span>get</span><span>(</span><span>int</span> <span>index</span><span>,</span> <span>DictionaryEncoded</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>encoded</span><span>)</span> <span>{</span>
    <span>return</span> <span>encoded</span><span>.</span><span>dictionary</span><span>().</span><span>get</span><span>(</span><span>encoded</span><span>.</span><span>ordinals</span><span>()[</span><span>index</span><span>]);</span>
<span>}</span>
</code></pre></div></div>

<p>This kind of format is used by many data systems - open source projects like Apache Arrow, Parquet, Lucene, closed source projects like Vertica all contain a model somewhat like this, since it has advantages for both storage and querying. On the storage side, it’s a cheap way to reduce the amount of data stored; in my example above the worst case additional memory usage amortizes to 4 bytes per element; in the case where we have a single large element being repeated over and over, it could replace kilobytes with those same 4 bytes. This usually improves both storage cost and query performance (since databases are usually I/O bottlenecked). Further, some queries may no longer require scanning all of the data (for example a query to select the max element need only scan the dictionary). Conversely, if one is able to compute a global dictionary, if the column is accessed for a join, we could join the values column and ignore the dictionary entirely. If the dictionary represents large strings, this might dramatically improve performance because the comparison operation may go from hundreds of cycles to 1.</p>

<p>Unfortunately, there can be some downsides. The key to high performing data processing code is usually to do as many sequential reads as possible, minimizing the amount of random memory access to regions that don’t fit in the L1 or L2 caches. This is because uncached memory accesses are far slower than a processor can handle data; <a href="https://colin-scott.github.io/personal_website/research/interactive_latency.html">an L1 cache read might be 0.5ns, whereas a main memory read might be 100ns, whereas a disk read might be into the milliseconds</a>. In some cases, practitioners may limit the sizes of their dictionaries to compensate for this, so as to very rarely result in a main memory or disk read, whereas in others the cost may simply be eaten as an unlikely worst case outcome.</p>

<p>In this latter case, suppose we need to read a subset of the values, but in a way where we don’t care about the order. An example of the pattern might be:</p>

<div><div><pre><code><span>class</span> <span>NaiveMaxAccumulator</span> <span>{</span>
    <span>final</span> <span>List</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>dictionary</span><span>;</span>
    <span>final</span> <span>Ordering</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>ordering</span><span>;</span>

    <span>T</span> <span>max</span><span>;</span>


    <span>void</span> <span>accumulate</span><span>(</span><span>int</span> <span>ordinal</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>max</span> <span>=</span> <span>null</span><span>)</span> <span>{</span>
            <span>max</span> <span>=</span> <span>dictionary</span><span>.</span><span>get</span><span>(</span><span>ordinal</span><span>);</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>max</span> <span>=</span> <span>ordering</span><span>.</span><span>max</span><span>(</span><span>max</span><span>,</span> <span>dictionary</span><span>.</span><span>get</span><span>(</span><span>ordinal</span><span>));</span>
        <span>}</span>
    <span>}</span>

    <span>T</span> <span>getValue</span><span>()</span> <span>{</span>
        <span>return</span> <span>checkNotNull</span><span>(</span><span>max</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>where some other code is responsible for passing us those ordinals which are a part of the query.</p>

<p>We could perhaps improve this code by writing something more like</p>

<div><div><pre><code><span>class</span> <span>DeduplicatingMaxAccumulator</span> <span>{</span>
    <span>final</span> <span>List</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>dictionary</span><span>;</span>
    <span>final</span> <span>Ordering</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>ordering</span><span>;</span>

    <span>final</span> <span>int</span><span>[]</span> <span>buffer</span> <span>=</span> <span>new</span> <span>int</span><span>[</span><span>1</span> <span>&lt;&lt;</span> <span>16</span><span>];</span>
    <span>int</span> <span>bufferSize</span> <span>=</span> <span>0</span><span>;</span>

    <span>T</span> <span>max</span><span>;</span>

    <span>void</span> <span>accumulate</span><span>(</span><span>int</span> <span>ordinal</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>bufferSize</span> <span>==</span> <span>buffer</span><span>.</span><span>length</span><span>)</span> <span>{</span>
            <span>flush</span><span>();</span>
        <span>}</span>
        <span>buffer</span><span>[</span><span>bufferSize</span><span>++]</span> <span>=</span> <span>ordinal</span><span>;</span>
    <span>}</span>

    <span>T</span> <span>getValue</span><span>()</span> <span>{</span>
        <span>flush</span><span>();</span>
        <span>return</span> <span>checkNotNull</span><span>(</span><span>max</span><span>);</span>
    <span>}</span>

    <span>void</span> <span>flush</span><span>()</span> <span>{</span>
        <span>Arrays</span><span>.</span><span>sort</span><span>(</span><span>buffer</span><span>,</span> <span>0</span><span>,</span> <span>bufferSize</span><span>);</span>
        <span>int</span> <span>lastOrdinal</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>bufferSize</span><span>;</span> <span>i</span><span>++)</span> <span>{</span>
            <span>int</span> <span>ordinal</span> <span>=</span> <span>buffer</span><span>[</span><span>i</span><span>];</span>
            <span>if</span> <span>(</span><span>ordinal</span> <span>!=</span> <span>lastOrdinal</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span><span>max</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    <span>max</span> <span>=</span> <span>dictionary</span><span>.</span><span>get</span><span>(</span><span>ordinal</span><span>);</span>
                <span>}</span> <span>else</span> <span>{</span>
                    <span>max</span> <span>=</span> <span>ordering</span><span>.</span><span>max</span><span>(</span><span>max</span><span>,</span> <span>dictionary</span><span>.</span><span>get</span><span>(</span><span>ordinal</span><span>));</span>
                <span>}</span>
                <span>lastOrdinal</span> <span>=</span> <span>ordinal</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>bufferSize</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This approach gives us two potential advantages. The first is that in the naive approach, the comparison is run linearly with the number of elements, whereas the improved approach runs it linearly with the number of <em>unique</em> elements. If the comparison function is particularly expensive (as it might be for strings or other more complex datatypes) this might be a considerable percentage of the overall time. The second advantage is that by sorting the ordinals, we can benefit from spatial locality of reference. When we issue a small read to a storage volume, it’s common for the operating system to load a larger chunk of data and cache it (e.g. if we try to read 16 bytes from our app, it might read 4096 and keep it around). If we are accessing ordinals 0, 2, 5, 9, 11 and we have laid out our data linearly, these will likely be located on the same operating system pages, reducing cost. If we are accessing ordinals 0, 1000000, 2000000, 300000, 45012, etc etc, randomly jumping around, we have no hope of achieving this.</p>

<p>Practically speaking, I’ve seen this tactic lead to an order of magnitude jump. However, it’s not a pure improvement - for each element we process, we are definitely adding the amortized cost of sorting that element, and possibly removing the costs of loading and comparing the element, or otherwise possibly reducing the cost of loading the element. If these are only sometimes true (for example, if loading is cheap but comparing is expensive, if the dictionary is very large we will lose out, if the dictionary is very small but the comparison is very cheap we might also lose out).</p>

<p>On my computer, Java’s <code>Arrays.sort</code> method costs around 50ns/element in the real world. This means that we unfortunately have a lot of scope to cause ourselves performance problems by using this approach, because in some cases the cost of sorting will dominate the cost of processing. If we could sort at more like 10ns/element, the change would almost always be worthwhile.</p>

  
</div>



      </div></div>
  </body>
</html>
