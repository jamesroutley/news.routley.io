<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://charlie-volow.com/blog/posts/premature_optimization.html">Original</a>
    <h1>&#34;Premature Optimization is the Root of All Evil&#34;</h1>
    
    <div id="readability-page-1" class="page"><div id="indexable">
	    <p><em>originally published 2024-09-06 on Recurse Center
    zulip</em></p>
    <p>I’d heard this Knuth quote but never really connected with it or
    dug into the source material (though Knuth Tome I has been gazing at
    me intently from my shelf for some time), but got a little taste of
    what he might’ve meant recently.</p>
    <h3 id="problem">Problem</h3>
    <p>In Jackdaw, each <code>Track</code> contains an array of clips
    (actually “clip references,” type <a href="https://github.com/chvolow24/jackdaw/blob/ad23433e6a801adc316ae968d0de9c07e174e894/src/project.h#L151"><code>ClipRef</code></a>).
    When the program <a href="https://github.com/chvolow24/jackdaw/blob/ad23433e6a801adc316ae968d0de9c07e174e894/src/mixdown.c#L182">assembles
    a chunk</a> (typically 2048 sample frames) of mixed-down audio for
    playback, every single clip is checked for intersection with the
    chunk.</p>
    <p>That seems like a lot of work! The visual nature of the program
    also makes it feel superfluous. <em>I</em> can easily see which
    clips intersect the playhead, so why can’t the program just check
    those? If I have tons of clips on my project, won’t it take forever
    to search through them every time a new chunk is needed (many times
    a second)?</p>
    <p><img src="https://charlie-volow.com/assets/blog_imgs/clipsearch_intersection.jpeg" width="100%"/></p>
    <p>My aesthetic displeasure with the brute force solution – which of
    course has been working fine for me thus far – led me to spend some
    time thinking about it and planning a better solution. It’s a
    challenging problem because of the variable length of clips. A clip
    way back at time 0 might still need to be checked when we’re at the
    30m mark, because that clip may be more than 30m long; so data
    structures based on a naive notion of clip locality are
    inadequate.</p>
    <h3 id="solution">Solution</h3>
    <p>The solution involves maintaining two sorted arrays of clips on
    each track – one ordered by the clips’ starting positions, and one
    by their ending positions – as well as a cache of currently “active”
    clips.</p>
    <p>When playback commences in the forward direction, all clips with
    starting positions up to the playhead position are checked to see if
    they are of sufficient duration to intersect with the playhead. If
    so, they are added to the “active” clip cache. During playback, each
    time a chunk is requested, the next clip in the sorted list is
    checked to see if it ought to be added to the active clip cache. We
    keep checking the next clip until one is not added. Then, only
    active clips are read for mixdown. When the end position of a clip
    is reached, it is dropped from the active clip cache. Any time the
    playhead position “jumps” (user clicks somewhere on the timeline or
    invokes a “jump to” command) the active clip cache must be reset;
    but this is <em>only</em> necessary when there is a jump.</p>
    <p>The second array sorted in reverse order of clip end position is
    necessary to apply the same process for reverse playback.</p>
    <p>I had filed this solution away a month or so ago, and decided it
    would be a good time to implement it earlier this week. I spent way
    more time than I expected getting binary search insertion right;
    it’s something I’ve probably done before and expected to be quick
    and easy, but perhaps due to haste, I took a wrong turn and got
    really frustrated with myself. I used libc <code>qsort</code> for a
    couple other scenarios (e.g. when moving a bunch of clips from one
    track to another) and the name of Knuth stared out at me sternly
    from the man page. Surveying several other parts of the program that
    would have to change, I got an itch about how necessary all of this
    really was.</p>
    <h3 id="how-necessary-all-of-this-really-was">How necessary all of
    this really was</h3>
    <p>I crudely timed a few different sections of the mixdown logic
    without the search optimization. Turns out that, even with ~500
    clips in the project, the search time is dwarfed by a single
    FFT-based effect.</p>
    <p>In retrospect, this is not surprising at all; 500 is a huge
    number of clips to have in a DAW project (I think – DAW users weigh
    in please), but is not a huge number of computer operations to run
    every time a mixdown chunk is needed (every ~0.04 seconds). The
    problem seemed worse than it was because clips look “heavy”; I
    overestimated the cost of the brute force search because I
    subconsciously and incorrectly implicated the scale of clip data
    (i.e., the actual audio data associated with the clip) in the search
    process, while the only actually relevant parameters are a couple
    integers (start and end position).</p>
    <p>None of this was “evil.” It was an interesting problem, and there
    may come a time when it’s worthwhile to implement this optimization.
    But I have no shortage of interesting problems to work at, so
    perhaps it wasn’t the best use of my time.</p>
	  </div></div>
  </body>
</html>
