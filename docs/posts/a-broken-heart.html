<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://allenpike.com/2026/a-broken-heart/">Original</a>
    <h1>A Broken Heart</h1>
    
    <div id="readability-page-1" class="page"><p>
  Or, getting a 100x speedup with one dumb line of code.
</p><div>
  <p>You always know itâ€™s a good bug when your first reaction is, â€œ<a href="https://allenpike.com/2018/the-great-bug-hunt/">How could this even happen?</a>â€</p>
<p>The other day, I was refining the dashboard of a web app weâ€™re working on â€“ as you do â€“ and I noticed it was taking <em>forever</em> to load. Like, it had been loading in a single second, but now it was taking ten seconds. Something fishy was going on.</p>
<p>Naturally, I blamed React.</p>
<p>I mean, sure, in a modern web app there are many potential causes of a performance problem: third-party JavaScript, overburdened servers, bloated assets, missing database indexes â€“ a list as long as your arm. But decades of building for the web told me that this was a frontend problem. I could just smell it. The page looked janky while loading. And despite being the least-bad approach for web frontends today, the React ecosystem is lousy with ways for a codebase to get tangled, slow, and fishy.</p>
<p>So to prove my theory, I explained to Claude that the dashboard was loading slowly, that it surely had some React problems, and to analyze it and rank them from most to least serious. And sure enough, Claude found a bunch of React fishiness â€“ unnecessary re-renders, missing memoizations. We still werenâ€™t on React Compiler, which I hadnâ€™t realized. So I had Claude do a first pass on the easiest and most serious React issues, andâ€¦</p>
<p>It made almost no difference? Maybe it wasnâ€™t React after all.</p>
<p>So, I rolled up my sleeves, and started investigating properly.</p>
<ol>
<li>Maybe the server really is slow? A little, but itâ€™s not blocking the frontend.</li>
<li>Was the problem in all browsers? No. It was somehow specific to Safari?</li>
<li>Ah, it must be third-party JavaScript then. Intercom? No. PostHog? No.</li>
<li>Okay, letâ€™s really dig in to the performance timeline.</li>
</ol>
<p>Now, the Safari performance inspector has diverged from the Chromium one over the years, and has gotten (on this page at least) rather flaky. But it painted a pretty clear picture: It wasnâ€™t spending 7+ seconds parsing JavaScript, calculating styles, or loading from the network. It was using 94% of an M1 Max CPU onâ€¦ Layout?</p>
<p><img src="https://allenpike.com/images/2026/safari-profile.jpg" alt="Safari performance inspector showing Layout taking 94% of CPU time."/>
</p>
<p>Digging into the details, it showed multiple Layout passes taking more than 1600ms each. For reference, thatâ€™s roughly 100x slower than it should be, so something was seriously wrong with how our page was being laid out. Flexbox can get a little slow, but not <em>this</em> slow.</p>
<h2 id="time-to-tear-things-apart" tabindex="-1">Time to tear things apart</h2>
<p>At that point, I reached for an age-old tool that has gotten more useful in the modern age: binary search. That is, you explain the symptom to your coding agent. Then you have it repeatedly remove stuff from your code that might be causing the problem, and see if that fixes it. When you find <em>something</em> that fixes it, you iteratively re-add everything until you have a minimal change that indicates the underlying issue, and thus a workaround.</p>
<p>This is especially fast if the agent can see the problem itself, but I didnâ€™t have a command-line Safari perf analysis tool on hand. Still, after only 10 minutes of telling Claude whether a given change did or didnâ€™t fix the issue, coaching it through how to think about what weâ€™d just learned with each step, weâ€™d found the culprit!</p>
<p>A heart emoji. â¤ï¸</p>
<p>If we removed the emoji in our Send Feedback button (which Iâ€™d recently added), then Safari could lay the page out in 2 milliseconds. If we re-added it, the page took 1600ms for each layout, of which there were multiple.</p>
<p>Now, I like to use emoji in early prototype interfaces. Theyâ€™re trivial to add, and load faster than images. Right? A single character of a font should not take 100x longer to render (or, according to Safari, â€œLayoutâ€) than the rest of a dynamic React web app. Seems like Iâ€™d hit a Safari bug.</p>
<p>This is generally the â€œokay now I need a drinkâ€ moment in a Weird Bug Hunt. But it was still before noon, so I went to get another coffee instead.</p>
<p>When you find something that looks to be a bug in the browser, you want to submit that bug. To submit a bug, though, you canâ€™t just attach your whole project. â€œHey if you run this whole production app, Safari has a problem.â€ Youâ€™re meant to produce a minimal reproduction case: â€œHereâ€™s a simple file that triggers the issue. Load it and see.â€ Even better, this means youâ€™ll fully understand the problem, and can likely find a better workaround than â€œnever use emoji in this app againâ€.</p>
<p>Making a minimal repro sample is a huge barrier for submitters, though, since fully boiling a full-fledged app containing proprietary stuff down to the minimal repro case is a ton of tedium.</p>
<p>Or, it used to be a ton of tedium! Related to their bug-isolating capabilities, coding agents are also particularly well-suited to producing minimal test cases. They can edit a lot of code at once, and it usually doesnâ€™t take much creativity â€“ youâ€™re just iteratively removing as much as you can without making the bug stop triggering.</p>
<p>So, before long, I had a very simple repro case for the Safari team. And, in looking at the minimal repro code, it became very clear what the real culprit was. On my Mac, Safari 26.2 takes 1600ms to â€œLayoutâ€ the following HTML.</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;link href=&#34;https://fonts.googleapis.com/css2?family=Noto+Color+Emoji&#34; rel=&#34;stylesheet&#34;&gt;
  &lt;style&gt;
    body { font-family: &#34;Noto Color Emoji&#34;; }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  ğŸ’”
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Curse you, <strong>Noto Color Emoji</strong>.</p>
<h2 id="fonts-can-have-colors-now" tabindex="-1">Fonts can have colors now!</h2>
<p>Traditionally, fonts were just shapes. It would display in black, or white, or whatever color you chose. But in 2008, Apple shipped <a href="https://typographica.org/typeface-reviews/apple-color-emoji/">Apple Color Emoji</a> in iPhone OS 2.2, and brought it to Mac OS X in 2011. Emojiâ€™s rise in popularity led to demand for fonts that have intrinsic color.</p>
<p>Originally, Appleâ€™s Color Emoji were basically a hack. They just stuck PNG images in a font, which was neither standardized nor resolution-independent. Outside a certain size range, they looked like butt. This led to four competing color font standards (from Apple, Mozilla, Google, and Microsoft) all being submitted to <a href="https://en.wikipedia.org/wiki/OpenType">OpenType</a> 1.7. According to Wikipedia, Microsoft and Apple added support for these different approaches, and thatâ€™s that.</p>
<p>But that â€“ as it so often is â€“ was not that.</p>
<p>You see, Noto Color Emoji is a Google font that is helpful in that it gives you consistent emoji rendering across platforms. Weâ€™d included it earlier to get decent emoji rendering on Linux (where we do some HTML-to-video rendering in the cloud, a technique that sounds horrifying but can be pretty useful). However, the font relies on <a href="https://developer.chrome.com/blog/colrv1-fonts">COLRv1</a>, a spec Google advises will make your apps load faster because it results in smaller emoji than bitmaps â€“ and can fall back to supplying SVG for other browsers.</p>
<p>â€œOther browsersâ€, in this case, is Safari. And, I guess, â€œfalling back to SVGâ€ means spending 1600ms of â€œLayoutâ€ for a single character. If youâ€™d like to see what this looks like scaled up, you can try loading <a href="https://fonts.google.com/noto/specimen/Noto+Color+Emoji">the Google Fonts page that attempts to showcase all of the Noto Color Emoji</a> glyphs on iPhone. (As of iOS 26.2, it goes poorly.)</p>
<p><img src="https://allenpike.com/images/2026/iphone-emoji-error.png" alt="iPhone showing an error when trying to load Noto Color Emoji."/></p><p>After I mentioned the bug in a Slack, Daniel Jalkut <a href="https://bugs.webkit.org/show_bug.cgi?id=305636">filed it in the Safari bug tracker</a>, and Simon Fraser on the webkit team has already commented, noting the slowness seems to be within CoreSVG. Chances are this will get fixed!</p>
<p>In the meantime, Iâ€™d like to contribute this humble finding to the search corpus: donâ€™t use Noto Color Emoji on Apple platforms â€“Â list â€œApple Color Emojiâ€ first. At least, until the bug is fixed and the resulting Safari release is widespread.</p>
<p>Iâ€™d also like to come clean on a little secret. As profoundly helpful as Claude was in debugging this â€“ I surely fixed this problem 10x faster than I would have without it â€“ I must admit, it was Claude that tipped us off to the existence of Noto Color Emoji in the first place. I suspect that, without the coding agent, we would have solved the Linux emoji problem in a more boring way (using an icon library) and not ended up with a weird slow emoji implementation.</p>
<p>It seems more true every month: these coding agents are very much like a power saw. Profoundly useful, and proportionately dangerous.</p>
<p>So, I suppose, hereâ€™s to Claude. The cause of â€“ and solution to â€“ all of startupsâ€™ problems.</p>


</div></div>
  </body>
</html>
