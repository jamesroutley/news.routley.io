<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://smallstep.com/blog/use-ssh-certificates/">Original</a>
    <h1>If you’re not using SSH certificates you’re doing SSH wrong (2019)</h1>
    
    <div id="readability-page-1" class="page"><div>
<section>
<p><img src="https://smallstep.com/uploads/use-ssh-certs-unfurl.png" alt=""/></p><p>SSH is ubiquitous. It’s the de-facto solution for remote administration of *nix systems. But SSH has some pretty gnarly issues when it comes to usability, operability, and security.</p><p>You’re probably familiar with these issues:</p><ul>
<li><strong>SSH user experience is terrible.</strong> SSH user on-boarding is slow and manual. Connecting to new hosts produces confusing security warnings. You’re left with weird new credentials to manage with little guidance on how to do so.</li><li><strong>Operating SSH at scale is a disaster.</strong> Key approval &amp; distribution is a silly waste of time. Host names can’t be reused. Homegrown tools scatter key material across your fleet that must be cleaned up later to off-board users.</li><li><strong>SSH encourages bad security practices.</strong> Rekeying is hard, so it’s not done. Users are exposed to key material and encouraged to reuse keys across devices. Keys are trusted permanently, so mistakes are fail-open.</li></ul><p>The good news is this is all easy to fix.</p><p>None of these issues are actually inherent to SSH. They’re actually problems with SSH <em>public key authentication</em>. The solution is to switch to <em>certificate authentication</em>.</p><p><strong>SSH certificate authentication makes SSH easier to use, easier to operate, and more secure.</strong></p><h2 id="background">Background</h2><p>At smallstep, certificates are kind of our jam. We build open source software that lets you run your own private certificate authority and manage X.509 (TLS/HTTPS) certificates.</p><p>SSH certificates have been on our radar for a while. From our perspective they’re all pros, no cons. But no one uses them. Why not? We’ve asked hundreds of people that question. Here’s what we found out:</p><ul>
<li>People do use SSH certificates. In fact, pretty much <em>everyone</em> operating at scale that knows what they’re doing does (<a href="https://engineering.fb.com/security/scalable-and-secure-access-with-ssh/">Facebook</a>, <a href="https://medium.com/uber-security-privacy/introducing-the-uber-ssh-certificate-authority-4f840839c5cc">Uber</a>, Google, <a href="https://github.com/Netflix/bless">Netflix</a>, <a href="https://www.usenix.org/conference/srecon17europe/program/presentation/sheridan">Intercom</a>, <a href="https://eng.lyft.com/blessing-your-ssh-at-lyft-a1b38f81629d">Lyft</a>, etc), but…</li><li>Certificates and public key infrastructure (PKI) are hard to grok. People don’t immediately understand the benefits.</li><li>There’s a (small) tooling gap that exacerbates this knowledge gap. It’s not hard to fill, but people are wary to do so themselves without a deeper understanding of PKI concepts.</li><li>More than anything, SSH certificates haven’t gotten the press they deserve. <em>Most</em> people we asked hadn’t heard of them at all.</li></ul><p>We’re convinced that SSH certificates are the right way to do SSH. They’re not that hard to understand, and it’s well worth the effort. SSH certificates deserve more press, and broader use.</p><p><img src="https://smallstep.com/uploads/why-dont-more-people-use-ssh-certs.png" alt="why don’t more people know about ssh certificates?"/></p><h2 id="public-key-authentication">Public key authentication</h2><p>Most SSH deployments use <em>public key authentication</em>, which uses asymmetric (public key) cryptography with a public / private key pair generated for each user &amp; host to authenticate.</p><p>The magic of asymmetric cryptography is the special correspondence between a public and private key. You can <em>sign</em> data with your private key and someone else can <em>verify</em> your signature with the corresponding public key. Like a hash, it’s computationally infeasible to forge a signature. Thus, if you can verify a signature, and you know who owns the private key, you know who generated the signature.</p><p>Simple authentication can be implemented by challenging someone to sign a big random number. If I open a socket to you and send a random number, and you respond with a valid signature over that number, I must be talking to you.</p><p>This is an oversimplification, but it’s more or less how SSH public key authentication works. Certificate authentication works the same way, but with an important twist that we’ll get to in a moment.</p><p>To SSH to a host using public key authentication the host needs to know your public key. By default, your public key must be added to <code>~/.ssh/authorized_keys</code>. Maintaining this file for every user across a fleet is operationally challenging and error prone.</p><p><img src="https://smallstep.com/uploads/ssh-deploy-rgm.png" alt="SSH Deployment Rube Goldberg Machine"/></p><p>SSH user onboarding with public key authentication usually starts with some baroque incantation of <code>ssh-keygen</code>, hopefully pulled from a runbook, but more likely cribbed from stack overflow. Next you’ll be asked to submit your public key for <em>approval and distribution</em>. This process is typically manual and opaque. You might be asked to email an administrator or open a JIRA ticket. Then you wait. While you’re doing that, some poor operator gets interrupted and told to add your key to a manifest in some repo and trigger a deploy. Once that’s done you can SSH. Since key bindings are permanent, your SSH access will continue in perpetuity until someone reverses this process.</p><h2 id="certificate-authentication">Certificate authentication</h2><p>Certificate authentication eliminates key approval and distribution. Instead of scattering public keys across static files, you bind a public key to a name with a <em>certificate</em>. A certificate is just a data structure that includes a public key, name, and ancillary data like an expiration date and permissions. The data structure is signed by a <em>certificate authority</em> (CA).</p><pre><code>$ ssh-keygen -L -f id_ecdsa-cert.pub
id_ecdsa-cert.pub:
        Type: ecdsa-sha2-nistp256-cert-v01@openssh.com user certificate
        Public key: ECDSA-CERT SHA256:O6M6oIjDm5gPm1/aTY619BgC3KSpS4c3aHVWxYh/uGQ
        Signing CA: ECDSA SHA256:EY2EXJGoPv2LA6yEbjH+sf9JjG9Rd45FH1Wt/6H1k7Y
        Key ID: &#34;mike@example.com&#34;
        Serial: 4309995459650363134
        Valid: from 2019-09-11T14:50:01 to 2019-09-11T18:50:01
        Principals:
                mike
        Critical Options: (none)
        Extensions:
                permit-X11-forwarding
                permit-agent-forwarding
                permit-port-forwarding
                permit-pty
                permit-user-rc
</code></pre><p>To enable certificate authentication simply configure clients and hosts to verify certificates using your CA’s public key (i.e., trust certificates issued by your CA).</p><p>On each host, edit <code>/etc/ssh/sshd_config</code>, specifying the CA public key for verifying user certificates, the host’s private key, and the host’s certificate:</p><pre><code># Path to the CA public key for verifying user certificates
TrustedUserCAKeys /etc/ssh/ssh_user_key.pub

# Path to this host&#39;s private key and certificate
HostKey /etc/ssh/ssh_host_ecdsa_key
HostCertificate /etc/ssh/ssh_host_ecdsa_key-cert.pub
</code></pre><p>On each client, add a line to <code>~/.ssh/known_hosts</code> specifying the CA public key for verifying host certificates:</p><pre><code>@cert-authority *.example.com ecdsa-sha2-nistp256 AAAAE...=
</code></pre><p>That’s it. That’s literally all that you need to do to start using certificate authentication. You can even use it alongside public key authentication to make transitioning easier.</p><p><img src="https://smallstep.com/uploads/ssh-certificate-authentication.png" alt="SSH Certificate Authentication - Example Architecture"/></p><p>Static keys in <code>~/.ssh/authorized_keys</code> are no longer needed. Instead, peers learn one another’s public keys on demand, when connections are established, by exchanging certificates. Once certificates have been exchanged the protocol proceeds as it would with public key authentication.</p><h3 id="certificate-authentication-improves-usability">Certificate authentication improves usability</h3><p>With public key authentication, when you SSH to a remote host for the first time, you’ll be presented with a security warning like this:</p><pre><code>$ ssh ubuntu@ec2-54-161-77-102.compute-1.amazonaws.com
The authenticity of host &#39;ec2-54-161-77-102.compute-1.amazonaws.com (54.161.77.102)&#39; can&#39;t be established.
ECDSA key fingerprint is SHA256:2ae53QcOB0W6HO+XtPmMXk7To/MvMuhFxTj8ZD7eSsE.
Are you sure you want to continue connecting (yes/no)?
</code></pre><p>You’ve probably seen this before. If you’re like most people, you’ve been trained to ignore it by just typing “yes”. That’s a problem because this is a legitimate security threat. It’s also a pretty horrendous user experience. I’d wager the vast majority of SSH users don’t actually understand this warning.</p><p>When you SSH to a host, the host authenticates you. Your SSH client also attempts to authenticate the host. To do so your client needs to know the host’s public key. Host public keys are stored in a simple database in <code>~/.ssh/known_hosts</code>. If your client can’t find the host’s public key in this database you get this warning. <strong>It’s telling you that the host can’t be authenticated!</strong></p><p><img src="https://smallstep.com/uploads/ssh-warnings-are-equivalent.png" alt="Browser certificate warning is equivalent to TOFU"/></p><p>What you’re <em>supposed</em> to do is verify the key fingerprint out-of-band by asking an administrator or consulting a database or something. But no one does that. When you type “yes” the connection proceeds without authentication and the public key is permanently added to <code>~/.ssh/known_hosts</code>. This is the <em>trust on first use</em> (TOFU) anti-pattern.</p><p>Since certificate authentication uses certificates to communicate public key bindings, clients are always able to authenticate, even if it’s the first time connecting to a host. <strong>TOFU warnings go away.</strong></p><p>Certificate authentication also offers a convenient place to gate SSH with custom authentication: when the certificate is issued. This can be leveraged to further enhance SSH usability. In particular, it let’s you extend single sign-on (SSO) to SSH. SSO for SSH is certificate authentication’s biggest party trick. We’ll return to this idea and see how it further enhances usability and security later. For now, let’s move on to operability.</p><h3 id="certificate-authentication-improves-operability">Certificate authentication improves operability</h3><p>Eliminating key approval and distribution has immediate operational benefits. You’re no longer wasting ops cycles on mundane key management tasks, and you eliminate any ongoing costs associated with monitoring and maintaining homegrown machinery for adding, removing, synchronizing, and auditing static public key files across your fleet.</p><p>The ability to issue SSH user certificates via a variety of authentication mechanisms also facilitates operational automation. If a cron job or script needs SSH access it can obtain an ephemeral SSH certificate automatically, when it’s needed, instead of being pre-provisioned with a long-lived, static private key.</p><p>SSH public key authentication introduces some weird operational constraints around host names that certificate authentication eliminates. As we’ve seen, when an SSH client connects to a host for the first time it displays a TOFU warning to the user. When the user types “yes” the host’s public key is added locally to <code>~/.ssh/known_hosts</code>. This binding between the host name and a specific public key is <em>permanent</em>. If the host presents a different public key later, the user gets an even scarier <em>host key verification failure</em> error message that looks like this:</p><pre><code>$ ssh ubuntu@ec2-54-161-77-102.compute-1.amazonaws.com
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
SHA256:2ae53QcOB0W6HO+XtPmMXk7To/MvMuhFxTj8ZD7eSsE.
Please contact your system administrator.
Add correct host key in ~/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in ~/.ssh/known_hosts:11
ECDSA host key for ec2-54-161-77-102.compute-1.amazonaws.com has changed and you have requested strict checking.
Host key verification failed.
</code></pre><p>This makes it operationally challenging to reuse host names. If <code>prod01.example.com</code> has a hardware failure, and it’s replaced with a new host using the same name, host key verification failures will ensue. This usually results in a bunch engineers contacting secops to tell them they’re being hacked.</p><p>Ignoring host key verification failures has the exact same attack surface area as not knowing the key at all. Curiously, OpenSSH chooses to soft-fail with an easily bypassed prompt when the key isn’t known (TOFU), but hard-fails with a much scarier and harder to bypass error when there’s a mismatch.</p><p>In any case, certificates fix all of this since a current name-to-public-key binding is communicated when a connection is established. Changing the host’s public key is fine, as long as the host also gets a new certificate. You can safely reuse host names and even run multiple hosts with the same name. You’ll never see a host key verification failure again. Beyond name reuse, we’ll soon see that eliminating host key verification failures is one of the many ways certificate authentication facilitates good security hygiene.</p><h3 id="certificate-authentication-improves-security">Certificate authentication improves security</h3><p>While the SSH protocol itself is secure, public key authentication encourages a bunch of bad security practices and makes good security hygiene hard to achieve.</p><p>With public key authentication, keys are trusted permanently. A compromised private key or illegitimate key binding may go unnoticed or unreported for a long time. Key management oversight (e.g., forgetting to remove an ex-employee’s public keys from hosts) results in SSH failing open: unauthorized access without end.</p><p>Certificates, on the other hand, expire. In an incident — a mistake, theft, misuse, or key exfiltration of any form — compromised SSH credentials will expire automatically, without intervention, even if the incident goes unnoticed or unreported. <strong>SSH certificates are fail-secure.</strong> Access expires naturally if no action is taken to extend it. And when SSH users and hosts check in periodically with your CA to renew their credentials, a complete audit record is produced as a byproduct.</p><p>We’ve already seen how public key authentication trains users to ignore serious security warnings (TOFU) and triggers spurious security errors. This is more than an operational nuisance. Confusion caused by host key verification failure discourages host rekeying (i.e., replacing a host’s key pair). Host private keys aren’t very well protected, so periodic rekeying is good practice. Rekeying may be required after a breach or after offboarding a user. But, to avoid disruption from ensuing host key verification failures, it’s often not done. Certificate authentication makes rekeying hosts trivial.</p><p>Public key authentication also makes rekeying difficult for users. Key approval and distribution is annoying enough that users are reluctant to rekey, even if you’ve built tools to make it possible. Worse, frustrated users copy private keys and reuse them across devices, often for many years. Key reuse is a serious security sin. Private keys are <em>never</em> supposed to be transferred across a network. But SSH public key authentication exposes users directly to sensitive private keys, then fails to give them usable tools for key management. It’s a recipe for misuse and abuse.</p><p>An SSH CA, coupled with a simple command-line client for users, can streamline key generation and insulate users from a lot of unnecessary detail. Certificate authentication can’t completely eliminate all security risks, but it does facilitate SSH workflows that are more intuitive, easier to use, and harder to misuse.</p><h2 id="an-ideal-ssh-flow">An ideal SSH flow</h2><p>SSH certificate authentication is the foundation of what I think is the ideal SSH flow.</p><p>To SSH, users first run a login command in their terminal (e.g., <code>step ssh login</code>):</p><pre><code>$ step ssh login
Your default web browser has been opened for you to login: https://accounts.google.com/...
</code></pre><p>A browser is opened and an SSO flow is initiated at your organization’s identity provider:</p><p><img src="https://smallstep.com/uploads/ssh-sso-in-browser.png" alt="User authenticates in browser via SSO"/></p><p>A web-based SSO flow makes it easy to leverage strong MFA (e.g., FIDO U2F) and any other advanced authentication capabilities your identity provider offers. Users login with a familiar flow, and removing a user from your canonical identity provider ensures prompt termination of SSH access.</p><p>Once the user completes SSO, a bearer token (e.g., an OIDC identity token) is returned to the login utility. The utility generates a new key pair and requests a signed certificate from the CA, using the bearer token to authenticate and authorize the certificate request.</p><p>The CA returns a certificate with an expiry long enough for a work day (e.g., 16-20 hours). The login utility automatically adds the signed certificate and corresponding private key to the user’s <code>ssh-agent</code>.</p><p>Users needn’t be aware of any of this detail. All they need to know is that, in order to use SSH, they must first run <code>step ssh login</code>. Once that’s done they can use SSH like normal:</p><pre><code>$ ssh prod01.example.com
Welcome to Ubuntu 18.04.2 LTS (GNU/Linux 4.15.0-1036-gcp x86_64)

Last login: Wed Sep 11 04:04:51 2019 from 98.210.132.79
mmalone@prod01:~$
</code></pre><p>Like browser cookies, short-lived certificates issued by this flow are ephemeral credentials, lasting just long enough for one work day. Like logging into a website, logging into SSH creates a session. It’s a simple process that must be completed, at most, once per day. This is infrequent enough that strong MFA can be used without frustrating or desensitizing users.</p><p>New private keys and certificates are generated automatically every time the user logs in, and they never touch disk. Inserting directly into <code>ssh-agent</code> insulates users from sensitive credentials. If a user wants to connect from a different device it’s easier for them to run <code>step ssh login</code> there than it is to exfiltrate keys from <code>ssh-agent</code> and reuse them.</p><p>There are lots of possible variations of this flow. You can adjust the certificate expiry, use PAM authentication at the CA instead of SSO, generate the private key on a smart card or TPM, opt not to use <code>ssh-agent</code>, or move MFA to the actual SSH connection. Personally, I think this combination offers the best balance of security and usability. Indeed, relative to most existing SSH deployments it’s operationally simpler, more secure, and more usable.</p><p>Critics of SSH certificate authentication say that it’s new, not well supported, and the tooling doesn’t exist to use certificates in practice. The truth is, <strong>certificate authentication was added in</strong> <a href="https://www.openssh.com/txt/release-5.4"><strong>OpenSSH 5.4</strong></a> <strong>almost a decade ago</strong>. It’s battle tested and used in production by massive operations. And the tooling required to build this ideal SSH flow is available today.</p><p>There are lots of existing tools for managing SSH certificates. Here are a few:</p><ul>
<li><code>ssh-keygen</code> can generate root certificates and sign user &amp; host certificates</li><li><a href="https://github.com/netflix/bless"><code>netflix/bless</code></a> is Netflix’s SSH CA that runs in AWS Lambda and uses IAM</li><li><a href="https://github.com/nsheridan/cashier"><code>nsheridan/cashier</code></a> is Intercom’s SSH CA</li><li><a href="https://github.com/uber/pam-ussh"><code>uber/pam-ussh</code></a> lets you use certificates to authorize <code>sudo</code> use</li><li><a href="https://github.com/hashicorp/vault"><code>hashicorp/vault</code></a> has an <a href="https://www.vaultproject.io/docs/secrets/ssh/index.html">SSH secrets engine</a></li></ul><p>For our part, the most recent release of <code>step</code> &amp; <code>step-ca</code> (<code>v0.12.0</code>) adds basic SSH certificate support. In other words:</p><ul>
<li><a href="https://github.com/smallstep/certificates"><code>step-ca</code></a> is now an SSH CA (in addition to being an X.509 CA)</li><li><a href="https://github.com/smallstep/cli"><code>step</code></a> makes it easy for users and hosts to get certificates from <code>step-ca</code></li></ul><p>SSH workflows aren’t fully fleshed out yet, but these tools already do everything you need for the ideal flow.</p><p>With the appropriate configuration of <code>step-ca</code> you can use <code>step</code> to:</p><h3 id="get-a-host-certificate-automatically-at-startup">Get a host certificate automatically at startup</h3><p>To demonstrate, let’s create a new EC2 instance with the <code>aws</code> CLI tool. The interesting bits are tucked in <a href="https://github.com/smallstep/step-ssh-example/blob/master/host-bootstrap.sh">some light configuration</a> (using a <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html">user-data startup script</a>) that gets a host certificate and enables certificate authentication for users:</p><pre><code>$ aws ec2 run-instances --image-id ami-07d0cf3af28718ef8 \
    --count 1 --instance-type t2.micro \
    --key-name mike-test \
    --security-group-ids launch-wizard-7 \
    --user-data file://startup.sh
</code></pre><p>Note: you should be able to use our <a href="https://smallstep.com/blog/embarrassingly-easy-certificates-on-aws-azure-gcp/">instance identity document support</a> here, but we’ve got a few kinks to work out. Stay tuned.</p><h3 id="get-a-user-certificate-using-sso-oauth-oidc">Get a user certificate using SSO (OAuth OIDC)</h3><p>Now we’ll use <code>step ssh certificate</code> locally (you can <code>brew install step</code>) to generate a new key pair, get a certificate from the CA <a href="https://smallstep.com/blog/easily-curl-services-secured-by-https-tls/#personal-certificates-via-oauth-openid-connect">using SSO</a>, and automatically add the certificate and private key to <code>ssh-agent</code>.</p><p>That sounds like a lot, but it’s just one command:</p><pre><code>$ step ssh certificate mike@smallstep.com id_ecdsa
✔ Provisioner: Google (OIDC)
Your default web browser has been opened to visit:

https://accounts.google.com/o/oauth2/v2/auth?client_id=650...

✔ CA: https://ca.internal
✔ Private Key: id_ecdsa
✔ Public Key: id_ecdsa.pub
✔ Certificate: id_ecdsa-cert.pub
✔ SSH Agent: yes
</code></pre><p>Once that’s done we can SSH to the instance we just created, using certificate authentication, with no TOFU!</p><pre><code>$ ssh mike@ec2-100-26-100-55.compute-1.amazonaws.com
Welcome to Ubuntu 18.04.2 LTS (GNU/Linux 4.15.0-1044-aws x86_64)

Last login: Thu Sep 12 02:25:43 2019 from 98.210.132.79
mike@ip-172-31-70-94:~$
</code></pre><p>For more info check out our <a href="https://smallstep.com/docs/getting-started/">getting started guide</a> and <a href="https://github.com/smallstep/step-ssh-example">SSH example repo</a>. Make sure you pass the <code>--ssh</code> flag to <code>step ca init</code> when you’re setting up the CA (the getting started guide doesn’t do this).</p><p>There’s a lot more that can be done to make SSH certificate authentication even more awesome. We’re working on that. If you have any ideas, <a href="https://github.com/smallstep/certificates/discussions">let us know</a>!</p><h2 id="use-ssh-certificates">Use SSH certificates</h2><p>SSH certificate authentication does a lot to improve SSH. It eliminates spurious TOFU warnings and host key verification failures. It lets you drop complex key approval &amp; distribution processes and extend SSO to SSH. It makes rekeying possible for hosts and easier than key reuse for users. It makes SSH keys ephemeral, making key management oversights fail-secure.</p><p>You can deploy an SSH CA and reconfigure hosts in a matter of minutes. It’s easy to transition — you can continue supporting public key authentication at the same time.</p><p>SSH certificate authentication is the right way to do SSH.</p><p>At smallstep, we’re looking forward to improving our SSH story. We’re building out infrastructure and streamlined workflows to make SSH better for everyone. And keep an eye on our blog because we have a lot more to say about SSH!</p><div>
<div>
<p><img src="https://smallstep.com/images/smallstep-icon.svg" alt="cta-icon"/>
</p></div></div></section></div></div>
  </body>
</html>
