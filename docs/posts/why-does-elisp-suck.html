<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.emacswiki.org/emacs/WhyDoesElispSuck">Original</a>
    <h1>Why Does Elisp Suck</h1>
    
    <div id="readability-page-1" class="page"><div><div lang="en"><p>(See also <a href="https://www.emacswiki.org/emacs/EmacsLispLimitations">EmacsLispLimitations</a>, <a href="https://www.emacswiki.org/emacs/SchemeAndLisp">SchemeAndLisp</a>)</p><h2>Background</h2><p>I‚Äôm a long-time Emacs user who is new to the under-the-hood side of things. I recently started learning <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> and writing my own Emacs extensions. I like sitting in IRC channels devoted to technical subjects I‚Äôm interested in, so I found #emacs and started hanging out there. It was not long before I discovered the Terrible Secrets of the Emacs community: <i>EmacsLisp Sucks</i> and <i>Emacs Is Dying</i>.</p><p>This caused me a great deal of consternation and confusion, because I love Emacs and had recently become quite fond of <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>, so much so that I was toying with learning LISP as a standalone language. I tried to get more information, but ‚ÄúWhat do you mean, ‚Äò<a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> sucks‚Äô?‚Äù was more often than not met with a reply which seemed either elliptical, tautological, or a non sequiteur, at least to someone with my level of understanding of the issues (none)[1].</p><p>Common replies: </p><ul><li><a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> isn‚Äôt <a href="https://www.emacswiki.org/emacs/Scheme">Scheme</a></li><li><a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> doesn‚Äôt have lexical scoping (it does since 2011)</li><li><a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> isn‚Äôt <a href="https://www.emacswiki.org/emacs/CommonLisp">CommonLisp</a></li><li><a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> isn‚Äôt Haskell</li><li>The Emacs APIs suck</li><li><a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> isn‚Äôt multithreaded / lacks coroutines (programs like Gnus can make everything stall)</li><li>Do you mean <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>-the-language or <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>-the-library?</li></ul><p>Steve Yegge wrote a blog post contrasting <a href="https://www.emacswiki.org/emacs/JavaScript">JavaScript</a> and Elisp: <a href="http://steve-yegge.blogspot.com/2008/11/ejacs-javascript-interpreter-for-emacs.html">http://steve-yegge.blogspot.com/2008/11/ejacs-javascript-interpreter-for-emacs.html</a></p><p>In it, he idenitifies problems with Elisp: </p><ul><li>Problem #1: Momentum</li><li>Problem #2: No encapsulation</li><li>Problem #3: No delegation</li><li>Problem #4: Properties</li><li>Problem #5: No polymorphic toString</li></ul><h2>EmacsLisp Isn&#39;t Scheme</h2><p>This, from my highly unscientific sample, is far and away the most popular reason <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> sucks. Well, that‚Äôs good to know. <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> is also not Perl, or COBOL, or IBM 1130 assembler, or a bicycle, or an orange. Thanks for the help!</p><p>I didn‚Äôt know Scheme ‚Äì and in fact do not now claim to know Scheme, though I have begun working through <i>SICP</i> ‚Äì and to my untrained eye, the main difference between <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> and Scheme was that Scheme required hitting the shift key a lot more (#t, #f, set!, predicate?, etc). Further inquiry eventually yielded the conclusion that this reason is really just a restatement of ‚Äú<a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> doesn‚Äôt have lexical scoping‚Äù[2].</p><p>That conclusion is not justified. There‚Äôs a great deal of difference between Scheme and <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> beyond just the question of lexical scoping. As the OP mentions in passing, but then ignores, there‚Äôs the fact that <tt>nil</tt> isn‚Äôt false in Scheme, but is in <a href="https://www.emacswiki.org/emacs/CommonLisp">CommonLisp</a> and <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>. Scheme has a stylistic convention of marking destructive operations with an exclamation point and predicates (boolean functions) with a question mark; again noted in the OP. I‚Äôm not sure the latter is so significant, but the former indicates a stigmatization of side-effecting in the Scheme community, more closely wedded to function programming concepts, that we certainly don‚Äôt see in <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>. Scheme is a Lisp-1, sharing the same namespace for variable and function definitions, so that the name <tt>list</tt> must be bound (at least locally) <em>either</em> to a function, or a variable, but not both. In a Lisp-2, you can use the same name for both a function and a variable.</p><hr/><h2>EmacsLisp Isn&#39;t CommonLisp/Haskell/Other</h2><p>I don‚Äôt know enough about any of these to offer any informed commentary, except to note that aside from Common Lisp, they all seems to be edge cases that either no one supports seriously, or only one or two people in the universe actually want.</p><dl><dt></dt><dd>Comment: That‚Äôs blowing Haskell‚Äôs uncommonness way out of proportion. It may not be very widespread in industry yet, but you could just have a look at the IRC channel, the mailing lists or hackage to debunk ‚Äúone or two people in the universe‚Äù, even taking hyperbole into account üòä</dd></dl><h2>The Emacs APIs Suck</h2><p>I heard this a lot as well, but I have no idea what exactly is being referred to. Elucidation greatly appreciated.</p><dl><dt></dt><dd>My wild guess would be ‚Äúbecause they‚Äôre not OO‚Äù, which doesn‚Äôt really bother me, but can be seen as a problem given the typical Java-centric way people are taught CS in the US.</dd></dl><p>The APIs related to match data are an example. Instead of returning a data structure of the match results (eg from a call to match-string), the match results are mutated in global memory and accessed in separate function calls. This is both less functional in style and more error prone. For example, if save-match-data is not used appropriately, then library functions can trample on the match data which a higher level function is in the middle of using.</p><h2>Do You Mean EmacsLisp (Language) Or EmacsLisp (Library)?</h2><p>I don‚Äôt know. Which do you, the <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> detractor, mean?</p><p>Most people seem to hate <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>-the-language, but the primary obstacle to replacing <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> is, of course, <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>-the-library. 30+ years and 80+ megabytes of Emacs functionality, all in <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>. Redoing even the core editing functions is a terrifying thought to me[4].</p><h2>Who Is EmacsLisp For? Who Wants EmacsLisp Dead?</h2><p>This is the larger question I referred to in the Scheme section. I can‚Äôt say for sure, but my gut feeling is that most of the people who are unhappy with <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> are the people who are using Emacs as an application development platform rather than as an extensible editor.</p><p>I am, of course, aware of the kitchen-sink nature of Emacs, and revel in it. I know that the design of Emacs evolved in the time when a programmer only had access to a single terminal session to a computer, thus becoming in effect the world‚Äôs first Integrated Development Environment so a user could meet all their needs without dropping in and out of their primary application: the editor.</p><p>But I believe there is a difference between making Emacs read mail or news or have a shell because you <i>needed to</i> in the 1970s and making Emacs browse web sites or act as an httpd because <i>you can</i> in the 2000s. I wonder if perhaps the people who want to fix all of <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>‚Äôs problems want to do so more for their own benefit ‚Äì so it will be a better general-purpose development base and toolkit ‚Äì than to make Emacs better for everyone. I wonder if they have lost sight of the primary application: the editor[5].</p><h2>Conclusion</h2><p>This is meant to be polemic but not dogmatic[6]. I have stated my observations, opinions, and conclusions, but I have done this to show my point of view and <i>lack</i> of full understanding rather than to try and convince others that I am correct. I am not against fixing or replacing <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>, but I have yet to see any logical, thorough, and cogent arguments for it. Therefore: get to arguing!</p><p>--<a href="https://www.emacswiki.org/emacs/ShawnBoyette">ShawnBoyette</a></p><hr/><h2>Other commonly-named problems</h2><ul><li>No namespaces/modules/packages. This leads to dozens of functions that all start with e.g. ‚Äúdired-‚Äù, even inside the library itself.</li><li>No object system (CLOS). This remark isn‚Äôt really true - there‚Äôs eieio - but the basic point is that the whole design isn‚Äôt object oriented (it‚Äôs debateable wether that‚Äôs a worthwhile goal)<ul><li>Related to this, there‚Äôs no way to create a new abstract type that‚Äôs disjoint from other types (e.g. vectorp doesn‚Äôt return t on those, for example).<ul><li>Other than for ‚Äúconceptual purity‚Äù or something, why is this relevant? i.e. why would you pass an object to code that expects an ordinary vector, and expect that code to distinguish this case and treat it correctly?</li></ul></li></ul></li><li>No concurrency. Dynamic scoping really bites here, btw.</li><li>The regular expressions are clumsy, especially when stored as strings (call this ‚Äú<a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> is not perl‚Äù, if you like): <a href="http://obsidianrook.com/devnotes/whinery/elisp-regexps.html">http://obsidianrook.com/devnotes/whinery/elisp-regexps.html</a></li></ul><hr/><h2>Pipeline&#39;s Commentary</h2><p>[1] The last sentence of this paragraph is especially telling. The author has:</p><ul><li>A special love for Emacs</li><li>Never experimented with any lisp besides <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>.</li><li>Only ‚Äútoyed with‚Äù the idea of learning lisp.</li></ul><p>[2] Scheme is a standard lisp dialect, easier to implement than CL, partly because it‚Äôs smaller, partly because the standard was written with optimization in mind. In contrast, CL was written with commonality in mind. Important differences include a focus on tail recursion and CPS optimization. I think Scheme used to not have keyword arguments, but I‚Äôm no longer sure about that one. </p><ul><ul><li>Some Scheme implementations, notably my favorite Gambit-C, have keywords. It‚Äôs not specified in R5RS or IEEE. -<a href="https://www.emacswiki.org/emacs/JoelAdamson">JoelAdamson</a> I think one may sum up the ‚Äú<a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> isn‚Äôt &lt;foo&gt;‚Äù problems pretty simply. <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> appears quite similar to other lisp dialects, but it has enough ‚Äúgotchas‚Äù and differences to frustrate the beginning <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> programmer very badly. There‚Äôs tons of people with some understanding of scheme or lisp, but relatively few who really get into <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>. I expect that many <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> programmers are like me, desperately trying to apply knowledge of another language. Part of this problem is that twenty years ago, lisp programmers were accustomed to widely varying dialects. Today, most Lisp dialects are quite similar. <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> looks like an aberration if one does not consider its history.</li></ul></ul><p>[3] A tremendous number of emacs extensions are both large and complex, even untenably so.</p><p>[4] This is partly because, as you pointed out, dynamic scoping makes large projects ‚Äúinteresting.‚Äù Is it not a sign of <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>‚Äôs flaws that we‚Äôre all desperately afraid of an attempt to rewrite <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> libraries?</p><p>[5] As you pointed out, Emacs is not primarily an editor, it‚Äôs known first and foremost as a ‚Äúkitchen sink.‚Äù There‚Äôs a reason that the first word in its name is ‚ÄúExtensible.‚Äù I feel I should also mention a popular Microsoft anecdote. Microsoft, at some point in its office research, discovered that any given feature is really only used by a insignificant fraction of users ‚Äì but if it‚Äôs taken out, that individually insignificant fraction becomes irate. By the time you trim Word down to its ‚Äúprimary application,‚Äù you‚Äôve lost 99% of its users.</p><div><dl><dt></dt><dd>I just wish to clarify that I was <em>not</em> pointing out that Emacs is not primarily an editor when mentioning the kitchen sink. My point is that Emacs <em>should</em> be regarded as an editor first and foremost. --mdxi </dd></dl></div><p>[6] The dogma comes through anyway.</p><hr/><h2>Utis&#39; Commentary</h2><h2>ad Pipeline&#39;s Commentary [2]</h2><p>Scheme is probably easier to implement than CL, because it is much, much smaller. But I definitely wouldn‚Äôt say that its standard has been written with optimization in mind. Following the book ‚ÄúLisp in Small Pieces‚Äù, the existence of continuations as first class objects alone implies a performance penalty; likewise the fact that the first element of a form has to be evaluated, possibly at runtime; likewise the fact that scheme programs may overwrite built in functions. I guess that modern compiler techniques may be able to deal with that, I don‚Äôt know. But it is definitely not easy.</p><h2>ad the OP&#39;s topic &#34;EmacsLisp Doesn&#39;t Have Lexical Scoping&#34;</h2><p><a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>‚Äôs lack of lexical scoping isn‚Äôt so much a matter of writing and maintaining large and complex programs. The byte compiler <em>does</em> warn you, if you access a dynamically bound variable outside of its let-form. You have to add a variable declaration in order to get rid of that warning.</p><p>There are two other reasons why I, at least, want lexical scoping: 1) it allows faster variable bindings and better optimization techniques. Introducing lexical scoping could vastly improve <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>‚Äôs speed. In fact the slowness of creating a dynamical environment urges people (myself included) to use such ugly constructs as (let (var) (while &lt;condition&gt; (setq var ‚Ä¶))). This won‚Äôt be necessary with lexical scoping.</p><p>2) Lexical scoping is a requirement for closures. Closures would allow for a lot of very useful programming techniques.</p><p>In that context: ad Pipeline‚Äôs comment [4]: I explained above, why I fail to see that <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>‚Äôs dynamical scoping ‚Äúmakes large projects ‚Äòinteresting‚Äô‚Äù. I hardly recall any problem comming up in emacs-devel or gnu.emacs.help that could have been attributed to dynamical scoping. So this point would require some extra arguments. After all, Emacs <i>is</i> a very large project. Moreover, I don‚Äôt understand why that would anybody make afraid of <em>rewriting</em> an <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> library in a different language ‚Äì presumably one that does provide lexical scoping.</p><h2>ad the OP&#39;s topic &#34;Who Is EmacsLisp For? Who Wants EmacsLisp Dead?&#34;</h2><p>I strongly agree with Pipeline here. What does ‚Äúeditor‚Äù mean for the OP? Just writing ASCII text? Just writing text/plain in general? Just writing text/plain and offering special support for programming source code? Does ‚Äújust an editor‚Äù include functionality like Tramp (for remotely accessing files)? If yes, why doesn‚Äôt it include a newsreader?</p><p>For me most of the so-called ‚Äúkitchen-sink‚Äù stuff is simply part of an editor. There is a big benefit in having everything in a unified environment with a common user interfacec. If my editor would not provide functionality to read mail and news, then I‚Äôd drop it and look for a  mail reader that let‚Äôs me edit programming text. In fact what the OP is attacking here is that Emacs is an Emacs, and not just an Emacs-like editor.</p><h2>ad EmacsLisp in general</h2><p>I didn‚Äôt know that ‚ÄúEmacs is dying‚Äù is a Terrible Secret of the Emacs community. If so then they haven‚Äôt told me in all those years. Well, yes, <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> sucks. And at the same time: <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> is a very nice language. A contradiction? Well, <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> is just lacking a few features and I‚Äôd wish by heart that they were introduced to that language: a few problems are mentioned above. But the most important problem is: speed. <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> (or rather its implementation, but that amounts to the same here) is too slow. Closures are lacking, too. Yes, a deeply integrated, efficient object-system would be necessary, too. Oh, and modules or a package system. And, as a personal wish of mine: tail call reduction.</p><p>So, I agree: <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> could and should be improved. But that doesn‚Äôt mean that we need to replace it with something else. --<a href="https://www.emacswiki.org/emacs/OliverScholz">OliverScholz</a></p><hr/><h2>Mathrick&#39;s plug-in</h2><h2>Why Emacs Should Die (a.k.a Death Rebirth Revolution [1])</h2><p>Second of Terrible Secrets is discussed so often I doubt it‚Äôs a secret any longer (maybe it‚Äôs fact it‚Äôs secret that‚Äôs Terrible Secret üòä). So here are my reasons why I want to see current Emacs code thrown out the window and rewritten (and most importantly, redesigned) from scratch. What we want to retain is Emacs-the-project, Emacs-the-team, Emacs-the-community, Emacs-the-spirit, and also, Emacs-the-name üòä. But actual source code should be redone, because:</p><ol><li>Emacs is extensible, yet its core is horrible example of one of most inflexible designs I have ever seen in use. Let just one word suffice: fringes. Options allowing to influence them in <em>any</em> way were introduced only in CVS, and still all you can do is use them for predefined you‚Äôre-debugging-this-line indicator.</li><li>Another example is that you can‚Äôt advice built-in function (you partly can, but only in <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> invocations, core will continue to use unadviced one). In general, your ability to do anything with builtins is most often void or negligible.</li><li>After all these years, you still have to do full edit .c file ‚Äì save ‚Äì recompile ‚Äì try cycle to change core even in slightest detail. You cannot change it, you cannot extend it. No dynamic modules, no FFI, and (AFAICU) if you dump image with particular set of <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> preloaded, you‚Äôre stuck with that <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> in effect forever</li><li>You can‚Äôt use anything besides C for core. This, in advent of .NET-like runtimes, and era of omnipresent bindings, is Not Nice(TM). I‚Äôd really like to be able to use python for that, and maybe one day seamlessly interface Emacs with .NET runtime (if nothing else, just for introspection data you can get for free in .NET / Java, it‚Äôs really kinda necessary when writing in environment that consist almost 100% of library functions and classes)</li><li><a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> (as it is today) really sucks. It has loads of small annoyances, my personal pet peeve is lack of anything near concurrency. And I don‚Äôt even use Gnus (if I did, I suppose I‚Äôd kill for any threads in <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> ;). I don‚Äôt know how that‚Äôs usually done in ‚Äúbig‚Äù Lisps, but I presume CL <em>has</em> to have threads or equivalent primitive.</li></ol><p>What I envision is ultra small and lean core, that does only one thing - allows extensions to interface each other, binary objects and Lisp-written alike. Ideally, there shouldn‚Äôt be any difference between C and Lisp code, each should be overridable and changable by outside. This way, you could plug in different display engines on console and X, making it possible to introduce for example structured graphics manipulation primitives (another long-time wish of mine). That means to see and manipulate pretty UML figures, I don‚Äôt need to leave Emacs, and I can still use all the graphics capabilities offered by X I use, without making life hard for console users. And plugging Emacs into .NET would be matter of one extension that bridges between Emacs binary and runtime. Incidentally, that seems to be design employed by <a href="https://www.emacswiki.org/emacs/MonoDevelop">MonoDevelop</a>/<a href="https://www.emacswiki.org/emacs/SharpDevelop">SharpDevelop</a> IDE running on .NET, where core has astonishing size of 23KB, and everything else (including GUI) is a plugin. Yes, I know it‚Äôs not small undertaking. But I can‚Äôt see how could Emacs survive and grow in its current incarnation (unless we are content with I‚Äôm-too-hardcore-to-move-from-console users only and no new souls coming)</p><p>That‚Äôs my 3 cents, hope I was clear enough and managed not to offend anyone üòä. Oh, and I don‚Äôt say everyone and their dog have to use .NET for everything, I just say that modern programmer‚Äôs editor needs to be able to do that, or will get forgotten in world of runtimes everywhere.</p><p>[1] Yes, I know lame anime references are lame. But I couldn‚Äôt resist üòä</p><pre> --MaciejKatafiasz</pre><h2>Mornfall&#39;s comment</h2><p>I think Mathrick is on crack. [1]</p><p>[1] Really.</p><h2>Spirit&#39;s comment</h2><p>Mathrick, you will want Eclipse. üòä</p><p>Seriously, I tried that a few months ago. Still have the core but not much functionality. I‚Äôm not sure where such elementary things, like buffers, are supposed to be in that design. There‚Äôs one single static plugin, which can hold scripting engines, which in turn use the core library to communicate with each other. Different window systems are no problem at all, since you can just plug them in (need a streamlined interface though).</p><p>But then‚Ä¶there‚Äôs Eclipse and I think it does all of the above minus console modes (and it‚Äôs slow).</p><pre> --Spirit</pre><h2>blandest&#39;s comment</h2><p>I‚Äôv been using Gnus for a short period of time (less than 2 months) and found the lack of threads quite annoying. The only hack that I could come up with was to make an idle timer that will scan for new mail once every 30 seconds or so. There is also a 3 minutes delay between consecutive scans to avoid useless request to the mail server. How hard would it be to add only one background thread that runs these idle tasks ? (We don‚Äôt need Emacs to be a scalable, multi-threaded web server üòä) I guess it‚Äôs the same thing as adding support for any number of threads ‚Ä¶</p><pre> -- Blandest</pre><h2>pro-emacs comment</h2><p>I think it‚Äôs quite funny that people never take into account the empirically observable reality. It‚Äôs like falling and staying in love with comunism besides real history.</p><p>Almost any kind of application I can think of, when there is an emacs mode for it, its always best in class. Going back from Emacs to other editors /IDE‚Äôs is like going back to the stoneage. If Scheme is so great - why is there no proof of it? Why is it possible to realize really complex extensions like org-mode and gnus in <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a>, if it sucks so much? Where are better extensible programs in Java, Phyton, whatever?</p><p>I think it‚Äôs fun to program in Emacs Lisp, a huge project with a long history in this language yielded an unsurpassed piece of software (Emacs) - it can‚Äôt be bad, it must be very suitable for the task at hand.</p><pre> -- pro-emacs</pre><h2>someone in the future comments</h2><p>I am in the future, and here we first have Sublime Text become the absolute most popular editor with a Python interface, and then came Atom by Github in <a href="https://www.emacswiki.org/emacs/CoffeeScript">CoffeeScript</a> / <a href="https://www.emacswiki.org/emacs/JavaScript">JavaScript</a>, and VS Code by Microsoft in <a href="https://www.emacswiki.org/emacs/TypeScript">TypeScript</a>. This is a future where <a href="https://www.emacswiki.org/emacs/JavaScript">JavaScript</a> dominates. Lispy people can still extend Atom by <a href="https://www.emacswiki.org/emacs/ClojureScript">ClojureScript</a>, and some proclaim it be the Emacs of the new generation. The new trend is to do all UI stuff in Web terms, so that Atom‚Äôs CSV extension comes with a full fledged table editor.</p><pre> -- One from the future</pre><h2>EmacsLisp is not a general purpose language</h2><p>Get over it. Emacs lisp is designed to be an extension language for Emacs editor. It is ridiculous to compare <a href="https://www.emacswiki.org/emacs/EmacsLisp">EmacsLisp</a> to Haskel, Scheme and Common Lisp.</p><pre> -- unlocksmith</pre><h2>What about Emacs Lisp 2?</h2><ul><li>There are several common misconceptions voiced here</li></ul><ol><li>‚ÄúBetter‚Äù Lisps have concurrency. Nope, not really. They do in practice (because you can‚Äôt really not have it in 21‚Äôst century), but the standard has nothing to say about it. This is really up to the implementation to provide this feature (for now at least).</li><li>Scheme is a lot simpler than Common Lisp. Even if true, not by much. In the end of the day, you will still find yourself needing the same tools. In one instance those will come from the standard library, in another instance those will come from a library developed by community.</li><li>There are more developers in Scheme or Common Lisp than there are people writing Emacs Lisp. Not according to Github statistics at least. If anything, of all Lisps (unless you count <a href="https://www.emacswiki.org/emacs/JavaScript">JavaScript</a>), Emacs Lisp seems to be the most popular one. Ahem. It‚Äôs not popular due to its features, but because it serves a purpose no other language can (being the scripting language of Emacs).</li></ol><p>I think I read somewhere about the history of Emacs Lisp, and I think that Stallman said so himself that many of the language-related decisions were motivated by the simplicity and the implementation and the time it would take to come up with one as well as the presence of the practical problems the language had to address. In other words, in a sense, Emacs Lisp was (and still is) a prototype language, and as such it did an unthinkably good job. But there are some roadblocks, where the development of the language seems to have come to a stand-still because the change / update will require things to be thrown away.</p><ul><li>In my view, these problems are</li></ul><ol><li>Performance. There‚Äôs really so much you can do with an interpreted language. In order to manage large projects on par with other modern editors the language needs to do better. Emacs Lisp needs an optimizing compiler. I think that LLVM might be a good target to compile to.</li><li>Concurrency model. Not just threads and other low-level tools needed for synchronization or mutual exclusion (I‚Äôd even prefer that those be hidden from sight), but a thought-through system based on either Actors model, or Concurrent C / Ada, or maybe something else, genuinely new?</li><li>Collections. Good programs must have good tools to work with data. This, again, means that there needs to be a system, a good design: perhaps, like iterators in C++, or perhaps such as Java collections, or maybe look into functional data types? Whichever way it will be, it‚Äôll be still better than the current state, where one can‚Äôt even iterate over two hash-tables at once.</li><li>Interface with the outside world. If CFFI seems like a threat, than, perhaps, a different mechanism?</li><li>Security? It‚Äôs not always appropriate to trust the code written by other people blindly. Some concept of sandboxes would be nice for loading semi/untrusted code.</li><li>Modules (information hiding in general).</li><li>Types? On one hand these make programs more difficult to write, on the other hand, these make them compile better.</li></ol><p>‚Äì wvxvw</p><hr/><p><a href="https://www.emacswiki.org/emacs/CategoryCode">CategoryCode</a> <a href="https://www.emacswiki.org/emacs/CategoryHistory">CategoryHistory</a></p></div></div></div>
  </body>
</html>
